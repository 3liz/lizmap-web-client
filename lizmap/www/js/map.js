var Lizmap =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/ol/ol.css":
/*!**********************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/ol/ol.css ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js")(false);
// Module
exports.push([module.i, ".ol-box {\n  box-sizing: border-box;\n  border-radius: 2px;\n  border: 2px solid blue;\n}\n\n.ol-mouse-position {\n  top: 8px;\n  right: 8px;\n  position: absolute;\n}\n\n.ol-scale-line {\n  background: rgba(0,60,136,0.3);\n  border-radius: 4px;\n  bottom: 8px;\n  left: 8px;\n  padding: 2px;\n  position: absolute;\n}\n.ol-scale-line-inner {\n  border: 1px solid #eee;\n  border-top: none;\n  color: #eee;\n  font-size: 10px;\n  text-align: center;\n  margin: 1px;\n  will-change: contents, width;\n}\n.ol-overlay-container {\n  will-change: left,right,top,bottom;\n}\n\n.ol-unsupported {\n  display: none;\n}\n.ol-viewport, .ol-unselectable {\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n.ol-selectable {\n  -webkit-touch-callout: default;\n  -webkit-user-select: text;\n  -moz-user-select: text;\n  -ms-user-select: text;\n  user-select: text;\n}\n.ol-grabbing {\n  cursor: -webkit-grabbing;\n  cursor: -moz-grabbing;\n  cursor: grabbing;\n}\n.ol-grab {\n  cursor: move;\n  cursor: -webkit-grab;\n  cursor: -moz-grab;\n  cursor: grab;\n}\n.ol-control {\n  position: absolute;\n  background-color: rgba(255,255,255,0.4);\n  border-radius: 4px;\n  padding: 2px;\n}\n.ol-control:hover {\n  background-color: rgba(255,255,255,0.6);\n}\n.ol-zoom {\n  top: .5em;\n  left: .5em;\n}\n.ol-rotate {\n  top: .5em;\n  right: .5em;\n  transition: opacity .25s linear, visibility 0s linear;\n}\n.ol-rotate.ol-hidden {\n  opacity: 0;\n  visibility: hidden;\n  transition: opacity .25s linear, visibility 0s linear .25s;\n}\n.ol-zoom-extent {\n  top: 4.643em;\n  left: .5em;\n}\n.ol-full-screen {\n  right: .5em;\n  top: .5em;\n}\n@media print {\n  .ol-control {\n    display: none;\n  }\n}\n\n.ol-control button {\n  display: block;\n  margin: 1px;\n  padding: 0;\n  color: white;\n  font-size: 1.14em;\n  font-weight: bold;\n  text-decoration: none;\n  text-align: center;\n  height: 1.375em;\n  width: 1.375em;\n  line-height: .4em;\n  background-color: rgba(0,60,136,0.5);\n  border: none;\n  border-radius: 2px;\n}\n.ol-control button::-moz-focus-inner {\n  border: none;\n  padding: 0;\n}\n.ol-zoom-extent button {\n  line-height: 1.4em;\n}\n.ol-compass {\n  display: block;\n  font-weight: normal;\n  font-size: 1.2em;\n  will-change: transform;\n}\n.ol-touch .ol-control button {\n  font-size: 1.5em;\n}\n.ol-touch .ol-zoom-extent {\n  top: 5.5em;\n}\n.ol-control button:hover,\n.ol-control button:focus {\n  text-decoration: none;\n  background-color: rgba(0,60,136,0.7);\n}\n.ol-zoom .ol-zoom-in {\n  border-radius: 2px 2px 0 0;\n}\n.ol-zoom .ol-zoom-out {\n  border-radius: 0 0 2px 2px;\n}\n\n\n.ol-attribution {\n  text-align: right;\n  bottom: .5em;\n  right: .5em;\n  max-width: calc(100% - 1.3em);\n}\n\n.ol-attribution ul {\n  margin: 0;\n  padding: 0 .5em;\n  font-size: .7rem;\n  line-height: 1.375em;\n  color: #000;\n  text-shadow: 0 0 2px #fff;\n}\n.ol-attribution li {\n  display: inline;\n  list-style: none;\n  line-height: inherit;\n}\n.ol-attribution li:not(:last-child):after {\n  content: \" \";\n}\n.ol-attribution img {\n  max-height: 2em;\n  max-width: inherit;\n  vertical-align: middle;\n}\n.ol-attribution ul, .ol-attribution button {\n  display: inline-block;\n}\n.ol-attribution.ol-collapsed ul {\n  display: none;\n}\n.ol-attribution:not(.ol-collapsed) {\n  background: rgba(255,255,255,0.8);\n}\n.ol-attribution.ol-uncollapsible {\n  bottom: 0;\n  right: 0;\n  border-radius: 4px 0 0;\n  height: 1.1em;\n  line-height: 1em;\n}\n.ol-attribution.ol-uncollapsible img {\n  margin-top: -.2em;\n  max-height: 1.6em;\n}\n.ol-attribution.ol-uncollapsible button {\n  display: none;\n}\n\n.ol-zoomslider {\n  top: 4.5em;\n  left: .5em;\n  height: 200px;\n}\n.ol-zoomslider button {\n  position: relative;\n  height: 10px;\n}\n\n.ol-touch .ol-zoomslider {\n  top: 5.5em;\n}\n\n.ol-overviewmap {\n  left: 0.5em;\n  bottom: 0.5em;\n}\n.ol-overviewmap.ol-uncollapsible {\n  bottom: 0;\n  left: 0;\n  border-radius: 0 4px 0 0;\n}\n.ol-overviewmap .ol-overviewmap-map,\n.ol-overviewmap button {\n  display: inline-block;\n}\n.ol-overviewmap .ol-overviewmap-map {\n  border: 1px solid #7b98bc;\n  height: 150px;\n  margin: 2px;\n  width: 150px;\n}\n.ol-overviewmap:not(.ol-collapsed) button{\n  bottom: 1px;\n  left: 2px;\n  position: absolute;\n}\n.ol-overviewmap.ol-collapsed .ol-overviewmap-map,\n.ol-overviewmap.ol-uncollapsible button {\n  display: none;\n}\n.ol-overviewmap:not(.ol-collapsed) {\n  background: rgba(255,255,255,0.8);\n}\n.ol-overviewmap-box {\n  border: 2px dotted rgba(0,60,136,0.7);\n}\n\n.ol-overviewmap .ol-overviewmap-box:hover {\n  cursor: move;\n}\n", ""]);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], "{").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    for (var i = 0; i < this.length; i++) {
      // eslint-disable-next-line prefer-destructuring
      var id = this[i][0];

      if (id != null) {
        alreadyImportedModules[id] = true;
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = modules[_i]; // skip already imported module
      // this implementation is not 100% perfect for weird media query combinations
      // when a module is imported multiple times with different media queries.
      // I hope this will never occur (Hey this way we have smaller bundles)

      if (item[0] == null || !alreadyImportedModules[item[0]]) {
        if (mediaQuery && !item[2]) {
          item[2] = mediaQuery;
        } else if (mediaQuery) {
          item[2] = "(".concat(item[2], ") and (").concat(mediaQuery, ")");
        }

        list.push(item);
      }
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot).concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),

/***/ "./node_modules/ol/AssertionError.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/AssertionError.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ "./node_modules/ol/util.js");
/**
 * @module ol/AssertionError
 */


/**
 * Error object thrown when an assertion failed. This is an ECMA-262 Error,
 * extended with a `code` property.
 * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error.
 */
var AssertionError = /*@__PURE__*/(function (Error) {
  function AssertionError(code) {
    var path = _util_js__WEBPACK_IMPORTED_MODULE_0__["VERSION"] === 'latest' ? _util_js__WEBPACK_IMPORTED_MODULE_0__["VERSION"] : 'v' + _util_js__WEBPACK_IMPORTED_MODULE_0__["VERSION"].split('-')[0];
    var message = 'Assertion failed. See https://openlayers.org/en/' + path +
    '/doc/errors/#' + code + ' for details.';

    Error.call(this, message);

    /**
     * Error code. The meaning of the code can be found on
     * https://openlayers.org/en/latest/doc/errors/ (replace `latest` with
     * the version found in the OpenLayers script's header comment if a version
     * other than the latest is used).
     * @type {number}
     * @api
     */
    this.code = code;

    /**
     * @type {string}
     */
    this.name = 'AssertionError';

    // Re-assign message, see https://github.com/Rich-Harris/buble/issues/40
    this.message = message;
  }

  if ( Error ) AssertionError.__proto__ = Error;
  AssertionError.prototype = Object.create( Error && Error.prototype );
  AssertionError.prototype.constructor = AssertionError;

  return AssertionError;
}(Error));

/* harmony default export */ __webpack_exports__["default"] = (AssertionError);

//# sourceMappingURL=AssertionError.js.map

/***/ }),

/***/ "./node_modules/ol/Collection.js":
/*!***************************************!*\
  !*** ./node_modules/ol/Collection.js ***!
  \***************************************/
/*! exports provided: CollectionEvent, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CollectionEvent", function() { return CollectionEvent; });
/* harmony import */ var _AssertionError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AssertionError.js */ "./node_modules/ol/AssertionError.js");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CollectionEventType.js */ "./node_modules/ol/CollectionEventType.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./events/Event.js */ "./node_modules/ol/events/Event.js");
/**
 * @module ol/Collection
 */






/**
 * @enum {string}
 * @private
 */
var Property = {
  LENGTH: 'length'
};


/**
 * @classdesc
 * Events emitted by {@link module:ol/Collection~Collection} instances are instances of this
 * type.
 */
var CollectionEvent = /*@__PURE__*/(function (Event) {
  function CollectionEvent(type, opt_element) {
    Event.call(this, type);

    /**
     * The element that is added to or removed from the collection.
     * @type {*}
     * @api
     */
    this.element = opt_element;

  }

  if ( Event ) CollectionEvent.__proto__ = Event;
  CollectionEvent.prototype = Object.create( Event && Event.prototype );
  CollectionEvent.prototype.constructor = CollectionEvent;

  return CollectionEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_3__["default"]));


/**
 * @typedef {Object} Options
 * @property {boolean} [unique=false] Disallow the same item from being added to
 * the collection twice.
 */

/**
 * @classdesc
 * An expanded version of standard JS Array, adding convenience methods for
 * manipulation. Add and remove changes to the Collection trigger a Collection
 * event. Note that this does not cover changes to the objects _within_ the
 * Collection; they trigger events on the appropriate object, not on the
 * Collection as a whole.
 *
 * @fires CollectionEvent
 *
 * @template T
 * @api
 */
var Collection = /*@__PURE__*/(function (BaseObject) {
  function Collection(opt_array, opt_options) {

    BaseObject.call(this);

    var options = opt_options || {};

    /**
     * @private
     * @type {boolean}
     */
    this.unique_ = !!options.unique;

    /**
     * @private
     * @type {!Array<T>}
     */
    this.array_ = opt_array ? opt_array : [];

    if (this.unique_) {
      for (var i = 0, ii = this.array_.length; i < ii; ++i) {
        this.assertUnique_(this.array_[i], i);
      }
    }

    this.updateLength_();

  }

  if ( BaseObject ) Collection.__proto__ = BaseObject;
  Collection.prototype = Object.create( BaseObject && BaseObject.prototype );
  Collection.prototype.constructor = Collection;

  /**
   * Remove all elements from the collection.
   * @api
   */
  Collection.prototype.clear = function clear () {
    while (this.getLength() > 0) {
      this.pop();
    }
  };

  /**
   * Add elements to the collection.  This pushes each item in the provided array
   * to the end of the collection.
   * @param {!Array<T>} arr Array.
   * @return {Collection<T>} This collection.
   * @api
   */
  Collection.prototype.extend = function extend (arr) {
    for (var i = 0, ii = arr.length; i < ii; ++i) {
      this.push(arr[i]);
    }
    return this;
  };

  /**
   * Iterate over each element, calling the provided callback.
   * @param {function(T, number, Array<T>): *} f The function to call
   *     for every element. This function takes 3 arguments (the element, the
   *     index and the array). The return value is ignored.
   * @api
   */
  Collection.prototype.forEach = function forEach (f) {
    var array = this.array_;
    for (var i = 0, ii = array.length; i < ii; ++i) {
      f(array[i], i, array);
    }
  };

  /**
   * Get a reference to the underlying Array object. Warning: if the array
   * is mutated, no events will be dispatched by the collection, and the
   * collection's "length" property won't be in sync with the actual length
   * of the array.
   * @return {!Array<T>} Array.
   * @api
   */
  Collection.prototype.getArray = function getArray () {
    return this.array_;
  };

  /**
   * Get the element at the provided index.
   * @param {number} index Index.
   * @return {T} Element.
   * @api
   */
  Collection.prototype.item = function item (index) {
    return this.array_[index];
  };

  /**
   * Get the length of this collection.
   * @return {number} The length of the array.
   * @observable
   * @api
   */
  Collection.prototype.getLength = function getLength () {
    return this.get(Property.LENGTH);
  };

  /**
   * Insert an element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  Collection.prototype.insertAt = function insertAt (index, elem) {
    if (this.unique_) {
      this.assertUnique_(elem);
    }
    this.array_.splice(index, 0, elem);
    this.updateLength_();
    this.dispatchEvent(
      new CollectionEvent(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].ADD, elem));
  };

  /**
   * Remove the last element of the collection and return it.
   * Return `undefined` if the collection is empty.
   * @return {T|undefined} Element.
   * @api
   */
  Collection.prototype.pop = function pop () {
    return this.removeAt(this.getLength() - 1);
  };

  /**
   * Insert the provided element at the end of the collection.
   * @param {T} elem Element.
   * @return {number} New length of the collection.
   * @api
   */
  Collection.prototype.push = function push (elem) {
    if (this.unique_) {
      this.assertUnique_(elem);
    }
    var n = this.getLength();
    this.insertAt(n, elem);
    return this.getLength();
  };

  /**
   * Remove the first occurrence of an element from the collection.
   * @param {T} elem Element.
   * @return {T|undefined} The removed element or undefined if none found.
   * @api
   */
  Collection.prototype.remove = function remove (elem) {
    var arr = this.array_;
    for (var i = 0, ii = arr.length; i < ii; ++i) {
      if (arr[i] === elem) {
        return this.removeAt(i);
      }
    }
    return undefined;
  };

  /**
   * Remove the element at the provided index and return it.
   * Return `undefined` if the collection does not contain this index.
   * @param {number} index Index.
   * @return {T|undefined} Value.
   * @api
   */
  Collection.prototype.removeAt = function removeAt (index) {
    var prev = this.array_[index];
    this.array_.splice(index, 1);
    this.updateLength_();
    this.dispatchEvent(new CollectionEvent(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].REMOVE, prev));
    return prev;
  };

  /**
   * Set the element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  Collection.prototype.setAt = function setAt (index, elem) {
    var n = this.getLength();
    if (index < n) {
      if (this.unique_) {
        this.assertUnique_(elem, index);
      }
      var prev = this.array_[index];
      this.array_[index] = elem;
      this.dispatchEvent(
        new CollectionEvent(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].REMOVE, prev));
      this.dispatchEvent(
        new CollectionEvent(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].ADD, elem));
    } else {
      for (var j = n; j < index; ++j) {
        this.insertAt(j, undefined);
      }
      this.insertAt(index, elem);
    }
  };

  /**
   * @private
   */
  Collection.prototype.updateLength_ = function updateLength_ () {
    this.set(Property.LENGTH, this.array_.length);
  };

  /**
   * @private
   * @param {T} elem Element.
   * @param {number=} opt_except Optional index to ignore.
   */
  Collection.prototype.assertUnique_ = function assertUnique_ (elem, opt_except) {
    for (var i = 0, ii = this.array_.length; i < ii; ++i) {
      if (this.array_[i] === elem && i !== opt_except) {
        throw new _AssertionError_js__WEBPACK_IMPORTED_MODULE_0__["default"](58);
      }
    }
  };

  return Collection;
}(_Object_js__WEBPACK_IMPORTED_MODULE_2__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (Collection);

//# sourceMappingURL=Collection.js.map

/***/ }),

/***/ "./node_modules/ol/CollectionEventType.js":
/*!************************************************!*\
  !*** ./node_modules/ol/CollectionEventType.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/CollectionEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  /**
   * Triggered when an item is added to the collection.
   * @event module:ol/Collection.CollectionEvent#add
   * @api
   */
  ADD: 'add',
  /**
   * Triggered when an item is removed from the collection.
   * @event module:ol/Collection.CollectionEvent#remove
   * @api
   */
  REMOVE: 'remove'
});

//# sourceMappingURL=CollectionEventType.js.map

/***/ }),

/***/ "./node_modules/ol/Disposable.js":
/*!***************************************!*\
  !*** ./node_modules/ol/Disposable.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/Disposable
 */

/**
 * @classdesc
 * Objects that need to clean up after themselves.
 */
var Disposable = function Disposable() {
  /**
   * The object has already been disposed.
   * @type {boolean}
   * @private
   */
  this.disposed_ = false;
};

/**
 * Clean up.
 */
Disposable.prototype.dispose = function dispose () {
  if (!this.disposed_) {
    this.disposed_ = true;
    this.disposeInternal();
  }
};

/**
 * Extension point for disposable objects.
 * @protected
 */
Disposable.prototype.disposeInternal = function disposeInternal () {};

/* harmony default export */ __webpack_exports__["default"] = (Disposable);

//# sourceMappingURL=Disposable.js.map

/***/ }),

/***/ "./node_modules/ol/Feature.js":
/*!************************************!*\
  !*** ./node_modules/ol/Feature.js ***!
  \************************************/
/*! exports provided: createStyleFunction, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createStyleFunction", function() { return createStyleFunction; });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Object.js */ "./node_modules/ol/Object.js");
/**
 * @module ol/Feature
 */





/**
 * @typedef {typeof Feature|typeof import("./render/Feature.js").default} FeatureClass
 */

/**
 * @typedef {Feature|import("./render/Feature.js").default} FeatureLike
 */

/**
 * @classdesc
 * A vector object for geographic features with a geometry and other
 * attribute properties, similar to the features in vector file formats like
 * GeoJSON.
 *
 * Features can be styled individually with `setStyle`; otherwise they use the
 * style of their vector layer.
 *
 * Note that attribute properties are set as {@link module:ol/Object} properties on
 * the feature object, so they are observable, and have get/set accessors.
 *
 * Typically, a feature has a single geometry property. You can set the
 * geometry using the `setGeometry` method and get it with `getGeometry`.
 * It is possible to store more than one geometry on a feature using attribute
 * properties. By default, the geometry used for rendering is identified by
 * the property name `geometry`. If you want to use another geometry property
 * for rendering, use the `setGeometryName` method to change the attribute
 * property associated with the geometry for the feature.  For example:
 *
 * ```js
 *
 * import Feature from 'ol/Feature';
 * import Polygon from 'ol/geom/Polygon';
 * import Point from 'ol/geom/Point';
 *
 * var feature = new Feature({
 *   geometry: new Polygon(polyCoords),
 *   labelPoint: new Point(labelCoords),
 *   name: 'My Polygon'
 * });
 *
 * // get the polygon geometry
 * var poly = feature.getGeometry();
 *
 * // Render the feature as a point using the coordinates from labelPoint
 * feature.setGeometryName('labelPoint');
 *
 * // get the point geometry
 * var point = feature.getGeometry();
 * ```
 *
 * @api
 */
var Feature = /*@__PURE__*/(function (BaseObject) {
  function Feature(opt_geometryOrProperties) {

    BaseObject.call(this);

    /**
     * @private
     * @type {number|string|undefined}
     */
    this.id_ = undefined;

    /**
     * @type {string}
     * @private
     */
    this.geometryName_ = 'geometry';

    /**
     * User provided style.
     * @private
     * @type {import("./style/Style.js").StyleLike}
     */
    this.style_ = null;

    /**
     * @private
     * @type {import("./style/Style.js").StyleFunction|undefined}
     */
    this.styleFunction_ = undefined;

    /**
     * @private
     * @type {?import("./events.js").EventsKey}
     */
    this.geometryChangeKey_ = null;

    Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["listen"])(
      this, Object(_Object_js__WEBPACK_IMPORTED_MODULE_3__["getChangeEventType"])(this.geometryName_),
      this.handleGeometryChanged_, this);

    if (opt_geometryOrProperties) {
      if (typeof /** @type {?} */ (opt_geometryOrProperties).getSimplifiedGeometry === 'function') {
        var geometry = /** @type {import("./geom/Geometry.js").default} */ (opt_geometryOrProperties);
        this.setGeometry(geometry);
      } else {
        /** @type {Object<string, *>} */
        var properties = opt_geometryOrProperties;
        this.setProperties(properties);
      }
    }
  }

  if ( BaseObject ) Feature.__proto__ = BaseObject;
  Feature.prototype = Object.create( BaseObject && BaseObject.prototype );
  Feature.prototype.constructor = Feature;

  /**
   * Clone this feature. If the original feature has a geometry it
   * is also cloned. The feature id is not set in the clone.
   * @return {Feature} The clone.
   * @api
   */
  Feature.prototype.clone = function clone () {
    var clone = new Feature(this.getProperties());
    clone.setGeometryName(this.getGeometryName());
    var geometry = this.getGeometry();
    if (geometry) {
      clone.setGeometry(geometry.clone());
    }
    var style = this.getStyle();
    if (style) {
      clone.setStyle(style);
    }
    return clone;
  };

  /**
   * Get the feature's default geometry.  A feature may have any number of named
   * geometries.  The "default" geometry (the one that is rendered by default) is
   * set when calling {@link module:ol/Feature~Feature#setGeometry}.
   * @return {import("./geom/Geometry.js").default|undefined} The default geometry for the feature.
   * @api
   * @observable
   */
  Feature.prototype.getGeometry = function getGeometry () {
    return (
      /** @type {import("./geom/Geometry.js").default|undefined} */ (this.get(this.geometryName_))
    );
  };

  /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is either set when reading data from a remote source or set explicitly by
   * calling {@link module:ol/Feature~Feature#setId}.
   * @return {number|string|undefined} Id.
   * @api
   */
  Feature.prototype.getId = function getId () {
    return this.id_;
  };

  /**
   * Get the name of the feature's default geometry.  By default, the default
   * geometry is named `geometry`.
   * @return {string} Get the property name associated with the default geometry
   *     for this feature.
   * @api
   */
  Feature.prototype.getGeometryName = function getGeometryName () {
    return this.geometryName_;
  };

  /**
   * Get the feature's style. Will return what was provided to the
   * {@link module:ol/Feature~Feature#setStyle} method.
   * @return {import("./style/Style.js").StyleLike} The feature style.
   * @api
   */
  Feature.prototype.getStyle = function getStyle () {
    return this.style_;
  };

  /**
   * Get the feature's style function.
   * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
   * representing the current style of this feature.
   * @api
   */
  Feature.prototype.getStyleFunction = function getStyleFunction () {
    return this.styleFunction_;
  };

  /**
   * @private
   */
  Feature.prototype.handleGeometryChange_ = function handleGeometryChange_ () {
    this.changed();
  };

  /**
   * @private
   */
  Feature.prototype.handleGeometryChanged_ = function handleGeometryChanged_ () {
    if (this.geometryChangeKey_) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["unlistenByKey"])(this.geometryChangeKey_);
      this.geometryChangeKey_ = null;
    }
    var geometry = this.getGeometry();
    if (geometry) {
      this.geometryChangeKey_ = Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["listen"])(geometry,
        _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CHANGE, this.handleGeometryChange_, this);
    }
    this.changed();
  };

  /**
   * Set the default geometry for the feature.  This will update the property
   * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
   * @param {import("./geom/Geometry.js").default|undefined} geometry The new geometry.
   * @api
   * @observable
   */
  Feature.prototype.setGeometry = function setGeometry (geometry) {
    this.set(this.geometryName_, geometry);
  };

  /**
   * Set the style for the feature.  This can be a single style object, an array
   * of styles, or a function that takes a resolution and returns an array of
   * styles. If it is `null` the feature has no style (a `null` style).
   * @param {import("./style/Style.js").StyleLike} style Style for this feature.
   * @api
   * @fires module:ol/events/Event~Event#event:change
   */
  Feature.prototype.setStyle = function setStyle (style) {
    this.style_ = style;
    this.styleFunction_ = !style ? undefined : createStyleFunction(style);
    this.changed();
  };

  /**
   * Set the feature id.  The feature id is considered stable and may be used when
   * requesting features or comparing identifiers returned from a remote source.
   * The feature id can be used with the
   * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
   * @param {number|string|undefined} id The feature id.
   * @api
   * @fires module:ol/events/Event~Event#event:change
   */
  Feature.prototype.setId = function setId (id) {
    this.id_ = id;
    this.changed();
  };

  /**
   * Set the property name to be used when getting the feature's default geometry.
   * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
   * this name will be returned.
   * @param {string} name The property name of the default geometry.
   * @api
   */
  Feature.prototype.setGeometryName = function setGeometryName (name) {
    Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["unlisten"])(
      this, Object(_Object_js__WEBPACK_IMPORTED_MODULE_3__["getChangeEventType"])(this.geometryName_),
      this.handleGeometryChanged_, this);
    this.geometryName_ = name;
    Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["listen"])(
      this, Object(_Object_js__WEBPACK_IMPORTED_MODULE_3__["getChangeEventType"])(this.geometryName_),
      this.handleGeometryChanged_, this);
    this.handleGeometryChanged_();
  };

  return Feature;
}(_Object_js__WEBPACK_IMPORTED_MODULE_3__["default"]));


/**
 * Convert the provided object into a feature style function.  Functions passed
 * through unchanged.  Arrays of Style or single style objects wrapped
 * in a new feature style function.
 * @param {!import("./style/Style.js").StyleFunction|!Array<import("./style/Style.js").default>|!import("./style/Style.js").default} obj
 *     A feature style function, a single style, or an array of styles.
 * @return {import("./style/Style.js").StyleFunction} A style function.
 */
function createStyleFunction(obj) {
  if (typeof obj === 'function') {
    return obj;
  } else {
    /**
     * @type {Array<import("./style/Style.js").default>}
     */
    var styles;
    if (Array.isArray(obj)) {
      styles = obj;
    } else {
      Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(typeof /** @type {?} */ (obj).getZIndex === 'function',
        41); // Expected an `import("./style/Style.js").Style` or an array of `import("./style/Style.js").Style`
      var style = /** @type {import("./style/Style.js").default} */ (obj);
      styles = [style];
    }
    return function() {
      return styles;
    };
  }
}
/* harmony default export */ __webpack_exports__["default"] = (Feature);

//# sourceMappingURL=Feature.js.map

/***/ }),

/***/ "./node_modules/ol/ImageBase.js":
/*!**************************************!*\
  !*** ./node_modules/ol/ImageBase.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events/Target.js */ "./node_modules/ol/events/Target.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/**
 * @module ol/ImageBase
 */




/**
 * @abstract
 */
var ImageBase = /*@__PURE__*/(function (EventTarget) {
  function ImageBase(extent, resolution, pixelRatio, state) {

    EventTarget.call(this);

    /**
     * @protected
     * @type {import("./extent.js").Extent}
     */
    this.extent = extent;

    /**
     * @private
     * @type {number}
     */
    this.pixelRatio_ = pixelRatio;

    /**
     * @protected
     * @type {number|undefined}
     */
    this.resolution = resolution;

    /**
     * @protected
     * @type {import("./ImageState.js").default}
     */
    this.state = state;

  }

  if ( EventTarget ) ImageBase.__proto__ = EventTarget;
  ImageBase.prototype = Object.create( EventTarget && EventTarget.prototype );
  ImageBase.prototype.constructor = ImageBase;

  /**
   * @protected
   */
  ImageBase.prototype.changed = function changed () {
    this.dispatchEvent(_events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CHANGE);
  };

  /**
   * @return {import("./extent.js").Extent} Extent.
   */
  ImageBase.prototype.getExtent = function getExtent () {
    return this.extent;
  };

  /**
   * @abstract
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   */
  ImageBase.prototype.getImage = function getImage () {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * @return {number} PixelRatio.
   */
  ImageBase.prototype.getPixelRatio = function getPixelRatio () {
    return this.pixelRatio_;
  };

  /**
   * @return {number} Resolution.
   */
  ImageBase.prototype.getResolution = function getResolution () {
    return /** @type {number} */ (this.resolution);
  };

  /**
   * @return {import("./ImageState.js").default} State.
   */
  ImageBase.prototype.getState = function getState () {
    return this.state;
  };

  /**
   * Load not yet loaded URI.
   * @abstract
   */
  ImageBase.prototype.load = function load () {
    Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  return ImageBase;
}(_events_Target_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (ImageBase);

//# sourceMappingURL=ImageBase.js.map

/***/ }),

/***/ "./node_modules/ol/ImageCanvas.js":
/*!****************************************!*\
  !*** ./node_modules/ol/ImageCanvas.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ImageBase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ImageBase.js */ "./node_modules/ol/ImageBase.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ImageState.js */ "./node_modules/ol/ImageState.js");
/**
 * @module ol/ImageCanvas
 */




/**
 * A function that is called to trigger asynchronous canvas drawing.  It is
 * called with a "done" callback that should be called when drawing is done.
 * If any error occurs during drawing, the "done" callback should be called with
 * that error.
 *
 * @typedef {function(function(Error=))} Loader
 */


var ImageCanvas = /*@__PURE__*/(function (ImageBase) {
  function ImageCanvas(extent, resolution, pixelRatio, canvas, opt_loader) {

    var state = opt_loader !== undefined ? _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE : _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED;

    ImageBase.call(this, extent, resolution, pixelRatio, state);

    /**
     * Optional canvas loader function.
     * @type {?Loader}
     * @private
     */
    this.loader_ = opt_loader !== undefined ? opt_loader : null;

    /**
     * @private
     * @type {HTMLCanvasElement}
     */
    this.canvas_ = canvas;

    /**
     * @private
     * @type {Error}
     */
    this.error_ = null;

  }

  if ( ImageBase ) ImageCanvas.__proto__ = ImageBase;
  ImageCanvas.prototype = Object.create( ImageBase && ImageBase.prototype );
  ImageCanvas.prototype.constructor = ImageCanvas;

  /**
   * Get any error associated with asynchronous rendering.
   * @return {Error} Any error that occurred during rendering.
   */
  ImageCanvas.prototype.getError = function getError () {
    return this.error_;
  };

  /**
   * Handle async drawing complete.
   * @param {Error=} err Any error during drawing.
   * @private
   */
  ImageCanvas.prototype.handleLoad_ = function handleLoad_ (err) {
    if (err) {
      this.error_ = err;
      this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR;
    } else {
      this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED;
    }
    this.changed();
  };

  /**
   * @inheritDoc
   */
  ImageCanvas.prototype.load = function load () {
    if (this.state == _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE) {
      this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING;
      this.changed();
      this.loader_(this.handleLoad_.bind(this));
    }
  };

  /**
   * @return {HTMLCanvasElement} Canvas element.
   */
  ImageCanvas.prototype.getImage = function getImage () {
    return this.canvas_;
  };

  return ImageCanvas;
}(_ImageBase_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (ImageCanvas);

//# sourceMappingURL=ImageCanvas.js.map

/***/ }),

/***/ "./node_modules/ol/ImageState.js":
/*!***************************************!*\
  !*** ./node_modules/ol/ImageState.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/ImageState
 */

/**
 * @enum {number}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3
});

//# sourceMappingURL=ImageState.js.map

/***/ }),

/***/ "./node_modules/ol/ImageTile.js":
/*!**************************************!*\
  !*** ./node_modules/ol/ImageTile.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Tile.js */ "./node_modules/ol/Tile.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/**
 * @module ol/ImageTile
 */







var ImageTile = /*@__PURE__*/(function (Tile) {
  function ImageTile(tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options) {

    Tile.call(this, tileCoord, state, opt_options);

    /**
     * @private
     * @type {?string}
     */
    this.crossOrigin_ = crossOrigin;

    /**
     * Image URI
     *
     * @private
     * @type {string}
     */
    this.src_ = src;

    /**
     * @private
     * @type {HTMLImageElement|HTMLCanvasElement}
     */
    this.image_ = new Image();
    if (crossOrigin !== null) {
      this.image_.crossOrigin = crossOrigin;
    }

    /**
     * @private
     * @type {Array<import("./events.js").EventsKey>}
     */
    this.imageListenerKeys_ = null;

    /**
     * @private
     * @type {import("./Tile.js").LoadFunction}
     */
    this.tileLoadFunction_ = tileLoadFunction;

  }

  if ( Tile ) ImageTile.__proto__ = Tile;
  ImageTile.prototype = Object.create( Tile && Tile.prototype );
  ImageTile.prototype.constructor = ImageTile;

  /**
   * @inheritDoc
   */
  ImageTile.prototype.disposeInternal = function disposeInternal () {
    if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING) {
      this.unlistenImage_();
      this.image_ = getBlankImage();
    }
    if (this.interimTile) {
      this.interimTile.dispose();
    }
    this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ABORT;
    this.changed();
    Tile.prototype.disposeInternal.call(this);
  };

  /**
   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @api
   */
  ImageTile.prototype.getImage = function getImage () {
    return this.image_;
  };

  /**
   * @inheritDoc
   */
  ImageTile.prototype.getKey = function getKey () {
    return this.src_;
  };

  /**
   * Tracks loading or read errors.
   *
   * @private
   */
  ImageTile.prototype.handleImageError_ = function handleImageError_ () {
    this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR;
    this.unlistenImage_();
    this.image_ = getBlankImage();
    this.changed();
  };

  /**
   * Tracks successful image load.
   *
   * @private
   */
  ImageTile.prototype.handleImageLoad_ = function handleImageLoad_ () {
    var image = /** @type {HTMLImageElement} */ (this.image_);
    if (image.naturalWidth && image.naturalHeight) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED;
    } else {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].EMPTY;
    }
    this.unlistenImage_();
    this.changed();
  };

  /**
   * @inheritDoc
   * @api
   */
  ImageTile.prototype.load = function load () {
    if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE;
      this.image_ = new Image();
      if (this.crossOrigin_ !== null) {
        this.image_.crossOrigin = this.crossOrigin_;
      }
    }
    if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING;
      this.changed();
      this.imageListenerKeys_ = [
        Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listenOnce"])(this.image_, _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].ERROR,
          this.handleImageError_, this),
        Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listenOnce"])(this.image_, _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].LOAD,
          this.handleImageLoad_, this)
      ];
      this.tileLoadFunction_(this, this.src_);
    }
  };

  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */
  ImageTile.prototype.unlistenImage_ = function unlistenImage_ () {
    this.imageListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_3__["unlistenByKey"]);
    this.imageListenerKeys_ = null;
  };

  return ImageTile;
}(_Tile_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/**
 * Get a 1-pixel blank image.
 * @return {HTMLCanvasElement} Blank image.
 */
function getBlankImage() {
  var ctx = Object(_dom_js__WEBPACK_IMPORTED_MODULE_2__["createCanvasContext2D"])(1, 1);
  ctx.fillStyle = 'rgba(0,0,0,0)';
  ctx.fillRect(0, 0, 1, 1);
  return ctx.canvas;
}

/* harmony default export */ __webpack_exports__["default"] = (ImageTile);

//# sourceMappingURL=ImageTile.js.map

/***/ }),

/***/ "./node_modules/ol/Kinetic.js":
/*!************************************!*\
  !*** ./node_modules/ol/Kinetic.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/Kinetic
 */

/**
 * @classdesc
 * Implementation of inertial deceleration for map movement.
 *
 * @api
 */
var Kinetic = function Kinetic(decay, minVelocity, delay) {

  /**
   * @private
   * @type {number}
   */
  this.decay_ = decay;

  /**
   * @private
   * @type {number}
   */
  this.minVelocity_ = minVelocity;

  /**
   * @private
   * @type {number}
   */
  this.delay_ = delay;

  /**
   * @private
   * @type {Array<number>}
   */
  this.points_ = [];

  /**
   * @private
   * @type {number}
   */
  this.angle_ = 0;

  /**
   * @private
   * @type {number}
   */
  this.initialVelocity_ = 0;
};

/**
 * FIXME empty description for jsdoc
 */
Kinetic.prototype.begin = function begin () {
  this.points_.length = 0;
  this.angle_ = 0;
  this.initialVelocity_ = 0;
};

/**
 * @param {number} x X.
 * @param {number} y Y.
 */
Kinetic.prototype.update = function update (x, y) {
  this.points_.push(x, y, Date.now());
};

/**
 * @return {boolean} Whether we should do kinetic animation.
 */
Kinetic.prototype.end = function end () {
  if (this.points_.length < 6) {
    // at least 2 points are required (i.e. there must be at least 6 elements
    // in the array)
    return false;
  }
  var delay = Date.now() - this.delay_;
  var lastIndex = this.points_.length - 3;
  if (this.points_[lastIndex + 2] < delay) {
    // the last tracked point is too old, which means that the user stopped
    // panning before releasing the map
    return false;
  }

  // get the first point which still falls into the delay time
  var firstIndex = lastIndex - 3;
  while (firstIndex > 0 && this.points_[firstIndex + 2] > delay) {
    firstIndex -= 3;
  }

  var duration = this.points_[lastIndex + 2] - this.points_[firstIndex + 2];
  // we don't want a duration of 0 (divide by zero)
  // we also make sure the user panned for a duration of at least one frame
  // (1/60s) to compute sane displacement values
  if (duration < 1000 / 60) {
    return false;
  }

  var dx = this.points_[lastIndex] - this.points_[firstIndex];
  var dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];
  this.angle_ = Math.atan2(dy, dx);
  this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration;
  return this.initialVelocity_ > this.minVelocity_;
};

/**
 * @return {number} Total distance travelled (pixels).
 */
Kinetic.prototype.getDistance = function getDistance () {
  return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
};

/**
 * @return {number} Angle of the kinetic panning animation (radians).
 */
Kinetic.prototype.getAngle = function getAngle () {
  return this.angle_;
};

/* harmony default export */ __webpack_exports__["default"] = (Kinetic);

//# sourceMappingURL=Kinetic.js.map

/***/ }),

/***/ "./node_modules/ol/LayerType.js":
/*!**************************************!*\
  !*** ./node_modules/ol/LayerType.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/LayerType
 */

/**
 * A layer type used when creating layer renderers.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  IMAGE: 'IMAGE',
  TILE: 'TILE',
  VECTOR_TILE: 'VECTOR_TILE',
  VECTOR: 'VECTOR'
});

//# sourceMappingURL=LayerType.js.map

/***/ }),

/***/ "./node_modules/ol/Map.js":
/*!********************************!*\
  !*** ./node_modules/ol/Map.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _PluggableMap_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PluggableMap.js */ "./node_modules/ol/PluggableMap.js");
/* harmony import */ var _control_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./control/util.js */ "./node_modules/ol/control/util.js");
/* harmony import */ var _interaction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interaction.js */ "./node_modules/ol/interaction.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _renderer_canvas_ImageLayer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./renderer/canvas/ImageLayer.js */ "./node_modules/ol/renderer/canvas/ImageLayer.js");
/* harmony import */ var _renderer_canvas_Map_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./renderer/canvas/Map.js */ "./node_modules/ol/renderer/canvas/Map.js");
/* harmony import */ var _renderer_canvas_TileLayer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./renderer/canvas/TileLayer.js */ "./node_modules/ol/renderer/canvas/TileLayer.js");
/* harmony import */ var _renderer_canvas_VectorLayer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./renderer/canvas/VectorLayer.js */ "./node_modules/ol/renderer/canvas/VectorLayer.js");
/* harmony import */ var _renderer_canvas_VectorTileLayer_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./renderer/canvas/VectorTileLayer.js */ "./node_modules/ol/renderer/canvas/VectorTileLayer.js");
/**
 * @module ol/Map
 */










/**
 * @classdesc
 * The map is the core component of OpenLayers. For a map to render, a view,
 * one or more layers, and a target container are needed:
 *
 *     import Map from 'ol/Map';
 *     import View from 'ol/View';
 *     import TileLayer from 'ol/layer/Tile';
 *     import OSM from 'ol/source/OSM';
 *
 *     var map = new Map({
 *       view: new View({
 *         center: [0, 0],
 *         zoom: 1
 *       }),
 *       layers: [
 *         new TileLayer({
 *           source: new OSM()
 *         })
 *       ],
 *       target: 'map'
 *     });
 *
 * The above snippet creates a map using a {@link module:ol/layer/Tile} to
 * display {@link module:ol/source/OSM~OSM} OSM data and render it to a DOM
 * element with the id `map`.
 *
 * The constructor places a viewport container (with CSS class name
 * `ol-viewport`) in the target element (see `getViewport()`), and then two
 * further elements within the viewport: one with CSS class name
 * `ol-overlaycontainer-stopevent` for controls and some overlays, and one with
 * CSS class name `ol-overlaycontainer` for other overlays (see the `stopEvent`
 * option of {@link module:ol/Overlay~Overlay} for the difference). The map
 * itself is placed in a further element within the viewport.
 *
 * Layers are stored as a {@link module:ol/Collection~Collection} in
 * layerGroups. A top-level group is provided by the library. This is what is
 * accessed by `getLayerGroup` and `setLayerGroup`. Layers entered in the
 * options are added to this group, and `addLayer` and `removeLayer` change the
 * layer collection in the group. `getLayers` is a convenience function for
 * `getLayerGroup().getLayers()`. Note that {@link module:ol/layer/Group~Group}
 * is a subclass of {@link module:ol/layer/Base}, so layers entered in the
 * options or added with `addLayer` can be groups, which can contain further
 * groups, and so on.
 *
 * @fires import("./MapBrowserEvent.js").MapBrowserEvent
 * @fires import("./MapEvent.js").MapEvent
 * @fires module:ol/render/Event~RenderEvent#postcompose
 * @fires module:ol/render/Event~RenderEvent#precompose
 * @api
 */
var Map = /*@__PURE__*/(function (PluggableMap) {
  function Map(options) {
    options = Object(_obj_js__WEBPACK_IMPORTED_MODULE_3__["assign"])({}, options);
    if (!options.controls) {
      options.controls = Object(_control_util_js__WEBPACK_IMPORTED_MODULE_1__["defaults"])();
    }
    if (!options.interactions) {
      options.interactions = Object(_interaction_js__WEBPACK_IMPORTED_MODULE_2__["defaults"])();
    }

    PluggableMap.call(this, options);
  }

  if ( PluggableMap ) Map.__proto__ = PluggableMap;
  Map.prototype = Object.create( PluggableMap && PluggableMap.prototype );
  Map.prototype.constructor = Map;

  Map.prototype.createRenderer = function createRenderer () {
    var renderer = new _renderer_canvas_Map_js__WEBPACK_IMPORTED_MODULE_5__["default"](this);
    renderer.registerLayerRenderers([
      _renderer_canvas_ImageLayer_js__WEBPACK_IMPORTED_MODULE_4__["default"],
      _renderer_canvas_TileLayer_js__WEBPACK_IMPORTED_MODULE_6__["default"],
      _renderer_canvas_VectorLayer_js__WEBPACK_IMPORTED_MODULE_7__["default"],
      _renderer_canvas_VectorTileLayer_js__WEBPACK_IMPORTED_MODULE_8__["default"]
    ]);
    return renderer;
  };

  return Map;
}(_PluggableMap_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (Map);

//# sourceMappingURL=Map.js.map

/***/ }),

/***/ "./node_modules/ol/MapBrowserEvent.js":
/*!********************************************!*\
  !*** ./node_modules/ol/MapBrowserEvent.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _MapEvent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MapEvent.js */ "./node_modules/ol/MapEvent.js");
/**
 * @module ol/MapBrowserEvent
 */


/**
 * @classdesc
 * Events emitted as map browser events are instances of this type.
 * See {@link module:ol/PluggableMap~PluggableMap} for which events trigger a map browser event.
 */
var MapBrowserEvent = /*@__PURE__*/(function (MapEvent) {
  function MapBrowserEvent(type, map, browserEvent, opt_dragging, opt_frameState) {

    MapEvent.call(this, type, map, opt_frameState);

    /**
     * The original browser event.
     * @const
     * @type {Event}
     * @api
     */
    this.originalEvent = browserEvent;

    /**
     * The map pixel relative to the viewport corresponding to the original browser event.
     * @type {import("./pixel.js").Pixel}
     * @api
     */
    this.pixel = map.getEventPixel(browserEvent);

    /**
     * The coordinate in view projection corresponding to the original browser event.
     * @type {import("./coordinate.js").Coordinate}
     * @api
     */
    this.coordinate = map.getCoordinateFromPixel(this.pixel);

    /**
     * Indicates if the map is currently being dragged. Only set for
     * `POINTERDRAG` and `POINTERMOVE` events. Default is `false`.
     *
     * @type {boolean}
     * @api
     */
    this.dragging = opt_dragging !== undefined ? opt_dragging : false;

  }

  if ( MapEvent ) MapBrowserEvent.__proto__ = MapEvent;
  MapBrowserEvent.prototype = Object.create( MapEvent && MapEvent.prototype );
  MapBrowserEvent.prototype.constructor = MapBrowserEvent;

  /**
   * Prevents the default browser action.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
   * @override
   * @api
   */
  MapBrowserEvent.prototype.preventDefault = function preventDefault () {
    MapEvent.prototype.preventDefault.call(this);
    this.originalEvent.preventDefault();
  };

  /**
   * Prevents further propagation of the current event.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
   * @override
   * @api
   */
  MapBrowserEvent.prototype.stopPropagation = function stopPropagation () {
    MapEvent.prototype.stopPropagation.call(this);
    this.originalEvent.stopPropagation();
  };

  return MapBrowserEvent;
}(_MapEvent_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (MapBrowserEvent);

//# sourceMappingURL=MapBrowserEvent.js.map

/***/ }),

/***/ "./node_modules/ol/MapBrowserEventHandler.js":
/*!***************************************************!*\
  !*** ./node_modules/ol/MapBrowserEventHandler.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MapBrowserEventType.js */ "./node_modules/ol/MapBrowserEventType.js");
/* harmony import */ var _MapBrowserPointerEvent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MapBrowserPointerEvent.js */ "./node_modules/ol/MapBrowserPointerEvent.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./events/Target.js */ "./node_modules/ol/events/Target.js");
/* harmony import */ var _pointer_EventType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./pointer/EventType.js */ "./node_modules/ol/pointer/EventType.js");
/* harmony import */ var _pointer_PointerEventHandler_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./pointer/PointerEventHandler.js */ "./node_modules/ol/pointer/PointerEventHandler.js");
/**
 * @module ol/MapBrowserEventHandler
 */








var MapBrowserEventHandler = /*@__PURE__*/(function (EventTarget) {
  function MapBrowserEventHandler(map, moveTolerance) {

    EventTarget.call(this);

    /**
     * This is the element that we will listen to the real events on.
     * @type {import("./PluggableMap.js").default}
     * @private
     */
    this.map_ = map;

    /**
     * @type {any}
     * @private
     */
    this.clickTimeoutId_;

    /**
     * @type {boolean}
     * @private
     */
    this.dragging_ = false;

    /**
     * @type {!Array<import("./events.js").EventsKey>}
     * @private
     */
    this.dragListenerKeys_ = [];

    /**
     * @type {number}
     * @private
     */
    this.moveTolerance_ = moveTolerance ?
      moveTolerance * _has_js__WEBPACK_IMPORTED_MODULE_0__["DEVICE_PIXEL_RATIO"] : _has_js__WEBPACK_IMPORTED_MODULE_0__["DEVICE_PIXEL_RATIO"];

    /**
     * The most recent "down" type event (or null if none have occurred).
     * Set on pointerdown.
     * @type {import("./pointer/PointerEvent.js").default}
     * @private
     */
    this.down_ = null;

    var element = this.map_.getViewport();

    /**
     * @type {number}
     * @private
     */
    this.activePointers_ = 0;

    /**
     * @type {!Object<number, boolean>}
     * @private
     */
    this.trackedTouches_ = {};

    /**
     * Event handler which generates pointer events for
     * the viewport element.
     *
     * @type {PointerEventHandler}
     * @private
     */
    this.pointerEventHandler_ = new _pointer_PointerEventHandler_js__WEBPACK_IMPORTED_MODULE_6__["default"](element);

    /**
     * Event handler which generates pointer events for
     * the document (used when dragging).
     *
     * @type {PointerEventHandler}
     * @private
     */
    this.documentPointerEventHandler_ = null;

    /**
     * @type {?import("./events.js").EventsKey}
     * @private
     */
    this.pointerdownListenerKey_ = Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(this.pointerEventHandler_,
      _pointer_EventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POINTERDOWN,
      this.handlePointerDown_, this);

    /**
     * @type {?import("./events.js").EventsKey}
     * @private
     */
    this.relayedListenerKey_ = Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(this.pointerEventHandler_,
      _pointer_EventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POINTERMOVE,
      this.relayEvent_, this);

  }

  if ( EventTarget ) MapBrowserEventHandler.__proto__ = EventTarget;
  MapBrowserEventHandler.prototype = Object.create( EventTarget && EventTarget.prototype );
  MapBrowserEventHandler.prototype.constructor = MapBrowserEventHandler;

  /**
   * @param {import("./pointer/PointerEvent.js").default} pointerEvent Pointer
   * event.
   * @private
   */
  MapBrowserEventHandler.prototype.emulateClick_ = function emulateClick_ (pointerEvent) {
    var newEvent = new _MapBrowserPointerEvent_js__WEBPACK_IMPORTED_MODULE_2__["default"](
      _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CLICK, this.map_, pointerEvent);
    this.dispatchEvent(newEvent);
    if (this.clickTimeoutId_ !== undefined) {
      // double-click
      clearTimeout(this.clickTimeoutId_);
      this.clickTimeoutId_ = undefined;
      newEvent = new _MapBrowserPointerEvent_js__WEBPACK_IMPORTED_MODULE_2__["default"](
        _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].DBLCLICK, this.map_, pointerEvent);
      this.dispatchEvent(newEvent);
    } else {
      // click
      this.clickTimeoutId_ = setTimeout(function() {
        this.clickTimeoutId_ = undefined;
        var newEvent = new _MapBrowserPointerEvent_js__WEBPACK_IMPORTED_MODULE_2__["default"](
          _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].SINGLECLICK, this.map_, pointerEvent);
        this.dispatchEvent(newEvent);
      }.bind(this), 250);
    }
  };

  /**
   * Keeps track on how many pointers are currently active.
   *
   * @param {import("./pointer/PointerEvent.js").default} pointerEvent Pointer
   * event.
   * @private
   */
  MapBrowserEventHandler.prototype.updateActivePointers_ = function updateActivePointers_ (pointerEvent) {
    var event = pointerEvent;

    if (event.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERUP ||
        event.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERCANCEL) {
      delete this.trackedTouches_[event.pointerId];
    } else if (event.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERDOWN) {
      this.trackedTouches_[event.pointerId] = true;
    }
    this.activePointers_ = Object.keys(this.trackedTouches_).length;
  };

  /**
   * @param {import("./pointer/PointerEvent.js").default} pointerEvent Pointer
   * event.
   * @private
   */
  MapBrowserEventHandler.prototype.handlePointerUp_ = function handlePointerUp_ (pointerEvent) {
    this.updateActivePointers_(pointerEvent);
    var newEvent = new _MapBrowserPointerEvent_js__WEBPACK_IMPORTED_MODULE_2__["default"](
      _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERUP, this.map_, pointerEvent);
    this.dispatchEvent(newEvent);

    // We emulate click events on left mouse button click, touch contact, and pen
    // contact. isMouseActionButton returns true in these cases (evt.button is set
    // to 0).
    // See http://www.w3.org/TR/pointerevents/#button-states
    // We only fire click, singleclick, and doubleclick if nobody has called
    // event.stopPropagation() or event.preventDefault().
    if (!newEvent.propagationStopped && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {
      this.emulateClick_(this.down_);
    }

    if (this.activePointers_ === 0) {
      this.dragListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_3__["unlistenByKey"]);
      this.dragListenerKeys_.length = 0;
      this.dragging_ = false;
      this.down_ = null;
      this.documentPointerEventHandler_.dispose();
      this.documentPointerEventHandler_ = null;
    }
  };

  /**
   * @param {import("./pointer/PointerEvent.js").default} pointerEvent Pointer
   * event.
   * @return {boolean} If the left mouse button was pressed.
   * @private
   */
  MapBrowserEventHandler.prototype.isMouseActionButton_ = function isMouseActionButton_ (pointerEvent) {
    return pointerEvent.button === 0;
  };

  /**
   * @param {import("./pointer/PointerEvent.js").default} pointerEvent Pointer
   * event.
   * @private
   */
  MapBrowserEventHandler.prototype.handlePointerDown_ = function handlePointerDown_ (pointerEvent) {
    this.updateActivePointers_(pointerEvent);
    var newEvent = new _MapBrowserPointerEvent_js__WEBPACK_IMPORTED_MODULE_2__["default"](
      _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERDOWN, this.map_, pointerEvent);
    this.dispatchEvent(newEvent);

    this.down_ = pointerEvent;

    if (this.dragListenerKeys_.length === 0) {
      /* Set up a pointer event handler on the `document`,
       * which is required when the pointer is moved outside
       * the viewport when dragging.
       */
      this.documentPointerEventHandler_ =
          new _pointer_PointerEventHandler_js__WEBPACK_IMPORTED_MODULE_6__["default"](document);

      this.dragListenerKeys_.push(
        Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(this.documentPointerEventHandler_,
          _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERMOVE,
          this.handlePointerMove_, this),
        Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(this.documentPointerEventHandler_,
          _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERUP,
          this.handlePointerUp_, this),
        /* Note that the listener for `pointercancel is set up on
         * `pointerEventHandler_` and not `documentPointerEventHandler_` like
         * the `pointerup` and `pointermove` listeners.
         *
         * The reason for this is the following: `TouchSource.vacuumTouches_()`
         * issues `pointercancel` events, when there was no `touchend` for a
         * `touchstart`. Now, let's say a first `touchstart` is registered on
         * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
         * But `documentPointerEventHandler_` doesn't know about the first
         * `touchstart`. If there is no `touchend` for the `touchstart`, we can
         * only receive a `touchcancel` from `pointerEventHandler_`, because it is
         * only registered there.
         */
        Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(this.pointerEventHandler_,
          _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERCANCEL,
          this.handlePointerUp_, this)
      );
    }
  };

  /**
   * @param {import("./pointer/PointerEvent.js").default} pointerEvent Pointer
   * event.
   * @private
   */
  MapBrowserEventHandler.prototype.handlePointerMove_ = function handlePointerMove_ (pointerEvent) {
    // Between pointerdown and pointerup, pointermove events are triggered.
    // To avoid a 'false' touchmove event to be dispatched, we test if the pointer
    // moved a significant distance.
    if (this.isMoving_(pointerEvent)) {
      this.dragging_ = true;
      var newEvent = new _MapBrowserPointerEvent_js__WEBPACK_IMPORTED_MODULE_2__["default"](
        _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERDRAG, this.map_, pointerEvent,
        this.dragging_);
      this.dispatchEvent(newEvent);
    }

    // Some native android browser triggers mousemove events during small period
    // of time. See: https://code.google.com/p/android/issues/detail?id=5491 or
    // https://code.google.com/p/android/issues/detail?id=19827
    // ex: Galaxy Tab P3110 + Android 4.1.1
    pointerEvent.preventDefault();
  };

  /**
   * Wrap and relay a pointer event.  Note that this requires that the type
   * string for the MapBrowserPointerEvent matches the PointerEvent type.
   * @param {import("./pointer/PointerEvent.js").default} pointerEvent Pointer
   * event.
   * @private
   */
  MapBrowserEventHandler.prototype.relayEvent_ = function relayEvent_ (pointerEvent) {
    var dragging = !!(this.down_ && this.isMoving_(pointerEvent));
    this.dispatchEvent(new _MapBrowserPointerEvent_js__WEBPACK_IMPORTED_MODULE_2__["default"](
      pointerEvent.type, this.map_, pointerEvent, dragging));
  };

  /**
   * @param {import("./pointer/PointerEvent.js").default} pointerEvent Pointer
   * event.
   * @return {boolean} Is moving.
   * @private
   */
  MapBrowserEventHandler.prototype.isMoving_ = function isMoving_ (pointerEvent) {
    return this.dragging_ ||
        Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ ||
        Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;
  };

  /**
   * @inheritDoc
   */
  MapBrowserEventHandler.prototype.disposeInternal = function disposeInternal () {
    if (this.relayedListenerKey_) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["unlistenByKey"])(this.relayedListenerKey_);
      this.relayedListenerKey_ = null;
    }
    if (this.pointerdownListenerKey_) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["unlistenByKey"])(this.pointerdownListenerKey_);
      this.pointerdownListenerKey_ = null;
    }

    this.dragListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_3__["unlistenByKey"]);
    this.dragListenerKeys_.length = 0;

    if (this.documentPointerEventHandler_) {
      this.documentPointerEventHandler_.dispose();
      this.documentPointerEventHandler_ = null;
    }
    if (this.pointerEventHandler_) {
      this.pointerEventHandler_.dispose();
      this.pointerEventHandler_ = null;
    }
    EventTarget.prototype.disposeInternal.call(this);
  };

  return MapBrowserEventHandler;
}(_events_Target_js__WEBPACK_IMPORTED_MODULE_4__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (MapBrowserEventHandler);

//# sourceMappingURL=MapBrowserEventHandler.js.map

/***/ }),

/***/ "./node_modules/ol/MapBrowserEventType.js":
/*!************************************************!*\
  !*** ./node_modules/ol/MapBrowserEventType.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/**
 * @module ol/MapBrowserEventType
 */


/**
 * Constants for event names.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({

  /**
   * A true single click with no dragging and no double click. Note that this
   * event is delayed by 250 ms to ensure that it is not a double click.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
   * @api
   */
  SINGLECLICK: 'singleclick',

  /**
   * A click with no dragging. A double click will fire two of this.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
   * @api
   */
  CLICK: _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].CLICK,

  /**
   * A true double click, with no dragging.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
   * @api
   */
  DBLCLICK: _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].DBLCLICK,

  /**
   * Triggered when a pointer is dragged.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
   * @api
   */
  POINTERDRAG: 'pointerdrag',

  /**
   * Triggered when a pointer is moved. Note that on touch devices this is
   * triggered when the map is panned, so is not the same as mousemove.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
   * @api
   */
  POINTERMOVE: 'pointermove',

  POINTERDOWN: 'pointerdown',
  POINTERUP: 'pointerup',
  POINTEROVER: 'pointerover',
  POINTEROUT: 'pointerout',
  POINTERENTER: 'pointerenter',
  POINTERLEAVE: 'pointerleave',
  POINTERCANCEL: 'pointercancel'
});

//# sourceMappingURL=MapBrowserEventType.js.map

/***/ }),

/***/ "./node_modules/ol/MapBrowserPointerEvent.js":
/*!***************************************************!*\
  !*** ./node_modules/ol/MapBrowserPointerEvent.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MapBrowserEvent.js */ "./node_modules/ol/MapBrowserEvent.js");
/**
 * @module ol/MapBrowserPointerEvent
 */


var MapBrowserPointerEvent = /*@__PURE__*/(function (MapBrowserEvent) {
  function MapBrowserPointerEvent(type, map, pointerEvent, opt_dragging, opt_frameState) {

    MapBrowserEvent.call(this, type, map, pointerEvent.originalEvent, opt_dragging, opt_frameState);

    /**
     * @const
     * @type {import("./pointer/PointerEvent.js").default}
     */
    this.pointerEvent = pointerEvent;

  }

  if ( MapBrowserEvent ) MapBrowserPointerEvent.__proto__ = MapBrowserEvent;
  MapBrowserPointerEvent.prototype = Object.create( MapBrowserEvent && MapBrowserEvent.prototype );
  MapBrowserPointerEvent.prototype.constructor = MapBrowserPointerEvent;

  return MapBrowserPointerEvent;
}(_MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_0__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (MapBrowserPointerEvent);

//# sourceMappingURL=MapBrowserPointerEvent.js.map

/***/ }),

/***/ "./node_modules/ol/MapEvent.js":
/*!*************************************!*\
  !*** ./node_modules/ol/MapEvent.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events/Event.js */ "./node_modules/ol/events/Event.js");
/**
 * @module ol/MapEvent
 */


/**
 * @classdesc
 * Events emitted as map events are instances of this type.
 * See {@link module:ol/PluggableMap~PluggableMap} for which events trigger a map event.
 */
var MapEvent = /*@__PURE__*/(function (Event) {
  function MapEvent(type, map, opt_frameState) {

    Event.call(this, type);

    /**
     * The map where the event occurred.
     * @type {import("./PluggableMap.js").default}
     * @api
     */
    this.map = map;

    /**
     * The frame state at the time of the event.
     * @type {?import("./PluggableMap.js").FrameState}
     * @api
     */
    this.frameState = opt_frameState !== undefined ? opt_frameState : null;

  }

  if ( Event ) MapEvent.__proto__ = Event;
  MapEvent.prototype = Object.create( Event && Event.prototype );
  MapEvent.prototype.constructor = MapEvent;

  return MapEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_0__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (MapEvent);

//# sourceMappingURL=MapEvent.js.map

/***/ }),

/***/ "./node_modules/ol/MapEventType.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/MapEventType.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/MapEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({

  /**
   * Triggered after a map frame is rendered.
   * @event module:ol/MapEvent~MapEvent#postrender
   * @api
   */
  POSTRENDER: 'postrender',

  /**
   * Triggered when the map starts moving.
   * @event module:ol/MapEvent~MapEvent#movestart
   * @api
   */
  MOVESTART: 'movestart',

  /**
   * Triggered after the map is moved.
   * @event module:ol/MapEvent~MapEvent#moveend
   * @api
   */
  MOVEEND: 'moveend'

});

//# sourceMappingURL=MapEventType.js.map

/***/ }),

/***/ "./node_modules/ol/MapProperty.js":
/*!****************************************!*\
  !*** ./node_modules/ol/MapProperty.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/MapProperty
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  LAYERGROUP: 'layergroup',
  SIZE: 'size',
  TARGET: 'target',
  VIEW: 'view'
});

//# sourceMappingURL=MapProperty.js.map

/***/ }),

/***/ "./node_modules/ol/Object.js":
/*!***********************************!*\
  !*** ./node_modules/ol/Object.js ***!
  \***********************************/
/*! exports provided: ObjectEvent, getChangeEventType, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObjectEvent", function() { return ObjectEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getChangeEventType", function() { return getChangeEventType; });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ObjectEventType.js */ "./node_modules/ol/ObjectEventType.js");
/* harmony import */ var _Observable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Observable.js */ "./node_modules/ol/Observable.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/Object
 */







/**
 * @classdesc
 * Events emitted by {@link module:ol/Object~BaseObject} instances are instances of this type.
 */
var ObjectEvent = /*@__PURE__*/(function (Event) {
  function ObjectEvent(type, key, oldValue) {
    Event.call(this, type);

    /**
     * The name of the property whose value is changing.
     * @type {string}
     * @api
     */
    this.key = key;

    /**
     * The old value. To get the new value use `e.target.get(e.key)` where
     * `e` is the event object.
     * @type {*}
     * @api
     */
    this.oldValue = oldValue;

  }

  if ( Event ) ObjectEvent.__proto__ = Event;
  ObjectEvent.prototype = Object.create( Event && Event.prototype );
  ObjectEvent.prototype.constructor = ObjectEvent;

  return ObjectEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_3__["default"]));


/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Most non-trivial classes inherit from this.
 *
 * This extends {@link module:ol/Observable} with observable
 * properties, where each property is observable as well as the object as a
 * whole.
 *
 * Classes that inherit from this have pre-defined properties, to which you can
 * add your owns. The pre-defined properties are listed in this documentation as
 * 'Observable Properties', and have their own accessors; for example,
 * {@link module:ol/Map~Map} has a `target` property, accessed with
 * `getTarget()` and changed with `setTarget()`. Not all properties are however
 * settable. There are also general-purpose accessors `get()` and `set()`. For
 * example, `get('target')` is equivalent to `getTarget()`.
 *
 * The `set` accessors trigger a change event, and you can monitor this by
 * registering a listener. For example, {@link module:ol/View~View} has a
 * `center` property, so `view.on('change:center', function(evt) {...});` would
 * call the function whenever the value of the center property changes. Within
 * the function, `evt.target` would be the view, so `evt.target.getCenter()`
 * would return the new center.
 *
 * You can add your own observable properties with
 * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.
 * You can listen for changes on that property value with
 * `object.on('change:prop', listener)`. You can get a list of all
 * properties with {@link module:ol/Object~BaseObject#getProperties}.
 *
 * Note that the observable properties are separate from standard JS properties.
 * You can, for example, give your map object a title with
 * `map.title='New title'` and with `map.set('title', 'Another title')`. The
 * first will be a `hasOwnProperty`; the second will appear in
 * `getProperties()`. Only the second is observable.
 *
 * Properties can be deleted by using the unset method. E.g.
 * object.unset('foo').
 *
 * @fires ObjectEvent
 * @api
 */
var BaseObject = /*@__PURE__*/(function (Observable) {
  function BaseObject(opt_values) {
    Observable.call(this);

    // Call {@link module:ol/util~getUid} to ensure that the order of objects' ids is
    // the same as the order in which they were created.  This also helps to
    // ensure that object properties are always added in the same order, which
    // helps many JavaScript engines generate faster code.
    Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(this);

    /**
     * @private
     * @type {!Object<string, *>}
     */
    this.values_ = {};

    if (opt_values !== undefined) {
      this.setProperties(opt_values);
    }
  }

  if ( Observable ) BaseObject.__proto__ = Observable;
  BaseObject.prototype = Object.create( Observable && Observable.prototype );
  BaseObject.prototype.constructor = BaseObject;

  /**
   * Gets a value.
   * @param {string} key Key name.
   * @return {*} Value.
   * @api
   */
  BaseObject.prototype.get = function get (key) {
    var value;
    if (this.values_.hasOwnProperty(key)) {
      value = this.values_[key];
    }
    return value;
  };

  /**
   * Get a list of object property names.
   * @return {Array<string>} List of property names.
   * @api
   */
  BaseObject.prototype.getKeys = function getKeys () {
    return Object.keys(this.values_);
  };

  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>} Object.
   * @api
   */
  BaseObject.prototype.getProperties = function getProperties () {
    return Object(_obj_js__WEBPACK_IMPORTED_MODULE_4__["assign"])({}, this.values_);
  };

  /**
   * @param {string} key Key name.
   * @param {*} oldValue Old value.
   */
  BaseObject.prototype.notify = function notify (key, oldValue) {
    var eventType;
    eventType = getChangeEventType(key);
    this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
    eventType = _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].PROPERTYCHANGE;
    this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
  };

  /**
   * Sets a value.
   * @param {string} key Key name.
   * @param {*} value Value.
   * @param {boolean=} opt_silent Update without triggering an event.
   * @api
   */
  BaseObject.prototype.set = function set (key, value, opt_silent) {
    if (opt_silent) {
      this.values_[key] = value;
    } else {
      var oldValue = this.values_[key];
      this.values_[key] = value;
      if (oldValue !== value) {
        this.notify(key, oldValue);
      }
    }
  };

  /**
   * Sets a collection of key-value pairs.  Note that this changes any existing
   * properties and adds new ones (it does not remove any existing properties).
   * @param {Object<string, *>} values Values.
   * @param {boolean=} opt_silent Update without triggering an event.
   * @api
   */
  BaseObject.prototype.setProperties = function setProperties (values, opt_silent) {
    for (var key in values) {
      this.set(key, values[key], opt_silent);
    }
  };

  /**
   * Unsets a property.
   * @param {string} key Key name.
   * @param {boolean=} opt_silent Unset without triggering an event.
   * @api
   */
  BaseObject.prototype.unset = function unset (key, opt_silent) {
    if (key in this.values_) {
      var oldValue = this.values_[key];
      delete this.values_[key];
      if (!opt_silent) {
        this.notify(key, oldValue);
      }
    }
  };

  return BaseObject;
}(_Observable_js__WEBPACK_IMPORTED_MODULE_2__["default"]));


/**
 * @type {Object<string, string>}
 */
var changeEventTypeCache = {};


/**
 * @param {string} key Key name.
 * @return {string} Change name.
 */
function getChangeEventType(key) {
  return changeEventTypeCache.hasOwnProperty(key) ?
    changeEventTypeCache[key] :
    (changeEventTypeCache[key] = 'change:' + key);
}


/* harmony default export */ __webpack_exports__["default"] = (BaseObject);

//# sourceMappingURL=Object.js.map

/***/ }),

/***/ "./node_modules/ol/ObjectEventType.js":
/*!********************************************!*\
  !*** ./node_modules/ol/ObjectEventType.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/ObjectEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  /**
   * Triggered when a property is changed.
   * @event module:ol/Object.ObjectEvent#propertychange
   * @api
   */
  PROPERTYCHANGE: 'propertychange'
});

//# sourceMappingURL=ObjectEventType.js.map

/***/ }),

/***/ "./node_modules/ol/Observable.js":
/*!***************************************!*\
  !*** ./node_modules/ol/Observable.js ***!
  \***************************************/
/*! exports provided: unByKey, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unByKey", function() { return unByKey; });
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events/Target.js */ "./node_modules/ol/events/Target.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/**
 * @module ol/Observable
 */




/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * An event target providing convenient methods for listener registration
 * and unregistration. A generic `change` event is always available through
 * {@link module:ol/Observable~Observable#changed}.
 *
 * @fires import("./events/Event.js").Event
 * @api
 */
var Observable = /*@__PURE__*/(function (EventTarget) {
  function Observable() {

    EventTarget.call(this);

    /**
     * @private
     * @type {number}
     */
    this.revision_ = 0;

  }

  if ( EventTarget ) Observable.__proto__ = EventTarget;
  Observable.prototype = Object.create( EventTarget && EventTarget.prototype );
  Observable.prototype.constructor = Observable;

  /**
   * Increases the revision counter and dispatches a 'change' event.
   * @api
   */
  Observable.prototype.changed = function changed () {
    ++this.revision_;
    this.dispatchEvent(_events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CHANGE);
  };

  /**
   * Get the version number for this object.  Each time the object is modified,
   * its version number will be incremented.
   * @return {number} Revision.
   * @api
   */
  Observable.prototype.getRevision = function getRevision () {
    return this.revision_;
  };

  /**
   * Listen for a certain type of event.
   * @param {string|Array<string>} type The event type or array of event types.
   * @param {function(?): ?} listener The listener function.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
   *     called with an array of event types as the first argument, the return
   *     will be an array of keys.
   * @api
   */
  Observable.prototype.on = function on (type, listener) {
    if (Array.isArray(type)) {
      var len = type.length;
      var keys = new Array(len);
      for (var i = 0; i < len; ++i) {
        keys[i] = Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listen"])(this, type[i], listener);
      }
      return keys;
    } else {
      return Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listen"])(this, /** @type {string} */ (type), listener);
    }
  };

  /**
   * Listen once for a certain type of event.
   * @param {string|Array<string>} type The event type or array of event types.
   * @param {function(?): ?} listener The listener function.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
   *     called with an array of event types as the first argument, the return
   *     will be an array of keys.
   * @api
   */
  Observable.prototype.once = function once (type, listener) {
    if (Array.isArray(type)) {
      var len = type.length;
      var keys = new Array(len);
      for (var i = 0; i < len; ++i) {
        keys[i] = Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listenOnce"])(this, type[i], listener);
      }
      return keys;
    } else {
      return Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listenOnce"])(this, /** @type {string} */ (type), listener);
    }
  };

  /**
   * Unlisten for a certain type of event.
   * @param {string|Array<string>} type The event type or array of event types.
   * @param {function(?): ?} listener The listener function.
   * @api
   */
  Observable.prototype.un = function un (type, listener) {
    if (Array.isArray(type)) {
      for (var i = 0, ii = type.length; i < ii; ++i) {
        Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["unlisten"])(this, type[i], listener);
      }
      return;
    } else {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["unlisten"])(this, /** @type {string} */ (type), listener);
    }
  };

  return Observable;
}(_events_Target_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/**
 * Removes an event listener using the key returned by `on()` or `once()`.
 * @param {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} key The key returned by `on()`
 *     or `once()` (or an array of keys).
 * @api
 */
function unByKey(key) {
  if (Array.isArray(key)) {
    for (var i = 0, ii = key.length; i < ii; ++i) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["unlistenByKey"])(key[i]);
    }
  } else {
    Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["unlistenByKey"])(/** @type {import("./events.js").EventsKey} */ (key));
  }
}


/* harmony default export */ __webpack_exports__["default"] = (Observable);

//# sourceMappingURL=Observable.js.map

/***/ }),

/***/ "./node_modules/ol/PluggableMap.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/PluggableMap.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Collection.js */ "./node_modules/ol/Collection.js");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CollectionEventType.js */ "./node_modules/ol/CollectionEventType.js");
/* harmony import */ var _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MapBrowserEvent.js */ "./node_modules/ol/MapBrowserEvent.js");
/* harmony import */ var _MapBrowserEventHandler_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MapBrowserEventHandler.js */ "./node_modules/ol/MapBrowserEventHandler.js");
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./MapBrowserEventType.js */ "./node_modules/ol/MapBrowserEventType.js");
/* harmony import */ var _MapEvent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./MapEvent.js */ "./node_modules/ol/MapEvent.js");
/* harmony import */ var _MapEventType_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./MapEventType.js */ "./node_modules/ol/MapEventType.js");
/* harmony import */ var _MapProperty_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./MapProperty.js */ "./node_modules/ol/MapProperty.js");
/* harmony import */ var _render_EventType_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./render/EventType.js */ "./node_modules/ol/render/EventType.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./ObjectEventType.js */ "./node_modules/ol/ObjectEventType.js");
/* harmony import */ var _TileQueue_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./TileQueue.js */ "./node_modules/ol/TileQueue.js");
/* harmony import */ var _View_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./View.js */ "./node_modules/ol/View.js");
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./ViewHint.js */ "./node_modules/ol/ViewHint.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _layer_Group_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./layer/Group.js */ "./node_modules/ol/layer/Group.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./size.js */ "./node_modules/ol/size.js");
/* harmony import */ var _structs_PriorityQueue_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./structs/PriorityQueue.js */ "./node_modules/ol/structs/PriorityQueue.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/PluggableMap
 */





























/**
 * State of the current frame. Only `pixelRatio`, `time` and `viewState` should
 * be used in applications.
 * @typedef {Object} FrameState
 * @property {number} pixelRatio The pixel ratio of the frame.
 * @property {number} time The time when rendering of the frame was requested.
 * @property {import("./View.js").State} viewState The state of the current view.
 * @property {boolean} animate
 * @property {import("./transform.js").Transform} coordinateToPixelTransform
 * @property {null|import("./extent.js").Extent} extent
 * @property {import("./coordinate.js").Coordinate} focus
 * @property {number} index
 * @property {Object<string, import("./layer/Layer.js").State>} layerStates
 * @property {Array<import("./layer/Layer.js").State>} layerStatesArray
 * @property {import("./transform.js").Transform} pixelToCoordinateTransform
 * @property {Array<PostRenderFunction>} postRenderFunctions
 * @property {import("./size.js").Size} size
 * @property {!Object<string, boolean>} skippedFeatureUids
 * @property {TileQueue} tileQueue
 * @property {Object<string, Object<string, import("./TileRange.js").default>>} usedTiles
 * @property {Array<number>} viewHints
 * @property {!Object<string, Object<string, boolean>>} wantedTiles
 */


/**
 * @typedef {function(PluggableMap, ?FrameState): boolean} PostRenderFunction
 */


/**
 * @typedef {Object} AtPixelOptions
 * @property {undefined|function(import("./layer/Layer.js").default): boolean} layerFilter Layer filter
 * function. The filter function will receive one argument, the
 * {@link module:ol/layer/Layer layer-candidate} and it should return a boolean value.
 * Only layers which are visible and for which this function returns `true`
 * will be tested for features. By default, all visible layers will be tested.
 * @property {number} [hitTolerance=0] Hit-detection tolerance in pixels. Pixels
 * inside the radius around the given position will be checked for features. This only
 * works for the canvas renderer and not for WebGL.
 */


/**
 * @typedef {Object} MapOptionsInternal
 * @property {Collection<import("./control/Control.js").default>} [controls]
 * @property {Collection<import("./interaction/Interaction.js").default>} [interactions]
 * @property {HTMLElement|Document} keyboardEventTarget
 * @property {Collection<import("./Overlay.js").default>} overlays
 * @property {Object<string, *>} values
 */


/**
 * Object literal with config options for the map.
 * @typedef {Object} MapOptions
 * @property {Collection<import("./control/Control.js").default>|Array<import("./control/Control.js").default>} [controls]
 * Controls initially added to the map. If not specified,
 * {@link module:ol/control~defaults} is used.
 * @property {number} [pixelRatio=window.devicePixelRatio] The ratio between
 * physical pixels and device-independent pixels (dips) on the device.
 * @property {Collection<import("./interaction/Interaction.js").default>|Array<import("./interaction/Interaction.js").default>} [interactions]
 * Interactions that are initially added to the map. If not specified,
 * {@link module:ol/interaction~defaults} is used.
 * @property {HTMLElement|Document|string} [keyboardEventTarget] The element to
 * listen to keyboard events on. This determines when the `KeyboardPan` and
 * `KeyboardZoom` interactions trigger. For example, if this option is set to
 * `document` the keyboard interactions will always trigger. If this option is
 * not specified, the element the library listens to keyboard events on is the
 * map target (i.e. the user-provided div for the map). If this is not
 * `document`, the target element needs to be focused for key events to be
 * emitted, requiring that the target element has a `tabindex` attribute.
 * @property {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>|LayerGroup} [layers]
 * Layers. If this is not defined, a map with no layers will be rendered. Note
 * that layers are rendered in the order supplied, so if you want, for example,
 * a vector layer to appear on top of a tile layer, it must come after the tile
 * layer.
 * @property {number} [maxTilesLoading=16] Maximum number tiles to load
 * simultaneously.
 * @property {boolean} [loadTilesWhileAnimating=false] When set to `true`, tiles
 * will be loaded during animations. This may improve the user experience, but
 * can also make animations stutter on devices with slow memory.
 * @property {boolean} [loadTilesWhileInteracting=false] When set to `true`,
 * tiles will be loaded while interacting with the map. This may improve the
 * user experience, but can also make map panning and zooming choppy on devices
 * with slow memory.
 * @property {number} [moveTolerance=1] The minimum distance in pixels the
 * cursor must move to be detected as a map move event instead of a click.
 * Increasing this value can make it easier to click on the map.
 * @property {Collection<import("./Overlay.js").default>|Array<import("./Overlay.js").default>} [overlays]
 * Overlays initially added to the map. By default, no overlays are added.
 * @property {HTMLElement|string} [target] The container for the map, either the
 * element itself or the `id` of the element. If not specified at construction
 * time, {@link module:ol/Map~Map#setTarget} must be called for the map to be
 * rendered.
 * @property {View} [view] The map's view.  No layer sources will be
 * fetched unless this is specified at construction time or through
 * {@link module:ol/Map~Map#setView}.
 */


/**
 * @fires import("./MapBrowserEvent.js").MapBrowserEvent
 * @fires import("./MapEvent.js").MapEvent
 * @fires module:ol/render/Event~RenderEvent#postcompose
 * @fires module:ol/render/Event~RenderEvent#precompose
 * @fires module:ol/render/Event~RenderEvent#rendercomplete
 * @api
 */
var PluggableMap = /*@__PURE__*/(function (BaseObject) {
  function PluggableMap(options) {

    BaseObject.call(this);

    var optionsInternal = createOptionsInternal(options);

    /**
     * @type {number}
     * @private
     */
    this.maxTilesLoading_ = options.maxTilesLoading !== undefined ? options.maxTilesLoading : 16;

    /**
     * @type {boolean}
     * @private
     */
    this.loadTilesWhileAnimating_ =
        options.loadTilesWhileAnimating !== undefined ?
          options.loadTilesWhileAnimating : false;

    /**
     * @type {boolean}
     * @private
     */
    this.loadTilesWhileInteracting_ =
        options.loadTilesWhileInteracting !== undefined ?
          options.loadTilesWhileInteracting : false;

    /**
     * @private
     * @type {number}
     */
    this.pixelRatio_ = options.pixelRatio !== undefined ?
      options.pixelRatio : _has_js__WEBPACK_IMPORTED_MODULE_22__["DEVICE_PIXEL_RATIO"];

    /**
     * @private
     * @type {number|undefined}
     */
    this.animationDelayKey_;

    /**
     * @private
     */
    this.animationDelay_ = function() {
      this.animationDelayKey_ = undefined;
      this.renderFrame_.call(this, Date.now());
    }.bind(this);

    /**
     * @private
     * @type {import("./transform.js").Transform}
     */
    this.coordinateToPixelTransform_ = Object(_transform_js__WEBPACK_IMPORTED_MODULE_26__["create"])();

    /**
     * @private
     * @type {import("./transform.js").Transform}
     */
    this.pixelToCoordinateTransform_ = Object(_transform_js__WEBPACK_IMPORTED_MODULE_26__["create"])();

    /**
     * @private
     * @type {number}
     */
    this.frameIndex_ = 0;

    /**
     * @private
     * @type {?FrameState}
     */
    this.frameState_ = null;

    /**
     * The extent at the previous 'moveend' event.
     * @private
     * @type {import("./extent.js").Extent}
     */
    this.previousExtent_ = null;

    /**
     * @private
     * @type {?import("./events.js").EventsKey}
     */
    this.viewPropertyListenerKey_ = null;

    /**
     * @private
     * @type {?import("./events.js").EventsKey}
     */
    this.viewChangeListenerKey_ = null;

    /**
     * @private
     * @type {Array<import("./events.js").EventsKey>}
     */
    this.layerGroupPropertyListenerKeys_ = null;

    /**
     * @private
     * @type {!HTMLElement}
     */
    this.viewport_ = document.createElement('div');
    this.viewport_.className = 'ol-viewport' + (_has_js__WEBPACK_IMPORTED_MODULE_22__["TOUCH"] ? ' ol-touch' : '');
    this.viewport_.style.position = 'relative';
    this.viewport_.style.overflow = 'hidden';
    this.viewport_.style.width = '100%';
    this.viewport_.style.height = '100%';
    // prevent page zoom on IE >= 10 browsers
    this.viewport_.style.msTouchAction = 'none';
    this.viewport_.style.touchAction = 'none';

    /**
     * @private
     * @type {!HTMLElement}
     */
    this.overlayContainer_ = document.createElement('div');
    this.overlayContainer_.className = 'ol-overlaycontainer';
    this.viewport_.appendChild(this.overlayContainer_);

    /**
     * @private
     * @type {!HTMLElement}
     */
    this.overlayContainerStopEvent_ = document.createElement('div');
    this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent';
    var overlayEvents = [
      _events_EventType_js__WEBPACK_IMPORTED_MODULE_19__["default"].CLICK,
      _events_EventType_js__WEBPACK_IMPORTED_MODULE_19__["default"].DBLCLICK,
      _events_EventType_js__WEBPACK_IMPORTED_MODULE_19__["default"].MOUSEDOWN,
      _events_EventType_js__WEBPACK_IMPORTED_MODULE_19__["default"].TOUCHSTART,
      _events_EventType_js__WEBPACK_IMPORTED_MODULE_19__["default"].MSPOINTERDOWN,
      _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POINTERDOWN,
      _events_EventType_js__WEBPACK_IMPORTED_MODULE_19__["default"].MOUSEWHEEL,
      _events_EventType_js__WEBPACK_IMPORTED_MODULE_19__["default"].WHEEL
    ];
    for (var i = 0, ii = overlayEvents.length; i < ii; ++i) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["listen"])(this.overlayContainerStopEvent_, overlayEvents[i], _events_Event_js__WEBPACK_IMPORTED_MODULE_18__["stopPropagation"]);
    }
    this.viewport_.appendChild(this.overlayContainerStopEvent_);

    /**
     * @private
     * @type {MapBrowserEventHandler}
     */
    this.mapBrowserEventHandler_ = new _MapBrowserEventHandler_js__WEBPACK_IMPORTED_MODULE_4__["default"](this, options.moveTolerance);
    for (var key in _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_5__["default"]) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["listen"])(this.mapBrowserEventHandler_, _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_5__["default"][key],
        this.handleMapBrowserEvent, this);
    }

    /**
     * @private
     * @type {HTMLElement|Document}
     */
    this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;

    /**
     * @private
     * @type {Array<import("./events.js").EventsKey>}
     */
    this.keyHandlerKeys_ = null;

    Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["listen"])(this.viewport_, _events_EventType_js__WEBPACK_IMPORTED_MODULE_19__["default"].CONTEXTMENU, this.handleBrowserEvent, this);
    Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["listen"])(this.viewport_, _events_EventType_js__WEBPACK_IMPORTED_MODULE_19__["default"].WHEEL, this.handleBrowserEvent, this);
    Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["listen"])(this.viewport_, _events_EventType_js__WEBPACK_IMPORTED_MODULE_19__["default"].MOUSEWHEEL, this.handleBrowserEvent, this);

    /**
     * @type {Collection<import("./control/Control.js").default>}
     * @protected
     */
    this.controls = optionsInternal.controls || new _Collection_js__WEBPACK_IMPORTED_MODULE_1__["default"]();

    /**
     * @type {Collection<import("./interaction/Interaction.js").default>}
     * @protected
     */
    this.interactions = optionsInternal.interactions || new _Collection_js__WEBPACK_IMPORTED_MODULE_1__["default"]();

    /**
     * @type {Collection<import("./Overlay.js").default>}
     * @private
     */
    this.overlays_ = optionsInternal.overlays;

    /**
     * A lookup of overlays by id.
     * @private
     * @type {Object<string, import("./Overlay.js").default>}
     */
    this.overlayIdIndex_ = {};

    /**
     * @type {import("./renderer/Map.js").default}
     * @private
     */
    this.renderer_ = this.createRenderer();

    /**
     * @type {function(Event)|undefined}
     * @private
     */
    this.handleResize_;

    /**
     * @private
     * @type {import("./coordinate.js").Coordinate}
     */
    this.focus_ = null;

    /**
     * @private
     * @type {!Array<PostRenderFunction>}
     */
    this.postRenderFunctions_ = [];

    /**
     * @private
     * @type {TileQueue}
     */
    this.tileQueue_ = new _TileQueue_js__WEBPACK_IMPORTED_MODULE_12__["default"](
      this.getTilePriority.bind(this),
      this.handleTileChange_.bind(this));

    /**
     * Uids of features to skip at rendering time.
     * @type {Object<string, boolean>}
     * @private
     */
    this.skippedFeatureUids_ = {};

    Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["listen"])(
      this, Object(_Object_js__WEBPACK_IMPORTED_MODULE_10__["getChangeEventType"])(_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].LAYERGROUP),
      this.handleLayerGroupChanged_, this);
    Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["listen"])(this, Object(_Object_js__WEBPACK_IMPORTED_MODULE_10__["getChangeEventType"])(_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].VIEW),
      this.handleViewChanged_, this);
    Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["listen"])(this, Object(_Object_js__WEBPACK_IMPORTED_MODULE_10__["getChangeEventType"])(_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].SIZE),
      this.handleSizeChanged_, this);
    Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["listen"])(this, Object(_Object_js__WEBPACK_IMPORTED_MODULE_10__["getChangeEventType"])(_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].TARGET),
      this.handleTargetChanged_, this);

    // setProperties will trigger the rendering of the map if the map
    // is "defined" already.
    this.setProperties(optionsInternal.values);

    this.controls.forEach(
      /**
       * @param {import("./control/Control.js").default} control Control.
       * @this {PluggableMap}
       */
      (function(control) {
        control.setMap(this);
      }).bind(this));

    Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["listen"])(this.controls, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
       */
      function(event) {
        event.element.setMap(this);
      }, this);

    Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["listen"])(this.controls, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
       */
      function(event) {
        event.element.setMap(null);
      }, this);

    this.interactions.forEach(
      /**
       * @param {import("./interaction/Interaction.js").default} interaction Interaction.
       * @this {PluggableMap}
       */
      (function(interaction) {
        interaction.setMap(this);
      }).bind(this));

    Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["listen"])(this.interactions, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
       */
      function(event) {
        event.element.setMap(this);
      }, this);

    Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["listen"])(this.interactions, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
       */
      function(event) {
        event.element.setMap(null);
      }, this);

    this.overlays_.forEach(this.addOverlayInternal_.bind(this));

    Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["listen"])(this.overlays_, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
       */
      function(event) {
        this.addOverlayInternal_(/** @type {import("./Overlay.js").default} */ (event.element));
      }, this);

    Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["listen"])(this.overlays_, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
       */
      function(event) {
        var overlay = /** @type {import("./Overlay.js").default} */ (event.element);
        var id = overlay.getId();
        if (id !== undefined) {
          delete this.overlayIdIndex_[id.toString()];
        }
        event.element.setMap(null);
      }, this);

  }

  if ( BaseObject ) PluggableMap.__proto__ = BaseObject;
  PluggableMap.prototype = Object.create( BaseObject && BaseObject.prototype );
  PluggableMap.prototype.constructor = PluggableMap;

  /**
   * @abstract
   * @return {import("./renderer/Map.js").default} The map renderer
   */
  PluggableMap.prototype.createRenderer = function createRenderer () {
    throw new Error('Use a map type that has a createRenderer method');
  };

  /**
   * Add the given control to the map.
   * @param {import("./control/Control.js").default} control Control.
   * @api
   */
  PluggableMap.prototype.addControl = function addControl (control) {
    this.getControls().push(control);
  };

  /**
   * Add the given interaction to the map.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to add.
   * @api
   */
  PluggableMap.prototype.addInteraction = function addInteraction (interaction) {
    this.getInteractions().push(interaction);
  };

  /**
   * Adds the given layer to the top of this map. If you want to add a layer
   * elsewhere in the stack, use `getLayers()` and the methods available on
   * {@link module:ol/Collection~Collection}.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @api
   */
  PluggableMap.prototype.addLayer = function addLayer (layer) {
    var layers = this.getLayerGroup().getLayers();
    layers.push(layer);
  };

  /**
   * Add the given overlay to the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @api
   */
  PluggableMap.prototype.addOverlay = function addOverlay (overlay) {
    this.getOverlays().push(overlay);
  };

  /**
   * This deals with map's overlay collection changes.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @private
   */
  PluggableMap.prototype.addOverlayInternal_ = function addOverlayInternal_ (overlay) {
    var id = overlay.getId();
    if (id !== undefined) {
      this.overlayIdIndex_[id.toString()] = overlay;
    }
    overlay.setMap(this);
  };

  /**
   *
   * @inheritDoc
   */
  PluggableMap.prototype.disposeInternal = function disposeInternal () {
    this.mapBrowserEventHandler_.dispose();
    Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["unlisten"])(this.viewport_, _events_EventType_js__WEBPACK_IMPORTED_MODULE_19__["default"].CONTEXTMENU, this.handleBrowserEvent, this);
    Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["unlisten"])(this.viewport_, _events_EventType_js__WEBPACK_IMPORTED_MODULE_19__["default"].WHEEL, this.handleBrowserEvent, this);
    Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["unlisten"])(this.viewport_, _events_EventType_js__WEBPACK_IMPORTED_MODULE_19__["default"].MOUSEWHEEL, this.handleBrowserEvent, this);
    if (this.handleResize_ !== undefined) {
      removeEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_19__["default"].RESIZE, this.handleResize_, false);
      this.handleResize_ = undefined;
    }
    if (this.animationDelayKey_) {
      cancelAnimationFrame(this.animationDelayKey_);
      this.animationDelayKey_ = undefined;
    }
    this.setTarget(null);
    BaseObject.prototype.disposeInternal.call(this);
  };

  /**
   * Detect features that intersect a pixel on the viewport, and execute a
   * callback with each intersecting feature. Layers included in the detection can
   * be configured through the `layerFilter` option in `opt_options`.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {function(this: S, import("./Feature.js").FeatureLike,
   *     import("./layer/Layer.js").default): T} callback Feature callback. The callback will be
   *     called with two arguments. The first argument is one
   *     {@link module:ol/Feature feature} or
   *     {@link module:ol/render/Feature render feature} at the pixel, the second is
   *     the {@link module:ol/layer/Layer layer} of the feature and will be null for
   *     unmanaged layers. To stop detection, callback functions can return a
   *     truthy value.
   * @param {AtPixelOptions=} opt_options Optional options.
   * @return {T|undefined} Callback result, i.e. the return value of last
   * callback execution, or the first truthy callback return value.
   * @template S,T
   * @api
   */
  PluggableMap.prototype.forEachFeatureAtPixel = function forEachFeatureAtPixel (pixel, callback, opt_options) {
    if (!this.frameState_) {
      return;
    }
    var coordinate = this.getCoordinateFromPixel(pixel);
    opt_options = opt_options !== undefined ? opt_options :
      /** @type {AtPixelOptions} */ ({});
    var hitTolerance = opt_options.hitTolerance !== undefined ?
      opt_options.hitTolerance * this.frameState_.pixelRatio : 0;
    var layerFilter = opt_options.layerFilter !== undefined ?
      opt_options.layerFilter : _functions_js__WEBPACK_IMPORTED_MODULE_21__["TRUE"];
    return this.renderer_.forEachFeatureAtCoordinate(
      coordinate, this.frameState_, hitTolerance, callback, null,
      layerFilter, null);
  };

  /**
   * Get all features that intersect a pixel on the viewport.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions=} opt_options Optional options.
   * @return {Array<import("./Feature.js").FeatureLike>} The detected features or
   * `null` if none were found.
   * @api
   */
  PluggableMap.prototype.getFeaturesAtPixel = function getFeaturesAtPixel (pixel, opt_options) {
    var features = null;
    this.forEachFeatureAtPixel(pixel, function(feature) {
      if (!features) {
        features = [];
      }
      features.push(feature);
    }, opt_options);
    return features;
  };

  /**
   * Detect layers that have a color value at a pixel on the viewport, and
   * execute a callback with each matching layer. Layers included in the
   * detection can be configured through `opt_layerFilter`.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {function(this: S, import("./layer/Layer.js").default, (Uint8ClampedArray|Uint8Array)): T} callback
   *     Layer callback. This callback will receive two arguments: first is the
   *     {@link module:ol/layer/Layer layer}, second argument is an array representing
   *     [R, G, B, A] pixel values (0 - 255) and will be `null` for layer types
   *     that do not currently support this argument. To stop detection, callback
   *     functions can return a truthy value.
   * @param {AtPixelOptions=} opt_options Configuration options.
   * @return {T|undefined} Callback result, i.e. the return value of last
   * callback execution, or the first truthy callback return value.
   * @template S,T
   * @api
   */
  PluggableMap.prototype.forEachLayerAtPixel = function forEachLayerAtPixel (pixel, callback, opt_options) {
    if (!this.frameState_) {
      return;
    }
    var options = opt_options || /** @type {AtPixelOptions} */ ({});
    var hitTolerance = options.hitTolerance !== undefined ?
      opt_options.hitTolerance * this.frameState_.pixelRatio : 0;
    var layerFilter = options.layerFilter || _functions_js__WEBPACK_IMPORTED_MODULE_21__["TRUE"];
    return this.renderer_.forEachLayerAtPixel(
      pixel, this.frameState_, hitTolerance, callback, null, layerFilter, null);
  };

  /**
   * Detect if features intersect a pixel on the viewport. Layers included in the
   * detection can be configured through `opt_layerFilter`.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions=} opt_options Optional options.
   * @return {boolean} Is there a feature at the given pixel?
   * @template U
   * @api
   */
  PluggableMap.prototype.hasFeatureAtPixel = function hasFeatureAtPixel (pixel, opt_options) {
    if (!this.frameState_) {
      return false;
    }
    var coordinate = this.getCoordinateFromPixel(pixel);
    opt_options = opt_options !== undefined ? opt_options :
      /** @type {AtPixelOptions} */ ({});
    var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : _functions_js__WEBPACK_IMPORTED_MODULE_21__["TRUE"];
    var hitTolerance = opt_options.hitTolerance !== undefined ?
      opt_options.hitTolerance * this.frameState_.pixelRatio : 0;
    return this.renderer_.hasFeatureAtCoordinate(
      coordinate, this.frameState_, hitTolerance, layerFilter, null);
  };

  /**
   * Returns the coordinate in view projection for a browser event.
   * @param {Event} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   * @api
   */
  PluggableMap.prototype.getEventCoordinate = function getEventCoordinate (event) {
    return this.getCoordinateFromPixel(this.getEventPixel(event));
  };

  /**
   * Returns the map pixel position for a browser event relative to the viewport.
   * @param {Event|TouchEvent} event Event.
   * @return {import("./pixel.js").Pixel} Pixel.
   * @api
   */
  PluggableMap.prototype.getEventPixel = function getEventPixel (event) {
    var viewportPosition = this.viewport_.getBoundingClientRect();
    var eventPosition = 'changedTouches' in event ?
      /** @type {TouchEvent} */ (event).changedTouches[0] :
      /** @type {MouseEvent} */ (event);

    return [
      eventPosition.clientX - viewportPosition.left,
      eventPosition.clientY - viewportPosition.top
    ];
  };

  /**
   * Get the target in which this map is rendered.
   * Note that this returns what is entered as an option or in setTarget:
   * if that was an element, it returns an element; if a string, it returns that.
   * @return {HTMLElement|string|undefined} The Element or id of the Element that the
   *     map is rendered in.
   * @observable
   * @api
   */
  PluggableMap.prototype.getTarget = function getTarget () {
    return /** @type {HTMLElement|string|undefined} */ (this.get(_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].TARGET));
  };

  /**
   * Get the DOM element into which this map is rendered. In contrast to
   * `getTarget` this method always return an `Element`, or `null` if the
   * map has no target.
   * @return {HTMLElement} The element that the map is rendered in.
   * @api
   */
  PluggableMap.prototype.getTargetElement = function getTargetElement () {
    var target = this.getTarget();
    if (target !== undefined) {
      return typeof target === 'string' ? document.getElementById(target) : target;
    } else {
      return null;
    }
  };

  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * map view projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   * @api
   */
  PluggableMap.prototype.getCoordinateFromPixel = function getCoordinateFromPixel (pixel) {
    var frameState = this.frameState_;
    if (!frameState) {
      return null;
    } else {
      return Object(_transform_js__WEBPACK_IMPORTED_MODULE_26__["apply"])(frameState.pixelToCoordinateTransform, pixel.slice());
    }
  };

  /**
   * Get the map controls. Modifying this collection changes the controls
   * associated with the map.
   * @return {Collection<import("./control/Control.js").default>} Controls.
   * @api
   */
  PluggableMap.prototype.getControls = function getControls () {
    return this.controls;
  };

  /**
   * Get the map overlays. Modifying this collection changes the overlays
   * associated with the map.
   * @return {Collection<import("./Overlay.js").default>} Overlays.
   * @api
   */
  PluggableMap.prototype.getOverlays = function getOverlays () {
    return this.overlays_;
  };

  /**
   * Get an overlay by its identifier (the value returned by overlay.getId()).
   * Note that the index treats string and numeric identifiers as the same. So
   * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
   * @param {string|number} id Overlay identifier.
   * @return {import("./Overlay.js").default} Overlay.
   * @api
   */
  PluggableMap.prototype.getOverlayById = function getOverlayById (id) {
    var overlay = this.overlayIdIndex_[id.toString()];
    return overlay !== undefined ? overlay : null;
  };

  /**
   * Get the map interactions. Modifying this collection changes the interactions
   * associated with the map.
   *
   * Interactions are used for e.g. pan, zoom and rotate.
   * @return {Collection<import("./interaction/Interaction.js").default>} Interactions.
   * @api
   */
  PluggableMap.prototype.getInteractions = function getInteractions () {
    return this.interactions;
  };

  /**
   * Get the layergroup associated with this map.
   * @return {LayerGroup} A layer group containing the layers in this map.
   * @observable
   * @api
   */
  PluggableMap.prototype.getLayerGroup = function getLayerGroup () {
    return (
      /** @type {LayerGroup} */ (this.get(_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].LAYERGROUP))
    );
  };

  /**
   * Get the collection of layers associated with this map.
   * @return {!Collection<import("./layer/Base.js").default>} Layers.
   * @api
   */
  PluggableMap.prototype.getLayers = function getLayers () {
    var layers = this.getLayerGroup().getLayers();
    return layers;
  };

  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the map view
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   * @api
   */
  PluggableMap.prototype.getPixelFromCoordinate = function getPixelFromCoordinate (coordinate) {
    var frameState = this.frameState_;
    if (!frameState) {
      return null;
    } else {
      return Object(_transform_js__WEBPACK_IMPORTED_MODULE_26__["apply"])(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));
    }
  };

  /**
   * Get the map renderer.
   * @return {import("./renderer/Map.js").default} Renderer
   */
  PluggableMap.prototype.getRenderer = function getRenderer () {
    return this.renderer_;
  };

  /**
   * Get the size of this map.
   * @return {import("./size.js").Size|undefined} The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  PluggableMap.prototype.getSize = function getSize () {
    return (
      /** @type {import("./size.js").Size|undefined} */ (this.get(_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].SIZE))
    );
  };

  /**
   * Get the view associated with this map. A view manages properties such as
   * center and resolution.
   * @return {View} The view that controls this map.
   * @observable
   * @api
   */
  PluggableMap.prototype.getView = function getView () {
    return (
      /** @type {View} */ (this.get(_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].VIEW))
    );
  };

  /**
   * Get the element that serves as the map viewport.
   * @return {HTMLElement} Viewport.
   * @api
   */
  PluggableMap.prototype.getViewport = function getViewport () {
    return this.viewport_;
  };

  /**
   * Get the element that serves as the container for overlays.  Elements added to
   * this container will let mousedown and touchstart events through to the map,
   * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}
   * events.
   * @return {!HTMLElement} The map's overlay container.
   */
  PluggableMap.prototype.getOverlayContainer = function getOverlayContainer () {
    return this.overlayContainer_;
  };

  /**
   * Get the element that serves as a container for overlays that don't allow
   * event propagation. Elements added to this container won't let mousedown and
   * touchstart events through to the map, so clicks and gestures on an overlay
   * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   * @return {!HTMLElement} The map's overlay container that stops events.
   */
  PluggableMap.prototype.getOverlayContainerStopEvent = function getOverlayContainerStopEvent () {
    return this.overlayContainerStopEvent_;
  };

  /**
   * @param {import("./Tile.js").default} tile Tile.
   * @param {string} tileSourceKey Tile source key.
   * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
   * @param {number} tileResolution Tile resolution.
   * @return {number} Tile priority.
   */
  PluggableMap.prototype.getTilePriority = function getTilePriority (tile, tileSourceKey, tileCenter, tileResolution) {
    // Filter out tiles at higher zoom levels than the current zoom level, or that
    // are outside the visible extent.
    var frameState = this.frameState_;
    if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {
      return _structs_PriorityQueue_js__WEBPACK_IMPORTED_MODULE_25__["DROP"];
    }
    if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {
      return _structs_PriorityQueue_js__WEBPACK_IMPORTED_MODULE_25__["DROP"];
    }
    // Prioritize the highest zoom level tiles closest to the focus.
    // Tiles at higher zoom levels are prioritized using Math.log(tileResolution).
    // Within a zoom level, tiles are prioritized by the distance in pixels
    // between the center of the tile and the focus.  The factor of 65536 means
    // that the prioritization should behave as desired for tiles up to
    // 65536 * Math.log(2) = 45426 pixels from the focus.
    var deltaX = tileCenter[0] - frameState.focus[0];
    var deltaY = tileCenter[1] - frameState.focus[1];
    return 65536 * Math.log(tileResolution) +
        Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;
  };

  /**
   * @param {Event} browserEvent Browser event.
   * @param {string=} opt_type Type.
   */
  PluggableMap.prototype.handleBrowserEvent = function handleBrowserEvent (browserEvent, opt_type) {
    var type = opt_type || browserEvent.type;
    var mapBrowserEvent = new _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_3__["default"](type, this, browserEvent);
    this.handleMapBrowserEvent(mapBrowserEvent);
  };

  /**
   * @param {MapBrowserEvent} mapBrowserEvent The event to handle.
   */
  PluggableMap.prototype.handleMapBrowserEvent = function handleMapBrowserEvent (mapBrowserEvent) {
    if (!this.frameState_) {
      // With no view defined, we cannot translate pixels into geographical
      // coordinates so interactions cannot be used.
      return;
    }
    this.focus_ = mapBrowserEvent.coordinate;
    mapBrowserEvent.frameState = this.frameState_;
    var interactionsArray = this.getInteractions().getArray();
    if (this.dispatchEvent(mapBrowserEvent) !== false) {
      for (var i = interactionsArray.length - 1; i >= 0; i--) {
        var interaction = interactionsArray[i];
        if (!interaction.getActive()) {
          continue;
        }
        var cont = interaction.handleEvent(mapBrowserEvent);
        if (!cont) {
          break;
        }
      }
    }
  };

  /**
   * @protected
   */
  PluggableMap.prototype.handlePostRender = function handlePostRender () {

    var frameState = this.frameState_;

    // Manage the tile queue
    // Image loads are expensive and a limited resource, so try to use them
    // efficiently:
    // * When the view is static we allow a large number of parallel tile loads
    //   to complete the frame as quickly as possible.
    // * When animating or interacting, image loads can cause janks, so we reduce
    //   the maximum number of loads per frame and limit the number of parallel
    //   tile loads to remain reactive to view changes and to reduce the chance of
    //   loading tiles that will quickly disappear from view.
    var tileQueue = this.tileQueue_;
    if (!tileQueue.isEmpty()) {
      var maxTotalLoading = this.maxTilesLoading_;
      var maxNewLoads = maxTotalLoading;
      if (frameState) {
        var hints = frameState.viewHints;
        if (hints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_14__["default"].ANIMATING]) {
          maxTotalLoading = this.loadTilesWhileAnimating_ ? 8 : 0;
          maxNewLoads = 2;
        }
        if (hints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_14__["default"].INTERACTING]) {
          maxTotalLoading = this.loadTilesWhileInteracting_ ? 8 : 0;
          maxNewLoads = 2;
        }
      }
      if (tileQueue.getTilesLoading() < maxTotalLoading) {
        tileQueue.reprioritize(); // FIXME only call if view has changed
        tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);
      }
    }
    if (frameState && this.hasListener(_render_EventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].RENDERCOMPLETE) && !frameState.animate &&
        !this.tileQueue_.getTilesLoading() && !getLoading(this.getLayers().getArray())) {
      this.renderer_.dispatchRenderEvent(_render_EventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].RENDERCOMPLETE, frameState);
    }

    var postRenderFunctions = this.postRenderFunctions_;
    for (var i = 0, ii = postRenderFunctions.length; i < ii; ++i) {
      postRenderFunctions[i](this, frameState);
    }
    postRenderFunctions.length = 0;
  };

  /**
   * @private
   */
  PluggableMap.prototype.handleSizeChanged_ = function handleSizeChanged_ () {
    this.render();
  };

  /**
   * @private
   */
  PluggableMap.prototype.handleTargetChanged_ = function handleTargetChanged_ () {
    // target may be undefined, null, a string or an Element.
    // If it's a string we convert it to an Element before proceeding.
    // If it's not now an Element we remove the viewport from the DOM.
    // If it's an Element we append the viewport element to it.

    var targetElement;
    if (this.getTarget()) {
      targetElement = this.getTargetElement();
    }

    if (this.keyHandlerKeys_) {
      for (var i = 0, ii = this.keyHandlerKeys_.length; i < ii; ++i) {
        Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["unlistenByKey"])(this.keyHandlerKeys_[i]);
      }
      this.keyHandlerKeys_ = null;
    }

    if (!targetElement) {
      this.renderer_.removeLayerRenderers();
      Object(_dom_js__WEBPACK_IMPORTED_MODULE_16__["removeNode"])(this.viewport_);
      if (this.handleResize_ !== undefined) {
        removeEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_19__["default"].RESIZE, this.handleResize_, false);
        this.handleResize_ = undefined;
      }
    } else {
      targetElement.appendChild(this.viewport_);

      var keyboardEventTarget = !this.keyboardEventTarget_ ?
        targetElement : this.keyboardEventTarget_;
      this.keyHandlerKeys_ = [
        Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["listen"])(keyboardEventTarget, _events_EventType_js__WEBPACK_IMPORTED_MODULE_19__["default"].KEYDOWN, this.handleBrowserEvent, this),
        Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["listen"])(keyboardEventTarget, _events_EventType_js__WEBPACK_IMPORTED_MODULE_19__["default"].KEYPRESS, this.handleBrowserEvent, this)
      ];

      if (!this.handleResize_) {
        this.handleResize_ = this.updateSize.bind(this);
        window.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_19__["default"].RESIZE, this.handleResize_, false);
      }
    }

    this.updateSize();
    // updateSize calls setSize, so no need to call this.render
    // ourselves here.
  };

  /**
   * @private
   */
  PluggableMap.prototype.handleTileChange_ = function handleTileChange_ () {
    this.render();
  };

  /**
   * @private
   */
  PluggableMap.prototype.handleViewPropertyChanged_ = function handleViewPropertyChanged_ () {
    this.render();
  };

  /**
   * @private
   */
  PluggableMap.prototype.handleViewChanged_ = function handleViewChanged_ () {
    if (this.viewPropertyListenerKey_) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["unlistenByKey"])(this.viewPropertyListenerKey_);
      this.viewPropertyListenerKey_ = null;
    }
    if (this.viewChangeListenerKey_) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["unlistenByKey"])(this.viewChangeListenerKey_);
      this.viewChangeListenerKey_ = null;
    }
    var view = this.getView();
    if (view) {
      this.viewport_.setAttribute('data-view', Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(view));
      this.viewPropertyListenerKey_ = Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["listen"])(
        view, _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_11__["default"].PROPERTYCHANGE,
        this.handleViewPropertyChanged_, this);
      this.viewChangeListenerKey_ = Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["listen"])(
        view, _events_EventType_js__WEBPACK_IMPORTED_MODULE_19__["default"].CHANGE,
        this.handleViewPropertyChanged_, this);
    }
    this.render();
  };

  /**
   * @private
   */
  PluggableMap.prototype.handleLayerGroupChanged_ = function handleLayerGroupChanged_ () {
    if (this.layerGroupPropertyListenerKeys_) {
      this.layerGroupPropertyListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_17__["unlistenByKey"]);
      this.layerGroupPropertyListenerKeys_ = null;
    }
    var layerGroup = this.getLayerGroup();
    if (layerGroup) {
      this.layerGroupPropertyListenerKeys_ = [
        Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["listen"])(
          layerGroup, _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_11__["default"].PROPERTYCHANGE,
          this.render, this),
        Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["listen"])(
          layerGroup, _events_EventType_js__WEBPACK_IMPORTED_MODULE_19__["default"].CHANGE,
          this.render, this)
      ];
    }
    this.render();
  };

  /**
   * @return {boolean} Is rendered.
   */
  PluggableMap.prototype.isRendered = function isRendered () {
    return !!this.frameState_;
  };

  /**
   * Requests an immediate render in a synchronous manner.
   * @api
   */
  PluggableMap.prototype.renderSync = function renderSync () {
    if (this.animationDelayKey_) {
      cancelAnimationFrame(this.animationDelayKey_);
    }
    this.animationDelay_();
  };

  /**
   * Request a map rendering (at the next animation frame).
   * @api
   */
  PluggableMap.prototype.render = function render () {
    if (this.animationDelayKey_ === undefined) {
      this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);
    }
  };

  /**
   * Remove the given control from the map.
   * @param {import("./control/Control.js").default} control Control.
   * @return {import("./control/Control.js").default|undefined} The removed control (or undefined
   *     if the control was not found).
   * @api
   */
  PluggableMap.prototype.removeControl = function removeControl (control) {
    return this.getControls().remove(control);
  };

  /**
   * Remove the given interaction from the map.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to remove.
   * @return {import("./interaction/Interaction.js").default|undefined} The removed interaction (or
   *     undefined if the interaction was not found).
   * @api
   */
  PluggableMap.prototype.removeInteraction = function removeInteraction (interaction) {
    return this.getInteractions().remove(interaction);
  };

  /**
   * Removes the given layer from the map.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @return {import("./layer/Base.js").default|undefined} The removed layer (or undefined if the
   *     layer was not found).
   * @api
   */
  PluggableMap.prototype.removeLayer = function removeLayer (layer) {
    var layers = this.getLayerGroup().getLayers();
    return layers.remove(layer);
  };

  /**
   * Remove the given overlay from the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @return {import("./Overlay.js").default|undefined} The removed overlay (or undefined
   *     if the overlay was not found).
   * @api
   */
  PluggableMap.prototype.removeOverlay = function removeOverlay (overlay) {
    return this.getOverlays().remove(overlay);
  };

  /**
   * @param {number} time Time.
   * @private
   */
  PluggableMap.prototype.renderFrame_ = function renderFrame_ (time) {
    var viewState;

    var size = this.getSize();
    var view = this.getView();
    var extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_20__["createEmpty"])();
    var previousFrameState = this.frameState_;
    /** @type {?FrameState} */
    var frameState = null;
    if (size !== undefined && Object(_size_js__WEBPACK_IMPORTED_MODULE_24__["hasArea"])(size) && view && view.isDef()) {
      var viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : undefined);
      var layerStatesArray = this.getLayerGroup().getLayerStatesArray();
      var layerStates = {};
      for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
        layerStates[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(layerStatesArray[i].layer)] = layerStatesArray[i];
      }
      viewState = view.getState(this.pixelRatio_);
      frameState = /** @type {FrameState} */ ({
        animate: false,
        coordinateToPixelTransform: this.coordinateToPixelTransform_,
        extent: extent,
        focus: this.focus_ ? this.focus_ : viewState.center,
        index: this.frameIndex_++,
        layerStates: layerStates,
        layerStatesArray: layerStatesArray,
        pixelRatio: this.pixelRatio_,
        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
        postRenderFunctions: [],
        size: size,
        skippedFeatureUids: this.skippedFeatureUids_,
        tileQueue: this.tileQueue_,
        time: time,
        usedTiles: {},
        viewState: viewState,
        viewHints: viewHints,
        wantedTiles: {}
      });
    }

    if (frameState) {
      frameState.extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_20__["getForViewAndSize"])(viewState.center,
        viewState.resolution, viewState.rotation, frameState.size, extent);
    }

    this.frameState_ = frameState;
    this.renderer_.renderFrame(frameState);

    if (frameState) {
      if (frameState.animate) {
        this.render();
      }
      Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);

      if (previousFrameState) {
        var moveStart = !this.previousExtent_ ||
                    (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_20__["isEmpty"])(this.previousExtent_) &&
                    !Object(_extent_js__WEBPACK_IMPORTED_MODULE_20__["equals"])(frameState.extent, this.previousExtent_));
        if (moveStart) {
          this.dispatchEvent(
            new _MapEvent_js__WEBPACK_IMPORTED_MODULE_6__["default"](_MapEventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].MOVESTART, this, previousFrameState));
          this.previousExtent_ = Object(_extent_js__WEBPACK_IMPORTED_MODULE_20__["createOrUpdateEmpty"])(this.previousExtent_);
        }
      }

      var idle = this.previousExtent_ &&
          !frameState.viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_14__["default"].ANIMATING] &&
          !frameState.viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_14__["default"].INTERACTING] &&
          !Object(_extent_js__WEBPACK_IMPORTED_MODULE_20__["equals"])(frameState.extent, this.previousExtent_);

      if (idle) {
        this.dispatchEvent(new _MapEvent_js__WEBPACK_IMPORTED_MODULE_6__["default"](_MapEventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].MOVEEND, this, frameState));
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_20__["clone"])(frameState.extent, this.previousExtent_);
      }
    }

    this.dispatchEvent(new _MapEvent_js__WEBPACK_IMPORTED_MODULE_6__["default"](_MapEventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].POSTRENDER, this, frameState));

    setTimeout(this.handlePostRender.bind(this), 0);

  };

  /**
   * Sets the layergroup of this map.
   * @param {LayerGroup} layerGroup A layer group containing the layers in this map.
   * @observable
   * @api
   */
  PluggableMap.prototype.setLayerGroup = function setLayerGroup (layerGroup) {
    this.set(_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].LAYERGROUP, layerGroup);
  };

  /**
   * Set the size of this map.
   * @param {import("./size.js").Size|undefined} size The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  PluggableMap.prototype.setSize = function setSize (size) {
    this.set(_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].SIZE, size);
  };

  /**
   * Set the target element to render this map into.
   * @param {HTMLElement|string|undefined} target The Element or id of the Element
   *     that the map is rendered in.
   * @observable
   * @api
   */
  PluggableMap.prototype.setTarget = function setTarget (target) {
    this.set(_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].TARGET, target);
  };

  /**
   * Set the view for this map.
   * @param {View} view The view that controls this map.
   * @observable
   * @api
   */
  PluggableMap.prototype.setView = function setView (view) {
    this.set(_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].VIEW, view);
  };

  /**
   * @param {import("./Feature.js").default} feature Feature.
   */
  PluggableMap.prototype.skipFeature = function skipFeature (feature) {
    this.skippedFeatureUids_[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature)] = true;
    this.render();
  };

  /**
   * Force a recalculation of the map viewport size.  This should be called when
   * third-party code changes the size of the map viewport.
   * @api
   */
  PluggableMap.prototype.updateSize = function updateSize () {
    var targetElement = this.getTargetElement();

    if (!targetElement) {
      this.setSize(undefined);
    } else {
      var computedStyle = getComputedStyle(targetElement);
      this.setSize([
        targetElement.offsetWidth -
            parseFloat(computedStyle['borderLeftWidth']) -
            parseFloat(computedStyle['paddingLeft']) -
            parseFloat(computedStyle['paddingRight']) -
            parseFloat(computedStyle['borderRightWidth']),
        targetElement.offsetHeight -
            parseFloat(computedStyle['borderTopWidth']) -
            parseFloat(computedStyle['paddingTop']) -
            parseFloat(computedStyle['paddingBottom']) -
            parseFloat(computedStyle['borderBottomWidth'])
      ]);
    }
  };

  /**
   * @param {import("./Feature.js").default} feature Feature.
   */
  PluggableMap.prototype.unskipFeature = function unskipFeature (feature) {
    delete this.skippedFeatureUids_[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature)];
    this.render();
  };

  return PluggableMap;
}(_Object_js__WEBPACK_IMPORTED_MODULE_10__["default"]));


/**
 * @param {MapOptions} options Map options.
 * @return {MapOptionsInternal} Internal map options.
 */
function createOptionsInternal(options) {

  /**
   * @type {HTMLElement|Document}
   */
  var keyboardEventTarget = null;
  if (options.keyboardEventTarget !== undefined) {
    keyboardEventTarget = typeof options.keyboardEventTarget === 'string' ?
      document.getElementById(options.keyboardEventTarget) :
      options.keyboardEventTarget;
  }

  /**
   * @type {Object<string, *>}
   */
  var values = {};

  var layerGroup = options.layers && typeof /** @type {?} */ (options.layers).getLayers === 'function' ?
    /** @type {LayerGroup} */ (options.layers) : new _layer_Group_js__WEBPACK_IMPORTED_MODULE_23__["default"]({layers: /** @type {Collection} */ (options.layers)});
  values[_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].LAYERGROUP] = layerGroup;

  values[_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].TARGET] = options.target;

  values[_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].VIEW] = options.view !== undefined ?
    options.view : new _View_js__WEBPACK_IMPORTED_MODULE_13__["default"]();

  var controls;
  if (options.controls !== undefined) {
    if (Array.isArray(options.controls)) {
      controls = new _Collection_js__WEBPACK_IMPORTED_MODULE_1__["default"](options.controls.slice());
    } else {
      Object(_asserts_js__WEBPACK_IMPORTED_MODULE_15__["assert"])(typeof /** @type {?} */ (options.controls).getArray === 'function',
        47); // Expected `controls` to be an array or an `import("./Collection.js").Collection`
      controls = /** @type {Collection} */ (options.controls);
    }
  }

  var interactions;
  if (options.interactions !== undefined) {
    if (Array.isArray(options.interactions)) {
      interactions = new _Collection_js__WEBPACK_IMPORTED_MODULE_1__["default"](options.interactions.slice());
    } else {
      Object(_asserts_js__WEBPACK_IMPORTED_MODULE_15__["assert"])(typeof /** @type {?} */ (options.interactions).getArray === 'function',
        48); // Expected `interactions` to be an array or an `import("./Collection.js").Collection`
      interactions = /** @type {Collection} */ (options.interactions);
    }
  }

  var overlays;
  if (options.overlays !== undefined) {
    if (Array.isArray(options.overlays)) {
      overlays = new _Collection_js__WEBPACK_IMPORTED_MODULE_1__["default"](options.overlays.slice());
    } else {
      Object(_asserts_js__WEBPACK_IMPORTED_MODULE_15__["assert"])(typeof /** @type {?} */ (options.overlays).getArray === 'function',
        49); // Expected `overlays` to be an array or an `import("./Collection.js").Collection`
      overlays = options.overlays;
    }
  } else {
    overlays = new _Collection_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
  }

  return {
    controls: controls,
    interactions: interactions,
    keyboardEventTarget: keyboardEventTarget,
    overlays: overlays,
    values: values
  };

}
/* harmony default export */ __webpack_exports__["default"] = (PluggableMap);

/**
 * @param  {Array<import("./layer/Base.js").default>} layers Layers.
 * @return {boolean} Layers have sources that are still loading.
 */
function getLoading(layers) {
  for (var i = 0, ii = layers.length; i < ii; ++i) {
    var layer = layers[i];
    if (typeof /** @type {?} */ (layer).getLayers === 'function') {
      return getLoading(/** @type {LayerGroup} */ (layer).getLayers().getArray());
    } else {
      var source = /** @type {import("./layer/Layer.js").default} */ (
        layer).getSource();
      if (source && source.loading) {
        return true;
      }
    }
  }
  return false;
}

//# sourceMappingURL=PluggableMap.js.map

/***/ }),

/***/ "./node_modules/ol/Tile.js":
/*!*********************************!*\
  !*** ./node_modules/ol/Tile.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./easing.js */ "./node_modules/ol/easing.js");
/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events/Target.js */ "./node_modules/ol/events/Target.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/**
 * @module ol/Tile
 */






/**
 * A function that takes an {@link module:ol/Tile} for the tile and a
 * `{string}` for the url as arguments. The default is
 * ```js
 * source.setTileLoadFunction(function(tile, src) {
 *   tile.getImage().src = src;
 * });
 * ```
 * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve
 * error handling:
 *
 * ```js
 * import TileState from 'ol/TileState';
 *
 * source.setTileLoadFunction(function(tile, src) {
 *   var xhr = new XMLHttpRequest();
 *   xhr.responseType = 'blob';
 *   xhr.addEventListener('loadend', function (evt) {
 *     var data = this.response;
 *     if (data !== undefined) {
 *       tile.getImage().src = URL.createObjectURL(data);
 *     } else {
 *       tile.setState(TileState.ERROR);
 *     }
 *   });
 *   xhr.addEventListener('error', function () {
 *     tile.setState(TileState.ERROR);
 *   });
 *   xhr.open('GET', src);
 *   xhr.send();
 * });
 * ```
 *
 * @typedef {function(Tile, string)} LoadFunction
 * @api
 */

/**
 * {@link module:ol/source/Tile~Tile} sources use a function of this type to get
 * the url that provides a tile for a given tile coordinate.
 *
 * This function takes an {@link module:ol/tilecoord~TileCoord} for the tile
 * coordinate, a `{number}` representing the pixel ratio and a
 * {@link module:ol/proj/Projection} for the projection  as arguments
 * and returns a `{string}` representing the tile URL, or undefined if no tile
 * should be requested for the passed tile coordinate.
 *
 * @typedef {function(import("./tilecoord.js").TileCoord, number,
 *           import("./proj/Projection.js").default): (string|undefined)} UrlFunction
 * @api
 */


/**
 * @typedef {Object} Options
 * @property {number} [transition=250] A duration for tile opacity
 * transitions in milliseconds. A duration of 0 disables the opacity transition.
 * @api
 */


/**
 * @classdesc
 * Base class for tiles.
 *
 * @abstract
 */
var Tile = /*@__PURE__*/(function (EventTarget) {
  function Tile(tileCoord, state, opt_options) {
    EventTarget.call(this);

    var options = opt_options ? opt_options : {};

    /**
     * @type {import("./tilecoord.js").TileCoord}
     */
    this.tileCoord = tileCoord;

    /**
     * @protected
     * @type {TileState}
     */
    this.state = state;

    /**
     * An "interim" tile for this tile. The interim tile may be used while this
     * one is loading, for "smooth" transitions when changing params/dimensions
     * on the source.
     * @type {Tile}
     */
    this.interimTile = null;

    /**
     * A key assigned to the tile. This is used by the tile source to determine
     * if this tile can effectively be used, or if a new tile should be created
     * and this one be used as an interim tile for this new tile.
     * @type {string}
     */
    this.key = '';

    /**
     * The duration for the opacity transition.
     * @type {number}
     */
    this.transition_ = options.transition === undefined ? 250 : options.transition;

    /**
     * Lookup of start times for rendering transitions.  If the start time is
     * equal to -1, the transition is complete.
     * @type {Object<string, number>}
     */
    this.transitionStarts_ = {};

  }

  if ( EventTarget ) Tile.__proto__ = EventTarget;
  Tile.prototype = Object.create( EventTarget && EventTarget.prototype );
  Tile.prototype.constructor = Tile;

  /**
   * @protected
   */
  Tile.prototype.changed = function changed () {
    this.dispatchEvent(_events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].CHANGE);
  };

  /**
   * @return {string} Key.
   */
  Tile.prototype.getKey = function getKey () {
    return this.key + '/' + this.tileCoord;
  };

  /**
   * Get the interim tile most suitable for rendering using the chain of interim
   * tiles. This corresponds to the  most recent tile that has been loaded, if no
   * such tile exists, the original tile is returned.
   * @return {!Tile} Best tile for rendering.
   */
  Tile.prototype.getInterimTile = function getInterimTile () {
    if (!this.interimTile) {
      //empty chain
      return this;
    }
    var tile = this.interimTile;

    // find the first loaded tile and return it. Since the chain is sorted in
    // decreasing order of creation time, there is no need to search the remainder
    // of the list (all those tiles correspond to older requests and will be
    // cleaned up by refreshInterimChain)
    do {
      if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].LOADED) {
        return tile;
      }
      tile = tile.interimTile;
    } while (tile);

    // we can not find a better tile
    return this;
  };

  /**
   * Goes through the chain of interim tiles and discards sections of the chain
   * that are no longer relevant.
   */
  Tile.prototype.refreshInterimChain = function refreshInterimChain () {
    if (!this.interimTile) {
      return;
    }

    var tile = this.interimTile;
    var prev = /** @type {Tile} */ (this);

    do {
      if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].LOADED) {
        //we have a loaded tile, we can discard the rest of the list
        //we would could abort any LOADING tile request
        //older than this tile (i.e. any LOADING tile following this entry in the chain)
        tile.interimTile = null;
        break;
      } else if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].LOADING) {
        //keep this LOADING tile any loaded tiles later in the chain are
        //older than this tile, so we're still interested in the request
        prev = tile;
      } else if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].IDLE) {
        //the head of the list is the most current tile, we don't need
        //to start any other requests for this chain
        prev.interimTile = tile.interimTile;
      } else {
        prev = tile;
      }
      tile = prev.interimTile;
    } while (tile);
  };

  /**
   * Get the tile coordinate for this tile.
   * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
   * @api
   */
  Tile.prototype.getTileCoord = function getTileCoord () {
    return this.tileCoord;
  };

  /**
   * @return {TileState} State.
   */
  Tile.prototype.getState = function getState () {
    return this.state;
  };

  /**
   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,
   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}
   * when the tile cannot be loaded. Otherwise the tile cannot be removed from
   * the tile queue and will block other requests.
   * @param {TileState} state State.
   * @api
   */
  Tile.prototype.setState = function setState (state) {
    this.state = state;
    this.changed();
  };

  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   * @abstract
   * @api
   */
  Tile.prototype.load = function load () {};

  /**
   * Get the alpha value for rendering.
   * @param {string} id An id for the renderer.
   * @param {number} time The render frame time.
   * @return {number} A number between 0 and 1.
   */
  Tile.prototype.getAlpha = function getAlpha (id, time) {
    if (!this.transition_) {
      return 1;
    }

    var start = this.transitionStarts_[id];
    if (!start) {
      start = time;
      this.transitionStarts_[id] = start;
    } else if (start === -1) {
      return 1;
    }

    var delta = time - start + (1000 / 60); // avoid rendering at 0
    if (delta >= this.transition_) {
      return 1;
    }
    return Object(_easing_js__WEBPACK_IMPORTED_MODULE_1__["easeIn"])(delta / this.transition_);
  };

  /**
   * Determine if a tile is in an alpha transition.  A tile is considered in
   * transition if tile.getAlpha() has not yet been called or has been called
   * and returned 1.
   * @param {string} id An id for the renderer.
   * @return {boolean} The tile is in transition.
   */
  Tile.prototype.inTransition = function inTransition (id) {
    if (!this.transition_) {
      return false;
    }
    return this.transitionStarts_[id] !== -1;
  };

  /**
   * Mark a transition as complete.
   * @param {string} id An id for the renderer.
   */
  Tile.prototype.endTransition = function endTransition (id) {
    if (this.transition_) {
      this.transitionStarts_[id] = -1;
    }
  };

  return Tile;
}(_events_Target_js__WEBPACK_IMPORTED_MODULE_2__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (Tile);

//# sourceMappingURL=Tile.js.map

/***/ }),

/***/ "./node_modules/ol/TileCache.js":
/*!**************************************!*\
  !*** ./node_modules/ol/TileCache.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _structs_LRUCache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./structs/LRUCache.js */ "./node_modules/ol/structs/LRUCache.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tilecoord.js */ "./node_modules/ol/tilecoord.js");
/**
 * @module ol/TileCache
 */



var TileCache = /*@__PURE__*/(function (LRUCache) {
  function TileCache(opt_highWaterMark) {

    LRUCache.call(this, opt_highWaterMark);

  }

  if ( LRUCache ) TileCache.__proto__ = LRUCache;
  TileCache.prototype = Object.create( LRUCache && LRUCache.prototype );
  TileCache.prototype.constructor = TileCache;

  /**
   * @param {!Object<string, import("./TileRange.js").default>} usedTiles Used tiles.
   */
  TileCache.prototype.expireCache = function expireCache (usedTiles) {
    while (this.canExpireCache()) {
      var tile = this.peekLast();
      var zKey = tile.tileCoord[0].toString();
      if (zKey in usedTiles && usedTiles[zKey].contains(tile.tileCoord)) {
        break;
      } else {
        this.pop().dispose();
      }
    }
  };

  /**
   * Prune all tiles from the cache that don't have the same z as the newest tile.
   */
  TileCache.prototype.pruneExceptNewestZ = function pruneExceptNewestZ () {
    if (this.getCount() === 0) {
      return;
    }
    var key = this.peekFirstKey();
    var tileCoord = Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_1__["fromKey"])(key);
    var z = tileCoord[0];
    this.forEach(function(tile) {
      if (tile.tileCoord[0] !== z) {
        this.remove(Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_1__["getKey"])(tile.tileCoord));
        tile.dispose();
      }
    }, this);
  };

  return TileCache;
}(_structs_LRUCache_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (TileCache);

//# sourceMappingURL=TileCache.js.map

/***/ }),

/***/ "./node_modules/ol/TileQueue.js":
/*!**************************************!*\
  !*** ./node_modules/ol/TileQueue.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _structs_PriorityQueue_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./structs/PriorityQueue.js */ "./node_modules/ol/structs/PriorityQueue.js");
/**
 * @module ol/TileQueue
 */






/**
 * @typedef {function(import("./Tile.js").default, string, import("./coordinate.js").Coordinate, number): number} PriorityFunction
 */


var TileQueue = /*@__PURE__*/(function (PriorityQueue) {
  function TileQueue(tilePriorityFunction, tileChangeCallback) {

    PriorityQueue.call(
      /**
       * @param {Array} element Element.
       * @return {number} Priority.
       */
      this, function(element) {
        return tilePriorityFunction.apply(null, element);
      },
      /**
       * @param {Array} element Element.
       * @return {string} Key.
       */
      function(element) {
        return (/** @type {import("./Tile.js").default} */ (element[0]).getKey());
      });

    /**
     * @private
     * @type {function(): ?}
     */
    this.tileChangeCallback_ = tileChangeCallback;

    /**
     * @private
     * @type {number}
     */
    this.tilesLoading_ = 0;

    /**
     * @private
     * @type {!Object<string,boolean>}
     */
    this.tilesLoadingKeys_ = {};

  }

  if ( PriorityQueue ) TileQueue.__proto__ = PriorityQueue;
  TileQueue.prototype = Object.create( PriorityQueue && PriorityQueue.prototype );
  TileQueue.prototype.constructor = TileQueue;

  /**
   * @inheritDoc
   */
  TileQueue.prototype.enqueue = function enqueue (element) {
    var added = PriorityQueue.prototype.enqueue.call(this, element);
    if (added) {
      var tile = element[0];
      Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["listen"])(tile, _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CHANGE, this.handleTileChange, this);
    }
    return added;
  };

  /**
   * @return {number} Number of tiles loading.
   */
  TileQueue.prototype.getTilesLoading = function getTilesLoading () {
    return this.tilesLoading_;
  };

  /**
   * @param {import("./events/Event.js").default} event Event.
   * @protected
   */
  TileQueue.prototype.handleTileChange = function handleTileChange (event) {
    var tile = /** @type {import("./Tile.js").default} */ (event.target);
    var state = tile.getState();
    if (state === _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].LOADED || state === _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].ERROR ||
        state === _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].EMPTY || state === _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].ABORT) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["unlisten"])(tile, _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CHANGE, this.handleTileChange, this);
      var tileKey = tile.getKey();
      if (tileKey in this.tilesLoadingKeys_) {
        delete this.tilesLoadingKeys_[tileKey];
        --this.tilesLoading_;
      }
      this.tileChangeCallback_();
    }
  };

  /**
   * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
   * @param {number} maxNewLoads Maximum number of new tiles to load.
   */
  TileQueue.prototype.loadMoreTiles = function loadMoreTiles (maxTotalLoading, maxNewLoads) {
    var newLoads = 0;
    var abortedTiles = false;
    var state, tile, tileKey;
    while (this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads &&
           this.getCount() > 0) {
      tile = /** @type {import("./Tile.js").default} */ (this.dequeue()[0]);
      tileKey = tile.getKey();
      state = tile.getState();
      if (state === _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].ABORT) {
        abortedTiles = true;
      } else if (state === _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].IDLE && !(tileKey in this.tilesLoadingKeys_)) {
        this.tilesLoadingKeys_[tileKey] = true;
        ++this.tilesLoading_;
        ++newLoads;
        tile.load();
      }
    }
    if (newLoads === 0 && abortedTiles) {
      // Do not stop the render loop when all wanted tiles were aborted due to
      // a small, saturated tile cache.
      this.tileChangeCallback_();
    }
  };

  return TileQueue;
}(_structs_PriorityQueue_js__WEBPACK_IMPORTED_MODULE_3__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (TileQueue);

//# sourceMappingURL=TileQueue.js.map

/***/ }),

/***/ "./node_modules/ol/TileRange.js":
/*!**************************************!*\
  !*** ./node_modules/ol/TileRange.js ***!
  \**************************************/
/*! exports provided: createOrUpdate, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdate", function() { return createOrUpdate; });
/**
 * @module ol/TileRange
 */

/**
 * A representation of a contiguous block of tiles.  A tile range is specified
 * by its min/max tile coordinates and is inclusive of coordinates.
 */
var TileRange = function TileRange(minX, maxX, minY, maxY) {

  /**
   * @type {number}
   */
  this.minX = minX;

  /**
   * @type {number}
   */
  this.maxX = maxX;

  /**
   * @type {number}
   */
  this.minY = minY;

  /**
   * @type {number}
   */
  this.maxY = maxY;

};

/**
 * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @return {boolean} Contains tile coordinate.
 */
TileRange.prototype.contains = function contains (tileCoord) {
  return this.containsXY(tileCoord[1], tileCoord[2]);
};

/**
 * @param {TileRange} tileRange Tile range.
 * @return {boolean} Contains.
 */
TileRange.prototype.containsTileRange = function containsTileRange (tileRange) {
  return this.minX <= tileRange.minX && tileRange.maxX <= this.maxX &&
     this.minY <= tileRange.minY && tileRange.maxY <= this.maxY;
};

/**
 * @param {number} x Tile coordinate x.
 * @param {number} y Tile coordinate y.
 * @return {boolean} Contains coordinate.
 */
TileRange.prototype.containsXY = function containsXY (x, y) {
  return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
};

/**
 * @param {TileRange} tileRange Tile range.
 * @return {boolean} Equals.
 */
TileRange.prototype.equals = function equals (tileRange) {
  return this.minX == tileRange.minX && this.minY == tileRange.minY &&
     this.maxX == tileRange.maxX && this.maxY == tileRange.maxY;
};

/**
 * @param {TileRange} tileRange Tile range.
 */
TileRange.prototype.extend = function extend (tileRange) {
  if (tileRange.minX < this.minX) {
    this.minX = tileRange.minX;
  }
  if (tileRange.maxX > this.maxX) {
    this.maxX = tileRange.maxX;
  }
  if (tileRange.minY < this.minY) {
    this.minY = tileRange.minY;
  }
  if (tileRange.maxY > this.maxY) {
    this.maxY = tileRange.maxY;
  }
};

/**
 * @return {number} Height.
 */
TileRange.prototype.getHeight = function getHeight () {
  return this.maxY - this.minY + 1;
};

/**
 * @return {import("./size.js").Size} Size.
 */
TileRange.prototype.getSize = function getSize () {
  return [this.getWidth(), this.getHeight()];
};

/**
 * @return {number} Width.
 */
TileRange.prototype.getWidth = function getWidth () {
  return this.maxX - this.minX + 1;
};

/**
 * @param {TileRange} tileRange Tile range.
 * @return {boolean} Intersects.
 */
TileRange.prototype.intersects = function intersects (tileRange) {
  return this.minX <= tileRange.maxX &&
     this.maxX >= tileRange.minX &&
     this.minY <= tileRange.maxY &&
     this.maxY >= tileRange.minY;
};


/**
 * @param {number} minX Minimum X.
 * @param {number} maxX Maximum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxY Maximum Y.
 * @param {TileRange=} tileRange TileRange.
 * @return {TileRange} Tile range.
 */
function createOrUpdate(minX, maxX, minY, maxY, tileRange) {
  if (tileRange !== undefined) {
    tileRange.minX = minX;
    tileRange.maxX = maxX;
    tileRange.minY = minY;
    tileRange.maxY = maxY;
    return tileRange;
  } else {
    return new TileRange(minX, maxX, minY, maxY);
  }
}


/* harmony default export */ __webpack_exports__["default"] = (TileRange);

//# sourceMappingURL=TileRange.js.map

/***/ }),

/***/ "./node_modules/ol/TileState.js":
/*!**************************************!*\
  !*** ./node_modules/ol/TileState.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/TileState
 */

/**
 * @enum {number}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  /**
   * Indicates that tile loading failed
   * @type {number}
   */
  ERROR: 3,
  EMPTY: 4,
  ABORT: 5
});

//# sourceMappingURL=TileState.js.map

/***/ }),

/***/ "./node_modules/ol/View.js":
/*!*********************************!*\
  !*** ./node_modules/ol/View.js ***!
  \*********************************/
/*! exports provided: createCenterConstraint, createResolutionConstraint, createRotationConstraint, isNoopAnimation, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createCenterConstraint", function() { return createCenterConstraint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createResolutionConstraint", function() { return createResolutionConstraint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createRotationConstraint", function() { return createRotationConstraint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNoopAnimation", function() { return isNoopAnimation; });
/* harmony import */ var _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tilegrid/common.js */ "./node_modules/ol/tilegrid/common.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _centerconstraint_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./centerconstraint.js */ "./node_modules/ol/centerconstraint.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _resolutionconstraint_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./resolutionconstraint.js */ "./node_modules/ol/resolutionconstraint.js");
/* harmony import */ var _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./rotationconstraint.js */ "./node_modules/ol/rotationconstraint.js");
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ViewHint.js */ "./node_modules/ol/ViewHint.js");
/* harmony import */ var _ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ViewProperty.js */ "./node_modules/ol/ViewProperty.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./coordinate.js */ "./node_modules/ol/coordinate.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./easing.js */ "./node_modules/ol/easing.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./geom/Polygon.js */ "./node_modules/ol/geom/Polygon.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _proj_Units_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./proj/Units.js */ "./node_modules/ol/proj/Units.js");
/**
 * @module ol/View
 */






















/**
 * An animation configuration
 *
 * @typedef {Object} Animation
 * @property {import("./coordinate.js").Coordinate} [sourceCenter]
 * @property {import("./coordinate.js").Coordinate} [targetCenter]
 * @property {number} [sourceResolution]
 * @property {number} [targetResolution]
 * @property {number} [sourceRotation]
 * @property {number} [targetRotation]
 * @property {import("./coordinate.js").Coordinate} [anchor]
 * @property {number} start
 * @property {number} duration
 * @property {boolean} complete
 * @property {function(number):number} easing
 * @property {function(boolean)} callback
 */


/**
 * @typedef {Object} Constraints
 * @property {import("./centerconstraint.js").Type} center
 * @property {import("./resolutionconstraint.js").Type} resolution
 * @property {import("./rotationconstraint.js").Type} rotation
 */


/**
 * @typedef {Object} FitOptions
 * @property {import("./size.js").Size} [size] The size in pixels of the box to fit
 * the extent into. Default is the current size of the first map in the DOM that
 * uses this view, or `[100, 100]` if no such map is found.
 * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in pixels) to be
 * cleared inside the view. Values in the array are top, right, bottom and left
 * padding.
 * @property {boolean} [constrainResolution=true] Constrain the resolution.
 * @property {boolean} [nearest=false] If `constrainResolution` is `true`, get
 * the nearest extent instead of the closest that actually fits the view.
 * @property {number} [minResolution=0] Minimum resolution that we zoom to.
 * @property {number} [maxZoom] Maximum zoom level that we zoom to. If
 * `minResolution` is given, this property is ignored.
 * @property {number} [duration] The duration of the animation in milliseconds.
 * By default, there is no animation to the target extent.
 * @property {function(number):number} [easing] The easing function used during
 * the animation (defaults to {@link module:ol/easing~inAndOut}).
 * The function will be called for each frame with a number representing a
 * fraction of the animation's duration.  The function should return a number
 * between 0 and 1 representing the progress toward the destination state.
 * @property {function(boolean)} [callback] Function called when the view is in
 * its final position. The callback will be called with `true` if the animation
 * series completed on its own or `false` if it was cancelled.
 */


/**
 * @typedef {Object} ViewOptions
 * @property {import("./coordinate.js").Coordinate} [center] The initial center for
 * the view. The coordinate system for the center is specified with the
 * `projection` option. Layer sources will not be fetched if this is not set,
 * but the center can be set later with {@link #setCenter}.
 * @property {boolean|number} [constrainRotation=true] Rotation constraint.
 * `false` means no constraint. `true` means no constraint, but snap to zero
 * near zero. A number constrains the rotation to that number of values. For
 * example, `4` will constrain the rotation to 0, 90, 180, and 270 degrees.
 * @property {boolean} [enableRotation=true] Enable rotation.
 * If `false`, a rotation constraint that always sets the rotation to zero is
 * used. The `constrainRotation` option has no effect if `enableRotation` is
 * `false`.
 * @property {import("./extent.js").Extent} [extent] The extent that constrains the
 * center, in other words, center cannot be set outside this extent.
 * @property {number} [maxResolution] The maximum resolution used to determine
 * the resolution constraint. It is used together with `minResolution` (or
 * `maxZoom`) and `zoomFactor`. If unspecified it is calculated in such a way
 * that the projection's validity extent fits in a 256x256 px tile. If the
 * projection is Spherical Mercator (the default) then `maxResolution` defaults
 * to `40075016.68557849 / 256 = 156543.03392804097`.
 * @property {number} [minResolution] The minimum resolution used to determine
 * the resolution constraint.  It is used together with `maxResolution` (or
 * `minZoom`) and `zoomFactor`.  If unspecified it is calculated assuming 29
 * zoom levels (with a factor of 2). If the projection is Spherical Mercator
 * (the default) then `minResolution` defaults to
 * `40075016.68557849 / 256 / Math.pow(2, 28) = 0.0005831682455839253`.
 * @property {number} [maxZoom=28] The maximum zoom level used to determine the
 * resolution constraint. It is used together with `minZoom` (or
 * `maxResolution`) and `zoomFactor`.  Note that if `minResolution` is also
 * provided, it is given precedence over `maxZoom`.
 * @property {number} [minZoom=0] The minimum zoom level used to determine the
 * resolution constraint. It is used together with `maxZoom` (or
 * `minResolution`) and `zoomFactor`.  Note that if `maxResolution` is also
 * provided, it is given precedence over `minZoom`.
 * @property {import("./proj.js").ProjectionLike} [projection='EPSG:3857'] The
 * projection. The default is Spherical Mercator.
 * @property {number} [resolution] The initial resolution for the view. The
 * units are `projection` units per pixel (e.g. meters per pixel). An
 * alternative to setting this is to set `zoom`. Layer sources will not be
 * fetched if neither this nor `zoom` are defined, but they can be set later
 * with {@link #setZoom} or {@link #setResolution}.
 * @property {Array<number>} [resolutions] Resolutions to determine the
 * resolution constraint. If set the `maxResolution`, `minResolution`,
 * `minZoom`, `maxZoom`, and `zoomFactor` options are ignored.
 * @property {number} [rotation=0] The initial rotation for the view in radians
 * (positive rotation clockwise, 0 means North).
 * @property {number} [zoom] Only used if `resolution` is not defined. Zoom
 * level used to calculate the initial resolution for the view. The initial
 * resolution is determined using the {@link #constrainResolution} method.
 * @property {number} [zoomFactor=2] The zoom factor used to determine the
 * resolution constraint.
 */


/**
 * @typedef {Object} AnimationOptions
 * @property {import("./coordinate.js").Coordinate} [center] The center of the view at the end of
 * the animation.
 * @property {number} [zoom] The zoom level of the view at the end of the
 * animation. This takes precedence over `resolution`.
 * @property {number} [resolution] The resolution of the view at the end
 * of the animation.  If `zoom` is also provided, this option will be ignored.
 * @property {number} [rotation] The rotation of the view at the end of
 * the animation.
 * @property {import("./coordinate.js").Coordinate} [anchor] Optional anchor to remained fixed
 * during a rotation or resolution animation.
 * @property {number} [duration=1000] The duration of the animation in milliseconds.
 * @property {function(number):number} [easing] The easing function used
 * during the animation (defaults to {@link module:ol/easing~inAndOut}).
 * The function will be called for each frame with a number representing a
 * fraction of the animation's duration.  The function should return a number
 * between 0 and 1 representing the progress toward the destination state.
 */


/**
 * @typedef {Object} State
 * @property {import("./coordinate.js").Coordinate} center
 * @property {import("./proj/Projection.js").default} projection
 * @property {number} resolution
 * @property {number} rotation
 * @property {number} zoom
 */


/**
 * Default min zoom level for the map view.
 * @type {number}
 */
var DEFAULT_MIN_ZOOM = 0;


/**
 * @classdesc
 * A View object represents a simple 2D view of the map.
 *
 * This is the object to act upon to change the center, resolution,
 * and rotation of the map.
 *
 * ### The view states
 *
 * An View is determined by three states: `center`, `resolution`,
 * and `rotation`. Each state has a corresponding getter and setter, e.g.
 * `getCenter` and `setCenter` for the `center` state.
 *
 * An View has a `projection`. The projection determines the
 * coordinate system of the center, and its units determine the units of the
 * resolution (projection units per pixel). The default projection is
 * Spherical Mercator (EPSG:3857).
 *
 * ### The constraints
 *
 * `setCenter`, `setResolution` and `setRotation` can be used to change the
 * states of the view. Any value can be passed to the setters. And the value
 * that is passed to a setter will effectively be the value set in the view,
 * and returned by the corresponding getter.
 *
 * But a View object also has a *resolution constraint*, a
 * *rotation constraint* and a *center constraint*.
 *
 * As said above, no constraints are applied when the setters are used to set
 * new states for the view. Applying constraints is done explicitly through
 * the use of the `constrain*` functions (`constrainResolution` and
 * `constrainRotation` and `constrainCenter`).
 *
 * The main users of the constraints are the interactions and the
 * controls. For example, double-clicking on the map changes the view to
 * the "next" resolution. And releasing the fingers after pinch-zooming
 * snaps to the closest resolution (with an animation).
 *
 * The *resolution constraint* snaps to specific resolutions. It is
 * determined by the following options: `resolutions`, `maxResolution`,
 * `maxZoom`, and `zoomFactor`. If `resolutions` is set, the other three
 * options are ignored. See documentation for each option for more
 * information.
 *
 * The *rotation constraint* snaps to specific angles. It is determined
 * by the following options: `enableRotation` and `constrainRotation`.
 * By default the rotation value is snapped to zero when approaching the
 * horizontal.
 *
 * The *center constraint* is determined by the `extent` option. By
 * default the center is not constrained at all.
 *
  * @api
 */
var View = /*@__PURE__*/(function (BaseObject) {
  function View(opt_options) {
    BaseObject.call(this);

    var options = Object(_obj_js__WEBPACK_IMPORTED_MODULE_17__["assign"])({}, opt_options);

    /**
     * @private
     * @type {Array<number>}
     */
    this.hints_ = [0, 0];

    /**
     * @private
     * @type {Array<Array<Animation>>}
     */
    this.animations_ = [];

    /**
     * @private
     * @type {number|undefined}
     */
    this.updateAnimationKey_;

    this.updateAnimations_ = this.updateAnimations_.bind(this);

    /**
     * @private
     * @const
     * @type {import("./proj/Projection.js").default}
     */
    this.projection_ = Object(_proj_js__WEBPACK_IMPORTED_MODULE_18__["createProjection"])(options.projection, 'EPSG:3857');

    this.applyOptions_(options);
  }

  if ( BaseObject ) View.__proto__ = BaseObject;
  View.prototype = Object.create( BaseObject && BaseObject.prototype );
  View.prototype.constructor = View;

  /**
   * Set up the view with the given options.
   * @param {ViewOptions} options View options.
   */
  View.prototype.applyOptions_ = function applyOptions_ (options) {

    /**
     * @type {Object<string, *>}
     */
    var properties = {};
    properties[_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].CENTER] = options.center !== undefined ?
      options.center : null;

    var resolutionConstraintInfo = createResolutionConstraint(options);

    /**
     * @private
     * @type {number}
     */
    this.maxResolution_ = resolutionConstraintInfo.maxResolution;

    /**
     * @private
     * @type {number}
     */
    this.minResolution_ = resolutionConstraintInfo.minResolution;

    /**
     * @private
     * @type {number}
     */
    this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;

    /**
     * @private
     * @type {Array<number>|undefined}
     */
    this.resolutions_ = options.resolutions;

    /**
     * @private
     * @type {number}
     */
    this.minZoom_ = resolutionConstraintInfo.minZoom;

    var centerConstraint = createCenterConstraint(options);
    var resolutionConstraint = resolutionConstraintInfo.constraint;
    var rotationConstraint = createRotationConstraint(options);

    /**
     * @private
     * @type {Constraints}
     */
    this.constraints_ = {
      center: centerConstraint,
      resolution: resolutionConstraint,
      rotation: rotationConstraint
    };

    if (options.resolution !== undefined) {
      properties[_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].RESOLUTION] = options.resolution;
    } else if (options.zoom !== undefined) {
      properties[_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].RESOLUTION] = this.constrainResolution(
        this.maxResolution_, options.zoom - this.minZoom_);

      if (this.resolutions_) { // in case map zoom is out of min/max zoom range
        properties[_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].RESOLUTION] = Object(_math_js__WEBPACK_IMPORTED_MODULE_16__["clamp"])(
          Number(this.getResolution() || properties[_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].RESOLUTION]),
          this.minResolution_, this.maxResolution_);
      }
    }
    properties[_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].ROTATION] = options.rotation !== undefined ? options.rotation : 0;
    this.setProperties(properties);

    /**
     * @private
     * @type {ViewOptions}
     */
    this.options_ = options;

  };

  /**
   * Get an updated version of the view options used to construct the view.  The
   * current resolution (or zoom), center, and rotation are applied to any stored
   * options.  The provided options can be used to apply new min/max zoom or
   * resolution limits.
   * @param {ViewOptions} newOptions New options to be applied.
   * @return {ViewOptions} New options updated with the current view state.
   */
  View.prototype.getUpdatedOptions_ = function getUpdatedOptions_ (newOptions) {
    var options = Object(_obj_js__WEBPACK_IMPORTED_MODULE_17__["assign"])({}, this.options_);

    // preserve resolution (or zoom)
    if (options.resolution !== undefined) {
      options.resolution = this.getResolution();
    } else {
      options.zoom = this.getZoom();
    }

    // preserve center
    options.center = this.getCenter();

    // preserve rotation
    options.rotation = this.getRotation();

    return Object(_obj_js__WEBPACK_IMPORTED_MODULE_17__["assign"])({}, options, newOptions);
  };

  /**
   * Animate the view.  The view's center, zoom (or resolution), and rotation
   * can be animated for smooth transitions between view states.  For example,
   * to animate the view to a new zoom level:
   *
   *     view.animate({zoom: view.getZoom() + 1});
   *
   * By default, the animation lasts one second and uses in-and-out easing.  You
   * can customize this behavior by including `duration` (in milliseconds) and
   * `easing` options (see {@link module:ol/easing}).
   *
   * To chain together multiple animations, call the method with multiple
   * animation objects.  For example, to first zoom and then pan:
   *
   *     view.animate({zoom: 10}, {center: [0, 0]});
   *
   * If you provide a function as the last argument to the animate method, it
   * will get called at the end of an animation series.  The callback will be
   * called with `true` if the animation series completed on its own or `false`
   * if it was cancelled.
   *
   * Animations are cancelled by user interactions (e.g. dragging the map) or by
   * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
   * (or another method that calls one of these).
   *
   * @param {...(AnimationOptions|function(boolean))} var_args Animation
   *     options.  Multiple animations can be run in series by passing multiple
   *     options objects.  To run multiple animations in parallel, call the method
   *     multiple times.  An optional callback can be provided as a final
   *     argument.  The callback will be called with a boolean indicating whether
   *     the animation completed without being cancelled.
   * @api
   */
  View.prototype.animate = function animate (var_args) {
    var arguments$1 = arguments;

    var animationCount = arguments.length;
    var callback;
    if (animationCount > 1 && typeof arguments[animationCount - 1] === 'function') {
      callback = arguments[animationCount - 1];
      --animationCount;
    }
    if (!this.isDef()) {
      // if view properties are not yet set, shortcut to the final state
      var state = arguments[animationCount - 1];
      if (state.center) {
        this.setCenter(state.center);
      }
      if (state.zoom !== undefined) {
        this.setZoom(state.zoom);
      }
      if (state.rotation !== undefined) {
        this.setRotation(state.rotation);
      }
      if (callback) {
        animationCallback(callback, true);
      }
      return;
    }
    var start = Date.now();
    var center = this.getCenter().slice();
    var resolution = this.getResolution();
    var rotation = this.getRotation();
    var series = [];
    for (var i = 0; i < animationCount; ++i) {
      var options = /** @type {AnimationOptions} */ (arguments$1[i]);

      var animation = /** @type {Animation} */ ({
        start: start,
        complete: false,
        anchor: options.anchor,
        duration: options.duration !== undefined ? options.duration : 1000,
        easing: options.easing || _easing_js__WEBPACK_IMPORTED_MODULE_12__["inAndOut"]
      });

      if (options.center) {
        animation.sourceCenter = center;
        animation.targetCenter = options.center;
        center = animation.targetCenter;
      }

      if (options.zoom !== undefined) {
        animation.sourceResolution = resolution;
        animation.targetResolution = this.constrainResolution(
          this.maxResolution_, options.zoom - this.minZoom_, 0);
        resolution = animation.targetResolution;
      } else if (options.resolution) {
        animation.sourceResolution = resolution;
        animation.targetResolution = options.resolution;
        resolution = animation.targetResolution;
      }

      if (options.rotation !== undefined) {
        animation.sourceRotation = rotation;
        var delta = Object(_math_js__WEBPACK_IMPORTED_MODULE_16__["modulo"])(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
        animation.targetRotation = rotation + delta;
        rotation = animation.targetRotation;
      }

      animation.callback = callback;

      // check if animation is a no-op
      if (isNoopAnimation(animation)) {
        animation.complete = true;
        // we still push it onto the series for callback handling
      } else {
        start += animation.duration;
      }
      series.push(animation);
    }
    this.animations_.push(series);
    this.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_7__["default"].ANIMATING, 1);
    this.updateAnimations_();
  };

  /**
   * Determine if the view is being animated.
   * @return {boolean} The view is being animated.
   * @api
   */
  View.prototype.getAnimating = function getAnimating () {
    return this.hints_[_ViewHint_js__WEBPACK_IMPORTED_MODULE_7__["default"].ANIMATING] > 0;
  };

  /**
   * Determine if the user is interacting with the view, such as panning or zooming.
   * @return {boolean} The view is being interacted with.
   * @api
   */
  View.prototype.getInteracting = function getInteracting () {
    return this.hints_[_ViewHint_js__WEBPACK_IMPORTED_MODULE_7__["default"].INTERACTING] > 0;
  };

  /**
   * Cancel any ongoing animations.
   * @api
   */
  View.prototype.cancelAnimations = function cancelAnimations () {
    this.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_7__["default"].ANIMATING, -this.hints_[_ViewHint_js__WEBPACK_IMPORTED_MODULE_7__["default"].ANIMATING]);
    for (var i = 0, ii = this.animations_.length; i < ii; ++i) {
      var series = this.animations_[i];
      if (series[0].callback) {
        animationCallback(series[0].callback, false);
      }
    }
    this.animations_.length = 0;
  };

  /**
   * Update all animations.
   */
  View.prototype.updateAnimations_ = function updateAnimations_ () {
    if (this.updateAnimationKey_ !== undefined) {
      cancelAnimationFrame(this.updateAnimationKey_);
      this.updateAnimationKey_ = undefined;
    }
    if (!this.getAnimating()) {
      return;
    }
    var now = Date.now();
    var more = false;
    for (var i = this.animations_.length - 1; i >= 0; --i) {
      var series = this.animations_[i];
      var seriesComplete = true;
      for (var j = 0, jj = series.length; j < jj; ++j) {
        var animation = series[j];
        if (animation.complete) {
          continue;
        }
        var elapsed = now - animation.start;
        var fraction = animation.duration > 0 ? elapsed / animation.duration : 1;
        if (fraction >= 1) {
          animation.complete = true;
          fraction = 1;
        } else {
          seriesComplete = false;
        }
        var progress = animation.easing(fraction);
        if (animation.sourceCenter) {
          var x0 = animation.sourceCenter[0];
          var y0 = animation.sourceCenter[1];
          var x1 = animation.targetCenter[0];
          var y1 = animation.targetCenter[1];
          var x = x0 + progress * (x1 - x0);
          var y = y0 + progress * (y1 - y0);
          this.set(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].CENTER, [x, y]);
        }
        if (animation.sourceResolution && animation.targetResolution) {
          var resolution = progress === 1 ?
            animation.targetResolution :
            animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);
          if (animation.anchor) {
            this.set(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].CENTER,
              this.calculateCenterZoom(resolution, animation.anchor));
          }
          this.set(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].RESOLUTION, resolution);
        }
        if (animation.sourceRotation !== undefined && animation.targetRotation !== undefined) {
          var rotation = progress === 1 ?
            Object(_math_js__WEBPACK_IMPORTED_MODULE_16__["modulo"])(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI :
            animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);
          if (animation.anchor) {
            this.set(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].CENTER,
              this.calculateCenterRotate(rotation, animation.anchor));
          }
          this.set(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].ROTATION, rotation);
        }
        more = true;
        if (!animation.complete) {
          break;
        }
      }
      if (seriesComplete) {
        this.animations_[i] = null;
        this.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_7__["default"].ANIMATING, -1);
        var callback = series[0].callback;
        if (callback) {
          animationCallback(callback, true);
        }
      }
    }
    // prune completed series
    this.animations_ = this.animations_.filter(Boolean);
    if (more && this.updateAnimationKey_ === undefined) {
      this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_);
    }
  };

  /**
   * @param {number} rotation Target rotation.
   * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
   */
  View.prototype.calculateCenterRotate = function calculateCenterRotate (rotation, anchor) {
    var center;
    var currentCenter = this.getCenter();
    if (currentCenter !== undefined) {
      center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];
      Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_11__["rotate"])(center, rotation - this.getRotation());
      Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_11__["add"])(center, anchor);
    }
    return center;
  };

  /**
   * @param {number} resolution Target resolution.
   * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
   */
  View.prototype.calculateCenterZoom = function calculateCenterZoom (resolution, anchor) {
    var center;
    var currentCenter = this.getCenter();
    var currentResolution = this.getResolution();
    if (currentCenter !== undefined && currentResolution !== undefined) {
      var x = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;
      var y = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;
      center = [x, y];
    }
    return center;
  };

  /**
   * @private
   * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
   */
  View.prototype.getSizeFromViewport_ = function getSizeFromViewport_ () {
    var size = [100, 100];
    var selector = '.ol-viewport[data-view="' + Object(_util_js__WEBPACK_IMPORTED_MODULE_1__["getUid"])(this) + '"]';
    var element = document.querySelector(selector);
    if (element) {
      var metrics = getComputedStyle(element);
      size[0] = parseInt(metrics.width, 10);
      size[1] = parseInt(metrics.height, 10);
    }
    return size;
  };

  /**
   * Get the constrained center of this view.
   * @param {import("./coordinate.js").Coordinate|undefined} center Center.
   * @return {import("./coordinate.js").Coordinate|undefined} Constrained center.
   * @api
   */
  View.prototype.constrainCenter = function constrainCenter (center) {
    return this.constraints_.center(center);
  };

  /**
   * Get the constrained resolution of this view.
   * @param {number|undefined} resolution Resolution.
   * @param {number=} opt_delta Delta. Default is `0`.
   * @param {number=} opt_direction Direction. Default is `0`.
   * @return {number|undefined} Constrained resolution.
   * @api
   */
  View.prototype.constrainResolution = function constrainResolution (resolution, opt_delta, opt_direction) {
    var delta = opt_delta || 0;
    var direction = opt_direction || 0;
    return this.constraints_.resolution(resolution, delta, direction);
  };

  /**
   * Get the constrained rotation of this view.
   * @param {number|undefined} rotation Rotation.
   * @param {number=} opt_delta Delta. Default is `0`.
   * @return {number|undefined} Constrained rotation.
   * @api
   */
  View.prototype.constrainRotation = function constrainRotation (rotation, opt_delta) {
    var delta = opt_delta || 0;
    return this.constraints_.rotation(rotation, delta);
  };

  /**
   * Get the view center.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   * @observable
   * @api
   */
  View.prototype.getCenter = function getCenter () {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */ (this.get(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].CENTER))
    );
  };

  /**
   * @return {Constraints} Constraints.
   */
  View.prototype.getConstraints = function getConstraints () {
    return this.constraints_;
  };

  /**
   * @param {Array<number>=} opt_hints Destination array.
   * @return {Array<number>} Hint.
   */
  View.prototype.getHints = function getHints (opt_hints) {
    if (opt_hints !== undefined) {
      opt_hints[0] = this.hints_[0];
      opt_hints[1] = this.hints_[1];
      return opt_hints;
    } else {
      return this.hints_.slice();
    }
  };

  /**
   * Calculate the extent for the current view state and the passed size.
   * The size is the pixel dimensions of the box into which the calculated extent
   * should fit. In most cases you want to get the extent of the entire map,
   * that is `map.getSize()`.
   * @param {import("./size.js").Size=} opt_size Box pixel size. If not provided, the size of the
   * first map that uses this view will be used.
   * @return {import("./extent.js").Extent} Extent.
   * @api
   */
  View.prototype.calculateExtent = function calculateExtent (opt_size) {
    var size = opt_size || this.getSizeFromViewport_();
    var center = /** @type {!import("./coordinate.js").Coordinate} */ (this.getCenter());
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_10__["assert"])(center, 1); // The view center is not defined
    var resolution = /** @type {!number} */ (this.getResolution());
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_10__["assert"])(resolution !== undefined, 2); // The view resolution is not defined
    var rotation = /** @type {!number} */ (this.getRotation());
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_10__["assert"])(rotation !== undefined, 3); // The view rotation is not defined

    return Object(_extent_js__WEBPACK_IMPORTED_MODULE_13__["getForViewAndSize"])(center, resolution, rotation, size);
  };

  /**
   * Get the maximum resolution of the view.
   * @return {number} The maximum resolution of the view.
   * @api
   */
  View.prototype.getMaxResolution = function getMaxResolution () {
    return this.maxResolution_;
  };

  /**
   * Get the minimum resolution of the view.
   * @return {number} The minimum resolution of the view.
   * @api
   */
  View.prototype.getMinResolution = function getMinResolution () {
    return this.minResolution_;
  };

  /**
   * Get the maximum zoom level for the view.
   * @return {number} The maximum zoom level.
   * @api
   */
  View.prototype.getMaxZoom = function getMaxZoom () {
    return /** @type {number} */ (this.getZoomForResolution(this.minResolution_));
  };

  /**
   * Set a new maximum zoom level for the view.
   * @param {number} zoom The maximum zoom level.
   * @api
   */
  View.prototype.setMaxZoom = function setMaxZoom (zoom) {
    this.applyOptions_(this.getUpdatedOptions_({maxZoom: zoom}));
  };

  /**
   * Get the minimum zoom level for the view.
   * @return {number} The minimum zoom level.
   * @api
   */
  View.prototype.getMinZoom = function getMinZoom () {
    return /** @type {number} */ (this.getZoomForResolution(this.maxResolution_));
  };

  /**
   * Set a new minimum zoom level for the view.
   * @param {number} zoom The minimum zoom level.
   * @api
   */
  View.prototype.setMinZoom = function setMinZoom (zoom) {
    this.applyOptions_(this.getUpdatedOptions_({minZoom: zoom}));
  };

  /**
   * Get the view projection.
   * @return {import("./proj/Projection.js").default} The projection of the view.
   * @api
   */
  View.prototype.getProjection = function getProjection () {
    return this.projection_;
  };

  /**
   * Get the view resolution.
   * @return {number|undefined} The resolution of the view.
   * @observable
   * @api
   */
  View.prototype.getResolution = function getResolution () {
    return /** @type {number|undefined} */ (this.get(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].RESOLUTION));
  };

  /**
   * Get the resolutions for the view. This returns the array of resolutions
   * passed to the constructor of the View, or undefined if none were given.
   * @return {Array<number>|undefined} The resolutions of the view.
   * @api
   */
  View.prototype.getResolutions = function getResolutions () {
    return this.resolutions_;
  };

  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size=} opt_size Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   * @api
   */
  View.prototype.getResolutionForExtent = function getResolutionForExtent (extent, opt_size) {
    var size = opt_size || this.getSizeFromViewport_();
    var xResolution = Object(_extent_js__WEBPACK_IMPORTED_MODULE_13__["getWidth"])(extent) / size[0];
    var yResolution = Object(_extent_js__WEBPACK_IMPORTED_MODULE_13__["getHeight"])(extent) / size[1];
    return Math.max(xResolution, yResolution);
  };

  /**
   * Return a function that returns a value between 0 and 1 for a
   * resolution. Exponential scaling is assumed.
   * @param {number=} opt_power Power.
   * @return {function(number): number} Resolution for value function.
   */
  View.prototype.getResolutionForValueFunction = function getResolutionForValueFunction (opt_power) {
    var power = opt_power || 2;
    var maxResolution = this.maxResolution_;
    var minResolution = this.minResolution_;
    var max = Math.log(maxResolution / minResolution) / Math.log(power);
    return (
      /**
       * @param {number} value Value.
       * @return {number} Resolution.
       */
      function(value) {
        var resolution = maxResolution / Math.pow(power, value * max);
        return resolution;
      });
  };

  /**
   * Get the view rotation.
   * @return {number} The rotation of the view in radians.
   * @observable
   * @api
   */
  View.prototype.getRotation = function getRotation () {
    return /** @type {number} */ (this.get(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].ROTATION));
  };

  /**
   * Return a function that returns a resolution for a value between
   * 0 and 1. Exponential scaling is assumed.
   * @param {number=} opt_power Power.
   * @return {function(number): number} Value for resolution function.
   */
  View.prototype.getValueForResolutionFunction = function getValueForResolutionFunction (opt_power) {
    var power = opt_power || 2;
    var maxResolution = this.maxResolution_;
    var minResolution = this.minResolution_;
    var max = Math.log(maxResolution / minResolution) / Math.log(power);
    return (
      /**
       * @param {number} resolution Resolution.
       * @return {number} Value.
       */
      function(resolution) {
        var value = (Math.log(maxResolution / resolution) / Math.log(power)) / max;
        return value;
      });
  };

  /**
   * @param {number} pixelRatio Pixel ratio for center rounding.
   * @return {State} View state.
   */
  View.prototype.getState = function getState (pixelRatio) {
    var center = /** @type {import("./coordinate.js").Coordinate} */ (this.getCenter());
    var projection = this.getProjection();
    var resolution = /** @type {number} */ (this.getResolution());
    var pixelResolution = resolution / pixelRatio;
    var rotation = this.getRotation();
    return (
      /** @type {State} */ ({
        center: [
          Math.round(center[0] / pixelResolution) * pixelResolution,
          Math.round(center[1] / pixelResolution) * pixelResolution
        ],
        projection: projection !== undefined ? projection : null,
        resolution: resolution,
        rotation: rotation,
        zoom: this.getZoom()
      })
    );
  };

  /**
   * Get the current zoom level.  If you configured your view with a resolutions
   * array (this is rare), this method may return non-integer zoom levels (so
   * the zoom level is not safe to use as an index into a resolutions array).
   * @return {number|undefined} Zoom.
   * @api
   */
  View.prototype.getZoom = function getZoom () {
    var zoom;
    var resolution = this.getResolution();
    if (resolution !== undefined) {
      zoom = this.getZoomForResolution(resolution);
    }
    return zoom;
  };

  /**
   * Get the zoom level for a resolution.
   * @param {number} resolution The resolution.
   * @return {number|undefined} The zoom level for the provided resolution.
   * @api
   */
  View.prototype.getZoomForResolution = function getZoomForResolution (resolution) {
    var offset = this.minZoom_ || 0;
    var max, zoomFactor;
    if (this.resolutions_) {
      var nearest = Object(_array_js__WEBPACK_IMPORTED_MODULE_9__["linearFindNearest"])(this.resolutions_, resolution, 1);
      offset = nearest;
      max = this.resolutions_[nearest];
      if (nearest == this.resolutions_.length - 1) {
        zoomFactor = 2;
      } else {
        zoomFactor = max / this.resolutions_[nearest + 1];
      }
    } else {
      max = this.maxResolution_;
      zoomFactor = this.zoomFactor_;
    }
    return offset + Math.log(max / resolution) / Math.log(zoomFactor);
  };

  /**
   * Get the resolution for a zoom level.
   * @param {number} zoom Zoom level.
   * @return {number} The view resolution for the provided zoom level.
   * @api
   */
  View.prototype.getResolutionForZoom = function getResolutionForZoom (zoom) {
    return /** @type {number} */ (this.constrainResolution(
      this.maxResolution_, zoom - this.minZoom_, 0));
  };

  /**
   * Fit the given geometry or extent based on the given map size and border.
   * The size is pixel dimensions of the box to fit the extent into.
   * In most cases you will want to use the map size, that is `map.getSize()`.
   * Takes care of the map angle.
   * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
   *     extent to fit the view to.
   * @param {FitOptions=} opt_options Options.
   * @api
   */
  View.prototype.fit = function fit (geometryOrExtent, opt_options) {
    var options = opt_options || {};
    var size = options.size;
    if (!size) {
      size = this.getSizeFromViewport_();
    }
    /** @type {import("./geom/SimpleGeometry.js").default} */
    var geometry;
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_10__["assert"])(Array.isArray(geometryOrExtent) || typeof /** @type {?} */ (geometryOrExtent).getSimplifiedGeometry === 'function',
      24); // Invalid extent or geometry provided as `geometry`
    if (Array.isArray(geometryOrExtent)) {
      Object(_asserts_js__WEBPACK_IMPORTED_MODULE_10__["assert"])(!Object(_extent_js__WEBPACK_IMPORTED_MODULE_13__["isEmpty"])(geometryOrExtent),
        25); // Cannot fit empty extent provided as `geometry`
      geometry = Object(_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_15__["fromExtent"])(geometryOrExtent);
    } else if (geometryOrExtent.getType() === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_14__["default"].CIRCLE) {
      geometryOrExtent = geometryOrExtent.getExtent();
      geometry = Object(_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_15__["fromExtent"])(geometryOrExtent);
      geometry.rotate(this.getRotation(), Object(_extent_js__WEBPACK_IMPORTED_MODULE_13__["getCenter"])(geometryOrExtent));
    } else {
      geometry = geometryOrExtent;
    }

    var padding = options.padding !== undefined ? options.padding : [0, 0, 0, 0];
    var constrainResolution = options.constrainResolution !== undefined ?
      options.constrainResolution : true;
    var nearest = options.nearest !== undefined ? options.nearest : false;
    var minResolution;
    if (options.minResolution !== undefined) {
      minResolution = options.minResolution;
    } else if (options.maxZoom !== undefined) {
      minResolution = this.constrainResolution(
        this.maxResolution_, options.maxZoom - this.minZoom_, 0);
    } else {
      minResolution = 0;
    }
    var coords = geometry.getFlatCoordinates();

    // calculate rotated extent
    var rotation = this.getRotation();
    var cosAngle = Math.cos(-rotation);
    var sinAngle = Math.sin(-rotation);
    var minRotX = +Infinity;
    var minRotY = +Infinity;
    var maxRotX = -Infinity;
    var maxRotY = -Infinity;
    var stride = geometry.getStride();
    for (var i = 0, ii = coords.length; i < ii; i += stride) {
      var rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;
      var rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;
      minRotX = Math.min(minRotX, rotX);
      minRotY = Math.min(minRotY, rotY);
      maxRotX = Math.max(maxRotX, rotX);
      maxRotY = Math.max(maxRotY, rotY);
    }

    // calculate resolution
    var resolution = this.getResolutionForExtent(
      [minRotX, minRotY, maxRotX, maxRotY],
      [size[0] - padding[1] - padding[3], size[1] - padding[0] - padding[2]]);
    resolution = isNaN(resolution) ? minResolution :
      Math.max(resolution, minResolution);
    if (constrainResolution) {
      var constrainedResolution = this.constrainResolution(resolution, 0, 0);
      if (!nearest && constrainedResolution < resolution) {
        constrainedResolution = this.constrainResolution(
          constrainedResolution, -1, 0);
      }
      resolution = constrainedResolution;
    }

    // calculate center
    sinAngle = -sinAngle; // go back to original rotation
    var centerRotX = (minRotX + maxRotX) / 2;
    var centerRotY = (minRotY + maxRotY) / 2;
    centerRotX += (padding[1] - padding[3]) / 2 * resolution;
    centerRotY += (padding[0] - padding[2]) / 2 * resolution;
    var centerX = centerRotX * cosAngle - centerRotY * sinAngle;
    var centerY = centerRotY * cosAngle + centerRotX * sinAngle;
    var center = [centerX, centerY];
    var callback = options.callback ? options.callback : _functions_js__WEBPACK_IMPORTED_MODULE_2__["VOID"];

    if (options.duration !== undefined) {
      this.animate({
        resolution: resolution,
        center: center,
        duration: options.duration,
        easing: options.easing
      }, callback);
    } else {
      this.setResolution(resolution);
      this.setCenter(center);
      animationCallback(callback, true);
    }
  };

  /**
   * Center on coordinate and view position.
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   * @api
   */
  View.prototype.centerOn = function centerOn (coordinate, size, position) {
    // calculate rotated position
    var rotation = this.getRotation();
    var cosAngle = Math.cos(-rotation);
    var sinAngle = Math.sin(-rotation);
    var rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
    var rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
    var resolution = this.getResolution();
    rotX += (size[0] / 2 - position[0]) * resolution;
    rotY += (position[1] - size[1] / 2) * resolution;

    // go back to original angle
    sinAngle = -sinAngle; // go back to original rotation
    var centerX = rotX * cosAngle - rotY * sinAngle;
    var centerY = rotY * cosAngle + rotX * sinAngle;

    this.setCenter([centerX, centerY]);
  };

  /**
   * @return {boolean} Is defined.
   */
  View.prototype.isDef = function isDef () {
    return !!this.getCenter() && this.getResolution() !== undefined;
  };

  /**
   * Rotate the view around a given coordinate.
   * @param {number} rotation New rotation value for the view.
   * @param {import("./coordinate.js").Coordinate=} opt_anchor The rotation center.
   * @api
   */
  View.prototype.rotate = function rotate (rotation, opt_anchor) {
    if (opt_anchor !== undefined) {
      var center = this.calculateCenterRotate(rotation, opt_anchor);
      this.setCenter(center);
    }
    this.setRotation(rotation);
  };

  /**
   * Set the center of the current view.
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   * @observable
   * @api
   */
  View.prototype.setCenter = function setCenter (center) {
    this.set(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].CENTER, center);
    if (this.getAnimating()) {
      this.cancelAnimations();
    }
  };

  /**
   * @param {ViewHint} hint Hint.
   * @param {number} delta Delta.
   * @return {number} New value.
   */
  View.prototype.setHint = function setHint (hint, delta) {
    this.hints_[hint] += delta;
    this.changed();
    return this.hints_[hint];
  };

  /**
   * Set the resolution for this view.
   * @param {number|undefined} resolution The resolution of the view.
   * @observable
   * @api
   */
  View.prototype.setResolution = function setResolution (resolution) {
    this.set(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].RESOLUTION, resolution);
    if (this.getAnimating()) {
      this.cancelAnimations();
    }
  };

  /**
   * Set the rotation for this view.
   * @param {number} rotation The rotation of the view in radians.
   * @observable
   * @api
   */
  View.prototype.setRotation = function setRotation (rotation) {
    this.set(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].ROTATION, rotation);
    if (this.getAnimating()) {
      this.cancelAnimations();
    }
  };

  /**
   * Zoom to a specific zoom level.
   * @param {number} zoom Zoom level.
   * @api
   */
  View.prototype.setZoom = function setZoom (zoom) {
    this.setResolution(this.getResolutionForZoom(zoom));
  };

  return View;
}(_Object_js__WEBPACK_IMPORTED_MODULE_4__["default"]));


/**
 * @param {Function} callback Callback.
 * @param {*} returnValue Return value.
 */
function animationCallback(callback, returnValue) {
  setTimeout(function() {
    callback(returnValue);
  }, 0);
}


/**
 * @param {ViewOptions} options View options.
 * @return {import("./centerconstraint.js").Type} The constraint.
 */
function createCenterConstraint(options) {
  if (options.extent !== undefined) {
    return Object(_centerconstraint_js__WEBPACK_IMPORTED_MODULE_3__["createExtent"])(options.extent);
  } else {
    return _centerconstraint_js__WEBPACK_IMPORTED_MODULE_3__["none"];
  }
}


/**
 * @param {ViewOptions} options View options.
 * @return {{constraint: import("./resolutionconstraint.js").Type, maxResolution: number,
 *     minResolution: number, minZoom: number, zoomFactor: number}} The constraint.
 */
function createResolutionConstraint(options) {
  var resolutionConstraint;
  var maxResolution;
  var minResolution;

  // TODO: move these to be ol constants
  // see https://github.com/openlayers/openlayers/issues/2076
  var defaultMaxZoom = 28;
  var defaultZoomFactor = 2;

  var minZoom = options.minZoom !== undefined ?
    options.minZoom : DEFAULT_MIN_ZOOM;

  var maxZoom = options.maxZoom !== undefined ?
    options.maxZoom : defaultMaxZoom;

  var zoomFactor = options.zoomFactor !== undefined ?
    options.zoomFactor : defaultZoomFactor;

  if (options.resolutions !== undefined) {
    var resolutions = options.resolutions;
    maxResolution = resolutions[minZoom];
    minResolution = resolutions[maxZoom] !== undefined ?
      resolutions[maxZoom] : resolutions[resolutions.length - 1];
    resolutionConstraint = Object(_resolutionconstraint_js__WEBPACK_IMPORTED_MODULE_5__["createSnapToResolutions"])(
      resolutions);
  } else {
    // calculate the default min and max resolution
    var projection = Object(_proj_js__WEBPACK_IMPORTED_MODULE_18__["createProjection"])(options.projection, 'EPSG:3857');
    var extent = projection.getExtent();
    var size = !extent ?
      // use an extent that can fit the whole world if need be
      360 * _proj_js__WEBPACK_IMPORTED_MODULE_18__["METERS_PER_UNIT"][_proj_Units_js__WEBPACK_IMPORTED_MODULE_19__["default"].DEGREES] /
            projection.getMetersPerUnit() :
      Math.max(Object(_extent_js__WEBPACK_IMPORTED_MODULE_13__["getWidth"])(extent), Object(_extent_js__WEBPACK_IMPORTED_MODULE_13__["getHeight"])(extent));

    var defaultMaxResolution = size / _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_TILE_SIZE"] / Math.pow(
      defaultZoomFactor, DEFAULT_MIN_ZOOM);

    var defaultMinResolution = defaultMaxResolution / Math.pow(
      defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);

    // user provided maxResolution takes precedence
    maxResolution = options.maxResolution;
    if (maxResolution !== undefined) {
      minZoom = 0;
    } else {
      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
    }

    // user provided minResolution takes precedence
    minResolution = options.minResolution;
    if (minResolution === undefined) {
      if (options.maxZoom !== undefined) {
        if (options.maxResolution !== undefined) {
          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
        } else {
          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
        }
      } else {
        minResolution = defaultMinResolution;
      }
    }

    // given discrete zoom levels, minResolution may be different than provided
    maxZoom = minZoom + Math.floor(
      Math.log(maxResolution / minResolution) / Math.log(zoomFactor));
    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);

    resolutionConstraint = Object(_resolutionconstraint_js__WEBPACK_IMPORTED_MODULE_5__["createSnapToPower"])(
      zoomFactor, maxResolution, maxZoom - minZoom);
  }
  return {constraint: resolutionConstraint, maxResolution: maxResolution,
    minResolution: minResolution, minZoom: minZoom, zoomFactor: zoomFactor};
}


/**
 * @param {ViewOptions} options View options.
 * @return {import("./rotationconstraint.js").Type} Rotation constraint.
 */
function createRotationConstraint(options) {
  var enableRotation = options.enableRotation !== undefined ?
    options.enableRotation : true;
  if (enableRotation) {
    var constrainRotation = options.constrainRotation;
    if (constrainRotation === undefined || constrainRotation === true) {
      return Object(_rotationconstraint_js__WEBPACK_IMPORTED_MODULE_6__["createSnapToZero"])();
    } else if (constrainRotation === false) {
      return _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_6__["none"];
    } else if (typeof constrainRotation === 'number') {
      return Object(_rotationconstraint_js__WEBPACK_IMPORTED_MODULE_6__["createSnapToN"])(constrainRotation);
    } else {
      return _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_6__["none"];
    }
  } else {
    return _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_6__["disable"];
  }
}


/**
 * Determine if an animation involves no view change.
 * @param {Animation} animation The animation.
 * @return {boolean} The animation involves no view change.
 */
function isNoopAnimation(animation) {
  if (animation.sourceCenter && animation.targetCenter) {
    if (!Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_11__["equals"])(animation.sourceCenter, animation.targetCenter)) {
      return false;
    }
  }
  if (animation.sourceResolution !== animation.targetResolution) {
    return false;
  }
  if (animation.sourceRotation !== animation.targetRotation) {
    return false;
  }
  return true;
}

/* harmony default export */ __webpack_exports__["default"] = (View);

//# sourceMappingURL=View.js.map

/***/ }),

/***/ "./node_modules/ol/ViewHint.js":
/*!*************************************!*\
  !*** ./node_modules/ol/ViewHint.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/ViewHint
 */

/**
 * @enum {number}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  ANIMATING: 0,
  INTERACTING: 1
});

//# sourceMappingURL=ViewHint.js.map

/***/ }),

/***/ "./node_modules/ol/ViewProperty.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/ViewProperty.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/ViewProperty
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  CENTER: 'center',
  RESOLUTION: 'resolution',
  ROTATION: 'rotation'
});

//# sourceMappingURL=ViewProperty.js.map

/***/ }),

/***/ "./node_modules/ol/array.js":
/*!**********************************!*\
  !*** ./node_modules/ol/array.js ***!
  \**********************************/
/*! exports provided: binarySearch, numberSafeCompareFunction, includes, linearFindNearest, reverseSubArray, extend, remove, find, equals, stableSort, findIndex, isSorted */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "binarySearch", function() { return binarySearch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "numberSafeCompareFunction", function() { return numberSafeCompareFunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "includes", function() { return includes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearFindNearest", function() { return linearFindNearest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverseSubArray", function() { return reverseSubArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "remove", function() { return remove; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "find", function() { return find; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stableSort", function() { return stableSort; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findIndex", function() { return findIndex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSorted", function() { return isSorted; });
/**
 * @module ol/array
 */


/**
 * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.
 * https://github.com/darkskyapp/binary-search
 *
 * @param {Array<*>} haystack Items to search through.
 * @param {*} needle The item to look for.
 * @param {Function=} opt_comparator Comparator function.
 * @return {number} The index of the item if found, -1 if not.
 */
function binarySearch(haystack, needle, opt_comparator) {
  var mid, cmp;
  var comparator = opt_comparator || numberSafeCompareFunction;
  var low = 0;
  var high = haystack.length;
  var found = false;

  while (low < high) {
    /* Note that "(low + high) >>> 1" may overflow, and results in a typecast
     * to double (which gives the wrong results). */
    mid = low + (high - low >> 1);
    cmp = +comparator(haystack[mid], needle);

    if (cmp < 0.0) { /* Too low. */
      low = mid + 1;

    } else { /* Key found or too high */
      high = mid;
      found = !cmp;
    }
  }

  /* Key not found. */
  return found ? low : ~low;
}


/**
 * Compare function for array sort that is safe for numbers.
 * @param {*} a The first object to be compared.
 * @param {*} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is less than, equal to, or greater than the second.
 */
function numberSafeCompareFunction(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
}


/**
 * Whether the array contains the given object.
 * @param {Array<*>} arr The array to test for the presence of the element.
 * @param {*} obj The object for which to test.
 * @return {boolean} The object is in the array.
 */
function includes(arr, obj) {
  return arr.indexOf(obj) >= 0;
}


/**
 * @param {Array<number>} arr Array.
 * @param {number} target Target.
 * @param {number} direction 0 means return the nearest, > 0
 *    means return the largest nearest, < 0 means return the
 *    smallest nearest.
 * @return {number} Index.
 */
function linearFindNearest(arr, target, direction) {
  var n = arr.length;
  if (arr[0] <= target) {
    return 0;
  } else if (target <= arr[n - 1]) {
    return n - 1;
  } else {
    var i;
    if (direction > 0) {
      for (i = 1; i < n; ++i) {
        if (arr[i] < target) {
          return i - 1;
        }
      }
    } else if (direction < 0) {
      for (i = 1; i < n; ++i) {
        if (arr[i] <= target) {
          return i;
        }
      }
    } else {
      for (i = 1; i < n; ++i) {
        if (arr[i] == target) {
          return i;
        } else if (arr[i] < target) {
          if (arr[i - 1] - target < target - arr[i]) {
            return i - 1;
          } else {
            return i;
          }
        }
      }
    }
    return n - 1;
  }
}


/**
 * @param {Array<*>} arr Array.
 * @param {number} begin Begin index.
 * @param {number} end End index.
 */
function reverseSubArray(arr, begin, end) {
  while (begin < end) {
    var tmp = arr[begin];
    arr[begin] = arr[end];
    arr[end] = tmp;
    ++begin;
    --end;
  }
}


/**
 * @param {Array<VALUE>} arr The array to modify.
 * @param {!Array<VALUE>|VALUE} data The elements or arrays of elements to add to arr.
 * @template VALUE
 */
function extend(arr, data) {
  var extension = Array.isArray(data) ? data : [data];
  var length = extension.length;
  for (var i = 0; i < length; i++) {
    arr[arr.length] = extension[i];
  }
}


/**
 * @param {Array<VALUE>} arr The array to modify.
 * @param {VALUE} obj The element to remove.
 * @template VALUE
 * @return {boolean} If the element was removed.
 */
function remove(arr, obj) {
  var i = arr.indexOf(obj);
  var found = i > -1;
  if (found) {
    arr.splice(i, 1);
  }
  return found;
}


/**
 * @param {Array<VALUE>} arr The array to search in.
 * @param {function(VALUE, number, ?) : boolean} func The function to compare.
 * @template VALUE
 * @return {VALUE|null} The element found or null.
 */
function find(arr, func) {
  var length = arr.length >>> 0;
  var value;

  for (var i = 0; i < length; i++) {
    value = arr[i];
    if (func(value, i, arr)) {
      return value;
    }
  }
  return null;
}


/**
 * @param {Array|Uint8ClampedArray} arr1 The first array to compare.
 * @param {Array|Uint8ClampedArray} arr2 The second array to compare.
 * @return {boolean} Whether the two arrays are equal.
 */
function equals(arr1, arr2) {
  var len1 = arr1.length;
  if (len1 !== arr2.length) {
    return false;
  }
  for (var i = 0; i < len1; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
}


/**
 * Sort the passed array such that the relative order of equal elements is preverved.
 * See https://en.wikipedia.org/wiki/Sorting_algorithm#Stability for details.
 * @param {Array<*>} arr The array to sort (modifies original).
 * @param {!function(*, *): number} compareFnc Comparison function.
 * @api
 */
function stableSort(arr, compareFnc) {
  var length = arr.length;
  var tmp = Array(arr.length);
  var i;
  for (i = 0; i < length; i++) {
    tmp[i] = {index: i, value: arr[i]};
  }
  tmp.sort(function(a, b) {
    return compareFnc(a.value, b.value) || a.index - b.index;
  });
  for (i = 0; i < arr.length; i++) {
    arr[i] = tmp[i].value;
  }
}


/**
 * @param {Array<*>} arr The array to search in.
 * @param {Function} func Comparison function.
 * @return {number} Return index.
 */
function findIndex(arr, func) {
  var index;
  var found = !arr.every(function(el, idx) {
    index = idx;
    return !func(el, idx, arr);
  });
  return found ? index : -1;
}


/**
 * @param {Array<*>} arr The array to test.
 * @param {Function=} opt_func Comparison function.
 * @param {boolean=} opt_strict Strictly sorted (default false).
 * @return {boolean} Return index.
 */
function isSorted(arr, opt_func, opt_strict) {
  var compare = opt_func || numberSafeCompareFunction;
  return arr.every(function(currentVal, index) {
    if (index === 0) {
      return true;
    }
    var res = compare(arr[index - 1], currentVal);
    return !(res > 0 || opt_strict && res === 0);
  });
}

//# sourceMappingURL=array.js.map

/***/ }),

/***/ "./node_modules/ol/asserts.js":
/*!************************************!*\
  !*** ./node_modules/ol/asserts.js ***!
  \************************************/
/*! exports provided: assert */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return assert; });
/* harmony import */ var _AssertionError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AssertionError.js */ "./node_modules/ol/AssertionError.js");
/**
 * @module ol/asserts
 */


/**
 * @param {*} assertion Assertion we expected to be truthy.
 * @param {number} errorCode Error code.
 */
function assert(assertion, errorCode) {
  if (!assertion) {
    throw new _AssertionError_js__WEBPACK_IMPORTED_MODULE_0__["default"](errorCode);
  }
}

//# sourceMappingURL=asserts.js.map

/***/ }),

/***/ "./node_modules/ol/centerconstraint.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/centerconstraint.js ***!
  \*********************************************/
/*! exports provided: createExtent, none */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createExtent", function() { return createExtent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "none", function() { return none; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/centerconstraint
 */



/**
 * @typedef {function((import("./coordinate.js").Coordinate|undefined)): (import("./coordinate.js").Coordinate|undefined)} Type
 */


/**
 * @param {import("./extent.js").Extent} extent Extent.
 * @return {Type} The constraint.
 */
function createExtent(extent) {
  return (
    /**
     * @param {import("./coordinate.js").Coordinate=} center Center.
     * @return {import("./coordinate.js").Coordinate|undefined} Center.
     */
    function(center) {
      if (center) {
        return [
          Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["clamp"])(center[0], extent[0], extent[2]),
          Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["clamp"])(center[1], extent[1], extent[3])
        ];
      } else {
        return undefined;
      }
    }
  );
}


/**
 * @param {import("./coordinate.js").Coordinate=} center Center.
 * @return {import("./coordinate.js").Coordinate|undefined} Center.
 */
function none(center) {
  return center;
}

//# sourceMappingURL=centerconstraint.js.map

/***/ }),

/***/ "./node_modules/ol/color.js":
/*!**********************************!*\
  !*** ./node_modules/ol/color.js ***!
  \**********************************/
/*! exports provided: asString, fromString, asArray, normalize, toString */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asString", function() { return asString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromString", function() { return fromString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asArray", function() { return asArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toString", function() { return toString; });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/color
 */




/**
 * A color represented as a short array [red, green, blue, alpha].
 * red, green, and blue should be integers in the range 0..255 inclusive.
 * alpha should be a float in the range 0..1 inclusive. If no alpha value is
 * given then `1` will be used.
 * @typedef {Array<number>} Color
 * @api
 */


/**
 * This RegExp matches # followed by 3, 4, 6, or 8 hex digits.
 * @const
 * @type {RegExp}
 * @private
 */
var HEX_COLOR_RE_ = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i;


/**
 * Regular expression for matching potential named color style strings.
 * @const
 * @type {RegExp}
 * @private
 */
var NAMED_COLOR_RE_ = /^([a-z]*)$/i;


/**
 * Return the color as an rgba string.
 * @param {Color|string} color Color.
 * @return {string} Rgba string.
 * @api
 */
function asString(color) {
  if (typeof color === 'string') {
    return color;
  } else {
    return toString(color);
  }
}

/**
 * Return named color as an rgba string.
 * @param {string} color Named color.
 * @return {string} Rgb string.
 */
function fromNamed(color) {
  var el = document.createElement('div');
  el.style.color = color;
  if (el.style.color !== '') {
    document.body.appendChild(el);
    var rgb = getComputedStyle(el).color;
    document.body.removeChild(el);
    return rgb;
  } else {
    return '';
  }
}


/**
 * @param {string} s String.
 * @return {Color} Color.
 */
var fromString = (
  function() {

    // We maintain a small cache of parsed strings.  To provide cheap LRU-like
    // semantics, whenever the cache grows too large we simply delete an
    // arbitrary 25% of the entries.

    /**
     * @const
     * @type {number}
     */
    var MAX_CACHE_SIZE = 1024;

    /**
     * @type {Object<string, Color>}
     */
    var cache = {};

    /**
     * @type {number}
     */
    var cacheSize = 0;

    return (
      /**
       * @param {string} s String.
       * @return {Color} Color.
       */
      function(s) {
        var color;
        if (cache.hasOwnProperty(s)) {
          color = cache[s];
        } else {
          if (cacheSize >= MAX_CACHE_SIZE) {
            var i = 0;
            for (var key in cache) {
              if ((i++ & 3) === 0) {
                delete cache[key];
                --cacheSize;
              }
            }
          }
          color = fromStringInternal_(s);
          cache[s] = color;
          ++cacheSize;
        }
        return color;
      }
    );

  })();

/**
 * Return the color as an array. This function maintains a cache of calculated
 * arrays which means the result should not be modified.
 * @param {Color|string} color Color.
 * @return {Color} Color.
 * @api
 */
function asArray(color) {
  if (Array.isArray(color)) {
    return color;
  } else {
    return fromString(color);
  }
}

/**
 * @param {string} s String.
 * @private
 * @return {Color} Color.
 */
function fromStringInternal_(s) {
  var r, g, b, a, color;

  if (NAMED_COLOR_RE_.exec(s)) {
    s = fromNamed(s);
  }

  if (HEX_COLOR_RE_.exec(s)) { // hex
    var n = s.length - 1; // number of hex digits
    var d; // number of digits per channel
    if (n <= 4) {
      d = 1;
    } else {
      d = 2;
    }
    var hasAlpha = n === 4 || n === 8;
    r = parseInt(s.substr(1 + 0 * d, d), 16);
    g = parseInt(s.substr(1 + 1 * d, d), 16);
    b = parseInt(s.substr(1 + 2 * d, d), 16);
    if (hasAlpha) {
      a = parseInt(s.substr(1 + 3 * d, d), 16);
    } else {
      a = 255;
    }
    if (d == 1) {
      r = (r << 4) + r;
      g = (g << 4) + g;
      b = (b << 4) + b;
      if (hasAlpha) {
        a = (a << 4) + a;
      }
    }
    color = [r, g, b, a / 255];
  } else if (s.indexOf('rgba(') == 0) { // rgba()
    color = s.slice(5, -1).split(',').map(Number);
    normalize(color);
  } else if (s.indexOf('rgb(') == 0) { // rgb()
    color = s.slice(4, -1).split(',').map(Number);
    color.push(1);
    normalize(color);
  } else {
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(false, 14); // Invalid color
  }
  return color;
}


/**
 * TODO this function is only used in the test, we probably shouldn't export it
 * @param {Color} color Color.
 * @return {Color} Clamped color.
 */
function normalize(color) {
  color[0] = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["clamp"])((color[0] + 0.5) | 0, 0, 255);
  color[1] = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["clamp"])((color[1] + 0.5) | 0, 0, 255);
  color[2] = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["clamp"])((color[2] + 0.5) | 0, 0, 255);
  color[3] = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["clamp"])(color[3], 0, 1);
  return color;
}


/**
 * @param {Color} color Color.
 * @return {string} String.
 */
function toString(color) {
  var r = color[0];
  if (r != (r | 0)) {
    r = (r + 0.5) | 0;
  }
  var g = color[1];
  if (g != (g | 0)) {
    g = (g + 0.5) | 0;
  }
  var b = color[2];
  if (b != (b | 0)) {
    b = (b + 0.5) | 0;
  }
  var a = color[3] === undefined ? 1 : color[3];
  return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
}

//# sourceMappingURL=color.js.map

/***/ }),

/***/ "./node_modules/ol/colorlike.js":
/*!**************************************!*\
  !*** ./node_modules/ol/colorlike.js ***!
  \**************************************/
/*! exports provided: asColorLike */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asColorLike", function() { return asColorLike; });
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/ol/color.js");
/**
 * @module ol/colorlike
 */



/**
 * A type accepted by CanvasRenderingContext2D.fillStyle
 * or CanvasRenderingContext2D.strokeStyle.
 * Represents a color, pattern, or gradient. The origin for patterns and
 * gradients as fill style is an increment of 512 css pixels from map coordinate
 * `[0, 0]`. For seamless repeat patterns, width and height of the pattern image
 * must be a factor of two (2, 4, 8, ..., 512).
 *
 * @typedef {string|CanvasPattern|CanvasGradient} ColorLike
 * @api
 */


/**
 * @param {import("./color.js").Color|ColorLike} color Color.
 * @return {ColorLike} The color as an {@link ol/colorlike~ColorLike}.
 * @api
 */
function asColorLike(color) {
  if (Array.isArray(color)) {
    return Object(_color_js__WEBPACK_IMPORTED_MODULE_0__["toString"])(color);
  } else {
    return color;
  }
}

//# sourceMappingURL=colorlike.js.map

/***/ }),

/***/ "./node_modules/ol/control/Attribution.js":
/*!************************************************!*\
  !*** ./node_modules/ol/control/Attribution.js ***!
  \************************************************/
/*! exports provided: render, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _Control_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Control.js */ "./node_modules/ol/control/Control.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../css.js */ "./node_modules/ol/css.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _layer_Layer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../layer/Layer.js */ "./node_modules/ol/layer/Layer.js");
/**
 * @module ol/control/Attribution
 */









/**
 * @typedef {Object} Options
 * @property {string} [className='ol-attribution'] CSS class name.
 * @property {HTMLElement|string} [target] Specify a target if you
 * want the control to be rendered outside of the map's
 * viewport.
 * @property {boolean} [collapsible] Specify if attributions can
 * be collapsed. If not specified, sources control this behavior with their
 * `attributionsCollapsible` setting.
 * @property {boolean} [collapsed=true] Specify if attributions should
 * be collapsed at startup.
 * @property {string} [tipLabel='Attributions'] Text label to use for the button tip.
 * @property {string} [label='i'] Text label to use for the
 * collapsed attributions button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string|HTMLElement} [collapseLabel='»'] Text label to use
 * for the expanded attributions button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {function(import("../MapEvent.js").default)} [render] Function called when
 * the control should be re-rendered. This is called in a `requestAnimationFrame`
 * callback.
 */


/**
 * @classdesc
 * Control to show all the attributions associated with the layer sources
 * in the map. This control is one of the default controls included in maps.
 * By default it will show in the bottom right portion of the map, but this can
 * be changed by using a css selector for `.ol-attribution`.
 *
 * @api
 */
var Attribution = /*@__PURE__*/(function (Control) {
  function Attribution(opt_options) {

    var options = opt_options ? opt_options : {};

    Control.call(this, {
      element: document.createElement('div'),
      render: options.render || render,
      target: options.target
    });

    /**
     * @private
     * @type {HTMLElement}
     */
    this.ulElement_ = document.createElement('ul');

    /**
     * @private
     * @type {boolean}
     */
    this.collapsed_ = options.collapsed !== undefined ? options.collapsed : true;

    /**
     * @private
     * @type {boolean}
     */
    this.overrideCollapsible_ = options.collapsible !== undefined;

    /**
     * @private
     * @type {boolean}
     */
    this.collapsible_ = options.collapsible !== undefined ?
      options.collapsible : true;

    if (!this.collapsible_) {
      this.collapsed_ = false;
    }

    var className = options.className !== undefined ? options.className : 'ol-attribution';

    var tipLabel = options.tipLabel !== undefined ? options.tipLabel : 'Attributions';

    var collapseLabel = options.collapseLabel !== undefined ? options.collapseLabel : '\u00BB';

    if (typeof collapseLabel === 'string') {
      /**
       * @private
       * @type {HTMLElement}
       */
      this.collapseLabel_ = document.createElement('span');
      this.collapseLabel_.textContent = collapseLabel;
    } else {
      this.collapseLabel_ = collapseLabel;
    }

    var label = options.label !== undefined ? options.label : 'i';

    if (typeof label === 'string') {
      /**
       * @private
       * @type {HTMLElement}
       */
      this.label_ = document.createElement('span');
      this.label_.textContent = label;
    } else {
      this.label_ = label;
    }


    var activeLabel = (this.collapsible_ && !this.collapsed_) ?
      this.collapseLabel_ : this.label_;
    var button = document.createElement('button');
    button.setAttribute('type', 'button');
    button.title = tipLabel;
    button.appendChild(activeLabel);

    Object(_events_js__WEBPACK_IMPORTED_MODULE_4__["listen"])(button, _events_EventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].CLICK, this.handleClick_, this);

    var cssClasses = className + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_2__["CLASS_UNSELECTABLE"] + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_2__["CLASS_CONTROL"] +
        (this.collapsed_ && this.collapsible_ ? ' ' + _css_js__WEBPACK_IMPORTED_MODULE_2__["CLASS_COLLAPSED"] : '') +
        (this.collapsible_ ? '' : ' ol-uncollapsible');
    var element = this.element;
    element.className = cssClasses;
    element.appendChild(this.ulElement_);
    element.appendChild(button);

    /**
     * A list of currently rendered resolutions.
     * @type {Array<string>}
     * @private
     */
    this.renderedAttributions_ = [];

    /**
     * @private
     * @type {boolean}
     */
    this.renderedVisible_ = true;

  }

  if ( Control ) Attribution.__proto__ = Control;
  Attribution.prototype = Object.create( Control && Control.prototype );
  Attribution.prototype.constructor = Attribution;

  /**
   * Collect a list of visible attributions and set the collapsible state.
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @return {Array<string>} Attributions.
   * @private
   */
  Attribution.prototype.collectSourceAttributions_ = function collectSourceAttributions_ (frameState) {
    /**
     * Used to determine if an attribution already exists.
     * @type {!Object<string, boolean>}
     */
    var lookup = {};

    /**
     * A list of visible attributions.
     * @type {Array<string>}
     */
    var visibleAttributions = [];

    var layerStatesArray = frameState.layerStatesArray;
    var resolution = frameState.viewState.resolution;
    for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      var layerState = layerStatesArray[i];
      if (!Object(_layer_Layer_js__WEBPACK_IMPORTED_MODULE_6__["visibleAtResolution"])(layerState, resolution)) {
        continue;
      }

      var source = /** @type {import("../layer/Layer.js").default} */ (layerState.layer).getSource();
      if (!source) {
        continue;
      }

      var attributionGetter = source.getAttributions();
      if (!attributionGetter) {
        continue;
      }

      var attributions = attributionGetter(frameState);
      if (!attributions) {
        continue;
      }

      if (!this.overrideCollapsible_ && source.getAttributionsCollapsible() === false) {
        this.setCollapsible(false);
      }

      if (Array.isArray(attributions)) {
        for (var j = 0, jj = attributions.length; j < jj; ++j) {
          if (!(attributions[j] in lookup)) {
            visibleAttributions.push(attributions[j]);
            lookup[attributions[j]] = true;
          }
        }
      } else {
        if (!(attributions in lookup)) {
          visibleAttributions.push(attributions);
          lookup[attributions] = true;
        }
      }
    }
    return visibleAttributions;
  };

  /**
   * @private
   * @param {?import("../PluggableMap.js").FrameState} frameState Frame state.
   */
  Attribution.prototype.updateElement_ = function updateElement_ (frameState) {
    if (!frameState) {
      if (this.renderedVisible_) {
        this.element.style.display = 'none';
        this.renderedVisible_ = false;
      }
      return;
    }

    var attributions = this.collectSourceAttributions_(frameState);

    var visible = attributions.length > 0;
    if (this.renderedVisible_ != visible) {
      this.element.style.display = visible ? '' : 'none';
      this.renderedVisible_ = visible;
    }

    if (Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["equals"])(attributions, this.renderedAttributions_)) {
      return;
    }

    Object(_dom_js__WEBPACK_IMPORTED_MODULE_3__["removeChildren"])(this.ulElement_);

    // append the attributions
    for (var i = 0, ii = attributions.length; i < ii; ++i) {
      var element = document.createElement('li');
      element.innerHTML = attributions[i];
      this.ulElement_.appendChild(element);
    }

    this.renderedAttributions_ = attributions;
  };

  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  Attribution.prototype.handleClick_ = function handleClick_ (event) {
    event.preventDefault();
    this.handleToggle_();
  };

  /**
   * @private
   */
  Attribution.prototype.handleToggle_ = function handleToggle_ () {
    this.element.classList.toggle(_css_js__WEBPACK_IMPORTED_MODULE_2__["CLASS_COLLAPSED"]);
    if (this.collapsed_) {
      Object(_dom_js__WEBPACK_IMPORTED_MODULE_3__["replaceNode"])(this.collapseLabel_, this.label_);
    } else {
      Object(_dom_js__WEBPACK_IMPORTED_MODULE_3__["replaceNode"])(this.label_, this.collapseLabel_);
    }
    this.collapsed_ = !this.collapsed_;
  };

  /**
   * Return `true` if the attribution is collapsible, `false` otherwise.
   * @return {boolean} True if the widget is collapsible.
   * @api
   */
  Attribution.prototype.getCollapsible = function getCollapsible () {
    return this.collapsible_;
  };

  /**
   * Set whether the attribution should be collapsible.
   * @param {boolean} collapsible True if the widget is collapsible.
   * @api
   */
  Attribution.prototype.setCollapsible = function setCollapsible (collapsible) {
    if (this.collapsible_ === collapsible) {
      return;
    }
    this.collapsible_ = collapsible;
    this.element.classList.toggle('ol-uncollapsible');
    if (!collapsible && this.collapsed_) {
      this.handleToggle_();
    }
  };

  /**
   * Collapse or expand the attribution according to the passed parameter. Will
   * not do anything if the attribution isn't collapsible or if the current
   * collapsed state is already the one requested.
   * @param {boolean} collapsed True if the widget is collapsed.
   * @api
   */
  Attribution.prototype.setCollapsed = function setCollapsed (collapsed) {
    if (!this.collapsible_ || this.collapsed_ === collapsed) {
      return;
    }
    this.handleToggle_();
  };

  /**
   * Return `true` when the attribution is currently collapsed or `false`
   * otherwise.
   * @return {boolean} True if the widget is collapsed.
   * @api
   */
  Attribution.prototype.getCollapsed = function getCollapsed () {
    return this.collapsed_;
  };

  return Attribution;
}(_Control_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/**
 * Update the attribution element.
 * @param {import("../MapEvent.js").default} mapEvent Map event.
 * @this {Attribution}
 * @api
 */
function render(mapEvent) {
  this.updateElement_(mapEvent.frameState);
}


/* harmony default export */ __webpack_exports__["default"] = (Attribution);

//# sourceMappingURL=Attribution.js.map

/***/ }),

/***/ "./node_modules/ol/control/Control.js":
/*!********************************************!*\
  !*** ./node_modules/ol/control/Control.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _MapEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../MapEventType.js */ "./node_modules/ol/MapEventType.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/**
 * @module ol/control/Control
 */







/**
 * @typedef {Object} Options
 * @property {HTMLElement} [element] The element is the control's
 * container element. This only needs to be specified if you're developing
 * a custom control.
 * @property {function(import("../MapEvent.js").default)} [render] Function called when
 * the control should be re-rendered. This is called in a `requestAnimationFrame`
 * callback.
 * @property {HTMLElement|string} [target] Specify a target if you want
 * the control to be rendered outside of the map's viewport.
 */


/**
 * @classdesc
 * A control is a visible widget with a DOM element in a fixed position on the
 * screen. They can involve user input (buttons), or be informational only;
 * the position is determined using CSS. By default these are placed in the
 * container with CSS class name `ol-overlaycontainer-stopevent`, but can use
 * any outside DOM element.
 *
 * This is the base class for controls. You can use it for simple custom
 * controls by creating the element with listeners, creating an instance:
 * ```js
 * var myControl = new Control({element: myElement});
 * ```
 * and then adding this to the map.
 *
 * The main advantage of having this as a control rather than a simple separate
 * DOM element is that preventing propagation is handled for you. Controls
 * will also be objects in a {@link module:ol/Collection~Collection}, so you can use their methods.
 *
 * You can also extend this base for your own control class. See
 * examples/custom-controls for an example of how to do this.
 *
 * @api
 */
var Control = /*@__PURE__*/(function (BaseObject) {
  function Control(options) {

    BaseObject.call(this);

    /**
     * @protected
     * @type {HTMLElement}
     */
    this.element = options.element ? options.element : null;

    /**
     * @private
     * @type {HTMLElement}
     */
    this.target_ = null;

    /**
     * @private
     * @type {import("../PluggableMap.js").default}
     */
    this.map_ = null;

    /**
     * @protected
     * @type {!Array<import("../events.js").EventsKey>}
     */
    this.listenerKeys = [];

    /**
     * @type {function(import("../MapEvent.js").default)}
     */
    this.render = options.render ? options.render : _functions_js__WEBPACK_IMPORTED_MODULE_0__["VOID"];

    if (options.target) {
      this.setTarget(options.target);
    }

  }

  if ( BaseObject ) Control.__proto__ = BaseObject;
  Control.prototype = Object.create( BaseObject && BaseObject.prototype );
  Control.prototype.constructor = Control;

  /**
   * @inheritDoc
   */
  Control.prototype.disposeInternal = function disposeInternal () {
    Object(_dom_js__WEBPACK_IMPORTED_MODULE_3__["removeNode"])(this.element);
    BaseObject.prototype.disposeInternal.call(this);
  };

  /**
   * Get the map associated with this control.
   * @return {import("../PluggableMap.js").default} Map.
   * @api
   */
  Control.prototype.getMap = function getMap () {
    return this.map_;
  };

  /**
   * Remove the control from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../PluggableMap.js").default} map Map.
   * @api
   */
  Control.prototype.setMap = function setMap (map) {
    if (this.map_) {
      Object(_dom_js__WEBPACK_IMPORTED_MODULE_3__["removeNode"])(this.element);
    }
    for (var i = 0, ii = this.listenerKeys.length; i < ii; ++i) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_4__["unlistenByKey"])(this.listenerKeys[i]);
    }
    this.listenerKeys.length = 0;
    this.map_ = map;
    if (this.map_) {
      var target = this.target_ ?
        this.target_ : map.getOverlayContainerStopEvent();
      target.appendChild(this.element);
      if (this.render !== _functions_js__WEBPACK_IMPORTED_MODULE_0__["VOID"]) {
        this.listenerKeys.push(Object(_events_js__WEBPACK_IMPORTED_MODULE_4__["listen"])(map,
          _MapEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POSTRENDER, this.render, this));
      }
      map.render();
    }
  };

  /**
   * This function is used to set a target element for the control. It has no
   * effect if it is called after the control has been added to the map (i.e.
   * after `setMap` is called on the control). If no `target` is set in the
   * options passed to the control constructor and if `setTarget` is not called
   * then the control is added to the map's overlay container.
   * @param {HTMLElement|string} target Target.
   * @api
   */
  Control.prototype.setTarget = function setTarget (target) {
    this.target_ = typeof target === 'string' ?
      document.getElementById(target) :
      target;
  };

  return Control;
}(_Object_js__WEBPACK_IMPORTED_MODULE_2__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (Control);

//# sourceMappingURL=Control.js.map

/***/ }),

/***/ "./node_modules/ol/control/Rotate.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/control/Rotate.js ***!
  \*******************************************/
/*! exports provided: render, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony import */ var _Control_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Control.js */ "./node_modules/ol/control/Control.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../css.js */ "./node_modules/ol/css.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../easing.js */ "./node_modules/ol/easing.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/**
 * @module ol/control/Rotate
 */







/**
 * @typedef {Object} Options
 * @property {string} [className='ol-rotate'] CSS class name.
 * @property {string|HTMLElement} [label='⇧'] Text label to use for the rotate button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [tipLabel='Reset rotation'] Text label to use for the rotate tip.
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {boolean} [autoHide=true] Hide the control when rotation is 0.
 * @property {function(import("../MapEvent.js").default)} [render] Function called when the control should
 * be re-rendered. This is called in a `requestAnimationFrame` callback.
 * @property {function()} [resetNorth] Function called when the control is clicked.
 * This will override the default `resetNorth`.
 * @property {HTMLElement|string} [target] Specify a target if you want the control to be
 * rendered outside of the map's viewport.
 */


/**
 * @classdesc
 * A button control to reset rotation to 0.
 * To style this control use css selector `.ol-rotate`. A `.ol-hidden` css
 * selector is added to the button when the rotation is 0.
 *
 * @api
 */
var Rotate = /*@__PURE__*/(function (Control) {
  function Rotate(opt_options) {

    var options = opt_options ? opt_options : {};

    Control.call(this, {
      element: document.createElement('div'),
      render: options.render || render,
      target: options.target
    });

    var className = options.className !== undefined ? options.className : 'ol-rotate';

    var label = options.label !== undefined ? options.label : '\u21E7';

    /**
     * @type {HTMLElement}
     * @private
     */
    this.label_ = null;

    if (typeof label === 'string') {
      this.label_ = document.createElement('span');
      this.label_.className = 'ol-compass';
      this.label_.textContent = label;
    } else {
      this.label_ = label;
      this.label_.classList.add('ol-compass');
    }

    var tipLabel = options.tipLabel ? options.tipLabel : 'Reset rotation';

    var button = document.createElement('button');
    button.className = className + '-reset';
    button.setAttribute('type', 'button');
    button.title = tipLabel;
    button.appendChild(this.label_);

    Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(button, _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].CLICK, this.handleClick_, this);

    var cssClasses = className + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_1__["CLASS_UNSELECTABLE"] + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_1__["CLASS_CONTROL"];
    var element = this.element;
    element.className = cssClasses;
    element.appendChild(button);

    this.callResetNorth_ = options.resetNorth ? options.resetNorth : undefined;

    /**
     * @type {number}
     * @private
     */
    this.duration_ = options.duration !== undefined ? options.duration : 250;

    /**
     * @type {boolean}
     * @private
     */
    this.autoHide_ = options.autoHide !== undefined ? options.autoHide : true;

    /**
     * @private
     * @type {number|undefined}
     */
    this.rotation_ = undefined;

    if (this.autoHide_) {
      this.element.classList.add(_css_js__WEBPACK_IMPORTED_MODULE_1__["CLASS_HIDDEN"]);
    }

  }

  if ( Control ) Rotate.__proto__ = Control;
  Rotate.prototype = Object.create( Control && Control.prototype );
  Rotate.prototype.constructor = Rotate;

  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  Rotate.prototype.handleClick_ = function handleClick_ (event) {
    event.preventDefault();
    if (this.callResetNorth_ !== undefined) {
      this.callResetNorth_();
    } else {
      this.resetNorth_();
    }
  };

  /**
   * @private
   */
  Rotate.prototype.resetNorth_ = function resetNorth_ () {
    var map = this.getMap();
    var view = map.getView();
    if (!view) {
      // the map does not have a view, so we can't act
      // upon it
      return;
    }
    if (view.getRotation() !== undefined) {
      if (this.duration_ > 0) {
        view.animate({
          rotation: 0,
          duration: this.duration_,
          easing: _easing_js__WEBPACK_IMPORTED_MODULE_2__["easeOut"]
        });
      } else {
        view.setRotation(0);
      }
    }
  };

  return Rotate;
}(_Control_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/**
 * Update the rotate control element.
 * @param {import("../MapEvent.js").default} mapEvent Map event.
 * @this {Rotate}
 * @api
 */
function render(mapEvent) {
  var frameState = mapEvent.frameState;
  if (!frameState) {
    return;
  }
  var rotation = frameState.viewState.rotation;
  if (rotation != this.rotation_) {
    var transform = 'rotate(' + rotation + 'rad)';
    if (this.autoHide_) {
      var contains = this.element.classList.contains(_css_js__WEBPACK_IMPORTED_MODULE_1__["CLASS_HIDDEN"]);
      if (!contains && rotation === 0) {
        this.element.classList.add(_css_js__WEBPACK_IMPORTED_MODULE_1__["CLASS_HIDDEN"]);
      } else if (contains && rotation !== 0) {
        this.element.classList.remove(_css_js__WEBPACK_IMPORTED_MODULE_1__["CLASS_HIDDEN"]);
      }
    }
    this.label_.style.msTransform = transform;
    this.label_.style.webkitTransform = transform;
    this.label_.style.transform = transform;
  }
  this.rotation_ = rotation;
}

/* harmony default export */ __webpack_exports__["default"] = (Rotate);

//# sourceMappingURL=Rotate.js.map

/***/ }),

/***/ "./node_modules/ol/control/Zoom.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/control/Zoom.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _Control_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Control.js */ "./node_modules/ol/control/Control.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../css.js */ "./node_modules/ol/css.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../easing.js */ "./node_modules/ol/easing.js");
/**
 * @module ol/control/Zoom
 */







/**
 * @typedef {Object} Options
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {string} [className='ol-zoom'] CSS class name.
 * @property {string|HTMLElement} [zoomInLabel='+'] Text label to use for the zoom-in
 * button. Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string|HTMLElement} [zoomOutLabel='-'] Text label to use for the zoom-out button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [zoomInTipLabel='Zoom in'] Text label to use for the button tip.
 * @property {string} [zoomOutTipLabel='Zoom out'] Text label to use for the button tip.
 * @property {number} [delta=1] The zoom delta applied on each click.
 * @property {HTMLElement|string} [target] Specify a target if you want the control to be
 * rendered outside of the map's viewport.
 */


/**
 * @classdesc
 * A control with 2 buttons, one for zoom in and one for zoom out.
 * This control is one of the default controls of a map. To style this control
 * use css selectors `.ol-zoom-in` and `.ol-zoom-out`.
 *
 * @api
 */
var Zoom = /*@__PURE__*/(function (Control) {
  function Zoom(opt_options) {

    var options = opt_options ? opt_options : {};

    Control.call(this, {
      element: document.createElement('div'),
      target: options.target
    });

    var className = options.className !== undefined ? options.className : 'ol-zoom';

    var delta = options.delta !== undefined ? options.delta : 1;

    var zoomInLabel = options.zoomInLabel !== undefined ? options.zoomInLabel : '+';
    var zoomOutLabel = options.zoomOutLabel !== undefined ? options.zoomOutLabel : '\u2212';

    var zoomInTipLabel = options.zoomInTipLabel !== undefined ?
      options.zoomInTipLabel : 'Zoom in';
    var zoomOutTipLabel = options.zoomOutTipLabel !== undefined ?
      options.zoomOutTipLabel : 'Zoom out';

    var inElement = document.createElement('button');
    inElement.className = className + '-in';
    inElement.setAttribute('type', 'button');
    inElement.title = zoomInTipLabel;
    inElement.appendChild(
      typeof zoomInLabel === 'string' ? document.createTextNode(zoomInLabel) : zoomInLabel
    );

    Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listen"])(inElement, _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CLICK, this.handleClick_.bind(this, delta));

    var outElement = document.createElement('button');
    outElement.className = className + '-out';
    outElement.setAttribute('type', 'button');
    outElement.title = zoomOutTipLabel;
    outElement.appendChild(
      typeof zoomOutLabel === 'string' ? document.createTextNode(zoomOutLabel) : zoomOutLabel
    );

    Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listen"])(outElement, _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CLICK, this.handleClick_.bind(this, -delta));

    var cssClasses = className + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_3__["CLASS_UNSELECTABLE"] + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_3__["CLASS_CONTROL"];
    var element = this.element;
    element.className = cssClasses;
    element.appendChild(inElement);
    element.appendChild(outElement);

    /**
     * @type {number}
     * @private
     */
    this.duration_ = options.duration !== undefined ? options.duration : 250;

  }

  if ( Control ) Zoom.__proto__ = Control;
  Zoom.prototype = Object.create( Control && Control.prototype );
  Zoom.prototype.constructor = Zoom;

  /**
   * @param {number} delta Zoom delta.
   * @param {MouseEvent} event The event to handle
   * @private
   */
  Zoom.prototype.handleClick_ = function handleClick_ (delta, event) {
    event.preventDefault();
    this.zoomByDelta_(delta);
  };

  /**
   * @param {number} delta Zoom delta.
   * @private
   */
  Zoom.prototype.zoomByDelta_ = function zoomByDelta_ (delta) {
    var map = this.getMap();
    var view = map.getView();
    if (!view) {
      // the map does not have a view, so we can't act
      // upon it
      return;
    }
    var currentResolution = view.getResolution();
    if (currentResolution) {
      var newResolution = view.constrainResolution(currentResolution, delta);
      if (this.duration_ > 0) {
        if (view.getAnimating()) {
          view.cancelAnimations();
        }
        view.animate({
          resolution: newResolution,
          duration: this.duration_,
          easing: _easing_js__WEBPACK_IMPORTED_MODULE_4__["easeOut"]
        });
      } else {
        view.setResolution(newResolution);
      }
    }
  };

  return Zoom;
}(_Control_js__WEBPACK_IMPORTED_MODULE_2__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (Zoom);

//# sourceMappingURL=Zoom.js.map

/***/ }),

/***/ "./node_modules/ol/control/util.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/control/util.js ***!
  \*****************************************/
/*! exports provided: defaults */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaults", function() { return defaults; });
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Collection.js */ "./node_modules/ol/Collection.js");
/* harmony import */ var _Attribution_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Attribution.js */ "./node_modules/ol/control/Attribution.js");
/* harmony import */ var _Rotate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Rotate.js */ "./node_modules/ol/control/Rotate.js");
/* harmony import */ var _Zoom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Zoom.js */ "./node_modules/ol/control/Zoom.js");
/**
 * @module ol/control/util
 */






/**
 * @typedef {Object} DefaultsOptions
 * @property {boolean} [attribution=true] Include
 * {@link module:ol/control/Attribution~Attribution}.
 * @property {import("./Attribution.js").Options} [attributionOptions]
 * Options for {@link module:ol/control/Attribution~Attribution}.
 * @property {boolean} [rotate=true] Include
 * {@link module:ol/control/Rotate~Rotate}.
 * @property {import("./Rotate.js").Options} [rotateOptions] Options
 * for {@link module:ol/control/Rotate~Rotate}.
 * @property {boolean} [zoom] Include {@link module:ol/control/Zoom~Zoom}.
 * @property {import("./Zoom.js").Options} [zoomOptions] Options for
 * {@link module:ol/control/Zoom~Zoom}.
 * @api
 */


/**
 * Set of controls included in maps by default. Unless configured otherwise,
 * this returns a collection containing an instance of each of the following
 * controls:
 * * {@link module:ol/control/Zoom~Zoom}
 * * {@link module:ol/control/Rotate~Rotate}
 * * {@link module:ol/control/Attribution~Attribution}
 *
 * @param {DefaultsOptions=} opt_options
 * Defaults options.
 * @return {Collection<import("./Control.js").default>}
 * Controls.
 * @function module:ol/control.defaults
 * @api
 */
function defaults(opt_options) {

  var options = opt_options ? opt_options : {};

  var controls = new _Collection_js__WEBPACK_IMPORTED_MODULE_0__["default"]();

  var zoomControl = options.zoom !== undefined ? options.zoom : true;
  if (zoomControl) {
    controls.push(new _Zoom_js__WEBPACK_IMPORTED_MODULE_3__["default"](options.zoomOptions));
  }

  var rotateControl = options.rotate !== undefined ? options.rotate : true;
  if (rotateControl) {
    controls.push(new _Rotate_js__WEBPACK_IMPORTED_MODULE_2__["default"](options.rotateOptions));
  }

  var attributionControl = options.attribution !== undefined ?
    options.attribution : true;
  if (attributionControl) {
    controls.push(new _Attribution_js__WEBPACK_IMPORTED_MODULE_1__["default"](options.attributionOptions));
  }

  return controls;
}

//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/ol/coordinate.js":
/*!***************************************!*\
  !*** ./node_modules/ol/coordinate.js ***!
  \***************************************/
/*! exports provided: add, closestOnCircle, closestOnSegment, createStringXY, degreesToStringHDMS, format, equals, rotate, scale, squaredDistance, distance, squaredDistanceToSegment, toStringHDMS, toStringXY */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "closestOnCircle", function() { return closestOnCircle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "closestOnSegment", function() { return closestOnSegment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createStringXY", function() { return createStringXY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "degreesToStringHDMS", function() { return degreesToStringHDMS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "format", function() { return format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistanceToSegment", function() { return squaredDistanceToSegment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toStringHDMS", function() { return toStringHDMS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toStringXY", function() { return toStringXY; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./string.js */ "./node_modules/ol/string.js");
/**
 * @module ol/coordinate
 */




/**
 * An array of numbers representing an xy coordinate. Example: `[16, 48]`.
 * @typedef {Array<number>} Coordinate
 * @api
 */


/**
 * A function that takes a {@link module:ol/coordinate~Coordinate} and
 * transforms it into a `{string}`.
 *
 * @typedef {function((Coordinate|undefined)): string} CoordinateFormat
 * @api
 */


/**
 * Add `delta` to `coordinate`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     import {add} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     add(coord, [-2, 4]);
 *     // coord is now [5.85, 51.983333]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {Coordinate} delta Delta.
 * @return {Coordinate} The input coordinate adjusted by
 * the given delta.
 * @api
 */
function add(coordinate, delta) {
  coordinate[0] += delta[0];
  coordinate[1] += delta[1];
  return coordinate;
}


/**
 * Calculates the point closest to the passed coordinate on the passed circle.
 *
 * @param {Coordinate} coordinate The coordinate.
 * @param {import("./geom/Circle.js").default} circle The circle.
 * @return {Coordinate} Closest point on the circumference.
 */
function closestOnCircle(coordinate, circle) {
  var r = circle.getRadius();
  var center = circle.getCenter();
  var x0 = center[0];
  var y0 = center[1];
  var x1 = coordinate[0];
  var y1 = coordinate[1];

  var dx = x1 - x0;
  var dy = y1 - y0;
  if (dx === 0 && dy === 0) {
    dx = 1;
  }
  var d = Math.sqrt(dx * dx + dy * dy);

  var x = x0 + r * dx / d;
  var y = y0 + r * dy / d;

  return [x, y];
}


/**
 * Calculates the point closest to the passed coordinate on the passed segment.
 * This is the foot of the perpendicular of the coordinate to the segment when
 * the foot is on the segment, or the closest segment coordinate when the foot
 * is outside the segment.
 *
 * @param {Coordinate} coordinate The coordinate.
 * @param {Array<Coordinate>} segment The two coordinates
 * of the segment.
 * @return {Coordinate} The foot of the perpendicular of
 * the coordinate to the segment.
 */
function closestOnSegment(coordinate, segment) {
  var x0 = coordinate[0];
  var y0 = coordinate[1];
  var start = segment[0];
  var end = segment[1];
  var x1 = start[0];
  var y1 = start[1];
  var x2 = end[0];
  var y2 = end[1];
  var dx = x2 - x1;
  var dy = y2 - y1;
  var along = (dx === 0 && dy === 0) ? 0 :
    ((dx * (x0 - x1)) + (dy * (y0 - y1))) / ((dx * dx + dy * dy) || 0);
  var x, y;
  if (along <= 0) {
    x = x1;
    y = y1;
  } else if (along >= 1) {
    x = x2;
    y = y2;
  } else {
    x = x1 + along * dx;
    y = y1 + along * dy;
  }
  return [x, y];
}


/**
 * Returns a {@link module:ol/coordinate~CoordinateFormat} function that can be
 * used to format
 * a {Coordinate} to a string.
 *
 * Example without specifying the fractional digits:
 *
 *     import {createStringXY} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var stringifyFunc = createStringXY();
 *     var out = stringifyFunc(coord);
 *     // out is now '8, 48'
 *
 * Example with explicitly specifying 2 fractional digits:
 *
 *     import {createStringXY} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var stringifyFunc = createStringXY(2);
 *     var out = stringifyFunc(coord);
 *     // out is now '7.85, 47.98'
 *
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {CoordinateFormat} Coordinate format.
 * @api
 */
function createStringXY(opt_fractionDigits) {
  return (
    /**
     * @param {Coordinate} coordinate Coordinate.
     * @return {string} String XY.
     */
    function(coordinate) {
      return toStringXY(coordinate, opt_fractionDigits);
    }
  );
}


/**
 * @param {string} hemispheres Hemispheres.
 * @param {number} degrees Degrees.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} String.
 */
function degreesToStringHDMS(hemispheres, degrees, opt_fractionDigits) {
  var normalizedDegrees = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["modulo"])(degrees + 180, 360) - 180;
  var x = Math.abs(3600 * normalizedDegrees);
  var dflPrecision = opt_fractionDigits || 0;
  var precision = Math.pow(10, dflPrecision);

  var deg = Math.floor(x / 3600);
  var min = Math.floor((x - deg * 3600) / 60);
  var sec = x - (deg * 3600) - (min * 60);
  sec = Math.ceil(sec * precision) / precision;

  if (sec >= 60) {
    sec = 0;
    min += 1;
  }

  if (min >= 60) {
    min = 0;
    deg += 1;
  }

  return deg + '\u00b0 ' + Object(_string_js__WEBPACK_IMPORTED_MODULE_1__["padNumber"])(min, 2) + '\u2032 ' +
    Object(_string_js__WEBPACK_IMPORTED_MODULE_1__["padNumber"])(sec, 2, dflPrecision) + '\u2033' +
    (normalizedDegrees == 0 ? '' : ' ' + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0));
}


/**
 * Transforms the given {@link module:ol/coordinate~Coordinate} to a string
 * using the given string template. The strings `{x}` and `{y}` in the template
 * will be replaced with the first and second coordinate values respectively.
 *
 * Example without specifying the fractional digits:
 *
 *     import {format} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var template = 'Coordinate is ({x}|{y}).';
 *     var out = format(coord, template);
 *     // out is now 'Coordinate is (8|48).'
 *
 * Example explicitly specifying the fractional digits:
 *
 *     import {format} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var template = 'Coordinate is ({x}|{y}).';
 *     var out = format(coord, template, 2);
 *     // out is now 'Coordinate is (7.85|47.98).'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {string} template A template string with `{x}` and `{y}` placeholders
 *     that will be replaced by first and second coordinate values.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Formatted coordinate.
 * @api
 */
function format(coordinate, template, opt_fractionDigits) {
  if (coordinate) {
    return template
      .replace('{x}', coordinate[0].toFixed(opt_fractionDigits))
      .replace('{y}', coordinate[1].toFixed(opt_fractionDigits));
  } else {
    return '';
  }
}


/**
 * @param {Coordinate} coordinate1 First coordinate.
 * @param {Coordinate} coordinate2 Second coordinate.
 * @return {boolean} The two coordinates are equal.
 */
function equals(coordinate1, coordinate2) {
  var equals = true;
  for (var i = coordinate1.length - 1; i >= 0; --i) {
    if (coordinate1[i] != coordinate2[i]) {
      equals = false;
      break;
    }
  }
  return equals;
}


/**
 * Rotate `coordinate` by `angle`. `coordinate` is modified in place and
 * returned by the function.
 *
 * Example:
 *
 *     import {rotate} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var rotateRadians = Math.PI / 2; // 90 degrees
 *     rotate(coord, rotateRadians);
 *     // coord is now [-47.983333, 7.85]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} angle Angle in radian.
 * @return {Coordinate} Coordinate.
 * @api
 */
function rotate(coordinate, angle) {
  var cosAngle = Math.cos(angle);
  var sinAngle = Math.sin(angle);
  var x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  var y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  coordinate[0] = x;
  coordinate[1] = y;
  return coordinate;
}


/**
 * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     import {scale as scaleCoordinate} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var scale = 1.2;
 *     scaleCoordinate(coord, scale);
 *     // coord is now [9.42, 57.5799996]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} scale Scale factor.
 * @return {Coordinate} Coordinate.
 */
function scale(coordinate, scale) {
  coordinate[0] *= scale;
  coordinate[1] *= scale;
  return coordinate;
}


/**
 * @param {Coordinate} coord1 First coordinate.
 * @param {Coordinate} coord2 Second coordinate.
 * @return {number} Squared distance between coord1 and coord2.
 */
function squaredDistance(coord1, coord2) {
  var dx = coord1[0] - coord2[0];
  var dy = coord1[1] - coord2[1];
  return dx * dx + dy * dy;
}


/**
 * @param {Coordinate} coord1 First coordinate.
 * @param {Coordinate} coord2 Second coordinate.
 * @return {number} Distance between coord1 and coord2.
 */
function distance(coord1, coord2) {
  return Math.sqrt(squaredDistance(coord1, coord2));
}


/**
 * Calculate the squared distance from a coordinate to a line segment.
 *
 * @param {Coordinate} coordinate Coordinate of the point.
 * @param {Array<Coordinate>} segment Line segment (2
 * coordinates).
 * @return {number} Squared distance from the point to the line segment.
 */
function squaredDistanceToSegment(coordinate, segment) {
  return squaredDistance(coordinate,
    closestOnSegment(coordinate, segment));
}


/**
 * Format a geographic coordinate with the hemisphere, degrees, minutes, and
 * seconds.
 *
 * Example without specifying fractional digits:
 *
 *     import {toStringHDMS} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var out = toStringHDMS(coord);
 *     // out is now '47° 58′ 60″ N 7° 50′ 60″ E'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     import {toStringHDMS} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var out = toStringHDMS(coord, 1);
 *     // out is now '47° 58′ 60.0″ N 7° 50′ 60.0″ E'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Hemisphere, degrees, minutes and seconds.
 * @api
 */
function toStringHDMS(coordinate, opt_fractionDigits) {
  if (coordinate) {
    return degreesToStringHDMS('NS', coordinate[1], opt_fractionDigits) + ' ' +
        degreesToStringHDMS('EW', coordinate[0], opt_fractionDigits);
  } else {
    return '';
  }
}


/**
 * Format a coordinate as a comma delimited string.
 *
 * Example without specifying fractional digits:
 *
 *     import {toStringXY} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var out = toStringXY(coord);
 *     // out is now '8, 48'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     import {toStringXY} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var out = toStringXY(coord, 1);
 *     // out is now '7.8, 48.0'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} XY.
 * @api
 */
function toStringXY(coordinate, opt_fractionDigits) {
  return format(coordinate, '{x}, {y}', opt_fractionDigits);
}

//# sourceMappingURL=coordinate.js.map

/***/ }),

/***/ "./node_modules/ol/css.js":
/*!********************************!*\
  !*** ./node_modules/ol/css.js ***!
  \********************************/
/*! exports provided: CLASS_HIDDEN, CLASS_SELECTABLE, CLASS_UNSELECTABLE, CLASS_UNSUPPORTED, CLASS_CONTROL, CLASS_COLLAPSED, getFontFamilies */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLASS_HIDDEN", function() { return CLASS_HIDDEN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLASS_SELECTABLE", function() { return CLASS_SELECTABLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLASS_UNSELECTABLE", function() { return CLASS_UNSELECTABLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLASS_UNSUPPORTED", function() { return CLASS_UNSUPPORTED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLASS_CONTROL", function() { return CLASS_CONTROL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLASS_COLLAPSED", function() { return CLASS_COLLAPSED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFontFamilies", function() { return getFontFamilies; });
/**
 * @module ol/css
 */


/**
 * The CSS class for hidden feature.
 *
 * @const
 * @type {string}
 */
var CLASS_HIDDEN = 'ol-hidden';


/**
 * The CSS class that we'll give the DOM elements to have them selectable.
 *
 * @const
 * @type {string}
 */
var CLASS_SELECTABLE = 'ol-selectable';


/**
 * The CSS class that we'll give the DOM elements to have them unselectable.
 *
 * @const
 * @type {string}
 */
var CLASS_UNSELECTABLE = 'ol-unselectable';


/**
 * The CSS class for unsupported feature.
 *
 * @const
 * @type {string}
 */
var CLASS_UNSUPPORTED = 'ol-unsupported';


/**
 * The CSS class for controls.
 *
 * @const
 * @type {string}
 */
var CLASS_CONTROL = 'ol-control';


/**
 * The CSS class that we'll give the DOM elements that are collapsed, i.e.
 * to those elements which usually can be expanded.
 *
 * @const
 * @type {string}
 */
var CLASS_COLLAPSED = 'ol-collapsed';


/**
 * Get the list of font families from a font spec.  Note that this doesn't work
 * for font families that have commas in them.
 * @param {string} The CSS font property.
 * @return {Object<string>} The font families (or null if the input spec is invalid).
 */
var getFontFamilies = (function() {
  var style;
  var cache = {};
  return function(font) {
    if (!style) {
      style = document.createElement('div').style;
    }
    if (!(font in cache)) {
      style.font = font;
      var family = style.fontFamily;
      style.font = '';
      if (!family) {
        return null;
      }
      cache[font] = family.split(/,\s?/);
    }
    return cache[font];
  };
})();

//# sourceMappingURL=css.js.map

/***/ }),

/***/ "./node_modules/ol/dom.js":
/*!********************************!*\
  !*** ./node_modules/ol/dom.js ***!
  \********************************/
/*! exports provided: createCanvasContext2D, outerWidth, outerHeight, replaceNode, removeNode, removeChildren */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createCanvasContext2D", function() { return createCanvasContext2D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "outerWidth", function() { return outerWidth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "outerHeight", function() { return outerHeight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "replaceNode", function() { return replaceNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeNode", function() { return removeNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeChildren", function() { return removeChildren; });
/**
 * @module ol/dom
 */


/**
 * Create an html canvas element and returns its 2d context.
 * @param {number=} opt_width Canvas width.
 * @param {number=} opt_height Canvas height.
 * @return {CanvasRenderingContext2D} The context.
 */
function createCanvasContext2D(opt_width, opt_height) {
  var canvas = /** @type {HTMLCanvasElement} */ (document.createElement('canvas'));
  if (opt_width) {
    canvas.width = opt_width;
  }
  if (opt_height) {
    canvas.height = opt_height;
  }
  return /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));
}


/**
 * Get the current computed width for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerWidth(true)`.
 * @param {!HTMLElement} element Element.
 * @return {number} The width.
 */
function outerWidth(element) {
  var width = element.offsetWidth;
  var style = getComputedStyle(element);
  width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);

  return width;
}


/**
 * Get the current computed height for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerHeight(true)`.
 * @param {!HTMLElement} element Element.
 * @return {number} The height.
 */
function outerHeight(element) {
  var height = element.offsetHeight;
  var style = getComputedStyle(element);
  height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);

  return height;
}

/**
 * @param {Node} newNode Node to replace old node
 * @param {Node} oldNode The node to be replaced
 */
function replaceNode(newNode, oldNode) {
  var parent = oldNode.parentNode;
  if (parent) {
    parent.replaceChild(newNode, oldNode);
  }
}

/**
 * @param {Node} node The node to remove.
 * @returns {Node} The node that was removed or null.
 */
function removeNode(node) {
  return node && node.parentNode ? node.parentNode.removeChild(node) : null;
}

/**
 * @param {Node} node The node to remove the children from.
 */
function removeChildren(node) {
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
}

//# sourceMappingURL=dom.js.map

/***/ }),

/***/ "./node_modules/ol/easing.js":
/*!***********************************!*\
  !*** ./node_modules/ol/easing.js ***!
  \***********************************/
/*! exports provided: easeIn, easeOut, inAndOut, linear, upAndDown */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "easeIn", function() { return easeIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "easeOut", function() { return easeOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inAndOut", function() { return inAndOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linear", function() { return linear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "upAndDown", function() { return upAndDown; });
/**
 * @module ol/easing
 */


/**
 * Start slow and speed up.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function easeIn(t) {
  return Math.pow(t, 3);
}


/**
 * Start fast and slow down.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function easeOut(t) {
  return 1 - easeIn(1 - t);
}


/**
 * Start slow, speed up, and then slow down again.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function inAndOut(t) {
  return 3 * t * t - 2 * t * t * t;
}


/**
 * Maintain a constant speed over time.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function linear(t) {
  return t;
}


/**
 * Start slow, speed up, and at the very end slow down again.  This has the
 * same general behavior as {@link module:ol/easing~inAndOut}, but the final
 * slowdown is delayed.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function upAndDown(t) {
  if (t < 0.5) {
    return inAndOut(2 * t);
  } else {
    return 1 - inAndOut(2 * (t - 0.5));
  }
}

//# sourceMappingURL=easing.js.map

/***/ }),

/***/ "./node_modules/ol/events.js":
/*!***********************************!*\
  !*** ./node_modules/ol/events.js ***!
  \***********************************/
/*! exports provided: bindListener, findListener, getListeners, listen, listenOnce, unlisten, unlistenByKey, unlistenAll */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bindListener", function() { return bindListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findListener", function() { return findListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getListeners", function() { return getListeners; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "listen", function() { return listen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "listenOnce", function() { return listenOnce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unlisten", function() { return unlisten; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unlistenByKey", function() { return unlistenByKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unlistenAll", function() { return unlistenAll; });
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/events
 */



/**
 * Key to use with {@link module:ol/Observable~Observable#unByKey}.
 * @typedef {Object} EventsKey
 * @property {Object} [bindTo]
 * @property {ListenerFunction} [boundListener]
 * @property {boolean} callOnce
 * @property {number} [deleteIndex]
 * @property {ListenerFunction} listener
 * @property {import("./events/Target.js").EventTargetLike} target
 * @property {string} type
 * @api
 */


/**
 * Listener function. This function is called with an event object as argument.
 * When the function returns `false`, event propagation will stop.
 *
 * @typedef {function((Event|import("./events/Event.js").default)): (void|boolean)} ListenerFunction
 * @api
 */


/**
 * @param {EventsKey} listenerObj Listener object.
 * @return {ListenerFunction} Bound listener.
 */
function bindListener(listenerObj) {
  var boundListener = function(evt) {
    var listener = listenerObj.listener;
    var bindTo = listenerObj.bindTo || listenerObj.target;
    if (listenerObj.callOnce) {
      unlistenByKey(listenerObj);
    }
    return listener.call(bindTo, evt);
  };
  listenerObj.boundListener = boundListener;
  return boundListener;
}


/**
 * Finds the matching {@link module:ol/events~EventsKey} in the given listener
 * array.
 *
 * @param {!Array<!EventsKey>} listeners Array of listeners.
 * @param {!Function} listener The listener function.
 * @param {Object=} opt_this The `this` value inside the listener.
 * @param {boolean=} opt_setDeleteIndex Set the deleteIndex on the matching
 *     listener, for {@link module:ol/events~unlistenByKey}.
 * @return {EventsKey|undefined} The matching listener object.
 */
function findListener(listeners, listener, opt_this, opt_setDeleteIndex) {
  var listenerObj;
  for (var i = 0, ii = listeners.length; i < ii; ++i) {
    listenerObj = listeners[i];
    if (listenerObj.listener === listener &&
        listenerObj.bindTo === opt_this) {
      if (opt_setDeleteIndex) {
        listenerObj.deleteIndex = i;
      }
      return listenerObj;
    }
  }
  return undefined;
}


/**
 * @param {import("./events/Target.js").EventTargetLike} target Target.
 * @param {string} type Type.
 * @return {Array<EventsKey>|undefined} Listeners.
 */
function getListeners(target, type) {
  var listenerMap = getListenerMap(target);
  return listenerMap ? listenerMap[type] : undefined;
}


/**
 * Get the lookup of listeners.
 * @param {Object} target Target.
 * @param {boolean=} opt_create If a map should be created if it doesn't exist.
 * @return {!Object<string, Array<EventsKey>>} Map of
 *     listeners by event type.
 */
function getListenerMap(target, opt_create) {
  var listenerMap = target.ol_lm;
  if (!listenerMap && opt_create) {
    listenerMap = target.ol_lm = {};
  }
  return listenerMap;
}


/**
 * Remove the listener map from a target.
 * @param {Object} target Target.
 */
function removeListenerMap(target) {
  delete target.ol_lm;
}


/**
 * Clean up all listener objects of the given type.  All properties on the
 * listener objects will be removed, and if no listeners remain in the listener
 * map, it will be removed from the target.
 * @param {import("./events/Target.js").EventTargetLike} target Target.
 * @param {string} type Type.
 */
function removeListeners(target, type) {
  var listeners = getListeners(target, type);
  if (listeners) {
    for (var i = 0, ii = listeners.length; i < ii; ++i) {
      /** @type {import("./events/Target.js").default} */ (target).
        removeEventListener(type, listeners[i].boundListener);
      Object(_obj_js__WEBPACK_IMPORTED_MODULE_0__["clear"])(listeners[i]);
    }
    listeners.length = 0;
    var listenerMap = getListenerMap(target);
    if (listenerMap) {
      delete listenerMap[type];
      if (Object.keys(listenerMap).length === 0) {
        removeListenerMap(target);
      }
    }
  }
}


/**
 * Registers an event listener on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * This function efficiently binds a `listener` to a `this` object, and returns
 * a key for use with {@link module:ol/events~unlistenByKey}.
 *
 * @param {import("./events/Target.js").EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ListenerFunction} listener Listener.
 * @param {Object=} opt_this Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @param {boolean=} opt_once If true, add the listener as one-off listener.
 * @return {EventsKey} Unique key for the listener.
 */
function listen(target, type, listener, opt_this, opt_once) {
  var listenerMap = getListenerMap(target, true);
  var listeners = listenerMap[type];
  if (!listeners) {
    listeners = listenerMap[type] = [];
  }
  var listenerObj = findListener(listeners, listener, opt_this, false);
  if (listenerObj) {
    if (!opt_once) {
      // Turn one-off listener into a permanent one.
      listenerObj.callOnce = false;
    }
  } else {
    listenerObj = /** @type {EventsKey} */ ({
      bindTo: opt_this,
      callOnce: !!opt_once,
      listener: listener,
      target: target,
      type: type
    });
    /** @type {import("./events/Target.js").default} */ (target).
      addEventListener(type, bindListener(listenerObj));
    listeners.push(listenerObj);
  }

  return listenerObj;
}


/**
 * Registers a one-off event listener on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * This function efficiently binds a `listener` as self-unregistering listener
 * to a `this` object, and returns a key for use with
 * {@link module:ol/events~unlistenByKey} in case the listener needs to be
 * unregistered before it is called.
 *
 * When {@link module:ol/events~listen} is called with the same arguments after this
 * function, the self-unregistering listener will be turned into a permanent
 * listener.
 *
 * @param {import("./events/Target.js").EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ListenerFunction} listener Listener.
 * @param {Object=} opt_this Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @return {EventsKey} Key for unlistenByKey.
 */
function listenOnce(target, type, listener, opt_this) {
  return listen(target, type, listener, opt_this, true);
}


/**
 * Unregisters an event listener on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * To return a listener, this function needs to be called with the exact same
 * arguments that were used for a previous {@link module:ol/events~listen} call.
 *
 * @param {import("./events/Target.js").EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ListenerFunction} listener Listener.
 * @param {Object=} opt_this Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 */
function unlisten(target, type, listener, opt_this) {
  var listeners = getListeners(target, type);
  if (listeners) {
    var listenerObj = findListener(listeners, listener, opt_this, true);
    if (listenerObj) {
      unlistenByKey(listenerObj);
    }
  }
}


/**
 * Unregisters event listeners on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * The argument passed to this function is the key returned from
 * {@link module:ol/events~listen} or {@link module:ol/events~listenOnce}.
 *
 * @param {EventsKey} key The key.
 */
function unlistenByKey(key) {
  if (key && key.target) {
    /** @type {import("./events/Target.js").default} */ (key.target).
      removeEventListener(key.type, key.boundListener);
    var listeners = getListeners(key.target, key.type);
    if (listeners) {
      var i = 'deleteIndex' in key ? key.deleteIndex : listeners.indexOf(key);
      if (i !== -1) {
        listeners.splice(i, 1);
      }
      if (listeners.length === 0) {
        removeListeners(key.target, key.type);
      }
    }
    Object(_obj_js__WEBPACK_IMPORTED_MODULE_0__["clear"])(key);
  }
}


/**
 * Unregisters all event listeners on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * @param {import("./events/Target.js").EventTargetLike} target Target.
 */
function unlistenAll(target) {
  var listenerMap = getListenerMap(target);
  if (listenerMap) {
    for (var type in listenerMap) {
      removeListeners(target, type);
    }
  }
}

//# sourceMappingURL=events.js.map

/***/ }),

/***/ "./node_modules/ol/events/Event.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/events/Event.js ***!
  \*****************************************/
/*! exports provided: stopPropagation, preventDefault, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stopPropagation", function() { return stopPropagation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "preventDefault", function() { return preventDefault; });
/**
 * @module ol/events/Event
 */

/**
 * @classdesc
 * Stripped down implementation of the W3C DOM Level 2 Event interface.
 * See https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface.
 *
 * This implementation only provides `type` and `target` properties, and
 * `stopPropagation` and `preventDefault` methods. It is meant as base class
 * for higher level events defined in the library, and works with
 * {@link module:ol/events/Target~Target}.
 */
var Event = function Event(type) {

  /**
   * @type {boolean}
   */
  this.propagationStopped;

  /**
   * The event type.
   * @type {string}
   * @api
   */
  this.type = type;

  /**
   * The event target.
   * @type {Object}
   * @api
   */
  this.target = null;
};

/**
 * Stop event propagation.
 * @api
 */
Event.prototype.preventDefault = function preventDefault () {
  this.propagationStopped = true;
};

/**
 * Stop event propagation.
 * @api
 */
Event.prototype.stopPropagation = function stopPropagation () {
  this.propagationStopped = true;
};


/**
 * @param {Event|import("./Event.js").default} evt Event
 */
function stopPropagation(evt) {
  evt.stopPropagation();
}


/**
 * @param {Event|import("./Event.js").default} evt Event
 */
function preventDefault(evt) {
  evt.preventDefault();
}

/* harmony default export */ __webpack_exports__["default"] = (Event);

//# sourceMappingURL=Event.js.map

/***/ }),

/***/ "./node_modules/ol/events/EventType.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/events/EventType.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/events/EventType
 */

/**
 * @enum {string}
 * @const
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event module:ol/events/Event~Event#change
   * @api
   */
  CHANGE: 'change',

  CLEAR: 'clear',
  CONTEXTMENU: 'contextmenu',
  CLICK: 'click',
  DBLCLICK: 'dblclick',
  DRAGENTER: 'dragenter',
  DRAGOVER: 'dragover',
  DROP: 'drop',
  ERROR: 'error',
  KEYDOWN: 'keydown',
  KEYPRESS: 'keypress',
  LOAD: 'load',
  MOUSEDOWN: 'mousedown',
  MOUSEMOVE: 'mousemove',
  MOUSEOUT: 'mouseout',
  MOUSEUP: 'mouseup',
  MOUSEWHEEL: 'mousewheel',
  MSPOINTERDOWN: 'MSPointerDown',
  RESIZE: 'resize',
  TOUCHSTART: 'touchstart',
  TOUCHMOVE: 'touchmove',
  TOUCHEND: 'touchend',
  WHEEL: 'wheel'
});

//# sourceMappingURL=EventType.js.map

/***/ }),

/***/ "./node_modules/ol/events/KeyCode.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/events/KeyCode.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/events/KeyCode
 */

/**
 * @enum {number}
 * @const
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40
});

//# sourceMappingURL=KeyCode.js.map

/***/ }),

/***/ "./node_modules/ol/events/Target.js":
/*!******************************************!*\
  !*** ./node_modules/ol/events/Target.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Disposable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Disposable.js */ "./node_modules/ol/Disposable.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _Event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Event.js */ "./node_modules/ol/events/Event.js");
/**
 * @module ol/events/Target
 */






/**
 * @typedef {EventTarget|Target} EventTargetLike
 */


/**
 * @classdesc
 * A simplified implementation of the W3C DOM Level 2 EventTarget interface.
 * See https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget.
 *
 * There are two important simplifications compared to the specification:
 *
 * 1. The handling of `useCapture` in `addEventListener` and
 *    `removeEventListener`. There is no real capture model.
 * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.
 *    There is no event target hierarchy. When a listener calls
 *    `stopPropagation` or `preventDefault` on an event object, it means that no
 *    more listeners after this one will be called. Same as when the listener
 *    returns false.
 */
var Target = /*@__PURE__*/(function (Disposable) {
  function Target() {

    Disposable.call(this);

    /**
     * @private
     * @type {!Object<string, number>}
     */
    this.pendingRemovals_ = {};

    /**
     * @private
     * @type {!Object<string, number>}
     */
    this.dispatching_ = {};

    /**
     * @private
     * @type {!Object<string, Array<import("../events.js").ListenerFunction>>}
     */
    this.listeners_ = {};

  }

  if ( Disposable ) Target.__proto__ = Disposable;
  Target.prototype = Object.create( Disposable && Disposable.prototype );
  Target.prototype.constructor = Target;

  /**
   * @param {string} type Type.
   * @param {import("../events.js").ListenerFunction} listener Listener.
   */
  Target.prototype.addEventListener = function addEventListener (type, listener) {
    var listeners = this.listeners_[type];
    if (!listeners) {
      listeners = this.listeners_[type] = [];
    }
    if (listeners.indexOf(listener) === -1) {
      listeners.push(listener);
    }
  };

  /**
   * Dispatches an event and calls all listeners listening for events
   * of this type. The event parameter can either be a string or an
   * Object with a `type` property.
   *
   * @param {{type: string,
   *     target: (EventTargetLike|undefined),
   *     propagationStopped: (boolean|undefined)}|
   *     import("./Event.js").default|string} event Event object.
   * @return {boolean|undefined} `false` if anyone called preventDefault on the
   *     event object or if any of the listeners returned false.
   * @api
   */
  Target.prototype.dispatchEvent = function dispatchEvent (event) {
    var evt = typeof event === 'string' ? new _Event_js__WEBPACK_IMPORTED_MODULE_3__["default"](event) : event;
    var type = evt.type;
    evt.target = this;
    var listeners = this.listeners_[type];
    var propagate;
    if (listeners) {
      if (!(type in this.dispatching_)) {
        this.dispatching_[type] = 0;
        this.pendingRemovals_[type] = 0;
      }
      ++this.dispatching_[type];
      for (var i = 0, ii = listeners.length; i < ii; ++i) {
        if (listeners[i].call(this, evt) === false || evt.propagationStopped) {
          propagate = false;
          break;
        }
      }
      --this.dispatching_[type];
      if (this.dispatching_[type] === 0) {
        var pendingRemovals = this.pendingRemovals_[type];
        delete this.pendingRemovals_[type];
        while (pendingRemovals--) {
          this.removeEventListener(type, _functions_js__WEBPACK_IMPORTED_MODULE_2__["VOID"]);
        }
        delete this.dispatching_[type];
      }
      return propagate;
    }
  };

  /**
   * @inheritDoc
   */
  Target.prototype.disposeInternal = function disposeInternal () {
    Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["unlistenAll"])(this);
  };

  /**
   * Get the listeners for a specified event type. Listeners are returned in the
   * order that they will be called in.
   *
   * @param {string} type Type.
   * @return {Array<import("../events.js").ListenerFunction>} Listeners.
   */
  Target.prototype.getListeners = function getListeners (type) {
    return this.listeners_[type];
  };

  /**
   * @param {string=} opt_type Type. If not provided,
   *     `true` will be returned if this event target has any listeners.
   * @return {boolean} Has listeners.
   */
  Target.prototype.hasListener = function hasListener (opt_type) {
    return opt_type ?
      opt_type in this.listeners_ :
      Object.keys(this.listeners_).length > 0;
  };

  /**
   * @param {string} type Type.
   * @param {import("../events.js").ListenerFunction} listener Listener.
   */
  Target.prototype.removeEventListener = function removeEventListener (type, listener) {
    var listeners = this.listeners_[type];
    if (listeners) {
      var index = listeners.indexOf(listener);
      if (type in this.pendingRemovals_) {
        // make listener a no-op, and remove later in #dispatchEvent()
        listeners[index] = _functions_js__WEBPACK_IMPORTED_MODULE_2__["VOID"];
        ++this.pendingRemovals_[type];
      } else {
        listeners.splice(index, 1);
        if (listeners.length === 0) {
          delete this.listeners_[type];
        }
      }
    }
  };

  return Target;
}(_Disposable_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (Target);

//# sourceMappingURL=Target.js.map

/***/ }),

/***/ "./node_modules/ol/events/condition.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/events/condition.js ***!
  \*********************************************/
/*! exports provided: altKeyOnly, altShiftKeysOnly, focus, always, click, mouseActionButton, never, pointerMove, singleClick, doubleClick, noModifierKeys, platformModifierKeyOnly, shiftKeyOnly, targetNotEditable, mouseOnly, primaryAction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "altKeyOnly", function() { return altKeyOnly; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "altShiftKeysOnly", function() { return altShiftKeysOnly; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "focus", function() { return focus; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "always", function() { return always; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "click", function() { return click; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mouseActionButton", function() { return mouseActionButton; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "never", function() { return never; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointerMove", function() { return pointerMove; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "singleClick", function() { return singleClick; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "doubleClick", function() { return doubleClick; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "noModifierKeys", function() { return noModifierKeys; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "platformModifierKeyOnly", function() { return platformModifierKeyOnly; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shiftKeyOnly", function() { return shiftKeyOnly; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "targetNotEditable", function() { return targetNotEditable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mouseOnly", function() { return mouseOnly; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "primaryAction", function() { return primaryAction; });
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MapBrowserEventType.js */ "./node_modules/ol/MapBrowserEventType.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../has.js */ "./node_modules/ol/has.js");
/**
 * @module ol/events/condition
 */






/**
 * A function that takes an {@link module:ol/MapBrowserEvent} and returns a
 * `{boolean}`. If the condition is met, true should be returned.
 *
 * @typedef {function(this: ?, import("../MapBrowserEvent.js").default): boolean} Condition
 */


/**
 * Return `true` if only the alt-key is pressed, `false` otherwise (e.g. when
 * additionally the shift-key is pressed).
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the alt key is pressed.
 * @api
 */
var altKeyOnly = function(mapBrowserEvent) {
  var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (mapBrowserEvent.originalEvent);
  return (
    originalEvent.altKey &&
      !(originalEvent.metaKey || originalEvent.ctrlKey) &&
      !originalEvent.shiftKey);
};


/**
 * Return `true` if only the alt-key and shift-key is pressed, `false` otherwise
 * (e.g. when additionally the platform-modifier-key is pressed).
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the alt and shift keys are pressed.
 * @api
 */
var altShiftKeysOnly = function(mapBrowserEvent) {
  var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (mapBrowserEvent.originalEvent);
  return (
    originalEvent.altKey &&
      !(originalEvent.metaKey || originalEvent.ctrlKey) &&
      originalEvent.shiftKey);
};


/**
 * Return `true` if the map has the focus. This condition requires a map target
 * element with a `tabindex` attribute, e.g. `<div id="map" tabindex="1">`.
 *
 * @param {import("../MapBrowserEvent.js").default} event Map browser event.
 * @return {boolean} The map has the focus.
 * @api
 */
var focus = function(event) {
  return event.target.getTargetElement() === document.activeElement;
};


/**
 * Return always true.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True.
 * @api
 */
var always = _functions_js__WEBPACK_IMPORTED_MODULE_2__["TRUE"];


/**
 * Return `true` if the event is a `click` event, `false` otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `click` event.
 * @api
 */
var click = function(mapBrowserEvent) {
  return mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].CLICK;
};


/**
 * Return `true` if the event has an "action"-producing mouse button.
 *
 * By definition, this includes left-click on windows/linux, and left-click
 * without the ctrl key on Macs.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} The result.
 */
var mouseActionButton = function(mapBrowserEvent) {
  var originalEvent = /** @type {MouseEvent} */ (mapBrowserEvent.originalEvent);
  return originalEvent.button == 0 &&
      !(_has_js__WEBPACK_IMPORTED_MODULE_3__["WEBKIT"] && _has_js__WEBPACK_IMPORTED_MODULE_3__["MAC"] && originalEvent.ctrlKey);
};


/**
 * Return always false.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} False.
 * @api
 */
var never = _functions_js__WEBPACK_IMPORTED_MODULE_2__["FALSE"];


/**
 * Return `true` if the browser event is a `pointermove` event, `false`
 * otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the browser event is a `pointermove` event.
 * @api
 */
var pointerMove = function(mapBrowserEvent) {
  return mapBrowserEvent.type == 'pointermove';
};


/**
 * Return `true` if the event is a map `singleclick` event, `false` otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `singleclick` event.
 * @api
 */
var singleClick = function(mapBrowserEvent) {
  return mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].SINGLECLICK;
};


/**
 * Return `true` if the event is a map `dblclick` event, `false` otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `dblclick` event.
 * @api
 */
var doubleClick = function(mapBrowserEvent) {
  return mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].DBLCLICK;
};


/**
 * Return `true` if no modifier key (alt-, shift- or platform-modifier-key) is
 * pressed.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True only if there no modifier keys are pressed.
 * @api
 */
var noModifierKeys = function(mapBrowserEvent) {
  var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (mapBrowserEvent.originalEvent);
  return (
    !originalEvent.altKey &&
      !(originalEvent.metaKey || originalEvent.ctrlKey) &&
      !originalEvent.shiftKey);
};


/**
 * Return `true` if only the platform-modifier-key (the meta-key on Mac,
 * ctrl-key otherwise) is pressed, `false` otherwise (e.g. when additionally
 * the shift-key is pressed).
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the platform modifier key is pressed.
 * @api
 */
var platformModifierKeyOnly = function(mapBrowserEvent) {
  var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (mapBrowserEvent.originalEvent);
  return !originalEvent.altKey &&
    (_has_js__WEBPACK_IMPORTED_MODULE_3__["MAC"] ? originalEvent.metaKey : originalEvent.ctrlKey) &&
    !originalEvent.shiftKey;
};


/**
 * Return `true` if only the shift-key is pressed, `false` otherwise (e.g. when
 * additionally the alt-key is pressed).
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the shift key is pressed.
 * @api
 */
var shiftKeyOnly = function(mapBrowserEvent) {
  var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (mapBrowserEvent.originalEvent);
  return (
    !originalEvent.altKey &&
      !(originalEvent.metaKey || originalEvent.ctrlKey) &&
      originalEvent.shiftKey);
};


/**
 * Return `true` if the target element is not editable, i.e. not a `<input>`-,
 * `<select>`- or `<textarea>`-element, `false` otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True only if the target element is not editable.
 * @api
 */
var targetNotEditable = function(mapBrowserEvent) {
  var target = mapBrowserEvent.originalEvent.target;
  var tagName = /** @type {Element} */ (target).tagName;
  return (
    tagName !== 'INPUT' &&
      tagName !== 'SELECT' &&
      tagName !== 'TEXTAREA');
};


/**
 * Return `true` if the event originates from a mouse device.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a mouse device.
 * @api
 */
var mouseOnly = function(mapBrowserEvent) {
  var pointerEvent = /** @type {import("../MapBrowserPointerEvent").default} */ (mapBrowserEvent).pointerEvent;
  Object(_asserts_js__WEBPACK_IMPORTED_MODULE_1__["assert"])(pointerEvent !== undefined, 56); // mapBrowserEvent must originate from a pointer event
  // see http://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType
  return pointerEvent.pointerType == 'mouse';
};


/**
 * Return `true` if the event originates from a primary pointer in
 * contact with the surface or if the left mouse button is pressed.
 * See http://www.w3.org/TR/pointerevents/#button-states.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a primary pointer.
 * @api
 */
var primaryAction = function(mapBrowserEvent) {
  var pointerEvent = /** @type {import("../MapBrowserPointerEvent").default} */ (mapBrowserEvent).pointerEvent;
  Object(_asserts_js__WEBPACK_IMPORTED_MODULE_1__["assert"])(pointerEvent !== undefined, 56); // mapBrowserEvent must originate from a pointer event
  return pointerEvent.isPrimary && pointerEvent.button === 0;
};

//# sourceMappingURL=condition.js.map

/***/ }),

/***/ "./node_modules/ol/extent.js":
/*!***********************************!*\
  !*** ./node_modules/ol/extent.js ***!
  \***********************************/
/*! exports provided: boundingExtent, buffer, clone, closestSquaredDistanceXY, containsCoordinate, containsExtent, containsXY, coordinateRelationship, createEmpty, createOrUpdate, createOrUpdateEmpty, createOrUpdateFromCoordinate, createOrUpdateFromCoordinates, createOrUpdateFromFlatCoordinates, createOrUpdateFromRings, equals, extend, extendCoordinate, extendCoordinates, extendFlatCoordinates, extendRings, extendXY, forEachCorner, getArea, getBottomLeft, getBottomRight, getCenter, getCorner, getEnlargedArea, getForViewAndSize, getHeight, getIntersectionArea, getIntersection, getMargin, getSize, getTopLeft, getTopRight, getWidth, intersects, isEmpty, returnOrUpdate, scaleFromCenter, intersectsSegment, applyTransform */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "boundingExtent", function() { return boundingExtent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buffer", function() { return buffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "closestSquaredDistanceXY", function() { return closestSquaredDistanceXY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "containsCoordinate", function() { return containsCoordinate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "containsExtent", function() { return containsExtent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "containsXY", function() { return containsXY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "coordinateRelationship", function() { return coordinateRelationship; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createEmpty", function() { return createEmpty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdate", function() { return createOrUpdate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdateEmpty", function() { return createOrUpdateEmpty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdateFromCoordinate", function() { return createOrUpdateFromCoordinate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdateFromCoordinates", function() { return createOrUpdateFromCoordinates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdateFromFlatCoordinates", function() { return createOrUpdateFromFlatCoordinates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdateFromRings", function() { return createOrUpdateFromRings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendCoordinate", function() { return extendCoordinate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendCoordinates", function() { return extendCoordinates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendFlatCoordinates", function() { return extendFlatCoordinates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendRings", function() { return extendRings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendXY", function() { return extendXY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEachCorner", function() { return forEachCorner; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getArea", function() { return getArea; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBottomLeft", function() { return getBottomLeft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBottomRight", function() { return getBottomRight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCenter", function() { return getCenter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCorner", function() { return getCorner; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getEnlargedArea", function() { return getEnlargedArea; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getForViewAndSize", function() { return getForViewAndSize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getHeight", function() { return getHeight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getIntersectionArea", function() { return getIntersectionArea; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getIntersection", function() { return getIntersection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMargin", function() { return getMargin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSize", function() { return getSize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTopLeft", function() { return getTopLeft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTopRight", function() { return getTopRight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getWidth", function() { return getWidth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersects", function() { return intersects; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEmpty", function() { return isEmpty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "returnOrUpdate", function() { return returnOrUpdate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleFromCenter", function() { return scaleFromCenter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersectsSegment", function() { return intersectsSegment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyTransform", function() { return applyTransform; });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _extent_Corner_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./extent/Corner.js */ "./node_modules/ol/extent/Corner.js");
/* harmony import */ var _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./extent/Relationship.js */ "./node_modules/ol/extent/Relationship.js");
/**
 * @module ol/extent
 */





/**
 * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.
 * @typedef {Array<number>} Extent
 * @api
 */

/**
 * Build an extent that includes all given coordinates.
 *
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @return {Extent} Bounding extent.
 * @api
 */
function boundingExtent(coordinates) {
  var extent = createEmpty();
  for (var i = 0, ii = coordinates.length; i < ii; ++i) {
    extendCoordinate(extent, coordinates[i]);
  }
  return extent;
}


/**
 * @param {Array<number>} xs Xs.
 * @param {Array<number>} ys Ys.
 * @param {Extent=} opt_extent Destination extent.
 * @private
 * @return {Extent} Extent.
 */
function _boundingExtentXYs(xs, ys, opt_extent) {
  var minX = Math.min.apply(null, xs);
  var minY = Math.min.apply(null, ys);
  var maxX = Math.max.apply(null, xs);
  var maxY = Math.max.apply(null, ys);
  return createOrUpdate(minX, minY, maxX, maxY, opt_extent);
}


/**
 * Return extent increased by the provided value.
 * @param {Extent} extent Extent.
 * @param {number} value The amount by which the extent should be buffered.
 * @param {Extent=} opt_extent Extent.
 * @return {Extent} Extent.
 * @api
 */
function buffer(extent, value, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent[0] - value;
    opt_extent[1] = extent[1] - value;
    opt_extent[2] = extent[2] + value;
    opt_extent[3] = extent[3] + value;
    return opt_extent;
  } else {
    return [
      extent[0] - value,
      extent[1] - value,
      extent[2] + value,
      extent[3] + value
    ];
  }
}


/**
 * Creates a clone of an extent.
 *
 * @param {Extent} extent Extent to clone.
 * @param {Extent=} opt_extent Extent.
 * @return {Extent} The clone.
 */
function clone(extent, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent[0];
    opt_extent[1] = extent[1];
    opt_extent[2] = extent[2];
    opt_extent[3] = extent[3];
    return opt_extent;
  } else {
    return extent.slice();
  }
}


/**
 * @param {Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {number} Closest squared distance.
 */
function closestSquaredDistanceXY(extent, x, y) {
  var dx, dy;
  if (x < extent[0]) {
    dx = extent[0] - x;
  } else if (extent[2] < x) {
    dx = x - extent[2];
  } else {
    dx = 0;
  }
  if (y < extent[1]) {
    dy = extent[1] - y;
  } else if (extent[3] < y) {
    dy = y - extent[3];
  } else {
    dy = 0;
  }
  return dx * dx + dy * dy;
}


/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {Extent} extent Extent.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @return {boolean} The coordinate is contained in the extent.
 * @api
 */
function containsCoordinate(extent, coordinate) {
  return containsXY(extent, coordinate[0], coordinate[1]);
}


/**
 * Check if one extent contains another.
 *
 * An extent is deemed contained if it lies completely within the other extent,
 * including if they share one or more edges.
 *
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {boolean} The second extent is contained by or on the edge of the
 *     first.
 * @api
 */
function containsExtent(extent1, extent2) {
  return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] &&
      extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
}


/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {Extent} extent Extent.
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @return {boolean} The x, y values are contained in the extent.
 * @api
 */
function containsXY(extent, x, y) {
  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
}


/**
 * Get the relationship between a coordinate and extent.
 * @param {Extent} extent The extent.
 * @param {import("./coordinate.js").Coordinate} coordinate The coordinate.
 * @return {Relationship} The relationship (bitwise compare with
 *     import("./extent/Relationship.js").Relationship).
 */
function coordinateRelationship(extent, coordinate) {
  var minX = extent[0];
  var minY = extent[1];
  var maxX = extent[2];
  var maxY = extent[3];
  var x = coordinate[0];
  var y = coordinate[1];
  var relationship = _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].UNKNOWN;
  if (x < minX) {
    relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].LEFT;
  } else if (x > maxX) {
    relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].RIGHT;
  }
  if (y < minY) {
    relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].BELOW;
  } else if (y > maxY) {
    relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].ABOVE;
  }
  if (relationship === _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].UNKNOWN) {
    relationship = _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].INTERSECTING;
  }
  return relationship;
}


/**
 * Create an empty extent.
 * @return {Extent} Empty extent.
 * @api
 */
function createEmpty() {
  return [Infinity, Infinity, -Infinity, -Infinity];
}


/**
 * Create a new extent or update the provided extent.
 * @param {number} minX Minimum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxX Maximum X.
 * @param {number} maxY Maximum Y.
 * @param {Extent=} opt_extent Destination extent.
 * @return {Extent} Extent.
 */
function createOrUpdate(minX, minY, maxX, maxY, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = minX;
    opt_extent[1] = minY;
    opt_extent[2] = maxX;
    opt_extent[3] = maxY;
    return opt_extent;
  } else {
    return [minX, minY, maxX, maxY];
  }
}


/**
 * Create a new empty extent or make the provided one empty.
 * @param {Extent=} opt_extent Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateEmpty(opt_extent) {
  return createOrUpdate(
    Infinity, Infinity, -Infinity, -Infinity, opt_extent);
}


/**
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {Extent=} opt_extent Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateFromCoordinate(coordinate, opt_extent) {
  var x = coordinate[0];
  var y = coordinate[1];
  return createOrUpdate(x, y, x, y, opt_extent);
}


/**
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @param {Extent=} opt_extent Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateFromCoordinates(coordinates, opt_extent) {
  var extent = createOrUpdateEmpty(opt_extent);
  return extendCoordinates(extent, coordinates);
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Extent=} opt_extent Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, opt_extent) {
  var extent = createOrUpdateEmpty(opt_extent);
  return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
}

/**
 * @param {Array<Array<import("./coordinate.js").Coordinate>>} rings Rings.
 * @param {Extent=} opt_extent Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateFromRings(rings, opt_extent) {
  var extent = createOrUpdateEmpty(opt_extent);
  return extendRings(extent, rings);
}


/**
 * Determine if two extents are equivalent.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {boolean} The two extents are equivalent.
 * @api
 */
function equals(extent1, extent2) {
  return extent1[0] == extent2[0] && extent1[2] == extent2[2] &&
      extent1[1] == extent2[1] && extent1[3] == extent2[3];
}


/**
 * Modify an extent to include another extent.
 * @param {Extent} extent1 The extent to be modified.
 * @param {Extent} extent2 The extent that will be included in the first.
 * @return {Extent} A reference to the first (extended) extent.
 * @api
 */
function extend(extent1, extent2) {
  if (extent2[0] < extent1[0]) {
    extent1[0] = extent2[0];
  }
  if (extent2[2] > extent1[2]) {
    extent1[2] = extent2[2];
  }
  if (extent2[1] < extent1[1]) {
    extent1[1] = extent2[1];
  }
  if (extent2[3] > extent1[3]) {
    extent1[3] = extent2[3];
  }
  return extent1;
}


/**
 * @param {Extent} extent Extent.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 */
function extendCoordinate(extent, coordinate) {
  if (coordinate[0] < extent[0]) {
    extent[0] = coordinate[0];
  }
  if (coordinate[0] > extent[2]) {
    extent[2] = coordinate[0];
  }
  if (coordinate[1] < extent[1]) {
    extent[1] = coordinate[1];
  }
  if (coordinate[1] > extent[3]) {
    extent[3] = coordinate[1];
  }
}


/**
 * @param {Extent} extent Extent.
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @return {Extent} Extent.
 */
function extendCoordinates(extent, coordinates) {
  for (var i = 0, ii = coordinates.length; i < ii; ++i) {
    extendCoordinate(extent, coordinates[i]);
  }
  return extent;
}


/**
 * @param {Extent} extent Extent.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {Extent} Extent.
 */
function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {
  for (; offset < end; offset += stride) {
    extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
  }
  return extent;
}


/**
 * @param {Extent} extent Extent.
 * @param {Array<Array<import("./coordinate.js").Coordinate>>} rings Rings.
 * @return {Extent} Extent.
 */
function extendRings(extent, rings) {
  for (var i = 0, ii = rings.length; i < ii; ++i) {
    extendCoordinates(extent, rings[i]);
  }
  return extent;
}


/**
 * @param {Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 */
function extendXY(extent, x, y) {
  extent[0] = Math.min(extent[0], x);
  extent[1] = Math.min(extent[1], y);
  extent[2] = Math.max(extent[2], x);
  extent[3] = Math.max(extent[3], y);
}


/**
 * This function calls `callback` for each corner of the extent. If the
 * callback returns a truthy value the function returns that value
 * immediately. Otherwise the function returns `false`.
 * @param {Extent} extent Extent.
 * @param {function(this:T, import("./coordinate.js").Coordinate): S} callback Callback.
 * @param {T=} opt_this Value to use as `this` when executing `callback`.
 * @return {S|boolean} Value.
 * @template S, T
 */
function forEachCorner(extent, callback, opt_this) {
  var val;
  val = callback.call(opt_this, getBottomLeft(extent));
  if (val) {
    return val;
  }
  val = callback.call(opt_this, getBottomRight(extent));
  if (val) {
    return val;
  }
  val = callback.call(opt_this, getTopRight(extent));
  if (val) {
    return val;
  }
  val = callback.call(opt_this, getTopLeft(extent));
  if (val) {
    return val;
  }
  return false;
}


/**
 * Get the size of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Area.
 * @api
 */
function getArea(extent) {
  var area = 0;
  if (!isEmpty(extent)) {
    area = getWidth(extent) * getHeight(extent);
  }
  return area;
}


/**
 * Get the bottom left coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Bottom left coordinate.
 * @api
 */
function getBottomLeft(extent) {
  return [extent[0], extent[1]];
}


/**
 * Get the bottom right coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Bottom right coordinate.
 * @api
 */
function getBottomRight(extent) {
  return [extent[2], extent[1]];
}


/**
 * Get the center coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Center.
 * @api
 */
function getCenter(extent) {
  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
}


/**
 * Get a corner coordinate of an extent.
 * @param {Extent} extent Extent.
 * @param {Corner} corner Corner.
 * @return {import("./coordinate.js").Coordinate} Corner coordinate.
 */
function getCorner(extent, corner) {
  var coordinate;
  if (corner === _extent_Corner_js__WEBPACK_IMPORTED_MODULE_1__["default"].BOTTOM_LEFT) {
    coordinate = getBottomLeft(extent);
  } else if (corner === _extent_Corner_js__WEBPACK_IMPORTED_MODULE_1__["default"].BOTTOM_RIGHT) {
    coordinate = getBottomRight(extent);
  } else if (corner === _extent_Corner_js__WEBPACK_IMPORTED_MODULE_1__["default"].TOP_LEFT) {
    coordinate = getTopLeft(extent);
  } else if (corner === _extent_Corner_js__WEBPACK_IMPORTED_MODULE_1__["default"].TOP_RIGHT) {
    coordinate = getTopRight(extent);
  } else {
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(false, 13); // Invalid corner
  }
  return coordinate;
}


/**
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {number} Enlarged area.
 */
function getEnlargedArea(extent1, extent2) {
  var minX = Math.min(extent1[0], extent2[0]);
  var minY = Math.min(extent1[1], extent2[1]);
  var maxX = Math.max(extent1[2], extent2[2]);
  var maxY = Math.max(extent1[3], extent2[3]);
  return (maxX - minX) * (maxY - minY);
}


/**
 * @param {import("./coordinate.js").Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {import("./size.js").Size} size Size.
 * @param {Extent=} opt_extent Destination extent.
 * @return {Extent} Extent.
 */
function getForViewAndSize(center, resolution, rotation, size, opt_extent) {
  var dx = resolution * size[0] / 2;
  var dy = resolution * size[1] / 2;
  var cosRotation = Math.cos(rotation);
  var sinRotation = Math.sin(rotation);
  var xCos = dx * cosRotation;
  var xSin = dx * sinRotation;
  var yCos = dy * cosRotation;
  var ySin = dy * sinRotation;
  var x = center[0];
  var y = center[1];
  var x0 = x - xCos + ySin;
  var x1 = x - xCos - ySin;
  var x2 = x + xCos - ySin;
  var x3 = x + xCos + ySin;
  var y0 = y - xSin - yCos;
  var y1 = y - xSin + yCos;
  var y2 = y + xSin + yCos;
  var y3 = y + xSin - yCos;
  return createOrUpdate(
    Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3),
    Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3),
    opt_extent);
}


/**
 * Get the height of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Height.
 * @api
 */
function getHeight(extent) {
  return extent[3] - extent[1];
}


/**
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {number} Intersection area.
 */
function getIntersectionArea(extent1, extent2) {
  var intersection = getIntersection(extent1, extent2);
  return getArea(intersection);
}


/**
 * Get the intersection of two extents.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @param {Extent=} opt_extent Optional extent to populate with intersection.
 * @return {Extent} Intersecting extent.
 * @api
 */
function getIntersection(extent1, extent2, opt_extent) {
  var intersection = opt_extent ? opt_extent : createEmpty();
  if (intersects(extent1, extent2)) {
    if (extent1[0] > extent2[0]) {
      intersection[0] = extent1[0];
    } else {
      intersection[0] = extent2[0];
    }
    if (extent1[1] > extent2[1]) {
      intersection[1] = extent1[1];
    } else {
      intersection[1] = extent2[1];
    }
    if (extent1[2] < extent2[2]) {
      intersection[2] = extent1[2];
    } else {
      intersection[2] = extent2[2];
    }
    if (extent1[3] < extent2[3]) {
      intersection[3] = extent1[3];
    } else {
      intersection[3] = extent2[3];
    }
  } else {
    createOrUpdateEmpty(intersection);
  }
  return intersection;
}


/**
 * @param {Extent} extent Extent.
 * @return {number} Margin.
 */
function getMargin(extent) {
  return getWidth(extent) + getHeight(extent);
}


/**
 * Get the size (width, height) of an extent.
 * @param {Extent} extent The extent.
 * @return {import("./size.js").Size} The extent size.
 * @api
 */
function getSize(extent) {
  return [extent[2] - extent[0], extent[3] - extent[1]];
}


/**
 * Get the top left coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Top left coordinate.
 * @api
 */
function getTopLeft(extent) {
  return [extent[0], extent[3]];
}


/**
 * Get the top right coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Top right coordinate.
 * @api
 */
function getTopRight(extent) {
  return [extent[2], extent[3]];
}


/**
 * Get the width of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Width.
 * @api
 */
function getWidth(extent) {
  return extent[2] - extent[0];
}


/**
 * Determine if one extent intersects another.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent.
 * @return {boolean} The two extents intersect.
 * @api
 */
function intersects(extent1, extent2) {
  return extent1[0] <= extent2[2] &&
      extent1[2] >= extent2[0] &&
      extent1[1] <= extent2[3] &&
      extent1[3] >= extent2[1];
}


/**
 * Determine if an extent is empty.
 * @param {Extent} extent Extent.
 * @return {boolean} Is empty.
 * @api
 */
function isEmpty(extent) {
  return extent[2] < extent[0] || extent[3] < extent[1];
}


/**
 * @param {Extent} extent Extent.
 * @param {Extent=} opt_extent Extent.
 * @return {Extent} Extent.
 */
function returnOrUpdate(extent, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent[0];
    opt_extent[1] = extent[1];
    opt_extent[2] = extent[2];
    opt_extent[3] = extent[3];
    return opt_extent;
  } else {
    return extent;
  }
}


/**
 * @param {Extent} extent Extent.
 * @param {number} value Value.
 */
function scaleFromCenter(extent, value) {
  var deltaX = ((extent[2] - extent[0]) / 2) * (value - 1);
  var deltaY = ((extent[3] - extent[1]) / 2) * (value - 1);
  extent[0] -= deltaX;
  extent[2] += deltaX;
  extent[1] -= deltaY;
  extent[3] += deltaY;
}


/**
 * Determine if the segment between two coordinates intersects (crosses,
 * touches, or is contained by) the provided extent.
 * @param {Extent} extent The extent.
 * @param {import("./coordinate.js").Coordinate} start Segment start coordinate.
 * @param {import("./coordinate.js").Coordinate} end Segment end coordinate.
 * @return {boolean} The segment intersects the extent.
 */
function intersectsSegment(extent, start, end) {
  var intersects = false;
  var startRel = coordinateRelationship(extent, start);
  var endRel = coordinateRelationship(extent, end);
  if (startRel === _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].INTERSECTING ||
      endRel === _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].INTERSECTING) {
    intersects = true;
  } else {
    var minX = extent[0];
    var minY = extent[1];
    var maxX = extent[2];
    var maxY = extent[3];
    var startX = start[0];
    var startY = start[1];
    var endX = end[0];
    var endY = end[1];
    var slope = (endY - startY) / (endX - startX);
    var x, y;
    if (!!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].ABOVE) &&
        !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].ABOVE)) {
      // potentially intersects top
      x = endX - ((endY - maxY) / slope);
      intersects = x >= minX && x <= maxX;
    }
    if (!intersects && !!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].RIGHT) &&
        !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].RIGHT)) {
      // potentially intersects right
      y = endY - ((endX - maxX) * slope);
      intersects = y >= minY && y <= maxY;
    }
    if (!intersects && !!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].BELOW) &&
        !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].BELOW)) {
      // potentially intersects bottom
      x = endX - ((endY - minY) / slope);
      intersects = x >= minX && x <= maxX;
    }
    if (!intersects && !!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].LEFT) &&
        !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].LEFT)) {
      // potentially intersects left
      y = endY - ((endX - minX) * slope);
      intersects = y >= minY && y <= maxY;
    }

  }
  return intersects;
}


/**
 * Apply a transform function to the extent.
 * @param {Extent} extent Extent.
 * @param {import("./proj.js").TransformFunction} transformFn Transform function.
 * Called with `[minX, minY, maxX, maxY]` extent coordinates.
 * @param {Extent=} opt_extent Destination extent.
 * @return {Extent} Extent.
 * @api
 */
function applyTransform(extent, transformFn, opt_extent) {
  var coordinates = [
    extent[0], extent[1],
    extent[0], extent[3],
    extent[2], extent[1],
    extent[2], extent[3]
  ];
  transformFn(coordinates, coordinates, 2);
  var xs = [coordinates[0], coordinates[2], coordinates[4], coordinates[6]];
  var ys = [coordinates[1], coordinates[3], coordinates[5], coordinates[7]];
  return _boundingExtentXYs(xs, ys, opt_extent);
}

//# sourceMappingURL=extent.js.map

/***/ }),

/***/ "./node_modules/ol/extent/Corner.js":
/*!******************************************!*\
  !*** ./node_modules/ol/extent/Corner.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/extent/Corner
 */

/**
 * Extent corner.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  BOTTOM_LEFT: 'bottom-left',
  BOTTOM_RIGHT: 'bottom-right',
  TOP_LEFT: 'top-left',
  TOP_RIGHT: 'top-right'
});

//# sourceMappingURL=Corner.js.map

/***/ }),

/***/ "./node_modules/ol/extent/Relationship.js":
/*!************************************************!*\
  !*** ./node_modules/ol/extent/Relationship.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/extent/Relationship
 */

/**
 * Relationship to an extent.
 * @enum {number}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  UNKNOWN: 0,
  INTERSECTING: 1,
  ABOVE: 2,
  RIGHT: 4,
  BELOW: 8,
  LEFT: 16
});

//# sourceMappingURL=Relationship.js.map

/***/ }),

/***/ "./node_modules/ol/featureloader.js":
/*!******************************************!*\
  !*** ./node_modules/ol/featureloader.js ***!
  \******************************************/
/*! exports provided: loadFeaturesXhr, xhr */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadFeaturesXhr", function() { return loadFeaturesXhr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xhr", function() { return xhr; });
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _format_FormatType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./format/FormatType.js */ "./node_modules/ol/format/FormatType.js");
/**
 * @module ol/featureloader
 */



/**
 * {@link module:ol/source/Vector} sources use a function of this type to
 * load features.
 *
 * This function takes an {@link module:ol/extent~Extent} representing the area to be loaded,
 * a `{number}` representing the resolution (map units per pixel) and an
 * {@link module:ol/proj/Projection} for the projection  as
 * arguments. `this` within the function is bound to the
 * {@link module:ol/source/Vector} it's called from.
 *
 * The function is responsible for loading the features and adding them to the
 * source.
 * @typedef {function(this:(import("./source/Vector").default|import("./VectorTile.js").default), import("./extent.js").Extent, number,
 *                    import("./proj/Projection.js").default)} FeatureLoader
 * @api
 */


/**
 * {@link module:ol/source/Vector} sources use a function of this type to
 * get the url to load features from.
 *
 * This function takes an {@link module:ol/extent~Extent} representing the area
 * to be loaded, a `{number}` representing the resolution (map units per pixel)
 * and an {@link module:ol/proj/Projection} for the projection  as
 * arguments and returns a `{string}` representing the URL.
 * @typedef {function(import("./extent.js").Extent, number, import("./proj/Projection.js").default): string} FeatureUrlFunction
 * @api
 */


/**
 * @param {string|FeatureUrlFunction} url Feature URL service.
 * @param {import("./format/Feature.js").default} format Feature format.
 * @param {function(this:import("./VectorTile.js").default, Array<import("./Feature.js").default>, import("./proj/Projection.js").default, import("./extent.js").Extent)|function(this:import("./source/Vector").default, Array<import("./Feature.js").default>)} success
 *     Function called with the loaded features and optionally with the data
 *     projection. Called with the vector tile or source as `this`.
 * @param {function(this:import("./VectorTile.js").default)|function(this:import("./source/Vector").default)} failure
 *     Function called when loading failed. Called with the vector tile or
 *     source as `this`.
 * @return {FeatureLoader} The feature loader.
 */
function loadFeaturesXhr(url, format, success, failure) {
  return (
    /**
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @this {import("./source/Vector").default|import("./VectorTile.js").default}
     */
    function(extent, resolution, projection) {
      var xhr = new XMLHttpRequest();
      xhr.open('GET',
        typeof url === 'function' ? url(extent, resolution, projection) : url,
        true);
      if (format.getType() == _format_FormatType_js__WEBPACK_IMPORTED_MODULE_1__["default"].ARRAY_BUFFER) {
        xhr.responseType = 'arraybuffer';
      }
      /**
       * @param {Event} event Event.
       * @private
       */
      xhr.onload = function(event) {
        // status will be 0 for file:// urls
        if (!xhr.status || xhr.status >= 200 && xhr.status < 300) {
          var type = format.getType();
          /** @type {Document|Node|Object|string|undefined} */
          var source;
          if (type == _format_FormatType_js__WEBPACK_IMPORTED_MODULE_1__["default"].JSON || type == _format_FormatType_js__WEBPACK_IMPORTED_MODULE_1__["default"].TEXT) {
            source = xhr.responseText;
          } else if (type == _format_FormatType_js__WEBPACK_IMPORTED_MODULE_1__["default"].XML) {
            source = xhr.responseXML;
            if (!source) {
              source = new DOMParser().parseFromString(xhr.responseText, 'application/xml');
            }
          } else if (type == _format_FormatType_js__WEBPACK_IMPORTED_MODULE_1__["default"].ARRAY_BUFFER) {
            source = /** @type {ArrayBuffer} */ (xhr.response);
          }
          if (source) {
            success.call(this, format.readFeatures(source,
              {featureProjection: projection}),
            format.readProjection(source), format.getLastExtent());
          } else {
            failure.call(this);
          }
        } else {
          failure.call(this);
        }
      }.bind(this);
      /**
       * @private
       */
      xhr.onerror = function() {
        failure.call(this);
      }.bind(this);
      xhr.send();
    }
  );
}


/**
 * Create an XHR feature loader for a `url` and `format`. The feature loader
 * loads features (with XHR), parses the features, and adds them to the
 * vector source.
 * @param {string|FeatureUrlFunction} url Feature URL service.
 * @param {import("./format/Feature.js").default} format Feature format.
 * @return {FeatureLoader} The feature loader.
 * @api
 */
function xhr(url, format) {
  return loadFeaturesXhr(url, format,
    /**
     * @param {Array<import("./Feature.js").default>} features The loaded features.
     * @param {import("./proj/Projection.js").default} dataProjection Data
     * projection.
     * @this {import("./source/Vector").default|import("./VectorTile.js").default}
     */
    function(features, dataProjection) {
      var sourceOrTile = /** @type {?} */ (this);
      if (typeof sourceOrTile.addFeatures === 'function') {
        /** @type {import("./source/Vector").default} */ (sourceOrTile).addFeatures(features);
      }
    }, /* FIXME handle error */ _functions_js__WEBPACK_IMPORTED_MODULE_0__["VOID"]);
}

//# sourceMappingURL=featureloader.js.map

/***/ }),

/***/ "./node_modules/ol/format/FormatType.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/format/FormatType.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/format/FormatType
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  ARRAY_BUFFER: 'arraybuffer',
  JSON: 'json',
  TEXT: 'text',
  XML: 'xml'
});

//# sourceMappingURL=FormatType.js.map

/***/ }),

/***/ "./node_modules/ol/functions.js":
/*!**************************************!*\
  !*** ./node_modules/ol/functions.js ***!
  \**************************************/
/*! exports provided: TRUE, FALSE, VOID */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TRUE", function() { return TRUE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FALSE", function() { return FALSE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VOID", function() { return VOID; });
/**
 * @module ol/functions
 */

/**
 * Always returns true.
 * @returns {boolean} true.
 */
function TRUE() {
  return true;
}

/**
 * Always returns false.
 * @returns {boolean} false.
 */
function FALSE() {
  return false;
}

/**
 * A reusable function, used e.g. as a default for callbacks.
 *
 * @return {void} Nothing.
 */
function VOID() {}

//# sourceMappingURL=functions.js.map

/***/ }),

/***/ "./node_modules/ol/geom/Circle.js":
/*!****************************************!*\
  !*** ./node_modules/ol/geom/Circle.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _GeometryType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/**
 * @module ol/geom/Circle
 */





/**
 * @classdesc
 * Circle geometry.
 *
 * @api
 */
var Circle = /*@__PURE__*/(function (SimpleGeometry) {
  function Circle(center, opt_radius, opt_layout) {
    SimpleGeometry.call(this);
    if (opt_layout !== undefined && opt_radius === undefined) {
      this.setFlatCoordinates(opt_layout, center);
    } else {
      var radius = opt_radius ? opt_radius : 0;
      this.setCenterAndRadius(center, radius, opt_layout);
    }
  }

  if ( SimpleGeometry ) Circle.__proto__ = SimpleGeometry;
  Circle.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );
  Circle.prototype.constructor = Circle;

  /**
   * Make a complete copy of the geometry.
   * @return {!Circle} Clone.
   * @override
   * @api
   */
  Circle.prototype.clone = function clone () {
    return new Circle(this.flatCoordinates.slice(), undefined, this.layout);
  };

  /**
   * @inheritDoc
   */
  Circle.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {
    var flatCoordinates = this.flatCoordinates;
    var dx = x - flatCoordinates[0];
    var dy = y - flatCoordinates[1];
    var squaredDistance = dx * dx + dy * dy;
    if (squaredDistance < minSquaredDistance) {
      if (squaredDistance === 0) {
        for (var i = 0; i < this.stride; ++i) {
          closestPoint[i] = flatCoordinates[i];
        }
      } else {
        var delta = this.getRadius() / Math.sqrt(squaredDistance);
        closestPoint[0] = flatCoordinates[0] + delta * dx;
        closestPoint[1] = flatCoordinates[1] + delta * dy;
        for (var i$1 = 2; i$1 < this.stride; ++i$1) {
          closestPoint[i$1] = flatCoordinates[i$1];
        }
      }
      closestPoint.length = this.stride;
      return squaredDistance;
    } else {
      return minSquaredDistance;
    }
  };

  /**
   * @inheritDoc
   */
  Circle.prototype.containsXY = function containsXY (x, y) {
    var flatCoordinates = this.flatCoordinates;
    var dx = x - flatCoordinates[0];
    var dy = y - flatCoordinates[1];
    return dx * dx + dy * dy <= this.getRadiusSquared_();
  };

  /**
   * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
   * @return {import("../coordinate.js").Coordinate} Center.
   * @api
   */
  Circle.prototype.getCenter = function getCenter () {
    return this.flatCoordinates.slice(0, this.stride);
  };

  /**
   * @inheritDoc
   */
  Circle.prototype.computeExtent = function computeExtent (extent) {
    var flatCoordinates = this.flatCoordinates;
    var radius = flatCoordinates[this.stride] - flatCoordinates[0];
    return Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["createOrUpdate"])(
      flatCoordinates[0] - radius, flatCoordinates[1] - radius,
      flatCoordinates[0] + radius, flatCoordinates[1] + radius,
      extent);
  };

  /**
   * Return the radius of the circle.
   * @return {number} Radius.
   * @api
   */
  Circle.prototype.getRadius = function getRadius () {
    return Math.sqrt(this.getRadiusSquared_());
  };

  /**
   * @private
   * @return {number} Radius squared.
   */
  Circle.prototype.getRadiusSquared_ = function getRadiusSquared_ () {
    var dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];
    var dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
    return dx * dx + dy * dy;
  };

  /**
   * @inheritDoc
   * @api
   */
  Circle.prototype.getType = function getType () {
    return _GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CIRCLE;
  };

  /**
   * @inheritDoc
   * @api
   */
  Circle.prototype.intersectsExtent = function intersectsExtent (extent) {
    var circleExtent = this.getExtent();
    if (Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["intersects"])(extent, circleExtent)) {
      var center = this.getCenter();

      if (extent[0] <= center[0] && extent[2] >= center[0]) {
        return true;
      }
      if (extent[1] <= center[1] && extent[3] >= center[1]) {
        return true;
      }

      return Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["forEachCorner"])(extent, this.intersectsCoordinate, this);
    }
    return false;

  };

  /**
   * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} center Center.
   * @api
   */
  Circle.prototype.setCenter = function setCenter (center) {
    var stride = this.stride;
    var radius = this.flatCoordinates[stride] - this.flatCoordinates[0];
    var flatCoordinates = center.slice();
    flatCoordinates[stride] = flatCoordinates[0] + radius;
    for (var i = 1; i < stride; ++i) {
      flatCoordinates[stride + i] = center[i];
    }
    this.setFlatCoordinates(this.layout, flatCoordinates);
    this.changed();
  };

  /**
   * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as
   * number) of the circle.
   * @param {!import("../coordinate.js").Coordinate} center Center.
   * @param {number} radius Radius.
   * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
   * @api
   */
  Circle.prototype.setCenterAndRadius = function setCenterAndRadius (center, radius, opt_layout) {
    this.setLayout(opt_layout, center, 0);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    /** @type {Array<number>} */
    var flatCoordinates = this.flatCoordinates;
    var offset = Object(_flat_deflate_js__WEBPACK_IMPORTED_MODULE_3__["deflateCoordinate"])(
      flatCoordinates, 0, center, this.stride);
    flatCoordinates[offset++] = flatCoordinates[0] + radius;
    for (var i = 1, ii = this.stride; i < ii; ++i) {
      flatCoordinates[offset++] = flatCoordinates[i];
    }
    flatCoordinates.length = offset;
    this.changed();
  };

  /**
   * @inheritDoc
   */
  Circle.prototype.getCoordinates = function getCoordinates () {
    return null;
  };

  /**
   * @inheritDoc
   */
  Circle.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {};

  /**
   * Set the radius of the circle. The radius is in the units of the projection.
   * @param {number} radius Radius.
   * @api
   */
  Circle.prototype.setRadius = function setRadius (radius) {
    this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;
    this.changed();
  };

  return Circle;
}(_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_2__["default"]));


/**
 * Transform each coordinate of the circle from one coordinate reference system
 * to another. The geometry is modified in place.
 * If you do not want the geometry modified in place, first clone() it and
 * then use this function on the clone.
 *
 * Internally a circle is currently represented by two points: the center of
 * the circle `[cx, cy]`, and the point to the right of the circle
 * `[cx + r, cy]`. This `transform` function just transforms these two points.
 * So the resulting geometry is also a circle, and that circle does not
 * correspond to the shape that would be obtained by transforming every point
 * of the original circle.
 *
 * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
 *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
 * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
 *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
 * @return {Circle} This geometry.  Note that original geometry is
 *     modified in place.
 * @function
 * @api
 */
Circle.prototype.transform;
/* harmony default export */ __webpack_exports__["default"] = (Circle);

//# sourceMappingURL=Circle.js.map

/***/ }),

/***/ "./node_modules/ol/geom/Geometry.js":
/*!******************************************!*\
  !*** ./node_modules/ol/geom/Geometry.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _flat_transform_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./flat/transform.js */ "./node_modules/ol/geom/flat/transform.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _proj_Units_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../proj/Units.js */ "./node_modules/ol/proj/Units.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/geom/Geometry
 */









/**
 * @type {import("../transform.js").Transform}
 */
var tmpTransform = Object(_transform_js__WEBPACK_IMPORTED_MODULE_6__["create"])();


/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for vector geometries.
 *
 * To get notified of changes to the geometry, register a listener for the
 * generic `change` event on your geometry instance.
 *
 * @abstract
 * @api
 */
var Geometry = /*@__PURE__*/(function (BaseObject) {
  function Geometry() {

    BaseObject.call(this);

    /**
     * @private
     * @type {import("../extent.js").Extent}
     */
    this.extent_ = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["createEmpty"])();

    /**
     * @private
     * @type {number}
     */
    this.extentRevision_ = -1;

    /**
     * @protected
     * @type {Object<string, Geometry>}
     */
    this.simplifiedGeometryCache = {};

    /**
     * @protected
     * @type {number}
     */
    this.simplifiedGeometryMaxMinSquaredTolerance = 0;

    /**
     * @protected
     * @type {number}
     */
    this.simplifiedGeometryRevision = 0;

  }

  if ( BaseObject ) Geometry.__proto__ = BaseObject;
  Geometry.prototype = Object.create( BaseObject && BaseObject.prototype );
  Geometry.prototype.constructor = Geometry;

  /**
   * Make a complete copy of the geometry.
   * @abstract
   * @return {!Geometry} Clone.
   */
  Geometry.prototype.clone = function clone () {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * @abstract
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  Geometry.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  Geometry.prototype.containsXY = function containsXY (x, y) {
    return false;
  };

  /**
   * Return the closest point of the geometry to the passed point as
   * {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} point Point.
   * @param {import("../coordinate.js").Coordinate=} opt_closestPoint Closest point.
   * @return {import("../coordinate.js").Coordinate} Closest point.
   * @api
   */
  Geometry.prototype.getClosestPoint = function getClosestPoint (point, opt_closestPoint) {
    var closestPoint = opt_closestPoint ? opt_closestPoint : [NaN, NaN];
    this.closestPointXY(point[0], point[1], closestPoint, Infinity);
    return closestPoint;
  };

  /**
   * Returns true if this geometry includes the specified coordinate. If the
   * coordinate is on the boundary of the geometry, returns false.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {boolean} Contains coordinate.
   * @api
   */
  Geometry.prototype.intersectsCoordinate = function intersectsCoordinate (coordinate) {
    return this.containsXY(coordinate[0], coordinate[1]);
  };

  /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  Geometry.prototype.computeExtent = function computeExtent (extent) {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Get the extent of the geometry.
   * @param {import("../extent.js").Extent=} opt_extent Extent.
   * @return {import("../extent.js").Extent} extent Extent.
   * @api
   */
  Geometry.prototype.getExtent = function getExtent (opt_extent) {
    if (this.extentRevision_ != this.getRevision()) {
      this.extent_ = this.computeExtent(this.extent_);
      this.extentRevision_ = this.getRevision();
    }
    return Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["returnOrUpdate"])(this.extent_, opt_extent);
  };

  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  Geometry.prototype.rotate = function rotate (angle, anchor) {
    Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number=} opt_sy The scaling factor in the y-direction (defaults to
   *     sx).
   * @param {import("../coordinate.js").Coordinate=} opt_anchor The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  Geometry.prototype.scale = function scale (sx, opt_sy, opt_anchor) {
    Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Create a simplified version of this geometry.  For linestrings, this uses
   * the the {@link
   * https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm
   * Douglas Peucker} algorithm.  For polygons, a quantization-based
   * simplification is used to preserve topology.
   * @param {number} tolerance The tolerance distance for simplification.
   * @return {Geometry} A new, simplified version of the original geometry.
   * @api
   */
  Geometry.prototype.simplify = function simplify (tolerance) {
    return this.getSimplifiedGeometry(tolerance * tolerance);
  };

  /**
   * Create a simplified version of this geometry using the Douglas Peucker
   * algorithm.
   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Geometry} Simplified geometry.
   */
  Geometry.prototype.getSimplifiedGeometry = function getSimplifiedGeometry (squaredTolerance) {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Get the type of this geometry.
   * @abstract
   * @return {import("./GeometryType.js").default} Geometry type.
   */
  Geometry.prototype.getType = function getType () {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Apply a transform function to each coordinate of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @abstract
   * @param {import("../proj.js").TransformFunction} transformFn Transform.
   */
  Geometry.prototype.applyTransform = function applyTransform (transformFn) {
    Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Test if the geometry and the passed extent intersect.
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   */
  Geometry.prototype.intersectsExtent = function intersectsExtent (extent) {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @abstract
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  Geometry.prototype.translate = function translate (deltaX, deltaY) {
    Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Transform each coordinate of the geometry from one coordinate reference
   * system to another. The geometry is modified in place.
   * For example, a line will be transformed to a line and a circle to a circle.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   *
   * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @return {Geometry} This geometry.  Note that original geometry is
   *     modified in place.
   * @api
   */
  Geometry.prototype.transform = function transform (source, destination) {
    /** @type {import("../proj/Projection.js").default} */
    var sourceProj = Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__["get"])(source);
    var transformFn = sourceProj.getUnits() == _proj_Units_js__WEBPACK_IMPORTED_MODULE_5__["default"].TILE_PIXELS ?
      function(inCoordinates, outCoordinates, stride) {
        var pixelExtent = sourceProj.getExtent();
        var projectedExtent = sourceProj.getWorldExtent();
        var scale = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["getHeight"])(projectedExtent) / Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["getHeight"])(pixelExtent);
        Object(_transform_js__WEBPACK_IMPORTED_MODULE_6__["compose"])(tmpTransform,
          projectedExtent[0], projectedExtent[3],
          scale, -scale, 0,
          0, 0);
        Object(_flat_transform_js__WEBPACK_IMPORTED_MODULE_3__["transform2D"])(inCoordinates, 0, inCoordinates.length, stride,
          tmpTransform, outCoordinates);
        return Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__["getTransform"])(sourceProj, destination)(inCoordinates, outCoordinates, stride);
      } :
      Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__["getTransform"])(sourceProj, destination);
    this.applyTransform(transformFn);
    return this;
  };

  return Geometry;
}(_Object_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (Geometry);

//# sourceMappingURL=Geometry.js.map

/***/ }),

/***/ "./node_modules/ol/geom/GeometryLayout.js":
/*!************************************************!*\
  !*** ./node_modules/ol/geom/GeometryLayout.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/geom/GeometryLayout
 */

/**
 * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')
 * or measure ('M') coordinate is available. Supported values are `'XY'`,
 * `'XYZ'`, `'XYM'`, `'XYZM'`.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  XY: 'XY',
  XYZ: 'XYZ',
  XYM: 'XYM',
  XYZM: 'XYZM'
});

//# sourceMappingURL=GeometryLayout.js.map

/***/ }),

/***/ "./node_modules/ol/geom/GeometryType.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/geom/GeometryType.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/geom/GeometryType
 */

/**
 * The geometry type. One of `'Point'`, `'LineString'`, `'LinearRing'`,
 * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,
 * `'GeometryCollection'`, `'Circle'`.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  POINT: 'Point',
  LINE_STRING: 'LineString',
  LINEAR_RING: 'LinearRing',
  POLYGON: 'Polygon',
  MULTI_POINT: 'MultiPoint',
  MULTI_LINE_STRING: 'MultiLineString',
  MULTI_POLYGON: 'MultiPolygon',
  GEOMETRY_COLLECTION: 'GeometryCollection',
  CIRCLE: 'Circle'
});

//# sourceMappingURL=GeometryType.js.map

/***/ }),

/***/ "./node_modules/ol/geom/LineString.js":
/*!********************************************!*\
  !*** ./node_modules/ol/geom/LineString.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GeometryLayout.js */ "./node_modules/ol/geom/GeometryLayout.js");
/* harmony import */ var _GeometryType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _flat_closest_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./flat/closest.js */ "./node_modules/ol/geom/flat/closest.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _flat_inflate_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _flat_interpolate_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./flat/interpolate.js */ "./node_modules/ol/geom/flat/interpolate.js");
/* harmony import */ var _flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./flat/intersectsextent.js */ "./node_modules/ol/geom/flat/intersectsextent.js");
/* harmony import */ var _flat_length_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./flat/length.js */ "./node_modules/ol/geom/flat/length.js");
/* harmony import */ var _flat_segments_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./flat/segments.js */ "./node_modules/ol/geom/flat/segments.js");
/* harmony import */ var _flat_simplify_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./flat/simplify.js */ "./node_modules/ol/geom/flat/simplify.js");
/**
 * @module ol/geom/LineString
 */














/**
 * @classdesc
 * Linestring geometry.
 *
 * @api
 */
var LineString = /*@__PURE__*/(function (SimpleGeometry) {
  function LineString(coordinates, opt_layout) {

    SimpleGeometry.call(this);

    /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */
    this.flatMidpoint_ = null;

    /**
     * @private
     * @type {number}
     */
    this.flatMidpointRevision_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.maxDelta_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.maxDeltaRevision_ = -1;

    if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {
      this.setFlatCoordinates(opt_layout, /** @type {Array<number>} */ (coordinates));
    } else {
      this.setCoordinates(/** @type {Array<import("../coordinate.js").Coordinate>} */ (coordinates), opt_layout);
    }

  }

  if ( SimpleGeometry ) LineString.__proto__ = SimpleGeometry;
  LineString.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );
  LineString.prototype.constructor = LineString;

  /**
   * Append the passed coordinate to the coordinates of the linestring.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @api
   */
  LineString.prototype.appendCoordinate = function appendCoordinate (coordinate) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = coordinate.slice();
    } else {
      Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(this.flatCoordinates, coordinate);
    }
    this.changed();
  };

  /**
   * Make a complete copy of the geometry.
   * @return {!LineString} Clone.
   * @override
   * @api
   */
  LineString.prototype.clone = function clone () {
    return new LineString(this.flatCoordinates.slice(), this.layout);
  };

  /**
   * @inheritDoc
   */
  LineString.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["closestSquaredDistanceXY"])(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(Object(_flat_closest_js__WEBPACK_IMPORTED_MODULE_5__["maxSquaredDelta"])(
        this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
      this.maxDeltaRevision_ = this.getRevision();
    }
    return Object(_flat_closest_js__WEBPACK_IMPORTED_MODULE_5__["assignClosestPoint"])(
      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,
      this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
  };

  /**
   * Iterate over each segment, calling the provided callback.
   * If the callback returns a truthy value the function returns that
   * value immediately. Otherwise the function returns `false`.
   *
   * @param {function(this: S, import("../coordinate.js").Coordinate, import("../coordinate.js").Coordinate): T} callback Function
   *     called for each segment.
   * @return {T|boolean} Value.
   * @template T,S
   * @api
   */
  LineString.prototype.forEachSegment = function forEachSegment$1 (callback) {
    return Object(_flat_segments_js__WEBPACK_IMPORTED_MODULE_11__["forEach"])(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, callback);
  };

  /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `opt_extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * @param {number} m M.
   * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate} Coordinate.
   * @api
   */
  LineString.prototype.getCoordinateAtM = function getCoordinateAtM (m, opt_extrapolate) {
    if (this.layout != _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__["default"].XYM &&
        this.layout != _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__["default"].XYZM) {
      return null;
    }
    var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;
    return Object(_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_8__["lineStringCoordinateAtM"])(this.flatCoordinates, 0,
      this.flatCoordinates.length, this.stride, m, extrapolate);
  };

  /**
   * Return the coordinates of the linestring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @override
   * @api
   */
  LineString.prototype.getCoordinates = function getCoordinates () {
    return Object(_flat_inflate_js__WEBPACK_IMPORTED_MODULE_7__["inflateCoordinates"])(
      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
  };

  /**
   * Return the coordinate at the provided fraction along the linestring.
   * The `fraction` is a number between 0 and 1, where 0 is the start of the
   * linestring and 1 is the end.
   * @param {number} fraction Fraction.
   * @param {import("../coordinate.js").Coordinate=} opt_dest Optional coordinate whose values will
   *     be modified. If not provided, a new coordinate will be returned.
   * @return {import("../coordinate.js").Coordinate} Coordinate of the interpolated point.
   * @api
   */
  LineString.prototype.getCoordinateAt = function getCoordinateAt (fraction, opt_dest) {
    return Object(_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_8__["interpolatePoint"])(
      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,
      fraction, opt_dest);
  };

  /**
   * Return the length of the linestring on projected plane.
   * @return {number} Length (on projected plane).
   * @api
   */
  LineString.prototype.getLength = function getLength () {
    return Object(_flat_length_js__WEBPACK_IMPORTED_MODULE_10__["lineStringLength"])(
      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
  };

  /**
   * @return {Array<number>} Flat midpoint.
   */
  LineString.prototype.getFlatMidpoint = function getFlatMidpoint () {
    if (this.flatMidpointRevision_ != this.getRevision()) {
      this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);
      this.flatMidpointRevision_ = this.getRevision();
    }
    return this.flatMidpoint_;
  };

  /**
   * @inheritDoc
   */
  LineString.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {
    var simplifiedFlatCoordinates = [];
    simplifiedFlatCoordinates.length = Object(_flat_simplify_js__WEBPACK_IMPORTED_MODULE_12__["douglasPeucker"])(
      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,
      squaredTolerance, simplifiedFlatCoordinates, 0);
    return new LineString(simplifiedFlatCoordinates, _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__["default"].XY);
  };

  /**
   * @inheritDoc
   * @api
   */
  LineString.prototype.getType = function getType () {
    return _GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].LINE_STRING;
  };

  /**
   * @inheritDoc
   * @api
   */
  LineString.prototype.intersectsExtent = function intersectsExtent (extent) {
    return Object(_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_9__["intersectsLineString"])(
      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,
      extent);
  };

  /**
   * Set the coordinates of the linestring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {GeometryLayout=} opt_layout Layout.
   * @override
   * @api
   */
  LineString.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 1);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = Object(_flat_deflate_js__WEBPACK_IMPORTED_MODULE_6__["deflateCoordinates"])(
      this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  };

  return LineString;
}(_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_4__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (LineString);

//# sourceMappingURL=LineString.js.map

/***/ }),

/***/ "./node_modules/ol/geom/LinearRing.js":
/*!********************************************!*\
  !*** ./node_modules/ol/geom/LinearRing.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GeometryLayout.js */ "./node_modules/ol/geom/GeometryLayout.js");
/* harmony import */ var _GeometryType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _flat_area_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./flat/area.js */ "./node_modules/ol/geom/flat/area.js");
/* harmony import */ var _flat_closest_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./flat/closest.js */ "./node_modules/ol/geom/flat/closest.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _flat_inflate_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _flat_simplify_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./flat/simplify.js */ "./node_modules/ol/geom/flat/simplify.js");
/**
 * @module ol/geom/LinearRing
 */










/**
 * @classdesc
 * Linear ring geometry. Only used as part of polygon; cannot be rendered
 * on its own.
 *
 * @api
 */
var LinearRing = /*@__PURE__*/(function (SimpleGeometry) {
  function LinearRing(coordinates, opt_layout) {

    SimpleGeometry.call(this);

    /**
     * @private
     * @type {number}
     */
    this.maxDelta_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.maxDeltaRevision_ = -1;

    if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {
      this.setFlatCoordinates(opt_layout, /** @type {Array<number>} */ (coordinates));
    } else {
      this.setCoordinates(/** @type {Array<import("../coordinate.js").Coordinate>} */ (coordinates), opt_layout);
    }

  }

  if ( SimpleGeometry ) LinearRing.__proto__ = SimpleGeometry;
  LinearRing.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );
  LinearRing.prototype.constructor = LinearRing;

  /**
   * Make a complete copy of the geometry.
   * @return {!LinearRing} Clone.
   * @override
   * @api
   */
  LinearRing.prototype.clone = function clone () {
    return new LinearRing(this.flatCoordinates.slice(), this.layout);
  };

  /**
   * @inheritDoc
   */
  LinearRing.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["closestSquaredDistanceXY"])(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(Object(_flat_closest_js__WEBPACK_IMPORTED_MODULE_5__["maxSquaredDelta"])(
        this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
      this.maxDeltaRevision_ = this.getRevision();
    }
    return Object(_flat_closest_js__WEBPACK_IMPORTED_MODULE_5__["assignClosestPoint"])(
      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,
      this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
  };

  /**
   * Return the area of the linear ring on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  LinearRing.prototype.getArea = function getArea () {
    return Object(_flat_area_js__WEBPACK_IMPORTED_MODULE_4__["linearRing"])(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
  };

  /**
   * Return the coordinates of the linear ring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @override
   * @api
   */
  LinearRing.prototype.getCoordinates = function getCoordinates () {
    return Object(_flat_inflate_js__WEBPACK_IMPORTED_MODULE_7__["inflateCoordinates"])(
      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
  };

  /**
   * @inheritDoc
   */
  LinearRing.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {
    var simplifiedFlatCoordinates = [];
    simplifiedFlatCoordinates.length = Object(_flat_simplify_js__WEBPACK_IMPORTED_MODULE_8__["douglasPeucker"])(
      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,
      squaredTolerance, simplifiedFlatCoordinates, 0);
    return new LinearRing(simplifiedFlatCoordinates, _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_1__["default"].XY);
  };

  /**
   * @inheritDoc
   * @api
   */
  LinearRing.prototype.getType = function getType () {
    return _GeometryType_js__WEBPACK_IMPORTED_MODULE_2__["default"].LINEAR_RING;
  };

  /**
   * @inheritDoc
   */
  LinearRing.prototype.intersectsExtent = function intersectsExtent (extent) {
    return false;
  };

  /**
   * Set the coordinates of the linear ring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {GeometryLayout=} opt_layout Layout.
   * @override
   * @api
   */
  LinearRing.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 1);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = Object(_flat_deflate_js__WEBPACK_IMPORTED_MODULE_6__["deflateCoordinates"])(
      this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  };

  return LinearRing;
}(_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_3__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (LinearRing);

//# sourceMappingURL=LinearRing.js.map

/***/ }),

/***/ "./node_modules/ol/geom/MultiLineString.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/geom/MultiLineString.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GeometryLayout.js */ "./node_modules/ol/geom/GeometryLayout.js");
/* harmony import */ var _GeometryType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _LineString_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./LineString.js */ "./node_modules/ol/geom/LineString.js");
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _flat_closest_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./flat/closest.js */ "./node_modules/ol/geom/flat/closest.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _flat_inflate_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _flat_interpolate_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./flat/interpolate.js */ "./node_modules/ol/geom/flat/interpolate.js");
/* harmony import */ var _flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./flat/intersectsextent.js */ "./node_modules/ol/geom/flat/intersectsextent.js");
/* harmony import */ var _flat_simplify_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./flat/simplify.js */ "./node_modules/ol/geom/flat/simplify.js");
/**
 * @module ol/geom/MultiLineString
 */













/**
 * @classdesc
 * Multi-linestring geometry.
 *
 * @api
 */
var MultiLineString = /*@__PURE__*/(function (SimpleGeometry) {
  function MultiLineString(coordinates, opt_layout, opt_ends) {

    SimpleGeometry.call(this);

    /**
     * @type {Array<number>}
     * @private
     */
    this.ends_ = [];

    /**
     * @private
     * @type {number}
     */
    this.maxDelta_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.maxDeltaRevision_ = -1;

    if (Array.isArray(coordinates[0])) {
      this.setCoordinates(/** @type {Array<Array<import("../coordinate.js").Coordinate>>} */ (coordinates), opt_layout);
    } else if (opt_layout !== undefined && opt_ends) {
      this.setFlatCoordinates(opt_layout, /** @type {Array<number>} */ (coordinates));
      this.ends_ = opt_ends;
    } else {
      var layout = this.getLayout();
      var lineStrings = /** @type {Array<LineString>} */ (coordinates);
      var flatCoordinates = [];
      var ends = [];
      for (var i = 0, ii = lineStrings.length; i < ii; ++i) {
        var lineString = lineStrings[i];
        if (i === 0) {
          layout = lineString.getLayout();
        }
        Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(flatCoordinates, lineString.getFlatCoordinates());
        ends.push(flatCoordinates.length);
      }
      this.setFlatCoordinates(layout, flatCoordinates);
      this.ends_ = ends;
    }

  }

  if ( SimpleGeometry ) MultiLineString.__proto__ = SimpleGeometry;
  MultiLineString.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );
  MultiLineString.prototype.constructor = MultiLineString;

  /**
   * Append the passed linestring to the multilinestring.
   * @param {LineString} lineString LineString.
   * @api
   */
  MultiLineString.prototype.appendLineString = function appendLineString (lineString) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = lineString.getFlatCoordinates().slice();
    } else {
      Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(this.flatCoordinates, lineString.getFlatCoordinates().slice());
    }
    this.ends_.push(this.flatCoordinates.length);
    this.changed();
  };

  /**
   * Make a complete copy of the geometry.
   * @return {!MultiLineString} Clone.
   * @override
   * @api
   */
  MultiLineString.prototype.clone = function clone () {
    return new MultiLineString(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
  };

  /**
   * @inheritDoc
   */
  MultiLineString.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["closestSquaredDistanceXY"])(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(Object(_flat_closest_js__WEBPACK_IMPORTED_MODULE_6__["arrayMaxSquaredDelta"])(
        this.flatCoordinates, 0, this.ends_, this.stride, 0));
      this.maxDeltaRevision_ = this.getRevision();
    }
    return Object(_flat_closest_js__WEBPACK_IMPORTED_MODULE_6__["assignClosestArrayPoint"])(
      this.flatCoordinates, 0, this.ends_, this.stride,
      this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
  };

  /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `opt_extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * `opt_interpolate` controls interpolation between consecutive LineStrings
   * within the MultiLineString. If `opt_interpolate` is `true` the coordinates
   * will be linearly interpolated between the last coordinate of one LineString
   * and the first coordinate of the next LineString.  If `opt_interpolate` is
   * `false` then the function will return `null` for Ms falling between
   * LineStrings.
   *
   * @param {number} m M.
   * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.
   * @param {boolean=} opt_interpolate Interpolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate} Coordinate.
   * @api
   */
  MultiLineString.prototype.getCoordinateAtM = function getCoordinateAtM (m, opt_extrapolate, opt_interpolate) {
    if ((this.layout != _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__["default"].XYM &&
         this.layout != _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__["default"].XYZM) ||
        this.flatCoordinates.length === 0) {
      return null;
    }
    var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;
    var interpolate = opt_interpolate !== undefined ? opt_interpolate : false;
    return Object(_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_9__["lineStringsCoordinateAtM"])(this.flatCoordinates, 0,
      this.ends_, this.stride, m, extrapolate, interpolate);
  };

  /**
   * Return the coordinates of the multilinestring.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @override
   * @api
   */
  MultiLineString.prototype.getCoordinates = function getCoordinates () {
    return Object(_flat_inflate_js__WEBPACK_IMPORTED_MODULE_8__["inflateCoordinatesArray"])(
      this.flatCoordinates, 0, this.ends_, this.stride);
  };

  /**
   * @return {Array<number>} Ends.
   */
  MultiLineString.prototype.getEnds = function getEnds () {
    return this.ends_;
  };

  /**
   * Return the linestring at the specified index.
   * @param {number} index Index.
   * @return {LineString} LineString.
   * @api
   */
  MultiLineString.prototype.getLineString = function getLineString (index) {
    if (index < 0 || this.ends_.length <= index) {
      return null;
    }
    return new _LineString_js__WEBPACK_IMPORTED_MODULE_4__["default"](this.flatCoordinates.slice(
      index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
  };

  /**
   * Return the linestrings of this multilinestring.
   * @return {Array<LineString>} LineStrings.
   * @api
   */
  MultiLineString.prototype.getLineStrings = function getLineStrings () {
    var flatCoordinates = this.flatCoordinates;
    var ends = this.ends_;
    var layout = this.layout;
    /** @type {Array<LineString>} */
    var lineStrings = [];
    var offset = 0;
    for (var i = 0, ii = ends.length; i < ii; ++i) {
      var end = ends[i];
      var lineString = new _LineString_js__WEBPACK_IMPORTED_MODULE_4__["default"](flatCoordinates.slice(offset, end), layout);
      lineStrings.push(lineString);
      offset = end;
    }
    return lineStrings;
  };

  /**
   * @return {Array<number>} Flat midpoints.
   */
  MultiLineString.prototype.getFlatMidpoints = function getFlatMidpoints () {
    var midpoints = [];
    var flatCoordinates = this.flatCoordinates;
    var offset = 0;
    var ends = this.ends_;
    var stride = this.stride;
    for (var i = 0, ii = ends.length; i < ii; ++i) {
      var end = ends[i];
      var midpoint = Object(_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_9__["interpolatePoint"])(
        flatCoordinates, offset, end, stride, 0.5);
      Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(midpoints, midpoint);
      offset = end;
    }
    return midpoints;
  };

  /**
   * @inheritDoc
   */
  MultiLineString.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {
    var simplifiedFlatCoordinates = [];
    var simplifiedEnds = [];
    simplifiedFlatCoordinates.length = Object(_flat_simplify_js__WEBPACK_IMPORTED_MODULE_11__["douglasPeuckerArray"])(
      this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance,
      simplifiedFlatCoordinates, 0, simplifiedEnds);
    return new MultiLineString(simplifiedFlatCoordinates, _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__["default"].XY, simplifiedEnds);
  };

  /**
   * @inheritDoc
   * @api
   */
  MultiLineString.prototype.getType = function getType () {
    return _GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].MULTI_LINE_STRING;
  };

  /**
   * @inheritDoc
   * @api
   */
  MultiLineString.prototype.intersectsExtent = function intersectsExtent (extent) {
    return Object(_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_10__["intersectsLineStringArray"])(
      this.flatCoordinates, 0, this.ends_, this.stride, extent);
  };

  /**
   * Set the coordinates of the multilinestring.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {GeometryLayout=} opt_layout Layout.
   * @override
   * @api
   */
  MultiLineString.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 2);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    var ends = Object(_flat_deflate_js__WEBPACK_IMPORTED_MODULE_7__["deflateCoordinatesArray"])(
      this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
    this.changed();
  };

  return MultiLineString;
}(_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_5__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (MultiLineString);

//# sourceMappingURL=MultiLineString.js.map

/***/ }),

/***/ "./node_modules/ol/geom/MultiPoint.js":
/*!********************************************!*\
  !*** ./node_modules/ol/geom/MultiPoint.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _GeometryType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _Point_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Point.js */ "./node_modules/ol/geom/Point.js");
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _flat_inflate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/geom/MultiPoint
 */









/**
 * @classdesc
 * Multi-point geometry.
 *
 * @api
 */
var MultiPoint = /*@__PURE__*/(function (SimpleGeometry) {
  function MultiPoint(coordinates, opt_layout) {
    SimpleGeometry.call(this);
    if (opt_layout && !Array.isArray(coordinates[0])) {
      this.setFlatCoordinates(opt_layout, /** @type {Array<number>} */ (coordinates));
    } else {
      this.setCoordinates(/** @type {Array<import("../coordinate.js").Coordinate>} */ (coordinates), opt_layout);
    }
  }

  if ( SimpleGeometry ) MultiPoint.__proto__ = SimpleGeometry;
  MultiPoint.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );
  MultiPoint.prototype.constructor = MultiPoint;

  /**
   * Append the passed point to this multipoint.
   * @param {Point} point Point.
   * @api
   */
  MultiPoint.prototype.appendPoint = function appendPoint (point) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = point.getFlatCoordinates().slice();
    } else {
      Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(this.flatCoordinates, point.getFlatCoordinates());
    }
    this.changed();
  };

  /**
   * Make a complete copy of the geometry.
   * @return {!MultiPoint} Clone.
   * @override
   * @api
   */
  MultiPoint.prototype.clone = function clone () {
    var multiPoint = new MultiPoint(this.flatCoordinates.slice(), this.layout);
    return multiPoint;
  };

  /**
   * @inheritDoc
   */
  MultiPoint.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["closestSquaredDistanceXY"])(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    var flatCoordinates = this.flatCoordinates;
    var stride = this.stride;
    for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
      var squaredDistance = Object(_math_js__WEBPACK_IMPORTED_MODULE_7__["squaredDistance"])(
        x, y, flatCoordinates[i], flatCoordinates[i + 1]);
      if (squaredDistance < minSquaredDistance) {
        minSquaredDistance = squaredDistance;
        for (var j = 0; j < stride; ++j) {
          closestPoint[j] = flatCoordinates[i + j];
        }
        closestPoint.length = stride;
      }
    }
    return minSquaredDistance;
  };

  /**
   * Return the coordinates of the multipoint.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @override
   * @api
   */
  MultiPoint.prototype.getCoordinates = function getCoordinates () {
    return Object(_flat_inflate_js__WEBPACK_IMPORTED_MODULE_6__["inflateCoordinates"])(
      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
  };

  /**
   * Return the point at the specified index.
   * @param {number} index Index.
   * @return {Point} Point.
   * @api
   */
  MultiPoint.prototype.getPoint = function getPoint (index) {
    var n = !this.flatCoordinates ? 0 : this.flatCoordinates.length / this.stride;
    if (index < 0 || n <= index) {
      return null;
    }
    return new _Point_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.flatCoordinates.slice(
      index * this.stride, (index + 1) * this.stride), this.layout);
  };

  /**
   * Return the points of this multipoint.
   * @return {Array<Point>} Points.
   * @api
   */
  MultiPoint.prototype.getPoints = function getPoints () {
    var flatCoordinates = this.flatCoordinates;
    var layout = this.layout;
    var stride = this.stride;
    /** @type {Array<Point>} */
    var points = [];
    for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
      var point = new _Point_js__WEBPACK_IMPORTED_MODULE_3__["default"](flatCoordinates.slice(i, i + stride), layout);
      points.push(point);
    }
    return points;
  };

  /**
   * @inheritDoc
   * @api
   */
  MultiPoint.prototype.getType = function getType () {
    return _GeometryType_js__WEBPACK_IMPORTED_MODULE_2__["default"].MULTI_POINT;
  };

  /**
   * @inheritDoc
   * @api
   */
  MultiPoint.prototype.intersectsExtent = function intersectsExtent (extent) {
    var flatCoordinates = this.flatCoordinates;
    var stride = this.stride;
    for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
      var x = flatCoordinates[i];
      var y = flatCoordinates[i + 1];
      if (Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["containsXY"])(extent, x, y)) {
        return true;
      }
    }
    return false;
  };

  /**
   * Set the coordinates of the multipoint.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
   * @override
   * @api
   */
  MultiPoint.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 1);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = Object(_flat_deflate_js__WEBPACK_IMPORTED_MODULE_5__["deflateCoordinates"])(
      this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  };

  return MultiPoint;
}(_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_4__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (MultiPoint);

//# sourceMappingURL=MultiPoint.js.map

/***/ }),

/***/ "./node_modules/ol/geom/MultiPolygon.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/geom/MultiPolygon.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GeometryLayout.js */ "./node_modules/ol/geom/GeometryLayout.js");
/* harmony import */ var _GeometryType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _MultiPoint_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MultiPoint.js */ "./node_modules/ol/geom/MultiPoint.js");
/* harmony import */ var _Polygon_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Polygon.js */ "./node_modules/ol/geom/Polygon.js");
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _flat_area_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./flat/area.js */ "./node_modules/ol/geom/flat/area.js");
/* harmony import */ var _flat_center_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./flat/center.js */ "./node_modules/ol/geom/flat/center.js");
/* harmony import */ var _flat_closest_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./flat/closest.js */ "./node_modules/ol/geom/flat/closest.js");
/* harmony import */ var _flat_contains_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./flat/contains.js */ "./node_modules/ol/geom/flat/contains.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _flat_inflate_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _flat_interiorpoint_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./flat/interiorpoint.js */ "./node_modules/ol/geom/flat/interiorpoint.js");
/* harmony import */ var _flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./flat/intersectsextent.js */ "./node_modules/ol/geom/flat/intersectsextent.js");
/* harmony import */ var _flat_orient_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./flat/orient.js */ "./node_modules/ol/geom/flat/orient.js");
/* harmony import */ var _flat_simplify_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./flat/simplify.js */ "./node_modules/ol/geom/flat/simplify.js");
/**
 * @module ol/geom/MultiPolygon
 */


















/**
 * @classdesc
 * Multi-polygon geometry.
 *
 * @api
 */
var MultiPolygon = /*@__PURE__*/(function (SimpleGeometry) {
  function MultiPolygon(coordinates, opt_layout, opt_endss) {

    SimpleGeometry.call(this);

    /**
     * @type {Array<Array<number>>}
     * @private
     */
    this.endss_ = [];

    /**
     * @private
     * @type {number}
     */
    this.flatInteriorPointsRevision_ = -1;

    /**
     * @private
     * @type {Array<number>}
     */
    this.flatInteriorPoints_ = null;

    /**
     * @private
     * @type {number}
     */
    this.maxDelta_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.maxDeltaRevision_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.orientedRevision_ = -1;

    /**
     * @private
     * @type {Array<number>}
     */
    this.orientedFlatCoordinates_ = null;

    if (!opt_endss && !Array.isArray(coordinates[0])) {
      var layout = this.getLayout();
      var polygons = /** @type {Array<Polygon>} */ (coordinates);
      var flatCoordinates = [];
      var endss = [];
      for (var i = 0, ii = polygons.length; i < ii; ++i) {
        var polygon = polygons[i];
        if (i === 0) {
          layout = polygon.getLayout();
        }
        var offset = flatCoordinates.length;
        var ends = polygon.getEnds();
        for (var j = 0, jj = ends.length; j < jj; ++j) {
          ends[j] += offset;
        }
        Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(flatCoordinates, polygon.getFlatCoordinates());
        endss.push(ends);
      }
      opt_layout = layout;
      coordinates = flatCoordinates;
      opt_endss = endss;
    }
    if (opt_layout !== undefined && opt_endss) {
      this.setFlatCoordinates(opt_layout, /** @type {Array<number>} */ (coordinates));
      this.endss_ = opt_endss;
    } else {
      this.setCoordinates(/** @type {Array<Array<Array<import("../coordinate.js").Coordinate>>>} */ (coordinates),
        opt_layout);
    }

  }

  if ( SimpleGeometry ) MultiPolygon.__proto__ = SimpleGeometry;
  MultiPolygon.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );
  MultiPolygon.prototype.constructor = MultiPolygon;

  /**
   * Append the passed polygon to this multipolygon.
   * @param {Polygon} polygon Polygon.
   * @api
   */
  MultiPolygon.prototype.appendPolygon = function appendPolygon (polygon) {
    /** @type {Array<number>} */
    var ends;
    if (!this.flatCoordinates) {
      this.flatCoordinates = polygon.getFlatCoordinates().slice();
      ends = polygon.getEnds().slice();
      this.endss_.push();
    } else {
      var offset = this.flatCoordinates.length;
      Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(this.flatCoordinates, polygon.getFlatCoordinates());
      ends = polygon.getEnds().slice();
      for (var i = 0, ii = ends.length; i < ii; ++i) {
        ends[i] += offset;
      }
    }
    this.endss_.push(ends);
    this.changed();
  };

  /**
   * Make a complete copy of the geometry.
   * @return {!MultiPolygon} Clone.
   * @override
   * @api
   */
  MultiPolygon.prototype.clone = function clone () {
    var len = this.endss_.length;
    var newEndss = new Array(len);
    for (var i = 0; i < len; ++i) {
      newEndss[i] = this.endss_[i].slice();
    }

    return new MultiPolygon(
      this.flatCoordinates.slice(), this.layout, newEndss);
  };

  /**
   * @inheritDoc
   */
  MultiPolygon.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["closestSquaredDistanceXY"])(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(Object(_flat_closest_js__WEBPACK_IMPORTED_MODULE_9__["multiArrayMaxSquaredDelta"])(
        this.flatCoordinates, 0, this.endss_, this.stride, 0));
      this.maxDeltaRevision_ = this.getRevision();
    }
    return Object(_flat_closest_js__WEBPACK_IMPORTED_MODULE_9__["assignClosestMultiArrayPoint"])(
      this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride,
      this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
  };

  /**
   * @inheritDoc
   */
  MultiPolygon.prototype.containsXY = function containsXY (x, y) {
    return Object(_flat_contains_js__WEBPACK_IMPORTED_MODULE_10__["linearRingssContainsXY"])(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);
  };

  /**
   * Return the area of the multipolygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  MultiPolygon.prototype.getArea = function getArea () {
    return Object(_flat_area_js__WEBPACK_IMPORTED_MODULE_7__["linearRingss"])(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);
  };

  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for multi-polygons.
   *
   * @param {boolean=} opt_right Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<Array<import("../coordinate.js").Coordinate>>>} Coordinates.
   * @override
   * @api
   */
  MultiPolygon.prototype.getCoordinates = function getCoordinates (opt_right) {
    var flatCoordinates;
    if (opt_right !== undefined) {
      flatCoordinates = this.getOrientedFlatCoordinates().slice();
      Object(_flat_orient_js__WEBPACK_IMPORTED_MODULE_15__["orientLinearRingsArray"])(
        flatCoordinates, 0, this.endss_, this.stride, opt_right);
    } else {
      flatCoordinates = this.flatCoordinates;
    }

    return Object(_flat_inflate_js__WEBPACK_IMPORTED_MODULE_12__["inflateMultiCoordinatesArray"])(
      flatCoordinates, 0, this.endss_, this.stride);
  };

  /**
   * @return {Array<Array<number>>} Endss.
   */
  MultiPolygon.prototype.getEndss = function getEndss () {
    return this.endss_;
  };

  /**
   * @return {Array<number>} Flat interior points.
   */
  MultiPolygon.prototype.getFlatInteriorPoints = function getFlatInteriorPoints () {
    if (this.flatInteriorPointsRevision_ != this.getRevision()) {
      var flatCenters = Object(_flat_center_js__WEBPACK_IMPORTED_MODULE_8__["linearRingss"])(
        this.flatCoordinates, 0, this.endss_, this.stride);
      this.flatInteriorPoints_ = Object(_flat_interiorpoint_js__WEBPACK_IMPORTED_MODULE_13__["getInteriorPointsOfMultiArray"])(
        this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride,
        flatCenters);
      this.flatInteriorPointsRevision_ = this.getRevision();
    }
    return this.flatInteriorPoints_;
  };

  /**
   * Return the interior points as {@link module:ol/geom/MultiPoint multipoint}.
   * @return {MultiPoint} Interior points as XYM coordinates, where M is
   * the length of the horizontal intersection that the point belongs to.
   * @api
   */
  MultiPolygon.prototype.getInteriorPoints = function getInteriorPoints () {
    return new _MultiPoint_js__WEBPACK_IMPORTED_MODULE_4__["default"](this.getFlatInteriorPoints().slice(), _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__["default"].XYM);
  };

  /**
   * @return {Array<number>} Oriented flat coordinates.
   */
  MultiPolygon.prototype.getOrientedFlatCoordinates = function getOrientedFlatCoordinates () {
    if (this.orientedRevision_ != this.getRevision()) {
      var flatCoordinates = this.flatCoordinates;
      if (Object(_flat_orient_js__WEBPACK_IMPORTED_MODULE_15__["linearRingsAreOriented"])(
        flatCoordinates, 0, this.endss_, this.stride)) {
        this.orientedFlatCoordinates_ = flatCoordinates;
      } else {
        this.orientedFlatCoordinates_ = flatCoordinates.slice();
        this.orientedFlatCoordinates_.length =
            Object(_flat_orient_js__WEBPACK_IMPORTED_MODULE_15__["orientLinearRingsArray"])(
              this.orientedFlatCoordinates_, 0, this.endss_, this.stride);
      }
      this.orientedRevision_ = this.getRevision();
    }
    return this.orientedFlatCoordinates_;
  };

  /**
   * @inheritDoc
   */
  MultiPolygon.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {
    var simplifiedFlatCoordinates = [];
    var simplifiedEndss = [];
    simplifiedFlatCoordinates.length = Object(_flat_simplify_js__WEBPACK_IMPORTED_MODULE_16__["quantizeMultiArray"])(
      this.flatCoordinates, 0, this.endss_, this.stride,
      Math.sqrt(squaredTolerance),
      simplifiedFlatCoordinates, 0, simplifiedEndss);
    return new MultiPolygon(simplifiedFlatCoordinates, _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__["default"].XY, simplifiedEndss);
  };

  /**
   * Return the polygon at the specified index.
   * @param {number} index Index.
   * @return {Polygon} Polygon.
   * @api
   */
  MultiPolygon.prototype.getPolygon = function getPolygon (index) {
    if (index < 0 || this.endss_.length <= index) {
      return null;
    }
    var offset;
    if (index === 0) {
      offset = 0;
    } else {
      var prevEnds = this.endss_[index - 1];
      offset = prevEnds[prevEnds.length - 1];
    }
    var ends = this.endss_[index].slice();
    var end = ends[ends.length - 1];
    if (offset !== 0) {
      for (var i = 0, ii = ends.length; i < ii; ++i) {
        ends[i] -= offset;
      }
    }
    return new _Polygon_js__WEBPACK_IMPORTED_MODULE_5__["default"](this.flatCoordinates.slice(offset, end), this.layout, ends);
  };

  /**
   * Return the polygons of this multipolygon.
   * @return {Array<Polygon>} Polygons.
   * @api
   */
  MultiPolygon.prototype.getPolygons = function getPolygons () {
    var layout = this.layout;
    var flatCoordinates = this.flatCoordinates;
    var endss = this.endss_;
    var polygons = [];
    var offset = 0;
    for (var i = 0, ii = endss.length; i < ii; ++i) {
      var ends = endss[i].slice();
      var end = ends[ends.length - 1];
      if (offset !== 0) {
        for (var j = 0, jj = ends.length; j < jj; ++j) {
          ends[j] -= offset;
        }
      }
      var polygon = new _Polygon_js__WEBPACK_IMPORTED_MODULE_5__["default"](flatCoordinates.slice(offset, end), layout, ends);
      polygons.push(polygon);
      offset = end;
    }
    return polygons;
  };

  /**
   * @inheritDoc
   * @api
   */
  MultiPolygon.prototype.getType = function getType () {
    return _GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].MULTI_POLYGON;
  };

  /**
   * @inheritDoc
   * @api
   */
  MultiPolygon.prototype.intersectsExtent = function intersectsExtent (extent) {
    return Object(_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_14__["intersectsLinearRingMultiArray"])(
      this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);
  };

  /**
   * Set the coordinates of the multipolygon.
   * @param {!Array<Array<Array<import("../coordinate.js").Coordinate>>>} coordinates Coordinates.
   * @param {GeometryLayout=} opt_layout Layout.
   * @override
   * @api
   */
  MultiPolygon.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 3);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    var endss = Object(_flat_deflate_js__WEBPACK_IMPORTED_MODULE_11__["deflateMultiCoordinatesArray"])(
      this.flatCoordinates, 0, coordinates, this.stride, this.endss_);
    if (endss.length === 0) {
      this.flatCoordinates.length = 0;
    } else {
      var lastEnds = endss[endss.length - 1];
      this.flatCoordinates.length = lastEnds.length === 0 ?
        0 : lastEnds[lastEnds.length - 1];
    }
    this.changed();
  };

  return MultiPolygon;
}(_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_6__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (MultiPolygon);

//# sourceMappingURL=MultiPolygon.js.map

/***/ }),

/***/ "./node_modules/ol/geom/Point.js":
/*!***************************************!*\
  !*** ./node_modules/ol/geom/Point.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _GeometryType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/geom/Point
 */






/**
 * @classdesc
 * Point geometry.
 *
 * @api
 */
var Point = /*@__PURE__*/(function (SimpleGeometry) {
  function Point(coordinates, opt_layout) {
    SimpleGeometry.call(this);
    this.setCoordinates(coordinates, opt_layout);
  }

  if ( SimpleGeometry ) Point.__proto__ = SimpleGeometry;
  Point.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );
  Point.prototype.constructor = Point;

  /**
   * Make a complete copy of the geometry.
   * @return {!Point} Clone.
   * @override
   * @api
   */
  Point.prototype.clone = function clone () {
    var point = new Point(this.flatCoordinates.slice(), this.layout);
    return point;
  };

  /**
   * @inheritDoc
   */
  Point.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {
    var flatCoordinates = this.flatCoordinates;
    var squaredDistance = Object(_math_js__WEBPACK_IMPORTED_MODULE_4__["squaredDistance"])(x, y, flatCoordinates[0], flatCoordinates[1]);
    if (squaredDistance < minSquaredDistance) {
      var stride = this.stride;
      for (var i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[i];
      }
      closestPoint.length = stride;
      return squaredDistance;
    } else {
      return minSquaredDistance;
    }
  };

  /**
   * Return the coordinate of the point.
   * @return {import("../coordinate.js").Coordinate} Coordinates.
   * @override
   * @api
   */
  Point.prototype.getCoordinates = function getCoordinates () {
    return !this.flatCoordinates ? [] : this.flatCoordinates.slice();
  };

  /**
   * @inheritDoc
   */
  Point.prototype.computeExtent = function computeExtent (extent) {
    return Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["createOrUpdateFromCoordinate"])(this.flatCoordinates, extent);
  };

  /**
   * @inheritDoc
   * @api
   */
  Point.prototype.getType = function getType () {
    return _GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINT;
  };

  /**
   * @inheritDoc
   * @api
   */
  Point.prototype.intersectsExtent = function intersectsExtent (extent) {
    return Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["containsXY"])(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
  };

  /**
   * @inheritDoc
   * @api
   */
  Point.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 0);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = Object(_flat_deflate_js__WEBPACK_IMPORTED_MODULE_3__["deflateCoordinate"])(
      this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  };

  return Point;
}(_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_2__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (Point);

//# sourceMappingURL=Point.js.map

/***/ }),

/***/ "./node_modules/ol/geom/Polygon.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/geom/Polygon.js ***!
  \*****************************************/
/*! exports provided: default, circular, fromExtent, fromCircle, makeRegular */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circular", function() { return circular; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromExtent", function() { return fromExtent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromCircle", function() { return fromCircle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeRegular", function() { return makeRegular; });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GeometryLayout.js */ "./node_modules/ol/geom/GeometryLayout.js");
/* harmony import */ var _GeometryType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _LinearRing_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./LinearRing.js */ "./node_modules/ol/geom/LinearRing.js");
/* harmony import */ var _Point_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Point.js */ "./node_modules/ol/geom/Point.js");
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _sphere_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../sphere.js */ "./node_modules/ol/sphere.js");
/* harmony import */ var _flat_area_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./flat/area.js */ "./node_modules/ol/geom/flat/area.js");
/* harmony import */ var _flat_closest_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./flat/closest.js */ "./node_modules/ol/geom/flat/closest.js");
/* harmony import */ var _flat_contains_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./flat/contains.js */ "./node_modules/ol/geom/flat/contains.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _flat_inflate_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _flat_interiorpoint_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./flat/interiorpoint.js */ "./node_modules/ol/geom/flat/interiorpoint.js");
/* harmony import */ var _flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./flat/intersectsextent.js */ "./node_modules/ol/geom/flat/intersectsextent.js");
/* harmony import */ var _flat_orient_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./flat/orient.js */ "./node_modules/ol/geom/flat/orient.js");
/* harmony import */ var _flat_simplify_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./flat/simplify.js */ "./node_modules/ol/geom/flat/simplify.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/geom/Polygon
 */



















/**
 * @classdesc
 * Polygon geometry.
 *
 * @api
 */
var Polygon = /*@__PURE__*/(function (SimpleGeometry) {
  function Polygon(coordinates, opt_layout, opt_ends) {

    SimpleGeometry.call(this);

    /**
     * @type {Array<number>}
     * @private
     */
    this.ends_ = [];

    /**
     * @private
     * @type {number}
     */
    this.flatInteriorPointRevision_ = -1;

    /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */
    this.flatInteriorPoint_ = null;

    /**
     * @private
     * @type {number}
     */
    this.maxDelta_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.maxDeltaRevision_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.orientedRevision_ = -1;

    /**
     * @private
     * @type {Array<number>}
     */
    this.orientedFlatCoordinates_ = null;

    if (opt_layout !== undefined && opt_ends) {
      this.setFlatCoordinates(opt_layout, /** @type {Array<number>} */ (coordinates));
      this.ends_ = opt_ends;
    } else {
      this.setCoordinates(/** @type {Array<Array<import("../coordinate.js").Coordinate>>} */ (coordinates), opt_layout);
    }

  }

  if ( SimpleGeometry ) Polygon.__proto__ = SimpleGeometry;
  Polygon.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );
  Polygon.prototype.constructor = Polygon;

  /**
   * Append the passed linear ring to this polygon.
   * @param {LinearRing} linearRing Linear ring.
   * @api
   */
  Polygon.prototype.appendLinearRing = function appendLinearRing (linearRing) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = linearRing.getFlatCoordinates().slice();
    } else {
      Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(this.flatCoordinates, linearRing.getFlatCoordinates());
    }
    this.ends_.push(this.flatCoordinates.length);
    this.changed();
  };

  /**
   * Make a complete copy of the geometry.
   * @return {!Polygon} Clone.
   * @override
   * @api
   */
  Polygon.prototype.clone = function clone () {
    return new Polygon(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
  };

  /**
   * @inheritDoc
   */
  Polygon.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["closestSquaredDistanceXY"])(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(Object(_flat_closest_js__WEBPACK_IMPORTED_MODULE_9__["arrayMaxSquaredDelta"])(
        this.flatCoordinates, 0, this.ends_, this.stride, 0));
      this.maxDeltaRevision_ = this.getRevision();
    }
    return Object(_flat_closest_js__WEBPACK_IMPORTED_MODULE_9__["assignClosestArrayPoint"])(
      this.flatCoordinates, 0, this.ends_, this.stride,
      this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
  };

  /**
   * @inheritDoc
   */
  Polygon.prototype.containsXY = function containsXY (x, y) {
    return Object(_flat_contains_js__WEBPACK_IMPORTED_MODULE_10__["linearRingsContainsXY"])(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);
  };

  /**
   * Return the area of the polygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  Polygon.prototype.getArea = function getArea () {
    return Object(_flat_area_js__WEBPACK_IMPORTED_MODULE_8__["linearRings"])(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);
  };

  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for polygons.
   *
   * @param {boolean=} opt_right Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @override
   * @api
   */
  Polygon.prototype.getCoordinates = function getCoordinates (opt_right) {
    var flatCoordinates;
    if (opt_right !== undefined) {
      flatCoordinates = this.getOrientedFlatCoordinates().slice();
      Object(_flat_orient_js__WEBPACK_IMPORTED_MODULE_15__["orientLinearRings"])(
        flatCoordinates, 0, this.ends_, this.stride, opt_right);
    } else {
      flatCoordinates = this.flatCoordinates;
    }

    return Object(_flat_inflate_js__WEBPACK_IMPORTED_MODULE_12__["inflateCoordinatesArray"])(
      flatCoordinates, 0, this.ends_, this.stride);
  };

  /**
   * @return {Array<number>} Ends.
   */
  Polygon.prototype.getEnds = function getEnds () {
    return this.ends_;
  };

  /**
   * @return {Array<number>} Interior point.
   */
  Polygon.prototype.getFlatInteriorPoint = function getFlatInteriorPoint () {
    if (this.flatInteriorPointRevision_ != this.getRevision()) {
      var flatCenter = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getCenter"])(this.getExtent());
      this.flatInteriorPoint_ = Object(_flat_interiorpoint_js__WEBPACK_IMPORTED_MODULE_13__["getInteriorPointOfArray"])(
        this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride,
        flatCenter, 0);
      this.flatInteriorPointRevision_ = this.getRevision();
    }
    return this.flatInteriorPoint_;
  };

  /**
   * Return an interior point of the polygon.
   * @return {Point} Interior point as XYM coordinate, where M is the
   * length of the horizontal intersection that the point belongs to.
   * @api
   */
  Polygon.prototype.getInteriorPoint = function getInteriorPoint () {
    return new _Point_js__WEBPACK_IMPORTED_MODULE_5__["default"](this.getFlatInteriorPoint(), _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__["default"].XYM);
  };

  /**
   * Return the number of rings of the polygon,  this includes the exterior
   * ring and any interior rings.
   *
   * @return {number} Number of rings.
   * @api
   */
  Polygon.prototype.getLinearRingCount = function getLinearRingCount () {
    return this.ends_.length;
  };

  /**
   * Return the Nth linear ring of the polygon geometry. Return `null` if the
   * given index is out of range.
   * The exterior linear ring is available at index `0` and the interior rings
   * at index `1` and beyond.
   *
   * @param {number} index Index.
   * @return {LinearRing} Linear ring.
   * @api
   */
  Polygon.prototype.getLinearRing = function getLinearRing (index) {
    if (index < 0 || this.ends_.length <= index) {
      return null;
    }
    return new _LinearRing_js__WEBPACK_IMPORTED_MODULE_4__["default"](this.flatCoordinates.slice(
      index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
  };

  /**
   * Return the linear rings of the polygon.
   * @return {Array<LinearRing>} Linear rings.
   * @api
   */
  Polygon.prototype.getLinearRings = function getLinearRings () {
    var layout = this.layout;
    var flatCoordinates = this.flatCoordinates;
    var ends = this.ends_;
    var linearRings = [];
    var offset = 0;
    for (var i = 0, ii = ends.length; i < ii; ++i) {
      var end = ends[i];
      var linearRing = new _LinearRing_js__WEBPACK_IMPORTED_MODULE_4__["default"](flatCoordinates.slice(offset, end), layout);
      linearRings.push(linearRing);
      offset = end;
    }
    return linearRings;
  };

  /**
   * @return {Array<number>} Oriented flat coordinates.
   */
  Polygon.prototype.getOrientedFlatCoordinates = function getOrientedFlatCoordinates () {
    if (this.orientedRevision_ != this.getRevision()) {
      var flatCoordinates = this.flatCoordinates;
      if (Object(_flat_orient_js__WEBPACK_IMPORTED_MODULE_15__["linearRingIsOriented"])(
        flatCoordinates, 0, this.ends_, this.stride)) {
        this.orientedFlatCoordinates_ = flatCoordinates;
      } else {
        this.orientedFlatCoordinates_ = flatCoordinates.slice();
        this.orientedFlatCoordinates_.length =
            Object(_flat_orient_js__WEBPACK_IMPORTED_MODULE_15__["orientLinearRings"])(
              this.orientedFlatCoordinates_, 0, this.ends_, this.stride);
      }
      this.orientedRevision_ = this.getRevision();
    }
    return this.orientedFlatCoordinates_;
  };

  /**
   * @inheritDoc
   */
  Polygon.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {
    var simplifiedFlatCoordinates = [];
    var simplifiedEnds = [];
    simplifiedFlatCoordinates.length = Object(_flat_simplify_js__WEBPACK_IMPORTED_MODULE_16__["quantizeArray"])(
      this.flatCoordinates, 0, this.ends_, this.stride,
      Math.sqrt(squaredTolerance),
      simplifiedFlatCoordinates, 0, simplifiedEnds);
    return new Polygon(simplifiedFlatCoordinates, _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__["default"].XY, simplifiedEnds);
  };

  /**
   * @inheritDoc
   * @api
   */
  Polygon.prototype.getType = function getType () {
    return _GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POLYGON;
  };

  /**
   * @inheritDoc
   * @api
   */
  Polygon.prototype.intersectsExtent = function intersectsExtent (extent) {
    return Object(_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_14__["intersectsLinearRingArray"])(
      this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);
  };

  /**
   * Set the coordinates of the polygon.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {GeometryLayout=} opt_layout Layout.
   * @override
   * @api
   */
  Polygon.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 2);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    var ends = Object(_flat_deflate_js__WEBPACK_IMPORTED_MODULE_11__["deflateCoordinatesArray"])(
      this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
    this.changed();
  };

  return Polygon;
}(_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_6__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (Polygon);


/**
 * Create an approximation of a circle on the surface of a sphere.
 * @param {import("../coordinate.js").Coordinate} center Center (`[lon, lat]` in degrees).
 * @param {number} radius The great-circle distance from the center to
 *     the polygon vertices.
 * @param {number=} opt_n Optional number of vertices for the resulting
 *     polygon. Default is `32`.
 * @param {number=} opt_sphereRadius Optional radius for the sphere (defaults to
 *     the Earth's mean radius using the WGS84 ellipsoid).
 * @return {Polygon} The "circular" polygon.
 * @api
 */
function circular(center, radius, opt_n, opt_sphereRadius) {
  var n = opt_n ? opt_n : 32;
  /** @type {Array<number>} */
  var flatCoordinates = [];
  for (var i = 0; i < n; ++i) {
    Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(flatCoordinates, Object(_sphere_js__WEBPACK_IMPORTED_MODULE_7__["offset"])(center, radius, 2 * Math.PI * i / n, opt_sphereRadius));
  }
  flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);
  return new Polygon(flatCoordinates, _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__["default"].XY, [flatCoordinates.length]);
}


/**
 * Create a polygon from an extent. The layout used is `XY`.
 * @param {import("../extent.js").Extent} extent The extent.
 * @return {Polygon} The polygon.
 * @api
 */
function fromExtent(extent) {
  var minX = extent[0];
  var minY = extent[1];
  var maxX = extent[2];
  var maxY = extent[3];
  var flatCoordinates =
      [minX, minY, minX, maxY, maxX, maxY, maxX, minY, minX, minY];
  return new Polygon(flatCoordinates, _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__["default"].XY, [flatCoordinates.length]);
}


/**
 * Create a regular polygon from a circle.
 * @param {import("./Circle.js").default} circle Circle geometry.
 * @param {number=} opt_sides Number of sides of the polygon. Default is 32.
 * @param {number=} opt_angle Start angle for the first vertex of the polygon in
 *     radians. Default is 0.
 * @return {Polygon} Polygon geometry.
 * @api
 */
function fromCircle(circle, opt_sides, opt_angle) {
  var sides = opt_sides ? opt_sides : 32;
  var stride = circle.getStride();
  var layout = circle.getLayout();
  var center = circle.getCenter();
  var arrayLength = stride * (sides + 1);
  var flatCoordinates = new Array(arrayLength);
  for (var i = 0; i < arrayLength; i += stride) {
    flatCoordinates[i] = 0;
    flatCoordinates[i + 1] = 0;
    for (var j = 2; j < stride; j++) {
      flatCoordinates[i + j] = center[j];
    }
  }
  var ends = [flatCoordinates.length];
  var polygon = new Polygon(flatCoordinates, layout, ends);
  makeRegular(polygon, center, circle.getRadius(), opt_angle);
  return polygon;
}


/**
 * Modify the coordinates of a polygon to make it a regular polygon.
 * @param {Polygon} polygon Polygon geometry.
 * @param {import("../coordinate.js").Coordinate} center Center of the regular polygon.
 * @param {number} radius Radius of the regular polygon.
 * @param {number=} opt_angle Start angle for the first vertex of the polygon in
 *     radians. Default is 0.
 */
function makeRegular(polygon, center, radius, opt_angle) {
  var flatCoordinates = polygon.getFlatCoordinates();
  var stride = polygon.getStride();
  var sides = flatCoordinates.length / stride - 1;
  var startAngle = opt_angle ? opt_angle : 0;
  for (var i = 0; i <= sides; ++i) {
    var offset = i * stride;
    var angle = startAngle + (Object(_math_js__WEBPACK_IMPORTED_MODULE_17__["modulo"])(i, sides) * 2 * Math.PI / sides);
    flatCoordinates[offset] = center[0] + (radius * Math.cos(angle));
    flatCoordinates[offset + 1] = center[1] + (radius * Math.sin(angle));
  }
  polygon.changed();
}

//# sourceMappingURL=Polygon.js.map

/***/ }),

/***/ "./node_modules/ol/geom/SimpleGeometry.js":
/*!************************************************!*\
  !*** ./node_modules/ol/geom/SimpleGeometry.js ***!
  \************************************************/
/*! exports provided: getStrideForLayout, transformGeom2D, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getStrideForLayout", function() { return getStrideForLayout; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformGeom2D", function() { return transformGeom2D; });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _Geometry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Geometry.js */ "./node_modules/ol/geom/Geometry.js");
/* harmony import */ var _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GeometryLayout.js */ "./node_modules/ol/geom/GeometryLayout.js");
/* harmony import */ var _flat_transform_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./flat/transform.js */ "./node_modules/ol/geom/flat/transform.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/geom/SimpleGeometry
 */







/**
 * @classdesc
 * Abstract base class; only used for creating subclasses; do not instantiate
 * in apps, as cannot be rendered.
 *
 * @abstract
 * @api
 */
var SimpleGeometry = /*@__PURE__*/(function (Geometry) {
  function SimpleGeometry() {

    Geometry.call(this);

    /**
     * @protected
     * @type {GeometryLayout}
     */
    this.layout = _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XY;

    /**
     * @protected
     * @type {number}
     */
    this.stride = 2;

    /**
     * @protected
     * @type {Array<number>}
     */
    this.flatCoordinates = null;

  }

  if ( Geometry ) SimpleGeometry.__proto__ = Geometry;
  SimpleGeometry.prototype = Object.create( Geometry && Geometry.prototype );
  SimpleGeometry.prototype.constructor = SimpleGeometry;

  /**
   * @inheritDoc
   */
  SimpleGeometry.prototype.computeExtent = function computeExtent (extent) {
    return Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["createOrUpdateFromFlatCoordinates"])(this.flatCoordinates,
      0, this.flatCoordinates.length, this.stride, extent);
  };

  /**
   * @abstract
   * @return {Array} Coordinates.
   */
  SimpleGeometry.prototype.getCoordinates = function getCoordinates () {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Return the first coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} First coordinate.
   * @api
   */
  SimpleGeometry.prototype.getFirstCoordinate = function getFirstCoordinate () {
    return this.flatCoordinates.slice(0, this.stride);
  };

  /**
   * @return {Array<number>} Flat coordinates.
   */
  SimpleGeometry.prototype.getFlatCoordinates = function getFlatCoordinates () {
    return this.flatCoordinates;
  };

  /**
   * Return the last coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} Last point.
   * @api
   */
  SimpleGeometry.prototype.getLastCoordinate = function getLastCoordinate () {
    return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);
  };

  /**
   * Return the {@link module:ol/geom/GeometryLayout layout} of the geometry.
   * @return {GeometryLayout} Layout.
   * @api
   */
  SimpleGeometry.prototype.getLayout = function getLayout () {
    return this.layout;
  };

  /**
   * @inheritDoc
   */
  SimpleGeometry.prototype.getSimplifiedGeometry = function getSimplifiedGeometry (squaredTolerance) {
    if (this.simplifiedGeometryRevision != this.getRevision()) {
      Object(_obj_js__WEBPACK_IMPORTED_MODULE_5__["clear"])(this.simplifiedGeometryCache);
      this.simplifiedGeometryMaxMinSquaredTolerance = 0;
      this.simplifiedGeometryRevision = this.getRevision();
    }
    // If squaredTolerance is negative or if we know that simplification will not
    // have any effect then just return this.
    if (squaredTolerance < 0 ||
        (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&
         squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance)) {
      return this;
    }
    var key = squaredTolerance.toString();
    if (this.simplifiedGeometryCache.hasOwnProperty(key)) {
      return this.simplifiedGeometryCache[key];
    } else {
      var simplifiedGeometry =
          this.getSimplifiedGeometryInternal(squaredTolerance);
      var simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();
      if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {
        this.simplifiedGeometryCache[key] = simplifiedGeometry;
        return simplifiedGeometry;
      } else {
        // Simplification did not actually remove any coordinates.  We now know
        // that any calls to getSimplifiedGeometry with a squaredTolerance less
        // than or equal to the current squaredTolerance will also not have any
        // effect.  This allows us to short circuit simplification (saving CPU
        // cycles) and prevents the cache of simplified geometries from filling
        // up with useless identical copies of this geometry (saving memory).
        this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
        return this;
      }
    }
  };

  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   * @protected
   */
  SimpleGeometry.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {
    return this;
  };

  /**
   * @return {number} Stride.
   */
  SimpleGeometry.prototype.getStride = function getStride () {
    return this.stride;
  };

  /**
   * @param {GeometryLayout} layout Layout.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   */
  SimpleGeometry.prototype.setFlatCoordinates = function setFlatCoordinates (layout, flatCoordinates) {
    this.stride = getStrideForLayout(layout);
    this.layout = layout;
    this.flatCoordinates = flatCoordinates;
  };

  /**
   * @abstract
   * @param {!Array} coordinates Coordinates.
   * @param {GeometryLayout=} opt_layout Layout.
   */
  SimpleGeometry.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {
    Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * @param {GeometryLayout|undefined} layout Layout.
   * @param {Array} coordinates Coordinates.
   * @param {number} nesting Nesting.
   * @protected
   */
  SimpleGeometry.prototype.setLayout = function setLayout (layout, coordinates, nesting) {
    /** @type {number} */
    var stride;
    if (layout) {
      stride = getStrideForLayout(layout);
    } else {
      for (var i = 0; i < nesting; ++i) {
        if (coordinates.length === 0) {
          this.layout = _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XY;
          this.stride = 2;
          return;
        } else {
          coordinates = /** @type {Array} */ (coordinates[0]);
        }
      }
      stride = coordinates.length;
      layout = getLayoutForStride(stride);
    }
    this.layout = layout;
    this.stride = stride;
  };

  /**
   * @inheritDoc
   * @api
   */
  SimpleGeometry.prototype.applyTransform = function applyTransform (transformFn) {
    if (this.flatCoordinates) {
      transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);
      this.changed();
    }
  };

  /**
   * @inheritDoc
   * @api
   */
  SimpleGeometry.prototype.rotate = function rotate$1 (angle, anchor) {
    var flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      var stride = this.getStride();
      Object(_flat_transform_js__WEBPACK_IMPORTED_MODULE_4__["rotate"])(
        flatCoordinates, 0, flatCoordinates.length,
        stride, angle, anchor, flatCoordinates);
      this.changed();
    }
  };

  /**
   * @inheritDoc
   * @api
   */
  SimpleGeometry.prototype.scale = function scale$1 (sx, opt_sy, opt_anchor) {
    var sy = opt_sy;
    if (sy === undefined) {
      sy = sx;
    }
    var anchor = opt_anchor;
    if (!anchor) {
      anchor = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getCenter"])(this.getExtent());
    }
    var flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      var stride = this.getStride();
      Object(_flat_transform_js__WEBPACK_IMPORTED_MODULE_4__["scale"])(
        flatCoordinates, 0, flatCoordinates.length,
        stride, sx, sy, anchor, flatCoordinates);
      this.changed();
    }
  };

  /**
   * @inheritDoc
   * @api
   */
  SimpleGeometry.prototype.translate = function translate$1 (deltaX, deltaY) {
    var flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      var stride = this.getStride();
      Object(_flat_transform_js__WEBPACK_IMPORTED_MODULE_4__["translate"])(
        flatCoordinates, 0, flatCoordinates.length, stride,
        deltaX, deltaY, flatCoordinates);
      this.changed();
    }
  };

  return SimpleGeometry;
}(_Geometry_js__WEBPACK_IMPORTED_MODULE_2__["default"]));


/**
 * @param {number} stride Stride.
 * @return {GeometryLayout} layout Layout.
 */
function getLayoutForStride(stride) {
  var layout;
  if (stride == 2) {
    layout = _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XY;
  } else if (stride == 3) {
    layout = _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XYZ;
  } else if (stride == 4) {
    layout = _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XYZM;
  }
  return (
    /** @type {GeometryLayout} */ (layout)
  );
}


/**
 * @param {GeometryLayout} layout Layout.
 * @return {number} Stride.
 */
function getStrideForLayout(layout) {
  var stride;
  if (layout == _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XY) {
    stride = 2;
  } else if (layout == _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XYZ || layout == _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XYM) {
    stride = 3;
  } else if (layout == _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XYZM) {
    stride = 4;
  }
  return /** @type {number} */ (stride);
}


/**
 * @param {SimpleGeometry} simpleGeometry Simple geometry.
 * @param {import("../transform.js").Transform} transform Transform.
 * @param {Array<number>=} opt_dest Destination.
 * @return {Array<number>} Transformed flat coordinates.
 */
function transformGeom2D(simpleGeometry, transform, opt_dest) {
  var flatCoordinates = simpleGeometry.getFlatCoordinates();
  if (!flatCoordinates) {
    return null;
  } else {
    var stride = simpleGeometry.getStride();
    return Object(_flat_transform_js__WEBPACK_IMPORTED_MODULE_4__["transform2D"])(
      flatCoordinates, 0, flatCoordinates.length, stride,
      transform, opt_dest);
  }
}

/* harmony default export */ __webpack_exports__["default"] = (SimpleGeometry);

//# sourceMappingURL=SimpleGeometry.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/area.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/geom/flat/area.js ***!
  \*******************************************/
/*! exports provided: linearRing, linearRings, linearRingss */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearRing", function() { return linearRing; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearRings", function() { return linearRings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearRingss", function() { return linearRingss; });
/**
 * @module ol/geom/flat/area
 */


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Area.
 */
function linearRing(flatCoordinates, offset, end, stride) {
  var twiceArea = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    twiceArea += y1 * x2 - x1 * y2;
    x1 = x2;
    y1 = y2;
  }
  return twiceArea / 2;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @return {number} Area.
 */
function linearRings(flatCoordinates, offset, ends, stride) {
  var area = 0;
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    area += linearRing(flatCoordinates, offset, end, stride);
    offset = end;
  }
  return area;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @return {number} Area.
 */
function linearRingss(flatCoordinates, offset, endss, stride) {
  var area = 0;
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    area += linearRings(flatCoordinates, offset, ends, stride);
    offset = ends[ends.length - 1];
  }
  return area;
}

//# sourceMappingURL=area.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/center.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/geom/flat/center.js ***!
  \*********************************************/
/*! exports provided: linearRingss */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearRingss", function() { return linearRingss; });
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/**
 * @module ol/geom/flat/center
 */



/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @return {Array<number>} Flat centers.
 */
function linearRingss(flatCoordinates, offset, endss, stride) {
  var flatCenters = [];
  var extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["createEmpty"])();
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["createOrUpdateFromFlatCoordinates"])(flatCoordinates, offset, ends[0], stride);
    flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);
    offset = ends[ends.length - 1];
  }
  return flatCenters;
}

//# sourceMappingURL=center.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/closest.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/geom/flat/closest.js ***!
  \**********************************************/
/*! exports provided: maxSquaredDelta, arrayMaxSquaredDelta, multiArrayMaxSquaredDelta, assignClosestPoint, assignClosestArrayPoint, assignClosestMultiArrayPoint */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "maxSquaredDelta", function() { return maxSquaredDelta; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arrayMaxSquaredDelta", function() { return arrayMaxSquaredDelta; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiArrayMaxSquaredDelta", function() { return multiArrayMaxSquaredDelta; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assignClosestPoint", function() { return assignClosestPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assignClosestArrayPoint", function() { return assignClosestArrayPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assignClosestMultiArrayPoint", function() { return assignClosestMultiArrayPoint; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/geom/flat/closest
 */



/**
 * Returns the point on the 2D line segment flatCoordinates[offset1] to
 * flatCoordinates[offset2] that is closest to the point (x, y).  Extra
 * dimensions are linearly interpolated.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset1 Offset 1.
 * @param {number} offset2 Offset 2.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 */
function assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {
  var x1 = flatCoordinates[offset1];
  var y1 = flatCoordinates[offset1 + 1];
  var dx = flatCoordinates[offset2] - x1;
  var dy = flatCoordinates[offset2 + 1] - y1;
  var offset;
  if (dx === 0 && dy === 0) {
    offset = offset1;
  } else {
    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      offset = offset2;
    } else if (t > 0) {
      for (var i = 0; i < stride; ++i) {
        closestPoint[i] = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["lerp"])(flatCoordinates[offset1 + i],
          flatCoordinates[offset2 + i], t);
      }
      closestPoint.length = stride;
      return;
    } else {
      offset = offset1;
    }
  }
  for (var i$1 = 0; i$1 < stride; ++i$1) {
    closestPoint[i$1] = flatCoordinates[offset + i$1];
  }
  closestPoint.length = stride;
}


/**
 * Return the squared of the largest distance between any pair of consecutive
 * coordinates.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */
function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {
  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1];
  for (offset += stride; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    var squaredDelta = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["squaredDistance"])(x1, y1, x2, y2);
    if (squaredDelta > max) {
      max = squaredDelta;
    }
    x1 = x2;
    y1 = y2;
  }
  return max;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */
function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    max = maxSquaredDelta(
      flatCoordinates, offset, end, stride, max);
    offset = end;
  }
  return max;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */
function multiArrayMaxSquaredDelta(flatCoordinates, offset, endss, stride, max) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    max = arrayMaxSquaredDelta(
      flatCoordinates, offset, ends, stride, max);
    offset = ends[ends.length - 1];
  }
  return max;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>=} opt_tmpPoint Temporary point object.
 * @return {number} Minimum squared distance.
 */
function assignClosestPoint(flatCoordinates, offset, end,
  stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance,
  opt_tmpPoint) {
  if (offset == end) {
    return minSquaredDistance;
  }
  var i, squaredDistance;
  if (maxDelta === 0) {
    // All points are identical, so just test the first point.
    squaredDistance = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["squaredDistance"])(
      x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);
    if (squaredDistance < minSquaredDistance) {
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[offset + i];
      }
      closestPoint.length = stride;
      return squaredDistance;
    } else {
      return minSquaredDistance;
    }
  }
  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
  var index = offset + stride;
  while (index < end) {
    assignClosest(
      flatCoordinates, index - stride, index, stride, x, y, tmpPoint);
    squaredDistance = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["squaredDistance"])(x, y, tmpPoint[0], tmpPoint[1]);
    if (squaredDistance < minSquaredDistance) {
      minSquaredDistance = squaredDistance;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }
      closestPoint.length = stride;
      index += stride;
    } else {
      // Skip ahead multiple points, because we know that all the skipped
      // points cannot be any closer than the closest point we have found so
      // far.  We know this because we know how close the current point is, how
      // close the closest point we have found so far is, and the maximum
      // distance between consecutive points.  For example, if we're currently
      // at distance 10, the best we've found so far is 3, and that the maximum
      // distance between consecutive points is 2, then we'll need to skip at
      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of
      // finding a closer point.  We use Math.max(..., 1) to ensure that we
      // always advance at least one point, to avoid an infinite loop.
      index += stride * Math.max(
        ((Math.sqrt(squaredDistance) -
            Math.sqrt(minSquaredDistance)) / maxDelta) | 0, 1);
    }
  }
  if (isRing) {
    // Check the closing segment.
    assignClosest(
      flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);
    squaredDistance = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["squaredDistance"])(x, y, tmpPoint[0], tmpPoint[1]);
    if (squaredDistance < minSquaredDistance) {
      minSquaredDistance = squaredDistance;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }
      closestPoint.length = stride;
    }
  }
  return minSquaredDistance;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>=} opt_tmpPoint Temporary point object.
 * @return {number} Minimum squared distance.
 */
function assignClosestArrayPoint(flatCoordinates, offset, ends,
  stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance,
  opt_tmpPoint) {
  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    minSquaredDistance = assignClosestPoint(
      flatCoordinates, offset, end, stride,
      maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
    offset = end;
  }
  return minSquaredDistance;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>=} opt_tmpPoint Temporary point object.
 * @return {number} Minimum squared distance.
 */
function assignClosestMultiArrayPoint(flatCoordinates, offset,
  endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance,
  opt_tmpPoint) {
  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    minSquaredDistance = assignClosestArrayPoint(
      flatCoordinates, offset, ends, stride,
      maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
    offset = ends[ends.length - 1];
  }
  return minSquaredDistance;
}

//# sourceMappingURL=closest.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/contains.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/geom/flat/contains.js ***!
  \***********************************************/
/*! exports provided: linearRingContainsExtent, linearRingContainsXY, linearRingsContainsXY, linearRingssContainsXY */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearRingContainsExtent", function() { return linearRingContainsExtent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearRingContainsXY", function() { return linearRingContainsXY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearRingsContainsXY", function() { return linearRingsContainsXY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearRingssContainsXY", function() { return linearRingssContainsXY; });
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/**
 * @module ol/geom/flat/contains
 */



/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} Contains extent.
 */
function linearRingContainsExtent(flatCoordinates, offset, end, stride, extent) {
  var outside = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["forEachCorner"])(extent,
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains (x, y).
     */
    function(coordinate) {
      return !linearRingContainsXY(flatCoordinates, offset, end, stride, coordinate[0], coordinate[1]);
    });
  return !outside;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */
function linearRingContainsXY(flatCoordinates, offset, end, stride, x, y) {
  // http://geomalgorithms.com/a03-_inclusion.html
  // Copyright 2000 softSurfer, 2012 Dan Sunday
  // This code may be freely used and modified for any purpose
  // providing that this copyright notice is included with it.
  // SoftSurfer makes no warranty for this code, and cannot be held
  // liable for any real or imagined damage resulting from its use.
  // Users of this code must verify correctness for their application.
  var wn = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    if (y1 <= y) {
      if (y2 > y && ((x2 - x1) * (y - y1)) - ((x - x1) * (y2 - y1)) > 0) {
        wn++;
      }
    } else if (y2 <= y && ((x2 - x1) * (y - y1)) - ((x - x1) * (y2 - y1)) < 0) {
      wn--;
    }
    x1 = x2;
    y1 = y2;
  }
  return wn !== 0;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */
function linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y) {
  if (ends.length === 0) {
    return false;
  }
  if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {
    return false;
  }
  for (var i = 1, ii = ends.length; i < ii; ++i) {
    if (linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {
      return false;
    }
  }
  return true;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */
function linearRingssContainsXY(flatCoordinates, offset, endss, stride, x, y) {
  if (endss.length === 0) {
    return false;
  }
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
      return true;
    }
    offset = ends[ends.length - 1];
  }
  return false;
}

//# sourceMappingURL=contains.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/deflate.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/geom/flat/deflate.js ***!
  \**********************************************/
/*! exports provided: deflateCoordinate, deflateCoordinates, deflateCoordinatesArray, deflateMultiCoordinatesArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deflateCoordinate", function() { return deflateCoordinate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deflateCoordinates", function() { return deflateCoordinates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deflateCoordinatesArray", function() { return deflateCoordinatesArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deflateMultiCoordinatesArray", function() { return deflateMultiCoordinatesArray; });
/**
 * @module ol/geom/flat/deflate
 */


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */
function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {
  for (var i = 0, ii = coordinate.length; i < ii; ++i) {
    flatCoordinates[offset++] = coordinate[i];
  }
  return offset;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<import("../../coordinate.js").Coordinate>} coordinates Coordinates.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */
function deflateCoordinates(flatCoordinates, offset, coordinates, stride) {
  for (var i = 0, ii = coordinates.length; i < ii; ++i) {
    var coordinate = coordinates[i];
    for (var j = 0; j < stride; ++j) {
      flatCoordinates[offset++] = coordinate[j];
    }
  }
  return offset;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<import("../../coordinate.js").Coordinate>>} coordinatess Coordinatess.
 * @param {number} stride Stride.
 * @param {Array<number>=} opt_ends Ends.
 * @return {Array<number>} Ends.
 */
function deflateCoordinatesArray(flatCoordinates, offset, coordinatess, stride, opt_ends) {
  var ends = opt_ends ? opt_ends : [];
  var i = 0;
  for (var j = 0, jj = coordinatess.length; j < jj; ++j) {
    var end = deflateCoordinates(
      flatCoordinates, offset, coordinatess[j], stride);
    ends[i++] = end;
    offset = end;
  }
  ends.length = i;
  return ends;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} coordinatesss Coordinatesss.
 * @param {number} stride Stride.
 * @param {Array<Array<number>>=} opt_endss Endss.
 * @return {Array<Array<number>>} Endss.
 */
function deflateMultiCoordinatesArray(flatCoordinates, offset, coordinatesss, stride, opt_endss) {
  var endss = opt_endss ? opt_endss : [];
  var i = 0;
  for (var j = 0, jj = coordinatesss.length; j < jj; ++j) {
    var ends = deflateCoordinatesArray(
      flatCoordinates, offset, coordinatesss[j], stride, endss[i]);
    endss[i++] = ends;
    offset = ends[ends.length - 1];
  }
  endss.length = i;
  return endss;
}

//# sourceMappingURL=deflate.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/inflate.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/geom/flat/inflate.js ***!
  \**********************************************/
/*! exports provided: inflateCoordinates, inflateCoordinatesArray, inflateMultiCoordinatesArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inflateCoordinates", function() { return inflateCoordinates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inflateCoordinatesArray", function() { return inflateCoordinatesArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inflateMultiCoordinatesArray", function() { return inflateMultiCoordinatesArray; });
/**
 * @module ol/geom/flat/inflate
 */


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Array<import("../../coordinate.js").Coordinate>=} opt_coordinates Coordinates.
 * @return {Array<import("../../coordinate.js").Coordinate>} Coordinates.
 */
function inflateCoordinates(flatCoordinates, offset, end, stride, opt_coordinates) {
  var coordinates = opt_coordinates !== undefined ? opt_coordinates : [];
  var i = 0;
  for (var j = offset; j < end; j += stride) {
    coordinates[i++] = flatCoordinates.slice(j, j + stride);
  }
  coordinates.length = i;
  return coordinates;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array<Array<import("../../coordinate.js").Coordinate>>=} opt_coordinatess Coordinatess.
 * @return {Array<Array<import("../../coordinate.js").Coordinate>>} Coordinatess.
 */
function inflateCoordinatesArray(flatCoordinates, offset, ends, stride, opt_coordinatess) {
  var coordinatess = opt_coordinatess !== undefined ? opt_coordinatess : [];
  var i = 0;
  for (var j = 0, jj = ends.length; j < jj; ++j) {
    var end = ends[j];
    coordinatess[i++] = inflateCoordinates(
      flatCoordinates, offset, end, stride, coordinatess[i]);
    offset = end;
  }
  coordinatess.length = i;
  return coordinatess;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>=} opt_coordinatesss
 *     Coordinatesss.
 * @return {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} Coordinatesss.
 */
function inflateMultiCoordinatesArray(flatCoordinates, offset, endss, stride, opt_coordinatesss) {
  var coordinatesss = opt_coordinatesss !== undefined ? opt_coordinatesss : [];
  var i = 0;
  for (var j = 0, jj = endss.length; j < jj; ++j) {
    var ends = endss[j];
    coordinatesss[i++] = inflateCoordinatesArray(
      flatCoordinates, offset, ends, stride, coordinatesss[i]);
    offset = ends[ends.length - 1];
  }
  coordinatesss.length = i;
  return coordinatesss;
}

//# sourceMappingURL=inflate.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/interiorpoint.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/geom/flat/interiorpoint.js ***!
  \****************************************************/
/*! exports provided: getInteriorPointOfArray, getInteriorPointsOfMultiArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getInteriorPointOfArray", function() { return getInteriorPointOfArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getInteriorPointsOfMultiArray", function() { return getInteriorPointsOfMultiArray; });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./contains.js */ "./node_modules/ol/geom/flat/contains.js");
/**
 * @module ol/geom/flat/interiorpoint
 */




/**
 * Calculates a point that is likely to lie in the interior of the linear rings.
 * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array<number>} flatCenters Flat centers.
 * @param {number} flatCentersOffset Flat center offset.
 * @param {Array<number>=} opt_dest Destination.
 * @return {Array<number>} Destination point as XYM coordinate, where M is the
 * length of the horizontal intersection that the point belongs to.
 */
function getInteriorPointOfArray(flatCoordinates, offset,
  ends, stride, flatCenters, flatCentersOffset, opt_dest) {
  var i, ii, x, x1, x2, y1, y2;
  var y = flatCenters[flatCentersOffset + 1];
  /** @type {Array<number>} */
  var intersections = [];
  // Calculate intersections with the horizontal line
  for (var r = 0, rr = ends.length; r < rr; ++r) {
    var end = ends[r];
    x1 = flatCoordinates[end - stride];
    y1 = flatCoordinates[end - stride + 1];
    for (i = offset; i < end; i += stride) {
      x2 = flatCoordinates[i];
      y2 = flatCoordinates[i + 1];
      if ((y <= y1 && y2 <= y) || (y1 <= y && y <= y2)) {
        x = (y - y1) / (y2 - y1) * (x2 - x1) + x1;
        intersections.push(x);
      }
      x1 = x2;
      y1 = y2;
    }
  }
  // Find the longest segment of the horizontal line that has its center point
  // inside the linear ring.
  var pointX = NaN;
  var maxSegmentLength = -Infinity;
  intersections.sort(_array_js__WEBPACK_IMPORTED_MODULE_0__["numberSafeCompareFunction"]);
  x1 = intersections[0];
  for (i = 1, ii = intersections.length; i < ii; ++i) {
    x2 = intersections[i];
    var segmentLength = Math.abs(x2 - x1);
    if (segmentLength > maxSegmentLength) {
      x = (x1 + x2) / 2;
      if (Object(_contains_js__WEBPACK_IMPORTED_MODULE_1__["linearRingsContainsXY"])(flatCoordinates, offset, ends, stride, x, y)) {
        pointX = x;
        maxSegmentLength = segmentLength;
      }
    }
    x1 = x2;
  }
  if (isNaN(pointX)) {
    // There is no horizontal line that has its center point inside the linear
    // ring.  Use the center of the the linear ring's extent.
    pointX = flatCenters[flatCentersOffset];
  }
  if (opt_dest) {
    opt_dest.push(pointX, y, maxSegmentLength);
    return opt_dest;
  } else {
    return [pointX, y, maxSegmentLength];
  }
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array<number>} flatCenters Flat centers.
 * @return {Array<number>} Interior points as XYM coordinates, where M is the
 * length of the horizontal intersection that the point belongs to.
 */
function getInteriorPointsOfMultiArray(flatCoordinates, offset, endss, stride, flatCenters) {
  var interiorPoints = [];
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    interiorPoints = getInteriorPointOfArray(flatCoordinates,
      offset, ends, stride, flatCenters, 2 * i, interiorPoints);
    offset = ends[ends.length - 1];
  }
  return interiorPoints;
}

//# sourceMappingURL=interiorpoint.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/interpolate.js":
/*!**************************************************!*\
  !*** ./node_modules/ol/geom/flat/interpolate.js ***!
  \**************************************************/
/*! exports provided: interpolatePoint, lineStringCoordinateAtM, lineStringsCoordinateAtM */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interpolatePoint", function() { return interpolatePoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineStringCoordinateAtM", function() { return lineStringCoordinateAtM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineStringsCoordinateAtM", function() { return lineStringsCoordinateAtM; });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/geom/flat/interpolate
 */




/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} fraction Fraction.
 * @param {Array<number>=} opt_dest Destination.
 * @return {Array<number>} Destination.
 */
function interpolatePoint(flatCoordinates, offset, end, stride, fraction, opt_dest) {
  var pointX = NaN;
  var pointY = NaN;
  var n = (end - offset) / stride;
  if (n === 1) {
    pointX = flatCoordinates[offset];
    pointY = flatCoordinates[offset + 1];
  } else if (n == 2) {
    pointX = (1 - fraction) * flatCoordinates[offset] +
        fraction * flatCoordinates[offset + stride];
    pointY = (1 - fraction) * flatCoordinates[offset + 1] +
        fraction * flatCoordinates[offset + stride + 1];
  } else if (n !== 0) {
    var x1 = flatCoordinates[offset];
    var y1 = flatCoordinates[offset + 1];
    var length = 0;
    var cumulativeLengths = [0];
    for (var i = offset + stride; i < end; i += stride) {
      var x2 = flatCoordinates[i];
      var y2 = flatCoordinates[i + 1];
      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
      cumulativeLengths.push(length);
      x1 = x2;
      y1 = y2;
    }
    var target = fraction * length;
    var index = Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["binarySearch"])(cumulativeLengths, target);
    if (index < 0) {
      var t = (target - cumulativeLengths[-index - 2]) /
          (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);
      var o = offset + (-index - 2) * stride;
      pointX = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["lerp"])(
        flatCoordinates[o], flatCoordinates[o + stride], t);
      pointY = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["lerp"])(
        flatCoordinates[o + 1], flatCoordinates[o + stride + 1], t);
    } else {
      pointX = flatCoordinates[offset + index * stride];
      pointY = flatCoordinates[offset + index * stride + 1];
    }
  }
  if (opt_dest) {
    opt_dest[0] = pointX;
    opt_dest[1] = pointY;
    return opt_dest;
  } else {
    return [pointX, pointY];
  }
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} m M.
 * @param {boolean} extrapolate Extrapolate.
 * @return {import("../../coordinate.js").Coordinate} Coordinate.
 */
function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {
  if (end == offset) {
    return null;
  }
  var coordinate;
  if (m < flatCoordinates[offset + stride - 1]) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(offset, offset + stride);
      coordinate[stride - 1] = m;
      return coordinate;
    } else {
      return null;
    }
  } else if (flatCoordinates[end - 1] < m) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(end - stride, end);
      coordinate[stride - 1] = m;
      return coordinate;
    } else {
      return null;
    }
  }
  // FIXME use O(1) search
  if (m == flatCoordinates[offset + stride - 1]) {
    return flatCoordinates.slice(offset, offset + stride);
  }
  var lo = offset / stride;
  var hi = end / stride;
  while (lo < hi) {
    var mid = (lo + hi) >> 1;
    if (m < flatCoordinates[(mid + 1) * stride - 1]) {
      hi = mid;
    } else {
      lo = mid + 1;
    }
  }
  var m0 = flatCoordinates[lo * stride - 1];
  if (m == m0) {
    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);
  }
  var m1 = flatCoordinates[(lo + 1) * stride - 1];
  var t = (m - m0) / (m1 - m0);
  coordinate = [];
  for (var i = 0; i < stride - 1; ++i) {
    coordinate.push(Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["lerp"])(flatCoordinates[(lo - 1) * stride + i],
      flatCoordinates[lo * stride + i], t));
  }
  coordinate.push(m);
  return coordinate;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} m M.
 * @param {boolean} extrapolate Extrapolate.
 * @param {boolean} interpolate Interpolate.
 * @return {import("../../coordinate.js").Coordinate} Coordinate.
 */
function lineStringsCoordinateAtM(
  flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {
  if (interpolate) {
    return lineStringCoordinateAtM(
      flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);
  }
  var coordinate;
  if (m < flatCoordinates[stride - 1]) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(0, stride);
      coordinate[stride - 1] = m;
      return coordinate;
    } else {
      return null;
    }
  }
  if (flatCoordinates[flatCoordinates.length - 1] < m) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);
      coordinate[stride - 1] = m;
      return coordinate;
    } else {
      return null;
    }
  }
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    if (offset == end) {
      continue;
    }
    if (m < flatCoordinates[offset + stride - 1]) {
      return null;
    } else if (m <= flatCoordinates[end - 1]) {
      return lineStringCoordinateAtM(
        flatCoordinates, offset, end, stride, m, false);
    }
    offset = end;
  }
  return null;
}

//# sourceMappingURL=interpolate.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/intersectsextent.js":
/*!*******************************************************!*\
  !*** ./node_modules/ol/geom/flat/intersectsextent.js ***!
  \*******************************************************/
/*! exports provided: intersectsLineString, intersectsLineStringArray, intersectsLinearRing, intersectsLinearRingArray, intersectsLinearRingMultiArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersectsLineString", function() { return intersectsLineString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersectsLineStringArray", function() { return intersectsLineStringArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersectsLinearRing", function() { return intersectsLinearRing; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersectsLinearRingArray", function() { return intersectsLinearRingArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersectsLinearRingMultiArray", function() { return intersectsLinearRingMultiArray; });
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./contains.js */ "./node_modules/ol/geom/flat/contains.js");
/* harmony import */ var _segments_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./segments.js */ "./node_modules/ol/geom/flat/segments.js");
/**
 * @module ol/geom/flat/intersectsextent
 */





/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
function intersectsLineString(flatCoordinates, offset, end, stride, extent) {
  var coordinatesExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["extendFlatCoordinates"])(
    Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["createEmpty"])(), flatCoordinates, offset, end, stride);
  if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["intersects"])(extent, coordinatesExtent)) {
    return false;
  }
  if (Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["containsExtent"])(extent, coordinatesExtent)) {
    return true;
  }
  if (coordinatesExtent[0] >= extent[0] &&
      coordinatesExtent[2] <= extent[2]) {
    return true;
  }
  if (coordinatesExtent[1] >= extent[1] &&
      coordinatesExtent[3] <= extent[3]) {
    return true;
  }
  return Object(_segments_js__WEBPACK_IMPORTED_MODULE_2__["forEach"])(flatCoordinates, offset, end, stride,
    /**
     * @param {import("../../coordinate.js").Coordinate} point1 Start point.
     * @param {import("../../coordinate.js").Coordinate} point2 End point.
     * @return {boolean} `true` if the segment and the extent intersect,
     *     `false` otherwise.
     */
    function(point1, point2) {
      return Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["intersectsSegment"])(extent, point1, point2);
    });
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
function intersectsLineStringArray(flatCoordinates, offset, ends, stride, extent) {
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    if (intersectsLineString(
      flatCoordinates, offset, ends[i], stride, extent)) {
      return true;
    }
    offset = ends[i];
  }
  return false;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
function intersectsLinearRing(flatCoordinates, offset, end, stride, extent) {
  if (intersectsLineString(
    flatCoordinates, offset, end, stride, extent)) {
    return true;
  }
  if (Object(_contains_js__WEBPACK_IMPORTED_MODULE_1__["linearRingContainsXY"])(flatCoordinates, offset, end, stride, extent[0], extent[1])) {
    return true;
  }
  if (Object(_contains_js__WEBPACK_IMPORTED_MODULE_1__["linearRingContainsXY"])(flatCoordinates, offset, end, stride, extent[0], extent[3])) {
    return true;
  }
  if (Object(_contains_js__WEBPACK_IMPORTED_MODULE_1__["linearRingContainsXY"])(flatCoordinates, offset, end, stride, extent[2], extent[1])) {
    return true;
  }
  if (Object(_contains_js__WEBPACK_IMPORTED_MODULE_1__["linearRingContainsXY"])(flatCoordinates, offset, end, stride, extent[2], extent[3])) {
    return true;
  }
  return false;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
function intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent) {
  if (!intersectsLinearRing(
    flatCoordinates, offset, ends[0], stride, extent)) {
    return false;
  }
  if (ends.length === 1) {
    return true;
  }
  for (var i = 1, ii = ends.length; i < ii; ++i) {
    if (Object(_contains_js__WEBPACK_IMPORTED_MODULE_1__["linearRingContainsExtent"])(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
      if (!intersectsLineString(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
        return false;
      }
    }
  }
  return true;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
function intersectsLinearRingMultiArray(flatCoordinates, offset, endss, stride, extent) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    if (intersectsLinearRingArray(
      flatCoordinates, offset, ends, stride, extent)) {
      return true;
    }
    offset = ends[ends.length - 1];
  }
  return false;
}

//# sourceMappingURL=intersectsextent.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/length.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/geom/flat/length.js ***!
  \*********************************************/
/*! exports provided: lineStringLength, linearRingLength */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineStringLength", function() { return lineStringLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearRingLength", function() { return linearRingLength; });
/**
 * @module ol/geom/flat/length
 */


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Length.
 */
function lineStringLength(flatCoordinates, offset, end, stride) {
  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1];
  var length = 0;
  for (var i = offset + stride; i < end; i += stride) {
    var x2 = flatCoordinates[i];
    var y2 = flatCoordinates[i + 1];
    length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    x1 = x2;
    y1 = y2;
  }
  return length;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Perimeter.
 */
function linearRingLength(flatCoordinates, offset, end, stride) {
  var perimeter = lineStringLength(flatCoordinates, offset, end, stride);
  var dx = flatCoordinates[end - stride] - flatCoordinates[offset];
  var dy = flatCoordinates[end - stride + 1] - flatCoordinates[offset + 1];
  perimeter += Math.sqrt(dx * dx + dy * dy);
  return perimeter;
}

//# sourceMappingURL=length.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/orient.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/geom/flat/orient.js ***!
  \*********************************************/
/*! exports provided: linearRingIsClockwise, linearRingIsOriented, linearRingsAreOriented, orientLinearRings, orientLinearRingsArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearRingIsClockwise", function() { return linearRingIsClockwise; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearRingIsOriented", function() { return linearRingIsOriented; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearRingsAreOriented", function() { return linearRingsAreOriented; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "orientLinearRings", function() { return orientLinearRings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "orientLinearRingsArray", function() { return orientLinearRingsArray; });
/* harmony import */ var _reverse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reverse.js */ "./node_modules/ol/geom/flat/reverse.js");
/**
 * @module ol/geom/flat/orient
 */



/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {boolean} Is clockwise.
 */
function linearRingIsClockwise(flatCoordinates, offset, end, stride) {
  // http://tinyurl.com/clockwise-method
  // https://github.com/OSGeo/gdal/blob/trunk/gdal/ogr/ogrlinearring.cpp
  var edge = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    edge += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }
  return edge > 0;
}


/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `opt_right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean=} opt_right Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */
function linearRingIsOriented(flatCoordinates, offset, ends, stride, opt_right) {
  var right = opt_right !== undefined ? opt_right : false;
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    var isClockwise = linearRingIsClockwise(
      flatCoordinates, offset, end, stride);
    if (i === 0) {
      if ((right && isClockwise) || (!right && !isClockwise)) {
        return false;
      }
    } else {
      if ((right && !isClockwise) || (!right && isClockwise)) {
        return false;
      }
    }
    offset = end;
  }
  return true;
}


/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `opt_right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean=} opt_right Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */
function linearRingsAreOriented(flatCoordinates, offset, endss, stride, opt_right) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    if (!linearRingIsOriented(
      flatCoordinates, offset, endss[i], stride, opt_right)) {
      return false;
    }
  }
  return true;
}


/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `opt_right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {boolean=} opt_right Follow the right-hand rule for orientation.
 * @return {number} End.
 */
function orientLinearRings(flatCoordinates, offset, ends, stride, opt_right) {
  var right = opt_right !== undefined ? opt_right : false;
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    var isClockwise = linearRingIsClockwise(
      flatCoordinates, offset, end, stride);
    var reverse = i === 0 ?
      (right && isClockwise) || (!right && !isClockwise) :
      (right && !isClockwise) || (!right && isClockwise);
    if (reverse) {
      Object(_reverse_js__WEBPACK_IMPORTED_MODULE_0__["coordinates"])(flatCoordinates, offset, end, stride);
    }
    offset = end;
  }
  return offset;
}


/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `opt_right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean=} opt_right Follow the right-hand rule for orientation.
 * @return {number} End.
 */
function orientLinearRingsArray(flatCoordinates, offset, endss, stride, opt_right) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    offset = orientLinearRings(
      flatCoordinates, offset, endss[i], stride, opt_right);
  }
  return offset;
}

//# sourceMappingURL=orient.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/reverse.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/geom/flat/reverse.js ***!
  \**********************************************/
/*! exports provided: coordinates */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "coordinates", function() { return coordinates; });
/**
 * @module ol/geom/flat/reverse
 */


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 */
function coordinates(flatCoordinates, offset, end, stride) {
  while (offset < end - stride) {
    for (var i = 0; i < stride; ++i) {
      var tmp = flatCoordinates[offset + i];
      flatCoordinates[offset + i] = flatCoordinates[end - stride + i];
      flatCoordinates[end - stride + i] = tmp;
    }
    offset += stride;
    end -= stride;
  }
}

//# sourceMappingURL=reverse.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/segments.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/geom/flat/segments.js ***!
  \***********************************************/
/*! exports provided: forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/**
 * @module ol/geom/flat/segments
 */


/**
 * This function calls `callback` for each segment of the flat coordinates
 * array. If the callback returns a truthy value the function returns that
 * value immediately. Otherwise the function returns `false`.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {function(this: S, import("../../coordinate.js").Coordinate, import("../../coordinate.js").Coordinate): T} callback Function
 *     called for each segment.
 * @param {S=} opt_this The object to be used as the value of 'this'
 *     within callback.
 * @return {T|boolean} Value.
 * @template T,S
 */
function forEach(flatCoordinates, offset, end, stride, callback, opt_this) {
  var point1 = [flatCoordinates[offset], flatCoordinates[offset + 1]];
  var point2 = [];
  var ret;
  for (; (offset + stride) < end; offset += stride) {
    point2[0] = flatCoordinates[offset + stride];
    point2[1] = flatCoordinates[offset + stride + 1];
    ret = callback.call(opt_this, point1, point2);
    if (ret) {
      return ret;
    }
    point1[0] = point2[0];
    point1[1] = point2[1];
  }
  return false;
}

//# sourceMappingURL=segments.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/simplify.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/geom/flat/simplify.js ***!
  \***********************************************/
/*! exports provided: simplifyLineString, douglasPeucker, douglasPeuckerArray, douglasPeuckerMultiArray, radialDistance, snap, quantize, quantizeArray, quantizeMultiArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "simplifyLineString", function() { return simplifyLineString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "douglasPeucker", function() { return douglasPeucker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "douglasPeuckerArray", function() { return douglasPeuckerArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "douglasPeuckerMultiArray", function() { return douglasPeuckerMultiArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "radialDistance", function() { return radialDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "snap", function() { return snap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quantize", function() { return quantize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quantizeArray", function() { return quantizeArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quantizeMultiArray", function() { return quantizeMultiArray; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/geom/flat/simplify
 */
// Based on simplify-js https://github.com/mourner/simplify-js
// Copyright (c) 2012, Vladimir Agafonkin
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.




/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {boolean} highQuality Highest quality.
 * @param {Array<number>=} opt_simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @return {Array<number>} Simplified line string.
 */
function simplifyLineString(flatCoordinates, offset, end,
  stride, squaredTolerance, highQuality, opt_simplifiedFlatCoordinates) {
  var simplifiedFlatCoordinates = opt_simplifiedFlatCoordinates !== undefined ?
    opt_simplifiedFlatCoordinates : [];
  if (!highQuality) {
    end = radialDistance(flatCoordinates, offset, end,
      stride, squaredTolerance,
      simplifiedFlatCoordinates, 0);
    flatCoordinates = simplifiedFlatCoordinates;
    offset = 0;
    stride = 2;
  }
  simplifiedFlatCoordinates.length = douglasPeucker(
    flatCoordinates, offset, end, stride, squaredTolerance,
    simplifiedFlatCoordinates, 0);
  return simplifiedFlatCoordinates;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */
function douglasPeucker(flatCoordinates, offset, end,
  stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  var n = (end - offset) / stride;
  if (n < 3) {
    for (; offset < end; offset += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] =
          flatCoordinates[offset];
      simplifiedFlatCoordinates[simplifiedOffset++] =
          flatCoordinates[offset + 1];
    }
    return simplifiedOffset;
  }
  /** @type {Array<number>} */
  var markers = new Array(n);
  markers[0] = 1;
  markers[n - 1] = 1;
  /** @type {Array<number>} */
  var stack = [offset, end - stride];
  var index = 0;
  while (stack.length > 0) {
    var last = stack.pop();
    var first = stack.pop();
    var maxSquaredDistance = 0;
    var x1 = flatCoordinates[first];
    var y1 = flatCoordinates[first + 1];
    var x2 = flatCoordinates[last];
    var y2 = flatCoordinates[last + 1];
    for (var i = first + stride; i < last; i += stride) {
      var x = flatCoordinates[i];
      var y = flatCoordinates[i + 1];
      var squaredDistance = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["squaredSegmentDistance"])(
        x, y, x1, y1, x2, y2);
      if (squaredDistance > maxSquaredDistance) {
        index = i;
        maxSquaredDistance = squaredDistance;
      }
    }
    if (maxSquaredDistance > squaredTolerance) {
      markers[(index - offset) / stride] = 1;
      if (first + stride < index) {
        stack.push(first, index);
      }
      if (index + stride < last) {
        stack.push(index, last);
      }
    }
  }
  for (var i$1 = 0; i$1 < n; ++i$1) {
    if (markers[i$1]) {
      simplifiedFlatCoordinates[simplifiedOffset++] =
          flatCoordinates[offset + i$1 * stride];
      simplifiedFlatCoordinates[simplifiedOffset++] =
          flatCoordinates[offset + i$1 * stride + 1];
    }
  }
  return simplifiedOffset;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */
function douglasPeuckerArray(flatCoordinates, offset,
  ends, stride, squaredTolerance, simplifiedFlatCoordinates,
  simplifiedOffset, simplifiedEnds) {
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    simplifiedOffset = douglasPeucker(
      flatCoordinates, offset, end, stride, squaredTolerance,
      simplifiedFlatCoordinates, simplifiedOffset);
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }
  return simplifiedOffset;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<Array<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */
function douglasPeuckerMultiArray(
  flatCoordinates, offset, endss, stride, squaredTolerance,
  simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    var simplifiedEnds = [];
    simplifiedOffset = douglasPeuckerArray(
      flatCoordinates, offset, ends, stride, squaredTolerance,
      simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
    simplifiedEndss.push(simplifiedEnds);
    offset = ends[ends.length - 1];
  }
  return simplifiedOffset;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */
function radialDistance(flatCoordinates, offset, end,
  stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  if (end <= offset + stride) {
    // zero or one point, no simplification possible, so copy and return
    for (; offset < end; offset += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
      simplifiedFlatCoordinates[simplifiedOffset++] =
          flatCoordinates[offset + 1];
    }
    return simplifiedOffset;
  }
  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1];
  // copy first point
  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1;
  var x2 = x1;
  var y2 = y1;
  for (offset += stride; offset < end; offset += stride) {
    x2 = flatCoordinates[offset];
    y2 = flatCoordinates[offset + 1];
    if (Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["squaredDistance"])(x1, y1, x2, y2) > squaredTolerance) {
      // copy point at offset
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      x1 = x2;
      y1 = y2;
    }
  }
  if (x2 != x1 || y2 != y1) {
    // copy last point
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  }
  return simplifiedOffset;
}


/**
 * @param {number} value Value.
 * @param {number} tolerance Tolerance.
 * @return {number} Rounded value.
 */
function snap(value, tolerance) {
  return tolerance * Math.round(value / tolerance);
}


/**
 * Simplifies a line string using an algorithm designed by Tim Schaub.
 * Coordinates are snapped to the nearest value in a virtual grid and
 * consecutive duplicate coordinates are discarded.  This effectively preserves
 * topology as the simplification of any subsection of a line string is
 * independent of the rest of the line string.  This means that, for examples,
 * the common edge between two polygons will be simplified to the same line
 * string independently in both polygons.  This implementation uses a single
 * pass over the coordinates and eliminates intermediate collinear points.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */
function quantize(flatCoordinates, offset, end, stride,
  tolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  // do nothing if the line is empty
  if (offset == end) {
    return simplifiedOffset;
  }
  // snap the first coordinate (P1)
  var x1 = snap(flatCoordinates[offset], tolerance);
  var y1 = snap(flatCoordinates[offset + 1], tolerance);
  offset += stride;
  // add the first coordinate to the output
  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1;
  // find the next coordinate that does not snap to the same value as the first
  // coordinate (P2)
  var x2, y2;
  do {
    x2 = snap(flatCoordinates[offset], tolerance);
    y2 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;
    if (offset == end) {
      // all coordinates snap to the same value, the line collapses to a point
      // push the last snapped value anyway to ensure that the output contains
      // at least two points
      // FIXME should we really return at least two points anyway?
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      return simplifiedOffset;
    }
  } while (x2 == x1 && y2 == y1);
  while (offset < end) {
    // snap the next coordinate (P3)
    var x3 = snap(flatCoordinates[offset], tolerance);
    var y3 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;
    // skip P3 if it is equal to P2
    if (x3 == x2 && y3 == y2) {
      continue;
    }
    // calculate the delta between P1 and P2
    var dx1 = x2 - x1;
    var dy1 = y2 - y1;
    // calculate the delta between P3 and P1
    var dx2 = x3 - x1;
    var dy2 = y3 - y1;
    // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from
    // P1 in the same direction then P2 is on the straight line between P1 and
    // P3
    if ((dx1 * dy2 == dy1 * dx2) &&
        ((dx1 < 0 && dx2 < dx1) || dx1 == dx2 || (dx1 > 0 && dx2 > dx1)) &&
        ((dy1 < 0 && dy2 < dy1) || dy1 == dy2 || (dy1 > 0 && dy2 > dy1))) {
      // discard P2 and set P2 = P3
      x2 = x3;
      y2 = y3;
      continue;
    }
    // either P1, P2, and P3 are not colinear, or they are colinear but P3 is
    // between P3 and P1 or on the opposite half of the line to P2.  add P2,
    // and continue with P1 = P2 and P2 = P3
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
    x1 = x2;
    y1 = y2;
    x2 = x3;
    y2 = y3;
  }
  // add the last point (P2)
  simplifiedFlatCoordinates[simplifiedOffset++] = x2;
  simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  return simplifiedOffset;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */
function quantizeArray(
  flatCoordinates, offset, ends, stride,
  tolerance,
  simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    simplifiedOffset = quantize(
      flatCoordinates, offset, end, stride,
      tolerance,
      simplifiedFlatCoordinates, simplifiedOffset);
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }
  return simplifiedOffset;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<Array<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */
function quantizeMultiArray(
  flatCoordinates, offset, endss, stride,
  tolerance,
  simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    var simplifiedEnds = [];
    simplifiedOffset = quantizeArray(
      flatCoordinates, offset, ends, stride,
      tolerance,
      simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
    simplifiedEndss.push(simplifiedEnds);
    offset = ends[ends.length - 1];
  }
  return simplifiedOffset;
}

//# sourceMappingURL=simplify.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/straightchunk.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/geom/flat/straightchunk.js ***!
  \****************************************************/
/*! exports provided: matchingChunk */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matchingChunk", function() { return matchingChunk; });
/**
 * @module ol/geom/flat/straightchunk
 */


/**
 * @param {number} maxAngle Maximum acceptable angle delta between segments.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {Array<number>} Start and end of the first suitable chunk of the
 * given `flatCoordinates`.
 */
function matchingChunk(maxAngle, flatCoordinates, offset, end, stride) {
  var chunkStart = offset;
  var chunkEnd = offset;
  var chunkM = 0;
  var m = 0;
  var start = offset;
  var acos, i, m12, m23, x1, y1, x12, y12, x23, y23;
  for (i = offset; i < end; i += stride) {
    var x2 = flatCoordinates[i];
    var y2 = flatCoordinates[i + 1];
    if (x1 !== undefined) {
      x23 = x2 - x1;
      y23 = y2 - y1;
      m23 = Math.sqrt(x23 * x23 + y23 * y23);
      if (x12 !== undefined) {
        m += m12;
        acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));
        if (acos > maxAngle) {
          if (m > chunkM) {
            chunkM = m;
            chunkStart = start;
            chunkEnd = i;
          }
          m = 0;
          start = i - stride;
        }
      }
      m12 = m23;
      x12 = x23;
      y12 = y23;
    }
    x1 = x2;
    y1 = y2;
  }
  m += m23;
  return m > chunkM ? [start, i] : [chunkStart, chunkEnd];
}

//# sourceMappingURL=straightchunk.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/textpath.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/geom/flat/textpath.js ***!
  \***********************************************/
/*! exports provided: drawTextOnPath */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawTextOnPath", function() { return drawTextOnPath; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/geom/flat/textpath
 */



/**
 * @param {Array<number>} flatCoordinates Path to put text on.
 * @param {number} offset Start offset of the `flatCoordinates`.
 * @param {number} end End offset of the `flatCoordinates`.
 * @param {number} stride Stride.
 * @param {string} text Text to place on the path.
 * @param {function(string):number} measure Measure function returning the
 * width of the character passed as 1st argument.
 * @param {number} startM m along the path where the text starts.
 * @param {number} maxAngle Max angle between adjacent chars in radians.
 * @return {Array<Array<*>>} The result array of null if `maxAngle` was
 * exceeded. Entries of the array are x, y, anchorX, angle, chunk.
 */
function drawTextOnPath(
  flatCoordinates, offset, end, stride, text, measure, startM, maxAngle) {
  var result = [];

  // Keep text upright
  var reverse = flatCoordinates[offset] > flatCoordinates[end - stride];

  var numChars = text.length;

  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1];
  offset += stride;
  var x2 = flatCoordinates[offset];
  var y2 = flatCoordinates[offset + 1];
  var segmentM = 0;
  var segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));

  var chunk = '';
  var chunkLength = 0;
  var data, index, previousAngle;
  for (var i = 0; i < numChars; ++i) {
    index = reverse ? numChars - i - 1 : i;
    var char = text.charAt(index);
    chunk = reverse ? char + chunk : chunk + char;
    var charLength = measure(chunk) - chunkLength;
    chunkLength += charLength;
    var charM = startM + charLength / 2;
    while (offset < end - stride && segmentM + segmentLength < charM) {
      x1 = x2;
      y1 = y2;
      offset += stride;
      x2 = flatCoordinates[offset];
      y2 = flatCoordinates[offset + 1];
      segmentM += segmentLength;
      segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    }
    var segmentPos = charM - segmentM;
    var angle = Math.atan2(y2 - y1, x2 - x1);
    if (reverse) {
      angle += angle > 0 ? -Math.PI : Math.PI;
    }
    if (previousAngle !== undefined) {
      var delta = angle - previousAngle;
      delta += (delta > Math.PI) ? -2 * Math.PI : (delta < -Math.PI) ? 2 * Math.PI : 0;
      if (Math.abs(delta) > maxAngle) {
        return null;
      }
    }
    var interpolate = segmentPos / segmentLength;
    var x = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["lerp"])(x1, x2, interpolate);
    var y = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["lerp"])(y1, y2, interpolate);
    if (previousAngle == angle) {
      if (reverse) {
        data[0] = x;
        data[1] = y;
        data[2] = charLength / 2;
      }
      data[4] = chunk;
    } else {
      chunk = char;
      chunkLength = charLength;
      data = [x, y, charLength / 2, angle, chunk];
      if (reverse) {
        result.unshift(data);
      } else {
        result.push(data);
      }
      previousAngle = angle;
    }
    startM += charLength;
  }
  return result;
}

//# sourceMappingURL=textpath.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/transform.js":
/*!************************************************!*\
  !*** ./node_modules/ol/geom/flat/transform.js ***!
  \************************************************/
/*! exports provided: transform2D, rotate, scale, translate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transform2D", function() { return transform2D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/**
 * @module ol/geom/flat/transform
 */


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../transform.js").Transform} transform Transform.
 * @param {Array<number>=} opt_dest Destination.
 * @return {Array<number>} Transformed coordinates.
 */
function transform2D(flatCoordinates, offset, end, stride, transform, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var i = 0;
  for (var j = offset; j < end; j += stride) {
    var x = flatCoordinates[j];
    var y = flatCoordinates[j + 1];
    dest[i++] = transform[0] * x + transform[2] * y + transform[4];
    dest[i++] = transform[1] * x + transform[3] * y + transform[5];
  }
  if (opt_dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} angle Angle.
 * @param {Array<number>} anchor Rotation anchor point.
 * @param {Array<number>=} opt_dest Destination.
 * @return {Array<number>} Transformed coordinates.
 */
function rotate(flatCoordinates, offset, end, stride, angle, anchor, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var cos = Math.cos(angle);
  var sin = Math.sin(angle);
  var anchorX = anchor[0];
  var anchorY = anchor[1];
  var i = 0;
  for (var j = offset; j < end; j += stride) {
    var deltaX = flatCoordinates[j] - anchorX;
    var deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + deltaX * cos - deltaY * sin;
    dest[i++] = anchorY + deltaX * sin + deltaY * cos;
    for (var k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (opt_dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}


/**
 * Scale the coordinates.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} sx Scale factor in the x-direction.
 * @param {number} sy Scale factor in the y-direction.
 * @param {Array<number>} anchor Scale anchor point.
 * @param {Array<number>=} opt_dest Destination.
 * @return {Array<number>} Transformed coordinates.
 */
function scale(flatCoordinates, offset, end, stride, sx, sy, anchor, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var anchorX = anchor[0];
  var anchorY = anchor[1];
  var i = 0;
  for (var j = offset; j < end; j += stride) {
    var deltaX = flatCoordinates[j] - anchorX;
    var deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + sx * deltaX;
    dest[i++] = anchorY + sy * deltaY;
    for (var k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (opt_dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} deltaX Delta X.
 * @param {number} deltaY Delta Y.
 * @param {Array<number>=} opt_dest Destination.
 * @return {Array<number>} Transformed coordinates.
 */
function translate(flatCoordinates, offset, end, stride, deltaX, deltaY, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var i = 0;
  for (var j = offset; j < end; j += stride) {
    dest[i++] = flatCoordinates[j] + deltaX;
    dest[i++] = flatCoordinates[j + 1] + deltaY;
    for (var k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (opt_dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}

//# sourceMappingURL=transform.js.map

/***/ }),

/***/ "./node_modules/ol/has.js":
/*!********************************!*\
  !*** ./node_modules/ol/has.js ***!
  \********************************/
/*! exports provided: FIREFOX, SAFARI, WEBKIT, MAC, DEVICE_PIXEL_RATIO, CANVAS_LINE_DASH, GEOLOCATION, TOUCH, POINTER, MSPOINTER, WEBGL */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FIREFOX", function() { return FIREFOX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SAFARI", function() { return SAFARI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WEBKIT", function() { return WEBKIT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAC", function() { return MAC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEVICE_PIXEL_RATIO", function() { return DEVICE_PIXEL_RATIO; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CANVAS_LINE_DASH", function() { return CANVAS_LINE_DASH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GEOLOCATION", function() { return GEOLOCATION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOUCH", function() { return TOUCH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POINTER", function() { return POINTER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MSPOINTER", function() { return MSPOINTER; });
/* harmony import */ var _webgl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webgl.js */ "./node_modules/ol/webgl.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WEBGL", function() { return _webgl_js__WEBPACK_IMPORTED_MODULE_0__["HAS"]; });

/**
 * @module ol/has
 */

var ua = typeof navigator !== 'undefined' ?
  navigator.userAgent.toLowerCase() : '';

/**
 * User agent string says we are dealing with Firefox as browser.
 * @type {boolean}
 */
var FIREFOX = ua.indexOf('firefox') !== -1;

/**
 * User agent string says we are dealing with Safari as browser.
 * @type {boolean}
 */
var SAFARI = ua.indexOf('safari') !== -1 && ua.indexOf('chrom') == -1;

/**
 * User agent string says we are dealing with a WebKit engine.
 * @type {boolean}
 */
var WEBKIT = ua.indexOf('webkit') !== -1 && ua.indexOf('edge') == -1;

/**
 * User agent string says we are dealing with a Mac as platform.
 * @type {boolean}
 */
var MAC = ua.indexOf('macintosh') !== -1;


/**
 * The ratio between physical pixels and device-independent pixels
 * (dips) on the device (`window.devicePixelRatio`).
 * @const
 * @type {number}
 * @api
 */
var DEVICE_PIXEL_RATIO = window.devicePixelRatio || 1;


/**
 * True if the browser's Canvas implementation implements {get,set}LineDash.
 * @type {boolean}
 */
var CANVAS_LINE_DASH = function() {
  var has = false;
  try {
    has = !!document.createElement('canvas').getContext('2d').setLineDash;
  } catch (e) {
    // pass
  }
  return has;
}();


/**
 * Is HTML5 geolocation supported in the current browser?
 * @const
 * @type {boolean}
 * @api
 */
var GEOLOCATION = 'geolocation' in navigator;


/**
 * True if browser supports touch events.
 * @const
 * @type {boolean}
 * @api
 */
var TOUCH = 'ontouchstart' in window;


/**
 * True if browser supports pointer events.
 * @const
 * @type {boolean}
 */
var POINTER = 'PointerEvent' in window;


/**
 * True if browser supports ms pointer events (IE 10).
 * @const
 * @type {boolean}
 */
var MSPOINTER = !!(navigator.msPointerEnabled);




//# sourceMappingURL=has.js.map

/***/ }),

/***/ "./node_modules/ol/interaction.js":
/*!****************************************!*\
  !*** ./node_modules/ol/interaction.js ***!
  \****************************************/
/*! exports provided: DoubleClickZoom, DragAndDrop, DragBox, DragPan, DragRotate, DragRotateAndZoom, DragZoom, Draw, Extent, Interaction, KeyboardPan, KeyboardZoom, Modify, MouseWheelZoom, PinchRotate, PinchZoom, Pointer, Select, Snap, Translate, defaults */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaults", function() { return defaults; });
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Collection.js */ "./node_modules/ol/Collection.js");
/* harmony import */ var _Kinetic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Kinetic.js */ "./node_modules/ol/Kinetic.js");
/* harmony import */ var _interaction_DoubleClickZoom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interaction/DoubleClickZoom.js */ "./node_modules/ol/interaction/DoubleClickZoom.js");
/* harmony import */ var _interaction_DragPan_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interaction/DragPan.js */ "./node_modules/ol/interaction/DragPan.js");
/* harmony import */ var _interaction_DragRotate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./interaction/DragRotate.js */ "./node_modules/ol/interaction/DragRotate.js");
/* harmony import */ var _interaction_DragZoom_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./interaction/DragZoom.js */ "./node_modules/ol/interaction/DragZoom.js");
/* harmony import */ var _interaction_KeyboardPan_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./interaction/KeyboardPan.js */ "./node_modules/ol/interaction/KeyboardPan.js");
/* harmony import */ var _interaction_KeyboardZoom_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./interaction/KeyboardZoom.js */ "./node_modules/ol/interaction/KeyboardZoom.js");
/* harmony import */ var _interaction_MouseWheelZoom_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./interaction/MouseWheelZoom.js */ "./node_modules/ol/interaction/MouseWheelZoom.js");
/* harmony import */ var _interaction_PinchRotate_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./interaction/PinchRotate.js */ "./node_modules/ol/interaction/PinchRotate.js");
/* harmony import */ var _interaction_PinchZoom_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./interaction/PinchZoom.js */ "./node_modules/ol/interaction/PinchZoom.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DoubleClickZoom", function() { return _interaction_DoubleClickZoom_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _interaction_DragAndDrop_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./interaction/DragAndDrop.js */ "./node_modules/ol/interaction/DragAndDrop.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DragAndDrop", function() { return _interaction_DragAndDrop_js__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _interaction_DragBox_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./interaction/DragBox.js */ "./node_modules/ol/interaction/DragBox.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DragBox", function() { return _interaction_DragBox_js__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DragPan", function() { return _interaction_DragPan_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DragRotate", function() { return _interaction_DragRotate_js__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _interaction_DragRotateAndZoom_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./interaction/DragRotateAndZoom.js */ "./node_modules/ol/interaction/DragRotateAndZoom.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DragRotateAndZoom", function() { return _interaction_DragRotateAndZoom_js__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DragZoom", function() { return _interaction_DragZoom_js__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _interaction_Draw_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./interaction/Draw.js */ "./node_modules/ol/interaction/Draw.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Draw", function() { return _interaction_Draw_js__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony import */ var _interaction_Extent_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./interaction/Extent.js */ "./node_modules/ol/interaction/Extent.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Extent", function() { return _interaction_Extent_js__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony import */ var _interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./interaction/Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Interaction", function() { return _interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "KeyboardPan", function() { return _interaction_KeyboardPan_js__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "KeyboardZoom", function() { return _interaction_KeyboardZoom_js__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _interaction_Modify_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./interaction/Modify.js */ "./node_modules/ol/interaction/Modify.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Modify", function() { return _interaction_Modify_js__WEBPACK_IMPORTED_MODULE_18__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MouseWheelZoom", function() { return _interaction_MouseWheelZoom_js__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PinchRotate", function() { return _interaction_PinchRotate_js__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PinchZoom", function() { return _interaction_PinchZoom_js__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _interaction_Pointer_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./interaction/Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Pointer", function() { return _interaction_Pointer_js__WEBPACK_IMPORTED_MODULE_19__["default"]; });

/* harmony import */ var _interaction_Select_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./interaction/Select.js */ "./node_modules/ol/interaction/Select.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Select", function() { return _interaction_Select_js__WEBPACK_IMPORTED_MODULE_20__["default"]; });

/* harmony import */ var _interaction_Snap_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./interaction/Snap.js */ "./node_modules/ol/interaction/Snap.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Snap", function() { return _interaction_Snap_js__WEBPACK_IMPORTED_MODULE_21__["default"]; });

/* harmony import */ var _interaction_Translate_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./interaction/Translate.js */ "./node_modules/ol/interaction/Translate.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Translate", function() { return _interaction_Translate_js__WEBPACK_IMPORTED_MODULE_22__["default"]; });

/**
 * @module ol/interaction
 */



































/**
 * @typedef {Object} DefaultsOptions
 * @property {boolean} [altShiftDragRotate=true] Whether Alt-Shift-drag rotate is
 * desired.
 * @property {boolean} [onFocusOnly=false] Interact only when the map has the
 * focus. This affects the `MouseWheelZoom` and `DragPan` interactions and is
 * useful when page scroll is desired for maps that do not have the browser's
 * focus.
 * @property {boolean} [constrainResolution=false] Zoom to the closest integer
 * zoom level after the wheel/trackpad or pinch gesture ends.
 * @property {boolean} [doubleClickZoom=true] Whether double click zoom is
 * desired.
 * @property {boolean} [keyboard=true] Whether keyboard interaction is desired.
 * @property {boolean} [mouseWheelZoom=true] Whether mousewheel zoom is desired.
 * @property {boolean} [shiftDragZoom=true] Whether Shift-drag zoom is desired.
 * @property {boolean} [dragPan=true] Whether drag pan is desired.
 * @property {boolean} [pinchRotate=true] Whether pinch rotate is desired.
 * @property {boolean} [pinchZoom=true] Whether pinch zoom is desired.
 * @property {number} [zoomDelta] Zoom level delta when using keyboard or
 * mousewheel zoom.
 * @property {number} [zoomDuration] Duration of the zoom animation in
 * milliseconds.
 */


/**
 * Set of interactions included in maps by default. Specific interactions can be
 * excluded by setting the appropriate option to false in the constructor
 * options, but the order of the interactions is fixed.  If you want to specify
 * a different order for interactions, you will need to create your own
 * {@link module:ol/interaction/Interaction} instances and insert
 * them into a {@link module:ol/Collection} in the order you want
 * before creating your {@link module:ol/Map~Map} instance. The default set of
 * interactions, in sequence, is:
 * * {@link module:ol/interaction/DragRotate~DragRotate}
 * * {@link module:ol/interaction/DoubleClickZoom~DoubleClickZoom}
 * * {@link module:ol/interaction/DragPan~DragPan}
 * * {@link module:ol/interaction/PinchRotate~PinchRotate}
 * * {@link module:ol/interaction/PinchZoom~PinchZoom}
 * * {@link module:ol/interaction/KeyboardPan~KeyboardPan}
 * * {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}
 * * {@link module:ol/interaction/MouseWheelZoom~MouseWheelZoom}
 * * {@link module:ol/interaction/DragZoom~DragZoom}
 *
 * @param {DefaultsOptions=} opt_options Defaults options.
 * @return {import("./Collection.js").default<import("./interaction/Interaction.js").default>}
 * A collection of interactions to be used with the {@link module:ol/Map~Map}
 * constructor's `interactions` option.
 * @api
 */
function defaults(opt_options) {

  var options = opt_options ? opt_options : {};

  var interactions = new _Collection_js__WEBPACK_IMPORTED_MODULE_0__["default"]();

  var kinetic = new _Kinetic_js__WEBPACK_IMPORTED_MODULE_1__["default"](-0.005, 0.05, 100);

  var altShiftDragRotate = options.altShiftDragRotate !== undefined ?
    options.altShiftDragRotate : true;
  if (altShiftDragRotate) {
    interactions.push(new _interaction_DragRotate_js__WEBPACK_IMPORTED_MODULE_4__["default"]());
  }

  var doubleClickZoom = options.doubleClickZoom !== undefined ?
    options.doubleClickZoom : true;
  if (doubleClickZoom) {
    interactions.push(new _interaction_DoubleClickZoom_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
      delta: options.zoomDelta,
      duration: options.zoomDuration
    }));
  }

  var dragPan = options.dragPan !== undefined ? options.dragPan : true;
  if (dragPan) {
    interactions.push(new _interaction_DragPan_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
      condition: options.onFocusOnly ? _events_condition_js__WEBPACK_IMPORTED_MODULE_11__["focus"] : undefined,
      kinetic: kinetic
    }));
  }

  var pinchRotate = options.pinchRotate !== undefined ? options.pinchRotate :
    true;
  if (pinchRotate) {
    interactions.push(new _interaction_PinchRotate_js__WEBPACK_IMPORTED_MODULE_9__["default"]());
  }

  var pinchZoom = options.pinchZoom !== undefined ? options.pinchZoom : true;
  if (pinchZoom) {
    interactions.push(new _interaction_PinchZoom_js__WEBPACK_IMPORTED_MODULE_10__["default"]({
      constrainResolution: options.constrainResolution,
      duration: options.zoomDuration
    }));
  }

  var keyboard = options.keyboard !== undefined ? options.keyboard : true;
  if (keyboard) {
    interactions.push(new _interaction_KeyboardPan_js__WEBPACK_IMPORTED_MODULE_6__["default"]());
    interactions.push(new _interaction_KeyboardZoom_js__WEBPACK_IMPORTED_MODULE_7__["default"]({
      delta: options.zoomDelta,
      duration: options.zoomDuration
    }));
  }

  var mouseWheelZoom = options.mouseWheelZoom !== undefined ?
    options.mouseWheelZoom : true;
  if (mouseWheelZoom) {
    interactions.push(new _interaction_MouseWheelZoom_js__WEBPACK_IMPORTED_MODULE_8__["default"]({
      condition: options.onFocusOnly ? _events_condition_js__WEBPACK_IMPORTED_MODULE_11__["focus"] : undefined,
      constrainResolution: options.constrainResolution,
      duration: options.zoomDuration
    }));
  }

  var shiftDragZoom = options.shiftDragZoom !== undefined ?
    options.shiftDragZoom : true;
  if (shiftDragZoom) {
    interactions.push(new _interaction_DragZoom_js__WEBPACK_IMPORTED_MODULE_5__["default"]({
      duration: options.zoomDuration
    }));
  }

  return interactions;

}

//# sourceMappingURL=interaction.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/DoubleClickZoom.js":
/*!********************************************************!*\
  !*** ./node_modules/ol/interaction/DoubleClickZoom.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MapBrowserEventType.js */ "./node_modules/ol/MapBrowserEventType.js");
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/**
 * @module ol/interaction/DoubleClickZoom
 */




/**
 * @typedef {Object} Options
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {number} [delta=1] The zoom delta applied on each double click.
 */


/**
 * @classdesc
 * Allows the user to zoom by double-clicking on the map.
 * @api
 */
var DoubleClickZoom = /*@__PURE__*/(function (Interaction) {
  function DoubleClickZoom(opt_options) {
    Interaction.call(this, {
      handleEvent: handleEvent
    });

    var options = opt_options ? opt_options : {};

    /**
     * @private
     * @type {number}
     */
    this.delta_ = options.delta ? options.delta : 1;

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 250;

  }

  if ( Interaction ) DoubleClickZoom.__proto__ = Interaction;
  DoubleClickZoom.prototype = Object.create( Interaction && Interaction.prototype );
  DoubleClickZoom.prototype.constructor = DoubleClickZoom;

  return DoubleClickZoom;
}(_Interaction_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/**
 * Handles the {@link module:ol/MapBrowserEvent map browser event} (if it was a
 * doubleclick) and eventually zooms the map.
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} `false` to stop event propagation.
 * @this {DoubleClickZoom}
 */
function handleEvent(mapBrowserEvent) {
  var stopEvent = false;
  if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].DBLCLICK) {
    var browserEvent = /** @type {MouseEvent} */ (mapBrowserEvent.originalEvent);
    var map = mapBrowserEvent.map;
    var anchor = mapBrowserEvent.coordinate;
    var delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;
    var view = map.getView();
    Object(_Interaction_js__WEBPACK_IMPORTED_MODULE_1__["zoomByDelta"])(view, delta, anchor, this.duration_);
    mapBrowserEvent.preventDefault();
    stopEvent = true;
  }
  return !stopEvent;
}

/* harmony default export */ __webpack_exports__["default"] = (DoubleClickZoom);

//# sourceMappingURL=DoubleClickZoom.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/DragAndDrop.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/interaction/DragAndDrop.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/**
 * @module ol/interaction/DragAndDrop
 */
// FIXME should handle all geo-referenced data, not just vector data









/**
 * @typedef {Object} Options
 * @property {Array<typeof import("../format/Feature.js").default>} [formatConstructors] Format constructors.
 * @property {import("../source/Vector.js").default} [source] Optional vector source where features will be added.  If a source is provided
 * all existing features will be removed and new features will be added when
 * they are dropped on the target.  If you want to add features to a vector
 * source without removing the existing features (append only), instead of
 * providing the source option listen for the "addfeatures" event.
 * @property {import("../proj.js").ProjectionLike} [projection] Target projection. By default, the map's view's projection is used.
 * @property {HTMLElement} [target] The element that is used as the drop target, default is the viewport element.
 */


/**
 * @enum {string}
 */
var DragAndDropEventType = {
  /**
   * Triggered when features are added
   * @event DragAndDropEvent#addfeatures
   * @api
   */
  ADD_FEATURES: 'addfeatures'
};


/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/DragAndDrop~DragAndDrop} instances are instances
 * of this type.
 */
var DragAndDropEvent = /*@__PURE__*/(function (Event) {
  function DragAndDropEvent(type, file, opt_features, opt_projection) {

    Event.call(this, type);

    /**
     * The features parsed from dropped data.
     * @type {Array<import("../Feature.js").FeatureLike>|undefined}
     * @api
     */
    this.features = opt_features;

    /**
     * The dropped file.
     * @type {File}
     * @api
     */
    this.file = file;

    /**
     * The feature projection.
     * @type {import("../proj/Projection.js").default|undefined}
     * @api
     */
    this.projection = opt_projection;

  }

  if ( Event ) DragAndDropEvent.__proto__ = Event;
  DragAndDropEvent.prototype = Object.create( Event && Event.prototype );
  DragAndDropEvent.prototype.constructor = DragAndDropEvent;

  return DragAndDropEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_2__["default"]));


/**
 * @classdesc
 * Handles input of vector data by drag and drop.
 * @api
 *
 * @fires DragAndDropEvent
 */
var DragAndDrop = /*@__PURE__*/(function (Interaction) {
  function DragAndDrop(opt_options) {

    var options = opt_options ? opt_options : {};

    Interaction.call(this, {
      handleEvent: _functions_js__WEBPACK_IMPORTED_MODULE_0__["TRUE"]
    });

    /**
     * @private
     * @type {Array<typeof import("../format/Feature.js").default>}
     */
    this.formatConstructors_ = options.formatConstructors ?
      options.formatConstructors : [];

    /**
     * @private
     * @type {import("../proj/Projection.js").default}
     */
    this.projection_ = options.projection ?
      Object(_proj_js__WEBPACK_IMPORTED_MODULE_5__["get"])(options.projection) : null;

    /**
     * @private
     * @type {Array<import("../events.js").EventsKey>}
     */
    this.dropListenKeys_ = null;

    /**
     * @private
     * @type {import("../source/Vector.js").default}
     */
    this.source_ = options.source || null;

    /**
     * @private
     * @type {HTMLElement}
     */
    this.target = options.target ? options.target : null;

  }

  if ( Interaction ) DragAndDrop.__proto__ = Interaction;
  DragAndDrop.prototype = Object.create( Interaction && Interaction.prototype );
  DragAndDrop.prototype.constructor = DragAndDrop;

  /**
   * @param {File} file File.
   * @param {Event} event Load event.
   * @private
   */
  DragAndDrop.prototype.handleResult_ = function handleResult_ (file, event) {
    var result = event.target.result;
    var map = this.getMap();
    var projection = this.projection_;
    if (!projection) {
      var view = map.getView();
      projection = view.getProjection();
    }

    var formatConstructors = this.formatConstructors_;
    var features = [];
    for (var i = 0, ii = formatConstructors.length; i < ii; ++i) {
      var format = new formatConstructors[i]();
      features = this.tryReadFeatures_(format, result, {
        featureProjection: projection
      });
      if (features && features.length > 0) {
        break;
      }
    }
    if (this.source_) {
      this.source_.clear();
      this.source_.addFeatures(features);
    }
    this.dispatchEvent(
      new DragAndDropEvent(
        DragAndDropEventType.ADD_FEATURES, file,
        features, projection));
  };

  /**
   * @private
   */
  DragAndDrop.prototype.registerListeners_ = function registerListeners_ () {
    var map = this.getMap();
    if (map) {
      var dropArea = this.target ? this.target : map.getViewport();
      this.dropListenKeys_ = [
        Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["listen"])(dropArea, _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].DROP, handleDrop, this),
        Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["listen"])(dropArea, _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].DRAGENTER, handleStop, this),
        Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["listen"])(dropArea, _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].DRAGOVER, handleStop, this),
        Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["listen"])(dropArea, _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].DROP, handleStop, this)
      ];
    }
  };

  /**
   * @inheritDoc
   */
  DragAndDrop.prototype.setActive = function setActive (active) {
    Interaction.prototype.setActive.call(this, active);
    if (active) {
      this.registerListeners_();
    } else {
      this.unregisterListeners_();
    }
  };

  /**
   * @inheritDoc
   */
  DragAndDrop.prototype.setMap = function setMap (map) {
    this.unregisterListeners_();
    Interaction.prototype.setMap.call(this, map);
    if (this.getActive()) {
      this.registerListeners_();
    }
  };

  /**
   * @param {import("../format/Feature.js").default} format Format.
   * @param {string} text Text.
   * @param {import("../format/Feature.js").ReadOptions} options Read options.
   * @private
   * @return {Array<import("../Feature.js").FeatureLike>} Features.
   */
  DragAndDrop.prototype.tryReadFeatures_ = function tryReadFeatures_ (format, text, options) {
    try {
      return format.readFeatures(text, options);
    } catch (e) {
      return null;
    }
  };

  /**
   * @private
   */
  DragAndDrop.prototype.unregisterListeners_ = function unregisterListeners_ () {
    if (this.dropListenKeys_) {
      this.dropListenKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_1__["unlistenByKey"]);
      this.dropListenKeys_ = null;
    }
  };

  return DragAndDrop;
}(_Interaction_js__WEBPACK_IMPORTED_MODULE_4__["default"]));


/**
 * @param {DragEvent} event Event.
 * @this {DragAndDrop}
 */
function handleDrop(event) {
  var files = event.dataTransfer.files;
  for (var i = 0, ii = files.length; i < ii; ++i) {
    var file = files.item(i);
    var reader = new FileReader();
    reader.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].LOAD, this.handleResult_.bind(this, file));
    reader.readAsText(file);
  }
}


/**
 * @param {DragEvent} event Event.
 */
function handleStop(event) {
  event.stopPropagation();
  event.preventDefault();
  event.dataTransfer.dropEffect = 'copy';
}


/* harmony default export */ __webpack_exports__["default"] = (DragAndDrop);

//# sourceMappingURL=DragAndDrop.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/DragBox.js":
/*!************************************************!*\
  !*** ./node_modules/ol/interaction/DragBox.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/* harmony import */ var _render_Box_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../render/Box.js */ "./node_modules/ol/render/Box.js");
/**
 * @module ol/interaction/DragBox
 */
// FIXME draw drag box







/**
 * A function that takes a {@link module:ol/MapBrowserEvent} and two
 * {@link module:ol/pixel~Pixel}s and returns a `{boolean}`. If the condition is met,
 * true should be returned.
 * @typedef {function(this: ?, import("../MapBrowserEvent.js").default, import("../pixel.js").Pixel, import("../pixel.js").Pixel):boolean} EndCondition
 */


/**
 * @typedef {Object} Options
 * @property {string} [className='ol-dragbox'] CSS class name for styling the box.
 * @property {import("../events/condition.js").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link ol/events/condition~always}.
 * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the default
 * `boxEndCondition` function.
 * @property {EndCondition} [boxEndCondition] A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two
 * {@link module:ol/pixel~Pixel}s to indicate whether a `boxend` event should be fired.
 * Default is `true` if the area of the box is bigger than the `minArea` option.
 * @property {function(this:DragBox, import("../MapBrowserEvent.js").default)} onBoxEnd Code to execute just
 * before `boxend` is fired.
 */


/**
 * @enum {string}
 */
var DragBoxEventType = {
  /**
   * Triggered upon drag box start.
   * @event DragBoxEvent#boxstart
   * @api
   */
  BOXSTART: 'boxstart',

  /**
   * Triggered on drag when box is active.
   * @event DragBoxEvent#boxdrag
   * @api
   */
  BOXDRAG: 'boxdrag',

  /**
   * Triggered upon drag box end.
   * @event DragBoxEvent#boxend
   * @api
   */
  BOXEND: 'boxend'
};


/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/DragBox~DragBox} instances are instances of
 * this type.
 */
var DragBoxEvent = /*@__PURE__*/(function (Event) {
  function DragBoxEvent(type, coordinate, mapBrowserEvent) {
    Event.call(this, type);

    /**
     * The coordinate of the drag event.
     * @const
     * @type {import("../coordinate.js").Coordinate}
     * @api
     */
    this.coordinate = coordinate;

    /**
     * @const
     * @type {import("../MapBrowserEvent.js").default}
     * @api
     */
    this.mapBrowserEvent = mapBrowserEvent;

  }

  if ( Event ) DragBoxEvent.__proto__ = Event;
  DragBoxEvent.prototype = Object.create( Event && Event.prototype );
  DragBoxEvent.prototype.constructor = DragBoxEvent;

  return DragBoxEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/**
 * @classdesc
 * Allows the user to draw a vector box by clicking and dragging on the map,
 * normally combined with an {@link module:ol/events/condition} that limits
 * it to when the shift or other key is held down. This is used, for example,
 * for zooming to a specific area of the map
 * (see {@link module:ol/interaction/DragZoom~DragZoom} and
 * {@link module:ol/interaction/DragRotateAndZoom}).
 *
 * This interaction is only supported for mouse devices.
 *
 * @fires DragBoxEvent
 * @api
 */
var DragBox = /*@__PURE__*/(function (PointerInteraction) {
  function DragBox(opt_options) {

    PointerInteraction.call(this);

    var options = opt_options ? opt_options : {};

    /**
    * @type {import("../render/Box.js").default}
    * @private
    */
    this.box_ = new _render_Box_js__WEBPACK_IMPORTED_MODULE_4__["default"](options.className || 'ol-dragbox');

    /**
    * @type {number}
    * @private
    */
    this.minArea_ = options.minArea !== undefined ? options.minArea : 64;

    /**
     * Function to execute just before `onboxend` is fired
     * @type {function(this:DragBox, import("../MapBrowserEvent.js").default)}
     * @private
     */
    this.onBoxEnd_ = options.onBoxEnd ? options.onBoxEnd : _functions_js__WEBPACK_IMPORTED_MODULE_2__["VOID"];

    /**
    * @type {import("../pixel.js").Pixel}
    * @private
    */
    this.startPixel_ = null;

    /**
    * @private
    * @type {import("../events/condition.js").Condition}
    */
    this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_1__["always"];

    /**
    * @private
    * @type {EndCondition}
    */
    this.boxEndCondition_ = options.boxEndCondition ?
      options.boxEndCondition : this.defaultBoxEndCondition;
  }

  if ( PointerInteraction ) DragBox.__proto__ = PointerInteraction;
  DragBox.prototype = Object.create( PointerInteraction && PointerInteraction.prototype );
  DragBox.prototype.constructor = DragBox;

  /**
   * The default condition for determining whether the boxend event
   * should fire.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent The originating MapBrowserEvent
   *     leading to the box end.
   * @param {import("../pixel.js").Pixel} startPixel The starting pixel of the box.
   * @param {import("../pixel.js").Pixel} endPixel The end pixel of the box.
   * @return {boolean} Whether or not the boxend condition should be fired.
   */
  DragBox.prototype.defaultBoxEndCondition = function defaultBoxEndCondition (mapBrowserEvent, startPixel, endPixel) {
    var width = endPixel[0] - startPixel[0];
    var height = endPixel[1] - startPixel[1];
    return width * width + height * height >= this.minArea_;
  };

  /**
  * Returns geometry of last drawn box.
  * @return {import("../geom/Polygon.js").default} Geometry.
  * @api
  */
  DragBox.prototype.getGeometry = function getGeometry () {
    return this.box_.getGeometry();
  };

  /**
   * @inheritDoc
   */
  DragBox.prototype.handleDragEvent = function handleDragEvent (mapBrowserEvent) {
    if (!Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_1__["mouseOnly"])(mapBrowserEvent)) {
      return;
    }

    this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);

    this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXDRAG,
      mapBrowserEvent.coordinate, mapBrowserEvent));
  };

  /**
   * @inheritDoc
   */
  DragBox.prototype.handleUpEvent = function handleUpEvent (mapBrowserEvent) {
    if (!Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_1__["mouseOnly"])(mapBrowserEvent)) {
      return true;
    }

    this.box_.setMap(null);

    if (this.boxEndCondition_(mapBrowserEvent, this.startPixel_, mapBrowserEvent.pixel)) {
      this.onBoxEnd_(mapBrowserEvent);
      this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXEND,
        mapBrowserEvent.coordinate, mapBrowserEvent));
    }
    return false;
  };

  /**
   * @inheritDoc
   */
  DragBox.prototype.handleDownEvent = function handleDownEvent (mapBrowserEvent) {
    if (!Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_1__["mouseOnly"])(mapBrowserEvent)) {
      return false;
    }

    if (Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_1__["mouseActionButton"])(mapBrowserEvent) &&
        this.condition_(mapBrowserEvent)) {
      this.startPixel_ = mapBrowserEvent.pixel;
      this.box_.setMap(mapBrowserEvent.map);
      this.box_.setPixels(this.startPixel_, this.startPixel_);
      this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXSTART,
        mapBrowserEvent.coordinate, mapBrowserEvent));
      return true;
    } else {
      return false;
    }
  };

  return DragBox;
}(_Pointer_js__WEBPACK_IMPORTED_MODULE_3__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (DragBox);

//# sourceMappingURL=DragBox.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/DragPan.js":
/*!************************************************!*\
  !*** ./node_modules/ol/interaction/DragPan.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ViewHint.js */ "./node_modules/ol/ViewHint.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../coordinate.js */ "./node_modules/ol/coordinate.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../easing.js */ "./node_modules/ol/easing.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/**
 * @module ol/interaction/DragPan
 */








/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition~noModifierKeys}.
 * @property {import("../Kinetic.js").default} [kinetic] Kinetic inertia to apply to the pan.
 */


/**
 * @classdesc
 * Allows the user to pan the map by dragging the map.
 * @api
 */
var DragPan = /*@__PURE__*/(function (PointerInteraction) {
  function DragPan(opt_options) {

    PointerInteraction.call(this, {
      stopDown: _functions_js__WEBPACK_IMPORTED_MODULE_4__["FALSE"]
    });

    var options = opt_options ? opt_options : {};

    /**
     * @private
     * @type {import("../Kinetic.js").default|undefined}
     */
    this.kinetic_ = options.kinetic;

    /**
     * @type {import("../pixel.js").Pixel}
     */
    this.lastCentroid = null;

    /**
     * @type {number}
     */
    this.lastPointersCount_;

    /**
     * @type {boolean}
     */
    this.panning_ = false;

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_3__["noModifierKeys"];

    /**
     * @private
     * @type {boolean}
     */
    this.noKinetic_ = false;

  }

  if ( PointerInteraction ) DragPan.__proto__ = PointerInteraction;
  DragPan.prototype = Object.create( PointerInteraction && PointerInteraction.prototype );
  DragPan.prototype.constructor = DragPan;

  /**
   * @inheritDoc
   */
  DragPan.prototype.handleDragEvent = function handleDragEvent (mapBrowserEvent) {
    if (!this.panning_) {
      this.panning_ = true;
      this.getMap().getView().setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_0__["default"].INTERACTING, 1);
    }
    var targetPointers = this.targetPointers;
    var centroid = Object(_Pointer_js__WEBPACK_IMPORTED_MODULE_5__["centroid"])(targetPointers);
    if (targetPointers.length == this.lastPointersCount_) {
      if (this.kinetic_) {
        this.kinetic_.update(centroid[0], centroid[1]);
      }
      if (this.lastCentroid) {
        var deltaX = this.lastCentroid[0] - centroid[0];
        var deltaY = centroid[1] - this.lastCentroid[1];
        var map = mapBrowserEvent.map;
        var view = map.getView();
        var center = [deltaX, deltaY];
        Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_1__["scale"])(center, view.getResolution());
        Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_1__["rotate"])(center, view.getRotation());
        Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_1__["add"])(center, view.getCenter());
        center = view.constrainCenter(center);
        view.setCenter(center);
      }
    } else if (this.kinetic_) {
      // reset so we don't overestimate the kinetic energy after
      // after one finger down, tiny drag, second finger down
      this.kinetic_.begin();
    }
    this.lastCentroid = centroid;
    this.lastPointersCount_ = targetPointers.length;
  };

  /**
   * @inheritDoc
   */
  DragPan.prototype.handleUpEvent = function handleUpEvent (mapBrowserEvent) {
    var map = mapBrowserEvent.map;
    var view = map.getView();
    if (this.targetPointers.length === 0) {
      if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
        var distance = this.kinetic_.getDistance();
        var angle = this.kinetic_.getAngle();
        var center = /** @type {!import("../coordinate.js").Coordinate} */ (view.getCenter());
        var centerpx = map.getPixelFromCoordinate(center);
        var dest = map.getCoordinateFromPixel([
          centerpx[0] - distance * Math.cos(angle),
          centerpx[1] - distance * Math.sin(angle)
        ]);
        view.animate({
          center: view.constrainCenter(dest),
          duration: 500,
          easing: _easing_js__WEBPACK_IMPORTED_MODULE_2__["easeOut"]
        });
      }
      if (this.panning_) {
        this.panning_ = false;
        view.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_0__["default"].INTERACTING, -1);
      }
      return false;
    } else {
      if (this.kinetic_) {
        // reset so we don't overestimate the kinetic energy after
        // after one finger up, tiny drag, second finger up
        this.kinetic_.begin();
      }
      this.lastCentroid = null;
      return true;
    }
  };

  /**
   * @inheritDoc
   */
  DragPan.prototype.handleDownEvent = function handleDownEvent (mapBrowserEvent) {
    if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {
      var map = mapBrowserEvent.map;
      var view = map.getView();
      this.lastCentroid = null;
      // stop any current animation
      if (view.getAnimating()) {
        view.setCenter(mapBrowserEvent.frameState.viewState.center);
      }
      if (this.kinetic_) {
        this.kinetic_.begin();
      }
      // No kinetic as soon as more than one pointer on the screen is
      // detected. This is to prevent nasty pans after pinch.
      this.noKinetic_ = this.targetPointers.length > 1;
      return true;
    } else {
      return false;
    }
  };

  return DragPan;
}(_Pointer_js__WEBPACK_IMPORTED_MODULE_5__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (DragPan);

//# sourceMappingURL=DragPan.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/DragRotate.js":
/*!***************************************************!*\
  !*** ./node_modules/ol/interaction/DragRotate.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../rotationconstraint.js */ "./node_modules/ol/rotationconstraint.js");
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ViewHint.js */ "./node_modules/ol/ViewHint.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/**
 * @module ol/interaction/DragRotate
 */








/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that takes an
 * {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition~altShiftKeysOnly}.
 * @property {number} [duration=250] Animation duration in milliseconds.
 */


/**
 * @classdesc
 * Allows the user to rotate the map by clicking and dragging on the map,
 * normally combined with an {@link module:ol/events/condition} that limits
 * it to when the alt and shift keys are held down.
 *
 * This interaction is only supported for mouse devices.
 * @api
 */
var DragRotate = /*@__PURE__*/(function (PointerInteraction) {
  function DragRotate(opt_options) {

    var options = opt_options ? opt_options : {};

    PointerInteraction.call(this, {
      stopDown: _functions_js__WEBPACK_IMPORTED_MODULE_3__["FALSE"]
    });

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_2__["altShiftKeysOnly"];

    /**
     * @private
     * @type {number|undefined}
     */
    this.lastAngle_ = undefined;

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 250;

  }

  if ( PointerInteraction ) DragRotate.__proto__ = PointerInteraction;
  DragRotate.prototype = Object.create( PointerInteraction && PointerInteraction.prototype );
  DragRotate.prototype.constructor = DragRotate;

  /**
   * @inheritDoc
   */
  DragRotate.prototype.handleDragEvent = function handleDragEvent (mapBrowserEvent) {
    if (!Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_2__["mouseOnly"])(mapBrowserEvent)) {
      return;
    }

    var map = mapBrowserEvent.map;
    var view = map.getView();
    if (view.getConstraints().rotation === _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_0__["disable"]) {
      return;
    }
    var size = map.getSize();
    var offset = mapBrowserEvent.pixel;
    var theta =
        Math.atan2(size[1] / 2 - offset[1], offset[0] - size[0] / 2);
    if (this.lastAngle_ !== undefined) {
      var delta = theta - this.lastAngle_;
      var rotation = view.getRotation();
      Object(_Interaction_js__WEBPACK_IMPORTED_MODULE_4__["rotateWithoutConstraints"])(view, rotation - delta);
    }
    this.lastAngle_ = theta;
  };


  /**
   * @inheritDoc
   */
  DragRotate.prototype.handleUpEvent = function handleUpEvent (mapBrowserEvent) {
    if (!Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_2__["mouseOnly"])(mapBrowserEvent)) {
      return true;
    }

    var map = mapBrowserEvent.map;
    var view = map.getView();
    view.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_1__["default"].INTERACTING, -1);
    var rotation = view.getRotation();
    Object(_Interaction_js__WEBPACK_IMPORTED_MODULE_4__["rotate"])(view, rotation, undefined, this.duration_);
    return false;
  };


  /**
   * @inheritDoc
   */
  DragRotate.prototype.handleDownEvent = function handleDownEvent (mapBrowserEvent) {
    if (!Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_2__["mouseOnly"])(mapBrowserEvent)) {
      return false;
    }

    if (Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_2__["mouseActionButton"])(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {
      var map = mapBrowserEvent.map;
      map.getView().setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_1__["default"].INTERACTING, 1);
      this.lastAngle_ = undefined;
      return true;
    } else {
      return false;
    }
  };

  return DragRotate;
}(_Pointer_js__WEBPACK_IMPORTED_MODULE_5__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (DragRotate);

//# sourceMappingURL=DragRotate.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/DragRotateAndZoom.js":
/*!**********************************************************!*\
  !*** ./node_modules/ol/interaction/DragRotateAndZoom.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../rotationconstraint.js */ "./node_modules/ol/rotationconstraint.js");
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ViewHint.js */ "./node_modules/ol/ViewHint.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/**
 * @module ol/interaction/DragRotateAndZoom
 */







/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition~shiftKeyOnly}.
 * @property {number} [duration=400] Animation duration in milliseconds.
 */


/**
 * @classdesc
 * Allows the user to zoom and rotate the map by clicking and dragging
 * on the map.  By default, this interaction is limited to when the shift
 * key is held down.
 *
 * This interaction is only supported for mouse devices.
 *
 * And this interaction is not included in the default interactions.
 * @api
 */
var DragRotateAndZoom = /*@__PURE__*/(function (PointerInteraction) {
  function DragRotateAndZoom(opt_options) {

    var options = opt_options ? opt_options : {};

    PointerInteraction.call(/** @type {import("./Pointer.js").Options} */ this, (options));

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_2__["shiftKeyOnly"];

    /**
     * @private
     * @type {number|undefined}
     */
    this.lastAngle_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.lastMagnitude_ = undefined;

    /**
     * @private
     * @type {number}
     */
    this.lastScaleDelta_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 400;

  }

  if ( PointerInteraction ) DragRotateAndZoom.__proto__ = PointerInteraction;
  DragRotateAndZoom.prototype = Object.create( PointerInteraction && PointerInteraction.prototype );
  DragRotateAndZoom.prototype.constructor = DragRotateAndZoom;

  /**
   * @inheritDoc
   */
  DragRotateAndZoom.prototype.handleDragEvent = function handleDragEvent (mapBrowserEvent) {
    if (!Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_2__["mouseOnly"])(mapBrowserEvent)) {
      return;
    }

    var map = mapBrowserEvent.map;
    var size = map.getSize();
    var offset = mapBrowserEvent.pixel;
    var deltaX = offset[0] - size[0] / 2;
    var deltaY = size[1] / 2 - offset[1];
    var theta = Math.atan2(deltaY, deltaX);
    var magnitude = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    var view = map.getView();
    if (view.getConstraints().rotation !== _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_0__["disable"] && this.lastAngle_ !== undefined) {
      var angleDelta = theta - this.lastAngle_;
      Object(_Interaction_js__WEBPACK_IMPORTED_MODULE_3__["rotateWithoutConstraints"])(view, view.getRotation() - angleDelta);
    }
    this.lastAngle_ = theta;
    if (this.lastMagnitude_ !== undefined) {
      var resolution = this.lastMagnitude_ * (view.getResolution() / magnitude);
      Object(_Interaction_js__WEBPACK_IMPORTED_MODULE_3__["zoomWithoutConstraints"])(view, resolution);
    }
    if (this.lastMagnitude_ !== undefined) {
      this.lastScaleDelta_ = this.lastMagnitude_ / magnitude;
    }
    this.lastMagnitude_ = magnitude;
  };

  /**
   * @inheritDoc
   */
  DragRotateAndZoom.prototype.handleUpEvent = function handleUpEvent (mapBrowserEvent) {
    if (!Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_2__["mouseOnly"])(mapBrowserEvent)) {
      return true;
    }

    var map = mapBrowserEvent.map;
    var view = map.getView();
    view.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_1__["default"].INTERACTING, -1);
    var direction = this.lastScaleDelta_ - 1;
    Object(_Interaction_js__WEBPACK_IMPORTED_MODULE_3__["rotate"])(view, view.getRotation());
    Object(_Interaction_js__WEBPACK_IMPORTED_MODULE_3__["zoom"])(view, view.getResolution(), undefined, this.duration_, direction);
    this.lastScaleDelta_ = 0;
    return false;
  };

  /**
   * @inheritDoc
   */
  DragRotateAndZoom.prototype.handleDownEvent = function handleDownEvent (mapBrowserEvent) {
    if (!Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_2__["mouseOnly"])(mapBrowserEvent)) {
      return false;
    }

    if (this.condition_(mapBrowserEvent)) {
      mapBrowserEvent.map.getView().setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_1__["default"].INTERACTING, 1);
      this.lastAngle_ = undefined;
      this.lastMagnitude_ = undefined;
      return true;
    } else {
      return false;
    }
  };

  return DragRotateAndZoom;
}(_Pointer_js__WEBPACK_IMPORTED_MODULE_4__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (DragRotateAndZoom);

//# sourceMappingURL=DragRotateAndZoom.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/DragZoom.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/interaction/DragZoom.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../easing.js */ "./node_modules/ol/easing.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _DragBox_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DragBox.js */ "./node_modules/ol/interaction/DragBox.js");
/**
 * @module ol/interaction/DragZoom
 */






/**
 * @typedef {Object} Options
 * @property {string} [className='ol-dragzoom'] CSS class name for styling the
 * box.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition~shiftKeyOnly}.
 * @property {number} [duration=200] Animation duration in milliseconds.
 * @property {boolean} [out=false] Use interaction for zooming out.
 */


/**
 * @classdesc
 * Allows the user to zoom the map by clicking and dragging on the map,
 * normally combined with an {@link module:ol/events/condition} that limits
 * it to when a key, shift by default, is held down.
 *
 * To change the style of the box, use CSS and the `.ol-dragzoom` selector, or
 * your custom one configured with `className`.
 * @api
 */
var DragZoom = /*@__PURE__*/(function (DragBox) {
  function DragZoom(opt_options) {
    var options = opt_options ? opt_options : {};

    var condition = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_1__["shiftKeyOnly"];

    DragBox.call(this, {
      condition: condition,
      className: options.className || 'ol-dragzoom',
      onBoxEnd: onBoxEnd
    });

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 200;

    /**
     * @private
     * @type {boolean}
     */
    this.out_ = options.out !== undefined ? options.out : false;
  }

  if ( DragBox ) DragZoom.__proto__ = DragBox;
  DragZoom.prototype = Object.create( DragBox && DragBox.prototype );
  DragZoom.prototype.constructor = DragZoom;

  return DragZoom;
}(_DragBox_js__WEBPACK_IMPORTED_MODULE_3__["default"]));


/**
 * @this {DragZoom}
 */
function onBoxEnd() {
  var map = this.getMap();
  var view = /** @type {!import("../View.js").default} */ (map.getView());
  var size = /** @type {!import("../size.js").Size} */ (map.getSize());
  var extent = this.getGeometry().getExtent();

  if (this.out_) {
    var mapExtent = view.calculateExtent(size);
    var boxPixelExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["createOrUpdateFromCoordinates"])([
      map.getPixelFromCoordinate(Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["getBottomLeft"])(extent)),
      map.getPixelFromCoordinate(Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["getTopRight"])(extent))]);
    var factor = view.getResolutionForExtent(boxPixelExtent, size);

    Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["scaleFromCenter"])(mapExtent, 1 / factor);
    extent = mapExtent;
  }

  var resolution = view.constrainResolution(
    view.getResolutionForExtent(extent, size));

  var center = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["getCenter"])(extent);
  center = view.constrainCenter(center);

  view.animate({
    resolution: resolution,
    center: center,
    duration: this.duration_,
    easing: _easing_js__WEBPACK_IMPORTED_MODULE_0__["easeOut"]
  });
}


/* harmony default export */ __webpack_exports__["default"] = (DragZoom);

//# sourceMappingURL=DragZoom.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/Draw.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/interaction/Draw.js ***!
  \*********************************************/
/*! exports provided: createRegularPolygon, createBox, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createRegularPolygon", function() { return createRegularPolygon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createBox", function() { return createBox; });
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Feature.js */ "./node_modules/ol/Feature.js");
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../MapBrowserEventType.js */ "./node_modules/ol/MapBrowserEventType.js");
/* harmony import */ var _MapBrowserPointerEvent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../MapBrowserPointerEvent.js */ "./node_modules/ol/MapBrowserPointerEvent.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../coordinate.js */ "./node_modules/ol/coordinate.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _geom_Circle_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../geom/Circle.js */ "./node_modules/ol/geom/Circle.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _geom_LineString_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../geom/LineString.js */ "./node_modules/ol/geom/LineString.js");
/* harmony import */ var _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../geom/MultiLineString.js */ "./node_modules/ol/geom/MultiLineString.js");
/* harmony import */ var _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../geom/MultiPoint.js */ "./node_modules/ol/geom/MultiPoint.js");
/* harmony import */ var _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../geom/MultiPolygon.js */ "./node_modules/ol/geom/MultiPolygon.js");
/* harmony import */ var _pointer_MouseSource_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../pointer/MouseSource.js */ "./node_modules/ol/pointer/MouseSource.js");
/* harmony import */ var _geom_Point_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../geom/Point.js */ "./node_modules/ol/geom/Point.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../geom/Polygon.js */ "./node_modules/ol/geom/Polygon.js");
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/* harmony import */ var _Property_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./Property.js */ "./node_modules/ol/interaction/Property.js");
/* harmony import */ var _layer_Vector_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../layer/Vector.js */ "./node_modules/ol/layer/Vector.js");
/* harmony import */ var _source_Vector_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../source/Vector.js */ "./node_modules/ol/source/Vector.js");
/* harmony import */ var _style_Style_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../style/Style.js */ "./node_modules/ol/style/Style.js");
/**
 * @module ol/interaction/Draw
 */



























/**
 * @typedef {Object} Options
 * @property {GeometryType} type Geometry type of
 * the geometries being drawn with this instance.
 * @property {number} [clickTolerance=6] The maximum distance in pixels between
 * "down" and "up" for a "up" event to be considered a "click" event and
 * actually add a point/vertex to the geometry being drawn.  The default of `6`
 * was chosen for the draw interaction to behave correctly on mouse as well as
 * on touch devices.
 * @property {import("../Collection.js").default<Feature>} [features]
 * Destination collection for the drawn features.
 * @property {VectorSource} [source] Destination source for
 * the drawn features.
 * @property {number} [dragVertexDelay=500] Delay in milliseconds after pointerdown
 * before the current vertex can be dragged to its exact position.
 * @property {number} [snapTolerance=12] Pixel distance for snapping to the
 * drawing finish.
 * @property {boolean} [stopClick=false] Stop click, singleclick, and
 * doubleclick events from firing during drawing.
 * @property {number} [maxPoints] The number of points that can be drawn before
 * a polygon ring or line string is finished. By default there is no
 * restriction.
 * @property {number} [minPoints] The number of points that must be drawn
 * before a polygon ring or line string can be finished. Default is `3` for
 * polygon rings and `2` for line strings.
 * @property {import("../events/condition.js").Condition} [finishCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether the drawing can be finished.
 * @property {import("../style/Style.js").StyleLike} [style]
 * Style for sketch features.
 * @property {GeometryFunction} [geometryFunction]
 * Function that is called when a geometry's coordinates are updated.
 * @property {string} [geometryName] Geometry name to use for features created
 * by the draw interaction.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * By default {@link module:ol/events/condition~noModifierKeys}, i.e. a click,
 * adds a vertex or deactivates freehand drawing.
 * @property {boolean} [freehand=false] Operate in freehand mode for lines,
 * polygons, and circles.  This makes the interaction always operate in freehand
 * mode and takes precedence over any `freehandCondition` option.
 * @property {import("../events/condition.js").Condition} [freehandCondition]
 * Condition that activates freehand drawing for lines and polygons. This
 * function takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and
 * returns a boolean to indicate whether that event should be handled. The
 * default is {@link module:ol/events/condition~shiftKeyOnly}, meaning that the
 * Shift key activates freehand drawing.
 * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch
 * overlay.
 */


/**
 * Coordinate type when drawing points.
 * @typedef {import("../coordinate.js").Coordinate} PointCoordType
 */


/**
 * Coordinate type when drawing lines.
 * @typedef {Array<import("../coordinate.js").Coordinate>} LineCoordType
 */


/**
 * Coordinate type when drawing polygons.
 * @typedef {Array<Array<import("../coordinate.js").Coordinate>>} PolyCoordType
 */


/**
 * Types used for drawing coordinates.
 * @typedef {PointCoordType|LineCoordType|PolyCoordType} SketchCoordType
 */


/**
 * Function that takes an array of coordinates and an optional existing geometry as
 * arguments, and returns a geometry. The optional existing geometry is the
 * geometry that is returned when the function is called without a second
 * argument.
 * @typedef {function(!SketchCoordType, import("../geom/SimpleGeometry.js").default=):
 *     import("../geom/SimpleGeometry.js").default} GeometryFunction
 */


/**
 * Draw mode.  This collapses multi-part geometry types with their single-part
 * cousins.
 * @enum {string}
 */
var Mode = {
  POINT: 'Point',
  LINE_STRING: 'LineString',
  POLYGON: 'Polygon',
  CIRCLE: 'Circle'
};


/**
 * @enum {string}
 */
var DrawEventType = {
  /**
   * Triggered upon feature draw start
   * @event DrawEvent#drawstart
   * @api
   */
  DRAWSTART: 'drawstart',
  /**
   * Triggered upon feature draw end
   * @event DrawEvent#drawend
   * @api
   */
  DRAWEND: 'drawend'
};


/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Draw~Draw} instances are
 * instances of this type.
 */
var DrawEvent = /*@__PURE__*/(function (Event) {
  function DrawEvent(type, feature) {

    Event.call(this, type);

    /**
     * The feature being drawn.
     * @type {Feature}
     * @api
     */
    this.feature = feature;

  }

  if ( Event ) DrawEvent.__proto__ = Event;
  DrawEvent.prototype = Object.create( Event && Event.prototype );
  DrawEvent.prototype.constructor = DrawEvent;

  return DrawEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_7__["default"]));


/**
 * @classdesc
 * Interaction for drawing feature geometries.
 *
 * @fires DrawEvent
 * @api
 */
var Draw = /*@__PURE__*/(function (PointerInteraction) {
  function Draw(options) {

    var pointerOptions = /** @type {import("./Pointer.js").Options} */ (options);
    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = _functions_js__WEBPACK_IMPORTED_MODULE_10__["FALSE"];
    }

    PointerInteraction.call(this, pointerOptions);

    /**
     * @type {boolean}
     * @private
     */
    this.shouldHandle_ = false;

    /**
     * @type {import("../pixel.js").Pixel}
     * @private
     */
    this.downPx_ = null;

    /**
     * @type {?}
     * @private
     */
    this.downTimeout_;

    /**
     * @type {number|undefined}
     * @private
     */
    this.lastDragTime_;

    /**
     * @type {boolean}
     * @private
     */
    this.freehand_ = false;

    /**
     * Target source for drawn features.
     * @type {VectorSource}
     * @private
     */
    this.source_ = options.source ? options.source : null;

    /**
     * Target collection for drawn features.
     * @type {import("../Collection.js").default<Feature>}
     * @private
     */
    this.features_ = options.features ? options.features : null;

    /**
     * Pixel distance for snapping.
     * @type {number}
     * @private
     */
    this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;

    /**
     * Geometry type.
     * @type {GeometryType}
     * @private
     */
    this.type_ = /** @type {GeometryType} */ (options.type);

    /**
     * Drawing mode (derived from geometry type.
     * @type {Mode}
     * @private
     */
    this.mode_ = getMode(this.type_);

    /**
     * Stop click, singleclick, and doubleclick events from firing during drawing.
     * Default is `false`.
     * @type {boolean}
     * @private
     */
    this.stopClick_ = !!options.stopClick;

    /**
     * The number of points that must be drawn before a polygon ring or line
     * string can be finished.  The default is 3 for polygon rings and 2 for
     * line strings.
     * @type {number}
     * @private
     */
    this.minPoints_ = options.minPoints ?
      options.minPoints :
      (this.mode_ === Mode.POLYGON ? 3 : 2);

    /**
     * The number of points that can be drawn before a polygon ring or line string
     * is finished. The default is no restriction.
     * @type {number}
     * @private
     */
    this.maxPoints_ = options.maxPoints ? options.maxPoints : Infinity;

    /**
     * A function to decide if a potential finish coordinate is permissible
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.finishCondition_ = options.finishCondition ? options.finishCondition : _functions_js__WEBPACK_IMPORTED_MODULE_10__["TRUE"];

    var geometryFunction = options.geometryFunction;
    if (!geometryFunction) {
      if (this.type_ === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].CIRCLE) {
        /**
         * @param {!LineCoordType} coordinates The coordinates.
         * @param {import("../geom/SimpleGeometry.js").default=} opt_geometry Optional geometry.
         * @return {import("../geom/SimpleGeometry.js").default} A geometry.
         */
        geometryFunction = function(coordinates, opt_geometry) {
          var circle = opt_geometry ? /** @type {Circle} */ (opt_geometry) :
            new _geom_Circle_js__WEBPACK_IMPORTED_MODULE_11__["default"]([NaN, NaN]);
          var squaredLength = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_5__["squaredDistance"])(
            coordinates[0], coordinates[1]);
          circle.setCenterAndRadius(coordinates[0], Math.sqrt(squaredLength));
          return circle;
        };
      } else {
        var Constructor;
        var mode = this.mode_;
        if (mode === Mode.POINT) {
          Constructor = _geom_Point_js__WEBPACK_IMPORTED_MODULE_18__["default"];
        } else if (mode === Mode.LINE_STRING) {
          Constructor = _geom_LineString_js__WEBPACK_IMPORTED_MODULE_13__["default"];
        } else if (mode === Mode.POLYGON) {
          Constructor = _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_19__["default"];
        }
        /**
         * @param {!LineCoordType} coordinates The coordinates.
         * @param {import("../geom/SimpleGeometry.js").default=} opt_geometry Optional geometry.
         * @return {import("../geom/SimpleGeometry.js").default} A geometry.
         */
        geometryFunction = function(coordinates, opt_geometry) {
          var geometry = opt_geometry;
          if (geometry) {
            if (mode === Mode.POLYGON) {
              if (coordinates[0].length) {
                // Add a closing coordinate to match the first
                geometry.setCoordinates([coordinates[0].concat([coordinates[0][0]])]);
              } else {
                geometry.setCoordinates([]);
              }
            } else {
              geometry.setCoordinates(coordinates);
            }
          } else {
            geometry = new Constructor(coordinates);
          }
          return geometry;
        };
      }
    }

    /**
     * @type {GeometryFunction}
     * @private
     */
    this.geometryFunction_ = geometryFunction;

    /**
     * @type {number}
     * @private
     */
    this.dragVertexDelay_ = options.dragVertexDelay !== undefined ? options.dragVertexDelay : 500;

    /**
     * Finish coordinate for the feature (first point for polygons, last point for
     * linestrings).
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */
    this.finishCoordinate_ = null;

    /**
     * Sketch feature.
     * @type {Feature}
     * @private
     */
    this.sketchFeature_ = null;

    /**
     * Sketch point.
     * @type {Feature}
     * @private
     */
    this.sketchPoint_ = null;

    /**
     * Sketch coordinates. Used when drawing a line or polygon.
     * @type {SketchCoordType}
     * @private
     */
    this.sketchCoords_ = null;

    /**
     * Sketch line. Used when drawing polygon.
     * @type {Feature}
     * @private
     */
    this.sketchLine_ = null;

    /**
     * Sketch line coordinates. Used when drawing a polygon or circle.
     * @type {LineCoordType}
     * @private
     */
    this.sketchLineCoords_ = null;

    /**
     * Squared tolerance for handling up events.  If the squared distance
     * between a down and up event is greater than this tolerance, up events
     * will not be handled.
     * @type {number}
     * @private
     */
    this.squaredClickTolerance_ = options.clickTolerance ?
      options.clickTolerance * options.clickTolerance : 36;

    /**
     * Draw overlay where our sketch features are drawn.
     * @type {VectorLayer}
     * @private
     */
    this.overlay_ = new _layer_Vector_js__WEBPACK_IMPORTED_MODULE_22__["default"]({
      source: new _source_Vector_js__WEBPACK_IMPORTED_MODULE_23__["default"]({
        useSpatialIndex: false,
        wrapX: options.wrapX ? options.wrapX : false
      }),
      style: options.style ? options.style :
        getDefaultStyleFunction(),
      updateWhileInteracting: true
    });

    /**
     * Name of the geometry attribute for newly created features.
     * @type {string|undefined}
     * @private
     */
    this.geometryName_ = options.geometryName;

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_8__["noModifierKeys"];

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.freehandCondition_;
    if (options.freehand) {
      this.freehandCondition_ = _events_condition_js__WEBPACK_IMPORTED_MODULE_8__["always"];
    } else {
      this.freehandCondition_ = options.freehandCondition ?
        options.freehandCondition : _events_condition_js__WEBPACK_IMPORTED_MODULE_8__["shiftKeyOnly"];
    }

    Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(this,
      Object(_Object_js__WEBPACK_IMPORTED_MODULE_4__["getChangeEventType"])(_Property_js__WEBPACK_IMPORTED_MODULE_21__["default"].ACTIVE),
      this.updateState_, this);

  }

  if ( PointerInteraction ) Draw.__proto__ = PointerInteraction;
  Draw.prototype = Object.create( PointerInteraction && PointerInteraction.prototype );
  Draw.prototype.constructor = Draw;

  /**
   * @inheritDoc
   */
  Draw.prototype.setMap = function setMap (map) {
    PointerInteraction.prototype.setMap.call(this, map);
    this.updateState_();
  };

  /**
   * Get the overlay layer that this interaction renders sketch features to.
   * @return {VectorLayer} Overlay layer.
   * @api
   */
  Draw.prototype.getOverlay = function getOverlay () {
    return this.overlay_;
  };

  /**
   * Handles the {@link module:ol/MapBrowserEvent map browser event} and may actually draw or finish the drawing.
   * @override
   * @api
   */
  Draw.prototype.handleEvent = function handleEvent (event) {
    if (event.originalEvent.type === _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].CONTEXTMENU) {
      // Avoid context menu for long taps when drawing on mobile
      event.preventDefault();
    }
    this.freehand_ = this.mode_ !== Mode.POINT && this.freehandCondition_(event);
    var move = event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERMOVE;
    var pass = true;
    if (!this.freehand_ && this.lastDragTime_ && event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERDRAG) {
      var now = Date.now();
      if (now - this.lastDragTime_ >= this.dragVertexDelay_) {
        this.downPx_ = event.pixel;
        this.shouldHandle_ = !this.freehand_;
        move = true;
      } else {
        this.lastDragTime_ = undefined;
      }
      if (this.shouldHandle_ && this.downTimeout_ !== undefined) {
        clearTimeout(this.downTimeout_);
        this.downTimeout_ = undefined;
      }
    }
    if (this.freehand_ &&
        event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERDRAG &&
        this.sketchFeature_ !== null) {
      this.addToDrawing_(event);
      pass = false;
    } else if (this.freehand_ &&
        event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERDOWN) {
      pass = false;
    } else if (move) {
      pass = event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERMOVE;
      if (pass && this.freehand_) {
        pass = this.handlePointerMove_(event);
      } else if (/** @type {MapBrowserPointerEvent} */ (event).pointerEvent.pointerType == _pointer_MouseSource_js__WEBPACK_IMPORTED_MODULE_17__["POINTER_TYPE"] ||
          (event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERDRAG && this.downTimeout_ === undefined)) {
        this.handlePointerMove_(event);
      }
    } else if (event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].DBLCLICK) {
      pass = false;
    }

    return PointerInteraction.prototype.handleEvent.call(this, event) && pass;
  };

  /**
   * @inheritDoc
   */
  Draw.prototype.handleDownEvent = function handleDownEvent (event) {
    this.shouldHandle_ = !this.freehand_;

    if (this.freehand_) {
      this.downPx_ = event.pixel;
      if (!this.finishCoordinate_) {
        this.startDrawing_(event);
      }
      return true;
    } else if (this.condition_(event)) {
      this.lastDragTime_ = Date.now();
      this.downTimeout_ = setTimeout(function() {
        this.handlePointerMove_(new _MapBrowserPointerEvent_js__WEBPACK_IMPORTED_MODULE_3__["default"](
          _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERMOVE, event.map, event.pointerEvent, false, event.frameState));
      }.bind(this), this.dragVertexDelay_);
      this.downPx_ = event.pixel;
      return true;
    } else {
      return false;
    }
  };


  /**
   * @inheritDoc
   */
  Draw.prototype.handleUpEvent = function handleUpEvent (event) {
    var pass = true;

    if (this.downTimeout_) {
      clearTimeout(this.downTimeout_);
      this.downTimeout_ = undefined;
    }

    this.handlePointerMove_(event);

    var circleMode = this.mode_ === Mode.CIRCLE;

    if (this.shouldHandle_) {
      if (!this.finishCoordinate_) {
        this.startDrawing_(event);
        if (this.mode_ === Mode.POINT) {
          this.finishDrawing();
        }
      } else if (this.freehand_ || circleMode) {
        this.finishDrawing();
      } else if (this.atFinish_(event)) {
        if (this.finishCondition_(event)) {
          this.finishDrawing();
        }
      } else {
        this.addToDrawing_(event);
      }
      pass = false;
    } else if (this.freehand_) {
      this.finishCoordinate_ = null;
      this.abortDrawing_();
    }
    if (!pass && this.stopClick_) {
      event.stopPropagation();
    }
    return pass;
  };

  /**
   * Handle move events.
   * @param {import("../MapBrowserEvent.js").default} event A move event.
   * @return {boolean} Pass the event to other interactions.
   * @private
   */
  Draw.prototype.handlePointerMove_ = function handlePointerMove_ (event) {
    if (this.downPx_ &&
        ((!this.freehand_ && this.shouldHandle_) ||
        (this.freehand_ && !this.shouldHandle_))) {
      var downPx = this.downPx_;
      var clickPx = event.pixel;
      var dx = downPx[0] - clickPx[0];
      var dy = downPx[1] - clickPx[1];
      var squaredDistance = dx * dx + dy * dy;
      this.shouldHandle_ = this.freehand_ ?
        squaredDistance > this.squaredClickTolerance_ :
        squaredDistance <= this.squaredClickTolerance_;
      if (!this.shouldHandle_) {
        return true;
      }
    }

    if (this.finishCoordinate_) {
      this.modifyDrawing_(event);
    } else {
      this.createOrUpdateSketchPoint_(event);
    }
    return true;
  };

  /**
   * Determine if an event is within the snapping tolerance of the start coord.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} The event is within the snapping tolerance of the start.
   * @private
   */
  Draw.prototype.atFinish_ = function atFinish_ (event) {
    var at = false;
    if (this.sketchFeature_) {
      var potentiallyDone = false;
      var potentiallyFinishCoordinates = [this.finishCoordinate_];
      if (this.mode_ === Mode.LINE_STRING) {
        potentiallyDone = this.sketchCoords_.length > this.minPoints_;
      } else if (this.mode_ === Mode.POLYGON) {
        var sketchCoords = /** @type {PolyCoordType} */ (this.sketchCoords_);
        potentiallyDone = sketchCoords[0].length > this.minPoints_;
        potentiallyFinishCoordinates = [sketchCoords[0][0], sketchCoords[0][sketchCoords[0].length - 2]];
      }
      if (potentiallyDone) {
        var map = event.map;
        for (var i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++) {
          var finishCoordinate = potentiallyFinishCoordinates[i];
          var finishPixel = map.getPixelFromCoordinate(finishCoordinate);
          var pixel = event.pixel;
          var dx = pixel[0] - finishPixel[0];
          var dy = pixel[1] - finishPixel[1];
          var snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;
          at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;
          if (at) {
            this.finishCoordinate_ = finishCoordinate;
            break;
          }
        }
      }
    }
    return at;
  };

  /**
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @private
   */
  Draw.prototype.createOrUpdateSketchPoint_ = function createOrUpdateSketchPoint_ (event) {
    var coordinates = event.coordinate.slice();
    if (!this.sketchPoint_) {
      this.sketchPoint_ = new _Feature_js__WEBPACK_IMPORTED_MODULE_1__["default"](new _geom_Point_js__WEBPACK_IMPORTED_MODULE_18__["default"](coordinates));
      this.updateSketchFeatures_();
    } else {
      var sketchPointGeom = /** @type {Point} */ (this.sketchPoint_.getGeometry());
      sketchPointGeom.setCoordinates(coordinates);
    }
  };

  /**
   * Start the drawing.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @private
   */
  Draw.prototype.startDrawing_ = function startDrawing_ (event) {
    var start = event.coordinate;
    this.finishCoordinate_ = start;
    if (this.mode_ === Mode.POINT) {
      this.sketchCoords_ = start.slice();
    } else if (this.mode_ === Mode.POLYGON) {
      this.sketchCoords_ = [[start.slice(), start.slice()]];
      this.sketchLineCoords_ = this.sketchCoords_[0];
    } else {
      this.sketchCoords_ = [start.slice(), start.slice()];
    }
    if (this.sketchLineCoords_) {
      this.sketchLine_ = new _Feature_js__WEBPACK_IMPORTED_MODULE_1__["default"](
        new _geom_LineString_js__WEBPACK_IMPORTED_MODULE_13__["default"](this.sketchLineCoords_));
    }
    var geometry = this.geometryFunction_(this.sketchCoords_);
    this.sketchFeature_ = new _Feature_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
    if (this.geometryName_) {
      this.sketchFeature_.setGeometryName(this.geometryName_);
    }
    this.sketchFeature_.setGeometry(geometry);
    this.updateSketchFeatures_();
    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));
  };

  /**
   * Modify the drawing.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @private
   */
  Draw.prototype.modifyDrawing_ = function modifyDrawing_ (event) {
    var coordinate = event.coordinate;
    var geometry = /** @type {import("../geom/SimpleGeometry.js").default} */ (this.sketchFeature_.getGeometry());
    var coordinates, last;
    if (this.mode_ === Mode.POINT) {
      last = this.sketchCoords_;
    } else if (this.mode_ === Mode.POLYGON) {
      coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];
      last = coordinates[coordinates.length - 1];
      if (this.atFinish_(event)) {
        // snap to finish
        coordinate = this.finishCoordinate_.slice();
      }
    } else {
      coordinates = this.sketchCoords_;
      last = coordinates[coordinates.length - 1];
    }
    last[0] = coordinate[0];
    last[1] = coordinate[1];
    this.geometryFunction_(/** @type {!LineCoordType} */ (this.sketchCoords_), geometry);
    if (this.sketchPoint_) {
      var sketchPointGeom = /** @type {Point} */ (this.sketchPoint_.getGeometry());
      sketchPointGeom.setCoordinates(coordinate);
    }
    /** @type {LineString} */
    var sketchLineGeom;
    if (geometry.getType() == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].POLYGON &&
        this.mode_ !== Mode.POLYGON) {
      if (!this.sketchLine_) {
        this.sketchLine_ = new _Feature_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
      }
      var ring = /** @type {Polygon} */ (geometry).getLinearRing(0);
      sketchLineGeom = /** @type {LineString} */ (this.sketchLine_.getGeometry());
      if (!sketchLineGeom) {
        sketchLineGeom = new _geom_LineString_js__WEBPACK_IMPORTED_MODULE_13__["default"](ring.getFlatCoordinates(), ring.getLayout());
        this.sketchLine_.setGeometry(sketchLineGeom);
      } else {
        sketchLineGeom.setFlatCoordinates(
          ring.getLayout(), ring.getFlatCoordinates());
        sketchLineGeom.changed();
      }
    } else if (this.sketchLineCoords_) {
      sketchLineGeom = /** @type {LineString} */ (this.sketchLine_.getGeometry());
      sketchLineGeom.setCoordinates(this.sketchLineCoords_);
    }
    this.updateSketchFeatures_();
  };

  /**
   * Add a new coordinate to the drawing.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @private
   */
  Draw.prototype.addToDrawing_ = function addToDrawing_ (event) {
    var coordinate = event.coordinate;
    var geometry = /** @type {import("../geom/SimpleGeometry.js").default} */ (this.sketchFeature_.getGeometry());
    var done;
    var coordinates;
    if (this.mode_ === Mode.LINE_STRING) {
      this.finishCoordinate_ = coordinate.slice();
      coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);
      if (coordinates.length >= this.maxPoints_) {
        if (this.freehand_) {
          coordinates.pop();
        } else {
          done = true;
        }
      }
      coordinates.push(coordinate.slice());
      this.geometryFunction_(coordinates, geometry);
    } else if (this.mode_ === Mode.POLYGON) {
      coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];
      if (coordinates.length >= this.maxPoints_) {
        if (this.freehand_) {
          coordinates.pop();
        } else {
          done = true;
        }
      }
      coordinates.push(coordinate.slice());
      if (done) {
        this.finishCoordinate_ = coordinates[0];
      }
      this.geometryFunction_(this.sketchCoords_, geometry);
    }
    this.updateSketchFeatures_();
    if (done) {
      this.finishDrawing();
    }
  };

  /**
   * Remove last point of the feature currently being drawn.
   * @api
   */
  Draw.prototype.removeLastPoint = function removeLastPoint () {
    if (!this.sketchFeature_) {
      return;
    }
    var geometry = /** @type {import("../geom/SimpleGeometry.js").default} */ (this.sketchFeature_.getGeometry());
    var coordinates;
    /** @type {LineString} */
    var sketchLineGeom;
    if (this.mode_ === Mode.LINE_STRING) {
      coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);
      coordinates.splice(-2, 1);
      this.geometryFunction_(coordinates, geometry);
      if (coordinates.length >= 2) {
        this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();
      }
    } else if (this.mode_ === Mode.POLYGON) {
      coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];
      coordinates.splice(-2, 1);
      sketchLineGeom = /** @type {LineString} */ (this.sketchLine_.getGeometry());
      sketchLineGeom.setCoordinates(coordinates);
      this.geometryFunction_(this.sketchCoords_, geometry);
    }

    if (coordinates.length === 0) {
      this.finishCoordinate_ = null;
    }

    this.updateSketchFeatures_();
  };

  /**
   * Stop drawing and add the sketch feature to the target layer.
   * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is
   * dispatched before inserting the feature.
   * @api
   */
  Draw.prototype.finishDrawing = function finishDrawing () {
    var sketchFeature = this.abortDrawing_();
    if (!sketchFeature) {
      return;
    }
    var coordinates = this.sketchCoords_;
    var geometry = /** @type {import("../geom/SimpleGeometry.js").default} */ (sketchFeature.getGeometry());
    if (this.mode_ === Mode.LINE_STRING) {
      // remove the redundant last point
      coordinates.pop();
      this.geometryFunction_(coordinates, geometry);
    } else if (this.mode_ === Mode.POLYGON) {
      // remove the redundant last point in ring
      /** @type {PolyCoordType} */ (coordinates)[0].pop();
      this.geometryFunction_(coordinates, geometry);
      coordinates = geometry.getCoordinates();
    }

    // cast multi-part geometries
    if (this.type_ === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].MULTI_POINT) {
      sketchFeature.setGeometry(new _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_15__["default"]([/** @type {PointCoordType} */(coordinates)]));
    } else if (this.type_ === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].MULTI_LINE_STRING) {
      sketchFeature.setGeometry(new _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_14__["default"]([/** @type {LineCoordType} */(coordinates)]));
    } else if (this.type_ === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].MULTI_POLYGON) {
      sketchFeature.setGeometry(new _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_16__["default"]([/** @type {PolyCoordType} */(coordinates)]));
    }

    // First dispatch event to allow full set up of feature
    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature));

    // Then insert feature
    if (this.features_) {
      this.features_.push(sketchFeature);
    }
    if (this.source_) {
      this.source_.addFeature(sketchFeature);
    }
  };

  /**
   * Stop drawing without adding the sketch feature to the target layer.
   * @return {Feature} The sketch feature (or null if none).
   * @private
   */
  Draw.prototype.abortDrawing_ = function abortDrawing_ () {
    this.finishCoordinate_ = null;
    var sketchFeature = this.sketchFeature_;
    if (sketchFeature) {
      this.sketchFeature_ = null;
      this.sketchPoint_ = null;
      this.sketchLine_ = null;
      /** @type {VectorSource} */ (this.overlay_.getSource()).clear(true);
    }
    return sketchFeature;
  };

  /**
   * Extend an existing geometry by adding additional points. This only works
   * on features with `LineString` geometries, where the interaction will
   * extend lines by adding points to the end of the coordinates array.
   * @param {!Feature} feature Feature to be extended.
   * @api
   */
  Draw.prototype.extend = function extend (feature) {
    var geometry = feature.getGeometry();
    var lineString = /** @type {LineString} */ (geometry);
    this.sketchFeature_ = feature;
    this.sketchCoords_ = lineString.getCoordinates();
    var last = this.sketchCoords_[this.sketchCoords_.length - 1];
    this.finishCoordinate_ = last.slice();
    this.sketchCoords_.push(last.slice());
    this.updateSketchFeatures_();
    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));
  };

  /**
   * Redraw the sketch features.
   * @private
   */
  Draw.prototype.updateSketchFeatures_ = function updateSketchFeatures_ () {
    var sketchFeatures = [];
    if (this.sketchFeature_) {
      sketchFeatures.push(this.sketchFeature_);
    }
    if (this.sketchLine_) {
      sketchFeatures.push(this.sketchLine_);
    }
    if (this.sketchPoint_) {
      sketchFeatures.push(this.sketchPoint_);
    }
    var overlaySource = /** @type {VectorSource} */ (this.overlay_.getSource());
    overlaySource.clear(true);
    overlaySource.addFeatures(sketchFeatures);
  };

  /**
   * @private
   */
  Draw.prototype.updateState_ = function updateState_ () {
    var map = this.getMap();
    var active = this.getActive();
    if (!map || !active) {
      this.abortDrawing_();
    }
    this.overlay_.setMap(active ? map : null);
  };

  return Draw;
}(_Pointer_js__WEBPACK_IMPORTED_MODULE_20__["default"]));


/**
 * @return {import("../style/Style.js").StyleFunction} Styles.
 */
function getDefaultStyleFunction() {
  var styles = Object(_style_Style_js__WEBPACK_IMPORTED_MODULE_24__["createEditingStyle"])();
  return function(feature, resolution) {
    return styles[feature.getGeometry().getType()];
  };
}


/**
 * Create a `geometryFunction` for `type: 'Circle'` that will create a regular
 * polygon with a user specified number of sides and start angle instead of an
 * `import("../geom/Circle.js").Circle` geometry.
 * @param {number=} opt_sides Number of sides of the regular polygon. Default is
 *     32.
 * @param {number=} opt_angle Angle of the first point in radians. 0 means East.
 *     Default is the angle defined by the heading from the center of the
 *     regular polygon to the current pointer position.
 * @return {GeometryFunction} Function that draws a
 *     polygon.
 * @api
 */
function createRegularPolygon(opt_sides, opt_angle) {
  return function(coordinates, opt_geometry) {
    var center = /** @type {LineCoordType} */ (coordinates)[0];
    var end = /** @type {LineCoordType} */ (coordinates)[1];
    var radius = Math.sqrt(
      Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_5__["squaredDistance"])(center, end));
    var geometry = opt_geometry ? /** @type {Polygon} */ (opt_geometry) :
      Object(_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_19__["fromCircle"])(new _geom_Circle_js__WEBPACK_IMPORTED_MODULE_11__["default"](center), opt_sides);
    var angle = opt_angle;
    if (!opt_angle) {
      var x = end[0] - center[0];
      var y = end[1] - center[1];
      angle = Math.atan(y / x) - (x < 0 ? Math.PI : 0);
    }
    Object(_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_19__["makeRegular"])(geometry, center, radius, angle);
    return geometry;
  };
}


/**
 * Create a `geometryFunction` that will create a box-shaped polygon (aligned
 * with the coordinate system axes).  Use this with the draw interaction and
 * `type: 'Circle'` to return a box instead of a circle geometry.
 * @return {GeometryFunction} Function that draws a box-shaped polygon.
 * @api
 */
function createBox() {
  return (
    function(coordinates, opt_geometry) {
      var extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_9__["boundingExtent"])(/** @type {LineCoordType} */ (coordinates));
      var boxCoordinates = [[
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_9__["getBottomLeft"])(extent),
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_9__["getBottomRight"])(extent),
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_9__["getTopRight"])(extent),
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_9__["getTopLeft"])(extent),
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_9__["getBottomLeft"])(extent)
      ]];
      var geometry = opt_geometry;
      if (geometry) {
        geometry.setCoordinates(boxCoordinates);
      } else {
        geometry = new _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_19__["default"](boxCoordinates);
      }
      return geometry;
    }
  );
}


/**
 * Get the drawing mode.  The mode for mult-part geometries is the same as for
 * their single-part cousins.
 * @param {GeometryType} type Geometry type.
 * @return {Mode} Drawing mode.
 */
function getMode(type) {
  var mode;
  if (type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].POINT ||
      type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].MULTI_POINT) {
    mode = Mode.POINT;
  } else if (type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].LINE_STRING ||
      type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].MULTI_LINE_STRING) {
    mode = Mode.LINE_STRING;
  } else if (type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].POLYGON ||
      type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].MULTI_POLYGON) {
    mode = Mode.POLYGON;
  } else if (type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].CIRCLE) {
    mode = Mode.CIRCLE;
  }
  return (
    /** @type {!Mode} */ (mode)
  );
}


/* harmony default export */ __webpack_exports__["default"] = (Draw);

//# sourceMappingURL=Draw.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/Extent.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/interaction/Extent.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Feature.js */ "./node_modules/ol/Feature.js");
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../MapBrowserEventType.js */ "./node_modules/ol/MapBrowserEventType.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../coordinate.js */ "./node_modules/ol/coordinate.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _geom_Point_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geom/Point.js */ "./node_modules/ol/geom/Point.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../geom/Polygon.js */ "./node_modules/ol/geom/Polygon.js");
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/* harmony import */ var _layer_Vector_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../layer/Vector.js */ "./node_modules/ol/layer/Vector.js");
/* harmony import */ var _source_Vector_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../source/Vector.js */ "./node_modules/ol/source/Vector.js");
/* harmony import */ var _style_Style_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../style/Style.js */ "./node_modules/ol/style/Style.js");
/**
 * @module ol/interaction/Extent
 */














/**
 * @typedef {Object} Options
 * @property {import("../extent.js").Extent} [extent] Initial extent. Defaults to no
 * initial extent.
 * @property {import("../style/Style.js").StyleLike} [boxStyle]
 * Style for the drawn extent box. Defaults to
 * {@link module:ol/style/Style~createEditing()['Polygon']}
 * @property {number} [pixelTolerance=10] Pixel tolerance for considering the
 * pointer close enough to a segment or vertex for editing.
 * @property {import("../style/Style.js").StyleLike} [pointerStyle]
 * Style for the cursor used to draw the extent. Defaults to
 * {@link module:ol/style/Style~createEditing()['Point']}
 * @property {boolean} [wrapX=false] Wrap the drawn extent across multiple maps
 * in the X direction? Only affects visuals, not functionality.
 */


/**
 * @enum {string}
 */
var ExtentEventType = {
  /**
   * Triggered after the extent is changed
   * @event ExtentEventType#extentchanged
   * @api
   */
  EXTENTCHANGED: 'extentchanged'
};


/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Extent~ExtentInteraction} instances are
 * instances of this type.
 */
var ExtentInteractionEvent = /*@__PURE__*/(function (Event) {
  function ExtentInteractionEvent(extent) {
    Event.call(this, ExtentEventType.EXTENTCHANGED);

    /**
     * The current extent.
     * @type {import("../extent.js").Extent}
     * @api
     */
    this.extent = extent;
  }

  if ( Event ) ExtentInteractionEvent.__proto__ = Event;
  ExtentInteractionEvent.prototype = Object.create( Event && Event.prototype );
  ExtentInteractionEvent.prototype.constructor = ExtentInteractionEvent;

  return ExtentInteractionEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_3__["default"]));


/**
 * @classdesc
 * Allows the user to draw a vector box by clicking and dragging on the map.
 * Once drawn, the vector box can be modified by dragging its vertices or edges.
 * This interaction is only supported for mouse devices.
 *
 * @fires Event
 * @api
 */
var ExtentInteraction = /*@__PURE__*/(function (PointerInteraction) {
  function ExtentInteraction(opt_options) {

    var options = opt_options || {};

    PointerInteraction.call(/** @type {import("./Pointer.js").Options} */ this, (options));

    /**
     * Extent of the drawn box
     * @type {import("../extent.js").Extent}
     * @private
     */
    this.extent_ = null;

    /**
     * Handler for pointer move events
     * @type {function (import("../coordinate.js").Coordinate): import("../extent.js").Extent|null}
     * @private
     */
    this.pointerHandler_ = null;

    /**
     * Pixel threshold to snap to extent
     * @type {number}
     * @private
     */
    this.pixelTolerance_ = options.pixelTolerance !== undefined ?
      options.pixelTolerance : 10;

    /**
     * Is the pointer snapped to an extent vertex
     * @type {boolean}
     * @private
     */
    this.snappedToVertex_ = false;

    /**
     * Feature for displaying the visible extent
     * @type {Feature}
     * @private
     */
    this.extentFeature_ = null;

    /**
     * Feature for displaying the visible pointer
     * @type {Feature}
     * @private
     */
    this.vertexFeature_ = null;

    if (!opt_options) {
      opt_options = {};
    }

    /**
     * Layer for the extentFeature
     * @type {VectorLayer}
     * @private
     */
    this.extentOverlay_ = new _layer_Vector_js__WEBPACK_IMPORTED_MODULE_9__["default"]({
      source: new _source_Vector_js__WEBPACK_IMPORTED_MODULE_10__["default"]({
        useSpatialIndex: false,
        wrapX: !!opt_options.wrapX
      }),
      style: opt_options.boxStyle ? opt_options.boxStyle : getDefaultExtentStyleFunction(),
      updateWhileAnimating: true,
      updateWhileInteracting: true
    });

    /**
     * Layer for the vertexFeature
     * @type {VectorLayer}
     * @private
     */
    this.vertexOverlay_ = new _layer_Vector_js__WEBPACK_IMPORTED_MODULE_9__["default"]({
      source: new _source_Vector_js__WEBPACK_IMPORTED_MODULE_10__["default"]({
        useSpatialIndex: false,
        wrapX: !!opt_options.wrapX
      }),
      style: opt_options.pointerStyle ? opt_options.pointerStyle : getDefaultPointerStyleFunction(),
      updateWhileAnimating: true,
      updateWhileInteracting: true
    });

    if (opt_options.extent) {
      this.setExtent(opt_options.extent);
    }
  }

  if ( PointerInteraction ) ExtentInteraction.__proto__ = PointerInteraction;
  ExtentInteraction.prototype = Object.create( PointerInteraction && PointerInteraction.prototype );
  ExtentInteraction.prototype.constructor = ExtentInteraction;

  /**
   * @param {import("../pixel.js").Pixel} pixel cursor location
   * @param {import("../PluggableMap.js").default} map map
   * @returns {import("../coordinate.js").Coordinate|null} snapped vertex on extent
   * @private
   */
  ExtentInteraction.prototype.snapToVertex_ = function snapToVertex_ (pixel, map) {
    var pixelCoordinate = map.getCoordinateFromPixel(pixel);
    var sortByDistance = function(a, b) {
      return Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_2__["squaredDistanceToSegment"])(pixelCoordinate, a) -
          Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_2__["squaredDistanceToSegment"])(pixelCoordinate, b);
    };
    var extent = this.getExtent();
    if (extent) {
      //convert extents to line segments and find the segment closest to pixelCoordinate
      var segments = getSegments(extent);
      segments.sort(sortByDistance);
      var closestSegment = segments[0];

      var vertex = (Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_2__["closestOnSegment"])(pixelCoordinate,
        closestSegment));
      var vertexPixel = map.getPixelFromCoordinate(vertex);

      //if the distance is within tolerance, snap to the segment
      if (Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_2__["distance"])(pixel, vertexPixel) <= this.pixelTolerance_) {
        //test if we should further snap to a vertex
        var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
        var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
        var squaredDist1 = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_2__["squaredDistance"])(vertexPixel, pixel1);
        var squaredDist2 = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_2__["squaredDistance"])(vertexPixel, pixel2);
        var dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
        this.snappedToVertex_ = dist <= this.pixelTolerance_;
        if (this.snappedToVertex_) {
          vertex = squaredDist1 > squaredDist2 ?
            closestSegment[1] : closestSegment[0];
        }
        return vertex;
      }
    }
    return null;
  };

  /**
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent pointer move event
   * @private
   */
  ExtentInteraction.prototype.handlePointerMove_ = function handlePointerMove_ (mapBrowserEvent) {
    var pixel = mapBrowserEvent.pixel;
    var map = mapBrowserEvent.map;

    var vertex = this.snapToVertex_(pixel, map);
    if (!vertex) {
      vertex = map.getCoordinateFromPixel(pixel);
    }
    this.createOrUpdatePointerFeature_(vertex);
  };

  /**
   * @param {import("../extent.js").Extent} extent extent
   * @returns {Feature} extent as featrue
   * @private
   */
  ExtentInteraction.prototype.createOrUpdateExtentFeature_ = function createOrUpdateExtentFeature_ (extent) {
    var extentFeature = this.extentFeature_;

    if (!extentFeature) {
      if (!extent) {
        extentFeature = new _Feature_js__WEBPACK_IMPORTED_MODULE_0__["default"]({});
      } else {
        extentFeature = new _Feature_js__WEBPACK_IMPORTED_MODULE_0__["default"](Object(_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_7__["fromExtent"])(extent));
      }
      this.extentFeature_ = extentFeature;
      /** @type {VectorSource} */ (this.extentOverlay_.getSource()).addFeature(extentFeature);
    } else {
      if (!extent) {
        extentFeature.setGeometry(undefined);
      } else {
        extentFeature.setGeometry(Object(_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_7__["fromExtent"])(extent));
      }
    }
    return extentFeature;
  };

  /**
   * @param {import("../coordinate.js").Coordinate} vertex location of feature
   * @returns {Feature} vertex as feature
   * @private
   */
  ExtentInteraction.prototype.createOrUpdatePointerFeature_ = function createOrUpdatePointerFeature_ (vertex) {
    var vertexFeature = this.vertexFeature_;
    if (!vertexFeature) {
      vertexFeature = new _Feature_js__WEBPACK_IMPORTED_MODULE_0__["default"](new _geom_Point_js__WEBPACK_IMPORTED_MODULE_6__["default"](vertex));
      this.vertexFeature_ = vertexFeature;
      /** @type {VectorSource} */ (this.vertexOverlay_.getSource()).addFeature(vertexFeature);
    } else {
      var geometry = /** @type {Point} */ (vertexFeature.getGeometry());
      geometry.setCoordinates(vertex);
    }
    return vertexFeature;
  };

  /**
   * @inheritDoc
   */
  ExtentInteraction.prototype.handleEvent = function handleEvent (mapBrowserEvent) {
    if (!(/** @type {import("../MapBrowserPointerEvent.js").default} */ (mapBrowserEvent).pointerEvent)) {
      return true;
    }
    //display pointer (if not dragging)
    if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERMOVE && !this.handlingDownUpSequence) {
      this.handlePointerMove_(mapBrowserEvent);
    }
    //call pointer to determine up/down/drag
    PointerInteraction.prototype.handleEvent.call(this, mapBrowserEvent);
    //return false to stop propagation
    return false;
  };

  /**
   * @inheritDoc
   */
  ExtentInteraction.prototype.handleDownEvent = function handleDownEvent (mapBrowserEvent) {
    var pixel = mapBrowserEvent.pixel;
    var map = mapBrowserEvent.map;

    var extent = this.getExtent();
    var vertex = this.snapToVertex_(pixel, map);

    //find the extent corner opposite the passed corner
    var getOpposingPoint = function(point) {
      var x_ = null;
      var y_ = null;
      if (point[0] == extent[0]) {
        x_ = extent[2];
      } else if (point[0] == extent[2]) {
        x_ = extent[0];
      }
      if (point[1] == extent[1]) {
        y_ = extent[3];
      } else if (point[1] == extent[3]) {
        y_ = extent[1];
      }
      if (x_ !== null && y_ !== null) {
        return [x_, y_];
      }
      return null;
    };
    if (vertex && extent) {
      var x = (vertex[0] == extent[0] || vertex[0] == extent[2]) ? vertex[0] : null;
      var y = (vertex[1] == extent[1] || vertex[1] == extent[3]) ? vertex[1] : null;

      //snap to point
      if (x !== null && y !== null) {
        this.pointerHandler_ = getPointHandler(getOpposingPoint(vertex));
      //snap to edge
      } else if (x !== null) {
        this.pointerHandler_ = getEdgeHandler(
          getOpposingPoint([x, extent[1]]),
          getOpposingPoint([x, extent[3]])
        );
      } else if (y !== null) {
        this.pointerHandler_ = getEdgeHandler(
          getOpposingPoint([extent[0], y]),
          getOpposingPoint([extent[2], y])
        );
      }
    //no snap - new bbox
    } else {
      vertex = map.getCoordinateFromPixel(pixel);
      this.setExtent([vertex[0], vertex[1], vertex[0], vertex[1]]);
      this.pointerHandler_ = getPointHandler(vertex);
    }
    return true; //event handled; start downup sequence
  };

  /**
   * @inheritDoc
   */
  ExtentInteraction.prototype.handleDragEvent = function handleDragEvent (mapBrowserEvent) {
    if (this.pointerHandler_) {
      var pixelCoordinate = mapBrowserEvent.coordinate;
      this.setExtent(this.pointerHandler_(pixelCoordinate));
      this.createOrUpdatePointerFeature_(pixelCoordinate);
    }
    return true;
  };

  /**
   * @inheritDoc
   */
  ExtentInteraction.prototype.handleUpEvent = function handleUpEvent (mapBrowserEvent) {
    this.pointerHandler_ = null;
    //If bbox is zero area, set to null;
    var extent = this.getExtent();
    if (!extent || Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["getArea"])(extent) === 0) {
      this.setExtent(null);
    }
    return false; //Stop handling downup sequence
  };

  /**
   * @inheritDoc
   */
  ExtentInteraction.prototype.setMap = function setMap (map) {
    this.extentOverlay_.setMap(map);
    this.vertexOverlay_.setMap(map);
    PointerInteraction.prototype.setMap.call(this, map);
  };

  /**
   * Returns the current drawn extent in the view projection
   *
   * @return {import("../extent.js").Extent} Drawn extent in the view projection.
   * @api
   */
  ExtentInteraction.prototype.getExtent = function getExtent () {
    return this.extent_;
  };

  /**
   * Manually sets the drawn extent, using the view projection.
   *
   * @param {import("../extent.js").Extent} extent Extent
   * @api
   */
  ExtentInteraction.prototype.setExtent = function setExtent (extent) {
    //Null extent means no bbox
    this.extent_ = extent ? extent : null;
    this.createOrUpdateExtentFeature_(extent);
    this.dispatchEvent(new ExtentInteractionEvent(this.extent_));
  };

  return ExtentInteraction;
}(_Pointer_js__WEBPACK_IMPORTED_MODULE_8__["default"]));

/**
 * Returns the default style for the drawn bbox
 *
 * @return {import("../style/Style.js").StyleFunction} Default Extent style
 */
function getDefaultExtentStyleFunction() {
  var style = Object(_style_Style_js__WEBPACK_IMPORTED_MODULE_11__["createEditingStyle"])();
  return function(feature, resolution) {
    return style[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POLYGON];
  };
}

/**
 * Returns the default style for the pointer
 *
 * @return {import("../style/Style.js").StyleFunction} Default pointer style
 */
function getDefaultPointerStyleFunction() {
  var style = Object(_style_Style_js__WEBPACK_IMPORTED_MODULE_11__["createEditingStyle"])();
  return function(feature, resolution) {
    return style[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POINT];
  };
}

/**
 * @param {import("../coordinate.js").Coordinate} fixedPoint corner that will be unchanged in the new extent
 * @returns {function (import("../coordinate.js").Coordinate): import("../extent.js").Extent} event handler
 */
function getPointHandler(fixedPoint) {
  return function(point) {
    return Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["boundingExtent"])([fixedPoint, point]);
  };
}

/**
 * @param {import("../coordinate.js").Coordinate} fixedP1 first corner that will be unchanged in the new extent
 * @param {import("../coordinate.js").Coordinate} fixedP2 second corner that will be unchanged in the new extent
 * @returns {function (import("../coordinate.js").Coordinate): import("../extent.js").Extent|null} event handler
 */
function getEdgeHandler(fixedP1, fixedP2) {
  if (fixedP1[0] == fixedP2[0]) {
    return function(point) {
      return Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["boundingExtent"])([fixedP1, [point[0], fixedP2[1]]]);
    };
  } else if (fixedP1[1] == fixedP2[1]) {
    return function(point) {
      return Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["boundingExtent"])([fixedP1, [fixedP2[0], point[1]]]);
    };
  } else {
    return null;
  }
}

/**
 * @param {import("../extent.js").Extent} extent extent
 * @returns {Array<Array<import("../coordinate.js").Coordinate>>} extent line segments
 */
function getSegments(extent) {
  return [
    [[extent[0], extent[1]], [extent[0], extent[3]]],
    [[extent[0], extent[3]], [extent[2], extent[3]]],
    [[extent[2], extent[3]], [extent[2], extent[1]]],
    [[extent[2], extent[1]], [extent[0], extent[1]]]
  ];
}


/* harmony default export */ __webpack_exports__["default"] = (ExtentInteraction);

//# sourceMappingURL=Extent.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/Interaction.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/interaction/Interaction.js ***!
  \****************************************************/
/*! exports provided: pan, rotate, rotateWithoutConstraints, zoom, zoomByDelta, zoomWithoutConstraints, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pan", function() { return pan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateWithoutConstraints", function() { return rotateWithoutConstraints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zoom", function() { return zoom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zoomByDelta", function() { return zoomByDelta; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zoomWithoutConstraints", function() { return zoomWithoutConstraints; });
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../easing.js */ "./node_modules/ol/easing.js");
/* harmony import */ var _Property_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Property.js */ "./node_modules/ol/interaction/Property.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/interaction/Interaction
 */






/**
 * Object literal with config options for interactions.
 * @typedef {Object} InteractionOptions
 * @property {function(import("../MapBrowserEvent.js").default):boolean} handleEvent
 * Method called by the map to notify the interaction that a browser event was
 * dispatched to the map. If the function returns a falsy value, propagation of
 * the event to other interactions in the map's interactions chain will be
 * prevented (this includes functions with no explicit return).
 */


/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * User actions that change the state of the map. Some are similar to controls,
 * but are not associated with a DOM element.
 * For example, {@link module:ol/interaction/KeyboardZoom~KeyboardZoom} is
 * functionally the same as {@link module:ol/control/Zoom~Zoom}, but triggered
 * by a keyboard event not a button element event.
 * Although interactions do not have a DOM element, some of them do render
 * vectors and so are visible on the screen.
 * @api
 */
var Interaction = /*@__PURE__*/(function (BaseObject) {
  function Interaction(options) {
    BaseObject.call(this);

    if (options.handleEvent) {
      this.handleEvent = options.handleEvent;
    }

    /**
     * @private
     * @type {import("../PluggableMap.js").default}
     */
    this.map_ = null;

    this.setActive(true);
  }

  if ( BaseObject ) Interaction.__proto__ = BaseObject;
  Interaction.prototype = Object.create( BaseObject && BaseObject.prototype );
  Interaction.prototype.constructor = Interaction;

  /**
   * Return whether the interaction is currently active.
   * @return {boolean} `true` if the interaction is active, `false` otherwise.
   * @observable
   * @api
   */
  Interaction.prototype.getActive = function getActive () {
    return /** @type {boolean} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].ACTIVE));
  };

  /**
   * Get the map associated with this interaction.
   * @return {import("../PluggableMap.js").default} Map.
   * @api
   */
  Interaction.prototype.getMap = function getMap () {
    return this.map_;
  };

  /**
   * Handles the {@link module:ol/MapBrowserEvent map browser event}.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  Interaction.prototype.handleEvent = function handleEvent (mapBrowserEvent) {
    return true;
  };

  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */
  Interaction.prototype.setActive = function setActive (active) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].ACTIVE, active);
  };

  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../PluggableMap.js").default} map Map.
   */
  Interaction.prototype.setMap = function setMap (map) {
    this.map_ = map;
  };

  return Interaction;
}(_Object_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/**
 * @param {import("../View.js").default} view View.
 * @param {import("../coordinate.js").Coordinate} delta Delta.
 * @param {number=} opt_duration Duration.
 */
function pan(view, delta, opt_duration) {
  var currentCenter = view.getCenter();
  if (currentCenter) {
    var center = view.constrainCenter(
      [currentCenter[0] + delta[0], currentCenter[1] + delta[1]]);
    if (opt_duration) {
      view.animate({
        duration: opt_duration,
        easing: _easing_js__WEBPACK_IMPORTED_MODULE_1__["linear"],
        center: center
      });
    } else {
      view.setCenter(center);
    }
  }
}


/**
 * @param {import("../View.js").default} view View.
 * @param {number|undefined} rotation Rotation.
 * @param {import("../coordinate.js").Coordinate=} opt_anchor Anchor coordinate.
 * @param {number=} opt_duration Duration.
 */
function rotate(view, rotation, opt_anchor, opt_duration) {
  rotation = view.constrainRotation(rotation, 0);
  rotateWithoutConstraints(view, rotation, opt_anchor, opt_duration);
}


/**
 * @param {import("../View.js").default} view View.
 * @param {number|undefined} rotation Rotation.
 * @param {import("../coordinate.js").Coordinate=} opt_anchor Anchor coordinate.
 * @param {number=} opt_duration Duration.
 */
function rotateWithoutConstraints(view, rotation, opt_anchor, opt_duration) {
  if (rotation !== undefined) {
    var currentRotation = view.getRotation();
    var currentCenter = view.getCenter();
    if (currentRotation !== undefined && currentCenter && opt_duration > 0) {
      view.animate({
        rotation: rotation,
        anchor: opt_anchor,
        duration: opt_duration,
        easing: _easing_js__WEBPACK_IMPORTED_MODULE_1__["easeOut"]
      });
    } else {
      view.rotate(rotation, opt_anchor);
    }
  }
}


/**
 * @param {import("../View.js").default} view View.
 * @param {number|undefined} resolution Resolution to go to.
 * @param {import("../coordinate.js").Coordinate=} opt_anchor Anchor coordinate.
 * @param {number=} opt_duration Duration.
 * @param {number=} opt_direction Zooming direction; > 0 indicates
 *     zooming out, in which case the constraints system will select
 *     the largest nearest resolution; < 0 indicates zooming in, in
 *     which case the constraints system will select the smallest
 *     nearest resolution; == 0 indicates that the zooming direction
 *     is unknown/not relevant, in which case the constraints system
 *     will select the nearest resolution. If not defined 0 is
 *     assumed.
 */
function zoom(view, resolution, opt_anchor, opt_duration, opt_direction) {
  resolution = view.constrainResolution(resolution, 0, opt_direction);
  zoomWithoutConstraints(view, resolution, opt_anchor, opt_duration);
}


/**
 * @param {import("../View.js").default} view View.
 * @param {number} delta Delta from previous zoom level.
 * @param {import("../coordinate.js").Coordinate=} opt_anchor Anchor coordinate.
 * @param {number=} opt_duration Duration.
 */
function zoomByDelta(view, delta, opt_anchor, opt_duration) {
  var currentResolution = view.getResolution();
  var resolution = view.constrainResolution(currentResolution, delta, 0);

  if (resolution !== undefined) {
    var resolutions = view.getResolutions();
    resolution = Object(_math_js__WEBPACK_IMPORTED_MODULE_3__["clamp"])(
      resolution,
      view.getMinResolution() || resolutions[resolutions.length - 1],
      view.getMaxResolution() || resolutions[0]);
  }

  // If we have a constraint on center, we need to change the anchor so that the
  // new center is within the extent. We first calculate the new center, apply
  // the constraint to it, and then calculate back the anchor
  if (opt_anchor && resolution !== undefined && resolution !== currentResolution) {
    var currentCenter = view.getCenter();
    var center = view.calculateCenterZoom(resolution, opt_anchor);
    center = view.constrainCenter(center);

    opt_anchor = [
      (resolution * currentCenter[0] - currentResolution * center[0]) /
          (resolution - currentResolution),
      (resolution * currentCenter[1] - currentResolution * center[1]) /
          (resolution - currentResolution)
    ];
  }

  zoomWithoutConstraints(view, resolution, opt_anchor, opt_duration);
}


/**
 * @param {import("../View.js").default} view View.
 * @param {number|undefined} resolution Resolution to go to.
 * @param {import("../coordinate.js").Coordinate=} opt_anchor Anchor coordinate.
 * @param {number=} opt_duration Duration.
 */
function zoomWithoutConstraints(view, resolution, opt_anchor, opt_duration) {
  if (resolution) {
    var currentResolution = view.getResolution();
    var currentCenter = view.getCenter();
    if (currentResolution !== undefined && currentCenter &&
        resolution !== currentResolution && opt_duration) {
      view.animate({
        resolution: resolution,
        anchor: opt_anchor,
        duration: opt_duration,
        easing: _easing_js__WEBPACK_IMPORTED_MODULE_1__["easeOut"]
      });
    } else {
      if (opt_anchor) {
        var center = view.calculateCenterZoom(resolution, opt_anchor);
        view.setCenter(center);
      }
      view.setResolution(resolution);
    }
  }
}

/* harmony default export */ __webpack_exports__["default"] = (Interaction);

//# sourceMappingURL=Interaction.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/KeyboardPan.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/interaction/KeyboardPan.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../coordinate.js */ "./node_modules/ol/coordinate.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _events_KeyCode_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/KeyCode.js */ "./node_modules/ol/events/KeyCode.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/**
 * @module ol/interaction/KeyboardPan
 */







/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. Default is
 * {@link module:ol/events/condition~noModifierKeys} and
 * {@link module:ol/events/condition~targetNotEditable}.
 * @property {number} [duration=100] Animation duration in milliseconds.
 * @property {number} [pixelDelta=128] The amount of pixels to pan on each key
 * press.
 */


/**
 * @classdesc
 * Allows the user to pan the map using keyboard arrows.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {@link module:ol/Map~Map}. `document` never loses focus but, for any other
 * element, focus will have to be on, and returned to, this element if the keys
 * are to function.
 * See also {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}.
 * @api
 */
var KeyboardPan = /*@__PURE__*/(function (Interaction) {
  function KeyboardPan(opt_options) {

    Interaction.call(this, {
      handleEvent: handleEvent
    });

    var options = opt_options || {};

    /**
     * @private
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Browser event.
     * @return {boolean} Combined condition result.
     */
    this.defaultCondition_ = function(mapBrowserEvent) {
      return Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_3__["noModifierKeys"])(mapBrowserEvent) &&
        Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_3__["targetNotEditable"])(mapBrowserEvent);
    };

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.condition_ = options.condition !== undefined ?
      options.condition : this.defaultCondition_;

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 100;

    /**
     * @private
     * @type {number}
     */
    this.pixelDelta_ = options.pixelDelta !== undefined ?
      options.pixelDelta : 128;

  }

  if ( Interaction ) KeyboardPan.__proto__ = Interaction;
  KeyboardPan.prototype = Object.create( Interaction && Interaction.prototype );
  KeyboardPan.prototype.constructor = KeyboardPan;

  return KeyboardPan;
}(_Interaction_js__WEBPACK_IMPORTED_MODULE_4__["default"]));


/**
 * Handles the {@link module:ol/MapBrowserEvent map browser event} if it was a
 * `KeyEvent`, and decides the direction to pan to (if an arrow key was
 * pressed).
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} `false` to stop event propagation.
 * @this {KeyboardPan}
 */
function handleEvent(mapBrowserEvent) {
  var stopEvent = false;
  if (mapBrowserEvent.type == _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].KEYDOWN) {
    var keyEvent = /** @type {KeyboardEvent} */ (mapBrowserEvent.originalEvent);
    var keyCode = keyEvent.keyCode;
    if (this.condition_(mapBrowserEvent) &&
        (keyCode == _events_KeyCode_js__WEBPACK_IMPORTED_MODULE_2__["default"].DOWN ||
        keyCode == _events_KeyCode_js__WEBPACK_IMPORTED_MODULE_2__["default"].LEFT ||
        keyCode == _events_KeyCode_js__WEBPACK_IMPORTED_MODULE_2__["default"].RIGHT ||
        keyCode == _events_KeyCode_js__WEBPACK_IMPORTED_MODULE_2__["default"].UP)) {
      var map = mapBrowserEvent.map;
      var view = map.getView();
      var mapUnitsDelta = view.getResolution() * this.pixelDelta_;
      var deltaX = 0, deltaY = 0;
      if (keyCode == _events_KeyCode_js__WEBPACK_IMPORTED_MODULE_2__["default"].DOWN) {
        deltaY = -mapUnitsDelta;
      } else if (keyCode == _events_KeyCode_js__WEBPACK_IMPORTED_MODULE_2__["default"].LEFT) {
        deltaX = -mapUnitsDelta;
      } else if (keyCode == _events_KeyCode_js__WEBPACK_IMPORTED_MODULE_2__["default"].RIGHT) {
        deltaX = mapUnitsDelta;
      } else {
        deltaY = mapUnitsDelta;
      }
      var delta = [deltaX, deltaY];
      Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_0__["rotate"])(delta, view.getRotation());
      Object(_Interaction_js__WEBPACK_IMPORTED_MODULE_4__["pan"])(view, delta, this.duration_);
      mapBrowserEvent.preventDefault();
      stopEvent = true;
    }
  }
  return !stopEvent;
}

/* harmony default export */ __webpack_exports__["default"] = (KeyboardPan);

//# sourceMappingURL=KeyboardPan.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/KeyboardZoom.js":
/*!*****************************************************!*\
  !*** ./node_modules/ol/interaction/KeyboardZoom.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/**
 * @module ol/interaction/KeyboardZoom
 */





/**
 * @typedef {Object} Options
 * @property {number} [duration=100] Animation duration in milliseconds.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. Default is
 * {@link module:ol/events/condition~targetNotEditable}.
 * @property {number} [delta=1] The zoom level delta on each key press.
 */


/**
 * @classdesc
 * Allows the user to zoom the map using keyboard + and -.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {@link module:ol/Map~Map}. `document` never loses focus but, for any other
 * element, focus will have to be on, and returned to, this element if the keys
 * are to function.
 * See also {@link module:ol/interaction/KeyboardPan~KeyboardPan}.
 * @api
 */
var KeyboardZoom = /*@__PURE__*/(function (Interaction) {
  function KeyboardZoom(opt_options) {

    Interaction.call(this, {
      handleEvent: handleEvent
    });

    var options = opt_options ? opt_options : {};

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_1__["targetNotEditable"];

    /**
     * @private
     * @type {number}
     */
    this.delta_ = options.delta ? options.delta : 1;

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 100;

  }

  if ( Interaction ) KeyboardZoom.__proto__ = Interaction;
  KeyboardZoom.prototype = Object.create( Interaction && Interaction.prototype );
  KeyboardZoom.prototype.constructor = KeyboardZoom;

  return KeyboardZoom;
}(_Interaction_js__WEBPACK_IMPORTED_MODULE_2__["default"]));


/**
 * Handles the {@link module:ol/MapBrowserEvent map browser event} if it was a
 * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
 * key pressed was '+' or '-').
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} `false` to stop event propagation.
 * @this {KeyboardZoom}
 */
function handleEvent(mapBrowserEvent) {
  var stopEvent = false;
  if (mapBrowserEvent.type == _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].KEYDOWN ||
      mapBrowserEvent.type == _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].KEYPRESS) {
    var keyEvent = /** @type {KeyboardEvent} */ (mapBrowserEvent.originalEvent);
    var charCode = keyEvent.charCode;
    if (this.condition_(mapBrowserEvent) &&
        (charCode == '+'.charCodeAt(0) || charCode == '-'.charCodeAt(0))) {
      var map = mapBrowserEvent.map;
      var delta = (charCode == '+'.charCodeAt(0)) ? this.delta_ : -this.delta_;
      var view = map.getView();
      Object(_Interaction_js__WEBPACK_IMPORTED_MODULE_2__["zoomByDelta"])(view, delta, undefined, this.duration_);
      mapBrowserEvent.preventDefault();
      stopEvent = true;
    }
  }
  return !stopEvent;
}

/* harmony default export */ __webpack_exports__["default"] = (KeyboardZoom);

//# sourceMappingURL=KeyboardZoom.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/Modify.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/interaction/Modify.js ***!
  \***********************************************/
/*! exports provided: ModifyEvent, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ModifyEvent", function() { return ModifyEvent; });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Collection.js */ "./node_modules/ol/Collection.js");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../CollectionEventType.js */ "./node_modules/ol/CollectionEventType.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Feature.js */ "./node_modules/ol/Feature.js");
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../MapBrowserEventType.js */ "./node_modules/ol/MapBrowserEventType.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../coordinate.js */ "./node_modules/ol/coordinate.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _geom_Point_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../geom/Point.js */ "./node_modules/ol/geom/Point.js");
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/* harmony import */ var _layer_Vector_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../layer/Vector.js */ "./node_modules/ol/layer/Vector.js");
/* harmony import */ var _source_Vector_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../source/Vector.js */ "./node_modules/ol/source/Vector.js");
/* harmony import */ var _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../source/VectorEventType.js */ "./node_modules/ol/source/VectorEventType.js");
/* harmony import */ var _structs_RBush_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../structs/RBush.js */ "./node_modules/ol/structs/RBush.js");
/* harmony import */ var _style_Style_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../style/Style.js */ "./node_modules/ol/style/Style.js");
/**
 * @module ol/interaction/Modify
 */






















/**
 * The segment index assigned to a circle's center when
 * breaking up a circle into ModifySegmentDataType segments.
 * @type {number}
 */
var CIRCLE_CENTER_INDEX = 0;

/**
 * The segment index assigned to a circle's circumference when
 * breaking up a circle into ModifySegmentDataType segments.
 * @type {number}
 */
var CIRCLE_CIRCUMFERENCE_INDEX = 1;


/**
 * @enum {string}
 */
var ModifyEventType = {
  /**
   * Triggered upon feature modification start
   * @event ModifyEvent#modifystart
   * @api
   */
  MODIFYSTART: 'modifystart',
  /**
   * Triggered upon feature modification end
   * @event ModifyEvent#modifyend
   * @api
   */
  MODIFYEND: 'modifyend'
};


/**
 * @typedef {Object} SegmentData
 * @property {Array<number>} [depth]
 * @property {Feature} feature
 * @property {import("../geom/SimpleGeometry.js").default} geometry
 * @property {number} [index]
 * @property {Array<import("../extent.js").Extent>} segment
 * @property {Array<SegmentData>} [featureSegments]
 */


/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event will be considered to add or move a
 * vertex to the sketch. Default is
 * {@link module:ol/events/condition~primaryAction}.
 * @property {import("../events/condition.js").Condition} [deleteCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. By default,
 * {@link module:ol/events/condition~singleClick} with
 * {@link module:ol/events/condition~altKeyOnly} results in a vertex deletion.
 * @property {import("../events/condition.js").Condition} [insertVertexCondition] A
 * function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and
 * returns a boolean to indicate whether a new vertex can be added to the sketch
 * features. Default is {@link module:ol/events/condition~always}.
 * @property {number} [pixelTolerance=10] Pixel tolerance for considering the
 * pointer close enough to a segment or vertex for editing.
 * @property {import("../style/Style.js").StyleLike} [style]
 * Style used for the features being modified. By default the default edit
 * style is used (see {@link module:ol/style}).
 * @property {VectorSource} [source] The vector source with
 * features to modify.  If a vector source is not provided, a feature collection
 * must be provided with the features option.
 * @property {Collection<Feature>} [features]
 * The features the interaction works on.  If a feature collection is not
 * provided, a vector source must be provided with the source option.
 * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch
 * overlay.
 */


/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Modify~Modify} instances are
 * instances of this type.
 */
var ModifyEvent = /*@__PURE__*/(function (Event) {
  function ModifyEvent(type, features, mapBrowserPointerEvent) {
    Event.call(this, type);

    /**
     * The features being modified.
     * @type {Collection<Feature>}
     * @api
     */
    this.features = features;

    /**
     * Associated {@link module:ol/MapBrowserEvent}.
     * @type {import("../MapBrowserEvent.js").default}
     * @api
     */
    this.mapBrowserEvent = mapBrowserPointerEvent;

  }

  if ( Event ) ModifyEvent.__proto__ = Event;
  ModifyEvent.prototype = Object.create( Event && Event.prototype );
  ModifyEvent.prototype.constructor = ModifyEvent;

  return ModifyEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_8__["default"]));


/**
 * @classdesc
 * Interaction for modifying feature geometries.  To modify features that have
 * been added to an existing source, construct the modify interaction with the
 * `source` option.  If you want to modify features in a collection (for example,
 * the collection used by a select interaction), construct the interaction with
 * the `features` option.  The interaction must be constructed with either a
 * `source` or `features` option.
 *
 * By default, the interaction will allow deletion of vertices when the `alt`
 * key is pressed.  To configure the interaction with a different condition
 * for deletion, use the `deleteCondition` option.
 * @fires ModifyEvent
 * @api
 */
var Modify = /*@__PURE__*/(function (PointerInteraction) {
  function Modify(options) {

    PointerInteraction.call(/** @type {import("./Pointer.js").Options} */ this, (options));

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_10__["primaryAction"];

    /**
     * @private
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Browser event.
     * @return {boolean} Combined condition result.
     */
    this.defaultDeleteCondition_ = function(mapBrowserEvent) {
      return Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_10__["altKeyOnly"])(mapBrowserEvent) && Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_10__["singleClick"])(mapBrowserEvent);
    };

    /**
     * @type {import("../events/condition.js").Condition}
     * @private
     */
    this.deleteCondition_ = options.deleteCondition ?
      options.deleteCondition : this.defaultDeleteCondition_;

    /**
     * @type {import("../events/condition.js").Condition}
     * @private
     */
    this.insertVertexCondition_ = options.insertVertexCondition ?
      options.insertVertexCondition : _events_condition_js__WEBPACK_IMPORTED_MODULE_10__["always"];

    /**
     * Editing vertex.
     * @type {Feature}
     * @private
     */
    this.vertexFeature_ = null;

    /**
     * Segments intersecting {@link this.vertexFeature_} by segment uid.
     * @type {Object<string, boolean>}
     * @private
     */
    this.vertexSegments_ = null;

    /**
     * @type {import("../pixel.js").Pixel}
     * @private
     */
    this.lastPixel_ = [0, 0];

    /**
     * Tracks if the next `singleclick` event should be ignored to prevent
     * accidental deletion right after vertex creation.
     * @type {boolean}
     * @private
     */
    this.ignoreNextSingleClick_ = false;

    /**
     * @type {boolean}
     * @private
     */
    this.modified_ = false;

    /**
     * Segment RTree for each layer
     * @type {RBush<SegmentData>}
     * @private
     */
    this.rBush_ = new _structs_RBush_js__WEBPACK_IMPORTED_MODULE_18__["default"]();

    /**
     * @type {number}
     * @private
     */
    this.pixelTolerance_ = options.pixelTolerance !== undefined ?
      options.pixelTolerance : 10;

    /**
     * @type {boolean}
     * @private
     */
    this.snappedToVertex_ = false;

    /**
     * Indicate whether the interaction is currently changing a feature's
     * coordinates.
     * @type {boolean}
     * @private
     */
    this.changingFeature_ = false;

    /**
     * @type {Array}
     * @private
     */
    this.dragSegments_ = [];

    /**
     * Draw overlay where sketch features are drawn.
     * @type {VectorLayer}
     * @private
     */
    this.overlay_ = new _layer_Vector_js__WEBPACK_IMPORTED_MODULE_15__["default"]({
      source: new _source_Vector_js__WEBPACK_IMPORTED_MODULE_16__["default"]({
        useSpatialIndex: false,
        wrapX: !!options.wrapX
      }),
      style: options.style ? options.style :
        getDefaultStyleFunction(),
      updateWhileAnimating: true,
      updateWhileInteracting: true
    });

    /**
     * @const
     * @private
     * @type {!Object<string, function(Feature, import("../geom/Geometry.js").default)>}
     */
    this.SEGMENT_WRITERS_ = {
      'Point': this.writePointGeometry_,
      'LineString': this.writeLineStringGeometry_,
      'LinearRing': this.writeLineStringGeometry_,
      'Polygon': this.writePolygonGeometry_,
      'MultiPoint': this.writeMultiPointGeometry_,
      'MultiLineString': this.writeMultiLineStringGeometry_,
      'MultiPolygon': this.writeMultiPolygonGeometry_,
      'Circle': this.writeCircleGeometry_,
      'GeometryCollection': this.writeGeometryCollectionGeometry_
    };


    /**
     * @type {VectorSource}
     * @private
     */
    this.source_ = null;

    var features;
    if (options.source) {
      this.source_ = options.source;
      features = new _Collection_js__WEBPACK_IMPORTED_MODULE_1__["default"](this.source_.getFeatures());
      Object(_events_js__WEBPACK_IMPORTED_MODULE_7__["listen"])(this.source_, _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_17__["default"].ADDFEATURE,
        this.handleSourceAdd_, this);
      Object(_events_js__WEBPACK_IMPORTED_MODULE_7__["listen"])(this.source_, _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_17__["default"].REMOVEFEATURE,
        this.handleSourceRemove_, this);
    } else {
      features = options.features;
    }
    if (!features) {
      throw new Error('The modify interaction requires features or a source');
    }

    /**
     * @type {Collection<Feature>}
     * @private
     */
    this.features_ = features;

    this.features_.forEach(this.addFeature_.bind(this));
    Object(_events_js__WEBPACK_IMPORTED_MODULE_7__["listen"])(this.features_, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].ADD,
      this.handleFeatureAdd_, this);
    Object(_events_js__WEBPACK_IMPORTED_MODULE_7__["listen"])(this.features_, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].REMOVE,
      this.handleFeatureRemove_, this);

    /**
     * @type {import("../MapBrowserPointerEvent.js").default}
     * @private
     */
    this.lastPointerEvent_ = null;

  }

  if ( PointerInteraction ) Modify.__proto__ = PointerInteraction;
  Modify.prototype = Object.create( PointerInteraction && PointerInteraction.prototype );
  Modify.prototype.constructor = Modify;

  /**
   * @param {Feature} feature Feature.
   * @private
   */
  Modify.prototype.addFeature_ = function addFeature_ (feature) {
    var geometry = feature.getGeometry();
    if (geometry && geometry.getType() in this.SEGMENT_WRITERS_) {
      this.SEGMENT_WRITERS_[geometry.getType()].call(this, feature, geometry);
    }
    var map = this.getMap();
    if (map && map.isRendered() && this.getActive()) {
      this.handlePointerAtPixel_(this.lastPixel_, map);
    }
    Object(_events_js__WEBPACK_IMPORTED_MODULE_7__["listen"])(feature, _events_EventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].CHANGE,
      this.handleFeatureChange_, this);
  };

  /**
   * @param {import("../MapBrowserPointerEvent.js").default} evt Map browser event
   * @private
   */
  Modify.prototype.willModifyFeatures_ = function willModifyFeatures_ (evt) {
    if (!this.modified_) {
      this.modified_ = true;
      this.dispatchEvent(new ModifyEvent(
        ModifyEventType.MODIFYSTART, this.features_, evt));
    }
  };

  /**
   * @param {Feature} feature Feature.
   * @private
   */
  Modify.prototype.removeFeature_ = function removeFeature_ (feature) {
    this.removeFeatureSegmentData_(feature);
    // Remove the vertex feature if the collection of canditate features
    // is empty.
    if (this.vertexFeature_ && this.features_.getLength() === 0) {
      /** @type {VectorSource} */ (this.overlay_.getSource()).removeFeature(this.vertexFeature_);
      this.vertexFeature_ = null;
    }
    Object(_events_js__WEBPACK_IMPORTED_MODULE_7__["unlisten"])(feature, _events_EventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].CHANGE,
      this.handleFeatureChange_, this);
  };

  /**
   * @param {Feature} feature Feature.
   * @private
   */
  Modify.prototype.removeFeatureSegmentData_ = function removeFeatureSegmentData_ (feature) {
    var rBush = this.rBush_;
    var /** @type {Array<SegmentData>} */ nodesToRemove = [];
    rBush.forEach(
      /**
       * @param {SegmentData} node RTree node.
       */
      function(node) {
        if (feature === node.feature) {
          nodesToRemove.push(node);
        }
      });
    for (var i = nodesToRemove.length - 1; i >= 0; --i) {
      rBush.remove(nodesToRemove[i]);
    }
  };

  /**
   * @inheritDoc
   */
  Modify.prototype.setActive = function setActive (active) {
    if (this.vertexFeature_ && !active) {
      /** @type {VectorSource} */ (this.overlay_.getSource()).removeFeature(this.vertexFeature_);
      this.vertexFeature_ = null;
    }
    PointerInteraction.prototype.setActive.call(this, active);
  };

  /**
   * @inheritDoc
   */
  Modify.prototype.setMap = function setMap (map) {
    this.overlay_.setMap(map);
    PointerInteraction.prototype.setMap.call(this, map);
  };

  /**
   * Get the overlay layer that this interaction renders sketch features to.
   * @return {VectorLayer} Overlay layer.
   * @api
   */
  Modify.prototype.getOverlay = function getOverlay () {
    return this.overlay_;
  };

  /**
   * @param {import("../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  Modify.prototype.handleSourceAdd_ = function handleSourceAdd_ (event) {
    if (event.feature) {
      this.features_.push(event.feature);
    }
  };

  /**
   * @param {import("../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  Modify.prototype.handleSourceRemove_ = function handleSourceRemove_ (event) {
    if (event.feature) {
      this.features_.remove(event.feature);
    }
  };

  /**
   * @param {import("../Collection.js").CollectionEvent} evt Event.
   * @private
   */
  Modify.prototype.handleFeatureAdd_ = function handleFeatureAdd_ (evt) {
    this.addFeature_(/** @type {Feature} */ (evt.element));
  };

  /**
   * @param {import("../events/Event.js").default} evt Event.
   * @private
   */
  Modify.prototype.handleFeatureChange_ = function handleFeatureChange_ (evt) {
    if (!this.changingFeature_) {
      var feature = /** @type {Feature} */ (evt.target);
      this.removeFeature_(feature);
      this.addFeature_(feature);
    }
  };

  /**
   * @param {import("../Collection.js").CollectionEvent} evt Event.
   * @private
   */
  Modify.prototype.handleFeatureRemove_ = function handleFeatureRemove_ (evt) {
    var feature = /** @type {Feature} */ (evt.element);
    this.removeFeature_(feature);
  };

  /**
   * @param {Feature} feature Feature
   * @param {Point} geometry Geometry.
   * @private
   */
  Modify.prototype.writePointGeometry_ = function writePointGeometry_ (feature, geometry) {
    var coordinates = geometry.getCoordinates();
    var segmentData = /** @type {SegmentData} */ ({
      feature: feature,
      geometry: geometry,
      segment: [coordinates, coordinates]
    });
    this.rBush_.insert(geometry.getExtent(), segmentData);
  };

  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiPoint.js").default} geometry Geometry.
   * @private
   */
  Modify.prototype.writeMultiPointGeometry_ = function writeMultiPointGeometry_ (feature, geometry) {
    var points = geometry.getCoordinates();
    for (var i = 0, ii = points.length; i < ii; ++i) {
      var coordinates = points[i];
      var segmentData = /** @type {SegmentData} */ ({
        feature: feature,
        geometry: geometry,
        depth: [i],
        index: i,
        segment: [coordinates, coordinates]
      });
      this.rBush_.insert(geometry.getExtent(), segmentData);
    }
  };

  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/LineString.js").default} geometry Geometry.
   * @private
   */
  Modify.prototype.writeLineStringGeometry_ = function writeLineStringGeometry_ (feature, geometry) {
    var coordinates = geometry.getCoordinates();
    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
      var segment = coordinates.slice(i, i + 2);
      var segmentData = /** @type {SegmentData} */ ({
        feature: feature,
        geometry: geometry,
        index: i,
        segment: segment
      });
      this.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_11__["boundingExtent"])(segment), segmentData);
    }
  };

  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiLineString.js").default} geometry Geometry.
   * @private
   */
  Modify.prototype.writeMultiLineStringGeometry_ = function writeMultiLineStringGeometry_ (feature, geometry) {
    var lines = geometry.getCoordinates();
    for (var j = 0, jj = lines.length; j < jj; ++j) {
      var coordinates = lines[j];
      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
        var segment = coordinates.slice(i, i + 2);
        var segmentData = /** @type {SegmentData} */ ({
          feature: feature,
          geometry: geometry,
          depth: [j],
          index: i,
          segment: segment
        });
        this.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_11__["boundingExtent"])(segment), segmentData);
      }
    }
  };

  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/Polygon.js").default} geometry Geometry.
   * @private
   */
  Modify.prototype.writePolygonGeometry_ = function writePolygonGeometry_ (feature, geometry) {
    var rings = geometry.getCoordinates();
    for (var j = 0, jj = rings.length; j < jj; ++j) {
      var coordinates = rings[j];
      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
        var segment = coordinates.slice(i, i + 2);
        var segmentData = /** @type {SegmentData} */ ({
          feature: feature,
          geometry: geometry,
          depth: [j],
          index: i,
          segment: segment
        });
        this.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_11__["boundingExtent"])(segment), segmentData);
      }
    }
  };

  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
   * @private
   */
  Modify.prototype.writeMultiPolygonGeometry_ = function writeMultiPolygonGeometry_ (feature, geometry) {
    var polygons = geometry.getCoordinates();
    for (var k = 0, kk = polygons.length; k < kk; ++k) {
      var rings = polygons[k];
      for (var j = 0, jj = rings.length; j < jj; ++j) {
        var coordinates = rings[j];
        for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
          var segment = coordinates.slice(i, i + 2);
          var segmentData = /** @type {SegmentData} */ ({
            feature: feature,
            geometry: geometry,
            depth: [j, k],
            index: i,
            segment: segment
          });
          this.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_11__["boundingExtent"])(segment), segmentData);
        }
      }
    }
  };

  /**
   * We convert a circle into two segments.  The segment at index
   * {@link CIRCLE_CENTER_INDEX} is the
   * circle's center (a point).  The segment at index
   * {@link CIRCLE_CIRCUMFERENCE_INDEX} is
   * the circumference, and is not a line segment.
   *
   * @param {Feature} feature Feature.
   * @param {import("../geom/Circle.js").default} geometry Geometry.
   * @private
   */
  Modify.prototype.writeCircleGeometry_ = function writeCircleGeometry_ (feature, geometry) {
    var coordinates = geometry.getCenter();
    var centerSegmentData = /** @type {SegmentData} */ ({
      feature: feature,
      geometry: geometry,
      index: CIRCLE_CENTER_INDEX,
      segment: [coordinates, coordinates]
    });
    var circumferenceSegmentData = /** @type {SegmentData} */ ({
      feature: feature,
      geometry: geometry,
      index: CIRCLE_CIRCUMFERENCE_INDEX,
      segment: [coordinates, coordinates]
    });
    var featureSegments = [centerSegmentData, circumferenceSegmentData];
    centerSegmentData.featureSegments = circumferenceSegmentData.featureSegments = featureSegments;
    this.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_11__["createOrUpdateFromCoordinate"])(coordinates), centerSegmentData);
    this.rBush_.insert(geometry.getExtent(), circumferenceSegmentData);
  };

  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
   * @private
   */
  Modify.prototype.writeGeometryCollectionGeometry_ = function writeGeometryCollectionGeometry_ (feature, geometry) {
    var geometries = geometry.getGeometriesArray();
    for (var i = 0; i < geometries.length; ++i) {
      this.SEGMENT_WRITERS_[geometries[i].getType()].call(this, feature, geometries[i]);
    }
  };

  /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @return {Feature} Vertex feature.
   * @private
   */
  Modify.prototype.createOrUpdateVertexFeature_ = function createOrUpdateVertexFeature_ (coordinates) {
    var vertexFeature = this.vertexFeature_;
    if (!vertexFeature) {
      vertexFeature = new _Feature_js__WEBPACK_IMPORTED_MODULE_3__["default"](new _geom_Point_js__WEBPACK_IMPORTED_MODULE_13__["default"](coordinates));
      this.vertexFeature_ = vertexFeature;
      /** @type {VectorSource} */ (this.overlay_.getSource()).addFeature(vertexFeature);
    } else {
      var geometry = /** @type {Point} */ (vertexFeature.getGeometry());
      geometry.setCoordinates(coordinates);
    }
    return vertexFeature;
  };

  /**
   * Handles the {@link module:ol/MapBrowserEvent map browser event} and may modify the geometry.
   * @override
   */
  Modify.prototype.handleEvent = function handleEvent (mapBrowserEvent) {
    if (!(/** @type {import("../MapBrowserPointerEvent.js").default} */ (mapBrowserEvent).pointerEvent)) {
      return true;
    }
    this.lastPointerEvent_ = mapBrowserEvent;

    var handled;
    if (!mapBrowserEvent.map.getView().getInteracting() &&
        mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].POINTERMOVE &&
        !this.handlingDownUpSequence) {
      this.handlePointerMove_(mapBrowserEvent);
    }
    if (this.vertexFeature_ && this.deleteCondition_(mapBrowserEvent)) {
      if (mapBrowserEvent.type != _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].SINGLECLICK || !this.ignoreNextSingleClick_) {
        handled = this.removePoint();
      } else {
        handled = true;
      }
    }

    if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].SINGLECLICK) {
      this.ignoreNextSingleClick_ = false;
    }

    return PointerInteraction.prototype.handleEvent.call(this, mapBrowserEvent) && !handled;
  };

  /**
   * @inheritDoc
   */
  Modify.prototype.handleDragEvent = function handleDragEvent (evt) {
    this.ignoreNextSingleClick_ = false;
    this.willModifyFeatures_(evt);

    var vertex = evt.coordinate;
    for (var i = 0, ii = this.dragSegments_.length; i < ii; ++i) {
      var dragSegment = this.dragSegments_[i];
      var segmentData = dragSegment[0];
      var depth = segmentData.depth;
      var geometry = segmentData.geometry;
      var coordinates = (void 0);
      var segment = segmentData.segment;
      var index = dragSegment[1];

      while (vertex.length < geometry.getStride()) {
        vertex.push(segment[index][vertex.length]);
      }

      switch (geometry.getType()) {
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].POINT:
          coordinates = vertex;
          segment[0] = segment[1] = vertex;
          break;
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].MULTI_POINT:
          coordinates = geometry.getCoordinates();
          coordinates[segmentData.index] = vertex;
          segment[0] = segment[1] = vertex;
          break;
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].LINE_STRING:
          coordinates = geometry.getCoordinates();
          coordinates[segmentData.index + index] = vertex;
          segment[index] = vertex;
          break;
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].MULTI_LINE_STRING:
          coordinates = geometry.getCoordinates();
          coordinates[depth[0]][segmentData.index + index] = vertex;
          segment[index] = vertex;
          break;
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].POLYGON:
          coordinates = geometry.getCoordinates();
          coordinates[depth[0]][segmentData.index + index] = vertex;
          segment[index] = vertex;
          break;
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].MULTI_POLYGON:
          coordinates = geometry.getCoordinates();
          coordinates[depth[1]][depth[0]][segmentData.index + index] = vertex;
          segment[index] = vertex;
          break;
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].CIRCLE:
          segment[0] = segment[1] = vertex;
          if (segmentData.index === CIRCLE_CENTER_INDEX) {
            this.changingFeature_ = true;
            geometry.setCenter(vertex);
            this.changingFeature_ = false;
          } else { // We're dragging the circle's circumference:
            this.changingFeature_ = true;
            geometry.setRadius(Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_6__["distance"])(geometry.getCenter(), vertex));
            this.changingFeature_ = false;
          }
          break;
        default:
          // pass
      }

      if (coordinates) {
        this.setGeometryCoordinates_(geometry, coordinates);
      }
    }
    this.createOrUpdateVertexFeature_(vertex);
  };

  /**
   * @inheritDoc
   */
  Modify.prototype.handleDownEvent = function handleDownEvent (evt) {
    if (!this.condition_(evt)) {
      return false;
    }
    this.handlePointerAtPixel_(evt.pixel, evt.map);
    var pixelCoordinate = evt.map.getCoordinateFromPixel(evt.pixel);
    this.dragSegments_.length = 0;
    this.modified_ = false;
    var vertexFeature = this.vertexFeature_;
    if (vertexFeature) {
      var insertVertices = [];
      var geometry = /** @type {Point} */ (vertexFeature.getGeometry());
      var vertex = geometry.getCoordinates();
      var vertexExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_11__["boundingExtent"])([vertex]);
      var segmentDataMatches = this.rBush_.getInExtent(vertexExtent);
      var componentSegments = {};
      segmentDataMatches.sort(compareIndexes);
      for (var i = 0, ii = segmentDataMatches.length; i < ii; ++i) {
        var segmentDataMatch = segmentDataMatches[i];
        var segment = segmentDataMatch.segment;
        var uid = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(segmentDataMatch.feature);
        var depth = segmentDataMatch.depth;
        if (depth) {
          uid += '-' + depth.join('-'); // separate feature components
        }
        if (!componentSegments[uid]) {
          componentSegments[uid] = new Array(2);
        }
        if (segmentDataMatch.geometry.getType() === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].CIRCLE &&
        segmentDataMatch.index === CIRCLE_CIRCUMFERENCE_INDEX) {

          var closestVertex = closestOnSegmentData(pixelCoordinate, segmentDataMatch);
          if (Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_6__["equals"])(closestVertex, vertex) && !componentSegments[uid][0]) {
            this.dragSegments_.push([segmentDataMatch, 0]);
            componentSegments[uid][0] = segmentDataMatch;
          }
        } else if (Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_6__["equals"])(segment[0], vertex) &&
            !componentSegments[uid][0]) {
          this.dragSegments_.push([segmentDataMatch, 0]);
          componentSegments[uid][0] = segmentDataMatch;
        } else if (Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_6__["equals"])(segment[1], vertex) &&
            !componentSegments[uid][1]) {

          // prevent dragging closed linestrings by the connecting node
          if ((segmentDataMatch.geometry.getType() ===
              _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].LINE_STRING ||
              segmentDataMatch.geometry.getType() ===
              _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].MULTI_LINE_STRING) &&
              componentSegments[uid][0] &&
              componentSegments[uid][0].index === 0) {
            continue;
          }

          this.dragSegments_.push([segmentDataMatch, 1]);
          componentSegments[uid][1] = segmentDataMatch;
        } else if (this.insertVertexCondition_(evt) && Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(segment) in this.vertexSegments_ &&
            (!componentSegments[uid][0] && !componentSegments[uid][1])) {
          insertVertices.push([segmentDataMatch, vertex]);
        }
      }
      if (insertVertices.length) {
        this.willModifyFeatures_(evt);
      }
      for (var j = insertVertices.length - 1; j >= 0; --j) {
        this.insertVertex_.apply(this, insertVertices[j]);
      }
    }
    return !!this.vertexFeature_;
  };

  /**
   * @inheritDoc
   */
  Modify.prototype.handleUpEvent = function handleUpEvent (evt) {
    for (var i = this.dragSegments_.length - 1; i >= 0; --i) {
      var segmentData = this.dragSegments_[i][0];
      var geometry = segmentData.geometry;
      if (geometry.getType() === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].CIRCLE) {
        // Update a circle object in the R* bush:
        var coordinates = geometry.getCenter();
        var centerSegmentData = segmentData.featureSegments[0];
        var circumferenceSegmentData = segmentData.featureSegments[1];
        centerSegmentData.segment[0] = centerSegmentData.segment[1] = coordinates;
        circumferenceSegmentData.segment[0] = circumferenceSegmentData.segment[1] = coordinates;
        this.rBush_.update(Object(_extent_js__WEBPACK_IMPORTED_MODULE_11__["createOrUpdateFromCoordinate"])(coordinates), centerSegmentData);
        this.rBush_.update(geometry.getExtent(), circumferenceSegmentData);
      } else {
        this.rBush_.update(Object(_extent_js__WEBPACK_IMPORTED_MODULE_11__["boundingExtent"])(segmentData.segment), segmentData);
      }
    }
    if (this.modified_) {
      this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND, this.features_, evt));
      this.modified_ = false;
    }
    return false;
  };

  /**
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @private
   */
  Modify.prototype.handlePointerMove_ = function handlePointerMove_ (evt) {
    this.lastPixel_ = evt.pixel;
    this.handlePointerAtPixel_(evt.pixel, evt.map);
  };

  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel
   * @param {import("../PluggableMap.js").default} map Map.
   * @private
   */
  Modify.prototype.handlePointerAtPixel_ = function handlePointerAtPixel_ (pixel, map) {
    var pixelCoordinate = map.getCoordinateFromPixel(pixel);
    var sortByDistance = function(a, b) {
      return pointDistanceToSegmentDataSquared(pixelCoordinate, a) -
          pointDistanceToSegmentDataSquared(pixelCoordinate, b);
    };

    var box = Object(_extent_js__WEBPACK_IMPORTED_MODULE_11__["buffer"])(Object(_extent_js__WEBPACK_IMPORTED_MODULE_11__["createOrUpdateFromCoordinate"])(pixelCoordinate),
      map.getView().getResolution() * this.pixelTolerance_);

    var rBush = this.rBush_;
    var nodes = rBush.getInExtent(box);
    if (nodes.length > 0) {
      nodes.sort(sortByDistance);
      var node = nodes[0];
      var closestSegment = node.segment;
      var vertex = closestOnSegmentData(pixelCoordinate, node);
      var vertexPixel = map.getPixelFromCoordinate(vertex);
      var dist = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_6__["distance"])(pixel, vertexPixel);
      if (dist <= this.pixelTolerance_) {
        /** @type {Object<string, boolean>} */
        var vertexSegments = {};

        if (node.geometry.getType() === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].CIRCLE &&
        node.index === CIRCLE_CIRCUMFERENCE_INDEX) {

          this.snappedToVertex_ = true;
          this.createOrUpdateVertexFeature_(vertex);
        } else {
          var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
          var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
          var squaredDist1 = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_6__["squaredDistance"])(vertexPixel, pixel1);
          var squaredDist2 = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_6__["squaredDistance"])(vertexPixel, pixel2);
          dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
          this.snappedToVertex_ = dist <= this.pixelTolerance_;
          if (this.snappedToVertex_) {
            vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
          }
          this.createOrUpdateVertexFeature_(vertex);
          for (var i = 1, ii = nodes.length; i < ii; ++i) {
            var segment = nodes[i].segment;
            if ((Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_6__["equals"])(closestSegment[0], segment[0]) &&
                Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_6__["equals"])(closestSegment[1], segment[1]) ||
                (Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_6__["equals"])(closestSegment[0], segment[1]) &&
                Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_6__["equals"])(closestSegment[1], segment[0])))) {
              vertexSegments[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(segment)] = true;
            } else {
              break;
            }
          }
        }

        vertexSegments[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(closestSegment)] = true;
        this.vertexSegments_ = vertexSegments;
        return;
      }
    }
    if (this.vertexFeature_) {
      /** @type {VectorSource} */ (this.overlay_.getSource()).removeFeature(this.vertexFeature_);
      this.vertexFeature_ = null;
    }
  };

  /**
   * @param {SegmentData} segmentData Segment data.
   * @param {import("../coordinate.js").Coordinate} vertex Vertex.
   * @private
   */
  Modify.prototype.insertVertex_ = function insertVertex_ (segmentData, vertex) {
    var segment = segmentData.segment;
    var feature = segmentData.feature;
    var geometry = segmentData.geometry;
    var depth = segmentData.depth;
    var index = /** @type {number} */ (segmentData.index);
    var coordinates;

    while (vertex.length < geometry.getStride()) {
      vertex.push(0);
    }

    switch (geometry.getType()) {
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].MULTI_LINE_STRING:
        coordinates = geometry.getCoordinates();
        coordinates[depth[0]].splice(index + 1, 0, vertex);
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].POLYGON:
        coordinates = geometry.getCoordinates();
        coordinates[depth[0]].splice(index + 1, 0, vertex);
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].MULTI_POLYGON:
        coordinates = geometry.getCoordinates();
        coordinates[depth[1]][depth[0]].splice(index + 1, 0, vertex);
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].LINE_STRING:
        coordinates = geometry.getCoordinates();
        coordinates.splice(index + 1, 0, vertex);
        break;
      default:
        return;
    }

    this.setGeometryCoordinates_(geometry, coordinates);
    var rTree = this.rBush_;
    rTree.remove(segmentData);
    this.updateSegmentIndices_(geometry, index, depth, 1);
    var newSegmentData = /** @type {SegmentData} */ ({
      segment: [segment[0], vertex],
      feature: feature,
      geometry: geometry,
      depth: depth,
      index: index
    });
    rTree.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_11__["boundingExtent"])(newSegmentData.segment),
      newSegmentData);
    this.dragSegments_.push([newSegmentData, 1]);

    var newSegmentData2 = /** @type {SegmentData} */ ({
      segment: [vertex, segment[1]],
      feature: feature,
      geometry: geometry,
      depth: depth,
      index: index + 1
    });
    rTree.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_11__["boundingExtent"])(newSegmentData2.segment), newSegmentData2);
    this.dragSegments_.push([newSegmentData2, 0]);
    this.ignoreNextSingleClick_ = true;
  };

  /**
   * Removes the vertex currently being pointed.
   * @return {boolean} True when a vertex was removed.
   * @api
   */
  Modify.prototype.removePoint = function removePoint () {
    if (this.lastPointerEvent_ && this.lastPointerEvent_.type != _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].POINTERDRAG) {
      var evt = this.lastPointerEvent_;
      this.willModifyFeatures_(evt);
      this.removeVertex_();
      this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND, this.features_, evt));
      this.modified_ = false;
      return true;
    }
    return false;
  };

  /**
   * Removes a vertex from all matching features.
   * @return {boolean} True when a vertex was removed.
   * @private
   */
  Modify.prototype.removeVertex_ = function removeVertex_ () {
    var dragSegments = this.dragSegments_;
    var segmentsByFeature = {};
    var deleted = false;
    var component, coordinates, dragSegment, geometry, i, index, left;
    var newIndex, right, segmentData, uid;
    for (i = dragSegments.length - 1; i >= 0; --i) {
      dragSegment = dragSegments[i];
      segmentData = dragSegment[0];
      uid = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(segmentData.feature);
      if (segmentData.depth) {
        // separate feature components
        uid += '-' + segmentData.depth.join('-');
      }
      if (!(uid in segmentsByFeature)) {
        segmentsByFeature[uid] = {};
      }
      if (dragSegment[1] === 0) {
        segmentsByFeature[uid].right = segmentData;
        segmentsByFeature[uid].index = segmentData.index;
      } else if (dragSegment[1] == 1) {
        segmentsByFeature[uid].left = segmentData;
        segmentsByFeature[uid].index = segmentData.index + 1;
      }

    }
    for (uid in segmentsByFeature) {
      right = segmentsByFeature[uid].right;
      left = segmentsByFeature[uid].left;
      index = segmentsByFeature[uid].index;
      newIndex = index - 1;
      if (left !== undefined) {
        segmentData = left;
      } else {
        segmentData = right;
      }
      if (newIndex < 0) {
        newIndex = 0;
      }
      geometry = segmentData.geometry;
      coordinates = geometry.getCoordinates();
      component = coordinates;
      deleted = false;
      switch (geometry.getType()) {
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].MULTI_LINE_STRING:
          if (coordinates[segmentData.depth[0]].length > 2) {
            coordinates[segmentData.depth[0]].splice(index, 1);
            deleted = true;
          }
          break;
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].LINE_STRING:
          if (coordinates.length > 2) {
            coordinates.splice(index, 1);
            deleted = true;
          }
          break;
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].MULTI_POLYGON:
          component = component[segmentData.depth[1]];
          /* falls through */
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].POLYGON:
          component = component[segmentData.depth[0]];
          if (component.length > 4) {
            if (index == component.length - 1) {
              index = 0;
            }
            component.splice(index, 1);
            deleted = true;
            if (index === 0) {
              // close the ring again
              component.pop();
              component.push(component[0]);
              newIndex = component.length - 1;
            }
          }
          break;
        default:
          // pass
      }

      if (deleted) {
        this.setGeometryCoordinates_(geometry, coordinates);
        var segments = [];
        if (left !== undefined) {
          this.rBush_.remove(left);
          segments.push(left.segment[0]);
        }
        if (right !== undefined) {
          this.rBush_.remove(right);
          segments.push(right.segment[1]);
        }
        if (left !== undefined && right !== undefined) {
          var newSegmentData = /** @type {SegmentData} */ ({
            depth: segmentData.depth,
            feature: segmentData.feature,
            geometry: segmentData.geometry,
            index: newIndex,
            segment: segments
          });
          this.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_11__["boundingExtent"])(newSegmentData.segment),
            newSegmentData);
        }
        this.updateSegmentIndices_(geometry, index, segmentData.depth, -1);
        if (this.vertexFeature_) {
          /** @type {VectorSource} */ (this.overlay_.getSource()).removeFeature(this.vertexFeature_);
          this.vertexFeature_ = null;
        }
        dragSegments.length = 0;
      }

    }
    return deleted;
  };

  /**
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {Array} coordinates Coordinates.
   * @private
   */
  Modify.prototype.setGeometryCoordinates_ = function setGeometryCoordinates_ (geometry, coordinates) {
    this.changingFeature_ = true;
    geometry.setCoordinates(coordinates);
    this.changingFeature_ = false;
  };

  /**
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {number} index Index.
   * @param {Array<number>|undefined} depth Depth.
   * @param {number} delta Delta (1 or -1).
   * @private
   */
  Modify.prototype.updateSegmentIndices_ = function updateSegmentIndices_ (geometry, index, depth, delta) {
    this.rBush_.forEachInExtent(geometry.getExtent(), function(segmentDataMatch) {
      if (segmentDataMatch.geometry === geometry &&
          (depth === undefined || segmentDataMatch.depth === undefined ||
          Object(_array_js__WEBPACK_IMPORTED_MODULE_5__["equals"])(segmentDataMatch.depth, depth)) &&
          segmentDataMatch.index > index) {
        segmentDataMatch.index += delta;
      }
    });
  };

  return Modify;
}(_Pointer_js__WEBPACK_IMPORTED_MODULE_14__["default"]));


/**
 * @param {SegmentData} a The first segment data.
 * @param {SegmentData} b The second segment data.
 * @return {number} The difference in indexes.
 */
function compareIndexes(a, b) {
  return a.index - b.index;
}


/**
 * Returns the distance from a point to a line segment.
 *
 * @param {import("../coordinate.js").Coordinate} pointCoordinates The coordinates of the point from
 *        which to calculate the distance.
 * @param {SegmentData} segmentData The object describing the line
 *        segment we are calculating the distance to.
 * @return {number} The square of the distance between a point and a line segment.
 */
function pointDistanceToSegmentDataSquared(pointCoordinates, segmentData) {
  var geometry = segmentData.geometry;

  if (geometry.getType() === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].CIRCLE) {
    var circleGeometry = /** @type {import("../geom/Circle.js").default} */ (geometry);

    if (segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {
      var distanceToCenterSquared =
            Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_6__["squaredDistance"])(circleGeometry.getCenter(), pointCoordinates);
      var distanceToCircumference =
            Math.sqrt(distanceToCenterSquared) - circleGeometry.getRadius();
      return distanceToCircumference * distanceToCircumference;
    }
  }
  return Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_6__["squaredDistanceToSegment"])(pointCoordinates, segmentData.segment);
}

/**
 * Returns the point closest to a given line segment.
 *
 * @param {import("../coordinate.js").Coordinate} pointCoordinates The point to which a closest point
 *        should be found.
 * @param {SegmentData} segmentData The object describing the line
 *        segment which should contain the closest point.
 * @return {import("../coordinate.js").Coordinate} The point closest to the specified line segment.
 */
function closestOnSegmentData(pointCoordinates, segmentData) {
  var geometry = segmentData.geometry;

  if (geometry.getType() === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].CIRCLE &&
  segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {
    return geometry.getClosestPoint(pointCoordinates);
  }
  return Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_6__["closestOnSegment"])(pointCoordinates, segmentData.segment);
}


/**
 * @return {import("../style/Style.js").StyleFunction} Styles.
 */
function getDefaultStyleFunction() {
  var style = Object(_style_Style_js__WEBPACK_IMPORTED_MODULE_19__["createEditingStyle"])();
  return function(feature, resolution) {
    return style[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].POINT];
  };
}


/* harmony default export */ __webpack_exports__["default"] = (Modify);

//# sourceMappingURL=Modify.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/MouseWheelZoom.js":
/*!*******************************************************!*\
  !*** ./node_modules/ol/interaction/MouseWheelZoom.js ***!
  \*******************************************************/
/*! exports provided: Mode, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Mode", function() { return Mode; });
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ViewHint.js */ "./node_modules/ol/ViewHint.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../easing.js */ "./node_modules/ol/easing.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/interaction/MouseWheelZoom
 */









/**
 * Maximum mouse wheel delta.
 * @type {number}
 */
var MAX_DELTA = 1;


/**
 * @enum {string}
 */
var Mode = {
  TRACKPAD: 'trackpad',
  WHEEL: 'wheel'
};


/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. Default is
 * {@link module:ol/events/condition~always}.
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {number} [timeout=80] Mouse wheel timeout duration in milliseconds.
 * @property {boolean} [constrainResolution=false] When using a trackpad or
 * magic mouse, zoom to the closest integer zoom level after the scroll gesture
 * ends.
 * @property {boolean} [useAnchor=true] Enable zooming using the mouse's
 * location as the anchor. When set to `false`, zooming in and out will zoom to
 * the center of the screen instead of zooming on the mouse's location.
 */


/**
 * @classdesc
 * Allows the user to zoom the map by scrolling the mouse wheel.
 * @api
 */
var MouseWheelZoom = /*@__PURE__*/(function (Interaction) {
  function MouseWheelZoom(opt_options) {

    var options = opt_options ? opt_options : {};

    Interaction.call(/** @type {import("./Interaction.js").InteractionOptions} */ this, (options));

    /**
     * @private
     * @type {number}
     */
    this.delta_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 250;

    /**
     * @private
     * @type {number}
     */
    this.timeout_ = options.timeout !== undefined ? options.timeout : 80;

    /**
     * @private
     * @type {boolean}
     */
    this.useAnchor_ = options.useAnchor !== undefined ? options.useAnchor : true;

    /**
     * @private
     * @type {boolean}
     */
    this.constrainResolution_ = options.constrainResolution || false;

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_1__["always"];

    /**
     * @private
     * @type {?import("../coordinate.js").Coordinate}
     */
    this.lastAnchor_ = null;

    /**
     * @private
     * @type {number|undefined}
     */
    this.startTime_ = undefined;

    /**
     * @private
     * @type {?}
     */
    this.timeoutId_;

    /**
     * @private
     * @type {Mode|undefined}
     */
    this.mode_ = undefined;

    /**
     * Trackpad events separated by this delay will be considered separate
     * interactions.
     * @type {number}
     */
    this.trackpadEventGap_ = 400;

    /**
     * @type {?}
     */
    this.trackpadTimeoutId_;

    /**
     * The number of delta values per zoom level
     * @private
     * @type {number}
     */
    this.trackpadDeltaPerZoom_ = 300;

    /**
     * The zoom factor by which scroll zooming is allowed to exceed the limits.
     * @private
     * @type {number}
     */
    this.trackpadZoomBuffer_ = 1.5;

  }

  if ( Interaction ) MouseWheelZoom.__proto__ = Interaction;
  MouseWheelZoom.prototype = Object.create( Interaction && Interaction.prototype );
  MouseWheelZoom.prototype.constructor = MouseWheelZoom;

  /**
   * @private
   */
  MouseWheelZoom.prototype.decrementInteractingHint_ = function decrementInteractingHint_ () {
    this.trackpadTimeoutId_ = undefined;
    var view = this.getMap().getView();
    view.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_0__["default"].INTERACTING, -1);
  };

  /**
   * Handles the {@link module:ol/MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually
   * zooms the map.
   * @override
   */
  MouseWheelZoom.prototype.handleEvent = function handleEvent (mapBrowserEvent) {
    if (!this.condition_(mapBrowserEvent)) {
      return true;
    }
    var type = mapBrowserEvent.type;
    if (type !== _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].WHEEL && type !== _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].MOUSEWHEEL) {
      return true;
    }

    mapBrowserEvent.preventDefault();

    var map = mapBrowserEvent.map;
    var wheelEvent = /** @type {WheelEvent} */ (mapBrowserEvent.originalEvent);

    if (this.useAnchor_) {
      this.lastAnchor_ = mapBrowserEvent.coordinate;
    }

    // Delta normalisation inspired by
    // https://github.com/mapbox/mapbox-gl-js/blob/001c7b9/js/ui/handler/scroll_zoom.js
    var delta;
    if (mapBrowserEvent.type == _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].WHEEL) {
      delta = wheelEvent.deltaY;
      if (_has_js__WEBPACK_IMPORTED_MODULE_4__["FIREFOX"] &&
          wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {
        delta /= _has_js__WEBPACK_IMPORTED_MODULE_4__["DEVICE_PIXEL_RATIO"];
      }
      if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {
        delta *= 40;
      }
    } else if (mapBrowserEvent.type == _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].MOUSEWHEEL) {
      delta = -wheelEvent.wheelDeltaY;
      if (_has_js__WEBPACK_IMPORTED_MODULE_4__["SAFARI"]) {
        delta /= 3;
      }
    }

    if (delta === 0) {
      return false;
    }

    var now = Date.now();

    if (this.startTime_ === undefined) {
      this.startTime_ = now;
    }

    if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {
      this.mode_ = Math.abs(delta) < 4 ?
        Mode.TRACKPAD :
        Mode.WHEEL;
    }

    if (this.mode_ === Mode.TRACKPAD) {
      var view = map.getView();
      if (this.trackpadTimeoutId_) {
        clearTimeout(this.trackpadTimeoutId_);
      } else {
        view.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_0__["default"].INTERACTING, 1);
      }
      this.trackpadTimeoutId_ = setTimeout(this.decrementInteractingHint_.bind(this), this.trackpadEventGap_);
      var resolution = view.getResolution() * Math.pow(2, delta / this.trackpadDeltaPerZoom_);
      var minResolution = view.getMinResolution();
      var maxResolution = view.getMaxResolution();
      var rebound = 0;
      if (resolution < minResolution) {
        resolution = Math.max(resolution, minResolution / this.trackpadZoomBuffer_);
        rebound = 1;
      } else if (resolution > maxResolution) {
        resolution = Math.min(resolution, maxResolution * this.trackpadZoomBuffer_);
        rebound = -1;
      }
      if (this.lastAnchor_) {
        var center = view.calculateCenterZoom(resolution, this.lastAnchor_);
        view.setCenter(view.constrainCenter(center));
      }
      view.setResolution(resolution);

      if (rebound === 0 && this.constrainResolution_) {
        view.animate({
          resolution: view.constrainResolution(resolution, delta > 0 ? -1 : 1),
          easing: _easing_js__WEBPACK_IMPORTED_MODULE_2__["easeOut"],
          anchor: this.lastAnchor_,
          duration: this.duration_
        });
      }

      if (rebound > 0) {
        view.animate({
          resolution: minResolution,
          easing: _easing_js__WEBPACK_IMPORTED_MODULE_2__["easeOut"],
          anchor: this.lastAnchor_,
          duration: 500
        });
      } else if (rebound < 0) {
        view.animate({
          resolution: maxResolution,
          easing: _easing_js__WEBPACK_IMPORTED_MODULE_2__["easeOut"],
          anchor: this.lastAnchor_,
          duration: 500
        });
      }
      this.startTime_ = now;
      return false;
    }

    this.delta_ += delta;

    var timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);

    clearTimeout(this.timeoutId_);
    this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, map), timeLeft);

    return false;
  };

  /**
   * @private
   * @param {import("../PluggableMap.js").default} map Map.
   */
  MouseWheelZoom.prototype.handleWheelZoom_ = function handleWheelZoom_ (map) {
    var view = map.getView();
    if (view.getAnimating()) {
      view.cancelAnimations();
    }
    var maxDelta = MAX_DELTA;
    var delta = Object(_math_js__WEBPACK_IMPORTED_MODULE_6__["clamp"])(this.delta_, -maxDelta, maxDelta);
    Object(_Interaction_js__WEBPACK_IMPORTED_MODULE_5__["zoomByDelta"])(view, -delta, this.lastAnchor_, this.duration_);
    this.mode_ = undefined;
    this.delta_ = 0;
    this.lastAnchor_ = null;
    this.startTime_ = undefined;
    this.timeoutId_ = undefined;
  };

  /**
   * Enable or disable using the mouse's location as an anchor when zooming
   * @param {boolean} useAnchor true to zoom to the mouse's location, false
   * to zoom to the center of the map
   * @api
   */
  MouseWheelZoom.prototype.setMouseAnchor = function setMouseAnchor (useAnchor) {
    this.useAnchor_ = useAnchor;
    if (!useAnchor) {
      this.lastAnchor_ = null;
    }
  };

  return MouseWheelZoom;
}(_Interaction_js__WEBPACK_IMPORTED_MODULE_5__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (MouseWheelZoom);

//# sourceMappingURL=MouseWheelZoom.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/PinchRotate.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/interaction/PinchRotate.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ViewHint.js */ "./node_modules/ol/ViewHint.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/* harmony import */ var _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../rotationconstraint.js */ "./node_modules/ol/rotationconstraint.js");
/**
 * @module ol/interaction/PinchRotate
 */







/**
 * @typedef {Object} Options
 * @property {number} [duration=250] The duration of the animation in
 * milliseconds.
 * @property {number} [threshold=0.3] Minimal angle in radians to start a rotation.
 */


/**
 * @classdesc
 * Allows the user to rotate the map by twisting with two fingers
 * on a touch screen.
 * @api
 */
var PinchRotate = /*@__PURE__*/(function (PointerInteraction) {
  function PinchRotate(opt_options) {

    var options = opt_options ? opt_options : {};

    var pointerOptions = /** @type {import("./Pointer.js").Options} */ (options);

    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = _functions_js__WEBPACK_IMPORTED_MODULE_1__["FALSE"];
    }

    PointerInteraction.call(this, pointerOptions);

    /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */
    this.anchor_ = null;

    /**
     * @private
     * @type {number|undefined}
     */
    this.lastAngle_ = undefined;

    /**
     * @private
     * @type {boolean}
     */
    this.rotating_ = false;

    /**
     * @private
     * @type {number}
     */
    this.rotationDelta_ = 0.0;

    /**
     * @private
     * @type {number}
     */
    this.threshold_ = options.threshold !== undefined ? options.threshold : 0.3;

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 250;

  }

  if ( PointerInteraction ) PinchRotate.__proto__ = PointerInteraction;
  PinchRotate.prototype = Object.create( PointerInteraction && PointerInteraction.prototype );
  PinchRotate.prototype.constructor = PinchRotate;

  /**
   * @inheritDoc
   */
  PinchRotate.prototype.handleDragEvent = function handleDragEvent (mapBrowserEvent) {
    var rotationDelta = 0.0;

    var touch0 = this.targetPointers[0];
    var touch1 = this.targetPointers[1];

    // angle between touches
    var angle = Math.atan2(
      touch1.clientY - touch0.clientY,
      touch1.clientX - touch0.clientX);

    if (this.lastAngle_ !== undefined) {
      var delta = angle - this.lastAngle_;
      this.rotationDelta_ += delta;
      if (!this.rotating_ &&
          Math.abs(this.rotationDelta_) > this.threshold_) {
        this.rotating_ = true;
      }
      rotationDelta = delta;
    }
    this.lastAngle_ = angle;

    var map = mapBrowserEvent.map;
    var view = map.getView();
    if (view.getConstraints().rotation === _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_4__["disable"]) {
      return;
    }

    // rotate anchor point.
    // FIXME: should be the intersection point between the lines:
    //     touch0,touch1 and previousTouch0,previousTouch1
    var viewportPosition = map.getViewport().getBoundingClientRect();
    var centroid = Object(_Pointer_js__WEBPACK_IMPORTED_MODULE_3__["centroid"])(this.targetPointers);
    centroid[0] -= viewportPosition.left;
    centroid[1] -= viewportPosition.top;
    this.anchor_ = map.getCoordinateFromPixel(centroid);

    // rotate
    if (this.rotating_) {
      var rotation = view.getRotation();
      map.render();
      Object(_Interaction_js__WEBPACK_IMPORTED_MODULE_2__["rotateWithoutConstraints"])(view, rotation + rotationDelta, this.anchor_);
    }
  };

  /**
   * @inheritDoc
   */
  PinchRotate.prototype.handleUpEvent = function handleUpEvent (mapBrowserEvent) {
    if (this.targetPointers.length < 2) {
      var map = mapBrowserEvent.map;
      var view = map.getView();
      view.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_0__["default"].INTERACTING, -1);
      if (this.rotating_) {
        var rotation = view.getRotation();
        Object(_Interaction_js__WEBPACK_IMPORTED_MODULE_2__["rotate"])(view, rotation, this.anchor_, this.duration_);
      }
      return false;
    } else {
      return true;
    }
  };

  /**
   * @inheritDoc
   */
  PinchRotate.prototype.handleDownEvent = function handleDownEvent (mapBrowserEvent) {
    if (this.targetPointers.length >= 2) {
      var map = mapBrowserEvent.map;
      this.anchor_ = null;
      this.lastAngle_ = undefined;
      this.rotating_ = false;
      this.rotationDelta_ = 0.0;
      if (!this.handlingDownUpSequence) {
        map.getView().setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_0__["default"].INTERACTING, 1);
      }
      return true;
    } else {
      return false;
    }
  };

  return PinchRotate;
}(_Pointer_js__WEBPACK_IMPORTED_MODULE_3__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (PinchRotate);

//# sourceMappingURL=PinchRotate.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/PinchZoom.js":
/*!**************************************************!*\
  !*** ./node_modules/ol/interaction/PinchZoom.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ViewHint.js */ "./node_modules/ol/ViewHint.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/**
 * @module ol/interaction/PinchZoom
 */






/**
 * @typedef {Object} Options
 * @property {number} [duration=400] Animation duration in milliseconds.
 * @property {boolean} [constrainResolution=false] Zoom to the closest integer
 * zoom level after the pinch gesture ends.
 */


/**
 * @classdesc
 * Allows the user to zoom the map by pinching with two fingers
 * on a touch screen.
 * @api
 */
var PinchZoom = /*@__PURE__*/(function (PointerInteraction) {
  function PinchZoom(opt_options) {

    var options = opt_options ? opt_options : {};

    var pointerOptions = /** @type {import("./Pointer.js").Options} */ (options);

    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = _functions_js__WEBPACK_IMPORTED_MODULE_1__["FALSE"];
    }

    PointerInteraction.call(this, pointerOptions);

    /**
     * @private
     * @type {boolean}
     */
    this.constrainResolution_ = options.constrainResolution || false;

    /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */
    this.anchor_ = null;

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 400;

    /**
     * @private
     * @type {number|undefined}
     */
    this.lastDistance_ = undefined;

    /**
     * @private
     * @type {number}
     */
    this.lastScaleDelta_ = 1;

  }

  if ( PointerInteraction ) PinchZoom.__proto__ = PointerInteraction;
  PinchZoom.prototype = Object.create( PointerInteraction && PointerInteraction.prototype );
  PinchZoom.prototype.constructor = PinchZoom;

  /**
   * @inheritDoc
   */
  PinchZoom.prototype.handleDragEvent = function handleDragEvent (mapBrowserEvent) {
    var scaleDelta = 1.0;

    var touch0 = this.targetPointers[0];
    var touch1 = this.targetPointers[1];
    var dx = touch0.clientX - touch1.clientX;
    var dy = touch0.clientY - touch1.clientY;

    // distance between touches
    var distance = Math.sqrt(dx * dx + dy * dy);

    if (this.lastDistance_ !== undefined) {
      scaleDelta = this.lastDistance_ / distance;
    }
    this.lastDistance_ = distance;


    var map = mapBrowserEvent.map;
    var view = map.getView();
    var resolution = view.getResolution();
    var maxResolution = view.getMaxResolution();
    var minResolution = view.getMinResolution();
    var newResolution = resolution * scaleDelta;
    if (newResolution > maxResolution) {
      scaleDelta = maxResolution / resolution;
      newResolution = maxResolution;
    } else if (newResolution < minResolution) {
      scaleDelta = minResolution / resolution;
      newResolution = minResolution;
    }

    if (scaleDelta != 1.0) {
      this.lastScaleDelta_ = scaleDelta;
    }

    // scale anchor point.
    var viewportPosition = map.getViewport().getBoundingClientRect();
    var centroid = Object(_Pointer_js__WEBPACK_IMPORTED_MODULE_3__["centroid"])(this.targetPointers);
    centroid[0] -= viewportPosition.left;
    centroid[1] -= viewportPosition.top;
    this.anchor_ = map.getCoordinateFromPixel(centroid);

    // scale, bypass the resolution constraint
    map.render();
    Object(_Interaction_js__WEBPACK_IMPORTED_MODULE_2__["zoomWithoutConstraints"])(view, newResolution, this.anchor_);
  };

  /**
   * @inheritDoc
   */
  PinchZoom.prototype.handleUpEvent = function handleUpEvent (mapBrowserEvent) {
    if (this.targetPointers.length < 2) {
      var map = mapBrowserEvent.map;
      var view = map.getView();
      view.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_0__["default"].INTERACTING, -1);
      var resolution = view.getResolution();
      if (this.constrainResolution_ ||
          resolution < view.getMinResolution() ||
          resolution > view.getMaxResolution()) {
        // Zoom to final resolution, with an animation, and provide a
        // direction not to zoom out/in if user was pinching in/out.
        // Direction is > 0 if pinching out, and < 0 if pinching in.
        var direction = this.lastScaleDelta_ - 1;
        Object(_Interaction_js__WEBPACK_IMPORTED_MODULE_2__["zoom"])(view, resolution, this.anchor_, this.duration_, direction);
      }
      return false;
    } else {
      return true;
    }
  };

  /**
   * @inheritDoc
   */
  PinchZoom.prototype.handleDownEvent = function handleDownEvent (mapBrowserEvent) {
    if (this.targetPointers.length >= 2) {
      var map = mapBrowserEvent.map;
      this.anchor_ = null;
      this.lastDistance_ = undefined;
      this.lastScaleDelta_ = 1;
      if (!this.handlingDownUpSequence) {
        map.getView().setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_0__["default"].INTERACTING, 1);
      }
      return true;
    } else {
      return false;
    }
  };

  return PinchZoom;
}(_Pointer_js__WEBPACK_IMPORTED_MODULE_3__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (PinchZoom);

//# sourceMappingURL=PinchZoom.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/Pointer.js":
/*!************************************************!*\
  !*** ./node_modules/ol/interaction/Pointer.js ***!
  \************************************************/
/*! exports provided: centroid, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "centroid", function() { return centroid; });
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MapBrowserEventType.js */ "./node_modules/ol/MapBrowserEventType.js");
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/interaction/Pointer
 */





/**
 * @typedef {Object} Options
 * @property {function(import("../MapBrowserPointerEvent.js").default):boolean} [handleDownEvent]
 * Function handling "down" events. If the function returns `true` then a drag
 * sequence is started.
 * @property {function(import("../MapBrowserPointerEvent.js").default)} [handleDragEvent]
 * Function handling "drag" events. This function is called on "move" events
 * during a drag sequence.
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleEvent]
 * Method called by the map to notify the interaction that a browser event was
 * dispatched to the map. The function may return `false` to prevent the
 * propagation of the event to other interactions in the map's interactions
 * chain.
 * @property {function(import("../MapBrowserPointerEvent.js").default)} [handleMoveEvent]
 * Function handling "move" events. This function is called on "move" events,
 * also during a drag sequence (so during a drag sequence both the
 * `handleDragEvent` function and this function are called).
 * @property {function(import("../MapBrowserPointerEvent.js").default):boolean} [handleUpEvent]
 *  Function handling "up" events. If the function returns `false` then the
 * current drag sequence is stopped.
 * @property {function(boolean):boolean} [stopDown]
 * Should the down event be propagated to other interactions, or should be
 * stopped?
 */


/**
 * @classdesc
 * Base class that calls user-defined functions on `down`, `move` and `up`
 * events. This class also manages "drag sequences".
 *
 * When the `handleDownEvent` user function returns `true` a drag sequence is
 * started. During a drag sequence the `handleDragEvent` user function is
 * called on `move` events. The drag sequence ends when the `handleUpEvent`
 * user function is called and returns `false`.
 * @api
 */
var PointerInteraction = /*@__PURE__*/(function (Interaction) {
  function PointerInteraction(opt_options) {

    var options = opt_options ? opt_options : {};

    Interaction.call(/** @type {import("./Interaction.js").InteractionOptions} */ this, (options));

    if (options.handleDownEvent) {
      this.handleDownEvent = options.handleDownEvent;
    }

    if (options.handleDragEvent) {
      this.handleDragEvent = options.handleDragEvent;
    }

    if (options.handleMoveEvent) {
      this.handleMoveEvent = options.handleMoveEvent;
    }

    if (options.handleUpEvent) {
      this.handleUpEvent = options.handleUpEvent;
    }

    if (options.stopDown) {
      this.stopDown = options.stopDown;
    }

    /**
     * @type {boolean}
     * @protected
     */
    this.handlingDownUpSequence = false;

    /**
     * @type {!Object<string, import("../pointer/PointerEvent.js").default>}
     * @private
     */
    this.trackedPointers_ = {};

    /**
     * @type {Array<import("../pointer/PointerEvent.js").default>}
     * @protected
     */
    this.targetPointers = [];

  }

  if ( Interaction ) PointerInteraction.__proto__ = Interaction;
  PointerInteraction.prototype = Object.create( Interaction && Interaction.prototype );
  PointerInteraction.prototype.constructor = PointerInteraction;

  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserPointerEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */
  PointerInteraction.prototype.handleDownEvent = function handleDownEvent (mapBrowserEvent) {
    return false;
  };

  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserPointerEvent.js").default} mapBrowserEvent Event.
   * @protected
   */
  PointerInteraction.prototype.handleDragEvent = function handleDragEvent (mapBrowserEvent) {};

  /**
   * Handles the {@link module:ol/MapBrowserEvent map browser event} and may call into
   * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
   * detected.
   * @override
   * @api
   */
  PointerInteraction.prototype.handleEvent = function handleEvent (mapBrowserEvent) {
    if (!(/** @type {import("../MapBrowserPointerEvent.js").default} */ (mapBrowserEvent).pointerEvent)) {
      return true;
    }

    var stopEvent = false;
    this.updateTrackedPointers_(mapBrowserEvent);
    if (this.handlingDownUpSequence) {
      if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].POINTERDRAG) {
        this.handleDragEvent(mapBrowserEvent);
      } else if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].POINTERUP) {
        var handledUp = this.handleUpEvent(mapBrowserEvent);
        this.handlingDownUpSequence = handledUp && this.targetPointers.length > 0;
      }
    } else {
      if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].POINTERDOWN) {
        var handled = this.handleDownEvent(mapBrowserEvent);
        if (handled) {
          mapBrowserEvent.preventDefault();
        }
        this.handlingDownUpSequence = handled;
        stopEvent = this.stopDown(handled);
      } else if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].POINTERMOVE) {
        this.handleMoveEvent(mapBrowserEvent);
      }
    }
    return !stopEvent;
  };

  /**
   * Handle pointer move events.
   * @param {import("../MapBrowserPointerEvent.js").default} mapBrowserEvent Event.
   * @protected
   */
  PointerInteraction.prototype.handleMoveEvent = function handleMoveEvent (mapBrowserEvent) {};

  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserPointerEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */
  PointerInteraction.prototype.handleUpEvent = function handleUpEvent (mapBrowserEvent) {
    return false;
  };

  /**
   * This function is used to determine if "down" events should be propagated
   * to other interactions or should be stopped.
   * @param {boolean} handled Was the event handled by the interaction?
   * @return {boolean} Should the `down` event be stopped?
   */
  PointerInteraction.prototype.stopDown = function stopDown (handled) {
    return handled;
  };

  /**
   * @param {import("../MapBrowserPointerEvent.js").default} mapBrowserEvent Event.
   * @private
   */
  PointerInteraction.prototype.updateTrackedPointers_ = function updateTrackedPointers_ (mapBrowserEvent) {
    if (isPointerDraggingEvent(mapBrowserEvent)) {
      var event = mapBrowserEvent.pointerEvent;

      var id = event.pointerId.toString();
      if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].POINTERUP) {
        delete this.trackedPointers_[id];
      } else if (mapBrowserEvent.type ==
          _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].POINTERDOWN) {
        this.trackedPointers_[id] = event;
      } else if (id in this.trackedPointers_) {
        // update only when there was a pointerdown event for this pointer
        this.trackedPointers_[id] = event;
      }
      this.targetPointers = Object(_obj_js__WEBPACK_IMPORTED_MODULE_2__["getValues"])(this.trackedPointers_);
    }
  };

  return PointerInteraction;
}(_Interaction_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/**
 * @param {Array<import("../pointer/PointerEvent.js").default>} pointerEvents List of events.
 * @return {import("../pixel.js").Pixel} Centroid pixel.
 */
function centroid(pointerEvents) {
  var length = pointerEvents.length;
  var clientX = 0;
  var clientY = 0;
  for (var i = 0; i < length; i++) {
    clientX += pointerEvents[i].clientX;
    clientY += pointerEvents[i].clientY;
  }
  return [clientX / length, clientY / length];
}


/**
 * @param {import("../MapBrowserPointerEvent.js").default} mapBrowserEvent Event.
 * @return {boolean} Whether the event is a pointerdown, pointerdrag
 *     or pointerup event.
 */
function isPointerDraggingEvent(mapBrowserEvent) {
  var type = mapBrowserEvent.type;
  return type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].POINTERDOWN ||
    type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].POINTERDRAG ||
    type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].POINTERUP;
}


/* harmony default export */ __webpack_exports__["default"] = (PointerInteraction);

//# sourceMappingURL=Pointer.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/Property.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/interaction/Property.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/interaction/Property
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  ACTIVE: 'active'
});

//# sourceMappingURL=Property.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/Select.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/interaction/Select.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../CollectionEventType.js */ "./node_modules/ol/CollectionEventType.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/* harmony import */ var _layer_Vector_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../layer/Vector.js */ "./node_modules/ol/layer/Vector.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _source_Vector_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../source/Vector.js */ "./node_modules/ol/source/Vector.js");
/* harmony import */ var _style_Style_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../style/Style.js */ "./node_modules/ol/style/Style.js");
/**
 * @module ol/interaction/Select
 */















/**
 * @enum {string}
 */
var SelectEventType = {
  /**
   * Triggered when feature(s) has been (de)selected.
   * @event SelectEvent#select
   * @api
   */
  SELECT: 'select'
};


/**
 * A function that takes an {@link module:ol/Feature} or
 * {@link module:ol/render/Feature} and an
 * {@link module:ol/layer/Layer} and returns `true` if the feature may be
 * selected or `false` otherwise.
 * @typedef {function(import("../Feature.js").FeatureLike, import("../layer/Layer.js").default):boolean} FilterFunction
 */


/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [addCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * By default, this is {@link module:ol/events/condition~never}. Use this if you
 * want to use different events for add and remove instead of `toggle`.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. This is the event
 * for the selected features as a whole. By default, this is
 * {@link module:ol/events/condition~singleClick}. Clicking on a feature selects that
 * feature and removes any that were in the selection. Clicking outside any
 * feature removes all from the selection.
 * See `toggle`, `add`, `remove` options for adding/removing extra features to/
 * from the selection.
 * @property {Array<import("../layer/Layer.js").default>|function(import("../layer/Layer.js").default): boolean} [layers]
 * A list of layers from which features should be selected. Alternatively, a
 * filter function can be provided. The function will be called for each layer
 * in the map and should return `true` for layers that you want to be
 * selectable. If the option is absent, all visible layers will be considered
 * selectable.
 * @property {import("../style/Style.js").StyleLike} [style]
 * Style for the selected features. By default the default edit style is used
 * (see {@link module:ol/style}).
 * @property {import("../events/condition.js").Condition} [removeCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * By default, this is {@link module:ol/events/condition~never}. Use this if you
 * want to use different events for add and remove instead of `toggle`.
 * @property {import("../events/condition.js").Condition} [toggleCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. This is in addition
 * to the `condition` event. By default,
 * {@link module:ol/events/condition~shiftKeyOnly}, i.e. pressing `shift` as
 * well as the `condition` event, adds that feature to the current selection if
 * it is not currently selected, and removes it if it is. See `add` and `remove`
 * if you want to use different events instead of a toggle.
 * @property {boolean} [multi=false] A boolean that determines if the default
 * behaviour should select only single features or all (overlapping) features at
 * the clicked map position. The default of `false` means single select.
 * @property {import("../Collection.js").default<import("../Feature.js").default>} [features]
 * Collection where the interaction will place selected features. Optional. If
 * not set the interaction will create a collection. In any case the collection
 * used by the interaction is returned by
 * {@link module:ol/interaction/Select~Select#getFeatures}.
 * @property {FilterFunction} [filter] A function
 * that takes an {@link module:ol/Feature} and an
 * {@link module:ol/layer/Layer} and returns `true` if the feature may be
 * selected or `false` otherwise.
 * @property {boolean} [wrapX=true] Wrap the world horizontally on the selection
 * overlay.
 * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside
 * the radius around the given position will be checked for features. This only
 * works for the canvas renderer and not for WebGL.
 */


/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Select~Select} instances are instances of
 * this type.
 */
var SelectEvent = /*@__PURE__*/(function (Event) {
  function SelectEvent(type, selected, deselected, mapBrowserEvent) {
    Event.call(this, type);

    /**
     * Selected features array.
     * @type {Array<import("../Feature.js").default>}
     * @api
     */
    this.selected = selected;

    /**
     * Deselected features array.
     * @type {Array<import("../Feature.js").default>}
     * @api
     */
    this.deselected = deselected;

    /**
     * Associated {@link module:ol/MapBrowserEvent}.
     * @type {import("../MapBrowserEvent.js").default}
     * @api
     */
    this.mapBrowserEvent = mapBrowserEvent;

  }

  if ( Event ) SelectEvent.__proto__ = Event;
  SelectEvent.prototype = Object.create( Event && Event.prototype );
  SelectEvent.prototype.constructor = SelectEvent;

  return SelectEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_4__["default"]));


/**
 * @classdesc
 * Interaction for selecting vector features. By default, selected features are
 * styled differently, so this interaction can be used for visual highlighting,
 * as well as selecting features for other actions, such as modification or
 * output. There are three ways of controlling which features are selected:
 * using the browser event as defined by the `condition` and optionally the
 * `toggle`, `add`/`remove`, and `multi` options; a `layers` filter; and a
 * further feature filter using the `filter` option.
 *
 * Selected features are added to an internal unmanaged layer.
 *
 * @fires SelectEvent
 * @api
 */
var Select = /*@__PURE__*/(function (Interaction) {
  function Select(opt_options) {

    Interaction.call(this, {
      handleEvent: handleEvent
    });

    var options = opt_options ? opt_options : {};

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_5__["singleClick"];

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.addCondition_ = options.addCondition ? options.addCondition : _events_condition_js__WEBPACK_IMPORTED_MODULE_5__["never"];

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.removeCondition_ = options.removeCondition ? options.removeCondition : _events_condition_js__WEBPACK_IMPORTED_MODULE_5__["never"];

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.toggleCondition_ = options.toggleCondition ? options.toggleCondition : _events_condition_js__WEBPACK_IMPORTED_MODULE_5__["shiftKeyOnly"];

    /**
     * @private
     * @type {boolean}
     */
    this.multi_ = options.multi ? options.multi : false;

    /**
     * @private
     * @type {FilterFunction}
     */
    this.filter_ = options.filter ? options.filter : _functions_js__WEBPACK_IMPORTED_MODULE_6__["TRUE"];

    /**
     * @private
     * @type {number}
     */
    this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;

    var featureOverlay = new _layer_Vector_js__WEBPACK_IMPORTED_MODULE_9__["default"]({
      source: new _source_Vector_js__WEBPACK_IMPORTED_MODULE_11__["default"]({
        useSpatialIndex: false,
        features: options.features,
        wrapX: options.wrapX
      }),
      style: options.style ? options.style :
        getDefaultStyleFunction(),
      updateWhileAnimating: true,
      updateWhileInteracting: true
    });

    /**
     * @private
     * @type {VectorLayer}
     */
    this.featureOverlay_ = featureOverlay;

    /** @type {function(import("../layer/Layer.js").default): boolean} */
    var layerFilter;
    if (options.layers) {
      if (typeof options.layers === 'function') {
        layerFilter = options.layers;
      } else {
        var layers = options.layers;
        layerFilter = function(layer) {
          return Object(_array_js__WEBPACK_IMPORTED_MODULE_2__["includes"])(layers, layer);
        };
      }
    } else {
      layerFilter = _functions_js__WEBPACK_IMPORTED_MODULE_6__["TRUE"];
    }

    /**
     * @private
     * @type {function(import("../layer/Layer.js").default): boolean}
     */
    this.layerFilter_ = layerFilter;

    /**
     * An association between selected feature (key)
     * and layer (value)
     * @private
     * @type {Object<string, import("../layer/Layer.js").default>}
     */
    this.featureLayerAssociation_ = {};

    var features = this.getFeatures();
    Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(features, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].ADD,
      this.addFeature_, this);
    Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(features, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].REMOVE,
      this.removeFeature_, this);
  }

  if ( Interaction ) Select.__proto__ = Interaction;
  Select.prototype = Object.create( Interaction && Interaction.prototype );
  Select.prototype.constructor = Select;

  /**
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {import("../layer/Layer.js").default} layer Layer.
   * @private
   */
  Select.prototype.addFeatureLayerAssociation_ = function addFeatureLayerAssociation_ (feature, layer) {
    this.featureLayerAssociation_[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature)] = layer;
  };

  /**
   * Get the selected features.
   * @return {import("../Collection.js").default<import("../Feature.js").default>} Features collection.
   * @api
   */
  Select.prototype.getFeatures = function getFeatures () {
    return /** @type {VectorSource} */ (this.featureOverlay_.getSource()).getFeaturesCollection();
  };

  /**
   * Returns the Hit-detection tolerance.
   * @returns {number} Hit tolerance in pixels.
   * @api
   */
  Select.prototype.getHitTolerance = function getHitTolerance () {
    return this.hitTolerance_;
  };

  /**
   * Returns the associated {@link module:ol/layer/Vector~Vector vectorlayer} of
   * the (last) selected feature. Note that this will not work with any
   * programmatic method like pushing features to
   * {@link module:ol/interaction/Select~Select#getFeatures collection}.
   * @param {import("../Feature.js").FeatureLike} feature Feature
   * @return {VectorLayer} Layer.
   * @api
   */
  Select.prototype.getLayer = function getLayer (feature) {
    return (
      /** @type {VectorLayer} */ (this.featureLayerAssociation_[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature)])
    );
  };

  /**
   * Get the overlay layer that this interaction renders selected features to.
   * @return {VectorLayer} Overlay layer.
   * @api
   */
  Select.prototype.getOverlay = function getOverlay () {
    return this.featureOverlay_;
  };

  /**
   * Hit-detection tolerance. Pixels inside the radius around the given position
   * will be checked for features. This only works for the canvas renderer and
   * not for WebGL.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @api
   */
  Select.prototype.setHitTolerance = function setHitTolerance (hitTolerance) {
    this.hitTolerance_ = hitTolerance;
  };

  /**
   * Remove the interaction from its current map, if any,  and attach it to a new
   * map, if any. Pass `null` to just remove the interaction from the current map.
   * @param {import("../PluggableMap.js").default} map Map.
   * @override
   * @api
   */
  Select.prototype.setMap = function setMap (map) {
    var currentMap = this.getMap();
    var selectedFeatures = this.getFeatures();
    if (currentMap) {
      selectedFeatures.forEach(currentMap.unskipFeature.bind(currentMap));
    }
    Interaction.prototype.setMap.call(this, map);
    this.featureOverlay_.setMap(map);
    if (map) {
      selectedFeatures.forEach(map.skipFeature.bind(map));
    }
  };

  /**
   * @param {import("../Collection.js").CollectionEvent} evt Event.
   * @private
   */
  Select.prototype.addFeature_ = function addFeature_ (evt) {
    var map = this.getMap();
    if (map) {
      map.skipFeature(/** @type {import("../Feature.js").default} */ (evt.element));
    }
  };

  /**
   * @param {import("../Collection.js").CollectionEvent} evt Event.
   * @private
   */
  Select.prototype.removeFeature_ = function removeFeature_ (evt) {
    var map = this.getMap();
    if (map) {
      map.unskipFeature(/** @type {import("../Feature.js").default} */ (evt.element));
    }
  };

  /**
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @private
   */
  Select.prototype.removeFeatureLayerAssociation_ = function removeFeatureLayerAssociation_ (feature) {
    delete this.featureLayerAssociation_[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature)];
  };

  return Select;
}(_Interaction_js__WEBPACK_IMPORTED_MODULE_8__["default"]));


/**
 * Handles the {@link module:ol/MapBrowserEvent map browser event} and may change the
 * selected state of features.
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} `false` to stop event propagation.
 * @this {Select}
 */
function handleEvent(mapBrowserEvent) {
  if (!this.condition_(mapBrowserEvent)) {
    return true;
  }
  var add = this.addCondition_(mapBrowserEvent);
  var remove = this.removeCondition_(mapBrowserEvent);
  var toggle = this.toggleCondition_(mapBrowserEvent);
  var set = !add && !remove && !toggle;
  var map = mapBrowserEvent.map;
  var features = this.getFeatures();
  var deselected = [];
  var selected = [];
  if (set) {
    // Replace the currently selected feature(s) with the feature(s) at the
    // pixel, or clear the selected feature(s) if there is no feature at
    // the pixel.
    Object(_obj_js__WEBPACK_IMPORTED_MODULE_10__["clear"])(this.featureLayerAssociation_);
    map.forEachFeatureAtPixel(mapBrowserEvent.pixel,
      (
        /**
         * @param {import("../Feature.js").FeatureLike} feature Feature.
         * @param {import("../layer/Layer.js").default} layer Layer.
         * @return {boolean|undefined} Continue to iterate over the features.
         */
        function(feature, layer) {
          if (this.filter_(feature, layer)) {
            selected.push(feature);
            this.addFeatureLayerAssociation_(feature, layer);
            return !this.multi_;
          }
        }).bind(this), {
        layerFilter: this.layerFilter_,
        hitTolerance: this.hitTolerance_
      });
    for (var i = features.getLength() - 1; i >= 0; --i) {
      var feature = features.item(i);
      var index = selected.indexOf(feature);
      if (index > -1) {
        // feature is already selected
        selected.splice(index, 1);
      } else {
        features.remove(feature);
        deselected.push(feature);
      }
    }
    if (selected.length !== 0) {
      features.extend(selected);
    }
  } else {
    // Modify the currently selected feature(s).
    map.forEachFeatureAtPixel(mapBrowserEvent.pixel,
      (
        /**
         * @param {import("../Feature.js").FeatureLike} feature Feature.
         * @param {import("../layer/Layer.js").default} layer Layer.
         * @return {boolean|undefined} Continue to iterate over the features.
         */
        function(feature, layer) {
          if (this.filter_(feature, layer)) {
            if ((add || toggle) && !Object(_array_js__WEBPACK_IMPORTED_MODULE_2__["includes"])(features.getArray(), feature)) {
              selected.push(feature);
              this.addFeatureLayerAssociation_(feature, layer);
            } else if ((remove || toggle) && Object(_array_js__WEBPACK_IMPORTED_MODULE_2__["includes"])(features.getArray(), feature)) {
              deselected.push(feature);
              this.removeFeatureLayerAssociation_(feature);
            }
            return !this.multi_;
          }
        }).bind(this), {
        layerFilter: this.layerFilter_,
        hitTolerance: this.hitTolerance_
      });
    for (var j = deselected.length - 1; j >= 0; --j) {
      features.remove(deselected[j]);
    }
    features.extend(selected);
  }
  if (selected.length > 0 || deselected.length > 0) {
    this.dispatchEvent(
      new SelectEvent(SelectEventType.SELECT,
        selected, deselected, mapBrowserEvent));
  }
  return Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_5__["pointerMove"])(mapBrowserEvent);
}


/**
 * @return {import("../style/Style.js").StyleFunction} Styles.
 */
function getDefaultStyleFunction() {
  var styles = Object(_style_Style_js__WEBPACK_IMPORTED_MODULE_12__["createEditingStyle"])();
  Object(_array_js__WEBPACK_IMPORTED_MODULE_2__["extend"])(styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_7__["default"].POLYGON], styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_7__["default"].LINE_STRING]);
  Object(_array_js__WEBPACK_IMPORTED_MODULE_2__["extend"])(styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_7__["default"].GEOMETRY_COLLECTION], styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_7__["default"].LINE_STRING]);

  return function(feature, resolution) {
    if (!feature.getGeometry()) {
      return null;
    }
    return styles[feature.getGeometry().getType()];
  };
}


/* harmony default export */ __webpack_exports__["default"] = (Select);

//# sourceMappingURL=Select.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/Snap.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/interaction/Snap.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../CollectionEventType.js */ "./node_modules/ol/CollectionEventType.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../coordinate.js */ "./node_modules/ol/coordinate.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../geom/Polygon.js */ "./node_modules/ol/geom/Polygon.js");
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../source/VectorEventType.js */ "./node_modules/ol/source/VectorEventType.js");
/* harmony import */ var _structs_RBush_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../structs/RBush.js */ "./node_modules/ol/structs/RBush.js");
/**
 * @module ol/interaction/Snap
 */















/**
 * @typedef {Object} Result
 * @property {boolean} snapped
 * @property {import("../coordinate.js").Coordinate|null} vertex
 * @property {import("../pixel.js").Pixel|null} vertexPixel
 */


/**
 * @typedef {Object} SegmentData
 * @property {import("../Feature.js").default} feature
 * @property {Array<import("../coordinate.js").Coordinate>} segment
 */


/**
 * @typedef {Object} Options
 * @property {import("../Collection.js").default<import("../Feature.js").default>} [features] Snap to these features. Either this option or source should be provided.
 * @property {boolean} [edge=true] Snap to edges.
 * @property {boolean} [vertex=true] Snap to vertices.
 * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or
 * vertex for snapping.
 * @property {import("../source/Vector.js").default} [source] Snap to features from this source. Either this option or features should be provided
 */


/**
 * @param  {import("../source/Vector.js").VectorSourceEvent|import("../Collection.js").CollectionEvent} evt Event.
 * @return {import("../Feature.js").default} Feature.
 */
function getFeatureFromEvent(evt) {
  if (/** @type {import("../source/Vector.js").VectorSourceEvent} */ (evt).feature) {
    return /** @type {import("../source/Vector.js").VectorSourceEvent} */ (evt).feature;
  } else if (/** @type {import("../Collection.js").CollectionEvent} */ (evt).element) {
    return /** @type {import("../Feature.js").default} */ (/** @type {import("../Collection.js").CollectionEvent} */ (evt).element);
  }

}

/**
 * @classdesc
 * Handles snapping of vector features while modifying or drawing them.  The
 * features can come from a {@link module:ol/source/Vector} or {@link module:ol/Collection~Collection}
 * Any interaction object that allows the user to interact
 * with the features using the mouse can benefit from the snapping, as long
 * as it is added before.
 *
 * The snap interaction modifies map browser event `coordinate` and `pixel`
 * properties to force the snap to occur to any interaction that them.
 *
 * Example:
 *
 *     import Snap from 'ol/interaction/Snap';
 *
 *     var snap = new Snap({
 *       source: source
 *     });
 *
 * @api
 */
var Snap = /*@__PURE__*/(function (PointerInteraction) {
  function Snap(opt_options) {

    var options = opt_options ? opt_options : {};

    var pointerOptions = /** @type {import("./Pointer.js").Options} */ (options);

    if (!pointerOptions.handleDownEvent) {
      pointerOptions.handleDownEvent = _functions_js__WEBPACK_IMPORTED_MODULE_6__["TRUE"];
    }

    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = _functions_js__WEBPACK_IMPORTED_MODULE_6__["FALSE"];
    }

    PointerInteraction.call(this, pointerOptions);

    /**
     * @type {import("../source/Vector.js").default}
     * @private
     */
    this.source_ = options.source ? options.source : null;

    /**
     * @private
     * @type {boolean}
     */
    this.vertex_ = options.vertex !== undefined ? options.vertex : true;

    /**
     * @private
     * @type {boolean}
     */
    this.edge_ = options.edge !== undefined ? options.edge : true;

    /**
     * @type {import("../Collection.js").default<import("../Feature.js").default>}
     * @private
     */
    this.features_ = options.features ? options.features : null;

    /**
     * @type {Array<import("../events.js").EventsKey>}
     * @private
     */
    this.featuresListenerKeys_ = [];

    /**
     * @type {Object<string, import("../events.js").EventsKey>}
     * @private
     */
    this.featureChangeListenerKeys_ = {};

    /**
     * Extents are preserved so indexed segment can be quickly removed
     * when its feature geometry changes
     * @type {Object<string, import("../extent.js").Extent>}
     * @private
     */
    this.indexedFeaturesExtents_ = {};

    /**
     * If a feature geometry changes while a pointer drag|move event occurs, the
     * feature doesn't get updated right away.  It will be at the next 'pointerup'
     * event fired.
     * @type {!Object<string, import("../Feature.js").default>}
     * @private
     */
    this.pendingFeatures_ = {};

    /**
     * Used for distance sorting in sortByDistance_
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */
    this.pixelCoordinate_ = null;

    /**
     * @type {number}
     * @private
     */
    this.pixelTolerance_ = options.pixelTolerance !== undefined ?
      options.pixelTolerance : 10;

    /**
     * @type {function(SegmentData, SegmentData): number}
     * @private
     */
    this.sortByDistance_ = sortByDistance.bind(this);


    /**
    * Segment RTree for each layer
    * @type {import("../structs/RBush.js").default<SegmentData>}
    * @private
    */
    this.rBush_ = new _structs_RBush_js__WEBPACK_IMPORTED_MODULE_12__["default"]();


    /**
    * @const
    * @private
    * @type {Object<string, function(import("../Feature.js").default, import("../geom/Geometry.js").default)>}
    */
    this.SEGMENT_WRITERS_ = {
      'Point': this.writePointGeometry_,
      'LineString': this.writeLineStringGeometry_,
      'LinearRing': this.writeLineStringGeometry_,
      'Polygon': this.writePolygonGeometry_,
      'MultiPoint': this.writeMultiPointGeometry_,
      'MultiLineString': this.writeMultiLineStringGeometry_,
      'MultiPolygon': this.writeMultiPolygonGeometry_,
      'GeometryCollection': this.writeGeometryCollectionGeometry_,
      'Circle': this.writeCircleGeometry_
    };
  }

  if ( PointerInteraction ) Snap.__proto__ = PointerInteraction;
  Snap.prototype = Object.create( PointerInteraction && PointerInteraction.prototype );
  Snap.prototype.constructor = Snap;

  /**
   * Add a feature to the collection of features that we may snap to.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {boolean=} opt_listen Whether to listen to the feature change or not
   *     Defaults to `true`.
   * @api
   */
  Snap.prototype.addFeature = function addFeature (feature, opt_listen) {
    var register = opt_listen !== undefined ? opt_listen : true;
    var feature_uid = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature);
    var geometry = feature.getGeometry();
    if (geometry) {
      var segmentWriter = this.SEGMENT_WRITERS_[geometry.getType()];
      if (segmentWriter) {
        this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["createEmpty"])());
        segmentWriter.call(this, feature, geometry);
      }
    }

    if (register) {
      this.featureChangeListenerKeys_[feature_uid] = Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(
        feature,
        _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].CHANGE,
        this.handleFeatureChange_, this);
    }
  };

  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @private
   */
  Snap.prototype.forEachFeatureAdd_ = function forEachFeatureAdd_ (feature) {
    this.addFeature(feature);
  };

  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @private
   */
  Snap.prototype.forEachFeatureRemove_ = function forEachFeatureRemove_ (feature) {
    this.removeFeature(feature);
  };

  /**
   * @return {import("../Collection.js").default<import("../Feature.js").default>|Array<import("../Feature.js").default>} Features.
   * @private
   */
  Snap.prototype.getFeatures_ = function getFeatures_ () {
    var features;
    if (this.features_) {
      features = this.features_;
    } else if (this.source_) {
      features = this.source_.getFeatures();
    }
    return features;
  };

  /**
   * @inheritDoc
   */
  Snap.prototype.handleEvent = function handleEvent (evt) {
    var result = this.snapTo(evt.pixel, evt.coordinate, evt.map);
    if (result.snapped) {
      evt.coordinate = result.vertex.slice(0, 2);
      evt.pixel = result.vertexPixel;
    }
    return PointerInteraction.prototype.handleEvent.call(this, evt);
  };

  /**
   * @param {import("../source/Vector.js").VectorSourceEvent|import("../Collection.js").CollectionEvent} evt Event.
   * @private
   */
  Snap.prototype.handleFeatureAdd_ = function handleFeatureAdd_ (evt) {
    var feature = getFeatureFromEvent(evt);
    this.addFeature(feature);
  };

  /**
   * @param {import("../source/Vector.js").VectorSourceEvent|import("../Collection.js").CollectionEvent} evt Event.
   * @private
   */
  Snap.prototype.handleFeatureRemove_ = function handleFeatureRemove_ (evt) {
    var feature = getFeatureFromEvent(evt);
    this.removeFeature(feature);
  };

  /**
   * @param {import("../events/Event.js").default} evt Event.
   * @private
   */
  Snap.prototype.handleFeatureChange_ = function handleFeatureChange_ (evt) {
    var feature = /** @type {import("../Feature.js").default} */ (evt.target);
    if (this.handlingDownUpSequence) {
      var uid = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature);
      if (!(uid in this.pendingFeatures_)) {
        this.pendingFeatures_[uid] = feature;
      }
    } else {
      this.updateFeature_(feature);
    }
  };

  /**
   * @inheritDoc
   */
  Snap.prototype.handleUpEvent = function handleUpEvent (evt) {
    var featuresToUpdate = Object(_obj_js__WEBPACK_IMPORTED_MODULE_10__["getValues"])(this.pendingFeatures_);
    if (featuresToUpdate.length) {
      featuresToUpdate.forEach(this.updateFeature_.bind(this));
      this.pendingFeatures_ = {};
    }
    return false;
  };

  /**
   * Remove a feature from the collection of features that we may snap to.
   * @param {import("../Feature.js").default} feature Feature
   * @param {boolean=} opt_unlisten Whether to unlisten to the feature change
   *     or not. Defaults to `true`.
   * @api
   */
  Snap.prototype.removeFeature = function removeFeature (feature, opt_unlisten) {
    var unregister = opt_unlisten !== undefined ? opt_unlisten : true;
    var feature_uid = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature);
    var extent = this.indexedFeaturesExtents_[feature_uid];
    if (extent) {
      var rBush = this.rBush_;
      var nodesToRemove = [];
      rBush.forEachInExtent(extent, function(node) {
        if (feature === node.feature) {
          nodesToRemove.push(node);
        }
      });
      for (var i = nodesToRemove.length - 1; i >= 0; --i) {
        rBush.remove(nodesToRemove[i]);
      }
    }

    if (unregister) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["unlistenByKey"])(this.featureChangeListenerKeys_[feature_uid]);
      delete this.featureChangeListenerKeys_[feature_uid];
    }
  };

  /**
   * @inheritDoc
   */
  Snap.prototype.setMap = function setMap (map) {
    var currentMap = this.getMap();
    var keys = this.featuresListenerKeys_;
    var features = /** @type {Array<import("../Feature.js").default>} */ (this.getFeatures_());

    if (currentMap) {
      keys.forEach(_events_js__WEBPACK_IMPORTED_MODULE_3__["unlistenByKey"]);
      keys.length = 0;
      features.forEach(this.forEachFeatureRemove_.bind(this));
    }
    PointerInteraction.prototype.setMap.call(this, map);

    if (map) {
      if (this.features_) {
        keys.push(
          Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(this.features_, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].ADD,
            this.handleFeatureAdd_, this),
          Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(this.features_, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].REMOVE,
            this.handleFeatureRemove_, this)
        );
      } else if (this.source_) {
        keys.push(
          Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(this.source_, _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_11__["default"].ADDFEATURE,
            this.handleFeatureAdd_, this),
          Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(this.source_, _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_11__["default"].REMOVEFEATURE,
            this.handleFeatureRemove_, this)
        );
      }
      features.forEach(this.forEachFeatureAdd_.bind(this));
    }
  };

  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel
   * @param {import("../coordinate.js").Coordinate} pixelCoordinate Coordinate
   * @param {import("../PluggableMap.js").default} map Map.
   * @return {Result} Snap result
   */
  Snap.prototype.snapTo = function snapTo (pixel, pixelCoordinate, map) {

    var lowerLeft = map.getCoordinateFromPixel(
      [pixel[0] - this.pixelTolerance_, pixel[1] + this.pixelTolerance_]);
    var upperRight = map.getCoordinateFromPixel(
      [pixel[0] + this.pixelTolerance_, pixel[1] - this.pixelTolerance_]);
    var box = Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["boundingExtent"])([lowerLeft, upperRight]);

    var segments = this.rBush_.getInExtent(box);

    // If snapping on vertices only, don't consider circles
    if (this.vertex_ && !this.edge_) {
      segments = segments.filter(function(segment) {
        return segment.feature.getGeometry().getType() !==
            _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_7__["default"].CIRCLE;
      });
    }

    var snappedToVertex = false;
    var snapped = false;
    var vertex = null;
    var vertexPixel = null;
    var dist, pixel1, pixel2, squaredDist1, squaredDist2;
    if (segments.length > 0) {
      this.pixelCoordinate_ = pixelCoordinate;
      segments.sort(this.sortByDistance_);
      var closestSegment = segments[0].segment;
      var isCircle = segments[0].feature.getGeometry().getType() ===
          _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_7__["default"].CIRCLE;
      if (this.vertex_ && !this.edge_) {
        pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
        pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
        squaredDist1 = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_2__["squaredDistance"])(pixel, pixel1);
        squaredDist2 = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_2__["squaredDistance"])(pixel, pixel2);
        dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
        snappedToVertex = dist <= this.pixelTolerance_;
        if (snappedToVertex) {
          snapped = true;
          vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
          vertexPixel = map.getPixelFromCoordinate(vertex);
        }
      } else if (this.edge_) {
        if (isCircle) {
          vertex = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_2__["closestOnCircle"])(pixelCoordinate,
            /** @type {import("../geom/Circle.js").default} */ (segments[0].feature.getGeometry()));
        } else {
          vertex = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_2__["closestOnSegment"])(pixelCoordinate, closestSegment);
        }
        vertexPixel = map.getPixelFromCoordinate(vertex);
        if (Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_2__["distance"])(pixel, vertexPixel) <= this.pixelTolerance_) {
          snapped = true;
          if (this.vertex_ && !isCircle) {
            pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
            pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
            squaredDist1 = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_2__["squaredDistance"])(vertexPixel, pixel1);
            squaredDist2 = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_2__["squaredDistance"])(vertexPixel, pixel2);
            dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
            snappedToVertex = dist <= this.pixelTolerance_;
            if (snappedToVertex) {
              vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
              vertexPixel = map.getPixelFromCoordinate(vertex);
            }
          }
        }
      }
      if (snapped) {
        vertexPixel = [Math.round(vertexPixel[0]), Math.round(vertexPixel[1])];
      }
    }
    return (
      /** @type {Result} */ ({
        snapped: snapped,
        vertex: vertex,
        vertexPixel: vertexPixel
      })
    );
  };

  /**
   * @param {import("../Feature.js").default} feature Feature
   * @private
   */
  Snap.prototype.updateFeature_ = function updateFeature_ (feature) {
    this.removeFeature(feature, false);
    this.addFeature(feature, false);
  };

  /**
   * @param {import("../Feature.js").default} feature Feature
   * @param {import("../geom/Circle.js").default} geometry Geometry.
   * @private
   */
  Snap.prototype.writeCircleGeometry_ = function writeCircleGeometry_ (feature, geometry) {
    var polygon = Object(_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_8__["fromCircle"])(geometry);
    var coordinates = polygon.getCoordinates()[0];
    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
      var segment = coordinates.slice(i, i + 2);
      var segmentData = /** @type {SegmentData} */ ({
        feature: feature,
        segment: segment
      });
      this.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["boundingExtent"])(segment), segmentData);
    }
  };

  /**
   * @param {import("../Feature.js").default} feature Feature
   * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
   * @private
   */
  Snap.prototype.writeGeometryCollectionGeometry_ = function writeGeometryCollectionGeometry_ (feature, geometry) {
    var geometries = geometry.getGeometriesArray();
    for (var i = 0; i < geometries.length; ++i) {
      var segmentWriter = this.SEGMENT_WRITERS_[geometries[i].getType()];
      if (segmentWriter) {
        segmentWriter.call(this, feature, geometries[i]);
      }
    }
  };

  /**
   * @param {import("../Feature.js").default} feature Feature
   * @param {import("../geom/LineString.js").default} geometry Geometry.
   * @private
   */
  Snap.prototype.writeLineStringGeometry_ = function writeLineStringGeometry_ (feature, geometry) {
    var coordinates = geometry.getCoordinates();
    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
      var segment = coordinates.slice(i, i + 2);
      var segmentData = /** @type {SegmentData} */ ({
        feature: feature,
        segment: segment
      });
      this.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["boundingExtent"])(segment), segmentData);
    }
  };

  /**
   * @param {import("../Feature.js").default} feature Feature
   * @param {import("../geom/MultiLineString.js").default} geometry Geometry.
   * @private
   */
  Snap.prototype.writeMultiLineStringGeometry_ = function writeMultiLineStringGeometry_ (feature, geometry) {
    var lines = geometry.getCoordinates();
    for (var j = 0, jj = lines.length; j < jj; ++j) {
      var coordinates = lines[j];
      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
        var segment = coordinates.slice(i, i + 2);
        var segmentData = /** @type {SegmentData} */ ({
          feature: feature,
          segment: segment
        });
        this.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["boundingExtent"])(segment), segmentData);
      }
    }
  };

  /**
   * @param {import("../Feature.js").default} feature Feature
   * @param {import("../geom/MultiPoint.js").default} geometry Geometry.
   * @private
   */
  Snap.prototype.writeMultiPointGeometry_ = function writeMultiPointGeometry_ (feature, geometry) {
    var points = geometry.getCoordinates();
    for (var i = 0, ii = points.length; i < ii; ++i) {
      var coordinates = points[i];
      var segmentData = /** @type {SegmentData} */ ({
        feature: feature,
        segment: [coordinates, coordinates]
      });
      this.rBush_.insert(geometry.getExtent(), segmentData);
    }
  };

  /**
   * @param {import("../Feature.js").default} feature Feature
   * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
   * @private
   */
  Snap.prototype.writeMultiPolygonGeometry_ = function writeMultiPolygonGeometry_ (feature, geometry) {
    var polygons = geometry.getCoordinates();
    for (var k = 0, kk = polygons.length; k < kk; ++k) {
      var rings = polygons[k];
      for (var j = 0, jj = rings.length; j < jj; ++j) {
        var coordinates = rings[j];
        for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
          var segment = coordinates.slice(i, i + 2);
          var segmentData = /** @type {SegmentData} */ ({
            feature: feature,
            segment: segment
          });
          this.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["boundingExtent"])(segment), segmentData);
        }
      }
    }
  };

  /**
   * @param {import("../Feature.js").default} feature Feature
   * @param {import("../geom/Point.js").default} geometry Geometry.
   * @private
   */
  Snap.prototype.writePointGeometry_ = function writePointGeometry_ (feature, geometry) {
    var coordinates = geometry.getCoordinates();
    var segmentData = /** @type {SegmentData} */ ({
      feature: feature,
      segment: [coordinates, coordinates]
    });
    this.rBush_.insert(geometry.getExtent(), segmentData);
  };

  /**
   * @param {import("../Feature.js").default} feature Feature
   * @param {import("../geom/Polygon.js").default} geometry Geometry.
   * @private
   */
  Snap.prototype.writePolygonGeometry_ = function writePolygonGeometry_ (feature, geometry) {
    var rings = geometry.getCoordinates();
    for (var j = 0, jj = rings.length; j < jj; ++j) {
      var coordinates = rings[j];
      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
        var segment = coordinates.slice(i, i + 2);
        var segmentData = /** @type {SegmentData} */ ({
          feature: feature,
          segment: segment
        });
        this.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["boundingExtent"])(segment), segmentData);
      }
    }
  };

  return Snap;
}(_Pointer_js__WEBPACK_IMPORTED_MODULE_9__["default"]));


/**
 * Sort segments by distance, helper function
 * @param {SegmentData} a The first segment data.
 * @param {SegmentData} b The second segment data.
 * @return {number} The difference in distance.
 * @this {Snap}
 */
function sortByDistance(a, b) {
  var deltaA = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_2__["squaredDistanceToSegment"])(this.pixelCoordinate_, a.segment);
  var deltaB = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_2__["squaredDistanceToSegment"])(this.pixelCoordinate_, b.segment);
  return deltaA - deltaB;
}

/* harmony default export */ __webpack_exports__["default"] = (Snap);

//# sourceMappingURL=Snap.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/Translate.js":
/*!**************************************************!*\
  !*** ./node_modules/ol/interaction/Translate.js ***!
  \**************************************************/
/*! exports provided: TranslateEvent, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TranslateEvent", function() { return TranslateEvent; });
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Collection.js */ "./node_modules/ol/Collection.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/* harmony import */ var _Property_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Property.js */ "./node_modules/ol/interaction/Property.js");
/**
 * @module ol/interaction/Translate
 */










/**
 * @enum {string}
 */
var TranslateEventType = {
  /**
   * Triggered upon feature translation start.
   * @event TranslateEvent#translatestart
   * @api
   */
  TRANSLATESTART: 'translatestart',
  /**
   * Triggered upon feature translation.
   * @event TranslateEvent#translating
   * @api
   */
  TRANSLATING: 'translating',
  /**
   * Triggered upon feature translation end.
   * @event TranslateEvent#translateend
   * @api
   */
  TRANSLATEEND: 'translateend'
};


/**
 * @typedef {Object} Options
 * @property {Collection<import("../Feature.js").default>} [features] Only features contained in this collection will be able to be translated. If
 * not specified, all features on the map will be able to be translated.
 * @property {Array<import("../layer/Layer.js").default>|function(import("../layer/Layer.js").default): boolean} [layers] A list of layers from which features should be
 * translated. Alternatively, a filter function can be provided. The
 * function will be called for each layer in the map and should return
 * `true` for layers that you want to be translatable. If the option is
 * absent, all visible layers will be considered translatable.
 * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside the radius around the given position
 * will be checked for features. This only works for the canvas renderer and
 * not for WebGL.
 */


/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Translate~Translate} instances
 * are instances of this type.
 */
var TranslateEvent = /*@__PURE__*/(function (Event) {
  function TranslateEvent(type, features, coordinate) {

    Event.call(this, type);

    /**
     * The features being translated.
     * @type {Collection<import("../Feature.js").default>}
     * @api
     */
    this.features = features;

    /**
     * The coordinate of the drag event.
     * @const
     * @type {import("../coordinate.js").Coordinate}
     * @api
     */
    this.coordinate = coordinate;

  }

  if ( Event ) TranslateEvent.__proto__ = Event;
  TranslateEvent.prototype = Object.create( Event && Event.prototype );
  TranslateEvent.prototype.constructor = TranslateEvent;

  return TranslateEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_3__["default"]));


/**
 * @classdesc
 * Interaction for translating (moving) features.
 *
 * @fires TranslateEvent
 * @api
 */
var Translate = /*@__PURE__*/(function (PointerInteraction) {
  function Translate(opt_options) {
    var options = opt_options ? opt_options : {};

    PointerInteraction.call(/** @type {import("./Pointer.js").Options} */ this, (options));

    /**
     * The last position we translated to.
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */
    this.lastCoordinate_ = null;


    /**
     * @type {Collection<import("../Feature.js").default>}
     * @private
     */
    this.features_ = options.features !== undefined ? options.features : null;

    /** @type {function(import("../layer/Layer.js").default): boolean} */
    var layerFilter;
    if (options.layers) {
      if (typeof options.layers === 'function') {
        layerFilter = options.layers;
      } else {
        var layers = options.layers;
        layerFilter = function(layer) {
          return Object(_array_js__WEBPACK_IMPORTED_MODULE_5__["includes"])(layers, layer);
        };
      }
    } else {
      layerFilter = _functions_js__WEBPACK_IMPORTED_MODULE_4__["TRUE"];
    }

    /**
     * @private
     * @type {function(import("../layer/Layer.js").default): boolean}
     */
    this.layerFilter_ = layerFilter;

    /**
     * @private
     * @type {number}
     */
    this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;

    /**
     * @type {import("../Feature.js").default}
     * @private
     */
    this.lastFeature_ = null;

    Object(_events_js__WEBPACK_IMPORTED_MODULE_2__["listen"])(this,
      Object(_Object_js__WEBPACK_IMPORTED_MODULE_1__["getChangeEventType"])(_Property_js__WEBPACK_IMPORTED_MODULE_7__["default"].ACTIVE),
      this.handleActiveChanged_, this);

  }

  if ( PointerInteraction ) Translate.__proto__ = PointerInteraction;
  Translate.prototype = Object.create( PointerInteraction && PointerInteraction.prototype );
  Translate.prototype.constructor = Translate;

  /**
   * @inheritDoc
   */
  Translate.prototype.handleDownEvent = function handleDownEvent (event) {
    this.lastFeature_ = this.featuresAtPixel_(event.pixel, event.map);
    if (!this.lastCoordinate_ && this.lastFeature_) {
      this.lastCoordinate_ = event.coordinate;
      this.handleMoveEvent(event);

      var features = this.features_ || new _Collection_js__WEBPACK_IMPORTED_MODULE_0__["default"]([this.lastFeature_]);

      this.dispatchEvent(
        new TranslateEvent(
          TranslateEventType.TRANSLATESTART, features,
          event.coordinate));
      return true;
    }
    return false;
  };

  /**
   * @inheritDoc
   */
  Translate.prototype.handleUpEvent = function handleUpEvent (event) {
    if (this.lastCoordinate_) {
      this.lastCoordinate_ = null;
      this.handleMoveEvent(event);

      var features = this.features_ || new _Collection_js__WEBPACK_IMPORTED_MODULE_0__["default"]([this.lastFeature_]);

      this.dispatchEvent(
        new TranslateEvent(
          TranslateEventType.TRANSLATEEND, features,
          event.coordinate));
      return true;
    }
    return false;
  };

  /**
   * @inheritDoc
   */
  Translate.prototype.handleDragEvent = function handleDragEvent (event) {
    if (this.lastCoordinate_) {
      var newCoordinate = event.coordinate;
      var deltaX = newCoordinate[0] - this.lastCoordinate_[0];
      var deltaY = newCoordinate[1] - this.lastCoordinate_[1];

      var features = this.features_ || new _Collection_js__WEBPACK_IMPORTED_MODULE_0__["default"]([this.lastFeature_]);

      features.forEach(function(feature) {
        var geom = feature.getGeometry();
        geom.translate(deltaX, deltaY);
        feature.setGeometry(geom);
      });

      this.lastCoordinate_ = newCoordinate;
      this.dispatchEvent(
        new TranslateEvent(
          TranslateEventType.TRANSLATING, features,
          newCoordinate));
    }
  };

  /**
   * @inheritDoc
   */
  Translate.prototype.handleMoveEvent = function handleMoveEvent (event) {
    var elem = event.map.getViewport();

    // Change the cursor to grab/grabbing if hovering any of the features managed
    // by the interaction
    if (this.featuresAtPixel_(event.pixel, event.map)) {
      elem.classList.remove(this.lastCoordinate_ ? 'ol-grab' : 'ol-grabbing');
      elem.classList.add(this.lastCoordinate_ ? 'ol-grabbing' : 'ol-grab');
    } else {
      elem.classList.remove('ol-grab', 'ol-grabbing');
    }
  };

  /**
   * Tests to see if the given coordinates intersects any of our selected
   * features.
   * @param {import("../pixel.js").Pixel} pixel Pixel coordinate to test for intersection.
   * @param {import("../PluggableMap.js").default} map Map to test the intersection on.
   * @return {import("../Feature.js").default} Returns the feature found at the specified pixel
   * coordinates.
   * @private
   */
  Translate.prototype.featuresAtPixel_ = function featuresAtPixel_ (pixel, map) {
    return map.forEachFeatureAtPixel(pixel,
      function(feature) {
        if (!this.features_ || Object(_array_js__WEBPACK_IMPORTED_MODULE_5__["includes"])(this.features_.getArray(), feature)) {
          return feature;
        }
      }.bind(this), {
        layerFilter: this.layerFilter_,
        hitTolerance: this.hitTolerance_
      });
  };

  /**
   * Returns the Hit-detection tolerance.
   * @returns {number} Hit tolerance in pixels.
   * @api
   */
  Translate.prototype.getHitTolerance = function getHitTolerance () {
    return this.hitTolerance_;
  };

  /**
   * Hit-detection tolerance. Pixels inside the radius around the given position
   * will be checked for features. This only works for the canvas renderer and
   * not for WebGL.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @api
   */
  Translate.prototype.setHitTolerance = function setHitTolerance (hitTolerance) {
    this.hitTolerance_ = hitTolerance;
  };

  /**
   * @inheritDoc
   */
  Translate.prototype.setMap = function setMap (map) {
    var oldMap = this.getMap();
    PointerInteraction.prototype.setMap.call(this, map);
    this.updateState_(oldMap);
  };

  /**
   * @private
   */
  Translate.prototype.handleActiveChanged_ = function handleActiveChanged_ () {
    this.updateState_(null);
  };

  /**
   * @param {import("../PluggableMap.js").default} oldMap Old map.
   * @private
   */
  Translate.prototype.updateState_ = function updateState_ (oldMap) {
    var map = this.getMap();
    var active = this.getActive();
    if (!map || !active) {
      map = map || oldMap;
      if (map) {
        var elem = map.getViewport();
        elem.classList.remove('ol-grab', 'ol-grabbing');
      }
    }
  };

  return Translate;
}(_Pointer_js__WEBPACK_IMPORTED_MODULE_6__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (Translate);

//# sourceMappingURL=Translate.js.map

/***/ }),

/***/ "./node_modules/ol/layer/Base.js":
/*!***************************************!*\
  !*** ./node_modules/ol/layer/Base.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _Property_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Property.js */ "./node_modules/ol/layer/Property.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/layer/Base
 */







/**
 * @typedef {Object} Options
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 */


/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Note that with {@link module:ol/layer/Base} and all its subclasses, any property set in
 * the options is set as a {@link module:ol/Object} property on the layer object, so
 * is observable, and has get/set accessors.
 *
 * @api
 */
var BaseLayer = /*@__PURE__*/(function (BaseObject) {
  function BaseLayer(options) {

    BaseObject.call(this);

    /**
     * @type {Object<string, *>}
     */
    var properties = Object(_obj_js__WEBPACK_IMPORTED_MODULE_4__["assign"])({}, options);
    properties[_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].OPACITY] =
       options.opacity !== undefined ? options.opacity : 1;
    properties[_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].VISIBLE] =
       options.visible !== undefined ? options.visible : true;
    properties[_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].Z_INDEX] = options.zIndex;
    properties[_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].MAX_RESOLUTION] =
       options.maxResolution !== undefined ? options.maxResolution : Infinity;
    properties[_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].MIN_RESOLUTION] =
       options.minResolution !== undefined ? options.minResolution : 0;

    this.setProperties(properties);

    /**
     * @type {import("./Layer.js").State}
     * @private
     */
    this.state_ = null;

    /**
     * The layer type.
     * @type {import("../LayerType.js").default}
     * @protected;
     */
    this.type;

  }

  if ( BaseObject ) BaseLayer.__proto__ = BaseObject;
  BaseLayer.prototype = Object.create( BaseObject && BaseObject.prototype );
  BaseLayer.prototype.constructor = BaseLayer;

  /**
   * Get the layer type (used when creating a layer renderer).
   * @return {import("../LayerType.js").default} The layer type.
   */
  BaseLayer.prototype.getType = function getType () {
    return this.type;
  };

  /**
   * @return {import("./Layer.js").State} Layer state.
   */
  BaseLayer.prototype.getLayerState = function getLayerState () {
    /** @type {import("./Layer.js").State} */
    var state = this.state_ || /** @type {?} */ ({
      layer: this,
      managed: true
    });
    state.opacity = Object(_math_js__WEBPACK_IMPORTED_MODULE_3__["clamp"])(this.getOpacity(), 0, 1);
    state.sourceState = this.getSourceState();
    state.visible = this.getVisible();
    state.extent = this.getExtent();
    state.zIndex = this.getZIndex() || 0;
    state.maxResolution = this.getMaxResolution();
    state.minResolution = Math.max(this.getMinResolution(), 0);
    this.state_ = state;

    return state;
  };

  /**
   * @abstract
   * @param {Array<import("./Layer.js").default>=} opt_array Array of layers (to be
   *     modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  BaseLayer.prototype.getLayersArray = function getLayersArray (opt_array) {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * @abstract
   * @param {Array<import("./Layer.js").State>=} opt_states Optional list of layer
   *     states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  BaseLayer.prototype.getLayerStatesArray = function getLayerStatesArray (opt_states) {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
   * will be visible regardless of extent.
   * @return {import("../extent.js").Extent|undefined} The layer extent.
   * @observable
   * @api
   */
  BaseLayer.prototype.getExtent = function getExtent () {
    return (
      /** @type {import("../extent.js").Extent|undefined} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].EXTENT))
    );
  };

  /**
   * Return the maximum resolution of the layer.
   * @return {number} The maximum resolution of the layer.
   * @observable
   * @api
   */
  BaseLayer.prototype.getMaxResolution = function getMaxResolution () {
    return /** @type {number} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].MAX_RESOLUTION));
  };

  /**
   * Return the minimum resolution of the layer.
   * @return {number} The minimum resolution of the layer.
   * @observable
   * @api
   */
  BaseLayer.prototype.getMinResolution = function getMinResolution () {
    return /** @type {number} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].MIN_RESOLUTION));
  };

  /**
   * Return the opacity of the layer (between 0 and 1).
   * @return {number} The opacity of the layer.
   * @observable
   * @api
   */
  BaseLayer.prototype.getOpacity = function getOpacity () {
    return /** @type {number} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].OPACITY));
  };

  /**
   * @abstract
   * @return {import("../source/State.js").default} Source state.
   */
  BaseLayer.prototype.getSourceState = function getSourceState () {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Return the visibility of the layer (`true` or `false`).
   * @return {boolean} The visibility of the layer.
   * @observable
   * @api
   */
  BaseLayer.prototype.getVisible = function getVisible () {
    return /** @type {boolean} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].VISIBLE));
  };

  /**
   * Return the Z-index of the layer, which is used to order layers before
   * rendering. The default Z-index is 0.
   * @return {number} The Z-index of the layer.
   * @observable
   * @api
   */
  BaseLayer.prototype.getZIndex = function getZIndex () {
    return /** @type {number} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].Z_INDEX));
  };

  /**
   * Set the extent at which the layer is visible.  If `undefined`, the layer
   * will be visible at all extents.
   * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
   * @observable
   * @api
   */
  BaseLayer.prototype.setExtent = function setExtent (extent) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].EXTENT, extent);
  };

  /**
   * Set the maximum resolution at which the layer is visible.
   * @param {number} maxResolution The maximum resolution of the layer.
   * @observable
   * @api
   */
  BaseLayer.prototype.setMaxResolution = function setMaxResolution (maxResolution) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].MAX_RESOLUTION, maxResolution);
  };

  /**
   * Set the minimum resolution at which the layer is visible.
   * @param {number} minResolution The minimum resolution of the layer.
   * @observable
   * @api
   */
  BaseLayer.prototype.setMinResolution = function setMinResolution (minResolution) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].MIN_RESOLUTION, minResolution);
  };

  /**
   * Set the opacity of the layer, allowed values range from 0 to 1.
   * @param {number} opacity The opacity of the layer.
   * @observable
   * @api
   */
  BaseLayer.prototype.setOpacity = function setOpacity (opacity) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].OPACITY, opacity);
  };

  /**
   * Set the visibility of the layer (`true` or `false`).
   * @param {boolean} visible The visibility of the layer.
   * @observable
   * @api
   */
  BaseLayer.prototype.setVisible = function setVisible (visible) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].VISIBLE, visible);
  };

  /**
   * Set Z-index of the layer, which is used to order layers before rendering.
   * The default Z-index is 0.
   * @param {number} zindex The z-index of the layer.
   * @observable
   * @api
   */
  BaseLayer.prototype.setZIndex = function setZIndex (zindex) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].Z_INDEX, zindex);
  };

  return BaseLayer;
}(_Object_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (BaseLayer);

//# sourceMappingURL=Base.js.map

/***/ }),

/***/ "./node_modules/ol/layer/Group.js":
/*!****************************************!*\
  !*** ./node_modules/ol/layer/Group.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Collection.js */ "./node_modules/ol/Collection.js");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../CollectionEventType.js */ "./node_modules/ol/CollectionEventType.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ObjectEventType.js */ "./node_modules/ol/ObjectEventType.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _Base_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Base.js */ "./node_modules/ol/layer/Base.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _source_State_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../source/State.js */ "./node_modules/ol/source/State.js");
/**
 * @module ol/layer/Group
 */














/**
 * @typedef {Object} Options
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {Array<import("./Base.js").default>|import("../Collection.js").default<import("./Base.js").default>} [layers] Child layers.
 */


/**
 * @enum {string}
 * @private
 */
var Property = {
  LAYERS: 'layers'
};


/**
 * @classdesc
 * A {@link module:ol/Collection~Collection} of layers that are handled together.
 *
 * A generic `change` event is triggered when the group/Collection changes.
 *
 * @api
 */
var LayerGroup = /*@__PURE__*/(function (BaseLayer) {
  function LayerGroup(opt_options) {

    var options = opt_options || {};
    var baseOptions = /** @type {Options} */ (Object(_obj_js__WEBPACK_IMPORTED_MODULE_10__["assign"])({}, options));
    delete baseOptions.layers;

    var layers = options.layers;

    BaseLayer.call(this, baseOptions);

    /**
     * @private
     * @type {Array<import("../events.js").EventsKey>}
     */
    this.layersListenerKeys_ = [];

    /**
     * @private
     * @type {Object<string, Array<import("../events.js").EventsKey>>}
     */
    this.listenerKeys_ = {};

    Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(this,
      Object(_Object_js__WEBPACK_IMPORTED_MODULE_3__["getChangeEventType"])(Property.LAYERS),
      this.handleLayersChanged_, this);

    if (layers) {
      if (Array.isArray(layers)) {
        layers = new _Collection_js__WEBPACK_IMPORTED_MODULE_1__["default"](layers.slice(), {unique: true});
      } else {
        Object(_asserts_js__WEBPACK_IMPORTED_MODULE_5__["assert"])(typeof /** @type {?} */ (layers).getArray === 'function',
          43); // Expected `layers` to be an array or a `Collection`
      }
    } else {
      layers = new _Collection_js__WEBPACK_IMPORTED_MODULE_1__["default"](undefined, {unique: true});
    }

    this.setLayers(layers);

  }

  if ( BaseLayer ) LayerGroup.__proto__ = BaseLayer;
  LayerGroup.prototype = Object.create( BaseLayer && BaseLayer.prototype );
  LayerGroup.prototype.constructor = LayerGroup;

  /**
   * @private
   */
  LayerGroup.prototype.handleLayerChange_ = function handleLayerChange_ () {
    this.changed();
  };

  /**
   * @private
   */
  LayerGroup.prototype.handleLayersChanged_ = function handleLayersChanged_ () {
    this.layersListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_6__["unlistenByKey"]);
    this.layersListenerKeys_.length = 0;

    var layers = this.getLayers();
    this.layersListenerKeys_.push(
      Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(layers, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].ADD, this.handleLayersAdd_, this),
      Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(layers, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].REMOVE, this.handleLayersRemove_, this)
    );

    for (var id in this.listenerKeys_) {
      this.listenerKeys_[id].forEach(_events_js__WEBPACK_IMPORTED_MODULE_6__["unlistenByKey"]);
    }
    Object(_obj_js__WEBPACK_IMPORTED_MODULE_10__["clear"])(this.listenerKeys_);

    var layersArray = layers.getArray();
    for (var i = 0, ii = layersArray.length; i < ii; i++) {
      var layer = layersArray[i];
      this.listenerKeys_[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(layer)] = [
        Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(layer, _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].PROPERTYCHANGE, this.handleLayerChange_, this),
        Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(layer, _events_EventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].CHANGE, this.handleLayerChange_, this)
      ];
    }

    this.changed();
  };

  /**
   * @param {import("../Collection.js").CollectionEvent} collectionEvent CollectionEvent.
   * @private
   */
  LayerGroup.prototype.handleLayersAdd_ = function handleLayersAdd_ (collectionEvent) {
    var layer = /** @type {import("./Base.js").default} */ (collectionEvent.element);
    this.listenerKeys_[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(layer)] = [
      Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(layer, _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].PROPERTYCHANGE, this.handleLayerChange_, this),
      Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(layer, _events_EventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].CHANGE, this.handleLayerChange_, this)
    ];
    this.changed();
  };

  /**
   * @param {import("../Collection.js").CollectionEvent} collectionEvent CollectionEvent.
   * @private
   */
  LayerGroup.prototype.handleLayersRemove_ = function handleLayersRemove_ (collectionEvent) {
    var layer = /** @type {import("./Base.js").default} */ (collectionEvent.element);
    var key = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(layer);
    this.listenerKeys_[key].forEach(_events_js__WEBPACK_IMPORTED_MODULE_6__["unlistenByKey"]);
    delete this.listenerKeys_[key];
    this.changed();
  };

  /**
   * Returns the {@link module:ol/Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @return {!import("../Collection.js").default<import("./Base.js").default>} Collection of
   *   {@link module:ol/layer/Base layers} that are part of this group.
   * @observable
   * @api
   */
  LayerGroup.prototype.getLayers = function getLayers () {
    return (
      /** @type {!import("../Collection.js").default<import("./Base.js").default>} */ (this.get(Property.LAYERS))
    );
  };

  /**
   * Set the {@link module:ol/Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @param {!import("../Collection.js").default<import("./Base.js").default>} layers Collection of
   *   {@link module:ol/layer/Base layers} that are part of this group.
   * @observable
   * @api
   */
  LayerGroup.prototype.setLayers = function setLayers (layers) {
    this.set(Property.LAYERS, layers);
  };

  /**
   * @inheritDoc
   */
  LayerGroup.prototype.getLayersArray = function getLayersArray (opt_array) {
    var array = opt_array !== undefined ? opt_array : [];
    this.getLayers().forEach(function(layer) {
      layer.getLayersArray(array);
    });
    return array;
  };

  /**
   * @inheritDoc
   */
  LayerGroup.prototype.getLayerStatesArray = function getLayerStatesArray (opt_states) {
    var states = opt_states !== undefined ? opt_states : [];

    var pos = states.length;

    this.getLayers().forEach(function(layer) {
      layer.getLayerStatesArray(states);
    });

    var ownLayerState = this.getLayerState();
    for (var i = pos, ii = states.length; i < ii; i++) {
      var layerState = states[i];
      layerState.opacity *= ownLayerState.opacity;
      layerState.visible = layerState.visible && ownLayerState.visible;
      layerState.maxResolution = Math.min(
        layerState.maxResolution, ownLayerState.maxResolution);
      layerState.minResolution = Math.max(
        layerState.minResolution, ownLayerState.minResolution);
      if (ownLayerState.extent !== undefined) {
        if (layerState.extent !== undefined) {
          layerState.extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_8__["getIntersection"])(layerState.extent, ownLayerState.extent);
        } else {
          layerState.extent = ownLayerState.extent;
        }
      }
    }

    return states;
  };

  /**
   * @inheritDoc
   */
  LayerGroup.prototype.getSourceState = function getSourceState () {
    return _source_State_js__WEBPACK_IMPORTED_MODULE_11__["default"].READY;
  };

  return LayerGroup;
}(_Base_js__WEBPACK_IMPORTED_MODULE_9__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (LayerGroup);

//# sourceMappingURL=Group.js.map

/***/ }),

/***/ "./node_modules/ol/layer/Layer.js":
/*!****************************************!*\
  !*** ./node_modules/ol/layer/Layer.js ***!
  \****************************************/
/*! exports provided: visibleAtResolution, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "visibleAtResolution", function() { return visibleAtResolution; });
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _Base_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Base.js */ "./node_modules/ol/layer/Base.js");
/* harmony import */ var _Property_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Property.js */ "./node_modules/ol/layer/Property.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _render_EventType_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../render/EventType.js */ "./node_modules/ol/render/EventType.js");
/* harmony import */ var _source_State_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../source/State.js */ "./node_modules/ol/source/State.js");
/**
 * @module ol/layer/Layer
 */











/**
 * @typedef {Object} Options
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {import("../source/Source.js").default} [source] Source for this layer.  If not provided to the constructor,
 * the source can be set by calling {@link module:ol/layer/Layer#setSource layer.setSource(source)} after
 * construction.
 * @property {import("../PluggableMap.js").default} [map] Map.
 */


/**
 * @typedef {Object} State
 * @property {import("./Base.js").default} layer
 * @property {number} opacity
 * @property {SourceState} sourceState
 * @property {boolean} visible
 * @property {boolean} managed
 * @property {import("../extent.js").Extent} [extent]
 * @property {number} zIndex
 * @property {number} maxResolution
 * @property {number} minResolution
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * A visual representation of raster or vector map data.
 * Layers group together those properties that pertain to how the data is to be
 * displayed, irrespective of the source of that data.
 *
 * Layers are usually added to a map with {@link module:ol/Map#addLayer}. Components
 * like {@link module:ol/interaction/Select~Select} use unmanaged layers
 * internally. These unmanaged layers are associated with the map using
 * {@link module:ol/layer/Layer~Layer#setMap} instead.
 *
 * A generic `change` event is fired when the state of the source changes.
 *
 * @fires import("../render/Event.js").RenderEvent
 */
var Layer = /*@__PURE__*/(function (BaseLayer) {
  function Layer(options) {

    var baseOptions = Object(_obj_js__WEBPACK_IMPORTED_MODULE_6__["assign"])({}, options);
    delete baseOptions.source;

    BaseLayer.call(this, baseOptions);

    /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */
    this.mapPrecomposeKey_ = null;

    /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */
    this.mapRenderKey_ = null;

    /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */
    this.sourceChangeKey_ = null;

    if (options.map) {
      this.setMap(options.map);
    }

    Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listen"])(this,
      Object(_Object_js__WEBPACK_IMPORTED_MODULE_3__["getChangeEventType"])(_Property_js__WEBPACK_IMPORTED_MODULE_5__["default"].SOURCE),
      this.handleSourcePropertyChange_, this);

    var source = options.source ? options.source : null;
    this.setSource(source);
  }

  if ( BaseLayer ) Layer.__proto__ = BaseLayer;
  Layer.prototype = Object.create( BaseLayer && BaseLayer.prototype );
  Layer.prototype.constructor = Layer;

  /**
   * @inheritDoc
   */
  Layer.prototype.getLayersArray = function getLayersArray (opt_array) {
    var array = opt_array ? opt_array : [];
    array.push(this);
    return array;
  };

  /**
   * @inheritDoc
   */
  Layer.prototype.getLayerStatesArray = function getLayerStatesArray (opt_states) {
    var states = opt_states ? opt_states : [];
    states.push(this.getLayerState());
    return states;
  };

  /**
   * Get the layer source.
   * @return {import("../source/Source.js").default} The layer source (or `null` if not yet set).
   * @observable
   * @api
   */
  Layer.prototype.getSource = function getSource () {
    var source = this.get(_Property_js__WEBPACK_IMPORTED_MODULE_5__["default"].SOURCE);
    return (
      /** @type {import("../source/Source.js").default} */ (source) || null
    );
  };

  /**
    * @inheritDoc
    */
  Layer.prototype.getSourceState = function getSourceState () {
    var source = this.getSource();
    return !source ? _source_State_js__WEBPACK_IMPORTED_MODULE_8__["default"].UNDEFINED : source.getState();
  };

  /**
   * @private
   */
  Layer.prototype.handleSourceChange_ = function handleSourceChange_ () {
    this.changed();
  };

  /**
   * @private
   */
  Layer.prototype.handleSourcePropertyChange_ = function handleSourcePropertyChange_ () {
    if (this.sourceChangeKey_) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["unlistenByKey"])(this.sourceChangeKey_);
      this.sourceChangeKey_ = null;
    }
    var source = this.getSource();
    if (source) {
      this.sourceChangeKey_ = Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listen"])(source,
        _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CHANGE, this.handleSourceChange_, this);
    }
    this.changed();
  };

  /**
   * Sets the layer to be rendered on top of other layers on a map. The map will
   * not manage this layer in its layers collection, and the callback in
   * {@link module:ol/Map#forEachLayerAtPixel} will receive `null` as layer. This
   * is useful for temporary layers. To remove an unmanaged layer from the map,
   * use `#setMap(null)`.
   *
   * To add the layer to a map and have it managed by the map, use
   * {@link module:ol/Map#addLayer} instead.
   * @param {import("../PluggableMap.js").default} map Map.
   * @api
   */
  Layer.prototype.setMap = function setMap (map) {
    if (this.mapPrecomposeKey_) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["unlistenByKey"])(this.mapPrecomposeKey_);
      this.mapPrecomposeKey_ = null;
    }
    if (!map) {
      this.changed();
    }
    if (this.mapRenderKey_) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["unlistenByKey"])(this.mapRenderKey_);
      this.mapRenderKey_ = null;
    }
    if (map) {
      this.mapPrecomposeKey_ = Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listen"])(map, _render_EventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].PRECOMPOSE, function(evt) {
        var renderEvent = /** @type {import("../render/Event.js").default} */ (evt);
        var layerState = this.getLayerState();
        layerState.managed = false;
        if (this.getZIndex() === undefined) {
          layerState.zIndex = Infinity;
        }
        renderEvent.frameState.layerStatesArray.push(layerState);
        renderEvent.frameState.layerStates[Object(_util_js__WEBPACK_IMPORTED_MODULE_2__["getUid"])(this)] = layerState;
      }, this);
      this.mapRenderKey_ = Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listen"])(this, _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CHANGE, map.render, map);
      this.changed();
    }
  };

  /**
   * Set the layer source.
   * @param {import("../source/Source.js").default} source The layer source.
   * @observable
   * @api
   */
  Layer.prototype.setSource = function setSource (source) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_5__["default"].SOURCE, source);
  };

  return Layer;
}(_Base_js__WEBPACK_IMPORTED_MODULE_4__["default"]));


/**
 * Return `true` if the layer is visible, and if the passed resolution is
 * between the layer's minResolution and maxResolution. The comparison is
 * inclusive for `minResolution` and exclusive for `maxResolution`.
 * @param {State} layerState Layer state.
 * @param {number} resolution Resolution.
 * @return {boolean} The layer is visible at the given resolution.
 */
function visibleAtResolution(layerState, resolution) {
  return layerState.visible && resolution >= layerState.minResolution &&
      resolution < layerState.maxResolution;
}


/* harmony default export */ __webpack_exports__["default"] = (Layer);

//# sourceMappingURL=Layer.js.map

/***/ }),

/***/ "./node_modules/ol/layer/Property.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/layer/Property.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/layer/Property
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  OPACITY: 'opacity',
  VISIBLE: 'visible',
  EXTENT: 'extent',
  Z_INDEX: 'zIndex',
  MAX_RESOLUTION: 'maxResolution',
  MIN_RESOLUTION: 'minResolution',
  SOURCE: 'source'
});

//# sourceMappingURL=Property.js.map

/***/ }),

/***/ "./node_modules/ol/layer/Tile.js":
/*!***************************************!*\
  !*** ./node_modules/ol/layer/Tile.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _LayerType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../LayerType.js */ "./node_modules/ol/LayerType.js");
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Layer.js */ "./node_modules/ol/layer/Layer.js");
/* harmony import */ var _TileProperty_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TileProperty.js */ "./node_modules/ol/layer/TileProperty.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/layer/Tile
 */






/**
 * @typedef {Object} Options
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`
 * means no preloading.
 * @property {import("../source/Tile.js").default} [source] Source for this layer.
 * @property {import("../PluggableMap.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link module:ol/Map#addLayer}.
 * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.
 */

/**
 * @classdesc
 * For layer sources that provide pre-rendered, tiled images in grids that are
 * organized by zoom levels for specific resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @api
 */
var TileLayer = /*@__PURE__*/(function (Layer) {
  function TileLayer(opt_options) {
    var options = opt_options ? opt_options : {};

    var baseOptions = Object(_obj_js__WEBPACK_IMPORTED_MODULE_3__["assign"])({}, options);

    delete baseOptions.preload;
    delete baseOptions.useInterimTilesOnError;
    Layer.call(this, baseOptions);

    this.setPreload(options.preload !== undefined ? options.preload : 0);
    this.setUseInterimTilesOnError(options.useInterimTilesOnError !== undefined ?
      options.useInterimTilesOnError : true);

    /**
    * The layer type.
    * @protected
    * @type {import("../LayerType.js").default}
    */
    this.type = _LayerType_js__WEBPACK_IMPORTED_MODULE_0__["default"].TILE;

  }

  if ( Layer ) TileLayer.__proto__ = Layer;
  TileLayer.prototype = Object.create( Layer && Layer.prototype );
  TileLayer.prototype.constructor = TileLayer;

  /**
  * Return the level as number to which we will preload tiles up to.
  * @return {number} The level to preload tiles up to.
  * @observable
  * @api
  */
  TileLayer.prototype.getPreload = function getPreload () {
    return /** @type {number} */ (this.get(_TileProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].PRELOAD));
  };

  /**
  * Set the level as number to which we will preload tiles up to.
  * @param {number} preload The level to preload tiles up to.
  * @observable
  * @api
  */
  TileLayer.prototype.setPreload = function setPreload (preload) {
    this.set(_TileProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].PRELOAD, preload);
  };

  /**
  * Whether we use interim tiles on error.
  * @return {boolean} Use interim tiles on error.
  * @observable
  * @api
  */
  TileLayer.prototype.getUseInterimTilesOnError = function getUseInterimTilesOnError () {
    return /** @type {boolean} */ (this.get(_TileProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].USE_INTERIM_TILES_ON_ERROR));
  };

  /**
  * Set whether we use interim tiles on error.
  * @param {boolean} useInterimTilesOnError Use interim tiles on error.
  * @observable
  * @api
  */
  TileLayer.prototype.setUseInterimTilesOnError = function setUseInterimTilesOnError (useInterimTilesOnError) {
    this.set(_TileProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
  };

  return TileLayer;
}(_Layer_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/**
 * Return the associated {@link module:ol/source/Tile tilesource} of the layer.
 * @function
 * @return {import("../source/Tile.js").default} Source.
 * @api
 */
TileLayer.prototype.getSource;


/* harmony default export */ __webpack_exports__["default"] = (TileLayer);

//# sourceMappingURL=Tile.js.map

/***/ }),

/***/ "./node_modules/ol/layer/TileProperty.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/layer/TileProperty.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/layer/TileProperty
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  PRELOAD: 'preload',
  USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError'
});

//# sourceMappingURL=TileProperty.js.map

/***/ }),

/***/ "./node_modules/ol/layer/Vector.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/layer/Vector.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _LayerType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../LayerType.js */ "./node_modules/ol/LayerType.js");
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Layer.js */ "./node_modules/ol/layer/Layer.js");
/* harmony import */ var _VectorRenderType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VectorRenderType.js */ "./node_modules/ol/layer/VectorRenderType.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _style_Style_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../style/Style.js */ "./node_modules/ol/style/Style.js");
/**
 * @module ol/layer/Vector
 */







/**
 * @typedef {Object} Options
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {import("../render.js").OrderFunction} [renderOrder] Render order. Function to be used when sorting
 * features before rendering. By default features are drawn in the order that they are created. Use
 * `null` to avoid the sort, but get an undefined draw order.
 * @property {number} [renderBuffer=100] The buffer in pixels around the viewport extent used by the
 * renderer when getting features from the vector source for the rendering or hit-detection.
 * Recommended value: the size of the largest symbol, line width or label.
 * @property {import("./VectorRenderType.js").default|string} [renderMode='vector'] Render mode for vector layers:
 *  * `'image'`: Vector layers are rendered as images. Great performance, but point symbols and
 *    texts are always rotated with the view and pixels are scaled during zoom animations.
 *  * `'vector'`: Vector layers are rendered as vectors. Most accurate rendering even during
 *    animations, but slower performance.
 * @property {import("../source/Vector.js").default} [source] Source.
 * @property {import("../PluggableMap.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link module:ol/Map#addLayer}.
 * @property {boolean} [declutter=false] Declutter images and text. Decluttering is applied to all
 * image and text styles, and the priority is defined by the z-index of the style. Lower z-index
 * means higher priority.
 * @property {import("../style/Style.js").StyleLike} [style] Layer style. See
 * {@link module:ol/style} for default style which will be used if this is not defined.
 * @property {boolean} [updateWhileAnimating=false] When set to `true` and `renderMode`
 * is `vector`, feature batches will be recreated during animations. This means that no
 * vectors will be shown clipped, but the setting will have a performance impact for large
 * amounts of vector data. When set to `false`, batches will be recreated when no animation
 * is active.
 * @property {boolean} [updateWhileInteracting=false] When set to `true` and `renderMode`
 * is `vector`, feature batches will be recreated during interactions. See also
 * `updateWhileAnimating`.
 */


/**
 * @enum {string}
 * @private
 */
var Property = {
  RENDER_ORDER: 'renderOrder'
};


/**
 * @classdesc
 * Vector data that is rendered client-side.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @api
 */
var VectorLayer = /*@__PURE__*/(function (Layer) {
  function VectorLayer(opt_options) {
    var options = opt_options ?
      opt_options : /** @type {Options} */ ({});

    var baseOptions = Object(_obj_js__WEBPACK_IMPORTED_MODULE_3__["assign"])({}, options);

    delete baseOptions.style;
    delete baseOptions.renderBuffer;
    delete baseOptions.updateWhileAnimating;
    delete baseOptions.updateWhileInteracting;
    Layer.call(this, baseOptions);

    /**
    * @private
    * @type {boolean}
    */
    this.declutter_ = options.declutter !== undefined ? options.declutter : false;

    /**
    * @type {number}
    * @private
    */
    this.renderBuffer_ = options.renderBuffer !== undefined ?
      options.renderBuffer : 100;

    /**
    * User provided style.
    * @type {import("../style/Style.js").StyleLike}
    * @private
    */
    this.style_ = null;

    /**
    * Style function for use within the library.
    * @type {import("../style/Style.js").StyleFunction|undefined}
    * @private
    */
    this.styleFunction_ = undefined;

    this.setStyle(options.style);

    /**
    * @type {boolean}
    * @private
    */
    this.updateWhileAnimating_ = options.updateWhileAnimating !== undefined ?
      options.updateWhileAnimating : false;

    /**
    * @type {boolean}
    * @private
    */
    this.updateWhileInteracting_ = options.updateWhileInteracting !== undefined ?
      options.updateWhileInteracting : false;

    /**
    * @private
    * @type {import("./VectorTileRenderType.js").default|string}
    */
    this.renderMode_ = options.renderMode || _VectorRenderType_js__WEBPACK_IMPORTED_MODULE_2__["default"].VECTOR;

    /**
    * The layer type.
    * @protected
    * @type {import("../LayerType.js").default}
    */
    this.type = _LayerType_js__WEBPACK_IMPORTED_MODULE_0__["default"].VECTOR;

  }

  if ( Layer ) VectorLayer.__proto__ = Layer;
  VectorLayer.prototype = Object.create( Layer && Layer.prototype );
  VectorLayer.prototype.constructor = VectorLayer;

  /**
  * @return {boolean} Declutter.
  */
  VectorLayer.prototype.getDeclutter = function getDeclutter () {
    return this.declutter_;
  };

  /**
  * @param {boolean} declutter Declutter.
  */
  VectorLayer.prototype.setDeclutter = function setDeclutter (declutter) {
    this.declutter_ = declutter;
  };

  /**
  * @return {number|undefined} Render buffer.
  */
  VectorLayer.prototype.getRenderBuffer = function getRenderBuffer () {
    return this.renderBuffer_;
  };

  /**
  * @return {function(import("../Feature.js").default, import("../Feature.js").default): number|null|undefined} Render
  *     order.
  */
  VectorLayer.prototype.getRenderOrder = function getRenderOrder () {
    return (
    /** @type {import("../render.js").OrderFunction|null|undefined} */ (this.get(Property.RENDER_ORDER))
    );
  };

  /**
  * Get the style for features.  This returns whatever was passed to the `style`
  * option at construction or to the `setStyle` method.
  * @return {import("../style/Style.js").StyleLike}
  *     Layer style.
  * @api
  */
  VectorLayer.prototype.getStyle = function getStyle () {
    return this.style_;
  };

  /**
  * Get the style function.
  * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
  * @api
  */
  VectorLayer.prototype.getStyleFunction = function getStyleFunction () {
    return this.styleFunction_;
  };

  /**
  * @return {boolean} Whether the rendered layer should be updated while
  *     animating.
  */
  VectorLayer.prototype.getUpdateWhileAnimating = function getUpdateWhileAnimating () {
    return this.updateWhileAnimating_;
  };

  /**
  * @return {boolean} Whether the rendered layer should be updated while
  *     interacting.
  */
  VectorLayer.prototype.getUpdateWhileInteracting = function getUpdateWhileInteracting () {
    return this.updateWhileInteracting_;
  };

  /**
  * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
  *     Render order.
  */
  VectorLayer.prototype.setRenderOrder = function setRenderOrder (renderOrder) {
    this.set(Property.RENDER_ORDER, renderOrder);
  };

  /**
  * Set the style for features.  This can be a single style object, an array
  * of styles, or a function that takes a feature and resolution and returns
  * an array of styles. If it is `undefined` the default style is used. If
  * it is `null` the layer has no style (a `null` style), so only features
  * that have their own styles will be rendered in the layer. See
  * {@link module:ol/style} for information on the default style.
  * @param {import("../style/Style.js").default|Array<import("../style/Style.js").default>|import("../style/Style.js").StyleFunction|null|undefined} style Layer style.
  * @api
  */
  VectorLayer.prototype.setStyle = function setStyle (style) {
    this.style_ = style !== undefined ? style : _style_Style_js__WEBPACK_IMPORTED_MODULE_4__["createDefaultStyle"];
    this.styleFunction_ = style === null ?
      undefined : Object(_style_Style_js__WEBPACK_IMPORTED_MODULE_4__["toFunction"])(this.style_);
    this.changed();
  };

  /**
  * @return {import("./VectorRenderType.js").default|string} The render mode.
  */
  VectorLayer.prototype.getRenderMode = function getRenderMode () {
    return this.renderMode_;
  };

  return VectorLayer;
}(_Layer_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/**
 * Return the associated {@link module:ol/source/Vector vectorsource} of the layer.
 * @function
 * @return {import("../source/Vector.js").default} Source.
 * @api
 */
VectorLayer.prototype.getSource;


/* harmony default export */ __webpack_exports__["default"] = (VectorLayer);

//# sourceMappingURL=Vector.js.map

/***/ }),

/***/ "./node_modules/ol/layer/VectorRenderType.js":
/*!***************************************************!*\
  !*** ./node_modules/ol/layer/VectorRenderType.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/layer/VectorRenderType
 */

/**
 * @enum {string}
 * Render mode for vector layers:
 *  * `'image'`: Vector layers are rendered as images. Great performance, but
 *    point symbols and texts are always rotated with the view and pixels are
 *    scaled during zoom animations.
 *  * `'vector'`: Vector layers are rendered as vectors. Most accurate rendering
 *    even during animations, but slower performance.
 * @api
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  IMAGE: 'image',
  VECTOR: 'vector'
});

//# sourceMappingURL=VectorRenderType.js.map

/***/ }),

/***/ "./node_modules/ol/layer/VectorTileRenderType.js":
/*!*******************************************************!*\
  !*** ./node_modules/ol/layer/VectorTileRenderType.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/layer/VectorTileRenderType
 */

/**
 * @enum {string}
 * Render mode for vector tiles:
 *  * `'image'`: Vector tiles are rendered as images. Great performance, but
 *    point symbols and texts are always rotated with the view and pixels are
 *    scaled during zoom animations.
 *  * `'hybrid'`: Polygon and line elements are rendered as images, so pixels
 *    are scaled during zoom animations. Point symbols and texts are accurately
 *    rendered as vectors and can stay upright on rotated views.
 *  * `'vector'`: Vector tiles are rendered as vectors. Most accurate rendering
 *    even during animations, but slower performance than the other options.
 * @api
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  IMAGE: 'image',
  HYBRID: 'hybrid',
  VECTOR: 'vector'
});

//# sourceMappingURL=VectorTileRenderType.js.map

/***/ }),

/***/ "./node_modules/ol/loadingstrategy.js":
/*!********************************************!*\
  !*** ./node_modules/ol/loadingstrategy.js ***!
  \********************************************/
/*! exports provided: all, bbox, tile */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "all", function() { return all; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bbox", function() { return bbox; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tile", function() { return tile; });
/**
 * @module ol/loadingstrategy
 */


/**
 * Strategy function for loading all features with a single request.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array<import("./extent.js").Extent>} Extents.
 * @api
 */
function all(extent, resolution) {
  return [[-Infinity, -Infinity, Infinity, Infinity]];
}


/**
 * Strategy function for loading features based on the view's extent and
 * resolution.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array<import("./extent.js").Extent>} Extents.
 * @api
 */
function bbox(extent, resolution) {
  return [extent];
}


/**
 * Creates a strategy function for loading features based on a tile grid.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {function(import("./extent.js").Extent, number): Array<import("./extent.js").Extent>} Loading strategy.
 * @api
 */
function tile(tileGrid) {
  return (
    /**
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @return {Array<import("./extent.js").Extent>} Extents.
     */
    function(extent, resolution) {
      var z = tileGrid.getZForResolution(resolution);
      var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
      /** @type {Array<import("./extent.js").Extent>} */
      var extents = [];
      /** @type {import("./tilecoord.js").TileCoord} */
      var tileCoord = [z, 0, 0];
      for (tileCoord[1] = tileRange.minX; tileCoord[1] <= tileRange.maxX; ++tileCoord[1]) {
        for (tileCoord[2] = tileRange.minY; tileCoord[2] <= tileRange.maxY; ++tileCoord[2]) {
          extents.push(tileGrid.getTileCoordExtent(tileCoord));
        }
      }
      return extents;
    }
  );
}

//# sourceMappingURL=loadingstrategy.js.map

/***/ }),

/***/ "./node_modules/ol/math.js":
/*!*********************************!*\
  !*** ./node_modules/ol/math.js ***!
  \*********************************/
/*! exports provided: clamp, cosh, roundUpToPowerOfTwo, squaredSegmentDistance, squaredDistance, solveLinearSystem, toDegrees, toRadians, modulo, lerp */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clamp", function() { return clamp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cosh", function() { return cosh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "roundUpToPowerOfTwo", function() { return roundUpToPowerOfTwo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredSegmentDistance", function() { return squaredSegmentDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "solveLinearSystem", function() { return solveLinearSystem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toDegrees", function() { return toDegrees; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toRadians", function() { return toRadians; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "modulo", function() { return modulo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/**
 * @module ol/math
 */


/**
 * Takes a number and clamps it to within the provided bounds.
 * @param {number} value The input number.
 * @param {number} min The minimum value to return.
 * @param {number} max The maximum value to return.
 * @return {number} The input number if it is within bounds, or the nearest
 *     number within the bounds.
 */
function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}


/**
 * Return the hyperbolic cosine of a given number. The method will use the
 * native `Math.cosh` function if it is available, otherwise the hyperbolic
 * cosine will be calculated via the reference implementation of the Mozilla
 * developer network.
 *
 * @param {number} x X.
 * @return {number} Hyperbolic cosine of x.
 */
var cosh = (function() {
  // Wrapped in a iife, to save the overhead of checking for the native
  // implementation on every invocation.
  var cosh;
  if ('cosh' in Math) {
    // The environment supports the native Math.cosh function, use it…
    cosh = Math.cosh;
  } else {
    // … else, use the reference implementation of MDN:
    cosh = function(x) {
      var y = /** @type {Math} */ (Math).exp(x);
      return (y + 1 / y) / 2;
    };
  }
  return cosh;
}());


/**
 * @param {number} x X.
 * @return {number} The smallest power of two greater than or equal to x.
 */
function roundUpToPowerOfTwo(x) {
  Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(0 < x, 29); // `x` must be greater than `0`
  return Math.pow(2, Math.ceil(Math.log(x) / Math.LN2));
}


/**
 * Returns the square of the closest distance between the point (x, y) and the
 * line segment (x1, y1) to (x2, y2).
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */
function squaredSegmentDistance(x, y, x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;
  if (dx !== 0 || dy !== 0) {
    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      x1 = x2;
      y1 = y2;
    } else if (t > 0) {
      x1 += dx * t;
      y1 += dy * t;
    }
  }
  return squaredDistance(x, y, x1, y1);
}


/**
 * Returns the square of the distance between the points (x1, y1) and (x2, y2).
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */
function squaredDistance(x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;
  return dx * dx + dy * dy;
}


/**
 * Solves system of linear equations using Gaussian elimination method.
 *
 * @param {Array<Array<number>>} mat Augmented matrix (n x n + 1 column)
 *                                     in row-major order.
 * @return {Array<number>} The resulting vector.
 */
function solveLinearSystem(mat) {
  var n = mat.length;

  for (var i = 0; i < n; i++) {
    // Find max in the i-th column (ignoring i - 1 first rows)
    var maxRow = i;
    var maxEl = Math.abs(mat[i][i]);
    for (var r = i + 1; r < n; r++) {
      var absValue = Math.abs(mat[r][i]);
      if (absValue > maxEl) {
        maxEl = absValue;
        maxRow = r;
      }
    }

    if (maxEl === 0) {
      return null; // matrix is singular
    }

    // Swap max row with i-th (current) row
    var tmp = mat[maxRow];
    mat[maxRow] = mat[i];
    mat[i] = tmp;

    // Subtract the i-th row to make all the remaining rows 0 in the i-th column
    for (var j = i + 1; j < n; j++) {
      var coef = -mat[j][i] / mat[i][i];
      for (var k = i; k < n + 1; k++) {
        if (i == k) {
          mat[j][k] = 0;
        } else {
          mat[j][k] += coef * mat[i][k];
        }
      }
    }
  }

  // Solve Ax=b for upper triangular matrix A (mat)
  var x = new Array(n);
  for (var l = n - 1; l >= 0; l--) {
    x[l] = mat[l][n] / mat[l][l];
    for (var m = l - 1; m >= 0; m--) {
      mat[m][n] -= mat[m][l] * x[l];
    }
  }
  return x;
}


/**
 * Converts radians to to degrees.
 *
 * @param {number} angleInRadians Angle in radians.
 * @return {number} Angle in degrees.
 */
function toDegrees(angleInRadians) {
  return angleInRadians * 180 / Math.PI;
}


/**
 * Converts degrees to radians.
 *
 * @param {number} angleInDegrees Angle in degrees.
 * @return {number} Angle in radians.
 */
function toRadians(angleInDegrees) {
  return angleInDegrees * Math.PI / 180;
}

/**
 * Returns the modulo of a / b, depending on the sign of b.
 *
 * @param {number} a Dividend.
 * @param {number} b Divisor.
 * @return {number} Modulo.
 */
function modulo(a, b) {
  var r = a % b;
  return r * b < 0 ? r + b : r;
}

/**
 * Calculates the linearly interpolated value of x between a and b.
 *
 * @param {number} a Number
 * @param {number} b Number
 * @param {number} x Value to be interpolated.
 * @return {number} Interpolated value.
 */
function lerp(a, b, x) {
  return a + x * (b - a);
}

//# sourceMappingURL=math.js.map

/***/ }),

/***/ "./node_modules/ol/obj.js":
/*!********************************!*\
  !*** ./node_modules/ol/obj.js ***!
  \********************************/
/*! exports provided: assign, clear, getValues, isEmpty */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assign", function() { return assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clear", function() { return clear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getValues", function() { return getValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEmpty", function() { return isEmpty; });
/**
 * @module ol/obj
 */


/**
 * Polyfill for Object.assign().  Assigns enumerable and own properties from
 * one or more source objects to a target object.
 * See https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign.
 *
 * @param {!Object} target The target object.
 * @param {...Object} var_sources The source object(s).
 * @return {!Object} The modified target object.
 */
var assign = (typeof Object.assign === 'function') ? Object.assign : function(target, var_sources) {
  var arguments$1 = arguments;

  if (target === undefined || target === null) {
    throw new TypeError('Cannot convert undefined or null to object');
  }

  var output = Object(target);
  for (var i = 1, ii = arguments.length; i < ii; ++i) {
    var source = arguments$1[i];
    if (source !== undefined && source !== null) {
      for (var key in source) {
        if (source.hasOwnProperty(key)) {
          output[key] = source[key];
        }
      }
    }
  }
  return output;
};


/**
 * Removes all properties from an object.
 * @param {Object} object The object to clear.
 */
function clear(object) {
  for (var property in object) {
    delete object[property];
  }
}


/**
 * Get an array of property values from an object.
 * @param {Object<K,V>} object The object from which to get the values.
 * @return {!Array<V>} The property values.
 * @template K,V
 */
function getValues(object) {
  var values = [];
  for (var property in object) {
    values.push(object[property]);
  }
  return values;
}


/**
 * Determine if an object has any properties.
 * @param {Object} object The object to check.
 * @return {boolean} The object is empty.
 */
function isEmpty(object) {
  var property;
  for (property in object) {
    return false;
  }
  return !property;
}

//# sourceMappingURL=obj.js.map

/***/ }),

/***/ "./node_modules/ol/ol.css":
/*!********************************!*\
  !*** ./node_modules/ol/ol.css ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../css-loader/dist/cjs.js!./ol.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/ol/ol.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./node_modules/ol/pointer/EventSource.js":
/*!************************************************!*\
  !*** ./node_modules/ol/pointer/EventSource.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/pointer/EventSource
 */

var EventSource = function EventSource(dispatcher, mapping) {

  /**
   * @type {import("./PointerEventHandler.js").default}
   */
  this.dispatcher = dispatcher;

  /**
   * @private
   * @const
   * @type {!Object<string, function(Event)>}
   */
  this.mapping_ = mapping;
};

/**
 * List of events supported by this source.
 * @return {Array<string>} Event names
 */
EventSource.prototype.getEvents = function getEvents () {
  return Object.keys(this.mapping_);
};

/**
 * Returns the handler that should handle a given event type.
 * @param {string} eventType The event type.
 * @return {function(Event)} Handler
 */
EventSource.prototype.getHandlerForEvent = function getHandlerForEvent (eventType) {
  return this.mapping_[eventType];
};

/* harmony default export */ __webpack_exports__["default"] = (EventSource);

//# sourceMappingURL=EventSource.js.map

/***/ }),

/***/ "./node_modules/ol/pointer/EventType.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/pointer/EventType.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/pointer/EventType
 */

/**
 * Constants for event names.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  POINTERMOVE: 'pointermove',
  POINTERDOWN: 'pointerdown',
  POINTERUP: 'pointerup',
  POINTEROVER: 'pointerover',
  POINTEROUT: 'pointerout',
  POINTERENTER: 'pointerenter',
  POINTERLEAVE: 'pointerleave',
  POINTERCANCEL: 'pointercancel'
});

//# sourceMappingURL=EventType.js.map

/***/ }),

/***/ "./node_modules/ol/pointer/MouseSource.js":
/*!************************************************!*\
  !*** ./node_modules/ol/pointer/MouseSource.js ***!
  \************************************************/
/*! exports provided: POINTER_ID, POINTER_TYPE, prepareEvent, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POINTER_ID", function() { return POINTER_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POINTER_TYPE", function() { return POINTER_TYPE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prepareEvent", function() { return prepareEvent; });
/* harmony import */ var _EventSource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EventSource.js */ "./node_modules/ol/pointer/EventSource.js");
/**
 * @module ol/pointer/MouseSource
 */

// Based on https://github.com/Polymer/PointerEvents

// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.




/**
 * @type {number}
 */
var POINTER_ID = 1;


/**
 * @type {string}
 */
var POINTER_TYPE = 'mouse';


/**
 * Radius around touchend that swallows mouse events.
 *
 * @type {number}
 */
var DEDUP_DIST = 25;

/**
 * Handler for `mousedown`.
 *
 * @this {MouseSource}
 * @param {MouseEvent} inEvent The in event.
 */
function mousedown(inEvent) {
  if (!this.isEventSimulatedFromTouch_(inEvent)) {
    // TODO(dfreedman) workaround for some elements not sending mouseup
    // http://crbug/149091
    if (POINTER_ID.toString() in this.pointerMap) {
      this.cancel(inEvent);
    }
    var e = prepareEvent(inEvent, this.dispatcher);
    this.pointerMap[POINTER_ID.toString()] = inEvent;
    this.dispatcher.down(e, inEvent);
  }
}

/**
 * Handler for `mousemove`.
 *
 * @this {MouseSource}
 * @param {MouseEvent} inEvent The in event.
 */
function mousemove(inEvent) {
  if (!this.isEventSimulatedFromTouch_(inEvent)) {
    var e = prepareEvent(inEvent, this.dispatcher);
    this.dispatcher.move(e, inEvent);
  }
}

/**
 * Handler for `mouseup`.
 *
 * @this {MouseSource}
 * @param {MouseEvent} inEvent The in event.
 */
function mouseup(inEvent) {
  if (!this.isEventSimulatedFromTouch_(inEvent)) {
    var p = this.pointerMap[POINTER_ID.toString()];

    if (p && p.button === inEvent.button) {
      var e = prepareEvent(inEvent, this.dispatcher);
      this.dispatcher.up(e, inEvent);
      this.cleanupMouse();
    }
  }
}

/**
 * Handler for `mouseover`.
 *
 * @this {MouseSource}
 * @param {MouseEvent} inEvent The in event.
 */
function mouseover(inEvent) {
  if (!this.isEventSimulatedFromTouch_(inEvent)) {
    var e = prepareEvent(inEvent, this.dispatcher);
    this.dispatcher.enterOver(e, inEvent);
  }
}

/**
 * Handler for `mouseout`.
 *
 * @this {MouseSource}
 * @param {MouseEvent} inEvent The in event.
 */
function mouseout(inEvent) {
  if (!this.isEventSimulatedFromTouch_(inEvent)) {
    var e = prepareEvent(inEvent, this.dispatcher);
    this.dispatcher.leaveOut(e, inEvent);
  }
}


var MouseSource = /*@__PURE__*/(function (EventSource) {
  function MouseSource(dispatcher) {
    var mapping = {
      'mousedown': mousedown,
      'mousemove': mousemove,
      'mouseup': mouseup,
      'mouseover': mouseover,
      'mouseout': mouseout
    };
    EventSource.call(this, dispatcher, mapping);

    /**
     * @const
     * @type {!Object<string, Event|Object>}
     */
    this.pointerMap = dispatcher.pointerMap;

    /**
     * @const
     * @type {Array<import("../pixel.js").Pixel>}
     */
    this.lastTouches = [];
  }

  if ( EventSource ) MouseSource.__proto__ = EventSource;
  MouseSource.prototype = Object.create( EventSource && EventSource.prototype );
  MouseSource.prototype.constructor = MouseSource;

  /**
   * Detect if a mouse event was simulated from a touch by
   * checking if previously there was a touch event at the
   * same position.
   *
   * FIXME - Known problem with the native Android browser on
   * Samsung GT-I9100 (Android 4.1.2):
   * In case the page is scrolled, this function does not work
   * correctly when a canvas is used (WebGL or canvas renderer).
   * Mouse listeners on canvas elements (for this browser), create
   * two mouse events: One 'good' and one 'bad' one (on other browsers or
   * when a div is used, there is only one event). For the 'bad' one,
   * clientX/clientY and also pageX/pageY are wrong when the page
   * is scrolled. Because of that, this function can not detect if
   * the events were simulated from a touch event. As result, a
   * pointer event at a wrong position is dispatched, which confuses
   * the map interactions.
   * It is unclear, how one can get the correct position for the event
   * or detect that the positions are invalid.
   *
   * @private
   * @param {MouseEvent} inEvent The in event.
   * @return {boolean} True, if the event was generated by a touch.
   */
  MouseSource.prototype.isEventSimulatedFromTouch_ = function isEventSimulatedFromTouch_ (inEvent) {
    var lts = this.lastTouches;
    var x = inEvent.clientX;
    var y = inEvent.clientY;
    for (var i = 0, l = lts.length, t = (void 0); i < l && (t = lts[i]); i++) {
      // simulated mouse events will be swallowed near a primary touchend
      var dx = Math.abs(x - t[0]);
      var dy = Math.abs(y - t[1]);
      if (dx <= DEDUP_DIST && dy <= DEDUP_DIST) {
        return true;
      }
    }
    return false;
  };

  /**
   * Dispatches a `pointercancel` event.
   *
   * @param {Event} inEvent The in event.
   */
  MouseSource.prototype.cancel = function cancel (inEvent) {
    var e = prepareEvent(inEvent, this.dispatcher);
    this.dispatcher.cancel(e, inEvent);
    this.cleanupMouse();
  };

  /**
   * Remove the mouse from the list of active pointers.
   */
  MouseSource.prototype.cleanupMouse = function cleanupMouse () {
    delete this.pointerMap[POINTER_ID.toString()];
  };

  return MouseSource;
}(_EventSource_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/**
 * Creates a copy of the original event that will be used
 * for the fake pointer event.
 *
 * @param {Event} inEvent The in event.
 * @param {import("./PointerEventHandler.js").default} dispatcher Event handler.
 * @return {Object} The copied event.
 */
function prepareEvent(inEvent, dispatcher) {
  var e = dispatcher.cloneEvent(inEvent, inEvent);

  // forward mouse preventDefault
  var pd = e.preventDefault;
  e.preventDefault = function() {
    inEvent.preventDefault();
    pd();
  };

  e.pointerId = POINTER_ID;
  e.isPrimary = true;
  e.pointerType = POINTER_TYPE;

  return e;
}


/* harmony default export */ __webpack_exports__["default"] = (MouseSource);

//# sourceMappingURL=MouseSource.js.map

/***/ }),

/***/ "./node_modules/ol/pointer/MsSource.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/pointer/MsSource.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _EventSource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EventSource.js */ "./node_modules/ol/pointer/EventSource.js");
/**
 * @module ol/pointer/MsSource
 */
// Based on https://github.com/Polymer/PointerEvents

// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.




/**
 * @const
 * @type {Array<string>}
 */
var POINTER_TYPES = [
  '',
  'unavailable',
  'touch',
  'pen',
  'mouse'
];

/**
 * Handler for `msPointerDown`.
 *
 * @this {MsSource}
 * @param {MSPointerEvent} inEvent The in event.
 */
function msPointerDown(inEvent) {
  this.pointerMap[inEvent.pointerId.toString()] = inEvent;
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.down(e, inEvent);
}

/**
 * Handler for `msPointerMove`.
 *
 * @this {MsSource}
 * @param {MSPointerEvent} inEvent The in event.
 */
function msPointerMove(inEvent) {
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.move(e, inEvent);
}

/**
 * Handler for `msPointerUp`.
 *
 * @this {MsSource}
 * @param {MSPointerEvent} inEvent The in event.
 */
function msPointerUp(inEvent) {
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.up(e, inEvent);
  this.cleanup(inEvent.pointerId);
}

/**
 * Handler for `msPointerOut`.
 *
 * @this {MsSource}
 * @param {MSPointerEvent} inEvent The in event.
 */
function msPointerOut(inEvent) {
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.leaveOut(e, inEvent);
}

/**
 * Handler for `msPointerOver`.
 *
 * @this {MsSource}
 * @param {MSPointerEvent} inEvent The in event.
 */
function msPointerOver(inEvent) {
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.enterOver(e, inEvent);
}

/**
 * Handler for `msPointerCancel`.
 *
 * @this {MsSource}
 * @param {MSPointerEvent} inEvent The in event.
 */
function msPointerCancel(inEvent) {
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.cancel(e, inEvent);
  this.cleanup(inEvent.pointerId);
}

/**
 * Handler for `msLostPointerCapture`.
 *
 * @this {MsSource}
 * @param {MSPointerEvent} inEvent The in event.
 */
function msLostPointerCapture(inEvent) {
  var e = this.dispatcher.makeEvent('lostpointercapture', inEvent, inEvent);
  this.dispatcher.dispatchEvent(e);
}

/**
 * Handler for `msGotPointerCapture`.
 *
 * @this {MsSource}
 * @param {MSPointerEvent} inEvent The in event.
 */
function msGotPointerCapture(inEvent) {
  var e = this.dispatcher.makeEvent('gotpointercapture', inEvent, inEvent);
  this.dispatcher.dispatchEvent(e);
}

var MsSource = /*@__PURE__*/(function (EventSource) {
  function MsSource(dispatcher) {
    var mapping = {
      'MSPointerDown': msPointerDown,
      'MSPointerMove': msPointerMove,
      'MSPointerUp': msPointerUp,
      'MSPointerOut': msPointerOut,
      'MSPointerOver': msPointerOver,
      'MSPointerCancel': msPointerCancel,
      'MSGotPointerCapture': msGotPointerCapture,
      'MSLostPointerCapture': msLostPointerCapture
    };
    EventSource.call(this, dispatcher, mapping);

    /**
     * @const
     * @type {!Object<string, MSPointerEvent|Object>}
     */
    this.pointerMap = dispatcher.pointerMap;
  }

  if ( EventSource ) MsSource.__proto__ = EventSource;
  MsSource.prototype = Object.create( EventSource && EventSource.prototype );
  MsSource.prototype.constructor = MsSource;

  /**
   * Creates a copy of the original event that will be used
   * for the fake pointer event.
   *
   * @private
   * @param {MSPointerEvent} inEvent The in event.
   * @return {Object} The copied event.
   */
  MsSource.prototype.prepareEvent_ = function prepareEvent_ (inEvent) {
    /** @type {MSPointerEvent|Object} */
    var e = inEvent;
    if (typeof inEvent.pointerType === 'number') {
      e = this.dispatcher.cloneEvent(inEvent, inEvent);
      e.pointerType = POINTER_TYPES[inEvent.pointerType];
    }

    return e;
  };

  /**
   * Remove this pointer from the list of active pointers.
   * @param {number} pointerId Pointer identifier.
   */
  MsSource.prototype.cleanup = function cleanup (pointerId) {
    delete this.pointerMap[pointerId.toString()];
  };

  return MsSource;
}(_EventSource_js__WEBPACK_IMPORTED_MODULE_0__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (MsSource);

//# sourceMappingURL=MsSource.js.map

/***/ }),

/***/ "./node_modules/ol/pointer/NativeSource.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/pointer/NativeSource.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _EventSource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EventSource.js */ "./node_modules/ol/pointer/EventSource.js");
/**
 * @module ol/pointer/NativeSource
 */

// Based on https://github.com/Polymer/PointerEvents

// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.



/**
 * Handler for `pointerdown`.
 *
 * @this {NativeSource}
 * @param {Event} inEvent The in event.
 */
function pointerDown(inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
}

/**
 * Handler for `pointermove`.
 *
 * @this {NativeSource}
 * @param {Event} inEvent The in event.
 */
function pointerMove(inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
}

/**
 * Handler for `pointerup`.
 *
 * @this {NativeSource}
 * @param {Event} inEvent The in event.
 */
function pointerUp(inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
}

/**
 * Handler for `pointerout`.
 *
 * @this {NativeSource}
 * @param {Event} inEvent The in event.
 */
function pointerOut(inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
}

/**
 * Handler for `pointerover`.
 *
 * @this {NativeSource}
 * @param {Event} inEvent The in event.
 */
function pointerOver(inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
}

/**
 * Handler for `pointercancel`.
 *
 * @this {NativeSource}
 * @param {Event} inEvent The in event.
 */
function pointerCancel(inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
}

/**
 * Handler for `lostpointercapture`.
 *
 * @this {NativeSource}
 * @param {Event} inEvent The in event.
 */
function lostPointerCapture(inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
}

/**
 * Handler for `gotpointercapture`.
 *
 * @this {NativeSource}
 * @param {Event} inEvent The in event.
 */
function gotPointerCapture(inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
}

var NativeSource = /*@__PURE__*/(function (EventSource) {
  function NativeSource(dispatcher) {
    var mapping = {
      'pointerdown': pointerDown,
      'pointermove': pointerMove,
      'pointerup': pointerUp,
      'pointerout': pointerOut,
      'pointerover': pointerOver,
      'pointercancel': pointerCancel,
      'gotpointercapture': gotPointerCapture,
      'lostpointercapture': lostPointerCapture
    };
    EventSource.call(this, dispatcher, mapping);
  }

  if ( EventSource ) NativeSource.__proto__ = EventSource;
  NativeSource.prototype = Object.create( EventSource && EventSource.prototype );
  NativeSource.prototype.constructor = NativeSource;

  return NativeSource;
}(_EventSource_js__WEBPACK_IMPORTED_MODULE_0__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (NativeSource);

//# sourceMappingURL=NativeSource.js.map

/***/ }),

/***/ "./node_modules/ol/pointer/PointerEvent.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/pointer/PointerEvent.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/**
 * @module ol/pointer/PointerEvent
 */

// Based on https://github.com/Polymer/PointerEvents

// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.




/**
 * Is the `buttons` property supported?
 * @type {boolean}
 */
var HAS_BUTTONS = false;


var PointerEvent = /*@__PURE__*/(function (_Event) {
  function PointerEvent(type, originalEvent, opt_eventDict) {
    _Event.call(this, type);

    /**
     * @const
     * @type {Event}
     */
    this.originalEvent = originalEvent;

    var eventDict = opt_eventDict ? opt_eventDict : {};

    /**
     * @type {number}
     */
    this.buttons = getButtons(eventDict);

    /**
     * @type {number}
     */
    this.pressure = getPressure(eventDict, this.buttons);

    // MouseEvent related properties

    /**
     * @type {boolean}
     */
    this.bubbles = 'bubbles' in eventDict ? eventDict['bubbles'] : false;

    /**
     * @type {boolean}
     */
    this.cancelable = 'cancelable' in eventDict ? eventDict['cancelable'] : false;

    /**
     * @type {Object}
     */
    this.view = 'view' in eventDict ? eventDict['view'] : null;

    /**
     * @type {number}
     */
    this.detail = 'detail' in eventDict ? eventDict['detail'] : null;

    /**
     * @type {number}
     */
    this.screenX = 'screenX' in eventDict ? eventDict['screenX'] : 0;

    /**
     * @type {number}
     */
    this.screenY = 'screenY' in eventDict ? eventDict['screenY'] : 0;

    /**
     * @type {number}
     */
    this.clientX = 'clientX' in eventDict ? eventDict['clientX'] : 0;

    /**
     * @type {number}
     */
    this.clientY = 'clientY' in eventDict ? eventDict['clientY'] : 0;

    /**
     * @type {boolean}
     */
    this.ctrlKey = 'ctrlKey' in eventDict ? eventDict['ctrlKey'] : false;

    /**
     * @type {boolean}
     */
    this.altKey = 'altKey' in eventDict ? eventDict['altKey'] : false;

    /**
     * @type {boolean}
     */
    this.shiftKey = 'shiftKey' in eventDict ? eventDict['shiftKey'] : false;

    /**
     * @type {boolean}
     */
    this.metaKey = 'metaKey' in eventDict ? eventDict['metaKey'] : false;

    /**
     * @type {number}
     */
    this.button = 'button' in eventDict ? eventDict['button'] : 0;

    /**
     * @type {Node}
     */
    this.relatedTarget = 'relatedTarget' in eventDict ?
      eventDict['relatedTarget'] : null;

    // PointerEvent related properties

    /**
     * @const
     * @type {number}
     */
    this.pointerId = 'pointerId' in eventDict ? eventDict['pointerId'] : 0;

    /**
     * @type {number}
     */
    this.width = 'width' in eventDict ? eventDict['width'] : 0;

    /**
     * @type {number}
     */
    this.height = 'height' in eventDict ? eventDict['height'] : 0;

    /**
     * @type {number}
     */
    this.tiltX = 'tiltX' in eventDict ? eventDict['tiltX'] : 0;

    /**
     * @type {number}
     */
    this.tiltY = 'tiltY' in eventDict ? eventDict['tiltY'] : 0;

    /**
     * @type {string}
     */
    this.pointerType = 'pointerType' in eventDict ? eventDict['pointerType'] : '';

    /**
     * @type {number}
     */
    this.hwTimestamp = 'hwTimestamp' in eventDict ? eventDict['hwTimestamp'] : 0;

    /**
     * @type {boolean}
     */
    this.isPrimary = 'isPrimary' in eventDict ? eventDict['isPrimary'] : false;

    // keep the semantics of preventDefault
    if (originalEvent.preventDefault) {
      this.preventDefault = function() {
        originalEvent.preventDefault();
      };
    }
  }

  if ( _Event ) PointerEvent.__proto__ = _Event;
  PointerEvent.prototype = Object.create( _Event && _Event.prototype );
  PointerEvent.prototype.constructor = PointerEvent;

  return PointerEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/**
 * @param {Object<string, ?>} eventDict The event dictionary.
 * @return {number} Button indicator.
 */
function getButtons(eventDict) {
  // According to the w3c spec,
  // http://www.w3.org/TR/DOM-Level-3-Events/#events-MouseEvent-button
  // MouseEvent.button == 0 can mean either no mouse button depressed, or the
  // left mouse button depressed.
  //
  // As of now, the only way to distinguish between the two states of
  // MouseEvent.button is by using the deprecated MouseEvent.which property, as
  // this maps mouse buttons to positive integers > 0, and uses 0 to mean that
  // no mouse button is held.
  //
  // MouseEvent.which is derived from MouseEvent.button at MouseEvent creation,
  // but initMouseEvent does not expose an argument with which to set
  // MouseEvent.which. Calling initMouseEvent with a buttonArg of 0 will set
  // MouseEvent.button == 0 and MouseEvent.which == 1, breaking the expectations
  // of app developers.
  //
  // The only way to propagate the correct state of MouseEvent.which and
  // MouseEvent.button to a new MouseEvent.button == 0 and MouseEvent.which == 0
  // is to call initMouseEvent with a buttonArg value of -1.
  //
  // This is fixed with DOM Level 4's use of buttons
  var buttons;
  if (eventDict.buttons || HAS_BUTTONS) {
    buttons = eventDict.buttons;
  } else {
    switch (eventDict.which) {
      case 1: buttons = 1; break;
      case 2: buttons = 4; break;
      case 3: buttons = 2; break;
      default: buttons = 0;
    }
  }
  return buttons;
}


/**
 * @param {Object<string, ?>} eventDict The event dictionary.
 * @param {number} buttons Button indicator.
 * @return {number} The pressure.
 */
function getPressure(eventDict, buttons) {
  // Spec requires that pointers without pressure specified use 0.5 for down
  // state and 0 for up state.
  var pressure = 0;
  if (eventDict.pressure) {
    pressure = eventDict.pressure;
  } else {
    pressure = buttons ? 0.5 : 0;
  }
  return pressure;
}


/**
 * Checks if the `buttons` property is supported.
 */
(function() {
  try {
    var ev = new MouseEvent('click', {buttons: 1});
    HAS_BUTTONS = ev.buttons === 1;
  } catch (e) {
    // pass
  }
})();

/* harmony default export */ __webpack_exports__["default"] = (PointerEvent);

//# sourceMappingURL=PointerEvent.js.map

/***/ }),

/***/ "./node_modules/ol/pointer/PointerEventHandler.js":
/*!********************************************************!*\
  !*** ./node_modules/ol/pointer/PointerEventHandler.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/Target.js */ "./node_modules/ol/events/Target.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EventType.js */ "./node_modules/ol/pointer/EventType.js");
/* harmony import */ var _MouseSource_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MouseSource.js */ "./node_modules/ol/pointer/MouseSource.js");
/* harmony import */ var _MsSource_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./MsSource.js */ "./node_modules/ol/pointer/MsSource.js");
/* harmony import */ var _NativeSource_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./NativeSource.js */ "./node_modules/ol/pointer/NativeSource.js");
/* harmony import */ var _PointerEvent_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./PointerEvent.js */ "./node_modules/ol/pointer/PointerEvent.js");
/* harmony import */ var _TouchSource_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./TouchSource.js */ "./node_modules/ol/pointer/TouchSource.js");
/**
 * @module ol/pointer/PointerEventHandler
 */

// Based on https://github.com/Polymer/PointerEvents

// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.












/**
 * Properties to copy when cloning an event, with default values.
 * @type {Array<Array>}
 */
var CLONE_PROPS = [
  // MouseEvent
  ['bubbles', false],
  ['cancelable', false],
  ['view', null],
  ['detail', null],
  ['screenX', 0],
  ['screenY', 0],
  ['clientX', 0],
  ['clientY', 0],
  ['ctrlKey', false],
  ['altKey', false],
  ['shiftKey', false],
  ['metaKey', false],
  ['button', 0],
  ['relatedTarget', null],
  // DOM Level 3
  ['buttons', 0],
  // PointerEvent
  ['pointerId', 0],
  ['width', 0],
  ['height', 0],
  ['pressure', 0],
  ['tiltX', 0],
  ['tiltY', 0],
  ['pointerType', ''],
  ['hwTimestamp', 0],
  ['isPrimary', false],
  // event instance
  ['type', ''],
  ['target', null],
  ['currentTarget', null],
  ['which', 0]
];


var PointerEventHandler = /*@__PURE__*/(function (EventTarget) {
  function PointerEventHandler(element) {
    EventTarget.call(this);

    /**
     * @const
     * @private
     * @type {Element|HTMLDocument}
     */
    this.element_ = element;

    /**
     * @const
     * @type {!Object<string, Event|Object>}
     */
    this.pointerMap = {};

    /**
     * @type {Object<string, function(Event)>}
     * @private
     */
    this.eventMap_ = {};

    /**
     * @type {Array<import("./EventSource.js").default>}
     * @private
     */
    this.eventSourceList_ = [];

    this.registerSources();
  }

  if ( EventTarget ) PointerEventHandler.__proto__ = EventTarget;
  PointerEventHandler.prototype = Object.create( EventTarget && EventTarget.prototype );
  PointerEventHandler.prototype.constructor = PointerEventHandler;

  /**
   * Set up the event sources (mouse, touch and native pointers)
   * that generate pointer events.
   */
  PointerEventHandler.prototype.registerSources = function registerSources () {
    if (_has_js__WEBPACK_IMPORTED_MODULE_2__["POINTER"]) {
      this.registerSource('native', new _NativeSource_js__WEBPACK_IMPORTED_MODULE_6__["default"](this));
    } else if (_has_js__WEBPACK_IMPORTED_MODULE_2__["MSPOINTER"]) {
      this.registerSource('ms', new _MsSource_js__WEBPACK_IMPORTED_MODULE_5__["default"](this));
    } else {
      var mouseSource = new _MouseSource_js__WEBPACK_IMPORTED_MODULE_4__["default"](this);
      this.registerSource('mouse', mouseSource);

      if (_has_js__WEBPACK_IMPORTED_MODULE_2__["TOUCH"]) {
        this.registerSource('touch', new _TouchSource_js__WEBPACK_IMPORTED_MODULE_8__["default"](this, mouseSource));
      }
    }

    // register events on the viewport element
    this.register_();
  };

  /**
   * Add a new event source that will generate pointer events.
   *
   * @param {string} name A name for the event source
   * @param {import("./EventSource.js").default} source The source event.
   */
  PointerEventHandler.prototype.registerSource = function registerSource (name, source) {
    var s = source;
    var newEvents = s.getEvents();

    if (newEvents) {
      newEvents.forEach(function(e) {
        var handler = s.getHandlerForEvent(e);

        if (handler) {
          this.eventMap_[e] = handler.bind(s);
        }
      }.bind(this));
      this.eventSourceList_.push(s);
    }
  };

  /**
   * Set up the events for all registered event sources.
   * @private
   */
  PointerEventHandler.prototype.register_ = function register_ () {
    var l = this.eventSourceList_.length;
    for (var i = 0; i < l; i++) {
      var eventSource = this.eventSourceList_[i];
      this.addEvents_(eventSource.getEvents());
    }
  };

  /**
   * Remove all registered events.
   * @private
   */
  PointerEventHandler.prototype.unregister_ = function unregister_ () {
    var l = this.eventSourceList_.length;
    for (var i = 0; i < l; i++) {
      var eventSource = this.eventSourceList_[i];
      this.removeEvents_(eventSource.getEvents());
    }
  };

  /**
   * Calls the right handler for a new event.
   * @private
   * @param {Event} inEvent Browser event.
   */
  PointerEventHandler.prototype.eventHandler_ = function eventHandler_ (inEvent) {
    var type = inEvent.type;
    var handler = this.eventMap_[type];
    if (handler) {
      handler(inEvent);
    }
  };

  /**
   * Setup listeners for the given events.
   * @private
   * @param {Array<string>} events List of events.
   */
  PointerEventHandler.prototype.addEvents_ = function addEvents_ (events) {
    events.forEach(function(eventName) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listen"])(this.element_, eventName, this.eventHandler_, this);
    }.bind(this));
  };

  /**
   * Unregister listeners for the given events.
   * @private
   * @param {Array<string>} events List of events.
   */
  PointerEventHandler.prototype.removeEvents_ = function removeEvents_ (events) {
    events.forEach(function(e) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["unlisten"])(this.element_, e, this.eventHandler_, this);
    }.bind(this));
  };

  /**
   * Returns a snapshot of inEvent, with writable properties.
   *
   * @param {Event} event Browser event.
   * @param {Event|Touch} inEvent An event that contains
   *    properties to copy.
   * @return {Object} An object containing shallow copies of
   *    `inEvent`'s properties.
   */
  PointerEventHandler.prototype.cloneEvent = function cloneEvent (event, inEvent) {
    var eventCopy = {};
    for (var i = 0, ii = CLONE_PROPS.length; i < ii; i++) {
      var p = CLONE_PROPS[i][0];
      eventCopy[p] = event[p] || inEvent[p] || CLONE_PROPS[i][1];
    }

    return eventCopy;
  };

  // EVENTS


  /**
   * Triggers a 'pointerdown' event.
   * @param {Object} data Pointer event data.
   * @param {Event} event The event.
   */
  PointerEventHandler.prototype.down = function down (data, event) {
    this.fireEvent(_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POINTERDOWN, data, event);
  };

  /**
   * Triggers a 'pointermove' event.
   * @param {Object} data Pointer event data.
   * @param {Event} event The event.
   */
  PointerEventHandler.prototype.move = function move (data, event) {
    this.fireEvent(_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POINTERMOVE, data, event);
  };

  /**
   * Triggers a 'pointerup' event.
   * @param {Object} data Pointer event data.
   * @param {Event} event The event.
   */
  PointerEventHandler.prototype.up = function up (data, event) {
    this.fireEvent(_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POINTERUP, data, event);
  };

  /**
   * Triggers a 'pointerenter' event.
   * @param {Object} data Pointer event data.
   * @param {Event} event The event.
   */
  PointerEventHandler.prototype.enter = function enter (data, event) {
    data.bubbles = false;
    this.fireEvent(_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POINTERENTER, data, event);
  };

  /**
   * Triggers a 'pointerleave' event.
   * @param {Object} data Pointer event data.
   * @param {Event} event The event.
   */
  PointerEventHandler.prototype.leave = function leave (data, event) {
    data.bubbles = false;
    this.fireEvent(_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POINTERLEAVE, data, event);
  };

  /**
   * Triggers a 'pointerover' event.
   * @param {Object} data Pointer event data.
   * @param {Event} event The event.
   */
  PointerEventHandler.prototype.over = function over (data, event) {
    data.bubbles = true;
    this.fireEvent(_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POINTEROVER, data, event);
  };

  /**
   * Triggers a 'pointerout' event.
   * @param {Object} data Pointer event data.
   * @param {Event} event The event.
   */
  PointerEventHandler.prototype.out = function out (data, event) {
    data.bubbles = true;
    this.fireEvent(_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POINTEROUT, data, event);
  };

  /**
   * Triggers a 'pointercancel' event.
   * @param {Object} data Pointer event data.
   * @param {Event} event The event.
   */
  PointerEventHandler.prototype.cancel = function cancel (data, event) {
    this.fireEvent(_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POINTERCANCEL, data, event);
  };

  /**
   * Triggers a combination of 'pointerout' and 'pointerleave' events.
   * @param {Object} data Pointer event data.
   * @param {Event} event The event.
   */
  PointerEventHandler.prototype.leaveOut = function leaveOut (data, event) {
    this.out(data, event);
    if (!this.contains_(data.target, data.relatedTarget)) {
      this.leave(data, event);
    }
  };

  /**
   * Triggers a combination of 'pointerover' and 'pointerevents' events.
   * @param {Object} data Pointer event data.
   * @param {Event} event The event.
   */
  PointerEventHandler.prototype.enterOver = function enterOver (data, event) {
    this.over(data, event);
    if (!this.contains_(data.target, data.relatedTarget)) {
      this.enter(data, event);
    }
  };

  /**
   * @private
   * @param {Element} container The container element.
   * @param {Element} contained The contained element.
   * @return {boolean} Returns true if the container element
   *   contains the other element.
   */
  PointerEventHandler.prototype.contains_ = function contains_ (container, contained) {
    if (!container || !contained) {
      return false;
    }
    return container.contains(contained);
  };

  // EVENT CREATION AND TRACKING
  /**
   * Creates a new Event of type `inType`, based on the information in
   * `data`.
   *
   * @param {string} inType A string representing the type of event to create.
   * @param {Object} data Pointer event data.
   * @param {Event} event The event.
   * @return {PointerEvent} A PointerEvent of type `inType`.
   */
  PointerEventHandler.prototype.makeEvent = function makeEvent (inType, data, event) {
    return new _PointerEvent_js__WEBPACK_IMPORTED_MODULE_7__["default"](inType, event, data);
  };

  /**
   * Make and dispatch an event in one call.
   * @param {string} inType A string representing the type of event.
   * @param {Object} data Pointer event data.
   * @param {Event} event The event.
   */
  PointerEventHandler.prototype.fireEvent = function fireEvent (inType, data, event) {
    var e = this.makeEvent(inType, data, event);
    this.dispatchEvent(e);
  };

  /**
   * Creates a pointer event from a native pointer event
   * and dispatches this event.
   * @param {Event} event A platform event with a target.
   */
  PointerEventHandler.prototype.fireNativeEvent = function fireNativeEvent (event) {
    var e = this.makeEvent(event.type, event, event);
    this.dispatchEvent(e);
  };

  /**
   * Wrap a native mouse event into a pointer event.
   * This proxy method is required for the legacy IE support.
   * @param {string} eventType The pointer event type.
   * @param {Event} event The event.
   * @return {PointerEvent} The wrapped event.
   */
  PointerEventHandler.prototype.wrapMouseEvent = function wrapMouseEvent (eventType, event) {
    var pointerEvent = this.makeEvent(
      eventType, Object(_MouseSource_js__WEBPACK_IMPORTED_MODULE_4__["prepareEvent"])(event, this), event);
    return pointerEvent;
  };

  /**
   * @inheritDoc
   */
  PointerEventHandler.prototype.disposeInternal = function disposeInternal () {
    this.unregister_();
    EventTarget.prototype.disposeInternal.call(this);
  };

  return PointerEventHandler;
}(_events_Target_js__WEBPACK_IMPORTED_MODULE_1__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (PointerEventHandler);

//# sourceMappingURL=PointerEventHandler.js.map

/***/ }),

/***/ "./node_modules/ol/pointer/TouchSource.js":
/*!************************************************!*\
  !*** ./node_modules/ol/pointer/TouchSource.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _EventSource_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EventSource.js */ "./node_modules/ol/pointer/EventSource.js");
/* harmony import */ var _MouseSource_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MouseSource.js */ "./node_modules/ol/pointer/MouseSource.js");
/**
 * @module ol/pointer/TouchSource
 */

// Based on https://github.com/Polymer/PointerEvents

// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.






/**
 * @type {number}
 */
var CLICK_COUNT_TIMEOUT = 200;

/**
 * @type {string}
 */
var POINTER_TYPE = 'touch';

/**
 * Handler for `touchstart`, triggers `pointerover`,
 * `pointerenter` and `pointerdown` events.
 *
 * @this {TouchSource}
 * @param {TouchEvent} inEvent The in event.
 */
function touchstart(inEvent) {
  this.vacuumTouches_(inEvent);
  this.setPrimaryTouch_(inEvent.changedTouches[0]);
  this.dedupSynthMouse_(inEvent);
  this.clickCount_++;
  this.processTouches_(inEvent, this.overDown_);
}

/**
 * Handler for `touchmove`.
 *
 * @this {TouchSource}
 * @param {TouchEvent} inEvent The in event.
 */
function touchmove(inEvent) {
  this.processTouches_(inEvent, this.moveOverOut_);
}

/**
 * Handler for `touchend`, triggers `pointerup`,
 * `pointerout` and `pointerleave` events.
 *
 * @this {TouchSource}
 * @param {TouchEvent} inEvent The event.
 */
function touchend(inEvent) {
  this.dedupSynthMouse_(inEvent);
  this.processTouches_(inEvent, this.upOut_);
}

/**
 * Handler for `touchcancel`, triggers `pointercancel`,
 * `pointerout` and `pointerleave` events.
 *
 * @this {TouchSource}
 * @param {TouchEvent} inEvent The in event.
 */
function touchcancel(inEvent) {
  this.processTouches_(inEvent, this.cancelOut_);
}


var TouchSource = /*@__PURE__*/(function (EventSource) {
  function TouchSource(dispatcher, mouseSource) {
    var mapping = {
      'touchstart': touchstart,
      'touchmove': touchmove,
      'touchend': touchend,
      'touchcancel': touchcancel
    };
    EventSource.call(this, dispatcher, mapping);

    /**
     * @const
     * @type {!Object<string, Event|Object>}
     */
    this.pointerMap = dispatcher.pointerMap;

    /**
     * @const
     * @type {import("./MouseSource.js").default}
     */
    this.mouseSource = mouseSource;

    /**
     * @private
     * @type {number|undefined}
     */
    this.firstTouchId_ = undefined;

    /**
     * @private
     * @type {number}
     */
    this.clickCount_ = 0;

    /**
     * @private
     * @type {?}
     */
    this.resetId_;

    /**
     * Mouse event timeout: This should be long enough to
     * ignore compat mouse events made by touch.
     * @private
     * @type {number}
     */
    this.dedupTimeout_ = 2500;
  }

  if ( EventSource ) TouchSource.__proto__ = EventSource;
  TouchSource.prototype = Object.create( EventSource && EventSource.prototype );
  TouchSource.prototype.constructor = TouchSource;

  /**
   * @private
   * @param {Touch} inTouch The in touch.
   * @return {boolean} True, if this is the primary touch.
   */
  TouchSource.prototype.isPrimaryTouch_ = function isPrimaryTouch_ (inTouch) {
    return this.firstTouchId_ === inTouch.identifier;
  };

  /**
   * Set primary touch if there are no pointers, or the only pointer is the mouse.
   * @param {Touch} inTouch The in touch.
   * @private
   */
  TouchSource.prototype.setPrimaryTouch_ = function setPrimaryTouch_ (inTouch) {
    var count = Object.keys(this.pointerMap).length;
    if (count === 0 || (count === 1 && _MouseSource_js__WEBPACK_IMPORTED_MODULE_2__["POINTER_ID"].toString() in this.pointerMap)) {
      this.firstTouchId_ = inTouch.identifier;
      this.cancelResetClickCount_();
    }
  };

  /**
   * @private
   * @param {PointerEvent} inPointer The in pointer object.
   */
  TouchSource.prototype.removePrimaryPointer_ = function removePrimaryPointer_ (inPointer) {
    if (inPointer.isPrimary) {
      this.firstTouchId_ = undefined;
      this.resetClickCount_();
    }
  };

  /**
   * @private
   */
  TouchSource.prototype.resetClickCount_ = function resetClickCount_ () {
    this.resetId_ = setTimeout(
      this.resetClickCountHandler_.bind(this),
      CLICK_COUNT_TIMEOUT);
  };

  /**
   * @private
   */
  TouchSource.prototype.resetClickCountHandler_ = function resetClickCountHandler_ () {
    this.clickCount_ = 0;
    this.resetId_ = undefined;
  };

  /**
   * @private
   */
  TouchSource.prototype.cancelResetClickCount_ = function cancelResetClickCount_ () {
    if (this.resetId_ !== undefined) {
      clearTimeout(this.resetId_);
    }
  };

  /**
   * @private
   * @param {TouchEvent} browserEvent Browser event
   * @param {Touch} inTouch Touch event
   * @return {PointerEvent} A pointer object.
   */
  TouchSource.prototype.touchToPointer_ = function touchToPointer_ (browserEvent, inTouch) {
    var e = this.dispatcher.cloneEvent(browserEvent, inTouch);
    // Spec specifies that pointerId 1 is reserved for Mouse.
    // Touch identifiers can start at 0.
    // Add 2 to the touch identifier for compatibility.
    e.pointerId = inTouch.identifier + 2;
    // TODO: check if this is necessary?
    //e.target = findTarget(e);
    e.bubbles = true;
    e.cancelable = true;
    e.detail = this.clickCount_;
    e.button = 0;
    e.buttons = 1;
    e.width = inTouch.radiusX || 0;
    e.height = inTouch.radiusY || 0;
    e.pressure = inTouch.force || 0.5;
    e.isPrimary = this.isPrimaryTouch_(inTouch);
    e.pointerType = POINTER_TYPE;

    // make sure that the properties that are different for
    // each `Touch` object are not copied from the BrowserEvent object
    e.clientX = inTouch.clientX;
    e.clientY = inTouch.clientY;
    e.screenX = inTouch.screenX;
    e.screenY = inTouch.screenY;

    return e;
  };

  /**
   * @private
   * @param {TouchEvent} inEvent Touch event
   * @param {function(TouchEvent, PointerEvent)} inFunction In function.
   */
  TouchSource.prototype.processTouches_ = function processTouches_ (inEvent, inFunction) {
    var touches = Array.prototype.slice.call(inEvent.changedTouches);
    var count = touches.length;
    function preventDefault() {
      inEvent.preventDefault();
    }
    for (var i = 0; i < count; ++i) {
      var pointer = this.touchToPointer_(inEvent, touches[i]);
      // forward touch preventDefaults
      pointer.preventDefault = preventDefault;
      inFunction.call(this, inEvent, pointer);
    }
  };

  /**
   * @private
   * @param {TouchList} touchList The touch list.
   * @param {number} searchId Search identifier.
   * @return {boolean} True, if the `Touch` with the given id is in the list.
   */
  TouchSource.prototype.findTouch_ = function findTouch_ (touchList, searchId) {
    var l = touchList.length;
    for (var i = 0; i < l; i++) {
      var touch = touchList[i];
      if (touch.identifier === searchId) {
        return true;
      }
    }
    return false;
  };

  /**
   * In some instances, a touchstart can happen without a touchend. This
   * leaves the pointermap in a broken state.
   * Therefore, on every touchstart, we remove the touches that did not fire a
   * touchend event.
   * To keep state globally consistent, we fire a pointercancel for
   * this "abandoned" touch
   *
   * @private
   * @param {TouchEvent} inEvent The in event.
   */
  TouchSource.prototype.vacuumTouches_ = function vacuumTouches_ (inEvent) {
    var touchList = inEvent.touches;
    // pointerMap.getCount() should be < touchList.length here,
    // as the touchstart has not been processed yet.
    var keys = Object.keys(this.pointerMap);
    var count = keys.length;
    if (count >= touchList.length) {
      var d = [];
      for (var i = 0; i < count; ++i) {
        var key = Number(keys[i]);
        var value = this.pointerMap[key];
        // Never remove pointerId == 1, which is mouse.
        // Touch identifiers are 2 smaller than their pointerId, which is the
        // index in pointermap.
        if (key != _MouseSource_js__WEBPACK_IMPORTED_MODULE_2__["POINTER_ID"] && !this.findTouch_(touchList, key - 2)) {
          d.push(value.out);
        }
      }
      for (var i$1 = 0; i$1 < d.length; ++i$1) {
        this.cancelOut_(inEvent, d[i$1]);
      }
    }
  };

  /**
   * @private
   * @param {TouchEvent} browserEvent The event.
   * @param {PointerEvent} inPointer The in pointer object.
   */
  TouchSource.prototype.overDown_ = function overDown_ (browserEvent, inPointer) {
    this.pointerMap[inPointer.pointerId] = {
      target: inPointer.target,
      out: inPointer,
      outTarget: inPointer.target
    };
    this.dispatcher.over(inPointer, browserEvent);
    this.dispatcher.enter(inPointer, browserEvent);
    this.dispatcher.down(inPointer, browserEvent);
  };

  /**
   * @private
   * @param {TouchEvent} browserEvent The event.
   * @param {PointerEvent} inPointer The in pointer.
   */
  TouchSource.prototype.moveOverOut_ = function moveOverOut_ (browserEvent, inPointer) {
    var event = inPointer;
    var pointer = this.pointerMap[event.pointerId];
    // a finger drifted off the screen, ignore it
    if (!pointer) {
      return;
    }
    var outEvent = pointer.out;
    var outTarget = pointer.outTarget;
    this.dispatcher.move(event, browserEvent);
    if (outEvent && outTarget !== event.target) {
      outEvent.relatedTarget = event.target;
      /** @type {Object} */ (event).relatedTarget = outTarget;
      // recover from retargeting by shadow
      outEvent.target = outTarget;
      if (event.target) {
        this.dispatcher.leaveOut(outEvent, browserEvent);
        this.dispatcher.enterOver(event, browserEvent);
      } else {
        // clean up case when finger leaves the screen
        /** @type {Object} */ (event).target = outTarget;
        /** @type {Object} */ (event).relatedTarget = null;
        this.cancelOut_(browserEvent, event);
      }
    }
    pointer.out = event;
    pointer.outTarget = event.target;
  };

  /**
   * @private
   * @param {TouchEvent} browserEvent An event.
   * @param {PointerEvent} inPointer The inPointer object.
   */
  TouchSource.prototype.upOut_ = function upOut_ (browserEvent, inPointer) {
    this.dispatcher.up(inPointer, browserEvent);
    this.dispatcher.out(inPointer, browserEvent);
    this.dispatcher.leave(inPointer, browserEvent);
    this.cleanUpPointer_(inPointer);
  };

  /**
   * @private
   * @param {TouchEvent} browserEvent The event.
   * @param {PointerEvent} inPointer The in pointer.
   */
  TouchSource.prototype.cancelOut_ = function cancelOut_ (browserEvent, inPointer) {
    this.dispatcher.cancel(inPointer, browserEvent);
    this.dispatcher.out(inPointer, browserEvent);
    this.dispatcher.leave(inPointer, browserEvent);
    this.cleanUpPointer_(inPointer);
  };

  /**
   * @private
   * @param {PointerEvent} inPointer The inPointer object.
   */
  TouchSource.prototype.cleanUpPointer_ = function cleanUpPointer_ (inPointer) {
    delete this.pointerMap[inPointer.pointerId];
    this.removePrimaryPointer_(inPointer);
  };

  /**
   * Prevent synth mouse events from creating pointer events.
   *
   * @private
   * @param {TouchEvent} inEvent The in event.
   */
  TouchSource.prototype.dedupSynthMouse_ = function dedupSynthMouse_ (inEvent) {
    var lts = this.mouseSource.lastTouches;
    var t = inEvent.changedTouches[0];
    // only the primary finger will synth mouse events
    if (this.isPrimaryTouch_(t)) {
      // remember x/y of last touch
      var lt = [t.clientX, t.clientY];
      lts.push(lt);

      setTimeout(function() {
        // remove touch after timeout
        Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["remove"])(lts, lt);
      }, this.dedupTimeout_);
    }
  };

  return TouchSource;
}(_EventSource_js__WEBPACK_IMPORTED_MODULE_1__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (TouchSource);

//# sourceMappingURL=TouchSource.js.map

/***/ }),

/***/ "./node_modules/ol/proj.js":
/*!*********************************!*\
  !*** ./node_modules/ol/proj.js ***!
  \*********************************/
/*! exports provided: METERS_PER_UNIT, Projection, cloneTransform, identityTransform, addProjection, addProjections, get, getPointResolution, addEquivalentProjections, addEquivalentTransforms, clearAllProjections, createProjection, createTransformFromCoordinateTransform, addCoordinateTransforms, fromLonLat, toLonLat, equivalent, getTransformFromProjections, getTransform, transform, transformExtent, transformWithProjections, addCommon */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cloneTransform", function() { return cloneTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identityTransform", function() { return identityTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addProjection", function() { return addProjection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addProjections", function() { return addProjections; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return get; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPointResolution", function() { return getPointResolution; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addEquivalentProjections", function() { return addEquivalentProjections; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addEquivalentTransforms", function() { return addEquivalentTransforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clearAllProjections", function() { return clearAllProjections; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createProjection", function() { return createProjection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createTransformFromCoordinateTransform", function() { return createTransformFromCoordinateTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addCoordinateTransforms", function() { return addCoordinateTransforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromLonLat", function() { return fromLonLat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toLonLat", function() { return toLonLat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equivalent", function() { return equivalent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTransformFromProjections", function() { return getTransformFromProjections; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTransform", function() { return getTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transform", function() { return transform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformExtent", function() { return transformExtent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformWithProjections", function() { return transformWithProjections; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addCommon", function() { return addCommon; });
/* harmony import */ var _sphere_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sphere.js */ "./node_modules/ol/sphere.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./proj/epsg3857.js */ "./node_modules/ol/proj/epsg3857.js");
/* harmony import */ var _proj_epsg4326_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./proj/epsg4326.js */ "./node_modules/ol/proj/epsg4326.js");
/* harmony import */ var _proj_Projection_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./proj/Projection.js */ "./node_modules/ol/proj/Projection.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Projection", function() { return _proj_Projection_js__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _proj_Units_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./proj/Units.js */ "./node_modules/ol/proj/Units.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "METERS_PER_UNIT", function() { return _proj_Units_js__WEBPACK_IMPORTED_MODULE_6__["METERS_PER_UNIT"]; });

/* harmony import */ var _proj_projections_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./proj/projections.js */ "./node_modules/ol/proj/projections.js");
/* harmony import */ var _proj_transforms_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./proj/transforms.js */ "./node_modules/ol/proj/transforms.js");
/**
 * @module ol/proj
 */

/**
 * The ol/proj module stores:
 * * a list of {@link module:ol/proj/Projection}
 * objects, one for each projection supported by the application
 * * a list of transform functions needed to convert coordinates in one projection
 * into another.
 *
 * The static functions are the methods used to maintain these.
 * Each transform function can handle not only simple coordinate pairs, but also
 * large arrays of coordinates such as vector geometries.
 *
 * When loaded, the library adds projection objects for EPSG:4326 (WGS84
 * geographic coordinates) and EPSG:3857 (Web or Spherical Mercator, as used
 * for example by Bing Maps or OpenStreetMap), together with the relevant
 * transform functions.
 *
 * Additional transforms may be added by using the http://proj4js.org/
 * library (version 2.2 or later). You can use the full build supplied by
 * Proj4js, or create a custom build to support those projections you need; see
 * the Proj4js website for how to do this. You also need the Proj4js definitions
 * for the required projections. These definitions can be obtained from
 * https://epsg.io/, and are a JS function, so can be loaded in a script
 * tag (as in the examples) or pasted into your application.
 *
 * After all required projection definitions are added to proj4's registry (by
 * using `proj4.defs()`), simply call `register(proj4)` from the `ol/proj/proj4`
 * package. Existing transforms are not changed by this function. See
 * examples/wms-image-custom-proj for an example of this.
 *
 * Additional projection definitions can be registered with `proj4.defs()` any
 * time. Just make sure to call `register(proj4)` again; for example, with user-supplied data where you don't
 * know in advance what projections are needed, you can initially load minimal
 * support and then load whichever are requested.
 *
 * Note that Proj4js does not support projection extents. If you want to add
 * one for creating default tile grids, you can add it after the Projection
 * object has been created with `setExtent`, for example,
 * `get('EPSG:1234').setExtent(extent)`.
 *
 * In addition to Proj4js support, any transform functions can be added with
 * {@link module:ol/proj~addCoordinateTransforms}. To use this, you must first create
 * a {@link module:ol/proj/Projection} object for the new projection and add it with
 * {@link module:ol/proj~addProjection}. You can then add the forward and inverse
 * functions with {@link module:ol/proj~addCoordinateTransforms}. See
 * examples/wms-custom-proj for an example of this.
 *
 * Note that if no transforms are needed and you only need to define the
 * projection, just add a {@link module:ol/proj/Projection} with
 * {@link module:ol/proj~addProjection}. See examples/wms-no-proj for an example of
 * this.
 */











/**
 * A projection as {@link module:ol/proj/Projection}, SRS identifier
 * string or undefined.
 * @typedef {Projection|string|undefined} ProjectionLike
 * @api
 */


/**
 * A transform function accepts an array of input coordinate values, an optional
 * output array, and an optional dimension (default should be 2).  The function
 * transforms the input coordinate values, populates the output array, and
 * returns the output array.
 *
 * @typedef {function(Array<number>, Array<number>=, number=): Array<number>} TransformFunction
 * @api
 */






/**
 * @param {Array<number>} input Input coordinate array.
 * @param {Array<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension.
 * @return {Array<number>} Output coordinate array (new array, same coordinate
 *     values).
 */
function cloneTransform(input, opt_output, opt_dimension) {
  var output;
  if (opt_output !== undefined) {
    for (var i = 0, ii = input.length; i < ii; ++i) {
      opt_output[i] = input[i];
    }
    output = opt_output;
  } else {
    output = input.slice();
  }
  return output;
}


/**
 * @param {Array<number>} input Input coordinate array.
 * @param {Array<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension.
 * @return {Array<number>} Input coordinate array (same array as input).
 */
function identityTransform(input, opt_output, opt_dimension) {
  if (opt_output !== undefined && input !== opt_output) {
    for (var i = 0, ii = input.length; i < ii; ++i) {
      opt_output[i] = input[i];
    }
    input = opt_output;
  }
  return input;
}


/**
 * Add a Projection object to the list of supported projections that can be
 * looked up by their code.
 *
 * @param {Projection} projection Projection instance.
 * @api
 */
function addProjection(projection) {
  _proj_projections_js__WEBPACK_IMPORTED_MODULE_7__["add"](projection.getCode(), projection);
  Object(_proj_transforms_js__WEBPACK_IMPORTED_MODULE_8__["add"])(projection, projection, cloneTransform);
}


/**
 * @param {Array<Projection>} projections Projections.
 */
function addProjections(projections) {
  projections.forEach(addProjection);
}


/**
 * Fetches a Projection object for the code specified.
 *
 * @param {ProjectionLike} projectionLike Either a code string which is
 *     a combination of authority and identifier such as "EPSG:4326", or an
 *     existing projection object, or undefined.
 * @return {Projection} Projection object, or null if not in list.
 * @api
 */
function get(projectionLike) {
  return typeof projectionLike === 'string' ?
    _proj_projections_js__WEBPACK_IMPORTED_MODULE_7__["get"](/** @type {string} */ (projectionLike)) :
    (/** @type {Projection} */ (projectionLike) || null);
}


/**
 * Get the resolution of the point in degrees or distance units.
 * For projections with degrees as the unit this will simply return the
 * provided resolution. For other projections the point resolution is
 * by default estimated by transforming the 'point' pixel to EPSG:4326,
 * measuring its width and height on the normal sphere,
 * and taking the average of the width and height.
 * A custom function can be provided for a specific projection, either
 * by setting the `getPointResolution` option in the
 * {@link module:ol/proj/Projection~Projection} constructor or by using
 * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing
 * projection object.
 * @param {ProjectionLike} projection The projection.
 * @param {number} resolution Nominal resolution in projection units.
 * @param {import("./coordinate.js").Coordinate} point Point to find adjusted resolution at.
 * @param {Units=} opt_units Units to get the point resolution in.
 * Default is the projection's units.
 * @return {number} Point resolution.
 * @api
 */
function getPointResolution(projection, resolution, point, opt_units) {
  projection = get(projection);
  var pointResolution;
  var getter = projection.getPointResolutionFunc();
  if (getter) {
    pointResolution = getter(resolution, point);
  } else {
    var units = projection.getUnits();
    if (units == _proj_Units_js__WEBPACK_IMPORTED_MODULE_6__["default"].DEGREES && !opt_units || opt_units == _proj_Units_js__WEBPACK_IMPORTED_MODULE_6__["default"].DEGREES) {
      pointResolution = resolution;
    } else {
      // Estimate point resolution by transforming the center pixel to EPSG:4326,
      // measuring its width and height on the normal sphere, and taking the
      // average of the width and height.
      var toEPSG4326 = getTransformFromProjections(projection, get('EPSG:4326'));
      var vertices = [
        point[0] - resolution / 2, point[1],
        point[0] + resolution / 2, point[1],
        point[0], point[1] - resolution / 2,
        point[0], point[1] + resolution / 2
      ];
      vertices = toEPSG4326(vertices, vertices, 2);
      var width = Object(_sphere_js__WEBPACK_IMPORTED_MODULE_0__["getDistance"])(vertices.slice(0, 2), vertices.slice(2, 4));
      var height = Object(_sphere_js__WEBPACK_IMPORTED_MODULE_0__["getDistance"])(vertices.slice(4, 6), vertices.slice(6, 8));
      pointResolution = (width + height) / 2;
      var metersPerUnit = opt_units ?
        _proj_Units_js__WEBPACK_IMPORTED_MODULE_6__["METERS_PER_UNIT"][opt_units] :
        projection.getMetersPerUnit();
      if (metersPerUnit !== undefined) {
        pointResolution /= metersPerUnit;
      }
    }
  }
  return pointResolution;
}


/**
 * Registers transformation functions that don't alter coordinates. Those allow
 * to transform between projections with equal meaning.
 *
 * @param {Array<Projection>} projections Projections.
 * @api
 */
function addEquivalentProjections(projections) {
  addProjections(projections);
  projections.forEach(function(source) {
    projections.forEach(function(destination) {
      if (source !== destination) {
        Object(_proj_transforms_js__WEBPACK_IMPORTED_MODULE_8__["add"])(source, destination, cloneTransform);
      }
    });
  });
}


/**
 * Registers transformation functions to convert coordinates in any projection
 * in projection1 to any projection in projection2.
 *
 * @param {Array<Projection>} projections1 Projections with equal
 *     meaning.
 * @param {Array<Projection>} projections2 Projections with equal
 *     meaning.
 * @param {TransformFunction} forwardTransform Transformation from any
 *   projection in projection1 to any projection in projection2.
 * @param {TransformFunction} inverseTransform Transform from any projection
 *   in projection2 to any projection in projection1..
 */
function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
  projections1.forEach(function(projection1) {
    projections2.forEach(function(projection2) {
      Object(_proj_transforms_js__WEBPACK_IMPORTED_MODULE_8__["add"])(projection1, projection2, forwardTransform);
      Object(_proj_transforms_js__WEBPACK_IMPORTED_MODULE_8__["add"])(projection2, projection1, inverseTransform);
    });
  });
}


/**
 * Clear all cached projections and transforms.
 */
function clearAllProjections() {
  _proj_projections_js__WEBPACK_IMPORTED_MODULE_7__["clear"]();
  Object(_proj_transforms_js__WEBPACK_IMPORTED_MODULE_8__["clear"])();
}


/**
 * @param {Projection|string|undefined} projection Projection.
 * @param {string} defaultCode Default code.
 * @return {Projection} Projection.
 */
function createProjection(projection, defaultCode) {
  if (!projection) {
    return get(defaultCode);
  } else if (typeof projection === 'string') {
    return get(projection);
  } else {
    return (
      /** @type {Projection} */ (projection)
    );
  }
}


/**
 * Creates a {@link module:ol/proj~TransformFunction} from a simple 2D coordinate transform
 * function.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} coordTransform Coordinate
 *     transform.
 * @return {TransformFunction} Transform function.
 */
function createTransformFromCoordinateTransform(coordTransform) {
  return (
    /**
     * @param {Array<number>} input Input.
     * @param {Array<number>=} opt_output Output.
     * @param {number=} opt_dimension Dimension.
     * @return {Array<number>} Output.
     */
    function(input, opt_output, opt_dimension) {
      var length = input.length;
      var dimension = opt_dimension !== undefined ? opt_dimension : 2;
      var output = opt_output !== undefined ? opt_output : new Array(length);
      for (var i = 0; i < length; i += dimension) {
        var point = coordTransform([input[i], input[i + 1]]);
        output[i] = point[0];
        output[i + 1] = point[1];
        for (var j = dimension - 1; j >= 2; --j) {
          output[i + j] = input[i + j];
        }
      }
      return output;
    });
}


/**
 * Registers coordinate transform functions to convert coordinates between the
 * source projection and the destination projection.
 * The forward and inverse functions convert coordinate pairs; this function
 * converts these into the functions used internally which also handle
 * extents and coordinate arrays.
 *
 * @param {ProjectionLike} source Source projection.
 * @param {ProjectionLike} destination Destination projection.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} forward The forward transform
 *     function (that is, from the source projection to the destination
 *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
 *     the transformed {@link module:ol/coordinate~Coordinate}.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} inverse The inverse transform
 *     function (that is, from the destination projection to the source
 *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
 *     the transformed {@link module:ol/coordinate~Coordinate}.
 * @api
 */
function addCoordinateTransforms(source, destination, forward, inverse) {
  var sourceProj = get(source);
  var destProj = get(destination);
  Object(_proj_transforms_js__WEBPACK_IMPORTED_MODULE_8__["add"])(sourceProj, destProj, createTransformFromCoordinateTransform(forward));
  Object(_proj_transforms_js__WEBPACK_IMPORTED_MODULE_8__["add"])(destProj, sourceProj, createTransformFromCoordinateTransform(inverse));
}


/**
 * Transforms a coordinate from longitude/latitude to a different projection.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate as longitude and latitude, i.e.
 *     an array with longitude as 1st and latitude as 2nd element.
 * @param {ProjectionLike=} opt_projection Target projection. The
 *     default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {import("./coordinate.js").Coordinate} Coordinate projected to the target projection.
 * @api
 */
function fromLonLat(coordinate, opt_projection) {
  return transform(coordinate, 'EPSG:4326',
    opt_projection !== undefined ? opt_projection : 'EPSG:3857');
}


/**
 * Transforms a coordinate to longitude/latitude.
 * @param {import("./coordinate.js").Coordinate} coordinate Projected coordinate.
 * @param {ProjectionLike=} opt_projection Projection of the coordinate.
 *     The default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {import("./coordinate.js").Coordinate} Coordinate as longitude and latitude, i.e. an array
 *     with longitude as 1st and latitude as 2nd element.
 * @api
 */
function toLonLat(coordinate, opt_projection) {
  var lonLat = transform(coordinate,
    opt_projection !== undefined ? opt_projection : 'EPSG:3857', 'EPSG:4326');
  var lon = lonLat[0];
  if (lon < -180 || lon > 180) {
    lonLat[0] = Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["modulo"])(lon + 180, 360) - 180;
  }
  return lonLat;
}


/**
 * Checks if two projections are the same, that is every coordinate in one
 * projection does represent the same geographic point as the same coordinate in
 * the other projection.
 *
 * @param {Projection} projection1 Projection 1.
 * @param {Projection} projection2 Projection 2.
 * @return {boolean} Equivalent.
 * @api
 */
function equivalent(projection1, projection2) {
  if (projection1 === projection2) {
    return true;
  }
  var equalUnits = projection1.getUnits() === projection2.getUnits();
  if (projection1.getCode() === projection2.getCode()) {
    return equalUnits;
  } else {
    var transformFunc = getTransformFromProjections(projection1, projection2);
    return transformFunc === cloneTransform && equalUnits;
  }
}


/**
 * Searches in the list of transform functions for the function for converting
 * coordinates from the source projection to the destination projection.
 *
 * @param {Projection} sourceProjection Source Projection object.
 * @param {Projection} destinationProjection Destination Projection
 *     object.
 * @return {TransformFunction} Transform function.
 */
function getTransformFromProjections(sourceProjection, destinationProjection) {
  var sourceCode = sourceProjection.getCode();
  var destinationCode = destinationProjection.getCode();
  var transformFunc = Object(_proj_transforms_js__WEBPACK_IMPORTED_MODULE_8__["get"])(sourceCode, destinationCode);
  if (!transformFunc) {
    transformFunc = identityTransform;
  }
  return transformFunc;
}


/**
 * Given the projection-like objects, searches for a transformation
 * function to convert a coordinates array from the source projection to the
 * destination projection.
 *
 * @param {ProjectionLike} source Source.
 * @param {ProjectionLike} destination Destination.
 * @return {TransformFunction} Transform function.
 * @api
 */
function getTransform(source, destination) {
  var sourceProjection = get(source);
  var destinationProjection = get(destination);
  return getTransformFromProjections(sourceProjection, destinationProjection);
}


/**
 * Transforms a coordinate from source projection to destination projection.
 * This returns a new coordinate (and does not modify the original).
 *
 * See {@link module:ol/proj~transformExtent} for extent transformation.
 * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its
 * subclasses for geometry transforms.
 *
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {ProjectionLike} source Source projection-like.
 * @param {ProjectionLike} destination Destination projection-like.
 * @return {import("./coordinate.js").Coordinate} Coordinate.
 * @api
 */
function transform(coordinate, source, destination) {
  var transformFunc = getTransform(source, destination);
  return transformFunc(coordinate, undefined, coordinate.length);
}


/**
 * Transforms an extent from source projection to destination projection.  This
 * returns a new extent (and does not modify the original).
 *
 * @param {import("./extent.js").Extent} extent The extent to transform.
 * @param {ProjectionLike} source Source projection-like.
 * @param {ProjectionLike} destination Destination projection-like.
 * @return {import("./extent.js").Extent} The transformed extent.
 * @api
 */
function transformExtent(extent, source, destination) {
  var transformFunc = getTransform(source, destination);
  return Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["applyTransform"])(extent, transformFunc);
}


/**
 * Transforms the given point to the destination projection.
 *
 * @param {import("./coordinate.js").Coordinate} point Point.
 * @param {Projection} sourceProjection Source projection.
 * @param {Projection} destinationProjection Destination projection.
 * @return {import("./coordinate.js").Coordinate} Point.
 */
function transformWithProjections(point, sourceProjection, destinationProjection) {
  var transformFunc = getTransformFromProjections(sourceProjection, destinationProjection);
  return transformFunc(point);
}

/**
 * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called
 * by when this module is executed and should only need to be called again after
 * `clearAllProjections()` is called (e.g. in tests).
 */
function addCommon() {
  // Add transformations that don't alter coordinates to convert within set of
  // projections with equal meaning.
  addEquivalentProjections(_proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_3__["PROJECTIONS"]);
  addEquivalentProjections(_proj_epsg4326_js__WEBPACK_IMPORTED_MODULE_4__["PROJECTIONS"]);
  // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like
  // coordinates and back.
  addEquivalentTransforms(_proj_epsg4326_js__WEBPACK_IMPORTED_MODULE_4__["PROJECTIONS"], _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_3__["PROJECTIONS"], _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_3__["fromEPSG4326"], _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_3__["toEPSG4326"]);
}

addCommon();

//# sourceMappingURL=proj.js.map

/***/ }),

/***/ "./node_modules/ol/proj/Projection.js":
/*!********************************************!*\
  !*** ./node_modules/ol/proj/Projection.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Units_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Units.js */ "./node_modules/ol/proj/Units.js");
/**
 * @module ol/proj/Projection
 */



/**
 * @typedef {Object} Options
 * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.
 * @property {import("./Units.js").default|string} [units] Units. Required unless a
 * proj4 projection is defined for `code`.
 * @property {import("../extent.js").Extent} [extent] The validity extent for the SRS.
 * @property {string} [axisOrientation='enu'] The axis orientation as specified in Proj4.
 * @property {boolean} [global=false] Whether the projection is valid for the whole globe.
 * @property {number} [metersPerUnit] The meters per unit for the SRS.
 * If not provided, the `units` are used to get the meters per unit from the {@link module:ol/proj/Units~METERS_PER_UNIT}
 * lookup table.
 * @property {import("../extent.js").Extent} [worldExtent] The world extent for the SRS.
 * @property {function(number, import("../coordinate.js").Coordinate):number} [getPointResolution]
 * Function to determine resolution at a point. The function is called with a
 * `{number}` view resolution and an `{import("../coordinate.js").Coordinate}` as arguments, and returns
 * the `{number}` resolution at the passed coordinate. If this is `undefined`,
 * the default {@link module:ol/proj#getPointResolution} function will be used.
 */


/**
 * @classdesc
 * Projection definition class. One of these is created for each projection
 * supported in the application and stored in the {@link module:ol/proj} namespace.
 * You can use these in applications, but this is not required, as API params
 * and options use {@link module:ol/proj~ProjectionLike} which means the simple string
 * code will suffice.
 *
 * You can use {@link module:ol/proj~get} to retrieve the object for a particular
 * projection.
 *
 * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together
 * with the following aliases:
 * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,
 *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,
 *     http://www.opengis.net/gml/srs/epsg.xml#4326,
 *     urn:x-ogc:def:crs:EPSG:4326
 * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,
 *     urn:ogc:def:crs:EPSG:6.18:3:3857,
 *     http://www.opengis.net/gml/srs/epsg.xml#3857
 *
 * If you use [proj4js](https://github.com/proj4js/proj4js), aliases can
 * be added using `proj4.defs()`. After all required projection definitions are
 * added, call the {@link module:ol/proj/proj4~register} function.
 *
 * @api
 */
var Projection = function Projection(options) {
  /**
   * @private
   * @type {string}
   */
  this.code_ = options.code;

  /**
   * Units of projected coordinates. When set to `TILE_PIXELS`, a
   * `this.extent_` and `this.worldExtent_` must be configured properly for each
   * tile.
   * @private
   * @type {import("./Units.js").default}
   */
  this.units_ = /** @type {import("./Units.js").default} */ (options.units);

  /**
   * Validity extent of the projection in projected coordinates. For projections
   * with `TILE_PIXELS` units, this is the extent of the tile in
   * tile pixel space.
   * @private
   * @type {import("../extent.js").Extent}
   */
  this.extent_ = options.extent !== undefined ? options.extent : null;

  /**
   * Extent of the world in EPSG:4326. For projections with
   * `TILE_PIXELS` units, this is the extent of the tile in
   * projected coordinate space.
   * @private
   * @type {import("../extent.js").Extent}
   */
  this.worldExtent_ = options.worldExtent !== undefined ?
    options.worldExtent : null;

  /**
   * @private
   * @type {string}
   */
  this.axisOrientation_ = options.axisOrientation !== undefined ?
    options.axisOrientation : 'enu';

  /**
   * @private
   * @type {boolean}
   */
  this.global_ = options.global !== undefined ? options.global : false;

  /**
   * @private
   * @type {boolean}
   */
  this.canWrapX_ = !!(this.global_ && this.extent_);

  /**
   * @private
   * @type {function(number, import("../coordinate.js").Coordinate):number|undefined}
   */
  this.getPointResolutionFunc_ = options.getPointResolution;

  /**
   * @private
   * @type {import("../tilegrid/TileGrid.js").default}
   */
  this.defaultTileGrid_ = null;

  /**
   * @private
   * @type {number|undefined}
   */
  this.metersPerUnit_ = options.metersPerUnit;
};

/**
 * @return {boolean} The projection is suitable for wrapping the x-axis
 */
Projection.prototype.canWrapX = function canWrapX () {
  return this.canWrapX_;
};

/**
 * Get the code for this projection, e.g. 'EPSG:4326'.
 * @return {string} Code.
 * @api
 */
Projection.prototype.getCode = function getCode () {
  return this.code_;
};

/**
 * Get the validity extent for this projection.
 * @return {import("../extent.js").Extent} Extent.
 * @api
 */
Projection.prototype.getExtent = function getExtent () {
  return this.extent_;
};

/**
 * Get the units of this projection.
 * @return {import("./Units.js").default} Units.
 * @api
 */
Projection.prototype.getUnits = function getUnits () {
  return this.units_;
};

/**
 * Get the amount of meters per unit of this projection.If the projection is
 * not configured with `metersPerUnit` or a units identifier, the return is
 * `undefined`.
 * @return {number|undefined} Meters.
 * @api
 */
Projection.prototype.getMetersPerUnit = function getMetersPerUnit () {
  return this.metersPerUnit_ || _Units_js__WEBPACK_IMPORTED_MODULE_0__["METERS_PER_UNIT"][this.units_];
};

/**
 * Get the world extent for this projection.
 * @return {import("../extent.js").Extent} Extent.
 * @api
 */
Projection.prototype.getWorldExtent = function getWorldExtent () {
  return this.worldExtent_;
};

/**
 * Get the axis orientation of this projection.
 * Example values are:
 * enu - the default easting, northing, elevation.
 * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
 *   or south orientated transverse mercator.
 * wnu - westing, northing, up - some planetary coordinate systems have
 *   "west positive" coordinate systems
 * @return {string} Axis orientation.
 * @api
 */
Projection.prototype.getAxisOrientation = function getAxisOrientation () {
  return this.axisOrientation_;
};

/**
 * Is this projection a global projection which spans the whole world?
 * @return {boolean} Whether the projection is global.
 * @api
 */
Projection.prototype.isGlobal = function isGlobal () {
  return this.global_;
};

/**
 * Set if the projection is a global projection which spans the whole world
 * @param {boolean} global Whether the projection is global.
 * @api
 */
Projection.prototype.setGlobal = function setGlobal (global) {
  this.global_ = global;
  this.canWrapX_ = !!(global && this.extent_);
};

/**
 * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
 */
Projection.prototype.getDefaultTileGrid = function getDefaultTileGrid () {
  return this.defaultTileGrid_;
};

/**
 * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
 */
Projection.prototype.setDefaultTileGrid = function setDefaultTileGrid (tileGrid) {
  this.defaultTileGrid_ = tileGrid;
};

/**
 * Set the validity extent for this projection.
 * @param {import("../extent.js").Extent} extent Extent.
 * @api
 */
Projection.prototype.setExtent = function setExtent (extent) {
  this.extent_ = extent;
  this.canWrapX_ = !!(this.global_ && extent);
};

/**
 * Set the world extent for this projection.
 * @param {import("../extent.js").Extent} worldExtent World extent
 *   [minlon, minlat, maxlon, maxlat].
 * @api
 */
Projection.prototype.setWorldExtent = function setWorldExtent (worldExtent) {
  this.worldExtent_ = worldExtent;
};

/**
 * Set the getPointResolution function (see {@link module:ol/proj~getPointResolution}
 * for this projection.
 * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
 * @api
 */
Projection.prototype.setGetPointResolution = function setGetPointResolution (func) {
  this.getPointResolutionFunc_ = func;
};

/**
 * Get the custom point resolution function for this projection (if set).
 * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
 * resolution function (if set).
 */
Projection.prototype.getPointResolutionFunc = function getPointResolutionFunc () {
  return this.getPointResolutionFunc_;
};

/* harmony default export */ __webpack_exports__["default"] = (Projection);

//# sourceMappingURL=Projection.js.map

/***/ }),

/***/ "./node_modules/ol/proj/Units.js":
/*!***************************************!*\
  !*** ./node_modules/ol/proj/Units.js ***!
  \***************************************/
/*! exports provided: METERS_PER_UNIT, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "METERS_PER_UNIT", function() { return METERS_PER_UNIT; });
/**
 * @module ol/proj/Units
 */

/**
 * Projection units: `'degrees'`, `'ft'`, `'m'`, `'pixels'`, `'tile-pixels'` or
 * `'us-ft'`.
 * @enum {string}
 */
var Units = {
  DEGREES: 'degrees',
  FEET: 'ft',
  METERS: 'm',
  PIXELS: 'pixels',
  TILE_PIXELS: 'tile-pixels',
  USFEET: 'us-ft'
};


/**
 * Meters per unit lookup table.
 * @const
 * @type {Object<Units, number>}
 * @api
 */
var METERS_PER_UNIT = {};
// use the radius of the Normal sphere
METERS_PER_UNIT[Units.DEGREES] = 2 * Math.PI * 6370997 / 360;
METERS_PER_UNIT[Units.FEET] = 0.3048;
METERS_PER_UNIT[Units.METERS] = 1;
METERS_PER_UNIT[Units.USFEET] = 1200 / 3937;

/* harmony default export */ __webpack_exports__["default"] = (Units);

//# sourceMappingURL=Units.js.map

/***/ }),

/***/ "./node_modules/ol/proj/epsg3857.js":
/*!******************************************!*\
  !*** ./node_modules/ol/proj/epsg3857.js ***!
  \******************************************/
/*! exports provided: RADIUS, HALF_SIZE, EXTENT, WORLD_EXTENT, PROJECTIONS, fromEPSG4326, toEPSG4326 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RADIUS", function() { return RADIUS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HALF_SIZE", function() { return HALF_SIZE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EXTENT", function() { return EXTENT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WORLD_EXTENT", function() { return WORLD_EXTENT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PROJECTIONS", function() { return PROJECTIONS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromEPSG4326", function() { return fromEPSG4326; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toEPSG4326", function() { return toEPSG4326; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _Projection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Projection.js */ "./node_modules/ol/proj/Projection.js");
/* harmony import */ var _Units_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Units.js */ "./node_modules/ol/proj/Units.js");
/**
 * @module ol/proj/epsg3857
 */





/**
 * Radius of WGS84 sphere
 *
 * @const
 * @type {number}
 */
var RADIUS = 6378137;


/**
 * @const
 * @type {number}
 */
var HALF_SIZE = Math.PI * RADIUS;


/**
 * @const
 * @type {import("../extent.js").Extent}
 */
var EXTENT = [
  -HALF_SIZE, -HALF_SIZE,
  HALF_SIZE, HALF_SIZE
];


/**
 * @const
 * @type {import("../extent.js").Extent}
 */
var WORLD_EXTENT = [-180, -85, 180, 85];


/**
 * @classdesc
 * Projection object for web/spherical Mercator (EPSG:3857).
 */
var EPSG3857Projection = /*@__PURE__*/(function (Projection) {
  function EPSG3857Projection(code) {
    Projection.call(this, {
      code: code,
      units: _Units_js__WEBPACK_IMPORTED_MODULE_2__["default"].METERS,
      extent: EXTENT,
      global: true,
      worldExtent: WORLD_EXTENT,
      getPointResolution: function(resolution, point) {
        return resolution / Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["cosh"])(point[1] / RADIUS);
      }
    });

  }

  if ( Projection ) EPSG3857Projection.__proto__ = Projection;
  EPSG3857Projection.prototype = Object.create( Projection && Projection.prototype );
  EPSG3857Projection.prototype.constructor = EPSG3857Projection;

  return EPSG3857Projection;
}(_Projection_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/**
 * Projections equal to EPSG:3857.
 *
 * @const
 * @type {Array<import("./Projection.js").default>}
 */
var PROJECTIONS = [
  new EPSG3857Projection('EPSG:3857'),
  new EPSG3857Projection('EPSG:102100'),
  new EPSG3857Projection('EPSG:102113'),
  new EPSG3857Projection('EPSG:900913'),
  new EPSG3857Projection('urn:ogc:def:crs:EPSG:6.18:3:3857'),
  new EPSG3857Projection('urn:ogc:def:crs:EPSG::3857'),
  new EPSG3857Projection('http://www.opengis.net/gml/srs/epsg.xml#3857')
];


/**
 * Transformation from EPSG:4326 to EPSG:3857.
 *
 * @param {Array<number>} input Input array of coordinate values.
 * @param {Array<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension (default is `2`).
 * @return {Array<number>} Output array of coordinate values.
 */
function fromEPSG4326(input, opt_output, opt_dimension) {
  var length = input.length;
  var dimension = opt_dimension > 1 ? opt_dimension : 2;
  var output = opt_output;
  if (output === undefined) {
    if (dimension > 2) {
      // preserve values beyond second dimension
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  var halfSize = HALF_SIZE;
  for (var i = 0; i < length; i += dimension) {
    output[i] = halfSize * input[i] / 180;
    var y = RADIUS *
        Math.log(Math.tan(Math.PI * (input[i + 1] + 90) / 360));
    if (y > halfSize) {
      y = halfSize;
    } else if (y < -halfSize) {
      y = -halfSize;
    }
    output[i + 1] = y;
  }
  return output;
}


/**
 * Transformation from EPSG:3857 to EPSG:4326.
 *
 * @param {Array<number>} input Input array of coordinate values.
 * @param {Array<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension (default is `2`).
 * @return {Array<number>} Output array of coordinate values.
 */
function toEPSG4326(input, opt_output, opt_dimension) {
  var length = input.length;
  var dimension = opt_dimension > 1 ? opt_dimension : 2;
  var output = opt_output;
  if (output === undefined) {
    if (dimension > 2) {
      // preserve values beyond second dimension
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (var i = 0; i < length; i += dimension) {
    output[i] = 180 * input[i] / HALF_SIZE;
    output[i + 1] = 360 * Math.atan(
      Math.exp(input[i + 1] / RADIUS)) / Math.PI - 90;
  }
  return output;
}

//# sourceMappingURL=epsg3857.js.map

/***/ }),

/***/ "./node_modules/ol/proj/epsg4326.js":
/*!******************************************!*\
  !*** ./node_modules/ol/proj/epsg4326.js ***!
  \******************************************/
/*! exports provided: RADIUS, EXTENT, METERS_PER_UNIT, PROJECTIONS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RADIUS", function() { return RADIUS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EXTENT", function() { return EXTENT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "METERS_PER_UNIT", function() { return METERS_PER_UNIT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PROJECTIONS", function() { return PROJECTIONS; });
/* harmony import */ var _Projection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Projection.js */ "./node_modules/ol/proj/Projection.js");
/* harmony import */ var _Units_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Units.js */ "./node_modules/ol/proj/Units.js");
/**
 * @module ol/proj/epsg4326
 */




/**
 * Semi-major radius of the WGS84 ellipsoid.
 *
 * @const
 * @type {number}
 */
var RADIUS = 6378137;


/**
 * Extent of the EPSG:4326 projection which is the whole world.
 *
 * @const
 * @type {import("../extent.js").Extent}
 */
var EXTENT = [-180, -90, 180, 90];


/**
 * @const
 * @type {number}
 */
var METERS_PER_UNIT = Math.PI * RADIUS / 180;


/**
 * @classdesc
 * Projection object for WGS84 geographic coordinates (EPSG:4326).
 *
 * Note that OpenLayers does not strictly comply with the EPSG definition.
 * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).
 * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.
 */
var EPSG4326Projection = /*@__PURE__*/(function (Projection) {
  function EPSG4326Projection(code, opt_axisOrientation) {
    Projection.call(this, {
      code: code,
      units: _Units_js__WEBPACK_IMPORTED_MODULE_1__["default"].DEGREES,
      extent: EXTENT,
      axisOrientation: opt_axisOrientation,
      global: true,
      metersPerUnit: METERS_PER_UNIT,
      worldExtent: EXTENT
    });

  }

  if ( Projection ) EPSG4326Projection.__proto__ = Projection;
  EPSG4326Projection.prototype = Object.create( Projection && Projection.prototype );
  EPSG4326Projection.prototype.constructor = EPSG4326Projection;

  return EPSG4326Projection;
}(_Projection_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/**
 * Projections equal to EPSG:4326.
 *
 * @const
 * @type {Array<import("./Projection.js").default>}
 */
var PROJECTIONS = [
  new EPSG4326Projection('CRS:84'),
  new EPSG4326Projection('EPSG:4326', 'neu'),
  new EPSG4326Projection('urn:ogc:def:crs:EPSG::4326', 'neu'),
  new EPSG4326Projection('urn:ogc:def:crs:EPSG:6.6:4326', 'neu'),
  new EPSG4326Projection('urn:ogc:def:crs:OGC:1.3:CRS84'),
  new EPSG4326Projection('urn:ogc:def:crs:OGC:2:84'),
  new EPSG4326Projection('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'),
  new EPSG4326Projection('urn:x-ogc:def:crs:EPSG:4326', 'neu')
];

//# sourceMappingURL=epsg4326.js.map

/***/ }),

/***/ "./node_modules/ol/proj/projections.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/proj/projections.js ***!
  \*********************************************/
/*! exports provided: clear, get, add */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clear", function() { return clear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return get; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/**
 * @module ol/proj/projections
 */


/**
 * @type {Object<string, import("./Projection.js").default>}
 */
var cache = {};


/**
 * Clear the projections cache.
 */
function clear() {
  cache = {};
}


/**
 * Get a cached projection by code.
 * @param {string} code The code for the projection.
 * @return {import("./Projection.js").default} The projection (if cached).
 */
function get(code) {
  return cache[code] || null;
}


/**
 * Add a projection to the cache.
 * @param {string} code The projection code.
 * @param {import("./Projection.js").default} projection The projection to cache.
 */
function add(code, projection) {
  cache[code] = projection;
}

//# sourceMappingURL=projections.js.map

/***/ }),

/***/ "./node_modules/ol/proj/transforms.js":
/*!********************************************!*\
  !*** ./node_modules/ol/proj/transforms.js ***!
  \********************************************/
/*! exports provided: clear, add, remove, get */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clear", function() { return clear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "remove", function() { return remove; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return get; });
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/proj/transforms
 */



/**
 * @private
 * @type {!Object<string, Object<string, import("../proj.js").TransformFunction>>}
 */
var transforms = {};


/**
 * Clear the transform cache.
 */
function clear() {
  transforms = {};
}


/**
 * Registers a conversion function to convert coordinates from the source
 * projection to the destination projection.
 *
 * @param {import("./Projection.js").default} source Source.
 * @param {import("./Projection.js").default} destination Destination.
 * @param {import("../proj.js").TransformFunction} transformFn Transform.
 */
function add(source, destination, transformFn) {
  var sourceCode = source.getCode();
  var destinationCode = destination.getCode();
  if (!(sourceCode in transforms)) {
    transforms[sourceCode] = {};
  }
  transforms[sourceCode][destinationCode] = transformFn;
}


/**
 * Unregisters the conversion function to convert coordinates from the source
 * projection to the destination projection.  This method is used to clean up
 * cached transforms during testing.
 *
 * @param {import("./Projection.js").default} source Source projection.
 * @param {import("./Projection.js").default} destination Destination projection.
 * @return {import("../proj.js").TransformFunction} transformFn The unregistered transform.
 */
function remove(source, destination) {
  var sourceCode = source.getCode();
  var destinationCode = destination.getCode();
  var transform = transforms[sourceCode][destinationCode];
  delete transforms[sourceCode][destinationCode];
  if (Object(_obj_js__WEBPACK_IMPORTED_MODULE_0__["isEmpty"])(transforms[sourceCode])) {
    delete transforms[sourceCode];
  }
  return transform;
}


/**
 * Get a transform given a source code and a destination code.
 * @param {string} sourceCode The code for the source projection.
 * @param {string} destinationCode The code for the destination projection.
 * @return {import("../proj.js").TransformFunction|undefined} The transform function (if found).
 */
function get(sourceCode, destinationCode) {
  var transform;
  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
    transform = transforms[sourceCode][destinationCode];
  }
  return transform;
}

//# sourceMappingURL=transforms.js.map

/***/ }),

/***/ "./node_modules/ol/render/Box.js":
/*!***************************************!*\
  !*** ./node_modules/ol/render/Box.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Disposable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Disposable.js */ "./node_modules/ol/Disposable.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geom/Polygon.js */ "./node_modules/ol/geom/Polygon.js");
/**
 * @module ol/render/Box
 */




var RenderBox = /*@__PURE__*/(function (Disposable) {
  function RenderBox(className) {
    Disposable.call(this);

    /**
     * @type {import("../geom/Polygon.js").default}
     * @private
     */
    this.geometry_ = null;

    /**
     * @type {HTMLDivElement}
     * @private
     */
    this.element_ = /** @type {HTMLDivElement} */ (document.createElement('div'));
    this.element_.style.position = 'absolute';
    this.element_.className = 'ol-box ' + className;

    /**
     * @private
     * @type {import("../PluggableMap.js").default}
     */
    this.map_ = null;

    /**
     * @private
     * @type {import("../pixel.js").Pixel}
     */
    this.startPixel_ = null;

    /**
     * @private
     * @type {import("../pixel.js").Pixel}
     */
    this.endPixel_ = null;

  }

  if ( Disposable ) RenderBox.__proto__ = Disposable;
  RenderBox.prototype = Object.create( Disposable && Disposable.prototype );
  RenderBox.prototype.constructor = RenderBox;

  /**
   * @inheritDoc
   */
  RenderBox.prototype.disposeInternal = function disposeInternal () {
    this.setMap(null);
  };

  /**
   * @private
   */
  RenderBox.prototype.render_ = function render_ () {
    var startPixel = this.startPixel_;
    var endPixel = this.endPixel_;
    var px = 'px';
    var style = this.element_.style;
    style.left = Math.min(startPixel[0], endPixel[0]) + px;
    style.top = Math.min(startPixel[1], endPixel[1]) + px;
    style.width = Math.abs(endPixel[0] - startPixel[0]) + px;
    style.height = Math.abs(endPixel[1] - startPixel[1]) + px;
  };

  /**
   * @param {import("../PluggableMap.js").default} map Map.
   */
  RenderBox.prototype.setMap = function setMap (map) {
    if (this.map_) {
      this.map_.getOverlayContainer().removeChild(this.element_);
      var style = this.element_.style;
      style.left = style.top = style.width = style.height = 'inherit';
    }
    this.map_ = map;
    if (this.map_) {
      this.map_.getOverlayContainer().appendChild(this.element_);
    }
  };

  /**
   * @param {import("../pixel.js").Pixel} startPixel Start pixel.
   * @param {import("../pixel.js").Pixel} endPixel End pixel.
   */
  RenderBox.prototype.setPixels = function setPixels (startPixel, endPixel) {
    this.startPixel_ = startPixel;
    this.endPixel_ = endPixel;
    this.createOrUpdateGeometry();
    this.render_();
  };

  /**
   * Creates or updates the cached geometry.
   */
  RenderBox.prototype.createOrUpdateGeometry = function createOrUpdateGeometry () {
    var startPixel = this.startPixel_;
    var endPixel = this.endPixel_;
    var pixels = [
      startPixel,
      [startPixel[0], endPixel[1]],
      endPixel,
      [endPixel[0], startPixel[1]]
    ];
    var coordinates = pixels.map(this.map_.getCoordinateFromPixel, this.map_);
    // close the polygon
    coordinates[4] = coordinates[0].slice();
    if (!this.geometry_) {
      this.geometry_ = new _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_1__["default"]([coordinates]);
    } else {
      this.geometry_.setCoordinates([coordinates]);
    }
  };

  /**
   * @return {import("../geom/Polygon.js").default} Geometry.
   */
  RenderBox.prototype.getGeometry = function getGeometry () {
    return this.geometry_;
  };

  return RenderBox;
}(_Disposable_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (RenderBox);

//# sourceMappingURL=Box.js.map

/***/ }),

/***/ "./node_modules/ol/render/Event.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/render/Event.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/**
 * @module ol/render/Event
 */



var RenderEvent = /*@__PURE__*/(function (Event) {
  function RenderEvent(type, opt_vectorContext, opt_frameState, opt_context, opt_glContext) {

    Event.call(this, type);

    /**
     * For canvas, this is an instance of {@link module:ol/render/canvas/Immediate}.
     * @type {import("./VectorContext.js").default|undefined}
     * @api
     */
    this.vectorContext = opt_vectorContext;

    /**
     * An object representing the current render frame state.
     * @type {import("../PluggableMap.js").FrameState|undefined}
     * @api
     */
    this.frameState = opt_frameState;

    /**
     * Canvas context. Only available when a Canvas renderer is used, null
     * otherwise.
     * @type {CanvasRenderingContext2D|null|undefined}
     * @api
     */
    this.context = opt_context;

    /**
     * WebGL context. Only available when a WebGL renderer is used, null
     * otherwise.
     * @type {import("../webgl/Context.js").default|null|undefined}
     * @api
     */
    this.glContext = opt_glContext;

  }

  if ( Event ) RenderEvent.__proto__ = Event;
  RenderEvent.prototype = Object.create( Event && Event.prototype );
  RenderEvent.prototype.constructor = RenderEvent;

  return RenderEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_0__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (RenderEvent);

//# sourceMappingURL=Event.js.map

/***/ }),

/***/ "./node_modules/ol/render/EventType.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/render/EventType.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/render/EventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  /**
   * @event module:ol/render/Event~RenderEvent#postcompose
   * @api
   */
  POSTCOMPOSE: 'postcompose',
  /**
   * @event module:ol/render/Event~RenderEvent#precompose
   * @api
   */
  PRECOMPOSE: 'precompose',
  /**
   * @event module:ol/render/Event~RenderEvent#render
   * @api
   */
  RENDER: 'render',
  /**
   * Triggered when rendering is complete, i.e. all sources and tiles have
   * finished loading for the current viewport, and all tiles are faded in.
   * @event module:ol/render/Event~RenderEvent#rendercomplete
   * @api
   */
  RENDERCOMPLETE: 'rendercomplete'
});

//# sourceMappingURL=EventType.js.map

/***/ }),

/***/ "./node_modules/ol/render/ReplayGroup.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/render/ReplayGroup.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/**
 * @module ol/render/ReplayGroup
 */


/**
 * Base class for replay groups.
 */
var ReplayGroup = function ReplayGroup () {};

ReplayGroup.prototype.getReplay = function getReplay (zIndex, replayType) {
  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
};

/**
 * @abstract
 * @return {boolean} Is empty.
 */
ReplayGroup.prototype.isEmpty = function isEmpty () {
  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
};

/**
 * @abstract
 * @param {boolean} group Group with previous replay
 * @return {Array<*>} The resulting instruction group
 */
ReplayGroup.prototype.addDeclutter = function addDeclutter (group) {
  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
};

/* harmony default export */ __webpack_exports__["default"] = (ReplayGroup);

//# sourceMappingURL=ReplayGroup.js.map

/***/ }),

/***/ "./node_modules/ol/render/ReplayType.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/render/ReplayType.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/render/ReplayType
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  CIRCLE: 'Circle',
  DEFAULT: 'Default',
  IMAGE: 'Image',
  LINE_STRING: 'LineString',
  POLYGON: 'Polygon',
  TEXT: 'Text'
});

//# sourceMappingURL=ReplayType.js.map

/***/ }),

/***/ "./node_modules/ol/render/VectorContext.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/render/VectorContext.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/render/VectorContext
 */

/**
 * @classdesc
 * Context for drawing geometries.  A vector context is available on render
 * events and does not need to be constructed directly.
 * @api
 */
var VectorContext = function VectorContext () {};

VectorContext.prototype.drawCustom = function drawCustom (geometry, feature, renderer) {};

/**
 * Render a geometry.
 *
 * @param {import("../geom/Geometry.js").default} geometry The geometry to render.
 */
VectorContext.prototype.drawGeometry = function drawGeometry (geometry) {};

/**
 * Set the rendering style.
 *
 * @param {import("../style/Style.js").default} style The rendering style.
 */
VectorContext.prototype.setStyle = function setStyle (style) {};

/**
 * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.
 * @param {import("../Feature.js").default} feature Feature.
 */
VectorContext.prototype.drawCircle = function drawCircle (circleGeometry, feature) {};

/**
 * @param {import("../Feature.js").default} feature Feature.
 * @param {import("../style/Style.js").default} style Style.
 */
VectorContext.prototype.drawFeature = function drawFeature (feature, style) {};

/**
 * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.
 * @param {import("../Feature.js").default} feature Feature.
 */
VectorContext.prototype.drawGeometryCollection = function drawGeometryCollection (geometryCollectionGeometry, feature) {};

/**
 * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.
 * @param {import("../Feature.js").default|import("./Feature.js").default} feature Feature.
 */
VectorContext.prototype.drawLineString = function drawLineString (lineStringGeometry, feature) {};

/**
 * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.
 * @param {import("../Feature.js").default|import("./Feature.js").default} feature Feature.
 */
VectorContext.prototype.drawMultiLineString = function drawMultiLineString (multiLineStringGeometry, feature) {};

/**
 * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.
 * @param {import("../Feature.js").default|import("./Feature.js").default} feature Feature.
 */
VectorContext.prototype.drawMultiPoint = function drawMultiPoint (multiPointGeometry, feature) {};

/**
 * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
 * @param {import("../Feature.js").default|import("./Feature.js").default} feature Feature.
 */
VectorContext.prototype.drawMultiPolygon = function drawMultiPolygon (multiPolygonGeometry, feature) {};

/**
 * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.
 * @param {import("../Feature.js").default|import("./Feature.js").default} feature Feature.
 */
VectorContext.prototype.drawPoint = function drawPoint (pointGeometry, feature) {};

/**
 * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.
 * @param {import("../Feature.js").default|import("./Feature.js").default} feature Feature.
 */
VectorContext.prototype.drawPolygon = function drawPolygon (polygonGeometry, feature) {};

/**
 * @param {import("../geom/Geometry.js").default|import("./Feature.js").default} geometry Geometry.
 * @param {import("../Feature.js").default|import("./Feature.js").default} feature Feature.
 */
VectorContext.prototype.drawText = function drawText (geometry, feature) {};

/**
 * @param {import("../style/Fill.js").default} fillStyle Fill style.
 * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.
 */
VectorContext.prototype.setFillStrokeStyle = function setFillStrokeStyle (fillStyle, strokeStyle) {};

/**
 * @param {import("../style/Image.js").default} imageStyle Image style.
 * @param {import("./canvas.js").DeclutterGroup=} opt_declutterGroup Declutter.
 */
VectorContext.prototype.setImageStyle = function setImageStyle (imageStyle, opt_declutterGroup) {};

/**
 * @param {import("../style/Text.js").default} textStyle Text style.
 * @param {import("./canvas.js").DeclutterGroup=} opt_declutterGroup Declutter.
 */
VectorContext.prototype.setTextStyle = function setTextStyle (textStyle, opt_declutterGroup) {};

/* harmony default export */ __webpack_exports__["default"] = (VectorContext);

//# sourceMappingURL=VectorContext.js.map

/***/ }),

/***/ "./node_modules/ol/render/canvas.js":
/*!******************************************!*\
  !*** ./node_modules/ol/render/canvas.js ***!
  \******************************************/
/*! exports provided: defaultFont, defaultFillStyle, defaultLineCap, defaultLineDash, defaultLineDashOffset, defaultLineJoin, defaultMiterLimit, defaultStrokeStyle, defaultTextAlign, defaultTextBaseline, defaultPadding, defaultLineWidth, labelCache, checkedFonts, textHeights, checkFont, measureTextHeight, measureTextWidth, rotateAtOffset, resetTransform, drawImage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultFont", function() { return defaultFont; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultFillStyle", function() { return defaultFillStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultLineCap", function() { return defaultLineCap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultLineDash", function() { return defaultLineDash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultLineDashOffset", function() { return defaultLineDashOffset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultLineJoin", function() { return defaultLineJoin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultMiterLimit", function() { return defaultMiterLimit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultStrokeStyle", function() { return defaultStrokeStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultTextAlign", function() { return defaultTextAlign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultTextBaseline", function() { return defaultTextBaseline; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultPadding", function() { return defaultPadding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultLineWidth", function() { return defaultLineWidth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "labelCache", function() { return labelCache; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkedFonts", function() { return checkedFonts; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "textHeights", function() { return textHeights; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkFont", function() { return checkFont; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "measureTextHeight", function() { return measureTextHeight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "measureTextWidth", function() { return measureTextWidth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateAtOffset", function() { return rotateAtOffset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resetTransform", function() { return resetTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawImage", function() { return drawImage; });
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../css.js */ "./node_modules/ol/css.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _structs_LRUCache_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../structs/LRUCache.js */ "./node_modules/ol/structs/LRUCache.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/render/canvas
 */







/**
 * @typedef {Object} FillState
 * @property {import("../colorlike.js").ColorLike} fillStyle
 */


/**
 * @typedef {Object} FillStrokeState
 * @property {import("../colorlike.js").ColorLike} [currentFillStyle]
 * @property {import("../colorlike.js").ColorLike} [currentStrokeStyle]
 * @property {string} [currentLineCap]
 * @property {Array<number>} currentLineDash
 * @property {number} [currentLineDashOffset]
 * @property {string} [currentLineJoin]
 * @property {number} [currentLineWidth]
 * @property {number} [currentMiterLimit]
 * @property {number} [lastStroke]
 * @property {import("../colorlike.js").ColorLike} [fillStyle]
 * @property {import("../colorlike.js").ColorLike} [strokeStyle]
 * @property {string} [lineCap]
 * @property {Array<number>} lineDash
 * @property {number} [lineDashOffset]
 * @property {string} [lineJoin]
 * @property {number} [lineWidth]
 * @property {number} [miterLimit]
 */


/**
 * @typedef {Object} StrokeState
 * @property {string} lineCap
 * @property {Array<number>} lineDash
 * @property {number} lineDashOffset
 * @property {string} lineJoin
 * @property {number} lineWidth
 * @property {number} miterLimit
 * @property {import("../colorlike.js").ColorLike} strokeStyle
 */


/**
 * @typedef {Object} TextState
 * @property {string} font
 * @property {string} [textAlign]
 * @property {string} textBaseline
 * @property {string} [placement]
 * @property {number} [maxAngle]
 * @property {boolean} [overflow]
 * @property {import("../style/Fill.js").default} [backgroundFill]
 * @property {import("../style/Stroke.js").default} [backgroundStroke]
 * @property {number} [scale]
 * @property {Array<number>} [padding]
 */


/**
 * Container for decluttered replay instructions that need to be rendered or
 * omitted together, i.e. when styles render both an image and text, or for the
 * characters that form text along lines. The basic elements of this array are
 * `[minX, minY, maxX, maxY, count]`, where the first four entries are the
 * rendered extent of the group in pixel space. `count` is the number of styles
 * in the group, i.e. 2 when an image and a text are grouped, or 1 otherwise.
 * In addition to these four elements, declutter instruction arrays (i.e. the
 * arguments to {@link module:ol/render/canvas~drawImage} are appended to the array.
 * @typedef {Array<*>} DeclutterGroup
 */


/**
 * @const
 * @type {string}
 */
var defaultFont = '10px sans-serif';


/**
 * @const
 * @type {import("../color.js").Color}
 */
var defaultFillStyle = [0, 0, 0, 1];


/**
 * @const
 * @type {string}
 */
var defaultLineCap = 'round';


/**
 * @const
 * @type {Array<number>}
 */
var defaultLineDash = [];


/**
 * @const
 * @type {number}
 */
var defaultLineDashOffset = 0;


/**
 * @const
 * @type {string}
 */
var defaultLineJoin = 'round';


/**
 * @const
 * @type {number}
 */
var defaultMiterLimit = 10;


/**
 * @const
 * @type {import("../color.js").Color}
 */
var defaultStrokeStyle = [0, 0, 0, 1];


/**
 * @const
 * @type {string}
 */
var defaultTextAlign = 'center';


/**
 * @const
 * @type {string}
 */
var defaultTextBaseline = 'middle';


/**
 * @const
 * @type {Array<number>}
 */
var defaultPadding = [0, 0, 0, 0];


/**
 * @const
 * @type {number}
 */
var defaultLineWidth = 1;


/**
 * The label cache for text rendering. To change the default cache size of 2048
 * entries, use {@link module:ol/structs/LRUCache#setSize}.
 * @type {LRUCache<HTMLCanvasElement>}
 * @api
 */
var labelCache = new _structs_LRUCache_js__WEBPACK_IMPORTED_MODULE_3__["default"]();


/**
 * @type {!Object<string, number>}
 */
var checkedFonts = {};


/**
 * @type {CanvasRenderingContext2D}
 */
var measureContext = null;


/**
 * @type {!Object<string, number>}
 */
var textHeights = {};


/**
 * Clears the label cache when a font becomes available.
 * @param {string} fontSpec CSS font spec.
 */
var checkFont = (function() {
  var retries = 60;
  var checked = checkedFonts;
  var size = '32px ';
  var referenceFonts = ['monospace', 'serif'];
  var len = referenceFonts.length;
  var text = 'wmytzilWMYTZIL@#/&?$%10\uF013';
  var interval, referenceWidth;

  function isAvailable(font) {
    var context = getMeasureContext();
    // Check weight ranges according to
    // https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight#Fallback_weights
    for (var weight = 100; weight <= 700; weight += 300) {
      var fontWeight = weight + ' ';
      var available = true;
      for (var i = 0; i < len; ++i) {
        var referenceFont = referenceFonts[i];
        context.font = fontWeight + size + referenceFont;
        referenceWidth = context.measureText(text).width;
        if (font != referenceFont) {
          context.font = fontWeight + size + font + ',' + referenceFont;
          var width = context.measureText(text).width;
          // If width and referenceWidth are the same, then the fallback was used
          // instead of the font we wanted, so the font is not available.
          available = available && width != referenceWidth;
        }
      }
      if (available) {
        // Consider font available when it is available in one weight range.
        //FIXME With this we miss rare corner cases, so we should consider
        //FIXME checking availability for each requested weight range.
        return true;
      }
    }
    return false;
  }

  function check() {
    var done = true;
    for (var font in checked) {
      if (checked[font] < retries) {
        if (isAvailable(font)) {
          checked[font] = retries;
          Object(_obj_js__WEBPACK_IMPORTED_MODULE_2__["clear"])(textHeights);
          // Make sure that loaded fonts are picked up by Safari
          measureContext = null;
          labelCache.clear();
        } else {
          ++checked[font];
          done = false;
        }
      }
    }
    if (done) {
      clearInterval(interval);
      interval = undefined;
    }
  }

  return function(fontSpec) {
    var fontFamilies = Object(_css_js__WEBPACK_IMPORTED_MODULE_0__["getFontFamilies"])(fontSpec);
    if (!fontFamilies) {
      return;
    }
    for (var i = 0, ii = fontFamilies.length; i < ii; ++i) {
      var fontFamily = fontFamilies[i];
      if (!(fontFamily in checked)) {
        checked[fontFamily] = retries;
        if (!isAvailable(fontFamily)) {
          checked[fontFamily] = 0;
          if (interval === undefined) {
            interval = setInterval(check, 32);
          }
        }
      }
    }
  };
})();


/**
 * @return {CanvasRenderingContext2D} Measure context.
 */
function getMeasureContext() {
  if (!measureContext) {
    measureContext = Object(_dom_js__WEBPACK_IMPORTED_MODULE_1__["createCanvasContext2D"])(1, 1);
  }
  return measureContext;
}


/**
 * @param {string} font Font to use for measuring.
 * @return {import("../size.js").Size} Measurement.
 */
var measureTextHeight = (function() {
  var span;
  var heights = textHeights;
  return function(font) {
    var height = heights[font];
    if (height == undefined) {
      if (!span) {
        span = document.createElement('span');
        span.textContent = 'M';
        span.style.margin = span.style.padding = '0 !important';
        span.style.position = 'absolute !important';
        span.style.left = '-99999px !important';
      }
      span.style.font = font;
      document.body.appendChild(span);
      height = heights[font] = span.offsetHeight;
      document.body.removeChild(span);
    }
    return height;
  };
})();


/**
 * @param {string} font Font.
 * @param {string} text Text.
 * @return {number} Width.
 */
function measureTextWidth(font, text) {
  var measureContext = getMeasureContext();
  if (font != measureContext.font) {
    measureContext.font = font;
  }
  return measureContext.measureText(text).width;
}


/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} rotation Rotation.
 * @param {number} offsetX X offset.
 * @param {number} offsetY Y offset.
 */
function rotateAtOffset(context, rotation, offsetX, offsetY) {
  if (rotation !== 0) {
    context.translate(offsetX, offsetY);
    context.rotate(rotation);
    context.translate(-offsetX, -offsetY);
  }
}


var resetTransform = Object(_transform_js__WEBPACK_IMPORTED_MODULE_4__["create"])();


/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {import("../transform.js").Transform|null} transform Transform.
 * @param {number} opacity Opacity.
 * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} image Image.
 * @param {number} originX Origin X.
 * @param {number} originY Origin Y.
 * @param {number} w Width.
 * @param {number} h Height.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} scale Scale.
 */
function drawImage(context,
  transform, opacity, image, originX, originY, w, h, x, y, scale) {
  var alpha;
  if (opacity != 1) {
    alpha = context.globalAlpha;
    context.globalAlpha = alpha * opacity;
  }
  if (transform) {
    context.setTransform.apply(context, transform);
  }

  context.drawImage(image, originX, originY, w, h, x, y, w * scale, h * scale);

  if (alpha) {
    context.globalAlpha = alpha;
  }
  if (transform) {
    context.setTransform.apply(context, resetTransform);
  }
}

//# sourceMappingURL=canvas.js.map

/***/ }),

/***/ "./node_modules/ol/render/canvas/ImageReplay.js":
/*!******************************************************!*\
  !*** ./node_modules/ol/render/canvas/ImageReplay.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Instruction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Instruction.js */ "./node_modules/ol/render/canvas/Instruction.js");
/* harmony import */ var _Replay_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Replay.js */ "./node_modules/ol/render/canvas/Replay.js");
/**
 * @module ol/render/canvas/ImageReplay
 */



var CanvasImageReplay = /*@__PURE__*/(function (CanvasReplay) {
  function CanvasImageReplay(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {
    CanvasReplay.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);

    /**
     * @private
     * @type {import("../canvas.js").DeclutterGroup}
     */
    this.declutterGroup_ = null;

    /**
     * @private
     * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
     */
    this.hitDetectionImage_ = null;

    /**
     * @private
     * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
     */
    this.image_ = null;

    /**
     * @private
     * @type {number|undefined}
     */
    this.anchorX_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.anchorY_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.height_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.opacity_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.originX_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.originY_ = undefined;

    /**
     * @private
     * @type {boolean|undefined}
     */
    this.rotateWithView_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.rotation_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.scale_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.width_ = undefined;

  }

  if ( CanvasReplay ) CanvasImageReplay.__proto__ = CanvasReplay;
  CanvasImageReplay.prototype = Object.create( CanvasReplay && CanvasReplay.prototype );
  CanvasImageReplay.prototype.constructor = CanvasImageReplay;

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   * @return {number} My end.
   */
  CanvasImageReplay.prototype.drawCoordinates_ = function drawCoordinates_ (flatCoordinates, offset, end, stride) {
    return this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);
  };

  /**
   * @inheritDoc
   */
  CanvasImageReplay.prototype.drawPoint = function drawPoint (pointGeometry, feature) {
    if (!this.image_) {
      return;
    }
    this.beginGeometry(pointGeometry, feature);
    var flatCoordinates = pointGeometry.getFlatCoordinates();
    var stride = pointGeometry.getStride();
    var myBegin = this.coordinates.length;
    var myEnd = this.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
    this.instructions.push([
      _Instruction_js__WEBPACK_IMPORTED_MODULE_0__["default"].DRAW_IMAGE, myBegin, myEnd, this.image_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_,
      this.originX_, this.originY_, this.rotateWithView_, this.rotation_,
      this.scale_ * this.pixelRatio, this.width_
    ]);
    this.hitDetectionInstructions.push([
      _Instruction_js__WEBPACK_IMPORTED_MODULE_0__["default"].DRAW_IMAGE, myBegin, myEnd, this.hitDetectionImage_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_,
      this.originX_, this.originY_, this.rotateWithView_, this.rotation_,
      this.scale_, this.width_
    ]);
    this.endGeometry(pointGeometry, feature);
  };

  /**
   * @inheritDoc
   */
  CanvasImageReplay.prototype.drawMultiPoint = function drawMultiPoint (multiPointGeometry, feature) {
    if (!this.image_) {
      return;
    }
    this.beginGeometry(multiPointGeometry, feature);
    var flatCoordinates = multiPointGeometry.getFlatCoordinates();
    var stride = multiPointGeometry.getStride();
    var myBegin = this.coordinates.length;
    var myEnd = this.drawCoordinates_(
      flatCoordinates, 0, flatCoordinates.length, stride);
    this.instructions.push([
      _Instruction_js__WEBPACK_IMPORTED_MODULE_0__["default"].DRAW_IMAGE, myBegin, myEnd, this.image_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_,
      this.originX_, this.originY_, this.rotateWithView_, this.rotation_,
      this.scale_ * this.pixelRatio, this.width_
    ]);
    this.hitDetectionInstructions.push([
      _Instruction_js__WEBPACK_IMPORTED_MODULE_0__["default"].DRAW_IMAGE, myBegin, myEnd, this.hitDetectionImage_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_,
      this.originX_, this.originY_, this.rotateWithView_, this.rotation_,
      this.scale_, this.width_
    ]);
    this.endGeometry(multiPointGeometry, feature);
  };

  /**
   * @inheritDoc
   */
  CanvasImageReplay.prototype.finish = function finish () {
    this.reverseHitDetectionInstructions();
    // FIXME this doesn't really protect us against further calls to draw*Geometry
    this.anchorX_ = undefined;
    this.anchorY_ = undefined;
    this.hitDetectionImage_ = null;
    this.image_ = null;
    this.height_ = undefined;
    this.scale_ = undefined;
    this.opacity_ = undefined;
    this.originX_ = undefined;
    this.originY_ = undefined;
    this.rotateWithView_ = undefined;
    this.rotation_ = undefined;
    this.width_ = undefined;
  };

  /**
   * @inheritDoc
   */
  CanvasImageReplay.prototype.setImageStyle = function setImageStyle (imageStyle, declutterGroup) {
    var anchor = imageStyle.getAnchor();
    var size = imageStyle.getSize();
    var hitDetectionImage = imageStyle.getHitDetectionImage(1);
    var image = imageStyle.getImage(1);
    var origin = imageStyle.getOrigin();
    this.anchorX_ = anchor[0];
    this.anchorY_ = anchor[1];
    this.declutterGroup_ = /** @type {import("../canvas.js").DeclutterGroup} */ (declutterGroup);
    this.hitDetectionImage_ = hitDetectionImage;
    this.image_ = image;
    this.height_ = size[1];
    this.opacity_ = imageStyle.getOpacity();
    this.originX_ = origin[0];
    this.originY_ = origin[1];
    this.rotateWithView_ = imageStyle.getRotateWithView();
    this.rotation_ = imageStyle.getRotation();
    this.scale_ = imageStyle.getScale();
    this.width_ = size[0];
  };

  return CanvasImageReplay;
}(_Replay_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (CanvasImageReplay);

//# sourceMappingURL=ImageReplay.js.map

/***/ }),

/***/ "./node_modules/ol/render/canvas/Immediate.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/render/canvas/Immediate.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _colorlike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../colorlike.js */ "./node_modules/ol/colorlike.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../geom/SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../geom/flat/transform.js */ "./node_modules/ol/geom/flat/transform.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _VectorContext_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../VectorContext.js */ "./node_modules/ol/render/VectorContext.js");
/* harmony import */ var _canvas_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/render/canvas/Immediate
 */
// FIXME test, especially polygons with holes and multipolygons
// FIXME need to handle large thick features (where pixel size matters)
// FIXME add offset and end to ol/geom/flat/transform~transform2D?












/**
 * @classdesc
 * A concrete subclass of {@link module:ol/render/VectorContext} that implements
 * direct rendering of features and geometries to an HTML5 Canvas context.
 * Instances of this class are created internally by the library and
 * provided to application code as vectorContext member of the
 * {@link module:ol/render/Event~RenderEvent} object associated with postcompose, precompose and
 * render events emitted by layers and maps.
 */
var CanvasImmediateRenderer = /*@__PURE__*/(function (VectorContext) {
  function CanvasImmediateRenderer(context, pixelRatio, extent, transform, viewRotation) {
    VectorContext.call(this);

    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */
    this.context_ = context;

    /**
     * @private
     * @type {number}
     */
    this.pixelRatio_ = pixelRatio;

    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */
    this.extent_ = extent;

    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */
    this.transform_ = transform;

    /**
     * @private
     * @type {number}
     */
    this.viewRotation_ = viewRotation;

    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */
    this.contextFillState_ = null;

    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */
    this.contextStrokeState_ = null;

    /**
     * @private
     * @type {?import("../canvas.js").TextState}
     */
    this.contextTextState_ = null;

    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */
    this.fillState_ = null;

    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */
    this.strokeState_ = null;

    /**
     * @private
     * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
     */
    this.image_ = null;

    /**
     * @private
     * @type {number}
     */
    this.imageAnchorX_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.imageAnchorY_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.imageHeight_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.imageOpacity_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.imageOriginX_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.imageOriginY_ = 0;

    /**
     * @private
     * @type {boolean}
     */
    this.imageRotateWithView_ = false;

    /**
     * @private
     * @type {number}
     */
    this.imageRotation_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.imageScale_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.imageWidth_ = 0;

    /**
     * @private
     * @type {string}
     */
    this.text_ = '';

    /**
     * @private
     * @type {number}
     */
    this.textOffsetX_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.textOffsetY_ = 0;

    /**
     * @private
     * @type {boolean}
     */
    this.textRotateWithView_ = false;

    /**
     * @private
     * @type {number}
     */
    this.textRotation_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.textScale_ = 0;

    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */
    this.textFillState_ = null;

    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */
    this.textStrokeState_ = null;

    /**
     * @private
     * @type {?import("../canvas.js").TextState}
     */
    this.textState_ = null;

    /**
     * @private
     * @type {Array<number>}
     */
    this.pixelCoordinates_ = [];

    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */
    this.tmpLocalTransform_ = Object(_transform_js__WEBPACK_IMPORTED_MODULE_9__["create"])();

  }

  if ( VectorContext ) CanvasImmediateRenderer.__proto__ = VectorContext;
  CanvasImmediateRenderer.prototype = Object.create( VectorContext && VectorContext.prototype );
  CanvasImmediateRenderer.prototype.constructor = CanvasImmediateRenderer;

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */
  CanvasImmediateRenderer.prototype.drawImages_ = function drawImages_ (flatCoordinates, offset, end, stride) {
    if (!this.image_) {
      return;
    }
    var pixelCoordinates = Object(_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_5__["transform2D"])(
      flatCoordinates, offset, end, 2, this.transform_,
      this.pixelCoordinates_);
    var context = this.context_;
    var localTransform = this.tmpLocalTransform_;
    var alpha = context.globalAlpha;
    if (this.imageOpacity_ != 1) {
      context.globalAlpha = alpha * this.imageOpacity_;
    }
    var rotation = this.imageRotation_;
    if (this.imageRotateWithView_) {
      rotation += this.viewRotation_;
    }
    for (var i = 0, ii = pixelCoordinates.length; i < ii; i += 2) {
      var x = pixelCoordinates[i] - this.imageAnchorX_;
      var y = pixelCoordinates[i + 1] - this.imageAnchorY_;
      if (rotation !== 0 || this.imageScale_ != 1) {
        var centerX = x + this.imageAnchorX_;
        var centerY = y + this.imageAnchorY_;
        Object(_transform_js__WEBPACK_IMPORTED_MODULE_9__["compose"])(localTransform,
          centerX, centerY,
          this.imageScale_, this.imageScale_,
          rotation,
          -centerX, -centerY);
        context.setTransform.apply(context, localTransform);
      }
      context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_,
        this.imageWidth_, this.imageHeight_, x, y,
        this.imageWidth_, this.imageHeight_);
    }
    if (rotation !== 0 || this.imageScale_ != 1) {
      context.setTransform(1, 0, 0, 1, 0, 0);
    }
    if (this.imageOpacity_ != 1) {
      context.globalAlpha = alpha;
    }
  };

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */
  CanvasImmediateRenderer.prototype.drawText_ = function drawText_ (flatCoordinates, offset, end, stride) {
    if (!this.textState_ || this.text_ === '') {
      return;
    }
    if (this.textFillState_) {
      this.setContextFillState_(this.textFillState_);
    }
    if (this.textStrokeState_) {
      this.setContextStrokeState_(this.textStrokeState_);
    }
    this.setContextTextState_(this.textState_);
    var pixelCoordinates = Object(_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_5__["transform2D"])(
      flatCoordinates, offset, end, stride, this.transform_,
      this.pixelCoordinates_);
    var context = this.context_;
    var rotation = this.textRotation_;
    if (this.textRotateWithView_) {
      rotation += this.viewRotation_;
    }
    for (; offset < end; offset += stride) {
      var x = pixelCoordinates[offset] + this.textOffsetX_;
      var y = pixelCoordinates[offset + 1] + this.textOffsetY_;
      if (rotation !== 0 || this.textScale_ != 1) {
        var localTransform = Object(_transform_js__WEBPACK_IMPORTED_MODULE_9__["compose"])(this.tmpLocalTransform_,
          x, y,
          this.textScale_, this.textScale_,
          rotation,
          -x, -y);
        context.setTransform.apply(context, localTransform);
      }
      if (this.textStrokeState_) {
        context.strokeText(this.text_, x, y);
      }
      if (this.textFillState_) {
        context.fillText(this.text_, x, y);
      }
    }
    if (rotation !== 0 || this.textScale_ != 1) {
      context.setTransform(1, 0, 0, 1, 0, 0);
    }
  };

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} close Close.
   * @private
   * @return {number} end End.
   */
  CanvasImmediateRenderer.prototype.moveToLineTo_ = function moveToLineTo_ (flatCoordinates, offset, end, stride, close) {
    var context = this.context_;
    var pixelCoordinates = Object(_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_5__["transform2D"])(
      flatCoordinates, offset, end, stride, this.transform_,
      this.pixelCoordinates_);
    context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);
    var length = pixelCoordinates.length;
    if (close) {
      length -= 2;
    }
    for (var i = 2; i < length; i += 2) {
      context.lineTo(pixelCoordinates[i], pixelCoordinates[i + 1]);
    }
    if (close) {
      context.closePath();
    }
    return end;
  };

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */
  CanvasImmediateRenderer.prototype.drawRings_ = function drawRings_ (flatCoordinates, offset, ends, stride) {
    for (var i = 0, ii = ends.length; i < ii; ++i) {
      offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, true);
    }
    return offset;
  };

  /**
   * Render a circle geometry into the canvas.  Rendering is immediate and uses
   * the current fill and stroke styles.
   *
   * @param {import("../../geom/Circle.js").default} geometry Circle geometry.
   * @override
   * @api
   */
  CanvasImmediateRenderer.prototype.drawCircle = function drawCircle (geometry) {
    if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["intersects"])(this.extent_, geometry.getExtent())) {
      return;
    }
    if (this.fillState_ || this.strokeState_) {
      if (this.fillState_) {
        this.setContextFillState_(this.fillState_);
      }
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
      }
      var pixelCoordinates = Object(_geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_4__["transformGeom2D"])(
        geometry, this.transform_, this.pixelCoordinates_);
      var dx = pixelCoordinates[2] - pixelCoordinates[0];
      var dy = pixelCoordinates[3] - pixelCoordinates[1];
      var radius = Math.sqrt(dx * dx + dy * dy);
      var context = this.context_;
      context.beginPath();
      context.arc(
        pixelCoordinates[0], pixelCoordinates[1], radius, 0, 2 * Math.PI);
      if (this.fillState_) {
        context.fill();
      }
      if (this.strokeState_) {
        context.stroke();
      }
    }
    if (this.text_ !== '') {
      this.drawText_(geometry.getCenter(), 0, 2, 2);
    }
  };

  /**
   * Set the rendering style.  Note that since this is an immediate rendering API,
   * any `zIndex` on the provided style will be ignored.
   *
   * @param {import("../../style/Style.js").default} style The rendering style.
   * @override
   * @api
   */
  CanvasImmediateRenderer.prototype.setStyle = function setStyle (style) {
    this.setFillStrokeStyle(style.getFill(), style.getStroke());
    this.setImageStyle(style.getImage());
    this.setTextStyle(style.getText());
  };

  /**
   * Render a geometry into the canvas.  Call
   * {@link module:ol/render/canvas/Immediate#setStyle} first to set the rendering style.
   *
   * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.
   * @override
   * @api
   */
  CanvasImmediateRenderer.prototype.drawGeometry = function drawGeometry (geometry) {
    var type = geometry.getType();
    switch (type) {
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POINT:
        this.drawPoint(/** @type {import("../../geom/Point.js").default} */ (geometry));
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].LINE_STRING:
        this.drawLineString(/** @type {import("../../geom/LineString.js").default} */ (geometry));
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POLYGON:
        this.drawPolygon(/** @type {import("../../geom/Polygon.js").default} */ (geometry));
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].MULTI_POINT:
        this.drawMultiPoint(/** @type {import("../../geom/MultiPoint.js").default} */ (geometry));
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].MULTI_LINE_STRING:
        this.drawMultiLineString(/** @type {import("../../geom/MultiLineString.js").default} */ (geometry));
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].MULTI_POLYGON:
        this.drawMultiPolygon(/** @type {import("../../geom/MultiPolygon.js").default} */ (geometry));
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].GEOMETRY_COLLECTION:
        this.drawGeometryCollection(/** @type {import("../../geom/GeometryCollection.js").default} */ (geometry));
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].CIRCLE:
        this.drawCircle(/** @type {import("../../geom/Circle.js").default} */ (geometry));
        break;
      default:
    }
  };

  /**
   * Render a feature into the canvas.  Note that any `zIndex` on the provided
   * style will be ignored - features are rendered immediately in the order that
   * this method is called.  If you need `zIndex` support, you should be using an
   * {@link module:ol/layer/Vector~VectorLayer} instead.
   *
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {import("../../style/Style.js").default} style Style.
   * @override
   * @api
   */
  CanvasImmediateRenderer.prototype.drawFeature = function drawFeature (feature, style) {
    var geometry = style.getGeometryFunction()(feature);
    if (!geometry || !Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["intersects"])(this.extent_, geometry.getExtent())) {
      return;
    }
    this.setStyle(style);
    this.drawGeometry(geometry);
  };

  /**
   * Render a GeometryCollection to the canvas.  Rendering is immediate and
   * uses the current styles appropriate for each geometry in the collection.
   *
   * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.
   * @override
   */
  CanvasImmediateRenderer.prototype.drawGeometryCollection = function drawGeometryCollection (geometry) {
    var geometries = geometry.getGeometriesArray();
    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      this.drawGeometry(geometries[i]);
    }
  };

  /**
   * Render a Point geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.
   * @override
   */
  CanvasImmediateRenderer.prototype.drawPoint = function drawPoint (geometry) {
    var flatCoordinates = geometry.getFlatCoordinates();
    var stride = geometry.getStride();
    if (this.image_) {
      this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
    if (this.text_ !== '') {
      this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
  };

  /**
   * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
   * uses the current style.
   *
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.
   * @override
   */
  CanvasImmediateRenderer.prototype.drawMultiPoint = function drawMultiPoint (geometry) {
    var flatCoordinates = geometry.getFlatCoordinates();
    var stride = geometry.getStride();
    if (this.image_) {
      this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
    if (this.text_ !== '') {
      this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
  };

  /**
   * Render a LineString into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.
   * @override
   */
  CanvasImmediateRenderer.prototype.drawLineString = function drawLineString (geometry) {
    if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["intersects"])(this.extent_, geometry.getExtent())) {
      return;
    }
    if (this.strokeState_) {
      this.setContextStrokeState_(this.strokeState_);
      var context = this.context_;
      var flatCoordinates = geometry.getFlatCoordinates();
      context.beginPath();
      this.moveToLineTo_(flatCoordinates, 0, flatCoordinates.length,
        geometry.getStride(), false);
      context.stroke();
    }
    if (this.text_ !== '') {
      var flatMidpoint = geometry.getFlatMidpoint();
      this.drawText_(flatMidpoint, 0, 2, 2);
    }
  };

  /**
   * Render a MultiLineString geometry into the canvas.  Rendering is immediate
   * and uses the current style.
   *
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.
   * @override
   */
  CanvasImmediateRenderer.prototype.drawMultiLineString = function drawMultiLineString (geometry) {
    var geometryExtent = geometry.getExtent();
    if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["intersects"])(this.extent_, geometryExtent)) {
      return;
    }
    if (this.strokeState_) {
      this.setContextStrokeState_(this.strokeState_);
      var context = this.context_;
      var flatCoordinates = geometry.getFlatCoordinates();
      var offset = 0;
      var ends = /** @type {Array<number>} */ (geometry.getEnds());
      var stride = geometry.getStride();
      context.beginPath();
      for (var i = 0, ii = ends.length; i < ii; ++i) {
        offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, false);
      }
      context.stroke();
    }
    if (this.text_ !== '') {
      var flatMidpoints = geometry.getFlatMidpoints();
      this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);
    }
  };

  /**
   * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.
   * @override
   */
  CanvasImmediateRenderer.prototype.drawPolygon = function drawPolygon (geometry) {
    if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["intersects"])(this.extent_, geometry.getExtent())) {
      return;
    }
    if (this.strokeState_ || this.fillState_) {
      if (this.fillState_) {
        this.setContextFillState_(this.fillState_);
      }
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
      }
      var context = this.context_;
      context.beginPath();
      this.drawRings_(geometry.getOrientedFlatCoordinates(),
        0, /** @type {Array<number>} */ (geometry.getEnds()), geometry.getStride());
      if (this.fillState_) {
        context.fill();
      }
      if (this.strokeState_) {
        context.stroke();
      }
    }
    if (this.text_ !== '') {
      var flatInteriorPoint = geometry.getFlatInteriorPoint();
      this.drawText_(flatInteriorPoint, 0, 2, 2);
    }
  };

  /**
   * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
   * uses the current style.
   * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
   * @override
   */
  CanvasImmediateRenderer.prototype.drawMultiPolygon = function drawMultiPolygon (geometry) {
    if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["intersects"])(this.extent_, geometry.getExtent())) {
      return;
    }
    if (this.strokeState_ || this.fillState_) {
      if (this.fillState_) {
        this.setContextFillState_(this.fillState_);
      }
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
      }
      var context = this.context_;
      var flatCoordinates = geometry.getOrientedFlatCoordinates();
      var offset = 0;
      var endss = geometry.getEndss();
      var stride = geometry.getStride();
      context.beginPath();
      for (var i = 0, ii = endss.length; i < ii; ++i) {
        var ends = endss[i];
        offset = this.drawRings_(flatCoordinates, offset, ends, stride);
      }
      if (this.fillState_) {
        context.fill();
      }
      if (this.strokeState_) {
        context.stroke();
      }
    }
    if (this.text_ !== '') {
      var flatInteriorPoints = geometry.getFlatInteriorPoints();
      this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);
    }
  };

  /**
   * @param {import("../canvas.js").FillState} fillState Fill state.
   * @private
   */
  CanvasImmediateRenderer.prototype.setContextFillState_ = function setContextFillState_ (fillState) {
    var context = this.context_;
    var contextFillState = this.contextFillState_;
    if (!contextFillState) {
      context.fillStyle = fillState.fillStyle;
      this.contextFillState_ = {
        fillStyle: fillState.fillStyle
      };
    } else {
      if (contextFillState.fillStyle != fillState.fillStyle) {
        contextFillState.fillStyle = context.fillStyle = fillState.fillStyle;
      }
    }
  };

  /**
   * @param {import("../canvas.js").StrokeState} strokeState Stroke state.
   * @private
   */
  CanvasImmediateRenderer.prototype.setContextStrokeState_ = function setContextStrokeState_ (strokeState) {
    var context = this.context_;
    var contextStrokeState = this.contextStrokeState_;
    if (!contextStrokeState) {
      context.lineCap = /** @type {CanvasLineCap} */ (strokeState.lineCap);
      if (_has_js__WEBPACK_IMPORTED_MODULE_6__["CANVAS_LINE_DASH"]) {
        context.setLineDash(strokeState.lineDash);
        context.lineDashOffset = strokeState.lineDashOffset;
      }
      context.lineJoin = /** @type {CanvasLineJoin} */ (strokeState.lineJoin);
      context.lineWidth = strokeState.lineWidth;
      context.miterLimit = strokeState.miterLimit;
      context.strokeStyle = strokeState.strokeStyle;
      this.contextStrokeState_ = {
        lineCap: strokeState.lineCap,
        lineDash: strokeState.lineDash,
        lineDashOffset: strokeState.lineDashOffset,
        lineJoin: strokeState.lineJoin,
        lineWidth: strokeState.lineWidth,
        miterLimit: strokeState.miterLimit,
        strokeStyle: strokeState.strokeStyle
      };
    } else {
      if (contextStrokeState.lineCap != strokeState.lineCap) {
        contextStrokeState.lineCap = context.lineCap = /** @type {CanvasLineCap} */ (strokeState.lineCap);
      }
      if (_has_js__WEBPACK_IMPORTED_MODULE_6__["CANVAS_LINE_DASH"]) {
        if (!Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["equals"])(contextStrokeState.lineDash, strokeState.lineDash)) {
          context.setLineDash(contextStrokeState.lineDash = strokeState.lineDash);
        }
        if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {
          contextStrokeState.lineDashOffset = context.lineDashOffset =
              strokeState.lineDashOffset;
        }
      }
      if (contextStrokeState.lineJoin != strokeState.lineJoin) {
        contextStrokeState.lineJoin = context.lineJoin = /** @type {CanvasLineJoin} */ (strokeState.lineJoin);
      }
      if (contextStrokeState.lineWidth != strokeState.lineWidth) {
        contextStrokeState.lineWidth = context.lineWidth = strokeState.lineWidth;
      }
      if (contextStrokeState.miterLimit != strokeState.miterLimit) {
        contextStrokeState.miterLimit = context.miterLimit =
            strokeState.miterLimit;
      }
      if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {
        contextStrokeState.strokeStyle = context.strokeStyle =
            strokeState.strokeStyle;
      }
    }
  };

  /**
   * @param {import("../canvas.js").TextState} textState Text state.
   * @private
   */
  CanvasImmediateRenderer.prototype.setContextTextState_ = function setContextTextState_ (textState) {
    var context = this.context_;
    var contextTextState = this.contextTextState_;
    var textAlign = textState.textAlign ?
      textState.textAlign : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultTextAlign"];
    if (!contextTextState) {
      context.font = textState.font;
      context.textAlign = /** @type {CanvasTextAlign} */ (textAlign);
      context.textBaseline = /** @type {CanvasTextBaseline} */ (textState.textBaseline);
      this.contextTextState_ = {
        font: textState.font,
        textAlign: textAlign,
        textBaseline: textState.textBaseline
      };
    } else {
      if (contextTextState.font != textState.font) {
        contextTextState.font = context.font = textState.font;
      }
      if (contextTextState.textAlign != textAlign) {
        contextTextState.textAlign = context.textAlign = /** @type {CanvasTextAlign} */ (textAlign);
      }
      if (contextTextState.textBaseline != textState.textBaseline) {
        contextTextState.textBaseline = context.textBaseline =
          /** @type {CanvasTextBaseline} */ (textState.textBaseline);
      }
    }
  };

  /**
   * Set the fill and stroke style for subsequent draw operations.  To clear
   * either fill or stroke styles, pass null for the appropriate parameter.
   *
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   * @override
   */
  CanvasImmediateRenderer.prototype.setFillStrokeStyle = function setFillStrokeStyle (fillStyle, strokeStyle) {
    if (!fillStyle) {
      this.fillState_ = null;
    } else {
      var fillStyleColor = fillStyle.getColor();
      this.fillState_ = {
        fillStyle: Object(_colorlike_js__WEBPACK_IMPORTED_MODULE_1__["asColorLike"])(fillStyleColor ?
          fillStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultFillStyle"])
      };
    }
    if (!strokeStyle) {
      this.strokeState_ = null;
    } else {
      var strokeStyleColor = strokeStyle.getColor();
      var strokeStyleLineCap = strokeStyle.getLineCap();
      var strokeStyleLineDash = strokeStyle.getLineDash();
      var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
      var strokeStyleLineJoin = strokeStyle.getLineJoin();
      var strokeStyleWidth = strokeStyle.getWidth();
      var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
      this.strokeState_ = {
        lineCap: strokeStyleLineCap !== undefined ?
          strokeStyleLineCap : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultLineCap"],
        lineDash: strokeStyleLineDash ?
          strokeStyleLineDash : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultLineDash"],
        lineDashOffset: strokeStyleLineDashOffset ?
          strokeStyleLineDashOffset : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultLineDashOffset"],
        lineJoin: strokeStyleLineJoin !== undefined ?
          strokeStyleLineJoin : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultLineJoin"],
        lineWidth: this.pixelRatio_ * (strokeStyleWidth !== undefined ?
          strokeStyleWidth : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultLineWidth"]),
        miterLimit: strokeStyleMiterLimit !== undefined ?
          strokeStyleMiterLimit : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultMiterLimit"],
        strokeStyle: Object(_colorlike_js__WEBPACK_IMPORTED_MODULE_1__["asColorLike"])(strokeStyleColor ?
          strokeStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultStrokeStyle"])
      };
    }
  };

  /**
   * Set the image style for subsequent draw operations.  Pass null to remove
   * the image style.
   *
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   * @override
   */
  CanvasImmediateRenderer.prototype.setImageStyle = function setImageStyle (imageStyle) {
    if (!imageStyle) {
      this.image_ = null;
    } else {
      var imageAnchor = imageStyle.getAnchor();
      // FIXME pixel ratio
      var imageImage = imageStyle.getImage(1);
      var imageOrigin = imageStyle.getOrigin();
      var imageSize = imageStyle.getSize();
      this.imageAnchorX_ = imageAnchor[0];
      this.imageAnchorY_ = imageAnchor[1];
      this.imageHeight_ = imageSize[1];
      this.image_ = imageImage;
      this.imageOpacity_ = imageStyle.getOpacity();
      this.imageOriginX_ = imageOrigin[0];
      this.imageOriginY_ = imageOrigin[1];
      this.imageRotateWithView_ = imageStyle.getRotateWithView();
      this.imageRotation_ = imageStyle.getRotation();
      this.imageScale_ = imageStyle.getScale() * this.pixelRatio_;
      this.imageWidth_ = imageSize[0];
    }
  };

  /**
   * Set the text style for subsequent draw operations.  Pass null to
   * remove the text style.
   *
   * @param {import("../../style/Text.js").default} textStyle Text style.
   * @override
   */
  CanvasImmediateRenderer.prototype.setTextStyle = function setTextStyle (textStyle) {
    if (!textStyle) {
      this.text_ = '';
    } else {
      var textFillStyle = textStyle.getFill();
      if (!textFillStyle) {
        this.textFillState_ = null;
      } else {
        var textFillStyleColor = textFillStyle.getColor();
        this.textFillState_ = {
          fillStyle: Object(_colorlike_js__WEBPACK_IMPORTED_MODULE_1__["asColorLike"])(textFillStyleColor ?
            textFillStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultFillStyle"])
        };
      }
      var textStrokeStyle = textStyle.getStroke();
      if (!textStrokeStyle) {
        this.textStrokeState_ = null;
      } else {
        var textStrokeStyleColor = textStrokeStyle.getColor();
        var textStrokeStyleLineCap = textStrokeStyle.getLineCap();
        var textStrokeStyleLineDash = textStrokeStyle.getLineDash();
        var textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();
        var textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();
        var textStrokeStyleWidth = textStrokeStyle.getWidth();
        var textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();
        this.textStrokeState_ = {
          lineCap: textStrokeStyleLineCap !== undefined ?
            textStrokeStyleLineCap : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultLineCap"],
          lineDash: textStrokeStyleLineDash ?
            textStrokeStyleLineDash : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultLineDash"],
          lineDashOffset: textStrokeStyleLineDashOffset ?
            textStrokeStyleLineDashOffset : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultLineDashOffset"],
          lineJoin: textStrokeStyleLineJoin !== undefined ?
            textStrokeStyleLineJoin : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultLineJoin"],
          lineWidth: textStrokeStyleWidth !== undefined ?
            textStrokeStyleWidth : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultLineWidth"],
          miterLimit: textStrokeStyleMiterLimit !== undefined ?
            textStrokeStyleMiterLimit : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultMiterLimit"],
          strokeStyle: Object(_colorlike_js__WEBPACK_IMPORTED_MODULE_1__["asColorLike"])(textStrokeStyleColor ?
            textStrokeStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultStrokeStyle"])
        };
      }
      var textFont = textStyle.getFont();
      var textOffsetX = textStyle.getOffsetX();
      var textOffsetY = textStyle.getOffsetY();
      var textRotateWithView = textStyle.getRotateWithView();
      var textRotation = textStyle.getRotation();
      var textScale = textStyle.getScale();
      var textText = textStyle.getText();
      var textTextAlign = textStyle.getTextAlign();
      var textTextBaseline = textStyle.getTextBaseline();
      this.textState_ = {
        font: textFont !== undefined ?
          textFont : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultFont"],
        textAlign: textTextAlign !== undefined ?
          textTextAlign : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultTextAlign"],
        textBaseline: textTextBaseline !== undefined ?
          textTextBaseline : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultTextBaseline"]
      };
      this.text_ = textText !== undefined ? textText : '';
      this.textOffsetX_ =
          textOffsetX !== undefined ? (this.pixelRatio_ * textOffsetX) : 0;
      this.textOffsetY_ =
          textOffsetY !== undefined ? (this.pixelRatio_ * textOffsetY) : 0;
      this.textRotateWithView_ = textRotateWithView !== undefined ? textRotateWithView : false;
      this.textRotation_ = textRotation !== undefined ? textRotation : 0;
      this.textScale_ = this.pixelRatio_ * (textScale !== undefined ?
        textScale : 1);
    }
  };

  return CanvasImmediateRenderer;
}(_VectorContext_js__WEBPACK_IMPORTED_MODULE_7__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (CanvasImmediateRenderer);

//# sourceMappingURL=Immediate.js.map

/***/ }),

/***/ "./node_modules/ol/render/canvas/Instruction.js":
/*!******************************************************!*\
  !*** ./node_modules/ol/render/canvas/Instruction.js ***!
  \******************************************************/
/*! exports provided: fillInstruction, strokeInstruction, beginPathInstruction, closePathInstruction, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fillInstruction", function() { return fillInstruction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "strokeInstruction", function() { return strokeInstruction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "beginPathInstruction", function() { return beginPathInstruction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "closePathInstruction", function() { return closePathInstruction; });
/**
 * @module ol/render/canvas/Instruction
 */

/**
 * @enum {number}
 */
var Instruction = {
  BEGIN_GEOMETRY: 0,
  BEGIN_PATH: 1,
  CIRCLE: 2,
  CLOSE_PATH: 3,
  CUSTOM: 4,
  DRAW_CHARS: 5,
  DRAW_IMAGE: 6,
  END_GEOMETRY: 7,
  FILL: 8,
  MOVE_TO_LINE_TO: 9,
  SET_FILL_STYLE: 10,
  SET_STROKE_STYLE: 11,
  STROKE: 12
};


/**
 * @type {Array<Instruction>}
 */
var fillInstruction = [Instruction.FILL];


/**
 * @type {Array<Instruction>}
 */
var strokeInstruction = [Instruction.STROKE];


/**
 * @type {Array<Instruction>}
 */
var beginPathInstruction = [Instruction.BEGIN_PATH];


/**
 * @type {Array<Instruction>}
 */
var closePathInstruction = [Instruction.CLOSE_PATH];


/* harmony default export */ __webpack_exports__["default"] = (Instruction);

//# sourceMappingURL=Instruction.js.map

/***/ }),

/***/ "./node_modules/ol/render/canvas/LineStringReplay.js":
/*!***********************************************************!*\
  !*** ./node_modules/ol/render/canvas/LineStringReplay.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Instruction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Instruction.js */ "./node_modules/ol/render/canvas/Instruction.js");
/* harmony import */ var _Replay_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Replay.js */ "./node_modules/ol/render/canvas/Replay.js");
/**
 * @module ol/render/canvas/LineStringReplay
 */



var CanvasLineStringReplay = /*@__PURE__*/(function (CanvasReplay) {
  function CanvasLineStringReplay(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {
    CanvasReplay.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);
  }

  if ( CanvasReplay ) CanvasLineStringReplay.__proto__ = CanvasReplay;
  CanvasLineStringReplay.prototype = Object.create( CanvasReplay && CanvasReplay.prototype );
  CanvasLineStringReplay.prototype.constructor = CanvasLineStringReplay;

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   * @return {number} end.
   */
  CanvasLineStringReplay.prototype.drawFlatCoordinates_ = function drawFlatCoordinates_ (flatCoordinates, offset, end, stride) {
    var myBegin = this.coordinates.length;
    var myEnd = this.appendFlatCoordinates(
      flatCoordinates, offset, end, stride, false, false);
    var moveToLineToInstruction = [_Instruction_js__WEBPACK_IMPORTED_MODULE_0__["default"].MOVE_TO_LINE_TO, myBegin, myEnd];
    this.instructions.push(moveToLineToInstruction);
    this.hitDetectionInstructions.push(moveToLineToInstruction);
    return end;
  };

  /**
   * @inheritDoc
   */
  CanvasLineStringReplay.prototype.drawLineString = function drawLineString (lineStringGeometry, feature) {
    var state = this.state;
    var strokeStyle = state.strokeStyle;
    var lineWidth = state.lineWidth;
    if (strokeStyle === undefined || lineWidth === undefined) {
      return;
    }
    this.updateStrokeStyle(state, this.applyStroke);
    this.beginGeometry(lineStringGeometry, feature);
    this.hitDetectionInstructions.push([
      _Instruction_js__WEBPACK_IMPORTED_MODULE_0__["default"].SET_STROKE_STYLE,
      state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,
      state.miterLimit, state.lineDash, state.lineDashOffset
    ], _Instruction_js__WEBPACK_IMPORTED_MODULE_0__["beginPathInstruction"]);
    var flatCoordinates = lineStringGeometry.getFlatCoordinates();
    var stride = lineStringGeometry.getStride();
    this.drawFlatCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
    this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_0__["strokeInstruction"]);
    this.endGeometry(lineStringGeometry, feature);
  };

  /**
   * @inheritDoc
   */
  CanvasLineStringReplay.prototype.drawMultiLineString = function drawMultiLineString (multiLineStringGeometry, feature) {
    var state = this.state;
    var strokeStyle = state.strokeStyle;
    var lineWidth = state.lineWidth;
    if (strokeStyle === undefined || lineWidth === undefined) {
      return;
    }
    this.updateStrokeStyle(state, this.applyStroke);
    this.beginGeometry(multiLineStringGeometry, feature);
    this.hitDetectionInstructions.push([
      _Instruction_js__WEBPACK_IMPORTED_MODULE_0__["default"].SET_STROKE_STYLE,
      state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,
      state.miterLimit, state.lineDash, state.lineDashOffset
    ], _Instruction_js__WEBPACK_IMPORTED_MODULE_0__["beginPathInstruction"]);
    var ends = multiLineStringGeometry.getEnds();
    var flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
    var stride = multiLineStringGeometry.getStride();
    var offset = 0;
    for (var i = 0, ii = ends.length; i < ii; ++i) {
      offset = this.drawFlatCoordinates_(flatCoordinates, offset, ends[i], stride);
    }
    this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_0__["strokeInstruction"]);
    this.endGeometry(multiLineStringGeometry, feature);
  };

  /**
   * @inheritDoc
   */
  CanvasLineStringReplay.prototype.finish = function finish () {
    var state = this.state;
    if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {
      this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_0__["strokeInstruction"]);
    }
    this.reverseHitDetectionInstructions();
    this.state = null;
  };

  /**
   * @inheritDoc.
   */
  CanvasLineStringReplay.prototype.applyStroke = function applyStroke (state) {
    if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {
      this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_0__["strokeInstruction"]);
      state.lastStroke = this.coordinates.length;
    }
    state.lastStroke = 0;
    CanvasReplay.prototype.applyStroke.call(this, state);
    this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_0__["beginPathInstruction"]);
  };

  return CanvasLineStringReplay;
}(_Replay_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (CanvasLineStringReplay);

//# sourceMappingURL=LineStringReplay.js.map

/***/ }),

/***/ "./node_modules/ol/render/canvas/PolygonReplay.js":
/*!********************************************************!*\
  !*** ./node_modules/ol/render/canvas/PolygonReplay.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../color.js */ "./node_modules/ol/color.js");
/* harmony import */ var _geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../geom/flat/simplify.js */ "./node_modules/ol/geom/flat/simplify.js");
/* harmony import */ var _canvas_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _Instruction_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Instruction.js */ "./node_modules/ol/render/canvas/Instruction.js");
/* harmony import */ var _Replay_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Replay.js */ "./node_modules/ol/render/canvas/Replay.js");
/**
 * @module ol/render/canvas/PolygonReplay
 */







var CanvasPolygonReplay = /*@__PURE__*/(function (CanvasReplay) {
  function CanvasPolygonReplay(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {
    CanvasReplay.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);
  }

  if ( CanvasReplay ) CanvasPolygonReplay.__proto__ = CanvasReplay;
  CanvasPolygonReplay.prototype = Object.create( CanvasReplay && CanvasReplay.prototype );
  CanvasPolygonReplay.prototype.constructor = CanvasPolygonReplay;

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */
  CanvasPolygonReplay.prototype.drawFlatCoordinatess_ = function drawFlatCoordinatess_ (flatCoordinates, offset, ends, stride) {
    var state = this.state;
    var fill = state.fillStyle !== undefined;
    var stroke = state.strokeStyle != undefined;
    var numEnds = ends.length;
    this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["beginPathInstruction"]);
    this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["beginPathInstruction"]);
    for (var i = 0; i < numEnds; ++i) {
      var end = ends[i];
      var myBegin = this.coordinates.length;
      var myEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, true, !stroke);
      var moveToLineToInstruction = [_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].MOVE_TO_LINE_TO, myBegin, myEnd];
      this.instructions.push(moveToLineToInstruction);
      this.hitDetectionInstructions.push(moveToLineToInstruction);
      if (stroke) {
        // Performance optimization: only call closePath() when we have a stroke.
        // Otherwise the ring is closed already (see appendFlatCoordinates above).
        this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["closePathInstruction"]);
        this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["closePathInstruction"]);
      }
      offset = end;
    }
    if (fill) {
      this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["fillInstruction"]);
      this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["fillInstruction"]);
    }
    if (stroke) {
      this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["strokeInstruction"]);
      this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["strokeInstruction"]);
    }
    return offset;
  };

  /**
   * @inheritDoc
   */
  CanvasPolygonReplay.prototype.drawCircle = function drawCircle (circleGeometry, feature) {
    var state = this.state;
    var fillStyle = state.fillStyle;
    var strokeStyle = state.strokeStyle;
    if (fillStyle === undefined && strokeStyle === undefined) {
      return;
    }
    this.setFillStrokeStyles_(circleGeometry);
    this.beginGeometry(circleGeometry, feature);
    if (state.fillStyle !== undefined) {
      this.hitDetectionInstructions.push([
        _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].SET_FILL_STYLE,
        Object(_color_js__WEBPACK_IMPORTED_MODULE_0__["asString"])(_canvas_js__WEBPACK_IMPORTED_MODULE_2__["defaultFillStyle"])
      ]);
    }
    if (state.strokeStyle !== undefined) {
      this.hitDetectionInstructions.push([
        _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].SET_STROKE_STYLE,
        state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,
        state.miterLimit, state.lineDash, state.lineDashOffset
      ]);
    }
    var flatCoordinates = circleGeometry.getFlatCoordinates();
    var stride = circleGeometry.getStride();
    var myBegin = this.coordinates.length;
    this.appendFlatCoordinates(
      flatCoordinates, 0, flatCoordinates.length, stride, false, false);
    var circleInstruction = [_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].CIRCLE, myBegin];
    this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["beginPathInstruction"], circleInstruction);
    this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["beginPathInstruction"], circleInstruction);
    this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["fillInstruction"]);
    if (state.fillStyle !== undefined) {
      this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["fillInstruction"]);
    }
    if (state.strokeStyle !== undefined) {
      this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["strokeInstruction"]);
      this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["strokeInstruction"]);
    }
    this.endGeometry(circleGeometry, feature);
  };

  /**
   * @inheritDoc
   */
  CanvasPolygonReplay.prototype.drawPolygon = function drawPolygon (polygonGeometry, feature) {
    var state = this.state;
    var fillStyle = state.fillStyle;
    var strokeStyle = state.strokeStyle;
    if (fillStyle === undefined && strokeStyle === undefined) {
      return;
    }
    this.setFillStrokeStyles_(polygonGeometry);
    this.beginGeometry(polygonGeometry, feature);
    if (state.fillStyle !== undefined) {
      this.hitDetectionInstructions.push([
        _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].SET_FILL_STYLE,
        Object(_color_js__WEBPACK_IMPORTED_MODULE_0__["asString"])(_canvas_js__WEBPACK_IMPORTED_MODULE_2__["defaultFillStyle"])
      ]);
    }
    if (state.strokeStyle !== undefined) {
      this.hitDetectionInstructions.push([
        _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].SET_STROKE_STYLE,
        state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,
        state.miterLimit, state.lineDash, state.lineDashOffset
      ]);
    }
    var ends = polygonGeometry.getEnds();
    var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();
    var stride = polygonGeometry.getStride();
    this.drawFlatCoordinatess_(flatCoordinates, 0, ends, stride);
    this.endGeometry(polygonGeometry, feature);
  };

  /**
   * @inheritDoc
   */
  CanvasPolygonReplay.prototype.drawMultiPolygon = function drawMultiPolygon (multiPolygonGeometry, feature) {
    var state = this.state;
    var fillStyle = state.fillStyle;
    var strokeStyle = state.strokeStyle;
    if (fillStyle === undefined && strokeStyle === undefined) {
      return;
    }
    this.setFillStrokeStyles_(multiPolygonGeometry);
    this.beginGeometry(multiPolygonGeometry, feature);
    if (state.fillStyle !== undefined) {
      this.hitDetectionInstructions.push([
        _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].SET_FILL_STYLE,
        Object(_color_js__WEBPACK_IMPORTED_MODULE_0__["asString"])(_canvas_js__WEBPACK_IMPORTED_MODULE_2__["defaultFillStyle"])
      ]);
    }
    if (state.strokeStyle !== undefined) {
      this.hitDetectionInstructions.push([
        _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].SET_STROKE_STYLE,
        state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,
        state.miterLimit, state.lineDash, state.lineDashOffset
      ]);
    }
    var endss = multiPolygonGeometry.getEndss();
    var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();
    var stride = multiPolygonGeometry.getStride();
    var offset = 0;
    for (var i = 0, ii = endss.length; i < ii; ++i) {
      offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);
    }
    this.endGeometry(multiPolygonGeometry, feature);
  };

  /**
   * @inheritDoc
   */
  CanvasPolygonReplay.prototype.finish = function finish () {
    this.reverseHitDetectionInstructions();
    this.state = null;
    // We want to preserve topology when drawing polygons.  Polygons are
    // simplified using quantization and point elimination. However, we might
    // have received a mix of quantized and non-quantized geometries, so ensure
    // that all are quantized by quantizing all coordinates in the batch.
    var tolerance = this.tolerance;
    if (tolerance !== 0) {
      var coordinates = this.coordinates;
      for (var i = 0, ii = coordinates.length; i < ii; ++i) {
        coordinates[i] = Object(_geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_1__["snap"])(coordinates[i], tolerance);
      }
    }
  };

  /**
   * @private
   * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry Geometry.
   */
  CanvasPolygonReplay.prototype.setFillStrokeStyles_ = function setFillStrokeStyles_ (geometry) {
    var state = this.state;
    var fillStyle = state.fillStyle;
    if (fillStyle !== undefined) {
      this.updateFillStyle(state, this.createFill, geometry);
    }
    if (state.strokeStyle !== undefined) {
      this.updateStrokeStyle(state, this.applyStroke);
    }
  };

  return CanvasPolygonReplay;
}(_Replay_js__WEBPACK_IMPORTED_MODULE_4__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (CanvasPolygonReplay);

//# sourceMappingURL=PolygonReplay.js.map

/***/ }),

/***/ "./node_modules/ol/render/canvas/Replay.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/render/canvas/Replay.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _colorlike_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../colorlike.js */ "./node_modules/ol/colorlike.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../extent/Relationship.js */ "./node_modules/ol/extent/Relationship.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../geom/flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _geom_flat_length_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../geom/flat/length.js */ "./node_modules/ol/geom/flat/length.js");
/* harmony import */ var _geom_flat_textpath_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../geom/flat/textpath.js */ "./node_modules/ol/geom/flat/textpath.js");
/* harmony import */ var _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../geom/flat/transform.js */ "./node_modules/ol/geom/flat/transform.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _VectorContext_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../VectorContext.js */ "./node_modules/ol/render/VectorContext.js");
/* harmony import */ var _canvas_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _Instruction_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Instruction.js */ "./node_modules/ol/render/canvas/Instruction.js");
/* harmony import */ var _replay_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../replay.js */ "./node_modules/ol/render/replay.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/render/canvas/Replay
 */



















/**
 * @type {import("../../extent.js").Extent}
 */
var tmpExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__["createEmpty"])();


/**
 * @type {!import("../../transform.js").Transform}
 */
var tmpTransform = Object(_transform_js__WEBPACK_IMPORTED_MODULE_16__["create"])();


var CanvasReplay = /*@__PURE__*/(function (VectorContext) {
  function CanvasReplay(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {
    VectorContext.call(this);

    /**
     * @type {?}
     */
    this.declutterTree = declutterTree;

    /**
     * @protected
     * @type {number}
     */
    this.tolerance = tolerance;

    /**
     * @protected
     * @const
     * @type {import("../../extent.js").Extent}
     */
    this.maxExtent = maxExtent;

    /**
     * @protected
     * @type {boolean}
     */
    this.overlaps = overlaps;

    /**
     * @protected
     * @type {number}
     */
    this.pixelRatio = pixelRatio;

    /**
     * @protected
     * @type {number}
     */
    this.maxLineWidth = 0;

    /**
     * @protected
     * @const
     * @type {number}
     */
    this.resolution = resolution;

    /**
     * @private
     * @type {boolean}
     */
    this.alignFill_;

    /**
     * @private
     * @type {Array<*>}
     */
    this.beginGeometryInstruction1_ = null;

    /**
     * @private
     * @type {Array<*>}
     */
    this.beginGeometryInstruction2_ = null;

    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */
    this.bufferedMaxExtent_ = null;

    /**
     * @protected
     * @type {Array<*>}
     */
    this.instructions = [];

    /**
     * @protected
     * @type {Array<number>}
     */
    this.coordinates = [];

    /**
     * @private
     * @type {!Object<number,import("../../coordinate.js").Coordinate|Array<import("../../coordinate.js").Coordinate>|Array<Array<import("../../coordinate.js").Coordinate>>>}
     */
    this.coordinateCache_ = {};

    /**
     * @private
     * @type {!import("../../transform.js").Transform}
     */
    this.renderedTransform_ = Object(_transform_js__WEBPACK_IMPORTED_MODULE_16__["create"])();

    /**
     * @protected
     * @type {Array<*>}
     */
    this.hitDetectionInstructions = [];

    /**
     * @private
     * @type {Array<number>}
     */
    this.pixelCoordinates_ = null;

    /**
     * @protected
     * @type {import("../canvas.js").FillStrokeState}
     */
    this.state = /** @type {import("../canvas.js").FillStrokeState} */ ({});

    /**
     * @private
     * @type {number}
     */
    this.viewRotation_ = 0;

  }

  if ( VectorContext ) CanvasReplay.__proto__ = VectorContext;
  CanvasReplay.prototype = Object.create( VectorContext && VectorContext.prototype );
  CanvasReplay.prototype.constructor = CanvasReplay;

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../coordinate.js").Coordinate} p1 1st point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p2 2nd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p3 3rd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p4 4th point of the background box.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   */
  CanvasReplay.prototype.replayTextBackground_ = function replayTextBackground_ (context, p1, p2, p3, p4, fillInstruction, strokeInstruction) {
    context.beginPath();
    context.moveTo.apply(context, p1);
    context.lineTo.apply(context, p2);
    context.lineTo.apply(context, p3);
    context.lineTo.apply(context, p4);
    context.lineTo.apply(context, p1);
    if (fillInstruction) {
      this.alignFill_ = /** @type {boolean} */ (fillInstruction[2]);
      this.fill_(context);
    }
    if (strokeInstruction) {
      this.setStrokeStyle_(context, /** @type {Array<*>} */ (strokeInstruction));
      context.stroke();
    }
  };

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} image Image.
   * @param {number} anchorX Anchor X.
   * @param {number} anchorY Anchor Y.
   * @param {import("../canvas.js").DeclutterGroup} declutterGroup Declutter group.
   * @param {number} height Height.
   * @param {number} opacity Opacity.
   * @param {number} originX Origin X.
   * @param {number} originY Origin Y.
   * @param {number} rotation Rotation.
   * @param {number} scale Scale.
   * @param {boolean} snapToPixel Snap to pixel.
   * @param {number} width Width.
   * @param {Array<number>} padding Padding.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   */
  CanvasReplay.prototype.replayImage_ = function replayImage_ (
    context,
    x,
    y,
    image,
    anchorX,
    anchorY,
    declutterGroup,
    height,
    opacity,
    originX,
    originY,
    rotation,
    scale,
    snapToPixel,
    width,
    padding,
    fillInstruction,
    strokeInstruction
  ) {
    var fillStroke = fillInstruction || strokeInstruction;
    anchorX *= scale;
    anchorY *= scale;
    x -= anchorX;
    y -= anchorY;

    var w = (width + originX > image.width) ? image.width - originX : width;
    var h = (height + originY > image.height) ? image.height - originY : height;
    var boxW = padding[3] + w * scale + padding[1];
    var boxH = padding[0] + h * scale + padding[2];
    var boxX = x - padding[3];
    var boxY = y - padding[0];

    /** @type {import("../../coordinate.js").Coordinate} */
    var p1;
    /** @type {import("../../coordinate.js").Coordinate} */
    var p2;
    /** @type {import("../../coordinate.js").Coordinate} */
    var p3;
    /** @type {import("../../coordinate.js").Coordinate} */
    var p4;
    if (fillStroke || rotation !== 0) {
      p1 = [boxX, boxY];
      p2 = [boxX + boxW, boxY];
      p3 = [boxX + boxW, boxY + boxH];
      p4 = [boxX, boxY + boxH];
    }

    var transform = null;
    if (rotation !== 0) {
      var centerX = x + anchorX;
      var centerY = y + anchorY;
      transform = Object(_transform_js__WEBPACK_IMPORTED_MODULE_16__["compose"])(tmpTransform, centerX, centerY, 1, 1, rotation, -centerX, -centerY);

      Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__["createOrUpdateEmpty"])(tmpExtent);
      Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__["extendCoordinate"])(tmpExtent, Object(_transform_js__WEBPACK_IMPORTED_MODULE_16__["apply"])(tmpTransform, p1));
      Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__["extendCoordinate"])(tmpExtent, Object(_transform_js__WEBPACK_IMPORTED_MODULE_16__["apply"])(tmpTransform, p2));
      Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__["extendCoordinate"])(tmpExtent, Object(_transform_js__WEBPACK_IMPORTED_MODULE_16__["apply"])(tmpTransform, p3));
      Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__["extendCoordinate"])(tmpExtent, Object(_transform_js__WEBPACK_IMPORTED_MODULE_16__["apply"])(tmpTransform, p4));
    } else {
      Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__["createOrUpdate"])(boxX, boxY, boxX + boxW, boxY + boxH, tmpExtent);
    }
    var canvas = context.canvas;
    var strokePadding = strokeInstruction ? (strokeInstruction[2] * scale / 2) : 0;
    var intersects =
        tmpExtent[0] - strokePadding <= canvas.width && tmpExtent[2] + strokePadding >= 0 &&
        tmpExtent[1] - strokePadding <= canvas.height && tmpExtent[3] + strokePadding >= 0;

    if (snapToPixel) {
      x = Math.round(x);
      y = Math.round(y);
    }

    if (declutterGroup) {
      if (!intersects && declutterGroup[4] == 1) {
        return;
      }
      Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__["extend"])(declutterGroup, tmpExtent);
      var declutterArgs = intersects ?
        [context, transform ? transform.slice(0) : null, opacity, image, originX, originY, w, h, x, y, scale] :
        null;
      if (declutterArgs && fillStroke) {
        declutterArgs.push(fillInstruction, strokeInstruction, p1, p2, p3, p4);
      }
      declutterGroup.push(declutterArgs);
    } else if (intersects) {
      if (fillStroke) {
        this.replayTextBackground_(context, p1, p2, p3, p4,
          /** @type {Array<*>} */ (fillInstruction),
          /** @type {Array<*>} */ (strokeInstruction));
      }
      Object(_canvas_js__WEBPACK_IMPORTED_MODULE_13__["drawImage"])(context, transform, opacity, image, originX, originY, w, h, x, y, scale);
    }
  };

  /**
   * @protected
   * @param {Array<number>} dashArray Dash array.
   * @return {Array<number>} Dash array with pixel ratio applied
   */
  CanvasReplay.prototype.applyPixelRatio = function applyPixelRatio (dashArray) {
    var pixelRatio = this.pixelRatio;
    return pixelRatio == 1 ? dashArray : dashArray.map(function(dash) {
      return dash * pixelRatio;
    });
  };

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} closed Last input coordinate equals first.
   * @param {boolean} skipFirst Skip first coordinate.
   * @protected
   * @return {number} My end.
   */
  CanvasReplay.prototype.appendFlatCoordinates = function appendFlatCoordinates (flatCoordinates, offset, end, stride, closed, skipFirst) {

    var myEnd = this.coordinates.length;
    var extent = this.getBufferedMaxExtent();
    if (skipFirst) {
      offset += stride;
    }
    var lastCoord = [flatCoordinates[offset], flatCoordinates[offset + 1]];
    var nextCoord = [NaN, NaN];
    var skipped = true;

    var i, lastRel, nextRel;
    for (i = offset + stride; i < end; i += stride) {
      nextCoord[0] = flatCoordinates[i];
      nextCoord[1] = flatCoordinates[i + 1];
      nextRel = Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__["coordinateRelationship"])(extent, nextCoord);
      if (nextRel !== lastRel) {
        if (skipped) {
          this.coordinates[myEnd++] = lastCoord[0];
          this.coordinates[myEnd++] = lastCoord[1];
        }
        this.coordinates[myEnd++] = nextCoord[0];
        this.coordinates[myEnd++] = nextCoord[1];
        skipped = false;
      } else if (nextRel === _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_4__["default"].INTERSECTING) {
        this.coordinates[myEnd++] = nextCoord[0];
        this.coordinates[myEnd++] = nextCoord[1];
        skipped = false;
      } else {
        skipped = true;
      }
      lastCoord[0] = nextCoord[0];
      lastCoord[1] = nextCoord[1];
      lastRel = nextRel;
    }

    // Last coordinate equals first or only one point to append:
    if ((closed && skipped) || i === offset + stride) {
      this.coordinates[myEnd++] = lastCoord[0];
      this.coordinates[myEnd++] = lastCoord[1];
    }
    return myEnd;
  };

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Array<number>} replayEnds Replay ends.
   * @return {number} Offset.
   */
  CanvasReplay.prototype.drawCustomCoordinates_ = function drawCustomCoordinates_ (flatCoordinates, offset, ends, stride, replayEnds) {
    for (var i = 0, ii = ends.length; i < ii; ++i) {
      var end = ends[i];
      var replayEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);
      replayEnds.push(replayEnd);
      offset = end;
    }
    return offset;
  };

  /**
   * @inheritDoc.
   */
  CanvasReplay.prototype.drawCustom = function drawCustom (geometry, feature, renderer) {
    this.beginGeometry(geometry, feature);
    var type = geometry.getType();
    var stride = geometry.getStride();
    var replayBegin = this.coordinates.length;
    var flatCoordinates, replayEnd, replayEnds, replayEndss;
    var offset;
    if (type == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].MULTI_POLYGON) {
      geometry = /** @type {import("../../geom/MultiPolygon.js").default} */ (geometry);
      flatCoordinates = geometry.getOrientedFlatCoordinates();
      replayEndss = [];
      var endss = geometry.getEndss();
      offset = 0;
      for (var i = 0, ii = endss.length; i < ii; ++i) {
        var myEnds = [];
        offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);
        replayEndss.push(myEnds);
      }
      this.instructions.push([_Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].CUSTOM,
        replayBegin, replayEndss, geometry, renderer, _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_6__["inflateMultiCoordinatesArray"]]);
    } else if (type == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POLYGON || type == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].MULTI_LINE_STRING) {
      replayEnds = [];
      flatCoordinates = (type == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POLYGON) ?
        /** @type {import("../../geom/Polygon.js").default} */ (geometry).getOrientedFlatCoordinates() :
        geometry.getFlatCoordinates();
      offset = this.drawCustomCoordinates_(flatCoordinates, 0,
        /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */ (geometry).getEnds(),
        stride, replayEnds);
      this.instructions.push([_Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].CUSTOM,
        replayBegin, replayEnds, geometry, renderer, _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_6__["inflateCoordinatesArray"]]);
    } else if (type == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].LINE_STRING || type == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].MULTI_POINT) {
      flatCoordinates = geometry.getFlatCoordinates();
      replayEnd = this.appendFlatCoordinates(
        flatCoordinates, 0, flatCoordinates.length, stride, false, false);
      this.instructions.push([_Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].CUSTOM,
        replayBegin, replayEnd, geometry, renderer, _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_6__["inflateCoordinates"]]);
    } else if (type == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POINT) {
      flatCoordinates = geometry.getFlatCoordinates();
      this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);
      replayEnd = this.coordinates.length;
      this.instructions.push([_Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].CUSTOM,
        replayBegin, replayEnd, geometry, renderer]);
    }
    this.endGeometry(geometry, feature);
  };

  /**
   * @protected
   * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry Geometry.
   * @param {import("../../Feature.js").default|import("../Feature.js").default} feature Feature.
   */
  CanvasReplay.prototype.beginGeometry = function beginGeometry (geometry, feature) {
    this.beginGeometryInstruction1_ = [_Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].BEGIN_GEOMETRY, feature, 0];
    this.instructions.push(this.beginGeometryInstruction1_);
    this.beginGeometryInstruction2_ = [_Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].BEGIN_GEOMETRY, feature, 0];
    this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
  };

  /**
   * FIXME empty description for jsdoc
   */
  CanvasReplay.prototype.finish = function finish () {};

  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   */
  CanvasReplay.prototype.fill_ = function fill_ (context) {
    if (this.alignFill_) {
      var origin = Object(_transform_js__WEBPACK_IMPORTED_MODULE_16__["apply"])(this.renderedTransform_, [0, 0]);
      var repeatSize = 512 * this.pixelRatio;
      context.translate(origin[0] % repeatSize, origin[1] % repeatSize);
      context.rotate(this.viewRotation_);
    }
    context.fill();
    if (this.alignFill_) {
      context.setTransform.apply(context, _canvas_js__WEBPACK_IMPORTED_MODULE_13__["resetTransform"]);
    }
  };

  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {Array<*>} instruction Instruction.
   */
  CanvasReplay.prototype.setStrokeStyle_ = function setStrokeStyle_ (context, instruction) {
    context.strokeStyle = /** @type {import("../../colorlike.js").ColorLike} */ (instruction[1]);
    context.lineWidth = /** @type {number} */ (instruction[2]);
    context.lineCap = /** @type {CanvasLineCap} */ (instruction[3]);
    context.lineJoin = /** @type {CanvasLineJoin} */ (instruction[4]);
    context.miterLimit = /** @type {number} */ (instruction[5]);
    if (_has_js__WEBPACK_IMPORTED_MODULE_10__["CANVAS_LINE_DASH"]) {
      context.lineDashOffset = /** @type {number} */ (instruction[7]);
      context.setLineDash(/** @type {Array<number>} */ (instruction[6]));
    }
  };

  /**
   * @param {import("../canvas.js").DeclutterGroup} declutterGroup Declutter group.
   * @param {import("../../Feature.js").default|import("../Feature.js").default} feature Feature.
   */
  CanvasReplay.prototype.renderDeclutter_ = function renderDeclutter_ (declutterGroup, feature) {
    if (declutterGroup && declutterGroup.length > 5) {
      var groupCount = declutterGroup[4];
      if (groupCount == 1 || groupCount == declutterGroup.length - 5) {
        /** @type {import("../../structs/RBush.js").Entry} */
        var box = {
          minX: /** @type {number} */ (declutterGroup[0]),
          minY: /** @type {number} */ (declutterGroup[1]),
          maxX: /** @type {number} */ (declutterGroup[2]),
          maxY: /** @type {number} */ (declutterGroup[3]),
          value: feature
        };
        if (!this.declutterTree.collides(box)) {
          this.declutterTree.insert(box);
          for (var j = 5, jj = declutterGroup.length; j < jj; ++j) {
            var declutterData = /** @type {Array} */ (declutterGroup[j]);
            if (declutterData) {
              if (declutterData.length > 11) {
                this.replayTextBackground_(declutterData[0],
                  declutterData[13], declutterData[14], declutterData[15], declutterData[16],
                  declutterData[11], declutterData[12]);
              }
              _canvas_js__WEBPACK_IMPORTED_MODULE_13__["drawImage"].apply(undefined, declutterData);
            }
          }
        }
        declutterGroup.length = 5;
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__["createOrUpdateEmpty"])(declutterGroup);
      }
    }
  };

  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {Object<string, boolean>} skippedFeaturesHash Ids of features
   *     to skip.
   * @param {Array<*>} instructions Instructions array.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {function((import("../../Feature.js").default|import("../Feature.js").default)): T|undefined} featureCallback Feature callback.
   * @param {import("../../extent.js").Extent=} opt_hitExtent Only check features that intersect this
   *     extent.
   * @return {T|undefined} Callback result.
   * @template T
   */
  CanvasReplay.prototype.replay_ = function replay_ (
    context,
    transform,
    skippedFeaturesHash,
    instructions,
    snapToPixel,
    featureCallback,
    opt_hitExtent
  ) {
    /** @type {Array<number>} */
    var pixelCoordinates;
    if (this.pixelCoordinates_ && Object(_array_js__WEBPACK_IMPORTED_MODULE_1__["equals"])(transform, this.renderedTransform_)) {
      pixelCoordinates = this.pixelCoordinates_;
    } else {
      if (!this.pixelCoordinates_) {
        this.pixelCoordinates_ = [];
      }
      pixelCoordinates = Object(_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_9__["transform2D"])(
        this.coordinates, 0, this.coordinates.length, 2,
        transform, this.pixelCoordinates_);
      Object(_transform_js__WEBPACK_IMPORTED_MODULE_16__["setFromArray"])(this.renderedTransform_, transform);
    }
    var skipFeatures = !Object(_obj_js__WEBPACK_IMPORTED_MODULE_11__["isEmpty"])(skippedFeaturesHash);
    var i = 0; // instruction index
    var ii = instructions.length; // end of instructions
    var d = 0; // data index
    var dd; // end of per-instruction data
    var anchorX, anchorY, prevX, prevY, roundX, roundY, declutterGroup, image;
    var pendingFill = 0;
    var pendingStroke = 0;
    var lastFillInstruction = null;
    var lastStrokeInstruction = null;
    var coordinateCache = this.coordinateCache_;
    var viewRotation = this.viewRotation_;

    var state = /** @type {import("../../render.js").State} */ ({
      context: context,
      pixelRatio: this.pixelRatio,
      resolution: this.resolution,
      rotation: viewRotation
    });

    // When the batch size gets too big, performance decreases. 200 is a good
    // balance between batch size and number of fill/stroke instructions.
    var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;
    var /** @type {import("../../Feature.js").default|import("../Feature.js").default} */ feature;
    var x, y;
    while (i < ii) {
      var instruction = instructions[i];
      var type = /** @type {CanvasInstruction} */ (instruction[0]);
      switch (type) {
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].BEGIN_GEOMETRY:
          feature = /** @type {import("../../Feature.js").default|import("../Feature.js").default} */ (instruction[1]);
          if ((skipFeatures && skippedFeaturesHash[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature)]) || !feature.getGeometry()) {
            i = /** @type {number} */ (instruction[2]);
          } else if (opt_hitExtent !== undefined && !Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__["intersects"])(
            opt_hitExtent, feature.getGeometry().getExtent())) {
            i = /** @type {number} */ (instruction[2]) + 1;
          } else {
            ++i;
          }
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].BEGIN_PATH:
          if (pendingFill > batchSize) {
            this.fill_(context);
            pendingFill = 0;
          }
          if (pendingStroke > batchSize) {
            context.stroke();
            pendingStroke = 0;
          }
          if (!pendingFill && !pendingStroke) {
            context.beginPath();
            prevX = prevY = NaN;
          }
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].CIRCLE:
          d = /** @type {number} */ (instruction[1]);
          var x1 = pixelCoordinates[d];
          var y1 = pixelCoordinates[d + 1];
          var x2 = pixelCoordinates[d + 2];
          var y2 = pixelCoordinates[d + 3];
          var dx = x2 - x1;
          var dy = y2 - y1;
          var r = Math.sqrt(dx * dx + dy * dy);
          context.moveTo(x1 + r, y1);
          context.arc(x1, y1, r, 0, 2 * Math.PI, true);
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].CLOSE_PATH:
          context.closePath();
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].CUSTOM:
          d = /** @type {number} */ (instruction[1]);
          dd = instruction[2];
          var geometry = /** @type {import("../../geom/SimpleGeometry.js").default} */ (instruction[3]);
          var renderer = instruction[4];
          var fn = instruction.length == 6 ? instruction[5] : undefined;
          state.geometry = geometry;
          state.feature = feature;
          if (!(i in coordinateCache)) {
            coordinateCache[i] = [];
          }
          var coords = coordinateCache[i];
          if (fn) {
            fn(pixelCoordinates, d, dd, 2, coords);
          } else {
            coords[0] = pixelCoordinates[d];
            coords[1] = pixelCoordinates[d + 1];
            coords.length = 2;
          }
          renderer(coords, state);
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].DRAW_IMAGE:
          d = /** @type {number} */ (instruction[1]);
          dd = /** @type {number} */ (instruction[2]);
          image = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */
              (instruction[3]);
          // Remaining arguments in DRAW_IMAGE are in alphabetical order
          anchorX = /** @type {number} */ (instruction[4]);
          anchorY = /** @type {number} */ (instruction[5]);
          declutterGroup = featureCallback ? null : /** @type {import("../canvas.js").DeclutterGroup} */ (instruction[6]);
          var height = /** @type {number} */ (instruction[7]);
          var opacity = /** @type {number} */ (instruction[8]);
          var originX = /** @type {number} */ (instruction[9]);
          var originY = /** @type {number} */ (instruction[10]);
          var rotateWithView = /** @type {boolean} */ (instruction[11]);
          var rotation = /** @type {number} */ (instruction[12]);
          var scale = /** @type {number} */ (instruction[13]);
          var width = /** @type {number} */ (instruction[14]);

          var padding = (void 0), backgroundFill = (void 0), backgroundStroke = (void 0);
          if (instruction.length > 16) {
            padding = /** @type {Array<number>} */ (instruction[15]);
            backgroundFill = /** @type {boolean} */ (instruction[16]);
            backgroundStroke = /** @type {boolean} */ (instruction[17]);
          } else {
            padding = _canvas_js__WEBPACK_IMPORTED_MODULE_13__["defaultPadding"];
            backgroundFill = backgroundStroke = false;
          }

          if (rotateWithView) {
            rotation += viewRotation;
          }
          for (; d < dd; d += 2) {
            this.replayImage_(context,
              pixelCoordinates[d], pixelCoordinates[d + 1], image, anchorX, anchorY,
              declutterGroup, height, opacity, originX, originY, rotation, scale,
              snapToPixel, width, padding,
              backgroundFill ? /** @type {Array<*>} */ (lastFillInstruction) : null,
              backgroundStroke ? /** @type {Array<*>} */ (lastStrokeInstruction) : null);
          }
          this.renderDeclutter_(declutterGroup, feature);
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].DRAW_CHARS:
          var begin = /** @type {number} */ (instruction[1]);
          var end = /** @type {number} */ (instruction[2]);
          var baseline = /** @type {number} */ (instruction[3]);
          declutterGroup = featureCallback ? null : /** @type {import("../canvas.js").DeclutterGroup} */ (instruction[4]);
          var overflow = /** @type {number} */ (instruction[5]);
          var fillKey = /** @type {string} */ (instruction[6]);
          var maxAngle = /** @type {number} */ (instruction[7]);
          var measure = /** @type {function(string):number} */ (instruction[8]);
          var offsetY = /** @type {number} */ (instruction[9]);
          var strokeKey = /** @type {string} */ (instruction[10]);
          var strokeWidth = /** @type {number} */ (instruction[11]);
          var text = /** @type {string} */ (instruction[12]);
          var textKey = /** @type {string} */ (instruction[13]);
          var textScale = /** @type {number} */ (instruction[14]);

          var pathLength = Object(_geom_flat_length_js__WEBPACK_IMPORTED_MODULE_7__["lineStringLength"])(pixelCoordinates, begin, end, 2);
          var textLength = measure(text);
          if (overflow || textLength <= pathLength) {
            /** @type {import("./TextReplay.js").default} */
            var textReplay = /** @type {?} */ (this);
            var textAlign = textReplay.textStates[textKey].textAlign;
            var startM = (pathLength - textLength) * _replay_js__WEBPACK_IMPORTED_MODULE_15__["TEXT_ALIGN"][textAlign];
            var parts = Object(_geom_flat_textpath_js__WEBPACK_IMPORTED_MODULE_8__["drawTextOnPath"])(
              pixelCoordinates, begin, end, 2, text, measure, startM, maxAngle);
            if (parts) {
              var c = (void 0), cc = (void 0), chars = (void 0), label = (void 0), part = (void 0);
              if (strokeKey) {
                for (c = 0, cc = parts.length; c < cc; ++c) {
                  part = parts[c]; // x, y, anchorX, rotation, chunk
                  chars = /** @type {string} */ (part[4]);
                  label = textReplay.getImage(chars, textKey, '', strokeKey);
                  anchorX = /** @type {number} */ (part[2]) + strokeWidth;
                  anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth - offsetY;
                  this.replayImage_(context,
                    /** @type {number} */ (part[0]), /** @type {number} */ (part[1]), label,
                    anchorX, anchorY, declutterGroup, label.height, 1, 0, 0,
                    /** @type {number} */ (part[3]), textScale, false, label.width,
                    _canvas_js__WEBPACK_IMPORTED_MODULE_13__["defaultPadding"], null, null);
                }
              }
              if (fillKey) {
                for (c = 0, cc = parts.length; c < cc; ++c) {
                  part = parts[c]; // x, y, anchorX, rotation, chunk
                  chars = /** @type {string} */ (part[4]);
                  label = textReplay.getImage(chars, textKey, fillKey, '');
                  anchorX = /** @type {number} */ (part[2]);
                  anchorY = baseline * label.height - offsetY;
                  this.replayImage_(context,
                    /** @type {number} */ (part[0]), /** @type {number} */ (part[1]), label,
                    anchorX, anchorY, declutterGroup, label.height, 1, 0, 0,
                    /** @type {number} */ (part[3]), textScale, false, label.width,
                    _canvas_js__WEBPACK_IMPORTED_MODULE_13__["defaultPadding"], null, null);
                }
              }
            }
          }
          this.renderDeclutter_(declutterGroup, feature);
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].END_GEOMETRY:
          if (featureCallback !== undefined) {
            feature = /** @type {import("../../Feature.js").default|import("../Feature.js").default} */ (instruction[1]);
            var result = featureCallback(feature);
            if (result) {
              return result;
            }
          }
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].FILL:
          if (batchSize) {
            pendingFill++;
          } else {
            this.fill_(context);
          }
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].MOVE_TO_LINE_TO:
          d = /** @type {number} */ (instruction[1]);
          dd = /** @type {number} */ (instruction[2]);
          x = pixelCoordinates[d];
          y = pixelCoordinates[d + 1];
          roundX = (x + 0.5) | 0;
          roundY = (y + 0.5) | 0;
          if (roundX !== prevX || roundY !== prevY) {
            context.moveTo(x, y);
            prevX = roundX;
            prevY = roundY;
          }
          for (d += 2; d < dd; d += 2) {
            x = pixelCoordinates[d];
            y = pixelCoordinates[d + 1];
            roundX = (x + 0.5) | 0;
            roundY = (y + 0.5) | 0;
            if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {
              context.lineTo(x, y);
              prevX = roundX;
              prevY = roundY;
            }
          }
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].SET_FILL_STYLE:
          lastFillInstruction = instruction;
          this.alignFill_ = instruction[2];

          if (pendingFill) {
            this.fill_(context);
            pendingFill = 0;
            if (pendingStroke) {
              context.stroke();
              pendingStroke = 0;
            }
          }

          context.fillStyle = /** @type {import("../../colorlike.js").ColorLike} */ (instruction[1]);
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].SET_STROKE_STYLE:
          lastStrokeInstruction = instruction;
          if (pendingStroke) {
            context.stroke();
            pendingStroke = 0;
          }
          this.setStrokeStyle_(context, /** @type {Array<*>} */ (instruction));
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].STROKE:
          if (batchSize) {
            pendingStroke++;
          } else {
            context.stroke();
          }
          ++i;
          break;
        default:
          ++i; // consume the instruction anyway, to avoid an infinite loop
          break;
      }
    }
    if (pendingFill) {
      this.fill_(context);
    }
    if (pendingStroke) {
      context.stroke();
    }
    return undefined;
  };

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {Object<string, boolean>} skippedFeaturesHash Ids of features
   *     to skip.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   */
  CanvasReplay.prototype.replay = function replay (context, transform, viewRotation, skippedFeaturesHash, snapToPixel) {
    this.viewRotation_ = viewRotation;
    this.replay_(context, transform,
      skippedFeaturesHash, this.instructions, snapToPixel, undefined, undefined);
  };

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {Object<string, boolean>} skippedFeaturesHash Ids of features
   *     to skip.
   * @param {function((import("../../Feature.js").default|import("../Feature.js").default)): T=} opt_featureCallback
   *     Feature callback.
   * @param {import("../../extent.js").Extent=} opt_hitExtent Only check features that intersect this
   *     extent.
   * @return {T|undefined} Callback result.
   * @template T
   */
  CanvasReplay.prototype.replayHitDetection = function replayHitDetection (
    context,
    transform,
    viewRotation,
    skippedFeaturesHash,
    opt_featureCallback,
    opt_hitExtent
  ) {
    this.viewRotation_ = viewRotation;
    return this.replay_(context, transform, skippedFeaturesHash,
      this.hitDetectionInstructions, true, opt_featureCallback, opt_hitExtent);
  };

  /**
   * Reverse the hit detection instructions.
   */
  CanvasReplay.prototype.reverseHitDetectionInstructions = function reverseHitDetectionInstructions () {
    var hitDetectionInstructions = this.hitDetectionInstructions;
    // step 1 - reverse array
    hitDetectionInstructions.reverse();
    // step 2 - reverse instructions within geometry blocks
    var i;
    var n = hitDetectionInstructions.length;
    var instruction;
    var type;
    var begin = -1;
    for (i = 0; i < n; ++i) {
      instruction = hitDetectionInstructions[i];
      type = /** @type {CanvasInstruction} */ (instruction[0]);
      if (type == _Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].END_GEOMETRY) {
        begin = i;
      } else if (type == _Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].BEGIN_GEOMETRY) {
        instruction[2] = i;
        Object(_array_js__WEBPACK_IMPORTED_MODULE_1__["reverseSubArray"])(this.hitDetectionInstructions, begin, i);
        begin = -1;
      }
    }
  };

  /**
   * @inheritDoc
   */
  CanvasReplay.prototype.setFillStrokeStyle = function setFillStrokeStyle (fillStyle, strokeStyle) {
    var state = this.state;
    if (fillStyle) {
      var fillStyleColor = fillStyle.getColor();
      state.fillStyle = Object(_colorlike_js__WEBPACK_IMPORTED_MODULE_2__["asColorLike"])(fillStyleColor ?
        fillStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_13__["defaultFillStyle"]);
    } else {
      state.fillStyle = undefined;
    }
    if (strokeStyle) {
      var strokeStyleColor = strokeStyle.getColor();
      state.strokeStyle = Object(_colorlike_js__WEBPACK_IMPORTED_MODULE_2__["asColorLike"])(strokeStyleColor ?
        strokeStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_13__["defaultStrokeStyle"]);
      var strokeStyleLineCap = strokeStyle.getLineCap();
      state.lineCap = strokeStyleLineCap !== undefined ?
        strokeStyleLineCap : _canvas_js__WEBPACK_IMPORTED_MODULE_13__["defaultLineCap"];
      var strokeStyleLineDash = strokeStyle.getLineDash();
      state.lineDash = strokeStyleLineDash ?
        strokeStyleLineDash.slice() : _canvas_js__WEBPACK_IMPORTED_MODULE_13__["defaultLineDash"];
      var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
      state.lineDashOffset = strokeStyleLineDashOffset ?
        strokeStyleLineDashOffset : _canvas_js__WEBPACK_IMPORTED_MODULE_13__["defaultLineDashOffset"];
      var strokeStyleLineJoin = strokeStyle.getLineJoin();
      state.lineJoin = strokeStyleLineJoin !== undefined ?
        strokeStyleLineJoin : _canvas_js__WEBPACK_IMPORTED_MODULE_13__["defaultLineJoin"];
      var strokeStyleWidth = strokeStyle.getWidth();
      state.lineWidth = strokeStyleWidth !== undefined ?
        strokeStyleWidth : _canvas_js__WEBPACK_IMPORTED_MODULE_13__["defaultLineWidth"];
      var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
      state.miterLimit = strokeStyleMiterLimit !== undefined ?
        strokeStyleMiterLimit : _canvas_js__WEBPACK_IMPORTED_MODULE_13__["defaultMiterLimit"];

      if (state.lineWidth > this.maxLineWidth) {
        this.maxLineWidth = state.lineWidth;
        // invalidate the buffered max extent cache
        this.bufferedMaxExtent_ = null;
      }
    } else {
      state.strokeStyle = undefined;
      state.lineCap = undefined;
      state.lineDash = null;
      state.lineDashOffset = undefined;
      state.lineJoin = undefined;
      state.lineWidth = undefined;
      state.miterLimit = undefined;
    }
  };

  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry Geometry.
   * @return {Array<*>} Fill instruction.
   */
  CanvasReplay.prototype.createFill = function createFill (state, geometry) {
    var fillStyle = state.fillStyle;
    /** @type {Array<*>} */
    var fillInstruction = [_Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].SET_FILL_STYLE, fillStyle];
    if (typeof fillStyle !== 'string') {
      // Fill is a pattern or gradient - align it!
      fillInstruction.push(true);
    }
    return fillInstruction;
  };

  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   */
  CanvasReplay.prototype.applyStroke = function applyStroke (state) {
    this.instructions.push(this.createStroke(state));
  };

  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Stroke instruction.
   */
  CanvasReplay.prototype.createStroke = function createStroke (state) {
    return [
      _Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].SET_STROKE_STYLE,
      state.strokeStyle, state.lineWidth * this.pixelRatio, state.lineCap,
      state.lineJoin, state.miterLimit,
      this.applyPixelRatio(state.lineDash), state.lineDashOffset * this.pixelRatio
    ];
  };

  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasReplay, import("../canvas.js").FillStrokeState, (import("../../geom/Geometry.js").default|import("../Feature.js").default)):Array<*>} createFill Create fill.
   * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry Geometry.
   */
  CanvasReplay.prototype.updateFillStyle = function updateFillStyle (state, createFill, geometry) {
    var fillStyle = state.fillStyle;
    if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {
      if (fillStyle !== undefined) {
        this.instructions.push(createFill.call(this, state, geometry));
      }
      state.currentFillStyle = fillStyle;
    }
  };

  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasReplay, import("../canvas.js").FillStrokeState)} applyStroke Apply stroke.
   */
  CanvasReplay.prototype.updateStrokeStyle = function updateStrokeStyle (state, applyStroke) {
    var strokeStyle = state.strokeStyle;
    var lineCap = state.lineCap;
    var lineDash = state.lineDash;
    var lineDashOffset = state.lineDashOffset;
    var lineJoin = state.lineJoin;
    var lineWidth = state.lineWidth;
    var miterLimit = state.miterLimit;
    if (state.currentStrokeStyle != strokeStyle ||
        state.currentLineCap != lineCap ||
        (lineDash != state.currentLineDash && !Object(_array_js__WEBPACK_IMPORTED_MODULE_1__["equals"])(state.currentLineDash, lineDash)) ||
        state.currentLineDashOffset != lineDashOffset ||
        state.currentLineJoin != lineJoin ||
        state.currentLineWidth != lineWidth ||
        state.currentMiterLimit != miterLimit) {
      if (strokeStyle !== undefined) {
        applyStroke.call(this, state);
      }
      state.currentStrokeStyle = strokeStyle;
      state.currentLineCap = lineCap;
      state.currentLineDash = lineDash;
      state.currentLineDashOffset = lineDashOffset;
      state.currentLineJoin = lineJoin;
      state.currentLineWidth = lineWidth;
      state.currentMiterLimit = miterLimit;
    }
  };

  /**
   * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry Geometry.
   * @param {import("../../Feature.js").default|import("../Feature.js").default} feature Feature.
   */
  CanvasReplay.prototype.endGeometry = function endGeometry (geometry, feature) {
    this.beginGeometryInstruction1_[2] = this.instructions.length;
    this.beginGeometryInstruction1_ = null;
    this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;
    this.beginGeometryInstruction2_ = null;
    var endGeometryInstruction = [_Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].END_GEOMETRY, feature];
    this.instructions.push(endGeometryInstruction);
    this.hitDetectionInstructions.push(endGeometryInstruction);
  };

  /**
   * Get the buffered rendering extent.  Rendering will be clipped to the extent
   * provided to the constructor.  To account for symbolizers that may intersect
   * this extent, we calculate a buffered extent (e.g. based on stroke width).
   * @return {import("../../extent.js").Extent} The buffered rendering extent.
   * @protected
   */
  CanvasReplay.prototype.getBufferedMaxExtent = function getBufferedMaxExtent () {
    if (!this.bufferedMaxExtent_) {
      this.bufferedMaxExtent_ = Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__["clone"])(this.maxExtent);
      if (this.maxLineWidth > 0) {
        var width = this.resolution * (this.maxLineWidth + 1) / 2;
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__["buffer"])(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
      }
    }
    return this.bufferedMaxExtent_;
  };

  return CanvasReplay;
}(_VectorContext_js__WEBPACK_IMPORTED_MODULE_12__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (CanvasReplay);

//# sourceMappingURL=Replay.js.map

/***/ }),

/***/ "./node_modules/ol/render/canvas/ReplayGroup.js":
/*!******************************************************!*\
  !*** ./node_modules/ol/render/canvas/ReplayGroup.js ***!
  \******************************************************/
/*! exports provided: getCircleArray, replayDeclutter, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCircleArray", function() { return getCircleArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "replayDeclutter", function() { return replayDeclutter; });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../geom/flat/transform.js */ "./node_modules/ol/geom/flat/transform.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _ReplayGroup_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../ReplayGroup.js */ "./node_modules/ol/render/ReplayGroup.js");
/* harmony import */ var _ReplayType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../ReplayType.js */ "./node_modules/ol/render/ReplayType.js");
/* harmony import */ var _Replay_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Replay.js */ "./node_modules/ol/render/canvas/Replay.js");
/* harmony import */ var _ImageReplay_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ImageReplay.js */ "./node_modules/ol/render/canvas/ImageReplay.js");
/* harmony import */ var _LineStringReplay_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./LineStringReplay.js */ "./node_modules/ol/render/canvas/LineStringReplay.js");
/* harmony import */ var _PolygonReplay_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./PolygonReplay.js */ "./node_modules/ol/render/canvas/PolygonReplay.js");
/* harmony import */ var _TextReplay_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./TextReplay.js */ "./node_modules/ol/render/canvas/TextReplay.js");
/* harmony import */ var _replay_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../replay.js */ "./node_modules/ol/render/replay.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/render/canvas/ReplayGroup
 */

















/**
 * @type {Object<ReplayType, typeof CanvasReplay>}
 */
var BATCH_CONSTRUCTORS = {
  'Circle': _PolygonReplay_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  'Default': _Replay_js__WEBPACK_IMPORTED_MODULE_7__["default"],
  'Image': _ImageReplay_js__WEBPACK_IMPORTED_MODULE_8__["default"],
  'LineString': _LineStringReplay_js__WEBPACK_IMPORTED_MODULE_9__["default"],
  'Polygon': _PolygonReplay_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  'Text': _TextReplay_js__WEBPACK_IMPORTED_MODULE_11__["default"]
};


var CanvasReplayGroup = /*@__PURE__*/(function (ReplayGroup) {
  function CanvasReplayGroup(
    tolerance,
    maxExtent,
    resolution,
    pixelRatio,
    overlaps,
    declutterTree,
    opt_renderBuffer
  ) {
    ReplayGroup.call(this);

    /**
     * Declutter tree.
     * @private
     */
    this.declutterTree_ = declutterTree;

    /**
     * @type {import("../canvas.js").DeclutterGroup}
     * @private
     */
    this.declutterGroup_ = null;

    /**
     * @private
     * @type {number}
     */
    this.tolerance_ = tolerance;

    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */
    this.maxExtent_ = maxExtent;

    /**
     * @private
     * @type {boolean}
     */
    this.overlaps_ = overlaps;

    /**
     * @private
     * @type {number}
     */
    this.pixelRatio_ = pixelRatio;

    /**
     * @private
     * @type {number}
     */
    this.resolution_ = resolution;

    /**
     * @private
     * @type {number|undefined}
     */
    this.renderBuffer_ = opt_renderBuffer;

    /**
     * @private
     * @type {!Object<string, !Object<ReplayType, CanvasReplay>>}
     */
    this.replaysByZIndex_ = {};

    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */
    this.hitDetectionContext_ = Object(_dom_js__WEBPACK_IMPORTED_MODULE_1__["createCanvasContext2D"])(1, 1);

    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */
    this.hitDetectionTransform_ = Object(_transform_js__WEBPACK_IMPORTED_MODULE_13__["create"])();
  }

  if ( ReplayGroup ) CanvasReplayGroup.__proto__ = ReplayGroup;
  CanvasReplayGroup.prototype = Object.create( ReplayGroup && ReplayGroup.prototype );
  CanvasReplayGroup.prototype.constructor = CanvasReplayGroup;

  /**
   * @inheritDoc
   */
  CanvasReplayGroup.prototype.addDeclutter = function addDeclutter (group) {
    var declutter = null;
    if (this.declutterTree_) {
      if (group) {
        declutter = this.declutterGroup_;
        /** @type {number} */ (declutter[4])++;
      } else {
        declutter = this.declutterGroup_ = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["createEmpty"])();
        declutter.push(1);
      }
    }
    return declutter;
  };

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   */
  CanvasReplayGroup.prototype.clip = function clip (context, transform) {
    var flatClipCoords = this.getClipCoords(transform);
    context.beginPath();
    context.moveTo(flatClipCoords[0], flatClipCoords[1]);
    context.lineTo(flatClipCoords[2], flatClipCoords[3]);
    context.lineTo(flatClipCoords[4], flatClipCoords[5]);
    context.lineTo(flatClipCoords[6], flatClipCoords[7]);
    context.clip();
  };

  /**
   * @param {Array<ReplayType>} replays Replays.
   * @return {boolean} Has replays of the provided types.
   */
  CanvasReplayGroup.prototype.hasReplays = function hasReplays (replays) {
    for (var zIndex in this.replaysByZIndex_) {
      var candidates = this.replaysByZIndex_[zIndex];
      for (var i = 0, ii = replays.length; i < ii; ++i) {
        if (replays[i] in candidates) {
          return true;
        }
      }
    }
    return false;
  };

  /**
   * FIXME empty description for jsdoc
   */
  CanvasReplayGroup.prototype.finish = function finish () {
    for (var zKey in this.replaysByZIndex_) {
      var replays = this.replaysByZIndex_[zKey];
      for (var replayKey in replays) {
        replays[replayKey].finish();
      }
    }
  };

  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {Object<string, boolean>} skippedFeaturesHash Ids of features to skip.
   * @param {function((import("../../Feature.js").default|import("../Feature.js").default)): T} callback Feature callback.
   * @param {Object<string, import("../canvas.js").DeclutterGroup>} declutterReplays Declutter replays.
   * @return {T|undefined} Callback result.
   * @template T
   */
  CanvasReplayGroup.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate (
    coordinate,
    resolution,
    rotation,
    hitTolerance,
    skippedFeaturesHash,
    callback,
    declutterReplays
  ) {

    hitTolerance = Math.round(hitTolerance);
    var contextSize = hitTolerance * 2 + 1;
    var transform = Object(_transform_js__WEBPACK_IMPORTED_MODULE_13__["compose"])(this.hitDetectionTransform_,
      hitTolerance + 0.5, hitTolerance + 0.5,
      1 / resolution, -1 / resolution,
      -rotation,
      -coordinate[0], -coordinate[1]);
    var context = this.hitDetectionContext_;

    if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {
      context.canvas.width = contextSize;
      context.canvas.height = contextSize;
    } else {
      context.clearRect(0, 0, contextSize, contextSize);
    }

    /**
     * @type {import("../../extent.js").Extent}
     */
    var hitExtent;
    if (this.renderBuffer_ !== undefined) {
      hitExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["createEmpty"])();
      Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["extendCoordinate"])(hitExtent, coordinate);
      Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["buffer"])(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);
    }

    var mask = getCircleArray(hitTolerance);
    var declutteredFeatures;
    if (this.declutterTree_) {
      declutteredFeatures = this.declutterTree_.all().map(function(entry) {
        return entry.value;
      });
    }

    var replayType;

    /**
     * @param {import("../../Feature.js").default|import("../Feature.js").default} feature Feature.
     * @return {?} Callback result.
     */
    function featureCallback(feature) {
      var imageData = context.getImageData(0, 0, contextSize, contextSize).data;
      for (var i = 0; i < contextSize; i++) {
        for (var j = 0; j < contextSize; j++) {
          if (mask[i][j]) {
            if (imageData[(j * contextSize + i) * 4 + 3] > 0) {
              var result = (void 0);
              if (!(declutteredFeatures && (replayType == _ReplayType_js__WEBPACK_IMPORTED_MODULE_6__["default"].IMAGE || replayType == _ReplayType_js__WEBPACK_IMPORTED_MODULE_6__["default"].TEXT)) ||
                  declutteredFeatures.indexOf(feature) !== -1) {
                result = callback(feature);
              }
              if (result) {
                return result;
              } else {
                context.clearRect(0, 0, contextSize, contextSize);
                return undefined;
              }
            }
          }
        }
      }
    }

    /** @type {Array<number>} */
    var zs = Object.keys(this.replaysByZIndex_).map(Number);
    zs.sort(_array_js__WEBPACK_IMPORTED_MODULE_0__["numberSafeCompareFunction"]);

    var i, j, replays, replay, result;
    for (i = zs.length - 1; i >= 0; --i) {
      var zIndexKey = zs[i].toString();
      replays = this.replaysByZIndex_[zIndexKey];
      for (j = _replay_js__WEBPACK_IMPORTED_MODULE_12__["ORDER"].length - 1; j >= 0; --j) {
        replayType = _replay_js__WEBPACK_IMPORTED_MODULE_12__["ORDER"][j];
        replay = replays[replayType];
        if (replay !== undefined) {
          if (declutterReplays &&
              (replayType == _ReplayType_js__WEBPACK_IMPORTED_MODULE_6__["default"].IMAGE || replayType == _ReplayType_js__WEBPACK_IMPORTED_MODULE_6__["default"].TEXT)) {
            var declutter = declutterReplays[zIndexKey];
            if (!declutter) {
              declutterReplays[zIndexKey] = [replay, transform.slice(0)];
            } else {
              declutter.push(replay, transform.slice(0));
            }
          } else {
            result = replay.replayHitDetection(context, transform, rotation,
              skippedFeaturesHash, featureCallback, hitExtent);
            if (result) {
              return result;
            }
          }
        }
      }
    }
    return undefined;
  };

  /**
   * @param {import("../../transform.js").Transform} transform Transform.
   * @return {Array<number>} Clip coordinates.
   */
  CanvasReplayGroup.prototype.getClipCoords = function getClipCoords (transform) {
    var maxExtent = this.maxExtent_;
    var minX = maxExtent[0];
    var minY = maxExtent[1];
    var maxX = maxExtent[2];
    var maxY = maxExtent[3];
    var flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];
    Object(_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_3__["transform2D"])(
      flatClipCoords, 0, 8, 2, transform, flatClipCoords);
    return flatClipCoords;
  };

  /**
   * @inheritDoc
   */
  CanvasReplayGroup.prototype.getReplay = function getReplay (zIndex, replayType) {
    var zIndexKey = zIndex !== undefined ? zIndex.toString() : '0';
    var replays = this.replaysByZIndex_[zIndexKey];
    if (replays === undefined) {
      replays = {};
      this.replaysByZIndex_[zIndexKey] = replays;
    }
    var replay = replays[replayType];
    if (replay === undefined) {
      var Constructor = BATCH_CONSTRUCTORS[replayType];
      replay = new Constructor(this.tolerance_, this.maxExtent_,
        this.resolution_, this.pixelRatio_, this.overlaps_, this.declutterTree_);
      replays[replayType] = replay;
    }
    return replay;
  };

  /**
   * @return {Object<string, Object<ReplayType, CanvasReplay>>} Replays.
   */
  CanvasReplayGroup.prototype.getReplays = function getReplays () {
    return this.replaysByZIndex_;
  };

  /**
   * @inheritDoc
   */
  CanvasReplayGroup.prototype.isEmpty = function isEmpty$1 () {
    return Object(_obj_js__WEBPACK_IMPORTED_MODULE_4__["isEmpty"])(this.replaysByZIndex_);
  };

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {Object<string, boolean>} skippedFeaturesHash Ids of features to skip.
   * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.
   * @param {Array<ReplayType>=} opt_replayTypes Ordered replay types to replay.
   *     Default is {@link module:ol/render/replay~ORDER}
   * @param {Object<string, import("../canvas.js").DeclutterGroup>=} opt_declutterReplays Declutter replays.
   */
  CanvasReplayGroup.prototype.replay = function replay (
    context,
    transform,
    viewRotation,
    skippedFeaturesHash,
    snapToPixel,
    opt_replayTypes,
    opt_declutterReplays
  ) {

    /** @type {Array<number>} */
    var zs = Object.keys(this.replaysByZIndex_).map(Number);
    zs.sort(_array_js__WEBPACK_IMPORTED_MODULE_0__["numberSafeCompareFunction"]);

    // setup clipping so that the parts of over-simplified geometries are not
    // visible outside the current extent when panning
    context.save();
    this.clip(context, transform);

    var replayTypes = opt_replayTypes ? opt_replayTypes : _replay_js__WEBPACK_IMPORTED_MODULE_12__["ORDER"];
    var i, ii, j, jj, replays, replay;
    for (i = 0, ii = zs.length; i < ii; ++i) {
      var zIndexKey = zs[i].toString();
      replays = this.replaysByZIndex_[zIndexKey];
      for (j = 0, jj = replayTypes.length; j < jj; ++j) {
        var replayType = replayTypes[j];
        replay = replays[replayType];
        if (replay !== undefined) {
          if (opt_declutterReplays &&
              (replayType == _ReplayType_js__WEBPACK_IMPORTED_MODULE_6__["default"].IMAGE || replayType == _ReplayType_js__WEBPACK_IMPORTED_MODULE_6__["default"].TEXT)) {
            var declutter = opt_declutterReplays[zIndexKey];
            if (!declutter) {
              opt_declutterReplays[zIndexKey] = [replay, transform.slice(0)];
            } else {
              declutter.push(replay, transform.slice(0));
            }
          } else {
            replay.replay(context, transform, viewRotation, skippedFeaturesHash, snapToPixel);
          }
        }
      }
    }

    context.restore();
  };

  return CanvasReplayGroup;
}(_ReplayGroup_js__WEBPACK_IMPORTED_MODULE_5__["default"]));


/**
 * This cache is used for storing calculated pixel circles for increasing performance.
 * It is a static property to allow each Replaygroup to access it.
 * @type {Object<number, Array<Array<(boolean|undefined)>>>}
 */
var circleArrayCache = {
  0: [[true]]
};


/**
 * This method fills a row in the array from the given coordinate to the
 * middle with `true`.
 * @param {Array<Array<(boolean|undefined)>>} array The array that will be altered.
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 */
function fillCircleArrayRowToMiddle(array, x, y) {
  var i;
  var radius = Math.floor(array.length / 2);
  if (x >= radius) {
    for (i = radius; i < x; i++) {
      array[i][y] = true;
    }
  } else if (x < radius) {
    for (i = x + 1; i < radius; i++) {
      array[i][y] = true;
    }
  }
}


/**
 * This methods creates a circle inside a fitting array. Points inside the
 * circle are marked by true, points on the outside are undefined.
 * It uses the midpoint circle algorithm.
 * A cache is used to increase performance.
 * @param {number} radius Radius.
 * @returns {Array<Array<(boolean|undefined)>>} An array with marked circle points.
 */
function getCircleArray(radius) {
  if (circleArrayCache[radius] !== undefined) {
    return circleArrayCache[radius];
  }

  var arraySize = radius * 2 + 1;
  var arr = new Array(arraySize);
  for (var i = 0; i < arraySize; i++) {
    arr[i] = new Array(arraySize);
  }

  var x = radius;
  var y = 0;
  var error = 0;

  while (x >= y) {
    fillCircleArrayRowToMiddle(arr, radius + x, radius + y);
    fillCircleArrayRowToMiddle(arr, radius + y, radius + x);
    fillCircleArrayRowToMiddle(arr, radius - y, radius + x);
    fillCircleArrayRowToMiddle(arr, radius - x, radius + y);
    fillCircleArrayRowToMiddle(arr, radius - x, radius - y);
    fillCircleArrayRowToMiddle(arr, radius - y, radius - x);
    fillCircleArrayRowToMiddle(arr, radius + y, radius - x);
    fillCircleArrayRowToMiddle(arr, radius + x, radius - y);

    y++;
    error += 1 + 2 * y;
    if (2 * (error - x) + 1 > 0) {
      x -= 1;
      error += 1 - 2 * x;
    }
  }

  circleArrayCache[radius] = arr;
  return arr;
}


/**
 * @param {!Object<string, Array<*>>} declutterReplays Declutter replays.
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} rotation Rotation.
 * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
 */
function replayDeclutter(declutterReplays, context, rotation, snapToPixel) {
  var zs = Object.keys(declutterReplays).map(Number).sort(_array_js__WEBPACK_IMPORTED_MODULE_0__["numberSafeCompareFunction"]);
  var skippedFeatureUids = {};
  for (var z = 0, zz = zs.length; z < zz; ++z) {
    var replayData = declutterReplays[zs[z].toString()];
    for (var i = 0, ii = replayData.length; i < ii;) {
      var replay = replayData[i++];
      var transform = replayData[i++];
      replay.replay(context, transform, rotation, skippedFeatureUids, snapToPixel);
    }
  }
}


/* harmony default export */ __webpack_exports__["default"] = (CanvasReplayGroup);

//# sourceMappingURL=ReplayGroup.js.map

/***/ }),

/***/ "./node_modules/ol/render/canvas/TextReplay.js":
/*!*****************************************************!*\
  !*** ./node_modules/ol/render/canvas/TextReplay.js ***!
  \*****************************************************/
/*! exports provided: measureTextWidths, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "measureTextWidths", function() { return measureTextWidths; });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _colorlike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../colorlike.js */ "./node_modules/ol/colorlike.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_flat_straightchunk_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../geom/flat/straightchunk.js */ "./node_modules/ol/geom/flat/straightchunk.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _canvas_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _Instruction_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Instruction.js */ "./node_modules/ol/render/canvas/Instruction.js");
/* harmony import */ var _Replay_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Replay.js */ "./node_modules/ol/render/canvas/Replay.js");
/* harmony import */ var _replay_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../replay.js */ "./node_modules/ol/render/replay.js");
/* harmony import */ var _style_TextPlacement_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../style/TextPlacement.js */ "./node_modules/ol/style/TextPlacement.js");
/**
 * @module ol/render/canvas/TextReplay
 */













var CanvasTextReplay = /*@__PURE__*/(function (CanvasReplay) {
  function CanvasTextReplay(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {
    CanvasReplay.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);

    /**
     * @private
     * @type {import("../canvas.js").DeclutterGroup}
     */
    this.declutterGroup_;

    /**
     * @private
     * @type {Array<HTMLCanvasElement>}
     */
    this.labels_ = null;

    /**
     * @private
     * @type {string}
     */
    this.text_ = '';

    /**
     * @private
     * @type {number}
     */
    this.textOffsetX_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.textOffsetY_ = 0;

    /**
     * @private
     * @type {boolean|undefined}
     */
    this.textRotateWithView_ = undefined;

    /**
     * @private
     * @type {number}
     */
    this.textRotation_ = 0;

    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */
    this.textFillState_ = null;

    /**
     * @type {!Object<string, import("../canvas.js").FillState>}
     */
    this.fillStates = {};

    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */
    this.textStrokeState_ = null;

    /**
     * @type {!Object<string, import("../canvas.js").StrokeState>}
     */
    this.strokeStates = {};

    /**
     * @private
     * @type {import("../canvas.js").TextState}
     */
    this.textState_ = /** @type {import("../canvas.js").TextState} */ ({});

    /**
     * @type {!Object<string, import("../canvas.js").TextState>}
     */
    this.textStates = {};

    /**
     * @private
     * @type {string}
     */
    this.textKey_ = '';

    /**
     * @private
     * @type {string}
     */
    this.fillKey_ = '';

    /**
     * @private
     * @type {string}
     */
    this.strokeKey_ = '';

    /**
     * @private
     * @type {Object<string, Object<string, number>>}
     */
    this.widths_ = {};

    _canvas_js__WEBPACK_IMPORTED_MODULE_7__["labelCache"].prune();

  }

  if ( CanvasReplay ) CanvasTextReplay.__proto__ = CanvasReplay;
  CanvasTextReplay.prototype = Object.create( CanvasReplay && CanvasReplay.prototype );
  CanvasTextReplay.prototype.constructor = CanvasTextReplay;

  /**
   * @inheritDoc
   */
  CanvasTextReplay.prototype.drawText = function drawText (geometry, feature) {
    var fillState = this.textFillState_;
    var strokeState = this.textStrokeState_;
    var textState = this.textState_;
    if (this.text_ === '' || !textState || (!fillState && !strokeState)) {
      return;
    }

    var begin = this.coordinates.length;

    var geometryType = geometry.getType();
    var flatCoordinates = null;
    var end = 2;
    var stride = 2;
    var i, ii;

    if (textState.placement === _style_TextPlacement_js__WEBPACK_IMPORTED_MODULE_11__["default"].LINE) {
      if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__["intersects"])(this.getBufferedMaxExtent(), geometry.getExtent())) {
        return;
      }
      var ends;
      flatCoordinates = geometry.getFlatCoordinates();
      stride = geometry.getStride();
      if (geometryType == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].LINE_STRING) {
        ends = [flatCoordinates.length];
      } else if (geometryType == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].MULTI_LINE_STRING) {
        ends = geometry.getEnds();
      } else if (geometryType == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POLYGON) {
        ends = geometry.getEnds().slice(0, 1);
      } else if (geometryType == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].MULTI_POLYGON) {
        var endss = geometry.getEndss();
        ends = [];
        for (i = 0, ii = endss.length; i < ii; ++i) {
          ends.push(endss[i][0]);
        }
      }
      this.beginGeometry(geometry, feature);
      var textAlign = textState.textAlign;
      var flatOffset = 0;
      var flatEnd;
      for (var o = 0, oo = ends.length; o < oo; ++o) {
        if (textAlign == undefined) {
          var range = Object(_geom_flat_straightchunk_js__WEBPACK_IMPORTED_MODULE_4__["matchingChunk"])(textState.maxAngle, flatCoordinates, flatOffset, ends[o], stride);
          flatOffset = range[0];
          flatEnd = range[1];
        } else {
          flatEnd = ends[o];
        }
        for (i = flatOffset; i < flatEnd; i += stride) {
          this.coordinates.push(flatCoordinates[i], flatCoordinates[i + 1]);
        }
        end = this.coordinates.length;
        flatOffset = ends[o];
        this.drawChars_(begin, end, this.declutterGroup_);
        begin = end;
      }
      this.endGeometry(geometry, feature);

    } else {
      var label = this.getImage(this.text_, this.textKey_, this.fillKey_, this.strokeKey_);
      var width = label.width / this.pixelRatio;
      switch (geometryType) {
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POINT:
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].MULTI_POINT:
          flatCoordinates = geometry.getFlatCoordinates();
          end = flatCoordinates.length;
          break;
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].LINE_STRING:
          flatCoordinates = /** @type {import("../../geom/LineString.js").default} */ (geometry).getFlatMidpoint();
          break;
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].CIRCLE:
          flatCoordinates = /** @type {import("../../geom/Circle.js").default} */ (geometry).getCenter();
          break;
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].MULTI_LINE_STRING:
          flatCoordinates = /** @type {import("../../geom/MultiLineString.js").default} */ (geometry).getFlatMidpoints();
          end = flatCoordinates.length;
          break;
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POLYGON:
          flatCoordinates = /** @type {import("../../geom/Polygon.js").default} */ (geometry).getFlatInteriorPoint();
          if (!textState.overflow && flatCoordinates[2] / this.resolution < width) {
            return;
          }
          stride = 3;
          break;
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].MULTI_POLYGON:
          var interiorPoints = /** @type {import("../../geom/MultiPolygon.js").default} */ (geometry).getFlatInteriorPoints();
          flatCoordinates = [];
          for (i = 0, ii = interiorPoints.length; i < ii; i += 3) {
            if (textState.overflow || interiorPoints[i + 2] / this.resolution >= width) {
              flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);
            }
          }
          end = flatCoordinates.length;
          if (end == 0) {
            return;
          }
          break;
        default:
      }
      end = this.appendFlatCoordinates(flatCoordinates, 0, end, stride, false, false);
      if (textState.backgroundFill || textState.backgroundStroke) {
        this.setFillStrokeStyle(textState.backgroundFill, textState.backgroundStroke);
        if (textState.backgroundFill) {
          this.updateFillStyle(this.state, this.createFill, geometry);
          this.hitDetectionInstructions.push(this.createFill(this.state, geometry));
        }
        if (textState.backgroundStroke) {
          this.updateStrokeStyle(this.state, this.applyStroke);
          this.hitDetectionInstructions.push(this.createStroke(this.state));
        }
      }
      this.beginGeometry(geometry, feature);
      this.drawTextImage_(label, begin, end);
      this.endGeometry(geometry, feature);
    }
  };

  /**
   * @param {string} text Text.
   * @param {string} textKey Text style key.
   * @param {string} fillKey Fill style key.
   * @param {string} strokeKey Stroke style key.
   * @return {HTMLCanvasElement} Image.
   */
  CanvasTextReplay.prototype.getImage = function getImage (text, textKey, fillKey, strokeKey) {
    var label;
    var key = strokeKey + textKey + text + fillKey + this.pixelRatio;

    if (!_canvas_js__WEBPACK_IMPORTED_MODULE_7__["labelCache"].containsKey(key)) {
      var strokeState = strokeKey ? this.strokeStates[strokeKey] || this.textStrokeState_ : null;
      var fillState = fillKey ? this.fillStates[fillKey] || this.textFillState_ : null;
      var textState = this.textStates[textKey] || this.textState_;
      var pixelRatio = this.pixelRatio;
      var scale = textState.scale * pixelRatio;
      var align = _replay_js__WEBPACK_IMPORTED_MODULE_10__["TEXT_ALIGN"][textState.textAlign || _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultTextAlign"]];
      var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;

      var lines = text.split('\n');
      var numLines = lines.length;
      var widths = [];
      var width = measureTextWidths(textState.font, lines, widths);
      var lineHeight = Object(_canvas_js__WEBPACK_IMPORTED_MODULE_7__["measureTextHeight"])(textState.font);
      var height = lineHeight * numLines;
      var renderWidth = (width + strokeWidth);
      var context = Object(_dom_js__WEBPACK_IMPORTED_MODULE_2__["createCanvasContext2D"])(
        Math.ceil(renderWidth * scale),
        Math.ceil((height + strokeWidth) * scale));
      label = context.canvas;
      _canvas_js__WEBPACK_IMPORTED_MODULE_7__["labelCache"].set(key, label);
      if (scale != 1) {
        context.scale(scale, scale);
      }
      context.font = textState.font;
      if (strokeKey) {
        context.strokeStyle = strokeState.strokeStyle;
        context.lineWidth = strokeWidth;
        context.lineCap = /** @type {CanvasLineCap} */ (strokeState.lineCap);
        context.lineJoin = /** @type {CanvasLineJoin} */ (strokeState.lineJoin);
        context.miterLimit = strokeState.miterLimit;
        if (_has_js__WEBPACK_IMPORTED_MODULE_6__["CANVAS_LINE_DASH"] && strokeState.lineDash.length) {
          context.setLineDash(strokeState.lineDash);
          context.lineDashOffset = strokeState.lineDashOffset;
        }
      }
      if (fillKey) {
        context.fillStyle = fillState.fillStyle;
      }
      context.textBaseline = 'middle';
      context.textAlign = 'center';
      var leftRight = (0.5 - align);
      var x = align * label.width / scale + leftRight * strokeWidth;
      var i;
      if (strokeKey) {
        for (i = 0; i < numLines; ++i) {
          context.strokeText(lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight);
        }
      }
      if (fillKey) {
        for (i = 0; i < numLines; ++i) {
          context.fillText(lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight);
        }
      }
    }
    return _canvas_js__WEBPACK_IMPORTED_MODULE_7__["labelCache"].get(key);
  };

  /**
   * @private
   * @param {HTMLCanvasElement} label Label.
   * @param {number} begin Begin.
   * @param {number} end End.
   */
  CanvasTextReplay.prototype.drawTextImage_ = function drawTextImage_ (label, begin, end) {
    var textState = this.textState_;
    var strokeState = this.textStrokeState_;
    var pixelRatio = this.pixelRatio;
    var align = _replay_js__WEBPACK_IMPORTED_MODULE_10__["TEXT_ALIGN"][textState.textAlign || _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultTextAlign"]];
    var baseline = _replay_js__WEBPACK_IMPORTED_MODULE_10__["TEXT_ALIGN"][textState.textBaseline];
    var strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;

    var anchorX = align * label.width / pixelRatio + 2 * (0.5 - align) * strokeWidth;
    var anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;
    this.instructions.push([_Instruction_js__WEBPACK_IMPORTED_MODULE_8__["default"].DRAW_IMAGE, begin, end,
      label, (anchorX - this.textOffsetX_) * pixelRatio, (anchorY - this.textOffsetY_) * pixelRatio,
      this.declutterGroup_, label.height, 1, 0, 0, this.textRotateWithView_, this.textRotation_,
      1, label.width,
      textState.padding == _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultPadding"] ?
        _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultPadding"] : textState.padding.map(function(p) {
          return p * pixelRatio;
        }),
      !!textState.backgroundFill, !!textState.backgroundStroke
    ]);
    this.hitDetectionInstructions.push([_Instruction_js__WEBPACK_IMPORTED_MODULE_8__["default"].DRAW_IMAGE, begin, end,
      label, (anchorX - this.textOffsetX_) * pixelRatio, (anchorY - this.textOffsetY_) * pixelRatio,
      this.declutterGroup_, label.height, 1, 0, 0, this.textRotateWithView_, this.textRotation_,
      1 / pixelRatio, label.width, textState.padding,
      !!textState.backgroundFill, !!textState.backgroundStroke
    ]);
  };

  /**
   * @private
   * @param {number} begin Begin.
   * @param {number} end End.
   * @param {import("../canvas.js").DeclutterGroup} declutterGroup Declutter group.
   */
  CanvasTextReplay.prototype.drawChars_ = function drawChars_ (begin, end, declutterGroup) {
    var strokeState = this.textStrokeState_;
    var textState = this.textState_;
    var fillState = this.textFillState_;

    var strokeKey = this.strokeKey_;
    if (strokeState) {
      if (!(strokeKey in this.strokeStates)) {
        this.strokeStates[strokeKey] = /** @type {import("../canvas.js").StrokeState} */ ({
          strokeStyle: strokeState.strokeStyle,
          lineCap: strokeState.lineCap,
          lineDashOffset: strokeState.lineDashOffset,
          lineWidth: strokeState.lineWidth,
          lineJoin: strokeState.lineJoin,
          miterLimit: strokeState.miterLimit,
          lineDash: strokeState.lineDash
        });
      }
    }
    var textKey = this.textKey_;
    if (!(this.textKey_ in this.textStates)) {
      this.textStates[this.textKey_] = /** @type {import("../canvas.js").TextState} */ ({
        font: textState.font,
        textAlign: textState.textAlign || _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultTextAlign"],
        scale: textState.scale
      });
    }
    var fillKey = this.fillKey_;
    if (fillState) {
      if (!(fillKey in this.fillStates)) {
        this.fillStates[fillKey] = /** @type {import("../canvas.js").FillState} */ ({
          fillStyle: fillState.fillStyle
        });
      }
    }

    var pixelRatio = this.pixelRatio;
    var baseline = _replay_js__WEBPACK_IMPORTED_MODULE_10__["TEXT_ALIGN"][textState.textBaseline];

    var offsetY = this.textOffsetY_ * pixelRatio;
    var text = this.text_;
    var font = textState.font;
    var textScale = textState.scale;
    var strokeWidth = strokeState ? strokeState.lineWidth * textScale / 2 : 0;
    var widths = this.widths_[font];
    if (!widths) {
      this.widths_[font] = widths = {};
    }
    this.instructions.push([_Instruction_js__WEBPACK_IMPORTED_MODULE_8__["default"].DRAW_CHARS,
      begin, end, baseline, declutterGroup,
      textState.overflow, fillKey, textState.maxAngle,
      function(text) {
        var width = widths[text];
        if (!width) {
          width = widths[text] = Object(_canvas_js__WEBPACK_IMPORTED_MODULE_7__["measureTextWidth"])(font, text);
        }
        return width * textScale * pixelRatio;
      },
      offsetY, strokeKey, strokeWidth * pixelRatio, text, textKey, 1
    ]);
    this.hitDetectionInstructions.push([_Instruction_js__WEBPACK_IMPORTED_MODULE_8__["default"].DRAW_CHARS,
      begin, end, baseline, declutterGroup,
      textState.overflow, fillKey, textState.maxAngle,
      function(text) {
        var width = widths[text];
        if (!width) {
          width = widths[text] = Object(_canvas_js__WEBPACK_IMPORTED_MODULE_7__["measureTextWidth"])(font, text);
        }
        return width * textScale;
      },
      offsetY, strokeKey, strokeWidth, text, textKey, 1 / pixelRatio
    ]);
  };

  /**
   * @inheritDoc
   */
  CanvasTextReplay.prototype.setTextStyle = function setTextStyle (textStyle, declutterGroup) {
    var textState, fillState, strokeState;
    if (!textStyle) {
      this.text_ = '';
    } else {
      this.declutterGroup_ = /** @type {import("../canvas.js").DeclutterGroup} */ (declutterGroup);

      var textFillStyle = textStyle.getFill();
      if (!textFillStyle) {
        fillState = this.textFillState_ = null;
      } else {
        fillState = this.textFillState_;
        if (!fillState) {
          fillState = this.textFillState_ = /** @type {import("../canvas.js").FillState} */ ({});
        }
        fillState.fillStyle = Object(_colorlike_js__WEBPACK_IMPORTED_MODULE_1__["asColorLike"])(
          textFillStyle.getColor() || _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultFillStyle"]);
      }

      var textStrokeStyle = textStyle.getStroke();
      if (!textStrokeStyle) {
        strokeState = this.textStrokeState_ = null;
      } else {
        strokeState = this.textStrokeState_;
        if (!strokeState) {
          strokeState = this.textStrokeState_ = /** @type {import("../canvas.js").StrokeState} */ ({});
        }
        var lineDash = textStrokeStyle.getLineDash();
        var lineDashOffset = textStrokeStyle.getLineDashOffset();
        var lineWidth = textStrokeStyle.getWidth();
        var miterLimit = textStrokeStyle.getMiterLimit();
        strokeState.lineCap = textStrokeStyle.getLineCap() || _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultLineCap"];
        strokeState.lineDash = lineDash ? lineDash.slice() : _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultLineDash"];
        strokeState.lineDashOffset =
            lineDashOffset === undefined ? _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultLineDashOffset"] : lineDashOffset;
        strokeState.lineJoin = textStrokeStyle.getLineJoin() || _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultLineJoin"];
        strokeState.lineWidth =
            lineWidth === undefined ? _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultLineWidth"] : lineWidth;
        strokeState.miterLimit =
            miterLimit === undefined ? _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultMiterLimit"] : miterLimit;
        strokeState.strokeStyle = Object(_colorlike_js__WEBPACK_IMPORTED_MODULE_1__["asColorLike"])(
          textStrokeStyle.getColor() || _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultStrokeStyle"]);
      }

      textState = this.textState_;
      var font = textStyle.getFont() || _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultFont"];
      Object(_canvas_js__WEBPACK_IMPORTED_MODULE_7__["checkFont"])(font);
      var textScale = textStyle.getScale();
      textState.overflow = textStyle.getOverflow();
      textState.font = font;
      textState.maxAngle = textStyle.getMaxAngle();
      textState.placement = textStyle.getPlacement();
      textState.textAlign = textStyle.getTextAlign();
      textState.textBaseline = textStyle.getTextBaseline() || _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultTextBaseline"];
      textState.backgroundFill = textStyle.getBackgroundFill();
      textState.backgroundStroke = textStyle.getBackgroundStroke();
      textState.padding = textStyle.getPadding() || _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultPadding"];
      textState.scale = textScale === undefined ? 1 : textScale;

      var textOffsetX = textStyle.getOffsetX();
      var textOffsetY = textStyle.getOffsetY();
      var textRotateWithView = textStyle.getRotateWithView();
      var textRotation = textStyle.getRotation();
      this.text_ = textStyle.getText() || '';
      this.textOffsetX_ = textOffsetX === undefined ? 0 : textOffsetX;
      this.textOffsetY_ = textOffsetY === undefined ? 0 : textOffsetY;
      this.textRotateWithView_ = textRotateWithView === undefined ? false : textRotateWithView;
      this.textRotation_ = textRotation === undefined ? 0 : textRotation;

      this.strokeKey_ = strokeState ?
        (typeof strokeState.strokeStyle == 'string' ? strokeState.strokeStyle : Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(strokeState.strokeStyle)) +
        strokeState.lineCap + strokeState.lineDashOffset + '|' + strokeState.lineWidth +
        strokeState.lineJoin + strokeState.miterLimit + '[' + strokeState.lineDash.join() + ']' :
        '';
      this.textKey_ = textState.font + textState.scale + (textState.textAlign || '?');
      this.fillKey_ = fillState ?
        (typeof fillState.fillStyle == 'string' ? fillState.fillStyle : ('|' + Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(fillState.fillStyle))) :
        '';
    }
  };

  return CanvasTextReplay;
}(_Replay_js__WEBPACK_IMPORTED_MODULE_9__["default"]));


/**
 * @param {string} font Font to use for measuring.
 * @param {Array<string>} lines Lines to measure.
 * @param {Array<number>} widths Array will be populated with the widths of
 * each line.
 * @return {number} Width of the whole text.
 */
function measureTextWidths(font, lines, widths) {
  var numLines = lines.length;
  var width = 0;
  for (var i = 0; i < numLines; ++i) {
    var currentWidth = Object(_canvas_js__WEBPACK_IMPORTED_MODULE_7__["measureTextWidth"])(font, lines[i]);
    width = Math.max(width, currentWidth);
    widths.push(currentWidth);
  }
  return width;
}


/* harmony default export */ __webpack_exports__["default"] = (CanvasTextReplay);

//# sourceMappingURL=TextReplay.js.map

/***/ }),

/***/ "./node_modules/ol/render/replay.js":
/*!******************************************!*\
  !*** ./node_modules/ol/render/replay.js ***!
  \******************************************/
/*! exports provided: ORDER, TEXT_ALIGN */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ORDER", function() { return ORDER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXT_ALIGN", function() { return TEXT_ALIGN; });
/* harmony import */ var _ReplayType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ReplayType.js */ "./node_modules/ol/render/ReplayType.js");
/**
 * @module ol/render/replay
 */



/**
 * @const
 * @type {Array<ReplayType>}
 */
var ORDER = [
  _ReplayType_js__WEBPACK_IMPORTED_MODULE_0__["default"].POLYGON,
  _ReplayType_js__WEBPACK_IMPORTED_MODULE_0__["default"].CIRCLE,
  _ReplayType_js__WEBPACK_IMPORTED_MODULE_0__["default"].LINE_STRING,
  _ReplayType_js__WEBPACK_IMPORTED_MODULE_0__["default"].IMAGE,
  _ReplayType_js__WEBPACK_IMPORTED_MODULE_0__["default"].TEXT,
  _ReplayType_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEFAULT
];

/**
 * @const
 * @enum {number}
 */
var TEXT_ALIGN = {};
TEXT_ALIGN['left'] = 0;
TEXT_ALIGN['end'] = 0;
TEXT_ALIGN['center'] = 0.5;
TEXT_ALIGN['right'] = 1;
TEXT_ALIGN['start'] = 1;
TEXT_ALIGN['top'] = 0;
TEXT_ALIGN['middle'] = 0.5;
TEXT_ALIGN['hanging'] = 0.2;
TEXT_ALIGN['alphabetic'] = 0.8;
TEXT_ALIGN['ideographic'] = 0.8;
TEXT_ALIGN['bottom'] = 1;

//# sourceMappingURL=replay.js.map

/***/ }),

/***/ "./node_modules/ol/renderer/Layer.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/renderer/Layer.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ImageState.js */ "./node_modules/ol/ImageState.js");
/* harmony import */ var _Observable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Observable.js */ "./node_modules/ol/Observable.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _source_State_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../source/State.js */ "./node_modules/ol/source/State.js");
/**
 * @module ol/renderer/Layer
 */








var LayerRenderer = /*@__PURE__*/(function (Observable) {
  function LayerRenderer(layer) {

    Observable.call(this);

    /**
     * @private
     * @type {import("../layer/Layer.js").default}
     */
    this.layer_ = layer;

  }

  if ( Observable ) LayerRenderer.__proto__ = Observable;
  LayerRenderer.prototype = Object.create( Observable && Observable.prototype );
  LayerRenderer.prototype.constructor = LayerRenderer;

  /**
   * Create a function that adds loaded tiles to the tile lookup.
   * @param {import("../source/Tile.js").default} source Tile source.
   * @param {import("../proj/Projection.js").default} projection Projection of the tiles.
   * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @return {function(number, import("../TileRange.js").default):boolean} A function that can be
   *     called with a zoom level and a tile range to add loaded tiles to the lookup.
   * @protected
   */
  LayerRenderer.prototype.createLoadedTileFinder = function createLoadedTileFinder (source, projection, tiles) {
    return (
      /**
       * @param {number} zoom Zoom level.
       * @param {import("../TileRange.js").default} tileRange Tile range.
       * @return {boolean} The tile range is fully loaded.
       */
      function(zoom, tileRange) {
        /**
         * @param {import("../Tile.js").default} tile Tile.
         */
        function callback(tile) {
          if (!tiles[zoom]) {
            tiles[zoom] = {};
          }
          tiles[zoom][tile.tileCoord.toString()] = tile;
        }
        return source.forEachLoadedTile(projection, zoom, tileRange, callback);
      }
    );
  };

  /**
   * @abstract
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(import("../Feature.js").FeatureLike, import("../layer/Layer.js").default): T} callback Feature callback.
   * @return {T|void} Callback result.
   * @template T
   */
  LayerRenderer.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate (coordinate, frameState, hitTolerance, callback) {};

  /**
   * @return {import("../layer/Layer.js").default} Layer.
   */
  LayerRenderer.prototype.getLayer = function getLayer () {
    return this.layer_;
  };

  /**
   * Handle changes in image state.
   * @param {import("../events/Event.js").default} event Image change event.
   * @private
   */
  LayerRenderer.prototype.handleImageChange_ = function handleImageChange_ (event) {
    var image = /** @type {import("../Image.js").default} */ (event.target);
    if (image.getState() === _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED) {
      this.renderIfReadyAndVisible();
    }
  };

  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @return {boolean} Is there a feature at the given coordinate?
   */
  LayerRenderer.prototype.hasFeatureAtCoordinate = function hasFeatureAtCoordinate (coordinate, frameState) {
    return false;
  };

  /**
   * Load the image if not already loaded, and register the image change
   * listener if needed.
   * @param {import("../ImageBase.js").default} image Image.
   * @return {boolean} `true` if the image is already loaded, `false` otherwise.
   * @protected
   */
  LayerRenderer.prototype.loadImage = function loadImage (image) {
    var imageState = image.getState();
    if (imageState != _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED && imageState != _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_4__["listen"])(image, _events_EventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].CHANGE, this.handleImageChange_, this);
    }
    if (imageState == _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE) {
      image.load();
      imageState = image.getState();
    }
    return imageState == _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED;
  };

  /**
   * @protected
   */
  LayerRenderer.prototype.renderIfReadyAndVisible = function renderIfReadyAndVisible () {
    var layer = this.getLayer();
    if (layer.getVisible() && layer.getSourceState() == _source_State_js__WEBPACK_IMPORTED_MODULE_6__["default"].READY) {
      this.changed();
    }
  };

  /**
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../source/Tile.js").default} tileSource Tile source.
   * @protected
   */
  LayerRenderer.prototype.scheduleExpireCache = function scheduleExpireCache (frameState, tileSource) {
    if (tileSource.canExpireCache()) {
      /**
       * @param {import("../source/Tile.js").default} tileSource Tile source.
       * @param {import("../PluggableMap.js").default} map Map.
       * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
       */
      var postRenderFunction = function(tileSource, map, frameState) {
        var tileSourceKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(tileSource);
        if (tileSourceKey in frameState.usedTiles) {
          tileSource.expireCache(frameState.viewState.projection,
            frameState.usedTiles[tileSourceKey]);
        }
      }.bind(null, tileSource);

      frameState.postRenderFunctions.push(
        /** @type {import("../PluggableMap.js").PostRenderFunction} */ (postRenderFunction)
      );
    }
  };

  /**
   * @param {!Object<string, !Object<string, import("../TileRange.js").default>>} usedTiles Used tiles.
   * @param {import("../source/Tile.js").default} tileSource Tile source.
   * @param {number} z Z.
   * @param {import("../TileRange.js").default} tileRange Tile range.
   * @protected
   */
  LayerRenderer.prototype.updateUsedTiles = function updateUsedTiles (usedTiles, tileSource, z, tileRange) {
    // FIXME should we use tilesToDrawByZ instead?
    var tileSourceKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(tileSource);
    var zKey = z.toString();
    if (tileSourceKey in usedTiles) {
      if (zKey in usedTiles[tileSourceKey]) {
        usedTiles[tileSourceKey][zKey].extend(tileRange);
      } else {
        usedTiles[tileSourceKey][zKey] = tileRange;
      }
    } else {
      usedTiles[tileSourceKey] = {};
      usedTiles[tileSourceKey][zKey] = tileRange;
    }
  };

  /**
   * Manage tile pyramid.
   * This function performs a number of functions related to the tiles at the
   * current zoom and lower zoom levels:
   * - registers idle tiles in frameState.wantedTiles so that they are not
   *   discarded by the tile queue
   * - enqueues missing tiles
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../source/Tile.js").default} tileSource Tile source.
   * @param {import("../tilegrid/TileGrid.js").default} tileGrid Tile grid.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} currentZ Current Z.
   * @param {number} preload Load low resolution tiles up to 'preload' levels.
   * @param {function(this: T, import("../Tile.js").default)=} opt_tileCallback Tile callback.
   * @param {T=} opt_this Object to use as `this` in `opt_tileCallback`.
   * @protected
   * @template T
   */
  LayerRenderer.prototype.manageTilePyramid = function manageTilePyramid (
    frameState,
    tileSource,
    tileGrid,
    pixelRatio,
    projection,
    extent,
    currentZ,
    preload,
    opt_tileCallback,
    opt_this
  ) {
    var tileSourceKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(tileSource);
    if (!(tileSourceKey in frameState.wantedTiles)) {
      frameState.wantedTiles[tileSourceKey] = {};
    }
    var wantedTiles = frameState.wantedTiles[tileSourceKey];
    var tileQueue = frameState.tileQueue;
    var minZoom = tileGrid.getMinZoom();
    var tile, tileRange, tileResolution, x, y, z;
    for (z = minZoom; z <= currentZ; ++z) {
      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);
      tileResolution = tileGrid.getResolution(z);
      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {
          if (currentZ - z <= preload) {
            tile = tileSource.getTile(z, x, y, pixelRatio, projection);
            if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_3__["default"].IDLE) {
              wantedTiles[tile.getKey()] = true;
              if (!tileQueue.isKeyQueued(tile.getKey())) {
                tileQueue.enqueue([tile, tileSourceKey,
                  tileGrid.getTileCoordCenter(tile.tileCoord), tileResolution]);
              }
            }
            if (opt_tileCallback !== undefined) {
              opt_tileCallback.call(opt_this, tile);
            }
          } else {
            tileSource.useTile(z, x, y, projection);
          }
        }
      }
    }
  };

  return LayerRenderer;
}(_Observable_js__WEBPACK_IMPORTED_MODULE_2__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (LayerRenderer);

//# sourceMappingURL=Layer.js.map

/***/ }),

/***/ "./node_modules/ol/renderer/Map.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/renderer/Map.js ***!
  \*****************************************/
/*! exports provided: sortByZIndex, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sortByZIndex", function() { return sortByZIndex; });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _Disposable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Disposable.js */ "./node_modules/ol/Disposable.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _layer_Layer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../layer/Layer.js */ "./node_modules/ol/layer/Layer.js");
/* harmony import */ var _style_IconImageCache_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../style/IconImageCache.js */ "./node_modules/ol/style/IconImageCache.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/renderer/Map
 */










/**
 * @abstract
 */
var MapRenderer = /*@__PURE__*/(function (Disposable) {
  function MapRenderer(map) {
    Disposable.call(this);

    /**
     * @private
     * @type {import("../PluggableMap.js").default}
     */
    this.map_ = map;

    /**
     * @private
     * @type {!Object<string, import("./Layer.js").default>}
     */
    this.layerRenderers_ = {};

    /**
     * @private
     * @type {Object<string, import("../events.js").EventsKey>}
     */
    this.layerRendererListeners_ = {};

    /**
     * @private
     * @type {Array<typeof import("./Layer.js").default>}
     */
    this.layerRendererConstructors_ = [];

  }

  if ( Disposable ) MapRenderer.__proto__ = Disposable;
  MapRenderer.prototype = Object.create( Disposable && Disposable.prototype );
  MapRenderer.prototype.constructor = MapRenderer;

  /**
   * @abstract
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   */
  MapRenderer.prototype.dispatchRenderEvent = function dispatchRenderEvent (type, frameState) {
    Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Register layer renderer constructors.
   * @param {Array<typeof import("./Layer.js").default>} constructors Layer renderers.
   */
  MapRenderer.prototype.registerLayerRenderers = function registerLayerRenderers (constructors) {
    this.layerRendererConstructors_.push.apply(this.layerRendererConstructors_, constructors);
  };

  /**
   * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
   * @protected
   */
  MapRenderer.prototype.calculateMatrices2D = function calculateMatrices2D (frameState) {
    var viewState = frameState.viewState;
    var coordinateToPixelTransform = frameState.coordinateToPixelTransform;
    var pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;

    Object(_transform_js__WEBPACK_IMPORTED_MODULE_8__["compose"])(coordinateToPixelTransform,
      frameState.size[0] / 2, frameState.size[1] / 2,
      1 / viewState.resolution, -1 / viewState.resolution,
      -viewState.rotation,
      -viewState.center[0], -viewState.center[1]);

    Object(_transform_js__WEBPACK_IMPORTED_MODULE_8__["invert"])(
      Object(_transform_js__WEBPACK_IMPORTED_MODULE_8__["setFromArray"])(pixelToCoordinateTransform, coordinateToPixelTransform));
  };

  /**
   * Removes all layer renderers.
   */
  MapRenderer.prototype.removeLayerRenderers = function removeLayerRenderers () {
    for (var key in this.layerRenderers_) {
      this.removeLayerRendererByKey_(key).dispose();
    }
  };

  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(this: S, import("../Feature.js").FeatureLike,
   *     import("../layer/Layer.js").default): T} callback Feature callback.
   * @param {S} thisArg Value to use as `this` when executing `callback`.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
   * @return {T|undefined} Callback result.
   * @template S,T,U
   */
  MapRenderer.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate (
    coordinate,
    frameState,
    hitTolerance,
    callback,
    thisArg,
    layerFilter,
    thisArg2
  ) {
    var result;
    var viewState = frameState.viewState;
    var viewResolution = viewState.resolution;

    /**
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {import("../layer/Layer.js").default} layer Layer.
     * @return {?} Callback result.
     */
    function forEachFeatureAtCoordinate(feature, layer) {
      var managed = frameState.layerStates[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(layer)].managed;
      if (!(Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature) in frameState.skippedFeatureUids && !managed)) {
        return callback.call(thisArg, feature, managed ? layer : null);
      }
    }

    var projection = viewState.projection;

    var translatedCoordinate = coordinate;
    if (projection.canWrapX()) {
      var projectionExtent = projection.getExtent();
      var worldWidth = Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["getWidth"])(projectionExtent);
      var x = coordinate[0];
      if (x < projectionExtent[0] || x > projectionExtent[2]) {
        var worldsAway = Math.ceil((projectionExtent[0] - x) / worldWidth);
        translatedCoordinate = [x + worldWidth * worldsAway, coordinate[1]];
      }
    }

    var layerStates = frameState.layerStatesArray;
    var numLayers = layerStates.length;
    var i;
    for (i = numLayers - 1; i >= 0; --i) {
      var layerState = layerStates[i];
      var layer = layerState.layer;
      if (Object(_layer_Layer_js__WEBPACK_IMPORTED_MODULE_6__["visibleAtResolution"])(layerState, viewResolution) && layerFilter.call(thisArg2, layer)) {
        var layerRenderer = this.getLayerRenderer(layer);
        var source = /** @type {import("../layer/Layer.js").default} */ (layer).getSource();
        if (source) {
          result = layerRenderer.forEachFeatureAtCoordinate(
            source.getWrapX() ? translatedCoordinate : coordinate,
            frameState, hitTolerance, forEachFeatureAtCoordinate);
        }
        if (result) {
          return result;
        }
      }
    }
    return undefined;
  };

  /**
   * @abstract
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(this: S, import("../layer/Layer.js").default, (Uint8ClampedArray|Uint8Array)): T} callback Layer
   *     callback.
   * @param {S} thisArg Value to use as `this` when executing `callback`.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
   * @return {T|undefined} Callback result.
   * @template S,T,U
   */
  MapRenderer.prototype.forEachLayerAtPixel = function forEachLayerAtPixel (pixel, frameState, hitTolerance, callback, thisArg, layerFilter, thisArg2) {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
   * @return {boolean} Is there a feature at the given coordinate?
   * @template U
   */
  MapRenderer.prototype.hasFeatureAtCoordinate = function hasFeatureAtCoordinate (coordinate, frameState, hitTolerance, layerFilter, thisArg) {
    var hasFeature = this.forEachFeatureAtCoordinate(
      coordinate, frameState, hitTolerance, _functions_js__WEBPACK_IMPORTED_MODULE_5__["TRUE"], this, layerFilter, thisArg);

    return hasFeature !== undefined;
  };

  /**
   * @param {import("../layer/Base.js").default} layer Layer.
   * @protected
   * @return {import("./Layer.js").default} Layer renderer.
   */
  MapRenderer.prototype.getLayerRenderer = function getLayerRenderer (layer) {
    var layerKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(layer);
    if (layerKey in this.layerRenderers_) {
      return this.layerRenderers_[layerKey];
    } else {
      var renderer;
      for (var i = 0, ii = this.layerRendererConstructors_.length; i < ii; ++i) {
        var candidate = this.layerRendererConstructors_[i];
        if (candidate['handles'](layer)) {
          renderer = candidate['create'](this, layer);
          break;
        }
      }
      if (renderer) {
        this.layerRenderers_[layerKey] = renderer;
        this.layerRendererListeners_[layerKey] = Object(_events_js__WEBPACK_IMPORTED_MODULE_2__["listen"])(renderer,
          _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].CHANGE, this.handleLayerRendererChange_, this);
      } else {
        throw new Error('Unable to create renderer for layer: ' + layer.getType());
      }
      return renderer;
    }
  };

  /**
   * @param {string} layerKey Layer key.
   * @protected
   * @return {import("./Layer.js").default} Layer renderer.
   */
  MapRenderer.prototype.getLayerRendererByKey = function getLayerRendererByKey (layerKey) {
    return this.layerRenderers_[layerKey];
  };

  /**
   * @protected
   * @return {Object<string, import("./Layer.js").default>} Layer renderers.
   */
  MapRenderer.prototype.getLayerRenderers = function getLayerRenderers () {
    return this.layerRenderers_;
  };

  /**
   * @return {import("../PluggableMap.js").default} Map.
   */
  MapRenderer.prototype.getMap = function getMap () {
    return this.map_;
  };

  /**
   * Handle changes in a layer renderer.
   * @private
   */
  MapRenderer.prototype.handleLayerRendererChange_ = function handleLayerRendererChange_ () {
    this.map_.render();
  };

  /**
   * @param {string} layerKey Layer key.
   * @return {import("./Layer.js").default} Layer renderer.
   * @private
   */
  MapRenderer.prototype.removeLayerRendererByKey_ = function removeLayerRendererByKey_ (layerKey) {
    var layerRenderer = this.layerRenderers_[layerKey];
    delete this.layerRenderers_[layerKey];

    Object(_events_js__WEBPACK_IMPORTED_MODULE_2__["unlistenByKey"])(this.layerRendererListeners_[layerKey]);
    delete this.layerRendererListeners_[layerKey];

    return layerRenderer;
  };

  /**
   * @param {import("../PluggableMap.js").default} map Map.
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @private
   */
  MapRenderer.prototype.removeUnusedLayerRenderers_ = function removeUnusedLayerRenderers_ (map, frameState) {
    for (var layerKey in this.layerRenderers_) {
      if (!frameState || !(layerKey in frameState.layerStates)) {
        this.removeLayerRendererByKey_(layerKey).dispose();
      }
    }
  };

  /**
   * Render.
   * @abstract
   * @param {?import("../PluggableMap.js").FrameState} frameState Frame state.
   */
  MapRenderer.prototype.renderFrame = function renderFrame (frameState) {
    Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @protected
   */
  MapRenderer.prototype.scheduleExpireIconCache = function scheduleExpireIconCache (frameState) {
    frameState.postRenderFunctions.push(/** @type {import("../PluggableMap.js").PostRenderFunction} */ (expireIconCache));
  };

  /**
   * @param {!import("../PluggableMap.js").FrameState} frameState Frame state.
   * @protected
   */
  MapRenderer.prototype.scheduleRemoveUnusedLayerRenderers = function scheduleRemoveUnusedLayerRenderers (frameState) {
    for (var layerKey in this.layerRenderers_) {
      if (!(layerKey in frameState.layerStates)) {
        frameState.postRenderFunctions.push(
          /** @type {import("../PluggableMap.js").PostRenderFunction} */ (this.removeUnusedLayerRenderers_.bind(this))
        );
        return;
      }
    }
  };

  return MapRenderer;
}(_Disposable_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/**
 * @param {import("../PluggableMap.js").default} map Map.
 * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
 */
function expireIconCache(map, frameState) {
  _style_IconImageCache_js__WEBPACK_IMPORTED_MODULE_7__["shared"].expire();
}


/**
 * @param {import("../layer/Layer.js").State} state1 First layer state.
 * @param {import("../layer/Layer.js").State} state2 Second layer state.
 * @return {number} The zIndex difference.
 */
function sortByZIndex(state1, state2) {
  return state1.zIndex - state2.zIndex;
}
/* harmony default export */ __webpack_exports__["default"] = (MapRenderer);

//# sourceMappingURL=Map.js.map

/***/ }),

/***/ "./node_modules/ol/renderer/canvas/ImageLayer.js":
/*!*******************************************************!*\
  !*** ./node_modules/ol/renderer/canvas/ImageLayer.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _reproj_common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../reproj/common.js */ "./node_modules/ol/reproj/common.js");
/* harmony import */ var _ImageCanvas_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../ImageCanvas.js */ "./node_modules/ol/ImageCanvas.js");
/* harmony import */ var _LayerType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../LayerType.js */ "./node_modules/ol/LayerType.js");
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../ViewHint.js */ "./node_modules/ol/ViewHint.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _layer_VectorRenderType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../layer/VectorRenderType.js */ "./node_modules/ol/layer/VectorRenderType.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _Map_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Map.js */ "./node_modules/ol/renderer/canvas/Map.js");
/* harmony import */ var _IntermediateCanvas_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./IntermediateCanvas.js */ "./node_modules/ol/renderer/canvas/IntermediateCanvas.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/renderer/canvas/ImageLayer
 */












/**
 * @classdesc
 * Canvas renderer for image layers.
 * @api
 */
var CanvasImageLayerRenderer = /*@__PURE__*/(function (IntermediateCanvasRenderer) {
  function CanvasImageLayerRenderer(imageLayer) {

    IntermediateCanvasRenderer.call(this, imageLayer);

    /**
     * @private
     * @type {?import("../../ImageBase.js").default}
     */
    this.image_ = null;

    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */
    this.imageTransform_ = Object(_transform_js__WEBPACK_IMPORTED_MODULE_10__["create"])();

    /**
     * @type {!Array<string>}
     */
    this.skippedFeatures_ = [];

    /**
     * @private
     * @type {import("./VectorLayer.js").default}
     */
    this.vectorRenderer_ = null;

    if (imageLayer.getType() === _LayerType_js__WEBPACK_IMPORTED_MODULE_2__["default"].VECTOR) {
      for (var i = 0, ii = _Map_js__WEBPACK_IMPORTED_MODULE_8__["layerRendererConstructors"].length; i < ii; ++i) {
        var ctor = _Map_js__WEBPACK_IMPORTED_MODULE_8__["layerRendererConstructors"][i];
        if (ctor !== CanvasImageLayerRenderer && ctor['handles'](imageLayer)) {
          this.vectorRenderer_ = /** @type {import("./VectorLayer.js").default} */ (new ctor(imageLayer));
          break;
        }
      }
    }

  }

  if ( IntermediateCanvasRenderer ) CanvasImageLayerRenderer.__proto__ = IntermediateCanvasRenderer;
  CanvasImageLayerRenderer.prototype = Object.create( IntermediateCanvasRenderer && IntermediateCanvasRenderer.prototype );
  CanvasImageLayerRenderer.prototype.constructor = CanvasImageLayerRenderer;

  /**
   * @inheritDoc
   */
  CanvasImageLayerRenderer.prototype.disposeInternal = function disposeInternal () {
    if (this.vectorRenderer_) {
      this.vectorRenderer_.dispose();
    }
    IntermediateCanvasRenderer.prototype.disposeInternal.call(this);
  };

  /**
   * @inheritDoc
   */
  CanvasImageLayerRenderer.prototype.getImage = function getImage () {
    return !this.image_ ? null : this.image_.getImage();
  };

  /**
   * @inheritDoc
   */
  CanvasImageLayerRenderer.prototype.getImageTransform = function getImageTransform () {
    return this.imageTransform_;
  };

  /**
   * @inheritDoc
   */
  CanvasImageLayerRenderer.prototype.prepareFrame = function prepareFrame (frameState, layerState) {

    var pixelRatio = frameState.pixelRatio;
    var size = frameState.size;
    var viewState = frameState.viewState;
    var viewCenter = viewState.center;
    var viewResolution = viewState.resolution;

    var image;
    var imageLayer = /** @type {import("../../layer/Image.js").default} */ (this.getLayer());
    var imageSource = /** @type {import("../../source/Image.js").default} */ (imageLayer.getSource());

    var hints = frameState.viewHints;

    var vectorRenderer = this.vectorRenderer_;
    var renderedExtent = frameState.extent;
    if (!vectorRenderer && layerState.extent !== undefined) {
      renderedExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getIntersection"])(renderedExtent, layerState.extent);
    }

    if (!hints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_3__["default"].ANIMATING] && !hints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_3__["default"].INTERACTING] &&
        !Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["isEmpty"])(renderedExtent)) {
      var projection = viewState.projection;
      if (!_reproj_common_js__WEBPACK_IMPORTED_MODULE_0__["ENABLE_RASTER_REPROJECTION"]) {
        var sourceProjection = imageSource.getProjection();
        if (sourceProjection) {
          projection = sourceProjection;
        }
      }
      var skippedFeatures = this.skippedFeatures_;
      if (vectorRenderer) {
        var context = vectorRenderer.context;
        var imageFrameState = /** @type {import("../../PluggableMap.js").FrameState} */ (Object(_obj_js__WEBPACK_IMPORTED_MODULE_7__["assign"])({}, frameState, {
          size: [
            Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getWidth"])(renderedExtent) / viewResolution,
            Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getHeight"])(renderedExtent) / viewResolution
          ],
          viewState: /** @type {import("../../View.js").State} */ (Object(_obj_js__WEBPACK_IMPORTED_MODULE_7__["assign"])({}, frameState.viewState, {
            rotation: 0
          }))
        }));
        var newSkippedFeatures = Object.keys(imageFrameState.skippedFeatureUids).sort();
        image = new _ImageCanvas_js__WEBPACK_IMPORTED_MODULE_1__["default"](renderedExtent, viewResolution, pixelRatio, context.canvas, function(callback) {
          if (vectorRenderer.prepareFrame(imageFrameState, layerState) &&
              (vectorRenderer.replayGroupChanged ||
              !Object(_array_js__WEBPACK_IMPORTED_MODULE_4__["equals"])(skippedFeatures, newSkippedFeatures))) {
            context.canvas.width = imageFrameState.size[0] * pixelRatio;
            context.canvas.height = imageFrameState.size[1] * pixelRatio;
            vectorRenderer.compose(context, imageFrameState, layerState);
            skippedFeatures = newSkippedFeatures;
            callback();
          }
        });
      } else {
        image = imageSource.getImage(
          renderedExtent, viewResolution, pixelRatio, projection);
      }
      if (image && this.loadImage(image)) {
        this.image_ = image;
        this.skippedFeatures_ = skippedFeatures;
      }
    }

    if (this.image_) {
      image = this.image_;
      var imageExtent = image.getExtent();
      var imageResolution = image.getResolution();
      var imagePixelRatio = image.getPixelRatio();
      var scale = pixelRatio * imageResolution /
          (viewResolution * imagePixelRatio);
      var transform = Object(_transform_js__WEBPACK_IMPORTED_MODULE_10__["compose"])(this.imageTransform_,
        pixelRatio * size[0] / 2, pixelRatio * size[1] / 2,
        scale, scale,
        0,
        imagePixelRatio * (imageExtent[0] - viewCenter[0]) / imageResolution,
        imagePixelRatio * (viewCenter[1] - imageExtent[3]) / imageResolution);
      Object(_transform_js__WEBPACK_IMPORTED_MODULE_10__["compose"])(this.coordinateToCanvasPixelTransform,
        pixelRatio * size[0] / 2 - transform[4], pixelRatio * size[1] / 2 - transform[5],
        pixelRatio / viewResolution, -pixelRatio / viewResolution,
        0,
        -viewCenter[0], -viewCenter[1]);

      this.renderedResolution = imageResolution * pixelRatio / imagePixelRatio;
    }

    return !!this.image_;
  };

  /**
   * @inheritDoc
   */
  CanvasImageLayerRenderer.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate (coordinate, frameState, hitTolerance, callback) {
    if (this.vectorRenderer_) {
      return this.vectorRenderer_.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback);
    } else {
      return IntermediateCanvasRenderer.prototype.forEachFeatureAtCoordinate.call(this, coordinate, frameState, hitTolerance, callback);
    }
  };

  return CanvasImageLayerRenderer;
}(_IntermediateCanvas_js__WEBPACK_IMPORTED_MODULE_9__["default"]));


/**
 * Determine if this renderer handles the provided layer.
 * @param {import("../../layer/Layer.js").default} layer The candidate layer.
 * @return {boolean} The renderer can render the layer.
 */
CanvasImageLayerRenderer['handles'] = function(layer) {
  return layer.getType() === _LayerType_js__WEBPACK_IMPORTED_MODULE_2__["default"].IMAGE ||
    layer.getType() === _LayerType_js__WEBPACK_IMPORTED_MODULE_2__["default"].VECTOR &&
    /** @type {import("../../layer/Vector.js").default} */ (layer).getRenderMode() === _layer_VectorRenderType_js__WEBPACK_IMPORTED_MODULE_6__["default"].IMAGE;
};


/**
 * Create a layer renderer.
 * @param {import("../Map.js").default} mapRenderer The map renderer.
 * @param {import("../../layer/Layer.js").default} layer The layer to be rendererd.
 * @return {CanvasImageLayerRenderer} The layer renderer.
 */
CanvasImageLayerRenderer['create'] = function(mapRenderer, layer) {
  return new CanvasImageLayerRenderer(/** @type {import("../../layer/Image.js").default} */ (layer));
};


/* harmony default export */ __webpack_exports__["default"] = (CanvasImageLayerRenderer);

//# sourceMappingURL=ImageLayer.js.map

/***/ }),

/***/ "./node_modules/ol/renderer/canvas/IntermediateCanvas.js":
/*!***************************************************************!*\
  !*** ./node_modules/ol/renderer/canvas/IntermediateCanvas.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../coordinate.js */ "./node_modules/ol/coordinate.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Layer.js */ "./node_modules/ol/renderer/canvas/Layer.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/renderer/canvas/IntermediateCanvas
 */







/**
 * @abstract
 */
var IntermediateCanvasRenderer = /*@__PURE__*/(function (CanvasLayerRenderer) {
  function IntermediateCanvasRenderer(layer) {

    CanvasLayerRenderer.call(this, layer);

    /**
     * @protected
     * @type {import("../../transform.js").Transform}
     */
    this.coordinateToCanvasPixelTransform = Object(_transform_js__WEBPACK_IMPORTED_MODULE_5__["create"])();

    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */
    this.hitCanvasContext_ = null;

  }

  if ( CanvasLayerRenderer ) IntermediateCanvasRenderer.__proto__ = CanvasLayerRenderer;
  IntermediateCanvasRenderer.prototype = Object.create( CanvasLayerRenderer && CanvasLayerRenderer.prototype );
  IntermediateCanvasRenderer.prototype.constructor = IntermediateCanvasRenderer;

  /**
   * @inheritDoc
   */
  IntermediateCanvasRenderer.prototype.composeFrame = function composeFrame (frameState, layerState, context) {

    this.preCompose(context, frameState);

    var image = this.getImage();
    if (image) {

      // clipped rendering if layer extent is set
      var extent = layerState.extent;
      var clipped = extent !== undefined &&
          !Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__["containsExtent"])(extent, frameState.extent) &&
          Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__["intersects"])(extent, frameState.extent);
      if (clipped) {
        this.clip(context, frameState, /** @type {import("../../extent.js").Extent} */ (extent));
      }

      var imageTransform = this.getImageTransform();
      // for performance reasons, context.save / context.restore is not used
      // to save and restore the transformation matrix and the opacity.
      // see http://jsperf.com/context-save-restore-versus-variable
      var alpha = context.globalAlpha;
      context.globalAlpha = layerState.opacity;

      // for performance reasons, context.setTransform is only used
      // when the view is rotated. see http://jsperf.com/canvas-transform
      var dx = imageTransform[4];
      var dy = imageTransform[5];
      var dw = image.width * imageTransform[0];
      var dh = image.height * imageTransform[3];
      if (dw >= 0.5 && dh >= 0.5) {
        context.drawImage(image, 0, 0, +image.width, +image.height,
          Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));
      }
      context.globalAlpha = alpha;

      if (clipped) {
        context.restore();
      }
    }

    this.postCompose(context, frameState, layerState);
  };

  /**
   * @abstract
   * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Canvas.
   */
  IntermediateCanvasRenderer.prototype.getImage = function getImage () {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * @abstract
   * @return {!import("../../transform.js").Transform} Image transform.
   */
  IntermediateCanvasRenderer.prototype.getImageTransform = function getImageTransform () {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * @inheritDoc
   */
  IntermediateCanvasRenderer.prototype.forEachLayerAtCoordinate = function forEachLayerAtCoordinate (coordinate, frameState, hitTolerance, callback, thisArg) {
    if (!this.getImage()) {
      return undefined;
    }

    var pixel = Object(_transform_js__WEBPACK_IMPORTED_MODULE_5__["apply"])(this.coordinateToCanvasPixelTransform, coordinate.slice());
    Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_1__["scale"])(pixel, frameState.viewState.resolution / this.renderedResolution);

    if (!this.hitCanvasContext_) {
      this.hitCanvasContext_ = Object(_dom_js__WEBPACK_IMPORTED_MODULE_2__["createCanvasContext2D"])(1, 1);
    }

    this.hitCanvasContext_.clearRect(0, 0, 1, 1);
    this.hitCanvasContext_.drawImage(this.getImage(), pixel[0], pixel[1], 1, 1, 0, 0, 1, 1);

    var imageData = this.hitCanvasContext_.getImageData(0, 0, 1, 1).data;
    if (imageData[3] > 0) {
      return callback.call(thisArg, this.getLayer(), imageData);
    } else {
      return undefined;
    }
  };

  return IntermediateCanvasRenderer;
}(_Layer_js__WEBPACK_IMPORTED_MODULE_4__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (IntermediateCanvasRenderer);

//# sourceMappingURL=IntermediateCanvas.js.map

/***/ }),

/***/ "./node_modules/ol/renderer/canvas/Layer.js":
/*!**************************************************!*\
  !*** ./node_modules/ol/renderer/canvas/Layer.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _render_Event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../render/Event.js */ "./node_modules/ol/render/Event.js");
/* harmony import */ var _render_EventType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../render/EventType.js */ "./node_modules/ol/render/EventType.js");
/* harmony import */ var _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../render/canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _render_canvas_Immediate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../render/canvas/Immediate.js */ "./node_modules/ol/render/canvas/Immediate.js");
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Layer.js */ "./node_modules/ol/renderer/Layer.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/renderer/canvas/Layer
 */










/**
 * @abstract
 */
var CanvasLayerRenderer = /*@__PURE__*/(function (LayerRenderer) {
  function CanvasLayerRenderer(layer) {

    LayerRenderer.call(this, layer);

    /**
     * @protected
     * @type {number}
     */
    this.renderedResolution;

    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */
    this.transform_ = Object(_transform_js__WEBPACK_IMPORTED_MODULE_8__["create"])();

  }

  if ( LayerRenderer ) CanvasLayerRenderer.__proto__ = LayerRenderer;
  CanvasLayerRenderer.prototype = Object.create( LayerRenderer && LayerRenderer.prototype );
  CanvasLayerRenderer.prototype.constructor = CanvasLayerRenderer;

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent Clip extent.
   * @protected
   */
  CanvasLayerRenderer.prototype.clip = function clip (context, frameState, extent) {
    var pixelRatio = frameState.pixelRatio;
    var width = frameState.size[0] * pixelRatio;
    var height = frameState.size[1] * pixelRatio;
    var rotation = frameState.viewState.rotation;
    var topLeft = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getTopLeft"])(extent);
    var topRight = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getTopRight"])(extent);
    var bottomRight = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getBottomRight"])(extent);
    var bottomLeft = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getBottomLeft"])(extent);

    Object(_transform_js__WEBPACK_IMPORTED_MODULE_8__["apply"])(frameState.coordinateToPixelTransform, topLeft);
    Object(_transform_js__WEBPACK_IMPORTED_MODULE_8__["apply"])(frameState.coordinateToPixelTransform, topRight);
    Object(_transform_js__WEBPACK_IMPORTED_MODULE_8__["apply"])(frameState.coordinateToPixelTransform, bottomRight);
    Object(_transform_js__WEBPACK_IMPORTED_MODULE_8__["apply"])(frameState.coordinateToPixelTransform, bottomLeft);

    context.save();
    Object(_render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["rotateAtOffset"])(context, -rotation, width / 2, height / 2);
    context.beginPath();
    context.moveTo(topLeft[0] * pixelRatio, topLeft[1] * pixelRatio);
    context.lineTo(topRight[0] * pixelRatio, topRight[1] * pixelRatio);
    context.lineTo(bottomRight[0] * pixelRatio, bottomRight[1] * pixelRatio);
    context.lineTo(bottomLeft[0] * pixelRatio, bottomLeft[1] * pixelRatio);
    context.clip();
    Object(_render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["rotateAtOffset"])(context, rotation, width / 2, height / 2);
  };

  /**
   * @param {import("../../render/EventType.js").default} type Event type.
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../../transform.js").Transform=} opt_transform Transform.
   * @private
   */
  CanvasLayerRenderer.prototype.dispatchComposeEvent_ = function dispatchComposeEvent_ (type, context, frameState, opt_transform) {
    var layer = this.getLayer();
    if (layer.hasListener(type)) {
      var width = frameState.size[0] * frameState.pixelRatio;
      var height = frameState.size[1] * frameState.pixelRatio;
      var rotation = frameState.viewState.rotation;
      Object(_render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["rotateAtOffset"])(context, -rotation, width / 2, height / 2);
      var transform = opt_transform !== undefined ?
        opt_transform : this.getTransform(frameState, 0);
      var render = new _render_canvas_Immediate_js__WEBPACK_IMPORTED_MODULE_6__["default"](
        context, frameState.pixelRatio, frameState.extent, transform,
        frameState.viewState.rotation);
      var composeEvent = new _render_Event_js__WEBPACK_IMPORTED_MODULE_3__["default"](type, render, frameState,
        context, null);
      layer.dispatchEvent(composeEvent);
      Object(_render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["rotateAtOffset"])(context, rotation, width / 2, height / 2);
    }
  };

  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../PluggableMap.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(this: S, import("../../layer/Layer.js").default, (Uint8ClampedArray|Uint8Array)): T} callback Layer
   *     callback.
   * @param {S} thisArg Value to use as `this` when executing `callback`.
   * @return {T|undefined} Callback result.
   * @template S,T,U
   */
  CanvasLayerRenderer.prototype.forEachLayerAtCoordinate = function forEachLayerAtCoordinate (coordinate, frameState, hitTolerance, callback, thisArg) {
    var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, _functions_js__WEBPACK_IMPORTED_MODULE_2__["TRUE"]);

    if (hasFeature) {
      return callback.call(thisArg, this.getLayer(), null);
    } else {
      return undefined;
    }
  };

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../../layer/Layer.js").State} layerState Layer state.
   * @param {import("../../transform.js").Transform=} opt_transform Transform.
   * @protected
   */
  CanvasLayerRenderer.prototype.postCompose = function postCompose (context, frameState, layerState, opt_transform) {
    this.dispatchComposeEvent_(_render_EventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].POSTCOMPOSE, context, frameState, opt_transform);
  };

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../../transform.js").Transform=} opt_transform Transform.
   * @protected
   */
  CanvasLayerRenderer.prototype.preCompose = function preCompose (context, frameState, opt_transform) {
    this.dispatchComposeEvent_(_render_EventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].PRECOMPOSE, context, frameState, opt_transform);
  };

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../../transform.js").Transform=} opt_transform Transform.
   * @protected
   */
  CanvasLayerRenderer.prototype.dispatchRenderEvent = function dispatchRenderEvent (context, frameState, opt_transform) {
    this.dispatchComposeEvent_(_render_EventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].RENDER, context, frameState, opt_transform);
  };

  /**
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {number} offsetX Offset on the x-axis in view coordinates.
   * @protected
   * @return {!import("../../transform.js").Transform} Transform.
   */
  CanvasLayerRenderer.prototype.getTransform = function getTransform (frameState, offsetX) {
    var viewState = frameState.viewState;
    var pixelRatio = frameState.pixelRatio;
    var dx1 = pixelRatio * frameState.size[0] / 2;
    var dy1 = pixelRatio * frameState.size[1] / 2;
    var sx = pixelRatio / viewState.resolution;
    var sy = -sx;
    var angle = -viewState.rotation;
    var dx2 = -viewState.center[0] + offsetX;
    var dy2 = -viewState.center[1];
    return Object(_transform_js__WEBPACK_IMPORTED_MODULE_8__["compose"])(this.transform_, dx1, dy1, sx, sy, angle, dx2, dy2);
  };

  /**
   * @abstract
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../../layer/Layer.js").State} layerState Layer state.
   * @param {CanvasRenderingContext2D} context Context.
   */
  CanvasLayerRenderer.prototype.composeFrame = function composeFrame (frameState, layerState, context) {
    Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * @abstract
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../../layer/Layer.js").State} layerState Layer state.
   * @return {boolean} whether composeFrame should be called.
   */
  CanvasLayerRenderer.prototype.prepareFrame = function prepareFrame (frameState, layerState) {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  return CanvasLayerRenderer;
}(_Layer_js__WEBPACK_IMPORTED_MODULE_7__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (CanvasLayerRenderer);

//# sourceMappingURL=Layer.js.map

/***/ }),

/***/ "./node_modules/ol/renderer/canvas/Map.js":
/*!************************************************!*\
  !*** ./node_modules/ol/renderer/canvas/Map.js ***!
  \************************************************/
/*! exports provided: layerRendererConstructors, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "layerRendererConstructors", function() { return layerRendererConstructors; });
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../css.js */ "./node_modules/ol/css.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _layer_Layer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../layer/Layer.js */ "./node_modules/ol/layer/Layer.js");
/* harmony import */ var _render_Event_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../render/Event.js */ "./node_modules/ol/render/Event.js");
/* harmony import */ var _render_EventType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../render/EventType.js */ "./node_modules/ol/render/EventType.js");
/* harmony import */ var _render_canvas_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../render/canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _render_canvas_Immediate_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../render/canvas/Immediate.js */ "./node_modules/ol/render/canvas/Immediate.js");
/* harmony import */ var _Map_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../Map.js */ "./node_modules/ol/renderer/Map.js");
/* harmony import */ var _source_State_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../source/State.js */ "./node_modules/ol/source/State.js");
/**
 * @module ol/renderer/canvas/Map
 */













/**
 * @type {Array<typeof import("../Layer.js").default>}
 */
var layerRendererConstructors = [];

/**
 * @classdesc
 * Canvas map renderer.
 * @api
 */
var CanvasMapRenderer = /*@__PURE__*/(function (MapRenderer) {
  function CanvasMapRenderer(map) {
    MapRenderer.call(this, map);

    var container = map.getViewport();

    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */
    this.context_ = Object(_dom_js__WEBPACK_IMPORTED_MODULE_3__["createCanvasContext2D"])();

    /**
     * @private
     * @type {HTMLCanvasElement}
     */
    this.canvas_ = this.context_.canvas;

    this.canvas_.style.width = '100%';
    this.canvas_.style.height = '100%';
    this.canvas_.style.display = 'block';
    this.canvas_.className = _css_js__WEBPACK_IMPORTED_MODULE_2__["CLASS_UNSELECTABLE"];
    container.insertBefore(this.canvas_, container.childNodes[0] || null);

    /**
     * @private
     * @type {boolean}
     */
    this.renderedVisible_ = true;

    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */
    this.transform_ = Object(_transform_js__WEBPACK_IMPORTED_MODULE_0__["create"])();

  }

  if ( MapRenderer ) CanvasMapRenderer.__proto__ = MapRenderer;
  CanvasMapRenderer.prototype = Object.create( MapRenderer && MapRenderer.prototype );
  CanvasMapRenderer.prototype.constructor = CanvasMapRenderer;

  /**
   * @param {import("../../render/EventType.js").default} type Event type.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   */
  CanvasMapRenderer.prototype.dispatchRenderEvent = function dispatchRenderEvent (type, frameState) {
    var map = this.getMap();
    var context = this.context_;
    if (map.hasListener(type)) {
      var extent = frameState.extent;
      var pixelRatio = frameState.pixelRatio;
      var viewState = frameState.viewState;
      var rotation = viewState.rotation;

      var transform = this.getTransform(frameState);

      var vectorContext = new _render_canvas_Immediate_js__WEBPACK_IMPORTED_MODULE_8__["default"](context, pixelRatio,
        extent, transform, rotation);
      var composeEvent = new _render_Event_js__WEBPACK_IMPORTED_MODULE_5__["default"](type, vectorContext,
        frameState, context, null);
      map.dispatchEvent(composeEvent);
    }
  };

  /**
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @protected
   * @return {!import("../../transform.js").Transform} Transform.
   */
  CanvasMapRenderer.prototype.getTransform = function getTransform (frameState) {
    var viewState = frameState.viewState;
    var dx1 = this.canvas_.width / 2;
    var dy1 = this.canvas_.height / 2;
    var sx = frameState.pixelRatio / viewState.resolution;
    var sy = -sx;
    var angle = -viewState.rotation;
    var dx2 = -viewState.center[0];
    var dy2 = -viewState.center[1];
    return Object(_transform_js__WEBPACK_IMPORTED_MODULE_0__["compose"])(this.transform_, dx1, dy1, sx, sy, angle, dx2, dy2);
  };

  /**
   * @inheritDoc
   */
  CanvasMapRenderer.prototype.renderFrame = function renderFrame (frameState) {

    if (!frameState) {
      if (this.renderedVisible_) {
        this.canvas_.style.display = 'none';
        this.renderedVisible_ = false;
      }
      return;
    }

    var context = this.context_;
    var pixelRatio = frameState.pixelRatio;
    var width = Math.round(frameState.size[0] * pixelRatio);
    var height = Math.round(frameState.size[1] * pixelRatio);
    if (this.canvas_.width != width || this.canvas_.height != height) {
      this.canvas_.width = width;
      this.canvas_.height = height;
    } else {
      context.clearRect(0, 0, width, height);
    }

    var rotation = frameState.viewState.rotation;

    this.calculateMatrices2D(frameState);

    this.dispatchRenderEvent(_render_EventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].PRECOMPOSE, frameState);

    var layerStatesArray = frameState.layerStatesArray;
    Object(_array_js__WEBPACK_IMPORTED_MODULE_1__["stableSort"])(layerStatesArray, _Map_js__WEBPACK_IMPORTED_MODULE_9__["sortByZIndex"]);

    if (rotation) {
      context.save();
      Object(_render_canvas_js__WEBPACK_IMPORTED_MODULE_7__["rotateAtOffset"])(context, rotation, width / 2, height / 2);
    }

    var viewResolution = frameState.viewState.resolution;
    var i, ii;
    for (i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      var layerState = layerStatesArray[i];
      var layer = layerState.layer;
      var layerRenderer = /** @type {import("./Layer.js").default} */ (this.getLayerRenderer(layer));
      if (!Object(_layer_Layer_js__WEBPACK_IMPORTED_MODULE_4__["visibleAtResolution"])(layerState, viewResolution) ||
          layerState.sourceState != _source_State_js__WEBPACK_IMPORTED_MODULE_10__["default"].READY) {
        continue;
      }
      if (layerRenderer.prepareFrame(frameState, layerState)) {
        layerRenderer.composeFrame(frameState, layerState, context);
      }
    }

    if (rotation) {
      context.restore();
    }

    this.dispatchRenderEvent(_render_EventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].POSTCOMPOSE, frameState);

    if (!this.renderedVisible_) {
      this.canvas_.style.display = '';
      this.renderedVisible_ = true;
    }

    this.scheduleRemoveUnusedLayerRenderers(frameState);
    this.scheduleExpireIconCache(frameState);
  };

  /**
   * @inheritDoc
   */
  CanvasMapRenderer.prototype.forEachLayerAtPixel = function forEachLayerAtPixel (pixel, frameState, hitTolerance, callback, thisArg, layerFilter, thisArg2) {
    var result;
    var viewState = frameState.viewState;
    var viewResolution = viewState.resolution;

    var layerStates = frameState.layerStatesArray;
    var numLayers = layerStates.length;

    var coordinate = Object(_transform_js__WEBPACK_IMPORTED_MODULE_0__["apply"])(
      frameState.pixelToCoordinateTransform, pixel.slice());

    var i;
    for (i = numLayers - 1; i >= 0; --i) {
      var layerState = layerStates[i];
      var layer = layerState.layer;
      if (Object(_layer_Layer_js__WEBPACK_IMPORTED_MODULE_4__["visibleAtResolution"])(layerState, viewResolution) && layerFilter.call(thisArg2, layer)) {
        var layerRenderer = /** @type {import("./Layer.js").default} */ (this.getLayerRenderer(layer));
        result = layerRenderer.forEachLayerAtCoordinate(
          coordinate, frameState, hitTolerance, callback, thisArg);
        if (result) {
          return result;
        }
      }
    }
    return undefined;
  };

  /**
   * @inheritDoc
   */
  CanvasMapRenderer.prototype.registerLayerRenderers = function registerLayerRenderers (constructors) {
    MapRenderer.prototype.registerLayerRenderers.call(this, constructors);
    for (var i = 0, ii = constructors.length; i < ii; ++i) {
      var ctor = constructors[i];
      if (!Object(_array_js__WEBPACK_IMPORTED_MODULE_1__["includes"])(layerRendererConstructors, ctor)) {
        layerRendererConstructors.push(ctor);
      }
    }
  };

  return CanvasMapRenderer;
}(_Map_js__WEBPACK_IMPORTED_MODULE_9__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (CanvasMapRenderer);

//# sourceMappingURL=Map.js.map

/***/ }),

/***/ "./node_modules/ol/renderer/canvas/TileLayer.js":
/*!******************************************************!*\
  !*** ./node_modules/ol/renderer/canvas/TileLayer.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _LayerType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../LayerType.js */ "./node_modules/ol/LayerType.js");
/* harmony import */ var _TileRange_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../TileRange.js */ "./node_modules/ol/TileRange.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../ViewHint.js */ "./node_modules/ol/ViewHint.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _IntermediateCanvas_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./IntermediateCanvas.js */ "./node_modules/ol/renderer/canvas/IntermediateCanvas.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/renderer/canvas/TileLayer
 */










/**
 * @classdesc
 * Canvas renderer for tile layers.
 * @api
 */
var CanvasTileLayerRenderer = /*@__PURE__*/(function (IntermediateCanvasRenderer) {
  function CanvasTileLayerRenderer(tileLayer, opt_noContext) {

    IntermediateCanvasRenderer.call(this, tileLayer);

    /**
     * @protected
     * @type {CanvasRenderingContext2D}
     */
    this.context = opt_noContext ? null : Object(_dom_js__WEBPACK_IMPORTED_MODULE_5__["createCanvasContext2D"])();

    /**
     * @private
     * @type {number}
     */
    this.oversampling_;

    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */
    this.renderedExtent_ = null;

    /**
     * @protected
     * @type {number}
     */
    this.renderedRevision;

    /**
     * @protected
     * @type {!Array<import("../../Tile.js").default>}
     */
    this.renderedTiles = [];

    /**
     * @private
     * @type {boolean}
     */
    this.newTiles_ = false;

    /**
     * @protected
     * @type {import("../../extent.js").Extent}
     */
    this.tmpExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_6__["createEmpty"])();

    /**
     * @private
     * @type {import("../../TileRange.js").default}
     */
    this.tmpTileRange_ = new _TileRange_js__WEBPACK_IMPORTED_MODULE_2__["default"](0, 0, 0, 0);

    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */
    this.imageTransform_ = Object(_transform_js__WEBPACK_IMPORTED_MODULE_8__["create"])();

    /**
     * @protected
     * @type {number}
     */
    this.zDirection = 0;

  }

  if ( IntermediateCanvasRenderer ) CanvasTileLayerRenderer.__proto__ = IntermediateCanvasRenderer;
  CanvasTileLayerRenderer.prototype = Object.create( IntermediateCanvasRenderer && IntermediateCanvasRenderer.prototype );
  CanvasTileLayerRenderer.prototype.constructor = CanvasTileLayerRenderer;

  /**
   * @private
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {boolean} Tile is drawable.
   */
  CanvasTileLayerRenderer.prototype.isDrawableTile_ = function isDrawableTile_ (tile) {
    var tileLayer = /** @type {import("../../layer/Tile.js").default} */ (this.getLayer());
    var tileState = tile.getState();
    var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();
    return tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_3__["default"].LOADED ||
        tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_3__["default"].EMPTY ||
        tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_3__["default"].ERROR && !useInterimTilesOnError;
  };

  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection.js").default} projection Projection.
   * @return {!import("../../Tile.js").default} Tile.
   */
  CanvasTileLayerRenderer.prototype.getTile = function getTile (z, x, y, pixelRatio, projection) {
    var tileLayer = /** @type {import("../../layer/Tile.js").default} */ (this.getLayer());
    var tileSource = /** @type {import("../../source/Tile.js").default} */ (tileLayer.getSource());
    var tile = tileSource.getTile(z, x, y, pixelRatio, projection);
    if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_3__["default"].ERROR) {
      if (!tileLayer.getUseInterimTilesOnError()) {
        // When useInterimTilesOnError is false, we consider the error tile as loaded.
        tile.setState(_TileState_js__WEBPACK_IMPORTED_MODULE_3__["default"].LOADED);
      } else if (tileLayer.getPreload() > 0) {
        // Preloaded tiles for lower resolutions might have finished loading.
        this.newTiles_ = true;
      }
    }
    if (!this.isDrawableTile_(tile)) {
      tile = tile.getInterimTile();
    }
    return tile;
  };

  /**
   * @inheritDoc
   */
  CanvasTileLayerRenderer.prototype.prepareFrame = function prepareFrame (frameState, layerState) {

    var pixelRatio = frameState.pixelRatio;
    var size = frameState.size;
    var viewState = frameState.viewState;
    var projection = viewState.projection;
    var viewResolution = viewState.resolution;
    var viewCenter = viewState.center;

    var tileLayer = /** @type {import("../../layer/Tile.js").default} */ (this.getLayer());
    var tileSource = /** @type {import("../../source/Tile.js").default} */ (tileLayer.getSource());
    var sourceRevision = tileSource.getRevision();
    var tileGrid = tileSource.getTileGridForProjection(projection);
    var z = tileGrid.getZForResolution(viewResolution, this.zDirection);
    var tileResolution = tileGrid.getResolution(z);
    var oversampling = Math.round(viewResolution / tileResolution) || 1;
    var extent = frameState.extent;

    if (layerState.extent !== undefined) {
      extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_6__["getIntersection"])(extent, layerState.extent);
    }
    if (Object(_extent_js__WEBPACK_IMPORTED_MODULE_6__["isEmpty"])(extent)) {
      // Return false to prevent the rendering of the layer.
      return false;
    }

    var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
    var imageExtent = tileGrid.getTileRangeExtent(z, tileRange);

    var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);

    /**
     * @type {Object<number, Object<string, import("../../Tile.js").default>>}
     */
    var tilesToDrawByZ = {};
    tilesToDrawByZ[z] = {};

    var findLoadedTiles = this.createLoadedTileFinder(
      tileSource, projection, tilesToDrawByZ);

    var hints = frameState.viewHints;
    var animatingOrInteracting = hints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_4__["default"].ANIMATING] || hints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_4__["default"].INTERACTING];

    var tmpExtent = this.tmpExtent;
    var tmpTileRange = this.tmpTileRange_;
    this.newTiles_ = false;
    var tile, x, y;
    for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (y = tileRange.minY; y <= tileRange.maxY; ++y) {
        if (Date.now() - frameState.time > 16 && animatingOrInteracting) {
          continue;
        }
        tile = this.getTile(z, x, y, pixelRatio, projection);
        if (this.isDrawableTile_(tile)) {
          var uid = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(this);
          if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_3__["default"].LOADED) {
            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;
            var inTransition = tile.inTransition(uid);
            if (!this.newTiles_ && (inTransition || this.renderedTiles.indexOf(tile) === -1)) {
              this.newTiles_ = true;
            }
          }
          if (tile.getAlpha(uid, frameState.time) === 1) {
            // don't look for alt tiles if alpha is 1
            continue;
          }
        }

        var childTileRange = tileGrid.getTileCoordChildTileRange(
          tile.tileCoord, tmpTileRange, tmpExtent);
        var covered = false;
        if (childTileRange) {
          covered = findLoadedTiles(z + 1, childTileRange);
        }
        if (!covered) {
          tileGrid.forEachTileCoordParentTileRange(
            tile.tileCoord, findLoadedTiles, null, tmpTileRange, tmpExtent);
        }

      }
    }

    var renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;
    if (!(this.renderedResolution && Date.now() - frameState.time > 16 && animatingOrInteracting) && (
      this.newTiles_ ||
          !(this.renderedExtent_ && Object(_extent_js__WEBPACK_IMPORTED_MODULE_6__["containsExtent"])(this.renderedExtent_, extent)) ||
          this.renderedRevision != sourceRevision ||
          oversampling != this.oversampling_ ||
          !animatingOrInteracting && renderedResolution != this.renderedResolution
    )) {

      var context = this.context;
      if (context) {
        var tilePixelSize = tileSource.getTilePixelSize(z, pixelRatio, projection);
        var width = Math.round(tileRange.getWidth() * tilePixelSize[0] / oversampling);
        var height = Math.round(tileRange.getHeight() * tilePixelSize[1] / oversampling);
        var canvas = context.canvas;
        if (canvas.width != width || canvas.height != height) {
          this.oversampling_ = oversampling;
          canvas.width = width;
          canvas.height = height;
        } else {
          if ((this.renderedExtent_ && !Object(_extent_js__WEBPACK_IMPORTED_MODULE_6__["equals"])(imageExtent, this.renderedExtent_)) ||
              this.renderedRevision != sourceRevision) {
            context.clearRect(0, 0, width, height);
          }
          oversampling = this.oversampling_;
        }
      }

      this.renderedTiles.length = 0;
      /** @type {Array<number>} */
      var zs = Object.keys(tilesToDrawByZ).map(Number);
      zs.sort(function(a, b) {
        if (a === z) {
          return 1;
        } else if (b === z) {
          return -1;
        } else {
          return a > b ? 1 : a < b ? -1 : 0;
        }
      });
      var currentResolution, currentScale, currentTilePixelSize, currentZ, i, ii;
      var tileExtent, tileGutter, tilesToDraw, w, h;
      for (i = 0, ii = zs.length; i < ii; ++i) {
        currentZ = zs[i];
        currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);
        currentResolution = tileGrid.getResolution(currentZ);
        currentScale = currentResolution / tileResolution;
        tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);
        tilesToDraw = tilesToDrawByZ[currentZ];
        for (var tileCoordKey in tilesToDraw) {
          tile = tilesToDraw[tileCoordKey];
          tileExtent = tileGrid.getTileCoordExtent(tile.getTileCoord(), tmpExtent);
          x = (tileExtent[0] - imageExtent[0]) / tileResolution * tilePixelRatio / oversampling;
          y = (imageExtent[3] - tileExtent[3]) / tileResolution * tilePixelRatio / oversampling;
          w = currentTilePixelSize[0] * currentScale / oversampling;
          h = currentTilePixelSize[1] * currentScale / oversampling;
          this.drawTileImage(tile, frameState, layerState, x, y, w, h, tileGutter, z === currentZ);
          this.renderedTiles.push(tile);
        }
      }

      this.renderedRevision = sourceRevision;
      this.renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;
      this.renderedExtent_ = imageExtent;
    }

    var scale = this.renderedResolution / viewResolution;
    var transform = Object(_transform_js__WEBPACK_IMPORTED_MODULE_8__["compose"])(this.imageTransform_,
      pixelRatio * size[0] / 2, pixelRatio * size[1] / 2,
      scale, scale,
      0,
      (this.renderedExtent_[0] - viewCenter[0]) / this.renderedResolution * pixelRatio,
      (viewCenter[1] - this.renderedExtent_[3]) / this.renderedResolution * pixelRatio);
    Object(_transform_js__WEBPACK_IMPORTED_MODULE_8__["compose"])(this.coordinateToCanvasPixelTransform,
      pixelRatio * size[0] / 2 - transform[4], pixelRatio * size[1] / 2 - transform[5],
      pixelRatio / viewResolution, -pixelRatio / viewResolution,
      0,
      -viewCenter[0], -viewCenter[1]);


    this.updateUsedTiles(frameState.usedTiles, tileSource, z, tileRange);
    this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio,
      projection, extent, z, tileLayer.getPreload());
    this.scheduleExpireCache(frameState, tileSource);

    return this.renderedTiles.length > 0;
  };

  /**
   * @param {import("../../Tile.js").default} tile Tile.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../../layer/Layer.js").State} layerState Layer state.
   * @param {number} x Left of the tile.
   * @param {number} y Top of the tile.
   * @param {number} w Width of the tile.
   * @param {number} h Height of the tile.
   * @param {number} gutter Tile gutter.
   * @param {boolean} transition Apply an alpha transition.
   */
  CanvasTileLayerRenderer.prototype.drawTileImage = function drawTileImage (tile, frameState, layerState, x, y, w, h, gutter, transition) {
    var image = this.getTileImage(tile);
    if (!image) {
      return;
    }
    var uid = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(this);
    var alpha = transition ? tile.getAlpha(uid, frameState.time) : 1;
    var tileLayer = /** @type {import("../../layer/Tile.js").default} */ (this.getLayer());
    var tileSource = /** @type {import("../../source/Tile.js").default} */ (tileLayer.getSource());
    if (alpha === 1 && !tileSource.getOpaque(frameState.viewState.projection)) {
      this.context.clearRect(x, y, w, h);
    }
    var alphaChanged = alpha !== this.context.globalAlpha;
    if (alphaChanged) {
      this.context.save();
      this.context.globalAlpha = alpha;
    }
    this.context.drawImage(image, gutter, gutter,
      image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);

    if (alphaChanged) {
      this.context.restore();
    }
    if (alpha !== 1) {
      frameState.animate = true;
    } else if (transition) {
      tile.endTransition(uid);
    }
  };

  /**
   * @inheritDoc
   */
  CanvasTileLayerRenderer.prototype.getImage = function getImage () {
    var context = this.context;
    return context ? context.canvas : null;
  };

  /**
   * @inheritDoc
   */
  CanvasTileLayerRenderer.prototype.getImageTransform = function getImageTransform () {
    return this.imageTransform_;
  };

  /**
   * Get the image from a tile.
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @protected
   */
  CanvasTileLayerRenderer.prototype.getTileImage = function getTileImage (tile) {
    return /** @type {import("../../ImageTile.js").default} */ (tile).getImage();
  };

  return CanvasTileLayerRenderer;
}(_IntermediateCanvas_js__WEBPACK_IMPORTED_MODULE_7__["default"]));


/**
 * Determine if this renderer handles the provided layer.
 * @param {import("../../layer/Layer.js").default} layer The candidate layer.
 * @return {boolean} The renderer can render the layer.
 */
CanvasTileLayerRenderer['handles'] = function(layer) {
  return layer.getType() === _LayerType_js__WEBPACK_IMPORTED_MODULE_1__["default"].TILE;
};


/**
 * Create a layer renderer.
 * @param {import("../Map.js").default} mapRenderer The map renderer.
 * @param {import("../../layer/Layer.js").default} layer The layer to be rendererd.
 * @return {CanvasTileLayerRenderer} The layer renderer.
 */
CanvasTileLayerRenderer['create'] = function(mapRenderer, layer) {
  return new CanvasTileLayerRenderer(/** @type {import("../../layer/Tile.js").default} */ (layer));
};


/**
 * @function
 * @return {import("../../layer/Tile.js").default|import("../../layer/VectorTile.js").default}
 */
CanvasTileLayerRenderer.prototype.getLayer;


/* harmony default export */ __webpack_exports__["default"] = (CanvasTileLayerRenderer);

//# sourceMappingURL=TileLayer.js.map

/***/ }),

/***/ "./node_modules/ol/renderer/canvas/VectorLayer.js":
/*!********************************************************!*\
  !*** ./node_modules/ol/renderer/canvas/VectorLayer.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _LayerType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../LayerType.js */ "./node_modules/ol/LayerType.js");
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../ViewHint.js */ "./node_modules/ol/ViewHint.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rbush */ "./node_modules/rbush/index.js");
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(rbush__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _render_EventType_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../render/EventType.js */ "./node_modules/ol/render/EventType.js");
/* harmony import */ var _render_canvas_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../render/canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _render_canvas_ReplayGroup_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../render/canvas/ReplayGroup.js */ "./node_modules/ol/render/canvas/ReplayGroup.js");
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Layer.js */ "./node_modules/ol/renderer/canvas/Layer.js");
/* harmony import */ var _vector_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../vector.js */ "./node_modules/ol/renderer/vector.js");
/**
 * @module ol/renderer/canvas/VectorLayer
 */














/**
 * @classdesc
 * Canvas renderer for vector layers.
 * @api
 */
var CanvasVectorLayerRenderer = /*@__PURE__*/(function (CanvasLayerRenderer) {
  function CanvasVectorLayerRenderer(vectorLayer) {

    CanvasLayerRenderer.call(this, vectorLayer);

    /**
     * Declutter tree.
     * @private
     */
    this.declutterTree_ = vectorLayer.getDeclutter() ? rbush__WEBPACK_IMPORTED_MODULE_6___default()(9, undefined) : null;

    /**
     * @private
     * @type {boolean}
     */
    this.dirty_ = false;

    /**
     * @private
     * @type {number}
     */
    this.renderedRevision_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.renderedResolution_ = NaN;

    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */
    this.renderedExtent_ = Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["createEmpty"])();

    /**
     * @private
     * @type {function(import("../../Feature.js").default, import("../../Feature.js").default): number|null}
     */
    this.renderedRenderOrder_ = null;

    /**
     * @private
     * @type {import("../../render/canvas/ReplayGroup.js").default}
     */
    this.replayGroup_ = null;

    /**
     * A new replay group had to be created by `prepareFrame()`
     * @type {boolean}
     */
    this.replayGroupChanged = true;

    /**
     * @type {CanvasRenderingContext2D}
     */
    this.context = Object(_dom_js__WEBPACK_IMPORTED_MODULE_3__["createCanvasContext2D"])();

    Object(_events_js__WEBPACK_IMPORTED_MODULE_4__["listen"])(_render_canvas_js__WEBPACK_IMPORTED_MODULE_9__["labelCache"], _events_EventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].CLEAR, this.handleFontsChanged_, this);

  }

  if ( CanvasLayerRenderer ) CanvasVectorLayerRenderer.__proto__ = CanvasLayerRenderer;
  CanvasVectorLayerRenderer.prototype = Object.create( CanvasLayerRenderer && CanvasLayerRenderer.prototype );
  CanvasVectorLayerRenderer.prototype.constructor = CanvasVectorLayerRenderer;

  /**
   * @inheritDoc
   */
  CanvasVectorLayerRenderer.prototype.disposeInternal = function disposeInternal () {
    Object(_events_js__WEBPACK_IMPORTED_MODULE_4__["unlisten"])(_render_canvas_js__WEBPACK_IMPORTED_MODULE_9__["labelCache"], _events_EventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].CLEAR, this.handleFontsChanged_, this);
    CanvasLayerRenderer.prototype.disposeInternal.call(this);
  };

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../../layer/Layer.js").State} layerState Layer state.
   */
  CanvasVectorLayerRenderer.prototype.compose = function compose (context, frameState, layerState) {
    var extent = frameState.extent;
    var pixelRatio = frameState.pixelRatio;
    var skippedFeatureUids = layerState.managed ?
      frameState.skippedFeatureUids : {};
    var viewState = frameState.viewState;
    var projection = viewState.projection;
    var rotation = viewState.rotation;
    var projectionExtent = projection.getExtent();
    var vectorSource = /** @type {import("../../source/Vector.js").default} */ (this.getLayer().getSource());

    var transform = this.getTransform(frameState, 0);

    // clipped rendering if layer extent is set
    var clipExtent = layerState.extent;
    var clipped = clipExtent !== undefined;
    if (clipped) {
      this.clip(context, frameState, /** @type {import("../../extent.js").Extent} */ (clipExtent));
    }
    var replayGroup = this.replayGroup_;
    if (replayGroup && !replayGroup.isEmpty()) {
      if (this.declutterTree_) {
        this.declutterTree_.clear();
      }
      var layer = /** @type {import("../../layer/Vector.js").default} */ (this.getLayer());
      var drawOffsetX = 0;
      var drawOffsetY = 0;
      var replayContext;
      var transparentLayer = layerState.opacity !== 1;
      var hasRenderListeners = layer.hasListener(_render_EventType_js__WEBPACK_IMPORTED_MODULE_8__["default"].RENDER);
      if (transparentLayer || hasRenderListeners) {
        var drawWidth = context.canvas.width;
        var drawHeight = context.canvas.height;
        if (rotation) {
          var drawSize = Math.round(Math.sqrt(drawWidth * drawWidth + drawHeight * drawHeight));
          drawOffsetX = (drawSize - drawWidth) / 2;
          drawOffsetY = (drawSize - drawHeight) / 2;
          drawWidth = drawHeight = drawSize;
        }
        // resize and clear
        this.context.canvas.width = drawWidth;
        this.context.canvas.height = drawHeight;
        replayContext = this.context;
      } else {
        replayContext = context;
      }

      var alpha = replayContext.globalAlpha;
      if (!transparentLayer) {
        // for performance reasons, context.save / context.restore is not used
        // to save and restore the transformation matrix and the opacity.
        // see http://jsperf.com/context-save-restore-versus-variable
        replayContext.globalAlpha = layerState.opacity;
      }

      if (replayContext != context) {
        replayContext.translate(drawOffsetX, drawOffsetY);
      }

      var viewHints = frameState.viewHints;
      var snapToPixel = !(viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_2__["default"].ANIMATING] || viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_2__["default"].INTERACTING]);
      var width = frameState.size[0] * pixelRatio;
      var height = frameState.size[1] * pixelRatio;
      Object(_render_canvas_js__WEBPACK_IMPORTED_MODULE_9__["rotateAtOffset"])(replayContext, -rotation,
        width / 2, height / 2);
      replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids, snapToPixel);
      if (vectorSource.getWrapX() && projection.canWrapX() &&
          !Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["containsExtent"])(projectionExtent, extent)) {
        var startX = extent[0];
        var worldWidth = Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["getWidth"])(projectionExtent);
        var world = 0;
        var offsetX;
        while (startX < projectionExtent[0]) {
          --world;
          offsetX = worldWidth * world;
          transform = this.getTransform(frameState, offsetX);
          replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids, snapToPixel);
          startX += worldWidth;
        }
        world = 0;
        startX = extent[2];
        while (startX > projectionExtent[2]) {
          ++world;
          offsetX = worldWidth * world;
          transform = this.getTransform(frameState, offsetX);
          replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids, snapToPixel);
          startX -= worldWidth;
        }
      }
      Object(_render_canvas_js__WEBPACK_IMPORTED_MODULE_9__["rotateAtOffset"])(replayContext, rotation,
        width / 2, height / 2);

      if (hasRenderListeners) {
        this.dispatchRenderEvent(replayContext, frameState, transform);
      }
      if (replayContext != context) {
        if (transparentLayer) {
          var mainContextAlpha = context.globalAlpha;
          context.globalAlpha = layerState.opacity;
          context.drawImage(replayContext.canvas, -drawOffsetX, -drawOffsetY);
          context.globalAlpha = mainContextAlpha;
        } else {
          context.drawImage(replayContext.canvas, -drawOffsetX, -drawOffsetY);
        }
        replayContext.translate(-drawOffsetX, -drawOffsetY);
      }

      if (!transparentLayer) {
        replayContext.globalAlpha = alpha;
      }
    }

    if (clipped) {
      context.restore();
    }
  };

  /**
   * @inheritDoc
   */
  CanvasVectorLayerRenderer.prototype.composeFrame = function composeFrame (frameState, layerState, context) {
    var transform = this.getTransform(frameState, 0);
    this.preCompose(context, frameState, transform);
    this.compose(context, frameState, layerState);
    this.postCompose(context, frameState, layerState, transform);
  };

  /**
   * @inheritDoc
   */
  CanvasVectorLayerRenderer.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate (coordinate, frameState, hitTolerance, callback, thisArg) {
    if (!this.replayGroup_) {
      return undefined;
    } else {
      var resolution = frameState.viewState.resolution;
      var rotation = frameState.viewState.rotation;
      var layer = /** @type {import("../../layer/Vector.js").default} */ (this.getLayer());
      /** @type {!Object<string, boolean>} */
      var features = {};
      var result = this.replayGroup_.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, {},
        /**
         * @param {import("../../Feature.js").FeatureLike} feature Feature.
         * @return {?} Callback result.
         */
        function(feature) {
          var key = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature);
          if (!(key in features)) {
            features[key] = true;
            return callback.call(thisArg, feature, layer);
          }
        }, null);
      return result;
    }
  };

  /**
   * @param {import("../../events/Event.js").default} event Event.
   */
  CanvasVectorLayerRenderer.prototype.handleFontsChanged_ = function handleFontsChanged_ (event) {
    var layer = this.getLayer();
    if (layer.getVisible() && this.replayGroup_) {
      layer.changed();
    }
  };

  /**
   * Handle changes in image style state.
   * @param {import("../../events/Event.js").default} event Image style change event.
   * @private
   */
  CanvasVectorLayerRenderer.prototype.handleStyleImageChange_ = function handleStyleImageChange_ (event) {
    this.renderIfReadyAndVisible();
  };

  /**
   * @inheritDoc
   */
  CanvasVectorLayerRenderer.prototype.prepareFrame = function prepareFrame (frameState, layerState) {
    var vectorLayer = /** @type {import("../../layer/Vector.js").default} */ (this.getLayer());
    var vectorSource = /** @type {import("../../source/Vector.js").default} */ (vectorLayer.getSource());

    var animating = frameState.viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_2__["default"].ANIMATING];
    var interacting = frameState.viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_2__["default"].INTERACTING];
    var updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();
    var updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();

    if (!this.dirty_ && (!updateWhileAnimating && animating) ||
        (!updateWhileInteracting && interacting)) {
      return true;
    }

    var frameStateExtent = frameState.extent;
    var viewState = frameState.viewState;
    var projection = viewState.projection;
    var resolution = viewState.resolution;
    var pixelRatio = frameState.pixelRatio;
    var vectorLayerRevision = vectorLayer.getRevision();
    var vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
    var vectorLayerRenderOrder = vectorLayer.getRenderOrder();

    if (vectorLayerRenderOrder === undefined) {
      vectorLayerRenderOrder = _vector_js__WEBPACK_IMPORTED_MODULE_12__["defaultOrder"];
    }

    var extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["buffer"])(frameStateExtent,
      vectorLayerRenderBuffer * resolution);
    var projectionExtent = viewState.projection.getExtent();

    if (vectorSource.getWrapX() && viewState.projection.canWrapX() &&
        !Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["containsExtent"])(projectionExtent, frameState.extent)) {
      // For the replay group, we need an extent that intersects the real world
      // (-180° to +180°). To support geometries in a coordinate range from -540°
      // to +540°, we add at least 1 world width on each side of the projection
      // extent. If the viewport is wider than the world, we need to add half of
      // the viewport width to make sure we cover the whole viewport.
      var worldWidth = Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["getWidth"])(projectionExtent);
      var gutter = Math.max(Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["getWidth"])(extent) / 2, worldWidth);
      extent[0] = projectionExtent[0] - gutter;
      extent[2] = projectionExtent[2] + gutter;
    }

    if (!this.dirty_ &&
        this.renderedResolution_ == resolution &&
        this.renderedRevision_ == vectorLayerRevision &&
        this.renderedRenderOrder_ == vectorLayerRenderOrder &&
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["containsExtent"])(this.renderedExtent_, extent)) {
      this.replayGroupChanged = false;
      return true;
    }

    this.replayGroup_ = null;

    this.dirty_ = false;

    var replayGroup = new _render_canvas_ReplayGroup_js__WEBPACK_IMPORTED_MODULE_10__["default"](
      Object(_vector_js__WEBPACK_IMPORTED_MODULE_12__["getTolerance"])(resolution, pixelRatio), extent, resolution,
      pixelRatio, vectorSource.getOverlaps(), this.declutterTree_, vectorLayer.getRenderBuffer());
    vectorSource.loadFeatures(extent, resolution, projection);
    /**
     * @param {import("../../Feature.js").default} feature Feature.
     * @this {CanvasVectorLayerRenderer}
     */
    var render = function(feature) {
      var styles;
      var styleFunction = feature.getStyleFunction() || vectorLayer.getStyleFunction();
      if (styleFunction) {
        styles = styleFunction(feature, resolution);
      }
      if (styles) {
        var dirty = this.renderFeature(
          feature, resolution, pixelRatio, styles, replayGroup);
        this.dirty_ = this.dirty_ || dirty;
      }
    }.bind(this);
    if (vectorLayerRenderOrder) {
      /** @type {Array<import("../../Feature.js").default>} */
      var features = [];
      vectorSource.forEachFeatureInExtent(extent,
        /**
         * @param {import("../../Feature.js").default} feature Feature.
         */
        function(feature) {
          features.push(feature);
        });
      features.sort(vectorLayerRenderOrder);
      for (var i = 0, ii = features.length; i < ii; ++i) {
        render(features[i]);
      }
    } else {
      vectorSource.forEachFeatureInExtent(extent, render);
    }
    replayGroup.finish();

    this.renderedResolution_ = resolution;
    this.renderedRevision_ = vectorLayerRevision;
    this.renderedRenderOrder_ = vectorLayerRenderOrder;
    this.renderedExtent_ = extent;
    this.replayGroup_ = replayGroup;

    this.replayGroupChanged = true;
    return true;
  };

  /**
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
   * @param {import("../../render/canvas/ReplayGroup.js").default} replayGroup Replay group.
   * @return {boolean} `true` if an image is loading.
   */
  CanvasVectorLayerRenderer.prototype.renderFeature = function renderFeature$1 (feature, resolution, pixelRatio, styles, replayGroup) {
    if (!styles) {
      return false;
    }
    var loading = false;
    if (Array.isArray(styles)) {
      for (var i = 0, ii = styles.length; i < ii; ++i) {
        loading = Object(_vector_js__WEBPACK_IMPORTED_MODULE_12__["renderFeature"])(
          replayGroup, feature, styles[i],
          Object(_vector_js__WEBPACK_IMPORTED_MODULE_12__["getSquaredTolerance"])(resolution, pixelRatio),
          this.handleStyleImageChange_, this) || loading;
      }
    } else {
      loading = Object(_vector_js__WEBPACK_IMPORTED_MODULE_12__["renderFeature"])(
        replayGroup, feature, styles,
        Object(_vector_js__WEBPACK_IMPORTED_MODULE_12__["getSquaredTolerance"])(resolution, pixelRatio),
        this.handleStyleImageChange_, this);
    }
    return loading;
  };

  return CanvasVectorLayerRenderer;
}(_Layer_js__WEBPACK_IMPORTED_MODULE_11__["default"]));


/**
 * Determine if this renderer handles the provided layer.
 * @param {import("../../layer/Layer.js").default} layer The candidate layer.
 * @return {boolean} The renderer can render the layer.
 */
CanvasVectorLayerRenderer['handles'] = function(layer) {
  return layer.getType() === _LayerType_js__WEBPACK_IMPORTED_MODULE_1__["default"].VECTOR;
};


/**
 * Create a layer renderer.
 * @param {import("../Map.js").default} mapRenderer The map renderer.
 * @param {import("../../layer/Layer.js").default} layer The layer to be rendererd.
 * @return {CanvasVectorLayerRenderer} The layer renderer.
 */
CanvasVectorLayerRenderer['create'] = function(mapRenderer, layer) {
  return new CanvasVectorLayerRenderer(/** @type {import("../../layer/Vector.js").default} */ (layer));
};


/* harmony default export */ __webpack_exports__["default"] = (CanvasVectorLayerRenderer);

//# sourceMappingURL=VectorLayer.js.map

/***/ }),

/***/ "./node_modules/ol/renderer/canvas/VectorTileLayer.js":
/*!************************************************************!*\
  !*** ./node_modules/ol/renderer/canvas/VectorTileLayer.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _LayerType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../LayerType.js */ "./node_modules/ol/LayerType.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../ViewHint.js */ "./node_modules/ol/ViewHint.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! rbush */ "./node_modules/rbush/index.js");
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(rbush__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _layer_VectorTileRenderType_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../layer/VectorTileRenderType.js */ "./node_modules/ol/layer/VectorTileRenderType.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _proj_Units_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../proj/Units.js */ "./node_modules/ol/proj/Units.js");
/* harmony import */ var _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../render/ReplayType.js */ "./node_modules/ol/render/ReplayType.js");
/* harmony import */ var _render_canvas_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../render/canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _render_canvas_ReplayGroup_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../render/canvas/ReplayGroup.js */ "./node_modules/ol/render/canvas/ReplayGroup.js");
/* harmony import */ var _render_replay_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../render/replay.js */ "./node_modules/ol/render/replay.js");
/* harmony import */ var _TileLayer_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./TileLayer.js */ "./node_modules/ol/renderer/canvas/TileLayer.js");
/* harmony import */ var _vector_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../vector.js */ "./node_modules/ol/renderer/vector.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/renderer/canvas/VectorTileLayer
 */





















/**
 * @type {!Object<string, Array<import("../../render/ReplayType.js").default>>}
 */
var IMAGE_REPLAYS = {
  'image': [_render_ReplayType_js__WEBPACK_IMPORTED_MODULE_12__["default"].POLYGON, _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_12__["default"].CIRCLE,
    _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_12__["default"].LINE_STRING, _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_12__["default"].IMAGE, _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_12__["default"].TEXT],
  'hybrid': [_render_ReplayType_js__WEBPACK_IMPORTED_MODULE_12__["default"].POLYGON, _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_12__["default"].LINE_STRING]
};


/**
 * @type {!Object<string, Array<import("../../render/ReplayType.js").default>>}
 */
var VECTOR_REPLAYS = {
  'image': [_render_ReplayType_js__WEBPACK_IMPORTED_MODULE_12__["default"].DEFAULT],
  'hybrid': [_render_ReplayType_js__WEBPACK_IMPORTED_MODULE_12__["default"].IMAGE, _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_12__["default"].TEXT, _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_12__["default"].DEFAULT],
  'vector': _render_replay_js__WEBPACK_IMPORTED_MODULE_15__["ORDER"]
};


/**
 * @classdesc
 * Canvas renderer for vector tile layers.
 * @api
 */
var CanvasVectorTileLayerRenderer = /*@__PURE__*/(function (CanvasTileLayerRenderer) {
  function CanvasVectorTileLayerRenderer(layer) {

    CanvasTileLayerRenderer.call(this, layer, true);

    /**
     * Declutter tree.
     * @private
     */
    this.declutterTree_ = layer.getDeclutter() ? rbush__WEBPACK_IMPORTED_MODULE_7___default()(9, undefined) : null;

    /**
     * @private
     * @type {boolean}
     */
    this.dirty_ = false;

    /**
     * @private
     * @type {number}
     */
    this.renderedLayerRevision_;

    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */
    this.tmpTransform_ = Object(_transform_js__WEBPACK_IMPORTED_MODULE_18__["create"])();

    var renderMode = layer.getRenderMode();

    // Use lower resolution for pure vector rendering. Closest resolution otherwise.
    this.zDirection = renderMode === _layer_VectorTileRenderType_js__WEBPACK_IMPORTED_MODULE_9__["default"].VECTOR ? 1 : 0;

    if (renderMode !== _layer_VectorTileRenderType_js__WEBPACK_IMPORTED_MODULE_9__["default"].VECTOR) {
      this.context = Object(_dom_js__WEBPACK_IMPORTED_MODULE_4__["createCanvasContext2D"])();
    }


    Object(_events_js__WEBPACK_IMPORTED_MODULE_5__["listen"])(_render_canvas_js__WEBPACK_IMPORTED_MODULE_13__["labelCache"], _events_EventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].CLEAR, this.handleFontsChanged_, this);

  }

  if ( CanvasTileLayerRenderer ) CanvasVectorTileLayerRenderer.__proto__ = CanvasTileLayerRenderer;
  CanvasVectorTileLayerRenderer.prototype = Object.create( CanvasTileLayerRenderer && CanvasTileLayerRenderer.prototype );
  CanvasVectorTileLayerRenderer.prototype.constructor = CanvasVectorTileLayerRenderer;

  /**
   * @inheritDoc
   */
  CanvasVectorTileLayerRenderer.prototype.disposeInternal = function disposeInternal () {
    Object(_events_js__WEBPACK_IMPORTED_MODULE_5__["unlisten"])(_render_canvas_js__WEBPACK_IMPORTED_MODULE_13__["labelCache"], _events_EventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].CLEAR, this.handleFontsChanged_, this);
    CanvasTileLayerRenderer.prototype.disposeInternal.call(this);
  };

  /**
   * @inheritDoc
   */
  CanvasVectorTileLayerRenderer.prototype.getTile = function getTile (z, x, y, pixelRatio, projection) {
    var tile = CanvasTileLayerRenderer.prototype.getTile.call(this, z, x, y, pixelRatio, projection);
    if (tile.getState() === _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED) {
      this.createReplayGroup_(/** @type {import("../../VectorImageTile.js").default} */ (tile), pixelRatio, projection);
      if (this.context) {
        this.renderTileImage_(/** @type {import("../../VectorImageTile.js").default} */ (tile), pixelRatio, projection);
      }
    }
    return tile;
  };

  /**
   * @inheritDoc
   */
  CanvasVectorTileLayerRenderer.prototype.getTileImage = function getTileImage (tile) {
    var tileLayer = /** @type {import("../../layer/Tile.js").default} */ (this.getLayer());
    return /** @type {import("../../VectorImageTile.js").default} */ (tile).getImage(tileLayer);
  };

  /**
   * @inheritDoc
   */
  CanvasVectorTileLayerRenderer.prototype.prepareFrame = function prepareFrame (frameState, layerState) {
    var layer = /** @type {import("../../layer/Vector.js").default} */ (this.getLayer());
    var layerRevision = layer.getRevision();
    if (this.renderedLayerRevision_ != layerRevision) {
      this.renderedTiles.length = 0;
    }
    this.renderedLayerRevision_ = layerRevision;
    return CanvasTileLayerRenderer.prototype.prepareFrame.call(this, frameState, layerState);
  };

  /**
   * @param {import("../../VectorImageTile.js").default} tile Tile.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection.js").default} projection Projection.
   * @private
   */
  CanvasVectorTileLayerRenderer.prototype.createReplayGroup_ = function createReplayGroup_ (tile, pixelRatio, projection) {
    var this$1 = this;

    var layer = /** @type {import("../../layer/Vector.js").default} */ (this.getLayer());
    var revision = layer.getRevision();
    var renderOrder = /** @type {import("../../render.js").OrderFunction} */ (layer.getRenderOrder()) || null;

    var replayState = tile.getReplayState(layer);
    if (!replayState.dirty && replayState.renderedRevision == revision &&
        replayState.renderedRenderOrder == renderOrder) {
      return;
    }

    var source = /** @type {import("../../source/VectorTile.js").default} */ (layer.getSource());
    var sourceTileGrid = source.getTileGrid();
    var tileGrid = source.getTileGridForProjection(projection);
    var resolution = tileGrid.getResolution(tile.tileCoord[0]);
    var tileExtent = tile.extent;

    var loop = function ( t, tt ) {
      var sourceTile = tile.getTile(tile.tileKeys[t]);
      if (sourceTile.getState() != _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED) {
        return;
      }

      var sourceTileCoord = sourceTile.tileCoord;
      var sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);
      var sharedExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_8__["getIntersection"])(tileExtent, sourceTileExtent);
      var bufferedExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_8__["equals"])(sourceTileExtent, sharedExtent) ? null :
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_8__["buffer"])(sharedExtent, layer.getRenderBuffer() * resolution, this$1.tmpExtent);
      var tileProjection = sourceTile.getProjection();
      var reproject = false;
      if (!Object(_proj_js__WEBPACK_IMPORTED_MODULE_10__["equivalent"])(projection, tileProjection)) {
        reproject = true;
        sourceTile.setProjection(projection);
      }
      replayState.dirty = false;
      var replayGroup = new _render_canvas_ReplayGroup_js__WEBPACK_IMPORTED_MODULE_14__["default"](0, sharedExtent, resolution,
        pixelRatio, source.getOverlaps(), this$1.declutterTree_, layer.getRenderBuffer());
      var squaredTolerance = Object(_vector_js__WEBPACK_IMPORTED_MODULE_17__["getSquaredTolerance"])(resolution, pixelRatio);

      /**
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       * @this {CanvasVectorTileLayerRenderer}
       */
      var render = function(feature) {
        var styles;
        var styleFunction = feature.getStyleFunction() || layer.getStyleFunction();
        if (styleFunction) {
          styles = styleFunction(feature, resolution);
        }
        if (styles) {
          var dirty = this.renderFeature(feature, squaredTolerance, styles, replayGroup);
          this.dirty_ = this.dirty_ || dirty;
          replayState.dirty = replayState.dirty || dirty;
        }
      };

      var features = sourceTile.getFeatures();
      if (renderOrder && renderOrder !== replayState.renderedRenderOrder) {
        features.sort(renderOrder);
      }
      for (var i = 0, ii = features.length; i < ii; ++i) {
        var feature = features[i];
        if (reproject) {
          if (tileProjection.getUnits() == _proj_Units_js__WEBPACK_IMPORTED_MODULE_11__["default"].TILE_PIXELS) {
            // projected tile extent
            tileProjection.setWorldExtent(sourceTileExtent);
            // tile extent in tile pixel space
            tileProjection.setExtent(sourceTile.getExtent());
          }
          feature.getGeometry().transform(tileProjection, projection);
        }
        if (!bufferedExtent || Object(_extent_js__WEBPACK_IMPORTED_MODULE_8__["intersects"])(bufferedExtent, feature.getGeometry().getExtent())) {
          render.call(this$1, feature);
        }
      }
      replayGroup.finish();
      sourceTile.setReplayGroup(layer, tile.tileCoord.toString(), replayGroup);
    };

    for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) loop( t, tt );
    replayState.renderedRevision = revision;
    replayState.renderedRenderOrder = renderOrder;
  };

  /**
   * @inheritDoc
   */
  CanvasVectorTileLayerRenderer.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate (coordinate, frameState, hitTolerance, callback, thisArg) {
    var resolution = frameState.viewState.resolution;
    var rotation = frameState.viewState.rotation;
    hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;
    var layer = this.getLayer();
    /** @type {!Object<string, boolean>} */
    var features = {};

    var renderedTiles = /** @type {Array<import("../../VectorImageTile.js").default>} */ (this.renderedTiles);

    var bufferedExtent, found;
    var i, ii;
    for (i = 0, ii = renderedTiles.length; i < ii; ++i) {
      var tile = renderedTiles[i];
      bufferedExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_8__["buffer"])(tile.extent, hitTolerance * resolution, bufferedExtent);
      if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_8__["containsCoordinate"])(bufferedExtent, coordinate)) {
        continue;
      }
      for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) {
        var sourceTile = tile.getTile(tile.tileKeys[t]);
        if (sourceTile.getState() != _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED) {
          continue;
        }
        var replayGroup = /** @type {CanvasReplayGroup} */ (sourceTile.getReplayGroup(layer,
          tile.tileCoord.toString()));
        found = found || replayGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, {},
          /**
           * @param {import("../../Feature.js").FeatureLike} feature Feature.
           * @return {?} Callback result.
           */
          function(feature) {
            var key = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature);
            if (!(key in features)) {
              features[key] = true;
              return callback.call(thisArg, feature, layer);
            }
          }, null);
      }
    }
    return found;
  };

  /**
   * @param {import("../../VectorTile.js").default} tile Tile.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @return {import("../../transform.js").Transform} transform Transform.
   * @private
   */
  CanvasVectorTileLayerRenderer.prototype.getReplayTransform_ = function getReplayTransform_ (tile, frameState) {
    var layer = this.getLayer();
    var source = /** @type {import("../../source/VectorTile.js").default} */ (layer.getSource());
    var tileGrid = source.getTileGrid();
    var tileCoord = tile.tileCoord;
    var tileResolution = tileGrid.getResolution(tileCoord[0]);
    var viewState = frameState.viewState;
    var pixelRatio = frameState.pixelRatio;
    var renderResolution = viewState.resolution / pixelRatio;
    var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);
    var center = viewState.center;
    var origin = Object(_extent_js__WEBPACK_IMPORTED_MODULE_8__["getTopLeft"])(tileExtent);
    var size = frameState.size;
    var offsetX = Math.round(pixelRatio * size[0] / 2);
    var offsetY = Math.round(pixelRatio * size[1] / 2);
    return Object(_transform_js__WEBPACK_IMPORTED_MODULE_18__["compose"])(this.tmpTransform_,
      offsetX, offsetY,
      tileResolution / renderResolution, tileResolution / renderResolution,
      viewState.rotation,
      (origin[0] - center[0]) / tileResolution,
      (center[1] - origin[1]) / tileResolution);
  };

  /**
   * @param {import("../../events/Event.js").default} event Event.
   */
  CanvasVectorTileLayerRenderer.prototype.handleFontsChanged_ = function handleFontsChanged_ (event) {
    var layer = this.getLayer();
    if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {
      layer.changed();
    }
  };

  /**
   * Handle changes in image style state.
   * @param {import("../../events/Event.js").default} event Image style change event.
   * @private
   */
  CanvasVectorTileLayerRenderer.prototype.handleStyleImageChange_ = function handleStyleImageChange_ (event) {
    this.renderIfReadyAndVisible();
  };

  /**
   * @inheritDoc
   */
  CanvasVectorTileLayerRenderer.prototype.postCompose = function postCompose (context, frameState, layerState) {
    var layer = /** @type {import("../../layer/Vector.js").default} */ (this.getLayer());
    var renderMode = layer.getRenderMode();
    if (renderMode != _layer_VectorTileRenderType_js__WEBPACK_IMPORTED_MODULE_9__["default"].IMAGE) {
      var declutterReplays = layer.getDeclutter() ? {} : null;
      var source = /** @type {import("../../source/VectorTile.js").default} */ (layer.getSource());
      var replayTypes = VECTOR_REPLAYS[renderMode];
      var pixelRatio = frameState.pixelRatio;
      var rotation = frameState.viewState.rotation;
      var size = frameState.size;
      var offsetX, offsetY;
      if (rotation) {
        offsetX = Math.round(pixelRatio * size[0] / 2);
        offsetY = Math.round(pixelRatio * size[1] / 2);
        Object(_render_canvas_js__WEBPACK_IMPORTED_MODULE_13__["rotateAtOffset"])(context, -rotation, offsetX, offsetY);
      }
      if (declutterReplays) {
        this.declutterTree_.clear();
      }
      var viewHints = frameState.viewHints;
      var snapToPixel = !(viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_3__["default"].ANIMATING] || viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_3__["default"].INTERACTING]);
      var tiles = this.renderedTiles;
      var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);
      var clips = [];
      var zs = [];
      for (var i = tiles.length - 1; i >= 0; --i) {
        var tile = /** @type {import("../../VectorImageTile.js").default} */ (tiles[i]);
        if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ABORT) {
          continue;
        }
        var tileCoord = tile.tileCoord;
        var worldOffset = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent)[0] - tile.extent[0];
        var transform = undefined;
        for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) {
          var sourceTile = tile.getTile(tile.tileKeys[t]);
          if (sourceTile.getState() != _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED) {
            continue;
          }
          var replayGroup = /** @type {CanvasReplayGroup} */ (sourceTile.getReplayGroup(layer, tileCoord.toString()));
          if (!replayGroup || !replayGroup.hasReplays(replayTypes)) {
            // sourceTile was not yet loaded when this.createReplayGroup_() was
            // called, or it has no replays of the types we want to render
            continue;
          }
          if (!transform) {
            transform = this.getTransform(frameState, worldOffset);
          }
          var currentZ = sourceTile.tileCoord[0];
          var currentClip = replayGroup.getClipCoords(transform);
          context.save();
          context.globalAlpha = layerState.opacity;
          // Create a clip mask for regions in this low resolution tile that are
          // already filled by a higher resolution tile
          for (var j = 0, jj = clips.length; j < jj; ++j) {
            var clip = clips[j];
            if (currentZ < zs[j]) {
              context.beginPath();
              // counter-clockwise (outer ring) for current tile
              context.moveTo(currentClip[0], currentClip[1]);
              context.lineTo(currentClip[2], currentClip[3]);
              context.lineTo(currentClip[4], currentClip[5]);
              context.lineTo(currentClip[6], currentClip[7]);
              // clockwise (inner ring) for higher resolution tile
              context.moveTo(clip[6], clip[7]);
              context.lineTo(clip[4], clip[5]);
              context.lineTo(clip[2], clip[3]);
              context.lineTo(clip[0], clip[1]);
              context.clip();
            }
          }
          replayGroup.replay(context, transform, rotation, {}, snapToPixel, replayTypes, declutterReplays);
          context.restore();
          clips.push(currentClip);
          zs.push(currentZ);
        }
      }
      if (declutterReplays) {
        Object(_render_canvas_ReplayGroup_js__WEBPACK_IMPORTED_MODULE_14__["replayDeclutter"])(declutterReplays, context, rotation, snapToPixel);
      }
      if (rotation) {
        Object(_render_canvas_js__WEBPACK_IMPORTED_MODULE_13__["rotateAtOffset"])(context, rotation,
          /** @type {number} */ (offsetX), /** @type {number} */ (offsetY));
      }
    }
    CanvasTileLayerRenderer.prototype.postCompose.call(this, context, frameState, layerState);
  };

  /**
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
   * @param {import("../../render/canvas/ReplayGroup.js").default} replayGroup Replay group.
   * @return {boolean} `true` if an image is loading.
   */
  CanvasVectorTileLayerRenderer.prototype.renderFeature = function renderFeature$1 (feature, squaredTolerance, styles, replayGroup) {
    if (!styles) {
      return false;
    }
    var loading = false;
    if (Array.isArray(styles)) {
      for (var i = 0, ii = styles.length; i < ii; ++i) {
        loading = Object(_vector_js__WEBPACK_IMPORTED_MODULE_17__["renderFeature"])(
          replayGroup, feature, styles[i], squaredTolerance,
          this.handleStyleImageChange_, this) || loading;
      }
    } else {
      loading = Object(_vector_js__WEBPACK_IMPORTED_MODULE_17__["renderFeature"])(
        replayGroup, feature, styles, squaredTolerance,
        this.handleStyleImageChange_, this);
    }
    return loading;
  };

  /**
   * @param {import("../../VectorImageTile.js").default} tile Tile.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection.js").default} projection Projection.
   * @private
   */
  CanvasVectorTileLayerRenderer.prototype.renderTileImage_ = function renderTileImage_ (tile, pixelRatio, projection) {
    var layer = /** @type {import("../../layer/Vector.js").default} */ (this.getLayer());
    var replayState = tile.getReplayState(layer);
    var revision = layer.getRevision();
    var replays = IMAGE_REPLAYS[layer.getRenderMode()];
    if (replays && replayState.renderedTileRevision !== revision) {
      replayState.renderedTileRevision = revision;
      var tileCoord = tile.wrappedTileCoord;
      var z = tileCoord[0];
      var source = /** @type {import("../../source/VectorTile.js").default} */ (layer.getSource());
      var tileGrid = source.getTileGridForProjection(projection);
      var resolution = tileGrid.getResolution(z);
      var context = tile.getContext(layer);
      var size = source.getTilePixelSize(z, pixelRatio, projection);
      context.canvas.width = size[0];
      context.canvas.height = size[1];
      var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);
      for (var i = 0, ii = tile.tileKeys.length; i < ii; ++i) {
        var sourceTile = tile.getTile(tile.tileKeys[i]);
        if (sourceTile.getState() != _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED) {
          continue;
        }
        var pixelScale = pixelRatio / resolution;
        var transform = Object(_transform_js__WEBPACK_IMPORTED_MODULE_18__["reset"])(this.tmpTransform_);
        Object(_transform_js__WEBPACK_IMPORTED_MODULE_18__["scale"])(transform, pixelScale, -pixelScale);
        Object(_transform_js__WEBPACK_IMPORTED_MODULE_18__["translate"])(transform, -tileExtent[0], -tileExtent[3]);
        var replayGroup = /** @type {CanvasReplayGroup} */ (sourceTile.getReplayGroup(layer,
          tile.tileCoord.toString()));
        replayGroup.replay(context, transform, 0, {}, true, replays);
      }
    }
  };

  return CanvasVectorTileLayerRenderer;
}(_TileLayer_js__WEBPACK_IMPORTED_MODULE_16__["default"]));


/**
 * Determine if this renderer handles the provided layer.
 * @param {import("../../layer/Layer.js").default} layer The candidate layer.
 * @return {boolean} The renderer can render the layer.
 */
CanvasVectorTileLayerRenderer['handles'] = function(layer) {
  return layer.getType() === _LayerType_js__WEBPACK_IMPORTED_MODULE_1__["default"].VECTOR_TILE;
};


/**
 * Create a layer renderer.
 * @param {import("../Map.js").default} mapRenderer The map renderer.
 * @param {import("../../layer/Layer.js").default} layer The layer to be rendererd.
 * @return {CanvasVectorTileLayerRenderer} The layer renderer.
 */
CanvasVectorTileLayerRenderer['create'] = function(mapRenderer, layer) {
  return new CanvasVectorTileLayerRenderer(/** @type {import("../../layer/VectorTile.js").default} */ (layer));
};


/* harmony default export */ __webpack_exports__["default"] = (CanvasVectorTileLayerRenderer);

//# sourceMappingURL=VectorTileLayer.js.map

/***/ }),

/***/ "./node_modules/ol/renderer/vector.js":
/*!********************************************!*\
  !*** ./node_modules/ol/renderer/vector.js ***!
  \********************************************/
/*! exports provided: defaultOrder, getSquaredTolerance, getTolerance, renderFeature */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultOrder", function() { return defaultOrder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSquaredTolerance", function() { return getSquaredTolerance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTolerance", function() { return getTolerance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderFeature", function() { return renderFeature; });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ImageState.js */ "./node_modules/ol/ImageState.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../render/ReplayType.js */ "./node_modules/ol/render/ReplayType.js");
/**
 * @module ol/renderer/vector
 */






/**
 * Tolerance for geometry simplification in device pixels.
 * @type {number}
 */
var SIMPLIFY_TOLERANCE = 0.5;


/**
 * @const
 * @type {Object<import("../geom/GeometryType.js").default,
 *                function(import("../render/ReplayGroup.js").default, import("../geom/Geometry.js").default,
 *                         import("../style/Style.js").default, Object)>}
 */
var GEOMETRY_RENDERERS = {
  'Point': renderPointGeometry,
  'LineString': renderLineStringGeometry,
  'Polygon': renderPolygonGeometry,
  'MultiPoint': renderMultiPointGeometry,
  'MultiLineString': renderMultiLineStringGeometry,
  'MultiPolygon': renderMultiPolygonGeometry,
  'GeometryCollection': renderGeometryCollectionGeometry,
  'Circle': renderCircleGeometry
};


/**
 * @param {import("../Feature.js").FeatureLike} feature1 Feature 1.
 * @param {import("../Feature.js").FeatureLike} feature2 Feature 2.
 * @return {number} Order.
 */
function defaultOrder(feature1, feature2) {
  return parseInt(Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature1), 10) - parseInt(Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature2), 10);
}


/**
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Squared pixel tolerance.
 */
function getSquaredTolerance(resolution, pixelRatio) {
  var tolerance = getTolerance(resolution, pixelRatio);
  return tolerance * tolerance;
}


/**
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Pixel tolerance.
 */
function getTolerance(resolution, pixelRatio) {
  return SIMPLIFY_TOLERANCE * resolution / pixelRatio;
}


/**
 * @param {import("../render/ReplayGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/Circle.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 */
function renderCircleGeometry(replayGroup, geometry, style, feature) {
  var fillStyle = style.getFill();
  var strokeStyle = style.getStroke();
  if (fillStyle || strokeStyle) {
    var circleReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].CIRCLE);
    circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    circleReplay.drawCircle(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));
    textReplay.drawText(geometry, feature);
  }
}


/**
 * @param {import("../render/ReplayGroup.js").default} replayGroup Replay group.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../style/Style.js").default} style Style.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {function(this: T, import("../events/Event.js").default)} listener Listener function.
 * @param {T} thisArg Value to use as `this` when executing `listener`.
 * @return {boolean} `true` if style is loading.
 * @template T
 */
function renderFeature(replayGroup, feature, style, squaredTolerance, listener, thisArg) {
  var loading = false;
  var imageStyle = style.getImage();
  if (imageStyle) {
    var imageState = imageStyle.getImageState();
    if (imageState == _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED || imageState == _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR) {
      imageStyle.unlistenImageChange(listener, thisArg);
    } else {
      if (imageState == _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE) {
        imageStyle.load();
      }
      imageState = imageStyle.getImageState();
      imageStyle.listenImageChange(listener, thisArg);
      loading = true;
    }
  }
  renderFeatureInternal(replayGroup, feature, style, squaredTolerance);

  return loading;
}


/**
 * @param {import("../render/ReplayGroup.js").default} replayGroup Replay group.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../style/Style.js").default} style Style.
 * @param {number} squaredTolerance Squared tolerance.
 */
function renderFeatureInternal(replayGroup, feature, style, squaredTolerance) {
  var geometry = style.getGeometryFunction()(feature);
  if (!geometry) {
    return;
  }
  var simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);
  var renderer = style.getRenderer();
  if (renderer) {
    renderGeometry(replayGroup, simplifiedGeometry, style, feature);
  } else {
    var geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];
    geometryRenderer(replayGroup, simplifiedGeometry, style, feature);
  }
}


/**
 * @param {import("../render/ReplayGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/Geometry.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 */
function renderGeometry(replayGroup, geometry, style, feature) {
  if (geometry.getType() == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__["default"].GEOMETRY_COLLECTION) {
    var geometries = /** @type {import("../geom/GeometryCollection.js").default} */ (geometry).getGeometries();
    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      renderGeometry(replayGroup, geometries[i], style, feature);
    }
    return;
  }
  var replay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].DEFAULT);
  replay.drawCustom(/** @type {import("../geom/SimpleGeometry.js").default} */ (geometry), feature, style.getRenderer());
}


/**
 * @param {import("../render/ReplayGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 */
function renderGeometryCollectionGeometry(replayGroup, geometry, style, feature) {
  var geometries = geometry.getGeometriesArray();
  var i, ii;
  for (i = 0, ii = geometries.length; i < ii; ++i) {
    var geometryRenderer =
        GEOMETRY_RENDERERS[geometries[i].getType()];
    geometryRenderer(replayGroup, geometries[i], style, feature);
  }
}


/**
 * @param {import("../render/ReplayGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/LineString.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 */
function renderLineStringGeometry(replayGroup, geometry, style, feature) {
  var strokeStyle = style.getStroke();
  if (strokeStyle) {
    var lineStringReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].LINE_STRING);
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawLineString(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));
    textReplay.drawText(geometry, feature);
  }
}


/**
 * @param {import("../render/ReplayGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/MultiLineString.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 */
function renderMultiLineStringGeometry(replayGroup, geometry, style, feature) {
  var strokeStyle = style.getStroke();
  if (strokeStyle) {
    var lineStringReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].LINE_STRING);
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawMultiLineString(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));
    textReplay.drawText(geometry, feature);
  }
}


/**
 * @param {import("../render/ReplayGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 */
function renderMultiPolygonGeometry(replayGroup, geometry, style, feature) {
  var fillStyle = style.getFill();
  var strokeStyle = style.getStroke();
  if (strokeStyle || fillStyle) {
    var polygonReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POLYGON);
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawMultiPolygon(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));
    textReplay.drawText(geometry, feature);
  }
}


/**
 * @param {import("../render/ReplayGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/Point.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 */
function renderPointGeometry(replayGroup, geometry, style, feature) {
  var imageStyle = style.getImage();
  if (imageStyle) {
    if (imageStyle.getImageState() != _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED) {
      return;
    }
    var imageReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].IMAGE);
    imageReplay.setImageStyle(imageStyle, replayGroup.addDeclutter(false));
    imageReplay.drawPoint(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(!!imageStyle));
    textReplay.drawText(geometry, feature);
  }
}


/**
 * @param {import("../render/ReplayGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/MultiPoint.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 */
function renderMultiPointGeometry(replayGroup, geometry, style, feature) {
  var imageStyle = style.getImage();
  if (imageStyle) {
    if (imageStyle.getImageState() != _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED) {
      return;
    }
    var imageReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].IMAGE);
    imageReplay.setImageStyle(imageStyle, replayGroup.addDeclutter(false));
    imageReplay.drawMultiPoint(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(!!imageStyle));
    textReplay.drawText(geometry, feature);
  }
}


/**
 * @param {import("../render/ReplayGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/Polygon.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 */
function renderPolygonGeometry(replayGroup, geometry, style, feature) {
  var fillStyle = style.getFill();
  var strokeStyle = style.getStroke();
  if (fillStyle || strokeStyle) {
    var polygonReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POLYGON);
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawPolygon(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));
    textReplay.drawText(geometry, feature);
  }
}

//# sourceMappingURL=vector.js.map

/***/ }),

/***/ "./node_modules/ol/reproj.js":
/*!***********************************!*\
  !*** ./node_modules/ol/reproj.js ***!
  \***********************************/
/*! exports provided: calculateSourceResolution, render */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calculateSourceResolution", function() { return calculateSourceResolution; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./proj.js */ "./node_modules/ol/proj.js");
/**
 * @module ol/reproj
 */






/**
 * Calculates ideal resolution to use from the source in order to achieve
 * pixel mapping as close as possible to 1:1 during reprojection.
 * The resolution is calculated regardless of what resolutions
 * are actually available in the dataset (TileGrid, Image, ...).
 *
 * @param {import("./proj/Projection.js").default} sourceProj Source projection.
 * @param {import("./proj/Projection.js").default} targetProj Target projection.
 * @param {import("./coordinate.js").Coordinate} targetCenter Target center.
 * @param {number} targetResolution Target resolution.
 * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
 */
function calculateSourceResolution(sourceProj, targetProj,
  targetCenter, targetResolution) {

  var sourceCenter = Object(_proj_js__WEBPACK_IMPORTED_MODULE_3__["transform"])(targetCenter, targetProj, sourceProj);

  // calculate the ideal resolution of the source data
  var sourceResolution = Object(_proj_js__WEBPACK_IMPORTED_MODULE_3__["getPointResolution"])(targetProj, targetResolution, targetCenter);

  var targetMetersPerUnit = targetProj.getMetersPerUnit();
  if (targetMetersPerUnit !== undefined) {
    sourceResolution *= targetMetersPerUnit;
  }
  var sourceMetersPerUnit = sourceProj.getMetersPerUnit();
  if (sourceMetersPerUnit !== undefined) {
    sourceResolution /= sourceMetersPerUnit;
  }

  // Based on the projection properties, the point resolution at the specified
  // coordinates may be slightly different. We need to reverse-compensate this
  // in order to achieve optimal results.

  var sourceExtent = sourceProj.getExtent();
  if (!sourceExtent || Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["containsCoordinate"])(sourceExtent, sourceCenter)) {
    var compensationFactor = Object(_proj_js__WEBPACK_IMPORTED_MODULE_3__["getPointResolution"])(sourceProj, sourceResolution, sourceCenter) /
        sourceResolution;
    if (isFinite(compensationFactor) && compensationFactor > 0) {
      sourceResolution /= compensationFactor;
    }
  }

  return sourceResolution;
}


/**
 * Enlarge the clipping triangle point by 1 pixel to ensure the edges overlap
 * in order to mask gaps caused by antialiasing.
 *
 * @param {number} centroidX Centroid of the triangle (x coordinate in pixels).
 * @param {number} centroidY Centroid of the triangle (y coordinate in pixels).
 * @param {number} x X coordinate of the point (in pixels).
 * @param {number} y Y coordinate of the point (in pixels).
 * @return {import("./coordinate.js").Coordinate} New point 1 px farther from the centroid.
 */
function enlargeClipPoint(centroidX, centroidY, x, y) {
  var dX = x - centroidX;
  var dY = y - centroidY;
  var distance = Math.sqrt(dX * dX + dY * dY);
  return [Math.round(x + dX / distance), Math.round(y + dY / distance)];
}


/**
 * Renders the source data into new canvas based on the triangulation.
 *
 * @param {number} width Width of the canvas.
 * @param {number} height Height of the canvas.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} sourceResolution Source resolution.
 * @param {import("./extent.js").Extent} sourceExtent Extent of the data source.
 * @param {number} targetResolution Target resolution.
 * @param {import("./extent.js").Extent} targetExtent Target extent.
 * @param {import("./reproj/Triangulation.js").default} triangulation
 * Calculated triangulation.
 * @param {Array<{extent: import("./extent.js").Extent,
 *                 image: (HTMLCanvasElement|HTMLImageElement|HTMLVideoElement)}>} sources
 * Array of sources.
 * @param {number} gutter Gutter of the sources.
 * @param {boolean=} opt_renderEdges Render reprojection edges.
 * @return {HTMLCanvasElement} Canvas with reprojected data.
 */
function render(width, height, pixelRatio,
  sourceResolution, sourceExtent, targetResolution, targetExtent,
  triangulation, sources, gutter, opt_renderEdges) {

  var context = Object(_dom_js__WEBPACK_IMPORTED_MODULE_0__["createCanvasContext2D"])(Math.round(pixelRatio * width),
    Math.round(pixelRatio * height));

  if (sources.length === 0) {
    return context.canvas;
  }

  context.scale(pixelRatio, pixelRatio);

  var sourceDataExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["createEmpty"])();
  sources.forEach(function(src, i, arr) {
    Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["extend"])(sourceDataExtent, src.extent);
  });

  var canvasWidthInUnits = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getWidth"])(sourceDataExtent);
  var canvasHeightInUnits = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getHeight"])(sourceDataExtent);
  var stitchContext = Object(_dom_js__WEBPACK_IMPORTED_MODULE_0__["createCanvasContext2D"])(
    Math.round(pixelRatio * canvasWidthInUnits / sourceResolution),
    Math.round(pixelRatio * canvasHeightInUnits / sourceResolution));

  var stitchScale = pixelRatio / sourceResolution;

  sources.forEach(function(src, i, arr) {
    var xPos = src.extent[0] - sourceDataExtent[0];
    var yPos = -(src.extent[3] - sourceDataExtent[3]);
    var srcWidth = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getWidth"])(src.extent);
    var srcHeight = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getHeight"])(src.extent);

    stitchContext.drawImage(
      src.image,
      gutter, gutter,
      src.image.width - 2 * gutter, src.image.height - 2 * gutter,
      xPos * stitchScale, yPos * stitchScale,
      srcWidth * stitchScale, srcHeight * stitchScale);
  });

  var targetTopLeft = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getTopLeft"])(targetExtent);

  triangulation.getTriangles().forEach(function(triangle, i, arr) {
    /* Calculate affine transform (src -> dst)
     * Resulting matrix can be used to transform coordinate
     * from `sourceProjection` to destination pixels.
     *
     * To optimize number of context calls and increase numerical stability,
     * we also do the following operations:
     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)
     * here before solving the linear system so [ui, vi] are pixel coordinates.
     *
     * Src points: xi, yi
     * Dst points: ui, vi
     * Affine coefficients: aij
     *
     * | x0 y0 1  0  0 0 |   |a00|   |u0|
     * | x1 y1 1  0  0 0 |   |a01|   |u1|
     * | x2 y2 1  0  0 0 | x |a02| = |u2|
     * |  0  0 0 x0 y0 1 |   |a10|   |v0|
     * |  0  0 0 x1 y1 1 |   |a11|   |v1|
     * |  0  0 0 x2 y2 1 |   |a12|   |v2|
     */
    var source = triangle.source;
    var target = triangle.target;
    var x0 = source[0][0], y0 = source[0][1];
    var x1 = source[1][0], y1 = source[1][1];
    var x2 = source[2][0], y2 = source[2][1];
    var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
    var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
    var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
    var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
    var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
    var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;

    // Shift all the source points to improve numerical stability
    // of all the subsequent calculations. The [x0, y0] is used here.
    // This is also used to simplify the linear system.
    var sourceNumericalShiftX = x0;
    var sourceNumericalShiftY = y0;
    x0 = 0;
    y0 = 0;
    x1 -= sourceNumericalShiftX;
    y1 -= sourceNumericalShiftY;
    x2 -= sourceNumericalShiftX;
    y2 -= sourceNumericalShiftY;

    var augmentedMatrix = [
      [x1, y1, 0, 0, u1 - u0],
      [x2, y2, 0, 0, u2 - u0],
      [0, 0, x1, y1, v1 - v0],
      [0, 0, x2, y2, v2 - v0]
    ];
    var affineCoefs = Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["solveLinearSystem"])(augmentedMatrix);
    if (!affineCoefs) {
      return;
    }

    context.save();
    context.beginPath();
    var centroidX = (u0 + u1 + u2) / 3;
    var centroidY = (v0 + v1 + v2) / 3;
    var p0 = enlargeClipPoint(centroidX, centroidY, u0, v0);
    var p1 = enlargeClipPoint(centroidX, centroidY, u1, v1);
    var p2 = enlargeClipPoint(centroidX, centroidY, u2, v2);

    context.moveTo(p1[0], p1[1]);
    context.lineTo(p0[0], p0[1]);
    context.lineTo(p2[0], p2[1]);
    context.clip();

    context.transform(
      affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);

    context.translate(sourceDataExtent[0] - sourceNumericalShiftX,
      sourceDataExtent[3] - sourceNumericalShiftY);

    context.scale(sourceResolution / pixelRatio,
      -sourceResolution / pixelRatio);

    context.drawImage(stitchContext.canvas, 0, 0);
    context.restore();
  });

  if (opt_renderEdges) {
    context.save();

    context.strokeStyle = 'black';
    context.lineWidth = 1;

    triangulation.getTriangles().forEach(function(triangle, i, arr) {
      var target = triangle.target;
      var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
      var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
      var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
      var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
      var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
      var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;

      context.beginPath();
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
      context.closePath();
      context.stroke();
    });

    context.restore();
  }
  return context.canvas;
}

//# sourceMappingURL=reproj.js.map

/***/ }),

/***/ "./node_modules/ol/reproj/Tile.js":
/*!****************************************!*\
  !*** ./node_modules/ol/reproj/Tile.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/ol/reproj/common.js");
/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Tile.js */ "./node_modules/ol/Tile.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _reproj_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../reproj.js */ "./node_modules/ol/reproj.js");
/* harmony import */ var _Triangulation_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Triangulation.js */ "./node_modules/ol/reproj/Triangulation.js");
/**
 * @module ol/reproj/Tile
 */












/**
 * @typedef {function(number, number, number, number) : import("../Tile.js").default} FunctionType
 */


/**
 * @classdesc
 * Class encapsulating single reprojected tile.
 * See {@link module:ol/source/TileImage~TileImage}.
 *
 */
var ReprojTile = /*@__PURE__*/(function (Tile) {
  function ReprojTile(
    sourceProj,
    sourceTileGrid,
    targetProj,
    targetTileGrid,
    tileCoord,
    wrappedTileCoord,
    pixelRatio,
    gutter,
    getTileFunction,
    opt_errorThreshold,
    opt_renderEdges
  ) {
    Tile.call(this, tileCoord, _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE);

    /**
     * @private
     * @type {boolean}
     */
    this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;

    /**
     * @private
     * @type {number}
     */
    this.pixelRatio_ = pixelRatio;

    /**
     * @private
     * @type {number}
     */
    this.gutter_ = gutter;

    /**
     * @private
     * @type {HTMLCanvasElement}
     */
    this.canvas_ = null;

    /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */
    this.sourceTileGrid_ = sourceTileGrid;

    /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */
    this.targetTileGrid_ = targetTileGrid;

    /**
     * @private
     * @type {import("../tilecoord.js").TileCoord}
     */
    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;

    /**
     * @private
     * @type {!Array<import("../Tile.js").default>}
     */
    this.sourceTiles_ = [];

    /**
     * @private
     * @type {Array<import("../events.js").EventsKey>}
     */
    this.sourcesListenerKeys_ = null;

    /**
     * @private
     * @type {number}
     */
    this.sourceZ_ = 0;

    var targetExtent = targetTileGrid.getTileCoordExtent(this.wrappedTileCoord_);
    var maxTargetExtent = this.targetTileGrid_.getExtent();
    var maxSourceExtent = this.sourceTileGrid_.getExtent();

    var limitedTargetExtent = maxTargetExtent ?
      Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getIntersection"])(targetExtent, maxTargetExtent) : targetExtent;

    if (Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getArea"])(limitedTargetExtent) === 0) {
      // Tile is completely outside range -> EMPTY
      // TODO: is it actually correct that the source even creates the tile ?
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY;
      return;
    }

    var sourceProjExtent = sourceProj.getExtent();
    if (sourceProjExtent) {
      if (!maxSourceExtent) {
        maxSourceExtent = sourceProjExtent;
      } else {
        maxSourceExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getIntersection"])(maxSourceExtent, sourceProjExtent);
      }
    }

    var targetResolution = targetTileGrid.getResolution(
      this.wrappedTileCoord_[0]);

    var targetCenter = Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getCenter"])(limitedTargetExtent);
    var sourceResolution = Object(_reproj_js__WEBPACK_IMPORTED_MODULE_7__["calculateSourceResolution"])(
      sourceProj, targetProj, targetCenter, targetResolution);

    if (!isFinite(sourceResolution) || sourceResolution <= 0) {
      // invalid sourceResolution -> EMPTY
      // probably edges of the projections when no extent is defined
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY;
      return;
    }

    var errorThresholdInPixels = opt_errorThreshold !== undefined ?
      opt_errorThreshold : _common_js__WEBPACK_IMPORTED_MODULE_0__["ERROR_THRESHOLD"];

    /**
     * @private
     * @type {!import("./Triangulation.js").default}
     */
    this.triangulation_ = new _Triangulation_js__WEBPACK_IMPORTED_MODULE_8__["default"](
      sourceProj, targetProj, limitedTargetExtent, maxSourceExtent,
      sourceResolution * errorThresholdInPixels);

    if (this.triangulation_.getTriangles().length === 0) {
      // no valid triangles -> EMPTY
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY;
      return;
    }

    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);
    var sourceExtent = this.triangulation_.calculateSourceExtent();

    if (maxSourceExtent) {
      if (sourceProj.canWrapX()) {
        sourceExtent[1] = Object(_math_js__WEBPACK_IMPORTED_MODULE_6__["clamp"])(
          sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);
        sourceExtent[3] = Object(_math_js__WEBPACK_IMPORTED_MODULE_6__["clamp"])(
          sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);
      } else {
        sourceExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getIntersection"])(sourceExtent, maxSourceExtent);
      }
    }

    if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getArea"])(sourceExtent)) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY;
    } else {
      var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(
        sourceExtent, this.sourceZ_);

      for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
        for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
          var tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);
          if (tile) {
            this.sourceTiles_.push(tile);
          }
        }
      }

      if (this.sourceTiles_.length === 0) {
        this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY;
      }
    }
  }

  if ( Tile ) ReprojTile.__proto__ = Tile;
  ReprojTile.prototype = Object.create( Tile && Tile.prototype );
  ReprojTile.prototype.constructor = ReprojTile;

  /**
   * @inheritDoc
   */
  ReprojTile.prototype.disposeInternal = function disposeInternal () {
    if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING) {
      this.unlistenSources_();
    }
    Tile.prototype.disposeInternal.call(this);
  };

  /**
   * Get the HTML Canvas element for this tile.
   * @return {HTMLCanvasElement} Canvas.
   */
  ReprojTile.prototype.getImage = function getImage () {
    return this.canvas_;
  };

  /**
   * @private
   */
  ReprojTile.prototype.reproject_ = function reproject_ () {
    var sources = [];
    this.sourceTiles_.forEach(function(tile, i, arr) {
      if (tile && tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED) {
        sources.push({
          extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),
          image: tile.getImage()
        });
      }
    }.bind(this));
    this.sourceTiles_.length = 0;

    if (sources.length === 0) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR;
    } else {
      var z = this.wrappedTileCoord_[0];
      var size = this.targetTileGrid_.getTileSize(z);
      var width = typeof size === 'number' ? size : size[0];
      var height = typeof size === 'number' ? size : size[1];
      var targetResolution = this.targetTileGrid_.getResolution(z);
      var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);

      var targetExtent = this.targetTileGrid_.getTileCoordExtent(
        this.wrappedTileCoord_);
      this.canvas_ = Object(_reproj_js__WEBPACK_IMPORTED_MODULE_7__["render"])(width, height, this.pixelRatio_,
        sourceResolution, this.sourceTileGrid_.getExtent(),
        targetResolution, targetExtent, this.triangulation_, sources,
        this.gutter_, this.renderEdges_);

      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED;
    }
    this.changed();
  };

  /**
   * @inheritDoc
   */
  ReprojTile.prototype.load = function load () {
    if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING;
      this.changed();

      var leftToLoad = 0;

      this.sourcesListenerKeys_ = [];
      this.sourceTiles_.forEach(function(tile, i, arr) {
        var state = tile.getState();
        if (state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE || state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING) {
          leftToLoad++;

          var sourceListenKey = Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(tile, _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].CHANGE,
            function(e) {
              var state = tile.getState();
              if (state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED ||
                    state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR ||
                    state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY) {
                Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["unlistenByKey"])(sourceListenKey);
                leftToLoad--;
                if (leftToLoad === 0) {
                  this.unlistenSources_();
                  this.reproject_();
                }
              }
            }, this);
          this.sourcesListenerKeys_.push(sourceListenKey);
        }
      }.bind(this));

      this.sourceTiles_.forEach(function(tile, i, arr) {
        var state = tile.getState();
        if (state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE) {
          tile.load();
        }
      });

      if (leftToLoad === 0) {
        setTimeout(this.reproject_.bind(this), 0);
      }
    }
  };

  /**
   * @private
   */
  ReprojTile.prototype.unlistenSources_ = function unlistenSources_ () {
    this.sourcesListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_3__["unlistenByKey"]);
    this.sourcesListenerKeys_ = null;
  };

  return ReprojTile;
}(_Tile_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (ReprojTile);

//# sourceMappingURL=Tile.js.map

/***/ }),

/***/ "./node_modules/ol/reproj/Triangulation.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/reproj/Triangulation.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/**
 * @module ol/reproj/Triangulation
 */





/**
 * Single triangle; consists of 3 source points and 3 target points.
 * @typedef {Object} Triangle
 * @property {Array<import("../coordinate.js").Coordinate>} source
 * @property {Array<import("../coordinate.js").Coordinate>} target
 */


/**
 * Maximum number of subdivision steps during raster reprojection triangulation.
 * Prevents high memory usage and large number of proj4 calls (for certain
 * transformations and areas). At most `2*(2^this)` triangles are created for
 * each triangulated extent (tile/image).
 * @type {number}
 */
var MAX_SUBDIVISION = 10;


/**
 * Maximum allowed size of triangle relative to world width. When transforming
 * corners of world extent between certain projections, the resulting
 * triangulation seems to have zero error and no subdivision is performed. If
 * the triangle width is more than this (relative to world width; 0-1),
 * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.
 * @type {number}
 */
var MAX_TRIANGLE_WIDTH = 0.25;


/**
 * @classdesc
 * Class containing triangulation of the given target extent.
 * Used for determining source data and the reprojection itself.
 */
var Triangulation = function Triangulation(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold) {

  /**
   * @type {import("../proj/Projection.js").default}
   * @private
   */
  this.sourceProj_ = sourceProj;

  /**
   * @type {import("../proj/Projection.js").default}
   * @private
   */
  this.targetProj_ = targetProj;

  /** @type {!Object<string, import("../coordinate.js").Coordinate>} */
  var transformInvCache = {};
  var transformInv = Object(_proj_js__WEBPACK_IMPORTED_MODULE_2__["getTransform"])(this.targetProj_, this.sourceProj_);

  /**
   * @param {import("../coordinate.js").Coordinate} c A coordinate.
   * @return {import("../coordinate.js").Coordinate} Transformed coordinate.
   * @private
   */
  this.transformInv_ = function(c) {
    var key = c[0] + '/' + c[1];
    if (!transformInvCache[key]) {
      transformInvCache[key] = transformInv(c);
    }
    return transformInvCache[key];
  };

  /**
   * @type {import("../extent.js").Extent}
   * @private
   */
  this.maxSourceExtent_ = maxSourceExtent;

  /**
   * @type {number}
   * @private
   */
  this.errorThresholdSquared_ = errorThreshold * errorThreshold;

  /**
   * @type {Array<Triangle>}
   * @private
   */
  this.triangles_ = [];

  /**
   * Indicates that the triangulation crosses edge of the source projection.
   * @type {boolean}
   * @private
   */
  this.wrapsXInSource_ = false;

  /**
   * @type {boolean}
   * @private
   */
  this.canWrapXInSource_ = this.sourceProj_.canWrapX() &&
      !!maxSourceExtent &&
      !!this.sourceProj_.getExtent() &&
      (Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getWidth"])(maxSourceExtent) == Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getWidth"])(this.sourceProj_.getExtent()));

  /**
   * @type {?number}
   * @private
   */
  this.sourceWorldWidth_ = this.sourceProj_.getExtent() ?
    Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getWidth"])(this.sourceProj_.getExtent()) : null;

  /**
   * @type {?number}
   * @private
   */
  this.targetWorldWidth_ = this.targetProj_.getExtent() ?
    Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getWidth"])(this.targetProj_.getExtent()) : null;

  var destinationTopLeft = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getTopLeft"])(targetExtent);
  var destinationTopRight = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getTopRight"])(targetExtent);
  var destinationBottomRight = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getBottomRight"])(targetExtent);
  var destinationBottomLeft = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getBottomLeft"])(targetExtent);
  var sourceTopLeft = this.transformInv_(destinationTopLeft);
  var sourceTopRight = this.transformInv_(destinationTopRight);
  var sourceBottomRight = this.transformInv_(destinationBottomRight);
  var sourceBottomLeft = this.transformInv_(destinationBottomLeft);

  this.addQuad_(
    destinationTopLeft, destinationTopRight,
    destinationBottomRight, destinationBottomLeft,
    sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft,
    MAX_SUBDIVISION);

  if (this.wrapsXInSource_) {
    var leftBound = Infinity;
    this.triangles_.forEach(function(triangle, i, arr) {
      leftBound = Math.min(leftBound,
        triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);
    });

    // Shift triangles to be as close to `leftBound` as possible
    // (if the distance is more than `worldWidth / 2` it can be closer.
    this.triangles_.forEach(function(triangle) {
      if (Math.max(triangle.source[0][0], triangle.source[1][0],
        triangle.source[2][0]) - leftBound > this.sourceWorldWidth_ / 2) {
        var newTriangle = [[triangle.source[0][0], triangle.source[0][1]],
          [triangle.source[1][0], triangle.source[1][1]],
          [triangle.source[2][0], triangle.source[2][1]]];
        if ((newTriangle[0][0] - leftBound) > this.sourceWorldWidth_ / 2) {
          newTriangle[0][0] -= this.sourceWorldWidth_;
        }
        if ((newTriangle[1][0] - leftBound) > this.sourceWorldWidth_ / 2) {
          newTriangle[1][0] -= this.sourceWorldWidth_;
        }
        if ((newTriangle[2][0] - leftBound) > this.sourceWorldWidth_ / 2) {
          newTriangle[2][0] -= this.sourceWorldWidth_;
        }

        // Rarely (if the extent contains both the dateline and prime meridian)
        // the shift can in turn break some triangles.
        // Detect this here and don't shift in such cases.
        var minX = Math.min(
          newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
        var maxX = Math.max(
          newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
        if ((maxX - minX) < this.sourceWorldWidth_ / 2) {
          triangle.source = newTriangle;
        }
      }
    }.bind(this));
  }

  transformInvCache = {};
};

/**
 * Adds triangle to the triangulation.
 * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
 * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
 * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
 * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
 * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
 * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
 * @private
 */
Triangulation.prototype.addTriangle_ = function addTriangle_ (a, b, c, aSrc, bSrc, cSrc) {
  this.triangles_.push({
    source: [aSrc, bSrc, cSrc],
    target: [a, b, c]
  });
};

/**
 * Adds quad (points in clock-wise order) to the triangulation
 * (and reprojects the vertices) if valid.
 * Performs quad subdivision if needed to increase precision.
 *
 * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
 * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
 * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
 * @param {import("../coordinate.js").Coordinate} d The target d coordinate.
 * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
 * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
 * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
 * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.
 * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
 * @private
 */
Triangulation.prototype.addQuad_ = function addQuad_ (a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {

  var sourceQuadExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["boundingExtent"])([aSrc, bSrc, cSrc, dSrc]);
  var sourceCoverageX = this.sourceWorldWidth_ ?
    Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getWidth"])(sourceQuadExtent) / this.sourceWorldWidth_ : null;
  var sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);

  // when the quad is wrapped in the source projection
  // it covers most of the projection extent, but not fully
  var wrapsX = this.sourceProj_.canWrapX() &&
               sourceCoverageX > 0.5 && sourceCoverageX < 1;

  var needsSubdivision = false;

  if (maxSubdivision > 0) {
    if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
      var targetQuadExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["boundingExtent"])([a, b, c, d]);
      var targetCoverageX = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getWidth"])(targetQuadExtent) / this.targetWorldWidth_;
      needsSubdivision = targetCoverageX > MAX_TRIANGLE_WIDTH ||
        needsSubdivision;
    }
    if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {
      needsSubdivision = sourceCoverageX > MAX_TRIANGLE_WIDTH ||
          needsSubdivision;
    }
  }

  if (!needsSubdivision && this.maxSourceExtent_) {
    if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["intersects"])(sourceQuadExtent, this.maxSourceExtent_)) {
      // whole quad outside source projection extent -> ignore
      return;
    }
  }

  if (!needsSubdivision) {
    if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ||
        !isFinite(bSrc[0]) || !isFinite(bSrc[1]) ||
        !isFinite(cSrc[0]) || !isFinite(cSrc[1]) ||
        !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {
      if (maxSubdivision > 0) {
        needsSubdivision = true;
      } else {
        return;
      }
    }
  }

  if (maxSubdivision > 0) {
    if (!needsSubdivision) {
      var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];
      var centerSrc = this.transformInv_(center);

      var dx;
      if (wrapsX) {
        var centerSrcEstimX =
            (Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["modulo"])(aSrc[0], sourceWorldWidth) +
             Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["modulo"])(cSrc[0], sourceWorldWidth)) / 2;
        dx = centerSrcEstimX -
            Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["modulo"])(centerSrc[0], sourceWorldWidth);
      } else {
        dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];
      }
      var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];
      var centerSrcErrorSquared = dx * dx + dy * dy;
      needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;
    }
    if (needsSubdivision) {
      if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {
        // split horizontally (top & bottom)
        var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];
        var bcSrc = this.transformInv_(bc);
        var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];
        var daSrc = this.transformInv_(da);

        this.addQuad_(
          a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);
        this.addQuad_(
          da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);
      } else {
        // split vertically (left & right)
        var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];
        var abSrc = this.transformInv_(ab);
        var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];
        var cdSrc = this.transformInv_(cd);

        this.addQuad_(
          a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);
        this.addQuad_(
          ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);
      }
      return;
    }
  }

  if (wrapsX) {
    if (!this.canWrapXInSource_) {
      return;
    }
    this.wrapsXInSource_ = true;
  }

  this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);
  this.addTriangle_(a, b, c, aSrc, bSrc, cSrc);
};

/**
 * Calculates extent of the 'source' coordinates from all the triangles.
 *
 * @return {import("../extent.js").Extent} Calculated extent.
 */
Triangulation.prototype.calculateSourceExtent = function calculateSourceExtent () {
  var extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["createEmpty"])();

  this.triangles_.forEach(function(triangle, i, arr) {
    var src = triangle.source;
    Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["extendCoordinate"])(extent, src[0]);
    Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["extendCoordinate"])(extent, src[1]);
    Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["extendCoordinate"])(extent, src[2]);
  });

  return extent;
};

/**
 * @return {Array<Triangle>} Array of the calculated triangles.
 */
Triangulation.prototype.getTriangles = function getTriangles () {
  return this.triangles_;
};

/* harmony default export */ __webpack_exports__["default"] = (Triangulation);

//# sourceMappingURL=Triangulation.js.map

/***/ }),

/***/ "./node_modules/ol/reproj/common.js":
/*!******************************************!*\
  !*** ./node_modules/ol/reproj/common.js ***!
  \******************************************/
/*! exports provided: ERROR_THRESHOLD, ENABLE_RASTER_REPROJECTION */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ERROR_THRESHOLD", function() { return ERROR_THRESHOLD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENABLE_RASTER_REPROJECTION", function() { return ENABLE_RASTER_REPROJECTION; });
/**
 * @module ol/reproj/common
 */

/**
 * Default maximum allowed threshold  (in pixels) for reprojection
 * triangulation.
 * @type {number}
 */
var ERROR_THRESHOLD = 0.5;

/**
 * Enable automatic reprojection of raster sources. Default is `true`.
 * TODO: decide if we want to expose this as a build flag or remove it
 * @type {boolean}
 */
var ENABLE_RASTER_REPROJECTION = true;

//# sourceMappingURL=common.js.map

/***/ }),

/***/ "./node_modules/ol/resolutionconstraint.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/resolutionconstraint.js ***!
  \*************************************************/
/*! exports provided: createSnapToResolutions, createSnapToPower */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSnapToResolutions", function() { return createSnapToResolutions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSnapToPower", function() { return createSnapToPower; });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/resolutionconstraint
 */




/**
 * @typedef {function((number|undefined), number, number): (number|undefined)} Type
 */


/**
 * @param {Array<number>} resolutions Resolutions.
 * @return {Type} Zoom function.
 */
function createSnapToResolutions(resolutions) {
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} delta Delta.
     * @param {number} direction Direction.
     * @return {number|undefined} Resolution.
     */
    function(resolution, delta, direction) {
      if (resolution !== undefined) {
        var z = Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["linearFindNearest"])(resolutions, resolution, direction);
        z = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["clamp"])(z + delta, 0, resolutions.length - 1);
        var index = Math.floor(z);
        if (z != index && index < resolutions.length - 1) {
          var power = resolutions[index] / resolutions[index + 1];
          return resolutions[index] / Math.pow(power, z - index);
        } else {
          return resolutions[index];
        }
      } else {
        return undefined;
      }
    }
  );
}


/**
 * @param {number} power Power.
 * @param {number} maxResolution Maximum resolution.
 * @param {number=} opt_maxLevel Maximum level.
 * @return {Type} Zoom function.
 */
function createSnapToPower(power, maxResolution, opt_maxLevel) {
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} delta Delta.
     * @param {number} direction Direction.
     * @return {number|undefined} Resolution.
     */
    function(resolution, delta, direction) {
      if (resolution !== undefined) {
        var offset = -direction / 2 + 0.5;
        var oldLevel = Math.floor(
          Math.log(maxResolution / resolution) / Math.log(power) + offset);
        var newLevel = Math.max(oldLevel + delta, 0);
        if (opt_maxLevel !== undefined) {
          newLevel = Math.min(newLevel, opt_maxLevel);
        }
        return maxResolution / Math.pow(power, newLevel);
      } else {
        return undefined;
      }
    });
}

//# sourceMappingURL=resolutionconstraint.js.map

/***/ }),

/***/ "./node_modules/ol/rotationconstraint.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/rotationconstraint.js ***!
  \***********************************************/
/*! exports provided: disable, none, createSnapToN, createSnapToZero */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "disable", function() { return disable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "none", function() { return none; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSnapToN", function() { return createSnapToN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSnapToZero", function() { return createSnapToZero; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/rotationconstraint
 */



/**
 * @typedef {function((number|undefined), number): (number|undefined)} Type
 */


/**
 * @param {number|undefined} rotation Rotation.
 * @param {number} delta Delta.
 * @return {number|undefined} Rotation.
 */
function disable(rotation, delta) {
  if (rotation !== undefined) {
    return 0;
  } else {
    return undefined;
  }
}


/**
 * @param {number|undefined} rotation Rotation.
 * @param {number} delta Delta.
 * @return {number|undefined} Rotation.
 */
function none(rotation, delta) {
  if (rotation !== undefined) {
    return rotation + delta;
  } else {
    return undefined;
  }
}


/**
 * @param {number} n N.
 * @return {Type} Rotation constraint.
 */
function createSnapToN(n) {
  var theta = 2 * Math.PI / n;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {number} delta Delta.
     * @return {number|undefined} Rotation.
     */
    function(rotation, delta) {
      if (rotation !== undefined) {
        rotation = Math.floor((rotation + delta) / theta + 0.5) * theta;
        return rotation;
      } else {
        return undefined;
      }
    });
}


/**
 * @param {number=} opt_tolerance Tolerance.
 * @return {Type} Rotation constraint.
 */
function createSnapToZero(opt_tolerance) {
  var tolerance = opt_tolerance || Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toRadians"])(5);
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {number} delta Delta.
     * @return {number|undefined} Rotation.
     */
    function(rotation, delta) {
      if (rotation !== undefined) {
        if (Math.abs(rotation + delta) <= tolerance) {
          return 0;
        } else {
          return rotation + delta;
        }
      } else {
        return undefined;
      }
    });
}

//# sourceMappingURL=rotationconstraint.js.map

/***/ }),

/***/ "./node_modules/ol/size.js":
/*!*********************************!*\
  !*** ./node_modules/ol/size.js ***!
  \*********************************/
/*! exports provided: buffer, hasArea, scale, toSize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buffer", function() { return buffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasArea", function() { return hasArea; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toSize", function() { return toSize; });
/**
 * @module ol/size
 */


/**
 * An array of numbers representing a size: `[width, height]`.
 * @typedef {Array<number>} Size
 * @api
 */


/**
 * Returns a buffered size.
 * @param {Size} size Size.
 * @param {number} num The amount by which to buffer.
 * @param {Size=} opt_size Optional reusable size array.
 * @return {Size} The buffered size.
 */
function buffer(size, num, opt_size) {
  if (opt_size === undefined) {
    opt_size = [0, 0];
  }
  opt_size[0] = size[0] + 2 * num;
  opt_size[1] = size[1] + 2 * num;
  return opt_size;
}


/**
 * Determines if a size has a positive area.
 * @param {Size} size The size to test.
 * @return {boolean} The size has a positive area.
 */
function hasArea(size) {
  return size[0] > 0 && size[1] > 0;
}


/**
 * Returns a size scaled by a ratio. The result will be an array of integers.
 * @param {Size} size Size.
 * @param {number} ratio Ratio.
 * @param {Size=} opt_size Optional reusable size array.
 * @return {Size} The scaled size.
 */
function scale(size, ratio, opt_size) {
  if (opt_size === undefined) {
    opt_size = [0, 0];
  }
  opt_size[0] = (size[0] * ratio + 0.5) | 0;
  opt_size[1] = (size[1] * ratio + 0.5) | 0;
  return opt_size;
}


/**
 * Returns an `Size` array for the passed in number (meaning: square) or
 * `Size` array.
 * (meaning: non-square),
 * @param {number|Size} size Width and height.
 * @param {Size=} opt_size Optional reusable size array.
 * @return {Size} Size.
 * @api
 */
function toSize(size, opt_size) {
  if (Array.isArray(size)) {
    return size;
  } else {
    if (opt_size === undefined) {
      opt_size = [size, size];
    } else {
      opt_size[0] = opt_size[1] = /** @type {number} */ (size);
    }
    return opt_size;
  }
}

//# sourceMappingURL=size.js.map

/***/ }),

/***/ "./node_modules/ol/source/OSM.js":
/*!***************************************!*\
  !*** ./node_modules/ol/source/OSM.js ***!
  \***************************************/
/*! exports provided: ATTRIBUTION, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ATTRIBUTION", function() { return ATTRIBUTION; });
/* harmony import */ var _XYZ_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./XYZ.js */ "./node_modules/ol/source/XYZ.js");
/**
 * @module ol/source/OSM
 */




/**
 * The attribution containing a link to the OpenStreetMap Copyright and License
 * page.
 * @const
 * @type {string}
 * @api
 */
var ATTRIBUTION = '&#169; ' +
      '<a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> ' +
      'contributors.';


/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize=2048] Cache size.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you are using the WebGL renderer or if you want to
 * access pixel data with the Canvas renderer.  See
 * https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {number} [maxZoom=19] Max zoom.
 * @property {boolean} [opaque=true] Whether the layer is opaque.
 * @property {number} [reprojectionErrorThreshold=1.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {string} [url='https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png'] URL template.
 * Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 */


/**
 * @classdesc
 * Layer source for the OpenStreetMap tile server.
 * @api
 */
var OSM = /*@__PURE__*/(function (XYZ) {
  function OSM(opt_options) {

    var options = opt_options || {};

    var attributions;
    if (options.attributions !== undefined) {
      attributions = options.attributions;
    } else {
      attributions = [ATTRIBUTION];
    }

    var crossOrigin = options.crossOrigin !== undefined ?
      options.crossOrigin : 'anonymous';

    var url = options.url !== undefined ?
      options.url : 'https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png';

    XYZ.call(this, {
      attributions: attributions,
      cacheSize: options.cacheSize,
      crossOrigin: crossOrigin,
      opaque: options.opaque !== undefined ? options.opaque : true,
      maxZoom: options.maxZoom !== undefined ? options.maxZoom : 19,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileLoadFunction: options.tileLoadFunction,
      url: url,
      wrapX: options.wrapX,
      attributionsCollapsible: false
    });

  }

  if ( XYZ ) OSM.__proto__ = XYZ;
  OSM.prototype = Object.create( XYZ && XYZ.prototype );
  OSM.prototype.constructor = OSM;

  return OSM;
}(_XYZ_js__WEBPACK_IMPORTED_MODULE_0__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (OSM);

//# sourceMappingURL=OSM.js.map

/***/ }),

/***/ "./node_modules/ol/source/Source.js":
/*!******************************************!*\
  !*** ./node_modules/ol/source/Source.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _State_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./State.js */ "./node_modules/ol/source/State.js");
/**
 * @module ol/source/Source
 */






/**
 * A function that returns a string or an array of strings representing source
 * attributions.
 *
 * @typedef {function(import("../PluggableMap.js").FrameState): (string|Array<string>)} Attribution
 */


/**
 * A type that can be used to provide attribution information for data sources.
 *
 * It represents either
 * * a simple string (e.g. `'© Acme Inc.'`)
 * * an array of simple strings (e.g. `['© Acme Inc.', '© Bacme Inc.']`)
 * * a function that returns a string or array of strings (`{@link module:ol/source/Source~Attribution}`)
 *
 * @typedef {string|Array<string>|Attribution} AttributionLike
 */


/**
 * @typedef {Object} Options
 * @property {AttributionLike} [attributions]
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {import("../proj.js").ProjectionLike} projection
 * @property {SourceState} [state='ready']
 * @property {boolean} [wrapX=false]
 */


/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for {@link module:ol/layer/Layer~Layer} sources.
 *
 * A generic `change` event is triggered when the state of the source changes.
 * @abstract
 * @api
 */
var Source = /*@__PURE__*/(function (BaseObject) {
  function Source(options) {

    BaseObject.call(this);

    /**
     * @private
     * @type {import("../proj/Projection.js").default}
     */
    this.projection_ = Object(_proj_js__WEBPACK_IMPORTED_MODULE_2__["get"])(options.projection);

    /**
     * @private
     * @type {?Attribution}
     */
    this.attributions_ = adaptAttributions(options.attributions);

    /**
     * @private
     * @type {boolean}
     */
    this.attributionsCollapsible_ = options.attributionsCollapsible !== undefined ?
      options.attributionsCollapsible : true;

    /**
     * This source is currently loading data. Sources that defer loading to the
     * map's tile queue never set this to `true`.
     * @type {boolean}
     */
    this.loading = false;

    /**
     * @private
     * @type {SourceState}
     */
    this.state_ = options.state !== undefined ?
      options.state : _State_js__WEBPACK_IMPORTED_MODULE_3__["default"].READY;

    /**
     * @private
     * @type {boolean}
     */
    this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;

  }

  if ( BaseObject ) Source.__proto__ = BaseObject;
  Source.prototype = Object.create( BaseObject && BaseObject.prototype );
  Source.prototype.constructor = Source;

  /**
   * Get the attribution function for the source.
   * @return {?Attribution} Attribution function.
   */
  Source.prototype.getAttributions = function getAttributions () {
    return this.attributions_;
  };

  /**
   * @return {boolean} Aattributions are collapsible.
   */
  Source.prototype.getAttributionsCollapsible = function getAttributionsCollapsible () {
    return this.attributionsCollapsible_;
  };

  /**
   * Get the projection of the source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   */
  Source.prototype.getProjection = function getProjection () {
    return this.projection_;
  };

  /**
   * @abstract
   * @return {Array<number>|undefined} Resolutions.
   */
  Source.prototype.getResolutions = function getResolutions () {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Get the state of the source, see {@link module:ol/source/State~State} for possible states.
   * @return {SourceState} State.
   * @api
   */
  Source.prototype.getState = function getState () {
    return this.state_;
  };

  /**
   * @return {boolean|undefined} Wrap X.
   */
  Source.prototype.getWrapX = function getWrapX () {
    return this.wrapX_;
  };

  /**
   * Refreshes the source and finally dispatches a 'change' event.
   * @api
   */
  Source.prototype.refresh = function refresh () {
    this.changed();
  };

  /**
   * Set the attributions of the source.
   * @param {AttributionLike|undefined} attributions Attributions.
   *     Can be passed as `string`, `Array<string>`, `{@link module:ol/source/Source~Attribution}`,
   *     or `undefined`.
   * @api
   */
  Source.prototype.setAttributions = function setAttributions (attributions) {
    this.attributions_ = adaptAttributions(attributions);
    this.changed();
  };

  /**
   * Set the state of the source.
   * @param {SourceState} state State.
   * @protected
   */
  Source.prototype.setState = function setState (state) {
    this.state_ = state;
    this.changed();
  };

  return Source;
}(_Object_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/**
 * Turns the attributions option into an attributions function.
 * @param {AttributionLike|undefined} attributionLike The attribution option.
 * @return {?Attribution} An attribution function (or null).
 */
function adaptAttributions(attributionLike) {
  if (!attributionLike) {
    return null;
  }
  if (Array.isArray(attributionLike)) {
    return function(frameState) {
      return attributionLike;
    };
  }

  if (typeof attributionLike === 'function') {
    return attributionLike;
  }

  return function(frameState) {
    return [attributionLike];
  };
}


/* harmony default export */ __webpack_exports__["default"] = (Source);

//# sourceMappingURL=Source.js.map

/***/ }),

/***/ "./node_modules/ol/source/Stamen.js":
/*!******************************************!*\
  !*** ./node_modules/ol/source/Stamen.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _OSM_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./OSM.js */ "./node_modules/ol/source/OSM.js");
/* harmony import */ var _XYZ_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./XYZ.js */ "./node_modules/ol/source/XYZ.js");
/**
 * @module ol/source/Stamen
 */





/**
 * @const
 * @type {Array<string>}
 */
var ATTRIBUTIONS = [
  'Map tiles by <a href="https://stamen.com/">Stamen Design</a>, ' +
        'under <a href="https://creativecommons.org/licenses/by/3.0/">CC BY' +
        ' 3.0</a>.',
  _OSM_js__WEBPACK_IMPORTED_MODULE_0__["ATTRIBUTION"]
];


/**
 * @type {Object<string, {extension: string, opaque: boolean}>}
 */
var LayerConfig = {
  'terrain': {
    extension: 'jpg',
    opaque: true
  },
  'terrain-background': {
    extension: 'jpg',
    opaque: true
  },
  'terrain-labels': {
    extension: 'png',
    opaque: false
  },
  'terrain-lines': {
    extension: 'png',
    opaque: false
  },
  'toner-background': {
    extension: 'png',
    opaque: true
  },
  'toner': {
    extension: 'png',
    opaque: true
  },
  'toner-hybrid': {
    extension: 'png',
    opaque: false
  },
  'toner-labels': {
    extension: 'png',
    opaque: false
  },
  'toner-lines': {
    extension: 'png',
    opaque: false
  },
  'toner-lite': {
    extension: 'png',
    opaque: true
  },
  'watercolor': {
    extension: 'jpg',
    opaque: true
  }
};


/**
 * @type {Object<string, {minZoom: number, maxZoom: number}>}
 */
var ProviderConfig = {
  'terrain': {
    minZoom: 4,
    maxZoom: 18
  },
  'toner': {
    minZoom: 0,
    maxZoom: 20
  },
  'watercolor': {
    minZoom: 1,
    maxZoom: 16
  }
};


/**
 * @typedef {Object} Options
 * @property {number} [cacheSize=2048] Cache size.
 * @property {string} layer Layer name.
 * @property {number} [minZoom] Minimum zoom.
 * @property {number} [maxZoom] Maximum zoom.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction]
 * Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 */


/**
 * @classdesc
 * Layer source for the Stamen tile server.
 * @api
 */
var Stamen = /*@__PURE__*/(function (XYZ) {
  function Stamen(options) {
    var i = options.layer.indexOf('-');
    var provider = i == -1 ? options.layer : options.layer.slice(0, i);
    var providerConfig = ProviderConfig[provider];

    var layerConfig = LayerConfig[options.layer];

    var url = options.url !== undefined ? options.url :
      'https://stamen-tiles-{a-d}.a.ssl.fastly.net/' + options.layer +
        '/{z}/{x}/{y}.' + layerConfig.extension;

    XYZ.call(this, {
      attributions: ATTRIBUTIONS,
      cacheSize: options.cacheSize,
      crossOrigin: 'anonymous',
      maxZoom: options.maxZoom != undefined ? options.maxZoom : providerConfig.maxZoom,
      minZoom: options.minZoom != undefined ? options.minZoom : providerConfig.minZoom,
      opaque: layerConfig.opaque,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileLoadFunction: options.tileLoadFunction,
      url: url,
      wrapX: options.wrapX
    });

  }

  if ( XYZ ) Stamen.__proto__ = XYZ;
  Stamen.prototype = Object.create( XYZ && XYZ.prototype );
  Stamen.prototype.constructor = Stamen;

  return Stamen;
}(_XYZ_js__WEBPACK_IMPORTED_MODULE_1__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (Stamen);

//# sourceMappingURL=Stamen.js.map

/***/ }),

/***/ "./node_modules/ol/source/State.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/source/State.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/source/State
 */

/**
 * @enum {string}
 * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  UNDEFINED: 'undefined',
  LOADING: 'loading',
  READY: 'ready',
  ERROR: 'error'
});

//# sourceMappingURL=State.js.map

/***/ }),

/***/ "./node_modules/ol/source/Tile.js":
/*!****************************************!*\
  !*** ./node_modules/ol/source/Tile.js ***!
  \****************************************/
/*! exports provided: TileSourceEvent, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TileSourceEvent", function() { return TileSourceEvent; });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _TileCache_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../TileCache.js */ "./node_modules/ol/TileCache.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../size.js */ "./node_modules/ol/size.js");
/* harmony import */ var _Source_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Source.js */ "./node_modules/ol/source/Source.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");
/* harmony import */ var _tilegrid_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../tilegrid.js */ "./node_modules/ol/tilegrid.js");
/**
 * @module ol/source/Tile
 */










/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions]
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize]
 * @property {boolean} [opaque]
 * @property {number} [tilePixelRatio]
 * @property {import("../proj.js").ProjectionLike} [projection]
 * @property {import("./State.js").default} [state]
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid]
 * @property {boolean} [wrapX=true]
 * @property {number} [transition]
 * @property {string} [key]
 */


/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for sources providing images divided into a tile grid.
 * @abstract
 * @api
 */
var TileSource = /*@__PURE__*/(function (Source) {
  function TileSource(options) {

    Source.call(this, {
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      projection: options.projection,
      state: options.state,
      wrapX: options.wrapX
    });

    /**
     * @private
     * @type {boolean}
     */
    this.opaque_ = options.opaque !== undefined ? options.opaque : false;

    /**
     * @private
     * @type {number}
     */
    this.tilePixelRatio_ = options.tilePixelRatio !== undefined ?
      options.tilePixelRatio : 1;

    /**
     * @protected
     * @type {import("../tilegrid/TileGrid.js").default}
     */
    this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;

    /**
     * @protected
     * @type {import("../TileCache.js").default}
     */
    this.tileCache = new _TileCache_js__WEBPACK_IMPORTED_MODULE_1__["default"](options.cacheSize);

    /**
     * @protected
     * @type {import("../size.js").Size}
     */
    this.tmpSize = [0, 0];

    /**
     * @private
     * @type {string}
     */
    this.key_ = options.key || '';

    /**
     * @protected
     * @type {import("../Tile.js").Options}
     */
    this.tileOptions = {transition: options.transition};

  }

  if ( Source ) TileSource.__proto__ = Source;
  TileSource.prototype = Object.create( Source && Source.prototype );
  TileSource.prototype.constructor = TileSource;

  /**
   * @return {boolean} Can expire cache.
   */
  TileSource.prototype.canExpireCache = function canExpireCache () {
    return this.tileCache.canExpireCache();
  };

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, import("../TileRange.js").default>} usedTiles Used tiles.
   */
  TileSource.prototype.expireCache = function expireCache (projection, usedTiles) {
    var tileCache = this.getTileCacheForProjection(projection);
    if (tileCache) {
      tileCache.expireCache(usedTiles);
    }
  };

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {number} z Zoom level.
   * @param {import("../TileRange.js").default} tileRange Tile range.
   * @param {function(import("../Tile.js").default):(boolean|void)} callback Called with each
   *     loaded tile.  If the callback returns `false`, the tile will not be
   *     considered loaded.
   * @return {boolean} The tile range is fully covered with loaded tiles.
   */
  TileSource.prototype.forEachLoadedTile = function forEachLoadedTile (projection, z, tileRange, callback) {
    var tileCache = this.getTileCacheForProjection(projection);
    if (!tileCache) {
      return false;
    }

    var covered = true;
    var tile, tileCoordKey, loaded;
    for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
        tileCoordKey = Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_7__["getKeyZXY"])(z, x, y);
        loaded = false;
        if (tileCache.containsKey(tileCoordKey)) {
          tile = /** @type {!import("../Tile.js").default} */ (tileCache.get(tileCoordKey));
          loaded = tile.getState() === _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED;
          if (loaded) {
            loaded = (callback(tile) !== false);
          }
        }
        if (!loaded) {
          covered = false;
        }
      }
    }
    return covered;
  };

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */
  TileSource.prototype.getGutterForProjection = function getGutterForProjection (projection) {
    return 0;
  };

  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   * @protected
   */
  TileSource.prototype.getKey = function getKey () {
    return this.key_;
  };

  /**
   * Set the value to be used as the key for all tiles in the source.
   * @param {string} key The key for tiles.
   * @protected
   */
  TileSource.prototype.setKey = function setKey (key) {
    if (this.key_ !== key) {
      this.key_ = key;
      this.changed();
    }
  };

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {boolean} Opaque.
   */
  TileSource.prototype.getOpaque = function getOpaque (projection) {
    return this.opaque_;
  };

  /**
   * @inheritDoc
   */
  TileSource.prototype.getResolutions = function getResolutions () {
    return this.tileGrid.getResolutions();
  };

  /**
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../Tile.js").default} Tile.
   */
  TileSource.prototype.getTile = function getTile (z, x, y, pixelRatio, projection) {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Return the tile grid of the tile source.
   * @return {import("../tilegrid/TileGrid.js").default} Tile grid.
   * @api
   */
  TileSource.prototype.getTileGrid = function getTileGrid () {
    return this.tileGrid;
  };

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */
  TileSource.prototype.getTileGridForProjection = function getTileGridForProjection$1 (projection) {
    if (!this.tileGrid) {
      return Object(_tilegrid_js__WEBPACK_IMPORTED_MODULE_8__["getForProjection"])(projection);
    } else {
      return this.tileGrid;
    }
  };

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../TileCache.js").default} Tile cache.
   * @protected
   */
  TileSource.prototype.getTileCacheForProjection = function getTileCacheForProjection (projection) {
    var thisProj = this.getProjection();
    if (thisProj && !Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__["equivalent"])(thisProj, projection)) {
      return null;
    } else {
      return this.tileCache;
    }
  };

  /**
   * Get the tile pixel ratio for this source. Subclasses may override this
   * method, which is meant to return a supported pixel ratio that matches the
   * provided `pixelRatio` as close as possible.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */
  TileSource.prototype.getTilePixelRatio = function getTilePixelRatio (pixelRatio) {
    return this.tilePixelRatio_;
  };

  /**
   * @param {number} z Z.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../size.js").Size} Tile size.
   */
  TileSource.prototype.getTilePixelSize = function getTilePixelSize (z, pixelRatio, projection) {
    var tileGrid = this.getTileGridForProjection(projection);
    var tilePixelRatio = this.getTilePixelRatio(pixelRatio);
    var tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_5__["toSize"])(tileGrid.getTileSize(z), this.tmpSize);
    if (tilePixelRatio == 1) {
      return tileSize;
    } else {
      return Object(_size_js__WEBPACK_IMPORTED_MODULE_5__["scale"])(tileSize, tilePixelRatio, this.tmpSize);
    }
  };

  /**
   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
   * is outside the resolution and extent range of the tile grid, `null` will be
   * returned.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../proj/Projection.js").default=} opt_projection Projection.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or
   *     null if no tile URL should be created for the passed `tileCoord`.
   */
  TileSource.prototype.getTileCoordForTileUrlFunction = function getTileCoordForTileUrlFunction (tileCoord, opt_projection) {
    var projection = opt_projection !== undefined ?
      opt_projection : this.getProjection();
    var tileGrid = this.getTileGridForProjection(projection);
    if (this.getWrapX() && projection.isGlobal()) {
      tileCoord = Object(_tilegrid_js__WEBPACK_IMPORTED_MODULE_8__["wrapX"])(tileGrid, tileCoord, projection);
    }
    return Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_7__["withinExtentAndZ"])(tileCoord, tileGrid) ? tileCoord : null;
  };

  /**
   * @inheritDoc
   */
  TileSource.prototype.refresh = function refresh () {
    this.tileCache.clear();
    this.changed();
  };

  /**
   * Marks a tile coord as being used, without triggering a load.
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  TileSource.prototype.useTile = function useTile (z, x, y, projection) {};

  return TileSource;
}(_Source_js__WEBPACK_IMPORTED_MODULE_6__["default"]));


/**
 * @classdesc
 * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this
 * type.
 */
var TileSourceEvent = /*@__PURE__*/(function (Event) {
  function TileSourceEvent(type, tile) {

    Event.call(this, type);

    /**
     * The tile related to the event.
     * @type {import("../Tile.js").default}
     * @api
     */
    this.tile = tile;

  }

  if ( Event ) TileSourceEvent.__proto__ = Event;
  TileSourceEvent.prototype = Object.create( Event && Event.prototype );
  TileSourceEvent.prototype.constructor = TileSourceEvent;

  return TileSourceEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_3__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (TileSource);

//# sourceMappingURL=Tile.js.map

/***/ }),

/***/ "./node_modules/ol/source/TileEventType.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/source/TileEventType.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/source/TileEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({

  /**
   * Triggered when a tile starts loading.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
   * @api
   */
  TILELOADSTART: 'tileloadstart',

  /**
   * Triggered when a tile finishes loading, either when its data is loaded,
   * or when loading was aborted because the tile is no longer needed.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadend
   * @api
   */
  TILELOADEND: 'tileloadend',

  /**
   * Triggered if tile loading results in an error.
   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
   * @api
   */
  TILELOADERROR: 'tileloaderror'

});

//# sourceMappingURL=TileEventType.js.map

/***/ }),

/***/ "./node_modules/ol/source/TileImage.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/source/TileImage.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _reproj_common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../reproj/common.js */ "./node_modules/ol/reproj/common.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _ImageTile_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ImageTile.js */ "./node_modules/ol/ImageTile.js");
/* harmony import */ var _TileCache_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../TileCache.js */ "./node_modules/ol/TileCache.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _reproj_Tile_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../reproj/Tile.js */ "./node_modules/ol/reproj/Tile.js");
/* harmony import */ var _UrlTile_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./UrlTile.js */ "./node_modules/ol/source/UrlTile.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");
/* harmony import */ var _tilegrid_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../tilegrid.js */ "./node_modules/ol/tilegrid.js");
/**
 * @module ol/source/TileImage
 */













/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize=2048] Cache size.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you are using the WebGL renderer or if you want to
 * access pixel data with the Canvas renderer.  See
 * https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [opaque=true] Whether the layer is opaque.
 * @property {import("../proj.js").ProjectionLike} projection Projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("./State.js").default} [state] Source state.
 * @property {typeof import("../ImageTile.js").default} [tileClass] Class used to instantiate image tiles.
 * Default is {@link module:ol/ImageTile~ImageTile}.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service. For example, if the tile
 * service advertizes 256px by 256px tiles but actually sends 512px
 * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
 * should be set to `2`.
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be
 * used instead of defining each one separately in the `urls` option.
 * @property {Array<string>} [urls] An array of URL templates.
 * @property {boolean} [wrapX] Whether to wrap the world horizontally. The default, is to
 * request out-of-bounds tiles from the server. When set to `false`, only one
 * world will be rendered. When set to `true`, tiles will be requested for one
 * world only, but they will be wrapped horizontally to render multiple worlds.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {string} [key] Optional tile key for proper cache fetching
 */


/**
 * @classdesc
 * Base class for sources providing images divided into a tile grid.
 *
 * @fires import("./Tile.js").TileSourceEvent
 * @api
 */
var TileImage = /*@__PURE__*/(function (UrlTile) {
  function TileImage(options) {

    UrlTile.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      opaque: options.opaque,
      projection: options.projection,
      state: options.state,
      tileGrid: options.tileGrid,
      tileLoadFunction: options.tileLoadFunction ?
        options.tileLoadFunction : defaultTileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX,
      transition: options.transition,
      key: options.key,
      attributionsCollapsible: options.attributionsCollapsible
    });

    /**
     * @protected
     * @type {?string}
     */
    this.crossOrigin =
        options.crossOrigin !== undefined ? options.crossOrigin : null;

    /**
     * @protected
     * @type {typeof ImageTile}
     */
    this.tileClass = options.tileClass !== undefined ?
      options.tileClass : _ImageTile_js__WEBPACK_IMPORTED_MODULE_2__["default"];

    /**
     * @protected
     * @type {!Object<string, TileCache>}
     */
    this.tileCacheForProjection = {};

    /**
     * @protected
     * @type {!Object<string, import("../tilegrid/TileGrid.js").default>}
     */
    this.tileGridForProjection = {};

    /**
     * @private
     * @type {number|undefined}
     */
    this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;

    /**
     * @private
     * @type {boolean}
     */
    this.renderReprojectionEdges_ = false;
  }

  if ( UrlTile ) TileImage.__proto__ = UrlTile;
  TileImage.prototype = Object.create( UrlTile && UrlTile.prototype );
  TileImage.prototype.constructor = TileImage;

  /**
   * @inheritDoc
   */
  TileImage.prototype.canExpireCache = function canExpireCache () {
    if (!_reproj_common_js__WEBPACK_IMPORTED_MODULE_0__["ENABLE_RASTER_REPROJECTION"]) {
      return UrlTile.prototype.canExpireCache.call(this);
    }
    if (this.tileCache.canExpireCache()) {
      return true;
    } else {
      for (var key in this.tileCacheForProjection) {
        if (this.tileCacheForProjection[key].canExpireCache()) {
          return true;
        }
      }
    }
    return false;
  };

  /**
   * @inheritDoc
   */
  TileImage.prototype.expireCache = function expireCache (projection, usedTiles) {
    if (!_reproj_common_js__WEBPACK_IMPORTED_MODULE_0__["ENABLE_RASTER_REPROJECTION"]) {
      UrlTile.prototype.expireCache.call(this, projection, usedTiles);
      return;
    }
    var usedTileCache = this.getTileCacheForProjection(projection);

    this.tileCache.expireCache(this.tileCache == usedTileCache ? usedTiles : {});
    for (var id in this.tileCacheForProjection) {
      var tileCache = this.tileCacheForProjection[id];
      tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});
    }
  };

  /**
   * @inheritDoc
   */
  TileImage.prototype.getGutterForProjection = function getGutterForProjection (projection) {
    if (_reproj_common_js__WEBPACK_IMPORTED_MODULE_0__["ENABLE_RASTER_REPROJECTION"] &&
        this.getProjection() && projection && !Object(_proj_js__WEBPACK_IMPORTED_MODULE_7__["equivalent"])(this.getProjection(), projection)) {
      return 0;
    } else {
      return this.getGutter();
    }
  };

  /**
   * @return {number} Gutter.
   */
  TileImage.prototype.getGutter = function getGutter () {
    return 0;
  };

  /**
   * @inheritDoc
   */
  TileImage.prototype.getOpaque = function getOpaque (projection) {
    if (_reproj_common_js__WEBPACK_IMPORTED_MODULE_0__["ENABLE_RASTER_REPROJECTION"] &&
        this.getProjection() && projection && !Object(_proj_js__WEBPACK_IMPORTED_MODULE_7__["equivalent"])(this.getProjection(), projection)) {
      return false;
    } else {
      return UrlTile.prototype.getOpaque.call(this, projection);
    }
  };

  /**
   * @inheritDoc
   */
  TileImage.prototype.getTileGridForProjection = function getTileGridForProjection$1 (projection) {
    if (!_reproj_common_js__WEBPACK_IMPORTED_MODULE_0__["ENABLE_RASTER_REPROJECTION"]) {
      return UrlTile.prototype.getTileGridForProjection.call(this, projection);
    }
    var thisProj = this.getProjection();
    if (this.tileGrid && (!thisProj || Object(_proj_js__WEBPACK_IMPORTED_MODULE_7__["equivalent"])(thisProj, projection))) {
      return this.tileGrid;
    } else {
      var projKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_1__["getUid"])(projection);
      if (!(projKey in this.tileGridForProjection)) {
        this.tileGridForProjection[projKey] = Object(_tilegrid_js__WEBPACK_IMPORTED_MODULE_11__["getForProjection"])(projection);
      }
      return (
        /** @type {!import("../tilegrid/TileGrid.js").default} */ (this.tileGridForProjection[projKey])
      );
    }
  };

  /**
   * @inheritDoc
   */
  TileImage.prototype.getTileCacheForProjection = function getTileCacheForProjection (projection) {
    if (!_reproj_common_js__WEBPACK_IMPORTED_MODULE_0__["ENABLE_RASTER_REPROJECTION"]) {
      return UrlTile.prototype.getTileCacheForProjection.call(this, projection);
    }
    var thisProj = this.getProjection(); if (!thisProj || Object(_proj_js__WEBPACK_IMPORTED_MODULE_7__["equivalent"])(thisProj, projection)) {
      return this.tileCache;
    } else {
      var projKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_1__["getUid"])(projection);
      if (!(projKey in this.tileCacheForProjection)) {
        this.tileCacheForProjection[projKey] = new _TileCache_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.tileCache.highWaterMark);
      }
      return this.tileCacheForProjection[projKey];
    }
  };

  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {string} key The key set on the tile.
   * @return {!import("../Tile.js").default} Tile.
   * @private
   */
  TileImage.prototype.createTile_ = function createTile_ (z, x, y, pixelRatio, projection, key) {
    var tileCoord = [z, x, y];
    var urlTileCoord = this.getTileCoordForTileUrlFunction(
      tileCoord, projection);
    var tileUrl = urlTileCoord ?
      this.tileUrlFunction(urlTileCoord, pixelRatio, projection) : undefined;
    var tile = new this.tileClass(
      tileCoord,
      tileUrl !== undefined ? _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].IDLE : _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].EMPTY,
      tileUrl !== undefined ? tileUrl : '',
      this.crossOrigin,
      this.tileLoadFunction,
      this.tileOptions);
    tile.key = key;
    Object(_events_js__WEBPACK_IMPORTED_MODULE_5__["listen"])(tile, _events_EventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].CHANGE,
      this.handleTileChange, this);
    return tile;
  };

  /**
   * @inheritDoc
   */
  TileImage.prototype.getTile = function getTile (z, x, y, pixelRatio, projection) {
    var sourceProjection = /** @type {!import("../proj/Projection.js").default} */ (this.getProjection());
    if (!_reproj_common_js__WEBPACK_IMPORTED_MODULE_0__["ENABLE_RASTER_REPROJECTION"] ||
        !sourceProjection || !projection || Object(_proj_js__WEBPACK_IMPORTED_MODULE_7__["equivalent"])(sourceProjection, projection)) {
      return this.getTileInternal(z, x, y, pixelRatio, sourceProjection || projection);
    } else {
      var cache = this.getTileCacheForProjection(projection);
      var tileCoord = [z, x, y];
      var tile;
      var tileCoordKey = Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_10__["getKey"])(tileCoord);
      if (cache.containsKey(tileCoordKey)) {
        tile = /** @type {!import("../Tile.js").default} */ (cache.get(tileCoordKey));
      }
      var key = this.getKey();
      if (tile && tile.key == key) {
        return tile;
      } else {
        var sourceTileGrid = this.getTileGridForProjection(sourceProjection);
        var targetTileGrid = this.getTileGridForProjection(projection);
        var wrappedTileCoord =
            this.getTileCoordForTileUrlFunction(tileCoord, projection);
        var newTile = new _reproj_Tile_js__WEBPACK_IMPORTED_MODULE_8__["default"](
          sourceProjection, sourceTileGrid,
          projection, targetTileGrid,
          tileCoord, wrappedTileCoord, this.getTilePixelRatio(pixelRatio),
          this.getGutter(),
          function(z, x, y, pixelRatio) {
            return this.getTileInternal(z, x, y, pixelRatio, sourceProjection);
          }.bind(this), this.reprojectionErrorThreshold_,
          this.renderReprojectionEdges_);
        newTile.key = key;

        if (tile) {
          newTile.interimTile = tile;
          newTile.refreshInterimChain();
          cache.replace(tileCoordKey, newTile);
        } else {
          cache.set(tileCoordKey, newTile);
        }
        return newTile;
      }
    }
  };

  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {!import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../Tile.js").default} Tile.
   * @protected
   */
  TileImage.prototype.getTileInternal = function getTileInternal (z, x, y, pixelRatio, projection) {
    var tile = null;
    var tileCoordKey = Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_10__["getKeyZXY"])(z, x, y);
    var key = this.getKey();
    if (!this.tileCache.containsKey(tileCoordKey)) {
      tile = this.createTile_(z, x, y, pixelRatio, projection, key);
      this.tileCache.set(tileCoordKey, tile);
    } else {
      tile = this.tileCache.get(tileCoordKey);
      if (tile.key != key) {
        // The source's params changed. If the tile has an interim tile and if we
        // can use it then we use it. Otherwise we create a new tile.  In both
        // cases we attempt to assign an interim tile to the new tile.
        var interimTile = tile;
        tile = this.createTile_(z, x, y, pixelRatio, projection, key);

        //make the new tile the head of the list,
        if (interimTile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].IDLE) {
          //the old tile hasn't begun loading yet, and is now outdated, so we can simply discard it
          tile.interimTile = interimTile.interimTile;
        } else {
          tile.interimTile = interimTile;
        }
        tile.refreshInterimChain();
        this.tileCache.replace(tileCoordKey, tile);
      }
    }
    return tile;
  };

  /**
   * Sets whether to render reprojection edges or not (usually for debugging).
   * @param {boolean} render Render the edges.
   * @api
   */
  TileImage.prototype.setRenderReprojectionEdges = function setRenderReprojectionEdges (render) {
    if (!_reproj_common_js__WEBPACK_IMPORTED_MODULE_0__["ENABLE_RASTER_REPROJECTION"] ||
        this.renderReprojectionEdges_ == render) {
      return;
    }
    this.renderReprojectionEdges_ = render;
    for (var id in this.tileCacheForProjection) {
      this.tileCacheForProjection[id].clear();
    }
    this.changed();
  };

  /**
   * Sets the tile grid to use when reprojecting the tiles to the given
   * projection instead of the default tile grid for the projection.
   *
   * This can be useful when the default tile grid cannot be created
   * (e.g. projection has no extent defined) or
   * for optimization reasons (custom tile size, resolutions, ...).
   *
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
   * @api
   */
  TileImage.prototype.setTileGridForProjection = function setTileGridForProjection (projection, tilegrid) {
    if (_reproj_common_js__WEBPACK_IMPORTED_MODULE_0__["ENABLE_RASTER_REPROJECTION"]) {
      var proj = Object(_proj_js__WEBPACK_IMPORTED_MODULE_7__["get"])(projection);
      if (proj) {
        var projKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_1__["getUid"])(proj);
        if (!(projKey in this.tileGridForProjection)) {
          this.tileGridForProjection[projKey] = tilegrid;
        }
      }
    }
  };

  return TileImage;
}(_UrlTile_js__WEBPACK_IMPORTED_MODULE_9__["default"]));


/**
 * @param {ImageTile} imageTile Image tile.
 * @param {string} src Source.
 */
function defaultTileLoadFunction(imageTile, src) {
  /** @type {HTMLImageElement|HTMLVideoElement} */ (imageTile.getImage()).src = src;
}

/* harmony default export */ __webpack_exports__["default"] = (TileImage);

//# sourceMappingURL=TileImage.js.map

/***/ }),

/***/ "./node_modules/ol/source/UrlTile.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/source/UrlTile.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tileurlfunction.js */ "./node_modules/ol/tileurlfunction.js");
/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Tile.js */ "./node_modules/ol/source/Tile.js");
/* harmony import */ var _TileEventType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./TileEventType.js */ "./node_modules/ol/source/TileEventType.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");
/**
 * @module ol/source/UrlTile
 */







/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions]
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize]
 * @property {boolean} [opaque]
 * @property {import("../proj.js").ProjectionLike} [projection]
 * @property {import("./State.js").default} [state]
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid]
 * @property {import("../Tile.js").LoadFunction} tileLoadFunction
 * @property {number} [tilePixelRatio]
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction]
 * @property {string} [url]
 * @property {Array<string>} [urls]
 * @property {boolean} [wrapX=true]
 * @property {number} [transition]
 * @property {string} [key]
 */


/**
 * @classdesc
 * Base class for sources providing tiles divided into a tile grid over http.
 *
 * @fires import("./Tile.js").TileSourceEvent
 */
var UrlTile = /*@__PURE__*/(function (TileSource) {
  function UrlTile(options) {

    TileSource.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      opaque: options.opaque,
      projection: options.projection,
      state: options.state,
      tileGrid: options.tileGrid,
      tilePixelRatio: options.tilePixelRatio,
      wrapX: options.wrapX,
      transition: options.transition,
      key: options.key,
      attributionsCollapsible: options.attributionsCollapsible
    });

    /**
     * @private
     * @type {boolean}
     */
    this.generateTileUrlFunction_ = !options.tileUrlFunction;

    /**
     * @protected
     * @type {import("../Tile.js").LoadFunction}
     */
    this.tileLoadFunction = options.tileLoadFunction;

    /**
     * @protected
     * @type {import("../Tile.js").UrlFunction}
     */
    this.tileUrlFunction = options.tileUrlFunction ? options.tileUrlFunction.bind(this) : _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_2__["nullTileUrlFunction"];

    /**
     * @protected
     * @type {!Array<string>|null}
     */
    this.urls = null;

    if (options.urls) {
      this.setUrls(options.urls);
    } else if (options.url) {
      this.setUrl(options.url);
    }

    if (options.tileUrlFunction) {
      this.setTileUrlFunction(options.tileUrlFunction, this.key_);
    }

    /**
     * @private
     * @type {!Object<string, boolean>}
     */
    this.tileLoadingKeys_ = {};

  }

  if ( TileSource ) UrlTile.__proto__ = TileSource;
  UrlTile.prototype = Object.create( TileSource && TileSource.prototype );
  UrlTile.prototype.constructor = UrlTile;

  /**
   * Return the tile load function of the source.
   * @return {import("../Tile.js").LoadFunction} TileLoadFunction
   * @api
   */
  UrlTile.prototype.getTileLoadFunction = function getTileLoadFunction () {
    return this.tileLoadFunction;
  };

  /**
   * Return the tile URL function of the source.
   * @return {import("../Tile.js").UrlFunction} TileUrlFunction
   * @api
   */
  UrlTile.prototype.getTileUrlFunction = function getTileUrlFunction () {
    return this.tileUrlFunction;
  };

  /**
   * Return the URLs used for this source.
   * When a tileUrlFunction is used instead of url or urls,
   * null will be returned.
   * @return {!Array<string>|null} URLs.
   * @api
   */
  UrlTile.prototype.getUrls = function getUrls () {
    return this.urls;
  };

  /**
   * Handle tile change events.
   * @param {import("../events/Event.js").default} event Event.
   * @protected
   */
  UrlTile.prototype.handleTileChange = function handleTileChange (event) {
    var tile = /** @type {import("../Tile.js").default} */ (event.target);
    var uid = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(tile);
    var tileState = tile.getState();
    var type;
    if (tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING) {
      this.tileLoadingKeys_[uid] = true;
      type = _TileEventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].TILELOADSTART;
    } else if (uid in this.tileLoadingKeys_) {
      delete this.tileLoadingKeys_[uid];
      type = tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR ? _TileEventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].TILELOADERROR :
        (tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED || tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ABORT) ?
          _TileEventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].TILELOADEND : undefined;
    }
    if (type != undefined) {
      this.dispatchEvent(new _Tile_js__WEBPACK_IMPORTED_MODULE_3__["TileSourceEvent"](type, tile));
    }
  };

  /**
   * Set the tile load function of the source.
   * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @api
   */
  UrlTile.prototype.setTileLoadFunction = function setTileLoadFunction (tileLoadFunction) {
    this.tileCache.clear();
    this.tileLoadFunction = tileLoadFunction;
    this.changed();
  };

  /**
   * Set the tile URL function of the source.
   * @param {import("../Tile.js").UrlFunction} tileUrlFunction Tile URL function.
   * @param {string=} key Optional new tile key for the source.
   * @api
   */
  UrlTile.prototype.setTileUrlFunction = function setTileUrlFunction (tileUrlFunction, key) {
    this.tileUrlFunction = tileUrlFunction;
    this.tileCache.pruneExceptNewestZ();
    if (typeof key !== 'undefined') {
      this.setKey(key);
    } else {
      this.changed();
    }
  };

  /**
   * Set the URL to use for requests.
   * @param {string} url URL.
   * @api
   */
  UrlTile.prototype.setUrl = function setUrl (url) {
    var urls = this.urls = Object(_tileurlfunction_js__WEBPACK_IMPORTED_MODULE_2__["expandUrl"])(url);
    this.setUrls(urls);
  };

  /**
   * Set the URLs to use for requests.
   * @param {Array<string>} urls URLs.
   * @api
   */
  UrlTile.prototype.setUrls = function setUrls (urls) {
    this.urls = urls;
    var key = urls.join('\n');
    if (this.generateTileUrlFunction_) {
      this.setTileUrlFunction(Object(_tileurlfunction_js__WEBPACK_IMPORTED_MODULE_2__["createFromTemplates"])(urls, this.tileGrid), key);
    } else {
      this.setKey(key);
    }
  };

  /**
   * @inheritDoc
   */
  UrlTile.prototype.useTile = function useTile (z, x, y) {
    var tileCoordKey = Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_5__["getKeyZXY"])(z, x, y);
    if (this.tileCache.containsKey(tileCoordKey)) {
      this.tileCache.get(tileCoordKey);
    }
  };

  return UrlTile;
}(_Tile_js__WEBPACK_IMPORTED_MODULE_3__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (UrlTile);

//# sourceMappingURL=UrlTile.js.map

/***/ }),

/***/ "./node_modules/ol/source/Vector.js":
/*!******************************************!*\
  !*** ./node_modules/ol/source/Vector.js ***!
  \******************************************/
/*! exports provided: VectorSourceEvent, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VectorSourceEvent", function() { return VectorSourceEvent; });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Collection.js */ "./node_modules/ol/Collection.js");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../CollectionEventType.js */ "./node_modules/ol/CollectionEventType.js");
/* harmony import */ var _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ObjectEventType.js */ "./node_modules/ol/ObjectEventType.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _featureloader_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../featureloader.js */ "./node_modules/ol/featureloader.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _loadingstrategy_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../loadingstrategy.js */ "./node_modules/ol/loadingstrategy.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _Source_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Source.js */ "./node_modules/ol/source/Source.js");
/* harmony import */ var _State_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./State.js */ "./node_modules/ol/source/State.js");
/* harmony import */ var _VectorEventType_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./VectorEventType.js */ "./node_modules/ol/source/VectorEventType.js");
/* harmony import */ var _structs_RBush_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../structs/RBush.js */ "./node_modules/ol/structs/RBush.js");
/**
 * @module ol/source/Vector
 */




















/**
 * A function that takes an {@link module:ol/extent~Extent} and a resolution as arguments, and
 * returns an array of {@link module:ol/extent~Extent} with the extents to load. Usually this
 * is one of the standard {@link module:ol/loadingstrategy} strategies.
 *
 * @typedef {function(import("../extent.js").Extent, number): Array<import("../extent.js").Extent>} LoadingStrategy
 * @api
 */


/**
 * @classdesc
 * Events emitted by {@link module:ol/source/Vector} instances are instances of this
 * type.
 */
var VectorSourceEvent = /*@__PURE__*/(function (Event) {
  function VectorSourceEvent(type, opt_feature) {

    Event.call(this, type);

    /**
     * The feature being added or removed.
     * @type {import("../Feature.js").default|undefined}
     * @api
     */
    this.feature = opt_feature;

  }

  if ( Event ) VectorSourceEvent.__proto__ = Event;
  VectorSourceEvent.prototype = Object.create( Event && Event.prototype );
  VectorSourceEvent.prototype.constructor = VectorSourceEvent;

  return VectorSourceEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_7__["default"]));


/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {Array<import("../Feature.js").default>|Collection<import("../Feature.js").default>} [features]
 * Features. If provided as {@link module:ol/Collection}, the features in the source
 * and the collection will stay in sync.
 * @property {import("../format/Feature.js").default} [format] The feature format used by the XHR
 * feature loader when `url` is set. Required if `url` is set, otherwise ignored.
 * @property {import("../featureloader.js").FeatureLoader} [loader]
 * The loader function used to load features, from a remote source for example.
 * If this is not set and `url` is set, the source will create and use an XHR
 * feature loader.
 *
 * Example:
 *
 * ```js
 * import {Vector} from 'ol/source';
 * import {GeoJSON} from 'ol/format';
 * import {bbox} from 'ol/loadingstrategy';
 *
 * var vectorSource = new Vector({
 *   format: new GeoJSON(),
 *   loader: function(extent, resolution, projection) {
 *      var proj = projection.getCode();
 *      var url = 'https://ahocevar.com/geoserver/wfs?service=WFS&' +
 *          'version=1.1.0&request=GetFeature&typename=osm:water_areas&' +
 *          'outputFormat=application/json&srsname=' + proj + '&' +
 *          'bbox=' + extent.join(',') + ',' + proj;
 *      var xhr = new XMLHttpRequest();
 *      xhr.open('GET', url);
 *      var onError = function() {
 *        vectorSource.removeLoadedExtent(extent);
 *      }
 *      xhr.onerror = onError;
 *      xhr.onload = function() {
 *        if (xhr.status == 200) {
 *          vectorSource.addFeatures(
 *              vectorSource.getFormat().readFeatures(xhr.responseText));
 *        } else {
 *          onError();
 *        }
 *      }
 *      xhr.send();
 *    },
 *    strategy: bbox
 *  });
 * ```
 * @property {boolean} [overlaps=true] This source may have overlapping geometries.
 * Setting this to `false` (e.g. for sources with polygons that represent administrative
 * boundaries or TopoJSON sources) allows the renderer to optimise fill and
 * stroke operations.
 * @property {LoadingStrategy} [strategy] The loading strategy to use.
 * By default an {@link module:ol/loadingstrategy~all}
 * strategy is used, a one-off strategy which loads all features at once.
 * @property {string|import("../featureloader.js").FeatureUrlFunction} [url]
 * Setting this option instructs the source to load features using an XHR loader
 * (see {@link module:ol/featureloader~xhr}). Use a `string` and an
 * {@link module:ol/loadingstrategy~all} for a one-off download of all features from
 * the given URL. Use a {@link module:ol/featureloader~FeatureUrlFunction} to generate the url with
 * other loading strategies.
 * Requires `format` to be set as well.
 * When default XHR feature loader is provided, the features will
 * be transformed from the data projection to the view projection
 * during parsing. If your remote data source does not advertise its projection
 * properly, this transformation will be incorrect. For some formats, the
 * default projection (usually EPSG:4326) can be overridden by setting the
 * dataProjection constructor option on the format.
 * Note that if a source contains non-feature data, such as a GeoJSON geometry
 * or a KML NetworkLink, these will be ignored. Use a custom loader to load these.
 * @property {boolean} [useSpatialIndex=true]
 * By default, an RTree is used as spatial index. When features are removed and
 * added frequently, and the total number of features is low, setting this to
 * `false` may improve performance.
 *
 * Note that
 * {@link module:ol/source/Vector~VectorSource#getFeaturesInExtent},
 * {@link module:ol/source/Vector~VectorSource#getClosestFeatureToCoordinate} and
 * {@link module:ol/source/Vector~VectorSource#getExtent} cannot be used when `useSpatialIndex` is
 * set to `false`, and {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent} will loop
 * through all features.
 *
 * When set to `false`, the features will be maintained in an
 * {@link module:ol/Collection}, which can be retrieved through
 * {@link module:ol/source/Vector~VectorSource#getFeaturesCollection}.
 * @property {boolean} [wrapX=true] Wrap the world horizontally. For vector editing across the
 * -180° and 180° meridians to work properly, this should be set to `false`. The
 * resulting geometry coordinates will then exceed the world bounds.
 */


/**
 * @classdesc
 * Provides a source of features for vector layers. Vector features provided
 * by this source are suitable for editing. See {@link module:ol/source/VectorTile~VectorTile} for
 * vector data that is optimized for rendering.
 *
 * @fires ol/source/Vector.VectorSourceEvent
 * @api
 */
var VectorSource = /*@__PURE__*/(function (Source) {
  function VectorSource(opt_options) {

    var options = opt_options || {};

    Source.call(this, {
      attributions: options.attributions,
      projection: undefined,
      state: _State_js__WEBPACK_IMPORTED_MODULE_15__["default"].READY,
      wrapX: options.wrapX !== undefined ? options.wrapX : true
    });

    /**
     * @private
     * @type {import("../featureloader.js").FeatureLoader}
     */
    this.loader_ = _functions_js__WEBPACK_IMPORTED_MODULE_11__["VOID"];

    /**
     * @private
     * @type {import("../format/Feature.js").default|undefined}
     */
    this.format_ = options.format;

    /**
     * @private
     * @type {boolean}
     */
    this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;

    /**
     * @private
     * @type {string|import("../featureloader.js").FeatureUrlFunction|undefined}
     */
    this.url_ = options.url;

    if (options.loader !== undefined) {
      this.loader_ = options.loader;
    } else if (this.url_ !== undefined) {
      Object(_asserts_js__WEBPACK_IMPORTED_MODULE_5__["assert"])(this.format_, 7); // `format` must be set when `url` is set
      // create a XHR feature loader for "url" and "format"
      this.loader_ = Object(_featureloader_js__WEBPACK_IMPORTED_MODULE_10__["xhr"])(this.url_, /** @type {import("../format/Feature.js").default} */ (this.format_));
    }

    /**
     * @private
     * @type {LoadingStrategy}
     */
    this.strategy_ = options.strategy !== undefined ? options.strategy : _loadingstrategy_js__WEBPACK_IMPORTED_MODULE_12__["all"];

    var useSpatialIndex =
        options.useSpatialIndex !== undefined ? options.useSpatialIndex : true;

    /**
     * @private
     * @type {RBush<import("../Feature.js").default>}
     */
    this.featuresRtree_ = useSpatialIndex ? new _structs_RBush_js__WEBPACK_IMPORTED_MODULE_17__["default"]() : null;

    /**
     * @private
     * @type {RBush<{extent: import("../extent.js").Extent}>}
     */
    this.loadedExtentsRtree_ = new _structs_RBush_js__WEBPACK_IMPORTED_MODULE_17__["default"]();

    /**
     * @private
     * @type {!Object<string, import("../Feature.js").default>}
     */
    this.nullGeometryFeatures_ = {};

    /**
     * A lookup of features by id (the return from feature.getId()).
     * @private
     * @type {!Object<string, import("../Feature.js").default>}
     */
    this.idIndex_ = {};

    /**
     * A lookup of features without id (keyed by getUid(feature)).
     * @private
     * @type {!Object<string, import("../Feature.js").default>}
     */
    this.undefIdIndex_ = {};

    /**
     * @private
     * @type {Object<string, Array<import("../events.js").EventsKey>>}
     */
    this.featureChangeKeys_ = {};

    /**
     * @private
     * @type {Collection<import("../Feature.js").default>}
     */
    this.featuresCollection_ = null;

    var collection, features;
    if (Array.isArray(options.features)) {
      features = options.features;
    } else if (options.features) {
      collection = options.features;
      features = collection.getArray();
    }
    if (!useSpatialIndex && collection === undefined) {
      collection = new _Collection_js__WEBPACK_IMPORTED_MODULE_1__["default"](features);
    }
    if (features !== undefined) {
      this.addFeaturesInternal(features);
    }
    if (collection !== undefined) {
      this.bindFeaturesCollection_(collection);
    }

  }

  if ( Source ) VectorSource.__proto__ = Source;
  VectorSource.prototype = Object.create( Source && Source.prototype );
  VectorSource.prototype.constructor = VectorSource;

  /**
   * Add a single feature to the source.  If you want to add a batch of features
   * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
   * instead. A feature will not be added to the source if feature with
   * the same id is already there. The reason for this behavior is to avoid
   * feature duplication when using bbox or tile loading strategies.
   * @param {import("../Feature.js").default} feature Feature to add.
   * @api
   */
  VectorSource.prototype.addFeature = function addFeature (feature) {
    this.addFeatureInternal(feature);
    this.changed();
  };


  /**
   * Add a feature without firing a `change` event.
   * @param {import("../Feature.js").default} feature Feature.
   * @protected
   */
  VectorSource.prototype.addFeatureInternal = function addFeatureInternal (feature) {
    var featureKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature);

    if (!this.addToIndex_(featureKey, feature)) {
      return;
    }

    this.setupChangeEvents_(featureKey, feature);

    var geometry = feature.getGeometry();
    if (geometry) {
      var extent = geometry.getExtent();
      if (this.featuresRtree_) {
        this.featuresRtree_.insert(extent, feature);
      }
    } else {
      this.nullGeometryFeatures_[featureKey] = feature;
    }

    this.dispatchEvent(
      new VectorSourceEvent(_VectorEventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].ADDFEATURE, feature));
  };


  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {import("../Feature.js").default} feature The feature.
   * @private
   */
  VectorSource.prototype.setupChangeEvents_ = function setupChangeEvents_ (featureKey, feature) {
    this.featureChangeKeys_[featureKey] = [
      Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(feature, _events_EventType_js__WEBPACK_IMPORTED_MODULE_8__["default"].CHANGE,
        this.handleFeatureChange_, this),
      Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(feature, _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].PROPERTYCHANGE,
        this.handleFeatureChange_, this)
    ];
  };


  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {import("../Feature.js").default} feature The feature.
   * @return {boolean} The feature is "valid", in the sense that it is also a
   *     candidate for insertion into the Rtree.
   * @private
   */
  VectorSource.prototype.addToIndex_ = function addToIndex_ (featureKey, feature) {
    var valid = true;
    var id = feature.getId();
    if (id !== undefined) {
      if (!(id.toString() in this.idIndex_)) {
        this.idIndex_[id.toString()] = feature;
      } else {
        valid = false;
      }
    } else {
      Object(_asserts_js__WEBPACK_IMPORTED_MODULE_5__["assert"])(!(featureKey in this.undefIdIndex_),
        30); // The passed `feature` was already added to the source
      this.undefIdIndex_[featureKey] = feature;
    }
    return valid;
  };


  /**
   * Add a batch of features to the source.
   * @param {Array<import("../Feature.js").default>} features Features to add.
   * @api
   */
  VectorSource.prototype.addFeatures = function addFeatures (features) {
    this.addFeaturesInternal(features);
    this.changed();
  };


  /**
   * Add features without firing a `change` event.
   * @param {Array<import("../Feature.js").default>} features Features.
   * @protected
   */
  VectorSource.prototype.addFeaturesInternal = function addFeaturesInternal (features) {
    var extents = [];
    var newFeatures = [];
    var geometryFeatures = [];

    for (var i = 0, length = features.length; i < length; i++) {
      var feature = features[i];
      var featureKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature);
      if (this.addToIndex_(featureKey, feature)) {
        newFeatures.push(feature);
      }
    }

    for (var i$1 = 0, length$1 = newFeatures.length; i$1 < length$1; i$1++) {
      var feature$1 = newFeatures[i$1];
      var featureKey$1 = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature$1);
      this.setupChangeEvents_(featureKey$1, feature$1);

      var geometry = feature$1.getGeometry();
      if (geometry) {
        var extent = geometry.getExtent();
        extents.push(extent);
        geometryFeatures.push(feature$1);
      } else {
        this.nullGeometryFeatures_[featureKey$1] = feature$1;
      }
    }
    if (this.featuresRtree_) {
      this.featuresRtree_.load(extents, geometryFeatures);
    }

    for (var i$2 = 0, length$2 = newFeatures.length; i$2 < length$2; i$2++) {
      this.dispatchEvent(new VectorSourceEvent(_VectorEventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].ADDFEATURE, newFeatures[i$2]));
    }
  };


  /**
   * @param {!Collection<import("../Feature.js").default>} collection Collection.
   * @private
   */
  VectorSource.prototype.bindFeaturesCollection_ = function bindFeaturesCollection_ (collection) {
    var modifyingCollection = false;
    Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(this, _VectorEventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].ADDFEATURE,
      /**
       * @param {VectorSourceEvent} evt The vector source event
       */
      function(evt) {
        if (!modifyingCollection) {
          modifyingCollection = true;
          collection.push(evt.feature);
          modifyingCollection = false;
        }
      });
    Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(this, _VectorEventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].REMOVEFEATURE,
      /**
       * @param {VectorSourceEvent} evt The vector source event
       */
      function(evt) {
        if (!modifyingCollection) {
          modifyingCollection = true;
          collection.remove(evt.feature);
          modifyingCollection = false;
        }
      });
    Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(collection, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].ADD,
      /**
       * @param {import("../Collection.js").CollectionEvent} evt The collection event
       */
      function(evt) {
        if (!modifyingCollection) {
          modifyingCollection = true;
          this.addFeature(/** @type {import("../Feature.js").default} */ (evt.element));
          modifyingCollection = false;
        }
      }, this);
    Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(collection, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].REMOVE,
      /**
       * @param {import("../Collection.js").CollectionEvent} evt The collection event
       */
      function(evt) {
        if (!modifyingCollection) {
          modifyingCollection = true;
          this.removeFeature(/** @type {import("../Feature.js").default} */ (evt.element));
          modifyingCollection = false;
        }
      }, this);
    this.featuresCollection_ = collection;
  };


  /**
   * Remove all features from the source.
   * @param {boolean=} opt_fast Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#removefeature} events.
   * @api
   */
  VectorSource.prototype.clear = function clear (opt_fast) {
    if (opt_fast) {
      for (var featureId in this.featureChangeKeys_) {
        var keys = this.featureChangeKeys_[featureId];
        keys.forEach(_events_js__WEBPACK_IMPORTED_MODULE_6__["unlistenByKey"]);
      }
      if (!this.featuresCollection_) {
        this.featureChangeKeys_ = {};
        this.idIndex_ = {};
        this.undefIdIndex_ = {};
      }
    } else {
      if (this.featuresRtree_) {
        this.featuresRtree_.forEach(this.removeFeatureInternal, this);
        for (var id in this.nullGeometryFeatures_) {
          this.removeFeatureInternal(this.nullGeometryFeatures_[id]);
        }
      }
    }
    if (this.featuresCollection_) {
      this.featuresCollection_.clear();
    }

    if (this.featuresRtree_) {
      this.featuresRtree_.clear();
    }
    this.loadedExtentsRtree_.clear();
    this.nullGeometryFeatures_ = {};

    var clearEvent = new VectorSourceEvent(_VectorEventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].CLEAR);
    this.dispatchEvent(clearEvent);
    this.changed();
  };


  /**
   * Iterate through all features on the source, calling the provided callback
   * with each one.  If the callback returns any "truthy" value, iteration will
   * stop and the function will return the same value.
   * Note: this function only iterate through the feature that have a defined geometry.
   *
   * @param {function(import("../Feature.js").default): T} callback Called with each feature
   *     on the source.  Return a truthy value to stop iteration.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  VectorSource.prototype.forEachFeature = function forEachFeature (callback) {
    if (this.featuresRtree_) {
      return this.featuresRtree_.forEach(callback);
    } else if (this.featuresCollection_) {
      this.featuresCollection_.forEach(callback);
    }
  };


  /**
   * Iterate through all features whose geometries contain the provided
   * coordinate, calling the callback with each feature.  If the callback returns
   * a "truthy" value, iteration will stop and the function will return the same
   * value.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(import("../Feature.js").default): T} callback Called with each feature
   *     whose goemetry contains the provided coordinate.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   */
  VectorSource.prototype.forEachFeatureAtCoordinateDirect = function forEachFeatureAtCoordinateDirect (coordinate, callback) {
    var extent = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];
    return this.forEachFeatureInExtent(extent, function(feature) {
      var geometry = feature.getGeometry();
      if (geometry.intersectsCoordinate(coordinate)) {
        return callback(feature);
      } else {
        return undefined;
      }
    });
  };


  /**
   * Iterate through all features whose bounding box intersects the provided
   * extent (note that the feature's geometry may not intersect the extent),
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you are interested in features whose geometry intersects an extent, call
   * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
   *
   * When `useSpatialIndex` is set to false, this method will loop through all
   * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(import("../Feature.js").default): T} callback Called with each feature
   *     whose bounding box intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  VectorSource.prototype.forEachFeatureInExtent = function forEachFeatureInExtent (extent, callback) {
    if (this.featuresRtree_) {
      return this.featuresRtree_.forEachInExtent(extent, callback);
    } else if (this.featuresCollection_) {
      this.featuresCollection_.forEach(callback);
    }
  };


  /**
   * Iterate through all features whose geometry intersects the provided extent,
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you only want to test for bounding box intersection, call the
   * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(import("../Feature.js").default): T} callback Called with each feature
   *     whose geometry intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  VectorSource.prototype.forEachFeatureIntersectingExtent = function forEachFeatureIntersectingExtent (extent, callback) {
    return this.forEachFeatureInExtent(extent,
      /**
       * @param {import("../Feature.js").default} feature Feature.
       * @return {T|undefined} The return value from the last call to the callback.
       */
      function(feature) {
        var geometry = feature.getGeometry();
        if (geometry.intersectsExtent(extent)) {
          var result = callback(feature);
          if (result) {
            return result;
          }
        }
      });
  };


  /**
   * Get the features collection associated with this source. Will be `null`
   * unless the source was configured with `useSpatialIndex` set to `false`, or
   * with an {@link module:ol/Collection} as `features`.
   * @return {Collection<import("../Feature.js").default>} The collection of features.
   * @api
   */
  VectorSource.prototype.getFeaturesCollection = function getFeaturesCollection () {
    return this.featuresCollection_;
  };


  /**
   * Get all features on the source in random order.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */
  VectorSource.prototype.getFeatures = function getFeatures () {
    var features;
    if (this.featuresCollection_) {
      features = this.featuresCollection_.getArray();
    } else if (this.featuresRtree_) {
      features = this.featuresRtree_.getAll();
      if (!Object(_obj_js__WEBPACK_IMPORTED_MODULE_13__["isEmpty"])(this.nullGeometryFeatures_)) {
        Object(_array_js__WEBPACK_IMPORTED_MODULE_4__["extend"])(features, Object(_obj_js__WEBPACK_IMPORTED_MODULE_13__["getValues"])(this.nullGeometryFeatures_));
      }
    }
    return (
      /** @type {Array<import("../Feature.js").default>} */ (features)
    );
  };


  /**
   * Get all features whose geometry intersects the provided coordinate.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */
  VectorSource.prototype.getFeaturesAtCoordinate = function getFeaturesAtCoordinate (coordinate) {
    var features = [];
    this.forEachFeatureAtCoordinateDirect(coordinate, function(feature) {
      features.push(feature);
    });
    return features;
  };


  /**
   * Get all features in the provided extent.  Note that this returns an array of
   * all features intersecting the given extent in random order (so it may include
   * features whose geometries do not intersect the extent).
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false`.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */
  VectorSource.prototype.getFeaturesInExtent = function getFeaturesInExtent (extent) {
    return this.featuresRtree_.getInExtent(extent);
  };


  /**
   * Get the closest feature to the provided coordinate.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false`.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(import("../Feature.js").default):boolean=} opt_filter Feature filter function.
   *     The filter function will receive one argument, the {@link module:ol/Feature feature}
   *     and it should return a boolean value. By default, no filtering is made.
   * @return {import("../Feature.js").default} Closest feature.
   * @api
   */
  VectorSource.prototype.getClosestFeatureToCoordinate = function getClosestFeatureToCoordinate (coordinate, opt_filter) {
    // Find the closest feature using branch and bound.  We start searching an
    // infinite extent, and find the distance from the first feature found.  This
    // becomes the closest feature.  We then compute a smaller extent which any
    // closer feature must intersect.  We continue searching with this smaller
    // extent, trying to find a closer feature.  Every time we find a closer
    // feature, we update the extent being searched so that any even closer
    // feature must intersect it.  We continue until we run out of features.
    var x = coordinate[0];
    var y = coordinate[1];
    var closestFeature = null;
    var closestPoint = [NaN, NaN];
    var minSquaredDistance = Infinity;
    var extent = [-Infinity, -Infinity, Infinity, Infinity];
    var filter = opt_filter ? opt_filter : _functions_js__WEBPACK_IMPORTED_MODULE_11__["TRUE"];
    this.featuresRtree_.forEachInExtent(extent,
      /**
       * @param {import("../Feature.js").default} feature Feature.
       */
      function(feature) {
        if (filter(feature)) {
          var geometry = feature.getGeometry();
          var previousMinSquaredDistance = minSquaredDistance;
          minSquaredDistance = geometry.closestPointXY(
            x, y, closestPoint, minSquaredDistance);
          if (minSquaredDistance < previousMinSquaredDistance) {
            closestFeature = feature;
            // This is sneaky.  Reduce the extent that it is currently being
            // searched while the R-Tree traversal using this same extent object
            // is still in progress.  This is safe because the new extent is
            // strictly contained by the old extent.
            var minDistance = Math.sqrt(minSquaredDistance);
            extent[0] = x - minDistance;
            extent[1] = y - minDistance;
            extent[2] = x + minDistance;
            extent[3] = y + minDistance;
          }
        }
      });
    return closestFeature;
  };


  /**
   * Get the extent of the features currently in the source.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false`.
   * @param {import("../extent.js").Extent=} opt_extent Destination extent. If provided, no new extent
   *     will be created. Instead, that extent's coordinates will be overwritten.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  VectorSource.prototype.getExtent = function getExtent (opt_extent) {
    return this.featuresRtree_.getExtent(opt_extent);
  };


  /**
   * Get a feature by its identifier (the value returned by feature.getId()).
   * Note that the index treats string and numeric identifiers as the same.  So
   * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
   *
   * @param {string|number} id Feature identifier.
   * @return {import("../Feature.js").default} The feature (or `null` if not found).
   * @api
   */
  VectorSource.prototype.getFeatureById = function getFeatureById (id) {
    var feature = this.idIndex_[id.toString()];
    return feature !== undefined ? feature : null;
  };


  /**
   * Get the format associated with this source.
   *
   * @return {import("../format/Feature.js").default|undefined} The feature format.
   * @api
   */
  VectorSource.prototype.getFormat = function getFormat () {
    return this.format_;
  };


  /**
   * @return {boolean} The source can have overlapping geometries.
   */
  VectorSource.prototype.getOverlaps = function getOverlaps () {
    return this.overlaps_;
  };


  /**
   * Get the url associated with this source.
   *
   * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.
   * @api
   */
  VectorSource.prototype.getUrl = function getUrl () {
    return this.url_;
  };


  /**
   * @param {Event} event Event.
   * @private
   */
  VectorSource.prototype.handleFeatureChange_ = function handleFeatureChange_ (event) {
    var feature = /** @type {import("../Feature.js").default} */ (event.target);
    var featureKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature);
    var geometry = feature.getGeometry();
    if (!geometry) {
      if (!(featureKey in this.nullGeometryFeatures_)) {
        if (this.featuresRtree_) {
          this.featuresRtree_.remove(feature);
        }
        this.nullGeometryFeatures_[featureKey] = feature;
      }
    } else {
      var extent = geometry.getExtent();
      if (featureKey in this.nullGeometryFeatures_) {
        delete this.nullGeometryFeatures_[featureKey];
        if (this.featuresRtree_) {
          this.featuresRtree_.insert(extent, feature);
        }
      } else {
        if (this.featuresRtree_) {
          this.featuresRtree_.update(extent, feature);
        }
      }
    }
    var id = feature.getId();
    if (id !== undefined) {
      var sid = id.toString();
      if (featureKey in this.undefIdIndex_) {
        delete this.undefIdIndex_[featureKey];
        this.idIndex_[sid] = feature;
      } else {
        if (this.idIndex_[sid] !== feature) {
          this.removeFromIdIndex_(feature);
          this.idIndex_[sid] = feature;
        }
      }
    } else {
      if (!(featureKey in this.undefIdIndex_)) {
        this.removeFromIdIndex_(feature);
        this.undefIdIndex_[featureKey] = feature;
      }
    }
    this.changed();
    this.dispatchEvent(new VectorSourceEvent(
      _VectorEventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].CHANGEFEATURE, feature));
  };

  /**
   * Returns true if the feature is contained within the source.
   * @param {import("../Feature.js").default} feature Feature.
   * @return {boolean} Has feature.
   * @api
   */
  VectorSource.prototype.hasFeature = function hasFeature (feature) {
    var id = feature.getId();
    if (id !== undefined) {
      return id in this.idIndex_;
    } else {
      return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature) in this.undefIdIndex_;
    }
  };

  /**
   * @return {boolean} Is empty.
   */
  VectorSource.prototype.isEmpty = function isEmpty$1 () {
    return this.featuresRtree_.isEmpty() && Object(_obj_js__WEBPACK_IMPORTED_MODULE_13__["isEmpty"])(this.nullGeometryFeatures_);
  };


  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  VectorSource.prototype.loadFeatures = function loadFeatures (extent, resolution, projection) {
    var this$1 = this;

    var loadedExtentsRtree = this.loadedExtentsRtree_;
    var extentsToLoad = this.strategy_(extent, resolution);
    this.loading = false;
    var loop = function ( i, ii ) {
      var extentToLoad = extentsToLoad[i];
      var alreadyLoaded = loadedExtentsRtree.forEachInExtent(extentToLoad,
        /**
         * @param {{extent: import("../extent.js").Extent}} object Object.
         * @return {boolean} Contains.
         */
        function(object) {
          return Object(_extent_js__WEBPACK_IMPORTED_MODULE_9__["containsExtent"])(object.extent, extentToLoad);
        });
      if (!alreadyLoaded) {
        this$1.loader_.call(this$1, extentToLoad, resolution, projection);
        loadedExtentsRtree.insert(extentToLoad, {extent: extentToLoad.slice()});
        this$1.loading = this$1.loader_ !== _functions_js__WEBPACK_IMPORTED_MODULE_11__["VOID"];
      }
    };

    for (var i = 0, ii = extentsToLoad.length; i < ii; ++i) loop( i, ii );
  };


  /**
   * Remove an extent from the list of loaded extents.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */
  VectorSource.prototype.removeLoadedExtent = function removeLoadedExtent (extent) {
    var loadedExtentsRtree = this.loadedExtentsRtree_;
    var obj;
    loadedExtentsRtree.forEachInExtent(extent, function(object) {
      if (Object(_extent_js__WEBPACK_IMPORTED_MODULE_9__["equals"])(object.extent, extent)) {
        obj = object;
        return true;
      }
    });
    if (obj) {
      loadedExtentsRtree.remove(obj);
    }
  };


  /**
   * Remove a single feature from the source.  If you want to remove all features
   * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
   * instead.
   * @param {import("../Feature.js").default} feature Feature to remove.
   * @api
   */
  VectorSource.prototype.removeFeature = function removeFeature (feature) {
    var featureKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature);
    if (featureKey in this.nullGeometryFeatures_) {
      delete this.nullGeometryFeatures_[featureKey];
    } else {
      if (this.featuresRtree_) {
        this.featuresRtree_.remove(feature);
      }
    }
    this.removeFeatureInternal(feature);
    this.changed();
  };


  /**
   * Remove feature without firing a `change` event.
   * @param {import("../Feature.js").default} feature Feature.
   * @protected
   */
  VectorSource.prototype.removeFeatureInternal = function removeFeatureInternal (feature) {
    var featureKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature);
    this.featureChangeKeys_[featureKey].forEach(_events_js__WEBPACK_IMPORTED_MODULE_6__["unlistenByKey"]);
    delete this.featureChangeKeys_[featureKey];
    var id = feature.getId();
    if (id !== undefined) {
      delete this.idIndex_[id.toString()];
    } else {
      delete this.undefIdIndex_[featureKey];
    }
    this.dispatchEvent(new VectorSourceEvent(
      _VectorEventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].REMOVEFEATURE, feature));
  };


  /**
   * Remove a feature from the id index.  Called internally when the feature id
   * may have changed.
   * @param {import("../Feature.js").default} feature The feature.
   * @return {boolean} Removed the feature from the index.
   * @private
   */
  VectorSource.prototype.removeFromIdIndex_ = function removeFromIdIndex_ (feature) {
    var removed = false;
    for (var id in this.idIndex_) {
      if (this.idIndex_[id] === feature) {
        delete this.idIndex_[id];
        removed = true;
        break;
      }
    }
    return removed;
  };


  /**
   * Set the new loader of the source. The next loadFeatures call will use the
   * new loader.
   * @param {import("../featureloader.js").FeatureLoader} loader The loader to set.
   * @api
   */
  VectorSource.prototype.setLoader = function setLoader (loader) {
    this.loader_ = loader;
  };

  return VectorSource;
}(_Source_js__WEBPACK_IMPORTED_MODULE_14__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (VectorSource);

//# sourceMappingURL=Vector.js.map

/***/ }),

/***/ "./node_modules/ol/source/VectorEventType.js":
/*!***************************************************!*\
  !*** ./node_modules/ol/source/VectorEventType.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/source/VectorEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  /**
   * Triggered when a feature is added to the source.
   * @event ol/source/Vector.VectorSourceEvent#addfeature
   * @api
   */
  ADDFEATURE: 'addfeature',

  /**
   * Triggered when a feature is updated.
   * @event ol/source/Vector.VectorSourceEvent#changefeature
   * @api
   */
  CHANGEFEATURE: 'changefeature',

  /**
   * Triggered when the clear method is called on the source.
   * @event ol/source/Vector.VectorSourceEvent#clear
   * @api
   */
  CLEAR: 'clear',

  /**
   * Triggered when a feature is removed from the source.
   * See {@link module:ol/source/Vector#clear source.clear()} for exceptions.
   * @event ol/source/Vector.VectorSourceEvent#removefeature
   * @api
   */
  REMOVEFEATURE: 'removefeature'
});

//# sourceMappingURL=VectorEventType.js.map

/***/ }),

/***/ "./node_modules/ol/source/XYZ.js":
/*!***************************************!*\
  !*** ./node_modules/ol/source/XYZ.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _TileImage_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TileImage.js */ "./node_modules/ol/source/TileImage.js");
/* harmony import */ var _tilegrid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tilegrid.js */ "./node_modules/ol/tilegrid.js");
/**
 * @module ol/source/XYZ
 */




/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize=2048] Cache size.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you are using the WebGL renderer or if you want to
 * access pixel data with the Canvas renderer.  See
 * https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [opaque=true] Whether the layer is opaque.
 * @property {import("../proj.js").ProjectionLike} [projection='EPSG:3857'] Projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {number} [maxZoom=18] Optional max zoom level.
 * @property {number} [minZoom=0] Optional min zoom level.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service.
 * For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px
 * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
 * should be set to `2`.
 * @property {number|import("../size.js").Size} [tileSize=[256, 256]] The tile size used by the tile service.
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Optional function to get
 * tile URL given a tile coordinate and the projection.
 * Required if url or urls are not provided.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`,
 * and `{z}` placeholders. A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`,
 * may be used instead of defining each one separately in the `urls` option.
 * @property {Array<string>} [urls] An array of URL templates.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 */


/**
 * @classdesc
 * Layer source for tile data with URLs in a set XYZ format that are
 * defined in a URL template. By default, this follows the widely-used
 * Google grid where `x` 0 and `y` 0 are in the top left. Grids like
 * TMS where `x` 0 and `y` 0 are in the bottom left can be used by
 * using the `{-y}` placeholder in the URL template, so long as the
 * source does not have a custom tile grid. In this case,
 * {@link module:ol/source/TileImage} can be used with a `tileUrlFunction`
 * such as:
 *
 *  tileUrlFunction: function(coordinate) {
 *    return 'http://mapserver.com/' + coordinate[0] + '/' +
 *        coordinate[1] + '/' + coordinate[2] + '.png';
 *    }
 *
 * @api
 */
var XYZ = /*@__PURE__*/(function (TileImage) {
  function XYZ(opt_options) {
    var options = opt_options || {};
    var projection = options.projection !== undefined ?
      options.projection : 'EPSG:3857';

    var tileGrid = options.tileGrid !== undefined ? options.tileGrid :
      Object(_tilegrid_js__WEBPACK_IMPORTED_MODULE_1__["createXYZ"])({
        extent: Object(_tilegrid_js__WEBPACK_IMPORTED_MODULE_1__["extentFromProjection"])(projection),
        maxZoom: options.maxZoom,
        minZoom: options.minZoom,
        tileSize: options.tileSize
      });

    TileImage.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      opaque: options.opaque,
      projection: projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileGrid: tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX !== undefined ? options.wrapX : true,
      transition: options.transition,
      attributionsCollapsible: options.attributionsCollapsible
    });

  }

  if ( TileImage ) XYZ.__proto__ = TileImage;
  XYZ.prototype = Object.create( TileImage && TileImage.prototype );
  XYZ.prototype.constructor = XYZ;

  return XYZ;
}(_TileImage_js__WEBPACK_IMPORTED_MODULE_0__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (XYZ);

//# sourceMappingURL=XYZ.js.map

/***/ }),

/***/ "./node_modules/ol/sphere.js":
/*!***********************************!*\
  !*** ./node_modules/ol/sphere.js ***!
  \***********************************/
/*! exports provided: DEFAULT_RADIUS, getDistance, getLength, getArea, offset */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_RADIUS", function() { return DEFAULT_RADIUS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDistance", function() { return getDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLength", function() { return getLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getArea", function() { return getArea; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "offset", function() { return offset; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/**
 * @license
 * Latitude/longitude spherical geodesy formulae taken from
 * http://www.movable-type.co.uk/scripts/latlong.html
 * Licensed under CC-BY-3.0.
 */

/**
 * @module ol/sphere
 */




/**
 * Object literal with options for the {@link getLength} or {@link getArea}
 * functions.
 * @typedef {Object} SphereMetricOptions
 * @property {import("./proj.js").ProjectionLike} [projection='EPSG:3857']
 * Projection of the  geometry.  By default, the geometry is assumed to be in
 * Web Mercator.
 * @property {number} [radius=6371008.8] Sphere radius.  By default, the radius of the
 * earth is used (Clarke 1866 Authalic Sphere).
 */


/**
 * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.
 * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius
 * @type {number}
 */
var DEFAULT_RADIUS = 6371008.8;


/**
 * Get the great circle distance (in meters) between two geographic coordinates.
 * @param {Array} c1 Starting coordinate.
 * @param {Array} c2 Ending coordinate.
 * @param {number=} opt_radius The sphere radius to use.  Defaults to the Earth's
 *     mean radius using the WGS84 ellipsoid.
 * @return {number} The great circle distance between the points (in meters).
 * @api
 */
function getDistance(c1, c2, opt_radius) {
  var radius = opt_radius || DEFAULT_RADIUS;
  var lat1 = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toRadians"])(c1[1]);
  var lat2 = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toRadians"])(c2[1]);
  var deltaLatBy2 = (lat2 - lat1) / 2;
  var deltaLonBy2 = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toRadians"])(c2[0] - c1[0]) / 2;
  var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) +
      Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) *
      Math.cos(lat1) * Math.cos(lat2);
  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}


/**
 * Get the cumulative great circle length of linestring coordinates (geographic).
 * @param {Array} coordinates Linestring coordinates.
 * @param {number} radius The sphere radius to use.
 * @return {number} The length (in meters).
 */
function getLengthInternal(coordinates, radius) {
  var length = 0;
  for (var i = 0, ii = coordinates.length; i < ii - 1; ++i) {
    length += getDistance(coordinates[i], coordinates[i + 1], radius);
  }
  return length;
}


/**
 * Get the spherical length of a geometry.  This length is the sum of the
 * great circle distances between coordinates.  For polygons, the length is
 * the sum of all rings.  For points, the length is zero.  For multi-part
 * geometries, the length is the sum of the length of each part.
 * @param {import("./geom/Geometry.js").default} geometry A geometry.
 * @param {SphereMetricOptions=} opt_options Options for the
 * length calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 * You can change this by providing a `projection` option.
 * @return {number} The spherical length (in meters).
 * @api
 */
function getLength(geometry, opt_options) {
  var options = opt_options || {};
  var radius = options.radius || DEFAULT_RADIUS;
  var projection = options.projection || 'EPSG:3857';
  var type = geometry.getType();
  if (type !== _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].GEOMETRY_COLLECTION) {
    geometry = geometry.clone().transform(projection, 'EPSG:4326');
  }
  var length = 0;
  var coordinates, coords, i, ii, j, jj;
  switch (type) {
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINT:
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POINT: {
      break;
    }
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINE_STRING:
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINEAR_RING: {
      coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ (geometry).getCoordinates();
      length = getLengthInternal(coordinates, radius);
      break;
    }
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_LINE_STRING:
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POLYGON: {
      coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ (geometry).getCoordinates();
      for (i = 0, ii = coordinates.length; i < ii; ++i) {
        length += getLengthInternal(coordinates[i], radius);
      }
      break;
    }
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POLYGON: {
      coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ (geometry).getCoordinates();
      for (i = 0, ii = coordinates.length; i < ii; ++i) {
        coords = coordinates[i];
        for (j = 0, jj = coords.length; j < jj; ++j) {
          length += getLengthInternal(coords[j], radius);
        }
      }
      break;
    }
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].GEOMETRY_COLLECTION: {
      var geometries = /** @type {import("./geom/GeometryCollection.js").default} */ (geometry).getGeometries();
      for (i = 0, ii = geometries.length; i < ii; ++i) {
        length += getLength(geometries[i], opt_options);
      }
      break;
    }
    default: {
      throw new Error('Unsupported geometry type: ' + type);
    }
  }
  return length;
}


/**
 * Returns the spherical area for a list of coordinates.
 *
 * [Reference](https://trs-new.jpl.nasa.gov/handle/2014/40409)
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 * Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 * Laboratory, Pasadena, CA, June 2007
 *
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates List of coordinates of a linear
 * ring. If the ring is oriented clockwise, the area will be positive,
 * otherwise it will be negative.
 * @param {number} radius The sphere radius.
 * @return {number} Area (in square meters).
 */
function getAreaInternal(coordinates, radius) {
  var area = 0;
  var len = coordinates.length;
  var x1 = coordinates[len - 1][0];
  var y1 = coordinates[len - 1][1];
  for (var i = 0; i < len; i++) {
    var x2 = coordinates[i][0];
    var y2 = coordinates[i][1];
    area += Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toRadians"])(x2 - x1) *
        (2 + Math.sin(Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toRadians"])(y1)) +
        Math.sin(Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toRadians"])(y2)));
    x1 = x2;
    y1 = y2;
  }
  return area * radius * radius / 2.0;
}


/**
 * Get the spherical area of a geometry.  This is the area (in meters) assuming
 * that polygon edges are segments of great circles on a sphere.
 * @param {import("./geom/Geometry.js").default} geometry A geometry.
 * @param {SphereMetricOptions=} opt_options Options for the area
 *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 *     You can change this by providing a `projection` option.
 * @return {number} The spherical area (in square meters).
 * @api
 */
function getArea(geometry, opt_options) {
  var options = opt_options || {};
  var radius = options.radius || DEFAULT_RADIUS;
  var projection = options.projection || 'EPSG:3857';
  var type = geometry.getType();
  if (type !== _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].GEOMETRY_COLLECTION) {
    geometry = geometry.clone().transform(projection, 'EPSG:4326');
  }
  var area = 0;
  var coordinates, coords, i, ii, j, jj;
  switch (type) {
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINT:
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POINT:
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINE_STRING:
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_LINE_STRING:
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINEAR_RING: {
      break;
    }
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POLYGON: {
      coordinates = /** @type {import("./geom/Polygon.js").default} */ (geometry).getCoordinates();
      area = Math.abs(getAreaInternal(coordinates[0], radius));
      for (i = 1, ii = coordinates.length; i < ii; ++i) {
        area -= Math.abs(getAreaInternal(coordinates[i], radius));
      }
      break;
    }
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POLYGON: {
      coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ (geometry).getCoordinates();
      for (i = 0, ii = coordinates.length; i < ii; ++i) {
        coords = coordinates[i];
        area += Math.abs(getAreaInternal(coords[0], radius));
        for (j = 1, jj = coords.length; j < jj; ++j) {
          area -= Math.abs(getAreaInternal(coords[j], radius));
        }
      }
      break;
    }
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].GEOMETRY_COLLECTION: {
      var geometries = /** @type {import("./geom/GeometryCollection.js").default} */ (geometry).getGeometries();
      for (i = 0, ii = geometries.length; i < ii; ++i) {
        area += getArea(geometries[i], opt_options);
      }
      break;
    }
    default: {
      throw new Error('Unsupported geometry type: ' + type);
    }
  }
  return area;
}


/**
 * Returns the coordinate at the given distance and bearing from `c1`.
 *
 * @param {import("./coordinate.js").Coordinate} c1 The origin point (`[lon, lat]` in degrees).
 * @param {number} distance The great-circle distance between the origin
 *     point and the target point.
 * @param {number} bearing The bearing (in radians).
 * @param {number=} opt_radius The sphere radius to use.  Defaults to the Earth's
 *     mean radius using the WGS84 ellipsoid.
 * @return {import("./coordinate.js").Coordinate} The target point.
 */
function offset(c1, distance, bearing, opt_radius) {
  var radius = opt_radius || DEFAULT_RADIUS;
  var lat1 = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toRadians"])(c1[1]);
  var lon1 = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toRadians"])(c1[0]);
  var dByR = distance / radius;
  var lat = Math.asin(
    Math.sin(lat1) * Math.cos(dByR) +
      Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));
  var lon = lon1 + Math.atan2(
    Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1),
    Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));
  return [Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toDegrees"])(lon), Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toDegrees"])(lat)];
}

//# sourceMappingURL=sphere.js.map

/***/ }),

/***/ "./node_modules/ol/string.js":
/*!***********************************!*\
  !*** ./node_modules/ol/string.js ***!
  \***********************************/
/*! exports provided: padNumber, compareVersions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "padNumber", function() { return padNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compareVersions", function() { return compareVersions; });
/**
 * @module ol/string
 */

/**
 * @param {number} number Number to be formatted
 * @param {number} width The desired width
 * @param {number=} opt_precision Precision of the output string (i.e. number of decimal places)
 * @returns {string} Formatted string
 */
function padNumber(number, width, opt_precision) {
  var numberString = opt_precision !== undefined ? number.toFixed(opt_precision) : '' + number;
  var decimal = numberString.indexOf('.');
  decimal = decimal === -1 ? numberString.length : decimal;
  return decimal > width ? numberString : new Array(1 + width - decimal).join('0') + numberString;
}


/**
 * Adapted from https://github.com/omichelsen/compare-versions/blob/master/index.js
 * @param {string|number} v1 First version
 * @param {string|number} v2 Second version
 * @returns {number} Value
 */
function compareVersions(v1, v2) {
  var s1 = ('' + v1).split('.');
  var s2 = ('' + v2).split('.');

  for (var i = 0; i < Math.max(s1.length, s2.length); i++) {
    var n1 = parseInt(s1[i] || '0', 10);
    var n2 = parseInt(s2[i] || '0', 10);

    if (n1 > n2) {
      return 1;
    }
    if (n2 > n1) {
      return -1;
    }
  }

  return 0;
}

//# sourceMappingURL=string.js.map

/***/ }),

/***/ "./node_modules/ol/structs/LRUCache.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/structs/LRUCache.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/Target.js */ "./node_modules/ol/events/Target.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/**
 * @module ol/structs/LRUCache
 */






/**
 * @typedef {Object} Entry
 * @property {string} key_
 * @property {Object} newer
 * @property {Object} older
 * @property {*} value_
 */


/**
 * @classdesc
 * Implements a Least-Recently-Used cache where the keys do not conflict with
 * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring
 * items from the cache is the responsibility of the user.
 *
 * @fires import("../events/Event.js").Event
 * @template T
 */
var LRUCache = /*@__PURE__*/(function (EventTarget) {
  function LRUCache(opt_highWaterMark) {

    EventTarget.call(this);

    /**
     * @type {number}
     */
    this.highWaterMark = opt_highWaterMark !== undefined ? opt_highWaterMark : 2048;

    /**
     * @private
     * @type {number}
     */
    this.count_ = 0;

    /**
     * @private
     * @type {!Object<string, Entry>}
     */
    this.entries_ = {};

    /**
     * @private
     * @type {?Entry}
     */
    this.oldest_ = null;

    /**
     * @private
     * @type {?Entry}
     */
    this.newest_ = null;

  }

  if ( EventTarget ) LRUCache.__proto__ = EventTarget;
  LRUCache.prototype = Object.create( EventTarget && EventTarget.prototype );
  LRUCache.prototype.constructor = LRUCache;


  /**
   * @return {boolean} Can expire cache.
   */
  LRUCache.prototype.canExpireCache = function canExpireCache () {
    return this.getCount() > this.highWaterMark;
  };


  /**
   * FIXME empty description for jsdoc
   */
  LRUCache.prototype.clear = function clear () {
    this.count_ = 0;
    this.entries_ = {};
    this.oldest_ = null;
    this.newest_ = null;
    this.dispatchEvent(_events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CLEAR);
  };


  /**
   * @param {string} key Key.
   * @return {boolean} Contains key.
   */
  LRUCache.prototype.containsKey = function containsKey (key) {
    return this.entries_.hasOwnProperty(key);
  };


  /**
   * @param {function(this: S, T, string, LRUCache): ?} f The function
   *     to call for every entry from the oldest to the newer. This function takes
   *     3 arguments (the entry value, the entry key and the LRUCache object).
   *     The return value is ignored.
   * @param {S=} opt_this The object to use as `this` in `f`.
   * @template S
   */
  LRUCache.prototype.forEach = function forEach (f, opt_this) {
    var entry = this.oldest_;
    while (entry) {
      f.call(opt_this, entry.value_, entry.key_, this);
      entry = entry.newer;
    }
  };


  /**
   * @param {string} key Key.
   * @return {T} Value.
   */
  LRUCache.prototype.get = function get (key) {
    var entry = this.entries_[key];
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(entry !== undefined,
      15); // Tried to get a value for a key that does not exist in the cache
    if (entry === this.newest_) {
      return entry.value_;
    } else if (entry === this.oldest_) {
      this.oldest_ = /** @type {Entry} */ (this.oldest_.newer);
      this.oldest_.older = null;
    } else {
      entry.newer.older = entry.older;
      entry.older.newer = entry.newer;
    }
    entry.newer = null;
    entry.older = this.newest_;
    this.newest_.newer = entry;
    this.newest_ = entry;
    return entry.value_;
  };


  /**
   * Remove an entry from the cache.
   * @param {string} key The entry key.
   * @return {T} The removed entry.
   */
  LRUCache.prototype.remove = function remove (key) {
    var entry = this.entries_[key];
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache
    if (entry === this.newest_) {
      this.newest_ = /** @type {Entry} */ (entry.older);
      if (this.newest_) {
        this.newest_.newer = null;
      }
    } else if (entry === this.oldest_) {
      this.oldest_ = /** @type {Entry} */ (entry.newer);
      if (this.oldest_) {
        this.oldest_.older = null;
      }
    } else {
      entry.newer.older = entry.older;
      entry.older.newer = entry.newer;
    }
    delete this.entries_[key];
    --this.count_;
    return entry.value_;
  };


  /**
   * @return {number} Count.
   */
  LRUCache.prototype.getCount = function getCount () {
    return this.count_;
  };


  /**
   * @return {Array<string>} Keys.
   */
  LRUCache.prototype.getKeys = function getKeys () {
    var keys = new Array(this.count_);
    var i = 0;
    var entry;
    for (entry = this.newest_; entry; entry = entry.older) {
      keys[i++] = entry.key_;
    }
    return keys;
  };


  /**
   * @return {Array<T>} Values.
   */
  LRUCache.prototype.getValues = function getValues () {
    var values = new Array(this.count_);
    var i = 0;
    var entry;
    for (entry = this.newest_; entry; entry = entry.older) {
      values[i++] = entry.value_;
    }
    return values;
  };


  /**
   * @return {T} Last value.
   */
  LRUCache.prototype.peekLast = function peekLast () {
    return this.oldest_.value_;
  };


  /**
   * @return {string} Last key.
   */
  LRUCache.prototype.peekLastKey = function peekLastKey () {
    return this.oldest_.key_;
  };


  /**
   * Get the key of the newest item in the cache.  Throws if the cache is empty.
   * @return {string} The newest key.
   */
  LRUCache.prototype.peekFirstKey = function peekFirstKey () {
    return this.newest_.key_;
  };


  /**
   * @return {T} value Value.
   */
  LRUCache.prototype.pop = function pop () {
    var entry = this.oldest_;
    delete this.entries_[entry.key_];
    if (entry.newer) {
      entry.newer.older = null;
    }
    this.oldest_ = /** @type {Entry} */ (entry.newer);
    if (!this.oldest_) {
      this.newest_ = null;
    }
    --this.count_;
    return entry.value_;
  };


  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  LRUCache.prototype.replace = function replace (key, value) {
    this.get(key); // update `newest_`
    this.entries_[key].value_ = value;
  };


  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  LRUCache.prototype.set = function set (key, value) {
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(!(key in this.entries_),
      16); // Tried to set a value for a key that is used already
    var entry = /** @type {Entry} */ ({
      key_: key,
      newer: null,
      older: this.newest_,
      value_: value
    });
    if (!this.newest_) {
      this.oldest_ = entry;
    } else {
      this.newest_.newer = entry;
    }
    this.newest_ = entry;
    this.entries_[key] = entry;
    ++this.count_;
  };


  /**
   * Set a maximum number of entries for the cache.
   * @param {number} size Cache size.
   * @api
   */
  LRUCache.prototype.setSize = function setSize (size) {
    this.highWaterMark = size;
  };


  /**
   * Prune the cache.
   */
  LRUCache.prototype.prune = function prune () {
    while (this.canExpireCache()) {
      this.pop();
    }
  };

  return LRUCache;
}(_events_Target_js__WEBPACK_IMPORTED_MODULE_1__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (LRUCache);

//# sourceMappingURL=LRUCache.js.map

/***/ }),

/***/ "./node_modules/ol/structs/PriorityQueue.js":
/*!**************************************************!*\
  !*** ./node_modules/ol/structs/PriorityQueue.js ***!
  \**************************************************/
/*! exports provided: DROP, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DROP", function() { return DROP; });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/structs/PriorityQueue
 */




/**
 * @type {number}
 */
var DROP = Infinity;


/**
 * @classdesc
 * Priority queue.
 *
 * The implementation is inspired from the Closure Library's Heap class and
 * Python's heapq module.
 *
 * See http://closure-library.googlecode.com/svn/docs/closure_goog_structs_heap.js.source.html
 * and http://hg.python.org/cpython/file/2.7/Lib/heapq.py.
 *
 * @template T
 */
var PriorityQueue = function PriorityQueue(priorityFunction, keyFunction) {

  /**
   * @type {function(T): number}
   * @private
   */
  this.priorityFunction_ = priorityFunction;

  /**
   * @type {function(T): string}
   * @private
   */
  this.keyFunction_ = keyFunction;

  /**
   * @type {Array<T>}
   * @private
   */
  this.elements_ = [];

  /**
   * @type {Array<number>}
   * @private
   */
  this.priorities_ = [];

  /**
   * @type {!Object<string, boolean>}
   * @private
   */
  this.queuedElements_ = {};

};

/**
 * FIXME empty description for jsdoc
 */
PriorityQueue.prototype.clear = function clear$1 () {
  this.elements_.length = 0;
  this.priorities_.length = 0;
  Object(_obj_js__WEBPACK_IMPORTED_MODULE_1__["clear"])(this.queuedElements_);
};


/**
 * Remove and return the highest-priority element. O(log N).
 * @return {T} Element.
 */
PriorityQueue.prototype.dequeue = function dequeue () {
  var elements = this.elements_;
  var priorities = this.priorities_;
  var element = elements[0];
  if (elements.length == 1) {
    elements.length = 0;
    priorities.length = 0;
  } else {
    elements[0] = elements.pop();
    priorities[0] = priorities.pop();
    this.siftUp_(0);
  }
  var elementKey = this.keyFunction_(element);
  delete this.queuedElements_[elementKey];
  return element;
};


/**
 * Enqueue an element. O(log N).
 * @param {T} element Element.
 * @return {boolean} The element was added to the queue.
 */
PriorityQueue.prototype.enqueue = function enqueue (element) {
  Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(!(this.keyFunction_(element) in this.queuedElements_),
    31); // Tried to enqueue an `element` that was already added to the queue
  var priority = this.priorityFunction_(element);
  if (priority != DROP) {
    this.elements_.push(element);
    this.priorities_.push(priority);
    this.queuedElements_[this.keyFunction_(element)] = true;
    this.siftDown_(0, this.elements_.length - 1);
    return true;
  }
  return false;
};


/**
 * @return {number} Count.
 */
PriorityQueue.prototype.getCount = function getCount () {
  return this.elements_.length;
};


/**
 * Gets the index of the left child of the node at the given index.
 * @param {number} index The index of the node to get the left child for.
 * @return {number} The index of the left child.
 * @private
 */
PriorityQueue.prototype.getLeftChildIndex_ = function getLeftChildIndex_ (index) {
  return index * 2 + 1;
};


/**
 * Gets the index of the right child of the node at the given index.
 * @param {number} index The index of the node to get the right child for.
 * @return {number} The index of the right child.
 * @private
 */
PriorityQueue.prototype.getRightChildIndex_ = function getRightChildIndex_ (index) {
  return index * 2 + 2;
};


/**
 * Gets the index of the parent of the node at the given index.
 * @param {number} index The index of the node to get the parent for.
 * @return {number} The index of the parent.
 * @private
 */
PriorityQueue.prototype.getParentIndex_ = function getParentIndex_ (index) {
  return (index - 1) >> 1;
};


/**
 * Make this a heap. O(N).
 * @private
 */
PriorityQueue.prototype.heapify_ = function heapify_ () {
  var i;
  for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {
    this.siftUp_(i);
  }
};


/**
 * @return {boolean} Is empty.
 */
PriorityQueue.prototype.isEmpty = function isEmpty () {
  return this.elements_.length === 0;
};


/**
 * @param {string} key Key.
 * @return {boolean} Is key queued.
 */
PriorityQueue.prototype.isKeyQueued = function isKeyQueued (key) {
  return key in this.queuedElements_;
};


/**
 * @param {T} element Element.
 * @return {boolean} Is queued.
 */
PriorityQueue.prototype.isQueued = function isQueued (element) {
  return this.isKeyQueued(this.keyFunction_(element));
};


/**
 * @param {number} index The index of the node to move down.
 * @private
 */
PriorityQueue.prototype.siftUp_ = function siftUp_ (index) {
  var elements = this.elements_;
  var priorities = this.priorities_;
  var count = elements.length;
  var element = elements[index];
  var priority = priorities[index];
  var startIndex = index;

  while (index < (count >> 1)) {
    var lIndex = this.getLeftChildIndex_(index);
    var rIndex = this.getRightChildIndex_(index);

    var smallerChildIndex = rIndex < count &&
        priorities[rIndex] < priorities[lIndex] ?
      rIndex : lIndex;

    elements[index] = elements[smallerChildIndex];
    priorities[index] = priorities[smallerChildIndex];
    index = smallerChildIndex;
  }

  elements[index] = element;
  priorities[index] = priority;
  this.siftDown_(startIndex, index);
};


/**
 * @param {number} startIndex The index of the root.
 * @param {number} index The index of the node to move up.
 * @private
 */
PriorityQueue.prototype.siftDown_ = function siftDown_ (startIndex, index) {
  var elements = this.elements_;
  var priorities = this.priorities_;
  var element = elements[index];
  var priority = priorities[index];

  while (index > startIndex) {
    var parentIndex = this.getParentIndex_(index);
    if (priorities[parentIndex] > priority) {
      elements[index] = elements[parentIndex];
      priorities[index] = priorities[parentIndex];
      index = parentIndex;
    } else {
      break;
    }
  }
  elements[index] = element;
  priorities[index] = priority;
};


/**
 * FIXME empty description for jsdoc
 */
PriorityQueue.prototype.reprioritize = function reprioritize () {
  var priorityFunction = this.priorityFunction_;
  var elements = this.elements_;
  var priorities = this.priorities_;
  var index = 0;
  var n = elements.length;
  var element, i, priority;
  for (i = 0; i < n; ++i) {
    element = elements[i];
    priority = priorityFunction(element);
    if (priority == DROP) {
      delete this.queuedElements_[this.keyFunction_(element)];
    } else {
      priorities[index] = priority;
      elements[index++] = element;
    }
  }
  elements.length = index;
  priorities.length = index;
  this.heapify_();
};


/* harmony default export */ __webpack_exports__["default"] = (PriorityQueue);

//# sourceMappingURL=PriorityQueue.js.map

/***/ }),

/***/ "./node_modules/ol/structs/RBush.js":
/*!******************************************!*\
  !*** ./node_modules/ol/structs/RBush.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rbush */ "./node_modules/rbush/index.js");
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(rbush__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/structs/RBush
 */





/**
 * @typedef {Object} Entry
 * @property {number} minX
 * @property {number} minY
 * @property {number} maxX
 * @property {number} maxY
 * @property {Object} [value]
 */

/**
 * @classdesc
 * Wrapper around the RBush by Vladimir Agafonkin.
 * See https://github.com/mourner/rbush.
 *
 * @template T
 */
var RBush = function RBush(opt_maxEntries) {

  /**
   * @private
   */
  this.rbush_ = rbush__WEBPACK_IMPORTED_MODULE_1___default()(opt_maxEntries, undefined);

  /**
   * A mapping between the objects added to this rbush wrapper
   * and the objects that are actually added to the internal rbush.
   * @private
   * @type {Object<string, Entry>}
   */
  this.items_ = {};

};

/**
 * Insert a value into the RBush.
 * @param {import("../extent.js").Extent} extent Extent.
 * @param {T} value Value.
 */
RBush.prototype.insert = function insert (extent, value) {
  /** @type {Entry} */
  var item = {
    minX: extent[0],
    minY: extent[1],
    maxX: extent[2],
    maxY: extent[3],
    value: value
  };

  this.rbush_.insert(item);
  this.items_[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(value)] = item;
};


/**
 * Bulk-insert values into the RBush.
 * @param {Array<import("../extent.js").Extent>} extents Extents.
 * @param {Array<T>} values Values.
 */
RBush.prototype.load = function load (extents, values) {
  var items = new Array(values.length);
  for (var i = 0, l = values.length; i < l; i++) {
    var extent = extents[i];
    var value = values[i];

    /** @type {Entry} */
    var item = {
      minX: extent[0],
      minY: extent[1],
      maxX: extent[2],
      maxY: extent[3],
      value: value
    };
    items[i] = item;
    this.items_[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(value)] = item;
  }
  this.rbush_.load(items);
};


/**
 * Remove a value from the RBush.
 * @param {T} value Value.
 * @return {boolean} Removed.
 */
RBush.prototype.remove = function remove (value) {
  var uid = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(value);

  // get the object in which the value was wrapped when adding to the
  // internal rbush. then use that object to do the removal.
  var item = this.items_[uid];
  delete this.items_[uid];
  return this.rbush_.remove(item) !== null;
};


/**
 * Update the extent of a value in the RBush.
 * @param {import("../extent.js").Extent} extent Extent.
 * @param {T} value Value.
 */
RBush.prototype.update = function update (extent, value) {
  var item = this.items_[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(value)];
  var bbox = [item.minX, item.minY, item.maxX, item.maxY];
  if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["equals"])(bbox, extent)) {
    this.remove(value);
    this.insert(extent, value);
  }
};


/**
 * Return all values in the RBush.
 * @return {Array<T>} All.
 */
RBush.prototype.getAll = function getAll () {
  var items = this.rbush_.all();
  return items.map(function(item) {
    return item.value;
  });
};


/**
 * Return all values in the given extent.
 * @param {import("../extent.js").Extent} extent Extent.
 * @return {Array<T>} All in extent.
 */
RBush.prototype.getInExtent = function getInExtent (extent) {
  /** @type {Entry} */
  var bbox = {
    minX: extent[0],
    minY: extent[1],
    maxX: extent[2],
    maxY: extent[3]
  };
  var items = this.rbush_.search(bbox);
  return items.map(function(item) {
    return item.value;
  });
};


/**
 * Calls a callback function with each value in the tree.
 * If the callback returns a truthy value, this value is returned without
 * checking the rest of the tree.
 * @param {function(this: S, T): *} callback Callback.
 * @param {S=} opt_this The object to use as `this` in `callback`.
 * @return {*} Callback return value.
 * @template S
 */
RBush.prototype.forEach = function forEach (callback, opt_this) {
  return this.forEach_(this.getAll(), callback, opt_this);
};


/**
 * Calls a callback function with each value in the provided extent.
 * @param {import("../extent.js").Extent} extent Extent.
 * @param {function(this: S, T): *} callback Callback.
 * @param {S=} opt_this The object to use as `this` in `callback`.
 * @return {*} Callback return value.
 * @template S
 */
RBush.prototype.forEachInExtent = function forEachInExtent (extent, callback, opt_this) {
  return this.forEach_(this.getInExtent(extent), callback, opt_this);
};


/**
 * @param {Array<T>} values Values.
 * @param {function(this: S, T): *} callback Callback.
 * @param {S=} opt_this The object to use as `this` in `callback`.
 * @private
 * @return {*} Callback return value.
 * @template S
 */
RBush.prototype.forEach_ = function forEach_ (values, callback, opt_this) {
  var result;
  for (var i = 0, l = values.length; i < l; i++) {
    result = callback.call(opt_this, values[i]);
    if (result) {
      return result;
    }
  }
  return result;
};


/**
 * @return {boolean} Is empty.
 */
RBush.prototype.isEmpty = function isEmpty$1 () {
  return Object(_obj_js__WEBPACK_IMPORTED_MODULE_3__["isEmpty"])(this.items_);
};


/**
 * Remove all values from the RBush.
 */
RBush.prototype.clear = function clear () {
  this.rbush_.clear();
  this.items_ = {};
};


/**
 * @param {import("../extent.js").Extent=} opt_extent Extent.
 * @return {import("../extent.js").Extent} Extent.
 */
RBush.prototype.getExtent = function getExtent (opt_extent) {
  var data = this.rbush_.toJSON();
  return Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["createOrUpdate"])(data.minX, data.minY, data.maxX, data.maxY, opt_extent);
};


/**
 * @param {RBush} rbush R-Tree.
 */
RBush.prototype.concat = function concat (rbush) {
  this.rbush_.load(rbush.rbush_.all());
  for (var i in rbush.items_) {
    this.items_[i] = rbush.items_[i];
  }
};


/* harmony default export */ __webpack_exports__["default"] = (RBush);

//# sourceMappingURL=RBush.js.map

/***/ }),

/***/ "./node_modules/ol/style/Circle.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/style/Circle.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _RegularShape_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RegularShape.js */ "./node_modules/ol/style/RegularShape.js");
/**
 * @module ol/style/Circle
 */




/**
 * @typedef {Object} Options
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {number} radius Circle radius.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {import("./AtlasManager.js").default} [atlasManager] The atlas manager to use for this circle.
 * When using WebGL it is recommended to use an atlas manager to avoid texture switching. If an atlas manager is given,
 * the circle is added to an atlas. By default no atlas manager is used.
 */


/**
 * @classdesc
 * Set circle style for vector features.
 * @api
 */
var CircleStyle = /*@__PURE__*/(function (RegularShape) {
  function CircleStyle(opt_options) {

    var options = opt_options || /** @type {Options} */ ({});

    RegularShape.call(this, {
      points: Infinity,
      fill: options.fill,
      radius: options.radius,
      stroke: options.stroke,
      atlasManager: options.atlasManager
    });

  }

  if ( RegularShape ) CircleStyle.__proto__ = RegularShape;
  CircleStyle.prototype = Object.create( RegularShape && RegularShape.prototype );
  CircleStyle.prototype.constructor = CircleStyle;

  /**
  * Clones the style.  If an atlasmanager was provided to the original style it will be used in the cloned style, too.
  * @return {CircleStyle} The cloned style.
  * @override
  * @api
  */
  CircleStyle.prototype.clone = function clone () {
    var style = new CircleStyle({
      fill: this.getFill() ? this.getFill().clone() : undefined,
      stroke: this.getStroke() ? this.getStroke().clone() : undefined,
      radius: this.getRadius(),
      atlasManager: this.atlasManager_
    });
    style.setOpacity(this.getOpacity());
    style.setScale(this.getScale());
    return style;
  };

  /**
  * Set the circle radius.
  *
  * @param {number} radius Circle radius.
  * @api
  */
  CircleStyle.prototype.setRadius = function setRadius (radius) {
    this.radius_ = radius;
    this.render_(this.atlasManager_);
  };

  return CircleStyle;
}(_RegularShape_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (CircleStyle);

//# sourceMappingURL=Circle.js.map

/***/ }),

/***/ "./node_modules/ol/style/Fill.js":
/*!***************************************!*\
  !*** ./node_modules/ol/style/Fill.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../color.js */ "./node_modules/ol/color.js");
/**
 * @module ol/style/Fill
 */




/**
 * @typedef {Object} Options
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [color] A color, gradient or pattern.
 * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
 * Default null; if null, the Canvas/renderer default black will be used.
 */


/**
 * @classdesc
 * Set fill style for vector features.
 * @api
 */
var Fill = function Fill(opt_options) {

  var options = opt_options || {};

  /**
   * @private
   * @type {import("../color.js").Color|import("../colorlike.js").ColorLike}
   */
  this.color_ = options.color !== undefined ? options.color : null;

  /**
   * @private
   * @type {string|undefined}
   */
  this.checksum_ = undefined;
};

/**
 * Clones the style. The color is not cloned if it is an {@link module:ol/colorlike~ColorLike}.
 * @return {Fill} The cloned style.
 * @api
 */
Fill.prototype.clone = function clone () {
  var color = this.getColor();
  return new Fill({
    color: Array.isArray(color) ? color.slice() : color || undefined
  });
};

/**
 * Get the fill color.
 * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
 * @api
 */
Fill.prototype.getColor = function getColor () {
  return this.color_;
};

/**
 * Set the color.
 *
 * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
 * @api
 */
Fill.prototype.setColor = function setColor (color) {
  this.color_ = color;
  this.checksum_ = undefined;
};

/**
 * @return {string} The checksum.
 */
Fill.prototype.getChecksum = function getChecksum () {
  if (this.checksum_ === undefined) {
    var color = this.color_;
    if (color) {
      if (Array.isArray(color) || typeof color == 'string') {
        this.checksum_ = 'f' + Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["asString"])(/** @type {import("../color.js").Color|string} */ (color));
      } else {
        this.checksum_ = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(this.color_);
      }
    } else {
      this.checksum_ = 'f-';
    }
  }

  return this.checksum_;
};

/* harmony default export */ __webpack_exports__["default"] = (Fill);

//# sourceMappingURL=Fill.js.map

/***/ }),

/***/ "./node_modules/ol/style/IconImageCache.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/style/IconImageCache.js ***!
  \*************************************************/
/*! exports provided: default, shared */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shared", function() { return shared; });
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../color.js */ "./node_modules/ol/color.js");
/**
 * @module ol/style/IconImageCache
 */


/**
 * @classdesc
 * Singleton class. Available through {@link module:ol/style/IconImageCache~shared}.
 */
var IconImageCache = function IconImageCache() {

  /**
  * @type {!Object<string, import("./IconImage.js").default>}
  * @private
  */
  this.cache_ = {};

  /**
  * @type {number}
  * @private
  */
  this.cacheSize_ = 0;

  /**
  * @type {number}
  * @private
  */
  this.maxCacheSize_ = 32;
};

/**
* FIXME empty description for jsdoc
*/
IconImageCache.prototype.clear = function clear () {
  this.cache_ = {};
  this.cacheSize_ = 0;
};

/**
* FIXME empty description for jsdoc
*/
IconImageCache.prototype.expire = function expire () {
  if (this.cacheSize_ > this.maxCacheSize_) {
    var i = 0;
    for (var key in this.cache_) {
      var iconImage = this.cache_[key];
      if ((i++ & 3) === 0 && !iconImage.hasListener()) {
        delete this.cache_[key];
        --this.cacheSize_;
      }
    }
  }
};

/**
* @param {string} src Src.
* @param {?string} crossOrigin Cross origin.
* @param {import("../color.js").Color} color Color.
* @return {import("./IconImage.js").default} Icon image.
*/
IconImageCache.prototype.get = function get (src, crossOrigin, color) {
  var key = getKey(src, crossOrigin, color);
  return key in this.cache_ ? this.cache_[key] : null;
};

/**
* @param {string} src Src.
* @param {?string} crossOrigin Cross origin.
* @param {import("../color.js").Color} color Color.
* @param {import("./IconImage.js").default} iconImage Icon image.
*/
IconImageCache.prototype.set = function set (src, crossOrigin, color, iconImage) {
  var key = getKey(src, crossOrigin, color);
  this.cache_[key] = iconImage;
  ++this.cacheSize_;
};

/**
* Set the cache size of the icon cache. Default is `32`. Change this value when
* your map uses more than 32 different icon images and you are not caching icon
* styles on the application level.
* @param {number} maxCacheSize Cache max size.
* @api
*/
IconImageCache.prototype.setSize = function setSize (maxCacheSize) {
  this.maxCacheSize_ = maxCacheSize;
  this.expire();
};


/**
 * @param {string} src Src.
 * @param {?string} crossOrigin Cross origin.
 * @param {import("../color.js").Color} color Color.
 * @return {string} Cache key.
 */
function getKey(src, crossOrigin, color) {
  var colorString = color ? Object(_color_js__WEBPACK_IMPORTED_MODULE_0__["asString"])(color) : 'null';
  return crossOrigin + ':' + src + ':' + colorString;
}


/* harmony default export */ __webpack_exports__["default"] = (IconImageCache);


/**
 * The {@link module:ol/style/IconImageCache~IconImageCache} for
 * {@link module:ol/style/Icon~Icon} images.
 * @api
 */
var shared = new IconImageCache();

//# sourceMappingURL=IconImageCache.js.map

/***/ }),

/***/ "./node_modules/ol/style/Image.js":
/*!****************************************!*\
  !*** ./node_modules/ol/style/Image.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/**
 * @module ol/style/Image
 */



/**
 * @typedef {Object} Options
 * @property {number} opacity
 * @property {boolean} rotateWithView
 * @property {number} rotation
 * @property {number} scale
 */


/**
 * @classdesc
 * A base class used for creating subclasses and not instantiated in
 * apps. Base class for {@link module:ol/style/Icon~Icon}, {@link module:ol/style/Circle~CircleStyle} and
 * {@link module:ol/style/RegularShape~RegularShape}.
 * @abstract
 * @api
 */
var ImageStyle = function ImageStyle(options) {

  /**
   * @private
   * @type {number}
   */
  this.opacity_ = options.opacity;

  /**
   * @private
   * @type {boolean}
   */
  this.rotateWithView_ = options.rotateWithView;

  /**
   * @private
   * @type {number}
   */
  this.rotation_ = options.rotation;

  /**
   * @private
   * @type {number}
   */
  this.scale_ = options.scale;

};

/**
 * Clones the style.
 * @return {ImageStyle} The cloned style.
 * @api
 */
ImageStyle.prototype.clone = function clone () {
  return new ImageStyle({
    opacity: this.getOpacity(),
    scale: this.getScale(),
    rotation: this.getRotation(),
    rotateWithView: this.getRotateWithView()
  });
};

/**
 * Get the symbolizer opacity.
 * @return {number} Opacity.
 * @api
 */
ImageStyle.prototype.getOpacity = function getOpacity () {
  return this.opacity_;
};

/**
 * Determine whether the symbolizer rotates with the map.
 * @return {boolean} Rotate with map.
 * @api
 */
ImageStyle.prototype.getRotateWithView = function getRotateWithView () {
  return this.rotateWithView_;
};

/**
 * Get the symoblizer rotation.
 * @return {number} Rotation.
 * @api
 */
ImageStyle.prototype.getRotation = function getRotation () {
  return this.rotation_;
};

/**
 * Get the symbolizer scale.
 * @return {number} Scale.
 * @api
 */
ImageStyle.prototype.getScale = function getScale () {
  return this.scale_;
};

/**
 * This method is deprecated and always returns false.
 * @return {boolean} false.
 * @deprecated
 * @api
 */
ImageStyle.prototype.getSnapToPixel = function getSnapToPixel () {
  return false;
};

/**
 * Get the anchor point in pixels. The anchor determines the center point for the
 * symbolizer.
 * @abstract
 * @return {Array<number>} Anchor.
 */
ImageStyle.prototype.getAnchor = function getAnchor () {
  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
};

/**
 * Get the image element for the symbolizer.
 * @abstract
 * @param {number} pixelRatio Pixel ratio.
 * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.
 */
ImageStyle.prototype.getImage = function getImage (pixelRatio) {
  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
};

/**
 * @abstract
 * @param {number} pixelRatio Pixel ratio.
 * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.
 */
ImageStyle.prototype.getHitDetectionImage = function getHitDetectionImage (pixelRatio) {
  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
};

/**
 * @abstract
 * @return {import("../ImageState.js").default} Image state.
 */
ImageStyle.prototype.getImageState = function getImageState () {
  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
};

/**
 * @abstract
 * @return {import("../size.js").Size} Image size.
 */
ImageStyle.prototype.getImageSize = function getImageSize () {
  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
};

/**
 * @abstract
 * @return {import("../size.js").Size} Size of the hit-detection image.
 */
ImageStyle.prototype.getHitDetectionImageSize = function getHitDetectionImageSize () {
  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
};

/**
 * Get the origin of the symbolizer.
 * @abstract
 * @return {Array<number>} Origin.
 */
ImageStyle.prototype.getOrigin = function getOrigin () {
  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
};

/**
 * Get the size of the symbolizer (in pixels).
 * @abstract
 * @return {import("../size.js").Size} Size.
 */
ImageStyle.prototype.getSize = function getSize () {
  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
};

/**
 * Set the opacity.
 *
 * @param {number} opacity Opacity.
 * @api
 */
ImageStyle.prototype.setOpacity = function setOpacity (opacity) {
  this.opacity_ = opacity;
};

/**
 * Set whether to rotate the style with the view.
 *
 * @param {boolean} rotateWithView Rotate with map.
 * @api
 */
ImageStyle.prototype.setRotateWithView = function setRotateWithView (rotateWithView) {
  this.rotateWithView_ = rotateWithView;
};

/**
 * Set the rotation.
 *
 * @param {number} rotation Rotation.
 * @api
 */
ImageStyle.prototype.setRotation = function setRotation (rotation) {
  this.rotation_ = rotation;
};
/**
 * Set the scale.
 *
 * @param {number} scale Scale.
 * @api
 */
ImageStyle.prototype.setScale = function setScale (scale) {
  this.scale_ = scale;
};

/**
 * This method is deprecated and does nothing.
 * @param {boolean} snapToPixel Snap to pixel?
 * @deprecated
 * @api
 */
ImageStyle.prototype.setSnapToPixel = function setSnapToPixel (snapToPixel) {};

/**
 * @abstract
 * @param {function(this: T, import("../events/Event.js").default)} listener Listener function.
 * @param {T} thisArg Value to use as `this` when executing `listener`.
 * @return {import("../events.js").EventsKey|undefined} Listener key.
 * @template T
 */
ImageStyle.prototype.listenImageChange = function listenImageChange (listener, thisArg) {
  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
};

/**
 * Load not yet loaded URI.
 * @abstract
 */
ImageStyle.prototype.load = function load () {
  Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
};

/**
 * @abstract
 * @param {function(this: T, import("../events/Event.js").default)} listener Listener function.
 * @param {T} thisArg Value to use as `this` when executing `listener`.
 * @template T
 */
ImageStyle.prototype.unlistenImageChange = function unlistenImageChange (listener, thisArg) {
  Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
};

/* harmony default export */ __webpack_exports__["default"] = (ImageStyle);

//# sourceMappingURL=Image.js.map

/***/ }),

/***/ "./node_modules/ol/style/RegularShape.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/style/RegularShape.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../color.js */ "./node_modules/ol/color.js");
/* harmony import */ var _colorlike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../colorlike.js */ "./node_modules/ol/colorlike.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ImageState.js */ "./node_modules/ol/ImageState.js");
/* harmony import */ var _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../render/canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _Image_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Image.js */ "./node_modules/ol/style/Image.js");
/**
 * @module ol/style/RegularShape
 */










/**
 * Specify radius for regular polygons, or radius1 and radius2 for stars.
 * @typedef {Object} Options
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {number} points Number of points for stars and regular polygons. In case of a polygon, the number of points
 * is the number of sides.
 * @property {number} [radius] Radius of a regular polygon.
 * @property {number} [radius1] Outer radius of a star.
 * @property {number} [radius2] Inner radius of a star.
 * @property {number} [angle=0] Shape's angle in radians. A value of 0 will have one of the shape's point facing up.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view.
 * @property {import("./AtlasManager.js").default} [atlasManager] The atlas manager to use for this symbol. When
 * using WebGL it is recommended to use an atlas manager to avoid texture switching. If an atlas manager is given, the
 * symbol is added to an atlas. By default no atlas manager is used.
 */


/**
 * @typedef {Object} RenderOptions
 * @property {import("../colorlike.js").ColorLike} [strokeStyle]
 * @property {number} strokeWidth
 * @property {number} size
 * @property {string} lineCap
 * @property {Array<number>} lineDash
 * @property {number} lineDashOffset
 * @property {string} lineJoin
 * @property {number} miterLimit
 */


/**
 * @classdesc
 * Set regular shape style for vector features. The resulting shape will be
 * a regular polygon when `radius` is provided, or a star when `radius1` and
 * `radius2` are provided.
 * @api
 */
var RegularShape = /*@__PURE__*/(function (ImageStyle) {
  function RegularShape(options) {
    /**
     * @type {boolean}
     */
    var rotateWithView = options.rotateWithView !== undefined ?
      options.rotateWithView : false;

    ImageStyle.call(this, {
      opacity: 1,
      rotateWithView: rotateWithView,
      rotation: options.rotation !== undefined ? options.rotation : 0,
      scale: 1
    });

    /**
     * @private
     * @type {Array<string|number>}
     */
    this.checksums_ = null;

    /**
     * @private
     * @type {HTMLCanvasElement}
     */
    this.canvas_ = null;

    /**
     * @private
     * @type {HTMLCanvasElement}
     */
    this.hitDetectionCanvas_ = null;

    /**
     * @private
     * @type {import("./Fill.js").default}
     */
    this.fill_ = options.fill !== undefined ? options.fill : null;

    /**
     * @private
     * @type {Array<number>}
     */
    this.origin_ = [0, 0];

    /**
     * @private
     * @type {number}
     */
    this.points_ = options.points;

    /**
     * @protected
     * @type {number}
     */
    this.radius_ = /** @type {number} */ (options.radius !== undefined ?
      options.radius : options.radius1);

    /**
     * @private
     * @type {number|undefined}
     */
    this.radius2_ = options.radius2;

    /**
     * @private
     * @type {number}
     */
    this.angle_ = options.angle !== undefined ? options.angle : 0;

    /**
     * @private
     * @type {import("./Stroke.js").default}
     */
    this.stroke_ = options.stroke !== undefined ? options.stroke : null;

    /**
     * @private
     * @type {Array<number>}
     */
    this.anchor_ = null;

    /**
     * @private
     * @type {import("../size.js").Size}
     */
    this.size_ = null;

    /**
     * @private
     * @type {import("../size.js").Size}
     */
    this.imageSize_ = null;

    /**
     * @private
     * @type {import("../size.js").Size}
     */
    this.hitDetectionImageSize_ = null;

    /**
     * @protected
     * @type {import("./AtlasManager.js").default|undefined}
     */
    this.atlasManager_ = options.atlasManager;

    this.render_(this.atlasManager_);

  }

  if ( ImageStyle ) RegularShape.__proto__ = ImageStyle;
  RegularShape.prototype = Object.create( ImageStyle && ImageStyle.prototype );
  RegularShape.prototype.constructor = RegularShape;

  /**
   * Clones the style. If an atlasmanager was provided to the original style it will be used in the cloned style, too.
   * @return {RegularShape} The cloned style.
   * @api
   */
  RegularShape.prototype.clone = function clone () {
    var style = new RegularShape({
      fill: this.getFill() ? this.getFill().clone() : undefined,
      points: this.getPoints(),
      radius: this.getRadius(),
      radius2: this.getRadius2(),
      angle: this.getAngle(),
      stroke: this.getStroke() ? this.getStroke().clone() : undefined,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      atlasManager: this.atlasManager_
    });
    style.setOpacity(this.getOpacity());
    style.setScale(this.getScale());
    return style;
  };

  /**
   * @inheritDoc
   * @api
   */
  RegularShape.prototype.getAnchor = function getAnchor () {
    return this.anchor_;
  };

  /**
   * Get the angle used in generating the shape.
   * @return {number} Shape's rotation in radians.
   * @api
   */
  RegularShape.prototype.getAngle = function getAngle () {
    return this.angle_;
  };

  /**
   * Get the fill style for the shape.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */
  RegularShape.prototype.getFill = function getFill () {
    return this.fill_;
  };

  /**
   * @inheritDoc
   */
  RegularShape.prototype.getHitDetectionImage = function getHitDetectionImage (pixelRatio) {
    return this.hitDetectionCanvas_;
  };

  /**
   * @inheritDoc
   * @api
   */
  RegularShape.prototype.getImage = function getImage (pixelRatio) {
    return this.canvas_;
  };

  /**
   * @inheritDoc
   */
  RegularShape.prototype.getImageSize = function getImageSize () {
    return this.imageSize_;
  };

  /**
   * @inheritDoc
   */
  RegularShape.prototype.getHitDetectionImageSize = function getHitDetectionImageSize () {
    return this.hitDetectionImageSize_;
  };

  /**
   * @inheritDoc
   */
  RegularShape.prototype.getImageState = function getImageState () {
    return _ImageState_js__WEBPACK_IMPORTED_MODULE_4__["default"].LOADED;
  };

  /**
   * @inheritDoc
   * @api
   */
  RegularShape.prototype.getOrigin = function getOrigin () {
    return this.origin_;
  };

  /**
   * Get the number of points for generating the shape.
   * @return {number} Number of points for stars and regular polygons.
   * @api
   */
  RegularShape.prototype.getPoints = function getPoints () {
    return this.points_;
  };

  /**
   * Get the (primary) radius for the shape.
   * @return {number} Radius.
   * @api
   */
  RegularShape.prototype.getRadius = function getRadius () {
    return this.radius_;
  };

  /**
   * Get the secondary radius for the shape.
   * @return {number|undefined} Radius2.
   * @api
   */
  RegularShape.prototype.getRadius2 = function getRadius2 () {
    return this.radius2_;
  };

  /**
   * @inheritDoc
   * @api
   */
  RegularShape.prototype.getSize = function getSize () {
    return this.size_;
  };

  /**
   * Get the stroke style for the shape.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */
  RegularShape.prototype.getStroke = function getStroke () {
    return this.stroke_;
  };

  /**
   * @inheritDoc
   */
  RegularShape.prototype.listenImageChange = function listenImageChange (listener, thisArg) {
    return undefined;
  };

  /**
   * @inheritDoc
   */
  RegularShape.prototype.load = function load () {};

  /**
   * @inheritDoc
   */
  RegularShape.prototype.unlistenImageChange = function unlistenImageChange (listener, thisArg) {};

  /**
   * @protected
   * @param {import("./AtlasManager.js").default|undefined} atlasManager An atlas manager.
   */
  RegularShape.prototype.render_ = function render_ (atlasManager) {
    var imageSize;
    var lineCap = '';
    var lineJoin = '';
    var miterLimit = 0;
    var lineDash = null;
    var lineDashOffset = 0;
    var strokeStyle;
    var strokeWidth = 0;

    if (this.stroke_) {
      strokeStyle = this.stroke_.getColor();
      if (strokeStyle === null) {
        strokeStyle = _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["defaultStrokeStyle"];
      }
      strokeStyle = Object(_colorlike_js__WEBPACK_IMPORTED_MODULE_1__["asColorLike"])(strokeStyle);
      strokeWidth = this.stroke_.getWidth();
      if (strokeWidth === undefined) {
        strokeWidth = _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["defaultLineWidth"];
      }
      lineDash = this.stroke_.getLineDash();
      lineDashOffset = this.stroke_.getLineDashOffset();
      if (!_has_js__WEBPACK_IMPORTED_MODULE_3__["CANVAS_LINE_DASH"]) {
        lineDash = null;
        lineDashOffset = 0;
      }
      lineJoin = this.stroke_.getLineJoin();
      if (lineJoin === undefined) {
        lineJoin = _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["defaultLineJoin"];
      }
      lineCap = this.stroke_.getLineCap();
      if (lineCap === undefined) {
        lineCap = _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["defaultLineCap"];
      }
      miterLimit = this.stroke_.getMiterLimit();
      if (miterLimit === undefined) {
        miterLimit = _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["defaultMiterLimit"];
      }
    }

    var size = 2 * (this.radius_ + strokeWidth) + 1;

    /** @type {RenderOptions} */
    var renderOptions = {
      strokeStyle: strokeStyle,
      strokeWidth: strokeWidth,
      size: size,
      lineCap: lineCap,
      lineDash: lineDash,
      lineDashOffset: lineDashOffset,
      lineJoin: lineJoin,
      miterLimit: miterLimit
    };

    if (atlasManager === undefined) {
      // no atlas manager is used, create a new canvas
      var context = Object(_dom_js__WEBPACK_IMPORTED_MODULE_2__["createCanvasContext2D"])(size, size);
      this.canvas_ = context.canvas;

      // canvas.width and height are rounded to the closest integer
      size = this.canvas_.width;
      imageSize = size;

      this.draw_(renderOptions, context, 0, 0);

      this.createHitDetectionCanvas_(renderOptions);
    } else {
      // an atlas manager is used, add the symbol to an atlas
      size = Math.round(size);

      var hasCustomHitDetectionImage = !this.fill_;
      var renderHitDetectionCallback;
      if (hasCustomHitDetectionImage) {
        // render the hit-detection image into a separate atlas image
        renderHitDetectionCallback =
            this.drawHitDetectionCanvas_.bind(this, renderOptions);
      }

      var id = this.getChecksum();
      var info = atlasManager.add(
        id, size, size, this.draw_.bind(this, renderOptions),
        renderHitDetectionCallback);

      this.canvas_ = info.image;
      this.origin_ = [info.offsetX, info.offsetY];
      imageSize = info.image.width;

      if (hasCustomHitDetectionImage) {
        this.hitDetectionCanvas_ = info.hitImage;
        this.hitDetectionImageSize_ =
            [info.hitImage.width, info.hitImage.height];
      } else {
        this.hitDetectionCanvas_ = this.canvas_;
        this.hitDetectionImageSize_ = [imageSize, imageSize];
      }
    }

    this.anchor_ = [size / 2, size / 2];
    this.size_ = [size, size];
    this.imageSize_ = [imageSize, imageSize];
  };

  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The rendering context.
   * @param {number} x The origin for the symbol (x).
   * @param {number} y The origin for the symbol (y).
   */
  RegularShape.prototype.draw_ = function draw_ (renderOptions, context, x, y) {
    var i, angle0, radiusC;
    // reset transform
    context.setTransform(1, 0, 0, 1, 0, 0);

    // then move to (x, y)
    context.translate(x, y);

    context.beginPath();

    var points = this.points_;
    if (points === Infinity) {
      context.arc(
        renderOptions.size / 2, renderOptions.size / 2,
        this.radius_, 0, 2 * Math.PI, true);
    } else {
      var radius2 = (this.radius2_ !== undefined) ? this.radius2_
        : this.radius_;
      if (radius2 !== this.radius_) {
        points = 2 * points;
      }
      for (i = 0; i <= points; i++) {
        angle0 = i * 2 * Math.PI / points - Math.PI / 2 + this.angle_;
        radiusC = i % 2 === 0 ? this.radius_ : radius2;
        context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0),
          renderOptions.size / 2 + radiusC * Math.sin(angle0));
      }
    }


    if (this.fill_) {
      var color = this.fill_.getColor();
      if (color === null) {
        color = _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["defaultFillStyle"];
      }
      context.fillStyle = Object(_colorlike_js__WEBPACK_IMPORTED_MODULE_1__["asColorLike"])(color);
      context.fill();
    }
    if (this.stroke_) {
      context.strokeStyle = renderOptions.strokeStyle;
      context.lineWidth = renderOptions.strokeWidth;
      if (renderOptions.lineDash) {
        context.setLineDash(renderOptions.lineDash);
        context.lineDashOffset = renderOptions.lineDashOffset;
      }
      context.lineCap = /** @type {CanvasLineCap} */ (renderOptions.lineCap);
      context.lineJoin = /** @type {CanvasLineJoin} */ (renderOptions.lineJoin);
      context.miterLimit = renderOptions.miterLimit;
      context.stroke();
    }
    context.closePath();
  };

  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   */
  RegularShape.prototype.createHitDetectionCanvas_ = function createHitDetectionCanvas_ (renderOptions) {
    this.hitDetectionImageSize_ = [renderOptions.size, renderOptions.size];
    if (this.fill_) {
      this.hitDetectionCanvas_ = this.canvas_;
      return;
    }

    // if no fill style is set, create an extra hit-detection image with a
    // default fill style
    var context = Object(_dom_js__WEBPACK_IMPORTED_MODULE_2__["createCanvasContext2D"])(renderOptions.size, renderOptions.size);
    this.hitDetectionCanvas_ = context.canvas;

    this.drawHitDetectionCanvas_(renderOptions, context, 0, 0);
  };

  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The context.
   * @param {number} x The origin for the symbol (x).
   * @param {number} y The origin for the symbol (y).
   */
  RegularShape.prototype.drawHitDetectionCanvas_ = function drawHitDetectionCanvas_ (renderOptions, context, x, y) {
    // reset transform
    context.setTransform(1, 0, 0, 1, 0, 0);

    // then move to (x, y)
    context.translate(x, y);

    context.beginPath();

    var points = this.points_;
    if (points === Infinity) {
      context.arc(
        renderOptions.size / 2, renderOptions.size / 2,
        this.radius_, 0, 2 * Math.PI, true);
    } else {
      var radius2 = (this.radius2_ !== undefined) ? this.radius2_
        : this.radius_;
      if (radius2 !== this.radius_) {
        points = 2 * points;
      }
      var i, radiusC, angle0;
      for (i = 0; i <= points; i++) {
        angle0 = i * 2 * Math.PI / points - Math.PI / 2 + this.angle_;
        radiusC = i % 2 === 0 ? this.radius_ : radius2;
        context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0),
          renderOptions.size / 2 + radiusC * Math.sin(angle0));
      }
    }

    context.fillStyle = Object(_color_js__WEBPACK_IMPORTED_MODULE_0__["asString"])(_render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["defaultFillStyle"]);
    context.fill();
    if (this.stroke_) {
      context.strokeStyle = renderOptions.strokeStyle;
      context.lineWidth = renderOptions.strokeWidth;
      if (renderOptions.lineDash) {
        context.setLineDash(renderOptions.lineDash);
        context.lineDashOffset = renderOptions.lineDashOffset;
      }
      context.stroke();
    }
    context.closePath();
  };

  /**
   * @return {string} The checksum.
   */
  RegularShape.prototype.getChecksum = function getChecksum () {
    var strokeChecksum = this.stroke_ ?
      this.stroke_.getChecksum() : '-';
    var fillChecksum = this.fill_ ?
      this.fill_.getChecksum() : '-';

    var recalculate = !this.checksums_ ||
        (strokeChecksum != this.checksums_[1] ||
        fillChecksum != this.checksums_[2] ||
        this.radius_ != this.checksums_[3] ||
        this.radius2_ != this.checksums_[4] ||
        this.angle_ != this.checksums_[5] ||
        this.points_ != this.checksums_[6]);

    if (recalculate) {
      var checksum = 'r' + strokeChecksum + fillChecksum +
          (this.radius_ !== undefined ? this.radius_.toString() : '-') +
          (this.radius2_ !== undefined ? this.radius2_.toString() : '-') +
          (this.angle_ !== undefined ? this.angle_.toString() : '-') +
          (this.points_ !== undefined ? this.points_.toString() : '-');
      this.checksums_ = [checksum, strokeChecksum, fillChecksum,
        this.radius_, this.radius2_, this.angle_, this.points_];
    }

    return /** @type {string} */ (this.checksums_[0]);
  };

  return RegularShape;
}(_Image_js__WEBPACK_IMPORTED_MODULE_6__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (RegularShape);

//# sourceMappingURL=RegularShape.js.map

/***/ }),

/***/ "./node_modules/ol/style/Stroke.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/style/Stroke.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/**
 * @module ol/style/Stroke
 */



/**
 * @typedef {Object} Options
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [color] A color, gradient or pattern.
 * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
 * Default null; if null, the Canvas/renderer default black will be used.
 * @property {string} [lineCap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {string} [lineJoin='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {Array<number>} [lineDash] Line dash pattern. Default is `undefined` (no dash).
 * Please note that Internet Explorer 10 and lower do not support the `setLineDash` method on
 * the `CanvasRenderingContext2D` and therefore this option will have no visual effect in these browsers.
 * @property {number} [lineDashOffset=0] Line dash offset.
 * @property {number} [miterLimit=10] Miter limit.
 * @property {number} [width] Width.
 */


/**
 * @classdesc
 * Set stroke style for vector features.
 * Note that the defaults given are the Canvas defaults, which will be used if
 * option is not defined. The `get` functions return whatever was entered in
 * the options; they will not return the default.
 * @api
 */
var Stroke = function Stroke(opt_options) {

  var options = opt_options || {};

  /**
   * @private
   * @type {import("../color.js").Color|import("../colorlike.js").ColorLike}
   */
  this.color_ = options.color !== undefined ? options.color : null;

  /**
   * @private
   * @type {string|undefined}
   */
  this.lineCap_ = options.lineCap;

  /**
   * @private
   * @type {Array<number>}
   */
  this.lineDash_ = options.lineDash !== undefined ? options.lineDash : null;

  /**
   * @private
   * @type {number|undefined}
   */
  this.lineDashOffset_ = options.lineDashOffset;

  /**
   * @private
   * @type {string|undefined}
   */
  this.lineJoin_ = options.lineJoin;

  /**
   * @private
   * @type {number|undefined}
   */
  this.miterLimit_ = options.miterLimit;

  /**
   * @private
   * @type {number|undefined}
   */
  this.width_ = options.width;

  /**
   * @private
   * @type {string|undefined}
   */
  this.checksum_ = undefined;
};

/**
 * Clones the style.
 * @return {Stroke} The cloned style.
 * @api
 */
Stroke.prototype.clone = function clone () {
  var color = this.getColor();
  return new Stroke({
    color: Array.isArray(color) ? color.slice() : color || undefined,
    lineCap: this.getLineCap(),
    lineDash: this.getLineDash() ? this.getLineDash().slice() : undefined,
    lineDashOffset: this.getLineDashOffset(),
    lineJoin: this.getLineJoin(),
    miterLimit: this.getMiterLimit(),
    width: this.getWidth()
  });
};

/**
 * Get the stroke color.
 * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
 * @api
 */
Stroke.prototype.getColor = function getColor () {
  return this.color_;
};

/**
 * Get the line cap type for the stroke.
 * @return {string|undefined} Line cap.
 * @api
 */
Stroke.prototype.getLineCap = function getLineCap () {
  return this.lineCap_;
};

/**
 * Get the line dash style for the stroke.
 * @return {Array<number>} Line dash.
 * @api
 */
Stroke.prototype.getLineDash = function getLineDash () {
  return this.lineDash_;
};

/**
 * Get the line dash offset for the stroke.
 * @return {number|undefined} Line dash offset.
 * @api
 */
Stroke.prototype.getLineDashOffset = function getLineDashOffset () {
  return this.lineDashOffset_;
};

/**
 * Get the line join type for the stroke.
 * @return {string|undefined} Line join.
 * @api
 */
Stroke.prototype.getLineJoin = function getLineJoin () {
  return this.lineJoin_;
};

/**
 * Get the miter limit for the stroke.
 * @return {number|undefined} Miter limit.
 * @api
 */
Stroke.prototype.getMiterLimit = function getMiterLimit () {
  return this.miterLimit_;
};

/**
 * Get the stroke width.
 * @return {number|undefined} Width.
 * @api
 */
Stroke.prototype.getWidth = function getWidth () {
  return this.width_;
};

/**
 * Set the color.
 *
 * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
 * @api
 */
Stroke.prototype.setColor = function setColor (color) {
  this.color_ = color;
  this.checksum_ = undefined;
};

/**
 * Set the line cap.
 *
 * @param {string|undefined} lineCap Line cap.
 * @api
 */
Stroke.prototype.setLineCap = function setLineCap (lineCap) {
  this.lineCap_ = lineCap;
  this.checksum_ = undefined;
};

/**
 * Set the line dash.
 *
 * Please note that Internet Explorer 10 and lower [do not support][mdn] the
 * `setLineDash` method on the `CanvasRenderingContext2D` and therefore this
 * property will have no visual effect in these browsers.
 *
 * [mdn]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility
 *
 * @param {Array<number>} lineDash Line dash.
 * @api
 */
Stroke.prototype.setLineDash = function setLineDash (lineDash) {
  this.lineDash_ = lineDash;
  this.checksum_ = undefined;
};

/**
 * Set the line dash offset.
 *
 * @param {number|undefined} lineDashOffset Line dash offset.
 * @api
 */
Stroke.prototype.setLineDashOffset = function setLineDashOffset (lineDashOffset) {
  this.lineDashOffset_ = lineDashOffset;
  this.checksum_ = undefined;
};

/**
 * Set the line join.
 *
 * @param {string|undefined} lineJoin Line join.
 * @api
 */
Stroke.prototype.setLineJoin = function setLineJoin (lineJoin) {
  this.lineJoin_ = lineJoin;
  this.checksum_ = undefined;
};

/**
 * Set the miter limit.
 *
 * @param {number|undefined} miterLimit Miter limit.
 * @api
 */
Stroke.prototype.setMiterLimit = function setMiterLimit (miterLimit) {
  this.miterLimit_ = miterLimit;
  this.checksum_ = undefined;
};

/**
 * Set the width.
 *
 * @param {number|undefined} width Width.
 * @api
 */
Stroke.prototype.setWidth = function setWidth (width) {
  this.width_ = width;
  this.checksum_ = undefined;
};

/**
 * @return {string} The checksum.
 */
Stroke.prototype.getChecksum = function getChecksum () {
  if (this.checksum_ === undefined) {
    this.checksum_ = 's';
    if (this.color_) {
      if (typeof this.color_ === 'string') {
        this.checksum_ += this.color_;
      } else {
        this.checksum_ += Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(this.color_);
      }
    } else {
      this.checksum_ += '-';
    }
    this.checksum_ += ',' +
        (this.lineCap_ !== undefined ?
          this.lineCap_.toString() : '-') + ',' +
        (this.lineDash_ ?
          this.lineDash_.toString() : '-') + ',' +
        (this.lineDashOffset_ !== undefined ?
          this.lineDashOffset_ : '-') + ',' +
        (this.lineJoin_ !== undefined ?
          this.lineJoin_ : '-') + ',' +
        (this.miterLimit_ !== undefined ?
          this.miterLimit_.toString() : '-') + ',' +
        (this.width_ !== undefined ?
          this.width_.toString() : '-');
  }

  return this.checksum_;
};

/* harmony default export */ __webpack_exports__["default"] = (Stroke);

//# sourceMappingURL=Stroke.js.map

/***/ }),

/***/ "./node_modules/ol/style/Style.js":
/*!****************************************!*\
  !*** ./node_modules/ol/style/Style.js ***!
  \****************************************/
/*! exports provided: toFunction, createDefaultStyle, createEditingStyle, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toFunction", function() { return toFunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createDefaultStyle", function() { return createDefaultStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createEditingStyle", function() { return createEditingStyle; });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _Circle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Circle.js */ "./node_modules/ol/style/Circle.js");
/* harmony import */ var _Fill_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Fill.js */ "./node_modules/ol/style/Fill.js");
/* harmony import */ var _Stroke_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Stroke.js */ "./node_modules/ol/style/Stroke.js");
/**
 * @module ol/style/Style
 */

/**
 * Feature styles.
 *
 * If no style is defined, the following default style is used:
 * ```js
 *  import {Fill, Stroke, Circle, Style} from 'ol/style';
 *
 *  var fill = new Fill({
 *    color: 'rgba(255,255,255,0.4)'
 *  });
 *  var stroke = new Stroke({
 *    color: '#3399CC',
 *    width: 1.25
 *  });
 *  var styles = [
 *    new Style({
 *      image: new Circle({
 *        fill: fill,
 *        stroke: stroke,
 *        radius: 5
 *      }),
 *      fill: fill,
 *      stroke: stroke
 *    })
 *  ];
 * ```
 *
 * A separate editing style has the following defaults:
 * ```js
 *  import {Fill, Stroke, Circle, Style} from 'ol/style';
 *  import GeometryType from 'ol/geom/GeometryType';
 *
 *  var white = [255, 255, 255, 1];
 *  var blue = [0, 153, 255, 1];
 *  var width = 3;
 *  styles[GeometryType.POLYGON] = [
 *    new Style({
 *      fill: new Fill({
 *        color: [255, 255, 255, 0.5]
 *      })
 *    })
 *  ];
 *  styles[GeometryType.MULTI_POLYGON] =
 *      styles[GeometryType.POLYGON];
 *  styles[GeometryType.LINE_STRING] = [
 *    new Style({
 *      stroke: new Stroke({
 *        color: white,
 *        width: width + 2
 *      })
 *    }),
 *    new Style({
 *      stroke: new Stroke({
 *        color: blue,
 *        width: width
 *      })
 *    })
 *  ];
 *  styles[GeometryType.MULTI_LINE_STRING] =
 *      styles[GeometryType.LINE_STRING];
 *  styles[GeometryType.POINT] = [
 *    new Style({
 *      image: new Circle({
 *        radius: width * 2,
 *        fill: new Fill({
 *          color: blue
 *        }),
 *        stroke: new Stroke({
 *          color: white,
 *          width: width / 2
 *        })
 *      }),
 *      zIndex: Infinity
 *    })
 *  ];
 *  styles[GeometryType.MULTI_POINT] =
 *      styles[GeometryType.POINT];
 *  styles[GeometryType.GEOMETRY_COLLECTION] =
 *      styles[GeometryType.POLYGON].concat(
 *          styles[GeometryType.LINE_STRING],
 *          styles[GeometryType.POINT]
 *      );
 * ```
 */







/**
 * A function that takes an {@link module:ol/Feature} and a `{number}`
 * representing the view's resolution. The function should return a
 * {@link module:ol/style/Style} or an array of them. This way e.g. a
 * vector layer can be styled.
 *
 * @typedef {function(import("../Feature.js").FeatureLike, number):(Style|Array<Style>)} StyleFunction
 */

/**
 * A {@link Style}, an array of {@link Style}, or a {@link StyleFunction}.
 * @typedef {Style|Array<Style>|StyleFunction} StyleLike
 */

/**
 * A function that takes an {@link module:ol/Feature} as argument and returns an
 * {@link module:ol/geom/Geometry} that will be rendered and styled for the feature.
 *
 * @typedef {function(import("../Feature.js").FeatureLike):
 *     (import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined)} GeometryFunction
 */


/**
 * Custom renderer function. Takes two arguments:
 *
 * 1. The pixel coordinates of the geometry in GeoJSON notation.
 * 2. The {@link module:ol/render~State} of the layer renderer.
 *
 * @typedef {function((import("../coordinate.js").Coordinate|Array<import("../coordinate.js").Coordinate>|Array<Array<import("../coordinate.js").Coordinate>>),import("../render.js").State)}
 * RenderFunction
 */


/**
 * @typedef {Object} Options
 * @property {string|import("../geom/Geometry.js").default|GeometryFunction} [geometry] Feature property or geometry
 * or function returning a geometry to render for this style.
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {import("./Image.js").default} [image] Image style.
 * @property {RenderFunction} [renderer] Custom renderer. When configured, `fill`, `stroke` and `image` will be
 * ignored, and the provided function will be called with each render frame for each geometry.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {import("./Text.js").default} [text] Text style.
 * @property {number} [zIndex] Z index.
 */

/**
 * @classdesc
 * Container for vector feature rendering styles. Any changes made to the style
 * or its children through `set*()` methods will not take effect until the
 * feature or layer that uses the style is re-rendered.
 * @api
 */
var Style = function Style(opt_options) {

  var options = opt_options || {};

  /**
   * @private
   * @type {string|import("../geom/Geometry.js").default|GeometryFunction}
   */
  this.geometry_ = null;

  /**
   * @private
   * @type {!GeometryFunction}
   */
  this.geometryFunction_ = defaultGeometryFunction;

  if (options.geometry !== undefined) {
    this.setGeometry(options.geometry);
  }

  /**
   * @private
   * @type {import("./Fill.js").default}
   */
  this.fill_ = options.fill !== undefined ? options.fill : null;

  /**
     * @private
     * @type {import("./Image.js").default}
     */
  this.image_ = options.image !== undefined ? options.image : null;

  /**
   * @private
   * @type {RenderFunction|null}
   */
  this.renderer_ = options.renderer !== undefined ? options.renderer : null;

  /**
   * @private
   * @type {import("./Stroke.js").default}
   */
  this.stroke_ = options.stroke !== undefined ? options.stroke : null;

  /**
   * @private
   * @type {import("./Text.js").default}
   */
  this.text_ = options.text !== undefined ? options.text : null;

  /**
   * @private
   * @type {number|undefined}
   */
  this.zIndex_ = options.zIndex;

};

/**
 * Clones the style.
 * @return {Style} The cloned style.
 * @api
 */
Style.prototype.clone = function clone () {
  var geometry = this.getGeometry();
  if (geometry && typeof geometry === 'object') {
    geometry = /** @type {import("../geom/Geometry.js").default} */ (geometry).clone();
  }
  return new Style({
    geometry: geometry,
    fill: this.getFill() ? this.getFill().clone() : undefined,
    image: this.getImage() ? this.getImage().clone() : undefined,
    stroke: this.getStroke() ? this.getStroke().clone() : undefined,
    text: this.getText() ? this.getText().clone() : undefined,
    zIndex: this.getZIndex()
  });
};

/**
 * Get the custom renderer function that was configured with
 * {@link #setRenderer} or the `renderer` constructor option.
 * @return {RenderFunction|null} Custom renderer function.
 * @api
 */
Style.prototype.getRenderer = function getRenderer () {
  return this.renderer_;
};

/**
 * Sets a custom renderer function for this style. When set, `fill`, `stroke`
 * and `image` options of the style will be ignored.
 * @param {RenderFunction|null} renderer Custom renderer function.
 * @api
 */
Style.prototype.setRenderer = function setRenderer (renderer) {
  this.renderer_ = renderer;
};

/**
 * Get the geometry to be rendered.
 * @return {string|import("../geom/Geometry.js").default|GeometryFunction}
 * Feature property or geometry or function that returns the geometry that will
 * be rendered with this style.
 * @api
 */
Style.prototype.getGeometry = function getGeometry () {
  return this.geometry_;
};

/**
 * Get the function used to generate a geometry for rendering.
 * @return {!GeometryFunction} Function that is called with a feature
 * and returns the geometry to render instead of the feature's geometry.
 * @api
 */
Style.prototype.getGeometryFunction = function getGeometryFunction () {
  return this.geometryFunction_;
};

/**
 * Get the fill style.
 * @return {import("./Fill.js").default} Fill style.
 * @api
 */
Style.prototype.getFill = function getFill () {
  return this.fill_;
};

/**
 * Set the fill style.
 * @param {import("./Fill.js").default} fill Fill style.
 * @api
 */
Style.prototype.setFill = function setFill (fill) {
  this.fill_ = fill;
};

/**
 * Get the image style.
 * @return {import("./Image.js").default} Image style.
 * @api
 */
Style.prototype.getImage = function getImage () {
  return this.image_;
};

/**
 * Set the image style.
 * @param {import("./Image.js").default} image Image style.
 * @api
 */
Style.prototype.setImage = function setImage (image) {
  this.image_ = image;
};

/**
 * Get the stroke style.
 * @return {import("./Stroke.js").default} Stroke style.
 * @api
 */
Style.prototype.getStroke = function getStroke () {
  return this.stroke_;
};

/**
 * Set the stroke style.
 * @param {import("./Stroke.js").default} stroke Stroke style.
 * @api
 */
Style.prototype.setStroke = function setStroke (stroke) {
  this.stroke_ = stroke;
};

/**
 * Get the text style.
 * @return {import("./Text.js").default} Text style.
 * @api
 */
Style.prototype.getText = function getText () {
  return this.text_;
};

/**
 * Set the text style.
 * @param {import("./Text.js").default} text Text style.
 * @api
 */
Style.prototype.setText = function setText (text) {
  this.text_ = text;
};

/**
 * Get the z-index for the style.
 * @return {number|undefined} ZIndex.
 * @api
 */
Style.prototype.getZIndex = function getZIndex () {
  return this.zIndex_;
};

/**
 * Set a geometry that is rendered instead of the feature's geometry.
 *
 * @param {string|import("../geom/Geometry.js").default|GeometryFunction} geometry
 *   Feature property or geometry or function returning a geometry to render
 *   for this style.
 * @api
 */
Style.prototype.setGeometry = function setGeometry (geometry) {
  if (typeof geometry === 'function') {
    this.geometryFunction_ = geometry;
  } else if (typeof geometry === 'string') {
    this.geometryFunction_ = function(feature) {
      return (
        /** @type {import("../geom/Geometry.js").default} */ (feature.get(geometry))
      );
    };
  } else if (!geometry) {
    this.geometryFunction_ = defaultGeometryFunction;
  } else if (geometry !== undefined) {
    this.geometryFunction_ = function() {
      return (
        /** @type {import("../geom/Geometry.js").default} */ (geometry)
      );
    };
  }
  this.geometry_ = geometry;
};

/**
 * Set the z-index.
 *
 * @param {number|undefined} zIndex ZIndex.
 * @api
 */
Style.prototype.setZIndex = function setZIndex (zIndex) {
  this.zIndex_ = zIndex;
};


/**
 * Convert the provided object into a style function.  Functions passed through
 * unchanged.  Arrays of Style or single style objects wrapped in a
 * new style function.
 * @param {StyleFunction|Array<Style>|Style} obj
 *     A style function, a single style, or an array of styles.
 * @return {StyleFunction} A style function.
 */
function toFunction(obj) {
  var styleFunction;

  if (typeof obj === 'function') {
    styleFunction = obj;
  } else {
    /**
     * @type {Array<Style>}
     */
    var styles;
    if (Array.isArray(obj)) {
      styles = obj;
    } else {
      Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(typeof /** @type {?} */ (obj).getZIndex === 'function',
        41); // Expected an `Style` or an array of `Style`
      var style = /** @type {Style} */ (obj);
      styles = [style];
    }
    styleFunction = function() {
      return styles;
    };
  }
  return styleFunction;
}


/**
 * @type {Array<Style>}
 */
var defaultStyles = null;


/**
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {number} resolution Resolution.
 * @return {Array<Style>} Style.
 */
function createDefaultStyle(feature, resolution) {
  // We don't use an immediately-invoked function
  // and a closure so we don't get an error at script evaluation time in
  // browsers that do not support Canvas. (import("./Circle.js").CircleStyle does
  // canvas.getContext('2d') at construction time, which will cause an.error
  // in such browsers.)
  if (!defaultStyles) {
    var fill = new _Fill_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
      color: 'rgba(255,255,255,0.4)'
    });
    var stroke = new _Stroke_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
      color: '#3399CC',
      width: 1.25
    });
    defaultStyles = [
      new Style({
        image: new _Circle_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
          fill: fill,
          stroke: stroke,
          radius: 5
        }),
        fill: fill,
        stroke: stroke
      })
    ];
  }
  return defaultStyles;
}


/**
 * Default styles for editing features.
 * @return {Object<import("../geom/GeometryType.js").default, Array<Style>>} Styles
 */
function createEditingStyle() {
  /** @type {Object<import("../geom/GeometryType.js").default, Array<Style>>} */
  var styles = {};
  var white = [255, 255, 255, 1];
  var blue = [0, 153, 255, 1];
  var width = 3;
  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POLYGON] = [
    new Style({
      fill: new _Fill_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
        color: [255, 255, 255, 0.5]
      })
    })
  ];
  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POLYGON] =
      styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POLYGON];

  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINE_STRING] = [
    new Style({
      stroke: new _Stroke_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
        color: white,
        width: width + 2
      })
    }),
    new Style({
      stroke: new _Stroke_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
        color: blue,
        width: width
      })
    })
  ];
  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_LINE_STRING] =
      styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINE_STRING];

  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CIRCLE] =
      styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POLYGON].concat(
        styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINE_STRING]
      );


  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINT] = [
    new Style({
      image: new _Circle_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
        radius: width * 2,
        fill: new _Fill_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
          color: blue
        }),
        stroke: new _Stroke_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
          color: white,
          width: width / 2
        })
      }),
      zIndex: Infinity
    })
  ];
  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POINT] =
      styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINT];

  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].GEOMETRY_COLLECTION] =
      styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POLYGON].concat(
        styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINE_STRING],
        styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINT]
      );

  return styles;
}


/**
 * Function that is called with a feature and returns its default geometry.
 * @param {import("../Feature.js").FeatureLike} feature Feature to get the geometry for.
 * @return {import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined} Geometry to render.
 */
function defaultGeometryFunction(feature) {
  return feature.getGeometry();
}

/* harmony default export */ __webpack_exports__["default"] = (Style);

//# sourceMappingURL=Style.js.map

/***/ }),

/***/ "./node_modules/ol/style/TextPlacement.js":
/*!************************************************!*\
  !*** ./node_modules/ol/style/TextPlacement.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/style/TextPlacement
 */

/**
 * Text placement. One of `'point'`, `'line'`. Default is `'point'`. Note that
 * `'line'` requires the underlying geometry to be a {@link module:ol/geom/LineString~LineString},
 * {@link module:ol/geom/Polygon~Polygon}, {@link module:ol/geom/MultiLineString~MultiLineString} or
 * {@link module:ol/geom/MultiPolygon~MultiPolygon}.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  POINT: 'point',
  LINE: 'line'
});

//# sourceMappingURL=TextPlacement.js.map

/***/ }),

/***/ "./node_modules/ol/tilecoord.js":
/*!**************************************!*\
  !*** ./node_modules/ol/tilecoord.js ***!
  \**************************************/
/*! exports provided: createOrUpdate, getKeyZXY, getKey, fromKey, hash, quadKey, withinExtentAndZ */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdate", function() { return createOrUpdate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getKeyZXY", function() { return getKeyZXY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getKey", function() { return getKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromKey", function() { return fromKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hash", function() { return hash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quadKey", function() { return quadKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "withinExtentAndZ", function() { return withinExtentAndZ; });
/**
 * @module ol/tilecoord
 */


/**
 * An array of three numbers representing the location of a tile in a tile
 * grid. The order is `z`, `x`, and `y`. `z` is the zoom level.
 * @typedef {Array<number>} TileCoord
 * @api
 */


/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {TileCoord=} opt_tileCoord Tile coordinate.
 * @return {TileCoord} Tile coordinate.
 */
function createOrUpdate(z, x, y, opt_tileCoord) {
  if (opt_tileCoord !== undefined) {
    opt_tileCoord[0] = z;
    opt_tileCoord[1] = x;
    opt_tileCoord[2] = y;
    return opt_tileCoord;
  } else {
    return [z, x, y];
  }
}


/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {string} Key.
 */
function getKeyZXY(z, x, y) {
  return z + '/' + x + '/' + y;
}


/**
 * Get the key for a tile coord.
 * @param {TileCoord} tileCoord The tile coord.
 * @return {string} Key.
 */
function getKey(tileCoord) {
  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);
}


/**
 * Get a tile coord given a key.
 * @param {string} key The tile coord key.
 * @return {TileCoord} The tile coord.
 */
function fromKey(key) {
  return key.split('/').map(Number);
}


/**
 * @param {TileCoord} tileCoord Tile coord.
 * @return {number} Hash.
 */
function hash(tileCoord) {
  return (tileCoord[1] << tileCoord[0]) + tileCoord[2];
}


/**
 * @param {TileCoord} tileCoord Tile coord.
 * @return {string} Quad key.
 */
function quadKey(tileCoord) {
  var z = tileCoord[0];
  var digits = new Array(z);
  var mask = 1 << (z - 1);
  var i, charCode;
  for (i = 0; i < z; ++i) {
    // 48 is charCode for 0 - '0'.charCodeAt(0)
    charCode = 48;
    if (tileCoord[1] & mask) {
      charCode += 1;
    }
    if (tileCoord[2] & mask) {
      charCode += 2;
    }
    digits[i] = String.fromCharCode(charCode);
    mask >>= 1;
  }
  return digits.join('');
}


/**
 * @param {TileCoord} tileCoord Tile coordinate.
 * @param {!import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {boolean} Tile coordinate is within extent and zoom level range.
 */
function withinExtentAndZ(tileCoord, tileGrid) {
  var z = tileCoord[0];
  var x = tileCoord[1];
  var y = tileCoord[2];

  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {
    return false;
  }
  var extent = tileGrid.getExtent();
  var tileRange;
  if (!extent) {
    tileRange = tileGrid.getFullTileRange(z);
  } else {
    tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
  }
  if (!tileRange) {
    return true;
  } else {
    return tileRange.containsXY(x, y);
  }
}

//# sourceMappingURL=tilecoord.js.map

/***/ }),

/***/ "./node_modules/ol/tilegrid.js":
/*!*************************************!*\
  !*** ./node_modules/ol/tilegrid.js ***!
  \*************************************/
/*! exports provided: getForProjection, wrapX, createForExtent, createXYZ, createForProjection, extentFromProjection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getForProjection", function() { return getForProjection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wrapX", function() { return wrapX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createForExtent", function() { return createForExtent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createXYZ", function() { return createXYZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createForProjection", function() { return createForProjection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extentFromProjection", function() { return extentFromProjection; });
/* harmony import */ var _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tilegrid/common.js */ "./node_modules/ol/tilegrid/common.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./size.js */ "./node_modules/ol/size.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _extent_Corner_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./extent/Corner.js */ "./node_modules/ol/extent/Corner.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _proj_Units_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./proj/Units.js */ "./node_modules/ol/proj/Units.js");
/* harmony import */ var _tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./tilegrid/TileGrid.js */ "./node_modules/ol/tilegrid/TileGrid.js");
/**
 * @module ol/tilegrid
 */









/**
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {!TileGrid} Default tile grid for the
 * passed projection.
 */
function getForProjection(projection) {
  var tileGrid = projection.getDefaultTileGrid();
  if (!tileGrid) {
    tileGrid = createForProjection(projection);
    projection.setDefaultTileGrid(tileGrid);
  }
  return tileGrid;
}


/**
 * @param {TileGrid} tileGrid Tile grid.
 * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {import("./tilecoord.js").TileCoord} Tile coordinate.
 */
function wrapX(tileGrid, tileCoord, projection) {
  var z = tileCoord[0];
  var center = tileGrid.getTileCoordCenter(tileCoord);
  var projectionExtent = extentFromProjection(projection);
  if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["containsCoordinate"])(projectionExtent, center)) {
    var worldWidth = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["getWidth"])(projectionExtent);
    var worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);
    center[0] += worldWidth * worldsAway;
    return tileGrid.getTileCoordForCoordAndZ(center, z);
  } else {
    return tileCoord;
  }
}


/**
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number=} opt_maxZoom Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size=} opt_tileSize Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {Corner=} opt_corner Extent corner (default is `'top-left'`).
 * @return {!TileGrid} TileGrid instance.
 */
function createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner) {
  var corner = opt_corner !== undefined ? opt_corner : _extent_Corner_js__WEBPACK_IMPORTED_MODULE_3__["default"].TOP_LEFT;

  var resolutions = resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize);

  return new _tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_6__["default"]({
    extent: extent,
    origin: Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["getCorner"])(extent, corner),
    resolutions: resolutions,
    tileSize: opt_tileSize
  });
}


/**
 * @typedef {Object} XYZOptions
 * @property {import("./extent.js").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the
 * top-left corner of the extent. The zero level of the grid is defined by the resolution at which one tile fits in the
 * provided extent. If not provided, the extent of the EPSG:3857 projection is used.
 * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels
 * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.
 * @property {number} [minZoom=0] Minimum zoom.
 * @property {number|import("./size.js").Size} [tileSize=[256, 256]] Tile size in pixels.
 */


/**
 * Creates a tile grid with a standard XYZ tiling scheme.
 * @param {XYZOptions=} opt_options Tile grid options.
 * @return {!TileGrid} Tile grid instance.
 * @api
 */
function createXYZ(opt_options) {
  /** @type {XYZOptions} */
  var xyzOptions = opt_options || {};

  var extent = xyzOptions.extent || Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__["get"])('EPSG:3857').getExtent();

  /** @type {import("./tilegrid/TileGrid.js").Options} */
  var gridOptions = {
    extent: extent,
    minZoom: xyzOptions.minZoom,
    tileSize: xyzOptions.tileSize,
    resolutions: resolutionsFromExtent(
      extent,
      xyzOptions.maxZoom,
      xyzOptions.tileSize
    )
  };
  return new _tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_6__["default"](gridOptions);
}


/**
 * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number=} opt_maxZoom Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size=} opt_tileSize Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @return {!Array<number>} Resolutions array.
 */
function resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize) {
  var maxZoom = opt_maxZoom !== undefined ?
    opt_maxZoom : _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_MAX_ZOOM"];

  var height = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["getHeight"])(extent);
  var width = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["getWidth"])(extent);

  var tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_1__["toSize"])(opt_tileSize !== undefined ?
    opt_tileSize : _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_TILE_SIZE"]);
  var maxResolution = Math.max(
    width / tileSize[0], height / tileSize[1]);

  var length = maxZoom + 1;
  var resolutions = new Array(length);
  for (var z = 0; z < length; ++z) {
    resolutions[z] = maxResolution / Math.pow(2, z);
  }
  return resolutions;
}


/**
 * @param {import("./proj.js").ProjectionLike} projection Projection.
 * @param {number=} opt_maxZoom Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size=} opt_tileSize Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {Corner=} opt_corner Extent corner (default is `'top-left'`).
 * @return {!TileGrid} TileGrid instance.
 */
function createForProjection(projection, opt_maxZoom, opt_tileSize, opt_corner) {
  var extent = extentFromProjection(projection);
  return createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner);
}


/**
 * Generate a tile grid extent from a projection.  If the projection has an
 * extent, it is used.  If not, a global extent is assumed.
 * @param {import("./proj.js").ProjectionLike} projection Projection.
 * @return {import("./extent.js").Extent} Extent.
 */
function extentFromProjection(projection) {
  projection = Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__["get"])(projection);
  var extent = projection.getExtent();
  if (!extent) {
    var half = 180 * _proj_js__WEBPACK_IMPORTED_MODULE_4__["METERS_PER_UNIT"][_proj_Units_js__WEBPACK_IMPORTED_MODULE_5__["default"].DEGREES] / projection.getMetersPerUnit();
    extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["createOrUpdate"])(-half, -half, half, half);
  }
  return extent;
}

//# sourceMappingURL=tilegrid.js.map

/***/ }),

/***/ "./node_modules/ol/tilegrid/TileGrid.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/tilegrid/TileGrid.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/ol/tilegrid/common.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _TileRange_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../TileRange.js */ "./node_modules/ol/TileRange.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../size.js */ "./node_modules/ol/size.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");
/**
 * @module ol/tilegrid/TileGrid
 */










/**
 * @private
 * @type {import("../tilecoord.js").TileCoord}
 */
var tmpTileCoord = [0, 0, 0];


/**
 * @typedef {Object} Options
 * @property {import("../extent.js").Extent} [extent] Extent for the tile grid. No tiles outside this
 * extent will be requested by {@link module:ol/source/Tile} sources. When no `origin` or
 * `origins` are configured, the `origin` will be set to the top-left corner of the extent.
 * @property {number} [minZoom=0] Minimum zoom.
 * @property {import("../coordinate.js").Coordinate} [origin] The tile grid origin, i.e. where the `x`
 * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and upwards. If not
 * specified, `extent` or `origins` must be provided.
 * @property {Array<import("../coordinate.js").Coordinate>} [origins] Tile grid origins, i.e. where
 * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length
 * should match the length of the `resolutions` array, i.e. each resolution can have a different
 * origin. Tile coordinates increase left to right and upwards. If not specified, `extent` or
 * `origin` must be provided.
 * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs
 * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions
 * array will have a length of `maxZoom + 1`.
 * @property {Array<import("../size.js").Size>} [sizes] Sizes.
 * @property {number|import("../size.js").Size} [tileSize] Tile size.
 * Default is `[256, 256]`.
 * @property {Array<import("../size.js").Size>} [tileSizes] Tile sizes. If given, the array length
 * should match the length of the `resolutions` array, i.e. each resolution can have a different
 * tile size.
 */


/**
 * @classdesc
 * Base class for setting the grid pattern for sources accessing tiled-image
 * servers.
 * @api
 */
var TileGrid = function TileGrid(options) {

  /**
   * @protected
   * @type {number}
   */
  this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;

  /**
   * @private
   * @type {!Array<number>}
   */
  this.resolutions_ = options.resolutions;
  Object(_asserts_js__WEBPACK_IMPORTED_MODULE_1__["assert"])(Object(_array_js__WEBPACK_IMPORTED_MODULE_3__["isSorted"])(this.resolutions_, function(a, b) {
    return b - a;
  }, true), 17); // `resolutions` must be sorted in descending order


  // check if we've got a consistent zoom factor and origin
  var zoomFactor;
  if (!options.origins) {
    for (var i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {
      if (!zoomFactor) {
        zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];
      } else {
        if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {
          zoomFactor = undefined;
          break;
        }
      }
    }
  }


  /**
   * @private
   * @type {number|undefined}
   */
  this.zoomFactor_ = zoomFactor;


  /**
   * @protected
   * @type {number}
   */
  this.maxZoom = this.resolutions_.length - 1;

  /**
   * @private
   * @type {import("../coordinate.js").Coordinate}
   */
  this.origin_ = options.origin !== undefined ? options.origin : null;

  /**
   * @private
   * @type {Array<import("../coordinate.js").Coordinate>}
   */
  this.origins_ = null;
  if (options.origins !== undefined) {
    this.origins_ = options.origins;
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_1__["assert"])(this.origins_.length == this.resolutions_.length,
      20); // Number of `origins` and `resolutions` must be equal
  }

  var extent = options.extent;

  if (extent !== undefined &&
      !this.origin_ && !this.origins_) {
    this.origin_ = Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["getTopLeft"])(extent);
  }

  Object(_asserts_js__WEBPACK_IMPORTED_MODULE_1__["assert"])(
    (!this.origin_ && this.origins_) || (this.origin_ && !this.origins_),
    18); // Either `origin` or `origins` must be configured, never both

  /**
   * @private
   * @type {Array<number|import("../size.js").Size>}
   */
  this.tileSizes_ = null;
  if (options.tileSizes !== undefined) {
    this.tileSizes_ = options.tileSizes;
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_1__["assert"])(this.tileSizes_.length == this.resolutions_.length,
      19); // Number of `tileSizes` and `resolutions` must be equal
  }

  /**
   * @private
   * @type {number|import("../size.js").Size}
   */
  this.tileSize_ = options.tileSize !== undefined ?
    options.tileSize :
    !this.tileSizes_ ? _common_js__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_TILE_SIZE"] : null;
  Object(_asserts_js__WEBPACK_IMPORTED_MODULE_1__["assert"])(
    (!this.tileSize_ && this.tileSizes_) ||
      (this.tileSize_ && !this.tileSizes_),
    22); // Either `tileSize` or `tileSizes` must be configured, never both

  /**
   * @private
   * @type {import("../extent.js").Extent}
   */
  this.extent_ = extent !== undefined ? extent : null;


  /**
   * @private
   * @type {Array<import("../TileRange.js").default>}
   */
  this.fullTileRanges_ = null;

  /**
   * @private
   * @type {import("../size.js").Size}
   */
  this.tmpSize_ = [0, 0];

  if (options.sizes !== undefined) {
    this.fullTileRanges_ = options.sizes.map(function(size, z) {
      var tileRange = new _TileRange_js__WEBPACK_IMPORTED_MODULE_2__["default"](
        Math.min(0, size[0]), Math.max(size[0] - 1, -1),
        Math.min(0, size[1]), Math.max(size[1] - 1, -1));
      return tileRange;
    }, this);
  } else if (extent) {
    this.calculateTileRanges_(extent);
  }

};

/**
 * Call a function with each tile coordinate for a given extent and zoom level.
 *
 * @param {import("../extent.js").Extent} extent Extent.
 * @param {number} zoom Integer zoom level.
 * @param {function(import("../tilecoord.js").TileCoord)} callback Function called with each tile coordinate.
 * @api
 */
TileGrid.prototype.forEachTileCoord = function forEachTileCoord (extent, zoom, callback) {
  var tileRange = this.getTileRangeForExtentAndZ(extent, zoom);
  for (var i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {
    for (var j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {
      callback([zoom, i, j]);
    }
  }
};

/**
 * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @param {function(this: T, number, import("../TileRange.js").default): boolean} callback Callback.
 * @param {T=} opt_this The object to use as `this` in `callback`.
 * @param {import("../TileRange.js").default=} opt_tileRange Temporary import("../TileRange.js").default object.
 * @param {import("../extent.js").Extent=} opt_extent Temporary import("../extent.js").Extent object.
 * @return {boolean} Callback succeeded.
 * @template T
 */
TileGrid.prototype.forEachTileCoordParentTileRange = function forEachTileCoordParentTileRange (tileCoord, callback, opt_this, opt_tileRange, opt_extent) {
  var tileRange, x, y;
  var tileCoordExtent = null;
  var z = tileCoord[0] - 1;
  if (this.zoomFactor_ === 2) {
    x = tileCoord[1];
    y = tileCoord[2];
  } else {
    tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);
  }
  while (z >= this.minZoom) {
    if (this.zoomFactor_ === 2) {
      x = Math.floor(x / 2);
      y = Math.floor(y / 2);
      tileRange = Object(_TileRange_js__WEBPACK_IMPORTED_MODULE_2__["createOrUpdate"])(x, x, y, y, opt_tileRange);
    } else {
      tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);
    }
    if (callback.call(opt_this, z, tileRange)) {
      return true;
    }
    --z;
  }
  return false;
};

/**
 * Get the extent for this tile grid, if it was configured.
 * @return {import("../extent.js").Extent} Extent.
 */
TileGrid.prototype.getExtent = function getExtent () {
  return this.extent_;
};

/**
 * Get the maximum zoom level for the grid.
 * @return {number} Max zoom.
 * @api
 */
TileGrid.prototype.getMaxZoom = function getMaxZoom () {
  return this.maxZoom;
};

/**
 * Get the minimum zoom level for the grid.
 * @return {number} Min zoom.
 * @api
 */
TileGrid.prototype.getMinZoom = function getMinZoom () {
  return this.minZoom;
};

/**
 * Get the origin for the grid at the given zoom level.
 * @param {number} z Integer zoom level.
 * @return {import("../coordinate.js").Coordinate} Origin.
 * @api
 */
TileGrid.prototype.getOrigin = function getOrigin (z) {
  if (this.origin_) {
    return this.origin_;
  } else {
    return this.origins_[z];
  }
};

/**
 * Get the resolution for the given zoom level.
 * @param {number} z Integer zoom level.
 * @return {number} Resolution.
 * @api
 */
TileGrid.prototype.getResolution = function getResolution (z) {
  return this.resolutions_[z];
};

/**
 * Get the list of resolutions for the tile grid.
 * @return {Array<number>} Resolutions.
 * @api
 */
TileGrid.prototype.getResolutions = function getResolutions () {
  return this.resolutions_;
};

/**
 * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @param {import("../TileRange.js").default=} opt_tileRange Temporary import("../TileRange.js").default object.
 * @param {import("../extent.js").Extent=} opt_extent Temporary import("../extent.js").Extent object.
 * @return {import("../TileRange.js").default} Tile range.
 */
TileGrid.prototype.getTileCoordChildTileRange = function getTileCoordChildTileRange (tileCoord, opt_tileRange, opt_extent) {
  if (tileCoord[0] < this.maxZoom) {
    if (this.zoomFactor_ === 2) {
      var minX = tileCoord[1] * 2;
      var minY = tileCoord[2] * 2;
      return Object(_TileRange_js__WEBPACK_IMPORTED_MODULE_2__["createOrUpdate"])(minX, minX + 1, minY, minY + 1, opt_tileRange);
    }
    var tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);
    return this.getTileRangeForExtentAndZ(
      tileCoordExtent, tileCoord[0] + 1, opt_tileRange);
  }
  return null;
};

/**
 * Get the extent for a tile range.
 * @param {number} z Integer zoom level.
 * @param {import("../TileRange.js").default} tileRange Tile range.
 * @param {import("../extent.js").Extent=} opt_extent Temporary import("../extent.js").Extent object.
 * @return {import("../extent.js").Extent} Extent.
 */
TileGrid.prototype.getTileRangeExtent = function getTileRangeExtent (z, tileRange, opt_extent) {
  var origin = this.getOrigin(z);
  var resolution = this.getResolution(z);
  var tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_6__["toSize"])(this.getTileSize(z), this.tmpSize_);
  var minX = origin[0] + tileRange.minX * tileSize[0] * resolution;
  var maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;
  var minY = origin[1] + tileRange.minY * tileSize[1] * resolution;
  var maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;
  return Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["createOrUpdate"])(minX, minY, maxX, maxY, opt_extent);
};

/**
 * Get a tile range for the given extent and integer zoom level.
 * @param {import("../extent.js").Extent} extent Extent.
 * @param {number} z Integer zoom level.
 * @param {import("../TileRange.js").default=} opt_tileRange Temporary tile range object.
 * @return {import("../TileRange.js").default} Tile range.
 */
TileGrid.prototype.getTileRangeForExtentAndZ = function getTileRangeForExtentAndZ (extent, z, opt_tileRange) {
  var tileCoord = tmpTileCoord;
  this.getTileCoordForXYAndZ_(extent[0], extent[1], z, false, tileCoord);
  var minX = tileCoord[1];
  var minY = tileCoord[2];
  this.getTileCoordForXYAndZ_(extent[2], extent[3], z, true, tileCoord);
  return Object(_TileRange_js__WEBPACK_IMPORTED_MODULE_2__["createOrUpdate"])(minX, tileCoord[1], minY, tileCoord[2], opt_tileRange);
};

/**
 * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @return {import("../coordinate.js").Coordinate} Tile center.
 */
TileGrid.prototype.getTileCoordCenter = function getTileCoordCenter (tileCoord) {
  var origin = this.getOrigin(tileCoord[0]);
  var resolution = this.getResolution(tileCoord[0]);
  var tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_6__["toSize"])(this.getTileSize(tileCoord[0]), this.tmpSize_);
  return [
    origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,
    origin[1] + (tileCoord[2] + 0.5) * tileSize[1] * resolution
  ];
};

/**
 * Get the extent of a tile coordinate.
 *
 * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @param {import("../extent.js").Extent=} opt_extent Temporary extent object.
 * @return {import("../extent.js").Extent} Extent.
 * @api
 */
TileGrid.prototype.getTileCoordExtent = function getTileCoordExtent (tileCoord, opt_extent) {
  var origin = this.getOrigin(tileCoord[0]);
  var resolution = this.getResolution(tileCoord[0]);
  var tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_6__["toSize"])(this.getTileSize(tileCoord[0]), this.tmpSize_);
  var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
  var minY = origin[1] + tileCoord[2] * tileSize[1] * resolution;
  var maxX = minX + tileSize[0] * resolution;
  var maxY = minY + tileSize[1] * resolution;
  return Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["createOrUpdate"])(minX, minY, maxX, maxY, opt_extent);
};

/**
 * Get the tile coordinate for the given map coordinate and resolution.This
 * method considers that coordinates that intersect tile boundaries should be
 * assigned the higher tile coordinate.
 *
 * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
 * @param {number} resolution Resolution.
 * @param {import("../tilecoord.js").TileCoord=} opt_tileCoord Destination import("../tilecoord.js").TileCoord object.
 * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
 * @api
 */
TileGrid.prototype.getTileCoordForCoordAndResolution = function getTileCoordForCoordAndResolution (coordinate, resolution, opt_tileCoord) {
  return this.getTileCoordForXYAndResolution_(
    coordinate[0], coordinate[1], resolution, false, opt_tileCoord);
};

/**
 * Note that this method should not be called for resolutions that correspond
 * to an integer zoom level.Instead call the `getTileCoordForXYAndZ_` method.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} resolution Resolution (for a non-integer zoom level).
 * @param {boolean} reverseIntersectionPolicy Instead of letting edge
 *   intersections go to the higher tile coordinate, let edge intersections
 *   go to the lower tile coordinate.
 * @param {import("../tilecoord.js").TileCoord=} opt_tileCoord Temporary import("../tilecoord.js").TileCoord object.
 * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
 * @private
 */
TileGrid.prototype.getTileCoordForXYAndResolution_ = function getTileCoordForXYAndResolution_ (x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {
  var z = this.getZForResolution(resolution);
  var scale = resolution / this.getResolution(z);
  var origin = this.getOrigin(z);
  var tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_6__["toSize"])(this.getTileSize(z), this.tmpSize_);

  var adjustX = reverseIntersectionPolicy ? 0.5 : 0;
  var adjustY = reverseIntersectionPolicy ? 0 : 0.5;
  var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);
  var yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY);
  var tileCoordX = scale * xFromOrigin / tileSize[0];
  var tileCoordY = scale * yFromOrigin / tileSize[1];

  if (reverseIntersectionPolicy) {
    tileCoordX = Math.ceil(tileCoordX) - 1;
    tileCoordY = Math.ceil(tileCoordY) - 1;
  } else {
    tileCoordX = Math.floor(tileCoordX);
    tileCoordY = Math.floor(tileCoordY);
  }

  return Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_7__["createOrUpdate"])(z, tileCoordX, tileCoordY, opt_tileCoord);
};

/**
 * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
 * they should have separate implementations.This method is for integer zoom
 * levels.The other method should only be called for resolutions corresponding
 * to non-integer zoom levels.
 * @param {number} x Map x coordinate.
 * @param {number} y Map y coordinate.
 * @param {number} z Integer zoom level.
 * @param {boolean} reverseIntersectionPolicy Instead of letting edge
 *   intersections go to the higher tile coordinate, let edge intersections
 *   go to the lower tile coordinate.
 * @param {import("../tilecoord.js").TileCoord=} opt_tileCoord Temporary import("../tilecoord.js").TileCoord object.
 * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
 * @private
 */
TileGrid.prototype.getTileCoordForXYAndZ_ = function getTileCoordForXYAndZ_ (x, y, z, reverseIntersectionPolicy, opt_tileCoord) {
  var origin = this.getOrigin(z);
  var resolution = this.getResolution(z);
  var tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_6__["toSize"])(this.getTileSize(z), this.tmpSize_);

  var adjustX = reverseIntersectionPolicy ? 0.5 : 0;
  var adjustY = reverseIntersectionPolicy ? 0 : 0.5;
  var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);
  var yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY);
  var tileCoordX = xFromOrigin / tileSize[0];
  var tileCoordY = yFromOrigin / tileSize[1];

  if (reverseIntersectionPolicy) {
    tileCoordX = Math.ceil(tileCoordX) - 1;
    tileCoordY = Math.ceil(tileCoordY) - 1;
  } else {
    tileCoordX = Math.floor(tileCoordX);
    tileCoordY = Math.floor(tileCoordY);
  }

  return Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_7__["createOrUpdate"])(z, tileCoordX, tileCoordY, opt_tileCoord);
};

/**
 * Get a tile coordinate given a map coordinate and zoom level.
 * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
 * @param {number} z Zoom level.
 * @param {import("../tilecoord.js").TileCoord=} opt_tileCoord Destination import("../tilecoord.js").TileCoord object.
 * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
 * @api
 */
TileGrid.prototype.getTileCoordForCoordAndZ = function getTileCoordForCoordAndZ (coordinate, z, opt_tileCoord) {
  return this.getTileCoordForXYAndZ_(
    coordinate[0], coordinate[1], z, false, opt_tileCoord);
};

/**
 * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @return {number} Tile resolution.
 */
TileGrid.prototype.getTileCoordResolution = function getTileCoordResolution (tileCoord) {
  return this.resolutions_[tileCoord[0]];
};

/**
 * Get the tile size for a zoom level. The type of the return value matches the
 * `tileSize` or `tileSizes` that the tile grid was configured with. To always
 * get an `import("../size.js").Size`, run the result through `import("../size.js").Size.toSize()`.
 * @param {number} z Z.
 * @return {number|import("../size.js").Size} Tile size.
 * @api
 */
TileGrid.prototype.getTileSize = function getTileSize (z) {
  if (this.tileSize_) {
    return this.tileSize_;
  } else {
    return this.tileSizes_[z];
  }
};

/**
 * @param {number} z Zoom level.
 * @return {import("../TileRange.js").default} Extent tile range for the specified zoom level.
 */
TileGrid.prototype.getFullTileRange = function getFullTileRange (z) {
  if (!this.fullTileRanges_) {
    return null;
  } else {
    return this.fullTileRanges_[z];
  }
};

/**
 * @param {number} resolution Resolution.
 * @param {number=} opt_direction If 0, the nearest resolution will be used.
 *   If 1, the nearest lower resolution will be used. If -1, the nearest
 *   higher resolution will be used. Default is 0.
 * @return {number} Z.
 * @api
 */
TileGrid.prototype.getZForResolution = function getZForResolution (resolution, opt_direction) {
  var z = Object(_array_js__WEBPACK_IMPORTED_MODULE_3__["linearFindNearest"])(this.resolutions_, resolution, opt_direction || 0);
  return Object(_math_js__WEBPACK_IMPORTED_MODULE_5__["clamp"])(z, this.minZoom, this.maxZoom);
};

/**
 * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
 * @private
 */
TileGrid.prototype.calculateTileRanges_ = function calculateTileRanges_ (extent) {
  var length = this.resolutions_.length;
  var fullTileRanges = new Array(length);
  for (var z = this.minZoom; z < length; ++z) {
    fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);
  }
  this.fullTileRanges_ = fullTileRanges;
};


/* harmony default export */ __webpack_exports__["default"] = (TileGrid);

//# sourceMappingURL=TileGrid.js.map

/***/ }),

/***/ "./node_modules/ol/tilegrid/common.js":
/*!********************************************!*\
  !*** ./node_modules/ol/tilegrid/common.js ***!
  \********************************************/
/*! exports provided: DEFAULT_MAX_ZOOM, DEFAULT_TILE_SIZE */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_MAX_ZOOM", function() { return DEFAULT_MAX_ZOOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_TILE_SIZE", function() { return DEFAULT_TILE_SIZE; });
/**
 * @module ol/tilegrid/common
 */

/**
 * Default maximum zoom for default tile grids.
 * @type {number}
 */
var DEFAULT_MAX_ZOOM = 42;

/**
 * Default tile size.
 * @type {number}
 */
var DEFAULT_TILE_SIZE = 256;

//# sourceMappingURL=common.js.map

/***/ }),

/***/ "./node_modules/ol/tileurlfunction.js":
/*!********************************************!*\
  !*** ./node_modules/ol/tileurlfunction.js ***!
  \********************************************/
/*! exports provided: createFromTemplate, createFromTemplates, createFromTileUrlFunctions, nullTileUrlFunction, expandUrl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createFromTemplate", function() { return createFromTemplate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createFromTemplates", function() { return createFromTemplates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createFromTileUrlFunctions", function() { return createFromTileUrlFunctions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nullTileUrlFunction", function() { return nullTileUrlFunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expandUrl", function() { return expandUrl; });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tilecoord.js */ "./node_modules/ol/tilecoord.js");
/**
 * @module ol/tileurlfunction
 */





/**
 * @param {string} template Template.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */
function createFromTemplate(template, tileGrid) {
  var zRegEx = /\{z\}/g;
  var xRegEx = /\{x\}/g;
  var yRegEx = /\{y\}/g;
  var dashYRegEx = /\{-y\}/g;
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return undefined;
      } else {
        return template.replace(zRegEx, tileCoord[0].toString())
          .replace(xRegEx, tileCoord[1].toString())
          .replace(yRegEx, function() {
            var y = -tileCoord[2] - 1;
            return y.toString();
          })
          .replace(dashYRegEx, function() {
            var z = tileCoord[0];
            var range = tileGrid.getFullTileRange(z);
            Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(range, 55); // The {-y} placeholder requires a tile grid with extent
            var y = range.getHeight() + tileCoord[2];
            return y.toString();
          });
      }
    }
  );
}


/**
 * @param {Array<string>} templates Templates.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */
function createFromTemplates(templates, tileGrid) {
  var len = templates.length;
  var tileUrlFunctions = new Array(len);
  for (var i = 0; i < len; ++i) {
    tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);
  }
  return createFromTileUrlFunctions(tileUrlFunctions);
}


/**
 * @param {Array<import("./Tile.js").UrlFunction>} tileUrlFunctions Tile URL Functions.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */
function createFromTileUrlFunctions(tileUrlFunctions) {
  if (tileUrlFunctions.length === 1) {
    return tileUrlFunctions[0];
  }
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return undefined;
      } else {
        var h = Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_2__["hash"])(tileCoord);
        var index = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["modulo"])(h, tileUrlFunctions.length);
        return tileUrlFunctions[index](tileCoord, pixelRatio, projection);
      }
    }
  );
}


/**
 * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @param {number} pixelRatio Pixel ratio.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {string|undefined} Tile URL.
 */
function nullTileUrlFunction(tileCoord, pixelRatio, projection) {
  return undefined;
}


/**
 * @param {string} url URL.
 * @return {Array<string>} Array of urls.
 */
function expandUrl(url) {
  var urls = [];
  var match = /\{([a-z])-([a-z])\}/.exec(url);
  if (match) {
    // char range
    var startCharCode = match[1].charCodeAt(0);
    var stopCharCode = match[2].charCodeAt(0);
    var charCode;
    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
      urls.push(url.replace(match[0], String.fromCharCode(charCode)));
    }
    return urls;
  }
  match = match = /\{(\d+)-(\d+)\}/.exec(url);
  if (match) {
    // number range
    var stop = parseInt(match[2], 10);
    for (var i = parseInt(match[1], 10); i <= stop; i++) {
      urls.push(url.replace(match[0], i.toString()));
    }
    return urls;
  }
  urls.push(url);
  return urls;
}

//# sourceMappingURL=tileurlfunction.js.map

/***/ }),

/***/ "./node_modules/ol/transform.js":
/*!**************************************!*\
  !*** ./node_modules/ol/transform.js ***!
  \**************************************/
/*! exports provided: create, reset, multiply, set, setFromArray, apply, rotate, scale, translate, compose, invert, determinant */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reset", function() { return reset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setFromArray", function() { return setFromArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "apply", function() { return apply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compose", function() { return compose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/**
 * @module ol/transform
 */



/**
 * An array representing an affine 2d transformation for use with
 * {@link module:ol/transform} functions. The array has 6 elements.
 * @typedef {!Array<number>} Transform
 */


/**
 * Collection of affine 2d transformation functions. The functions work on an
 * array of 6 elements. The element order is compatible with the [SVGMatrix
 * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is
 * a subset (elements a to f) of a 3×3 matrix:
 * ```
 * [ a c e ]
 * [ b d f ]
 * [ 0 0 1 ]
 * ```
 */


/**
 * @private
 * @type {Transform}
 */
var tmp_ = new Array(6);


/**
 * Create an identity transform.
 * @return {!Transform} Identity transform.
 */
function create() {
  return [1, 0, 0, 1, 0, 0];
}


/**
 * Resets the given transform to an identity transform.
 * @param {!Transform} transform Transform.
 * @return {!Transform} Transform.
 */
function reset(transform) {
  return set(transform, 1, 0, 0, 1, 0, 0);
}


/**
 * Multiply the underlying matrices of two transforms and return the result in
 * the first transform.
 * @param {!Transform} transform1 Transform parameters of matrix 1.
 * @param {!Transform} transform2 Transform parameters of matrix 2.
 * @return {!Transform} transform1 multiplied with transform2.
 */
function multiply(transform1, transform2) {
  var a1 = transform1[0];
  var b1 = transform1[1];
  var c1 = transform1[2];
  var d1 = transform1[3];
  var e1 = transform1[4];
  var f1 = transform1[5];
  var a2 = transform2[0];
  var b2 = transform2[1];
  var c2 = transform2[2];
  var d2 = transform2[3];
  var e2 = transform2[4];
  var f2 = transform2[5];

  transform1[0] = a1 * a2 + c1 * b2;
  transform1[1] = b1 * a2 + d1 * b2;
  transform1[2] = a1 * c2 + c1 * d2;
  transform1[3] = b1 * c2 + d1 * d2;
  transform1[4] = a1 * e2 + c1 * f2 + e1;
  transform1[5] = b1 * e2 + d1 * f2 + f1;

  return transform1;
}

/**
 * Set the transform components a-f on a given transform.
 * @param {!Transform} transform Transform.
 * @param {number} a The a component of the transform.
 * @param {number} b The b component of the transform.
 * @param {number} c The c component of the transform.
 * @param {number} d The d component of the transform.
 * @param {number} e The e component of the transform.
 * @param {number} f The f component of the transform.
 * @return {!Transform} Matrix with transform applied.
 */
function set(transform, a, b, c, d, e, f) {
  transform[0] = a;
  transform[1] = b;
  transform[2] = c;
  transform[3] = d;
  transform[4] = e;
  transform[5] = f;
  return transform;
}


/**
 * Set transform on one matrix from another matrix.
 * @param {!Transform} transform1 Matrix to set transform to.
 * @param {!Transform} transform2 Matrix to set transform from.
 * @return {!Transform} transform1 with transform from transform2 applied.
 */
function setFromArray(transform1, transform2) {
  transform1[0] = transform2[0];
  transform1[1] = transform2[1];
  transform1[2] = transform2[2];
  transform1[3] = transform2[3];
  transform1[4] = transform2[4];
  transform1[5] = transform2[5];
  return transform1;
}


/**
 * Transforms the given coordinate with the given transform returning the
 * resulting, transformed coordinate. The coordinate will be modified in-place.
 *
 * @param {Transform} transform The transformation.
 * @param {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} coordinate The coordinate to transform.
 * @return {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} return coordinate so that operations can be
 *     chained together.
 */
function apply(transform, coordinate) {
  var x = coordinate[0];
  var y = coordinate[1];
  coordinate[0] = transform[0] * x + transform[2] * y + transform[4];
  coordinate[1] = transform[1] * x + transform[3] * y + transform[5];
  return coordinate;
}


/**
 * Applies rotation to the given transform.
 * @param {!Transform} transform Transform.
 * @param {number} angle Angle in radians.
 * @return {!Transform} The rotated transform.
 */
function rotate(transform, angle) {
  var cos = Math.cos(angle);
  var sin = Math.sin(angle);
  return multiply(transform, set(tmp_, cos, sin, -sin, cos, 0, 0));
}


/**
 * Applies scale to a given transform.
 * @param {!Transform} transform Transform.
 * @param {number} x Scale factor x.
 * @param {number} y Scale factor y.
 * @return {!Transform} The scaled transform.
 */
function scale(transform, x, y) {
  return multiply(transform, set(tmp_, x, 0, 0, y, 0, 0));
}


/**
 * Applies translation to the given transform.
 * @param {!Transform} transform Transform.
 * @param {number} dx Translation x.
 * @param {number} dy Translation y.
 * @return {!Transform} The translated transform.
 */
function translate(transform, dx, dy) {
  return multiply(transform, set(tmp_, 1, 0, 0, 1, dx, dy));
}


/**
 * Creates a composite transform given an initial translation, scale, rotation, and
 * final translation (in that order only, not commutative).
 * @param {!Transform} transform The transform (will be modified in place).
 * @param {number} dx1 Initial translation x.
 * @param {number} dy1 Initial translation y.
 * @param {number} sx Scale factor x.
 * @param {number} sy Scale factor y.
 * @param {number} angle Rotation (in counter-clockwise radians).
 * @param {number} dx2 Final translation x.
 * @param {number} dy2 Final translation y.
 * @return {!Transform} The composite transform.
 */
function compose(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {
  var sin = Math.sin(angle);
  var cos = Math.cos(angle);
  transform[0] = sx * cos;
  transform[1] = sy * sin;
  transform[2] = -sx * sin;
  transform[3] = sy * cos;
  transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
  transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
  return transform;
}


/**
 * Invert the given transform.
 * @param {!Transform} transform Transform.
 * @return {!Transform} Inverse of the transform.
 */
function invert(transform) {
  var det = determinant(transform);
  Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(det !== 0, 32); // Transformation matrix cannot be inverted

  var a = transform[0];
  var b = transform[1];
  var c = transform[2];
  var d = transform[3];
  var e = transform[4];
  var f = transform[5];

  transform[0] = d / det;
  transform[1] = -b / det;
  transform[2] = -c / det;
  transform[3] = a / det;
  transform[4] = (c * f - d * e) / det;
  transform[5] = -(a * f - b * e) / det;

  return transform;
}


/**
 * Returns the determinant of the given matrix.
 * @param {!Transform} mat Matrix.
 * @return {number} Determinant.
 */
function determinant(mat) {
  return mat[0] * mat[3] - mat[1] * mat[2];
}

//# sourceMappingURL=transform.js.map

/***/ }),

/***/ "./node_modules/ol/util.js":
/*!*********************************!*\
  !*** ./node_modules/ol/util.js ***!
  \*********************************/
/*! exports provided: abstract, inherits, getUid, VERSION */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "abstract", function() { return abstract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inherits", function() { return inherits; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getUid", function() { return getUid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return VERSION; });
/**
 * @module ol/util
 */

/**
 * @return {?} Any return.
 */
function abstract() {
  return /** @type {?} */ ((function() {
    throw new Error('Unimplemented abstract method.');
  })());
}

/**
 * Inherit the prototype methods from one constructor into another.
 *
 * Usage:
 *
 *     function ParentClass(a, b) { }
 *     ParentClass.prototype.foo = function(a) { }
 *
 *     function ChildClass(a, b, c) {
 *       // Call parent constructor
 *       ParentClass.call(this, a, b);
 *     }
 *     inherits(ChildClass, ParentClass);
 *
 *     var child = new ChildClass('a', 'b', 'see');
 *     child.foo(); // This works.
 *
 * @param {!Function} childCtor Child constructor.
 * @param {!Function} parentCtor Parent constructor.
 * @function module:ol.inherits
 * @deprecated
 * @api
 */
function inherits(childCtor, parentCtor) {
  childCtor.prototype = Object.create(parentCtor.prototype);
  childCtor.prototype.constructor = childCtor;
}

/**
 * Counter for getUid.
 * @type {number}
 * @private
 */
var uidCounter_ = 0;

/**
 * Gets a unique ID for an object. This mutates the object so that further calls
 * with the same object as a parameter returns the same value. Unique IDs are generated
 * as a strictly increasing sequence. Adapted from goog.getUid.
 *
 * @param {Object} obj The object to get the unique ID for.
 * @return {string} The unique ID for the object.
 * @function module:ol.getUid
 * @api
 */
function getUid(obj) {
  return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));
}

/**
 * OpenLayers version.
 * @type {string}
 */
var VERSION = '5.3.3';

//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/ol/webgl.js":
/*!**********************************!*\
  !*** ./node_modules/ol/webgl.js ***!
  \**********************************/
/*! exports provided: ONE, SRC_ALPHA, COLOR_ATTACHMENT0, COLOR_BUFFER_BIT, TRIANGLES, TRIANGLE_STRIP, ONE_MINUS_SRC_ALPHA, ARRAY_BUFFER, ELEMENT_ARRAY_BUFFER, STREAM_DRAW, STATIC_DRAW, DYNAMIC_DRAW, CULL_FACE, BLEND, STENCIL_TEST, DEPTH_TEST, SCISSOR_TEST, UNSIGNED_BYTE, UNSIGNED_SHORT, UNSIGNED_INT, FLOAT, RGBA, FRAGMENT_SHADER, VERTEX_SHADER, LINK_STATUS, LINEAR, TEXTURE_MAG_FILTER, TEXTURE_MIN_FILTER, TEXTURE_WRAP_S, TEXTURE_WRAP_T, TEXTURE_2D, TEXTURE0, CLAMP_TO_EDGE, COMPILE_STATUS, FRAMEBUFFER, getContext, DEBUG, HAS, MAX_TEXTURE_SIZE, EXTENSIONS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ONE", function() { return ONE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRC_ALPHA", function() { return SRC_ALPHA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COLOR_ATTACHMENT0", function() { return COLOR_ATTACHMENT0; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COLOR_BUFFER_BIT", function() { return COLOR_BUFFER_BIT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TRIANGLES", function() { return TRIANGLES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TRIANGLE_STRIP", function() { return TRIANGLE_STRIP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ONE_MINUS_SRC_ALPHA", function() { return ONE_MINUS_SRC_ALPHA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ARRAY_BUFFER", function() { return ARRAY_BUFFER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ELEMENT_ARRAY_BUFFER", function() { return ELEMENT_ARRAY_BUFFER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STREAM_DRAW", function() { return STREAM_DRAW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STATIC_DRAW", function() { return STATIC_DRAW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DYNAMIC_DRAW", function() { return DYNAMIC_DRAW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CULL_FACE", function() { return CULL_FACE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BLEND", function() { return BLEND; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STENCIL_TEST", function() { return STENCIL_TEST; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEPTH_TEST", function() { return DEPTH_TEST; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SCISSOR_TEST", function() { return SCISSOR_TEST; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNSIGNED_BYTE", function() { return UNSIGNED_BYTE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNSIGNED_SHORT", function() { return UNSIGNED_SHORT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNSIGNED_INT", function() { return UNSIGNED_INT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FLOAT", function() { return FLOAT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA", function() { return RGBA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FRAGMENT_SHADER", function() { return FRAGMENT_SHADER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERTEX_SHADER", function() { return VERTEX_SHADER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LINK_STATUS", function() { return LINK_STATUS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LINEAR", function() { return LINEAR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXTURE_MAG_FILTER", function() { return TEXTURE_MAG_FILTER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXTURE_MIN_FILTER", function() { return TEXTURE_MIN_FILTER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXTURE_WRAP_S", function() { return TEXTURE_WRAP_S; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXTURE_WRAP_T", function() { return TEXTURE_WRAP_T; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXTURE_2D", function() { return TEXTURE_2D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXTURE0", function() { return TEXTURE0; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLAMP_TO_EDGE", function() { return CLAMP_TO_EDGE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COMPILE_STATUS", function() { return COMPILE_STATUS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FRAMEBUFFER", function() { return FRAMEBUFFER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getContext", function() { return getContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEBUG", function() { return DEBUG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HAS", function() { return HAS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAX_TEXTURE_SIZE", function() { return MAX_TEXTURE_SIZE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EXTENSIONS", function() { return EXTENSIONS; });
/**
 * @module ol/webgl
 */


/**
 * Constants taken from goog.webgl
 */


/**
 * @const
 * @type {number}
 */
var ONE = 1;


/**
 * @const
 * @type {number}
 */
var SRC_ALPHA = 0x0302;


/**
 * @const
 * @type {number}
 */
var COLOR_ATTACHMENT0 = 0x8CE0;


/**
 * @const
 * @type {number}
 */
var COLOR_BUFFER_BIT = 0x00004000;


/**
 * @const
 * @type {number}
 */
var TRIANGLES = 0x0004;


/**
 * @const
 * @type {number}
 */
var TRIANGLE_STRIP = 0x0005;


/**
 * @const
 * @type {number}
 */
var ONE_MINUS_SRC_ALPHA = 0x0303;


/**
 * @const
 * @type {number}
 */
var ARRAY_BUFFER = 0x8892;


/**
 * @const
 * @type {number}
 */
var ELEMENT_ARRAY_BUFFER = 0x8893;


/**
 * @const
 * @type {number}
 */
var STREAM_DRAW = 0x88E0;


/**
 * @const
 * @type {number}
 */
var STATIC_DRAW = 0x88E4;


/**
 * @const
 * @type {number}
 */
var DYNAMIC_DRAW = 0x88E8;


/**
 * @const
 * @type {number}
 */
var CULL_FACE = 0x0B44;


/**
 * @const
 * @type {number}
 */
var BLEND = 0x0BE2;


/**
 * @const
 * @type {number}
 */
var STENCIL_TEST = 0x0B90;


/**
 * @const
 * @type {number}
 */
var DEPTH_TEST = 0x0B71;


/**
 * @const
 * @type {number}
 */
var SCISSOR_TEST = 0x0C11;


/**
 * @const
 * @type {number}
 */
var UNSIGNED_BYTE = 0x1401;


/**
 * @const
 * @type {number}
 */
var UNSIGNED_SHORT = 0x1403;


/**
 * @const
 * @type {number}
 */
var UNSIGNED_INT = 0x1405;


/**
 * @const
 * @type {number}
 */
var FLOAT = 0x1406;


/**
 * @const
 * @type {number}
 */
var RGBA = 0x1908;


/**
 * @const
 * @type {number}
 */
var FRAGMENT_SHADER = 0x8B30;


/**
 * @const
 * @type {number}
 */
var VERTEX_SHADER = 0x8B31;


/**
 * @const
 * @type {number}
 */
var LINK_STATUS = 0x8B82;


/**
 * @const
 * @type {number}
 */
var LINEAR = 0x2601;


/**
 * @const
 * @type {number}
 */
var TEXTURE_MAG_FILTER = 0x2800;


/**
 * @const
 * @type {number}
 */
var TEXTURE_MIN_FILTER = 0x2801;


/**
 * @const
 * @type {number}
 */
var TEXTURE_WRAP_S = 0x2802;


/**
 * @const
 * @type {number}
 */
var TEXTURE_WRAP_T = 0x2803;


/**
 * @const
 * @type {number}
 */
var TEXTURE_2D = 0x0DE1;


/**
 * @const
 * @type {number}
 */
var TEXTURE0 = 0x84C0;


/**
 * @const
 * @type {number}
 */
var CLAMP_TO_EDGE = 0x812F;


/**
 * @const
 * @type {number}
 */
var COMPILE_STATUS = 0x8B81;


/**
 * @const
 * @type {number}
 */
var FRAMEBUFFER = 0x8D40;


/** end of goog.webgl constants
 */


/**
 * @const
 * @type {Array<string>}
 */
var CONTEXT_IDS = [
  'experimental-webgl',
  'webgl',
  'webkit-3d',
  'moz-webgl'
];


/**
 * @param {HTMLCanvasElement} canvas Canvas.
 * @param {Object=} opt_attributes Attributes.
 * @return {WebGLRenderingContext} WebGL rendering context.
 */
function getContext(canvas, opt_attributes) {
  var ii = CONTEXT_IDS.length;
  for (var i = 0; i < ii; ++i) {
    try {
      var context = canvas.getContext(CONTEXT_IDS[i], opt_attributes);
      if (context) {
        return /** @type {!WebGLRenderingContext} */ (context);
      }
    } catch (e) {
      // pass
    }
  }
  return null;
}


/**
 * Include debuggable shader sources.  Default is `true`. This should be set to
 * `false` for production builds.
 * @type {boolean}
 */
var DEBUG = true;


/**
 * The maximum supported WebGL texture size in pixels. If WebGL is not
 * supported, the value is set to `undefined`.
 * @type {number|undefined}
 */
var MAX_TEXTURE_SIZE; // value is set below


/**
 * List of supported WebGL extensions.
 * @type {Array<string>}
 */
var EXTENSIONS; // value is set below


/**
 * True if both OpenLayers and browser support WebGL.
 * @type {boolean}
 * @api
 */
var HAS = false;

//TODO Remove side effects
if (typeof window !== 'undefined' && 'WebGLRenderingContext' in window) {
  try {
    var canvas = /** @type {HTMLCanvasElement} */ (document.createElement('canvas'));
    var gl = getContext(canvas, {failIfMajorPerformanceCaveat: true});
    if (gl) {
      HAS = true;
      MAX_TEXTURE_SIZE = /** @type {number} */ (gl.getParameter(gl.MAX_TEXTURE_SIZE));
      EXTENSIONS = gl.getSupportedExtensions();
    }
  } catch (e) {
    // pass
  }
}



//# sourceMappingURL=webgl.js.map

/***/ }),

/***/ "./node_modules/quickselect/quickselect.js":
/*!*************************************************!*\
  !*** ./node_modules/quickselect/quickselect.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

(function (global, factory) {
	 true ? module.exports = factory() :
	undefined;
}(this, (function () { 'use strict';

function quickselect(arr, k, left, right, compare) {
    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);
}

function quickselectStep(arr, k, left, right, compare) {

    while (right > left) {
        if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            quickselectStep(arr, k, newLeft, newRight, compare);
        }

        var t = arr[k];
        var i = left;
        var j = right;

        swap(arr, left, k);
        if (compare(arr[right], t) > 0) swap(arr, left, right);

        while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (compare(arr[i], t) < 0) i++;
            while (compare(arr[j], t) > 0) j--;
        }

        if (compare(arr[left], t) === 0) swap(arr, left, j);
        else {
            j++;
            swap(arr, j, right);
        }

        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
    }
}

function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}

return quickselect;

})));


/***/ }),

/***/ "./node_modules/rbush/index.js":
/*!*************************************!*\
  !*** ./node_modules/rbush/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = rbush;
module.exports.default = rbush;

var quickselect = __webpack_require__(/*! quickselect */ "./node_modules/quickselect/quickselect.js");

function rbush(maxEntries, format) {
    if (!(this instanceof rbush)) return new rbush(maxEntries, format);

    // max entries in a node is 9 by default; min node fill is 40% for best performance
    this._maxEntries = Math.max(4, maxEntries || 9);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

    if (format) {
        this._initFormat(format);
    }

    this.clear();
}

rbush.prototype = {

    all: function () {
        return this._all(this.data, []);
    },

    search: function (bbox) {

        var node = this.data,
            result = [],
            toBBox = this.toBBox;

        if (!intersects(bbox, node)) return result;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf) result.push(child);
                    else if (contains(bbox, childBBox)) this._all(child, result);
                    else nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return result;
    },

    collides: function (bbox) {

        var node = this.data,
            toBBox = this.toBBox;

        if (!intersects(bbox, node)) return false;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf || contains(bbox, childBBox)) return true;
                    nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return false;
    },

    load: function (data) {
        if (!(data && data.length)) return this;

        if (data.length < this._minEntries) {
            for (var i = 0, len = data.length; i < len; i++) {
                this.insert(data[i]);
            }
            return this;
        }

        // recursively build the tree with the given data from scratch using OMT algorithm
        var node = this._build(data.slice(), 0, data.length - 1, 0);

        if (!this.data.children.length) {
            // save as is if tree is empty
            this.data = node;

        } else if (this.data.height === node.height) {
            // split root if trees have the same height
            this._splitRoot(this.data, node);

        } else {
            if (this.data.height < node.height) {
                // swap trees if inserted one is bigger
                var tmpNode = this.data;
                this.data = node;
                node = tmpNode;
            }

            // insert the small tree into the large tree at appropriate level
            this._insert(node, this.data.height - node.height - 1, true);
        }

        return this;
    },

    insert: function (item) {
        if (item) this._insert(item, this.data.height - 1);
        return this;
    },

    clear: function () {
        this.data = createNode([]);
        return this;
    },

    remove: function (item, equalsFn) {
        if (!item) return this;

        var node = this.data,
            bbox = this.toBBox(item),
            path = [],
            indexes = [],
            i, parent, index, goingUp;

        // depth-first iterative tree traversal
        while (node || path.length) {

            if (!node) { // go up
                node = path.pop();
                parent = path[path.length - 1];
                i = indexes.pop();
                goingUp = true;
            }

            if (node.leaf) { // check current node
                index = findItem(item, node.children, equalsFn);

                if (index !== -1) {
                    // item found, remove the item and condense tree upwards
                    node.children.splice(index, 1);
                    path.push(node);
                    this._condense(path);
                    return this;
                }
            }

            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down
                path.push(node);
                indexes.push(i);
                i = 0;
                parent = node;
                node = node.children[0];

            } else if (parent) { // go right
                i++;
                node = parent.children[i];
                goingUp = false;

            } else node = null; // nothing found
        }

        return this;
    },

    toBBox: function (item) { return item; },

    compareMinX: compareNodeMinX,
    compareMinY: compareNodeMinY,

    toJSON: function () { return this.data; },

    fromJSON: function (data) {
        this.data = data;
        return this;
    },

    _all: function (node, result) {
        var nodesToSearch = [];
        while (node) {
            if (node.leaf) result.push.apply(result, node.children);
            else nodesToSearch.push.apply(nodesToSearch, node.children);

            node = nodesToSearch.pop();
        }
        return result;
    },

    _build: function (items, left, right, height) {

        var N = right - left + 1,
            M = this._maxEntries,
            node;

        if (N <= M) {
            // reached leaf level; return leaf
            node = createNode(items.slice(left, right + 1));
            calcBBox(node, this.toBBox);
            return node;
        }

        if (!height) {
            // target height of the bulk-loaded tree
            height = Math.ceil(Math.log(N) / Math.log(M));

            // target number of root entries to maximize storage utilization
            M = Math.ceil(N / Math.pow(M, height - 1));
        }

        node = createNode([]);
        node.leaf = false;
        node.height = height;

        // split the items into M mostly square tiles

        var N2 = Math.ceil(N / M),
            N1 = N2 * Math.ceil(Math.sqrt(M)),
            i, j, right2, right3;

        multiSelect(items, left, right, N1, this.compareMinX);

        for (i = left; i <= right; i += N1) {

            right2 = Math.min(i + N1 - 1, right);

            multiSelect(items, i, right2, N2, this.compareMinY);

            for (j = i; j <= right2; j += N2) {

                right3 = Math.min(j + N2 - 1, right2);

                // pack each entry recursively
                node.children.push(this._build(items, j, right3, height - 1));
            }
        }

        calcBBox(node, this.toBBox);

        return node;
    },

    _chooseSubtree: function (bbox, node, level, path) {

        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

        while (true) {
            path.push(node);

            if (node.leaf || path.length - 1 === level) break;

            minArea = minEnlargement = Infinity;

            for (i = 0, len = node.children.length; i < len; i++) {
                child = node.children[i];
                area = bboxArea(child);
                enlargement = enlargedArea(bbox, child) - area;

                // choose entry with the least area enlargement
                if (enlargement < minEnlargement) {
                    minEnlargement = enlargement;
                    minArea = area < minArea ? area : minArea;
                    targetNode = child;

                } else if (enlargement === minEnlargement) {
                    // otherwise choose one with the smallest area
                    if (area < minArea) {
                        minArea = area;
                        targetNode = child;
                    }
                }
            }

            node = targetNode || node.children[0];
        }

        return node;
    },

    _insert: function (item, level, isNode) {

        var toBBox = this.toBBox,
            bbox = isNode ? item : toBBox(item),
            insertPath = [];

        // find the best node for accommodating the item, saving all nodes along the path too
        var node = this._chooseSubtree(bbox, this.data, level, insertPath);

        // put the item into the node
        node.children.push(item);
        extend(node, bbox);

        // split on node overflow; propagate upwards if necessary
        while (level >= 0) {
            if (insertPath[level].children.length > this._maxEntries) {
                this._split(insertPath, level);
                level--;
            } else break;
        }

        // adjust bboxes along the insertion path
        this._adjustParentBBoxes(bbox, insertPath, level);
    },

    // split overflowed node into two
    _split: function (insertPath, level) {

        var node = insertPath[level],
            M = node.children.length,
            m = this._minEntries;

        this._chooseSplitAxis(node, m, M);

        var splitIndex = this._chooseSplitIndex(node, m, M);

        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;

        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);

        if (level) insertPath[level - 1].children.push(newNode);
        else this._splitRoot(node, newNode);
    },

    _splitRoot: function (node, newNode) {
        // split root node
        this.data = createNode([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
    },

    _chooseSplitIndex: function (node, m, M) {

        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;

        minOverlap = minArea = Infinity;

        for (i = m; i <= M - m; i++) {
            bbox1 = distBBox(node, 0, i, this.toBBox);
            bbox2 = distBBox(node, i, M, this.toBBox);

            overlap = intersectionArea(bbox1, bbox2);
            area = bboxArea(bbox1) + bboxArea(bbox2);

            // choose distribution with minimum overlap
            if (overlap < minOverlap) {
                minOverlap = overlap;
                index = i;

                minArea = area < minArea ? area : minArea;

            } else if (overlap === minOverlap) {
                // otherwise choose distribution with minimum area
                if (area < minArea) {
                    minArea = area;
                    index = i;
                }
            }
        }

        return index;
    },

    // sorts node children by the best axis for split
    _chooseSplitAxis: function (node, m, M) {

        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
            xMargin = this._allDistMargin(node, m, M, compareMinX),
            yMargin = this._allDistMargin(node, m, M, compareMinY);

        // if total distributions margin value is minimal for x, sort by minX,
        // otherwise it's already sorted by minY
        if (xMargin < yMargin) node.children.sort(compareMinX);
    },

    // total margin of all possible split distributions where each node is at least m full
    _allDistMargin: function (node, m, M, compare) {

        node.children.sort(compare);

        var toBBox = this.toBBox,
            leftBBox = distBBox(node, 0, m, toBBox),
            rightBBox = distBBox(node, M - m, M, toBBox),
            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
            i, child;

        for (i = m; i < M - m; i++) {
            child = node.children[i];
            extend(leftBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(leftBBox);
        }

        for (i = M - m - 1; i >= m; i--) {
            child = node.children[i];
            extend(rightBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(rightBBox);
        }

        return margin;
    },

    _adjustParentBBoxes: function (bbox, path, level) {
        // adjust bboxes along the given tree path
        for (var i = level; i >= 0; i--) {
            extend(path[i], bbox);
        }
    },

    _condense: function (path) {
        // go through the path, removing empty nodes and updating bboxes
        for (var i = path.length - 1, siblings; i >= 0; i--) {
            if (path[i].children.length === 0) {
                if (i > 0) {
                    siblings = path[i - 1].children;
                    siblings.splice(siblings.indexOf(path[i]), 1);

                } else this.clear();

            } else calcBBox(path[i], this.toBBox);
        }
    },

    _initFormat: function (format) {
        // data format (minX, minY, maxX, maxY accessors)

        // uses eval-type function compilation instead of just accepting a toBBox function
        // because the algorithms are very sensitive to sorting functions performance,
        // so they should be dead simple and without inner calls

        var compareArr = ['return a', ' - b', ';'];

        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));

        this.toBBox = new Function('a',
            'return {minX: a' + format[0] +
            ', minY: a' + format[1] +
            ', maxX: a' + format[2] +
            ', maxY: a' + format[3] + '};');
    }
};

function findItem(item, items, equalsFn) {
    if (!equalsFn) return items.indexOf(item);

    for (var i = 0; i < items.length; i++) {
        if (equalsFn(item, items[i])) return i;
    }
    return -1;
}

// calculate node's bbox from bboxes of its children
function calcBBox(node, toBBox) {
    distBBox(node, 0, node.children.length, toBBox, node);
}

// min bounding rectangle of node children from k to p-1
function distBBox(node, k, p, toBBox, destNode) {
    if (!destNode) destNode = createNode(null);
    destNode.minX = Infinity;
    destNode.minY = Infinity;
    destNode.maxX = -Infinity;
    destNode.maxY = -Infinity;

    for (var i = k, child; i < p; i++) {
        child = node.children[i];
        extend(destNode, node.leaf ? toBBox(child) : child);
    }

    return destNode;
}

function extend(a, b) {
    a.minX = Math.min(a.minX, b.minX);
    a.minY = Math.min(a.minY, b.minY);
    a.maxX = Math.max(a.maxX, b.maxX);
    a.maxY = Math.max(a.maxY, b.maxY);
    return a;
}

function compareNodeMinX(a, b) { return a.minX - b.minX; }
function compareNodeMinY(a, b) { return a.minY - b.minY; }

function bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }
function bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }

function enlargedArea(a, b) {
    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
}

function intersectionArea(a, b) {
    var minX = Math.max(a.minX, b.minX),
        minY = Math.max(a.minY, b.minY),
        maxX = Math.min(a.maxX, b.maxX),
        maxY = Math.min(a.maxY, b.maxY);

    return Math.max(0, maxX - minX) *
           Math.max(0, maxY - minY);
}

function contains(a, b) {
    return a.minX <= b.minX &&
           a.minY <= b.minY &&
           b.maxX <= a.maxX &&
           b.maxY <= a.maxY;
}

function intersects(a, b) {
    return b.minX <= a.maxX &&
           b.minY <= a.maxY &&
           b.maxX >= a.minX &&
           b.maxY >= a.minY;
}

function createNode(children) {
    return {
        children: children,
        height: 1,
        leaf: true,
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity
    };
}

// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
// combines selection algorithm with binary divide & conquer approach

function multiSelect(arr, left, right, n, compare) {
    var stack = [left, right],
        mid;

    while (stack.length) {
        right = stack.pop();
        left = stack.pop();

        if (right - left <= n) continue;

        mid = left + Math.ceil((right - left) / n / 2) * n;
        quickselect(arr, mid, left, right, compare);

        stack.push(left, mid, mid, right);
    }
}


/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target, parent) {
  if (parent){
    return parent.querySelector(target);
  }
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target, parent) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target, parent);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "./node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertAt.before, target);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	if(options.attrs.nonce === undefined) {
		var nonce = getNonce();
		if (nonce) {
			options.attrs.nonce = nonce;
		}
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function getNonce() {
	if (false) {}

	return __webpack_require__.nc;
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = typeof options.transform === 'function'
		 ? options.transform(obj.css) 
		 : options.transform.default(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),

/***/ "./src/components/LizmapBaseLayersElement.js":
/*!***************************************************!*\
  !*** ./src/components/LizmapBaseLayersElement.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LizmapBaseLayersElement; });
/* harmony import */ var _modules_LizmapGlobals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/LizmapGlobals */ "./src/modules/LizmapGlobals.js");



class LizmapBaseLayersElement extends HTMLElement {
    constructor() {
        super();

        const shadowRoot = this.attachShadow({ mode: 'open' });
        this._select = document.createElement('select');
        shadowRoot.appendChild(this._select);

        this._select.addEventListener('change', (event) => {
            _modules_LizmapGlobals__WEBPACK_IMPORTED_MODULE_0__["LizmapMapManager"].getMap(this.mapId).baseLayerGroup.layerVisible = event.target.value;
        });
        this._layers = [];
        this._mapId = '';
    }

    get mapId () {
        return this._mapId;
    }

    connectedCallback() {
        this._mapId = this.getAttribute('map-id');
        _modules_LizmapGlobals__WEBPACK_IMPORTED_MODULE_0__["MainEventDispatcher"].addListener(this.onLoadedBaseLayers.bind(this),
            { type: 'map-base-layers-loaded', mapId : this.mapId});
    }

    disconnectedCallback() {
        _modules_LizmapGlobals__WEBPACK_IMPORTED_MODULE_0__["MainEventDispatcher"].removeListener(this.onLoadedBaseLayers.bind(this),
            { type: 'map-base-layers-loaded', mapId : this.mapId});

    }

    onLoadedBaseLayers(event) {
        this._layers = event.baseLayerGroup.layers;
        this.render();
    }

    render() {
        this._select.textContent = '';
        this._layers.forEach((layer) => {
            let newNode = document.createElement('option');
            newNode.setAttribute('value', layer.layerId);
            if (layer.visible) {
                newNode.setAttribute('selected', 'selected');
            }
            newNode.innerText = layer.layerName;

            this._select.appendChild(newNode);
        });
    }
}



/***/ }),

/***/ "./src/components/LizmapMapElement.js":
/*!********************************************!*\
  !*** ./src/components/LizmapMapElement.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LizmapMapElement; });
/* harmony import */ var ol_ol_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ol/ol.css */ "./node_modules/ol/ol.css");
/* harmony import */ var ol_ol_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ol_ol_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ol_Map_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ol/Map.js */ "./node_modules/ol/Map.js");
/* harmony import */ var ol_View_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ol/View.js */ "./node_modules/ol/View.js");
/* harmony import */ var ol_layer_Group__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ol/layer/Group */ "./node_modules/ol/layer/Group.js");
/* harmony import */ var ol_layer_Tile_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ol/layer/Tile.js */ "./node_modules/ol/layer/Tile.js");
/* harmony import */ var ol_source_OSM_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ol/source/OSM.js */ "./node_modules/ol/source/OSM.js");
/* harmony import */ var ol_source_Stamen__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ol/source/Stamen */ "./node_modules/ol/source/Stamen.js");
/* harmony import */ var _modules_LizmapGlobals__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../modules/LizmapGlobals */ "./src/modules/LizmapGlobals.js");


// OLMap and not Map to avoid collision with global object Map









class LizmapMapElement extends HTMLElement {
    constructor() {
        super();

        this._OLMap = null;
        this._OLlayerGroup = null;
        this._mapId = '';
    }

    get mapId() {
        return this._mapId;
    }

    connectedCallback() {
        this._mapId = this.getAttribute('map-id');

        _modules_LizmapGlobals__WEBPACK_IMPORTED_MODULE_7__["MainEventDispatcher"].addListener(this.onLoadedMapConfig.bind(this),
            { type: 'map-config-loaded', mapId: this.mapId });

        _modules_LizmapGlobals__WEBPACK_IMPORTED_MODULE_7__["MainEventDispatcher"].addListener(this.onLoadedBaseLayers.bind(this),
            { type: 'map-base-layers-loaded', mapId: this.mapId });

        _modules_LizmapGlobals__WEBPACK_IMPORTED_MODULE_7__["MainEventDispatcher"].addListener(this.onBaseLayerVisibility.bind(this),
            { type: 'map-base-layers-visibility', mapId: this.mapId });

        _modules_LizmapGlobals__WEBPACK_IMPORTED_MODULE_7__["MainEventDispatcher"].addListener(this.onZoomSet.bind(this),
            { type: 'map-zoom-set', mapId: this.mapId });
    }

    disconnectedCallback() {
        _modules_LizmapGlobals__WEBPACK_IMPORTED_MODULE_7__["MainEventDispatcher"].removeListener(this.onLoadedMapConfig.bind(this),
            { type: 'map-config-loaded', mapId: this.mapId });

        _modules_LizmapGlobals__WEBPACK_IMPORTED_MODULE_7__["MainEventDispatcher"].removeListener(this.onLoadedBaseLayers.bind(this),
            { type: 'map-base-layers-loaded', mapId: this.mapId });

        _modules_LizmapGlobals__WEBPACK_IMPORTED_MODULE_7__["MainEventDispatcher"].removeListener(this.onBaseLayerVisibility.bind(this),
            { type: 'map-base-layers-visibility', mapId: this.mapId });

        _modules_LizmapGlobals__WEBPACK_IMPORTED_MODULE_7__["MainEventDispatcher"].removeListener(this.onZoomSet.bind(this),
            { type: 'map-zoom-set', mapId: this.mapId });

    }

    onLoadedMapConfig(event) {
        this._mapId = event.mapId;

        this._OLMap = new ol_Map_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
            target: this,
            view: new ol_View_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
                center: [0, 0],
                zoom: this._zoom
            })
        });

        this._OLMap.getView().fit(event.config.options.initialExtent);

    }

    onLoadedBaseLayers(event) {
        let OLLayers = event.baseLayerGroup.layers.map((layer) => {
            let olLayer;
            if (layer.layerId === 'osmMapnik') {
                olLayer = new ol_layer_Tile_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
                    layerId: layer.layerId,
                    visible: layer.visible,
                    source: new ol_source_OSM_js__WEBPACK_IMPORTED_MODULE_5__["default"]()
                })
            } else if (layer.layerId === 'osmStamenToner') {
                olLayer = new ol_layer_Tile_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
                    layerId: layer.layerId,
                    visible: layer.visible,
                    source: new ol_source_Stamen__WEBPACK_IMPORTED_MODULE_6__["default"]({
                        layer: 'toner'
                    })
                });
            }
            return olLayer;
        });

        this._OLlayerGroup = new ol_layer_Group__WEBPACK_IMPORTED_MODULE_3__["default"]({
            layers: OLLayers
        });

        this._OLMap.addLayer(this._OLlayerGroup);
    }

    onBaseLayerVisibility(event) {
        let olLayers = this._OLlayerGroup.getLayers();
        event.layers.forEach((lzmLayer, idx) => {
            olLayers.item(idx).setVisible(lzmLayer.visible);
        });
    }

    onZoomSet(event) {
        this._OLMap.getView().setZoom(event.zoom);
    }
}


/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return main; });
/* harmony import */ var _components_LizmapMapElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/LizmapMapElement.js */ "./src/components/LizmapMapElement.js");
/* harmony import */ var _components_LizmapBaseLayersElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/LizmapBaseLayersElement.js */ "./src/components/LizmapBaseLayersElement.js");
/* harmony import */ var _modules_LizmapGlobals__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/LizmapGlobals */ "./src/modules/LizmapGlobals.js");





window.customElements.define('lizmap-map', _components_LizmapMapElement_js__WEBPACK_IMPORTED_MODULE_0__["default"]);
window.customElements.define('lizmap-baselayers', _components_LizmapBaseLayersElement_js__WEBPACK_IMPORTED_MODULE_1__["default"]);

window.addEventListener('load', function (event) {

    _modules_LizmapGlobals__WEBPACK_IMPORTED_MODULE_2__["LizmapMapManager"].createMap('mainmap', lizUrls.config, lizUrls.params.repository, lizUrls.params.project);

}, false);

/**
 * Object that export API for external scripts.
 */
const main = {
    manager: _modules_LizmapGlobals__WEBPACK_IMPORTED_MODULE_2__["LizmapMapManager"],
    dispatcher: _modules_LizmapGlobals__WEBPACK_IMPORTED_MODULE_2__["MainEventDispatcher"]
};




/***/ }),

/***/ "./src/modules/LizmapGlobals.js":
/*!**************************************!*\
  !*** ./src/modules/LizmapGlobals.js ***!
  \**************************************/
/*! exports provided: MainEventDispatcher, LizmapMapManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MainEventDispatcher", function() { return MainEventDispatcher; });
/* harmony import */ var _utils_EventDispatcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/EventDispatcher.js */ "./src/utils/EventDispatcher.js");
/* harmony import */ var _LizmapMapManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LizmapMapManager */ "./src/modules/LizmapMapManager.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LizmapMapManager", function() { return _LizmapMapManager__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/**
 * Export global objects needed by lizmap components and classes
 * Internal use only
 */




const MainEventDispatcher = new _utils_EventDispatcher_js__WEBPACK_IMPORTED_MODULE_0__["default"]();




/***/ }),

/***/ "./src/modules/LizmapLayer.js":
/*!************************************!*\
  !*** ./src/modules/LizmapLayer.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LizmapLayer; });


class LizmapLayer {
    constructor(layerId, name, visible) {

        this._layerId = layerId;
        this._layerName = name;
        this._visible = visible;
    }

    get layerId() {
        return this._layerId;
    }

    get layerName() {
        return this._layerName;
    }

    get visible() {
        return this._visible;
    }

    set visible(val) {
        this._visible = val;
    }


}

/***/ }),

/***/ "./src/modules/LizmapLayerGroup.js":
/*!*****************************************!*\
  !*** ./src/modules/LizmapLayerGroup.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LizmapLayerGroup; });
/* harmony import */ var _LizmapLayer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LizmapLayer.js */ "./src/modules/LizmapLayer.js");
/* harmony import */ var ol_layer_Group__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ol/layer/Group */ "./node_modules/ol/layer/Group.js");
/* harmony import */ var _LizmapGlobals__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LizmapGlobals */ "./src/modules/LizmapGlobals.js");




// attribut selected
class LizmapLayerGroup {
    /**
     * @param {String} mapId
     * @param {LizmapLayer[]} layers
     * @param {Object} opt_options
     */
    constructor(mapId, layers, opt_options) {
        this._mapId = mapId;
        this._mutuallyExclusive = opt_options.mutuallyExclusive;

        this._lizmapLayers = layers;
    }

    // Make class iterable
    [Symbol.iterator]() {
        let index = -1;

        return {
            next: () => ({ value: this._lizmapLayers[++index], done: !(index in this._lizmapLayers) })
        };
    };

    get layers () {
        return this._lizmapLayers;
    }

    set layerVisible(layerId) {
        for (let i = 0; i < this._lizmapLayers.length; i++) {
            // Set visibility to false when mutually exclusive
            if (this._mutuallyExclusive) {
                this._lizmapLayers[i].visible = false;
            }
            if (this._lizmapLayers[i].layerId === layerId) {
                this._lizmapLayers[i].visible = true;
            }
        }
        _LizmapGlobals__WEBPACK_IMPORTED_MODULE_2__["MainEventDispatcher"].dispatch({
            type: 'map-base-layers-visibility',
            mapId : this._mapId,
            layers : this._lizmapLayers
        })
    }
}

/***/ }),

/***/ "./src/modules/LizmapMap.js":
/*!**********************************!*\
  !*** ./src/modules/LizmapMap.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LizmapMap; });
/* harmony import */ var _LizmapGlobals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LizmapGlobals */ "./src/modules/LizmapGlobals.js");
/* harmony import */ var _LizmapLayerGroup__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LizmapLayerGroup */ "./src/modules/LizmapLayerGroup.js");
/* harmony import */ var _LizmapLayer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LizmapLayer */ "./src/modules/LizmapLayer.js");




class LizmapMap {

    constructor (mapId, repository, project) {
        this._mapId = mapId;
        this._repositoryName = repository;
        this._projectName = project;
    }

    setConfig(config) {
        this._config = config;
        _LizmapGlobals__WEBPACK_IMPORTED_MODULE_0__["MainEventDispatcher"].dispatch({
             type: "map-config-loaded",
             mapId: this._mapId,
             config: this._config
            });

        let baseLayers = [];
        for (let option in config.options) {
            if(option === 'osmMapnik'){
                baseLayers.push(new _LizmapLayer__WEBPACK_IMPORTED_MODULE_2__["default"](option, 'OSM', config.options.startupBaselayer === "osm-mapnik"));
            }
            if(option === 'osmStamenToner'){
                baseLayers.push(new _LizmapLayer__WEBPACK_IMPORTED_MODULE_2__["default"](option, 'OSM Toner', config.options.startupBaselayer === "osm-stamen-toner"));
            }
        }

        this._baseLayerGroup = new _LizmapLayerGroup__WEBPACK_IMPORTED_MODULE_1__["default"](this._mapId, baseLayers, {mutuallyExclusive: true});

        _LizmapGlobals__WEBPACK_IMPORTED_MODULE_0__["MainEventDispatcher"].dispatch({
            type: "map-base-layers-loaded",
            mapId: this._mapId,
            baseLayerGroup: this._baseLayerGroup
        });

    }

    get zoom () {
        return this._zoom;
    }

    get baseLayerGroup () {
        return this._baseLayerGroup;
    }
}

/***/ }),

/***/ "./src/modules/LizmapMapManager.js":
/*!*****************************************!*\
  !*** ./src/modules/LizmapMapManager.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LizmapMapManager; });
/* harmony import */ var _LizmapMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LizmapMap */ "./src/modules/LizmapMap.js");


/**
 *
 * @param {String} repository
 * @param {String} project
 * @returns {Promise}
 */
async function loadMapConfig(configURL, repository, project) {
    // http request to retrieve the "config"
    const config = await fetch(configURL + '?repository=' + repository + '&project=' + project)
        .then((resp) => resp.json());

    return config;
}

const maps = {};

const LizmapMapManager = {

    createMap: async function (mapId, configURL, repository, project) {
        if (mapId in maps) {
            return maps[mapId];
        }

        let config = await loadMapConfig(configURL, repository, project);
        maps[mapId] = new _LizmapMap__WEBPACK_IMPORTED_MODULE_0__["default"](mapId, repository, project);
        maps[mapId].setConfig(config);
        return maps[mapId];
    },

    getMap: function (mapId) {
        if (mapId in maps) {
            return maps[mapId];
        }
    }
};





/***/ }),

/***/ "./src/utils/EventDispatcher.js":
/*!**************************************!*\
  !*** ./src/utils/EventDispatcher.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EventDispatcher; });
/**
 * UI components or any other components can be notified by this object of some
 * application events, in order to update their state or to do something
 *
 * @version 0.1
 * @author Laurent Jouanneau
 * @licence MIT
 * @copyright 3Liz 2019
 */

/**
 * Dispatch some application events to listeners
 */
class EventDispatcher {

    constructor () {
        this._listeners = {};
    }

    /**
     * add a listener that will be called for one or several given events
     *
     * @param {Function} listener
     * @param {Array|String|Object} supportedEvents events on which the listener will
     *                       be called. if undefined or "*", it will be called for any events
     */
    addListener (listener, supportedEvents ) {

        if (supportedEvents === undefined) {
            supportedEvents = "*"
        }
        let append = (event) => {
            if ("string" === typeof event) {
                event = {
                    type: event
                };
            }

            if (!(event.type in this._listeners)) {
                this._listeners[event.type] = [];
            }
            this._listeners[event.type].push([listener, event]);
        };

        if (Array.isArray(supportedEvents)) {
            supportedEvents.forEach((event) => {
                if (event === "*") {
                    return;
                }
                append(event);
            });
        }
        else {
            append(supportedEvents);
        }
    }

    /**
     * remove a listener that is associated for one or several given events
     *
     * @param {Function} listener
     * @param {Array|String} supportedEvents list of events from which the listener
     *                       will be removed. if undefined or "*", it will be removed from any events
     */
    removeListener (listener, supportedEvents) {

        if (supportedEvents === undefined) {
            supportedEvents = "*"
        }
        let remove = (event) => {
            if ("string" === typeof event) {
                event = {
                    type: event
                };
            }
            if (event.type in this._listeners) {
                let properties = Object.getOwnPropertyNames(event);
                this._listeners[event.type] = this._listeners[event.type].filter((item) => {
                    let [listener, expectedEvent] = item;
                    let match = true;
                    properties.forEach((propName) => {
                        if (!match || propName == 'type') {
                            return;
                        }
                        if (!(propName in expectedEvent) || event[propName] != expectedEvent[propName]) {
                            match = false;
                        }
                    });
                    return !match; // remove all events that match the given event
                });
            }
        };

        if (Array.isArray(supportedEvents)) {
            supportedEvents.forEach(remove);
        }
        else if (supportedEvents == "*") {
            Object.getOwnPropertyNames(this._listeners).forEach(remove);
        }
        else {
            remove(supportedEvents);
        }
    }

    /**
     * Call listeners associated with the given event
     *
     * @param {Object|String} event  an event name, or an object with a 'type'
     *                               property having the event name. In this
     *                               case other properties are parameters for
     *                               listeners.
     */
    dispatch (event) {
        if ('string' == typeof event ) {
            event = {
                type: event
            };
        }

        if (event.type == "*") {
            throw Error("Notification for all events is not allowed");
        }

        if (event.type in this._listeners) {
            this._listeners[event.type].forEach((item) => {
                let [listener, expectedEvent] = item;
                let match = true;
                Object.getOwnPropertyNames(expectedEvent).forEach((propName) => {
                    if (!match || propName == 'type') {
                        return;
                    }
                    if (!(propName in event) || event[propName] != expectedEvent[propName]) {
                        match = false;
                    }
                });
                if (match) {
                    listener(event);
                }
            });
        }
        if ("*" in this._listeners) {
            this._listeners["*"].forEach((listener) => listener(event));
        }
    }
};



/***/ })

/******/ })["default"];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9MaXptYXAvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL29sLmNzcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9Bc3NlcnRpb25FcnJvci5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvQ29sbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvQ29sbGVjdGlvbkV2ZW50VHlwZS5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvRGlzcG9zYWJsZS5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvRmVhdHVyZS5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvSW1hZ2VCYXNlLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9JbWFnZUNhbnZhcy5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvSW1hZ2VTdGF0ZS5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvSW1hZ2VUaWxlLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9LaW5ldGljLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9MYXllclR5cGUuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL01hcC5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvTWFwQnJvd3NlckV2ZW50LmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9NYXBCcm93c2VyRXZlbnRIYW5kbGVyLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9NYXBCcm93c2VyRXZlbnRUeXBlLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9NYXBCcm93c2VyUG9pbnRlckV2ZW50LmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9NYXBFdmVudC5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvTWFwRXZlbnRUeXBlLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9NYXBQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvT2JqZWN0LmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9PYmplY3RFdmVudFR5cGUuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL09ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL1BsdWdnYWJsZU1hcC5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvVGlsZS5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvVGlsZUNhY2hlLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9UaWxlUXVldWUuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL1RpbGVSYW5nZS5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvVGlsZVN0YXRlLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9WaWV3LmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9WaWV3SGludC5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvVmlld1Byb3BlcnR5LmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9hcnJheS5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvYXNzZXJ0cy5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvY2VudGVyY29uc3RyYWludC5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvY29sb3IuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL2NvbG9ybGlrZS5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvY29udHJvbC9BdHRyaWJ1dGlvbi5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvY29udHJvbC9Db250cm9sLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9jb250cm9sL1JvdGF0ZS5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvY29udHJvbC9ab29tLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9jb250cm9sL3V0aWwuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL2Nvb3JkaW5hdGUuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL2Nzcy5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvZG9tLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9lYXNpbmcuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvZXZlbnRzL0V2ZW50LmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9ldmVudHMvRXZlbnRUeXBlLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9ldmVudHMvS2V5Q29kZS5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvZXZlbnRzL1RhcmdldC5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvZXZlbnRzL2NvbmRpdGlvbi5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvZXh0ZW50LmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9leHRlbnQvQ29ybmVyLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9leHRlbnQvUmVsYXRpb25zaGlwLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9mZWF0dXJlbG9hZGVyLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9mb3JtYXQvRm9ybWF0VHlwZS5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvZnVuY3Rpb25zLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL0NpcmNsZS5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9HZW9tZXRyeS5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9HZW9tZXRyeUxheW91dC5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9HZW9tZXRyeVR5cGUuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL2dlb20vTGluZVN0cmluZy5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9MaW5lYXJSaW5nLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL011bHRpTGluZVN0cmluZy5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9NdWx0aVBvaW50LmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL011bHRpUG9seWdvbi5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9Qb2ludC5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9Qb2x5Z29uLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvYXJlYS5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L2NlbnRlci5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L2Nsb3Nlc3QuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL2dlb20vZmxhdC9jb250YWlucy5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L2RlZmxhdGUuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL2dlb20vZmxhdC9pbmZsYXRlLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvaW50ZXJpb3Jwb2ludC5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L2ludGVycG9sYXRlLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvaW50ZXJzZWN0c2V4dGVudC5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L2xlbmd0aC5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L29yaWVudC5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L3JldmVyc2UuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL2dlb20vZmxhdC9zZWdtZW50cy5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L3NpbXBsaWZ5LmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvc3RyYWlnaHRjaHVuay5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L3RleHRwYXRoLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvdHJhbnNmb3JtLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9oYXMuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9Eb3VibGVDbGlja1pvb20uanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL0RyYWdBbmREcm9wLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9EcmFnQm94LmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9EcmFnUGFuLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9EcmFnUm90YXRlLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9EcmFnUm90YXRlQW5kWm9vbS5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvaW50ZXJhY3Rpb24vRHJhZ1pvb20uanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL0RyYXcuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL0V4dGVudC5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvaW50ZXJhY3Rpb24vSW50ZXJhY3Rpb24uanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL0tleWJvYXJkUGFuLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9LZXlib2FyZFpvb20uanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL01vZGlmeS5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvaW50ZXJhY3Rpb24vTW91c2VXaGVlbFpvb20uanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL1BpbmNoUm90YXRlLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9QaW5jaFpvb20uanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL1BvaW50ZXIuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL1Byb3BlcnR5LmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9TZWxlY3QuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL1NuYXAuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL1RyYW5zbGF0ZS5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvbGF5ZXIvQmFzZS5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvbGF5ZXIvR3JvdXAuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL2xheWVyL0xheWVyLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9sYXllci9Qcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvbGF5ZXIvVGlsZS5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvbGF5ZXIvVGlsZVByb3BlcnR5LmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9sYXllci9WZWN0b3IuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL2xheWVyL1ZlY3RvclJlbmRlclR5cGUuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL2xheWVyL1ZlY3RvclRpbGVSZW5kZXJUeXBlLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9sb2FkaW5nc3RyYXRlZ3kuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL21hdGguanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL29iai5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvb2wuY3NzPzA1ZmEiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL3BvaW50ZXIvRXZlbnRTb3VyY2UuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL3BvaW50ZXIvRXZlbnRUeXBlLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9wb2ludGVyL01vdXNlU291cmNlLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9wb2ludGVyL01zU291cmNlLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9wb2ludGVyL05hdGl2ZVNvdXJjZS5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvcG9pbnRlci9Qb2ludGVyRXZlbnQuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL3BvaW50ZXIvUG9pbnRlckV2ZW50SGFuZGxlci5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvcG9pbnRlci9Ub3VjaFNvdXJjZS5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvcHJvai5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvcHJvai9Qcm9qZWN0aW9uLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9wcm9qL1VuaXRzLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9wcm9qL2Vwc2czODU3LmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9wcm9qL2Vwc2c0MzI2LmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9wcm9qL3Byb2plY3Rpb25zLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9wcm9qL3RyYW5zZm9ybXMuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9Cb3guanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9FdmVudC5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyL0V2ZW50VHlwZS5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyL1JlcGxheUdyb3VwLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvUmVwbGF5VHlwZS5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyL1ZlY3RvckNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9jYW52YXMuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9jYW52YXMvSW1hZ2VSZXBsYXkuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9jYW52YXMvSW1tZWRpYXRlLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvY2FudmFzL0luc3RydWN0aW9uLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvY2FudmFzL0xpbmVTdHJpbmdSZXBsYXkuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9jYW52YXMvUG9seWdvblJlcGxheS5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyL2NhbnZhcy9SZXBsYXkuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9jYW52YXMvUmVwbGF5R3JvdXAuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9jYW52YXMvVGV4dFJlcGxheS5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyL3JlcGxheS5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyZXIvTGF5ZXIuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL3JlbmRlcmVyL01hcC5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyZXIvY2FudmFzL0ltYWdlTGF5ZXIuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL3JlbmRlcmVyL2NhbnZhcy9JbnRlcm1lZGlhdGVDYW52YXMuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL3JlbmRlcmVyL2NhbnZhcy9MYXllci5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyZXIvY2FudmFzL01hcC5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyZXIvY2FudmFzL1RpbGVMYXllci5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyZXIvY2FudmFzL1ZlY3RvckxheWVyLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXJlci9jYW52YXMvVmVjdG9yVGlsZUxheWVyLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXJlci92ZWN0b3IuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL3JlcHJvai5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvcmVwcm9qL1RpbGUuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL3JlcHJvai9Ucmlhbmd1bGF0aW9uLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9yZXByb2ovY29tbW9uLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9yZXNvbHV0aW9uY29uc3RyYWludC5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvcm90YXRpb25jb25zdHJhaW50LmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9zaXplLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9zb3VyY2UvT1NNLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9zb3VyY2UvU291cmNlLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9zb3VyY2UvU3RhbWVuLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9zb3VyY2UvU3RhdGUuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL3NvdXJjZS9UaWxlLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9zb3VyY2UvVGlsZUV2ZW50VHlwZS5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvc291cmNlL1RpbGVJbWFnZS5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvc291cmNlL1VybFRpbGUuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL3NvdXJjZS9WZWN0b3IuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL3NvdXJjZS9WZWN0b3JFdmVudFR5cGUuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL3NvdXJjZS9YWVouanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL3NwaGVyZS5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvc3RyaW5nLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9zdHJ1Y3RzL0xSVUNhY2hlLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9zdHJ1Y3RzL1ByaW9yaXR5UXVldWUuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL3N0cnVjdHMvUkJ1c2guanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL3N0eWxlL0NpcmNsZS5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvc3R5bGUvRmlsbC5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvc3R5bGUvSWNvbkltYWdlQ2FjaGUuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL3N0eWxlL0ltYWdlLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC9zdHlsZS9SZWd1bGFyU2hhcGUuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL3N0eWxlL1N0cm9rZS5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvc3R5bGUvU3R5bGUuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL3N0eWxlL1RleHRQbGFjZW1lbnQuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL3RpbGVjb29yZC5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvdGlsZWdyaWQuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL3RpbGVncmlkL1RpbGVHcmlkLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC90aWxlZ3JpZC9jb21tb24uanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL29sL3RpbGV1cmxmdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvb2wvdHJhbnNmb3JtLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC91dGlsLmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9vbC93ZWJnbC5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvcXVpY2tzZWxlY3QvcXVpY2tzZWxlY3QuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vbm9kZV9tb2R1bGVzL3JidXNoL2luZGV4LmpzIiwid2VicGFjazovL0xpem1hcC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzIiwid2VicGFjazovL0xpem1hcC8uL3NyYy9jb21wb25lbnRzL0xpem1hcEJhc2VMYXllcnNFbGVtZW50LmpzIiwid2VicGFjazovL0xpem1hcC8uL3NyYy9jb21wb25lbnRzL0xpem1hcE1hcEVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vc3JjL2luZGV4LmpzIiwid2VicGFjazovL0xpem1hcC8uL3NyYy9tb2R1bGVzL0xpem1hcEdsb2JhbHMuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vc3JjL21vZHVsZXMvTGl6bWFwTGF5ZXIuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vc3JjL21vZHVsZXMvTGl6bWFwTGF5ZXJHcm91cC5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9zcmMvbW9kdWxlcy9MaXptYXBNYXAuanMiLCJ3ZWJwYWNrOi8vTGl6bWFwLy4vc3JjL21vZHVsZXMvTGl6bWFwTWFwTWFuYWdlci5qcyIsIndlYnBhY2s6Ly9MaXptYXAvLi9zcmMvdXRpbHMvRXZlbnREaXNwYXRjaGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBMEMsZ0NBQWdDO0FBQzFFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0VBQXdELGtCQUFrQjtBQUMxRTtBQUNBLHlEQUFpRCxjQUFjO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBeUMsaUNBQWlDO0FBQzFFLHdIQUFnSCxtQkFBbUIsRUFBRTtBQUNySTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FB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O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPOzs7QUFHUDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ087OztBQUdQO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTzs7O0FBR1A7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPOzs7QUFHUDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ087OztBQUdQO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTzs7O0FBR1A7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPOzs7QUFHUDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ087OztBQUdQO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTzs7O0FBR1A7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPOzs7QUFHUDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ087OztBQUdQO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTzs7O0FBR1A7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPOzs7QUFHUDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ087OztBQUdQO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTzs7O0FBR1A7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPOzs7QUFHUDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ087OztBQUdQO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTzs7O0FBR1A7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPOzs7QUFHUDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ087OztBQUdQO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTzs7O0FBR1A7QUFDQTtBQUNBLFVBQVU7QUFD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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDs7QUFFQSw2QkFBNkIsbUJBQW1COztBQUVoRDs7QUFFQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxXQUFXLEVBQUU7QUFDckQsd0NBQXdDLFdBQVcsRUFBRTs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxzQ0FBc0M7QUFDdEMsR0FBRztBQUNIO0FBQ0EsOERBQThEO0FBQzlEOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2RitFOztBQUVoRTtBQUNmO0FBQ0E7O0FBRUEsOENBQThDLGVBQWU7QUFDN0Q7QUFDQTs7QUFFQTtBQUNBLFlBQVksdUVBQWdCO0FBQzVCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLDBFQUFtQjtBQUMzQixhQUFhLG9EQUFvRDtBQUNqRTs7QUFFQTtBQUNBLFFBQVEsMEVBQW1CO0FBQzNCLGFBQWEsb0RBQW9EOztBQUVqRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNwREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFtQjs7QUFFbkI7QUFDOEI7QUFDQTtBQUNVO0FBQ0M7QUFDTjtBQUNHOztBQUV5Qjs7QUFFaEQ7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFFBQVEsMEVBQW1CO0FBQzNCLGFBQWEsK0NBQStDOztBQUU1RCxRQUFRLDBFQUFtQjtBQUMzQixhQUFhLG9EQUFvRDs7QUFFakUsUUFBUSwwRUFBbUI7QUFDM0IsYUFBYSx3REFBd0Q7O0FBRXJFLFFBQVEsMEVBQW1CO0FBQzNCLGFBQWEsMENBQTBDO0FBQ3ZEOztBQUVBO0FBQ0EsUUFBUSwwRUFBbUI7QUFDM0IsYUFBYSwrQ0FBK0M7O0FBRTVELFFBQVEsMEVBQW1CO0FBQzNCLGFBQWEsb0RBQW9EOztBQUVqRSxRQUFRLDBFQUFtQjtBQUMzQixhQUFhLHdEQUF3RDs7QUFFckUsUUFBUSwwRUFBbUI7QUFDM0IsYUFBYSwwQ0FBMEM7O0FBRXZEOztBQUVBO0FBQ0E7O0FBRUEsMEJBQTBCLGlEQUFLO0FBQy9CO0FBQ0Esc0JBQXNCLGtEQUFJO0FBQzFCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix3REFBUztBQUN2QztBQUNBO0FBQ0EsZ0NBQWdDLHdEQUFHO0FBQ25DLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsOEJBQThCLHdEQUFTO0FBQ3ZDO0FBQ0E7QUFDQSxnQ0FBZ0Msd0RBQU07QUFDdEM7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTOztBQUVULGlDQUFpQyxzREFBVTtBQUMzQztBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzdHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQWdFO0FBQ2M7QUFDRTs7O0FBR2hGLDJDQUEyQyx1RUFBZ0I7QUFDM0Qsa0RBQWtELDhFQUF1Qjs7QUFFekU7O0FBRUEsSUFBSSx1RUFBZ0I7O0FBRXBCLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVFQUFnQjtBQUM3QixnQkFBZ0IsMEVBQW1CO0FBQ25DOztBQUUyQjs7Ozs7Ozs7Ozs7OztBQ3RCM0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRTBEO0FBQ1I7O0FBRWxELGdDQUFnQyxpRUFBZTs7QUFLN0M7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDWGE7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBLEM7Ozs7Ozs7Ozs7OztBQzNCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQTJDO0FBQ0g7QUFDWTs7QUFFcEQ7QUFDZTtBQUNmO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsY0FBYztBQUM3QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsMkVBQTJFO0FBQ3JHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLCtCQUErQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrRUFBbUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsQzs7Ozs7Ozs7Ozs7O0FDL0NBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBb0Q7QUFDRjtBQUNWOztBQUV6Qjs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLGtFQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvREFBVztBQUMvQztBQUNBO0FBQ0Esb0NBQW9DLG9EQUFXO0FBQy9DO0FBQ0E7O0FBRUEsbUNBQW1DLHlEQUFnQiwyQkFBMkIsd0JBQXdCOztBQUV0RyxRQUFRLGtFQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDOzs7Ozs7Ozs7Ozs7QUMvQ0E7QUFBQTtBQUFBO0FBQW9DOztBQUVwQztBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLGtEQUFTO0FBQ25DO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFdUM7Ozs7Ozs7Ozs7Ozs7O0FDdEN2QztBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNlOztBQUVmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixrQ0FBa0M7QUFDbEMsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi4vLi4vbGl6bWFwL3d3dy9qcy9tYXAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9pbmRleC5qc1wiKTtcbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIikoZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIub2wtYm94IHtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBib3JkZXItcmFkaXVzOiAycHg7XFxuICBib3JkZXI6IDJweCBzb2xpZCBibHVlO1xcbn1cXG5cXG4ub2wtbW91c2UtcG9zaXRpb24ge1xcbiAgdG9wOiA4cHg7XFxuICByaWdodDogOHB4O1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbn1cXG5cXG4ub2wtc2NhbGUtbGluZSB7XFxuICBiYWNrZ3JvdW5kOiByZ2JhKDAsNjAsMTM2LDAuMyk7XFxuICBib3JkZXItcmFkaXVzOiA0cHg7XFxuICBib3R0b206IDhweDtcXG4gIGxlZnQ6IDhweDtcXG4gIHBhZGRpbmc6IDJweDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuLm9sLXNjYWxlLWxpbmUtaW5uZXIge1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2VlZTtcXG4gIGJvcmRlci10b3A6IG5vbmU7XFxuICBjb2xvcjogI2VlZTtcXG4gIGZvbnQtc2l6ZTogMTBweDtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIG1hcmdpbjogMXB4O1xcbiAgd2lsbC1jaGFuZ2U6IGNvbnRlbnRzLCB3aWR0aDtcXG59XFxuLm9sLW92ZXJsYXktY29udGFpbmVyIHtcXG4gIHdpbGwtY2hhbmdlOiBsZWZ0LHJpZ2h0LHRvcCxib3R0b207XFxufVxcblxcbi5vbC11bnN1cHBvcnRlZCB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG4ub2wtdmlld3BvcnQsIC5vbC11bnNlbGVjdGFibGUge1xcbiAgLXdlYmtpdC10b3VjaC1jYWxsb3V0OiBub25lO1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICB1c2VyLXNlbGVjdDogbm9uZTtcXG4gIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogcmdiYSgwLDAsMCwwKTtcXG59XFxuLm9sLXNlbGVjdGFibGUge1xcbiAgLXdlYmtpdC10b3VjaC1jYWxsb3V0OiBkZWZhdWx0O1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogdGV4dDtcXG4gIC1tb3otdXNlci1zZWxlY3Q6IHRleHQ7XFxuICAtbXMtdXNlci1zZWxlY3Q6IHRleHQ7XFxuICB1c2VyLXNlbGVjdDogdGV4dDtcXG59XFxuLm9sLWdyYWJiaW5nIHtcXG4gIGN1cnNvcjogLXdlYmtpdC1ncmFiYmluZztcXG4gIGN1cnNvcjogLW1vei1ncmFiYmluZztcXG4gIGN1cnNvcjogZ3JhYmJpbmc7XFxufVxcbi5vbC1ncmFiIHtcXG4gIGN1cnNvcjogbW92ZTtcXG4gIGN1cnNvcjogLXdlYmtpdC1ncmFiO1xcbiAgY3Vyc29yOiAtbW96LWdyYWI7XFxuICBjdXJzb3I6IGdyYWI7XFxufVxcbi5vbC1jb250cm9sIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LDI1NSwyNTUsMC40KTtcXG4gIGJvcmRlci1yYWRpdXM6IDRweDtcXG4gIHBhZGRpbmc6IDJweDtcXG59XFxuLm9sLWNvbnRyb2w6aG92ZXIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsMjU1LDI1NSwwLjYpO1xcbn1cXG4ub2wtem9vbSB7XFxuICB0b3A6IC41ZW07XFxuICBsZWZ0OiAuNWVtO1xcbn1cXG4ub2wtcm90YXRlIHtcXG4gIHRvcDogLjVlbTtcXG4gIHJpZ2h0OiAuNWVtO1xcbiAgdHJhbnNpdGlvbjogb3BhY2l0eSAuMjVzIGxpbmVhciwgdmlzaWJpbGl0eSAwcyBsaW5lYXI7XFxufVxcbi5vbC1yb3RhdGUub2wtaGlkZGVuIHtcXG4gIG9wYWNpdHk6IDA7XFxuICB2aXNpYmlsaXR5OiBoaWRkZW47XFxuICB0cmFuc2l0aW9uOiBvcGFjaXR5IC4yNXMgbGluZWFyLCB2aXNpYmlsaXR5IDBzIGxpbmVhciAuMjVzO1xcbn1cXG4ub2wtem9vbS1leHRlbnQge1xcbiAgdG9wOiA0LjY0M2VtO1xcbiAgbGVmdDogLjVlbTtcXG59XFxuLm9sLWZ1bGwtc2NyZWVuIHtcXG4gIHJpZ2h0OiAuNWVtO1xcbiAgdG9wOiAuNWVtO1xcbn1cXG5AbWVkaWEgcHJpbnQge1xcbiAgLm9sLWNvbnRyb2wge1xcbiAgICBkaXNwbGF5OiBub25lO1xcbiAgfVxcbn1cXG5cXG4ub2wtY29udHJvbCBidXR0b24ge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBtYXJnaW46IDFweDtcXG4gIHBhZGRpbmc6IDA7XFxuICBjb2xvcjogd2hpdGU7XFxuICBmb250LXNpemU6IDEuMTRlbTtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgaGVpZ2h0OiAxLjM3NWVtO1xcbiAgd2lkdGg6IDEuMzc1ZW07XFxuICBsaW5lLWhlaWdodDogLjRlbTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCw2MCwxMzYsMC41KTtcXG4gIGJvcmRlcjogbm9uZTtcXG4gIGJvcmRlci1yYWRpdXM6IDJweDtcXG59XFxuLm9sLWNvbnRyb2wgYnV0dG9uOjotbW96LWZvY3VzLWlubmVyIHtcXG4gIGJvcmRlcjogbm9uZTtcXG4gIHBhZGRpbmc6IDA7XFxufVxcbi5vbC16b29tLWV4dGVudCBidXR0b24ge1xcbiAgbGluZS1oZWlnaHQ6IDEuNGVtO1xcbn1cXG4ub2wtY29tcGFzcyB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxuICBmb250LXNpemU6IDEuMmVtO1xcbiAgd2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTtcXG59XFxuLm9sLXRvdWNoIC5vbC1jb250cm9sIGJ1dHRvbiB7XFxuICBmb250LXNpemU6IDEuNWVtO1xcbn1cXG4ub2wtdG91Y2ggLm9sLXpvb20tZXh0ZW50IHtcXG4gIHRvcDogNS41ZW07XFxufVxcbi5vbC1jb250cm9sIGJ1dHRvbjpob3ZlcixcXG4ub2wtY29udHJvbCBidXR0b246Zm9jdXMge1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLDYwLDEzNiwwLjcpO1xcbn1cXG4ub2wtem9vbSAub2wtem9vbS1pbiB7XFxuICBib3JkZXItcmFkaXVzOiAycHggMnB4IDAgMDtcXG59XFxuLm9sLXpvb20gLm9sLXpvb20tb3V0IHtcXG4gIGJvcmRlci1yYWRpdXM6IDAgMCAycHggMnB4O1xcbn1cXG5cXG5cXG4ub2wtYXR0cmlidXRpb24ge1xcbiAgdGV4dC1hbGlnbjogcmlnaHQ7XFxuICBib3R0b206IC41ZW07XFxuICByaWdodDogLjVlbTtcXG4gIG1heC13aWR0aDogY2FsYygxMDAlIC0gMS4zZW0pO1xcbn1cXG5cXG4ub2wtYXR0cmlidXRpb24gdWwge1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMCAuNWVtO1xcbiAgZm9udC1zaXplOiAuN3JlbTtcXG4gIGxpbmUtaGVpZ2h0OiAxLjM3NWVtO1xcbiAgY29sb3I6ICMwMDA7XFxuICB0ZXh0LXNoYWRvdzogMCAwIDJweCAjZmZmO1xcbn1cXG4ub2wtYXR0cmlidXRpb24gbGkge1xcbiAgZGlzcGxheTogaW5saW5lO1xcbiAgbGlzdC1zdHlsZTogbm9uZTtcXG4gIGxpbmUtaGVpZ2h0OiBpbmhlcml0O1xcbn1cXG4ub2wtYXR0cmlidXRpb24gbGk6bm90KDpsYXN0LWNoaWxkKTphZnRlciB7XFxuICBjb250ZW50OiBcXFwiIFxcXCI7XFxufVxcbi5vbC1hdHRyaWJ1dGlvbiBpbWcge1xcbiAgbWF4LWhlaWdodDogMmVtO1xcbiAgbWF4LXdpZHRoOiBpbmhlcml0O1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG59XFxuLm9sLWF0dHJpYnV0aW9uIHVsLCAub2wtYXR0cmlidXRpb24gYnV0dG9uIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG59XFxuLm9sLWF0dHJpYnV0aW9uLm9sLWNvbGxhcHNlZCB1bCB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG4ub2wtYXR0cmlidXRpb246bm90KC5vbC1jb2xsYXBzZWQpIHtcXG4gIGJhY2tncm91bmQ6IHJnYmEoMjU1LDI1NSwyNTUsMC44KTtcXG59XFxuLm9sLWF0dHJpYnV0aW9uLm9sLXVuY29sbGFwc2libGUge1xcbiAgYm90dG9tOiAwO1xcbiAgcmlnaHQ6IDA7XFxuICBib3JkZXItcmFkaXVzOiA0cHggMCAwO1xcbiAgaGVpZ2h0OiAxLjFlbTtcXG4gIGxpbmUtaGVpZ2h0OiAxZW07XFxufVxcbi5vbC1hdHRyaWJ1dGlvbi5vbC11bmNvbGxhcHNpYmxlIGltZyB7XFxuICBtYXJnaW4tdG9wOiAtLjJlbTtcXG4gIG1heC1oZWlnaHQ6IDEuNmVtO1xcbn1cXG4ub2wtYXR0cmlidXRpb24ub2wtdW5jb2xsYXBzaWJsZSBidXR0b24ge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuXFxuLm9sLXpvb21zbGlkZXIge1xcbiAgdG9wOiA0LjVlbTtcXG4gIGxlZnQ6IC41ZW07XFxuICBoZWlnaHQ6IDIwMHB4O1xcbn1cXG4ub2wtem9vbXNsaWRlciBidXR0b24ge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgaGVpZ2h0OiAxMHB4O1xcbn1cXG5cXG4ub2wtdG91Y2ggLm9sLXpvb21zbGlkZXIge1xcbiAgdG9wOiA1LjVlbTtcXG59XFxuXFxuLm9sLW92ZXJ2aWV3bWFwIHtcXG4gIGxlZnQ6IDAuNWVtO1xcbiAgYm90dG9tOiAwLjVlbTtcXG59XFxuLm9sLW92ZXJ2aWV3bWFwLm9sLXVuY29sbGFwc2libGUge1xcbiAgYm90dG9tOiAwO1xcbiAgbGVmdDogMDtcXG4gIGJvcmRlci1yYWRpdXM6IDAgNHB4IDAgMDtcXG59XFxuLm9sLW92ZXJ2aWV3bWFwIC5vbC1vdmVydmlld21hcC1tYXAsXFxuLm9sLW92ZXJ2aWV3bWFwIGJ1dHRvbiB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxufVxcbi5vbC1vdmVydmlld21hcCAub2wtb3ZlcnZpZXdtYXAtbWFwIHtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICM3Yjk4YmM7XFxuICBoZWlnaHQ6IDE1MHB4O1xcbiAgbWFyZ2luOiAycHg7XFxuICB3aWR0aDogMTUwcHg7XFxufVxcbi5vbC1vdmVydmlld21hcDpub3QoLm9sLWNvbGxhcHNlZCkgYnV0dG9ue1xcbiAgYm90dG9tOiAxcHg7XFxuICBsZWZ0OiAycHg7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxufVxcbi5vbC1vdmVydmlld21hcC5vbC1jb2xsYXBzZWQgLm9sLW92ZXJ2aWV3bWFwLW1hcCxcXG4ub2wtb3ZlcnZpZXdtYXAub2wtdW5jb2xsYXBzaWJsZSBidXR0b24ge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuLm9sLW92ZXJ2aWV3bWFwOm5vdCgub2wtY29sbGFwc2VkKSB7XFxuICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwyNTUsMjU1LDAuOCk7XFxufVxcbi5vbC1vdmVydmlld21hcC1ib3gge1xcbiAgYm9yZGVyOiAycHggZG90dGVkIHJnYmEoMCw2MCwxMzYsMC43KTtcXG59XFxuXFxuLm9sLW92ZXJ2aWV3bWFwIC5vbC1vdmVydmlld21hcC1ib3g6aG92ZXIge1xcbiAgY3Vyc29yOiBtb3ZlO1xcbn1cXG5cIiwgXCJcIl0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVzZVNvdXJjZU1hcCkge1xuICB2YXIgbGlzdCA9IFtdOyAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIHJldHVybiBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCJ7XCIpLmNvbmNhdChjb250ZW50LCBcIn1cIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0pLmpvaW4oJycpO1xuICB9OyAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuXG5cbiAgbGlzdC5pID0gZnVuY3Rpb24gKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsICcnXV07XG4gICAgfVxuXG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICB2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXG4gICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG1vZHVsZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IG1vZHVsZXNbX2ldOyAvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG4gICAgICAvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuICAgICAgLy8gd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxuICAgICAgLy8gSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXG4gICAgICBpZiAoaXRlbVswXSA9PSBudWxsIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgIGlmIChtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhUXVlcnk7XG4gICAgICAgIH0gZWxzZSBpZiAobWVkaWFRdWVyeSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBcIihcIi5jb25jYXQoaXRlbVsyXSwgXCIpIGFuZCAoXCIpLmNvbmNhdChtZWRpYVF1ZXJ5LCBcIilcIik7XG4gICAgICAgIH1cblxuICAgICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcbiAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcblxuICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cbiAgaWYgKCFjc3NNYXBwaW5nKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG4gICAgdmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHJldHVybiBcIi8qIyBzb3VyY2VVUkw9XCIuY29uY2F0KGNzc01hcHBpbmcuc291cmNlUm9vdCkuY29uY2F0KHNvdXJjZSwgXCIgKi9cIik7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG4gIH1cblxuICByZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufSAvLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5cblxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgdmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSk7XG4gIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcbiAgcmV0dXJuIFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbn0iLCIvKipcbiAqIEBtb2R1bGUgb2wvQXNzZXJ0aW9uRXJyb3JcbiAqL1xuaW1wb3J0IHtWRVJTSU9OfSBmcm9tICcuL3V0aWwuanMnO1xuXG4vKipcbiAqIEVycm9yIG9iamVjdCB0aHJvd24gd2hlbiBhbiBhc3NlcnRpb24gZmFpbGVkLiBUaGlzIGlzIGFuIEVDTUEtMjYyIEVycm9yLFxuICogZXh0ZW5kZWQgd2l0aCBhIGBjb2RlYCBwcm9wZXJ0eS5cbiAqIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9FcnJvci5cbiAqL1xudmFyIEFzc2VydGlvbkVycm9yID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoRXJyb3IpIHtcbiAgZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3IoY29kZSkge1xuICAgIHZhciBwYXRoID0gVkVSU0lPTiA9PT0gJ2xhdGVzdCcgPyBWRVJTSU9OIDogJ3YnICsgVkVSU0lPTi5zcGxpdCgnLScpWzBdO1xuICAgIHZhciBtZXNzYWdlID0gJ0Fzc2VydGlvbiBmYWlsZWQuIFNlZSBodHRwczovL29wZW5sYXllcnMub3JnL2VuLycgKyBwYXRoICtcbiAgICAnL2RvYy9lcnJvcnMvIycgKyBjb2RlICsgJyBmb3IgZGV0YWlscy4nO1xuXG4gICAgRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcblxuICAgIC8qKlxuICAgICAqIEVycm9yIGNvZGUuIFRoZSBtZWFuaW5nIG9mIHRoZSBjb2RlIGNhbiBiZSBmb3VuZCBvblxuICAgICAqIGh0dHBzOi8vb3BlbmxheWVycy5vcmcvZW4vbGF0ZXN0L2RvYy9lcnJvcnMvIChyZXBsYWNlIGBsYXRlc3RgIHdpdGhcbiAgICAgKiB0aGUgdmVyc2lvbiBmb3VuZCBpbiB0aGUgT3BlbkxheWVycyBzY3JpcHQncyBoZWFkZXIgY29tbWVudCBpZiBhIHZlcnNpb25cbiAgICAgKiBvdGhlciB0aGFuIHRoZSBsYXRlc3QgaXMgdXNlZCkuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5jb2RlID0gY29kZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5uYW1lID0gJ0Fzc2VydGlvbkVycm9yJztcblxuICAgIC8vIFJlLWFzc2lnbiBtZXNzYWdlLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL1JpY2gtSGFycmlzL2J1YmxlL2lzc3Vlcy80MFxuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIH1cblxuICBpZiAoIEVycm9yICkgQXNzZXJ0aW9uRXJyb3IuX19wcm90b19fID0gRXJyb3I7XG4gIEFzc2VydGlvbkVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEVycm9yICYmIEVycm9yLnByb3RvdHlwZSApO1xuICBBc3NlcnRpb25FcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBc3NlcnRpb25FcnJvcjtcblxuICByZXR1cm4gQXNzZXJ0aW9uRXJyb3I7XG59KEVycm9yKSk7XG5cbmV4cG9ydCBkZWZhdWx0IEFzc2VydGlvbkVycm9yO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Bc3NlcnRpb25FcnJvci5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvQ29sbGVjdGlvblxuICovXG5pbXBvcnQgQXNzZXJ0aW9uRXJyb3IgZnJvbSAnLi9Bc3NlcnRpb25FcnJvci5qcyc7XG5pbXBvcnQgQ29sbGVjdGlvbkV2ZW50VHlwZSBmcm9tICcuL0NvbGxlY3Rpb25FdmVudFR5cGUuanMnO1xuaW1wb3J0IEJhc2VPYmplY3QgZnJvbSAnLi9PYmplY3QuanMnO1xuaW1wb3J0IEV2ZW50IGZyb20gJy4vZXZlbnRzL0V2ZW50LmpzJztcblxuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgUHJvcGVydHkgPSB7XG4gIExFTkdUSDogJ2xlbmd0aCdcbn07XG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBFdmVudHMgZW1pdHRlZCBieSB7QGxpbmsgbW9kdWxlOm9sL0NvbGxlY3Rpb25+Q29sbGVjdGlvbn0gaW5zdGFuY2VzIGFyZSBpbnN0YW5jZXMgb2YgdGhpc1xuICogdHlwZS5cbiAqL1xuZXhwb3J0IHZhciBDb2xsZWN0aW9uRXZlbnQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChFdmVudCkge1xuICBmdW5jdGlvbiBDb2xsZWN0aW9uRXZlbnQodHlwZSwgb3B0X2VsZW1lbnQpIHtcbiAgICBFdmVudC5jYWxsKHRoaXMsIHR5cGUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGVsZW1lbnQgdGhhdCBpcyBhZGRlZCB0byBvciByZW1vdmVkIGZyb20gdGhlIGNvbGxlY3Rpb24uXG4gICAgICogQHR5cGUgeyp9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMuZWxlbWVudCA9IG9wdF9lbGVtZW50O1xuXG4gIH1cblxuICBpZiAoIEV2ZW50ICkgQ29sbGVjdGlvbkV2ZW50Ll9fcHJvdG9fXyA9IEV2ZW50O1xuICBDb2xsZWN0aW9uRXZlbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXZlbnQgJiYgRXZlbnQucHJvdG90eXBlICk7XG4gIENvbGxlY3Rpb25FdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb2xsZWN0aW9uRXZlbnQ7XG5cbiAgcmV0dXJuIENvbGxlY3Rpb25FdmVudDtcbn0oRXZlbnQpKTtcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3VuaXF1ZT1mYWxzZV0gRGlzYWxsb3cgdGhlIHNhbWUgaXRlbSBmcm9tIGJlaW5nIGFkZGVkIHRvXG4gKiB0aGUgY29sbGVjdGlvbiB0d2ljZS5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFuIGV4cGFuZGVkIHZlcnNpb24gb2Ygc3RhbmRhcmQgSlMgQXJyYXksIGFkZGluZyBjb252ZW5pZW5jZSBtZXRob2RzIGZvclxuICogbWFuaXB1bGF0aW9uLiBBZGQgYW5kIHJlbW92ZSBjaGFuZ2VzIHRvIHRoZSBDb2xsZWN0aW9uIHRyaWdnZXIgYSBDb2xsZWN0aW9uXG4gKiBldmVudC4gTm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgY292ZXIgY2hhbmdlcyB0byB0aGUgb2JqZWN0cyBfd2l0aGluXyB0aGVcbiAqIENvbGxlY3Rpb247IHRoZXkgdHJpZ2dlciBldmVudHMgb24gdGhlIGFwcHJvcHJpYXRlIG9iamVjdCwgbm90IG9uIHRoZVxuICogQ29sbGVjdGlvbiBhcyBhIHdob2xlLlxuICpcbiAqIEBmaXJlcyBDb2xsZWN0aW9uRXZlbnRcbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQGFwaVxuICovXG52YXIgQ29sbGVjdGlvbiA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEJhc2VPYmplY3QpIHtcbiAgZnVuY3Rpb24gQ29sbGVjdGlvbihvcHRfYXJyYXksIG9wdF9vcHRpb25zKSB7XG5cbiAgICBCYXNlT2JqZWN0LmNhbGwodGhpcyk7XG5cbiAgICB2YXIgb3B0aW9ucyA9IG9wdF9vcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnVuaXF1ZV8gPSAhIW9wdGlvbnMudW5pcXVlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IUFycmF5PFQ+fVxuICAgICAqL1xuICAgIHRoaXMuYXJyYXlfID0gb3B0X2FycmF5ID8gb3B0X2FycmF5IDogW107XG5cbiAgICBpZiAodGhpcy51bmlxdWVfKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLmFycmF5Xy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0VW5pcXVlXyh0aGlzLmFycmF5X1tpXSwgaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVMZW5ndGhfKCk7XG5cbiAgfVxuXG4gIGlmICggQmFzZU9iamVjdCApIENvbGxlY3Rpb24uX19wcm90b19fID0gQmFzZU9iamVjdDtcbiAgQ29sbGVjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCYXNlT2JqZWN0ICYmIEJhc2VPYmplY3QucHJvdG90eXBlICk7XG4gIENvbGxlY3Rpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29sbGVjdGlvbjtcblxuICAvKipcbiAgICogUmVtb3ZlIGFsbCBlbGVtZW50cyBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBDb2xsZWN0aW9uLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICB3aGlsZSAodGhpcy5nZXRMZW5ndGgoKSA+IDApIHtcbiAgICAgIHRoaXMucG9wKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgZWxlbWVudHMgdG8gdGhlIGNvbGxlY3Rpb24uICBUaGlzIHB1c2hlcyBlYWNoIGl0ZW0gaW4gdGhlIHByb3ZpZGVkIGFycmF5XG4gICAqIHRvIHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAqIEBwYXJhbSB7IUFycmF5PFQ+fSBhcnIgQXJyYXkuXG4gICAqIEByZXR1cm4ge0NvbGxlY3Rpb248VD59IFRoaXMgY29sbGVjdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgQ29sbGVjdGlvbi5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kIChhcnIpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBhcnIubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgdGhpcy5wdXNoKGFycltpXSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJdGVyYXRlIG92ZXIgZWFjaCBlbGVtZW50LCBjYWxsaW5nIHRoZSBwcm92aWRlZCBjYWxsYmFjay5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihULCBudW1iZXIsIEFycmF5PFQ+KTogKn0gZiBUaGUgZnVuY3Rpb24gdG8gY2FsbFxuICAgKiAgICAgZm9yIGV2ZXJ5IGVsZW1lbnQuIFRoaXMgZnVuY3Rpb24gdGFrZXMgMyBhcmd1bWVudHMgKHRoZSBlbGVtZW50LCB0aGVcbiAgICogICAgIGluZGV4IGFuZCB0aGUgYXJyYXkpLiBUaGUgcmV0dXJuIHZhbHVlIGlzIGlnbm9yZWQuXG4gICAqIEBhcGlcbiAgICovXG4gIENvbGxlY3Rpb24ucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoIChmKSB7XG4gICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheV87XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gYXJyYXkubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgZihhcnJheVtpXSwgaSwgYXJyYXkpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IGEgcmVmZXJlbmNlIHRvIHRoZSB1bmRlcmx5aW5nIEFycmF5IG9iamVjdC4gV2FybmluZzogaWYgdGhlIGFycmF5XG4gICAqIGlzIG11dGF0ZWQsIG5vIGV2ZW50cyB3aWxsIGJlIGRpc3BhdGNoZWQgYnkgdGhlIGNvbGxlY3Rpb24sIGFuZCB0aGVcbiAgICogY29sbGVjdGlvbidzIFwibGVuZ3RoXCIgcHJvcGVydHkgd29uJ3QgYmUgaW4gc3luYyB3aXRoIHRoZSBhY3R1YWwgbGVuZ3RoXG4gICAqIG9mIHRoZSBhcnJheS5cbiAgICogQHJldHVybiB7IUFycmF5PFQ+fSBBcnJheS5cbiAgICogQGFwaVxuICAgKi9cbiAgQ29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0QXJyYXkgPSBmdW5jdGlvbiBnZXRBcnJheSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyYXlfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGVsZW1lbnQgYXQgdGhlIHByb3ZpZGVkIGluZGV4LlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXguXG4gICAqIEByZXR1cm4ge1R9IEVsZW1lbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIENvbGxlY3Rpb24ucHJvdG90eXBlLml0ZW0gPSBmdW5jdGlvbiBpdGVtIChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLmFycmF5X1tpbmRleF07XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGVuZ3RoIG9mIHRoaXMgY29sbGVjdGlvbi5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbGVuZ3RoIG9mIHRoZSBhcnJheS5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgQ29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gZ2V0TGVuZ3RoICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoUHJvcGVydHkuTEVOR1RIKTtcbiAgfTtcblxuICAvKipcbiAgICogSW5zZXJ0IGFuIGVsZW1lbnQgYXQgdGhlIHByb3ZpZGVkIGluZGV4LlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXguXG4gICAqIEBwYXJhbSB7VH0gZWxlbSBFbGVtZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBDb2xsZWN0aW9uLnByb3RvdHlwZS5pbnNlcnRBdCA9IGZ1bmN0aW9uIGluc2VydEF0IChpbmRleCwgZWxlbSkge1xuICAgIGlmICh0aGlzLnVuaXF1ZV8pIHtcbiAgICAgIHRoaXMuYXNzZXJ0VW5pcXVlXyhlbGVtKTtcbiAgICB9XG4gICAgdGhpcy5hcnJheV8uc3BsaWNlKGluZGV4LCAwLCBlbGVtKTtcbiAgICB0aGlzLnVwZGF0ZUxlbmd0aF8oKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICBuZXcgQ29sbGVjdGlvbkV2ZW50KENvbGxlY3Rpb25FdmVudFR5cGUuQURELCBlbGVtKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgbGFzdCBlbGVtZW50IG9mIHRoZSBjb2xsZWN0aW9uIGFuZCByZXR1cm4gaXQuXG4gICAqIFJldHVybiBgdW5kZWZpbmVkYCBpZiB0aGUgY29sbGVjdGlvbiBpcyBlbXB0eS5cbiAgICogQHJldHVybiB7VHx1bmRlZmluZWR9IEVsZW1lbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIENvbGxlY3Rpb24ucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uIHBvcCAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlQXQodGhpcy5nZXRMZW5ndGgoKSAtIDEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbnNlcnQgdGhlIHByb3ZpZGVkIGVsZW1lbnQgYXQgdGhlIGVuZCBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICogQHBhcmFtIHtUfSBlbGVtIEVsZW1lbnQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gTmV3IGxlbmd0aCBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgQ29sbGVjdGlvbi5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKGVsZW0pIHtcbiAgICBpZiAodGhpcy51bmlxdWVfKSB7XG4gICAgICB0aGlzLmFzc2VydFVuaXF1ZV8oZWxlbSk7XG4gICAgfVxuICAgIHZhciBuID0gdGhpcy5nZXRMZW5ndGgoKTtcbiAgICB0aGlzLmluc2VydEF0KG4sIGVsZW0pO1xuICAgIHJldHVybiB0aGlzLmdldExlbmd0aCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYW4gZWxlbWVudCBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuICAgKiBAcGFyYW0ge1R9IGVsZW0gRWxlbWVudC5cbiAgICogQHJldHVybiB7VHx1bmRlZmluZWR9IFRoZSByZW1vdmVkIGVsZW1lbnQgb3IgdW5kZWZpbmVkIGlmIG5vbmUgZm91bmQuXG4gICAqIEBhcGlcbiAgICovXG4gIENvbGxlY3Rpb24ucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAoZWxlbSkge1xuICAgIHZhciBhcnIgPSB0aGlzLmFycmF5XztcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBhcnIubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgaWYgKGFycltpXSA9PT0gZWxlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVBdChpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBlbGVtZW50IGF0IHRoZSBwcm92aWRlZCBpbmRleCBhbmQgcmV0dXJuIGl0LlxuICAgKiBSZXR1cm4gYHVuZGVmaW5lZGAgaWYgdGhlIGNvbGxlY3Rpb24gZG9lcyBub3QgY29udGFpbiB0aGlzIGluZGV4LlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXguXG4gICAqIEByZXR1cm4ge1R8dW5kZWZpbmVkfSBWYWx1ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgQ29sbGVjdGlvbi5wcm90b3R5cGUucmVtb3ZlQXQgPSBmdW5jdGlvbiByZW1vdmVBdCAoaW5kZXgpIHtcbiAgICB2YXIgcHJldiA9IHRoaXMuYXJyYXlfW2luZGV4XTtcbiAgICB0aGlzLmFycmF5Xy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHRoaXMudXBkYXRlTGVuZ3RoXygpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ29sbGVjdGlvbkV2ZW50KENvbGxlY3Rpb25FdmVudFR5cGUuUkVNT1ZFLCBwcmV2KSk7XG4gICAgcmV0dXJuIHByZXY7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZWxlbWVudCBhdCB0aGUgcHJvdmlkZWQgaW5kZXguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleC5cbiAgICogQHBhcmFtIHtUfSBlbGVtIEVsZW1lbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIENvbGxlY3Rpb24ucHJvdG90eXBlLnNldEF0ID0gZnVuY3Rpb24gc2V0QXQgKGluZGV4LCBlbGVtKSB7XG4gICAgdmFyIG4gPSB0aGlzLmdldExlbmd0aCgpO1xuICAgIGlmIChpbmRleCA8IG4pIHtcbiAgICAgIGlmICh0aGlzLnVuaXF1ZV8pIHtcbiAgICAgICAgdGhpcy5hc3NlcnRVbmlxdWVfKGVsZW0sIGluZGV4KTtcbiAgICAgIH1cbiAgICAgIHZhciBwcmV2ID0gdGhpcy5hcnJheV9baW5kZXhdO1xuICAgICAgdGhpcy5hcnJheV9baW5kZXhdID0gZWxlbTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgbmV3IENvbGxlY3Rpb25FdmVudChDb2xsZWN0aW9uRXZlbnRUeXBlLlJFTU9WRSwgcHJldikpO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgICBuZXcgQ29sbGVjdGlvbkV2ZW50KENvbGxlY3Rpb25FdmVudFR5cGUuQURELCBlbGVtKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGogPSBuOyBqIDwgaW5kZXg7ICsraikge1xuICAgICAgICB0aGlzLmluc2VydEF0KGosIHVuZGVmaW5lZCk7XG4gICAgICB9XG4gICAgICB0aGlzLmluc2VydEF0KGluZGV4LCBlbGVtKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBDb2xsZWN0aW9uLnByb3RvdHlwZS51cGRhdGVMZW5ndGhfID0gZnVuY3Rpb24gdXBkYXRlTGVuZ3RoXyAoKSB7XG4gICAgdGhpcy5zZXQoUHJvcGVydHkuTEVOR1RILCB0aGlzLmFycmF5Xy5sZW5ndGgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1R9IGVsZW0gRWxlbWVudC5cbiAgICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZXhjZXB0IE9wdGlvbmFsIGluZGV4IHRvIGlnbm9yZS5cbiAgICovXG4gIENvbGxlY3Rpb24ucHJvdG90eXBlLmFzc2VydFVuaXF1ZV8gPSBmdW5jdGlvbiBhc3NlcnRVbmlxdWVfIChlbGVtLCBvcHRfZXhjZXB0KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdGhpcy5hcnJheV8ubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgaWYgKHRoaXMuYXJyYXlfW2ldID09PSBlbGVtICYmIGkgIT09IG9wdF9leGNlcHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKDU4KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIENvbGxlY3Rpb247XG59KEJhc2VPYmplY3QpKTtcblxuXG5leHBvcnQgZGVmYXVsdCBDb2xsZWN0aW9uO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db2xsZWN0aW9uLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9Db2xsZWN0aW9uRXZlbnRUeXBlXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiBhbiBpdGVtIGlzIGFkZGVkIHRvIHRoZSBjb2xsZWN0aW9uLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL0NvbGxlY3Rpb24uQ29sbGVjdGlvbkV2ZW50I2FkZFxuICAgKiBAYXBpXG4gICAqL1xuICBBREQ6ICdhZGQnLFxuICAvKipcbiAgICogVHJpZ2dlcmVkIHdoZW4gYW4gaXRlbSBpcyByZW1vdmVkIGZyb20gdGhlIGNvbGxlY3Rpb24uXG4gICAqIEBldmVudCBtb2R1bGU6b2wvQ29sbGVjdGlvbi5Db2xsZWN0aW9uRXZlbnQjcmVtb3ZlXG4gICAqIEBhcGlcbiAgICovXG4gIFJFTU9WRTogJ3JlbW92ZSdcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbGxlY3Rpb25FdmVudFR5cGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL0Rpc3Bvc2FibGVcbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIE9iamVjdHMgdGhhdCBuZWVkIHRvIGNsZWFuIHVwIGFmdGVyIHRoZW1zZWx2ZXMuXG4gKi9cbnZhciBEaXNwb3NhYmxlID0gZnVuY3Rpb24gRGlzcG9zYWJsZSgpIHtcbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgaGFzIGFscmVhZHkgYmVlbiBkaXNwb3NlZC5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmRpc3Bvc2VkXyA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBDbGVhbiB1cC5cbiAqL1xuRGlzcG9zYWJsZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UgKCkge1xuICBpZiAoIXRoaXMuZGlzcG9zZWRfKSB7XG4gICAgdGhpcy5kaXNwb3NlZF8gPSB0cnVlO1xuICAgIHRoaXMuZGlzcG9zZUludGVybmFsKCk7XG4gIH1cbn07XG5cbi8qKlxuICogRXh0ZW5zaW9uIHBvaW50IGZvciBkaXNwb3NhYmxlIG9iamVjdHMuXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkRpc3Bvc2FibGUucHJvdG90eXBlLmRpc3Bvc2VJbnRlcm5hbCA9IGZ1bmN0aW9uIGRpc3Bvc2VJbnRlcm5hbCAoKSB7fTtcblxuZXhwb3J0IGRlZmF1bHQgRGlzcG9zYWJsZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGlzcG9zYWJsZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvRmVhdHVyZVxuICovXG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi9hc3NlcnRzLmpzJztcbmltcG9ydCB7bGlzdGVuLCB1bmxpc3RlbiwgdW5saXN0ZW5CeUtleX0gZnJvbSAnLi9ldmVudHMuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IEJhc2VPYmplY3QsIHtnZXRDaGFuZ2VFdmVudFR5cGV9IGZyb20gJy4vT2JqZWN0LmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7dHlwZW9mIEZlYXR1cmV8dHlwZW9mIGltcG9ydChcIi4vcmVuZGVyL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gRmVhdHVyZUNsYXNzXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7RmVhdHVyZXxpbXBvcnQoXCIuL3JlbmRlci9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IEZlYXR1cmVMaWtlXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBIHZlY3RvciBvYmplY3QgZm9yIGdlb2dyYXBoaWMgZmVhdHVyZXMgd2l0aCBhIGdlb21ldHJ5IGFuZCBvdGhlclxuICogYXR0cmlidXRlIHByb3BlcnRpZXMsIHNpbWlsYXIgdG8gdGhlIGZlYXR1cmVzIGluIHZlY3RvciBmaWxlIGZvcm1hdHMgbGlrZVxuICogR2VvSlNPTi5cbiAqXG4gKiBGZWF0dXJlcyBjYW4gYmUgc3R5bGVkIGluZGl2aWR1YWxseSB3aXRoIGBzZXRTdHlsZWA7IG90aGVyd2lzZSB0aGV5IHVzZSB0aGVcbiAqIHN0eWxlIG9mIHRoZWlyIHZlY3RvciBsYXllci5cbiAqXG4gKiBOb3RlIHRoYXQgYXR0cmlidXRlIHByb3BlcnRpZXMgYXJlIHNldCBhcyB7QGxpbmsgbW9kdWxlOm9sL09iamVjdH0gcHJvcGVydGllcyBvblxuICogdGhlIGZlYXR1cmUgb2JqZWN0LCBzbyB0aGV5IGFyZSBvYnNlcnZhYmxlLCBhbmQgaGF2ZSBnZXQvc2V0IGFjY2Vzc29ycy5cbiAqXG4gKiBUeXBpY2FsbHksIGEgZmVhdHVyZSBoYXMgYSBzaW5nbGUgZ2VvbWV0cnkgcHJvcGVydHkuIFlvdSBjYW4gc2V0IHRoZVxuICogZ2VvbWV0cnkgdXNpbmcgdGhlIGBzZXRHZW9tZXRyeWAgbWV0aG9kIGFuZCBnZXQgaXQgd2l0aCBgZ2V0R2VvbWV0cnlgLlxuICogSXQgaXMgcG9zc2libGUgdG8gc3RvcmUgbW9yZSB0aGFuIG9uZSBnZW9tZXRyeSBvbiBhIGZlYXR1cmUgdXNpbmcgYXR0cmlidXRlXG4gKiBwcm9wZXJ0aWVzLiBCeSBkZWZhdWx0LCB0aGUgZ2VvbWV0cnkgdXNlZCBmb3IgcmVuZGVyaW5nIGlzIGlkZW50aWZpZWQgYnlcbiAqIHRoZSBwcm9wZXJ0eSBuYW1lIGBnZW9tZXRyeWAuIElmIHlvdSB3YW50IHRvIHVzZSBhbm90aGVyIGdlb21ldHJ5IHByb3BlcnR5XG4gKiBmb3IgcmVuZGVyaW5nLCB1c2UgdGhlIGBzZXRHZW9tZXRyeU5hbWVgIG1ldGhvZCB0byBjaGFuZ2UgdGhlIGF0dHJpYnV0ZVxuICogcHJvcGVydHkgYXNzb2NpYXRlZCB3aXRoIHRoZSBnZW9tZXRyeSBmb3IgdGhlIGZlYXR1cmUuICBGb3IgZXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICpcbiAqIGltcG9ydCBGZWF0dXJlIGZyb20gJ29sL0ZlYXR1cmUnO1xuICogaW1wb3J0IFBvbHlnb24gZnJvbSAnb2wvZ2VvbS9Qb2x5Z29uJztcbiAqIGltcG9ydCBQb2ludCBmcm9tICdvbC9nZW9tL1BvaW50JztcbiAqXG4gKiB2YXIgZmVhdHVyZSA9IG5ldyBGZWF0dXJlKHtcbiAqICAgZ2VvbWV0cnk6IG5ldyBQb2x5Z29uKHBvbHlDb29yZHMpLFxuICogICBsYWJlbFBvaW50OiBuZXcgUG9pbnQobGFiZWxDb29yZHMpLFxuICogICBuYW1lOiAnTXkgUG9seWdvbidcbiAqIH0pO1xuICpcbiAqIC8vIGdldCB0aGUgcG9seWdvbiBnZW9tZXRyeVxuICogdmFyIHBvbHkgPSBmZWF0dXJlLmdldEdlb21ldHJ5KCk7XG4gKlxuICogLy8gUmVuZGVyIHRoZSBmZWF0dXJlIGFzIGEgcG9pbnQgdXNpbmcgdGhlIGNvb3JkaW5hdGVzIGZyb20gbGFiZWxQb2ludFxuICogZmVhdHVyZS5zZXRHZW9tZXRyeU5hbWUoJ2xhYmVsUG9pbnQnKTtcbiAqXG4gKiAvLyBnZXQgdGhlIHBvaW50IGdlb21ldHJ5XG4gKiB2YXIgcG9pbnQgPSBmZWF0dXJlLmdldEdlb21ldHJ5KCk7XG4gKiBgYGBcbiAqXG4gKiBAYXBpXG4gKi9cbnZhciBGZWF0dXJlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoQmFzZU9iamVjdCkge1xuICBmdW5jdGlvbiBGZWF0dXJlKG9wdF9nZW9tZXRyeU9yUHJvcGVydGllcykge1xuXG4gICAgQmFzZU9iamVjdC5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHN0cmluZ3x1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5pZF8gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5nZW9tZXRyeU5hbWVfID0gJ2dlb21ldHJ5JztcblxuICAgIC8qKlxuICAgICAqIFVzZXIgcHJvdmlkZWQgc3R5bGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUxpa2V9XG4gICAgICovXG4gICAgdGhpcy5zdHlsZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUZ1bmN0aW9ufHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnN0eWxlRnVuY3Rpb25fID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleX1cbiAgICAgKi9cbiAgICB0aGlzLmdlb21ldHJ5Q2hhbmdlS2V5XyA9IG51bGw7XG5cbiAgICBsaXN0ZW4oXG4gICAgICB0aGlzLCBnZXRDaGFuZ2VFdmVudFR5cGUodGhpcy5nZW9tZXRyeU5hbWVfKSxcbiAgICAgIHRoaXMuaGFuZGxlR2VvbWV0cnlDaGFuZ2VkXywgdGhpcyk7XG5cbiAgICBpZiAob3B0X2dlb21ldHJ5T3JQcm9wZXJ0aWVzKSB7XG4gICAgICBpZiAodHlwZW9mIC8qKiBAdHlwZSB7P30gKi8gKG9wdF9nZW9tZXRyeU9yUHJvcGVydGllcykuZ2V0U2ltcGxpZmllZEdlb21ldHJ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBnZW9tZXRyeSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9ICovIChvcHRfZ2VvbWV0cnlPclByb3BlcnRpZXMpO1xuICAgICAgICB0aGlzLnNldEdlb21ldHJ5KGdlb21ldHJ5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgKj59ICovXG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0gb3B0X2dlb21ldHJ5T3JQcm9wZXJ0aWVzO1xuICAgICAgICB0aGlzLnNldFByb3BlcnRpZXMocHJvcGVydGllcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCBCYXNlT2JqZWN0ICkgRmVhdHVyZS5fX3Byb3RvX18gPSBCYXNlT2JqZWN0O1xuICBGZWF0dXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJhc2VPYmplY3QgJiYgQmFzZU9iamVjdC5wcm90b3R5cGUgKTtcbiAgRmVhdHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGZWF0dXJlO1xuXG4gIC8qKlxuICAgKiBDbG9uZSB0aGlzIGZlYXR1cmUuIElmIHRoZSBvcmlnaW5hbCBmZWF0dXJlIGhhcyBhIGdlb21ldHJ5IGl0XG4gICAqIGlzIGFsc28gY2xvbmVkLiBUaGUgZmVhdHVyZSBpZCBpcyBub3Qgc2V0IGluIHRoZSBjbG9uZS5cbiAgICogQHJldHVybiB7RmVhdHVyZX0gVGhlIGNsb25lLlxuICAgKiBAYXBpXG4gICAqL1xuICBGZWF0dXJlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgICB2YXIgY2xvbmUgPSBuZXcgRmVhdHVyZSh0aGlzLmdldFByb3BlcnRpZXMoKSk7XG4gICAgY2xvbmUuc2V0R2VvbWV0cnlOYW1lKHRoaXMuZ2V0R2VvbWV0cnlOYW1lKCkpO1xuICAgIHZhciBnZW9tZXRyeSA9IHRoaXMuZ2V0R2VvbWV0cnkoKTtcbiAgICBpZiAoZ2VvbWV0cnkpIHtcbiAgICAgIGNsb25lLnNldEdlb21ldHJ5KGdlb21ldHJ5LmNsb25lKCkpO1xuICAgIH1cbiAgICB2YXIgc3R5bGUgPSB0aGlzLmdldFN0eWxlKCk7XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICBjbG9uZS5zZXRTdHlsZShzdHlsZSk7XG4gICAgfVxuICAgIHJldHVybiBjbG9uZTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBmZWF0dXJlJ3MgZGVmYXVsdCBnZW9tZXRyeS4gIEEgZmVhdHVyZSBtYXkgaGF2ZSBhbnkgbnVtYmVyIG9mIG5hbWVkXG4gICAqIGdlb21ldHJpZXMuICBUaGUgXCJkZWZhdWx0XCIgZ2VvbWV0cnkgKHRoZSBvbmUgdGhhdCBpcyByZW5kZXJlZCBieSBkZWZhdWx0KSBpc1xuICAgKiBzZXQgd2hlbiBjYWxsaW5nIHtAbGluayBtb2R1bGU6b2wvRmVhdHVyZX5GZWF0dXJlI3NldEdlb21ldHJ5fS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR8dW5kZWZpbmVkfSBUaGUgZGVmYXVsdCBnZW9tZXRyeSBmb3IgdGhlIGZlYXR1cmUuXG4gICAqIEBhcGlcbiAgICogQG9ic2VydmFibGVcbiAgICovXG4gIEZlYXR1cmUucHJvdG90eXBlLmdldEdlb21ldHJ5ID0gZnVuY3Rpb24gZ2V0R2VvbWV0cnkgKCkge1xuICAgIHJldHVybiAoXG4gICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fHVuZGVmaW5lZH0gKi8gKHRoaXMuZ2V0KHRoaXMuZ2VvbWV0cnlOYW1lXykpXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBmZWF0dXJlIGlkZW50aWZpZXIuICBUaGlzIGlzIGEgc3RhYmxlIGlkZW50aWZpZXIgZm9yIHRoZSBmZWF0dXJlIGFuZFxuICAgKiBpcyBlaXRoZXIgc2V0IHdoZW4gcmVhZGluZyBkYXRhIGZyb20gYSByZW1vdGUgc291cmNlIG9yIHNldCBleHBsaWNpdGx5IGJ5XG4gICAqIGNhbGxpbmcge0BsaW5rIG1vZHVsZTpvbC9GZWF0dXJlfkZlYXR1cmUjc2V0SWR9LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8c3RyaW5nfHVuZGVmaW5lZH0gSWQuXG4gICAqIEBhcGlcbiAgICovXG4gIEZlYXR1cmUucHJvdG90eXBlLmdldElkID0gZnVuY3Rpb24gZ2V0SWQgKCkge1xuICAgIHJldHVybiB0aGlzLmlkXztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBuYW1lIG9mIHRoZSBmZWF0dXJlJ3MgZGVmYXVsdCBnZW9tZXRyeS4gIEJ5IGRlZmF1bHQsIHRoZSBkZWZhdWx0XG4gICAqIGdlb21ldHJ5IGlzIG5hbWVkIGBnZW9tZXRyeWAuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gR2V0IHRoZSBwcm9wZXJ0eSBuYW1lIGFzc29jaWF0ZWQgd2l0aCB0aGUgZGVmYXVsdCBnZW9tZXRyeVxuICAgKiAgICAgZm9yIHRoaXMgZmVhdHVyZS5cbiAgICogQGFwaVxuICAgKi9cbiAgRmVhdHVyZS5wcm90b3R5cGUuZ2V0R2VvbWV0cnlOYW1lID0gZnVuY3Rpb24gZ2V0R2VvbWV0cnlOYW1lICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeU5hbWVfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGZlYXR1cmUncyBzdHlsZS4gV2lsbCByZXR1cm4gd2hhdCB3YXMgcHJvdmlkZWQgdG8gdGhlXG4gICAqIHtAbGluayBtb2R1bGU6b2wvRmVhdHVyZX5GZWF0dXJlI3NldFN0eWxlfSBtZXRob2QuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVMaWtlfSBUaGUgZmVhdHVyZSBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgRmVhdHVyZS5wcm90b3R5cGUuZ2V0U3R5bGUgPSBmdW5jdGlvbiBnZXRTdHlsZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3R5bGVfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGZlYXR1cmUncyBzdHlsZSBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUZ1bmN0aW9ufHVuZGVmaW5lZH0gUmV0dXJuIGEgZnVuY3Rpb25cbiAgICogcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHN0eWxlIG9mIHRoaXMgZmVhdHVyZS5cbiAgICogQGFwaVxuICAgKi9cbiAgRmVhdHVyZS5wcm90b3R5cGUuZ2V0U3R5bGVGdW5jdGlvbiA9IGZ1bmN0aW9uIGdldFN0eWxlRnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnN0eWxlRnVuY3Rpb25fO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgRmVhdHVyZS5wcm90b3R5cGUuaGFuZGxlR2VvbWV0cnlDaGFuZ2VfID0gZnVuY3Rpb24gaGFuZGxlR2VvbWV0cnlDaGFuZ2VfICgpIHtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEZlYXR1cmUucHJvdG90eXBlLmhhbmRsZUdlb21ldHJ5Q2hhbmdlZF8gPSBmdW5jdGlvbiBoYW5kbGVHZW9tZXRyeUNoYW5nZWRfICgpIHtcbiAgICBpZiAodGhpcy5nZW9tZXRyeUNoYW5nZUtleV8pIHtcbiAgICAgIHVubGlzdGVuQnlLZXkodGhpcy5nZW9tZXRyeUNoYW5nZUtleV8pO1xuICAgICAgdGhpcy5nZW9tZXRyeUNoYW5nZUtleV8gPSBudWxsO1xuICAgIH1cbiAgICB2YXIgZ2VvbWV0cnkgPSB0aGlzLmdldEdlb21ldHJ5KCk7XG4gICAgaWYgKGdlb21ldHJ5KSB7XG4gICAgICB0aGlzLmdlb21ldHJ5Q2hhbmdlS2V5XyA9IGxpc3RlbihnZW9tZXRyeSxcbiAgICAgICAgRXZlbnRUeXBlLkNIQU5HRSwgdGhpcy5oYW5kbGVHZW9tZXRyeUNoYW5nZV8sIHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBkZWZhdWx0IGdlb21ldHJ5IGZvciB0aGUgZmVhdHVyZS4gIFRoaXMgd2lsbCB1cGRhdGUgdGhlIHByb3BlcnR5XG4gICAqIHdpdGggdGhlIG5hbWUgcmV0dXJuZWQgYnkge0BsaW5rIG1vZHVsZTpvbC9GZWF0dXJlfkZlYXR1cmUjZ2V0R2VvbWV0cnlOYW1lfS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdHx1bmRlZmluZWR9IGdlb21ldHJ5IFRoZSBuZXcgZ2VvbWV0cnkuXG4gICAqIEBhcGlcbiAgICogQG9ic2VydmFibGVcbiAgICovXG4gIEZlYXR1cmUucHJvdG90eXBlLnNldEdlb21ldHJ5ID0gZnVuY3Rpb24gc2V0R2VvbWV0cnkgKGdlb21ldHJ5KSB7XG4gICAgdGhpcy5zZXQodGhpcy5nZW9tZXRyeU5hbWVfLCBnZW9tZXRyeSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc3R5bGUgZm9yIHRoZSBmZWF0dXJlLiAgVGhpcyBjYW4gYmUgYSBzaW5nbGUgc3R5bGUgb2JqZWN0LCBhbiBhcnJheVxuICAgKiBvZiBzdHlsZXMsIG9yIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHJlc29sdXRpb24gYW5kIHJldHVybnMgYW4gYXJyYXkgb2ZcbiAgICogc3R5bGVzLiBJZiBpdCBpcyBgbnVsbGAgdGhlIGZlYXR1cmUgaGFzIG5vIHN0eWxlIChhIGBudWxsYCBzdHlsZSkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUxpa2V9IHN0eWxlIFN0eWxlIGZvciB0aGlzIGZlYXR1cmUuXG4gICAqIEBhcGlcbiAgICogQGZpcmVzIG1vZHVsZTpvbC9ldmVudHMvRXZlbnR+RXZlbnQjZXZlbnQ6Y2hhbmdlXG4gICAqL1xuICBGZWF0dXJlLnByb3RvdHlwZS5zZXRTdHlsZSA9IGZ1bmN0aW9uIHNldFN0eWxlIChzdHlsZSkge1xuICAgIHRoaXMuc3R5bGVfID0gc3R5bGU7XG4gICAgdGhpcy5zdHlsZUZ1bmN0aW9uXyA9ICFzdHlsZSA/IHVuZGVmaW5lZCA6IGNyZWF0ZVN0eWxlRnVuY3Rpb24oc3R5bGUpO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGZlYXR1cmUgaWQuICBUaGUgZmVhdHVyZSBpZCBpcyBjb25zaWRlcmVkIHN0YWJsZSBhbmQgbWF5IGJlIHVzZWQgd2hlblxuICAgKiByZXF1ZXN0aW5nIGZlYXR1cmVzIG9yIGNvbXBhcmluZyBpZGVudGlmaWVycyByZXR1cm5lZCBmcm9tIGEgcmVtb3RlIHNvdXJjZS5cbiAgICogVGhlIGZlYXR1cmUgaWQgY2FuIGJlIHVzZWQgd2l0aCB0aGVcbiAgICoge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yflZlY3RvclNvdXJjZSNnZXRGZWF0dXJlQnlJZH0gbWV0aG9kLlxuICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd8dW5kZWZpbmVkfSBpZCBUaGUgZmVhdHVyZSBpZC5cbiAgICogQGFwaVxuICAgKiBAZmlyZXMgbW9kdWxlOm9sL2V2ZW50cy9FdmVudH5FdmVudCNldmVudDpjaGFuZ2VcbiAgICovXG4gIEZlYXR1cmUucHJvdG90eXBlLnNldElkID0gZnVuY3Rpb24gc2V0SWQgKGlkKSB7XG4gICAgdGhpcy5pZF8gPSBpZDtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBwcm9wZXJ0eSBuYW1lIHRvIGJlIHVzZWQgd2hlbiBnZXR0aW5nIHRoZSBmZWF0dXJlJ3MgZGVmYXVsdCBnZW9tZXRyeS5cbiAgICogV2hlbiBjYWxsaW5nIHtAbGluayBtb2R1bGU6b2wvRmVhdHVyZX5GZWF0dXJlI2dldEdlb21ldHJ5fSwgdGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSB3aXRoXG4gICAqIHRoaXMgbmFtZSB3aWxsIGJlIHJldHVybmVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgcHJvcGVydHkgbmFtZSBvZiB0aGUgZGVmYXVsdCBnZW9tZXRyeS5cbiAgICogQGFwaVxuICAgKi9cbiAgRmVhdHVyZS5wcm90b3R5cGUuc2V0R2VvbWV0cnlOYW1lID0gZnVuY3Rpb24gc2V0R2VvbWV0cnlOYW1lIChuYW1lKSB7XG4gICAgdW5saXN0ZW4oXG4gICAgICB0aGlzLCBnZXRDaGFuZ2VFdmVudFR5cGUodGhpcy5nZW9tZXRyeU5hbWVfKSxcbiAgICAgIHRoaXMuaGFuZGxlR2VvbWV0cnlDaGFuZ2VkXywgdGhpcyk7XG4gICAgdGhpcy5nZW9tZXRyeU5hbWVfID0gbmFtZTtcbiAgICBsaXN0ZW4oXG4gICAgICB0aGlzLCBnZXRDaGFuZ2VFdmVudFR5cGUodGhpcy5nZW9tZXRyeU5hbWVfKSxcbiAgICAgIHRoaXMuaGFuZGxlR2VvbWV0cnlDaGFuZ2VkXywgdGhpcyk7XG4gICAgdGhpcy5oYW5kbGVHZW9tZXRyeUNoYW5nZWRfKCk7XG4gIH07XG5cbiAgcmV0dXJuIEZlYXR1cmU7XG59KEJhc2VPYmplY3QpKTtcblxuXG4vKipcbiAqIENvbnZlcnQgdGhlIHByb3ZpZGVkIG9iamVjdCBpbnRvIGEgZmVhdHVyZSBzdHlsZSBmdW5jdGlvbi4gIEZ1bmN0aW9ucyBwYXNzZWRcbiAqIHRocm91Z2ggdW5jaGFuZ2VkLiAgQXJyYXlzIG9mIFN0eWxlIG9yIHNpbmdsZSBzdHlsZSBvYmplY3RzIHdyYXBwZWRcbiAqIGluIGEgbmV3IGZlYXR1cmUgc3R5bGUgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyFpbXBvcnQoXCIuL3N0eWxlL1N0eWxlLmpzXCIpLlN0eWxlRnVuY3Rpb258IUFycmF5PGltcG9ydChcIi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdD58IWltcG9ydChcIi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdH0gb2JqXG4gKiAgICAgQSBmZWF0dXJlIHN0eWxlIGZ1bmN0aW9uLCBhIHNpbmdsZSBzdHlsZSwgb3IgYW4gYXJyYXkgb2Ygc3R5bGVzLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUZ1bmN0aW9ufSBBIHN0eWxlIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU3R5bGVGdW5jdGlvbihvYmopIHtcbiAgaWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9IGVsc2Uge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHQ+fVxuICAgICAqL1xuICAgIHZhciBzdHlsZXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgc3R5bGVzID0gb2JqO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQodHlwZW9mIC8qKiBAdHlwZSB7P30gKi8gKG9iaikuZ2V0WkluZGV4ID09PSAnZnVuY3Rpb24nLFxuICAgICAgICA0MSk7IC8vIEV4cGVjdGVkIGFuIGBpbXBvcnQoXCIuL3N0eWxlL1N0eWxlLmpzXCIpLlN0eWxlYCBvciBhbiBhcnJheSBvZiBgaW1wb3J0KFwiLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZWBcbiAgICAgIHZhciBzdHlsZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9zdHlsZS9TdHlsZS5qc1wiKS5kZWZhdWx0fSAqLyAob2JqKTtcbiAgICAgIHN0eWxlcyA9IFtzdHlsZV07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgfTtcbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgRmVhdHVyZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmVhdHVyZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvSW1hZ2VCYXNlXG4gKi9cbmltcG9ydCB7YWJzdHJhY3R9IGZyb20gJy4vdXRpbC5qcyc7XG5pbXBvcnQgRXZlbnRUYXJnZXQgZnJvbSAnLi9ldmVudHMvVGFyZ2V0LmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcblxuLyoqXG4gKiBAYWJzdHJhY3RcbiAqL1xudmFyIEltYWdlQmFzZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEV2ZW50VGFyZ2V0KSB7XG4gIGZ1bmN0aW9uIEltYWdlQmFzZShleHRlbnQsIHJlc29sdXRpb24sIHBpeGVsUmF0aW8sIHN0YXRlKSB7XG5cbiAgICBFdmVudFRhcmdldC5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gICAgICovXG4gICAgdGhpcy5leHRlbnQgPSBleHRlbnQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5waXhlbFJhdGlvXyA9IHBpeGVsUmF0aW87XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9JbWFnZVN0YXRlLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuXG4gIH1cblxuICBpZiAoIEV2ZW50VGFyZ2V0ICkgSW1hZ2VCYXNlLl9fcHJvdG9fXyA9IEV2ZW50VGFyZ2V0O1xuICBJbWFnZUJhc2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXZlbnRUYXJnZXQgJiYgRXZlbnRUYXJnZXQucHJvdG90eXBlICk7XG4gIEltYWdlQmFzZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbWFnZUJhc2U7XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIEltYWdlQmFzZS5wcm90b3R5cGUuY2hhbmdlZCA9IGZ1bmN0aW9uIGNoYW5nZWQgKCkge1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudFR5cGUuQ0hBTkdFKTtcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBFeHRlbnQuXG4gICAqL1xuICBJbWFnZUJhc2UucHJvdG90eXBlLmdldEV4dGVudCA9IGZ1bmN0aW9uIGdldEV4dGVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR8SFRNTEltYWdlRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fSBJbWFnZS5cbiAgICovXG4gIEltYWdlQmFzZS5wcm90b3R5cGUuZ2V0SW1hZ2UgPSBmdW5jdGlvbiBnZXRJbWFnZSAoKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gUGl4ZWxSYXRpby5cbiAgICovXG4gIEltYWdlQmFzZS5wcm90b3R5cGUuZ2V0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uIGdldFBpeGVsUmF0aW8gKCkge1xuICAgIHJldHVybiB0aGlzLnBpeGVsUmF0aW9fO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFJlc29sdXRpb24uXG4gICAqL1xuICBJbWFnZUJhc2UucHJvdG90eXBlLmdldFJlc29sdXRpb24gPSBmdW5jdGlvbiBnZXRSZXNvbHV0aW9uICgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ9ICovICh0aGlzLnJlc29sdXRpb24pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL0ltYWdlU3RhdGUuanNcIikuZGVmYXVsdH0gU3RhdGUuXG4gICAqL1xuICBJbWFnZUJhc2UucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24gZ2V0U3RhdGUgKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMb2FkIG5vdCB5ZXQgbG9hZGVkIFVSSS5cbiAgICogQGFic3RyYWN0XG4gICAqL1xuICBJbWFnZUJhc2UucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiBsb2FkICgpIHtcbiAgICBhYnN0cmFjdCgpO1xuICB9O1xuXG4gIHJldHVybiBJbWFnZUJhc2U7XG59KEV2ZW50VGFyZ2V0KSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgSW1hZ2VCYXNlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbWFnZUJhc2UuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL0ltYWdlQ2FudmFzXG4gKi9cbmltcG9ydCBJbWFnZUJhc2UgZnJvbSAnLi9JbWFnZUJhc2UuanMnO1xuaW1wb3J0IEltYWdlU3RhdGUgZnJvbSAnLi9JbWFnZVN0YXRlLmpzJztcblxuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgdG8gdHJpZ2dlciBhc3luY2hyb25vdXMgY2FudmFzIGRyYXdpbmcuICBJdCBpc1xuICogY2FsbGVkIHdpdGggYSBcImRvbmVcIiBjYWxsYmFjayB0aGF0IHNob3VsZCBiZSBjYWxsZWQgd2hlbiBkcmF3aW5nIGlzIGRvbmUuXG4gKiBJZiBhbnkgZXJyb3Igb2NjdXJzIGR1cmluZyBkcmF3aW5nLCB0aGUgXCJkb25lXCIgY2FsbGJhY2sgc2hvdWxkIGJlIGNhbGxlZCB3aXRoXG4gKiB0aGF0IGVycm9yLlxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihmdW5jdGlvbihFcnJvcj0pKX0gTG9hZGVyXG4gKi9cblxuXG52YXIgSW1hZ2VDYW52YXMgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChJbWFnZUJhc2UpIHtcbiAgZnVuY3Rpb24gSW1hZ2VDYW52YXMoZXh0ZW50LCByZXNvbHV0aW9uLCBwaXhlbFJhdGlvLCBjYW52YXMsIG9wdF9sb2FkZXIpIHtcblxuICAgIHZhciBzdGF0ZSA9IG9wdF9sb2FkZXIgIT09IHVuZGVmaW5lZCA/IEltYWdlU3RhdGUuSURMRSA6IEltYWdlU3RhdGUuTE9BREVEO1xuXG4gICAgSW1hZ2VCYXNlLmNhbGwodGhpcywgZXh0ZW50LCByZXNvbHV0aW9uLCBwaXhlbFJhdGlvLCBzdGF0ZSk7XG5cbiAgICAvKipcbiAgICAgKiBPcHRpb25hbCBjYW52YXMgbG9hZGVyIGZ1bmN0aW9uLlxuICAgICAqIEB0eXBlIHs/TG9hZGVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5sb2FkZXJfID0gb3B0X2xvYWRlciAhPT0gdW5kZWZpbmVkID8gb3B0X2xvYWRlciA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmNhbnZhc18gPSBjYW52YXM7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtFcnJvcn1cbiAgICAgKi9cbiAgICB0aGlzLmVycm9yXyA9IG51bGw7XG5cbiAgfVxuXG4gIGlmICggSW1hZ2VCYXNlICkgSW1hZ2VDYW52YXMuX19wcm90b19fID0gSW1hZ2VCYXNlO1xuICBJbWFnZUNhbnZhcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbWFnZUJhc2UgJiYgSW1hZ2VCYXNlLnByb3RvdHlwZSApO1xuICBJbWFnZUNhbnZhcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbWFnZUNhbnZhcztcblxuICAvKipcbiAgICogR2V0IGFueSBlcnJvciBhc3NvY2lhdGVkIHdpdGggYXN5bmNocm9ub3VzIHJlbmRlcmluZy5cbiAgICogQHJldHVybiB7RXJyb3J9IEFueSBlcnJvciB0aGF0IG9jY3VycmVkIGR1cmluZyByZW5kZXJpbmcuXG4gICAqL1xuICBJbWFnZUNhbnZhcy5wcm90b3R5cGUuZ2V0RXJyb3IgPSBmdW5jdGlvbiBnZXRFcnJvciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXJyb3JfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYXN5bmMgZHJhd2luZyBjb21wbGV0ZS5cbiAgICogQHBhcmFtIHtFcnJvcj19IGVyciBBbnkgZXJyb3IgZHVyaW5nIGRyYXdpbmcuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBJbWFnZUNhbnZhcy5wcm90b3R5cGUuaGFuZGxlTG9hZF8gPSBmdW5jdGlvbiBoYW5kbGVMb2FkXyAoZXJyKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgdGhpcy5lcnJvcl8gPSBlcnI7XG4gICAgICB0aGlzLnN0YXRlID0gSW1hZ2VTdGF0ZS5FUlJPUjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGF0ZSA9IEltYWdlU3RhdGUuTE9BREVEO1xuICAgIH1cbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIEltYWdlQ2FudmFzLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gbG9hZCAoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT0gSW1hZ2VTdGF0ZS5JRExFKSB7XG4gICAgICB0aGlzLnN0YXRlID0gSW1hZ2VTdGF0ZS5MT0FESU5HO1xuICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgICB0aGlzLmxvYWRlcl8odGhpcy5oYW5kbGVMb2FkXy5iaW5kKHRoaXMpKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBDYW52YXMgZWxlbWVudC5cbiAgICovXG4gIEltYWdlQ2FudmFzLnByb3RvdHlwZS5nZXRJbWFnZSA9IGZ1bmN0aW9uIGdldEltYWdlICgpIHtcbiAgICByZXR1cm4gdGhpcy5jYW52YXNfO1xuICB9O1xuXG4gIHJldHVybiBJbWFnZUNhbnZhcztcbn0oSW1hZ2VCYXNlKSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgSW1hZ2VDYW52YXM7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUltYWdlQ2FudmFzLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9JbWFnZVN0YXRlXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIElETEU6IDAsXG4gIExPQURJTkc6IDEsXG4gIExPQURFRDogMixcbiAgRVJST1I6IDNcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUltYWdlU3RhdGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL0ltYWdlVGlsZVxuICovXG5pbXBvcnQgVGlsZSBmcm9tICcuL1RpbGUuanMnO1xuaW1wb3J0IFRpbGVTdGF0ZSBmcm9tICcuL1RpbGVTdGF0ZS5qcyc7XG5pbXBvcnQge2NyZWF0ZUNhbnZhc0NvbnRleHQyRH0gZnJvbSAnLi9kb20uanMnO1xuaW1wb3J0IHtsaXN0ZW5PbmNlLCB1bmxpc3RlbkJ5S2V5fSBmcm9tICcuL2V2ZW50cy5qcyc7XG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5cblxudmFyIEltYWdlVGlsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFRpbGUpIHtcbiAgZnVuY3Rpb24gSW1hZ2VUaWxlKHRpbGVDb29yZCwgc3RhdGUsIHNyYywgY3Jvc3NPcmlnaW4sIHRpbGVMb2FkRnVuY3Rpb24sIG9wdF9vcHRpb25zKSB7XG5cbiAgICBUaWxlLmNhbGwodGhpcywgdGlsZUNvb3JkLCBzdGF0ZSwgb3B0X29wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmNyb3NzT3JpZ2luXyA9IGNyb3NzT3JpZ2luO1xuXG4gICAgLyoqXG4gICAgICogSW1hZ2UgVVJJXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5zcmNfID0gc3JjO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlXyA9IG5ldyBJbWFnZSgpO1xuICAgIGlmIChjcm9zc09yaWdpbiAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5pbWFnZV8uY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VMaXN0ZW5lcktleXNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vVGlsZS5qc1wiKS5Mb2FkRnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy50aWxlTG9hZEZ1bmN0aW9uXyA9IHRpbGVMb2FkRnVuY3Rpb247XG5cbiAgfVxuXG4gIGlmICggVGlsZSApIEltYWdlVGlsZS5fX3Byb3RvX18gPSBUaWxlO1xuICBJbWFnZVRpbGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVGlsZSAmJiBUaWxlLnByb3RvdHlwZSApO1xuICBJbWFnZVRpbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW1hZ2VUaWxlO1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgSW1hZ2VUaWxlLnByb3RvdHlwZS5kaXNwb3NlSW50ZXJuYWwgPSBmdW5jdGlvbiBkaXNwb3NlSW50ZXJuYWwgKCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09IFRpbGVTdGF0ZS5MT0FESU5HKSB7XG4gICAgICB0aGlzLnVubGlzdGVuSW1hZ2VfKCk7XG4gICAgICB0aGlzLmltYWdlXyA9IGdldEJsYW5rSW1hZ2UoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaW50ZXJpbVRpbGUpIHtcbiAgICAgIHRoaXMuaW50ZXJpbVRpbGUuZGlzcG9zZSgpO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkFCT1JUO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIFRpbGUucHJvdG90eXBlLmRpc3Bvc2VJbnRlcm5hbC5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIEhUTUwgaW1hZ2UgZWxlbWVudCBmb3IgdGhpcyB0aWxlIChtYXkgYmUgYSBDYW52YXMsIEltYWdlLCBvciBWaWRlbykuXG4gICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fEhUTUxJbWFnZUVsZW1lbnR8SFRNTFZpZGVvRWxlbWVudH0gSW1hZ2UuXG4gICAqIEBhcGlcbiAgICovXG4gIEltYWdlVGlsZS5wcm90b3R5cGUuZ2V0SW1hZ2UgPSBmdW5jdGlvbiBnZXRJbWFnZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW1hZ2VfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgSW1hZ2VUaWxlLnByb3RvdHlwZS5nZXRLZXkgPSBmdW5jdGlvbiBnZXRLZXkgKCkge1xuICAgIHJldHVybiB0aGlzLnNyY187XG4gIH07XG5cbiAgLyoqXG4gICAqIFRyYWNrcyBsb2FkaW5nIG9yIHJlYWQgZXJyb3JzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgSW1hZ2VUaWxlLnByb3RvdHlwZS5oYW5kbGVJbWFnZUVycm9yXyA9IGZ1bmN0aW9uIGhhbmRsZUltYWdlRXJyb3JfICgpIHtcbiAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkVSUk9SO1xuICAgIHRoaXMudW5saXN0ZW5JbWFnZV8oKTtcbiAgICB0aGlzLmltYWdlXyA9IGdldEJsYW5rSW1hZ2UoKTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuICAvKipcbiAgICogVHJhY2tzIHN1Y2Nlc3NmdWwgaW1hZ2UgbG9hZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEltYWdlVGlsZS5wcm90b3R5cGUuaGFuZGxlSW1hZ2VMb2FkXyA9IGZ1bmN0aW9uIGhhbmRsZUltYWdlTG9hZF8gKCkge1xuICAgIHZhciBpbWFnZSA9IC8qKiBAdHlwZSB7SFRNTEltYWdlRWxlbWVudH0gKi8gKHRoaXMuaW1hZ2VfKTtcbiAgICBpZiAoaW1hZ2UubmF0dXJhbFdpZHRoICYmIGltYWdlLm5hdHVyYWxIZWlnaHQpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuTE9BREVEO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkVNUFRZO1xuICAgIH1cbiAgICB0aGlzLnVubGlzdGVuSW1hZ2VfKCk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqIEBhcGlcbiAgICovXG4gIEltYWdlVGlsZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIGxvYWQgKCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09IFRpbGVTdGF0ZS5FUlJPUikge1xuICAgICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5JRExFO1xuICAgICAgdGhpcy5pbWFnZV8gPSBuZXcgSW1hZ2UoKTtcbiAgICAgIGlmICh0aGlzLmNyb3NzT3JpZ2luXyAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmltYWdlXy5jcm9zc09yaWdpbiA9IHRoaXMuY3Jvc3NPcmlnaW5fO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5zdGF0ZSA9PSBUaWxlU3RhdGUuSURMRSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5MT0FESU5HO1xuICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgICB0aGlzLmltYWdlTGlzdGVuZXJLZXlzXyA9IFtcbiAgICAgICAgbGlzdGVuT25jZSh0aGlzLmltYWdlXywgRXZlbnRUeXBlLkVSUk9SLFxuICAgICAgICAgIHRoaXMuaGFuZGxlSW1hZ2VFcnJvcl8sIHRoaXMpLFxuICAgICAgICBsaXN0ZW5PbmNlKHRoaXMuaW1hZ2VfLCBFdmVudFR5cGUuTE9BRCxcbiAgICAgICAgICB0aGlzLmhhbmRsZUltYWdlTG9hZF8sIHRoaXMpXG4gICAgICBdO1xuICAgICAgdGhpcy50aWxlTG9hZEZ1bmN0aW9uXyh0aGlzLCB0aGlzLnNyY18pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRGlzY2FyZHMgZXZlbnQgaGFuZGxlcnMgd2hpY2ggbGlzdGVuIGZvciBsb2FkIGNvbXBsZXRpb24gb3IgZXJyb3JzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgSW1hZ2VUaWxlLnByb3RvdHlwZS51bmxpc3RlbkltYWdlXyA9IGZ1bmN0aW9uIHVubGlzdGVuSW1hZ2VfICgpIHtcbiAgICB0aGlzLmltYWdlTGlzdGVuZXJLZXlzXy5mb3JFYWNoKHVubGlzdGVuQnlLZXkpO1xuICAgIHRoaXMuaW1hZ2VMaXN0ZW5lcktleXNfID0gbnVsbDtcbiAgfTtcblxuICByZXR1cm4gSW1hZ2VUaWxlO1xufShUaWxlKSk7XG5cblxuLyoqXG4gKiBHZXQgYSAxLXBpeGVsIGJsYW5rIGltYWdlLlxuICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR9IEJsYW5rIGltYWdlLlxuICovXG5mdW5jdGlvbiBnZXRCbGFua0ltYWdlKCkge1xuICB2YXIgY3R4ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKDEsIDEpO1xuICBjdHguZmlsbFN0eWxlID0gJ3JnYmEoMCwwLDAsMCknO1xuICBjdHguZmlsbFJlY3QoMCwgMCwgMSwgMSk7XG4gIHJldHVybiBjdHguY2FudmFzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBJbWFnZVRpbGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUltYWdlVGlsZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvS2luZXRpY1xuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogSW1wbGVtZW50YXRpb24gb2YgaW5lcnRpYWwgZGVjZWxlcmF0aW9uIGZvciBtYXAgbW92ZW1lbnQuXG4gKlxuICogQGFwaVxuICovXG52YXIgS2luZXRpYyA9IGZ1bmN0aW9uIEtpbmV0aWMoZGVjYXksIG1pblZlbG9jaXR5LCBkZWxheSkge1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5kZWNheV8gPSBkZWNheTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMubWluVmVsb2NpdHlfID0gbWluVmVsb2NpdHk7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLmRlbGF5XyA9IGRlbGF5O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICovXG4gIHRoaXMucG9pbnRzXyA9IFtdO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5hbmdsZV8gPSAwO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5pbml0aWFsVmVsb2NpdHlfID0gMDtcbn07XG5cbi8qKlxuICogRklYTUUgZW1wdHkgZGVzY3JpcHRpb24gZm9yIGpzZG9jXG4gKi9cbktpbmV0aWMucHJvdG90eXBlLmJlZ2luID0gZnVuY3Rpb24gYmVnaW4gKCkge1xuICB0aGlzLnBvaW50c18ubGVuZ3RoID0gMDtcbiAgdGhpcy5hbmdsZV8gPSAwO1xuICB0aGlzLmluaXRpYWxWZWxvY2l0eV8gPSAwO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqL1xuS2luZXRpYy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlICh4LCB5KSB7XG4gIHRoaXMucG9pbnRzXy5wdXNoKHgsIHksIERhdGUubm93KCkpO1xufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHdlIHNob3VsZCBkbyBraW5ldGljIGFuaW1hdGlvbi5cbiAqL1xuS2luZXRpYy5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gZW5kICgpIHtcbiAgaWYgKHRoaXMucG9pbnRzXy5sZW5ndGggPCA2KSB7XG4gICAgLy8gYXQgbGVhc3QgMiBwb2ludHMgYXJlIHJlcXVpcmVkIChpLmUuIHRoZXJlIG11c3QgYmUgYXQgbGVhc3QgNiBlbGVtZW50c1xuICAgIC8vIGluIHRoZSBhcnJheSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGRlbGF5ID0gRGF0ZS5ub3coKSAtIHRoaXMuZGVsYXlfO1xuICB2YXIgbGFzdEluZGV4ID0gdGhpcy5wb2ludHNfLmxlbmd0aCAtIDM7XG4gIGlmICh0aGlzLnBvaW50c19bbGFzdEluZGV4ICsgMl0gPCBkZWxheSkge1xuICAgIC8vIHRoZSBsYXN0IHRyYWNrZWQgcG9pbnQgaXMgdG9vIG9sZCwgd2hpY2ggbWVhbnMgdGhhdCB0aGUgdXNlciBzdG9wcGVkXG4gICAgLy8gcGFubmluZyBiZWZvcmUgcmVsZWFzaW5nIHRoZSBtYXBcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBnZXQgdGhlIGZpcnN0IHBvaW50IHdoaWNoIHN0aWxsIGZhbGxzIGludG8gdGhlIGRlbGF5IHRpbWVcbiAgdmFyIGZpcnN0SW5kZXggPSBsYXN0SW5kZXggLSAzO1xuICB3aGlsZSAoZmlyc3RJbmRleCA+IDAgJiYgdGhpcy5wb2ludHNfW2ZpcnN0SW5kZXggKyAyXSA+IGRlbGF5KSB7XG4gICAgZmlyc3RJbmRleCAtPSAzO1xuICB9XG5cbiAgdmFyIGR1cmF0aW9uID0gdGhpcy5wb2ludHNfW2xhc3RJbmRleCArIDJdIC0gdGhpcy5wb2ludHNfW2ZpcnN0SW5kZXggKyAyXTtcbiAgLy8gd2UgZG9uJ3Qgd2FudCBhIGR1cmF0aW9uIG9mIDAgKGRpdmlkZSBieSB6ZXJvKVxuICAvLyB3ZSBhbHNvIG1ha2Ugc3VyZSB0aGUgdXNlciBwYW5uZWQgZm9yIGEgZHVyYXRpb24gb2YgYXQgbGVhc3Qgb25lIGZyYW1lXG4gIC8vICgxLzYwcykgdG8gY29tcHV0ZSBzYW5lIGRpc3BsYWNlbWVudCB2YWx1ZXNcbiAgaWYgKGR1cmF0aW9uIDwgMTAwMCAvIDYwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGR4ID0gdGhpcy5wb2ludHNfW2xhc3RJbmRleF0gLSB0aGlzLnBvaW50c19bZmlyc3RJbmRleF07XG4gIHZhciBkeSA9IHRoaXMucG9pbnRzX1tsYXN0SW5kZXggKyAxXSAtIHRoaXMucG9pbnRzX1tmaXJzdEluZGV4ICsgMV07XG4gIHRoaXMuYW5nbGVfID0gTWF0aC5hdGFuMihkeSwgZHgpO1xuICB0aGlzLmluaXRpYWxWZWxvY2l0eV8gPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpIC8gZHVyYXRpb247XG4gIHJldHVybiB0aGlzLmluaXRpYWxWZWxvY2l0eV8gPiB0aGlzLm1pblZlbG9jaXR5Xztcbn07XG5cbi8qKlxuICogQHJldHVybiB7bnVtYmVyfSBUb3RhbCBkaXN0YW5jZSB0cmF2ZWxsZWQgKHBpeGVscykuXG4gKi9cbktpbmV0aWMucHJvdG90eXBlLmdldERpc3RhbmNlID0gZnVuY3Rpb24gZ2V0RGlzdGFuY2UgKCkge1xuICByZXR1cm4gKHRoaXMubWluVmVsb2NpdHlfIC0gdGhpcy5pbml0aWFsVmVsb2NpdHlfKSAvIHRoaXMuZGVjYXlfO1xufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuZ2xlIG9mIHRoZSBraW5ldGljIHBhbm5pbmcgYW5pbWF0aW9uIChyYWRpYW5zKS5cbiAqL1xuS2luZXRpYy5wcm90b3R5cGUuZ2V0QW5nbGUgPSBmdW5jdGlvbiBnZXRBbmdsZSAoKSB7XG4gIHJldHVybiB0aGlzLmFuZ2xlXztcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEtpbmV0aWM7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUtpbmV0aWMuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL0xheWVyVHlwZVxuICovXG5cbi8qKlxuICogQSBsYXllciB0eXBlIHVzZWQgd2hlbiBjcmVhdGluZyBsYXllciByZW5kZXJlcnMuXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIElNQUdFOiAnSU1BR0UnLFxuICBUSUxFOiAnVElMRScsXG4gIFZFQ1RPUl9USUxFOiAnVkVDVE9SX1RJTEUnLFxuICBWRUNUT1I6ICdWRUNUT1InXG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1MYXllclR5cGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL01hcFxuICovXG5pbXBvcnQgUGx1Z2dhYmxlTWFwIGZyb20gJy4vUGx1Z2dhYmxlTWFwLmpzJztcbmltcG9ydCB7ZGVmYXVsdHMgYXMgZGVmYXVsdENvbnRyb2xzfSBmcm9tICcuL2NvbnRyb2wvdXRpbC5qcyc7XG5pbXBvcnQge2RlZmF1bHRzIGFzIGRlZmF1bHRJbnRlcmFjdGlvbnN9IGZyb20gJy4vaW50ZXJhY3Rpb24uanMnO1xuaW1wb3J0IHthc3NpZ259IGZyb20gJy4vb2JqLmpzJztcbmltcG9ydCBDYW52YXNJbWFnZUxheWVyUmVuZGVyZXIgZnJvbSAnLi9yZW5kZXJlci9jYW52YXMvSW1hZ2VMYXllci5qcyc7XG5pbXBvcnQgQ2FudmFzTWFwUmVuZGVyZXIgZnJvbSAnLi9yZW5kZXJlci9jYW52YXMvTWFwLmpzJztcbmltcG9ydCBDYW52YXNUaWxlTGF5ZXJSZW5kZXJlciBmcm9tICcuL3JlbmRlcmVyL2NhbnZhcy9UaWxlTGF5ZXIuanMnO1xuaW1wb3J0IENhbnZhc1ZlY3RvckxheWVyUmVuZGVyZXIgZnJvbSAnLi9yZW5kZXJlci9jYW52YXMvVmVjdG9yTGF5ZXIuanMnO1xuaW1wb3J0IENhbnZhc1ZlY3RvclRpbGVMYXllclJlbmRlcmVyIGZyb20gJy4vcmVuZGVyZXIvY2FudmFzL1ZlY3RvclRpbGVMYXllci5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogVGhlIG1hcCBpcyB0aGUgY29yZSBjb21wb25lbnQgb2YgT3BlbkxheWVycy4gRm9yIGEgbWFwIHRvIHJlbmRlciwgYSB2aWV3LFxuICogb25lIG9yIG1vcmUgbGF5ZXJzLCBhbmQgYSB0YXJnZXQgY29udGFpbmVyIGFyZSBuZWVkZWQ6XG4gKlxuICogICAgIGltcG9ydCBNYXAgZnJvbSAnb2wvTWFwJztcbiAqICAgICBpbXBvcnQgVmlldyBmcm9tICdvbC9WaWV3JztcbiAqICAgICBpbXBvcnQgVGlsZUxheWVyIGZyb20gJ29sL2xheWVyL1RpbGUnO1xuICogICAgIGltcG9ydCBPU00gZnJvbSAnb2wvc291cmNlL09TTSc7XG4gKlxuICogICAgIHZhciBtYXAgPSBuZXcgTWFwKHtcbiAqICAgICAgIHZpZXc6IG5ldyBWaWV3KHtcbiAqICAgICAgICAgY2VudGVyOiBbMCwgMF0sXG4gKiAgICAgICAgIHpvb206IDFcbiAqICAgICAgIH0pLFxuICogICAgICAgbGF5ZXJzOiBbXG4gKiAgICAgICAgIG5ldyBUaWxlTGF5ZXIoe1xuICogICAgICAgICAgIHNvdXJjZTogbmV3IE9TTSgpXG4gKiAgICAgICAgIH0pXG4gKiAgICAgICBdLFxuICogICAgICAgdGFyZ2V0OiAnbWFwJ1xuICogICAgIH0pO1xuICpcbiAqIFRoZSBhYm92ZSBzbmlwcGV0IGNyZWF0ZXMgYSBtYXAgdXNpbmcgYSB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL1RpbGV9IHRvXG4gKiBkaXNwbGF5IHtAbGluayBtb2R1bGU6b2wvc291cmNlL09TTX5PU019IE9TTSBkYXRhIGFuZCByZW5kZXIgaXQgdG8gYSBET01cbiAqIGVsZW1lbnQgd2l0aCB0aGUgaWQgYG1hcGAuXG4gKlxuICogVGhlIGNvbnN0cnVjdG9yIHBsYWNlcyBhIHZpZXdwb3J0IGNvbnRhaW5lciAod2l0aCBDU1MgY2xhc3MgbmFtZVxuICogYG9sLXZpZXdwb3J0YCkgaW4gdGhlIHRhcmdldCBlbGVtZW50IChzZWUgYGdldFZpZXdwb3J0KClgKSwgYW5kIHRoZW4gdHdvXG4gKiBmdXJ0aGVyIGVsZW1lbnRzIHdpdGhpbiB0aGUgdmlld3BvcnQ6IG9uZSB3aXRoIENTUyBjbGFzcyBuYW1lXG4gKiBgb2wtb3ZlcmxheWNvbnRhaW5lci1zdG9wZXZlbnRgIGZvciBjb250cm9scyBhbmQgc29tZSBvdmVybGF5cywgYW5kIG9uZSB3aXRoXG4gKiBDU1MgY2xhc3MgbmFtZSBgb2wtb3ZlcmxheWNvbnRhaW5lcmAgZm9yIG90aGVyIG92ZXJsYXlzIChzZWUgdGhlIGBzdG9wRXZlbnRgXG4gKiBvcHRpb24gb2Yge0BsaW5rIG1vZHVsZTpvbC9PdmVybGF5fk92ZXJsYXl9IGZvciB0aGUgZGlmZmVyZW5jZSkuIFRoZSBtYXBcbiAqIGl0c2VsZiBpcyBwbGFjZWQgaW4gYSBmdXJ0aGVyIGVsZW1lbnQgd2l0aGluIHRoZSB2aWV3cG9ydC5cbiAqXG4gKiBMYXllcnMgYXJlIHN0b3JlZCBhcyBhIHtAbGluayBtb2R1bGU6b2wvQ29sbGVjdGlvbn5Db2xsZWN0aW9ufSBpblxuICogbGF5ZXJHcm91cHMuIEEgdG9wLWxldmVsIGdyb3VwIGlzIHByb3ZpZGVkIGJ5IHRoZSBsaWJyYXJ5LiBUaGlzIGlzIHdoYXQgaXNcbiAqIGFjY2Vzc2VkIGJ5IGBnZXRMYXllckdyb3VwYCBhbmQgYHNldExheWVyR3JvdXBgLiBMYXllcnMgZW50ZXJlZCBpbiB0aGVcbiAqIG9wdGlvbnMgYXJlIGFkZGVkIHRvIHRoaXMgZ3JvdXAsIGFuZCBgYWRkTGF5ZXJgIGFuZCBgcmVtb3ZlTGF5ZXJgIGNoYW5nZSB0aGVcbiAqIGxheWVyIGNvbGxlY3Rpb24gaW4gdGhlIGdyb3VwLiBgZ2V0TGF5ZXJzYCBpcyBhIGNvbnZlbmllbmNlIGZ1bmN0aW9uIGZvclxuICogYGdldExheWVyR3JvdXAoKS5nZXRMYXllcnMoKWAuIE5vdGUgdGhhdCB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL0dyb3Vwfkdyb3VwfVxuICogaXMgYSBzdWJjbGFzcyBvZiB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL0Jhc2V9LCBzbyBsYXllcnMgZW50ZXJlZCBpbiB0aGVcbiAqIG9wdGlvbnMgb3IgYWRkZWQgd2l0aCBgYWRkTGF5ZXJgIGNhbiBiZSBncm91cHMsIHdoaWNoIGNhbiBjb250YWluIGZ1cnRoZXJcbiAqIGdyb3VwcywgYW5kIHNvIG9uLlxuICpcbiAqIEBmaXJlcyBpbXBvcnQoXCIuL01hcEJyb3dzZXJFdmVudC5qc1wiKS5NYXBCcm93c2VyRXZlbnRcbiAqIEBmaXJlcyBpbXBvcnQoXCIuL01hcEV2ZW50LmpzXCIpLk1hcEV2ZW50XG4gKiBAZmlyZXMgbW9kdWxlOm9sL3JlbmRlci9FdmVudH5SZW5kZXJFdmVudCNwb3N0Y29tcG9zZVxuICogQGZpcmVzIG1vZHVsZTpvbC9yZW5kZXIvRXZlbnR+UmVuZGVyRXZlbnQjcHJlY29tcG9zZVxuICogQGFwaVxuICovXG52YXIgTWFwID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoUGx1Z2dhYmxlTWFwKSB7XG4gIGZ1bmN0aW9uIE1hcChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IGFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgaWYgKCFvcHRpb25zLmNvbnRyb2xzKSB7XG4gICAgICBvcHRpb25zLmNvbnRyb2xzID0gZGVmYXVsdENvbnRyb2xzKCk7XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy5pbnRlcmFjdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMuaW50ZXJhY3Rpb25zID0gZGVmYXVsdEludGVyYWN0aW9ucygpO1xuICAgIH1cblxuICAgIFBsdWdnYWJsZU1hcC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKCBQbHVnZ2FibGVNYXAgKSBNYXAuX19wcm90b19fID0gUGx1Z2dhYmxlTWFwO1xuICBNYXAucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUGx1Z2dhYmxlTWFwICYmIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUgKTtcbiAgTWFwLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1hcDtcblxuICBNYXAucHJvdG90eXBlLmNyZWF0ZVJlbmRlcmVyID0gZnVuY3Rpb24gY3JlYXRlUmVuZGVyZXIgKCkge1xuICAgIHZhciByZW5kZXJlciA9IG5ldyBDYW52YXNNYXBSZW5kZXJlcih0aGlzKTtcbiAgICByZW5kZXJlci5yZWdpc3RlckxheWVyUmVuZGVyZXJzKFtcbiAgICAgIENhbnZhc0ltYWdlTGF5ZXJSZW5kZXJlcixcbiAgICAgIENhbnZhc1RpbGVMYXllclJlbmRlcmVyLFxuICAgICAgQ2FudmFzVmVjdG9yTGF5ZXJSZW5kZXJlcixcbiAgICAgIENhbnZhc1ZlY3RvclRpbGVMYXllclJlbmRlcmVyXG4gICAgXSk7XG4gICAgcmV0dXJuIHJlbmRlcmVyO1xuICB9O1xuXG4gIHJldHVybiBNYXA7XG59KFBsdWdnYWJsZU1hcCkpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IE1hcDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWFwLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9NYXBCcm93c2VyRXZlbnRcbiAqL1xuaW1wb3J0IE1hcEV2ZW50IGZyb20gJy4vTWFwRXZlbnQuanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEV2ZW50cyBlbWl0dGVkIGFzIG1hcCBicm93c2VyIGV2ZW50cyBhcmUgaW5zdGFuY2VzIG9mIHRoaXMgdHlwZS5cbiAqIFNlZSB7QGxpbmsgbW9kdWxlOm9sL1BsdWdnYWJsZU1hcH5QbHVnZ2FibGVNYXB9IGZvciB3aGljaCBldmVudHMgdHJpZ2dlciBhIG1hcCBicm93c2VyIGV2ZW50LlxuICovXG52YXIgTWFwQnJvd3NlckV2ZW50ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoTWFwRXZlbnQpIHtcbiAgZnVuY3Rpb24gTWFwQnJvd3NlckV2ZW50KHR5cGUsIG1hcCwgYnJvd3NlckV2ZW50LCBvcHRfZHJhZ2dpbmcsIG9wdF9mcmFtZVN0YXRlKSB7XG5cbiAgICBNYXBFdmVudC5jYWxsKHRoaXMsIHR5cGUsIG1hcCwgb3B0X2ZyYW1lU3RhdGUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9yaWdpbmFsIGJyb3dzZXIgZXZlbnQuXG4gICAgICogQGNvbnN0XG4gICAgICogQHR5cGUge0V2ZW50fVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLm9yaWdpbmFsRXZlbnQgPSBicm93c2VyRXZlbnQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWFwIHBpeGVsIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydCBjb3JyZXNwb25kaW5nIHRvIHRoZSBvcmlnaW5hbCBicm93c2VyIGV2ZW50LlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL3BpeGVsLmpzXCIpLlBpeGVsfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLnBpeGVsID0gbWFwLmdldEV2ZW50UGl4ZWwoYnJvd3NlckV2ZW50KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb29yZGluYXRlIGluIHZpZXcgcHJvamVjdGlvbiBjb3JyZXNwb25kaW5nIHRvIHRoZSBvcmlnaW5hbCBicm93c2VyIGV2ZW50LlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5jb29yZGluYXRlID0gbWFwLmdldENvb3JkaW5hdGVGcm9tUGl4ZWwodGhpcy5waXhlbCk7XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgdGhlIG1hcCBpcyBjdXJyZW50bHkgYmVpbmcgZHJhZ2dlZC4gT25seSBzZXQgZm9yXG4gICAgICogYFBPSU5URVJEUkFHYCBhbmQgYFBPSU5URVJNT1ZFYCBldmVudHMuIERlZmF1bHQgaXMgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLmRyYWdnaW5nID0gb3B0X2RyYWdnaW5nICE9PSB1bmRlZmluZWQgPyBvcHRfZHJhZ2dpbmcgOiBmYWxzZTtcblxuICB9XG5cbiAgaWYgKCBNYXBFdmVudCApIE1hcEJyb3dzZXJFdmVudC5fX3Byb3RvX18gPSBNYXBFdmVudDtcbiAgTWFwQnJvd3NlckV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1hcEV2ZW50ICYmIE1hcEV2ZW50LnByb3RvdHlwZSApO1xuICBNYXBCcm93c2VyRXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWFwQnJvd3NlckV2ZW50O1xuXG4gIC8qKlxuICAgKiBQcmV2ZW50cyB0aGUgZGVmYXVsdCBicm93c2VyIGFjdGlvbi5cbiAgICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9ldmVudC5wcmV2ZW50RGVmYXVsdC5cbiAgICogQG92ZXJyaWRlXG4gICAqIEBhcGlcbiAgICovXG4gIE1hcEJyb3dzZXJFdmVudC5wcm90b3R5cGUucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdCAoKSB7XG4gICAgTWFwRXZlbnQucHJvdG90eXBlLnByZXZlbnREZWZhdWx0LmNhbGwodGhpcyk7XG4gICAgdGhpcy5vcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByZXZlbnRzIGZ1cnRoZXIgcHJvcGFnYXRpb24gb2YgdGhlIGN1cnJlbnQgZXZlbnQuXG4gICAqIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvZXZlbnQuc3RvcFByb3BhZ2F0aW9uLlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGFwaVxuICAgKi9cbiAgTWFwQnJvd3NlckV2ZW50LnByb3RvdHlwZS5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24gKCkge1xuICAgIE1hcEV2ZW50LnByb3RvdHlwZS5zdG9wUHJvcGFnYXRpb24uY2FsbCh0aGlzKTtcbiAgICB0aGlzLm9yaWdpbmFsRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH07XG5cbiAgcmV0dXJuIE1hcEJyb3dzZXJFdmVudDtcbn0oTWFwRXZlbnQpKTtcblxuXG5leHBvcnQgZGVmYXVsdCBNYXBCcm93c2VyRXZlbnQ7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1hcEJyb3dzZXJFdmVudC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvTWFwQnJvd3NlckV2ZW50SGFuZGxlclxuICovXG5pbXBvcnQge0RFVklDRV9QSVhFTF9SQVRJT30gZnJvbSAnLi9oYXMuanMnO1xuaW1wb3J0IE1hcEJyb3dzZXJFdmVudFR5cGUgZnJvbSAnLi9NYXBCcm93c2VyRXZlbnRUeXBlLmpzJztcbmltcG9ydCBNYXBCcm93c2VyUG9pbnRlckV2ZW50IGZyb20gJy4vTWFwQnJvd3NlclBvaW50ZXJFdmVudC5qcyc7XG5pbXBvcnQge2xpc3RlbiwgdW5saXN0ZW5CeUtleX0gZnJvbSAnLi9ldmVudHMuanMnO1xuaW1wb3J0IEV2ZW50VGFyZ2V0IGZyb20gJy4vZXZlbnRzL1RhcmdldC5qcyc7XG5pbXBvcnQgUG9pbnRlckV2ZW50VHlwZSBmcm9tICcuL3BvaW50ZXIvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBQb2ludGVyRXZlbnRIYW5kbGVyIGZyb20gJy4vcG9pbnRlci9Qb2ludGVyRXZlbnRIYW5kbGVyLmpzJztcblxudmFyIE1hcEJyb3dzZXJFdmVudEhhbmRsZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChFdmVudFRhcmdldCkge1xuICBmdW5jdGlvbiBNYXBCcm93c2VyRXZlbnRIYW5kbGVyKG1hcCwgbW92ZVRvbGVyYW5jZSkge1xuXG4gICAgRXZlbnRUYXJnZXQuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIGVsZW1lbnQgdGhhdCB3ZSB3aWxsIGxpc3RlbiB0byB0aGUgcmVhbCBldmVudHMgb24uXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vUGx1Z2dhYmxlTWFwLmpzXCIpLmRlZmF1bHR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLm1hcF8gPSBtYXA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7YW55fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jbGlja1RpbWVvdXRJZF87XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZHJhZ2dpbmdfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IUFycmF5PGltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleT59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmRyYWdMaXN0ZW5lcktleXNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5tb3ZlVG9sZXJhbmNlXyA9IG1vdmVUb2xlcmFuY2UgP1xuICAgICAgbW92ZVRvbGVyYW5jZSAqIERFVklDRV9QSVhFTF9SQVRJTyA6IERFVklDRV9QSVhFTF9SQVRJTztcblxuICAgIC8qKlxuICAgICAqIFRoZSBtb3N0IHJlY2VudCBcImRvd25cIiB0eXBlIGV2ZW50IChvciBudWxsIGlmIG5vbmUgaGF2ZSBvY2N1cnJlZCkuXG4gICAgICogU2V0IG9uIHBvaW50ZXJkb3duLlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL3BvaW50ZXIvUG9pbnRlckV2ZW50LmpzXCIpLmRlZmF1bHR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmRvd25fID0gbnVsbDtcblxuICAgIHZhciBlbGVtZW50ID0gdGhpcy5tYXBfLmdldFZpZXdwb3J0KCk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5hY3RpdmVQb2ludGVyc18gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgeyFPYmplY3Q8bnVtYmVyLCBib29sZWFuPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudHJhY2tlZFRvdWNoZXNfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBoYW5kbGVyIHdoaWNoIGdlbmVyYXRlcyBwb2ludGVyIGV2ZW50cyBmb3JcbiAgICAgKiB0aGUgdmlld3BvcnQgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtQb2ludGVyRXZlbnRIYW5kbGVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5wb2ludGVyRXZlbnRIYW5kbGVyXyA9IG5ldyBQb2ludGVyRXZlbnRIYW5kbGVyKGVsZW1lbnQpO1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgaGFuZGxlciB3aGljaCBnZW5lcmF0ZXMgcG9pbnRlciBldmVudHMgZm9yXG4gICAgICogdGhlIGRvY3VtZW50ICh1c2VkIHdoZW4gZHJhZ2dpbmcpLlxuICAgICAqXG4gICAgICogQHR5cGUge1BvaW50ZXJFdmVudEhhbmRsZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmRvY3VtZW50UG9pbnRlckV2ZW50SGFuZGxlcl8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXl9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnBvaW50ZXJkb3duTGlzdGVuZXJLZXlfID0gbGlzdGVuKHRoaXMucG9pbnRlckV2ZW50SGFuZGxlcl8sXG4gICAgICBQb2ludGVyRXZlbnRUeXBlLlBPSU5URVJET1dOLFxuICAgICAgdGhpcy5oYW5kbGVQb2ludGVyRG93bl8sIHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXl9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnJlbGF5ZWRMaXN0ZW5lcktleV8gPSBsaXN0ZW4odGhpcy5wb2ludGVyRXZlbnRIYW5kbGVyXyxcbiAgICAgIFBvaW50ZXJFdmVudFR5cGUuUE9JTlRFUk1PVkUsXG4gICAgICB0aGlzLnJlbGF5RXZlbnRfLCB0aGlzKTtcblxuICB9XG5cbiAgaWYgKCBFdmVudFRhcmdldCApIE1hcEJyb3dzZXJFdmVudEhhbmRsZXIuX19wcm90b19fID0gRXZlbnRUYXJnZXQ7XG4gIE1hcEJyb3dzZXJFdmVudEhhbmRsZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXZlbnRUYXJnZXQgJiYgRXZlbnRUYXJnZXQucHJvdG90eXBlICk7XG4gIE1hcEJyb3dzZXJFdmVudEhhbmRsZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWFwQnJvd3NlckV2ZW50SGFuZGxlcjtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3BvaW50ZXIvUG9pbnRlckV2ZW50LmpzXCIpLmRlZmF1bHR9IHBvaW50ZXJFdmVudCBQb2ludGVyXG4gICAqIGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTWFwQnJvd3NlckV2ZW50SGFuZGxlci5wcm90b3R5cGUuZW11bGF0ZUNsaWNrXyA9IGZ1bmN0aW9uIGVtdWxhdGVDbGlja18gKHBvaW50ZXJFdmVudCkge1xuICAgIHZhciBuZXdFdmVudCA9IG5ldyBNYXBCcm93c2VyUG9pbnRlckV2ZW50KFxuICAgICAgTWFwQnJvd3NlckV2ZW50VHlwZS5DTElDSywgdGhpcy5tYXBfLCBwb2ludGVyRXZlbnQpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXdFdmVudCk7XG4gICAgaWYgKHRoaXMuY2xpY2tUaW1lb3V0SWRfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGRvdWJsZS1jbGlja1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY2xpY2tUaW1lb3V0SWRfKTtcbiAgICAgIHRoaXMuY2xpY2tUaW1lb3V0SWRfID0gdW5kZWZpbmVkO1xuICAgICAgbmV3RXZlbnQgPSBuZXcgTWFwQnJvd3NlclBvaW50ZXJFdmVudChcbiAgICAgICAgTWFwQnJvd3NlckV2ZW50VHlwZS5EQkxDTElDSywgdGhpcy5tYXBfLCBwb2ludGVyRXZlbnQpO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY2xpY2tcbiAgICAgIHRoaXMuY2xpY2tUaW1lb3V0SWRfID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jbGlja1RpbWVvdXRJZF8gPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBuZXdFdmVudCA9IG5ldyBNYXBCcm93c2VyUG9pbnRlckV2ZW50KFxuICAgICAgICAgIE1hcEJyb3dzZXJFdmVudFR5cGUuU0lOR0xFQ0xJQ0ssIHRoaXMubWFwXywgcG9pbnRlckV2ZW50KTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcbiAgICAgIH0uYmluZCh0aGlzKSwgMjUwKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEtlZXBzIHRyYWNrIG9uIGhvdyBtYW55IHBvaW50ZXJzIGFyZSBjdXJyZW50bHkgYWN0aXZlLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vcG9pbnRlci9Qb2ludGVyRXZlbnQuanNcIikuZGVmYXVsdH0gcG9pbnRlckV2ZW50IFBvaW50ZXJcbiAgICogZXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBNYXBCcm93c2VyRXZlbnRIYW5kbGVyLnByb3RvdHlwZS51cGRhdGVBY3RpdmVQb2ludGVyc18gPSBmdW5jdGlvbiB1cGRhdGVBY3RpdmVQb2ludGVyc18gKHBvaW50ZXJFdmVudCkge1xuICAgIHZhciBldmVudCA9IHBvaW50ZXJFdmVudDtcblxuICAgIGlmIChldmVudC50eXBlID09IE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUlVQIHx8XG4gICAgICAgIGV2ZW50LnR5cGUgPT0gTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSQ0FOQ0VMKSB7XG4gICAgICBkZWxldGUgdGhpcy50cmFja2VkVG91Y2hlc19bZXZlbnQucG9pbnRlcklkXTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50LnR5cGUgPT0gTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSRE9XTikge1xuICAgICAgdGhpcy50cmFja2VkVG91Y2hlc19bZXZlbnQucG9pbnRlcklkXSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlUG9pbnRlcnNfID0gT2JqZWN0LmtleXModGhpcy50cmFja2VkVG91Y2hlc18pLmxlbmd0aDtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3BvaW50ZXIvUG9pbnRlckV2ZW50LmpzXCIpLmRlZmF1bHR9IHBvaW50ZXJFdmVudCBQb2ludGVyXG4gICAqIGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTWFwQnJvd3NlckV2ZW50SGFuZGxlci5wcm90b3R5cGUuaGFuZGxlUG9pbnRlclVwXyA9IGZ1bmN0aW9uIGhhbmRsZVBvaW50ZXJVcF8gKHBvaW50ZXJFdmVudCkge1xuICAgIHRoaXMudXBkYXRlQWN0aXZlUG9pbnRlcnNfKHBvaW50ZXJFdmVudCk7XG4gICAgdmFyIG5ld0V2ZW50ID0gbmV3IE1hcEJyb3dzZXJQb2ludGVyRXZlbnQoXG4gICAgICBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJVUCwgdGhpcy5tYXBfLCBwb2ludGVyRXZlbnQpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXdFdmVudCk7XG5cbiAgICAvLyBXZSBlbXVsYXRlIGNsaWNrIGV2ZW50cyBvbiBsZWZ0IG1vdXNlIGJ1dHRvbiBjbGljaywgdG91Y2ggY29udGFjdCwgYW5kIHBlblxuICAgIC8vIGNvbnRhY3QuIGlzTW91c2VBY3Rpb25CdXR0b24gcmV0dXJucyB0cnVlIGluIHRoZXNlIGNhc2VzIChldnQuYnV0dG9uIGlzIHNldFxuICAgIC8vIHRvIDApLlxuICAgIC8vIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9wb2ludGVyZXZlbnRzLyNidXR0b24tc3RhdGVzXG4gICAgLy8gV2Ugb25seSBmaXJlIGNsaWNrLCBzaW5nbGVjbGljaywgYW5kIGRvdWJsZWNsaWNrIGlmIG5vYm9keSBoYXMgY2FsbGVkXG4gICAgLy8gZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCkgb3IgZXZlbnQucHJldmVudERlZmF1bHQoKS5cbiAgICBpZiAoIW5ld0V2ZW50LnByb3BhZ2F0aW9uU3RvcHBlZCAmJiAhdGhpcy5kcmFnZ2luZ18gJiYgdGhpcy5pc01vdXNlQWN0aW9uQnV0dG9uXyhwb2ludGVyRXZlbnQpKSB7XG4gICAgICB0aGlzLmVtdWxhdGVDbGlja18odGhpcy5kb3duXyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYWN0aXZlUG9pbnRlcnNfID09PSAwKSB7XG4gICAgICB0aGlzLmRyYWdMaXN0ZW5lcktleXNfLmZvckVhY2godW5saXN0ZW5CeUtleSk7XG4gICAgICB0aGlzLmRyYWdMaXN0ZW5lcktleXNfLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLmRyYWdnaW5nXyA9IGZhbHNlO1xuICAgICAgdGhpcy5kb3duXyA9IG51bGw7XG4gICAgICB0aGlzLmRvY3VtZW50UG9pbnRlckV2ZW50SGFuZGxlcl8uZGlzcG9zZSgpO1xuICAgICAgdGhpcy5kb2N1bWVudFBvaW50ZXJFdmVudEhhbmRsZXJfID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wb2ludGVyL1BvaW50ZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBwb2ludGVyRXZlbnQgUG9pbnRlclxuICAgKiBldmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIGxlZnQgbW91c2UgYnV0dG9uIHdhcyBwcmVzc2VkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTWFwQnJvd3NlckV2ZW50SGFuZGxlci5wcm90b3R5cGUuaXNNb3VzZUFjdGlvbkJ1dHRvbl8gPSBmdW5jdGlvbiBpc01vdXNlQWN0aW9uQnV0dG9uXyAocG9pbnRlckV2ZW50KSB7XG4gICAgcmV0dXJuIHBvaW50ZXJFdmVudC5idXR0b24gPT09IDA7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wb2ludGVyL1BvaW50ZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBwb2ludGVyRXZlbnQgUG9pbnRlclxuICAgKiBldmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIE1hcEJyb3dzZXJFdmVudEhhbmRsZXIucHJvdG90eXBlLmhhbmRsZVBvaW50ZXJEb3duXyA9IGZ1bmN0aW9uIGhhbmRsZVBvaW50ZXJEb3duXyAocG9pbnRlckV2ZW50KSB7XG4gICAgdGhpcy51cGRhdGVBY3RpdmVQb2ludGVyc18ocG9pbnRlckV2ZW50KTtcbiAgICB2YXIgbmV3RXZlbnQgPSBuZXcgTWFwQnJvd3NlclBvaW50ZXJFdmVudChcbiAgICAgIE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUkRPV04sIHRoaXMubWFwXywgcG9pbnRlckV2ZW50KTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuXG4gICAgdGhpcy5kb3duXyA9IHBvaW50ZXJFdmVudDtcblxuICAgIGlmICh0aGlzLmRyYWdMaXN0ZW5lcktleXNfLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLyogU2V0IHVwIGEgcG9pbnRlciBldmVudCBoYW5kbGVyIG9uIHRoZSBgZG9jdW1lbnRgLFxuICAgICAgICogd2hpY2ggaXMgcmVxdWlyZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBtb3ZlZCBvdXRzaWRlXG4gICAgICAgKiB0aGUgdmlld3BvcnQgd2hlbiBkcmFnZ2luZy5cbiAgICAgICAqL1xuICAgICAgdGhpcy5kb2N1bWVudFBvaW50ZXJFdmVudEhhbmRsZXJfID1cbiAgICAgICAgICBuZXcgUG9pbnRlckV2ZW50SGFuZGxlcihkb2N1bWVudCk7XG5cbiAgICAgIHRoaXMuZHJhZ0xpc3RlbmVyS2V5c18ucHVzaChcbiAgICAgICAgbGlzdGVuKHRoaXMuZG9jdW1lbnRQb2ludGVyRXZlbnRIYW5kbGVyXyxcbiAgICAgICAgICBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJNT1ZFLFxuICAgICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlck1vdmVfLCB0aGlzKSxcbiAgICAgICAgbGlzdGVuKHRoaXMuZG9jdW1lbnRQb2ludGVyRXZlbnRIYW5kbGVyXyxcbiAgICAgICAgICBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJVUCxcbiAgICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJVcF8sIHRoaXMpLFxuICAgICAgICAvKiBOb3RlIHRoYXQgdGhlIGxpc3RlbmVyIGZvciBgcG9pbnRlcmNhbmNlbCBpcyBzZXQgdXAgb25cbiAgICAgICAgICogYHBvaW50ZXJFdmVudEhhbmRsZXJfYCBhbmQgbm90IGBkb2N1bWVudFBvaW50ZXJFdmVudEhhbmRsZXJfYCBsaWtlXG4gICAgICAgICAqIHRoZSBgcG9pbnRlcnVwYCBhbmQgYHBvaW50ZXJtb3ZlYCBsaXN0ZW5lcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSByZWFzb24gZm9yIHRoaXMgaXMgdGhlIGZvbGxvd2luZzogYFRvdWNoU291cmNlLnZhY3V1bVRvdWNoZXNfKClgXG4gICAgICAgICAqIGlzc3VlcyBgcG9pbnRlcmNhbmNlbGAgZXZlbnRzLCB3aGVuIHRoZXJlIHdhcyBubyBgdG91Y2hlbmRgIGZvciBhXG4gICAgICAgICAqIGB0b3VjaHN0YXJ0YC4gTm93LCBsZXQncyBzYXkgYSBmaXJzdCBgdG91Y2hzdGFydGAgaXMgcmVnaXN0ZXJlZCBvblxuICAgICAgICAgKiBgcG9pbnRlckV2ZW50SGFuZGxlcl9gLiBUaGUgYGRvY3VtZW50UG9pbnRlckV2ZW50SGFuZGxlcl9gIGlzIHNldCB1cC5cbiAgICAgICAgICogQnV0IGBkb2N1bWVudFBvaW50ZXJFdmVudEhhbmRsZXJfYCBkb2Vzbid0IGtub3cgYWJvdXQgdGhlIGZpcnN0XG4gICAgICAgICAqIGB0b3VjaHN0YXJ0YC4gSWYgdGhlcmUgaXMgbm8gYHRvdWNoZW5kYCBmb3IgdGhlIGB0b3VjaHN0YXJ0YCwgd2UgY2FuXG4gICAgICAgICAqIG9ubHkgcmVjZWl2ZSBhIGB0b3VjaGNhbmNlbGAgZnJvbSBgcG9pbnRlckV2ZW50SGFuZGxlcl9gLCBiZWNhdXNlIGl0IGlzXG4gICAgICAgICAqIG9ubHkgcmVnaXN0ZXJlZCB0aGVyZS5cbiAgICAgICAgICovXG4gICAgICAgIGxpc3Rlbih0aGlzLnBvaW50ZXJFdmVudEhhbmRsZXJfLFxuICAgICAgICAgIE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUkNBTkNFTCxcbiAgICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJVcF8sIHRoaXMpXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3BvaW50ZXIvUG9pbnRlckV2ZW50LmpzXCIpLmRlZmF1bHR9IHBvaW50ZXJFdmVudCBQb2ludGVyXG4gICAqIGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTWFwQnJvd3NlckV2ZW50SGFuZGxlci5wcm90b3R5cGUuaGFuZGxlUG9pbnRlck1vdmVfID0gZnVuY3Rpb24gaGFuZGxlUG9pbnRlck1vdmVfIChwb2ludGVyRXZlbnQpIHtcbiAgICAvLyBCZXR3ZWVuIHBvaW50ZXJkb3duIGFuZCBwb2ludGVydXAsIHBvaW50ZXJtb3ZlIGV2ZW50cyBhcmUgdHJpZ2dlcmVkLlxuICAgIC8vIFRvIGF2b2lkIGEgJ2ZhbHNlJyB0b3VjaG1vdmUgZXZlbnQgdG8gYmUgZGlzcGF0Y2hlZCwgd2UgdGVzdCBpZiB0aGUgcG9pbnRlclxuICAgIC8vIG1vdmVkIGEgc2lnbmlmaWNhbnQgZGlzdGFuY2UuXG4gICAgaWYgKHRoaXMuaXNNb3ZpbmdfKHBvaW50ZXJFdmVudCkpIHtcbiAgICAgIHRoaXMuZHJhZ2dpbmdfID0gdHJ1ZTtcbiAgICAgIHZhciBuZXdFdmVudCA9IG5ldyBNYXBCcm93c2VyUG9pbnRlckV2ZW50KFxuICAgICAgICBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJEUkFHLCB0aGlzLm1hcF8sIHBvaW50ZXJFdmVudCxcbiAgICAgICAgdGhpcy5kcmFnZ2luZ18pO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcbiAgICB9XG5cbiAgICAvLyBTb21lIG5hdGl2ZSBhbmRyb2lkIGJyb3dzZXIgdHJpZ2dlcnMgbW91c2Vtb3ZlIGV2ZW50cyBkdXJpbmcgc21hbGwgcGVyaW9kXG4gICAgLy8gb2YgdGltZS4gU2VlOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2FuZHJvaWQvaXNzdWVzL2RldGFpbD9pZD01NDkxIG9yXG4gICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9hbmRyb2lkL2lzc3Vlcy9kZXRhaWw/aWQ9MTk4MjdcbiAgICAvLyBleDogR2FsYXh5IFRhYiBQMzExMCArIEFuZHJvaWQgNC4xLjFcbiAgICBwb2ludGVyRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfTtcblxuICAvKipcbiAgICogV3JhcCBhbmQgcmVsYXkgYSBwb2ludGVyIGV2ZW50LiAgTm90ZSB0aGF0IHRoaXMgcmVxdWlyZXMgdGhhdCB0aGUgdHlwZVxuICAgKiBzdHJpbmcgZm9yIHRoZSBNYXBCcm93c2VyUG9pbnRlckV2ZW50IG1hdGNoZXMgdGhlIFBvaW50ZXJFdmVudCB0eXBlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vcG9pbnRlci9Qb2ludGVyRXZlbnQuanNcIikuZGVmYXVsdH0gcG9pbnRlckV2ZW50IFBvaW50ZXJcbiAgICogZXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBNYXBCcm93c2VyRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5yZWxheUV2ZW50XyA9IGZ1bmN0aW9uIHJlbGF5RXZlbnRfIChwb2ludGVyRXZlbnQpIHtcbiAgICB2YXIgZHJhZ2dpbmcgPSAhISh0aGlzLmRvd25fICYmIHRoaXMuaXNNb3ZpbmdfKHBvaW50ZXJFdmVudCkpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgTWFwQnJvd3NlclBvaW50ZXJFdmVudChcbiAgICAgIHBvaW50ZXJFdmVudC50eXBlLCB0aGlzLm1hcF8sIHBvaW50ZXJFdmVudCwgZHJhZ2dpbmcpKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3BvaW50ZXIvUG9pbnRlckV2ZW50LmpzXCIpLmRlZmF1bHR9IHBvaW50ZXJFdmVudCBQb2ludGVyXG4gICAqIGV2ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJcyBtb3ZpbmcuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBNYXBCcm93c2VyRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5pc01vdmluZ18gPSBmdW5jdGlvbiBpc01vdmluZ18gKHBvaW50ZXJFdmVudCkge1xuICAgIHJldHVybiB0aGlzLmRyYWdnaW5nXyB8fFxuICAgICAgICBNYXRoLmFicyhwb2ludGVyRXZlbnQuY2xpZW50WCAtIHRoaXMuZG93bl8uY2xpZW50WCkgPiB0aGlzLm1vdmVUb2xlcmFuY2VfIHx8XG4gICAgICAgIE1hdGguYWJzKHBvaW50ZXJFdmVudC5jbGllbnRZIC0gdGhpcy5kb3duXy5jbGllbnRZKSA+IHRoaXMubW92ZVRvbGVyYW5jZV87XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBNYXBCcm93c2VyRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kaXNwb3NlSW50ZXJuYWwgPSBmdW5jdGlvbiBkaXNwb3NlSW50ZXJuYWwgKCkge1xuICAgIGlmICh0aGlzLnJlbGF5ZWRMaXN0ZW5lcktleV8pIHtcbiAgICAgIHVubGlzdGVuQnlLZXkodGhpcy5yZWxheWVkTGlzdGVuZXJLZXlfKTtcbiAgICAgIHRoaXMucmVsYXllZExpc3RlbmVyS2V5XyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLnBvaW50ZXJkb3duTGlzdGVuZXJLZXlfKSB7XG4gICAgICB1bmxpc3RlbkJ5S2V5KHRoaXMucG9pbnRlcmRvd25MaXN0ZW5lcktleV8pO1xuICAgICAgdGhpcy5wb2ludGVyZG93bkxpc3RlbmVyS2V5XyA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5kcmFnTGlzdGVuZXJLZXlzXy5mb3JFYWNoKHVubGlzdGVuQnlLZXkpO1xuICAgIHRoaXMuZHJhZ0xpc3RlbmVyS2V5c18ubGVuZ3RoID0gMDtcblxuICAgIGlmICh0aGlzLmRvY3VtZW50UG9pbnRlckV2ZW50SGFuZGxlcl8pIHtcbiAgICAgIHRoaXMuZG9jdW1lbnRQb2ludGVyRXZlbnRIYW5kbGVyXy5kaXNwb3NlKCk7XG4gICAgICB0aGlzLmRvY3VtZW50UG9pbnRlckV2ZW50SGFuZGxlcl8gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5wb2ludGVyRXZlbnRIYW5kbGVyXykge1xuICAgICAgdGhpcy5wb2ludGVyRXZlbnRIYW5kbGVyXy5kaXNwb3NlKCk7XG4gICAgICB0aGlzLnBvaW50ZXJFdmVudEhhbmRsZXJfID0gbnVsbDtcbiAgICB9XG4gICAgRXZlbnRUYXJnZXQucHJvdG90eXBlLmRpc3Bvc2VJbnRlcm5hbC5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIHJldHVybiBNYXBCcm93c2VyRXZlbnRIYW5kbGVyO1xufShFdmVudFRhcmdldCkpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IE1hcEJyb3dzZXJFdmVudEhhbmRsZXI7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1hcEJyb3dzZXJFdmVudEhhbmRsZXIuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL01hcEJyb3dzZXJFdmVudFR5cGVcbiAqL1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuXG4vKipcbiAqIENvbnN0YW50cyBmb3IgZXZlbnQgbmFtZXMuXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgLyoqXG4gICAqIEEgdHJ1ZSBzaW5nbGUgY2xpY2sgd2l0aCBubyBkcmFnZ2luZyBhbmQgbm8gZG91YmxlIGNsaWNrLiBOb3RlIHRoYXQgdGhpc1xuICAgKiBldmVudCBpcyBkZWxheWVkIGJ5IDI1MCBtcyB0byBlbnN1cmUgdGhhdCBpdCBpcyBub3QgYSBkb3VibGUgY2xpY2suXG4gICAqIEBldmVudCBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudCNzaW5nbGVjbGlja1xuICAgKiBAYXBpXG4gICAqL1xuICBTSU5HTEVDTElDSzogJ3NpbmdsZWNsaWNrJyxcblxuICAvKipcbiAgICogQSBjbGljayB3aXRoIG5vIGRyYWdnaW5nLiBBIGRvdWJsZSBjbGljayB3aWxsIGZpcmUgdHdvIG9mIHRoaXMuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudCNjbGlja1xuICAgKiBAYXBpXG4gICAqL1xuICBDTElDSzogRXZlbnRUeXBlLkNMSUNLLFxuXG4gIC8qKlxuICAgKiBBIHRydWUgZG91YmxlIGNsaWNrLCB3aXRoIG5vIGRyYWdnaW5nLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnQjZGJsY2xpY2tcbiAgICogQGFwaVxuICAgKi9cbiAgREJMQ0xJQ0s6IEV2ZW50VHlwZS5EQkxDTElDSyxcblxuICAvKipcbiAgICogVHJpZ2dlcmVkIHdoZW4gYSBwb2ludGVyIGlzIGRyYWdnZWQuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudCNwb2ludGVyZHJhZ1xuICAgKiBAYXBpXG4gICAqL1xuICBQT0lOVEVSRFJBRzogJ3BvaW50ZXJkcmFnJyxcblxuICAvKipcbiAgICogVHJpZ2dlcmVkIHdoZW4gYSBwb2ludGVyIGlzIG1vdmVkLiBOb3RlIHRoYXQgb24gdG91Y2ggZGV2aWNlcyB0aGlzIGlzXG4gICAqIHRyaWdnZXJlZCB3aGVuIHRoZSBtYXAgaXMgcGFubmVkLCBzbyBpcyBub3QgdGhlIHNhbWUgYXMgbW91c2Vtb3ZlLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnQjcG9pbnRlcm1vdmVcbiAgICogQGFwaVxuICAgKi9cbiAgUE9JTlRFUk1PVkU6ICdwb2ludGVybW92ZScsXG5cbiAgUE9JTlRFUkRPV046ICdwb2ludGVyZG93bicsXG4gIFBPSU5URVJVUDogJ3BvaW50ZXJ1cCcsXG4gIFBPSU5URVJPVkVSOiAncG9pbnRlcm92ZXInLFxuICBQT0lOVEVST1VUOiAncG9pbnRlcm91dCcsXG4gIFBPSU5URVJFTlRFUjogJ3BvaW50ZXJlbnRlcicsXG4gIFBPSU5URVJMRUFWRTogJ3BvaW50ZXJsZWF2ZScsXG4gIFBPSU5URVJDQU5DRUw6ICdwb2ludGVyY2FuY2VsJ1xufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWFwQnJvd3NlckV2ZW50VHlwZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvTWFwQnJvd3NlclBvaW50ZXJFdmVudFxuICovXG5pbXBvcnQgTWFwQnJvd3NlckV2ZW50IGZyb20gJy4vTWFwQnJvd3NlckV2ZW50LmpzJztcblxudmFyIE1hcEJyb3dzZXJQb2ludGVyRXZlbnQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChNYXBCcm93c2VyRXZlbnQpIHtcbiAgZnVuY3Rpb24gTWFwQnJvd3NlclBvaW50ZXJFdmVudCh0eXBlLCBtYXAsIHBvaW50ZXJFdmVudCwgb3B0X2RyYWdnaW5nLCBvcHRfZnJhbWVTdGF0ZSkge1xuXG4gICAgTWFwQnJvd3NlckV2ZW50LmNhbGwodGhpcywgdHlwZSwgbWFwLCBwb2ludGVyRXZlbnQub3JpZ2luYWxFdmVudCwgb3B0X2RyYWdnaW5nLCBvcHRfZnJhbWVTdGF0ZSk7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9wb2ludGVyL1BvaW50ZXJFdmVudC5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMucG9pbnRlckV2ZW50ID0gcG9pbnRlckV2ZW50O1xuXG4gIH1cblxuICBpZiAoIE1hcEJyb3dzZXJFdmVudCApIE1hcEJyb3dzZXJQb2ludGVyRXZlbnQuX19wcm90b19fID0gTWFwQnJvd3NlckV2ZW50O1xuICBNYXBCcm93c2VyUG9pbnRlckV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1hcEJyb3dzZXJFdmVudCAmJiBNYXBCcm93c2VyRXZlbnQucHJvdG90eXBlICk7XG4gIE1hcEJyb3dzZXJQb2ludGVyRXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWFwQnJvd3NlclBvaW50ZXJFdmVudDtcblxuICByZXR1cm4gTWFwQnJvd3NlclBvaW50ZXJFdmVudDtcbn0oTWFwQnJvd3NlckV2ZW50KSk7XG5cbmV4cG9ydCBkZWZhdWx0IE1hcEJyb3dzZXJQb2ludGVyRXZlbnQ7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1hcEJyb3dzZXJQb2ludGVyRXZlbnQuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL01hcEV2ZW50XG4gKi9cbmltcG9ydCBFdmVudCBmcm9tICcuL2V2ZW50cy9FdmVudC5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogRXZlbnRzIGVtaXR0ZWQgYXMgbWFwIGV2ZW50cyBhcmUgaW5zdGFuY2VzIG9mIHRoaXMgdHlwZS5cbiAqIFNlZSB7QGxpbmsgbW9kdWxlOm9sL1BsdWdnYWJsZU1hcH5QbHVnZ2FibGVNYXB9IGZvciB3aGljaCBldmVudHMgdHJpZ2dlciBhIG1hcCBldmVudC5cbiAqL1xudmFyIE1hcEV2ZW50ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoRXZlbnQpIHtcbiAgZnVuY3Rpb24gTWFwRXZlbnQodHlwZSwgbWFwLCBvcHRfZnJhbWVTdGF0ZSkge1xuXG4gICAgRXZlbnQuY2FsbCh0aGlzLCB0eXBlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtYXAgd2hlcmUgdGhlIGV2ZW50IG9jY3VycmVkLlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL1BsdWdnYWJsZU1hcC5qc1wiKS5kZWZhdWx0fVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLm1hcCA9IG1hcDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmcmFtZSBzdGF0ZSBhdCB0aGUgdGltZSBvZiB0aGUgZXZlbnQuXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuL1BsdWdnYWJsZU1hcC5qc1wiKS5GcmFtZVN0YXRlfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLmZyYW1lU3RhdGUgPSBvcHRfZnJhbWVTdGF0ZSAhPT0gdW5kZWZpbmVkID8gb3B0X2ZyYW1lU3RhdGUgOiBudWxsO1xuXG4gIH1cblxuICBpZiAoIEV2ZW50ICkgTWFwRXZlbnQuX19wcm90b19fID0gRXZlbnQ7XG4gIE1hcEV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEV2ZW50ICYmIEV2ZW50LnByb3RvdHlwZSApO1xuICBNYXBFdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNYXBFdmVudDtcblxuICByZXR1cm4gTWFwRXZlbnQ7XG59KEV2ZW50KSk7XG5cbmV4cG9ydCBkZWZhdWx0IE1hcEV2ZW50O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXBFdmVudC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvTWFwRXZlbnRUeXBlXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCBhZnRlciBhIG1hcCBmcmFtZSBpcyByZW5kZXJlZC5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9NYXBFdmVudH5NYXBFdmVudCNwb3N0cmVuZGVyXG4gICAqIEBhcGlcbiAgICovXG4gIFBPU1RSRU5ERVI6ICdwb3N0cmVuZGVyJyxcblxuICAvKipcbiAgICogVHJpZ2dlcmVkIHdoZW4gdGhlIG1hcCBzdGFydHMgbW92aW5nLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL01hcEV2ZW50fk1hcEV2ZW50I21vdmVzdGFydFxuICAgKiBAYXBpXG4gICAqL1xuICBNT1ZFU1RBUlQ6ICdtb3Zlc3RhcnQnLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1hcCBpcyBtb3ZlZC5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9NYXBFdmVudH5NYXBFdmVudCNtb3ZlZW5kXG4gICAqIEBhcGlcbiAgICovXG4gIE1PVkVFTkQ6ICdtb3ZlZW5kJ1xuXG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXBFdmVudFR5cGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL01hcFByb3BlcnR5XG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIExBWUVSR1JPVVA6ICdsYXllcmdyb3VwJyxcbiAgU0laRTogJ3NpemUnLFxuICBUQVJHRVQ6ICd0YXJnZXQnLFxuICBWSUVXOiAndmlldydcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1hcFByb3BlcnR5LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9PYmplY3RcbiAqL1xuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4vdXRpbC5qcyc7XG5pbXBvcnQgT2JqZWN0RXZlbnRUeXBlIGZyb20gJy4vT2JqZWN0RXZlbnRUeXBlLmpzJztcbmltcG9ydCBPYnNlcnZhYmxlIGZyb20gJy4vT2JzZXJ2YWJsZS5qcyc7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi9ldmVudHMvRXZlbnQuanMnO1xuaW1wb3J0IHthc3NpZ259IGZyb20gJy4vb2JqLmpzJztcblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEV2ZW50cyBlbWl0dGVkIGJ5IHtAbGluayBtb2R1bGU6b2wvT2JqZWN0fkJhc2VPYmplY3R9IGluc3RhbmNlcyBhcmUgaW5zdGFuY2VzIG9mIHRoaXMgdHlwZS5cbiAqL1xuZXhwb3J0IHZhciBPYmplY3RFdmVudCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEV2ZW50KSB7XG4gIGZ1bmN0aW9uIE9iamVjdEV2ZW50KHR5cGUsIGtleSwgb2xkVmFsdWUpIHtcbiAgICBFdmVudC5jYWxsKHRoaXMsIHR5cGUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHdob3NlIHZhbHVlIGlzIGNoYW5naW5nLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMua2V5ID0ga2V5O1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9sZCB2YWx1ZS4gVG8gZ2V0IHRoZSBuZXcgdmFsdWUgdXNlIGBlLnRhcmdldC5nZXQoZS5rZXkpYCB3aGVyZVxuICAgICAqIGBlYCBpcyB0aGUgZXZlbnQgb2JqZWN0LlxuICAgICAqIEB0eXBlIHsqfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLm9sZFZhbHVlID0gb2xkVmFsdWU7XG5cbiAgfVxuXG4gIGlmICggRXZlbnQgKSBPYmplY3RFdmVudC5fX3Byb3RvX18gPSBFdmVudDtcbiAgT2JqZWN0RXZlbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXZlbnQgJiYgRXZlbnQucHJvdG90eXBlICk7XG4gIE9iamVjdEV2ZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE9iamVjdEV2ZW50O1xuXG4gIHJldHVybiBPYmplY3RFdmVudDtcbn0oRXZlbnQpKTtcblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3M7IG5vcm1hbGx5IG9ubHkgdXNlZCBmb3IgY3JlYXRpbmcgc3ViY2xhc3NlcyBhbmQgbm90XG4gKiBpbnN0YW50aWF0ZWQgaW4gYXBwcy5cbiAqIE1vc3Qgbm9uLXRyaXZpYWwgY2xhc3NlcyBpbmhlcml0IGZyb20gdGhpcy5cbiAqXG4gKiBUaGlzIGV4dGVuZHMge0BsaW5rIG1vZHVsZTpvbC9PYnNlcnZhYmxlfSB3aXRoIG9ic2VydmFibGVcbiAqIHByb3BlcnRpZXMsIHdoZXJlIGVhY2ggcHJvcGVydHkgaXMgb2JzZXJ2YWJsZSBhcyB3ZWxsIGFzIHRoZSBvYmplY3QgYXMgYVxuICogd2hvbGUuXG4gKlxuICogQ2xhc3NlcyB0aGF0IGluaGVyaXQgZnJvbSB0aGlzIGhhdmUgcHJlLWRlZmluZWQgcHJvcGVydGllcywgdG8gd2hpY2ggeW91IGNhblxuICogYWRkIHlvdXIgb3ducy4gVGhlIHByZS1kZWZpbmVkIHByb3BlcnRpZXMgYXJlIGxpc3RlZCBpbiB0aGlzIGRvY3VtZW50YXRpb24gYXNcbiAqICdPYnNlcnZhYmxlIFByb3BlcnRpZXMnLCBhbmQgaGF2ZSB0aGVpciBvd24gYWNjZXNzb3JzOyBmb3IgZXhhbXBsZSxcbiAqIHtAbGluayBtb2R1bGU6b2wvTWFwfk1hcH0gaGFzIGEgYHRhcmdldGAgcHJvcGVydHksIGFjY2Vzc2VkIHdpdGhcbiAqIGBnZXRUYXJnZXQoKWAgYW5kIGNoYW5nZWQgd2l0aCBgc2V0VGFyZ2V0KClgLiBOb3QgYWxsIHByb3BlcnRpZXMgYXJlIGhvd2V2ZXJcbiAqIHNldHRhYmxlLiBUaGVyZSBhcmUgYWxzbyBnZW5lcmFsLXB1cnBvc2UgYWNjZXNzb3JzIGBnZXQoKWAgYW5kIGBzZXQoKWAuIEZvclxuICogZXhhbXBsZSwgYGdldCgndGFyZ2V0JylgIGlzIGVxdWl2YWxlbnQgdG8gYGdldFRhcmdldCgpYC5cbiAqXG4gKiBUaGUgYHNldGAgYWNjZXNzb3JzIHRyaWdnZXIgYSBjaGFuZ2UgZXZlbnQsIGFuZCB5b3UgY2FuIG1vbml0b3IgdGhpcyBieVxuICogcmVnaXN0ZXJpbmcgYSBsaXN0ZW5lci4gRm9yIGV4YW1wbGUsIHtAbGluayBtb2R1bGU6b2wvVmlld35WaWV3fSBoYXMgYVxuICogYGNlbnRlcmAgcHJvcGVydHksIHNvIGB2aWV3Lm9uKCdjaGFuZ2U6Y2VudGVyJywgZnVuY3Rpb24oZXZ0KSB7Li4ufSk7YCB3b3VsZFxuICogY2FsbCB0aGUgZnVuY3Rpb24gd2hlbmV2ZXIgdGhlIHZhbHVlIG9mIHRoZSBjZW50ZXIgcHJvcGVydHkgY2hhbmdlcy4gV2l0aGluXG4gKiB0aGUgZnVuY3Rpb24sIGBldnQudGFyZ2V0YCB3b3VsZCBiZSB0aGUgdmlldywgc28gYGV2dC50YXJnZXQuZ2V0Q2VudGVyKClgXG4gKiB3b3VsZCByZXR1cm4gdGhlIG5ldyBjZW50ZXIuXG4gKlxuICogWW91IGNhbiBhZGQgeW91ciBvd24gb2JzZXJ2YWJsZSBwcm9wZXJ0aWVzIHdpdGhcbiAqIGBvYmplY3Quc2V0KCdwcm9wJywgJ3ZhbHVlJylgLCBhbmQgcmV0cmlldmUgdGhhdCB3aXRoIGBvYmplY3QuZ2V0KCdwcm9wJylgLlxuICogWW91IGNhbiBsaXN0ZW4gZm9yIGNoYW5nZXMgb24gdGhhdCBwcm9wZXJ0eSB2YWx1ZSB3aXRoXG4gKiBgb2JqZWN0Lm9uKCdjaGFuZ2U6cHJvcCcsIGxpc3RlbmVyKWAuIFlvdSBjYW4gZ2V0IGEgbGlzdCBvZiBhbGxcbiAqIHByb3BlcnRpZXMgd2l0aCB7QGxpbmsgbW9kdWxlOm9sL09iamVjdH5CYXNlT2JqZWN0I2dldFByb3BlcnRpZXN9LlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgb2JzZXJ2YWJsZSBwcm9wZXJ0aWVzIGFyZSBzZXBhcmF0ZSBmcm9tIHN0YW5kYXJkIEpTIHByb3BlcnRpZXMuXG4gKiBZb3UgY2FuLCBmb3IgZXhhbXBsZSwgZ2l2ZSB5b3VyIG1hcCBvYmplY3QgYSB0aXRsZSB3aXRoXG4gKiBgbWFwLnRpdGxlPSdOZXcgdGl0bGUnYCBhbmQgd2l0aCBgbWFwLnNldCgndGl0bGUnLCAnQW5vdGhlciB0aXRsZScpYC4gVGhlXG4gKiBmaXJzdCB3aWxsIGJlIGEgYGhhc093blByb3BlcnR5YDsgdGhlIHNlY29uZCB3aWxsIGFwcGVhciBpblxuICogYGdldFByb3BlcnRpZXMoKWAuIE9ubHkgdGhlIHNlY29uZCBpcyBvYnNlcnZhYmxlLlxuICpcbiAqIFByb3BlcnRpZXMgY2FuIGJlIGRlbGV0ZWQgYnkgdXNpbmcgdGhlIHVuc2V0IG1ldGhvZC4gRS5nLlxuICogb2JqZWN0LnVuc2V0KCdmb28nKS5cbiAqXG4gKiBAZmlyZXMgT2JqZWN0RXZlbnRcbiAqIEBhcGlcbiAqL1xudmFyIEJhc2VPYmplY3QgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChPYnNlcnZhYmxlKSB7XG4gIGZ1bmN0aW9uIEJhc2VPYmplY3Qob3B0X3ZhbHVlcykge1xuICAgIE9ic2VydmFibGUuY2FsbCh0aGlzKTtcblxuICAgIC8vIENhbGwge0BsaW5rIG1vZHVsZTpvbC91dGlsfmdldFVpZH0gdG8gZW5zdXJlIHRoYXQgdGhlIG9yZGVyIG9mIG9iamVjdHMnIGlkcyBpc1xuICAgIC8vIHRoZSBzYW1lIGFzIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IHdlcmUgY3JlYXRlZC4gIFRoaXMgYWxzbyBoZWxwcyB0b1xuICAgIC8vIGVuc3VyZSB0aGF0IG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBhbHdheXMgYWRkZWQgaW4gdGhlIHNhbWUgb3JkZXIsIHdoaWNoXG4gICAgLy8gaGVscHMgbWFueSBKYXZhU2NyaXB0IGVuZ2luZXMgZ2VuZXJhdGUgZmFzdGVyIGNvZGUuXG4gICAgZ2V0VWlkKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsICo+fVxuICAgICAqL1xuICAgIHRoaXMudmFsdWVzXyA9IHt9O1xuXG4gICAgaWYgKG9wdF92YWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zZXRQcm9wZXJ0aWVzKG9wdF92YWx1ZXMpO1xuICAgIH1cbiAgfVxuXG4gIGlmICggT2JzZXJ2YWJsZSApIEJhc2VPYmplY3QuX19wcm90b19fID0gT2JzZXJ2YWJsZTtcbiAgQmFzZU9iamVjdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBPYnNlcnZhYmxlICYmIE9ic2VydmFibGUucHJvdG90eXBlICk7XG4gIEJhc2VPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQmFzZU9iamVjdDtcblxuICAvKipcbiAgICogR2V0cyBhIHZhbHVlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleSBuYW1lLlxuICAgKiBAcmV0dXJuIHsqfSBWYWx1ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgQmFzZU9iamVjdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChrZXkpIHtcbiAgICB2YXIgdmFsdWU7XG4gICAgaWYgKHRoaXMudmFsdWVzXy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMudmFsdWVzX1trZXldO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhIGxpc3Qgb2Ygb2JqZWN0IHByb3BlcnR5IG5hbWVzLlxuICAgKiBAcmV0dXJuIHtBcnJheTxzdHJpbmc+fSBMaXN0IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgKiBAYXBpXG4gICAqL1xuICBCYXNlT2JqZWN0LnByb3RvdHlwZS5nZXRLZXlzID0gZnVuY3Rpb24gZ2V0S2V5cyAoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMudmFsdWVzXyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhbiBvYmplY3Qgb2YgYWxsIHByb3BlcnR5IG5hbWVzIGFuZCB2YWx1ZXMuXG4gICAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsICo+fSBPYmplY3QuXG4gICAqIEBhcGlcbiAgICovXG4gIEJhc2VPYmplY3QucHJvdG90eXBlLmdldFByb3BlcnRpZXMgPSBmdW5jdGlvbiBnZXRQcm9wZXJ0aWVzICgpIHtcbiAgICByZXR1cm4gYXNzaWduKHt9LCB0aGlzLnZhbHVlc18pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleSBuYW1lLlxuICAgKiBAcGFyYW0geyp9IG9sZFZhbHVlIE9sZCB2YWx1ZS5cbiAgICovXG4gIEJhc2VPYmplY3QucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSAoa2V5LCBvbGRWYWx1ZSkge1xuICAgIHZhciBldmVudFR5cGU7XG4gICAgZXZlbnRUeXBlID0gZ2V0Q2hhbmdlRXZlbnRUeXBlKGtleSk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBPYmplY3RFdmVudChldmVudFR5cGUsIGtleSwgb2xkVmFsdWUpKTtcbiAgICBldmVudFR5cGUgPSBPYmplY3RFdmVudFR5cGUuUFJPUEVSVFlDSEFOR0U7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBPYmplY3RFdmVudChldmVudFR5cGUsIGtleSwgb2xkVmFsdWUpKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyBhIHZhbHVlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleSBuYW1lLlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfc2lsZW50IFVwZGF0ZSB3aXRob3V0IHRyaWdnZXJpbmcgYW4gZXZlbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIEJhc2VPYmplY3QucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAoa2V5LCB2YWx1ZSwgb3B0X3NpbGVudCkge1xuICAgIGlmIChvcHRfc2lsZW50KSB7XG4gICAgICB0aGlzLnZhbHVlc19ba2V5XSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlc19ba2V5XTtcbiAgICAgIHRoaXMudmFsdWVzX1trZXldID0gdmFsdWU7XG4gICAgICBpZiAob2xkVmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgIHRoaXMubm90aWZ5KGtleSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0cyBhIGNvbGxlY3Rpb24gb2Yga2V5LXZhbHVlIHBhaXJzLiAgTm90ZSB0aGF0IHRoaXMgY2hhbmdlcyBhbnkgZXhpc3RpbmdcbiAgICogcHJvcGVydGllcyBhbmQgYWRkcyBuZXcgb25lcyAoaXQgZG9lcyBub3QgcmVtb3ZlIGFueSBleGlzdGluZyBwcm9wZXJ0aWVzKS5cbiAgICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCAqPn0gdmFsdWVzIFZhbHVlcy5cbiAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3NpbGVudCBVcGRhdGUgd2l0aG91dCB0cmlnZ2VyaW5nIGFuIGV2ZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBCYXNlT2JqZWN0LnByb3RvdHlwZS5zZXRQcm9wZXJ0aWVzID0gZnVuY3Rpb24gc2V0UHJvcGVydGllcyAodmFsdWVzLCBvcHRfc2lsZW50KSB7XG4gICAgZm9yICh2YXIga2V5IGluIHZhbHVlcykge1xuICAgICAgdGhpcy5zZXQoa2V5LCB2YWx1ZXNba2V5XSwgb3B0X3NpbGVudCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBVbnNldHMgYSBwcm9wZXJ0eS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkgbmFtZS5cbiAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3NpbGVudCBVbnNldCB3aXRob3V0IHRyaWdnZXJpbmcgYW4gZXZlbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIEJhc2VPYmplY3QucHJvdG90eXBlLnVuc2V0ID0gZnVuY3Rpb24gdW5zZXQgKGtleSwgb3B0X3NpbGVudCkge1xuICAgIGlmIChrZXkgaW4gdGhpcy52YWx1ZXNfKSB7XG4gICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlc19ba2V5XTtcbiAgICAgIGRlbGV0ZSB0aGlzLnZhbHVlc19ba2V5XTtcbiAgICAgIGlmICghb3B0X3NpbGVudCkge1xuICAgICAgICB0aGlzLm5vdGlmeShrZXksIG9sZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIEJhc2VPYmplY3Q7XG59KE9ic2VydmFibGUpKTtcblxuXG4vKipcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fVxuICovXG52YXIgY2hhbmdlRXZlbnRUeXBlQ2FjaGUgPSB7fTtcblxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgS2V5IG5hbWUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IENoYW5nZSBuYW1lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2hhbmdlRXZlbnRUeXBlKGtleSkge1xuICByZXR1cm4gY2hhbmdlRXZlbnRUeXBlQ2FjaGUuaGFzT3duUHJvcGVydHkoa2V5KSA/XG4gICAgY2hhbmdlRXZlbnRUeXBlQ2FjaGVba2V5XSA6XG4gICAgKGNoYW5nZUV2ZW50VHlwZUNhY2hlW2tleV0gPSAnY2hhbmdlOicgKyBrZXkpO1xufVxuXG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VPYmplY3Q7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9iamVjdC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvT2JqZWN0RXZlbnRUeXBlXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiBhIHByb3BlcnR5IGlzIGNoYW5nZWQuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvT2JqZWN0Lk9iamVjdEV2ZW50I3Byb3BlcnR5Y2hhbmdlXG4gICAqIEBhcGlcbiAgICovXG4gIFBST1BFUlRZQ0hBTkdFOiAncHJvcGVydHljaGFuZ2UnXG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1PYmplY3RFdmVudFR5cGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL09ic2VydmFibGVcbiAqL1xuaW1wb3J0IHtsaXN0ZW4sIHVubGlzdGVuQnlLZXksIHVubGlzdGVuLCBsaXN0ZW5PbmNlfSBmcm9tICcuL2V2ZW50cy5qcyc7XG5pbXBvcnQgRXZlbnRUYXJnZXQgZnJvbSAnLi9ldmVudHMvVGFyZ2V0LmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzOyBub3JtYWxseSBvbmx5IHVzZWQgZm9yIGNyZWF0aW5nIHN1YmNsYXNzZXMgYW5kIG5vdFxuICogaW5zdGFudGlhdGVkIGluIGFwcHMuXG4gKiBBbiBldmVudCB0YXJnZXQgcHJvdmlkaW5nIGNvbnZlbmllbnQgbWV0aG9kcyBmb3IgbGlzdGVuZXIgcmVnaXN0cmF0aW9uXG4gKiBhbmQgdW5yZWdpc3RyYXRpb24uIEEgZ2VuZXJpYyBgY2hhbmdlYCBldmVudCBpcyBhbHdheXMgYXZhaWxhYmxlIHRocm91Z2hcbiAqIHtAbGluayBtb2R1bGU6b2wvT2JzZXJ2YWJsZX5PYnNlcnZhYmxlI2NoYW5nZWR9LlxuICpcbiAqIEBmaXJlcyBpbXBvcnQoXCIuL2V2ZW50cy9FdmVudC5qc1wiKS5FdmVudFxuICogQGFwaVxuICovXG52YXIgT2JzZXJ2YWJsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEV2ZW50VGFyZ2V0KSB7XG4gIGZ1bmN0aW9uIE9ic2VydmFibGUoKSB7XG5cbiAgICBFdmVudFRhcmdldC5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmV2aXNpb25fID0gMDtcblxuICB9XG5cbiAgaWYgKCBFdmVudFRhcmdldCApIE9ic2VydmFibGUuX19wcm90b19fID0gRXZlbnRUYXJnZXQ7XG4gIE9ic2VydmFibGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXZlbnRUYXJnZXQgJiYgRXZlbnRUYXJnZXQucHJvdG90eXBlICk7XG4gIE9ic2VydmFibGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gT2JzZXJ2YWJsZTtcblxuICAvKipcbiAgICogSW5jcmVhc2VzIHRoZSByZXZpc2lvbiBjb3VudGVyIGFuZCBkaXNwYXRjaGVzIGEgJ2NoYW5nZScgZXZlbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIE9ic2VydmFibGUucHJvdG90eXBlLmNoYW5nZWQgPSBmdW5jdGlvbiBjaGFuZ2VkICgpIHtcbiAgICArK3RoaXMucmV2aXNpb25fO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudFR5cGUuQ0hBTkdFKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSB2ZXJzaW9uIG51bWJlciBmb3IgdGhpcyBvYmplY3QuICBFYWNoIHRpbWUgdGhlIG9iamVjdCBpcyBtb2RpZmllZCxcbiAgICogaXRzIHZlcnNpb24gbnVtYmVyIHdpbGwgYmUgaW5jcmVtZW50ZWQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gUmV2aXNpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIE9ic2VydmFibGUucHJvdG90eXBlLmdldFJldmlzaW9uID0gZnVuY3Rpb24gZ2V0UmV2aXNpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnJldmlzaW9uXztcbiAgfTtcblxuICAvKipcbiAgICogTGlzdGVuIGZvciBhIGNlcnRhaW4gdHlwZSBvZiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXk8c3RyaW5nPn0gdHlwZSBUaGUgZXZlbnQgdHlwZSBvciBhcnJheSBvZiBldmVudCB0eXBlcy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbig/KTogP30gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXl8QXJyYXk8aW1wb3J0KFwiLi9ldmVudHMuanNcIikuRXZlbnRzS2V5Pn0gVW5pcXVlIGtleSBmb3IgdGhlIGxpc3RlbmVyLiBJZlxuICAgKiAgICAgY2FsbGVkIHdpdGggYW4gYXJyYXkgb2YgZXZlbnQgdHlwZXMgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LCB0aGUgcmV0dXJuXG4gICAqICAgICB3aWxsIGJlIGFuIGFycmF5IG9mIGtleXMuXG4gICAqIEBhcGlcbiAgICovXG4gIE9ic2VydmFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24gKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHZhciBsZW4gPSB0eXBlLmxlbmd0aDtcbiAgICAgIHZhciBrZXlzID0gbmV3IEFycmF5KGxlbik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGtleXNbaV0gPSBsaXN0ZW4odGhpcywgdHlwZVtpXSwgbGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtleXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBsaXN0ZW4odGhpcywgLyoqIEB0eXBlIHtzdHJpbmd9ICovICh0eXBlKSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogTGlzdGVuIG9uY2UgZm9yIGEgY2VydGFpbiB0eXBlIG9mIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheTxzdHJpbmc+fSB0eXBlIFRoZSBldmVudCB0eXBlIG9yIGFycmF5IG9mIGV2ZW50IHR5cGVzLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKD8pOiA/fSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleXxBcnJheTxpbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXk+fSBVbmlxdWUga2V5IGZvciB0aGUgbGlzdGVuZXIuIElmXG4gICAqICAgICBjYWxsZWQgd2l0aCBhbiBhcnJheSBvZiBldmVudCB0eXBlcyBhcyB0aGUgZmlyc3QgYXJndW1lbnQsIHRoZSByZXR1cm5cbiAgICogICAgIHdpbGwgYmUgYW4gYXJyYXkgb2Yga2V5cy5cbiAgICogQGFwaVxuICAgKi9cbiAgT2JzZXJ2YWJsZS5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UgKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHZhciBsZW4gPSB0eXBlLmxlbmd0aDtcbiAgICAgIHZhciBrZXlzID0gbmV3IEFycmF5KGxlbik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGtleXNbaV0gPSBsaXN0ZW5PbmNlKHRoaXMsIHR5cGVbaV0sIGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbGlzdGVuT25jZSh0aGlzLCAvKiogQHR5cGUge3N0cmluZ30gKi8gKHR5cGUpLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBVbmxpc3RlbiBmb3IgYSBjZXJ0YWluIHR5cGUgb2YgZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5PHN0cmluZz59IHR5cGUgVGhlIGV2ZW50IHR5cGUgb3IgYXJyYXkgb2YgZXZlbnQgdHlwZXMuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oPyk6ID99IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgT2JzZXJ2YWJsZS5wcm90b3R5cGUudW4gPSBmdW5jdGlvbiB1biAodHlwZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdHlwZS5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIHVubGlzdGVuKHRoaXMsIHR5cGVbaV0sIGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgdW5saXN0ZW4odGhpcywgLyoqIEB0eXBlIHtzdHJpbmd9ICovICh0eXBlKSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gT2JzZXJ2YWJsZTtcbn0oRXZlbnRUYXJnZXQpKTtcblxuXG4vKipcbiAqIFJlbW92ZXMgYW4gZXZlbnQgbGlzdGVuZXIgdXNpbmcgdGhlIGtleSByZXR1cm5lZCBieSBgb24oKWAgb3IgYG9uY2UoKWAuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleXxBcnJheTxpbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXk+fSBrZXkgVGhlIGtleSByZXR1cm5lZCBieSBgb24oKWBcbiAqICAgICBvciBgb25jZSgpYCAob3IgYW4gYXJyYXkgb2Yga2V5cykuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bkJ5S2V5KGtleSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShrZXkpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0ga2V5Lmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIHVubGlzdGVuQnlLZXkoa2V5W2ldKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdW5saXN0ZW5CeUtleSgvKiogQHR5cGUge2ltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleX0gKi8gKGtleSkpO1xuICB9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgT2JzZXJ2YWJsZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JzZXJ2YWJsZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvUGx1Z2dhYmxlTWFwXG4gKi9cbmltcG9ydCB7Z2V0VWlkfSBmcm9tICcuL3V0aWwuanMnO1xuaW1wb3J0IENvbGxlY3Rpb24gZnJvbSAnLi9Db2xsZWN0aW9uLmpzJztcbmltcG9ydCBDb2xsZWN0aW9uRXZlbnRUeXBlIGZyb20gJy4vQ29sbGVjdGlvbkV2ZW50VHlwZS5qcyc7XG5pbXBvcnQgTWFwQnJvd3NlckV2ZW50IGZyb20gJy4vTWFwQnJvd3NlckV2ZW50LmpzJztcbmltcG9ydCBNYXBCcm93c2VyRXZlbnRIYW5kbGVyIGZyb20gJy4vTWFwQnJvd3NlckV2ZW50SGFuZGxlci5qcyc7XG5pbXBvcnQgTWFwQnJvd3NlckV2ZW50VHlwZSBmcm9tICcuL01hcEJyb3dzZXJFdmVudFR5cGUuanMnO1xuaW1wb3J0IE1hcEV2ZW50IGZyb20gJy4vTWFwRXZlbnQuanMnO1xuaW1wb3J0IE1hcEV2ZW50VHlwZSBmcm9tICcuL01hcEV2ZW50VHlwZS5qcyc7XG5pbXBvcnQgTWFwUHJvcGVydHkgZnJvbSAnLi9NYXBQcm9wZXJ0eS5qcyc7XG5pbXBvcnQgUmVuZGVyRXZlbnRUeXBlIGZyb20gJy4vcmVuZGVyL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgQmFzZU9iamVjdCwge2dldENoYW5nZUV2ZW50VHlwZX0gZnJvbSAnLi9PYmplY3QuanMnO1xuaW1wb3J0IE9iamVjdEV2ZW50VHlwZSBmcm9tICcuL09iamVjdEV2ZW50VHlwZS5qcyc7XG5pbXBvcnQgVGlsZVF1ZXVlIGZyb20gJy4vVGlsZVF1ZXVlLmpzJztcbmltcG9ydCBWaWV3IGZyb20gJy4vVmlldy5qcyc7XG5pbXBvcnQgVmlld0hpbnQgZnJvbSAnLi9WaWV3SGludC5qcyc7XG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi9hc3NlcnRzLmpzJztcbmltcG9ydCB7cmVtb3ZlTm9kZX0gZnJvbSAnLi9kb20uanMnO1xuaW1wb3J0IHtsaXN0ZW4sIHVubGlzdGVuQnlLZXksIHVubGlzdGVufSBmcm9tICcuL2V2ZW50cy5qcyc7XG5pbXBvcnQge3N0b3BQcm9wYWdhdGlvbn0gZnJvbSAnLi9ldmVudHMvRXZlbnQuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IHtjcmVhdGVFbXB0eSwgY2xvbmUsIGNyZWF0ZU9yVXBkYXRlRW1wdHksIGVxdWFscywgZ2V0Rm9yVmlld0FuZFNpemUsIGlzRW1wdHl9IGZyb20gJy4vZXh0ZW50LmpzJztcbmltcG9ydCB7VFJVRX0gZnJvbSAnLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IHtERVZJQ0VfUElYRUxfUkFUSU8sIFRPVUNIfSBmcm9tICcuL2hhcy5qcyc7XG5pbXBvcnQgTGF5ZXJHcm91cCBmcm9tICcuL2xheWVyL0dyb3VwLmpzJztcbmltcG9ydCB7aGFzQXJlYX0gZnJvbSAnLi9zaXplLmpzJztcbmltcG9ydCB7RFJPUH0gZnJvbSAnLi9zdHJ1Y3RzL1ByaW9yaXR5UXVldWUuanMnO1xuaW1wb3J0IHtjcmVhdGUgYXMgY3JlYXRlVHJhbnNmb3JtLCBhcHBseSBhcyBhcHBseVRyYW5zZm9ybX0gZnJvbSAnLi90cmFuc2Zvcm0uanMnO1xuXG5cbi8qKlxuICogU3RhdGUgb2YgdGhlIGN1cnJlbnQgZnJhbWUuIE9ubHkgYHBpeGVsUmF0aW9gLCBgdGltZWAgYW5kIGB2aWV3U3RhdGVgIHNob3VsZFxuICogYmUgdXNlZCBpbiBhcHBsaWNhdGlvbnMuXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBGcmFtZVN0YXRlXG4gKiBAcHJvcGVydHkge251bWJlcn0gcGl4ZWxSYXRpbyBUaGUgcGl4ZWwgcmF0aW8gb2YgdGhlIGZyYW1lLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbWUgVGhlIHRpbWUgd2hlbiByZW5kZXJpbmcgb2YgdGhlIGZyYW1lIHdhcyByZXF1ZXN0ZWQuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vVmlldy5qc1wiKS5TdGF0ZX0gdmlld1N0YXRlIFRoZSBzdGF0ZSBvZiB0aGUgY3VycmVudCB2aWV3LlxuICogQHByb3BlcnR5IHtib29sZWFufSBhbmltYXRlXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX0gY29vcmRpbmF0ZVRvUGl4ZWxUcmFuc2Zvcm1cbiAqIEBwcm9wZXJ0eSB7bnVsbHxpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudFxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gZm9jdXNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbmRleFxuICogQHByb3BlcnR5IHtPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuL2xheWVyL0xheWVyLmpzXCIpLlN0YXRlPn0gbGF5ZXJTdGF0ZXNcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8aW1wb3J0KFwiLi9sYXllci9MYXllci5qc1wiKS5TdGF0ZT59IGxheWVyU3RhdGVzQXJyYXlcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfSBwaXhlbFRvQ29vcmRpbmF0ZVRyYW5zZm9ybVxuICogQHByb3BlcnR5IHtBcnJheTxQb3N0UmVuZGVyRnVuY3Rpb24+fSBwb3N0UmVuZGVyRnVuY3Rpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBzaXplXG4gKiBAcHJvcGVydHkgeyFPYmplY3Q8c3RyaW5nLCBib29sZWFuPn0gc2tpcHBlZEZlYXR1cmVVaWRzXG4gKiBAcHJvcGVydHkge1RpbGVRdWV1ZX0gdGlsZVF1ZXVlXG4gKiBAcHJvcGVydHkge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHQ+Pn0gdXNlZFRpbGVzXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IHZpZXdIaW50c1xuICogQHByb3BlcnR5IHshT2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgYm9vbGVhbj4+fSB3YW50ZWRUaWxlc1xuICovXG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oUGx1Z2dhYmxlTWFwLCA/RnJhbWVTdGF0ZSk6IGJvb2xlYW59IFBvc3RSZW5kZXJGdW5jdGlvblxuICovXG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBBdFBpeGVsT3B0aW9uc1xuICogQHByb3BlcnR5IHt1bmRlZmluZWR8ZnVuY3Rpb24oaW1wb3J0KFwiLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0KTogYm9vbGVhbn0gbGF5ZXJGaWx0ZXIgTGF5ZXIgZmlsdGVyXG4gKiBmdW5jdGlvbi4gVGhlIGZpbHRlciBmdW5jdGlvbiB3aWxsIHJlY2VpdmUgb25lIGFyZ3VtZW50LCB0aGVcbiAqIHtAbGluayBtb2R1bGU6b2wvbGF5ZXIvTGF5ZXIgbGF5ZXItY2FuZGlkYXRlfSBhbmQgaXQgc2hvdWxkIHJldHVybiBhIGJvb2xlYW4gdmFsdWUuXG4gKiBPbmx5IGxheWVycyB3aGljaCBhcmUgdmlzaWJsZSBhbmQgZm9yIHdoaWNoIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBgdHJ1ZWBcbiAqIHdpbGwgYmUgdGVzdGVkIGZvciBmZWF0dXJlcy4gQnkgZGVmYXVsdCwgYWxsIHZpc2libGUgbGF5ZXJzIHdpbGwgYmUgdGVzdGVkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtoaXRUb2xlcmFuY2U9MF0gSGl0LWRldGVjdGlvbiB0b2xlcmFuY2UgaW4gcGl4ZWxzLiBQaXhlbHNcbiAqIGluc2lkZSB0aGUgcmFkaXVzIGFyb3VuZCB0aGUgZ2l2ZW4gcG9zaXRpb24gd2lsbCBiZSBjaGVja2VkIGZvciBmZWF0dXJlcy4gVGhpcyBvbmx5XG4gKiB3b3JrcyBmb3IgdGhlIGNhbnZhcyByZW5kZXJlciBhbmQgbm90IGZvciBXZWJHTC5cbiAqL1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTWFwT3B0aW9uc0ludGVybmFsXG4gKiBAcHJvcGVydHkge0NvbGxlY3Rpb248aW1wb3J0KFwiLi9jb250cm9sL0NvbnRyb2wuanNcIikuZGVmYXVsdD59IFtjb250cm9sc11cbiAqIEBwcm9wZXJ0eSB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuL2ludGVyYWN0aW9uL0ludGVyYWN0aW9uLmpzXCIpLmRlZmF1bHQ+fSBbaW50ZXJhY3Rpb25zXVxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudHxEb2N1bWVudH0ga2V5Ym9hcmRFdmVudFRhcmdldFxuICogQHByb3BlcnR5IHtDb2xsZWN0aW9uPGltcG9ydChcIi4vT3ZlcmxheS5qc1wiKS5kZWZhdWx0Pn0gb3ZlcmxheXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0PHN0cmluZywgKj59IHZhbHVlc1xuICovXG5cblxuLyoqXG4gKiBPYmplY3QgbGl0ZXJhbCB3aXRoIGNvbmZpZyBvcHRpb25zIGZvciB0aGUgbWFwLlxuICogQHR5cGVkZWYge09iamVjdH0gTWFwT3B0aW9uc1xuICogQHByb3BlcnR5IHtDb2xsZWN0aW9uPGltcG9ydChcIi4vY29udHJvbC9Db250cm9sLmpzXCIpLmRlZmF1bHQ+fEFycmF5PGltcG9ydChcIi4vY29udHJvbC9Db250cm9sLmpzXCIpLmRlZmF1bHQ+fSBbY29udHJvbHNdXG4gKiBDb250cm9scyBpbml0aWFsbHkgYWRkZWQgdG8gdGhlIG1hcC4gSWYgbm90IHNwZWNpZmllZCxcbiAqIHtAbGluayBtb2R1bGU6b2wvY29udHJvbH5kZWZhdWx0c30gaXMgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcGl4ZWxSYXRpbz13aW5kb3cuZGV2aWNlUGl4ZWxSYXRpb10gVGhlIHJhdGlvIGJldHdlZW5cbiAqIHBoeXNpY2FsIHBpeGVscyBhbmQgZGV2aWNlLWluZGVwZW5kZW50IHBpeGVscyAoZGlwcykgb24gdGhlIGRldmljZS5cbiAqIEBwcm9wZXJ0eSB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuL2ludGVyYWN0aW9uL0ludGVyYWN0aW9uLmpzXCIpLmRlZmF1bHQ+fEFycmF5PGltcG9ydChcIi4vaW50ZXJhY3Rpb24vSW50ZXJhY3Rpb24uanNcIikuZGVmYXVsdD59IFtpbnRlcmFjdGlvbnNdXG4gKiBJbnRlcmFjdGlvbnMgdGhhdCBhcmUgaW5pdGlhbGx5IGFkZGVkIHRvIHRoZSBtYXAuIElmIG5vdCBzcGVjaWZpZWQsXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9ufmRlZmF1bHRzfSBpcyB1c2VkLlxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudHxEb2N1bWVudHxzdHJpbmd9IFtrZXlib2FyZEV2ZW50VGFyZ2V0XSBUaGUgZWxlbWVudCB0b1xuICogbGlzdGVuIHRvIGtleWJvYXJkIGV2ZW50cyBvbi4gVGhpcyBkZXRlcm1pbmVzIHdoZW4gdGhlIGBLZXlib2FyZFBhbmAgYW5kXG4gKiBgS2V5Ym9hcmRab29tYCBpbnRlcmFjdGlvbnMgdHJpZ2dlci4gRm9yIGV4YW1wbGUsIGlmIHRoaXMgb3B0aW9uIGlzIHNldCB0b1xuICogYGRvY3VtZW50YCB0aGUga2V5Ym9hcmQgaW50ZXJhY3Rpb25zIHdpbGwgYWx3YXlzIHRyaWdnZXIuIElmIHRoaXMgb3B0aW9uIGlzXG4gKiBub3Qgc3BlY2lmaWVkLCB0aGUgZWxlbWVudCB0aGUgbGlicmFyeSBsaXN0ZW5zIHRvIGtleWJvYXJkIGV2ZW50cyBvbiBpcyB0aGVcbiAqIG1hcCB0YXJnZXQgKGkuZS4gdGhlIHVzZXItcHJvdmlkZWQgZGl2IGZvciB0aGUgbWFwKS4gSWYgdGhpcyBpcyBub3RcbiAqIGBkb2N1bWVudGAsIHRoZSB0YXJnZXQgZWxlbWVudCBuZWVkcyB0byBiZSBmb2N1c2VkIGZvciBrZXkgZXZlbnRzIHRvIGJlXG4gKiBlbWl0dGVkLCByZXF1aXJpbmcgdGhhdCB0aGUgdGFyZ2V0IGVsZW1lbnQgaGFzIGEgYHRhYmluZGV4YCBhdHRyaWJ1dGUuXG4gKiBAcHJvcGVydHkge0FycmF5PGltcG9ydChcIi4vbGF5ZXIvQmFzZS5qc1wiKS5kZWZhdWx0PnxDb2xsZWN0aW9uPGltcG9ydChcIi4vbGF5ZXIvQmFzZS5qc1wiKS5kZWZhdWx0PnxMYXllckdyb3VwfSBbbGF5ZXJzXVxuICogTGF5ZXJzLiBJZiB0aGlzIGlzIG5vdCBkZWZpbmVkLCBhIG1hcCB3aXRoIG5vIGxheWVycyB3aWxsIGJlIHJlbmRlcmVkLiBOb3RlXG4gKiB0aGF0IGxheWVycyBhcmUgcmVuZGVyZWQgaW4gdGhlIG9yZGVyIHN1cHBsaWVkLCBzbyBpZiB5b3Ugd2FudCwgZm9yIGV4YW1wbGUsXG4gKiBhIHZlY3RvciBsYXllciB0byBhcHBlYXIgb24gdG9wIG9mIGEgdGlsZSBsYXllciwgaXQgbXVzdCBjb21lIGFmdGVyIHRoZSB0aWxlXG4gKiBsYXllci5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4VGlsZXNMb2FkaW5nPTE2XSBNYXhpbXVtIG51bWJlciB0aWxlcyB0byBsb2FkXG4gKiBzaW11bHRhbmVvdXNseS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2xvYWRUaWxlc1doaWxlQW5pbWF0aW5nPWZhbHNlXSBXaGVuIHNldCB0byBgdHJ1ZWAsIHRpbGVzXG4gKiB3aWxsIGJlIGxvYWRlZCBkdXJpbmcgYW5pbWF0aW9ucy4gVGhpcyBtYXkgaW1wcm92ZSB0aGUgdXNlciBleHBlcmllbmNlLCBidXRcbiAqIGNhbiBhbHNvIG1ha2UgYW5pbWF0aW9ucyBzdHV0dGVyIG9uIGRldmljZXMgd2l0aCBzbG93IG1lbW9yeS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2xvYWRUaWxlc1doaWxlSW50ZXJhY3Rpbmc9ZmFsc2VdIFdoZW4gc2V0IHRvIGB0cnVlYCxcbiAqIHRpbGVzIHdpbGwgYmUgbG9hZGVkIHdoaWxlIGludGVyYWN0aW5nIHdpdGggdGhlIG1hcC4gVGhpcyBtYXkgaW1wcm92ZSB0aGVcbiAqIHVzZXIgZXhwZXJpZW5jZSwgYnV0IGNhbiBhbHNvIG1ha2UgbWFwIHBhbm5pbmcgYW5kIHpvb21pbmcgY2hvcHB5IG9uIGRldmljZXNcbiAqIHdpdGggc2xvdyBtZW1vcnkuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21vdmVUb2xlcmFuY2U9MV0gVGhlIG1pbmltdW0gZGlzdGFuY2UgaW4gcGl4ZWxzIHRoZVxuICogY3Vyc29yIG11c3QgbW92ZSB0byBiZSBkZXRlY3RlZCBhcyBhIG1hcCBtb3ZlIGV2ZW50IGluc3RlYWQgb2YgYSBjbGljay5cbiAqIEluY3JlYXNpbmcgdGhpcyB2YWx1ZSBjYW4gbWFrZSBpdCBlYXNpZXIgdG8gY2xpY2sgb24gdGhlIG1hcC5cbiAqIEBwcm9wZXJ0eSB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuL092ZXJsYXkuanNcIikuZGVmYXVsdD58QXJyYXk8aW1wb3J0KFwiLi9PdmVybGF5LmpzXCIpLmRlZmF1bHQ+fSBbb3ZlcmxheXNdXG4gKiBPdmVybGF5cyBpbml0aWFsbHkgYWRkZWQgdG8gdGhlIG1hcC4gQnkgZGVmYXVsdCwgbm8gb3ZlcmxheXMgYXJlIGFkZGVkLlxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudHxzdHJpbmd9IFt0YXJnZXRdIFRoZSBjb250YWluZXIgZm9yIHRoZSBtYXAsIGVpdGhlciB0aGVcbiAqIGVsZW1lbnQgaXRzZWxmIG9yIHRoZSBgaWRgIG9mIHRoZSBlbGVtZW50LiBJZiBub3Qgc3BlY2lmaWVkIGF0IGNvbnN0cnVjdGlvblxuICogdGltZSwge0BsaW5rIG1vZHVsZTpvbC9NYXB+TWFwI3NldFRhcmdldH0gbXVzdCBiZSBjYWxsZWQgZm9yIHRoZSBtYXAgdG8gYmVcbiAqIHJlbmRlcmVkLlxuICogQHByb3BlcnR5IHtWaWV3fSBbdmlld10gVGhlIG1hcCdzIHZpZXcuICBObyBsYXllciBzb3VyY2VzIHdpbGwgYmVcbiAqIGZldGNoZWQgdW5sZXNzIHRoaXMgaXMgc3BlY2lmaWVkIGF0IGNvbnN0cnVjdGlvbiB0aW1lIG9yIHRocm91Z2hcbiAqIHtAbGluayBtb2R1bGU6b2wvTWFwfk1hcCNzZXRWaWV3fS5cbiAqL1xuXG5cbi8qKlxuICogQGZpcmVzIGltcG9ydChcIi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLk1hcEJyb3dzZXJFdmVudFxuICogQGZpcmVzIGltcG9ydChcIi4vTWFwRXZlbnQuanNcIikuTWFwRXZlbnRcbiAqIEBmaXJlcyBtb2R1bGU6b2wvcmVuZGVyL0V2ZW50flJlbmRlckV2ZW50I3Bvc3Rjb21wb3NlXG4gKiBAZmlyZXMgbW9kdWxlOm9sL3JlbmRlci9FdmVudH5SZW5kZXJFdmVudCNwcmVjb21wb3NlXG4gKiBAZmlyZXMgbW9kdWxlOm9sL3JlbmRlci9FdmVudH5SZW5kZXJFdmVudCNyZW5kZXJjb21wbGV0ZVxuICogQGFwaVxuICovXG52YXIgUGx1Z2dhYmxlTWFwID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoQmFzZU9iamVjdCkge1xuICBmdW5jdGlvbiBQbHVnZ2FibGVNYXAob3B0aW9ucykge1xuXG4gICAgQmFzZU9iamVjdC5jYWxsKHRoaXMpO1xuXG4gICAgdmFyIG9wdGlvbnNJbnRlcm5hbCA9IGNyZWF0ZU9wdGlvbnNJbnRlcm5hbChvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLm1heFRpbGVzTG9hZGluZ18gPSBvcHRpb25zLm1heFRpbGVzTG9hZGluZyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tYXhUaWxlc0xvYWRpbmcgOiAxNjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5sb2FkVGlsZXNXaGlsZUFuaW1hdGluZ18gPVxuICAgICAgICBvcHRpb25zLmxvYWRUaWxlc1doaWxlQW5pbWF0aW5nICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgIG9wdGlvbnMubG9hZFRpbGVzV2hpbGVBbmltYXRpbmcgOiBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5sb2FkVGlsZXNXaGlsZUludGVyYWN0aW5nXyA9XG4gICAgICAgIG9wdGlvbnMubG9hZFRpbGVzV2hpbGVJbnRlcmFjdGluZyAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICBvcHRpb25zLmxvYWRUaWxlc1doaWxlSW50ZXJhY3RpbmcgOiBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnBpeGVsUmF0aW9fID0gb3B0aW9ucy5waXhlbFJhdGlvICE9PSB1bmRlZmluZWQgP1xuICAgICAgb3B0aW9ucy5waXhlbFJhdGlvIDogREVWSUNFX1BJWEVMX1JBVElPO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmFuaW1hdGlvbkRlbGF5S2V5XztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5hbmltYXRpb25EZWxheV8gPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uRGVsYXlLZXlfID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5yZW5kZXJGcmFtZV8uY2FsbCh0aGlzLCBEYXRlLm5vdygpKTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19XG4gICAgICovXG4gICAgdGhpcy5jb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybV8gPSBjcmVhdGVUcmFuc2Zvcm0oKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX1cbiAgICAgKi9cbiAgICB0aGlzLnBpeGVsVG9Db29yZGluYXRlVHJhbnNmb3JtXyA9IGNyZWF0ZVRyYW5zZm9ybSgpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZnJhbWVJbmRleF8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P0ZyYW1lU3RhdGV9XG4gICAgICovXG4gICAgdGhpcy5mcmFtZVN0YXRlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZXh0ZW50IGF0IHRoZSBwcmV2aW91cyAnbW92ZWVuZCcgZXZlbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgICAqL1xuICAgIHRoaXMucHJldmlvdXNFeHRlbnRfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXl9XG4gICAgICovXG4gICAgdGhpcy52aWV3UHJvcGVydHlMaXN0ZW5lcktleV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleX1cbiAgICAgKi9cbiAgICB0aGlzLnZpZXdDaGFuZ2VMaXN0ZW5lcktleV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi9ldmVudHMuanNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLmxheWVyR3JvdXBQcm9wZXJ0eUxpc3RlbmVyS2V5c18gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IUhUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMudmlld3BvcnRfID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy52aWV3cG9ydF8uY2xhc3NOYW1lID0gJ29sLXZpZXdwb3J0JyArIChUT1VDSCA/ICcgb2wtdG91Y2gnIDogJycpO1xuICAgIHRoaXMudmlld3BvcnRfLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICB0aGlzLnZpZXdwb3J0Xy5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgIHRoaXMudmlld3BvcnRfLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgIHRoaXMudmlld3BvcnRfLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAvLyBwcmV2ZW50IHBhZ2Ugem9vbSBvbiBJRSA+PSAxMCBicm93c2Vyc1xuICAgIHRoaXMudmlld3BvcnRfLnN0eWxlLm1zVG91Y2hBY3Rpb24gPSAnbm9uZSc7XG4gICAgdGhpcy52aWV3cG9ydF8uc3R5bGUudG91Y2hBY3Rpb24gPSAnbm9uZSc7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshSFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5vdmVybGF5Q29udGFpbmVyXyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMub3ZlcmxheUNvbnRhaW5lcl8uY2xhc3NOYW1lID0gJ29sLW92ZXJsYXljb250YWluZXInO1xuICAgIHRoaXMudmlld3BvcnRfLmFwcGVuZENoaWxkKHRoaXMub3ZlcmxheUNvbnRhaW5lcl8pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IUhUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMub3ZlcmxheUNvbnRhaW5lclN0b3BFdmVudF8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLm92ZXJsYXlDb250YWluZXJTdG9wRXZlbnRfLmNsYXNzTmFtZSA9ICdvbC1vdmVybGF5Y29udGFpbmVyLXN0b3BldmVudCc7XG4gICAgdmFyIG92ZXJsYXlFdmVudHMgPSBbXG4gICAgICBFdmVudFR5cGUuQ0xJQ0ssXG4gICAgICBFdmVudFR5cGUuREJMQ0xJQ0ssXG4gICAgICBFdmVudFR5cGUuTU9VU0VET1dOLFxuICAgICAgRXZlbnRUeXBlLlRPVUNIU1RBUlQsXG4gICAgICBFdmVudFR5cGUuTVNQT0lOVEVSRE9XTixcbiAgICAgIE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUkRPV04sXG4gICAgICBFdmVudFR5cGUuTU9VU0VXSEVFTCxcbiAgICAgIEV2ZW50VHlwZS5XSEVFTFxuICAgIF07XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gb3ZlcmxheUV2ZW50cy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBsaXN0ZW4odGhpcy5vdmVybGF5Q29udGFpbmVyU3RvcEV2ZW50Xywgb3ZlcmxheUV2ZW50c1tpXSwgc3RvcFByb3BhZ2F0aW9uKTtcbiAgICB9XG4gICAgdGhpcy52aWV3cG9ydF8uYXBwZW5kQ2hpbGQodGhpcy5vdmVybGF5Q29udGFpbmVyU3RvcEV2ZW50Xyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtNYXBCcm93c2VyRXZlbnRIYW5kbGVyfVxuICAgICAqL1xuICAgIHRoaXMubWFwQnJvd3NlckV2ZW50SGFuZGxlcl8gPSBuZXcgTWFwQnJvd3NlckV2ZW50SGFuZGxlcih0aGlzLCBvcHRpb25zLm1vdmVUb2xlcmFuY2UpO1xuICAgIGZvciAodmFyIGtleSBpbiBNYXBCcm93c2VyRXZlbnRUeXBlKSB7XG4gICAgICBsaXN0ZW4odGhpcy5tYXBCcm93c2VyRXZlbnRIYW5kbGVyXywgTWFwQnJvd3NlckV2ZW50VHlwZVtrZXldLFxuICAgICAgICB0aGlzLmhhbmRsZU1hcEJyb3dzZXJFdmVudCwgdGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR8RG9jdW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5rZXlib2FyZEV2ZW50VGFyZ2V0XyA9IG9wdGlvbnNJbnRlcm5hbC5rZXlib2FyZEV2ZW50VGFyZ2V0O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi9ldmVudHMuanNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLmtleUhhbmRsZXJLZXlzXyA9IG51bGw7XG5cbiAgICBsaXN0ZW4odGhpcy52aWV3cG9ydF8sIEV2ZW50VHlwZS5DT05URVhUTUVOVSwgdGhpcy5oYW5kbGVCcm93c2VyRXZlbnQsIHRoaXMpO1xuICAgIGxpc3Rlbih0aGlzLnZpZXdwb3J0XywgRXZlbnRUeXBlLldIRUVMLCB0aGlzLmhhbmRsZUJyb3dzZXJFdmVudCwgdGhpcyk7XG4gICAgbGlzdGVuKHRoaXMudmlld3BvcnRfLCBFdmVudFR5cGUuTU9VU0VXSEVFTCwgdGhpcy5oYW5kbGVCcm93c2VyRXZlbnQsIHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0NvbGxlY3Rpb248aW1wb3J0KFwiLi9jb250cm9sL0NvbnRyb2wuanNcIikuZGVmYXVsdD59XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRoaXMuY29udHJvbHMgPSBvcHRpb25zSW50ZXJuYWwuY29udHJvbHMgfHwgbmV3IENvbGxlY3Rpb24oKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtDb2xsZWN0aW9uPGltcG9ydChcIi4vaW50ZXJhY3Rpb24vSW50ZXJhY3Rpb24uanNcIikuZGVmYXVsdD59XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRoaXMuaW50ZXJhY3Rpb25zID0gb3B0aW9uc0ludGVybmFsLmludGVyYWN0aW9ucyB8fCBuZXcgQ29sbGVjdGlvbigpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0NvbGxlY3Rpb248aW1wb3J0KFwiLi9PdmVybGF5LmpzXCIpLmRlZmF1bHQ+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5vdmVybGF5c18gPSBvcHRpb25zSW50ZXJuYWwub3ZlcmxheXM7XG5cbiAgICAvKipcbiAgICAgKiBBIGxvb2t1cCBvZiBvdmVybGF5cyBieSBpZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuL092ZXJsYXkuanNcIikuZGVmYXVsdD59XG4gICAgICovXG4gICAgdGhpcy5vdmVybGF5SWRJbmRleF8gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL3JlbmRlcmVyL01hcC5qc1wiKS5kZWZhdWx0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlcl8gPSB0aGlzLmNyZWF0ZVJlbmRlcmVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oRXZlbnQpfHVuZGVmaW5lZH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaGFuZGxlUmVzaXplXztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfVxuICAgICAqL1xuICAgIHRoaXMuZm9jdXNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFBcnJheTxQb3N0UmVuZGVyRnVuY3Rpb24+fVxuICAgICAqL1xuICAgIHRoaXMucG9zdFJlbmRlckZ1bmN0aW9uc18gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge1RpbGVRdWV1ZX1cbiAgICAgKi9cbiAgICB0aGlzLnRpbGVRdWV1ZV8gPSBuZXcgVGlsZVF1ZXVlKFxuICAgICAgdGhpcy5nZXRUaWxlUHJpb3JpdHkuYmluZCh0aGlzKSxcbiAgICAgIHRoaXMuaGFuZGxlVGlsZUNoYW5nZV8uYmluZCh0aGlzKSk7XG5cbiAgICAvKipcbiAgICAgKiBVaWRzIG9mIGZlYXR1cmVzIHRvIHNraXAgYXQgcmVuZGVyaW5nIHRpbWUuXG4gICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsIGJvb2xlYW4+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5za2lwcGVkRmVhdHVyZVVpZHNfID0ge307XG5cbiAgICBsaXN0ZW4oXG4gICAgICB0aGlzLCBnZXRDaGFuZ2VFdmVudFR5cGUoTWFwUHJvcGVydHkuTEFZRVJHUk9VUCksXG4gICAgICB0aGlzLmhhbmRsZUxheWVyR3JvdXBDaGFuZ2VkXywgdGhpcyk7XG4gICAgbGlzdGVuKHRoaXMsIGdldENoYW5nZUV2ZW50VHlwZShNYXBQcm9wZXJ0eS5WSUVXKSxcbiAgICAgIHRoaXMuaGFuZGxlVmlld0NoYW5nZWRfLCB0aGlzKTtcbiAgICBsaXN0ZW4odGhpcywgZ2V0Q2hhbmdlRXZlbnRUeXBlKE1hcFByb3BlcnR5LlNJWkUpLFxuICAgICAgdGhpcy5oYW5kbGVTaXplQ2hhbmdlZF8sIHRoaXMpO1xuICAgIGxpc3Rlbih0aGlzLCBnZXRDaGFuZ2VFdmVudFR5cGUoTWFwUHJvcGVydHkuVEFSR0VUKSxcbiAgICAgIHRoaXMuaGFuZGxlVGFyZ2V0Q2hhbmdlZF8sIHRoaXMpO1xuXG4gICAgLy8gc2V0UHJvcGVydGllcyB3aWxsIHRyaWdnZXIgdGhlIHJlbmRlcmluZyBvZiB0aGUgbWFwIGlmIHRoZSBtYXBcbiAgICAvLyBpcyBcImRlZmluZWRcIiBhbHJlYWR5LlxuICAgIHRoaXMuc2V0UHJvcGVydGllcyhvcHRpb25zSW50ZXJuYWwudmFsdWVzKTtcblxuICAgIHRoaXMuY29udHJvbHMuZm9yRWFjaChcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2NvbnRyb2wvQ29udHJvbC5qc1wiKS5kZWZhdWx0fSBjb250cm9sIENvbnRyb2wuXG4gICAgICAgKiBAdGhpcyB7UGx1Z2dhYmxlTWFwfVxuICAgICAgICovXG4gICAgICAoZnVuY3Rpb24oY29udHJvbCkge1xuICAgICAgICBjb250cm9sLnNldE1hcCh0aGlzKTtcbiAgICAgIH0pLmJpbmQodGhpcykpO1xuXG4gICAgbGlzdGVuKHRoaXMuY29udHJvbHMsIENvbGxlY3Rpb25FdmVudFR5cGUuQURELFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vQ29sbGVjdGlvbi5qc1wiKS5Db2xsZWN0aW9uRXZlbnR9IGV2ZW50IENvbGxlY3Rpb25FdmVudC5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgZXZlbnQuZWxlbWVudC5zZXRNYXAodGhpcyk7XG4gICAgICB9LCB0aGlzKTtcblxuICAgIGxpc3Rlbih0aGlzLmNvbnRyb2xzLCBDb2xsZWN0aW9uRXZlbnRUeXBlLlJFTU9WRSxcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0NvbGxlY3Rpb24uanNcIikuQ29sbGVjdGlvbkV2ZW50fSBldmVudCBDb2xsZWN0aW9uRXZlbnQuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LmVsZW1lbnQuc2V0TWFwKG51bGwpO1xuICAgICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLmludGVyYWN0aW9ucy5mb3JFYWNoKFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vaW50ZXJhY3Rpb24vSW50ZXJhY3Rpb24uanNcIikuZGVmYXVsdH0gaW50ZXJhY3Rpb24gSW50ZXJhY3Rpb24uXG4gICAgICAgKiBAdGhpcyB7UGx1Z2dhYmxlTWFwfVxuICAgICAgICovXG4gICAgICAoZnVuY3Rpb24oaW50ZXJhY3Rpb24pIHtcbiAgICAgICAgaW50ZXJhY3Rpb24uc2V0TWFwKHRoaXMpO1xuICAgICAgfSkuYmluZCh0aGlzKSk7XG5cbiAgICBsaXN0ZW4odGhpcy5pbnRlcmFjdGlvbnMsIENvbGxlY3Rpb25FdmVudFR5cGUuQURELFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vQ29sbGVjdGlvbi5qc1wiKS5Db2xsZWN0aW9uRXZlbnR9IGV2ZW50IENvbGxlY3Rpb25FdmVudC5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgZXZlbnQuZWxlbWVudC5zZXRNYXAodGhpcyk7XG4gICAgICB9LCB0aGlzKTtcblxuICAgIGxpc3Rlbih0aGlzLmludGVyYWN0aW9ucywgQ29sbGVjdGlvbkV2ZW50VHlwZS5SRU1PVkUsXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9Db2xsZWN0aW9uLmpzXCIpLkNvbGxlY3Rpb25FdmVudH0gZXZlbnQgQ29sbGVjdGlvbkV2ZW50LlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBldmVudC5lbGVtZW50LnNldE1hcChudWxsKTtcbiAgICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5vdmVybGF5c18uZm9yRWFjaCh0aGlzLmFkZE92ZXJsYXlJbnRlcm5hbF8uYmluZCh0aGlzKSk7XG5cbiAgICBsaXN0ZW4odGhpcy5vdmVybGF5c18sIENvbGxlY3Rpb25FdmVudFR5cGUuQURELFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vQ29sbGVjdGlvbi5qc1wiKS5Db2xsZWN0aW9uRXZlbnR9IGV2ZW50IENvbGxlY3Rpb25FdmVudC5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5hZGRPdmVybGF5SW50ZXJuYWxfKC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9PdmVybGF5LmpzXCIpLmRlZmF1bHR9ICovIChldmVudC5lbGVtZW50KSk7XG4gICAgICB9LCB0aGlzKTtcblxuICAgIGxpc3Rlbih0aGlzLm92ZXJsYXlzXywgQ29sbGVjdGlvbkV2ZW50VHlwZS5SRU1PVkUsXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9Db2xsZWN0aW9uLmpzXCIpLkNvbGxlY3Rpb25FdmVudH0gZXZlbnQgQ29sbGVjdGlvbkV2ZW50LlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgb3ZlcmxheSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9PdmVybGF5LmpzXCIpLmRlZmF1bHR9ICovIChldmVudC5lbGVtZW50KTtcbiAgICAgICAgdmFyIGlkID0gb3ZlcmxheS5nZXRJZCgpO1xuICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLm92ZXJsYXlJZEluZGV4X1tpZC50b1N0cmluZygpXTtcbiAgICAgICAgfVxuICAgICAgICBldmVudC5lbGVtZW50LnNldE1hcChudWxsKTtcbiAgICAgIH0sIHRoaXMpO1xuXG4gIH1cblxuICBpZiAoIEJhc2VPYmplY3QgKSBQbHVnZ2FibGVNYXAuX19wcm90b19fID0gQmFzZU9iamVjdDtcbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJhc2VPYmplY3QgJiYgQmFzZU9iamVjdC5wcm90b3R5cGUgKTtcbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBsdWdnYWJsZU1hcDtcblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vcmVuZGVyZXIvTWFwLmpzXCIpLmRlZmF1bHR9IFRoZSBtYXAgcmVuZGVyZXJcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuY3JlYXRlUmVuZGVyZXIgPSBmdW5jdGlvbiBjcmVhdGVSZW5kZXJlciAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVc2UgYSBtYXAgdHlwZSB0aGF0IGhhcyBhIGNyZWF0ZVJlbmRlcmVyIG1ldGhvZCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgdGhlIGdpdmVuIGNvbnRyb2wgdG8gdGhlIG1hcC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2NvbnRyb2wvQ29udHJvbC5qc1wiKS5kZWZhdWx0fSBjb250cm9sIENvbnRyb2wuXG4gICAqIEBhcGlcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuYWRkQ29udHJvbCA9IGZ1bmN0aW9uIGFkZENvbnRyb2wgKGNvbnRyb2wpIHtcbiAgICB0aGlzLmdldENvbnRyb2xzKCkucHVzaChjb250cm9sKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIHRoZSBnaXZlbiBpbnRlcmFjdGlvbiB0byB0aGUgbWFwLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vaW50ZXJhY3Rpb24vSW50ZXJhY3Rpb24uanNcIikuZGVmYXVsdH0gaW50ZXJhY3Rpb24gSW50ZXJhY3Rpb24gdG8gYWRkLlxuICAgKiBAYXBpXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLmFkZEludGVyYWN0aW9uID0gZnVuY3Rpb24gYWRkSW50ZXJhY3Rpb24gKGludGVyYWN0aW9uKSB7XG4gICAgdGhpcy5nZXRJbnRlcmFjdGlvbnMoKS5wdXNoKGludGVyYWN0aW9uKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkcyB0aGUgZ2l2ZW4gbGF5ZXIgdG8gdGhlIHRvcCBvZiB0aGlzIG1hcC4gSWYgeW91IHdhbnQgdG8gYWRkIGEgbGF5ZXJcbiAgICogZWxzZXdoZXJlIGluIHRoZSBzdGFjaywgdXNlIGBnZXRMYXllcnMoKWAgYW5kIHRoZSBtZXRob2RzIGF2YWlsYWJsZSBvblxuICAgKiB7QGxpbmsgbW9kdWxlOm9sL0NvbGxlY3Rpb25+Q29sbGVjdGlvbn0uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9sYXllci9CYXNlLmpzXCIpLmRlZmF1bHR9IGxheWVyIExheWVyLlxuICAgKiBAYXBpXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLmFkZExheWVyID0gZnVuY3Rpb24gYWRkTGF5ZXIgKGxheWVyKSB7XG4gICAgdmFyIGxheWVycyA9IHRoaXMuZ2V0TGF5ZXJHcm91cCgpLmdldExheWVycygpO1xuICAgIGxheWVycy5wdXNoKGxheWVyKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIHRoZSBnaXZlbiBvdmVybGF5IHRvIHRoZSBtYXAuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9PdmVybGF5LmpzXCIpLmRlZmF1bHR9IG92ZXJsYXkgT3ZlcmxheS5cbiAgICogQGFwaVxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5hZGRPdmVybGF5ID0gZnVuY3Rpb24gYWRkT3ZlcmxheSAob3ZlcmxheSkge1xuICAgIHRoaXMuZ2V0T3ZlcmxheXMoKS5wdXNoKG92ZXJsYXkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGRlYWxzIHdpdGggbWFwJ3Mgb3ZlcmxheSBjb2xsZWN0aW9uIGNoYW5nZXMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9PdmVybGF5LmpzXCIpLmRlZmF1bHR9IG92ZXJsYXkgT3ZlcmxheS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuYWRkT3ZlcmxheUludGVybmFsXyA9IGZ1bmN0aW9uIGFkZE92ZXJsYXlJbnRlcm5hbF8gKG92ZXJsYXkpIHtcbiAgICB2YXIgaWQgPSBvdmVybGF5LmdldElkKCk7XG4gICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMub3ZlcmxheUlkSW5kZXhfW2lkLnRvU3RyaW5nKCldID0gb3ZlcmxheTtcbiAgICB9XG4gICAgb3ZlcmxheS5zZXRNYXAodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLmRpc3Bvc2VJbnRlcm5hbCA9IGZ1bmN0aW9uIGRpc3Bvc2VJbnRlcm5hbCAoKSB7XG4gICAgdGhpcy5tYXBCcm93c2VyRXZlbnRIYW5kbGVyXy5kaXNwb3NlKCk7XG4gICAgdW5saXN0ZW4odGhpcy52aWV3cG9ydF8sIEV2ZW50VHlwZS5DT05URVhUTUVOVSwgdGhpcy5oYW5kbGVCcm93c2VyRXZlbnQsIHRoaXMpO1xuICAgIHVubGlzdGVuKHRoaXMudmlld3BvcnRfLCBFdmVudFR5cGUuV0hFRUwsIHRoaXMuaGFuZGxlQnJvd3NlckV2ZW50LCB0aGlzKTtcbiAgICB1bmxpc3Rlbih0aGlzLnZpZXdwb3J0XywgRXZlbnRUeXBlLk1PVVNFV0hFRUwsIHRoaXMuaGFuZGxlQnJvd3NlckV2ZW50LCB0aGlzKTtcbiAgICBpZiAodGhpcy5oYW5kbGVSZXNpemVfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoRXZlbnRUeXBlLlJFU0laRSwgdGhpcy5oYW5kbGVSZXNpemVfLCBmYWxzZSk7XG4gICAgICB0aGlzLmhhbmRsZVJlc2l6ZV8gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmFuaW1hdGlvbkRlbGF5S2V5Xykge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRpb25EZWxheUtleV8pO1xuICAgICAgdGhpcy5hbmltYXRpb25EZWxheUtleV8gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRoaXMuc2V0VGFyZ2V0KG51bGwpO1xuICAgIEJhc2VPYmplY3QucHJvdG90eXBlLmRpc3Bvc2VJbnRlcm5hbC5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXRlY3QgZmVhdHVyZXMgdGhhdCBpbnRlcnNlY3QgYSBwaXhlbCBvbiB0aGUgdmlld3BvcnQsIGFuZCBleGVjdXRlIGFcbiAgICogY2FsbGJhY2sgd2l0aCBlYWNoIGludGVyc2VjdGluZyBmZWF0dXJlLiBMYXllcnMgaW5jbHVkZWQgaW4gdGhlIGRldGVjdGlvbiBjYW5cbiAgICogYmUgY29uZmlndXJlZCB0aHJvdWdoIHRoZSBgbGF5ZXJGaWx0ZXJgIG9wdGlvbiBpbiBgb3B0X29wdGlvbnNgLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vcGl4ZWwuanNcIikuUGl4ZWx9IHBpeGVsIFBpeGVsLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6IFMsIGltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZSxcbiAgICogICAgIGltcG9ydChcIi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdCk6IFR9IGNhbGxiYWNrIEZlYXR1cmUgY2FsbGJhY2suIFRoZSBjYWxsYmFjayB3aWxsIGJlXG4gICAqICAgICBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzLiBUaGUgZmlyc3QgYXJndW1lbnQgaXMgb25lXG4gICAqICAgICB7QGxpbmsgbW9kdWxlOm9sL0ZlYXR1cmUgZmVhdHVyZX0gb3JcbiAgICogICAgIHtAbGluayBtb2R1bGU6b2wvcmVuZGVyL0ZlYXR1cmUgcmVuZGVyIGZlYXR1cmV9IGF0IHRoZSBwaXhlbCwgdGhlIHNlY29uZCBpc1xuICAgKiAgICAgdGhlIHtAbGluayBtb2R1bGU6b2wvbGF5ZXIvTGF5ZXIgbGF5ZXJ9IG9mIHRoZSBmZWF0dXJlIGFuZCB3aWxsIGJlIG51bGwgZm9yXG4gICAqICAgICB1bm1hbmFnZWQgbGF5ZXJzLiBUbyBzdG9wIGRldGVjdGlvbiwgY2FsbGJhY2sgZnVuY3Rpb25zIGNhbiByZXR1cm4gYVxuICAgKiAgICAgdHJ1dGh5IHZhbHVlLlxuICAgKiBAcGFyYW0ge0F0UGl4ZWxPcHRpb25zPX0gb3B0X29wdGlvbnMgT3B0aW9uYWwgb3B0aW9ucy5cbiAgICogQHJldHVybiB7VHx1bmRlZmluZWR9IENhbGxiYWNrIHJlc3VsdCwgaS5lLiB0aGUgcmV0dXJuIHZhbHVlIG9mIGxhc3RcbiAgICogY2FsbGJhY2sgZXhlY3V0aW9uLCBvciB0aGUgZmlyc3QgdHJ1dGh5IGNhbGxiYWNrIHJldHVybiB2YWx1ZS5cbiAgICogQHRlbXBsYXRlIFMsVFxuICAgKiBAYXBpXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLmZvckVhY2hGZWF0dXJlQXRQaXhlbCA9IGZ1bmN0aW9uIGZvckVhY2hGZWF0dXJlQXRQaXhlbCAocGl4ZWwsIGNhbGxiYWNrLCBvcHRfb3B0aW9ucykge1xuICAgIGlmICghdGhpcy5mcmFtZVN0YXRlXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY29vcmRpbmF0ZSA9IHRoaXMuZ2V0Q29vcmRpbmF0ZUZyb21QaXhlbChwaXhlbCk7XG4gICAgb3B0X29wdGlvbnMgPSBvcHRfb3B0aW9ucyAhPT0gdW5kZWZpbmVkID8gb3B0X29wdGlvbnMgOlxuICAgICAgLyoqIEB0eXBlIHtBdFBpeGVsT3B0aW9uc30gKi8gKHt9KTtcbiAgICB2YXIgaGl0VG9sZXJhbmNlID0gb3B0X29wdGlvbnMuaGl0VG9sZXJhbmNlICE9PSB1bmRlZmluZWQgP1xuICAgICAgb3B0X29wdGlvbnMuaGl0VG9sZXJhbmNlICogdGhpcy5mcmFtZVN0YXRlXy5waXhlbFJhdGlvIDogMDtcbiAgICB2YXIgbGF5ZXJGaWx0ZXIgPSBvcHRfb3B0aW9ucy5sYXllckZpbHRlciAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdF9vcHRpb25zLmxheWVyRmlsdGVyIDogVFJVRTtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJlcl8uZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGUoXG4gICAgICBjb29yZGluYXRlLCB0aGlzLmZyYW1lU3RhdGVfLCBoaXRUb2xlcmFuY2UsIGNhbGxiYWNrLCBudWxsLFxuICAgICAgbGF5ZXJGaWx0ZXIsIG51bGwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYWxsIGZlYXR1cmVzIHRoYXQgaW50ZXJzZWN0IGEgcGl4ZWwgb24gdGhlIHZpZXdwb3J0LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vcGl4ZWwuanNcIikuUGl4ZWx9IHBpeGVsIFBpeGVsLlxuICAgKiBAcGFyYW0ge0F0UGl4ZWxPcHRpb25zPX0gb3B0X29wdGlvbnMgT3B0aW9uYWwgb3B0aW9ucy5cbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlPn0gVGhlIGRldGVjdGVkIGZlYXR1cmVzIG9yXG4gICAqIGBudWxsYCBpZiBub25lIHdlcmUgZm91bmQuXG4gICAqIEBhcGlcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuZ2V0RmVhdHVyZXNBdFBpeGVsID0gZnVuY3Rpb24gZ2V0RmVhdHVyZXNBdFBpeGVsIChwaXhlbCwgb3B0X29wdGlvbnMpIHtcbiAgICB2YXIgZmVhdHVyZXMgPSBudWxsO1xuICAgIHRoaXMuZm9yRWFjaEZlYXR1cmVBdFBpeGVsKHBpeGVsLCBmdW5jdGlvbihmZWF0dXJlKSB7XG4gICAgICBpZiAoIWZlYXR1cmVzKSB7XG4gICAgICAgIGZlYXR1cmVzID0gW107XG4gICAgICB9XG4gICAgICBmZWF0dXJlcy5wdXNoKGZlYXR1cmUpO1xuICAgIH0sIG9wdF9vcHRpb25zKTtcbiAgICByZXR1cm4gZmVhdHVyZXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIERldGVjdCBsYXllcnMgdGhhdCBoYXZlIGEgY29sb3IgdmFsdWUgYXQgYSBwaXhlbCBvbiB0aGUgdmlld3BvcnQsIGFuZFxuICAgKiBleGVjdXRlIGEgY2FsbGJhY2sgd2l0aCBlYWNoIG1hdGNoaW5nIGxheWVyLiBMYXllcnMgaW5jbHVkZWQgaW4gdGhlXG4gICAqIGRldGVjdGlvbiBjYW4gYmUgY29uZmlndXJlZCB0aHJvdWdoIGBvcHRfbGF5ZXJGaWx0ZXJgLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vcGl4ZWwuanNcIikuUGl4ZWx9IHBpeGVsIFBpeGVsLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6IFMsIGltcG9ydChcIi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdCwgKFVpbnQ4Q2xhbXBlZEFycmF5fFVpbnQ4QXJyYXkpKTogVH0gY2FsbGJhY2tcbiAgICogICAgIExheWVyIGNhbGxiYWNrLiBUaGlzIGNhbGxiYWNrIHdpbGwgcmVjZWl2ZSB0d28gYXJndW1lbnRzOiBmaXJzdCBpcyB0aGVcbiAgICogICAgIHtAbGluayBtb2R1bGU6b2wvbGF5ZXIvTGF5ZXIgbGF5ZXJ9LCBzZWNvbmQgYXJndW1lbnQgaXMgYW4gYXJyYXkgcmVwcmVzZW50aW5nXG4gICAqICAgICBbUiwgRywgQiwgQV0gcGl4ZWwgdmFsdWVzICgwIC0gMjU1KSBhbmQgd2lsbCBiZSBgbnVsbGAgZm9yIGxheWVyIHR5cGVzXG4gICAqICAgICB0aGF0IGRvIG5vdCBjdXJyZW50bHkgc3VwcG9ydCB0aGlzIGFyZ3VtZW50LiBUbyBzdG9wIGRldGVjdGlvbiwgY2FsbGJhY2tcbiAgICogICAgIGZ1bmN0aW9ucyBjYW4gcmV0dXJuIGEgdHJ1dGh5IHZhbHVlLlxuICAgKiBAcGFyYW0ge0F0UGl4ZWxPcHRpb25zPX0gb3B0X29wdGlvbnMgQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtUfHVuZGVmaW5lZH0gQ2FsbGJhY2sgcmVzdWx0LCBpLmUuIHRoZSByZXR1cm4gdmFsdWUgb2YgbGFzdFxuICAgKiBjYWxsYmFjayBleGVjdXRpb24sIG9yIHRoZSBmaXJzdCB0cnV0aHkgY2FsbGJhY2sgcmV0dXJuIHZhbHVlLlxuICAgKiBAdGVtcGxhdGUgUyxUXG4gICAqIEBhcGlcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuZm9yRWFjaExheWVyQXRQaXhlbCA9IGZ1bmN0aW9uIGZvckVhY2hMYXllckF0UGl4ZWwgKHBpeGVsLCBjYWxsYmFjaywgb3B0X29wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuZnJhbWVTdGF0ZV8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRfb3B0aW9ucyB8fCAvKiogQHR5cGUge0F0UGl4ZWxPcHRpb25zfSAqLyAoe30pO1xuICAgIHZhciBoaXRUb2xlcmFuY2UgPSBvcHRpb25zLmhpdFRvbGVyYW5jZSAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdF9vcHRpb25zLmhpdFRvbGVyYW5jZSAqIHRoaXMuZnJhbWVTdGF0ZV8ucGl4ZWxSYXRpbyA6IDA7XG4gICAgdmFyIGxheWVyRmlsdGVyID0gb3B0aW9ucy5sYXllckZpbHRlciB8fCBUUlVFO1xuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyXy5mb3JFYWNoTGF5ZXJBdFBpeGVsKFxuICAgICAgcGl4ZWwsIHRoaXMuZnJhbWVTdGF0ZV8sIGhpdFRvbGVyYW5jZSwgY2FsbGJhY2ssIG51bGwsIGxheWVyRmlsdGVyLCBudWxsKTtcbiAgfTtcblxuICAvKipcbiAgICogRGV0ZWN0IGlmIGZlYXR1cmVzIGludGVyc2VjdCBhIHBpeGVsIG9uIHRoZSB2aWV3cG9ydC4gTGF5ZXJzIGluY2x1ZGVkIGluIHRoZVxuICAgKiBkZXRlY3Rpb24gY2FuIGJlIGNvbmZpZ3VyZWQgdGhyb3VnaCBgb3B0X2xheWVyRmlsdGVyYC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3BpeGVsLmpzXCIpLlBpeGVsfSBwaXhlbCBQaXhlbC5cbiAgICogQHBhcmFtIHtBdFBpeGVsT3B0aW9ucz19IG9wdF9vcHRpb25zIE9wdGlvbmFsIG9wdGlvbnMuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIHRoZXJlIGEgZmVhdHVyZSBhdCB0aGUgZ2l2ZW4gcGl4ZWw/XG4gICAqIEB0ZW1wbGF0ZSBVXG4gICAqIEBhcGlcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuaGFzRmVhdHVyZUF0UGl4ZWwgPSBmdW5jdGlvbiBoYXNGZWF0dXJlQXRQaXhlbCAocGl4ZWwsIG9wdF9vcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmZyYW1lU3RhdGVfKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBjb29yZGluYXRlID0gdGhpcy5nZXRDb29yZGluYXRlRnJvbVBpeGVsKHBpeGVsKTtcbiAgICBvcHRfb3B0aW9ucyA9IG9wdF9vcHRpb25zICE9PSB1bmRlZmluZWQgPyBvcHRfb3B0aW9ucyA6XG4gICAgICAvKiogQHR5cGUge0F0UGl4ZWxPcHRpb25zfSAqLyAoe30pO1xuICAgIHZhciBsYXllckZpbHRlciA9IG9wdF9vcHRpb25zLmxheWVyRmlsdGVyICE9PSB1bmRlZmluZWQgPyBvcHRfb3B0aW9ucy5sYXllckZpbHRlciA6IFRSVUU7XG4gICAgdmFyIGhpdFRvbGVyYW5jZSA9IG9wdF9vcHRpb25zLmhpdFRvbGVyYW5jZSAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdF9vcHRpb25zLmhpdFRvbGVyYW5jZSAqIHRoaXMuZnJhbWVTdGF0ZV8ucGl4ZWxSYXRpbyA6IDA7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZXJfLmhhc0ZlYXR1cmVBdENvb3JkaW5hdGUoXG4gICAgICBjb29yZGluYXRlLCB0aGlzLmZyYW1lU3RhdGVfLCBoaXRUb2xlcmFuY2UsIGxheWVyRmlsdGVyLCBudWxsKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY29vcmRpbmF0ZSBpbiB2aWV3IHByb2plY3Rpb24gZm9yIGEgYnJvd3NlciBldmVudC5cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgRXZlbnQuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBDb29yZGluYXRlLlxuICAgKiBAYXBpXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLmdldEV2ZW50Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldEV2ZW50Q29vcmRpbmF0ZSAoZXZlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDb29yZGluYXRlRnJvbVBpeGVsKHRoaXMuZ2V0RXZlbnRQaXhlbChldmVudCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBtYXAgcGl4ZWwgcG9zaXRpb24gZm9yIGEgYnJvd3NlciBldmVudCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQuXG4gICAqIEBwYXJhbSB7RXZlbnR8VG91Y2hFdmVudH0gZXZlbnQgRXZlbnQuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vcGl4ZWwuanNcIikuUGl4ZWx9IFBpeGVsLlxuICAgKiBAYXBpXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLmdldEV2ZW50UGl4ZWwgPSBmdW5jdGlvbiBnZXRFdmVudFBpeGVsIChldmVudCkge1xuICAgIHZhciB2aWV3cG9ydFBvc2l0aW9uID0gdGhpcy52aWV3cG9ydF8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIGV2ZW50UG9zaXRpb24gPSAnY2hhbmdlZFRvdWNoZXMnIGluIGV2ZW50ID9cbiAgICAgIC8qKiBAdHlwZSB7VG91Y2hFdmVudH0gKi8gKGV2ZW50KS5jaGFuZ2VkVG91Y2hlc1swXSA6XG4gICAgICAvKiogQHR5cGUge01vdXNlRXZlbnR9ICovIChldmVudCk7XG5cbiAgICByZXR1cm4gW1xuICAgICAgZXZlbnRQb3NpdGlvbi5jbGllbnRYIC0gdmlld3BvcnRQb3NpdGlvbi5sZWZ0LFxuICAgICAgZXZlbnRQb3NpdGlvbi5jbGllbnRZIC0gdmlld3BvcnRQb3NpdGlvbi50b3BcbiAgICBdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRhcmdldCBpbiB3aGljaCB0aGlzIG1hcCBpcyByZW5kZXJlZC5cbiAgICogTm90ZSB0aGF0IHRoaXMgcmV0dXJucyB3aGF0IGlzIGVudGVyZWQgYXMgYW4gb3B0aW9uIG9yIGluIHNldFRhcmdldDpcbiAgICogaWYgdGhhdCB3YXMgYW4gZWxlbWVudCwgaXQgcmV0dXJucyBhbiBlbGVtZW50OyBpZiBhIHN0cmluZywgaXQgcmV0dXJucyB0aGF0LlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudHxzdHJpbmd8dW5kZWZpbmVkfSBUaGUgRWxlbWVudCBvciBpZCBvZiB0aGUgRWxlbWVudCB0aGF0IHRoZVxuICAgKiAgICAgbWFwIGlzIHJlbmRlcmVkIGluLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLmdldFRhcmdldCA9IGZ1bmN0aW9uIGdldFRhcmdldCAoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR8c3RyaW5nfHVuZGVmaW5lZH0gKi8gKHRoaXMuZ2V0KE1hcFByb3BlcnR5LlRBUkdFVCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIERPTSBlbGVtZW50IGludG8gd2hpY2ggdGhpcyBtYXAgaXMgcmVuZGVyZWQuIEluIGNvbnRyYXN0IHRvXG4gICAqIGBnZXRUYXJnZXRgIHRoaXMgbWV0aG9kIGFsd2F5cyByZXR1cm4gYW4gYEVsZW1lbnRgLCBvciBgbnVsbGAgaWYgdGhlXG4gICAqIG1hcCBoYXMgbm8gdGFyZ2V0LlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gVGhlIGVsZW1lbnQgdGhhdCB0aGUgbWFwIGlzIHJlbmRlcmVkIGluLlxuICAgKiBAYXBpXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLmdldFRhcmdldEVsZW1lbnQgPSBmdW5jdGlvbiBnZXRUYXJnZXRFbGVtZW50ICgpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy5nZXRUYXJnZXQoKTtcbiAgICBpZiAodGFyZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRhcmdldCkgOiB0YXJnZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjb29yZGluYXRlIGZvciBhIGdpdmVuIHBpeGVsLiAgVGhpcyByZXR1cm5zIGEgY29vcmRpbmF0ZSBpbiB0aGVcbiAgICogbWFwIHZpZXcgcHJvamVjdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3BpeGVsLmpzXCIpLlBpeGVsfSBwaXhlbCBQaXhlbCBwb3NpdGlvbiBpbiB0aGUgbWFwIHZpZXdwb3J0LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gVGhlIGNvb3JkaW5hdGUgZm9yIHRoZSBwaXhlbCBwb3NpdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5nZXRDb29yZGluYXRlRnJvbVBpeGVsID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZUZyb21QaXhlbCAocGl4ZWwpIHtcbiAgICB2YXIgZnJhbWVTdGF0ZSA9IHRoaXMuZnJhbWVTdGF0ZV87XG4gICAgaWYgKCFmcmFtZVN0YXRlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFwcGx5VHJhbnNmb3JtKGZyYW1lU3RhdGUucGl4ZWxUb0Nvb3JkaW5hdGVUcmFuc2Zvcm0sIHBpeGVsLnNsaWNlKCkpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBtYXAgY29udHJvbHMuIE1vZGlmeWluZyB0aGlzIGNvbGxlY3Rpb24gY2hhbmdlcyB0aGUgY29udHJvbHNcbiAgICogYXNzb2NpYXRlZCB3aXRoIHRoZSBtYXAuXG4gICAqIEByZXR1cm4ge0NvbGxlY3Rpb248aW1wb3J0KFwiLi9jb250cm9sL0NvbnRyb2wuanNcIikuZGVmYXVsdD59IENvbnRyb2xzLlxuICAgKiBAYXBpXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLmdldENvbnRyb2xzID0gZnVuY3Rpb24gZ2V0Q29udHJvbHMgKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRyb2xzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1hcCBvdmVybGF5cy4gTW9kaWZ5aW5nIHRoaXMgY29sbGVjdGlvbiBjaGFuZ2VzIHRoZSBvdmVybGF5c1xuICAgKiBhc3NvY2lhdGVkIHdpdGggdGhlIG1hcC5cbiAgICogQHJldHVybiB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuL092ZXJsYXkuanNcIikuZGVmYXVsdD59IE92ZXJsYXlzLlxuICAgKiBAYXBpXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLmdldE92ZXJsYXlzID0gZnVuY3Rpb24gZ2V0T3ZlcmxheXMgKCkge1xuICAgIHJldHVybiB0aGlzLm92ZXJsYXlzXztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGFuIG92ZXJsYXkgYnkgaXRzIGlkZW50aWZpZXIgKHRoZSB2YWx1ZSByZXR1cm5lZCBieSBvdmVybGF5LmdldElkKCkpLlxuICAgKiBOb3RlIHRoYXQgdGhlIGluZGV4IHRyZWF0cyBzdHJpbmcgYW5kIG51bWVyaWMgaWRlbnRpZmllcnMgYXMgdGhlIHNhbWUuIFNvXG4gICAqIGBtYXAuZ2V0T3ZlcmxheUJ5SWQoMilgIHdpbGwgcmV0dXJuIGFuIG92ZXJsYXkgd2l0aCBpZCBgJzInYCBvciBgMmAuXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gaWQgT3ZlcmxheSBpZGVudGlmaWVyLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL092ZXJsYXkuanNcIikuZGVmYXVsdH0gT3ZlcmxheS5cbiAgICogQGFwaVxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5nZXRPdmVybGF5QnlJZCA9IGZ1bmN0aW9uIGdldE92ZXJsYXlCeUlkIChpZCkge1xuICAgIHZhciBvdmVybGF5ID0gdGhpcy5vdmVybGF5SWRJbmRleF9baWQudG9TdHJpbmcoKV07XG4gICAgcmV0dXJuIG92ZXJsYXkgIT09IHVuZGVmaW5lZCA/IG92ZXJsYXkgOiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1hcCBpbnRlcmFjdGlvbnMuIE1vZGlmeWluZyB0aGlzIGNvbGxlY3Rpb24gY2hhbmdlcyB0aGUgaW50ZXJhY3Rpb25zXG4gICAqIGFzc29jaWF0ZWQgd2l0aCB0aGUgbWFwLlxuICAgKlxuICAgKiBJbnRlcmFjdGlvbnMgYXJlIHVzZWQgZm9yIGUuZy4gcGFuLCB6b29tIGFuZCByb3RhdGUuXG4gICAqIEByZXR1cm4ge0NvbGxlY3Rpb248aW1wb3J0KFwiLi9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbi5qc1wiKS5kZWZhdWx0Pn0gSW50ZXJhY3Rpb25zLlxuICAgKiBAYXBpXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLmdldEludGVyYWN0aW9ucyA9IGZ1bmN0aW9uIGdldEludGVyYWN0aW9ucyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW50ZXJhY3Rpb25zO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxheWVyZ3JvdXAgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbWFwLlxuICAgKiBAcmV0dXJuIHtMYXllckdyb3VwfSBBIGxheWVyIGdyb3VwIGNvbnRhaW5pbmcgdGhlIGxheWVycyBpbiB0aGlzIG1hcC5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5nZXRMYXllckdyb3VwID0gZnVuY3Rpb24gZ2V0TGF5ZXJHcm91cCAoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIC8qKiBAdHlwZSB7TGF5ZXJHcm91cH0gKi8gKHRoaXMuZ2V0KE1hcFByb3BlcnR5LkxBWUVSR1JPVVApKVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY29sbGVjdGlvbiBvZiBsYXllcnMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbWFwLlxuICAgKiBAcmV0dXJuIHshQ29sbGVjdGlvbjxpbXBvcnQoXCIuL2xheWVyL0Jhc2UuanNcIikuZGVmYXVsdD59IExheWVycy5cbiAgICogQGFwaVxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5nZXRMYXllcnMgPSBmdW5jdGlvbiBnZXRMYXllcnMgKCkge1xuICAgIHZhciBsYXllcnMgPSB0aGlzLmdldExheWVyR3JvdXAoKS5nZXRMYXllcnMoKTtcbiAgICByZXR1cm4gbGF5ZXJzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHBpeGVsIGZvciBhIGNvb3JkaW5hdGUuICBUaGlzIHRha2VzIGEgY29vcmRpbmF0ZSBpbiB0aGUgbWFwIHZpZXdcbiAgICogcHJvamVjdGlvbiBhbmQgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwaXhlbC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBBIG1hcCBjb29yZGluYXRlLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL3BpeGVsLmpzXCIpLlBpeGVsfSBBIHBpeGVsIHBvc2l0aW9uIGluIHRoZSBtYXAgdmlld3BvcnQuXG4gICAqIEBhcGlcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuZ2V0UGl4ZWxGcm9tQ29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldFBpeGVsRnJvbUNvb3JkaW5hdGUgKGNvb3JkaW5hdGUpIHtcbiAgICB2YXIgZnJhbWVTdGF0ZSA9IHRoaXMuZnJhbWVTdGF0ZV87XG4gICAgaWYgKCFmcmFtZVN0YXRlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFwcGx5VHJhbnNmb3JtKGZyYW1lU3RhdGUuY29vcmRpbmF0ZVRvUGl4ZWxUcmFuc2Zvcm0sIGNvb3JkaW5hdGUuc2xpY2UoMCwgMikpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBtYXAgcmVuZGVyZXIuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vcmVuZGVyZXIvTWFwLmpzXCIpLmRlZmF1bHR9IFJlbmRlcmVyXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLmdldFJlbmRlcmVyID0gZnVuY3Rpb24gZ2V0UmVuZGVyZXIgKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyXztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBzaXplIG9mIHRoaXMgbWFwLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZXx1bmRlZmluZWR9IFRoZSBzaXplIGluIHBpeGVscyBvZiB0aGUgbWFwIGluIHRoZSBET00uXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuZ2V0U2l6ZSA9IGZ1bmN0aW9uIGdldFNpemUgKCkge1xuICAgIHJldHVybiAoXG4gICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfHVuZGVmaW5lZH0gKi8gKHRoaXMuZ2V0KE1hcFByb3BlcnR5LlNJWkUpKVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmlldyBhc3NvY2lhdGVkIHdpdGggdGhpcyBtYXAuIEEgdmlldyBtYW5hZ2VzIHByb3BlcnRpZXMgc3VjaCBhc1xuICAgKiBjZW50ZXIgYW5kIHJlc29sdXRpb24uXG4gICAqIEByZXR1cm4ge1ZpZXd9IFRoZSB2aWV3IHRoYXQgY29udHJvbHMgdGhpcyBtYXAuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuZ2V0VmlldyA9IGZ1bmN0aW9uIGdldFZpZXcgKCkge1xuICAgIHJldHVybiAoXG4gICAgICAvKiogQHR5cGUge1ZpZXd9ICovICh0aGlzLmdldChNYXBQcm9wZXJ0eS5WSUVXKSlcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGVsZW1lbnQgdGhhdCBzZXJ2ZXMgYXMgdGhlIG1hcCB2aWV3cG9ydC5cbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9IFZpZXdwb3J0LlxuICAgKiBAYXBpXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLmdldFZpZXdwb3J0ID0gZnVuY3Rpb24gZ2V0Vmlld3BvcnQgKCkge1xuICAgIHJldHVybiB0aGlzLnZpZXdwb3J0XztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBlbGVtZW50IHRoYXQgc2VydmVzIGFzIHRoZSBjb250YWluZXIgZm9yIG92ZXJsYXlzLiAgRWxlbWVudHMgYWRkZWQgdG9cbiAgICogdGhpcyBjb250YWluZXIgd2lsbCBsZXQgbW91c2Vkb3duIGFuZCB0b3VjaHN0YXJ0IGV2ZW50cyB0aHJvdWdoIHRvIHRoZSBtYXAsXG4gICAqIHNvIGNsaWNrcyBhbmQgZ2VzdHVyZXMgb24gYW4gb3ZlcmxheSB3aWxsIHRyaWdnZXIge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fVxuICAgKiBldmVudHMuXG4gICAqIEByZXR1cm4geyFIVE1MRWxlbWVudH0gVGhlIG1hcCdzIG92ZXJsYXkgY29udGFpbmVyLlxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5nZXRPdmVybGF5Q29udGFpbmVyID0gZnVuY3Rpb24gZ2V0T3ZlcmxheUNvbnRhaW5lciAoKSB7XG4gICAgcmV0dXJuIHRoaXMub3ZlcmxheUNvbnRhaW5lcl87XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZWxlbWVudCB0aGF0IHNlcnZlcyBhcyBhIGNvbnRhaW5lciBmb3Igb3ZlcmxheXMgdGhhdCBkb24ndCBhbGxvd1xuICAgKiBldmVudCBwcm9wYWdhdGlvbi4gRWxlbWVudHMgYWRkZWQgdG8gdGhpcyBjb250YWluZXIgd29uJ3QgbGV0IG1vdXNlZG93biBhbmRcbiAgICogdG91Y2hzdGFydCBldmVudHMgdGhyb3VnaCB0byB0aGUgbWFwLCBzbyBjbGlja3MgYW5kIGdlc3R1cmVzIG9uIGFuIG92ZXJsYXlcbiAgICogZG9uJ3QgdHJpZ2dlciBhbnkge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fS5cbiAgICogQHJldHVybiB7IUhUTUxFbGVtZW50fSBUaGUgbWFwJ3Mgb3ZlcmxheSBjb250YWluZXIgdGhhdCBzdG9wcyBldmVudHMuXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLmdldE92ZXJsYXlDb250YWluZXJTdG9wRXZlbnQgPSBmdW5jdGlvbiBnZXRPdmVybGF5Q29udGFpbmVyU3RvcEV2ZW50ICgpIHtcbiAgICByZXR1cm4gdGhpcy5vdmVybGF5Q29udGFpbmVyU3RvcEV2ZW50XztcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL1RpbGUuanNcIikuZGVmYXVsdH0gdGlsZSBUaWxlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGlsZVNvdXJjZUtleSBUaWxlIHNvdXJjZSBrZXkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IHRpbGVDZW50ZXIgVGlsZSBjZW50ZXIuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aWxlUmVzb2x1dGlvbiBUaWxlIHJlc29sdXRpb24uXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGlsZSBwcmlvcml0eS5cbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuZ2V0VGlsZVByaW9yaXR5ID0gZnVuY3Rpb24gZ2V0VGlsZVByaW9yaXR5ICh0aWxlLCB0aWxlU291cmNlS2V5LCB0aWxlQ2VudGVyLCB0aWxlUmVzb2x1dGlvbikge1xuICAgIC8vIEZpbHRlciBvdXQgdGlsZXMgYXQgaGlnaGVyIHpvb20gbGV2ZWxzIHRoYW4gdGhlIGN1cnJlbnQgem9vbSBsZXZlbCwgb3IgdGhhdFxuICAgIC8vIGFyZSBvdXRzaWRlIHRoZSB2aXNpYmxlIGV4dGVudC5cbiAgICB2YXIgZnJhbWVTdGF0ZSA9IHRoaXMuZnJhbWVTdGF0ZV87XG4gICAgaWYgKCFmcmFtZVN0YXRlIHx8ICEodGlsZVNvdXJjZUtleSBpbiBmcmFtZVN0YXRlLndhbnRlZFRpbGVzKSkge1xuICAgICAgcmV0dXJuIERST1A7XG4gICAgfVxuICAgIGlmICghZnJhbWVTdGF0ZS53YW50ZWRUaWxlc1t0aWxlU291cmNlS2V5XVt0aWxlLmdldEtleSgpXSkge1xuICAgICAgcmV0dXJuIERST1A7XG4gICAgfVxuICAgIC8vIFByaW9yaXRpemUgdGhlIGhpZ2hlc3Qgem9vbSBsZXZlbCB0aWxlcyBjbG9zZXN0IHRvIHRoZSBmb2N1cy5cbiAgICAvLyBUaWxlcyBhdCBoaWdoZXIgem9vbSBsZXZlbHMgYXJlIHByaW9yaXRpemVkIHVzaW5nIE1hdGgubG9nKHRpbGVSZXNvbHV0aW9uKS5cbiAgICAvLyBXaXRoaW4gYSB6b29tIGxldmVsLCB0aWxlcyBhcmUgcHJpb3JpdGl6ZWQgYnkgdGhlIGRpc3RhbmNlIGluIHBpeGVsc1xuICAgIC8vIGJldHdlZW4gdGhlIGNlbnRlciBvZiB0aGUgdGlsZSBhbmQgdGhlIGZvY3VzLiAgVGhlIGZhY3RvciBvZiA2NTUzNiBtZWFuc1xuICAgIC8vIHRoYXQgdGhlIHByaW9yaXRpemF0aW9uIHNob3VsZCBiZWhhdmUgYXMgZGVzaXJlZCBmb3IgdGlsZXMgdXAgdG9cbiAgICAvLyA2NTUzNiAqIE1hdGgubG9nKDIpID0gNDU0MjYgcGl4ZWxzIGZyb20gdGhlIGZvY3VzLlxuICAgIHZhciBkZWx0YVggPSB0aWxlQ2VudGVyWzBdIC0gZnJhbWVTdGF0ZS5mb2N1c1swXTtcbiAgICB2YXIgZGVsdGFZID0gdGlsZUNlbnRlclsxXSAtIGZyYW1lU3RhdGUuZm9jdXNbMV07XG4gICAgcmV0dXJuIDY1NTM2ICogTWF0aC5sb2codGlsZVJlc29sdXRpb24pICtcbiAgICAgICAgTWF0aC5zcXJ0KGRlbHRhWCAqIGRlbHRhWCArIGRlbHRhWSAqIGRlbHRhWSkgLyB0aWxlUmVzb2x1dGlvbjtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtFdmVudH0gYnJvd3NlckV2ZW50IEJyb3dzZXIgZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3R5cGUgVHlwZS5cbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuaGFuZGxlQnJvd3NlckV2ZW50ID0gZnVuY3Rpb24gaGFuZGxlQnJvd3NlckV2ZW50IChicm93c2VyRXZlbnQsIG9wdF90eXBlKSB7XG4gICAgdmFyIHR5cGUgPSBvcHRfdHlwZSB8fCBicm93c2VyRXZlbnQudHlwZTtcbiAgICB2YXIgbWFwQnJvd3NlckV2ZW50ID0gbmV3IE1hcEJyb3dzZXJFdmVudCh0eXBlLCB0aGlzLCBicm93c2VyRXZlbnQpO1xuICAgIHRoaXMuaGFuZGxlTWFwQnJvd3NlckV2ZW50KG1hcEJyb3dzZXJFdmVudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TWFwQnJvd3NlckV2ZW50fSBtYXBCcm93c2VyRXZlbnQgVGhlIGV2ZW50IHRvIGhhbmRsZS5cbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuaGFuZGxlTWFwQnJvd3NlckV2ZW50ID0gZnVuY3Rpb24gaGFuZGxlTWFwQnJvd3NlckV2ZW50IChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZnJhbWVTdGF0ZV8pIHtcbiAgICAgIC8vIFdpdGggbm8gdmlldyBkZWZpbmVkLCB3ZSBjYW5ub3QgdHJhbnNsYXRlIHBpeGVscyBpbnRvIGdlb2dyYXBoaWNhbFxuICAgICAgLy8gY29vcmRpbmF0ZXMgc28gaW50ZXJhY3Rpb25zIGNhbm5vdCBiZSB1c2VkLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmZvY3VzXyA9IG1hcEJyb3dzZXJFdmVudC5jb29yZGluYXRlO1xuICAgIG1hcEJyb3dzZXJFdmVudC5mcmFtZVN0YXRlID0gdGhpcy5mcmFtZVN0YXRlXztcbiAgICB2YXIgaW50ZXJhY3Rpb25zQXJyYXkgPSB0aGlzLmdldEludGVyYWN0aW9ucygpLmdldEFycmF5KCk7XG4gICAgaWYgKHRoaXMuZGlzcGF0Y2hFdmVudChtYXBCcm93c2VyRXZlbnQpICE9PSBmYWxzZSkge1xuICAgICAgZm9yICh2YXIgaSA9IGludGVyYWN0aW9uc0FycmF5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBpbnRlcmFjdGlvbiA9IGludGVyYWN0aW9uc0FycmF5W2ldO1xuICAgICAgICBpZiAoIWludGVyYWN0aW9uLmdldEFjdGl2ZSgpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnQgPSBpbnRlcmFjdGlvbi5oYW5kbGVFdmVudChtYXBCcm93c2VyRXZlbnQpO1xuICAgICAgICBpZiAoIWNvbnQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5oYW5kbGVQb3N0UmVuZGVyID0gZnVuY3Rpb24gaGFuZGxlUG9zdFJlbmRlciAoKSB7XG5cbiAgICB2YXIgZnJhbWVTdGF0ZSA9IHRoaXMuZnJhbWVTdGF0ZV87XG5cbiAgICAvLyBNYW5hZ2UgdGhlIHRpbGUgcXVldWVcbiAgICAvLyBJbWFnZSBsb2FkcyBhcmUgZXhwZW5zaXZlIGFuZCBhIGxpbWl0ZWQgcmVzb3VyY2UsIHNvIHRyeSB0byB1c2UgdGhlbVxuICAgIC8vIGVmZmljaWVudGx5OlxuICAgIC8vICogV2hlbiB0aGUgdmlldyBpcyBzdGF0aWMgd2UgYWxsb3cgYSBsYXJnZSBudW1iZXIgb2YgcGFyYWxsZWwgdGlsZSBsb2Fkc1xuICAgIC8vICAgdG8gY29tcGxldGUgdGhlIGZyYW1lIGFzIHF1aWNrbHkgYXMgcG9zc2libGUuXG4gICAgLy8gKiBXaGVuIGFuaW1hdGluZyBvciBpbnRlcmFjdGluZywgaW1hZ2UgbG9hZHMgY2FuIGNhdXNlIGphbmtzLCBzbyB3ZSByZWR1Y2VcbiAgICAvLyAgIHRoZSBtYXhpbXVtIG51bWJlciBvZiBsb2FkcyBwZXIgZnJhbWUgYW5kIGxpbWl0IHRoZSBudW1iZXIgb2YgcGFyYWxsZWxcbiAgICAvLyAgIHRpbGUgbG9hZHMgdG8gcmVtYWluIHJlYWN0aXZlIHRvIHZpZXcgY2hhbmdlcyBhbmQgdG8gcmVkdWNlIHRoZSBjaGFuY2Ugb2ZcbiAgICAvLyAgIGxvYWRpbmcgdGlsZXMgdGhhdCB3aWxsIHF1aWNrbHkgZGlzYXBwZWFyIGZyb20gdmlldy5cbiAgICB2YXIgdGlsZVF1ZXVlID0gdGhpcy50aWxlUXVldWVfO1xuICAgIGlmICghdGlsZVF1ZXVlLmlzRW1wdHkoKSkge1xuICAgICAgdmFyIG1heFRvdGFsTG9hZGluZyA9IHRoaXMubWF4VGlsZXNMb2FkaW5nXztcbiAgICAgIHZhciBtYXhOZXdMb2FkcyA9IG1heFRvdGFsTG9hZGluZztcbiAgICAgIGlmIChmcmFtZVN0YXRlKSB7XG4gICAgICAgIHZhciBoaW50cyA9IGZyYW1lU3RhdGUudmlld0hpbnRzO1xuICAgICAgICBpZiAoaGludHNbVmlld0hpbnQuQU5JTUFUSU5HXSkge1xuICAgICAgICAgIG1heFRvdGFsTG9hZGluZyA9IHRoaXMubG9hZFRpbGVzV2hpbGVBbmltYXRpbmdfID8gOCA6IDA7XG4gICAgICAgICAgbWF4TmV3TG9hZHMgPSAyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoaW50c1tWaWV3SGludC5JTlRFUkFDVElOR10pIHtcbiAgICAgICAgICBtYXhUb3RhbExvYWRpbmcgPSB0aGlzLmxvYWRUaWxlc1doaWxlSW50ZXJhY3RpbmdfID8gOCA6IDA7XG4gICAgICAgICAgbWF4TmV3TG9hZHMgPSAyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGlsZVF1ZXVlLmdldFRpbGVzTG9hZGluZygpIDwgbWF4VG90YWxMb2FkaW5nKSB7XG4gICAgICAgIHRpbGVRdWV1ZS5yZXByaW9yaXRpemUoKTsgLy8gRklYTUUgb25seSBjYWxsIGlmIHZpZXcgaGFzIGNoYW5nZWRcbiAgICAgICAgdGlsZVF1ZXVlLmxvYWRNb3JlVGlsZXMobWF4VG90YWxMb2FkaW5nLCBtYXhOZXdMb2Fkcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmcmFtZVN0YXRlICYmIHRoaXMuaGFzTGlzdGVuZXIoUmVuZGVyRXZlbnRUeXBlLlJFTkRFUkNPTVBMRVRFKSAmJiAhZnJhbWVTdGF0ZS5hbmltYXRlICYmXG4gICAgICAgICF0aGlzLnRpbGVRdWV1ZV8uZ2V0VGlsZXNMb2FkaW5nKCkgJiYgIWdldExvYWRpbmcodGhpcy5nZXRMYXllcnMoKS5nZXRBcnJheSgpKSkge1xuICAgICAgdGhpcy5yZW5kZXJlcl8uZGlzcGF0Y2hSZW5kZXJFdmVudChSZW5kZXJFdmVudFR5cGUuUkVOREVSQ09NUExFVEUsIGZyYW1lU3RhdGUpO1xuICAgIH1cblxuICAgIHZhciBwb3N0UmVuZGVyRnVuY3Rpb25zID0gdGhpcy5wb3N0UmVuZGVyRnVuY3Rpb25zXztcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBwb3N0UmVuZGVyRnVuY3Rpb25zLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIHBvc3RSZW5kZXJGdW5jdGlvbnNbaV0odGhpcywgZnJhbWVTdGF0ZSk7XG4gICAgfVxuICAgIHBvc3RSZW5kZXJGdW5jdGlvbnMubGVuZ3RoID0gMDtcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuaGFuZGxlU2l6ZUNoYW5nZWRfID0gZnVuY3Rpb24gaGFuZGxlU2l6ZUNoYW5nZWRfICgpIHtcbiAgICB0aGlzLnJlbmRlcigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5oYW5kbGVUYXJnZXRDaGFuZ2VkXyA9IGZ1bmN0aW9uIGhhbmRsZVRhcmdldENoYW5nZWRfICgpIHtcbiAgICAvLyB0YXJnZXQgbWF5IGJlIHVuZGVmaW5lZCwgbnVsbCwgYSBzdHJpbmcgb3IgYW4gRWxlbWVudC5cbiAgICAvLyBJZiBpdCdzIGEgc3RyaW5nIHdlIGNvbnZlcnQgaXQgdG8gYW4gRWxlbWVudCBiZWZvcmUgcHJvY2VlZGluZy5cbiAgICAvLyBJZiBpdCdzIG5vdCBub3cgYW4gRWxlbWVudCB3ZSByZW1vdmUgdGhlIHZpZXdwb3J0IGZyb20gdGhlIERPTS5cbiAgICAvLyBJZiBpdCdzIGFuIEVsZW1lbnQgd2UgYXBwZW5kIHRoZSB2aWV3cG9ydCBlbGVtZW50IHRvIGl0LlxuXG4gICAgdmFyIHRhcmdldEVsZW1lbnQ7XG4gICAgaWYgKHRoaXMuZ2V0VGFyZ2V0KCkpIHtcbiAgICAgIHRhcmdldEVsZW1lbnQgPSB0aGlzLmdldFRhcmdldEVsZW1lbnQoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5rZXlIYW5kbGVyS2V5c18pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHRoaXMua2V5SGFuZGxlcktleXNfLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgdW5saXN0ZW5CeUtleSh0aGlzLmtleUhhbmRsZXJLZXlzX1tpXSk7XG4gICAgICB9XG4gICAgICB0aGlzLmtleUhhbmRsZXJLZXlzXyA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCF0YXJnZXRFbGVtZW50KSB7XG4gICAgICB0aGlzLnJlbmRlcmVyXy5yZW1vdmVMYXllclJlbmRlcmVycygpO1xuICAgICAgcmVtb3ZlTm9kZSh0aGlzLnZpZXdwb3J0Xyk7XG4gICAgICBpZiAodGhpcy5oYW5kbGVSZXNpemVfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihFdmVudFR5cGUuUkVTSVpFLCB0aGlzLmhhbmRsZVJlc2l6ZV8sIGZhbHNlKTtcbiAgICAgICAgdGhpcy5oYW5kbGVSZXNpemVfID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXRFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMudmlld3BvcnRfKTtcblxuICAgICAgdmFyIGtleWJvYXJkRXZlbnRUYXJnZXQgPSAhdGhpcy5rZXlib2FyZEV2ZW50VGFyZ2V0XyA/XG4gICAgICAgIHRhcmdldEVsZW1lbnQgOiB0aGlzLmtleWJvYXJkRXZlbnRUYXJnZXRfO1xuICAgICAgdGhpcy5rZXlIYW5kbGVyS2V5c18gPSBbXG4gICAgICAgIGxpc3RlbihrZXlib2FyZEV2ZW50VGFyZ2V0LCBFdmVudFR5cGUuS0VZRE9XTiwgdGhpcy5oYW5kbGVCcm93c2VyRXZlbnQsIHRoaXMpLFxuICAgICAgICBsaXN0ZW4oa2V5Ym9hcmRFdmVudFRhcmdldCwgRXZlbnRUeXBlLktFWVBSRVNTLCB0aGlzLmhhbmRsZUJyb3dzZXJFdmVudCwgdGhpcylcbiAgICAgIF07XG5cbiAgICAgIGlmICghdGhpcy5oYW5kbGVSZXNpemVfKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlUmVzaXplXyA9IHRoaXMudXBkYXRlU2l6ZS5iaW5kKHRoaXMpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihFdmVudFR5cGUuUkVTSVpFLCB0aGlzLmhhbmRsZVJlc2l6ZV8sIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZVNpemUoKTtcbiAgICAvLyB1cGRhdGVTaXplIGNhbGxzIHNldFNpemUsIHNvIG5vIG5lZWQgdG8gY2FsbCB0aGlzLnJlbmRlclxuICAgIC8vIG91cnNlbHZlcyBoZXJlLlxuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5oYW5kbGVUaWxlQ2hhbmdlXyA9IGZ1bmN0aW9uIGhhbmRsZVRpbGVDaGFuZ2VfICgpIHtcbiAgICB0aGlzLnJlbmRlcigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5oYW5kbGVWaWV3UHJvcGVydHlDaGFuZ2VkXyA9IGZ1bmN0aW9uIGhhbmRsZVZpZXdQcm9wZXJ0eUNoYW5nZWRfICgpIHtcbiAgICB0aGlzLnJlbmRlcigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5oYW5kbGVWaWV3Q2hhbmdlZF8gPSBmdW5jdGlvbiBoYW5kbGVWaWV3Q2hhbmdlZF8gKCkge1xuICAgIGlmICh0aGlzLnZpZXdQcm9wZXJ0eUxpc3RlbmVyS2V5Xykge1xuICAgICAgdW5saXN0ZW5CeUtleSh0aGlzLnZpZXdQcm9wZXJ0eUxpc3RlbmVyS2V5Xyk7XG4gICAgICB0aGlzLnZpZXdQcm9wZXJ0eUxpc3RlbmVyS2V5XyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLnZpZXdDaGFuZ2VMaXN0ZW5lcktleV8pIHtcbiAgICAgIHVubGlzdGVuQnlLZXkodGhpcy52aWV3Q2hhbmdlTGlzdGVuZXJLZXlfKTtcbiAgICAgIHRoaXMudmlld0NoYW5nZUxpc3RlbmVyS2V5XyA9IG51bGw7XG4gICAgfVxuICAgIHZhciB2aWV3ID0gdGhpcy5nZXRWaWV3KCk7XG4gICAgaWYgKHZpZXcpIHtcbiAgICAgIHRoaXMudmlld3BvcnRfLnNldEF0dHJpYnV0ZSgnZGF0YS12aWV3JywgZ2V0VWlkKHZpZXcpKTtcbiAgICAgIHRoaXMudmlld1Byb3BlcnR5TGlzdGVuZXJLZXlfID0gbGlzdGVuKFxuICAgICAgICB2aWV3LCBPYmplY3RFdmVudFR5cGUuUFJPUEVSVFlDSEFOR0UsXG4gICAgICAgIHRoaXMuaGFuZGxlVmlld1Byb3BlcnR5Q2hhbmdlZF8sIHRoaXMpO1xuICAgICAgdGhpcy52aWV3Q2hhbmdlTGlzdGVuZXJLZXlfID0gbGlzdGVuKFxuICAgICAgICB2aWV3LCBFdmVudFR5cGUuQ0hBTkdFLFxuICAgICAgICB0aGlzLmhhbmRsZVZpZXdQcm9wZXJ0eUNoYW5nZWRfLCB0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuaGFuZGxlTGF5ZXJHcm91cENoYW5nZWRfID0gZnVuY3Rpb24gaGFuZGxlTGF5ZXJHcm91cENoYW5nZWRfICgpIHtcbiAgICBpZiAodGhpcy5sYXllckdyb3VwUHJvcGVydHlMaXN0ZW5lcktleXNfKSB7XG4gICAgICB0aGlzLmxheWVyR3JvdXBQcm9wZXJ0eUxpc3RlbmVyS2V5c18uZm9yRWFjaCh1bmxpc3RlbkJ5S2V5KTtcbiAgICAgIHRoaXMubGF5ZXJHcm91cFByb3BlcnR5TGlzdGVuZXJLZXlzXyA9IG51bGw7XG4gICAgfVxuICAgIHZhciBsYXllckdyb3VwID0gdGhpcy5nZXRMYXllckdyb3VwKCk7XG4gICAgaWYgKGxheWVyR3JvdXApIHtcbiAgICAgIHRoaXMubGF5ZXJHcm91cFByb3BlcnR5TGlzdGVuZXJLZXlzXyA9IFtcbiAgICAgICAgbGlzdGVuKFxuICAgICAgICAgIGxheWVyR3JvdXAsIE9iamVjdEV2ZW50VHlwZS5QUk9QRVJUWUNIQU5HRSxcbiAgICAgICAgICB0aGlzLnJlbmRlciwgdGhpcyksXG4gICAgICAgIGxpc3RlbihcbiAgICAgICAgICBsYXllckdyb3VwLCBFdmVudFR5cGUuQ0hBTkdFLFxuICAgICAgICAgIHRoaXMucmVuZGVyLCB0aGlzKVxuICAgICAgXTtcbiAgICB9XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSXMgcmVuZGVyZWQuXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLmlzUmVuZGVyZWQgPSBmdW5jdGlvbiBpc1JlbmRlcmVkICgpIHtcbiAgICByZXR1cm4gISF0aGlzLmZyYW1lU3RhdGVfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXF1ZXN0cyBhbiBpbW1lZGlhdGUgcmVuZGVyIGluIGEgc3luY2hyb25vdXMgbWFubmVyLlxuICAgKiBAYXBpXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLnJlbmRlclN5bmMgPSBmdW5jdGlvbiByZW5kZXJTeW5jICgpIHtcbiAgICBpZiAodGhpcy5hbmltYXRpb25EZWxheUtleV8pIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uRGVsYXlLZXlfKTtcbiAgICB9XG4gICAgdGhpcy5hbmltYXRpb25EZWxheV8oKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVxdWVzdCBhIG1hcCByZW5kZXJpbmcgKGF0IHRoZSBuZXh0IGFuaW1hdGlvbiBmcmFtZSkuXG4gICAqIEBhcGlcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgICBpZiAodGhpcy5hbmltYXRpb25EZWxheUtleV8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5hbmltYXRpb25EZWxheUtleV8gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRpb25EZWxheV8pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBnaXZlbiBjb250cm9sIGZyb20gdGhlIG1hcC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2NvbnRyb2wvQ29udHJvbC5qc1wiKS5kZWZhdWx0fSBjb250cm9sIENvbnRyb2wuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29udHJvbC9Db250cm9sLmpzXCIpLmRlZmF1bHR8dW5kZWZpbmVkfSBUaGUgcmVtb3ZlZCBjb250cm9sIChvciB1bmRlZmluZWRcbiAgICogICAgIGlmIHRoZSBjb250cm9sIHdhcyBub3QgZm91bmQpLlxuICAgKiBAYXBpXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLnJlbW92ZUNvbnRyb2wgPSBmdW5jdGlvbiByZW1vdmVDb250cm9sIChjb250cm9sKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q29udHJvbHMoKS5yZW1vdmUoY29udHJvbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgZ2l2ZW4gaW50ZXJhY3Rpb24gZnJvbSB0aGUgbWFwLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vaW50ZXJhY3Rpb24vSW50ZXJhY3Rpb24uanNcIikuZGVmYXVsdH0gaW50ZXJhY3Rpb24gSW50ZXJhY3Rpb24gdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2ludGVyYWN0aW9uL0ludGVyYWN0aW9uLmpzXCIpLmRlZmF1bHR8dW5kZWZpbmVkfSBUaGUgcmVtb3ZlZCBpbnRlcmFjdGlvbiAob3JcbiAgICogICAgIHVuZGVmaW5lZCBpZiB0aGUgaW50ZXJhY3Rpb24gd2FzIG5vdCBmb3VuZCkuXG4gICAqIEBhcGlcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUucmVtb3ZlSW50ZXJhY3Rpb24gPSBmdW5jdGlvbiByZW1vdmVJbnRlcmFjdGlvbiAoaW50ZXJhY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnRlcmFjdGlvbnMoKS5yZW1vdmUoaW50ZXJhY3Rpb24pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBtYXAuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9sYXllci9CYXNlLmpzXCIpLmRlZmF1bHR9IGxheWVyIExheWVyLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2xheWVyL0Jhc2UuanNcIikuZGVmYXVsdHx1bmRlZmluZWR9IFRoZSByZW1vdmVkIGxheWVyIChvciB1bmRlZmluZWQgaWYgdGhlXG4gICAqICAgICBsYXllciB3YXMgbm90IGZvdW5kKS5cbiAgICogQGFwaVxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5yZW1vdmVMYXllciA9IGZ1bmN0aW9uIHJlbW92ZUxheWVyIChsYXllcikge1xuICAgIHZhciBsYXllcnMgPSB0aGlzLmdldExheWVyR3JvdXAoKS5nZXRMYXllcnMoKTtcbiAgICByZXR1cm4gbGF5ZXJzLnJlbW92ZShsYXllcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgZ2l2ZW4gb3ZlcmxheSBmcm9tIHRoZSBtYXAuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9PdmVybGF5LmpzXCIpLmRlZmF1bHR9IG92ZXJsYXkgT3ZlcmxheS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9PdmVybGF5LmpzXCIpLmRlZmF1bHR8dW5kZWZpbmVkfSBUaGUgcmVtb3ZlZCBvdmVybGF5IChvciB1bmRlZmluZWRcbiAgICogICAgIGlmIHRoZSBvdmVybGF5IHdhcyBub3QgZm91bmQpLlxuICAgKiBAYXBpXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLnJlbW92ZU92ZXJsYXkgPSBmdW5jdGlvbiByZW1vdmVPdmVybGF5IChvdmVybGF5KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0T3ZlcmxheXMoKS5yZW1vdmUob3ZlcmxheSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lIFRpbWUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLnJlbmRlckZyYW1lXyA9IGZ1bmN0aW9uIHJlbmRlckZyYW1lXyAodGltZSkge1xuICAgIHZhciB2aWV3U3RhdGU7XG5cbiAgICB2YXIgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpO1xuICAgIHZhciB2aWV3ID0gdGhpcy5nZXRWaWV3KCk7XG4gICAgdmFyIGV4dGVudCA9IGNyZWF0ZUVtcHR5KCk7XG4gICAgdmFyIHByZXZpb3VzRnJhbWVTdGF0ZSA9IHRoaXMuZnJhbWVTdGF0ZV87XG4gICAgLyoqIEB0eXBlIHs/RnJhbWVTdGF0ZX0gKi9cbiAgICB2YXIgZnJhbWVTdGF0ZSA9IG51bGw7XG4gICAgaWYgKHNpemUgIT09IHVuZGVmaW5lZCAmJiBoYXNBcmVhKHNpemUpICYmIHZpZXcgJiYgdmlldy5pc0RlZigpKSB7XG4gICAgICB2YXIgdmlld0hpbnRzID0gdmlldy5nZXRIaW50cyh0aGlzLmZyYW1lU3RhdGVfID8gdGhpcy5mcmFtZVN0YXRlXy52aWV3SGludHMgOiB1bmRlZmluZWQpO1xuICAgICAgdmFyIGxheWVyU3RhdGVzQXJyYXkgPSB0aGlzLmdldExheWVyR3JvdXAoKS5nZXRMYXllclN0YXRlc0FycmF5KCk7XG4gICAgICB2YXIgbGF5ZXJTdGF0ZXMgPSB7fTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGxheWVyU3RhdGVzQXJyYXkubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBsYXllclN0YXRlc1tnZXRVaWQobGF5ZXJTdGF0ZXNBcnJheVtpXS5sYXllcildID0gbGF5ZXJTdGF0ZXNBcnJheVtpXTtcbiAgICAgIH1cbiAgICAgIHZpZXdTdGF0ZSA9IHZpZXcuZ2V0U3RhdGUodGhpcy5waXhlbFJhdGlvXyk7XG4gICAgICBmcmFtZVN0YXRlID0gLyoqIEB0eXBlIHtGcmFtZVN0YXRlfSAqLyAoe1xuICAgICAgICBhbmltYXRlOiBmYWxzZSxcbiAgICAgICAgY29vcmRpbmF0ZVRvUGl4ZWxUcmFuc2Zvcm06IHRoaXMuY29vcmRpbmF0ZVRvUGl4ZWxUcmFuc2Zvcm1fLFxuICAgICAgICBleHRlbnQ6IGV4dGVudCxcbiAgICAgICAgZm9jdXM6IHRoaXMuZm9jdXNfID8gdGhpcy5mb2N1c18gOiB2aWV3U3RhdGUuY2VudGVyLFxuICAgICAgICBpbmRleDogdGhpcy5mcmFtZUluZGV4XysrLFxuICAgICAgICBsYXllclN0YXRlczogbGF5ZXJTdGF0ZXMsXG4gICAgICAgIGxheWVyU3RhdGVzQXJyYXk6IGxheWVyU3RhdGVzQXJyYXksXG4gICAgICAgIHBpeGVsUmF0aW86IHRoaXMucGl4ZWxSYXRpb18sXG4gICAgICAgIHBpeGVsVG9Db29yZGluYXRlVHJhbnNmb3JtOiB0aGlzLnBpeGVsVG9Db29yZGluYXRlVHJhbnNmb3JtXyxcbiAgICAgICAgcG9zdFJlbmRlckZ1bmN0aW9uczogW10sXG4gICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgIHNraXBwZWRGZWF0dXJlVWlkczogdGhpcy5za2lwcGVkRmVhdHVyZVVpZHNfLFxuICAgICAgICB0aWxlUXVldWU6IHRoaXMudGlsZVF1ZXVlXyxcbiAgICAgICAgdGltZTogdGltZSxcbiAgICAgICAgdXNlZFRpbGVzOiB7fSxcbiAgICAgICAgdmlld1N0YXRlOiB2aWV3U3RhdGUsXG4gICAgICAgIHZpZXdIaW50czogdmlld0hpbnRzLFxuICAgICAgICB3YW50ZWRUaWxlczoge31cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChmcmFtZVN0YXRlKSB7XG4gICAgICBmcmFtZVN0YXRlLmV4dGVudCA9IGdldEZvclZpZXdBbmRTaXplKHZpZXdTdGF0ZS5jZW50ZXIsXG4gICAgICAgIHZpZXdTdGF0ZS5yZXNvbHV0aW9uLCB2aWV3U3RhdGUucm90YXRpb24sIGZyYW1lU3RhdGUuc2l6ZSwgZXh0ZW50KTtcbiAgICB9XG5cbiAgICB0aGlzLmZyYW1lU3RhdGVfID0gZnJhbWVTdGF0ZTtcbiAgICB0aGlzLnJlbmRlcmVyXy5yZW5kZXJGcmFtZShmcmFtZVN0YXRlKTtcblxuICAgIGlmIChmcmFtZVN0YXRlKSB7XG4gICAgICBpZiAoZnJhbWVTdGF0ZS5hbmltYXRlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICB9XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0aGlzLnBvc3RSZW5kZXJGdW5jdGlvbnNfLCBmcmFtZVN0YXRlLnBvc3RSZW5kZXJGdW5jdGlvbnMpO1xuXG4gICAgICBpZiAocHJldmlvdXNGcmFtZVN0YXRlKSB7XG4gICAgICAgIHZhciBtb3ZlU3RhcnQgPSAhdGhpcy5wcmV2aW91c0V4dGVudF8gfHxcbiAgICAgICAgICAgICAgICAgICAgKCFpc0VtcHR5KHRoaXMucHJldmlvdXNFeHRlbnRfKSAmJlxuICAgICAgICAgICAgICAgICAgICAhZXF1YWxzKGZyYW1lU3RhdGUuZXh0ZW50LCB0aGlzLnByZXZpb3VzRXh0ZW50XykpO1xuICAgICAgICBpZiAobW92ZVN0YXJ0KSB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgICAgICAgbmV3IE1hcEV2ZW50KE1hcEV2ZW50VHlwZS5NT1ZFU1RBUlQsIHRoaXMsIHByZXZpb3VzRnJhbWVTdGF0ZSkpO1xuICAgICAgICAgIHRoaXMucHJldmlvdXNFeHRlbnRfID0gY3JlYXRlT3JVcGRhdGVFbXB0eSh0aGlzLnByZXZpb3VzRXh0ZW50Xyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGlkbGUgPSB0aGlzLnByZXZpb3VzRXh0ZW50XyAmJlxuICAgICAgICAgICFmcmFtZVN0YXRlLnZpZXdIaW50c1tWaWV3SGludC5BTklNQVRJTkddICYmXG4gICAgICAgICAgIWZyYW1lU3RhdGUudmlld0hpbnRzW1ZpZXdIaW50LklOVEVSQUNUSU5HXSAmJlxuICAgICAgICAgICFlcXVhbHMoZnJhbWVTdGF0ZS5leHRlbnQsIHRoaXMucHJldmlvdXNFeHRlbnRfKTtcblxuICAgICAgaWYgKGlkbGUpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBNYXBFdmVudChNYXBFdmVudFR5cGUuTU9WRUVORCwgdGhpcywgZnJhbWVTdGF0ZSkpO1xuICAgICAgICBjbG9uZShmcmFtZVN0YXRlLmV4dGVudCwgdGhpcy5wcmV2aW91c0V4dGVudF8pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgTWFwRXZlbnQoTWFwRXZlbnRUeXBlLlBPU1RSRU5ERVIsIHRoaXMsIGZyYW1lU3RhdGUpKTtcblxuICAgIHNldFRpbWVvdXQodGhpcy5oYW5kbGVQb3N0UmVuZGVyLmJpbmQodGhpcyksIDApO1xuXG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGxheWVyZ3JvdXAgb2YgdGhpcyBtYXAuXG4gICAqIEBwYXJhbSB7TGF5ZXJHcm91cH0gbGF5ZXJHcm91cCBBIGxheWVyIGdyb3VwIGNvbnRhaW5pbmcgdGhlIGxheWVycyBpbiB0aGlzIG1hcC5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5zZXRMYXllckdyb3VwID0gZnVuY3Rpb24gc2V0TGF5ZXJHcm91cCAobGF5ZXJHcm91cCkge1xuICAgIHRoaXMuc2V0KE1hcFByb3BlcnR5LkxBWUVSR1JPVVAsIGxheWVyR3JvdXApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHNpemUgb2YgdGhpcyBtYXAuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV8dW5kZWZpbmVkfSBzaXplIFRoZSBzaXplIGluIHBpeGVscyBvZiB0aGUgbWFwIGluIHRoZSBET00uXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuc2V0U2l6ZSA9IGZ1bmN0aW9uIHNldFNpemUgKHNpemUpIHtcbiAgICB0aGlzLnNldChNYXBQcm9wZXJ0eS5TSVpFLCBzaXplKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSB0YXJnZXQgZWxlbWVudCB0byByZW5kZXIgdGhpcyBtYXAgaW50by5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxzdHJpbmd8dW5kZWZpbmVkfSB0YXJnZXQgVGhlIEVsZW1lbnQgb3IgaWQgb2YgdGhlIEVsZW1lbnRcbiAgICogICAgIHRoYXQgdGhlIG1hcCBpcyByZW5kZXJlZCBpbi5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5zZXRUYXJnZXQgPSBmdW5jdGlvbiBzZXRUYXJnZXQgKHRhcmdldCkge1xuICAgIHRoaXMuc2V0KE1hcFByb3BlcnR5LlRBUkdFVCwgdGFyZ2V0KTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSB2aWV3IGZvciB0aGlzIG1hcC5cbiAgICogQHBhcmFtIHtWaWV3fSB2aWV3IFRoZSB2aWV3IHRoYXQgY29udHJvbHMgdGhpcyBtYXAuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuc2V0VmlldyA9IGZ1bmN0aW9uIHNldFZpZXcgKHZpZXcpIHtcbiAgICB0aGlzLnNldChNYXBQcm9wZXJ0eS5WSUVXLCB2aWV3KTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5za2lwRmVhdHVyZSA9IGZ1bmN0aW9uIHNraXBGZWF0dXJlIChmZWF0dXJlKSB7XG4gICAgdGhpcy5za2lwcGVkRmVhdHVyZVVpZHNfW2dldFVpZChmZWF0dXJlKV0gPSB0cnVlO1xuICAgIHRoaXMucmVuZGVyKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZvcmNlIGEgcmVjYWxjdWxhdGlvbiBvZiB0aGUgbWFwIHZpZXdwb3J0IHNpemUuICBUaGlzIHNob3VsZCBiZSBjYWxsZWQgd2hlblxuICAgKiB0aGlyZC1wYXJ0eSBjb2RlIGNoYW5nZXMgdGhlIHNpemUgb2YgdGhlIG1hcCB2aWV3cG9ydC5cbiAgICogQGFwaVxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS51cGRhdGVTaXplID0gZnVuY3Rpb24gdXBkYXRlU2l6ZSAoKSB7XG4gICAgdmFyIHRhcmdldEVsZW1lbnQgPSB0aGlzLmdldFRhcmdldEVsZW1lbnQoKTtcblxuICAgIGlmICghdGFyZ2V0RWxlbWVudCkge1xuICAgICAgdGhpcy5zZXRTaXplKHVuZGVmaW5lZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXRFbGVtZW50KTtcbiAgICAgIHRoaXMuc2V0U2l6ZShbXG4gICAgICAgIHRhcmdldEVsZW1lbnQub2Zmc2V0V2lkdGggLVxuICAgICAgICAgICAgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlWydib3JkZXJMZWZ0V2lkdGgnXSkgLVxuICAgICAgICAgICAgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlWydwYWRkaW5nTGVmdCddKSAtXG4gICAgICAgICAgICBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGVbJ3BhZGRpbmdSaWdodCddKSAtXG4gICAgICAgICAgICBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGVbJ2JvcmRlclJpZ2h0V2lkdGgnXSksXG4gICAgICAgIHRhcmdldEVsZW1lbnQub2Zmc2V0SGVpZ2h0IC1cbiAgICAgICAgICAgIHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZVsnYm9yZGVyVG9wV2lkdGgnXSkgLVxuICAgICAgICAgICAgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlWydwYWRkaW5nVG9wJ10pIC1cbiAgICAgICAgICAgIHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZVsncGFkZGluZ0JvdHRvbSddKSAtXG4gICAgICAgICAgICBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGVbJ2JvcmRlckJvdHRvbVdpZHRoJ10pXG4gICAgICBdKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUudW5za2lwRmVhdHVyZSA9IGZ1bmN0aW9uIHVuc2tpcEZlYXR1cmUgKGZlYXR1cmUpIHtcbiAgICBkZWxldGUgdGhpcy5za2lwcGVkRmVhdHVyZVVpZHNfW2dldFVpZChmZWF0dXJlKV07XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfTtcblxuICByZXR1cm4gUGx1Z2dhYmxlTWFwO1xufShCYXNlT2JqZWN0KSk7XG5cblxuLyoqXG4gKiBAcGFyYW0ge01hcE9wdGlvbnN9IG9wdGlvbnMgTWFwIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtNYXBPcHRpb25zSW50ZXJuYWx9IEludGVybmFsIG1hcCBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zSW50ZXJuYWwob3B0aW9ucykge1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR8RG9jdW1lbnR9XG4gICAqL1xuICB2YXIga2V5Ym9hcmRFdmVudFRhcmdldCA9IG51bGw7XG4gIGlmIChvcHRpb25zLmtleWJvYXJkRXZlbnRUYXJnZXQgIT09IHVuZGVmaW5lZCkge1xuICAgIGtleWJvYXJkRXZlbnRUYXJnZXQgPSB0eXBlb2Ygb3B0aW9ucy5rZXlib2FyZEV2ZW50VGFyZ2V0ID09PSAnc3RyaW5nJyA/XG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChvcHRpb25zLmtleWJvYXJkRXZlbnRUYXJnZXQpIDpcbiAgICAgIG9wdGlvbnMua2V5Ym9hcmRFdmVudFRhcmdldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgKj59XG4gICAqL1xuICB2YXIgdmFsdWVzID0ge307XG5cbiAgdmFyIGxheWVyR3JvdXAgPSBvcHRpb25zLmxheWVycyAmJiB0eXBlb2YgLyoqIEB0eXBlIHs/fSAqLyAob3B0aW9ucy5sYXllcnMpLmdldExheWVycyA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgLyoqIEB0eXBlIHtMYXllckdyb3VwfSAqLyAob3B0aW9ucy5sYXllcnMpIDogbmV3IExheWVyR3JvdXAoe2xheWVyczogLyoqIEB0eXBlIHtDb2xsZWN0aW9ufSAqLyAob3B0aW9ucy5sYXllcnMpfSk7XG4gIHZhbHVlc1tNYXBQcm9wZXJ0eS5MQVlFUkdST1VQXSA9IGxheWVyR3JvdXA7XG5cbiAgdmFsdWVzW01hcFByb3BlcnR5LlRBUkdFVF0gPSBvcHRpb25zLnRhcmdldDtcblxuICB2YWx1ZXNbTWFwUHJvcGVydHkuVklFV10gPSBvcHRpb25zLnZpZXcgIT09IHVuZGVmaW5lZCA/XG4gICAgb3B0aW9ucy52aWV3IDogbmV3IFZpZXcoKTtcblxuICB2YXIgY29udHJvbHM7XG4gIGlmIChvcHRpb25zLmNvbnRyb2xzICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLmNvbnRyb2xzKSkge1xuICAgICAgY29udHJvbHMgPSBuZXcgQ29sbGVjdGlvbihvcHRpb25zLmNvbnRyb2xzLnNsaWNlKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQodHlwZW9mIC8qKiBAdHlwZSB7P30gKi8gKG9wdGlvbnMuY29udHJvbHMpLmdldEFycmF5ID09PSAnZnVuY3Rpb24nLFxuICAgICAgICA0Nyk7IC8vIEV4cGVjdGVkIGBjb250cm9sc2AgdG8gYmUgYW4gYXJyYXkgb3IgYW4gYGltcG9ydChcIi4vQ29sbGVjdGlvbi5qc1wiKS5Db2xsZWN0aW9uYFxuICAgICAgY29udHJvbHMgPSAvKiogQHR5cGUge0NvbGxlY3Rpb259ICovIChvcHRpb25zLmNvbnRyb2xzKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaW50ZXJhY3Rpb25zO1xuICBpZiAob3B0aW9ucy5pbnRlcmFjdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMuaW50ZXJhY3Rpb25zKSkge1xuICAgICAgaW50ZXJhY3Rpb25zID0gbmV3IENvbGxlY3Rpb24ob3B0aW9ucy5pbnRlcmFjdGlvbnMuc2xpY2UoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydCh0eXBlb2YgLyoqIEB0eXBlIHs/fSAqLyAob3B0aW9ucy5pbnRlcmFjdGlvbnMpLmdldEFycmF5ID09PSAnZnVuY3Rpb24nLFxuICAgICAgICA0OCk7IC8vIEV4cGVjdGVkIGBpbnRlcmFjdGlvbnNgIHRvIGJlIGFuIGFycmF5IG9yIGFuIGBpbXBvcnQoXCIuL0NvbGxlY3Rpb24uanNcIikuQ29sbGVjdGlvbmBcbiAgICAgIGludGVyYWN0aW9ucyA9IC8qKiBAdHlwZSB7Q29sbGVjdGlvbn0gKi8gKG9wdGlvbnMuaW50ZXJhY3Rpb25zKTtcbiAgICB9XG4gIH1cblxuICB2YXIgb3ZlcmxheXM7XG4gIGlmIChvcHRpb25zLm92ZXJsYXlzICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLm92ZXJsYXlzKSkge1xuICAgICAgb3ZlcmxheXMgPSBuZXcgQ29sbGVjdGlvbihvcHRpb25zLm92ZXJsYXlzLnNsaWNlKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQodHlwZW9mIC8qKiBAdHlwZSB7P30gKi8gKG9wdGlvbnMub3ZlcmxheXMpLmdldEFycmF5ID09PSAnZnVuY3Rpb24nLFxuICAgICAgICA0OSk7IC8vIEV4cGVjdGVkIGBvdmVybGF5c2AgdG8gYmUgYW4gYXJyYXkgb3IgYW4gYGltcG9ydChcIi4vQ29sbGVjdGlvbi5qc1wiKS5Db2xsZWN0aW9uYFxuICAgICAgb3ZlcmxheXMgPSBvcHRpb25zLm92ZXJsYXlzO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvdmVybGF5cyA9IG5ldyBDb2xsZWN0aW9uKCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNvbnRyb2xzOiBjb250cm9scyxcbiAgICBpbnRlcmFjdGlvbnM6IGludGVyYWN0aW9ucyxcbiAgICBrZXlib2FyZEV2ZW50VGFyZ2V0OiBrZXlib2FyZEV2ZW50VGFyZ2V0LFxuICAgIG92ZXJsYXlzOiBvdmVybGF5cyxcbiAgICB2YWx1ZXM6IHZhbHVlc1xuICB9O1xuXG59XG5leHBvcnQgZGVmYXVsdCBQbHVnZ2FibGVNYXA7XG5cbi8qKlxuICogQHBhcmFtICB7QXJyYXk8aW1wb3J0KFwiLi9sYXllci9CYXNlLmpzXCIpLmRlZmF1bHQ+fSBsYXllcnMgTGF5ZXJzLlxuICogQHJldHVybiB7Ym9vbGVhbn0gTGF5ZXJzIGhhdmUgc291cmNlcyB0aGF0IGFyZSBzdGlsbCBsb2FkaW5nLlxuICovXG5mdW5jdGlvbiBnZXRMb2FkaW5nKGxheWVycykge1xuICBmb3IgKHZhciBpID0gMCwgaWkgPSBsYXllcnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIHZhciBsYXllciA9IGxheWVyc1tpXTtcbiAgICBpZiAodHlwZW9mIC8qKiBAdHlwZSB7P30gKi8gKGxheWVyKS5nZXRMYXllcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBnZXRMb2FkaW5nKC8qKiBAdHlwZSB7TGF5ZXJHcm91cH0gKi8gKGxheWVyKS5nZXRMYXllcnMoKS5nZXRBcnJheSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNvdXJjZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0fSAqLyAoXG4gICAgICAgIGxheWVyKS5nZXRTb3VyY2UoKTtcbiAgICAgIGlmIChzb3VyY2UgJiYgc291cmNlLmxvYWRpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGx1Z2dhYmxlTWFwLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9UaWxlXG4gKi9cbmltcG9ydCBUaWxlU3RhdGUgZnJvbSAnLi9UaWxlU3RhdGUuanMnO1xuaW1wb3J0IHtlYXNlSW59IGZyb20gJy4vZWFzaW5nLmpzJztcbmltcG9ydCBFdmVudFRhcmdldCBmcm9tICcuL2V2ZW50cy9UYXJnZXQuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuXG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvVGlsZX0gZm9yIHRoZSB0aWxlIGFuZCBhXG4gKiBge3N0cmluZ31gIGZvciB0aGUgdXJsIGFzIGFyZ3VtZW50cy4gVGhlIGRlZmF1bHQgaXNcbiAqIGBgYGpzXG4gKiBzb3VyY2Uuc2V0VGlsZUxvYWRGdW5jdGlvbihmdW5jdGlvbih0aWxlLCBzcmMpIHtcbiAqICAgdGlsZS5nZXRJbWFnZSgpLnNyYyA9IHNyYztcbiAqIH0pO1xuICogYGBgXG4gKiBGb3IgbW9yZSBmaW5lIGdyYWluZWQgY29udHJvbCwgdGhlIGxvYWQgZnVuY3Rpb24gY2FuIHVzZSBmZXRjaCBvciBYTUxIdHRwUmVxdWVzdCBhbmQgaW52b2x2ZVxuICogZXJyb3IgaGFuZGxpbmc6XG4gKlxuICogYGBganNcbiAqIGltcG9ydCBUaWxlU3RhdGUgZnJvbSAnb2wvVGlsZVN0YXRlJztcbiAqXG4gKiBzb3VyY2Uuc2V0VGlsZUxvYWRGdW5jdGlvbihmdW5jdGlvbih0aWxlLCBzcmMpIHtcbiAqICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICogICB4aHIucmVzcG9uc2VUeXBlID0gJ2Jsb2InO1xuICogICB4aHIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVuZCcsIGZ1bmN0aW9uIChldnQpIHtcbiAqICAgICB2YXIgZGF0YSA9IHRoaXMucmVzcG9uc2U7XG4gKiAgICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICogICAgICAgdGlsZS5nZXRJbWFnZSgpLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwoZGF0YSk7XG4gKiAgICAgfSBlbHNlIHtcbiAqICAgICAgIHRpbGUuc2V0U3RhdGUoVGlsZVN0YXRlLkVSUk9SKTtcbiAqICAgICB9XG4gKiAgIH0pO1xuICogICB4aHIuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmdW5jdGlvbiAoKSB7XG4gKiAgICAgdGlsZS5zZXRTdGF0ZShUaWxlU3RhdGUuRVJST1IpO1xuICogICB9KTtcbiAqICAgeGhyLm9wZW4oJ0dFVCcsIHNyYyk7XG4gKiAgIHhoci5zZW5kKCk7XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihUaWxlLCBzdHJpbmcpfSBMb2FkRnVuY3Rpb25cbiAqIEBhcGlcbiAqL1xuXG4vKipcbiAqIHtAbGluayBtb2R1bGU6b2wvc291cmNlL1RpbGV+VGlsZX0gc291cmNlcyB1c2UgYSBmdW5jdGlvbiBvZiB0aGlzIHR5cGUgdG8gZ2V0XG4gKiB0aGUgdXJsIHRoYXQgcHJvdmlkZXMgYSB0aWxlIGZvciBhIGdpdmVuIHRpbGUgY29vcmRpbmF0ZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZH0gZm9yIHRoZSB0aWxlXG4gKiBjb29yZGluYXRlLCBhIGB7bnVtYmVyfWAgcmVwcmVzZW50aW5nIHRoZSBwaXhlbCByYXRpbyBhbmQgYVxuICoge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IGZvciB0aGUgcHJvamVjdGlvbiAgYXMgYXJndW1lbnRzXG4gKiBhbmQgcmV0dXJucyBhIGB7c3RyaW5nfWAgcmVwcmVzZW50aW5nIHRoZSB0aWxlIFVSTCwgb3IgdW5kZWZpbmVkIGlmIG5vIHRpbGVcbiAqIHNob3VsZCBiZSByZXF1ZXN0ZWQgZm9yIHRoZSBwYXNzZWQgdGlsZSBjb29yZGluYXRlLlxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihpbXBvcnQoXCIuL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmQsIG51bWJlcixcbiAqICAgICAgICAgICBpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0KTogKHN0cmluZ3x1bmRlZmluZWQpfSBVcmxGdW5jdGlvblxuICogQGFwaVxuICovXG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RyYW5zaXRpb249MjUwXSBBIGR1cmF0aW9uIGZvciB0aWxlIG9wYWNpdHlcbiAqIHRyYW5zaXRpb25zIGluIG1pbGxpc2Vjb25kcy4gQSBkdXJhdGlvbiBvZiAwIGRpc2FibGVzIHRoZSBvcGFjaXR5IHRyYW5zaXRpb24uXG4gKiBAYXBpXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEJhc2UgY2xhc3MgZm9yIHRpbGVzLlxuICpcbiAqIEBhYnN0cmFjdFxuICovXG52YXIgVGlsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEV2ZW50VGFyZ2V0KSB7XG4gIGZ1bmN0aW9uIFRpbGUodGlsZUNvb3JkLCBzdGF0ZSwgb3B0X29wdGlvbnMpIHtcbiAgICBFdmVudFRhcmdldC5jYWxsKHRoaXMpO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBvcHRfb3B0aW9ucyA/IG9wdF9vcHRpb25zIDoge307XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfVxuICAgICAqL1xuICAgIHRoaXMudGlsZUNvb3JkID0gdGlsZUNvb3JkO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtUaWxlU3RhdGV9XG4gICAgICovXG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuXG4gICAgLyoqXG4gICAgICogQW4gXCJpbnRlcmltXCIgdGlsZSBmb3IgdGhpcyB0aWxlLiBUaGUgaW50ZXJpbSB0aWxlIG1heSBiZSB1c2VkIHdoaWxlIHRoaXNcbiAgICAgKiBvbmUgaXMgbG9hZGluZywgZm9yIFwic21vb3RoXCIgdHJhbnNpdGlvbnMgd2hlbiBjaGFuZ2luZyBwYXJhbXMvZGltZW5zaW9uc1xuICAgICAqIG9uIHRoZSBzb3VyY2UuXG4gICAgICogQHR5cGUge1RpbGV9XG4gICAgICovXG4gICAgdGhpcy5pbnRlcmltVGlsZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBIGtleSBhc3NpZ25lZCB0byB0aGUgdGlsZS4gVGhpcyBpcyB1c2VkIGJ5IHRoZSB0aWxlIHNvdXJjZSB0byBkZXRlcm1pbmVcbiAgICAgKiBpZiB0aGlzIHRpbGUgY2FuIGVmZmVjdGl2ZWx5IGJlIHVzZWQsIG9yIGlmIGEgbmV3IHRpbGUgc2hvdWxkIGJlIGNyZWF0ZWRcbiAgICAgKiBhbmQgdGhpcyBvbmUgYmUgdXNlZCBhcyBhbiBpbnRlcmltIHRpbGUgZm9yIHRoaXMgbmV3IHRpbGUuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmtleSA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGR1cmF0aW9uIGZvciB0aGUgb3BhY2l0eSB0cmFuc2l0aW9uLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50cmFuc2l0aW9uXyA9IG9wdGlvbnMudHJhbnNpdGlvbiA9PT0gdW5kZWZpbmVkID8gMjUwIDogb3B0aW9ucy50cmFuc2l0aW9uO1xuXG4gICAgLyoqXG4gICAgICogTG9va3VwIG9mIHN0YXJ0IHRpbWVzIGZvciByZW5kZXJpbmcgdHJhbnNpdGlvbnMuICBJZiB0aGUgc3RhcnQgdGltZSBpc1xuICAgICAqIGVxdWFsIHRvIC0xLCB0aGUgdHJhbnNpdGlvbiBpcyBjb21wbGV0ZS5cbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgbnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLnRyYW5zaXRpb25TdGFydHNfID0ge307XG5cbiAgfVxuXG4gIGlmICggRXZlbnRUYXJnZXQgKSBUaWxlLl9fcHJvdG9fXyA9IEV2ZW50VGFyZ2V0O1xuICBUaWxlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEV2ZW50VGFyZ2V0ICYmIEV2ZW50VGFyZ2V0LnByb3RvdHlwZSApO1xuICBUaWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRpbGU7XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIFRpbGUucHJvdG90eXBlLmNoYW5nZWQgPSBmdW5jdGlvbiBjaGFuZ2VkICgpIHtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRUeXBlLkNIQU5HRSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gS2V5LlxuICAgKi9cbiAgVGlsZS5wcm90b3R5cGUuZ2V0S2V5ID0gZnVuY3Rpb24gZ2V0S2V5ICgpIHtcbiAgICByZXR1cm4gdGhpcy5rZXkgKyAnLycgKyB0aGlzLnRpbGVDb29yZDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBpbnRlcmltIHRpbGUgbW9zdCBzdWl0YWJsZSBmb3IgcmVuZGVyaW5nIHVzaW5nIHRoZSBjaGFpbiBvZiBpbnRlcmltXG4gICAqIHRpbGVzLiBUaGlzIGNvcnJlc3BvbmRzIHRvIHRoZSAgbW9zdCByZWNlbnQgdGlsZSB0aGF0IGhhcyBiZWVuIGxvYWRlZCwgaWYgbm9cbiAgICogc3VjaCB0aWxlIGV4aXN0cywgdGhlIG9yaWdpbmFsIHRpbGUgaXMgcmV0dXJuZWQuXG4gICAqIEByZXR1cm4geyFUaWxlfSBCZXN0IHRpbGUgZm9yIHJlbmRlcmluZy5cbiAgICovXG4gIFRpbGUucHJvdG90eXBlLmdldEludGVyaW1UaWxlID0gZnVuY3Rpb24gZ2V0SW50ZXJpbVRpbGUgKCkge1xuICAgIGlmICghdGhpcy5pbnRlcmltVGlsZSkge1xuICAgICAgLy9lbXB0eSBjaGFpblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciB0aWxlID0gdGhpcy5pbnRlcmltVGlsZTtcblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGxvYWRlZCB0aWxlIGFuZCByZXR1cm4gaXQuIFNpbmNlIHRoZSBjaGFpbiBpcyBzb3J0ZWQgaW5cbiAgICAvLyBkZWNyZWFzaW5nIG9yZGVyIG9mIGNyZWF0aW9uIHRpbWUsIHRoZXJlIGlzIG5vIG5lZWQgdG8gc2VhcmNoIHRoZSByZW1haW5kZXJcbiAgICAvLyBvZiB0aGUgbGlzdCAoYWxsIHRob3NlIHRpbGVzIGNvcnJlc3BvbmQgdG8gb2xkZXIgcmVxdWVzdHMgYW5kIHdpbGwgYmVcbiAgICAvLyBjbGVhbmVkIHVwIGJ5IHJlZnJlc2hJbnRlcmltQ2hhaW4pXG4gICAgZG8ge1xuICAgICAgaWYgKHRpbGUuZ2V0U3RhdGUoKSA9PSBUaWxlU3RhdGUuTE9BREVEKSB7XG4gICAgICAgIHJldHVybiB0aWxlO1xuICAgICAgfVxuICAgICAgdGlsZSA9IHRpbGUuaW50ZXJpbVRpbGU7XG4gICAgfSB3aGlsZSAodGlsZSk7XG5cbiAgICAvLyB3ZSBjYW4gbm90IGZpbmQgYSBiZXR0ZXIgdGlsZVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHb2VzIHRocm91Z2ggdGhlIGNoYWluIG9mIGludGVyaW0gdGlsZXMgYW5kIGRpc2NhcmRzIHNlY3Rpb25zIG9mIHRoZSBjaGFpblxuICAgKiB0aGF0IGFyZSBubyBsb25nZXIgcmVsZXZhbnQuXG4gICAqL1xuICBUaWxlLnByb3RvdHlwZS5yZWZyZXNoSW50ZXJpbUNoYWluID0gZnVuY3Rpb24gcmVmcmVzaEludGVyaW1DaGFpbiAoKSB7XG4gICAgaWYgKCF0aGlzLmludGVyaW1UaWxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRpbGUgPSB0aGlzLmludGVyaW1UaWxlO1xuICAgIHZhciBwcmV2ID0gLyoqIEB0eXBlIHtUaWxlfSAqLyAodGhpcyk7XG5cbiAgICBkbyB7XG4gICAgICBpZiAodGlsZS5nZXRTdGF0ZSgpID09IFRpbGVTdGF0ZS5MT0FERUQpIHtcbiAgICAgICAgLy93ZSBoYXZlIGEgbG9hZGVkIHRpbGUsIHdlIGNhbiBkaXNjYXJkIHRoZSByZXN0IG9mIHRoZSBsaXN0XG4gICAgICAgIC8vd2Ugd291bGQgY291bGQgYWJvcnQgYW55IExPQURJTkcgdGlsZSByZXF1ZXN0XG4gICAgICAgIC8vb2xkZXIgdGhhbiB0aGlzIHRpbGUgKGkuZS4gYW55IExPQURJTkcgdGlsZSBmb2xsb3dpbmcgdGhpcyBlbnRyeSBpbiB0aGUgY2hhaW4pXG4gICAgICAgIHRpbGUuaW50ZXJpbVRpbGUgPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAodGlsZS5nZXRTdGF0ZSgpID09IFRpbGVTdGF0ZS5MT0FESU5HKSB7XG4gICAgICAgIC8va2VlcCB0aGlzIExPQURJTkcgdGlsZSBhbnkgbG9hZGVkIHRpbGVzIGxhdGVyIGluIHRoZSBjaGFpbiBhcmVcbiAgICAgICAgLy9vbGRlciB0aGFuIHRoaXMgdGlsZSwgc28gd2UncmUgc3RpbGwgaW50ZXJlc3RlZCBpbiB0aGUgcmVxdWVzdFxuICAgICAgICBwcmV2ID0gdGlsZTtcbiAgICAgIH0gZWxzZSBpZiAodGlsZS5nZXRTdGF0ZSgpID09IFRpbGVTdGF0ZS5JRExFKSB7XG4gICAgICAgIC8vdGhlIGhlYWQgb2YgdGhlIGxpc3QgaXMgdGhlIG1vc3QgY3VycmVudCB0aWxlLCB3ZSBkb24ndCBuZWVkXG4gICAgICAgIC8vdG8gc3RhcnQgYW55IG90aGVyIHJlcXVlc3RzIGZvciB0aGlzIGNoYWluXG4gICAgICAgIHByZXYuaW50ZXJpbVRpbGUgPSB0aWxlLmludGVyaW1UaWxlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJldiA9IHRpbGU7XG4gICAgICB9XG4gICAgICB0aWxlID0gcHJldi5pbnRlcmltVGlsZTtcbiAgICB9IHdoaWxlICh0aWxlKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSB0aWxlIGNvb3JkaW5hdGUgZm9yIHRoaXMgdGlsZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSBUaGUgdGlsZSBjb29yZGluYXRlLlxuICAgKiBAYXBpXG4gICAqL1xuICBUaWxlLnByb3RvdHlwZS5nZXRUaWxlQ29vcmQgPSBmdW5jdGlvbiBnZXRUaWxlQ29vcmQgKCkge1xuICAgIHJldHVybiB0aGlzLnRpbGVDb29yZDtcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7VGlsZVN0YXRlfSBTdGF0ZS5cbiAgICovXG4gIFRpbGUucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24gZ2V0U3RhdGUgKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdGF0ZSBvZiB0aGlzIHRpbGUuIElmIHlvdSB3cml0ZSB5b3VyIG93biB7QGxpbmsgbW9kdWxlOm9sL1RpbGV+TG9hZEZ1bmN0aW9uIHRpbGVMb2FkRnVuY3Rpb259ICxcbiAgICogaXQgaXMgaW1wb3J0YW50IHRvIHNldCB0aGUgc3RhdGUgY29ycmVjdGx5IHRvIHtAbGluayBtb2R1bGU6b2wvVGlsZVN0YXRlfkVSUk9SfVxuICAgKiB3aGVuIHRoZSB0aWxlIGNhbm5vdCBiZSBsb2FkZWQuIE90aGVyd2lzZSB0aGUgdGlsZSBjYW5ub3QgYmUgcmVtb3ZlZCBmcm9tXG4gICAqIHRoZSB0aWxlIHF1ZXVlIGFuZCB3aWxsIGJsb2NrIG90aGVyIHJlcXVlc3RzLlxuICAgKiBAcGFyYW0ge1RpbGVTdGF0ZX0gc3RhdGUgU3RhdGUuXG4gICAqIEBhcGlcbiAgICovXG4gIFRpbGUucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gc2V0U3RhdGUgKHN0YXRlKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMb2FkIHRoZSBpbWFnZSBvciByZXRyeSBpZiBsb2FkaW5nIHByZXZpb3VzbHkgZmFpbGVkLlxuICAgKiBMb2FkaW5nIGlzIHRha2VuIGNhcmUgb2YgYnkgdGhlIHRpbGUgcXVldWUsIGFuZCBjYWxsaW5nIHRoaXMgbWV0aG9kIGlzXG4gICAqIG9ubHkgbmVlZGVkIGZvciBwcmVsb2FkaW5nIG9yIGZvciByZWxvYWRpbmcgaW4gY2FzZSBvZiBhbiBlcnJvci5cbiAgICogQGFic3RyYWN0XG4gICAqIEBhcGlcbiAgICovXG4gIFRpbGUucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiBsb2FkICgpIHt9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGFscGhhIHZhbHVlIGZvciByZW5kZXJpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBBbiBpZCBmb3IgdGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdGltZSBUaGUgcmVuZGVyIGZyYW1lIHRpbWUuXG4gICAqIEByZXR1cm4ge251bWJlcn0gQSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxLlxuICAgKi9cbiAgVGlsZS5wcm90b3R5cGUuZ2V0QWxwaGEgPSBmdW5jdGlvbiBnZXRBbHBoYSAoaWQsIHRpbWUpIHtcbiAgICBpZiAoIXRoaXMudHJhbnNpdGlvbl8pIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIHZhciBzdGFydCA9IHRoaXMudHJhbnNpdGlvblN0YXJ0c19baWRdO1xuICAgIGlmICghc3RhcnQpIHtcbiAgICAgIHN0YXJ0ID0gdGltZTtcbiAgICAgIHRoaXMudHJhbnNpdGlvblN0YXJ0c19baWRdID0gc3RhcnQ7XG4gICAgfSBlbHNlIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIHZhciBkZWx0YSA9IHRpbWUgLSBzdGFydCArICgxMDAwIC8gNjApOyAvLyBhdm9pZCByZW5kZXJpbmcgYXQgMFxuICAgIGlmIChkZWx0YSA+PSB0aGlzLnRyYW5zaXRpb25fKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIGVhc2VJbihkZWx0YSAvIHRoaXMudHJhbnNpdGlvbl8pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgYSB0aWxlIGlzIGluIGFuIGFscGhhIHRyYW5zaXRpb24uICBBIHRpbGUgaXMgY29uc2lkZXJlZCBpblxuICAgKiB0cmFuc2l0aW9uIGlmIHRpbGUuZ2V0QWxwaGEoKSBoYXMgbm90IHlldCBiZWVuIGNhbGxlZCBvciBoYXMgYmVlbiBjYWxsZWRcbiAgICogYW5kIHJldHVybmVkIDEuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBBbiBpZCBmb3IgdGhlIHJlbmRlcmVyLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgdGlsZSBpcyBpbiB0cmFuc2l0aW9uLlxuICAgKi9cbiAgVGlsZS5wcm90b3R5cGUuaW5UcmFuc2l0aW9uID0gZnVuY3Rpb24gaW5UcmFuc2l0aW9uIChpZCkge1xuICAgIGlmICghdGhpcy50cmFuc2l0aW9uXykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uU3RhcnRzX1tpZF0gIT09IC0xO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNYXJrIGEgdHJhbnNpdGlvbiBhcyBjb21wbGV0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIEFuIGlkIGZvciB0aGUgcmVuZGVyZXIuXG4gICAqL1xuICBUaWxlLnByb3RvdHlwZS5lbmRUcmFuc2l0aW9uID0gZnVuY3Rpb24gZW5kVHJhbnNpdGlvbiAoaWQpIHtcbiAgICBpZiAodGhpcy50cmFuc2l0aW9uXykge1xuICAgICAgdGhpcy50cmFuc2l0aW9uU3RhcnRzX1tpZF0gPSAtMTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFRpbGU7XG59KEV2ZW50VGFyZ2V0KSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgVGlsZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGlsZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvVGlsZUNhY2hlXG4gKi9cbmltcG9ydCBMUlVDYWNoZSBmcm9tICcuL3N0cnVjdHMvTFJVQ2FjaGUuanMnO1xuaW1wb3J0IHtmcm9tS2V5LCBnZXRLZXl9IGZyb20gJy4vdGlsZWNvb3JkLmpzJztcblxudmFyIFRpbGVDYWNoZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKExSVUNhY2hlKSB7XG4gIGZ1bmN0aW9uIFRpbGVDYWNoZShvcHRfaGlnaFdhdGVyTWFyaykge1xuXG4gICAgTFJVQ2FjaGUuY2FsbCh0aGlzLCBvcHRfaGlnaFdhdGVyTWFyayk7XG5cbiAgfVxuXG4gIGlmICggTFJVQ2FjaGUgKSBUaWxlQ2FjaGUuX19wcm90b19fID0gTFJVQ2FjaGU7XG4gIFRpbGVDYWNoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBMUlVDYWNoZSAmJiBMUlVDYWNoZS5wcm90b3R5cGUgKTtcbiAgVGlsZUNhY2hlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRpbGVDYWNoZTtcblxuICAvKipcbiAgICogQHBhcmFtIHshT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdD59IHVzZWRUaWxlcyBVc2VkIHRpbGVzLlxuICAgKi9cbiAgVGlsZUNhY2hlLnByb3RvdHlwZS5leHBpcmVDYWNoZSA9IGZ1bmN0aW9uIGV4cGlyZUNhY2hlICh1c2VkVGlsZXMpIHtcbiAgICB3aGlsZSAodGhpcy5jYW5FeHBpcmVDYWNoZSgpKSB7XG4gICAgICB2YXIgdGlsZSA9IHRoaXMucGVla0xhc3QoKTtcbiAgICAgIHZhciB6S2V5ID0gdGlsZS50aWxlQ29vcmRbMF0udG9TdHJpbmcoKTtcbiAgICAgIGlmICh6S2V5IGluIHVzZWRUaWxlcyAmJiB1c2VkVGlsZXNbektleV0uY29udGFpbnModGlsZS50aWxlQ29vcmQpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wb3AoKS5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBQcnVuZSBhbGwgdGlsZXMgZnJvbSB0aGUgY2FjaGUgdGhhdCBkb24ndCBoYXZlIHRoZSBzYW1lIHogYXMgdGhlIG5ld2VzdCB0aWxlLlxuICAgKi9cbiAgVGlsZUNhY2hlLnByb3RvdHlwZS5wcnVuZUV4Y2VwdE5ld2VzdFogPSBmdW5jdGlvbiBwcnVuZUV4Y2VwdE5ld2VzdFogKCkge1xuICAgIGlmICh0aGlzLmdldENvdW50KCkgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGtleSA9IHRoaXMucGVla0ZpcnN0S2V5KCk7XG4gICAgdmFyIHRpbGVDb29yZCA9IGZyb21LZXkoa2V5KTtcbiAgICB2YXIgeiA9IHRpbGVDb29yZFswXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odGlsZSkge1xuICAgICAgaWYgKHRpbGUudGlsZUNvb3JkWzBdICE9PSB6KSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKGdldEtleSh0aWxlLnRpbGVDb29yZCkpO1xuICAgICAgICB0aWxlLmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgfTtcblxuICByZXR1cm4gVGlsZUNhY2hlO1xufShMUlVDYWNoZSkpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IFRpbGVDYWNoZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGlsZUNhY2hlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9UaWxlUXVldWVcbiAqL1xuaW1wb3J0IFRpbGVTdGF0ZSBmcm9tICcuL1RpbGVTdGF0ZS5qcyc7XG5pbXBvcnQge2xpc3RlbiwgdW5saXN0ZW59IGZyb20gJy4vZXZlbnRzLmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBQcmlvcml0eVF1ZXVlIGZyb20gJy4vc3RydWN0cy9Qcmlvcml0eVF1ZXVlLmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihpbXBvcnQoXCIuL1RpbGUuanNcIikuZGVmYXVsdCwgc3RyaW5nLCBpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZSwgbnVtYmVyKTogbnVtYmVyfSBQcmlvcml0eUZ1bmN0aW9uXG4gKi9cblxuXG52YXIgVGlsZVF1ZXVlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoUHJpb3JpdHlRdWV1ZSkge1xuICBmdW5jdGlvbiBUaWxlUXVldWUodGlsZVByaW9yaXR5RnVuY3Rpb24sIHRpbGVDaGFuZ2VDYWxsYmFjaykge1xuXG4gICAgUHJpb3JpdHlRdWV1ZS5jYWxsKFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge0FycmF5fSBlbGVtZW50IEVsZW1lbnQuXG4gICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFByaW9yaXR5LlxuICAgICAgICovXG4gICAgICB0aGlzLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB0aWxlUHJpb3JpdHlGdW5jdGlvbi5hcHBseShudWxsLCBlbGVtZW50KTtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGVsZW1lbnQgRWxlbWVudC5cbiAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gS2V5LlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiAoLyoqIEB0eXBlIHtpbXBvcnQoXCIuL1RpbGUuanNcIikuZGVmYXVsdH0gKi8gKGVsZW1lbnRbMF0pLmdldEtleSgpKTtcbiAgICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oKTogP31cbiAgICAgKi9cbiAgICB0aGlzLnRpbGVDaGFuZ2VDYWxsYmFja18gPSB0aWxlQ2hhbmdlQ2FsbGJhY2s7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50aWxlc0xvYWRpbmdfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLGJvb2xlYW4+fVxuICAgICAqL1xuICAgIHRoaXMudGlsZXNMb2FkaW5nS2V5c18gPSB7fTtcblxuICB9XG5cbiAgaWYgKCBQcmlvcml0eVF1ZXVlICkgVGlsZVF1ZXVlLl9fcHJvdG9fXyA9IFByaW9yaXR5UXVldWU7XG4gIFRpbGVRdWV1ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQcmlvcml0eVF1ZXVlICYmIFByaW9yaXR5UXVldWUucHJvdG90eXBlICk7XG4gIFRpbGVRdWV1ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUaWxlUXVldWU7XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBUaWxlUXVldWUucHJvdG90eXBlLmVucXVldWUgPSBmdW5jdGlvbiBlbnF1ZXVlIChlbGVtZW50KSB7XG4gICAgdmFyIGFkZGVkID0gUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuZW5xdWV1ZS5jYWxsKHRoaXMsIGVsZW1lbnQpO1xuICAgIGlmIChhZGRlZCkge1xuICAgICAgdmFyIHRpbGUgPSBlbGVtZW50WzBdO1xuICAgICAgbGlzdGVuKHRpbGUsIEV2ZW50VHlwZS5DSEFOR0UsIHRoaXMuaGFuZGxlVGlsZUNoYW5nZSwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBhZGRlZDtcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBOdW1iZXIgb2YgdGlsZXMgbG9hZGluZy5cbiAgICovXG4gIFRpbGVRdWV1ZS5wcm90b3R5cGUuZ2V0VGlsZXNMb2FkaW5nID0gZnVuY3Rpb24gZ2V0VGlsZXNMb2FkaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy50aWxlc0xvYWRpbmdfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHR9IGV2ZW50IEV2ZW50LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBUaWxlUXVldWUucHJvdG90eXBlLmhhbmRsZVRpbGVDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVUaWxlQ2hhbmdlIChldmVudCkge1xuICAgIHZhciB0aWxlID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL1RpbGUuanNcIikuZGVmYXVsdH0gKi8gKGV2ZW50LnRhcmdldCk7XG4gICAgdmFyIHN0YXRlID0gdGlsZS5nZXRTdGF0ZSgpO1xuICAgIGlmIChzdGF0ZSA9PT0gVGlsZVN0YXRlLkxPQURFRCB8fCBzdGF0ZSA9PT0gVGlsZVN0YXRlLkVSUk9SIHx8XG4gICAgICAgIHN0YXRlID09PSBUaWxlU3RhdGUuRU1QVFkgfHwgc3RhdGUgPT09IFRpbGVTdGF0ZS5BQk9SVCkge1xuICAgICAgdW5saXN0ZW4odGlsZSwgRXZlbnRUeXBlLkNIQU5HRSwgdGhpcy5oYW5kbGVUaWxlQ2hhbmdlLCB0aGlzKTtcbiAgICAgIHZhciB0aWxlS2V5ID0gdGlsZS5nZXRLZXkoKTtcbiAgICAgIGlmICh0aWxlS2V5IGluIHRoaXMudGlsZXNMb2FkaW5nS2V5c18pIHtcbiAgICAgICAgZGVsZXRlIHRoaXMudGlsZXNMb2FkaW5nS2V5c19bdGlsZUtleV07XG4gICAgICAgIC0tdGhpcy50aWxlc0xvYWRpbmdfO1xuICAgICAgfVxuICAgICAgdGhpcy50aWxlQ2hhbmdlQ2FsbGJhY2tfKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4VG90YWxMb2FkaW5nIE1heGltdW0gbnVtYmVyIHRpbGVzIHRvIGxvYWQgc2ltdWx0YW5lb3VzbHkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhOZXdMb2FkcyBNYXhpbXVtIG51bWJlciBvZiBuZXcgdGlsZXMgdG8gbG9hZC5cbiAgICovXG4gIFRpbGVRdWV1ZS5wcm90b3R5cGUubG9hZE1vcmVUaWxlcyA9IGZ1bmN0aW9uIGxvYWRNb3JlVGlsZXMgKG1heFRvdGFsTG9hZGluZywgbWF4TmV3TG9hZHMpIHtcbiAgICB2YXIgbmV3TG9hZHMgPSAwO1xuICAgIHZhciBhYm9ydGVkVGlsZXMgPSBmYWxzZTtcbiAgICB2YXIgc3RhdGUsIHRpbGUsIHRpbGVLZXk7XG4gICAgd2hpbGUgKHRoaXMudGlsZXNMb2FkaW5nXyA8IG1heFRvdGFsTG9hZGluZyAmJiBuZXdMb2FkcyA8IG1heE5ld0xvYWRzICYmXG4gICAgICAgICAgIHRoaXMuZ2V0Q291bnQoKSA+IDApIHtcbiAgICAgIHRpbGUgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vVGlsZS5qc1wiKS5kZWZhdWx0fSAqLyAodGhpcy5kZXF1ZXVlKClbMF0pO1xuICAgICAgdGlsZUtleSA9IHRpbGUuZ2V0S2V5KCk7XG4gICAgICBzdGF0ZSA9IHRpbGUuZ2V0U3RhdGUoKTtcbiAgICAgIGlmIChzdGF0ZSA9PT0gVGlsZVN0YXRlLkFCT1JUKSB7XG4gICAgICAgIGFib3J0ZWRUaWxlcyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBUaWxlU3RhdGUuSURMRSAmJiAhKHRpbGVLZXkgaW4gdGhpcy50aWxlc0xvYWRpbmdLZXlzXykpIHtcbiAgICAgICAgdGhpcy50aWxlc0xvYWRpbmdLZXlzX1t0aWxlS2V5XSA9IHRydWU7XG4gICAgICAgICsrdGhpcy50aWxlc0xvYWRpbmdfO1xuICAgICAgICArK25ld0xvYWRzO1xuICAgICAgICB0aWxlLmxvYWQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5ld0xvYWRzID09PSAwICYmIGFib3J0ZWRUaWxlcykge1xuICAgICAgLy8gRG8gbm90IHN0b3AgdGhlIHJlbmRlciBsb29wIHdoZW4gYWxsIHdhbnRlZCB0aWxlcyB3ZXJlIGFib3J0ZWQgZHVlIHRvXG4gICAgICAvLyBhIHNtYWxsLCBzYXR1cmF0ZWQgdGlsZSBjYWNoZS5cbiAgICAgIHRoaXMudGlsZUNoYW5nZUNhbGxiYWNrXygpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVGlsZVF1ZXVlO1xufShQcmlvcml0eVF1ZXVlKSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgVGlsZVF1ZXVlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaWxlUXVldWUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL1RpbGVSYW5nZVxuICovXG5cbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiBhIGNvbnRpZ3VvdXMgYmxvY2sgb2YgdGlsZXMuICBBIHRpbGUgcmFuZ2UgaXMgc3BlY2lmaWVkXG4gKiBieSBpdHMgbWluL21heCB0aWxlIGNvb3JkaW5hdGVzIGFuZCBpcyBpbmNsdXNpdmUgb2YgY29vcmRpbmF0ZXMuXG4gKi9cbnZhciBUaWxlUmFuZ2UgPSBmdW5jdGlvbiBUaWxlUmFuZ2UobWluWCwgbWF4WCwgbWluWSwgbWF4WSkge1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5taW5YID0gbWluWDtcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMubWF4WCA9IG1heFg7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLm1pblkgPSBtaW5ZO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5tYXhZID0gbWF4WTtcblxufTtcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IENvbnRhaW5zIHRpbGUgY29vcmRpbmF0ZS5cbiAqL1xuVGlsZVJhbmdlLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIGNvbnRhaW5zICh0aWxlQ29vcmQpIHtcbiAgcmV0dXJuIHRoaXMuY29udGFpbnNYWSh0aWxlQ29vcmRbMV0sIHRpbGVDb29yZFsyXSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VGlsZVJhbmdlfSB0aWxlUmFuZ2UgVGlsZSByYW5nZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IENvbnRhaW5zLlxuICovXG5UaWxlUmFuZ2UucHJvdG90eXBlLmNvbnRhaW5zVGlsZVJhbmdlID0gZnVuY3Rpb24gY29udGFpbnNUaWxlUmFuZ2UgKHRpbGVSYW5nZSkge1xuICByZXR1cm4gdGhpcy5taW5YIDw9IHRpbGVSYW5nZS5taW5YICYmIHRpbGVSYW5nZS5tYXhYIDw9IHRoaXMubWF4WCAmJlxuICAgICB0aGlzLm1pblkgPD0gdGlsZVJhbmdlLm1pblkgJiYgdGlsZVJhbmdlLm1heFkgPD0gdGhpcy5tYXhZO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0geCBUaWxlIGNvb3JkaW5hdGUgeC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFRpbGUgY29vcmRpbmF0ZSB5LlxuICogQHJldHVybiB7Ym9vbGVhbn0gQ29udGFpbnMgY29vcmRpbmF0ZS5cbiAqL1xuVGlsZVJhbmdlLnByb3RvdHlwZS5jb250YWluc1hZID0gZnVuY3Rpb24gY29udGFpbnNYWSAoeCwgeSkge1xuICByZXR1cm4gdGhpcy5taW5YIDw9IHggJiYgeCA8PSB0aGlzLm1heFggJiYgdGhpcy5taW5ZIDw9IHkgJiYgeSA8PSB0aGlzLm1heFk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VGlsZVJhbmdlfSB0aWxlUmFuZ2UgVGlsZSByYW5nZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IEVxdWFscy5cbiAqL1xuVGlsZVJhbmdlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKHRpbGVSYW5nZSkge1xuICByZXR1cm4gdGhpcy5taW5YID09IHRpbGVSYW5nZS5taW5YICYmIHRoaXMubWluWSA9PSB0aWxlUmFuZ2UubWluWSAmJlxuICAgICB0aGlzLm1heFggPT0gdGlsZVJhbmdlLm1heFggJiYgdGhpcy5tYXhZID09IHRpbGVSYW5nZS5tYXhZO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1RpbGVSYW5nZX0gdGlsZVJhbmdlIFRpbGUgcmFuZ2UuXG4gKi9cblRpbGVSYW5nZS5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kICh0aWxlUmFuZ2UpIHtcbiAgaWYgKHRpbGVSYW5nZS5taW5YIDwgdGhpcy5taW5YKSB7XG4gICAgdGhpcy5taW5YID0gdGlsZVJhbmdlLm1pblg7XG4gIH1cbiAgaWYgKHRpbGVSYW5nZS5tYXhYID4gdGhpcy5tYXhYKSB7XG4gICAgdGhpcy5tYXhYID0gdGlsZVJhbmdlLm1heFg7XG4gIH1cbiAgaWYgKHRpbGVSYW5nZS5taW5ZIDwgdGhpcy5taW5ZKSB7XG4gICAgdGhpcy5taW5ZID0gdGlsZVJhbmdlLm1pblk7XG4gIH1cbiAgaWYgKHRpbGVSYW5nZS5tYXhZID4gdGhpcy5tYXhZKSB7XG4gICAgdGhpcy5tYXhZID0gdGlsZVJhbmdlLm1heFk7XG4gIH1cbn07XG5cbi8qKlxuICogQHJldHVybiB7bnVtYmVyfSBIZWlnaHQuXG4gKi9cblRpbGVSYW5nZS5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gZ2V0SGVpZ2h0ICgpIHtcbiAgcmV0dXJuIHRoaXMubWF4WSAtIHRoaXMubWluWSArIDE7XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBTaXplLlxuICovXG5UaWxlUmFuZ2UucHJvdG90eXBlLmdldFNpemUgPSBmdW5jdGlvbiBnZXRTaXplICgpIHtcbiAgcmV0dXJuIFt0aGlzLmdldFdpZHRoKCksIHRoaXMuZ2V0SGVpZ2h0KCldO1xufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFdpZHRoLlxuICovXG5UaWxlUmFuZ2UucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24gZ2V0V2lkdGggKCkge1xuICByZXR1cm4gdGhpcy5tYXhYIC0gdGhpcy5taW5YICsgMTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtUaWxlUmFuZ2V9IHRpbGVSYW5nZSBUaWxlIHJhbmdlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gSW50ZXJzZWN0cy5cbiAqL1xuVGlsZVJhbmdlLnByb3RvdHlwZS5pbnRlcnNlY3RzID0gZnVuY3Rpb24gaW50ZXJzZWN0cyAodGlsZVJhbmdlKSB7XG4gIHJldHVybiB0aGlzLm1pblggPD0gdGlsZVJhbmdlLm1heFggJiZcbiAgICAgdGhpcy5tYXhYID49IHRpbGVSYW5nZS5taW5YICYmXG4gICAgIHRoaXMubWluWSA8PSB0aWxlUmFuZ2UubWF4WSAmJlxuICAgICB0aGlzLm1heFkgPj0gdGlsZVJhbmdlLm1pblk7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG1pblggTWluaW11bSBYLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heFggTWF4aW11bSBYLlxuICogQHBhcmFtIHtudW1iZXJ9IG1pblkgTWluaW11bSBZLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heFkgTWF4aW11bSBZLlxuICogQHBhcmFtIHtUaWxlUmFuZ2U9fSB0aWxlUmFuZ2UgVGlsZVJhbmdlLlxuICogQHJldHVybiB7VGlsZVJhbmdlfSBUaWxlIHJhbmdlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGUobWluWCwgbWF4WCwgbWluWSwgbWF4WSwgdGlsZVJhbmdlKSB7XG4gIGlmICh0aWxlUmFuZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHRpbGVSYW5nZS5taW5YID0gbWluWDtcbiAgICB0aWxlUmFuZ2UubWF4WCA9IG1heFg7XG4gICAgdGlsZVJhbmdlLm1pblkgPSBtaW5ZO1xuICAgIHRpbGVSYW5nZS5tYXhZID0gbWF4WTtcbiAgICByZXR1cm4gdGlsZVJhbmdlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgVGlsZVJhbmdlKG1pblgsIG1heFgsIG1pblksIG1heFkpO1xuICB9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgVGlsZVJhbmdlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaWxlUmFuZ2UuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL1RpbGVTdGF0ZVxuICovXG5cbi8qKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBJRExFOiAwLFxuICBMT0FESU5HOiAxLFxuICBMT0FERUQ6IDIsXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgdGhhdCB0aWxlIGxvYWRpbmcgZmFpbGVkXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBFUlJPUjogMyxcbiAgRU1QVFk6IDQsXG4gIEFCT1JUOiA1XG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaWxlU3RhdGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL1ZpZXdcbiAqL1xuaW1wb3J0IHtERUZBVUxUX1RJTEVfU0laRX0gZnJvbSAnLi90aWxlZ3JpZC9jb21tb24uanMnO1xuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4vdXRpbC5qcyc7XG5pbXBvcnQge1ZPSUR9IGZyb20gJy4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCB7Y3JlYXRlRXh0ZW50LCBub25lIGFzIGNlbnRlck5vbmV9IGZyb20gJy4vY2VudGVyY29uc3RyYWludC5qcyc7XG5pbXBvcnQgQmFzZU9iamVjdCBmcm9tICcuL09iamVjdC5qcyc7XG5pbXBvcnQge2NyZWF0ZVNuYXBUb1Jlc29sdXRpb25zLCBjcmVhdGVTbmFwVG9Qb3dlcn0gZnJvbSAnLi9yZXNvbHV0aW9uY29uc3RyYWludC5qcyc7XG5pbXBvcnQge2NyZWF0ZVNuYXBUb1plcm8sIGNyZWF0ZVNuYXBUb04sIG5vbmUgYXMgcm90YXRpb25Ob25lLCBkaXNhYmxlfSBmcm9tICcuL3JvdGF0aW9uY29uc3RyYWludC5qcyc7XG5pbXBvcnQgVmlld0hpbnQgZnJvbSAnLi9WaWV3SGludC5qcyc7XG5pbXBvcnQgVmlld1Byb3BlcnR5IGZyb20gJy4vVmlld1Byb3BlcnR5LmpzJztcbmltcG9ydCB7bGluZWFyRmluZE5lYXJlc3R9IGZyb20gJy4vYXJyYXkuanMnO1xuaW1wb3J0IHthc3NlcnR9IGZyb20gJy4vYXNzZXJ0cy5qcyc7XG5pbXBvcnQge2FkZCBhcyBhZGRDb29yZGluYXRlLCByb3RhdGUgYXMgcm90YXRlQ29vcmRpbmF0ZSwgZXF1YWxzIGFzIGNvb3JkaW5hdGVzRXF1YWx9IGZyb20gJy4vY29vcmRpbmF0ZS5qcyc7XG5pbXBvcnQge2luQW5kT3V0fSBmcm9tICcuL2Vhc2luZy5qcyc7XG5pbXBvcnQge2dldEZvclZpZXdBbmRTaXplLCBnZXRDZW50ZXIsIGdldEhlaWdodCwgZ2V0V2lkdGgsIGlzRW1wdHl9IGZyb20gJy4vZXh0ZW50LmpzJztcbmltcG9ydCBHZW9tZXRyeVR5cGUgZnJvbSAnLi9nZW9tL0dlb21ldHJ5VHlwZS5qcyc7XG5pbXBvcnQge2Zyb21FeHRlbnQgYXMgcG9seWdvbkZyb21FeHRlbnR9IGZyb20gJy4vZ2VvbS9Qb2x5Z29uLmpzJztcbmltcG9ydCB7Y2xhbXAsIG1vZHVsb30gZnJvbSAnLi9tYXRoLmpzJztcbmltcG9ydCB7YXNzaWdufSBmcm9tICcuL29iai5qcyc7XG5pbXBvcnQge2NyZWF0ZVByb2plY3Rpb24sIE1FVEVSU19QRVJfVU5JVH0gZnJvbSAnLi9wcm9qLmpzJztcbmltcG9ydCBVbml0cyBmcm9tICcuL3Byb2ovVW5pdHMuanMnO1xuXG5cbi8qKlxuICogQW4gYW5pbWF0aW9uIGNvbmZpZ3VyYXRpb25cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBBbmltYXRpb25cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFtzb3VyY2VDZW50ZXJdXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBbdGFyZ2V0Q2VudGVyXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtzb3VyY2VSZXNvbHV0aW9uXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0YXJnZXRSZXNvbHV0aW9uXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtzb3VyY2VSb3RhdGlvbl1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdGFyZ2V0Um90YXRpb25dXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBbYW5jaG9yXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHN0YXJ0XG4gKiBAcHJvcGVydHkge251bWJlcn0gZHVyYXRpb25cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY29tcGxldGVcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24obnVtYmVyKTpudW1iZXJ9IGVhc2luZ1xuICogQHByb3BlcnR5IHtmdW5jdGlvbihib29sZWFuKX0gY2FsbGJhY2tcbiAqL1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ29uc3RyYWludHNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9jZW50ZXJjb25zdHJhaW50LmpzXCIpLlR5cGV9IGNlbnRlclxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL3Jlc29sdXRpb25jb25zdHJhaW50LmpzXCIpLlR5cGV9IHJlc29sdXRpb25cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9yb3RhdGlvbmNvbnN0cmFpbnQuanNcIikuVHlwZX0gcm90YXRpb25cbiAqL1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRml0T3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gW3NpemVdIFRoZSBzaXplIGluIHBpeGVscyBvZiB0aGUgYm94IHRvIGZpdFxuICogdGhlIGV4dGVudCBpbnRvLiBEZWZhdWx0IGlzIHRoZSBjdXJyZW50IHNpemUgb2YgdGhlIGZpcnN0IG1hcCBpbiB0aGUgRE9NIHRoYXRcbiAqIHVzZXMgdGhpcyB2aWV3LCBvciBgWzEwMCwgMTAwXWAgaWYgbm8gc3VjaCBtYXAgaXMgZm91bmQuXG4gKiBAcHJvcGVydHkgeyFBcnJheTxudW1iZXI+fSBbcGFkZGluZz1bMCwgMCwgMCwgMF1dIFBhZGRpbmcgKGluIHBpeGVscykgdG8gYmVcbiAqIGNsZWFyZWQgaW5zaWRlIHRoZSB2aWV3LiBWYWx1ZXMgaW4gdGhlIGFycmF5IGFyZSB0b3AsIHJpZ2h0LCBib3R0b20gYW5kIGxlZnRcbiAqIHBhZGRpbmcuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjb25zdHJhaW5SZXNvbHV0aW9uPXRydWVdIENvbnN0cmFpbiB0aGUgcmVzb2x1dGlvbi5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW25lYXJlc3Q9ZmFsc2VdIElmIGBjb25zdHJhaW5SZXNvbHV0aW9uYCBpcyBgdHJ1ZWAsIGdldFxuICogdGhlIG5lYXJlc3QgZXh0ZW50IGluc3RlYWQgb2YgdGhlIGNsb3Nlc3QgdGhhdCBhY3R1YWxseSBmaXRzIHRoZSB2aWV3LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5SZXNvbHV0aW9uPTBdIE1pbmltdW0gcmVzb2x1dGlvbiB0aGF0IHdlIHpvb20gdG8uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFpvb21dIE1heGltdW0gem9vbSBsZXZlbCB0aGF0IHdlIHpvb20gdG8uIElmXG4gKiBgbWluUmVzb2x1dGlvbmAgaXMgZ2l2ZW4sIHRoaXMgcHJvcGVydHkgaXMgaWdub3JlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHVyYXRpb25dIFRoZSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAqIEJ5IGRlZmF1bHQsIHRoZXJlIGlzIG5vIGFuaW1hdGlvbiB0byB0aGUgdGFyZ2V0IGV4dGVudC5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24obnVtYmVyKTpudW1iZXJ9IFtlYXNpbmddIFRoZSBlYXNpbmcgZnVuY3Rpb24gdXNlZCBkdXJpbmdcbiAqIHRoZSBhbmltYXRpb24gKGRlZmF1bHRzIHRvIHtAbGluayBtb2R1bGU6b2wvZWFzaW5nfmluQW5kT3V0fSkuXG4gKiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggZnJhbWUgd2l0aCBhIG51bWJlciByZXByZXNlbnRpbmcgYVxuICogZnJhY3Rpb24gb2YgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLiAgVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBudW1iZXJcbiAqIGJldHdlZW4gMCBhbmQgMSByZXByZXNlbnRpbmcgdGhlIHByb2dyZXNzIHRvd2FyZCB0aGUgZGVzdGluYXRpb24gc3RhdGUuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGJvb2xlYW4pfSBbY2FsbGJhY2tdIEZ1bmN0aW9uIGNhbGxlZCB3aGVuIHRoZSB2aWV3IGlzIGluXG4gKiBpdHMgZmluYWwgcG9zaXRpb24uIFRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCB3aXRoIGB0cnVlYCBpZiB0aGUgYW5pbWF0aW9uXG4gKiBzZXJpZXMgY29tcGxldGVkIG9uIGl0cyBvd24gb3IgYGZhbHNlYCBpZiBpdCB3YXMgY2FuY2VsbGVkLlxuICovXG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBWaWV3T3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gW2NlbnRlcl0gVGhlIGluaXRpYWwgY2VudGVyIGZvclxuICogdGhlIHZpZXcuIFRoZSBjb29yZGluYXRlIHN5c3RlbSBmb3IgdGhlIGNlbnRlciBpcyBzcGVjaWZpZWQgd2l0aCB0aGVcbiAqIGBwcm9qZWN0aW9uYCBvcHRpb24uIExheWVyIHNvdXJjZXMgd2lsbCBub3QgYmUgZmV0Y2hlZCBpZiB0aGlzIGlzIG5vdCBzZXQsXG4gKiBidXQgdGhlIGNlbnRlciBjYW4gYmUgc2V0IGxhdGVyIHdpdGgge0BsaW5rICNzZXRDZW50ZXJ9LlxuICogQHByb3BlcnR5IHtib29sZWFufG51bWJlcn0gW2NvbnN0cmFpblJvdGF0aW9uPXRydWVdIFJvdGF0aW9uIGNvbnN0cmFpbnQuXG4gKiBgZmFsc2VgIG1lYW5zIG5vIGNvbnN0cmFpbnQuIGB0cnVlYCBtZWFucyBubyBjb25zdHJhaW50LCBidXQgc25hcCB0byB6ZXJvXG4gKiBuZWFyIHplcm8uIEEgbnVtYmVyIGNvbnN0cmFpbnMgdGhlIHJvdGF0aW9uIHRvIHRoYXQgbnVtYmVyIG9mIHZhbHVlcy4gRm9yXG4gKiBleGFtcGxlLCBgNGAgd2lsbCBjb25zdHJhaW4gdGhlIHJvdGF0aW9uIHRvIDAsIDkwLCAxODAsIGFuZCAyNzAgZGVncmVlcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2VuYWJsZVJvdGF0aW9uPXRydWVdIEVuYWJsZSByb3RhdGlvbi5cbiAqIElmIGBmYWxzZWAsIGEgcm90YXRpb24gY29uc3RyYWludCB0aGF0IGFsd2F5cyBzZXRzIHRoZSByb3RhdGlvbiB0byB6ZXJvIGlzXG4gKiB1c2VkLiBUaGUgYGNvbnN0cmFpblJvdGF0aW9uYCBvcHRpb24gaGFzIG5vIGVmZmVjdCBpZiBgZW5hYmxlUm90YXRpb25gIGlzXG4gKiBgZmFsc2VgLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IFtleHRlbnRdIFRoZSBleHRlbnQgdGhhdCBjb25zdHJhaW5zIHRoZVxuICogY2VudGVyLCBpbiBvdGhlciB3b3JkcywgY2VudGVyIGNhbm5vdCBiZSBzZXQgb3V0c2lkZSB0aGlzIGV4dGVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4UmVzb2x1dGlvbl0gVGhlIG1heGltdW0gcmVzb2x1dGlvbiB1c2VkIHRvIGRldGVybWluZVxuICogdGhlIHJlc29sdXRpb24gY29uc3RyYWludC4gSXQgaXMgdXNlZCB0b2dldGhlciB3aXRoIGBtaW5SZXNvbHV0aW9uYCAob3JcbiAqIGBtYXhab29tYCkgYW5kIGB6b29tRmFjdG9yYC4gSWYgdW5zcGVjaWZpZWQgaXQgaXMgY2FsY3VsYXRlZCBpbiBzdWNoIGEgd2F5XG4gKiB0aGF0IHRoZSBwcm9qZWN0aW9uJ3MgdmFsaWRpdHkgZXh0ZW50IGZpdHMgaW4gYSAyNTZ4MjU2IHB4IHRpbGUuIElmIHRoZVxuICogcHJvamVjdGlvbiBpcyBTcGhlcmljYWwgTWVyY2F0b3IgKHRoZSBkZWZhdWx0KSB0aGVuIGBtYXhSZXNvbHV0aW9uYCBkZWZhdWx0c1xuICogdG8gYDQwMDc1MDE2LjY4NTU3ODQ5IC8gMjU2ID0gMTU2NTQzLjAzMzkyODA0MDk3YC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluUmVzb2x1dGlvbl0gVGhlIG1pbmltdW0gcmVzb2x1dGlvbiB1c2VkIHRvIGRldGVybWluZVxuICogdGhlIHJlc29sdXRpb24gY29uc3RyYWludC4gIEl0IGlzIHVzZWQgdG9nZXRoZXIgd2l0aCBgbWF4UmVzb2x1dGlvbmAgKG9yXG4gKiBgbWluWm9vbWApIGFuZCBgem9vbUZhY3RvcmAuICBJZiB1bnNwZWNpZmllZCBpdCBpcyBjYWxjdWxhdGVkIGFzc3VtaW5nIDI5XG4gKiB6b29tIGxldmVscyAod2l0aCBhIGZhY3RvciBvZiAyKS4gSWYgdGhlIHByb2plY3Rpb24gaXMgU3BoZXJpY2FsIE1lcmNhdG9yXG4gKiAodGhlIGRlZmF1bHQpIHRoZW4gYG1pblJlc29sdXRpb25gIGRlZmF1bHRzIHRvXG4gKiBgNDAwNzUwMTYuNjg1NTc4NDkgLyAyNTYgLyBNYXRoLnBvdygyLCAyOCkgPSAwLjAwMDU4MzE2ODI0NTU4MzkyNTNgLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhab29tPTI4XSBUaGUgbWF4aW11bSB6b29tIGxldmVsIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZVxuICogcmVzb2x1dGlvbiBjb25zdHJhaW50LiBJdCBpcyB1c2VkIHRvZ2V0aGVyIHdpdGggYG1pblpvb21gIChvclxuICogYG1heFJlc29sdXRpb25gKSBhbmQgYHpvb21GYWN0b3JgLiAgTm90ZSB0aGF0IGlmIGBtaW5SZXNvbHV0aW9uYCBpcyBhbHNvXG4gKiBwcm92aWRlZCwgaXQgaXMgZ2l2ZW4gcHJlY2VkZW5jZSBvdmVyIGBtYXhab29tYC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluWm9vbT0wXSBUaGUgbWluaW11bSB6b29tIGxldmVsIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZVxuICogcmVzb2x1dGlvbiBjb25zdHJhaW50LiBJdCBpcyB1c2VkIHRvZ2V0aGVyIHdpdGggYG1heFpvb21gIChvclxuICogYG1pblJlc29sdXRpb25gKSBhbmQgYHpvb21GYWN0b3JgLiAgTm90ZSB0aGF0IGlmIGBtYXhSZXNvbHV0aW9uYCBpcyBhbHNvXG4gKiBwcm92aWRlZCwgaXQgaXMgZ2l2ZW4gcHJlY2VkZW5jZSBvdmVyIGBtaW5ab29tYC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9wcm9qLmpzXCIpLlByb2plY3Rpb25MaWtlfSBbcHJvamVjdGlvbj0nRVBTRzozODU3J10gVGhlXG4gKiBwcm9qZWN0aW9uLiBUaGUgZGVmYXVsdCBpcyBTcGhlcmljYWwgTWVyY2F0b3IuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3Jlc29sdXRpb25dIFRoZSBpbml0aWFsIHJlc29sdXRpb24gZm9yIHRoZSB2aWV3LiBUaGVcbiAqIHVuaXRzIGFyZSBgcHJvamVjdGlvbmAgdW5pdHMgcGVyIHBpeGVsIChlLmcuIG1ldGVycyBwZXIgcGl4ZWwpLiBBblxuICogYWx0ZXJuYXRpdmUgdG8gc2V0dGluZyB0aGlzIGlzIHRvIHNldCBgem9vbWAuIExheWVyIHNvdXJjZXMgd2lsbCBub3QgYmVcbiAqIGZldGNoZWQgaWYgbmVpdGhlciB0aGlzIG5vciBgem9vbWAgYXJlIGRlZmluZWQsIGJ1dCB0aGV5IGNhbiBiZSBzZXQgbGF0ZXJcbiAqIHdpdGgge0BsaW5rICNzZXRab29tfSBvciB7QGxpbmsgI3NldFJlc29sdXRpb259LlxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBbcmVzb2x1dGlvbnNdIFJlc29sdXRpb25zIHRvIGRldGVybWluZSB0aGVcbiAqIHJlc29sdXRpb24gY29uc3RyYWludC4gSWYgc2V0IHRoZSBgbWF4UmVzb2x1dGlvbmAsIGBtaW5SZXNvbHV0aW9uYCxcbiAqIGBtaW5ab29tYCwgYG1heFpvb21gLCBhbmQgYHpvb21GYWN0b3JgIG9wdGlvbnMgYXJlIGlnbm9yZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JvdGF0aW9uPTBdIFRoZSBpbml0aWFsIHJvdGF0aW9uIGZvciB0aGUgdmlldyBpbiByYWRpYW5zXG4gKiAocG9zaXRpdmUgcm90YXRpb24gY2xvY2t3aXNlLCAwIG1lYW5zIE5vcnRoKS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbem9vbV0gT25seSB1c2VkIGlmIGByZXNvbHV0aW9uYCBpcyBub3QgZGVmaW5lZC4gWm9vbVxuICogbGV2ZWwgdXNlZCB0byBjYWxjdWxhdGUgdGhlIGluaXRpYWwgcmVzb2x1dGlvbiBmb3IgdGhlIHZpZXcuIFRoZSBpbml0aWFsXG4gKiByZXNvbHV0aW9uIGlzIGRldGVybWluZWQgdXNpbmcgdGhlIHtAbGluayAjY29uc3RyYWluUmVzb2x1dGlvbn0gbWV0aG9kLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt6b29tRmFjdG9yPTJdIFRoZSB6b29tIGZhY3RvciB1c2VkIHRvIGRldGVybWluZSB0aGVcbiAqIHJlc29sdXRpb24gY29uc3RyYWludC5cbiAqL1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQW5pbWF0aW9uT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gW2NlbnRlcl0gVGhlIGNlbnRlciBvZiB0aGUgdmlldyBhdCB0aGUgZW5kIG9mXG4gKiB0aGUgYW5pbWF0aW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt6b29tXSBUaGUgem9vbSBsZXZlbCBvZiB0aGUgdmlldyBhdCB0aGUgZW5kIG9mIHRoZVxuICogYW5pbWF0aW9uLiBUaGlzIHRha2VzIHByZWNlZGVuY2Ugb3ZlciBgcmVzb2x1dGlvbmAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3Jlc29sdXRpb25dIFRoZSByZXNvbHV0aW9uIG9mIHRoZSB2aWV3IGF0IHRoZSBlbmRcbiAqIG9mIHRoZSBhbmltYXRpb24uICBJZiBgem9vbWAgaXMgYWxzbyBwcm92aWRlZCwgdGhpcyBvcHRpb24gd2lsbCBiZSBpZ25vcmVkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyb3RhdGlvbl0gVGhlIHJvdGF0aW9uIG9mIHRoZSB2aWV3IGF0IHRoZSBlbmQgb2ZcbiAqIHRoZSBhbmltYXRpb24uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBbYW5jaG9yXSBPcHRpb25hbCBhbmNob3IgdG8gcmVtYWluZWQgZml4ZWRcbiAqIGR1cmluZyBhIHJvdGF0aW9uIG9yIHJlc29sdXRpb24gYW5pbWF0aW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkdXJhdGlvbj0xMDAwXSBUaGUgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKG51bWJlcik6bnVtYmVyfSBbZWFzaW5nXSBUaGUgZWFzaW5nIGZ1bmN0aW9uIHVzZWRcbiAqIGR1cmluZyB0aGUgYW5pbWF0aW9uIChkZWZhdWx0cyB0byB7QGxpbmsgbW9kdWxlOm9sL2Vhc2luZ35pbkFuZE91dH0pLlxuICogVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIGZyYW1lIHdpdGggYSBudW1iZXIgcmVwcmVzZW50aW5nIGFcbiAqIGZyYWN0aW9uIG9mIHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbi4gIFRoZSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgbnVtYmVyXG4gKiBiZXR3ZWVuIDAgYW5kIDEgcmVwcmVzZW50aW5nIHRoZSBwcm9ncmVzcyB0b3dhcmQgdGhlIGRlc3RpbmF0aW9uIHN0YXRlLlxuICovXG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTdGF0ZVxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY2VudGVyXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb25cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZXNvbHV0aW9uXG4gKiBAcHJvcGVydHkge251bWJlcn0gcm90YXRpb25cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB6b29tXG4gKi9cblxuXG4vKipcbiAqIERlZmF1bHQgbWluIHpvb20gbGV2ZWwgZm9yIHRoZSBtYXAgdmlldy5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbnZhciBERUZBVUxUX01JTl9aT09NID0gMDtcblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEEgVmlldyBvYmplY3QgcmVwcmVzZW50cyBhIHNpbXBsZSAyRCB2aWV3IG9mIHRoZSBtYXAuXG4gKlxuICogVGhpcyBpcyB0aGUgb2JqZWN0IHRvIGFjdCB1cG9uIHRvIGNoYW5nZSB0aGUgY2VudGVyLCByZXNvbHV0aW9uLFxuICogYW5kIHJvdGF0aW9uIG9mIHRoZSBtYXAuXG4gKlxuICogIyMjIFRoZSB2aWV3IHN0YXRlc1xuICpcbiAqIEFuIFZpZXcgaXMgZGV0ZXJtaW5lZCBieSB0aHJlZSBzdGF0ZXM6IGBjZW50ZXJgLCBgcmVzb2x1dGlvbmAsXG4gKiBhbmQgYHJvdGF0aW9uYC4gRWFjaCBzdGF0ZSBoYXMgYSBjb3JyZXNwb25kaW5nIGdldHRlciBhbmQgc2V0dGVyLCBlLmcuXG4gKiBgZ2V0Q2VudGVyYCBhbmQgYHNldENlbnRlcmAgZm9yIHRoZSBgY2VudGVyYCBzdGF0ZS5cbiAqXG4gKiBBbiBWaWV3IGhhcyBhIGBwcm9qZWN0aW9uYC4gVGhlIHByb2plY3Rpb24gZGV0ZXJtaW5lcyB0aGVcbiAqIGNvb3JkaW5hdGUgc3lzdGVtIG9mIHRoZSBjZW50ZXIsIGFuZCBpdHMgdW5pdHMgZGV0ZXJtaW5lIHRoZSB1bml0cyBvZiB0aGVcbiAqIHJlc29sdXRpb24gKHByb2plY3Rpb24gdW5pdHMgcGVyIHBpeGVsKS4gVGhlIGRlZmF1bHQgcHJvamVjdGlvbiBpc1xuICogU3BoZXJpY2FsIE1lcmNhdG9yIChFUFNHOjM4NTcpLlxuICpcbiAqICMjIyBUaGUgY29uc3RyYWludHNcbiAqXG4gKiBgc2V0Q2VudGVyYCwgYHNldFJlc29sdXRpb25gIGFuZCBgc2V0Um90YXRpb25gIGNhbiBiZSB1c2VkIHRvIGNoYW5nZSB0aGVcbiAqIHN0YXRlcyBvZiB0aGUgdmlldy4gQW55IHZhbHVlIGNhbiBiZSBwYXNzZWQgdG8gdGhlIHNldHRlcnMuIEFuZCB0aGUgdmFsdWVcbiAqIHRoYXQgaXMgcGFzc2VkIHRvIGEgc2V0dGVyIHdpbGwgZWZmZWN0aXZlbHkgYmUgdGhlIHZhbHVlIHNldCBpbiB0aGUgdmlldyxcbiAqIGFuZCByZXR1cm5lZCBieSB0aGUgY29ycmVzcG9uZGluZyBnZXR0ZXIuXG4gKlxuICogQnV0IGEgVmlldyBvYmplY3QgYWxzbyBoYXMgYSAqcmVzb2x1dGlvbiBjb25zdHJhaW50KiwgYVxuICogKnJvdGF0aW9uIGNvbnN0cmFpbnQqIGFuZCBhICpjZW50ZXIgY29uc3RyYWludCouXG4gKlxuICogQXMgc2FpZCBhYm92ZSwgbm8gY29uc3RyYWludHMgYXJlIGFwcGxpZWQgd2hlbiB0aGUgc2V0dGVycyBhcmUgdXNlZCB0byBzZXRcbiAqIG5ldyBzdGF0ZXMgZm9yIHRoZSB2aWV3LiBBcHBseWluZyBjb25zdHJhaW50cyBpcyBkb25lIGV4cGxpY2l0bHkgdGhyb3VnaFxuICogdGhlIHVzZSBvZiB0aGUgYGNvbnN0cmFpbipgIGZ1bmN0aW9ucyAoYGNvbnN0cmFpblJlc29sdXRpb25gIGFuZFxuICogYGNvbnN0cmFpblJvdGF0aW9uYCBhbmQgYGNvbnN0cmFpbkNlbnRlcmApLlxuICpcbiAqIFRoZSBtYWluIHVzZXJzIG9mIHRoZSBjb25zdHJhaW50cyBhcmUgdGhlIGludGVyYWN0aW9ucyBhbmQgdGhlXG4gKiBjb250cm9scy4gRm9yIGV4YW1wbGUsIGRvdWJsZS1jbGlja2luZyBvbiB0aGUgbWFwIGNoYW5nZXMgdGhlIHZpZXcgdG9cbiAqIHRoZSBcIm5leHRcIiByZXNvbHV0aW9uLiBBbmQgcmVsZWFzaW5nIHRoZSBmaW5nZXJzIGFmdGVyIHBpbmNoLXpvb21pbmdcbiAqIHNuYXBzIHRvIHRoZSBjbG9zZXN0IHJlc29sdXRpb24gKHdpdGggYW4gYW5pbWF0aW9uKS5cbiAqXG4gKiBUaGUgKnJlc29sdXRpb24gY29uc3RyYWludCogc25hcHMgdG8gc3BlY2lmaWMgcmVzb2x1dGlvbnMuIEl0IGlzXG4gKiBkZXRlcm1pbmVkIGJ5IHRoZSBmb2xsb3dpbmcgb3B0aW9uczogYHJlc29sdXRpb25zYCwgYG1heFJlc29sdXRpb25gLFxuICogYG1heFpvb21gLCBhbmQgYHpvb21GYWN0b3JgLiBJZiBgcmVzb2x1dGlvbnNgIGlzIHNldCwgdGhlIG90aGVyIHRocmVlXG4gKiBvcHRpb25zIGFyZSBpZ25vcmVkLiBTZWUgZG9jdW1lbnRhdGlvbiBmb3IgZWFjaCBvcHRpb24gZm9yIG1vcmVcbiAqIGluZm9ybWF0aW9uLlxuICpcbiAqIFRoZSAqcm90YXRpb24gY29uc3RyYWludCogc25hcHMgdG8gc3BlY2lmaWMgYW5nbGVzLiBJdCBpcyBkZXRlcm1pbmVkXG4gKiBieSB0aGUgZm9sbG93aW5nIG9wdGlvbnM6IGBlbmFibGVSb3RhdGlvbmAgYW5kIGBjb25zdHJhaW5Sb3RhdGlvbmAuXG4gKiBCeSBkZWZhdWx0IHRoZSByb3RhdGlvbiB2YWx1ZSBpcyBzbmFwcGVkIHRvIHplcm8gd2hlbiBhcHByb2FjaGluZyB0aGVcbiAqIGhvcml6b250YWwuXG4gKlxuICogVGhlICpjZW50ZXIgY29uc3RyYWludCogaXMgZGV0ZXJtaW5lZCBieSB0aGUgYGV4dGVudGAgb3B0aW9uLiBCeVxuICogZGVmYXVsdCB0aGUgY2VudGVyIGlzIG5vdCBjb25zdHJhaW5lZCBhdCBhbGwuXG4gKlxuICAqIEBhcGlcbiAqL1xudmFyIFZpZXcgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChCYXNlT2JqZWN0KSB7XG4gIGZ1bmN0aW9uIFZpZXcob3B0X29wdGlvbnMpIHtcbiAgICBCYXNlT2JqZWN0LmNhbGwodGhpcyk7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGFzc2lnbih7fSwgb3B0X29wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLmhpbnRzXyA9IFswLCAwXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PEFycmF5PEFuaW1hdGlvbj4+fVxuICAgICAqL1xuICAgIHRoaXMuYW5pbWF0aW9uc18gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy51cGRhdGVBbmltYXRpb25LZXlfO1xuXG4gICAgdGhpcy51cGRhdGVBbmltYXRpb25zXyA9IHRoaXMudXBkYXRlQW5pbWF0aW9uc18uYmluZCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0XG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5wcm9qZWN0aW9uXyA9IGNyZWF0ZVByb2plY3Rpb24ob3B0aW9ucy5wcm9qZWN0aW9uLCAnRVBTRzozODU3Jyk7XG5cbiAgICB0aGlzLmFwcGx5T3B0aW9uc18ob3B0aW9ucyk7XG4gIH1cblxuICBpZiAoIEJhc2VPYmplY3QgKSBWaWV3Ll9fcHJvdG9fXyA9IEJhc2VPYmplY3Q7XG4gIFZpZXcucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQmFzZU9iamVjdCAmJiBCYXNlT2JqZWN0LnByb3RvdHlwZSApO1xuICBWaWV3LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFZpZXc7XG5cbiAgLyoqXG4gICAqIFNldCB1cCB0aGUgdmlldyB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuICAgKiBAcGFyYW0ge1ZpZXdPcHRpb25zfSBvcHRpb25zIFZpZXcgb3B0aW9ucy5cbiAgICovXG4gIFZpZXcucHJvdG90eXBlLmFwcGx5T3B0aW9uc18gPSBmdW5jdGlvbiBhcHBseU9wdGlvbnNfIChvcHRpb25zKSB7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgKj59XG4gICAgICovXG4gICAgdmFyIHByb3BlcnRpZXMgPSB7fTtcbiAgICBwcm9wZXJ0aWVzW1ZpZXdQcm9wZXJ0eS5DRU5URVJdID0gb3B0aW9ucy5jZW50ZXIgIT09IHVuZGVmaW5lZCA/XG4gICAgICBvcHRpb25zLmNlbnRlciA6IG51bGw7XG5cbiAgICB2YXIgcmVzb2x1dGlvbkNvbnN0cmFpbnRJbmZvID0gY3JlYXRlUmVzb2x1dGlvbkNvbnN0cmFpbnQob3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXhSZXNvbHV0aW9uXyA9IHJlc29sdXRpb25Db25zdHJhaW50SW5mby5tYXhSZXNvbHV0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWluUmVzb2x1dGlvbl8gPSByZXNvbHV0aW9uQ29uc3RyYWludEluZm8ubWluUmVzb2x1dGlvbjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnpvb21GYWN0b3JfID0gcmVzb2x1dGlvbkNvbnN0cmFpbnRJbmZvLnpvb21GYWN0b3I7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnJlc29sdXRpb25zXyA9IG9wdGlvbnMucmVzb2x1dGlvbnM7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5taW5ab29tXyA9IHJlc29sdXRpb25Db25zdHJhaW50SW5mby5taW5ab29tO1xuXG4gICAgdmFyIGNlbnRlckNvbnN0cmFpbnQgPSBjcmVhdGVDZW50ZXJDb25zdHJhaW50KG9wdGlvbnMpO1xuICAgIHZhciByZXNvbHV0aW9uQ29uc3RyYWludCA9IHJlc29sdXRpb25Db25zdHJhaW50SW5mby5jb25zdHJhaW50O1xuICAgIHZhciByb3RhdGlvbkNvbnN0cmFpbnQgPSBjcmVhdGVSb3RhdGlvbkNvbnN0cmFpbnQob3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtDb25zdHJhaW50c31cbiAgICAgKi9cbiAgICB0aGlzLmNvbnN0cmFpbnRzXyA9IHtcbiAgICAgIGNlbnRlcjogY2VudGVyQ29uc3RyYWludCxcbiAgICAgIHJlc29sdXRpb246IHJlc29sdXRpb25Db25zdHJhaW50LFxuICAgICAgcm90YXRpb246IHJvdGF0aW9uQ29uc3RyYWludFxuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucy5yZXNvbHV0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHByb3BlcnRpZXNbVmlld1Byb3BlcnR5LlJFU09MVVRJT05dID0gb3B0aW9ucy5yZXNvbHV0aW9uO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy56b29tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHByb3BlcnRpZXNbVmlld1Byb3BlcnR5LlJFU09MVVRJT05dID0gdGhpcy5jb25zdHJhaW5SZXNvbHV0aW9uKFxuICAgICAgICB0aGlzLm1heFJlc29sdXRpb25fLCBvcHRpb25zLnpvb20gLSB0aGlzLm1pblpvb21fKTtcblxuICAgICAgaWYgKHRoaXMucmVzb2x1dGlvbnNfKSB7IC8vIGluIGNhc2UgbWFwIHpvb20gaXMgb3V0IG9mIG1pbi9tYXggem9vbSByYW5nZVxuICAgICAgICBwcm9wZXJ0aWVzW1ZpZXdQcm9wZXJ0eS5SRVNPTFVUSU9OXSA9IGNsYW1wKFxuICAgICAgICAgIE51bWJlcih0aGlzLmdldFJlc29sdXRpb24oKSB8fCBwcm9wZXJ0aWVzW1ZpZXdQcm9wZXJ0eS5SRVNPTFVUSU9OXSksXG4gICAgICAgICAgdGhpcy5taW5SZXNvbHV0aW9uXywgdGhpcy5tYXhSZXNvbHV0aW9uXyk7XG4gICAgICB9XG4gICAgfVxuICAgIHByb3BlcnRpZXNbVmlld1Byb3BlcnR5LlJPVEFUSU9OXSA9IG9wdGlvbnMucm90YXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucm90YXRpb24gOiAwO1xuICAgIHRoaXMuc2V0UHJvcGVydGllcyhwcm9wZXJ0aWVzKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge1ZpZXdPcHRpb25zfVxuICAgICAqL1xuICAgIHRoaXMub3B0aW9uc18gPSBvcHRpb25zO1xuXG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhbiB1cGRhdGVkIHZlcnNpb24gb2YgdGhlIHZpZXcgb3B0aW9ucyB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgdmlldy4gIFRoZVxuICAgKiBjdXJyZW50IHJlc29sdXRpb24gKG9yIHpvb20pLCBjZW50ZXIsIGFuZCByb3RhdGlvbiBhcmUgYXBwbGllZCB0byBhbnkgc3RvcmVkXG4gICAqIG9wdGlvbnMuICBUaGUgcHJvdmlkZWQgb3B0aW9ucyBjYW4gYmUgdXNlZCB0byBhcHBseSBuZXcgbWluL21heCB6b29tIG9yXG4gICAqIHJlc29sdXRpb24gbGltaXRzLlxuICAgKiBAcGFyYW0ge1ZpZXdPcHRpb25zfSBuZXdPcHRpb25zIE5ldyBvcHRpb25zIHRvIGJlIGFwcGxpZWQuXG4gICAqIEByZXR1cm4ge1ZpZXdPcHRpb25zfSBOZXcgb3B0aW9ucyB1cGRhdGVkIHdpdGggdGhlIGN1cnJlbnQgdmlldyBzdGF0ZS5cbiAgICovXG4gIFZpZXcucHJvdG90eXBlLmdldFVwZGF0ZWRPcHRpb25zXyA9IGZ1bmN0aW9uIGdldFVwZGF0ZWRPcHRpb25zXyAobmV3T3B0aW9ucykge1xuICAgIHZhciBvcHRpb25zID0gYXNzaWduKHt9LCB0aGlzLm9wdGlvbnNfKTtcblxuICAgIC8vIHByZXNlcnZlIHJlc29sdXRpb24gKG9yIHpvb20pXG4gICAgaWYgKG9wdGlvbnMucmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRpb25zLnJlc29sdXRpb24gPSB0aGlzLmdldFJlc29sdXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucy56b29tID0gdGhpcy5nZXRab29tKCk7XG4gICAgfVxuXG4gICAgLy8gcHJlc2VydmUgY2VudGVyXG4gICAgb3B0aW9ucy5jZW50ZXIgPSB0aGlzLmdldENlbnRlcigpO1xuXG4gICAgLy8gcHJlc2VydmUgcm90YXRpb25cbiAgICBvcHRpb25zLnJvdGF0aW9uID0gdGhpcy5nZXRSb3RhdGlvbigpO1xuXG4gICAgcmV0dXJuIGFzc2lnbih7fSwgb3B0aW9ucywgbmV3T3B0aW9ucyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFuaW1hdGUgdGhlIHZpZXcuICBUaGUgdmlldydzIGNlbnRlciwgem9vbSAob3IgcmVzb2x1dGlvbiksIGFuZCByb3RhdGlvblxuICAgKiBjYW4gYmUgYW5pbWF0ZWQgZm9yIHNtb290aCB0cmFuc2l0aW9ucyBiZXR3ZWVuIHZpZXcgc3RhdGVzLiAgRm9yIGV4YW1wbGUsXG4gICAqIHRvIGFuaW1hdGUgdGhlIHZpZXcgdG8gYSBuZXcgem9vbSBsZXZlbDpcbiAgICpcbiAgICogICAgIHZpZXcuYW5pbWF0ZSh7em9vbTogdmlldy5nZXRab29tKCkgKyAxfSk7XG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoZSBhbmltYXRpb24gbGFzdHMgb25lIHNlY29uZCBhbmQgdXNlcyBpbi1hbmQtb3V0IGVhc2luZy4gIFlvdVxuICAgKiBjYW4gY3VzdG9taXplIHRoaXMgYmVoYXZpb3IgYnkgaW5jbHVkaW5nIGBkdXJhdGlvbmAgKGluIG1pbGxpc2Vjb25kcykgYW5kXG4gICAqIGBlYXNpbmdgIG9wdGlvbnMgKHNlZSB7QGxpbmsgbW9kdWxlOm9sL2Vhc2luZ30pLlxuICAgKlxuICAgKiBUbyBjaGFpbiB0b2dldGhlciBtdWx0aXBsZSBhbmltYXRpb25zLCBjYWxsIHRoZSBtZXRob2Qgd2l0aCBtdWx0aXBsZVxuICAgKiBhbmltYXRpb24gb2JqZWN0cy4gIEZvciBleGFtcGxlLCB0byBmaXJzdCB6b29tIGFuZCB0aGVuIHBhbjpcbiAgICpcbiAgICogICAgIHZpZXcuYW5pbWF0ZSh7em9vbTogMTB9LCB7Y2VudGVyOiBbMCwgMF19KTtcbiAgICpcbiAgICogSWYgeW91IHByb3ZpZGUgYSBmdW5jdGlvbiBhcyB0aGUgbGFzdCBhcmd1bWVudCB0byB0aGUgYW5pbWF0ZSBtZXRob2QsIGl0XG4gICAqIHdpbGwgZ2V0IGNhbGxlZCBhdCB0aGUgZW5kIG9mIGFuIGFuaW1hdGlvbiBzZXJpZXMuICBUaGUgY2FsbGJhY2sgd2lsbCBiZVxuICAgKiBjYWxsZWQgd2l0aCBgdHJ1ZWAgaWYgdGhlIGFuaW1hdGlvbiBzZXJpZXMgY29tcGxldGVkIG9uIGl0cyBvd24gb3IgYGZhbHNlYFxuICAgKiBpZiBpdCB3YXMgY2FuY2VsbGVkLlxuICAgKlxuICAgKiBBbmltYXRpb25zIGFyZSBjYW5jZWxsZWQgYnkgdXNlciBpbnRlcmFjdGlvbnMgKGUuZy4gZHJhZ2dpbmcgdGhlIG1hcCkgb3IgYnlcbiAgICogY2FsbGluZyBgdmlldy5zZXRDZW50ZXIoKWAsIGB2aWV3LnNldFJlc29sdXRpb24oKWAsIG9yIGB2aWV3LnNldFJvdGF0aW9uKClgXG4gICAqIChvciBhbm90aGVyIG1ldGhvZCB0aGF0IGNhbGxzIG9uZSBvZiB0aGVzZSkuXG4gICAqXG4gICAqIEBwYXJhbSB7Li4uKEFuaW1hdGlvbk9wdGlvbnN8ZnVuY3Rpb24oYm9vbGVhbikpfSB2YXJfYXJncyBBbmltYXRpb25cbiAgICogICAgIG9wdGlvbnMuICBNdWx0aXBsZSBhbmltYXRpb25zIGNhbiBiZSBydW4gaW4gc2VyaWVzIGJ5IHBhc3NpbmcgbXVsdGlwbGVcbiAgICogICAgIG9wdGlvbnMgb2JqZWN0cy4gIFRvIHJ1biBtdWx0aXBsZSBhbmltYXRpb25zIGluIHBhcmFsbGVsLCBjYWxsIHRoZSBtZXRob2RcbiAgICogICAgIG11bHRpcGxlIHRpbWVzLiAgQW4gb3B0aW9uYWwgY2FsbGJhY2sgY2FuIGJlIHByb3ZpZGVkIGFzIGEgZmluYWxcbiAgICogICAgIGFyZ3VtZW50LiAgVGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdpdGggYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlclxuICAgKiAgICAgdGhlIGFuaW1hdGlvbiBjb21wbGV0ZWQgd2l0aG91dCBiZWluZyBjYW5jZWxsZWQuXG4gICAqIEBhcGlcbiAgICovXG4gIFZpZXcucHJvdG90eXBlLmFuaW1hdGUgPSBmdW5jdGlvbiBhbmltYXRlICh2YXJfYXJncykge1xuICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgIHZhciBhbmltYXRpb25Db3VudCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGNhbGxiYWNrO1xuICAgIGlmIChhbmltYXRpb25Db3VudCA+IDEgJiYgdHlwZW9mIGFyZ3VtZW50c1thbmltYXRpb25Db3VudCAtIDFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IGFyZ3VtZW50c1thbmltYXRpb25Db3VudCAtIDFdO1xuICAgICAgLS1hbmltYXRpb25Db3VudDtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzRGVmKCkpIHtcbiAgICAgIC8vIGlmIHZpZXcgcHJvcGVydGllcyBhcmUgbm90IHlldCBzZXQsIHNob3J0Y3V0IHRvIHRoZSBmaW5hbCBzdGF0ZVxuICAgICAgdmFyIHN0YXRlID0gYXJndW1lbnRzW2FuaW1hdGlvbkNvdW50IC0gMV07XG4gICAgICBpZiAoc3RhdGUuY2VudGVyKSB7XG4gICAgICAgIHRoaXMuc2V0Q2VudGVyKHN0YXRlLmNlbnRlcik7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuem9vbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuc2V0Wm9vbShzdGF0ZS56b29tKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5yb3RhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuc2V0Um90YXRpb24oc3RhdGUucm90YXRpb24pO1xuICAgICAgfVxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGFuaW1hdGlvbkNhbGxiYWNrKGNhbGxiYWNrLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICB2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXIoKS5zbGljZSgpO1xuICAgIHZhciByZXNvbHV0aW9uID0gdGhpcy5nZXRSZXNvbHV0aW9uKCk7XG4gICAgdmFyIHJvdGF0aW9uID0gdGhpcy5nZXRSb3RhdGlvbigpO1xuICAgIHZhciBzZXJpZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuaW1hdGlvbkNvdW50OyArK2kpIHtcbiAgICAgIHZhciBvcHRpb25zID0gLyoqIEB0eXBlIHtBbmltYXRpb25PcHRpb25zfSAqLyAoYXJndW1lbnRzJDFbaV0pO1xuXG4gICAgICB2YXIgYW5pbWF0aW9uID0gLyoqIEB0eXBlIHtBbmltYXRpb259ICovICh7XG4gICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgY29tcGxldGU6IGZhbHNlLFxuICAgICAgICBhbmNob3I6IG9wdGlvbnMuYW5jaG9yLFxuICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kdXJhdGlvbiA6IDEwMDAsXG4gICAgICAgIGVhc2luZzogb3B0aW9ucy5lYXNpbmcgfHwgaW5BbmRPdXRcbiAgICAgIH0pO1xuXG4gICAgICBpZiAob3B0aW9ucy5jZW50ZXIpIHtcbiAgICAgICAgYW5pbWF0aW9uLnNvdXJjZUNlbnRlciA9IGNlbnRlcjtcbiAgICAgICAgYW5pbWF0aW9uLnRhcmdldENlbnRlciA9IG9wdGlvbnMuY2VudGVyO1xuICAgICAgICBjZW50ZXIgPSBhbmltYXRpb24udGFyZ2V0Q2VudGVyO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy56b29tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYW5pbWF0aW9uLnNvdXJjZVJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuICAgICAgICBhbmltYXRpb24udGFyZ2V0UmVzb2x1dGlvbiA9IHRoaXMuY29uc3RyYWluUmVzb2x1dGlvbihcbiAgICAgICAgICB0aGlzLm1heFJlc29sdXRpb25fLCBvcHRpb25zLnpvb20gLSB0aGlzLm1pblpvb21fLCAwKTtcbiAgICAgICAgcmVzb2x1dGlvbiA9IGFuaW1hdGlvbi50YXJnZXRSZXNvbHV0aW9uO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnJlc29sdXRpb24pIHtcbiAgICAgICAgYW5pbWF0aW9uLnNvdXJjZVJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuICAgICAgICBhbmltYXRpb24udGFyZ2V0UmVzb2x1dGlvbiA9IG9wdGlvbnMucmVzb2x1dGlvbjtcbiAgICAgICAgcmVzb2x1dGlvbiA9IGFuaW1hdGlvbi50YXJnZXRSZXNvbHV0aW9uO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5yb3RhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFuaW1hdGlvbi5zb3VyY2VSb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgICAgICB2YXIgZGVsdGEgPSBtb2R1bG8ob3B0aW9ucy5yb3RhdGlvbiAtIHJvdGF0aW9uICsgTWF0aC5QSSwgMiAqIE1hdGguUEkpIC0gTWF0aC5QSTtcbiAgICAgICAgYW5pbWF0aW9uLnRhcmdldFJvdGF0aW9uID0gcm90YXRpb24gKyBkZWx0YTtcbiAgICAgICAgcm90YXRpb24gPSBhbmltYXRpb24udGFyZ2V0Um90YXRpb247XG4gICAgICB9XG5cbiAgICAgIGFuaW1hdGlvbi5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gICAgICAvLyBjaGVjayBpZiBhbmltYXRpb24gaXMgYSBuby1vcFxuICAgICAgaWYgKGlzTm9vcEFuaW1hdGlvbihhbmltYXRpb24pKSB7XG4gICAgICAgIGFuaW1hdGlvbi5jb21wbGV0ZSA9IHRydWU7XG4gICAgICAgIC8vIHdlIHN0aWxsIHB1c2ggaXQgb250byB0aGUgc2VyaWVzIGZvciBjYWxsYmFjayBoYW5kbGluZ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnQgKz0gYW5pbWF0aW9uLmR1cmF0aW9uO1xuICAgICAgfVxuICAgICAgc2VyaWVzLnB1c2goYW5pbWF0aW9uKTtcbiAgICB9XG4gICAgdGhpcy5hbmltYXRpb25zXy5wdXNoKHNlcmllcyk7XG4gICAgdGhpcy5zZXRIaW50KFZpZXdIaW50LkFOSU1BVElORywgMSk7XG4gICAgdGhpcy51cGRhdGVBbmltYXRpb25zXygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgdGhlIHZpZXcgaXMgYmVpbmcgYW5pbWF0ZWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB2aWV3IGlzIGJlaW5nIGFuaW1hdGVkLlxuICAgKiBAYXBpXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5nZXRBbmltYXRpbmcgPSBmdW5jdGlvbiBnZXRBbmltYXRpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLmhpbnRzX1tWaWV3SGludC5BTklNQVRJTkddID4gMDtcbiAgfTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIHRoZSB1c2VyIGlzIGludGVyYWN0aW5nIHdpdGggdGhlIHZpZXcsIHN1Y2ggYXMgcGFubmluZyBvciB6b29taW5nLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgdmlldyBpcyBiZWluZyBpbnRlcmFjdGVkIHdpdGguXG4gICAqIEBhcGlcbiAgICovXG4gIFZpZXcucHJvdG90eXBlLmdldEludGVyYWN0aW5nID0gZnVuY3Rpb24gZ2V0SW50ZXJhY3RpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLmhpbnRzX1tWaWV3SGludC5JTlRFUkFDVElOR10gPiAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYW5jZWwgYW55IG9uZ29pbmcgYW5pbWF0aW9ucy5cbiAgICogQGFwaVxuICAgKi9cbiAgVmlldy5wcm90b3R5cGUuY2FuY2VsQW5pbWF0aW9ucyA9IGZ1bmN0aW9uIGNhbmNlbEFuaW1hdGlvbnMgKCkge1xuICAgIHRoaXMuc2V0SGludChWaWV3SGludC5BTklNQVRJTkcsIC10aGlzLmhpbnRzX1tWaWV3SGludC5BTklNQVRJTkddKTtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLmFuaW1hdGlvbnNfLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIHZhciBzZXJpZXMgPSB0aGlzLmFuaW1hdGlvbnNfW2ldO1xuICAgICAgaWYgKHNlcmllc1swXS5jYWxsYmFjaykge1xuICAgICAgICBhbmltYXRpb25DYWxsYmFjayhzZXJpZXNbMF0uY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5hbmltYXRpb25zXy5sZW5ndGggPSAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgYWxsIGFuaW1hdGlvbnMuXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS51cGRhdGVBbmltYXRpb25zXyA9IGZ1bmN0aW9uIHVwZGF0ZUFuaW1hdGlvbnNfICgpIHtcbiAgICBpZiAodGhpcy51cGRhdGVBbmltYXRpb25LZXlfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMudXBkYXRlQW5pbWF0aW9uS2V5Xyk7XG4gICAgICB0aGlzLnVwZGF0ZUFuaW1hdGlvbktleV8gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICghdGhpcy5nZXRBbmltYXRpbmcoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICB2YXIgbW9yZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmFuaW1hdGlvbnNfLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB2YXIgc2VyaWVzID0gdGhpcy5hbmltYXRpb25zX1tpXTtcbiAgICAgIHZhciBzZXJpZXNDb21wbGV0ZSA9IHRydWU7XG4gICAgICBmb3IgKHZhciBqID0gMCwgamogPSBzZXJpZXMubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgICB2YXIgYW5pbWF0aW9uID0gc2VyaWVzW2pdO1xuICAgICAgICBpZiAoYW5pbWF0aW9uLmNvbXBsZXRlKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVsYXBzZWQgPSBub3cgLSBhbmltYXRpb24uc3RhcnQ7XG4gICAgICAgIHZhciBmcmFjdGlvbiA9IGFuaW1hdGlvbi5kdXJhdGlvbiA+IDAgPyBlbGFwc2VkIC8gYW5pbWF0aW9uLmR1cmF0aW9uIDogMTtcbiAgICAgICAgaWYgKGZyYWN0aW9uID49IDEpIHtcbiAgICAgICAgICBhbmltYXRpb24uY29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgIGZyYWN0aW9uID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXJpZXNDb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9ncmVzcyA9IGFuaW1hdGlvbi5lYXNpbmcoZnJhY3Rpb24pO1xuICAgICAgICBpZiAoYW5pbWF0aW9uLnNvdXJjZUNlbnRlcikge1xuICAgICAgICAgIHZhciB4MCA9IGFuaW1hdGlvbi5zb3VyY2VDZW50ZXJbMF07XG4gICAgICAgICAgdmFyIHkwID0gYW5pbWF0aW9uLnNvdXJjZUNlbnRlclsxXTtcbiAgICAgICAgICB2YXIgeDEgPSBhbmltYXRpb24udGFyZ2V0Q2VudGVyWzBdO1xuICAgICAgICAgIHZhciB5MSA9IGFuaW1hdGlvbi50YXJnZXRDZW50ZXJbMV07XG4gICAgICAgICAgdmFyIHggPSB4MCArIHByb2dyZXNzICogKHgxIC0geDApO1xuICAgICAgICAgIHZhciB5ID0geTAgKyBwcm9ncmVzcyAqICh5MSAtIHkwKTtcbiAgICAgICAgICB0aGlzLnNldChWaWV3UHJvcGVydHkuQ0VOVEVSLCBbeCwgeV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbmltYXRpb24uc291cmNlUmVzb2x1dGlvbiAmJiBhbmltYXRpb24udGFyZ2V0UmVzb2x1dGlvbikge1xuICAgICAgICAgIHZhciByZXNvbHV0aW9uID0gcHJvZ3Jlc3MgPT09IDEgP1xuICAgICAgICAgICAgYW5pbWF0aW9uLnRhcmdldFJlc29sdXRpb24gOlxuICAgICAgICAgICAgYW5pbWF0aW9uLnNvdXJjZVJlc29sdXRpb24gKyBwcm9ncmVzcyAqIChhbmltYXRpb24udGFyZ2V0UmVzb2x1dGlvbiAtIGFuaW1hdGlvbi5zb3VyY2VSZXNvbHV0aW9uKTtcbiAgICAgICAgICBpZiAoYW5pbWF0aW9uLmFuY2hvcikge1xuICAgICAgICAgICAgdGhpcy5zZXQoVmlld1Byb3BlcnR5LkNFTlRFUixcbiAgICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVDZW50ZXJab29tKHJlc29sdXRpb24sIGFuaW1hdGlvbi5hbmNob3IpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zZXQoVmlld1Byb3BlcnR5LlJFU09MVVRJT04sIHJlc29sdXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbmltYXRpb24uc291cmNlUm90YXRpb24gIT09IHVuZGVmaW5lZCAmJiBhbmltYXRpb24udGFyZ2V0Um90YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciByb3RhdGlvbiA9IHByb2dyZXNzID09PSAxID9cbiAgICAgICAgICAgIG1vZHVsbyhhbmltYXRpb24udGFyZ2V0Um90YXRpb24gKyBNYXRoLlBJLCAyICogTWF0aC5QSSkgLSBNYXRoLlBJIDpcbiAgICAgICAgICAgIGFuaW1hdGlvbi5zb3VyY2VSb3RhdGlvbiArIHByb2dyZXNzICogKGFuaW1hdGlvbi50YXJnZXRSb3RhdGlvbiAtIGFuaW1hdGlvbi5zb3VyY2VSb3RhdGlvbik7XG4gICAgICAgICAgaWYgKGFuaW1hdGlvbi5hbmNob3IpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KFZpZXdQcm9wZXJ0eS5DRU5URVIsXG4gICAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlQ2VudGVyUm90YXRlKHJvdGF0aW9uLCBhbmltYXRpb24uYW5jaG9yKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc2V0KFZpZXdQcm9wZXJ0eS5ST1RBVElPTiwgcm90YXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIG1vcmUgPSB0cnVlO1xuICAgICAgICBpZiAoIWFuaW1hdGlvbi5jb21wbGV0ZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2VyaWVzQ29tcGxldGUpIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb25zX1tpXSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2V0SGludChWaWV3SGludC5BTklNQVRJTkcsIC0xKTtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gc2VyaWVzWzBdLmNhbGxiYWNrO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBhbmltYXRpb25DYWxsYmFjayhjYWxsYmFjaywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcHJ1bmUgY29tcGxldGVkIHNlcmllc1xuICAgIHRoaXMuYW5pbWF0aW9uc18gPSB0aGlzLmFuaW1hdGlvbnNfLmZpbHRlcihCb29sZWFuKTtcbiAgICBpZiAobW9yZSAmJiB0aGlzLnVwZGF0ZUFuaW1hdGlvbktleV8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy51cGRhdGVBbmltYXRpb25LZXlfID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMudXBkYXRlQW5pbWF0aW9uc18pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIFRhcmdldCByb3RhdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gYW5jaG9yIFJvdGF0aW9uIGFuY2hvci5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8dW5kZWZpbmVkfSBDZW50ZXIgZm9yIHJvdGF0aW9uIGFuZCBhbmNob3IuXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5jYWxjdWxhdGVDZW50ZXJSb3RhdGUgPSBmdW5jdGlvbiBjYWxjdWxhdGVDZW50ZXJSb3RhdGUgKHJvdGF0aW9uLCBhbmNob3IpIHtcbiAgICB2YXIgY2VudGVyO1xuICAgIHZhciBjdXJyZW50Q2VudGVyID0gdGhpcy5nZXRDZW50ZXIoKTtcbiAgICBpZiAoY3VycmVudENlbnRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjZW50ZXIgPSBbY3VycmVudENlbnRlclswXSAtIGFuY2hvclswXSwgY3VycmVudENlbnRlclsxXSAtIGFuY2hvclsxXV07XG4gICAgICByb3RhdGVDb29yZGluYXRlKGNlbnRlciwgcm90YXRpb24gLSB0aGlzLmdldFJvdGF0aW9uKCkpO1xuICAgICAgYWRkQ29vcmRpbmF0ZShjZW50ZXIsIGFuY2hvcik7XG4gICAgfVxuICAgIHJldHVybiBjZW50ZXI7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFRhcmdldCByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBhbmNob3IgWm9vbSBhbmNob3IuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfHVuZGVmaW5lZH0gQ2VudGVyIGZvciByZXNvbHV0aW9uIGFuZCBhbmNob3IuXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5jYWxjdWxhdGVDZW50ZXJab29tID0gZnVuY3Rpb24gY2FsY3VsYXRlQ2VudGVyWm9vbSAocmVzb2x1dGlvbiwgYW5jaG9yKSB7XG4gICAgdmFyIGNlbnRlcjtcbiAgICB2YXIgY3VycmVudENlbnRlciA9IHRoaXMuZ2V0Q2VudGVyKCk7XG4gICAgdmFyIGN1cnJlbnRSZXNvbHV0aW9uID0gdGhpcy5nZXRSZXNvbHV0aW9uKCk7XG4gICAgaWYgKGN1cnJlbnRDZW50ZXIgIT09IHVuZGVmaW5lZCAmJiBjdXJyZW50UmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgeCA9IGFuY2hvclswXSAtIHJlc29sdXRpb24gKiAoYW5jaG9yWzBdIC0gY3VycmVudENlbnRlclswXSkgLyBjdXJyZW50UmVzb2x1dGlvbjtcbiAgICAgIHZhciB5ID0gYW5jaG9yWzFdIC0gcmVzb2x1dGlvbiAqIChhbmNob3JbMV0gLSBjdXJyZW50Q2VudGVyWzFdKSAvIGN1cnJlbnRSZXNvbHV0aW9uO1xuICAgICAgY2VudGVyID0gW3gsIHldO1xuICAgIH1cbiAgICByZXR1cm4gY2VudGVyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gVmlld3BvcnQgc2l6ZSBvciBgWzEwMCwgMTAwXWAgd2hlbiBubyB2aWV3cG9ydCBpcyBmb3VuZC5cbiAgICovXG4gIFZpZXcucHJvdG90eXBlLmdldFNpemVGcm9tVmlld3BvcnRfID0gZnVuY3Rpb24gZ2V0U2l6ZUZyb21WaWV3cG9ydF8gKCkge1xuICAgIHZhciBzaXplID0gWzEwMCwgMTAwXTtcbiAgICB2YXIgc2VsZWN0b3IgPSAnLm9sLXZpZXdwb3J0W2RhdGEtdmlldz1cIicgKyBnZXRVaWQodGhpcykgKyAnXCJdJztcbiAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgbWV0cmljcyA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gICAgICBzaXplWzBdID0gcGFyc2VJbnQobWV0cmljcy53aWR0aCwgMTApO1xuICAgICAgc2l6ZVsxXSA9IHBhcnNlSW50KG1ldHJpY3MuaGVpZ2h0LCAxMCk7XG4gICAgfVxuICAgIHJldHVybiBzaXplO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvbnN0cmFpbmVkIGNlbnRlciBvZiB0aGlzIHZpZXcuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8dW5kZWZpbmVkfSBjZW50ZXIgQ2VudGVyLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZXx1bmRlZmluZWR9IENvbnN0cmFpbmVkIGNlbnRlci5cbiAgICogQGFwaVxuICAgKi9cbiAgVmlldy5wcm90b3R5cGUuY29uc3RyYWluQ2VudGVyID0gZnVuY3Rpb24gY29uc3RyYWluQ2VudGVyIChjZW50ZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJhaW50c18uY2VudGVyKGNlbnRlcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY29uc3RyYWluZWQgcmVzb2x1dGlvbiBvZiB0aGlzIHZpZXcuXG4gICAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcj19IG9wdF9kZWx0YSBEZWx0YS4gRGVmYXVsdCBpcyBgMGAuXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2RpcmVjdGlvbiBEaXJlY3Rpb24uIERlZmF1bHQgaXMgYDBgLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBDb25zdHJhaW5lZCByZXNvbHV0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5jb25zdHJhaW5SZXNvbHV0aW9uID0gZnVuY3Rpb24gY29uc3RyYWluUmVzb2x1dGlvbiAocmVzb2x1dGlvbiwgb3B0X2RlbHRhLCBvcHRfZGlyZWN0aW9uKSB7XG4gICAgdmFyIGRlbHRhID0gb3B0X2RlbHRhIHx8IDA7XG4gICAgdmFyIGRpcmVjdGlvbiA9IG9wdF9kaXJlY3Rpb24gfHwgMDtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJhaW50c18ucmVzb2x1dGlvbihyZXNvbHV0aW9uLCBkZWx0YSwgZGlyZWN0aW9uKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjb25zdHJhaW5lZCByb3RhdGlvbiBvZiB0aGlzIHZpZXcuXG4gICAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gcm90YXRpb24gUm90YXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2RlbHRhIERlbHRhLiBEZWZhdWx0IGlzIGAwYC5cbiAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gQ29uc3RyYWluZWQgcm90YXRpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIFZpZXcucHJvdG90eXBlLmNvbnN0cmFpblJvdGF0aW9uID0gZnVuY3Rpb24gY29uc3RyYWluUm90YXRpb24gKHJvdGF0aW9uLCBvcHRfZGVsdGEpIHtcbiAgICB2YXIgZGVsdGEgPSBvcHRfZGVsdGEgfHwgMDtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJhaW50c18ucm90YXRpb24ocm90YXRpb24sIGRlbHRhKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSB2aWV3IGNlbnRlci5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8dW5kZWZpbmVkfSBUaGUgY2VudGVyIG9mIHRoZSB2aWV3LlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5nZXRDZW50ZXIgPSBmdW5jdGlvbiBnZXRDZW50ZXIgKCkge1xuICAgIHJldHVybiAoXG4gICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfHVuZGVmaW5lZH0gKi8gKHRoaXMuZ2V0KFZpZXdQcm9wZXJ0eS5DRU5URVIpKVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0NvbnN0cmFpbnRzfSBDb25zdHJhaW50cy5cbiAgICovXG4gIFZpZXcucHJvdG90eXBlLmdldENvbnN0cmFpbnRzID0gZnVuY3Rpb24gZ2V0Q29uc3RyYWludHMgKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cmFpbnRzXztcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+PX0gb3B0X2hpbnRzIERlc3RpbmF0aW9uIGFycmF5LlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBIaW50LlxuICAgKi9cbiAgVmlldy5wcm90b3R5cGUuZ2V0SGludHMgPSBmdW5jdGlvbiBnZXRIaW50cyAob3B0X2hpbnRzKSB7XG4gICAgaWYgKG9wdF9oaW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRfaGludHNbMF0gPSB0aGlzLmhpbnRzX1swXTtcbiAgICAgIG9wdF9oaW50c1sxXSA9IHRoaXMuaGludHNfWzFdO1xuICAgICAgcmV0dXJuIG9wdF9oaW50cztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuaGludHNfLnNsaWNlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGV4dGVudCBmb3IgdGhlIGN1cnJlbnQgdmlldyBzdGF0ZSBhbmQgdGhlIHBhc3NlZCBzaXplLlxuICAgKiBUaGUgc2l6ZSBpcyB0aGUgcGl4ZWwgZGltZW5zaW9ucyBvZiB0aGUgYm94IGludG8gd2hpY2ggdGhlIGNhbGN1bGF0ZWQgZXh0ZW50XG4gICAqIHNob3VsZCBmaXQuIEluIG1vc3QgY2FzZXMgeW91IHdhbnQgdG8gZ2V0IHRoZSBleHRlbnQgb2YgdGhlIGVudGlyZSBtYXAsXG4gICAqIHRoYXQgaXMgYG1hcC5nZXRTaXplKClgLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplPX0gb3B0X3NpemUgQm94IHBpeGVsIHNpemUuIElmIG5vdCBwcm92aWRlZCwgdGhlIHNpemUgb2YgdGhlXG4gICAqIGZpcnN0IG1hcCB0aGF0IHVzZXMgdGhpcyB2aWV3IHdpbGwgYmUgdXNlZC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBFeHRlbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIFZpZXcucHJvdG90eXBlLmNhbGN1bGF0ZUV4dGVudCA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUV4dGVudCAob3B0X3NpemUpIHtcbiAgICB2YXIgc2l6ZSA9IG9wdF9zaXplIHx8IHRoaXMuZ2V0U2l6ZUZyb21WaWV3cG9ydF8oKTtcbiAgICB2YXIgY2VudGVyID0gLyoqIEB0eXBlIHshaW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9ICovICh0aGlzLmdldENlbnRlcigpKTtcbiAgICBhc3NlcnQoY2VudGVyLCAxKTsgLy8gVGhlIHZpZXcgY2VudGVyIGlzIG5vdCBkZWZpbmVkXG4gICAgdmFyIHJlc29sdXRpb24gPSAvKiogQHR5cGUgeyFudW1iZXJ9ICovICh0aGlzLmdldFJlc29sdXRpb24oKSk7XG4gICAgYXNzZXJ0KHJlc29sdXRpb24gIT09IHVuZGVmaW5lZCwgMik7IC8vIFRoZSB2aWV3IHJlc29sdXRpb24gaXMgbm90IGRlZmluZWRcbiAgICB2YXIgcm90YXRpb24gPSAvKiogQHR5cGUgeyFudW1iZXJ9ICovICh0aGlzLmdldFJvdGF0aW9uKCkpO1xuICAgIGFzc2VydChyb3RhdGlvbiAhPT0gdW5kZWZpbmVkLCAzKTsgLy8gVGhlIHZpZXcgcm90YXRpb24gaXMgbm90IGRlZmluZWRcblxuICAgIHJldHVybiBnZXRGb3JWaWV3QW5kU2l6ZShjZW50ZXIsIHJlc29sdXRpb24sIHJvdGF0aW9uLCBzaXplKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBtYXhpbXVtIHJlc29sdXRpb24gb2YgdGhlIHZpZXcuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1heGltdW0gcmVzb2x1dGlvbiBvZiB0aGUgdmlldy5cbiAgICogQGFwaVxuICAgKi9cbiAgVmlldy5wcm90b3R5cGUuZ2V0TWF4UmVzb2x1dGlvbiA9IGZ1bmN0aW9uIGdldE1heFJlc29sdXRpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1heFJlc29sdXRpb25fO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1pbmltdW0gcmVzb2x1dGlvbiBvZiB0aGUgdmlldy5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWluaW11bSByZXNvbHV0aW9uIG9mIHRoZSB2aWV3LlxuICAgKiBAYXBpXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5nZXRNaW5SZXNvbHV0aW9uID0gZnVuY3Rpb24gZ2V0TWluUmVzb2x1dGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWluUmVzb2x1dGlvbl87XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWF4aW11bSB6b29tIGxldmVsIGZvciB0aGUgdmlldy5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWF4aW11bSB6b29tIGxldmVsLlxuICAgKiBAYXBpXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5nZXRNYXhab29tID0gZnVuY3Rpb24gZ2V0TWF4Wm9vbSAoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5nZXRab29tRm9yUmVzb2x1dGlvbih0aGlzLm1pblJlc29sdXRpb25fKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBhIG5ldyBtYXhpbXVtIHpvb20gbGV2ZWwgZm9yIHRoZSB2aWV3LlxuICAgKiBAcGFyYW0ge251bWJlcn0gem9vbSBUaGUgbWF4aW11bSB6b29tIGxldmVsLlxuICAgKiBAYXBpXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5zZXRNYXhab29tID0gZnVuY3Rpb24gc2V0TWF4Wm9vbSAoem9vbSkge1xuICAgIHRoaXMuYXBwbHlPcHRpb25zXyh0aGlzLmdldFVwZGF0ZWRPcHRpb25zXyh7bWF4Wm9vbTogem9vbX0pKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgZm9yIHRoZSB2aWV3LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBtaW5pbXVtIHpvb20gbGV2ZWwuXG4gICAqIEBhcGlcbiAgICovXG4gIFZpZXcucHJvdG90eXBlLmdldE1pblpvb20gPSBmdW5jdGlvbiBnZXRNaW5ab29tICgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ9ICovICh0aGlzLmdldFpvb21Gb3JSZXNvbHV0aW9uKHRoaXMubWF4UmVzb2x1dGlvbl8pKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGEgbmV3IG1pbmltdW0gem9vbSBsZXZlbCBmb3IgdGhlIHZpZXcuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6b29tIFRoZSBtaW5pbXVtIHpvb20gbGV2ZWwuXG4gICAqIEBhcGlcbiAgICovXG4gIFZpZXcucHJvdG90eXBlLnNldE1pblpvb20gPSBmdW5jdGlvbiBzZXRNaW5ab29tICh6b29tKSB7XG4gICAgdGhpcy5hcHBseU9wdGlvbnNfKHRoaXMuZ2V0VXBkYXRlZE9wdGlvbnNfKHttaW5ab29tOiB6b29tfSkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZpZXcgcHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gVGhlIHByb2plY3Rpb24gb2YgdGhlIHZpZXcuXG4gICAqIEBhcGlcbiAgICovXG4gIFZpZXcucHJvdG90eXBlLmdldFByb2plY3Rpb24gPSBmdW5jdGlvbiBnZXRQcm9qZWN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uXztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSB2aWV3IHJlc29sdXRpb24uXG4gICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFRoZSByZXNvbHV0aW9uIG9mIHRoZSB2aWV3LlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5nZXRSZXNvbHV0aW9uID0gZnVuY3Rpb24gZ2V0UmVzb2x1dGlvbiAoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi8gKHRoaXMuZ2V0KFZpZXdQcm9wZXJ0eS5SRVNPTFVUSU9OKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcmVzb2x1dGlvbnMgZm9yIHRoZSB2aWV3LiBUaGlzIHJldHVybnMgdGhlIGFycmF5IG9mIHJlc29sdXRpb25zXG4gICAqIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3Igb2YgdGhlIFZpZXcsIG9yIHVuZGVmaW5lZCBpZiBub25lIHdlcmUgZ2l2ZW4uXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj58dW5kZWZpbmVkfSBUaGUgcmVzb2x1dGlvbnMgb2YgdGhlIHZpZXcuXG4gICAqIEBhcGlcbiAgICovXG4gIFZpZXcucHJvdG90eXBlLmdldFJlc29sdXRpb25zID0gZnVuY3Rpb24gZ2V0UmVzb2x1dGlvbnMgKCkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdXRpb25zXztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSByZXNvbHV0aW9uIGZvciBhIHByb3ZpZGVkIGV4dGVudCAoaW4gbWFwIHVuaXRzKSBhbmQgc2l6ZSAoaW4gcGl4ZWxzKS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemU9fSBvcHRfc2l6ZSBCb3ggcGl4ZWwgc2l6ZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgcmVzb2x1dGlvbiBhdCB3aGljaCB0aGUgcHJvdmlkZWQgZXh0ZW50IHdpbGwgcmVuZGVyIGF0XG4gICAqICAgICB0aGUgZ2l2ZW4gc2l6ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgVmlldy5wcm90b3R5cGUuZ2V0UmVzb2x1dGlvbkZvckV4dGVudCA9IGZ1bmN0aW9uIGdldFJlc29sdXRpb25Gb3JFeHRlbnQgKGV4dGVudCwgb3B0X3NpemUpIHtcbiAgICB2YXIgc2l6ZSA9IG9wdF9zaXplIHx8IHRoaXMuZ2V0U2l6ZUZyb21WaWV3cG9ydF8oKTtcbiAgICB2YXIgeFJlc29sdXRpb24gPSBnZXRXaWR0aChleHRlbnQpIC8gc2l6ZVswXTtcbiAgICB2YXIgeVJlc29sdXRpb24gPSBnZXRIZWlnaHQoZXh0ZW50KSAvIHNpemVbMV07XG4gICAgcmV0dXJuIE1hdGgubWF4KHhSZXNvbHV0aW9uLCB5UmVzb2x1dGlvbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMSBmb3IgYVxuICAgKiByZXNvbHV0aW9uLiBFeHBvbmVudGlhbCBzY2FsaW5nIGlzIGFzc3VtZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X3Bvd2VyIFBvd2VyLlxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbihudW1iZXIpOiBudW1iZXJ9IFJlc29sdXRpb24gZm9yIHZhbHVlIGZ1bmN0aW9uLlxuICAgKi9cbiAgVmlldy5wcm90b3R5cGUuZ2V0UmVzb2x1dGlvbkZvclZhbHVlRnVuY3Rpb24gPSBmdW5jdGlvbiBnZXRSZXNvbHV0aW9uRm9yVmFsdWVGdW5jdGlvbiAob3B0X3Bvd2VyKSB7XG4gICAgdmFyIHBvd2VyID0gb3B0X3Bvd2VyIHx8IDI7XG4gICAgdmFyIG1heFJlc29sdXRpb24gPSB0aGlzLm1heFJlc29sdXRpb25fO1xuICAgIHZhciBtaW5SZXNvbHV0aW9uID0gdGhpcy5taW5SZXNvbHV0aW9uXztcbiAgICB2YXIgbWF4ID0gTWF0aC5sb2cobWF4UmVzb2x1dGlvbiAvIG1pblJlc29sdXRpb24pIC8gTWF0aC5sb2cocG93ZXIpO1xuICAgIHJldHVybiAoXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZS5cbiAgICAgICAqIEByZXR1cm4ge251bWJlcn0gUmVzb2x1dGlvbi5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc29sdXRpb24gPSBtYXhSZXNvbHV0aW9uIC8gTWF0aC5wb3cocG93ZXIsIHZhbHVlICogbWF4KTtcbiAgICAgICAgcmV0dXJuIHJlc29sdXRpb247XG4gICAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSB2aWV3IHJvdGF0aW9uLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSByb3RhdGlvbiBvZiB0aGUgdmlldyBpbiByYWRpYW5zLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5nZXRSb3RhdGlvbiA9IGZ1bmN0aW9uIGdldFJvdGF0aW9uICgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ9ICovICh0aGlzLmdldChWaWV3UHJvcGVydHkuUk9UQVRJT04pKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgcmVzb2x1dGlvbiBmb3IgYSB2YWx1ZSBiZXR3ZWVuXG4gICAqIDAgYW5kIDEuIEV4cG9uZW50aWFsIHNjYWxpbmcgaXMgYXNzdW1lZC5cbiAgICogQHBhcmFtIHtudW1iZXI9fSBvcHRfcG93ZXIgUG93ZXIuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9uKG51bWJlcik6IG51bWJlcn0gVmFsdWUgZm9yIHJlc29sdXRpb24gZnVuY3Rpb24uXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5nZXRWYWx1ZUZvclJlc29sdXRpb25GdW5jdGlvbiA9IGZ1bmN0aW9uIGdldFZhbHVlRm9yUmVzb2x1dGlvbkZ1bmN0aW9uIChvcHRfcG93ZXIpIHtcbiAgICB2YXIgcG93ZXIgPSBvcHRfcG93ZXIgfHwgMjtcbiAgICB2YXIgbWF4UmVzb2x1dGlvbiA9IHRoaXMubWF4UmVzb2x1dGlvbl87XG4gICAgdmFyIG1pblJlc29sdXRpb24gPSB0aGlzLm1pblJlc29sdXRpb25fO1xuICAgIHZhciBtYXggPSBNYXRoLmxvZyhtYXhSZXNvbHV0aW9uIC8gbWluUmVzb2x1dGlvbikgLyBNYXRoLmxvZyhwb3dlcik7XG4gICAgcmV0dXJuIChcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAgICAgICAqIEByZXR1cm4ge251bWJlcn0gVmFsdWUuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uKHJlc29sdXRpb24pIHtcbiAgICAgICAgdmFyIHZhbHVlID0gKE1hdGgubG9nKG1heFJlc29sdXRpb24gLyByZXNvbHV0aW9uKSAvIE1hdGgubG9nKHBvd2VyKSkgLyBtYXg7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpbyBmb3IgY2VudGVyIHJvdW5kaW5nLlxuICAgKiBAcmV0dXJuIHtTdGF0ZX0gVmlldyBzdGF0ZS5cbiAgICovXG4gIFZpZXcucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24gZ2V0U3RhdGUgKHBpeGVsUmF0aW8pIHtcbiAgICB2YXIgY2VudGVyID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gKi8gKHRoaXMuZ2V0Q2VudGVyKCkpO1xuICAgIHZhciBwcm9qZWN0aW9uID0gdGhpcy5nZXRQcm9qZWN0aW9uKCk7XG4gICAgdmFyIHJlc29sdXRpb24gPSAvKiogQHR5cGUge251bWJlcn0gKi8gKHRoaXMuZ2V0UmVzb2x1dGlvbigpKTtcbiAgICB2YXIgcGl4ZWxSZXNvbHV0aW9uID0gcmVzb2x1dGlvbiAvIHBpeGVsUmF0aW87XG4gICAgdmFyIHJvdGF0aW9uID0gdGhpcy5nZXRSb3RhdGlvbigpO1xuICAgIHJldHVybiAoXG4gICAgICAvKiogQHR5cGUge1N0YXRlfSAqLyAoe1xuICAgICAgICBjZW50ZXI6IFtcbiAgICAgICAgICBNYXRoLnJvdW5kKGNlbnRlclswXSAvIHBpeGVsUmVzb2x1dGlvbikgKiBwaXhlbFJlc29sdXRpb24sXG4gICAgICAgICAgTWF0aC5yb3VuZChjZW50ZXJbMV0gLyBwaXhlbFJlc29sdXRpb24pICogcGl4ZWxSZXNvbHV0aW9uXG4gICAgICAgIF0sXG4gICAgICAgIHByb2plY3Rpb246IHByb2plY3Rpb24gIT09IHVuZGVmaW5lZCA/IHByb2plY3Rpb24gOiBudWxsLFxuICAgICAgICByZXNvbHV0aW9uOiByZXNvbHV0aW9uLFxuICAgICAgICByb3RhdGlvbjogcm90YXRpb24sXG4gICAgICAgIHpvb206IHRoaXMuZ2V0Wm9vbSgpXG4gICAgICB9KVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCB6b29tIGxldmVsLiAgSWYgeW91IGNvbmZpZ3VyZWQgeW91ciB2aWV3IHdpdGggYSByZXNvbHV0aW9uc1xuICAgKiBhcnJheSAodGhpcyBpcyByYXJlKSwgdGhpcyBtZXRob2QgbWF5IHJldHVybiBub24taW50ZWdlciB6b29tIGxldmVscyAoc29cbiAgICogdGhlIHpvb20gbGV2ZWwgaXMgbm90IHNhZmUgdG8gdXNlIGFzIGFuIGluZGV4IGludG8gYSByZXNvbHV0aW9ucyBhcnJheSkuXG4gICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFpvb20uXG4gICAqIEBhcGlcbiAgICovXG4gIFZpZXcucHJvdG90eXBlLmdldFpvb20gPSBmdW5jdGlvbiBnZXRab29tICgpIHtcbiAgICB2YXIgem9vbTtcbiAgICB2YXIgcmVzb2x1dGlvbiA9IHRoaXMuZ2V0UmVzb2x1dGlvbigpO1xuICAgIGlmIChyZXNvbHV0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHpvb20gPSB0aGlzLmdldFpvb21Gb3JSZXNvbHV0aW9uKHJlc29sdXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gem9vbTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSB6b29tIGxldmVsIGZvciBhIHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFRoZSByZXNvbHV0aW9uLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBUaGUgem9vbSBsZXZlbCBmb3IgdGhlIHByb3ZpZGVkIHJlc29sdXRpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIFZpZXcucHJvdG90eXBlLmdldFpvb21Gb3JSZXNvbHV0aW9uID0gZnVuY3Rpb24gZ2V0Wm9vbUZvclJlc29sdXRpb24gKHJlc29sdXRpb24pIHtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5taW5ab29tXyB8fCAwO1xuICAgIHZhciBtYXgsIHpvb21GYWN0b3I7XG4gICAgaWYgKHRoaXMucmVzb2x1dGlvbnNfKSB7XG4gICAgICB2YXIgbmVhcmVzdCA9IGxpbmVhckZpbmROZWFyZXN0KHRoaXMucmVzb2x1dGlvbnNfLCByZXNvbHV0aW9uLCAxKTtcbiAgICAgIG9mZnNldCA9IG5lYXJlc3Q7XG4gICAgICBtYXggPSB0aGlzLnJlc29sdXRpb25zX1tuZWFyZXN0XTtcbiAgICAgIGlmIChuZWFyZXN0ID09IHRoaXMucmVzb2x1dGlvbnNfLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgem9vbUZhY3RvciA9IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB6b29tRmFjdG9yID0gbWF4IC8gdGhpcy5yZXNvbHV0aW9uc19bbmVhcmVzdCArIDFdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtYXggPSB0aGlzLm1heFJlc29sdXRpb25fO1xuICAgICAgem9vbUZhY3RvciA9IHRoaXMuem9vbUZhY3Rvcl87XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQgKyBNYXRoLmxvZyhtYXggLyByZXNvbHV0aW9uKSAvIE1hdGgubG9nKHpvb21GYWN0b3IpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHJlc29sdXRpb24gZm9yIGEgem9vbSBsZXZlbC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHpvb20gWm9vbSBsZXZlbC5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgdmlldyByZXNvbHV0aW9uIGZvciB0aGUgcHJvdmlkZWQgem9vbSBsZXZlbC5cbiAgICogQGFwaVxuICAgKi9cbiAgVmlldy5wcm90b3R5cGUuZ2V0UmVzb2x1dGlvbkZvclpvb20gPSBmdW5jdGlvbiBnZXRSZXNvbHV0aW9uRm9yWm9vbSAoem9vbSkge1xuICAgIHJldHVybiAvKiogQHR5cGUge251bWJlcn0gKi8gKHRoaXMuY29uc3RyYWluUmVzb2x1dGlvbihcbiAgICAgIHRoaXMubWF4UmVzb2x1dGlvbl8sIHpvb20gLSB0aGlzLm1pblpvb21fLCAwKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpdCB0aGUgZ2l2ZW4gZ2VvbWV0cnkgb3IgZXh0ZW50IGJhc2VkIG9uIHRoZSBnaXZlbiBtYXAgc2l6ZSBhbmQgYm9yZGVyLlxuICAgKiBUaGUgc2l6ZSBpcyBwaXhlbCBkaW1lbnNpb25zIG9mIHRoZSBib3ggdG8gZml0IHRoZSBleHRlbnQgaW50by5cbiAgICogSW4gbW9zdCBjYXNlcyB5b3Ugd2lsbCB3YW50IHRvIHVzZSB0aGUgbWFwIHNpemUsIHRoYXQgaXMgYG1hcC5nZXRTaXplKClgLlxuICAgKiBUYWtlcyBjYXJlIG9mIHRoZSBtYXAgYW5nbGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBnZW9tZXRyeU9yRXh0ZW50IFRoZSBnZW9tZXRyeSBvclxuICAgKiAgICAgZXh0ZW50IHRvIGZpdCB0aGUgdmlldyB0by5cbiAgICogQHBhcmFtIHtGaXRPcHRpb25zPX0gb3B0X29wdGlvbnMgT3B0aW9ucy5cbiAgICogQGFwaVxuICAgKi9cbiAgVmlldy5wcm90b3R5cGUuZml0ID0gZnVuY3Rpb24gZml0IChnZW9tZXRyeU9yRXh0ZW50LCBvcHRfb3B0aW9ucykge1xuICAgIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgfHwge307XG4gICAgdmFyIHNpemUgPSBvcHRpb25zLnNpemU7XG4gICAgaWYgKCFzaXplKSB7XG4gICAgICBzaXplID0gdGhpcy5nZXRTaXplRnJvbVZpZXdwb3J0XygpO1xuICAgIH1cbiAgICAvKiogQHR5cGUge2ltcG9ydChcIi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSAqL1xuICAgIHZhciBnZW9tZXRyeTtcbiAgICBhc3NlcnQoQXJyYXkuaXNBcnJheShnZW9tZXRyeU9yRXh0ZW50KSB8fCB0eXBlb2YgLyoqIEB0eXBlIHs/fSAqLyAoZ2VvbWV0cnlPckV4dGVudCkuZ2V0U2ltcGxpZmllZEdlb21ldHJ5ID09PSAnZnVuY3Rpb24nLFxuICAgICAgMjQpOyAvLyBJbnZhbGlkIGV4dGVudCBvciBnZW9tZXRyeSBwcm92aWRlZCBhcyBgZ2VvbWV0cnlgXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZ2VvbWV0cnlPckV4dGVudCkpIHtcbiAgICAgIGFzc2VydCghaXNFbXB0eShnZW9tZXRyeU9yRXh0ZW50KSxcbiAgICAgICAgMjUpOyAvLyBDYW5ub3QgZml0IGVtcHR5IGV4dGVudCBwcm92aWRlZCBhcyBgZ2VvbWV0cnlgXG4gICAgICBnZW9tZXRyeSA9IHBvbHlnb25Gcm9tRXh0ZW50KGdlb21ldHJ5T3JFeHRlbnQpO1xuICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnlPckV4dGVudC5nZXRUeXBlKCkgPT09IEdlb21ldHJ5VHlwZS5DSVJDTEUpIHtcbiAgICAgIGdlb21ldHJ5T3JFeHRlbnQgPSBnZW9tZXRyeU9yRXh0ZW50LmdldEV4dGVudCgpO1xuICAgICAgZ2VvbWV0cnkgPSBwb2x5Z29uRnJvbUV4dGVudChnZW9tZXRyeU9yRXh0ZW50KTtcbiAgICAgIGdlb21ldHJ5LnJvdGF0ZSh0aGlzLmdldFJvdGF0aW9uKCksIGdldENlbnRlcihnZW9tZXRyeU9yRXh0ZW50KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlb21ldHJ5ID0gZ2VvbWV0cnlPckV4dGVudDtcbiAgICB9XG5cbiAgICB2YXIgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5wYWRkaW5nIDogWzAsIDAsIDAsIDBdO1xuICAgIHZhciBjb25zdHJhaW5SZXNvbHV0aW9uID0gb3B0aW9ucy5jb25zdHJhaW5SZXNvbHV0aW9uICE9PSB1bmRlZmluZWQgP1xuICAgICAgb3B0aW9ucy5jb25zdHJhaW5SZXNvbHV0aW9uIDogdHJ1ZTtcbiAgICB2YXIgbmVhcmVzdCA9IG9wdGlvbnMubmVhcmVzdCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uZWFyZXN0IDogZmFsc2U7XG4gICAgdmFyIG1pblJlc29sdXRpb247XG4gICAgaWYgKG9wdGlvbnMubWluUmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBtaW5SZXNvbHV0aW9uID0gb3B0aW9ucy5taW5SZXNvbHV0aW9uO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5tYXhab29tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG1pblJlc29sdXRpb24gPSB0aGlzLmNvbnN0cmFpblJlc29sdXRpb24oXG4gICAgICAgIHRoaXMubWF4UmVzb2x1dGlvbl8sIG9wdGlvbnMubWF4Wm9vbSAtIHRoaXMubWluWm9vbV8sIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBtaW5SZXNvbHV0aW9uID0gMDtcbiAgICB9XG4gICAgdmFyIGNvb3JkcyA9IGdlb21ldHJ5LmdldEZsYXRDb29yZGluYXRlcygpO1xuXG4gICAgLy8gY2FsY3VsYXRlIHJvdGF0ZWQgZXh0ZW50XG4gICAgdmFyIHJvdGF0aW9uID0gdGhpcy5nZXRSb3RhdGlvbigpO1xuICAgIHZhciBjb3NBbmdsZSA9IE1hdGguY29zKC1yb3RhdGlvbik7XG4gICAgdmFyIHNpbkFuZ2xlID0gTWF0aC5zaW4oLXJvdGF0aW9uKTtcbiAgICB2YXIgbWluUm90WCA9ICtJbmZpbml0eTtcbiAgICB2YXIgbWluUm90WSA9ICtJbmZpbml0eTtcbiAgICB2YXIgbWF4Um90WCA9IC1JbmZpbml0eTtcbiAgICB2YXIgbWF4Um90WSA9IC1JbmZpbml0eTtcbiAgICB2YXIgc3RyaWRlID0gZ2VvbWV0cnkuZ2V0U3RyaWRlKCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gY29vcmRzLmxlbmd0aDsgaSA8IGlpOyBpICs9IHN0cmlkZSkge1xuICAgICAgdmFyIHJvdFggPSBjb29yZHNbaV0gKiBjb3NBbmdsZSAtIGNvb3Jkc1tpICsgMV0gKiBzaW5BbmdsZTtcbiAgICAgIHZhciByb3RZID0gY29vcmRzW2ldICogc2luQW5nbGUgKyBjb29yZHNbaSArIDFdICogY29zQW5nbGU7XG4gICAgICBtaW5Sb3RYID0gTWF0aC5taW4obWluUm90WCwgcm90WCk7XG4gICAgICBtaW5Sb3RZID0gTWF0aC5taW4obWluUm90WSwgcm90WSk7XG4gICAgICBtYXhSb3RYID0gTWF0aC5tYXgobWF4Um90WCwgcm90WCk7XG4gICAgICBtYXhSb3RZID0gTWF0aC5tYXgobWF4Um90WSwgcm90WSk7XG4gICAgfVxuXG4gICAgLy8gY2FsY3VsYXRlIHJlc29sdXRpb25cbiAgICB2YXIgcmVzb2x1dGlvbiA9IHRoaXMuZ2V0UmVzb2x1dGlvbkZvckV4dGVudChcbiAgICAgIFttaW5Sb3RYLCBtaW5Sb3RZLCBtYXhSb3RYLCBtYXhSb3RZXSxcbiAgICAgIFtzaXplWzBdIC0gcGFkZGluZ1sxXSAtIHBhZGRpbmdbM10sIHNpemVbMV0gLSBwYWRkaW5nWzBdIC0gcGFkZGluZ1syXV0pO1xuICAgIHJlc29sdXRpb24gPSBpc05hTihyZXNvbHV0aW9uKSA/IG1pblJlc29sdXRpb24gOlxuICAgICAgTWF0aC5tYXgocmVzb2x1dGlvbiwgbWluUmVzb2x1dGlvbik7XG4gICAgaWYgKGNvbnN0cmFpblJlc29sdXRpb24pIHtcbiAgICAgIHZhciBjb25zdHJhaW5lZFJlc29sdXRpb24gPSB0aGlzLmNvbnN0cmFpblJlc29sdXRpb24ocmVzb2x1dGlvbiwgMCwgMCk7XG4gICAgICBpZiAoIW5lYXJlc3QgJiYgY29uc3RyYWluZWRSZXNvbHV0aW9uIDwgcmVzb2x1dGlvbikge1xuICAgICAgICBjb25zdHJhaW5lZFJlc29sdXRpb24gPSB0aGlzLmNvbnN0cmFpblJlc29sdXRpb24oXG4gICAgICAgICAgY29uc3RyYWluZWRSZXNvbHV0aW9uLCAtMSwgMCk7XG4gICAgICB9XG4gICAgICByZXNvbHV0aW9uID0gY29uc3RyYWluZWRSZXNvbHV0aW9uO1xuICAgIH1cblxuICAgIC8vIGNhbGN1bGF0ZSBjZW50ZXJcbiAgICBzaW5BbmdsZSA9IC1zaW5BbmdsZTsgLy8gZ28gYmFjayB0byBvcmlnaW5hbCByb3RhdGlvblxuICAgIHZhciBjZW50ZXJSb3RYID0gKG1pblJvdFggKyBtYXhSb3RYKSAvIDI7XG4gICAgdmFyIGNlbnRlclJvdFkgPSAobWluUm90WSArIG1heFJvdFkpIC8gMjtcbiAgICBjZW50ZXJSb3RYICs9IChwYWRkaW5nWzFdIC0gcGFkZGluZ1szXSkgLyAyICogcmVzb2x1dGlvbjtcbiAgICBjZW50ZXJSb3RZICs9IChwYWRkaW5nWzBdIC0gcGFkZGluZ1syXSkgLyAyICogcmVzb2x1dGlvbjtcbiAgICB2YXIgY2VudGVyWCA9IGNlbnRlclJvdFggKiBjb3NBbmdsZSAtIGNlbnRlclJvdFkgKiBzaW5BbmdsZTtcbiAgICB2YXIgY2VudGVyWSA9IGNlbnRlclJvdFkgKiBjb3NBbmdsZSArIGNlbnRlclJvdFggKiBzaW5BbmdsZTtcbiAgICB2YXIgY2VudGVyID0gW2NlbnRlclgsIGNlbnRlclldO1xuICAgIHZhciBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2sgPyBvcHRpb25zLmNhbGxiYWNrIDogVk9JRDtcblxuICAgIGlmIChvcHRpb25zLmR1cmF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuYW5pbWF0ZSh7XG4gICAgICAgIHJlc29sdXRpb246IHJlc29sdXRpb24sXG4gICAgICAgIGNlbnRlcjogY2VudGVyLFxuICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcbiAgICAgICAgZWFzaW5nOiBvcHRpb25zLmVhc2luZ1xuICAgICAgfSwgY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldFJlc29sdXRpb24ocmVzb2x1dGlvbik7XG4gICAgICB0aGlzLnNldENlbnRlcihjZW50ZXIpO1xuICAgICAgYW5pbWF0aW9uQ2FsbGJhY2soY2FsbGJhY2ssIHRydWUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2VudGVyIG9uIGNvb3JkaW5hdGUgYW5kIHZpZXcgcG9zaXRpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gc2l6ZSBCb3ggcGl4ZWwgc2l6ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3BpeGVsLmpzXCIpLlBpeGVsfSBwb3NpdGlvbiBQb3NpdGlvbiBvbiB0aGUgdmlldyB0byBjZW50ZXIgb24uXG4gICAqIEBhcGlcbiAgICovXG4gIFZpZXcucHJvdG90eXBlLmNlbnRlck9uID0gZnVuY3Rpb24gY2VudGVyT24gKGNvb3JkaW5hdGUsIHNpemUsIHBvc2l0aW9uKSB7XG4gICAgLy8gY2FsY3VsYXRlIHJvdGF0ZWQgcG9zaXRpb25cbiAgICB2YXIgcm90YXRpb24gPSB0aGlzLmdldFJvdGF0aW9uKCk7XG4gICAgdmFyIGNvc0FuZ2xlID0gTWF0aC5jb3MoLXJvdGF0aW9uKTtcbiAgICB2YXIgc2luQW5nbGUgPSBNYXRoLnNpbigtcm90YXRpb24pO1xuICAgIHZhciByb3RYID0gY29vcmRpbmF0ZVswXSAqIGNvc0FuZ2xlIC0gY29vcmRpbmF0ZVsxXSAqIHNpbkFuZ2xlO1xuICAgIHZhciByb3RZID0gY29vcmRpbmF0ZVsxXSAqIGNvc0FuZ2xlICsgY29vcmRpbmF0ZVswXSAqIHNpbkFuZ2xlO1xuICAgIHZhciByZXNvbHV0aW9uID0gdGhpcy5nZXRSZXNvbHV0aW9uKCk7XG4gICAgcm90WCArPSAoc2l6ZVswXSAvIDIgLSBwb3NpdGlvblswXSkgKiByZXNvbHV0aW9uO1xuICAgIHJvdFkgKz0gKHBvc2l0aW9uWzFdIC0gc2l6ZVsxXSAvIDIpICogcmVzb2x1dGlvbjtcblxuICAgIC8vIGdvIGJhY2sgdG8gb3JpZ2luYWwgYW5nbGVcbiAgICBzaW5BbmdsZSA9IC1zaW5BbmdsZTsgLy8gZ28gYmFjayB0byBvcmlnaW5hbCByb3RhdGlvblxuICAgIHZhciBjZW50ZXJYID0gcm90WCAqIGNvc0FuZ2xlIC0gcm90WSAqIHNpbkFuZ2xlO1xuICAgIHZhciBjZW50ZXJZID0gcm90WSAqIGNvc0FuZ2xlICsgcm90WCAqIHNpbkFuZ2xlO1xuXG4gICAgdGhpcy5zZXRDZW50ZXIoW2NlbnRlclgsIGNlbnRlclldKTtcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSXMgZGVmaW5lZC5cbiAgICovXG4gIFZpZXcucHJvdG90eXBlLmlzRGVmID0gZnVuY3Rpb24gaXNEZWYgKCkge1xuICAgIHJldHVybiAhIXRoaXMuZ2V0Q2VudGVyKCkgJiYgdGhpcy5nZXRSZXNvbHV0aW9uKCkgIT09IHVuZGVmaW5lZDtcbiAgfTtcblxuICAvKipcbiAgICogUm90YXRlIHRoZSB2aWV3IGFyb3VuZCBhIGdpdmVuIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvbiBOZXcgcm90YXRpb24gdmFsdWUgZm9yIHRoZSB2aWV3LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPX0gb3B0X2FuY2hvciBUaGUgcm90YXRpb24gY2VudGVyLlxuICAgKiBAYXBpXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5yb3RhdGUgPSBmdW5jdGlvbiByb3RhdGUgKHJvdGF0aW9uLCBvcHRfYW5jaG9yKSB7XG4gICAgaWYgKG9wdF9hbmNob3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuY2FsY3VsYXRlQ2VudGVyUm90YXRlKHJvdGF0aW9uLCBvcHRfYW5jaG9yKTtcbiAgICAgIHRoaXMuc2V0Q2VudGVyKGNlbnRlcik7XG4gICAgfVxuICAgIHRoaXMuc2V0Um90YXRpb24ocm90YXRpb24pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNlbnRlciBvZiB0aGUgY3VycmVudCB2aWV3LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfHVuZGVmaW5lZH0gY2VudGVyIFRoZSBjZW50ZXIgb2YgdGhlIHZpZXcuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIFZpZXcucHJvdG90eXBlLnNldENlbnRlciA9IGZ1bmN0aW9uIHNldENlbnRlciAoY2VudGVyKSB7XG4gICAgdGhpcy5zZXQoVmlld1Byb3BlcnR5LkNFTlRFUiwgY2VudGVyKTtcbiAgICBpZiAodGhpcy5nZXRBbmltYXRpbmcoKSkge1xuICAgICAgdGhpcy5jYW5jZWxBbmltYXRpb25zKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1ZpZXdIaW50fSBoaW50IEhpbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YSBEZWx0YS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBOZXcgdmFsdWUuXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5zZXRIaW50ID0gZnVuY3Rpb24gc2V0SGludCAoaGludCwgZGVsdGEpIHtcbiAgICB0aGlzLmhpbnRzX1toaW50XSArPSBkZWx0YTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICByZXR1cm4gdGhpcy5oaW50c19baGludF07XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcmVzb2x1dGlvbiBmb3IgdGhpcyB2aWV3LlxuICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHJlc29sdXRpb24gVGhlIHJlc29sdXRpb24gb2YgdGhlIHZpZXcuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIFZpZXcucHJvdG90eXBlLnNldFJlc29sdXRpb24gPSBmdW5jdGlvbiBzZXRSZXNvbHV0aW9uIChyZXNvbHV0aW9uKSB7XG4gICAgdGhpcy5zZXQoVmlld1Byb3BlcnR5LlJFU09MVVRJT04sIHJlc29sdXRpb24pO1xuICAgIGlmICh0aGlzLmdldEFuaW1hdGluZygpKSB7XG4gICAgICB0aGlzLmNhbmNlbEFuaW1hdGlvbnMoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcm90YXRpb24gZm9yIHRoaXMgdmlldy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIFRoZSByb3RhdGlvbiBvZiB0aGUgdmlldyBpbiByYWRpYW5zLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5zZXRSb3RhdGlvbiA9IGZ1bmN0aW9uIHNldFJvdGF0aW9uIChyb3RhdGlvbikge1xuICAgIHRoaXMuc2V0KFZpZXdQcm9wZXJ0eS5ST1RBVElPTiwgcm90YXRpb24pO1xuICAgIGlmICh0aGlzLmdldEFuaW1hdGluZygpKSB7XG4gICAgICB0aGlzLmNhbmNlbEFuaW1hdGlvbnMoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFpvb20gdG8gYSBzcGVjaWZpYyB6b29tIGxldmVsLlxuICAgKiBAcGFyYW0ge251bWJlcn0gem9vbSBab29tIGxldmVsLlxuICAgKiBAYXBpXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5zZXRab29tID0gZnVuY3Rpb24gc2V0Wm9vbSAoem9vbSkge1xuICAgIHRoaXMuc2V0UmVzb2x1dGlvbih0aGlzLmdldFJlc29sdXRpb25Gb3Jab29tKHpvb20pKTtcbiAgfTtcblxuICByZXR1cm4gVmlldztcbn0oQmFzZU9iamVjdCkpO1xuXG5cbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2suXG4gKiBAcGFyYW0geyp9IHJldHVyblZhbHVlIFJldHVybiB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYW5pbWF0aW9uQ2FsbGJhY2soY2FsbGJhY2ssIHJldHVyblZhbHVlKSB7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgY2FsbGJhY2socmV0dXJuVmFsdWUpO1xuICB9LCAwKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7Vmlld09wdGlvbnN9IG9wdGlvbnMgVmlldyBvcHRpb25zLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9jZW50ZXJjb25zdHJhaW50LmpzXCIpLlR5cGV9IFRoZSBjb25zdHJhaW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2VudGVyQ29uc3RyYWludChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLmV4dGVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUV4dGVudChvcHRpb25zLmV4dGVudCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNlbnRlck5vbmU7XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7Vmlld09wdGlvbnN9IG9wdGlvbnMgVmlldyBvcHRpb25zLlxuICogQHJldHVybiB7e2NvbnN0cmFpbnQ6IGltcG9ydChcIi4vcmVzb2x1dGlvbmNvbnN0cmFpbnQuanNcIikuVHlwZSwgbWF4UmVzb2x1dGlvbjogbnVtYmVyLFxuICogICAgIG1pblJlc29sdXRpb246IG51bWJlciwgbWluWm9vbTogbnVtYmVyLCB6b29tRmFjdG9yOiBudW1iZXJ9fSBUaGUgY29uc3RyYWludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJlc29sdXRpb25Db25zdHJhaW50KG9wdGlvbnMpIHtcbiAgdmFyIHJlc29sdXRpb25Db25zdHJhaW50O1xuICB2YXIgbWF4UmVzb2x1dGlvbjtcbiAgdmFyIG1pblJlc29sdXRpb247XG5cbiAgLy8gVE9ETzogbW92ZSB0aGVzZSB0byBiZSBvbCBjb25zdGFudHNcbiAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVubGF5ZXJzL29wZW5sYXllcnMvaXNzdWVzLzIwNzZcbiAgdmFyIGRlZmF1bHRNYXhab29tID0gMjg7XG4gIHZhciBkZWZhdWx0Wm9vbUZhY3RvciA9IDI7XG5cbiAgdmFyIG1pblpvb20gPSBvcHRpb25zLm1pblpvb20gIT09IHVuZGVmaW5lZCA/XG4gICAgb3B0aW9ucy5taW5ab29tIDogREVGQVVMVF9NSU5fWk9PTTtcblxuICB2YXIgbWF4Wm9vbSA9IG9wdGlvbnMubWF4Wm9vbSAhPT0gdW5kZWZpbmVkID9cbiAgICBvcHRpb25zLm1heFpvb20gOiBkZWZhdWx0TWF4Wm9vbTtcblxuICB2YXIgem9vbUZhY3RvciA9IG9wdGlvbnMuem9vbUZhY3RvciAhPT0gdW5kZWZpbmVkID9cbiAgICBvcHRpb25zLnpvb21GYWN0b3IgOiBkZWZhdWx0Wm9vbUZhY3RvcjtcblxuICBpZiAob3B0aW9ucy5yZXNvbHV0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHJlc29sdXRpb25zID0gb3B0aW9ucy5yZXNvbHV0aW9ucztcbiAgICBtYXhSZXNvbHV0aW9uID0gcmVzb2x1dGlvbnNbbWluWm9vbV07XG4gICAgbWluUmVzb2x1dGlvbiA9IHJlc29sdXRpb25zW21heFpvb21dICE9PSB1bmRlZmluZWQgP1xuICAgICAgcmVzb2x1dGlvbnNbbWF4Wm9vbV0gOiByZXNvbHV0aW9uc1tyZXNvbHV0aW9ucy5sZW5ndGggLSAxXTtcbiAgICByZXNvbHV0aW9uQ29uc3RyYWludCA9IGNyZWF0ZVNuYXBUb1Jlc29sdXRpb25zKFxuICAgICAgcmVzb2x1dGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIC8vIGNhbGN1bGF0ZSB0aGUgZGVmYXVsdCBtaW4gYW5kIG1heCByZXNvbHV0aW9uXG4gICAgdmFyIHByb2plY3Rpb24gPSBjcmVhdGVQcm9qZWN0aW9uKG9wdGlvbnMucHJvamVjdGlvbiwgJ0VQU0c6Mzg1NycpO1xuICAgIHZhciBleHRlbnQgPSBwcm9qZWN0aW9uLmdldEV4dGVudCgpO1xuICAgIHZhciBzaXplID0gIWV4dGVudCA/XG4gICAgICAvLyB1c2UgYW4gZXh0ZW50IHRoYXQgY2FuIGZpdCB0aGUgd2hvbGUgd29ybGQgaWYgbmVlZCBiZVxuICAgICAgMzYwICogTUVURVJTX1BFUl9VTklUW1VuaXRzLkRFR1JFRVNdIC9cbiAgICAgICAgICAgIHByb2plY3Rpb24uZ2V0TWV0ZXJzUGVyVW5pdCgpIDpcbiAgICAgIE1hdGgubWF4KGdldFdpZHRoKGV4dGVudCksIGdldEhlaWdodChleHRlbnQpKTtcblxuICAgIHZhciBkZWZhdWx0TWF4UmVzb2x1dGlvbiA9IHNpemUgLyBERUZBVUxUX1RJTEVfU0laRSAvIE1hdGgucG93KFxuICAgICAgZGVmYXVsdFpvb21GYWN0b3IsIERFRkFVTFRfTUlOX1pPT00pO1xuXG4gICAgdmFyIGRlZmF1bHRNaW5SZXNvbHV0aW9uID0gZGVmYXVsdE1heFJlc29sdXRpb24gLyBNYXRoLnBvdyhcbiAgICAgIGRlZmF1bHRab29tRmFjdG9yLCBkZWZhdWx0TWF4Wm9vbSAtIERFRkFVTFRfTUlOX1pPT00pO1xuXG4gICAgLy8gdXNlciBwcm92aWRlZCBtYXhSZXNvbHV0aW9uIHRha2VzIHByZWNlZGVuY2VcbiAgICBtYXhSZXNvbHV0aW9uID0gb3B0aW9ucy5tYXhSZXNvbHV0aW9uO1xuICAgIGlmIChtYXhSZXNvbHV0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG1pblpvb20gPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXhSZXNvbHV0aW9uID0gZGVmYXVsdE1heFJlc29sdXRpb24gLyBNYXRoLnBvdyh6b29tRmFjdG9yLCBtaW5ab29tKTtcbiAgICB9XG5cbiAgICAvLyB1c2VyIHByb3ZpZGVkIG1pblJlc29sdXRpb24gdGFrZXMgcHJlY2VkZW5jZVxuICAgIG1pblJlc29sdXRpb24gPSBvcHRpb25zLm1pblJlc29sdXRpb247XG4gICAgaWYgKG1pblJlc29sdXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKG9wdGlvbnMubWF4Wm9vbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChvcHRpb25zLm1heFJlc29sdXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG1pblJlc29sdXRpb24gPSBtYXhSZXNvbHV0aW9uIC8gTWF0aC5wb3coem9vbUZhY3RvciwgbWF4Wm9vbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWluUmVzb2x1dGlvbiA9IGRlZmF1bHRNYXhSZXNvbHV0aW9uIC8gTWF0aC5wb3coem9vbUZhY3RvciwgbWF4Wm9vbSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1pblJlc29sdXRpb24gPSBkZWZhdWx0TWluUmVzb2x1dGlvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBnaXZlbiBkaXNjcmV0ZSB6b29tIGxldmVscywgbWluUmVzb2x1dGlvbiBtYXkgYmUgZGlmZmVyZW50IHRoYW4gcHJvdmlkZWRcbiAgICBtYXhab29tID0gbWluWm9vbSArIE1hdGguZmxvb3IoXG4gICAgICBNYXRoLmxvZyhtYXhSZXNvbHV0aW9uIC8gbWluUmVzb2x1dGlvbikgLyBNYXRoLmxvZyh6b29tRmFjdG9yKSk7XG4gICAgbWluUmVzb2x1dGlvbiA9IG1heFJlc29sdXRpb24gLyBNYXRoLnBvdyh6b29tRmFjdG9yLCBtYXhab29tIC0gbWluWm9vbSk7XG5cbiAgICByZXNvbHV0aW9uQ29uc3RyYWludCA9IGNyZWF0ZVNuYXBUb1Bvd2VyKFxuICAgICAgem9vbUZhY3RvciwgbWF4UmVzb2x1dGlvbiwgbWF4Wm9vbSAtIG1pblpvb20pO1xuICB9XG4gIHJldHVybiB7Y29uc3RyYWludDogcmVzb2x1dGlvbkNvbnN0cmFpbnQsIG1heFJlc29sdXRpb246IG1heFJlc29sdXRpb24sXG4gICAgbWluUmVzb2x1dGlvbjogbWluUmVzb2x1dGlvbiwgbWluWm9vbTogbWluWm9vbSwgem9vbUZhY3Rvcjogem9vbUZhY3Rvcn07XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge1ZpZXdPcHRpb25zfSBvcHRpb25zIFZpZXcgb3B0aW9ucy5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vcm90YXRpb25jb25zdHJhaW50LmpzXCIpLlR5cGV9IFJvdGF0aW9uIGNvbnN0cmFpbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSb3RhdGlvbkNvbnN0cmFpbnQob3B0aW9ucykge1xuICB2YXIgZW5hYmxlUm90YXRpb24gPSBvcHRpb25zLmVuYWJsZVJvdGF0aW9uICE9PSB1bmRlZmluZWQgP1xuICAgIG9wdGlvbnMuZW5hYmxlUm90YXRpb24gOiB0cnVlO1xuICBpZiAoZW5hYmxlUm90YXRpb24pIHtcbiAgICB2YXIgY29uc3RyYWluUm90YXRpb24gPSBvcHRpb25zLmNvbnN0cmFpblJvdGF0aW9uO1xuICAgIGlmIChjb25zdHJhaW5Sb3RhdGlvbiA9PT0gdW5kZWZpbmVkIHx8IGNvbnN0cmFpblJvdGF0aW9uID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlU25hcFRvWmVybygpO1xuICAgIH0gZWxzZSBpZiAoY29uc3RyYWluUm90YXRpb24gPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gcm90YXRpb25Ob25lO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbnN0cmFpblJvdGF0aW9uID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVNuYXBUb04oY29uc3RyYWluUm90YXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcm90YXRpb25Ob25lO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZGlzYWJsZTtcbiAgfVxufVxuXG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGFuIGFuaW1hdGlvbiBpbnZvbHZlcyBubyB2aWV3IGNoYW5nZS5cbiAqIEBwYXJhbSB7QW5pbWF0aW9ufSBhbmltYXRpb24gVGhlIGFuaW1hdGlvbi5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBhbmltYXRpb24gaW52b2x2ZXMgbm8gdmlldyBjaGFuZ2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc05vb3BBbmltYXRpb24oYW5pbWF0aW9uKSB7XG4gIGlmIChhbmltYXRpb24uc291cmNlQ2VudGVyICYmIGFuaW1hdGlvbi50YXJnZXRDZW50ZXIpIHtcbiAgICBpZiAoIWNvb3JkaW5hdGVzRXF1YWwoYW5pbWF0aW9uLnNvdXJjZUNlbnRlciwgYW5pbWF0aW9uLnRhcmdldENlbnRlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKGFuaW1hdGlvbi5zb3VyY2VSZXNvbHV0aW9uICE9PSBhbmltYXRpb24udGFyZ2V0UmVzb2x1dGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoYW5pbWF0aW9uLnNvdXJjZVJvdGF0aW9uICE9PSBhbmltYXRpb24udGFyZ2V0Um90YXRpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFZpZXc7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZpZXcuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL1ZpZXdIaW50XG4gKi9cblxuLyoqXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIEFOSU1BVElORzogMCxcbiAgSU5URVJBQ1RJTkc6IDFcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZpZXdIaW50LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9WaWV3UHJvcGVydHlcbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgQ0VOVEVSOiAnY2VudGVyJyxcbiAgUkVTT0xVVElPTjogJ3Jlc29sdXRpb24nLFxuICBST1RBVElPTjogJ3JvdGF0aW9uJ1xufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Vmlld1Byb3BlcnR5LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9hcnJheVxuICovXG5cblxuLyoqXG4gKiBQZXJmb3JtcyBhIGJpbmFyeSBzZWFyY2ggb24gdGhlIHByb3ZpZGVkIHNvcnRlZCBsaXN0IGFuZCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgaXRlbSBpZiBmb3VuZC4gSWYgaXQgY2FuJ3QgYmUgZm91bmQgaXQnbGwgcmV0dXJuIC0xLlxuICogaHR0cHM6Ly9naXRodWIuY29tL2Rhcmtza3lhcHAvYmluYXJ5LXNlYXJjaFxuICpcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGhheXN0YWNrIEl0ZW1zIHRvIHNlYXJjaCB0aHJvdWdoLlxuICogQHBhcmFtIHsqfSBuZWVkbGUgVGhlIGl0ZW0gdG8gbG9vayBmb3IuXG4gKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb3B0X2NvbXBhcmF0b3IgQ29tcGFyYXRvciBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGluZGV4IG9mIHRoZSBpdGVtIGlmIGZvdW5kLCAtMSBpZiBub3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5hcnlTZWFyY2goaGF5c3RhY2ssIG5lZWRsZSwgb3B0X2NvbXBhcmF0b3IpIHtcbiAgdmFyIG1pZCwgY21wO1xuICB2YXIgY29tcGFyYXRvciA9IG9wdF9jb21wYXJhdG9yIHx8IG51bWJlclNhZmVDb21wYXJlRnVuY3Rpb247XG4gIHZhciBsb3cgPSAwO1xuICB2YXIgaGlnaCA9IGhheXN0YWNrLmxlbmd0aDtcbiAgdmFyIGZvdW5kID0gZmFsc2U7XG5cbiAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAvKiBOb3RlIHRoYXQgXCIobG93ICsgaGlnaCkgPj4+IDFcIiBtYXkgb3ZlcmZsb3csIGFuZCByZXN1bHRzIGluIGEgdHlwZWNhc3RcbiAgICAgKiB0byBkb3VibGUgKHdoaWNoIGdpdmVzIHRoZSB3cm9uZyByZXN1bHRzKS4gKi9cbiAgICBtaWQgPSBsb3cgKyAoaGlnaCAtIGxvdyA+PiAxKTtcbiAgICBjbXAgPSArY29tcGFyYXRvcihoYXlzdGFja1ttaWRdLCBuZWVkbGUpO1xuXG4gICAgaWYgKGNtcCA8IDAuMCkgeyAvKiBUb28gbG93LiAqL1xuICAgICAgbG93ID0gbWlkICsgMTtcblxuICAgIH0gZWxzZSB7IC8qIEtleSBmb3VuZCBvciB0b28gaGlnaCAqL1xuICAgICAgaGlnaCA9IG1pZDtcbiAgICAgIGZvdW5kID0gIWNtcDtcbiAgICB9XG4gIH1cblxuICAvKiBLZXkgbm90IGZvdW5kLiAqL1xuICByZXR1cm4gZm91bmQgPyBsb3cgOiB+bG93O1xufVxuXG5cbi8qKlxuICogQ29tcGFyZSBmdW5jdGlvbiBmb3IgYXJyYXkgc29ydCB0aGF0IGlzIHNhZmUgZm9yIG51bWJlcnMuXG4gKiBAcGFyYW0geyp9IGEgVGhlIGZpcnN0IG9iamVjdCB0byBiZSBjb21wYXJlZC5cbiAqIEBwYXJhbSB7Kn0gYiBUaGUgc2Vjb25kIG9iamVjdCB0byBiZSBjb21wYXJlZC5cbiAqIEByZXR1cm4ge251bWJlcn0gQSBuZWdhdGl2ZSBudW1iZXIsIHplcm8sIG9yIGEgcG9zaXRpdmUgbnVtYmVyIGFzIHRoZSBmaXJzdFxuICogICAgIGFyZ3VtZW50IGlzIGxlc3MgdGhhbiwgZXF1YWwgdG8sIG9yIGdyZWF0ZXIgdGhhbiB0aGUgc2Vjb25kLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyU2FmZUNvbXBhcmVGdW5jdGlvbihhLCBiKSB7XG4gIHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMDtcbn1cblxuXG4vKipcbiAqIFdoZXRoZXIgdGhlIGFycmF5IGNvbnRhaW5zIHRoZSBnaXZlbiBvYmplY3QuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhcnIgVGhlIGFycmF5IHRvIHRlc3QgZm9yIHRoZSBwcmVzZW5jZSBvZiB0aGUgZWxlbWVudC5cbiAqIEBwYXJhbSB7Kn0gb2JqIFRoZSBvYmplY3QgZm9yIHdoaWNoIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgb2JqZWN0IGlzIGluIHRoZSBhcnJheS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluY2x1ZGVzKGFyciwgb2JqKSB7XG4gIHJldHVybiBhcnIuaW5kZXhPZihvYmopID49IDA7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGFyciBBcnJheS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0YXJnZXQgVGFyZ2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGRpcmVjdGlvbiAwIG1lYW5zIHJldHVybiB0aGUgbmVhcmVzdCwgPiAwXG4gKiAgICBtZWFucyByZXR1cm4gdGhlIGxhcmdlc3QgbmVhcmVzdCwgPCAwIG1lYW5zIHJldHVybiB0aGVcbiAqICAgIHNtYWxsZXN0IG5lYXJlc3QuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEluZGV4LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyRmluZE5lYXJlc3QoYXJyLCB0YXJnZXQsIGRpcmVjdGlvbikge1xuICB2YXIgbiA9IGFyci5sZW5ndGg7XG4gIGlmIChhcnJbMF0gPD0gdGFyZ2V0KSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSBpZiAodGFyZ2V0IDw9IGFycltuIC0gMV0pIHtcbiAgICByZXR1cm4gbiAtIDE7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGk7XG4gICAgaWYgKGRpcmVjdGlvbiA+IDApIHtcbiAgICAgIGZvciAoaSA9IDE7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaWYgKGFycltpXSA8IHRhcmdldCkge1xuICAgICAgICAgIHJldHVybiBpIC0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uIDwgMCkge1xuICAgICAgZm9yIChpID0gMTsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAoYXJyW2ldIDw9IHRhcmdldCkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDE7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaWYgKGFycltpXSA9PSB0YXJnZXQpIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfSBlbHNlIGlmIChhcnJbaV0gPCB0YXJnZXQpIHtcbiAgICAgICAgICBpZiAoYXJyW2kgLSAxXSAtIHRhcmdldCA8IHRhcmdldCAtIGFycltpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGkgLSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG4gLSAxO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhcnIgQXJyYXkuXG4gKiBAcGFyYW0ge251bWJlcn0gYmVnaW4gQmVnaW4gaW5kZXguXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZCBpbmRleC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJldmVyc2VTdWJBcnJheShhcnIsIGJlZ2luLCBlbmQpIHtcbiAgd2hpbGUgKGJlZ2luIDwgZW5kKSB7XG4gICAgdmFyIHRtcCA9IGFycltiZWdpbl07XG4gICAgYXJyW2JlZ2luXSA9IGFycltlbmRdO1xuICAgIGFycltlbmRdID0gdG1wO1xuICAgICsrYmVnaW47XG4gICAgLS1lbmQ7XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8VkFMVUU+fSBhcnIgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7IUFycmF5PFZBTFVFPnxWQUxVRX0gZGF0YSBUaGUgZWxlbWVudHMgb3IgYXJyYXlzIG9mIGVsZW1lbnRzIHRvIGFkZCB0byBhcnIuXG4gKiBAdGVtcGxhdGUgVkFMVUVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChhcnIsIGRhdGEpIHtcbiAgdmFyIGV4dGVuc2lvbiA9IEFycmF5LmlzQXJyYXkoZGF0YSkgPyBkYXRhIDogW2RhdGFdO1xuICB2YXIgbGVuZ3RoID0gZXh0ZW5zaW9uLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGFyclthcnIubGVuZ3RoXSA9IGV4dGVuc2lvbltpXTtcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxWQUxVRT59IGFyciBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtWQUxVRX0gb2JqIFRoZSBlbGVtZW50IHRvIHJlbW92ZS5cbiAqIEB0ZW1wbGF0ZSBWQUxVRVxuICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIGVsZW1lbnQgd2FzIHJlbW92ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmUoYXJyLCBvYmopIHtcbiAgdmFyIGkgPSBhcnIuaW5kZXhPZihvYmopO1xuICB2YXIgZm91bmQgPSBpID4gLTE7XG4gIGlmIChmb3VuZCkge1xuICAgIGFyci5zcGxpY2UoaSwgMSk7XG4gIH1cbiAgcmV0dXJuIGZvdW5kO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxWQUxVRT59IGFyciBUaGUgYXJyYXkgdG8gc2VhcmNoIGluLlxuICogQHBhcmFtIHtmdW5jdGlvbihWQUxVRSwgbnVtYmVyLCA/KSA6IGJvb2xlYW59IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbXBhcmUuXG4gKiBAdGVtcGxhdGUgVkFMVUVcbiAqIEByZXR1cm4ge1ZBTFVFfG51bGx9IFRoZSBlbGVtZW50IGZvdW5kIG9yIG51bGwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kKGFyciwgZnVuYykge1xuICB2YXIgbGVuZ3RoID0gYXJyLmxlbmd0aCA+Pj4gMDtcbiAgdmFyIHZhbHVlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YWx1ZSA9IGFycltpXTtcbiAgICBpZiAoZnVuYyh2YWx1ZSwgaSwgYXJyKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXl8VWludDhDbGFtcGVkQXJyYXl9IGFycjEgVGhlIGZpcnN0IGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fFVpbnQ4Q2xhbXBlZEFycmF5fSBhcnIyIFRoZSBzZWNvbmQgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHR3byBhcnJheXMgYXJlIGVxdWFsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGFycjEsIGFycjIpIHtcbiAgdmFyIGxlbjEgPSBhcnIxLmxlbmd0aDtcbiAgaWYgKGxlbjEgIT09IGFycjIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuMTsgaSsrKSB7XG4gICAgaWYgKGFycjFbaV0gIT09IGFycjJbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cblxuLyoqXG4gKiBTb3J0IHRoZSBwYXNzZWQgYXJyYXkgc3VjaCB0aGF0IHRoZSByZWxhdGl2ZSBvcmRlciBvZiBlcXVhbCBlbGVtZW50cyBpcyBwcmV2ZXJ2ZWQuXG4gKiBTZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU29ydGluZ19hbGdvcml0aG0jU3RhYmlsaXR5IGZvciBkZXRhaWxzLlxuICogQHBhcmFtIHtBcnJheTwqPn0gYXJyIFRoZSBhcnJheSB0byBzb3J0IChtb2RpZmllcyBvcmlnaW5hbCkuXG4gKiBAcGFyYW0geyFmdW5jdGlvbigqLCAqKTogbnVtYmVyfSBjb21wYXJlRm5jIENvbXBhcmlzb24gZnVuY3Rpb24uXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGFibGVTb3J0KGFyciwgY29tcGFyZUZuYykge1xuICB2YXIgbGVuZ3RoID0gYXJyLmxlbmd0aDtcbiAgdmFyIHRtcCA9IEFycmF5KGFyci5sZW5ndGgpO1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdG1wW2ldID0ge2luZGV4OiBpLCB2YWx1ZTogYXJyW2ldfTtcbiAgfVxuICB0bXAuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGNvbXBhcmVGbmMoYS52YWx1ZSwgYi52YWx1ZSkgfHwgYS5pbmRleCAtIGIuaW5kZXg7XG4gIH0pO1xuICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgYXJyW2ldID0gdG1wW2ldLnZhbHVlO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhcnIgVGhlIGFycmF5IHRvIHNlYXJjaCBpbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgQ29tcGFyaXNvbiBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn0gUmV0dXJuIGluZGV4LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZEluZGV4KGFyciwgZnVuYykge1xuICB2YXIgaW5kZXg7XG4gIHZhciBmb3VuZCA9ICFhcnIuZXZlcnkoZnVuY3Rpb24oZWwsIGlkeCkge1xuICAgIGluZGV4ID0gaWR4O1xuICAgIHJldHVybiAhZnVuYyhlbCwgaWR4LCBhcnIpO1xuICB9KTtcbiAgcmV0dXJuIGZvdW5kID8gaW5kZXggOiAtMTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGFyciBUaGUgYXJyYXkgdG8gdGVzdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb249fSBvcHRfZnVuYyBDb21wYXJpc29uIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3N0cmljdCBTdHJpY3RseSBzb3J0ZWQgKGRlZmF1bHQgZmFsc2UpLlxuICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJuIGluZGV4LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTb3J0ZWQoYXJyLCBvcHRfZnVuYywgb3B0X3N0cmljdCkge1xuICB2YXIgY29tcGFyZSA9IG9wdF9mdW5jIHx8IG51bWJlclNhZmVDb21wYXJlRnVuY3Rpb247XG4gIHJldHVybiBhcnIuZXZlcnkoZnVuY3Rpb24oY3VycmVudFZhbCwgaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgcmVzID0gY29tcGFyZShhcnJbaW5kZXggLSAxXSwgY3VycmVudFZhbCk7XG4gICAgcmV0dXJuICEocmVzID4gMCB8fCBvcHRfc3RyaWN0ICYmIHJlcyA9PT0gMCk7XG4gIH0pO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcnJheS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvYXNzZXJ0c1xuICovXG5pbXBvcnQgQXNzZXJ0aW9uRXJyb3IgZnJvbSAnLi9Bc3NlcnRpb25FcnJvci5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHsqfSBhc3NlcnRpb24gQXNzZXJ0aW9uIHdlIGV4cGVjdGVkIHRvIGJlIHRydXRoeS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlcnJvckNvZGUgRXJyb3IgY29kZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydChhc3NlcnRpb24sIGVycm9yQ29kZSkge1xuICBpZiAoIWFzc2VydGlvbikge1xuICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihlcnJvckNvZGUpO1xuICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzc2VydHMuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2NlbnRlcmNvbnN0cmFpbnRcbiAqL1xuaW1wb3J0IHtjbGFtcH0gZnJvbSAnLi9tYXRoLmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbigoaW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8dW5kZWZpbmVkKSk6IChpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZXx1bmRlZmluZWQpfSBUeXBlXG4gKi9cblxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7VHlwZX0gVGhlIGNvbnN0cmFpbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFeHRlbnQoZXh0ZW50KSB7XG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT19IGNlbnRlciBDZW50ZXIuXG4gICAgICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8dW5kZWZpbmVkfSBDZW50ZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24oY2VudGVyKSB7XG4gICAgICBpZiAoY2VudGVyKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgY2xhbXAoY2VudGVyWzBdLCBleHRlbnRbMF0sIGV4dGVudFsyXSksXG4gICAgICAgICAgY2xhbXAoY2VudGVyWzFdLCBleHRlbnRbMV0sIGV4dGVudFszXSlcbiAgICAgICAgXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICApO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT19IGNlbnRlciBDZW50ZXIuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZXx1bmRlZmluZWR9IENlbnRlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vbmUoY2VudGVyKSB7XG4gIHJldHVybiBjZW50ZXI7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNlbnRlcmNvbnN0cmFpbnQuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2NvbG9yXG4gKi9cbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuL2Fzc2VydHMuanMnO1xuaW1wb3J0IHtjbGFtcH0gZnJvbSAnLi9tYXRoLmpzJztcblxuXG4vKipcbiAqIEEgY29sb3IgcmVwcmVzZW50ZWQgYXMgYSBzaG9ydCBhcnJheSBbcmVkLCBncmVlbiwgYmx1ZSwgYWxwaGFdLlxuICogcmVkLCBncmVlbiwgYW5kIGJsdWUgc2hvdWxkIGJlIGludGVnZXJzIGluIHRoZSByYW5nZSAwLi4yNTUgaW5jbHVzaXZlLlxuICogYWxwaGEgc2hvdWxkIGJlIGEgZmxvYXQgaW4gdGhlIHJhbmdlIDAuLjEgaW5jbHVzaXZlLiBJZiBubyBhbHBoYSB2YWx1ZSBpc1xuICogZ2l2ZW4gdGhlbiBgMWAgd2lsbCBiZSB1c2VkLlxuICogQHR5cGVkZWYge0FycmF5PG51bWJlcj59IENvbG9yXG4gKiBAYXBpXG4gKi9cblxuXG4vKipcbiAqIFRoaXMgUmVnRXhwIG1hdGNoZXMgIyBmb2xsb3dlZCBieSAzLCA0LCA2LCBvciA4IGhleCBkaWdpdHMuXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgSEVYX0NPTE9SX1JFXyA9IC9eIyhbYS1mMC05XXszfXxbYS1mMC05XXs0fSg/OlthLWYwLTldezJ9KXswLDJ9KSQvaTtcblxuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgbWF0Y2hpbmcgcG90ZW50aWFsIG5hbWVkIGNvbG9yIHN0eWxlIHN0cmluZ3MuXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgTkFNRURfQ09MT1JfUkVfID0gL14oW2Etel0qKSQvaTtcblxuXG4vKipcbiAqIFJldHVybiB0aGUgY29sb3IgYXMgYW4gcmdiYSBzdHJpbmcuXG4gKiBAcGFyYW0ge0NvbG9yfHN0cmluZ30gY29sb3IgQ29sb3IuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFJnYmEgc3RyaW5nLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNTdHJpbmcoY29sb3IpIHtcbiAgaWYgKHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gY29sb3I7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nKGNvbG9yKTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybiBuYW1lZCBjb2xvciBhcyBhbiByZ2JhIHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvciBOYW1lZCBjb2xvci5cbiAqIEByZXR1cm4ge3N0cmluZ30gUmdiIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZnJvbU5hbWVkKGNvbG9yKSB7XG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBlbC5zdHlsZS5jb2xvciA9IGNvbG9yO1xuICBpZiAoZWwuc3R5bGUuY29sb3IgIT09ICcnKSB7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbCk7XG4gICAgdmFyIHJnYiA9IGdldENvbXB1dGVkU3R5bGUoZWwpLmNvbG9yO1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZWwpO1xuICAgIHJldHVybiByZ2I7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcyBTdHJpbmcuXG4gKiBAcmV0dXJuIHtDb2xvcn0gQ29sb3IuXG4gKi9cbmV4cG9ydCB2YXIgZnJvbVN0cmluZyA9IChcbiAgZnVuY3Rpb24oKSB7XG5cbiAgICAvLyBXZSBtYWludGFpbiBhIHNtYWxsIGNhY2hlIG9mIHBhcnNlZCBzdHJpbmdzLiAgVG8gcHJvdmlkZSBjaGVhcCBMUlUtbGlrZVxuICAgIC8vIHNlbWFudGljcywgd2hlbmV2ZXIgdGhlIGNhY2hlIGdyb3dzIHRvbyBsYXJnZSB3ZSBzaW1wbHkgZGVsZXRlIGFuXG4gICAgLy8gYXJiaXRyYXJ5IDI1JSBvZiB0aGUgZW50cmllcy5cblxuICAgIC8qKlxuICAgICAqIEBjb25zdFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdmFyIE1BWF9DQUNIRV9TSVpFID0gMTAyNDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBDb2xvcj59XG4gICAgICovXG4gICAgdmFyIGNhY2hlID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHZhciBjYWNoZVNpemUgPSAwO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHMgU3RyaW5nLlxuICAgICAgICogQHJldHVybiB7Q29sb3J9IENvbG9yLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbihzKSB7XG4gICAgICAgIHZhciBjb2xvcjtcbiAgICAgICAgaWYgKGNhY2hlLmhhc093blByb3BlcnR5KHMpKSB7XG4gICAgICAgICAgY29sb3IgPSBjYWNoZVtzXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY2FjaGVTaXplID49IE1BWF9DQUNIRV9TSVpFKSB7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gY2FjaGUpIHtcbiAgICAgICAgICAgICAgaWYgKChpKysgJiAzKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBjYWNoZVtrZXldO1xuICAgICAgICAgICAgICAgIC0tY2FjaGVTaXplO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbG9yID0gZnJvbVN0cmluZ0ludGVybmFsXyhzKTtcbiAgICAgICAgICBjYWNoZVtzXSA9IGNvbG9yO1xuICAgICAgICAgICsrY2FjaGVTaXplO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2xvcjtcbiAgICAgIH1cbiAgICApO1xuXG4gIH0pKCk7XG5cbi8qKlxuICogUmV0dXJuIHRoZSBjb2xvciBhcyBhbiBhcnJheS4gVGhpcyBmdW5jdGlvbiBtYWludGFpbnMgYSBjYWNoZSBvZiBjYWxjdWxhdGVkXG4gKiBhcnJheXMgd2hpY2ggbWVhbnMgdGhlIHJlc3VsdCBzaG91bGQgbm90IGJlIG1vZGlmaWVkLlxuICogQHBhcmFtIHtDb2xvcnxzdHJpbmd9IGNvbG9yIENvbG9yLlxuICogQHJldHVybiB7Q29sb3J9IENvbG9yLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNBcnJheShjb2xvcikge1xuICBpZiAoQXJyYXkuaXNBcnJheShjb2xvcikpIHtcbiAgICByZXR1cm4gY29sb3I7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcoY29sb3IpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHMgU3RyaW5nLlxuICogQHByaXZhdGVcbiAqIEByZXR1cm4ge0NvbG9yfSBDb2xvci5cbiAqL1xuZnVuY3Rpb24gZnJvbVN0cmluZ0ludGVybmFsXyhzKSB7XG4gIHZhciByLCBnLCBiLCBhLCBjb2xvcjtcblxuICBpZiAoTkFNRURfQ09MT1JfUkVfLmV4ZWMocykpIHtcbiAgICBzID0gZnJvbU5hbWVkKHMpO1xuICB9XG5cbiAgaWYgKEhFWF9DT0xPUl9SRV8uZXhlYyhzKSkgeyAvLyBoZXhcbiAgICB2YXIgbiA9IHMubGVuZ3RoIC0gMTsgLy8gbnVtYmVyIG9mIGhleCBkaWdpdHNcbiAgICB2YXIgZDsgLy8gbnVtYmVyIG9mIGRpZ2l0cyBwZXIgY2hhbm5lbFxuICAgIGlmIChuIDw9IDQpIHtcbiAgICAgIGQgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBkID0gMjtcbiAgICB9XG4gICAgdmFyIGhhc0FscGhhID0gbiA9PT0gNCB8fCBuID09PSA4O1xuICAgIHIgPSBwYXJzZUludChzLnN1YnN0cigxICsgMCAqIGQsIGQpLCAxNik7XG4gICAgZyA9IHBhcnNlSW50KHMuc3Vic3RyKDEgKyAxICogZCwgZCksIDE2KTtcbiAgICBiID0gcGFyc2VJbnQocy5zdWJzdHIoMSArIDIgKiBkLCBkKSwgMTYpO1xuICAgIGlmIChoYXNBbHBoYSkge1xuICAgICAgYSA9IHBhcnNlSW50KHMuc3Vic3RyKDEgKyAzICogZCwgZCksIDE2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IDI1NTtcbiAgICB9XG4gICAgaWYgKGQgPT0gMSkge1xuICAgICAgciA9IChyIDw8IDQpICsgcjtcbiAgICAgIGcgPSAoZyA8PCA0KSArIGc7XG4gICAgICBiID0gKGIgPDwgNCkgKyBiO1xuICAgICAgaWYgKGhhc0FscGhhKSB7XG4gICAgICAgIGEgPSAoYSA8PCA0KSArIGE7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbG9yID0gW3IsIGcsIGIsIGEgLyAyNTVdO1xuICB9IGVsc2UgaWYgKHMuaW5kZXhPZigncmdiYSgnKSA9PSAwKSB7IC8vIHJnYmEoKVxuICAgIGNvbG9yID0gcy5zbGljZSg1LCAtMSkuc3BsaXQoJywnKS5tYXAoTnVtYmVyKTtcbiAgICBub3JtYWxpemUoY29sb3IpO1xuICB9IGVsc2UgaWYgKHMuaW5kZXhPZigncmdiKCcpID09IDApIHsgLy8gcmdiKClcbiAgICBjb2xvciA9IHMuc2xpY2UoNCwgLTEpLnNwbGl0KCcsJykubWFwKE51bWJlcik7XG4gICAgY29sb3IucHVzaCgxKTtcbiAgICBub3JtYWxpemUoY29sb3IpO1xuICB9IGVsc2Uge1xuICAgIGFzc2VydChmYWxzZSwgMTQpOyAvLyBJbnZhbGlkIGNvbG9yXG4gIH1cbiAgcmV0dXJuIGNvbG9yO1xufVxuXG5cbi8qKlxuICogVE9ETyB0aGlzIGZ1bmN0aW9uIGlzIG9ubHkgdXNlZCBpbiB0aGUgdGVzdCwgd2UgcHJvYmFibHkgc2hvdWxkbid0IGV4cG9ydCBpdFxuICogQHBhcmFtIHtDb2xvcn0gY29sb3IgQ29sb3IuXG4gKiBAcmV0dXJuIHtDb2xvcn0gQ2xhbXBlZCBjb2xvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZShjb2xvcikge1xuICBjb2xvclswXSA9IGNsYW1wKChjb2xvclswXSArIDAuNSkgfCAwLCAwLCAyNTUpO1xuICBjb2xvclsxXSA9IGNsYW1wKChjb2xvclsxXSArIDAuNSkgfCAwLCAwLCAyNTUpO1xuICBjb2xvclsyXSA9IGNsYW1wKChjb2xvclsyXSArIDAuNSkgfCAwLCAwLCAyNTUpO1xuICBjb2xvclszXSA9IGNsYW1wKGNvbG9yWzNdLCAwLCAxKTtcbiAgcmV0dXJuIGNvbG9yO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtDb2xvcn0gY29sb3IgQ29sb3IuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvU3RyaW5nKGNvbG9yKSB7XG4gIHZhciByID0gY29sb3JbMF07XG4gIGlmIChyICE9IChyIHwgMCkpIHtcbiAgICByID0gKHIgKyAwLjUpIHwgMDtcbiAgfVxuICB2YXIgZyA9IGNvbG9yWzFdO1xuICBpZiAoZyAhPSAoZyB8IDApKSB7XG4gICAgZyA9IChnICsgMC41KSB8IDA7XG4gIH1cbiAgdmFyIGIgPSBjb2xvclsyXTtcbiAgaWYgKGIgIT0gKGIgfCAwKSkge1xuICAgIGIgPSAoYiArIDAuNSkgfCAwO1xuICB9XG4gIHZhciBhID0gY29sb3JbM10gPT09IHVuZGVmaW5lZCA/IDEgOiBjb2xvclszXTtcbiAgcmV0dXJuICdyZ2JhKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhICsgJyknO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2xvci5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvY29sb3JsaWtlXG4gKi9cbmltcG9ydCB7dG9TdHJpbmd9IGZyb20gJy4vY29sb3IuanMnO1xuXG5cbi8qKlxuICogQSB0eXBlIGFjY2VwdGVkIGJ5IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5maWxsU3R5bGVcbiAqIG9yIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5zdHJva2VTdHlsZS5cbiAqIFJlcHJlc2VudHMgYSBjb2xvciwgcGF0dGVybiwgb3IgZ3JhZGllbnQuIFRoZSBvcmlnaW4gZm9yIHBhdHRlcm5zIGFuZFxuICogZ3JhZGllbnRzIGFzIGZpbGwgc3R5bGUgaXMgYW4gaW5jcmVtZW50IG9mIDUxMiBjc3MgcGl4ZWxzIGZyb20gbWFwIGNvb3JkaW5hdGVcbiAqIGBbMCwgMF1gLiBGb3Igc2VhbWxlc3MgcmVwZWF0IHBhdHRlcm5zLCB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBwYXR0ZXJuIGltYWdlXG4gKiBtdXN0IGJlIGEgZmFjdG9yIG9mIHR3byAoMiwgNCwgOCwgLi4uLCA1MTIpLlxuICpcbiAqIEB0eXBlZGVmIHtzdHJpbmd8Q2FudmFzUGF0dGVybnxDYW52YXNHcmFkaWVudH0gQ29sb3JMaWtlXG4gKiBAYXBpXG4gKi9cblxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb2xvci5qc1wiKS5Db2xvcnxDb2xvckxpa2V9IGNvbG9yIENvbG9yLlxuICogQHJldHVybiB7Q29sb3JMaWtlfSBUaGUgY29sb3IgYXMgYW4ge0BsaW5rIG9sL2NvbG9ybGlrZX5Db2xvckxpa2V9LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNDb2xvckxpa2UoY29sb3IpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY29sb3IpKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nKGNvbG9yKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29sb3I7XG4gIH1cbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29sb3JsaWtlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9jb250cm9sL0F0dHJpYnV0aW9uXG4gKi9cbmltcG9ydCB7ZXF1YWxzfSBmcm9tICcuLi9hcnJheS5qcyc7XG5pbXBvcnQgQ29udHJvbCBmcm9tICcuL0NvbnRyb2wuanMnO1xuaW1wb3J0IHtDTEFTU19DT05UUk9MLCBDTEFTU19VTlNFTEVDVEFCTEUsIENMQVNTX0NPTExBUFNFRH0gZnJvbSAnLi4vY3NzLmpzJztcbmltcG9ydCB7cmVtb3ZlQ2hpbGRyZW4sIHJlcGxhY2VOb2RlfSBmcm9tICcuLi9kb20uanMnO1xuaW1wb3J0IHtsaXN0ZW59IGZyb20gJy4uL2V2ZW50cy5qcyc7XG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4uL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IHt2aXNpYmxlQXRSZXNvbHV0aW9ufSBmcm9tICcuLi9sYXllci9MYXllci5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzTmFtZT0nb2wtYXR0cmlidXRpb24nXSBDU1MgY2xhc3MgbmFtZS5cbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR8c3RyaW5nfSBbdGFyZ2V0XSBTcGVjaWZ5IGEgdGFyZ2V0IGlmIHlvdVxuICogd2FudCB0aGUgY29udHJvbCB0byBiZSByZW5kZXJlZCBvdXRzaWRlIG9mIHRoZSBtYXAnc1xuICogdmlld3BvcnQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjb2xsYXBzaWJsZV0gU3BlY2lmeSBpZiBhdHRyaWJ1dGlvbnMgY2FuXG4gKiBiZSBjb2xsYXBzZWQuIElmIG5vdCBzcGVjaWZpZWQsIHNvdXJjZXMgY29udHJvbCB0aGlzIGJlaGF2aW9yIHdpdGggdGhlaXJcbiAqIGBhdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZWAgc2V0dGluZy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2NvbGxhcHNlZD10cnVlXSBTcGVjaWZ5IGlmIGF0dHJpYnV0aW9ucyBzaG91bGRcbiAqIGJlIGNvbGxhcHNlZCBhdCBzdGFydHVwLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt0aXBMYWJlbD0nQXR0cmlidXRpb25zJ10gVGV4dCBsYWJlbCB0byB1c2UgZm9yIHRoZSBidXR0b24gdGlwLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtsYWJlbD0naSddIFRleHQgbGFiZWwgdG8gdXNlIGZvciB0aGVcbiAqIGNvbGxhcHNlZCBhdHRyaWJ1dGlvbnMgYnV0dG9uLlxuICogSW5zdGVhZCBvZiB0ZXh0LCBhbHNvIGFuIGVsZW1lbnQgKGUuZy4gYSBgc3BhbmAgZWxlbWVudCkgY2FuIGJlIHVzZWQuXG4gKiBAcHJvcGVydHkge3N0cmluZ3xIVE1MRWxlbWVudH0gW2NvbGxhcHNlTGFiZWw9J8K7J10gVGV4dCBsYWJlbCB0byB1c2VcbiAqIGZvciB0aGUgZXhwYW5kZWQgYXR0cmlidXRpb25zIGJ1dHRvbi5cbiAqIEluc3RlYWQgb2YgdGV4dCwgYWxzbyBhbiBlbGVtZW50IChlLmcuIGEgYHNwYW5gIGVsZW1lbnQpIGNhbiBiZSB1c2VkLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbihpbXBvcnQoXCIuLi9NYXBFdmVudC5qc1wiKS5kZWZhdWx0KX0gW3JlbmRlcl0gRnVuY3Rpb24gY2FsbGVkIHdoZW5cbiAqIHRoZSBjb250cm9sIHNob3VsZCBiZSByZS1yZW5kZXJlZC4gVGhpcyBpcyBjYWxsZWQgaW4gYSBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYFxuICogY2FsbGJhY2suXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIENvbnRyb2wgdG8gc2hvdyBhbGwgdGhlIGF0dHJpYnV0aW9ucyBhc3NvY2lhdGVkIHdpdGggdGhlIGxheWVyIHNvdXJjZXNcbiAqIGluIHRoZSBtYXAuIFRoaXMgY29udHJvbCBpcyBvbmUgb2YgdGhlIGRlZmF1bHQgY29udHJvbHMgaW5jbHVkZWQgaW4gbWFwcy5cbiAqIEJ5IGRlZmF1bHQgaXQgd2lsbCBzaG93IGluIHRoZSBib3R0b20gcmlnaHQgcG9ydGlvbiBvZiB0aGUgbWFwLCBidXQgdGhpcyBjYW5cbiAqIGJlIGNoYW5nZWQgYnkgdXNpbmcgYSBjc3Mgc2VsZWN0b3IgZm9yIGAub2wtYXR0cmlidXRpb25gLlxuICpcbiAqIEBhcGlcbiAqL1xudmFyIEF0dHJpYnV0aW9uID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoQ29udHJvbCkge1xuICBmdW5jdGlvbiBBdHRyaWJ1dGlvbihvcHRfb3B0aW9ucykge1xuXG4gICAgdmFyIG9wdGlvbnMgPSBvcHRfb3B0aW9ucyA/IG9wdF9vcHRpb25zIDoge307XG5cbiAgICBDb250cm9sLmNhbGwodGhpcywge1xuICAgICAgZWxlbWVudDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICByZW5kZXI6IG9wdGlvbnMucmVuZGVyIHx8IHJlbmRlcixcbiAgICAgIHRhcmdldDogb3B0aW9ucy50YXJnZXRcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMudWxFbGVtZW50XyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuY29sbGFwc2VkXyA9IG9wdGlvbnMuY29sbGFwc2VkICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNvbGxhcHNlZCA6IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMub3ZlcnJpZGVDb2xsYXBzaWJsZV8gPSBvcHRpb25zLmNvbGxhcHNpYmxlICE9PSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuY29sbGFwc2libGVfID0gb3B0aW9ucy5jb2xsYXBzaWJsZSAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdGlvbnMuY29sbGFwc2libGUgOiB0cnVlO1xuXG4gICAgaWYgKCF0aGlzLmNvbGxhcHNpYmxlXykge1xuICAgICAgdGhpcy5jb2xsYXBzZWRfID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGNsYXNzTmFtZSA9IG9wdGlvbnMuY2xhc3NOYW1lICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsYXNzTmFtZSA6ICdvbC1hdHRyaWJ1dGlvbic7XG5cbiAgICB2YXIgdGlwTGFiZWwgPSBvcHRpb25zLnRpcExhYmVsICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnRpcExhYmVsIDogJ0F0dHJpYnV0aW9ucyc7XG5cbiAgICB2YXIgY29sbGFwc2VMYWJlbCA9IG9wdGlvbnMuY29sbGFwc2VMYWJlbCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jb2xsYXBzZUxhYmVsIDogJ1xcdTAwQkInO1xuXG4gICAgaWYgKHR5cGVvZiBjb2xsYXBzZUxhYmVsID09PSAnc3RyaW5nJykge1xuICAgICAgLyoqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAgICovXG4gICAgICB0aGlzLmNvbGxhcHNlTGFiZWxfID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgdGhpcy5jb2xsYXBzZUxhYmVsXy50ZXh0Q29udGVudCA9IGNvbGxhcHNlTGFiZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29sbGFwc2VMYWJlbF8gPSBjb2xsYXBzZUxhYmVsO1xuICAgIH1cblxuICAgIHZhciBsYWJlbCA9IG9wdGlvbnMubGFiZWwgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubGFiZWwgOiAnaSc7XG5cbiAgICBpZiAodHlwZW9mIGxhYmVsID09PSAnc3RyaW5nJykge1xuICAgICAgLyoqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAgICovXG4gICAgICB0aGlzLmxhYmVsXyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgIHRoaXMubGFiZWxfLnRleHRDb250ZW50ID0gbGFiZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGFiZWxfID0gbGFiZWw7XG4gICAgfVxuXG5cbiAgICB2YXIgYWN0aXZlTGFiZWwgPSAodGhpcy5jb2xsYXBzaWJsZV8gJiYgIXRoaXMuY29sbGFwc2VkXykgP1xuICAgICAgdGhpcy5jb2xsYXBzZUxhYmVsXyA6IHRoaXMubGFiZWxfO1xuICAgIHZhciBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICBidXR0b24uc2V0QXR0cmlidXRlKCd0eXBlJywgJ2J1dHRvbicpO1xuICAgIGJ1dHRvbi50aXRsZSA9IHRpcExhYmVsO1xuICAgIGJ1dHRvbi5hcHBlbmRDaGlsZChhY3RpdmVMYWJlbCk7XG5cbiAgICBsaXN0ZW4oYnV0dG9uLCBFdmVudFR5cGUuQ0xJQ0ssIHRoaXMuaGFuZGxlQ2xpY2tfLCB0aGlzKTtcblxuICAgIHZhciBjc3NDbGFzc2VzID0gY2xhc3NOYW1lICsgJyAnICsgQ0xBU1NfVU5TRUxFQ1RBQkxFICsgJyAnICsgQ0xBU1NfQ09OVFJPTCArXG4gICAgICAgICh0aGlzLmNvbGxhcHNlZF8gJiYgdGhpcy5jb2xsYXBzaWJsZV8gPyAnICcgKyBDTEFTU19DT0xMQVBTRUQgOiAnJykgK1xuICAgICAgICAodGhpcy5jb2xsYXBzaWJsZV8gPyAnJyA6ICcgb2wtdW5jb2xsYXBzaWJsZScpO1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gY3NzQ2xhc3NlcztcbiAgICBlbGVtZW50LmFwcGVuZENoaWxkKHRoaXMudWxFbGVtZW50Xyk7XG4gICAgZWxlbWVudC5hcHBlbmRDaGlsZChidXR0b24pO1xuXG4gICAgLyoqXG4gICAgICogQSBsaXN0IG9mIGN1cnJlbnRseSByZW5kZXJlZCByZXNvbHV0aW9ucy5cbiAgICAgKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZWRBdHRyaWJ1dGlvbnNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZWRWaXNpYmxlXyA9IHRydWU7XG5cbiAgfVxuXG4gIGlmICggQ29udHJvbCApIEF0dHJpYnV0aW9uLl9fcHJvdG9fXyA9IENvbnRyb2w7XG4gIEF0dHJpYnV0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIENvbnRyb2wgJiYgQ29udHJvbC5wcm90b3R5cGUgKTtcbiAgQXR0cmlidXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQXR0cmlidXRpb247XG5cbiAgLyoqXG4gICAqIENvbGxlY3QgYSBsaXN0IG9mIHZpc2libGUgYXR0cmlidXRpb25zIGFuZCBzZXQgdGhlIGNvbGxhcHNpYmxlIHN0YXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1BsdWdnYWJsZU1hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcmV0dXJuIHtBcnJheTxzdHJpbmc+fSBBdHRyaWJ1dGlvbnMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBBdHRyaWJ1dGlvbi5wcm90b3R5cGUuY29sbGVjdFNvdXJjZUF0dHJpYnV0aW9uc18gPSBmdW5jdGlvbiBjb2xsZWN0U291cmNlQXR0cmlidXRpb25zXyAoZnJhbWVTdGF0ZSkge1xuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gZGV0ZXJtaW5lIGlmIGFuIGF0dHJpYnV0aW9uIGFscmVhZHkgZXhpc3RzLlxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgYm9vbGVhbj59XG4gICAgICovXG4gICAgdmFyIGxvb2t1cCA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQSBsaXN0IG9mIHZpc2libGUgYXR0cmlidXRpb25zLlxuICAgICAqIEB0eXBlIHtBcnJheTxzdHJpbmc+fVxuICAgICAqL1xuICAgIHZhciB2aXNpYmxlQXR0cmlidXRpb25zID0gW107XG5cbiAgICB2YXIgbGF5ZXJTdGF0ZXNBcnJheSA9IGZyYW1lU3RhdGUubGF5ZXJTdGF0ZXNBcnJheTtcbiAgICB2YXIgcmVzb2x1dGlvbiA9IGZyYW1lU3RhdGUudmlld1N0YXRlLnJlc29sdXRpb247XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gbGF5ZXJTdGF0ZXNBcnJheS5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB2YXIgbGF5ZXJTdGF0ZSA9IGxheWVyU3RhdGVzQXJyYXlbaV07XG4gICAgICBpZiAoIXZpc2libGVBdFJlc29sdXRpb24obGF5ZXJTdGF0ZSwgcmVzb2x1dGlvbikpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2UgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHR9ICovIChsYXllclN0YXRlLmxheWVyKS5nZXRTb3VyY2UoKTtcbiAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXR0cmlidXRpb25HZXR0ZXIgPSBzb3VyY2UuZ2V0QXR0cmlidXRpb25zKCk7XG4gICAgICBpZiAoIWF0dHJpYnV0aW9uR2V0dGVyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXR0cmlidXRpb25zID0gYXR0cmlidXRpb25HZXR0ZXIoZnJhbWVTdGF0ZSk7XG4gICAgICBpZiAoIWF0dHJpYnV0aW9ucykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLm92ZXJyaWRlQ29sbGFwc2libGVfICYmIHNvdXJjZS5nZXRBdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZSgpID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLnNldENvbGxhcHNpYmxlKGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXR0cmlidXRpb25zKSkge1xuICAgICAgICBmb3IgKHZhciBqID0gMCwgamogPSBhdHRyaWJ1dGlvbnMubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgICAgIGlmICghKGF0dHJpYnV0aW9uc1tqXSBpbiBsb29rdXApKSB7XG4gICAgICAgICAgICB2aXNpYmxlQXR0cmlidXRpb25zLnB1c2goYXR0cmlidXRpb25zW2pdKTtcbiAgICAgICAgICAgIGxvb2t1cFthdHRyaWJ1dGlvbnNbal1dID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghKGF0dHJpYnV0aW9ucyBpbiBsb29rdXApKSB7XG4gICAgICAgICAgdmlzaWJsZUF0dHJpYnV0aW9ucy5wdXNoKGF0dHJpYnV0aW9ucyk7XG4gICAgICAgICAgbG9va3VwW2F0dHJpYnV0aW9uc10gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2aXNpYmxlQXR0cmlidXRpb25zO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gez9pbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICovXG4gIEF0dHJpYnV0aW9uLnByb3RvdHlwZS51cGRhdGVFbGVtZW50XyA9IGZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnRfIChmcmFtZVN0YXRlKSB7XG4gICAgaWYgKCFmcmFtZVN0YXRlKSB7XG4gICAgICBpZiAodGhpcy5yZW5kZXJlZFZpc2libGVfKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLnJlbmRlcmVkVmlzaWJsZV8gPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYXR0cmlidXRpb25zID0gdGhpcy5jb2xsZWN0U291cmNlQXR0cmlidXRpb25zXyhmcmFtZVN0YXRlKTtcblxuICAgIHZhciB2aXNpYmxlID0gYXR0cmlidXRpb25zLmxlbmd0aCA+IDA7XG4gICAgaWYgKHRoaXMucmVuZGVyZWRWaXNpYmxlXyAhPSB2aXNpYmxlKSB7XG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IHZpc2libGUgPyAnJyA6ICdub25lJztcbiAgICAgIHRoaXMucmVuZGVyZWRWaXNpYmxlXyA9IHZpc2libGU7XG4gICAgfVxuXG4gICAgaWYgKGVxdWFscyhhdHRyaWJ1dGlvbnMsIHRoaXMucmVuZGVyZWRBdHRyaWJ1dGlvbnNfKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlbW92ZUNoaWxkcmVuKHRoaXMudWxFbGVtZW50Xyk7XG5cbiAgICAvLyBhcHBlbmQgdGhlIGF0dHJpYnV0aW9uc1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGF0dHJpYnV0aW9ucy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gICAgICBlbGVtZW50LmlubmVySFRNTCA9IGF0dHJpYnV0aW9uc1tpXTtcbiAgICAgIHRoaXMudWxFbGVtZW50Xy5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlcmVkQXR0cmlidXRpb25zXyA9IGF0dHJpYnV0aW9ucztcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gaGFuZGxlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBBdHRyaWJ1dGlvbi5wcm90b3R5cGUuaGFuZGxlQ2xpY2tfID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2tfIChldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy5oYW5kbGVUb2dnbGVfKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBBdHRyaWJ1dGlvbi5wcm90b3R5cGUuaGFuZGxlVG9nZ2xlXyA9IGZ1bmN0aW9uIGhhbmRsZVRvZ2dsZV8gKCkge1xuICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKENMQVNTX0NPTExBUFNFRCk7XG4gICAgaWYgKHRoaXMuY29sbGFwc2VkXykge1xuICAgICAgcmVwbGFjZU5vZGUodGhpcy5jb2xsYXBzZUxhYmVsXywgdGhpcy5sYWJlbF8pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXBsYWNlTm9kZSh0aGlzLmxhYmVsXywgdGhpcy5jb2xsYXBzZUxhYmVsXyk7XG4gICAgfVxuICAgIHRoaXMuY29sbGFwc2VkXyA9ICF0aGlzLmNvbGxhcHNlZF87XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIGF0dHJpYnV0aW9uIGlzIGNvbGxhcHNpYmxlLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgd2lkZ2V0IGlzIGNvbGxhcHNpYmxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBBdHRyaWJ1dGlvbi5wcm90b3R5cGUuZ2V0Q29sbGFwc2libGUgPSBmdW5jdGlvbiBnZXRDb2xsYXBzaWJsZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGFwc2libGVfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgd2hldGhlciB0aGUgYXR0cmlidXRpb24gc2hvdWxkIGJlIGNvbGxhcHNpYmxlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNvbGxhcHNpYmxlIFRydWUgaWYgdGhlIHdpZGdldCBpcyBjb2xsYXBzaWJsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgQXR0cmlidXRpb24ucHJvdG90eXBlLnNldENvbGxhcHNpYmxlID0gZnVuY3Rpb24gc2V0Q29sbGFwc2libGUgKGNvbGxhcHNpYmxlKSB7XG4gICAgaWYgKHRoaXMuY29sbGFwc2libGVfID09PSBjb2xsYXBzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmNvbGxhcHNpYmxlXyA9IGNvbGxhcHNpYmxlO1xuICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKCdvbC11bmNvbGxhcHNpYmxlJyk7XG4gICAgaWYgKCFjb2xsYXBzaWJsZSAmJiB0aGlzLmNvbGxhcHNlZF8pIHtcbiAgICAgIHRoaXMuaGFuZGxlVG9nZ2xlXygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ29sbGFwc2Ugb3IgZXhwYW5kIHRoZSBhdHRyaWJ1dGlvbiBhY2NvcmRpbmcgdG8gdGhlIHBhc3NlZCBwYXJhbWV0ZXIuIFdpbGxcbiAgICogbm90IGRvIGFueXRoaW5nIGlmIHRoZSBhdHRyaWJ1dGlvbiBpc24ndCBjb2xsYXBzaWJsZSBvciBpZiB0aGUgY3VycmVudFxuICAgKiBjb2xsYXBzZWQgc3RhdGUgaXMgYWxyZWFkeSB0aGUgb25lIHJlcXVlc3RlZC5cbiAgICogQHBhcmFtIHtib29sZWFufSBjb2xsYXBzZWQgVHJ1ZSBpZiB0aGUgd2lkZ2V0IGlzIGNvbGxhcHNlZC5cbiAgICogQGFwaVxuICAgKi9cbiAgQXR0cmlidXRpb24ucHJvdG90eXBlLnNldENvbGxhcHNlZCA9IGZ1bmN0aW9uIHNldENvbGxhcHNlZCAoY29sbGFwc2VkKSB7XG4gICAgaWYgKCF0aGlzLmNvbGxhcHNpYmxlXyB8fCB0aGlzLmNvbGxhcHNlZF8gPT09IGNvbGxhcHNlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmhhbmRsZVRvZ2dsZV8oKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIGB0cnVlYCB3aGVuIHRoZSBhdHRyaWJ1dGlvbiBpcyBjdXJyZW50bHkgY29sbGFwc2VkIG9yIGBmYWxzZWBcbiAgICogb3RoZXJ3aXNlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSB3aWRnZXQgaXMgY29sbGFwc2VkLlxuICAgKiBAYXBpXG4gICAqL1xuICBBdHRyaWJ1dGlvbi5wcm90b3R5cGUuZ2V0Q29sbGFwc2VkID0gZnVuY3Rpb24gZ2V0Q29sbGFwc2VkICgpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsYXBzZWRfO1xuICB9O1xuXG4gIHJldHVybiBBdHRyaWJ1dGlvbjtcbn0oQ29udHJvbCkpO1xuXG5cbi8qKlxuICogVXBkYXRlIHRoZSBhdHRyaWJ1dGlvbiBlbGVtZW50LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBFdmVudCBNYXAgZXZlbnQuXG4gKiBAdGhpcyB7QXR0cmlidXRpb259XG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXIobWFwRXZlbnQpIHtcbiAgdGhpcy51cGRhdGVFbGVtZW50XyhtYXBFdmVudC5mcmFtZVN0YXRlKTtcbn1cblxuXG5leHBvcnQgZGVmYXVsdCBBdHRyaWJ1dGlvbjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXR0cmlidXRpb24uanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2NvbnRyb2wvQ29udHJvbFxuICovXG5pbXBvcnQge1ZPSUR9IGZyb20gJy4uL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQgTWFwRXZlbnRUeXBlIGZyb20gJy4uL01hcEV2ZW50VHlwZS5qcyc7XG5pbXBvcnQgQmFzZU9iamVjdCBmcm9tICcuLi9PYmplY3QuanMnO1xuaW1wb3J0IHtyZW1vdmVOb2RlfSBmcm9tICcuLi9kb20uanMnO1xuaW1wb3J0IHtsaXN0ZW4sIHVubGlzdGVuQnlLZXl9IGZyb20gJy4uL2V2ZW50cy5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBbZWxlbWVudF0gVGhlIGVsZW1lbnQgaXMgdGhlIGNvbnRyb2wnc1xuICogY29udGFpbmVyIGVsZW1lbnQuIFRoaXMgb25seSBuZWVkcyB0byBiZSBzcGVjaWZpZWQgaWYgeW91J3JlIGRldmVsb3BpbmdcbiAqIGEgY3VzdG9tIGNvbnRyb2wuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGltcG9ydChcIi4uL01hcEV2ZW50LmpzXCIpLmRlZmF1bHQpfSBbcmVuZGVyXSBGdW5jdGlvbiBjYWxsZWQgd2hlblxuICogdGhlIGNvbnRyb2wgc2hvdWxkIGJlIHJlLXJlbmRlcmVkLiBUaGlzIGlzIGNhbGxlZCBpbiBhIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgXG4gKiBjYWxsYmFjay5cbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR8c3RyaW5nfSBbdGFyZ2V0XSBTcGVjaWZ5IGEgdGFyZ2V0IGlmIHlvdSB3YW50XG4gKiB0aGUgY29udHJvbCB0byBiZSByZW5kZXJlZCBvdXRzaWRlIG9mIHRoZSBtYXAncyB2aWV3cG9ydC5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQSBjb250cm9sIGlzIGEgdmlzaWJsZSB3aWRnZXQgd2l0aCBhIERPTSBlbGVtZW50IGluIGEgZml4ZWQgcG9zaXRpb24gb24gdGhlXG4gKiBzY3JlZW4uIFRoZXkgY2FuIGludm9sdmUgdXNlciBpbnB1dCAoYnV0dG9ucyksIG9yIGJlIGluZm9ybWF0aW9uYWwgb25seTtcbiAqIHRoZSBwb3NpdGlvbiBpcyBkZXRlcm1pbmVkIHVzaW5nIENTUy4gQnkgZGVmYXVsdCB0aGVzZSBhcmUgcGxhY2VkIGluIHRoZVxuICogY29udGFpbmVyIHdpdGggQ1NTIGNsYXNzIG5hbWUgYG9sLW92ZXJsYXljb250YWluZXItc3RvcGV2ZW50YCwgYnV0IGNhbiB1c2VcbiAqIGFueSBvdXRzaWRlIERPTSBlbGVtZW50LlxuICpcbiAqIFRoaXMgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGNvbnRyb2xzLiBZb3UgY2FuIHVzZSBpdCBmb3Igc2ltcGxlIGN1c3RvbVxuICogY29udHJvbHMgYnkgY3JlYXRpbmcgdGhlIGVsZW1lbnQgd2l0aCBsaXN0ZW5lcnMsIGNyZWF0aW5nIGFuIGluc3RhbmNlOlxuICogYGBganNcbiAqIHZhciBteUNvbnRyb2wgPSBuZXcgQ29udHJvbCh7ZWxlbWVudDogbXlFbGVtZW50fSk7XG4gKiBgYGBcbiAqIGFuZCB0aGVuIGFkZGluZyB0aGlzIHRvIHRoZSBtYXAuXG4gKlxuICogVGhlIG1haW4gYWR2YW50YWdlIG9mIGhhdmluZyB0aGlzIGFzIGEgY29udHJvbCByYXRoZXIgdGhhbiBhIHNpbXBsZSBzZXBhcmF0ZVxuICogRE9NIGVsZW1lbnQgaXMgdGhhdCBwcmV2ZW50aW5nIHByb3BhZ2F0aW9uIGlzIGhhbmRsZWQgZm9yIHlvdS4gQ29udHJvbHNcbiAqIHdpbGwgYWxzbyBiZSBvYmplY3RzIGluIGEge0BsaW5rIG1vZHVsZTpvbC9Db2xsZWN0aW9ufkNvbGxlY3Rpb259LCBzbyB5b3UgY2FuIHVzZSB0aGVpciBtZXRob2RzLlxuICpcbiAqIFlvdSBjYW4gYWxzbyBleHRlbmQgdGhpcyBiYXNlIGZvciB5b3VyIG93biBjb250cm9sIGNsYXNzLiBTZWVcbiAqIGV4YW1wbGVzL2N1c3RvbS1jb250cm9scyBmb3IgYW4gZXhhbXBsZSBvZiBob3cgdG8gZG8gdGhpcy5cbiAqXG4gKiBAYXBpXG4gKi9cbnZhciBDb250cm9sID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoQmFzZU9iamVjdCkge1xuICBmdW5jdGlvbiBDb250cm9sKG9wdGlvbnMpIHtcblxuICAgIEJhc2VPYmplY3QuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5lbGVtZW50ID0gb3B0aW9ucy5lbGVtZW50ID8gb3B0aW9ucy5lbGVtZW50IDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMudGFyZ2V0XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLm1hcF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHshQXJyYXk8aW1wb3J0KFwiLi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5saXN0ZW5lcktleXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9NYXBFdmVudC5qc1wiKS5kZWZhdWx0KX1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyID8gb3B0aW9ucy5yZW5kZXIgOiBWT0lEO1xuXG4gICAgaWYgKG9wdGlvbnMudGFyZ2V0KSB7XG4gICAgICB0aGlzLnNldFRhcmdldChvcHRpb25zLnRhcmdldCk7XG4gICAgfVxuXG4gIH1cblxuICBpZiAoIEJhc2VPYmplY3QgKSBDb250cm9sLl9fcHJvdG9fXyA9IEJhc2VPYmplY3Q7XG4gIENvbnRyb2wucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQmFzZU9iamVjdCAmJiBCYXNlT2JqZWN0LnByb3RvdHlwZSApO1xuICBDb250cm9sLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnRyb2w7XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDb250cm9sLnByb3RvdHlwZS5kaXNwb3NlSW50ZXJuYWwgPSBmdW5jdGlvbiBkaXNwb3NlSW50ZXJuYWwgKCkge1xuICAgIHJlbW92ZU5vZGUodGhpcy5lbGVtZW50KTtcbiAgICBCYXNlT2JqZWN0LnByb3RvdHlwZS5kaXNwb3NlSW50ZXJuYWwuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBtYXAgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY29udHJvbC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLmRlZmF1bHR9IE1hcC5cbiAgICogQGFwaVxuICAgKi9cbiAgQ29udHJvbC5wcm90b3R5cGUuZ2V0TWFwID0gZnVuY3Rpb24gZ2V0TWFwICgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXBfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGNvbnRyb2wgZnJvbSBpdHMgY3VycmVudCBtYXAgYW5kIGF0dGFjaCBpdCB0byB0aGUgbmV3IG1hcC5cbiAgICogU3ViY2xhc3NlcyBtYXkgc2V0IHVwIGV2ZW50IGhhbmRsZXJzIHRvIGdldCBub3RpZmllZCBhYm91dCBjaGFuZ2VzIHRvXG4gICAqIHRoZSBtYXAgaGVyZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuZGVmYXVsdH0gbWFwIE1hcC5cbiAgICogQGFwaVxuICAgKi9cbiAgQ29udHJvbC5wcm90b3R5cGUuc2V0TWFwID0gZnVuY3Rpb24gc2V0TWFwIChtYXApIHtcbiAgICBpZiAodGhpcy5tYXBfKSB7XG4gICAgICByZW1vdmVOb2RlKHRoaXMuZWxlbWVudCk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHRoaXMubGlzdGVuZXJLZXlzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIHVubGlzdGVuQnlLZXkodGhpcy5saXN0ZW5lcktleXNbaV0pO1xuICAgIH1cbiAgICB0aGlzLmxpc3RlbmVyS2V5cy5sZW5ndGggPSAwO1xuICAgIHRoaXMubWFwXyA9IG1hcDtcbiAgICBpZiAodGhpcy5tYXBfKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXRfID9cbiAgICAgICAgdGhpcy50YXJnZXRfIDogbWFwLmdldE92ZXJsYXlDb250YWluZXJTdG9wRXZlbnQoKTtcbiAgICAgIHRhcmdldC5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgICAgaWYgKHRoaXMucmVuZGVyICE9PSBWT0lEKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJLZXlzLnB1c2gobGlzdGVuKG1hcCxcbiAgICAgICAgICBNYXBFdmVudFR5cGUuUE9TVFJFTkRFUiwgdGhpcy5yZW5kZXIsIHRoaXMpKTtcbiAgICAgIH1cbiAgICAgIG1hcC5yZW5kZXIoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBzZXQgYSB0YXJnZXQgZWxlbWVudCBmb3IgdGhlIGNvbnRyb2wuIEl0IGhhcyBub1xuICAgKiBlZmZlY3QgaWYgaXQgaXMgY2FsbGVkIGFmdGVyIHRoZSBjb250cm9sIGhhcyBiZWVuIGFkZGVkIHRvIHRoZSBtYXAgKGkuZS5cbiAgICogYWZ0ZXIgYHNldE1hcGAgaXMgY2FsbGVkIG9uIHRoZSBjb250cm9sKS4gSWYgbm8gYHRhcmdldGAgaXMgc2V0IGluIHRoZVxuICAgKiBvcHRpb25zIHBhc3NlZCB0byB0aGUgY29udHJvbCBjb25zdHJ1Y3RvciBhbmQgaWYgYHNldFRhcmdldGAgaXMgbm90IGNhbGxlZFxuICAgKiB0aGVuIHRoZSBjb250cm9sIGlzIGFkZGVkIHRvIHRoZSBtYXAncyBvdmVybGF5IGNvbnRhaW5lci5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxzdHJpbmd9IHRhcmdldCBUYXJnZXQuXG4gICAqIEBhcGlcbiAgICovXG4gIENvbnRyb2wucHJvdG90eXBlLnNldFRhcmdldCA9IGZ1bmN0aW9uIHNldFRhcmdldCAodGFyZ2V0KSB7XG4gICAgdGhpcy50YXJnZXRfID0gdHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycgP1xuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGFyZ2V0KSA6XG4gICAgICB0YXJnZXQ7XG4gIH07XG5cbiAgcmV0dXJuIENvbnRyb2w7XG59KEJhc2VPYmplY3QpKTtcblxuXG5leHBvcnQgZGVmYXVsdCBDb250cm9sO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db250cm9sLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9jb250cm9sL1JvdGF0ZVxuICovXG5pbXBvcnQgQ29udHJvbCBmcm9tICcuL0NvbnRyb2wuanMnO1xuaW1wb3J0IHtDTEFTU19DT05UUk9MLCBDTEFTU19ISURERU4sIENMQVNTX1VOU0VMRUNUQUJMRX0gZnJvbSAnLi4vY3NzLmpzJztcbmltcG9ydCB7ZWFzZU91dH0gZnJvbSAnLi4vZWFzaW5nLmpzJztcbmltcG9ydCB7bGlzdGVufSBmcm9tICcuLi9ldmVudHMuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3NOYW1lPSdvbC1yb3RhdGUnXSBDU1MgY2xhc3MgbmFtZS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfEhUTUxFbGVtZW50fSBbbGFiZWw9J+KHpyddIFRleHQgbGFiZWwgdG8gdXNlIGZvciB0aGUgcm90YXRlIGJ1dHRvbi5cbiAqIEluc3RlYWQgb2YgdGV4dCwgYWxzbyBhbiBlbGVtZW50IChlLmcuIGEgYHNwYW5gIGVsZW1lbnQpIGNhbiBiZSB1c2VkLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt0aXBMYWJlbD0nUmVzZXQgcm90YXRpb24nXSBUZXh0IGxhYmVsIHRvIHVzZSBmb3IgdGhlIHJvdGF0ZSB0aXAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2R1cmF0aW9uPTI1MF0gQW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2F1dG9IaWRlPXRydWVdIEhpZGUgdGhlIGNvbnRyb2wgd2hlbiByb3RhdGlvbiBpcyAwLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbihpbXBvcnQoXCIuLi9NYXBFdmVudC5qc1wiKS5kZWZhdWx0KX0gW3JlbmRlcl0gRnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlIGNvbnRyb2wgc2hvdWxkXG4gKiBiZSByZS1yZW5kZXJlZC4gVGhpcyBpcyBjYWxsZWQgaW4gYSBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBjYWxsYmFjay5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oKX0gW3Jlc2V0Tm9ydGhdIEZ1bmN0aW9uIGNhbGxlZCB3aGVuIHRoZSBjb250cm9sIGlzIGNsaWNrZWQuXG4gKiBUaGlzIHdpbGwgb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYHJlc2V0Tm9ydGhgLlxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudHxzdHJpbmd9IFt0YXJnZXRdIFNwZWNpZnkgYSB0YXJnZXQgaWYgeW91IHdhbnQgdGhlIGNvbnRyb2wgdG8gYmVcbiAqIHJlbmRlcmVkIG91dHNpZGUgb2YgdGhlIG1hcCdzIHZpZXdwb3J0LlxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBIGJ1dHRvbiBjb250cm9sIHRvIHJlc2V0IHJvdGF0aW9uIHRvIDAuXG4gKiBUbyBzdHlsZSB0aGlzIGNvbnRyb2wgdXNlIGNzcyBzZWxlY3RvciBgLm9sLXJvdGF0ZWAuIEEgYC5vbC1oaWRkZW5gIGNzc1xuICogc2VsZWN0b3IgaXMgYWRkZWQgdG8gdGhlIGJ1dHRvbiB3aGVuIHRoZSByb3RhdGlvbiBpcyAwLlxuICpcbiAqIEBhcGlcbiAqL1xudmFyIFJvdGF0ZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKENvbnRyb2wpIHtcbiAgZnVuY3Rpb24gUm90YXRlKG9wdF9vcHRpb25zKSB7XG5cbiAgICB2YXIgb3B0aW9ucyA9IG9wdF9vcHRpb25zID8gb3B0X29wdGlvbnMgOiB7fTtcblxuICAgIENvbnRyb2wuY2FsbCh0aGlzLCB7XG4gICAgICBlbGVtZW50OiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgIHJlbmRlcjogb3B0aW9ucy5yZW5kZXIgfHwgcmVuZGVyLFxuICAgICAgdGFyZ2V0OiBvcHRpb25zLnRhcmdldFxuICAgIH0pO1xuXG4gICAgdmFyIGNsYXNzTmFtZSA9IG9wdGlvbnMuY2xhc3NOYW1lICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsYXNzTmFtZSA6ICdvbC1yb3RhdGUnO1xuXG4gICAgdmFyIGxhYmVsID0gb3B0aW9ucy5sYWJlbCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5sYWJlbCA6ICdcXHUyMUU3JztcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubGFiZWxfID0gbnVsbDtcblxuICAgIGlmICh0eXBlb2YgbGFiZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLmxhYmVsXyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgIHRoaXMubGFiZWxfLmNsYXNzTmFtZSA9ICdvbC1jb21wYXNzJztcbiAgICAgIHRoaXMubGFiZWxfLnRleHRDb250ZW50ID0gbGFiZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGFiZWxfID0gbGFiZWw7XG4gICAgICB0aGlzLmxhYmVsXy5jbGFzc0xpc3QuYWRkKCdvbC1jb21wYXNzJyk7XG4gICAgfVxuXG4gICAgdmFyIHRpcExhYmVsID0gb3B0aW9ucy50aXBMYWJlbCA/IG9wdGlvbnMudGlwTGFiZWwgOiAnUmVzZXQgcm90YXRpb24nO1xuXG4gICAgdmFyIGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgIGJ1dHRvbi5jbGFzc05hbWUgPSBjbGFzc05hbWUgKyAnLXJlc2V0JztcbiAgICBidXR0b24uc2V0QXR0cmlidXRlKCd0eXBlJywgJ2J1dHRvbicpO1xuICAgIGJ1dHRvbi50aXRsZSA9IHRpcExhYmVsO1xuICAgIGJ1dHRvbi5hcHBlbmRDaGlsZCh0aGlzLmxhYmVsXyk7XG5cbiAgICBsaXN0ZW4oYnV0dG9uLCBFdmVudFR5cGUuQ0xJQ0ssIHRoaXMuaGFuZGxlQ2xpY2tfLCB0aGlzKTtcblxuICAgIHZhciBjc3NDbGFzc2VzID0gY2xhc3NOYW1lICsgJyAnICsgQ0xBU1NfVU5TRUxFQ1RBQkxFICsgJyAnICsgQ0xBU1NfQ09OVFJPTDtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGNzc0NsYXNzZXM7XG4gICAgZWxlbWVudC5hcHBlbmRDaGlsZChidXR0b24pO1xuXG4gICAgdGhpcy5jYWxsUmVzZXROb3J0aF8gPSBvcHRpb25zLnJlc2V0Tm9ydGggPyBvcHRpb25zLnJlc2V0Tm9ydGggOiB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5kdXJhdGlvbl8gPSBvcHRpb25zLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmR1cmF0aW9uIDogMjUwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmF1dG9IaWRlXyA9IG9wdGlvbnMuYXV0b0hpZGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYXV0b0hpZGUgOiB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnJvdGF0aW9uXyA9IHVuZGVmaW5lZDtcblxuICAgIGlmICh0aGlzLmF1dG9IaWRlXykge1xuICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfSElEREVOKTtcbiAgICB9XG5cbiAgfVxuXG4gIGlmICggQ29udHJvbCApIFJvdGF0ZS5fX3Byb3RvX18gPSBDb250cm9sO1xuICBSb3RhdGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ29udHJvbCAmJiBDb250cm9sLnByb3RvdHlwZSApO1xuICBSb3RhdGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUm90YXRlO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IFRoZSBldmVudCB0byBoYW5kbGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFJvdGF0ZS5wcm90b3R5cGUuaGFuZGxlQ2xpY2tfID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2tfIChldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKHRoaXMuY2FsbFJlc2V0Tm9ydGhfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuY2FsbFJlc2V0Tm9ydGhfKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVzZXROb3J0aF8oKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBSb3RhdGUucHJvdG90eXBlLnJlc2V0Tm9ydGhfID0gZnVuY3Rpb24gcmVzZXROb3J0aF8gKCkge1xuICAgIHZhciBtYXAgPSB0aGlzLmdldE1hcCgpO1xuICAgIHZhciB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICBpZiAoIXZpZXcpIHtcbiAgICAgIC8vIHRoZSBtYXAgZG9lcyBub3QgaGF2ZSBhIHZpZXcsIHNvIHdlIGNhbid0IGFjdFxuICAgICAgLy8gdXBvbiBpdFxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodmlldy5nZXRSb3RhdGlvbigpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0aGlzLmR1cmF0aW9uXyA+IDApIHtcbiAgICAgICAgdmlldy5hbmltYXRlKHtcbiAgICAgICAgICByb3RhdGlvbjogMCxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbl8sXG4gICAgICAgICAgZWFzaW5nOiBlYXNlT3V0XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmlldy5zZXRSb3RhdGlvbigwKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFJvdGF0ZTtcbn0oQ29udHJvbCkpO1xuXG5cbi8qKlxuICogVXBkYXRlIHRoZSByb3RhdGUgY29udHJvbCBlbGVtZW50LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBFdmVudCBNYXAgZXZlbnQuXG4gKiBAdGhpcyB7Um90YXRlfVxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyKG1hcEV2ZW50KSB7XG4gIHZhciBmcmFtZVN0YXRlID0gbWFwRXZlbnQuZnJhbWVTdGF0ZTtcbiAgaWYgKCFmcmFtZVN0YXRlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciByb3RhdGlvbiA9IGZyYW1lU3RhdGUudmlld1N0YXRlLnJvdGF0aW9uO1xuICBpZiAocm90YXRpb24gIT0gdGhpcy5yb3RhdGlvbl8pIHtcbiAgICB2YXIgdHJhbnNmb3JtID0gJ3JvdGF0ZSgnICsgcm90YXRpb24gKyAncmFkKSc7XG4gICAgaWYgKHRoaXMuYXV0b0hpZGVfKSB7XG4gICAgICB2YXIgY29udGFpbnMgPSB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX0hJRERFTik7XG4gICAgICBpZiAoIWNvbnRhaW5zICYmIHJvdGF0aW9uID09PSAwKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX0hJRERFTik7XG4gICAgICB9IGVsc2UgaWYgKGNvbnRhaW5zICYmIHJvdGF0aW9uICE9PSAwKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX0hJRERFTik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubGFiZWxfLnN0eWxlLm1zVHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIHRoaXMubGFiZWxfLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICB0aGlzLmxhYmVsXy5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gIH1cbiAgdGhpcy5yb3RhdGlvbl8gPSByb3RhdGlvbjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgUm90YXRlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Sb3RhdGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2NvbnRyb2wvWm9vbVxuICovXG5pbXBvcnQge2xpc3Rlbn0gZnJvbSAnLi4vZXZlbnRzLmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgQ29udHJvbCBmcm9tICcuL0NvbnRyb2wuanMnO1xuaW1wb3J0IHtDTEFTU19DT05UUk9MLCBDTEFTU19VTlNFTEVDVEFCTEV9IGZyb20gJy4uL2Nzcy5qcyc7XG5pbXBvcnQge2Vhc2VPdXR9IGZyb20gJy4uL2Vhc2luZy5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2R1cmF0aW9uPTI1MF0gQW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3NOYW1lPSdvbC16b29tJ10gQ1NTIGNsYXNzIG5hbWUuXG4gKiBAcHJvcGVydHkge3N0cmluZ3xIVE1MRWxlbWVudH0gW3pvb21JbkxhYmVsPScrJ10gVGV4dCBsYWJlbCB0byB1c2UgZm9yIHRoZSB6b29tLWluXG4gKiBidXR0b24uIEluc3RlYWQgb2YgdGV4dCwgYWxzbyBhbiBlbGVtZW50IChlLmcuIGEgYHNwYW5gIGVsZW1lbnQpIGNhbiBiZSB1c2VkLlxuICogQHByb3BlcnR5IHtzdHJpbmd8SFRNTEVsZW1lbnR9IFt6b29tT3V0TGFiZWw9Jy0nXSBUZXh0IGxhYmVsIHRvIHVzZSBmb3IgdGhlIHpvb20tb3V0IGJ1dHRvbi5cbiAqIEluc3RlYWQgb2YgdGV4dCwgYWxzbyBhbiBlbGVtZW50IChlLmcuIGEgYHNwYW5gIGVsZW1lbnQpIGNhbiBiZSB1c2VkLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt6b29tSW5UaXBMYWJlbD0nWm9vbSBpbiddIFRleHQgbGFiZWwgdG8gdXNlIGZvciB0aGUgYnV0dG9uIHRpcC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbem9vbU91dFRpcExhYmVsPSdab29tIG91dCddIFRleHQgbGFiZWwgdG8gdXNlIGZvciB0aGUgYnV0dG9uIHRpcC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZGVsdGE9MV0gVGhlIHpvb20gZGVsdGEgYXBwbGllZCBvbiBlYWNoIGNsaWNrLlxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudHxzdHJpbmd9IFt0YXJnZXRdIFNwZWNpZnkgYSB0YXJnZXQgaWYgeW91IHdhbnQgdGhlIGNvbnRyb2wgdG8gYmVcbiAqIHJlbmRlcmVkIG91dHNpZGUgb2YgdGhlIG1hcCdzIHZpZXdwb3J0LlxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBIGNvbnRyb2wgd2l0aCAyIGJ1dHRvbnMsIG9uZSBmb3Igem9vbSBpbiBhbmQgb25lIGZvciB6b29tIG91dC5cbiAqIFRoaXMgY29udHJvbCBpcyBvbmUgb2YgdGhlIGRlZmF1bHQgY29udHJvbHMgb2YgYSBtYXAuIFRvIHN0eWxlIHRoaXMgY29udHJvbFxuICogdXNlIGNzcyBzZWxlY3RvcnMgYC5vbC16b29tLWluYCBhbmQgYC5vbC16b29tLW91dGAuXG4gKlxuICogQGFwaVxuICovXG52YXIgWm9vbSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKENvbnRyb2wpIHtcbiAgZnVuY3Rpb24gWm9vbShvcHRfb3B0aW9ucykge1xuXG4gICAgdmFyIG9wdGlvbnMgPSBvcHRfb3B0aW9ucyA/IG9wdF9vcHRpb25zIDoge307XG5cbiAgICBDb250cm9sLmNhbGwodGhpcywge1xuICAgICAgZWxlbWVudDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICB0YXJnZXQ6IG9wdGlvbnMudGFyZ2V0XG4gICAgfSk7XG5cbiAgICB2YXIgY2xhc3NOYW1lID0gb3B0aW9ucy5jbGFzc05hbWUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2xhc3NOYW1lIDogJ29sLXpvb20nO1xuXG4gICAgdmFyIGRlbHRhID0gb3B0aW9ucy5kZWx0YSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kZWx0YSA6IDE7XG5cbiAgICB2YXIgem9vbUluTGFiZWwgPSBvcHRpb25zLnpvb21JbkxhYmVsICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnpvb21JbkxhYmVsIDogJysnO1xuICAgIHZhciB6b29tT3V0TGFiZWwgPSBvcHRpb25zLnpvb21PdXRMYWJlbCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy56b29tT3V0TGFiZWwgOiAnXFx1MjIxMic7XG5cbiAgICB2YXIgem9vbUluVGlwTGFiZWwgPSBvcHRpb25zLnpvb21JblRpcExhYmVsICE9PSB1bmRlZmluZWQgP1xuICAgICAgb3B0aW9ucy56b29tSW5UaXBMYWJlbCA6ICdab29tIGluJztcbiAgICB2YXIgem9vbU91dFRpcExhYmVsID0gb3B0aW9ucy56b29tT3V0VGlwTGFiZWwgIT09IHVuZGVmaW5lZCA/XG4gICAgICBvcHRpb25zLnpvb21PdXRUaXBMYWJlbCA6ICdab29tIG91dCc7XG5cbiAgICB2YXIgaW5FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgaW5FbGVtZW50LmNsYXNzTmFtZSA9IGNsYXNzTmFtZSArICctaW4nO1xuICAgIGluRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnYnV0dG9uJyk7XG4gICAgaW5FbGVtZW50LnRpdGxlID0gem9vbUluVGlwTGFiZWw7XG4gICAgaW5FbGVtZW50LmFwcGVuZENoaWxkKFxuICAgICAgdHlwZW9mIHpvb21JbkxhYmVsID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHpvb21JbkxhYmVsKSA6IHpvb21JbkxhYmVsXG4gICAgKTtcblxuICAgIGxpc3RlbihpbkVsZW1lbnQsIEV2ZW50VHlwZS5DTElDSywgdGhpcy5oYW5kbGVDbGlja18uYmluZCh0aGlzLCBkZWx0YSkpO1xuXG4gICAgdmFyIG91dEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICBvdXRFbGVtZW50LmNsYXNzTmFtZSA9IGNsYXNzTmFtZSArICctb3V0JztcbiAgICBvdXRFbGVtZW50LnNldEF0dHJpYnV0ZSgndHlwZScsICdidXR0b24nKTtcbiAgICBvdXRFbGVtZW50LnRpdGxlID0gem9vbU91dFRpcExhYmVsO1xuICAgIG91dEVsZW1lbnQuYXBwZW5kQ2hpbGQoXG4gICAgICB0eXBlb2Ygem9vbU91dExhYmVsID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHpvb21PdXRMYWJlbCkgOiB6b29tT3V0TGFiZWxcbiAgICApO1xuXG4gICAgbGlzdGVuKG91dEVsZW1lbnQsIEV2ZW50VHlwZS5DTElDSywgdGhpcy5oYW5kbGVDbGlja18uYmluZCh0aGlzLCAtZGVsdGEpKTtcblxuICAgIHZhciBjc3NDbGFzc2VzID0gY2xhc3NOYW1lICsgJyAnICsgQ0xBU1NfVU5TRUxFQ1RBQkxFICsgJyAnICsgQ0xBU1NfQ09OVFJPTDtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGNzc0NsYXNzZXM7XG4gICAgZWxlbWVudC5hcHBlbmRDaGlsZChpbkVsZW1lbnQpO1xuICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQob3V0RWxlbWVudCk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5kdXJhdGlvbl8gPSBvcHRpb25zLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmR1cmF0aW9uIDogMjUwO1xuXG4gIH1cblxuICBpZiAoIENvbnRyb2wgKSBab29tLl9fcHJvdG9fXyA9IENvbnRyb2w7XG4gIFpvb20ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ29udHJvbCAmJiBDb250cm9sLnByb3RvdHlwZSApO1xuICBab29tLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFpvb207XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YSBab29tIGRlbHRhLlxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IFRoZSBldmVudCB0byBoYW5kbGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFpvb20ucHJvdG90eXBlLmhhbmRsZUNsaWNrXyA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrXyAoZGVsdGEsIGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLnpvb21CeURlbHRhXyhkZWx0YSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YSBab29tIGRlbHRhLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgWm9vbS5wcm90b3R5cGUuem9vbUJ5RGVsdGFfID0gZnVuY3Rpb24gem9vbUJ5RGVsdGFfIChkZWx0YSkge1xuICAgIHZhciBtYXAgPSB0aGlzLmdldE1hcCgpO1xuICAgIHZhciB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICBpZiAoIXZpZXcpIHtcbiAgICAgIC8vIHRoZSBtYXAgZG9lcyBub3QgaGF2ZSBhIHZpZXcsIHNvIHdlIGNhbid0IGFjdFxuICAgICAgLy8gdXBvbiBpdFxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY3VycmVudFJlc29sdXRpb24gPSB2aWV3LmdldFJlc29sdXRpb24oKTtcbiAgICBpZiAoY3VycmVudFJlc29sdXRpb24pIHtcbiAgICAgIHZhciBuZXdSZXNvbHV0aW9uID0gdmlldy5jb25zdHJhaW5SZXNvbHV0aW9uKGN1cnJlbnRSZXNvbHV0aW9uLCBkZWx0YSk7XG4gICAgICBpZiAodGhpcy5kdXJhdGlvbl8gPiAwKSB7XG4gICAgICAgIGlmICh2aWV3LmdldEFuaW1hdGluZygpKSB7XG4gICAgICAgICAgdmlldy5jYW5jZWxBbmltYXRpb25zKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmlldy5hbmltYXRlKHtcbiAgICAgICAgICByZXNvbHV0aW9uOiBuZXdSZXNvbHV0aW9uLFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uXyxcbiAgICAgICAgICBlYXNpbmc6IGVhc2VPdXRcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2aWV3LnNldFJlc29sdXRpb24obmV3UmVzb2x1dGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBab29tO1xufShDb250cm9sKSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgWm9vbTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Wm9vbS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvY29udHJvbC91dGlsXG4gKi9cbmltcG9ydCBDb2xsZWN0aW9uIGZyb20gJy4uL0NvbGxlY3Rpb24uanMnO1xuaW1wb3J0IEF0dHJpYnV0aW9uIGZyb20gJy4vQXR0cmlidXRpb24uanMnO1xuaW1wb3J0IFJvdGF0ZSBmcm9tICcuL1JvdGF0ZS5qcyc7XG5pbXBvcnQgWm9vbSBmcm9tICcuL1pvb20uanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRGVmYXVsdHNPcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthdHRyaWJ1dGlvbj10cnVlXSBJbmNsdWRlXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2NvbnRyb2wvQXR0cmlidXRpb25+QXR0cmlidXRpb259LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL0F0dHJpYnV0aW9uLmpzXCIpLk9wdGlvbnN9IFthdHRyaWJ1dGlvbk9wdGlvbnNdXG4gKiBPcHRpb25zIGZvciB7QGxpbmsgbW9kdWxlOm9sL2NvbnRyb2wvQXR0cmlidXRpb25+QXR0cmlidXRpb259LlxuICogQHByb3BlcnR5IHtib29sZWFufSBbcm90YXRlPXRydWVdIEluY2x1ZGVcbiAqIHtAbGluayBtb2R1bGU6b2wvY29udHJvbC9Sb3RhdGV+Um90YXRlfS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9Sb3RhdGUuanNcIikuT3B0aW9uc30gW3JvdGF0ZU9wdGlvbnNdIE9wdGlvbnNcbiAqIGZvciB7QGxpbmsgbW9kdWxlOm9sL2NvbnRyb2wvUm90YXRlflJvdGF0ZX0uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt6b29tXSBJbmNsdWRlIHtAbGluayBtb2R1bGU6b2wvY29udHJvbC9ab29tflpvb219LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL1pvb20uanNcIikuT3B0aW9uc30gW3pvb21PcHRpb25zXSBPcHRpb25zIGZvclxuICoge0BsaW5rIG1vZHVsZTpvbC9jb250cm9sL1pvb21+Wm9vbX0uXG4gKiBAYXBpXG4gKi9cblxuXG4vKipcbiAqIFNldCBvZiBjb250cm9scyBpbmNsdWRlZCBpbiBtYXBzIGJ5IGRlZmF1bHQuIFVubGVzcyBjb25maWd1cmVkIG90aGVyd2lzZSxcbiAqIHRoaXMgcmV0dXJucyBhIGNvbGxlY3Rpb24gY29udGFpbmluZyBhbiBpbnN0YW5jZSBvZiBlYWNoIG9mIHRoZSBmb2xsb3dpbmdcbiAqIGNvbnRyb2xzOlxuICogKiB7QGxpbmsgbW9kdWxlOm9sL2NvbnRyb2wvWm9vbX5ab29tfVxuICogKiB7QGxpbmsgbW9kdWxlOm9sL2NvbnRyb2wvUm90YXRlflJvdGF0ZX1cbiAqICoge0BsaW5rIG1vZHVsZTpvbC9jb250cm9sL0F0dHJpYnV0aW9ufkF0dHJpYnV0aW9ufVxuICpcbiAqIEBwYXJhbSB7RGVmYXVsdHNPcHRpb25zPX0gb3B0X29wdGlvbnNcbiAqIERlZmF1bHRzIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtDb2xsZWN0aW9uPGltcG9ydChcIi4vQ29udHJvbC5qc1wiKS5kZWZhdWx0Pn1cbiAqIENvbnRyb2xzLlxuICogQGZ1bmN0aW9uIG1vZHVsZTpvbC9jb250cm9sLmRlZmF1bHRzXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0cyhvcHRfb3B0aW9ucykge1xuXG4gIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgPyBvcHRfb3B0aW9ucyA6IHt9O1xuXG4gIHZhciBjb250cm9scyA9IG5ldyBDb2xsZWN0aW9uKCk7XG5cbiAgdmFyIHpvb21Db250cm9sID0gb3B0aW9ucy56b29tICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnpvb20gOiB0cnVlO1xuICBpZiAoem9vbUNvbnRyb2wpIHtcbiAgICBjb250cm9scy5wdXNoKG5ldyBab29tKG9wdGlvbnMuem9vbU9wdGlvbnMpKTtcbiAgfVxuXG4gIHZhciByb3RhdGVDb250cm9sID0gb3B0aW9ucy5yb3RhdGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucm90YXRlIDogdHJ1ZTtcbiAgaWYgKHJvdGF0ZUNvbnRyb2wpIHtcbiAgICBjb250cm9scy5wdXNoKG5ldyBSb3RhdGUob3B0aW9ucy5yb3RhdGVPcHRpb25zKSk7XG4gIH1cblxuICB2YXIgYXR0cmlidXRpb25Db250cm9sID0gb3B0aW9ucy5hdHRyaWJ1dGlvbiAhPT0gdW5kZWZpbmVkID9cbiAgICBvcHRpb25zLmF0dHJpYnV0aW9uIDogdHJ1ZTtcbiAgaWYgKGF0dHJpYnV0aW9uQ29udHJvbCkge1xuICAgIGNvbnRyb2xzLnB1c2gobmV3IEF0dHJpYnV0aW9uKG9wdGlvbnMuYXR0cmlidXRpb25PcHRpb25zKSk7XG4gIH1cblxuICByZXR1cm4gY29udHJvbHM7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2Nvb3JkaW5hdGVcbiAqL1xuaW1wb3J0IHttb2R1bG99IGZyb20gJy4vbWF0aC5qcyc7XG5pbXBvcnQge3BhZE51bWJlcn0gZnJvbSAnLi9zdHJpbmcuanMnO1xuXG5cbi8qKlxuICogQW4gYXJyYXkgb2YgbnVtYmVycyByZXByZXNlbnRpbmcgYW4geHkgY29vcmRpbmF0ZS4gRXhhbXBsZTogYFsxNiwgNDhdYC5cbiAqIEB0eXBlZGVmIHtBcnJheTxudW1iZXI+fSBDb29yZGluYXRlXG4gKiBAYXBpXG4gKi9cblxuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHtAbGluayBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBhbmRcbiAqIHRyYW5zZm9ybXMgaXQgaW50byBhIGB7c3RyaW5nfWAuXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKChDb29yZGluYXRlfHVuZGVmaW5lZCkpOiBzdHJpbmd9IENvb3JkaW5hdGVGb3JtYXRcbiAqIEBhcGlcbiAqL1xuXG5cbi8qKlxuICogQWRkIGBkZWx0YWAgdG8gYGNvb3JkaW5hdGVgLiBgY29vcmRpbmF0ZWAgaXMgbW9kaWZpZWQgaW4gcGxhY2UgYW5kIHJldHVybmVkXG4gKiBieSB0aGUgZnVuY3Rpb24uXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgaW1wb3J0IHthZGR9IGZyb20gJ29sL2Nvb3JkaW5hdGUnO1xuICpcbiAqICAgICB2YXIgY29vcmQgPSBbNy44NSwgNDcuOTgzMzMzXTtcbiAqICAgICBhZGQoY29vcmQsIFstMiwgNF0pO1xuICogICAgIC8vIGNvb3JkIGlzIG5vdyBbNS44NSwgNTEuOTgzMzMzXVxuICpcbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBkZWx0YSBEZWx0YS5cbiAqIEByZXR1cm4ge0Nvb3JkaW5hdGV9IFRoZSBpbnB1dCBjb29yZGluYXRlIGFkanVzdGVkIGJ5XG4gKiB0aGUgZ2l2ZW4gZGVsdGEuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGQoY29vcmRpbmF0ZSwgZGVsdGEpIHtcbiAgY29vcmRpbmF0ZVswXSArPSBkZWx0YVswXTtcbiAgY29vcmRpbmF0ZVsxXSArPSBkZWx0YVsxXTtcbiAgcmV0dXJuIGNvb3JkaW5hdGU7XG59XG5cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBwb2ludCBjbG9zZXN0IHRvIHRoZSBwYXNzZWQgY29vcmRpbmF0ZSBvbiB0aGUgcGFzc2VkIGNpcmNsZS5cbiAqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkaW5hdGUgVGhlIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZ2VvbS9DaXJjbGUuanNcIikuZGVmYXVsdH0gY2lyY2xlIFRoZSBjaXJjbGUuXG4gKiBAcmV0dXJuIHtDb29yZGluYXRlfSBDbG9zZXN0IHBvaW50IG9uIHRoZSBjaXJjdW1mZXJlbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvc2VzdE9uQ2lyY2xlKGNvb3JkaW5hdGUsIGNpcmNsZSkge1xuICB2YXIgciA9IGNpcmNsZS5nZXRSYWRpdXMoKTtcbiAgdmFyIGNlbnRlciA9IGNpcmNsZS5nZXRDZW50ZXIoKTtcbiAgdmFyIHgwID0gY2VudGVyWzBdO1xuICB2YXIgeTAgPSBjZW50ZXJbMV07XG4gIHZhciB4MSA9IGNvb3JkaW5hdGVbMF07XG4gIHZhciB5MSA9IGNvb3JkaW5hdGVbMV07XG5cbiAgdmFyIGR4ID0geDEgLSB4MDtcbiAgdmFyIGR5ID0geTEgLSB5MDtcbiAgaWYgKGR4ID09PSAwICYmIGR5ID09PSAwKSB7XG4gICAgZHggPSAxO1xuICB9XG4gIHZhciBkID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblxuICB2YXIgeCA9IHgwICsgciAqIGR4IC8gZDtcbiAgdmFyIHkgPSB5MCArIHIgKiBkeSAvIGQ7XG5cbiAgcmV0dXJuIFt4LCB5XTtcbn1cblxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHBvaW50IGNsb3Nlc3QgdG8gdGhlIHBhc3NlZCBjb29yZGluYXRlIG9uIHRoZSBwYXNzZWQgc2VnbWVudC5cbiAqIFRoaXMgaXMgdGhlIGZvb3Qgb2YgdGhlIHBlcnBlbmRpY3VsYXIgb2YgdGhlIGNvb3JkaW5hdGUgdG8gdGhlIHNlZ21lbnQgd2hlblxuICogdGhlIGZvb3QgaXMgb24gdGhlIHNlZ21lbnQsIG9yIHRoZSBjbG9zZXN0IHNlZ21lbnQgY29vcmRpbmF0ZSB3aGVuIHRoZSBmb290XG4gKiBpcyBvdXRzaWRlIHRoZSBzZWdtZW50LlxuICpcbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBUaGUgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7QXJyYXk8Q29vcmRpbmF0ZT59IHNlZ21lbnQgVGhlIHR3byBjb29yZGluYXRlc1xuICogb2YgdGhlIHNlZ21lbnQuXG4gKiBAcmV0dXJuIHtDb29yZGluYXRlfSBUaGUgZm9vdCBvZiB0aGUgcGVycGVuZGljdWxhciBvZlxuICogdGhlIGNvb3JkaW5hdGUgdG8gdGhlIHNlZ21lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9zZXN0T25TZWdtZW50KGNvb3JkaW5hdGUsIHNlZ21lbnQpIHtcbiAgdmFyIHgwID0gY29vcmRpbmF0ZVswXTtcbiAgdmFyIHkwID0gY29vcmRpbmF0ZVsxXTtcbiAgdmFyIHN0YXJ0ID0gc2VnbWVudFswXTtcbiAgdmFyIGVuZCA9IHNlZ21lbnRbMV07XG4gIHZhciB4MSA9IHN0YXJ0WzBdO1xuICB2YXIgeTEgPSBzdGFydFsxXTtcbiAgdmFyIHgyID0gZW5kWzBdO1xuICB2YXIgeTIgPSBlbmRbMV07XG4gIHZhciBkeCA9IHgyIC0geDE7XG4gIHZhciBkeSA9IHkyIC0geTE7XG4gIHZhciBhbG9uZyA9IChkeCA9PT0gMCAmJiBkeSA9PT0gMCkgPyAwIDpcbiAgICAoKGR4ICogKHgwIC0geDEpKSArIChkeSAqICh5MCAtIHkxKSkpIC8gKChkeCAqIGR4ICsgZHkgKiBkeSkgfHwgMCk7XG4gIHZhciB4LCB5O1xuICBpZiAoYWxvbmcgPD0gMCkge1xuICAgIHggPSB4MTtcbiAgICB5ID0geTE7XG4gIH0gZWxzZSBpZiAoYWxvbmcgPj0gMSkge1xuICAgIHggPSB4MjtcbiAgICB5ID0geTI7XG4gIH0gZWxzZSB7XG4gICAgeCA9IHgxICsgYWxvbmcgKiBkeDtcbiAgICB5ID0geTEgKyBhbG9uZyAqIGR5O1xuICB9XG4gIHJldHVybiBbeCwgeV07XG59XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEge0BsaW5rIG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGVGb3JtYXR9IGZ1bmN0aW9uIHRoYXQgY2FuIGJlXG4gKiB1c2VkIHRvIGZvcm1hdFxuICogYSB7Q29vcmRpbmF0ZX0gdG8gYSBzdHJpbmcuXG4gKlxuICogRXhhbXBsZSB3aXRob3V0IHNwZWNpZnlpbmcgdGhlIGZyYWN0aW9uYWwgZGlnaXRzOlxuICpcbiAqICAgICBpbXBvcnQge2NyZWF0ZVN0cmluZ1hZfSBmcm9tICdvbC9jb29yZGluYXRlJztcbiAqXG4gKiAgICAgdmFyIGNvb3JkID0gWzcuODUsIDQ3Ljk4MzMzM107XG4gKiAgICAgdmFyIHN0cmluZ2lmeUZ1bmMgPSBjcmVhdGVTdHJpbmdYWSgpO1xuICogICAgIHZhciBvdXQgPSBzdHJpbmdpZnlGdW5jKGNvb3JkKTtcbiAqICAgICAvLyBvdXQgaXMgbm93ICc4LCA0OCdcbiAqXG4gKiBFeGFtcGxlIHdpdGggZXhwbGljaXRseSBzcGVjaWZ5aW5nIDIgZnJhY3Rpb25hbCBkaWdpdHM6XG4gKlxuICogICAgIGltcG9ydCB7Y3JlYXRlU3RyaW5nWFl9IGZyb20gJ29sL2Nvb3JkaW5hdGUnO1xuICpcbiAqICAgICB2YXIgY29vcmQgPSBbNy44NSwgNDcuOTgzMzMzXTtcbiAqICAgICB2YXIgc3RyaW5naWZ5RnVuYyA9IGNyZWF0ZVN0cmluZ1hZKDIpO1xuICogICAgIHZhciBvdXQgPSBzdHJpbmdpZnlGdW5jKGNvb3JkKTtcbiAqICAgICAvLyBvdXQgaXMgbm93ICc3Ljg1LCA0Ny45OCdcbiAqXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9mcmFjdGlvbkRpZ2l0cyBUaGUgbnVtYmVyIG9mIGRpZ2l0cyB0byBpbmNsdWRlXG4gKiAgICBhZnRlciB0aGUgZGVjaW1hbCBwb2ludC4gRGVmYXVsdCBpcyBgMGAuXG4gKiBAcmV0dXJuIHtDb29yZGluYXRlRm9ybWF0fSBDb29yZGluYXRlIGZvcm1hdC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN0cmluZ1hZKG9wdF9mcmFjdGlvbkRpZ2l0cykge1xuICByZXR1cm4gKFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gU3RyaW5nIFhZLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uKGNvb3JkaW5hdGUpIHtcbiAgICAgIHJldHVybiB0b1N0cmluZ1hZKGNvb3JkaW5hdGUsIG9wdF9mcmFjdGlvbkRpZ2l0cyk7XG4gICAgfVxuICApO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGhlbWlzcGhlcmVzIEhlbWlzcGhlcmVzLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlZ3JlZXMgRGVncmVlcy5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2ZyYWN0aW9uRGlnaXRzIFRoZSBudW1iZXIgb2YgZGlnaXRzIHRvIGluY2x1ZGVcbiAqICAgIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50LiBEZWZhdWx0IGlzIGAwYC5cbiAqIEByZXR1cm4ge3N0cmluZ30gU3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVncmVlc1RvU3RyaW5nSERNUyhoZW1pc3BoZXJlcywgZGVncmVlcywgb3B0X2ZyYWN0aW9uRGlnaXRzKSB7XG4gIHZhciBub3JtYWxpemVkRGVncmVlcyA9IG1vZHVsbyhkZWdyZWVzICsgMTgwLCAzNjApIC0gMTgwO1xuICB2YXIgeCA9IE1hdGguYWJzKDM2MDAgKiBub3JtYWxpemVkRGVncmVlcyk7XG4gIHZhciBkZmxQcmVjaXNpb24gPSBvcHRfZnJhY3Rpb25EaWdpdHMgfHwgMDtcbiAgdmFyIHByZWNpc2lvbiA9IE1hdGgucG93KDEwLCBkZmxQcmVjaXNpb24pO1xuXG4gIHZhciBkZWcgPSBNYXRoLmZsb29yKHggLyAzNjAwKTtcbiAgdmFyIG1pbiA9IE1hdGguZmxvb3IoKHggLSBkZWcgKiAzNjAwKSAvIDYwKTtcbiAgdmFyIHNlYyA9IHggLSAoZGVnICogMzYwMCkgLSAobWluICogNjApO1xuICBzZWMgPSBNYXRoLmNlaWwoc2VjICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbjtcblxuICBpZiAoc2VjID49IDYwKSB7XG4gICAgc2VjID0gMDtcbiAgICBtaW4gKz0gMTtcbiAgfVxuXG4gIGlmIChtaW4gPj0gNjApIHtcbiAgICBtaW4gPSAwO1xuICAgIGRlZyArPSAxO1xuICB9XG5cbiAgcmV0dXJuIGRlZyArICdcXHUwMGIwICcgKyBwYWROdW1iZXIobWluLCAyKSArICdcXHUyMDMyICcgK1xuICAgIHBhZE51bWJlcihzZWMsIDIsIGRmbFByZWNpc2lvbikgKyAnXFx1MjAzMycgK1xuICAgIChub3JtYWxpemVkRGVncmVlcyA9PSAwID8gJycgOiAnICcgKyBoZW1pc3BoZXJlcy5jaGFyQXQobm9ybWFsaXplZERlZ3JlZXMgPCAwID8gMSA6IDApKTtcbn1cblxuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIGdpdmVuIHtAbGluayBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSB0byBhIHN0cmluZ1xuICogdXNpbmcgdGhlIGdpdmVuIHN0cmluZyB0ZW1wbGF0ZS4gVGhlIHN0cmluZ3MgYHt4fWAgYW5kIGB7eX1gIGluIHRoZSB0ZW1wbGF0ZVxuICogd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoZSBmaXJzdCBhbmQgc2Vjb25kIGNvb3JkaW5hdGUgdmFsdWVzIHJlc3BlY3RpdmVseS5cbiAqXG4gKiBFeGFtcGxlIHdpdGhvdXQgc3BlY2lmeWluZyB0aGUgZnJhY3Rpb25hbCBkaWdpdHM6XG4gKlxuICogICAgIGltcG9ydCB7Zm9ybWF0fSBmcm9tICdvbC9jb29yZGluYXRlJztcbiAqXG4gKiAgICAgdmFyIGNvb3JkID0gWzcuODUsIDQ3Ljk4MzMzM107XG4gKiAgICAgdmFyIHRlbXBsYXRlID0gJ0Nvb3JkaW5hdGUgaXMgKHt4fXx7eX0pLic7XG4gKiAgICAgdmFyIG91dCA9IGZvcm1hdChjb29yZCwgdGVtcGxhdGUpO1xuICogICAgIC8vIG91dCBpcyBub3cgJ0Nvb3JkaW5hdGUgaXMgKDh8NDgpLidcbiAqXG4gKiBFeGFtcGxlIGV4cGxpY2l0bHkgc3BlY2lmeWluZyB0aGUgZnJhY3Rpb25hbCBkaWdpdHM6XG4gKlxuICogICAgIGltcG9ydCB7Zm9ybWF0fSBmcm9tICdvbC9jb29yZGluYXRlJztcbiAqXG4gKiAgICAgdmFyIGNvb3JkID0gWzcuODUsIDQ3Ljk4MzMzM107XG4gKiAgICAgdmFyIHRlbXBsYXRlID0gJ0Nvb3JkaW5hdGUgaXMgKHt4fXx7eX0pLic7XG4gKiAgICAgdmFyIG91dCA9IGZvcm1hdChjb29yZCwgdGVtcGxhdGUsIDIpO1xuICogICAgIC8vIG91dCBpcyBub3cgJ0Nvb3JkaW5hdGUgaXMgKDcuODV8NDcuOTgpLidcbiAqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZW1wbGF0ZSBBIHRlbXBsYXRlIHN0cmluZyB3aXRoIGB7eH1gIGFuZCBge3l9YCBwbGFjZWhvbGRlcnNcbiAqICAgICB0aGF0IHdpbGwgYmUgcmVwbGFjZWQgYnkgZmlyc3QgYW5kIHNlY29uZCBjb29yZGluYXRlIHZhbHVlcy5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2ZyYWN0aW9uRGlnaXRzIFRoZSBudW1iZXIgb2YgZGlnaXRzIHRvIGluY2x1ZGVcbiAqICAgIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50LiBEZWZhdWx0IGlzIGAwYC5cbiAqIEByZXR1cm4ge3N0cmluZ30gRm9ybWF0dGVkIGNvb3JkaW5hdGUuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXQoY29vcmRpbmF0ZSwgdGVtcGxhdGUsIG9wdF9mcmFjdGlvbkRpZ2l0cykge1xuICBpZiAoY29vcmRpbmF0ZSkge1xuICAgIHJldHVybiB0ZW1wbGF0ZVxuICAgICAgLnJlcGxhY2UoJ3t4fScsIGNvb3JkaW5hdGVbMF0udG9GaXhlZChvcHRfZnJhY3Rpb25EaWdpdHMpKVxuICAgICAgLnJlcGxhY2UoJ3t5fScsIGNvb3JkaW5hdGVbMV0udG9GaXhlZChvcHRfZnJhY3Rpb25EaWdpdHMpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZTEgRmlyc3QgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZTIgU2Vjb25kIGNvb3JkaW5hdGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgdHdvIGNvb3JkaW5hdGVzIGFyZSBlcXVhbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhjb29yZGluYXRlMSwgY29vcmRpbmF0ZTIpIHtcbiAgdmFyIGVxdWFscyA9IHRydWU7XG4gIGZvciAodmFyIGkgPSBjb29yZGluYXRlMS5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIGlmIChjb29yZGluYXRlMVtpXSAhPSBjb29yZGluYXRlMltpXSkge1xuICAgICAgZXF1YWxzID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVxdWFscztcbn1cblxuXG4vKipcbiAqIFJvdGF0ZSBgY29vcmRpbmF0ZWAgYnkgYGFuZ2xlYC4gYGNvb3JkaW5hdGVgIGlzIG1vZGlmaWVkIGluIHBsYWNlIGFuZFxuICogcmV0dXJuZWQgYnkgdGhlIGZ1bmN0aW9uLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIGltcG9ydCB7cm90YXRlfSBmcm9tICdvbC9jb29yZGluYXRlJztcbiAqXG4gKiAgICAgdmFyIGNvb3JkID0gWzcuODUsIDQ3Ljk4MzMzM107XG4gKiAgICAgdmFyIHJvdGF0ZVJhZGlhbnMgPSBNYXRoLlBJIC8gMjsgLy8gOTAgZGVncmVlc1xuICogICAgIHJvdGF0ZShjb29yZCwgcm90YXRlUmFkaWFucyk7XG4gKiAgICAgLy8gY29vcmQgaXMgbm93IFstNDcuOTgzMzMzLCA3Ljg1XVxuICpcbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlIEFuZ2xlIGluIHJhZGlhbi5cbiAqIEByZXR1cm4ge0Nvb3JkaW5hdGV9IENvb3JkaW5hdGUuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGUoY29vcmRpbmF0ZSwgYW5nbGUpIHtcbiAgdmFyIGNvc0FuZ2xlID0gTWF0aC5jb3MoYW5nbGUpO1xuICB2YXIgc2luQW5nbGUgPSBNYXRoLnNpbihhbmdsZSk7XG4gIHZhciB4ID0gY29vcmRpbmF0ZVswXSAqIGNvc0FuZ2xlIC0gY29vcmRpbmF0ZVsxXSAqIHNpbkFuZ2xlO1xuICB2YXIgeSA9IGNvb3JkaW5hdGVbMV0gKiBjb3NBbmdsZSArIGNvb3JkaW5hdGVbMF0gKiBzaW5BbmdsZTtcbiAgY29vcmRpbmF0ZVswXSA9IHg7XG4gIGNvb3JkaW5hdGVbMV0gPSB5O1xuICByZXR1cm4gY29vcmRpbmF0ZTtcbn1cblxuXG4vKipcbiAqIFNjYWxlIGBjb29yZGluYXRlYCBieSBgc2NhbGVgLiBgY29vcmRpbmF0ZWAgaXMgbW9kaWZpZWQgaW4gcGxhY2UgYW5kIHJldHVybmVkXG4gKiBieSB0aGUgZnVuY3Rpb24uXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgaW1wb3J0IHtzY2FsZSBhcyBzY2FsZUNvb3JkaW5hdGV9IGZyb20gJ29sL2Nvb3JkaW5hdGUnO1xuICpcbiAqICAgICB2YXIgY29vcmQgPSBbNy44NSwgNDcuOTgzMzMzXTtcbiAqICAgICB2YXIgc2NhbGUgPSAxLjI7XG4gKiAgICAgc2NhbGVDb29yZGluYXRlKGNvb3JkLCBzY2FsZSk7XG4gKiAgICAgLy8gY29vcmQgaXMgbm93IFs5LjQyLCA1Ny41Nzk5OTk2XVxuICpcbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlIFNjYWxlIGZhY3Rvci5cbiAqIEByZXR1cm4ge0Nvb3JkaW5hdGV9IENvb3JkaW5hdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShjb29yZGluYXRlLCBzY2FsZSkge1xuICBjb29yZGluYXRlWzBdICo9IHNjYWxlO1xuICBjb29yZGluYXRlWzFdICo9IHNjYWxlO1xuICByZXR1cm4gY29vcmRpbmF0ZTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmQxIEZpcnN0IGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkMiBTZWNvbmQgY29vcmRpbmF0ZS5cbiAqIEByZXR1cm4ge251bWJlcn0gU3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGNvb3JkMSBhbmQgY29vcmQyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZERpc3RhbmNlKGNvb3JkMSwgY29vcmQyKSB7XG4gIHZhciBkeCA9IGNvb3JkMVswXSAtIGNvb3JkMlswXTtcbiAgdmFyIGR5ID0gY29vcmQxWzFdIC0gY29vcmQyWzFdO1xuICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkMSBGaXJzdCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZDIgU2Vjb25kIGNvb3JkaW5hdGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IERpc3RhbmNlIGJldHdlZW4gY29vcmQxIGFuZCBjb29yZDIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZShjb29yZDEsIGNvb3JkMikge1xuICByZXR1cm4gTWF0aC5zcXJ0KHNxdWFyZWREaXN0YW5jZShjb29yZDEsIGNvb3JkMikpO1xufVxuXG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBzcXVhcmVkIGRpc3RhbmNlIGZyb20gYSBjb29yZGluYXRlIHRvIGEgbGluZSBzZWdtZW50LlxuICpcbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlIG9mIHRoZSBwb2ludC5cbiAqIEBwYXJhbSB7QXJyYXk8Q29vcmRpbmF0ZT59IHNlZ21lbnQgTGluZSBzZWdtZW50ICgyXG4gKiBjb29yZGluYXRlcykuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFNxdWFyZWQgZGlzdGFuY2UgZnJvbSB0aGUgcG9pbnQgdG8gdGhlIGxpbmUgc2VnbWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZVRvU2VnbWVudChjb29yZGluYXRlLCBzZWdtZW50KSB7XG4gIHJldHVybiBzcXVhcmVkRGlzdGFuY2UoY29vcmRpbmF0ZSxcbiAgICBjbG9zZXN0T25TZWdtZW50KGNvb3JkaW5hdGUsIHNlZ21lbnQpKTtcbn1cblxuXG4vKipcbiAqIEZvcm1hdCBhIGdlb2dyYXBoaWMgY29vcmRpbmF0ZSB3aXRoIHRoZSBoZW1pc3BoZXJlLCBkZWdyZWVzLCBtaW51dGVzLCBhbmRcbiAqIHNlY29uZHMuXG4gKlxuICogRXhhbXBsZSB3aXRob3V0IHNwZWNpZnlpbmcgZnJhY3Rpb25hbCBkaWdpdHM6XG4gKlxuICogICAgIGltcG9ydCB7dG9TdHJpbmdIRE1TfSBmcm9tICdvbC9jb29yZGluYXRlJztcbiAqXG4gKiAgICAgdmFyIGNvb3JkID0gWzcuODUsIDQ3Ljk4MzMzM107XG4gKiAgICAgdmFyIG91dCA9IHRvU3RyaW5nSERNUyhjb29yZCk7XG4gKiAgICAgLy8gb3V0IGlzIG5vdyAnNDfCsCA1OOKAsiA2MOKAsyBOIDfCsCA1MOKAsiA2MOKAsyBFJ1xuICpcbiAqIEV4YW1wbGUgZXhwbGljaXRseSBzcGVjaWZ5aW5nIDEgZnJhY3Rpb25hbCBkaWdpdDpcbiAqXG4gKiAgICAgaW1wb3J0IHt0b1N0cmluZ0hETVN9IGZyb20gJ29sL2Nvb3JkaW5hdGUnO1xuICpcbiAqICAgICB2YXIgY29vcmQgPSBbNy44NSwgNDcuOTgzMzMzXTtcbiAqICAgICB2YXIgb3V0ID0gdG9TdHJpbmdIRE1TKGNvb3JkLCAxKTtcbiAqICAgICAvLyBvdXQgaXMgbm93ICc0N8KwIDU44oCyIDYwLjDigLMgTiA3wrAgNTDigLIgNjAuMOKAsyBFJ1xuICpcbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZnJhY3Rpb25EaWdpdHMgVGhlIG51bWJlciBvZiBkaWdpdHMgdG8gaW5jbHVkZVxuICogICAgYWZ0ZXIgdGhlIGRlY2ltYWwgcG9pbnQuIERlZmF1bHQgaXMgYDBgLlxuICogQHJldHVybiB7c3RyaW5nfSBIZW1pc3BoZXJlLCBkZWdyZWVzLCBtaW51dGVzIGFuZCBzZWNvbmRzLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9TdHJpbmdIRE1TKGNvb3JkaW5hdGUsIG9wdF9mcmFjdGlvbkRpZ2l0cykge1xuICBpZiAoY29vcmRpbmF0ZSkge1xuICAgIHJldHVybiBkZWdyZWVzVG9TdHJpbmdIRE1TKCdOUycsIGNvb3JkaW5hdGVbMV0sIG9wdF9mcmFjdGlvbkRpZ2l0cykgKyAnICcgK1xuICAgICAgICBkZWdyZWVzVG9TdHJpbmdIRE1TKCdFVycsIGNvb3JkaW5hdGVbMF0sIG9wdF9mcmFjdGlvbkRpZ2l0cyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cblxuLyoqXG4gKiBGb3JtYXQgYSBjb29yZGluYXRlIGFzIGEgY29tbWEgZGVsaW1pdGVkIHN0cmluZy5cbiAqXG4gKiBFeGFtcGxlIHdpdGhvdXQgc3BlY2lmeWluZyBmcmFjdGlvbmFsIGRpZ2l0czpcbiAqXG4gKiAgICAgaW1wb3J0IHt0b1N0cmluZ1hZfSBmcm9tICdvbC9jb29yZGluYXRlJztcbiAqXG4gKiAgICAgdmFyIGNvb3JkID0gWzcuODUsIDQ3Ljk4MzMzM107XG4gKiAgICAgdmFyIG91dCA9IHRvU3RyaW5nWFkoY29vcmQpO1xuICogICAgIC8vIG91dCBpcyBub3cgJzgsIDQ4J1xuICpcbiAqIEV4YW1wbGUgZXhwbGljaXRseSBzcGVjaWZ5aW5nIDEgZnJhY3Rpb25hbCBkaWdpdDpcbiAqXG4gKiAgICAgaW1wb3J0IHt0b1N0cmluZ1hZfSBmcm9tICdvbC9jb29yZGluYXRlJztcbiAqXG4gKiAgICAgdmFyIGNvb3JkID0gWzcuODUsIDQ3Ljk4MzMzM107XG4gKiAgICAgdmFyIG91dCA9IHRvU3RyaW5nWFkoY29vcmQsIDEpO1xuICogICAgIC8vIG91dCBpcyBub3cgJzcuOCwgNDguMCdcbiAqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2ZyYWN0aW9uRGlnaXRzIFRoZSBudW1iZXIgb2YgZGlnaXRzIHRvIGluY2x1ZGVcbiAqICAgIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50LiBEZWZhdWx0IGlzIGAwYC5cbiAqIEByZXR1cm4ge3N0cmluZ30gWFkuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1N0cmluZ1hZKGNvb3JkaW5hdGUsIG9wdF9mcmFjdGlvbkRpZ2l0cykge1xuICByZXR1cm4gZm9ybWF0KGNvb3JkaW5hdGUsICd7eH0sIHt5fScsIG9wdF9mcmFjdGlvbkRpZ2l0cyk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvb3JkaW5hdGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2Nzc1xuICovXG5cblxuLyoqXG4gKiBUaGUgQ1NTIGNsYXNzIGZvciBoaWRkZW4gZmVhdHVyZS5cbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCB2YXIgQ0xBU1NfSElEREVOID0gJ29sLWhpZGRlbic7XG5cblxuLyoqXG4gKiBUaGUgQ1NTIGNsYXNzIHRoYXQgd2UnbGwgZ2l2ZSB0aGUgRE9NIGVsZW1lbnRzIHRvIGhhdmUgdGhlbSBzZWxlY3RhYmxlLlxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IHZhciBDTEFTU19TRUxFQ1RBQkxFID0gJ29sLXNlbGVjdGFibGUnO1xuXG5cbi8qKlxuICogVGhlIENTUyBjbGFzcyB0aGF0IHdlJ2xsIGdpdmUgdGhlIERPTSBlbGVtZW50cyB0byBoYXZlIHRoZW0gdW5zZWxlY3RhYmxlLlxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IHZhciBDTEFTU19VTlNFTEVDVEFCTEUgPSAnb2wtdW5zZWxlY3RhYmxlJztcblxuXG4vKipcbiAqIFRoZSBDU1MgY2xhc3MgZm9yIHVuc3VwcG9ydGVkIGZlYXR1cmUuXG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgdmFyIENMQVNTX1VOU1VQUE9SVEVEID0gJ29sLXVuc3VwcG9ydGVkJztcblxuXG4vKipcbiAqIFRoZSBDU1MgY2xhc3MgZm9yIGNvbnRyb2xzLlxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IHZhciBDTEFTU19DT05UUk9MID0gJ29sLWNvbnRyb2wnO1xuXG5cbi8qKlxuICogVGhlIENTUyBjbGFzcyB0aGF0IHdlJ2xsIGdpdmUgdGhlIERPTSBlbGVtZW50cyB0aGF0IGFyZSBjb2xsYXBzZWQsIGkuZS5cbiAqIHRvIHRob3NlIGVsZW1lbnRzIHdoaWNoIHVzdWFsbHkgY2FuIGJlIGV4cGFuZGVkLlxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IHZhciBDTEFTU19DT0xMQVBTRUQgPSAnb2wtY29sbGFwc2VkJztcblxuXG4vKipcbiAqIEdldCB0aGUgbGlzdCBvZiBmb250IGZhbWlsaWVzIGZyb20gYSBmb250IHNwZWMuICBOb3RlIHRoYXQgdGhpcyBkb2Vzbid0IHdvcmtcbiAqIGZvciBmb250IGZhbWlsaWVzIHRoYXQgaGF2ZSBjb21tYXMgaW4gdGhlbS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBUaGUgQ1NTIGZvbnQgcHJvcGVydHkuXG4gKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nPn0gVGhlIGZvbnQgZmFtaWxpZXMgKG9yIG51bGwgaWYgdGhlIGlucHV0IHNwZWMgaXMgaW52YWxpZCkuXG4gKi9cbmV4cG9ydCB2YXIgZ2V0Rm9udEZhbWlsaWVzID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgc3R5bGU7XG4gIHZhciBjYWNoZSA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb24oZm9udCkge1xuICAgIGlmICghc3R5bGUpIHtcbiAgICAgIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG4gICAgfVxuICAgIGlmICghKGZvbnQgaW4gY2FjaGUpKSB7XG4gICAgICBzdHlsZS5mb250ID0gZm9udDtcbiAgICAgIHZhciBmYW1pbHkgPSBzdHlsZS5mb250RmFtaWx5O1xuICAgICAgc3R5bGUuZm9udCA9ICcnO1xuICAgICAgaWYgKCFmYW1pbHkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjYWNoZVtmb250XSA9IGZhbWlseS5zcGxpdCgvLFxccz8vKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlW2ZvbnRdO1xuICB9O1xufSkoKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3NzLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9kb21cbiAqL1xuXG5cbi8qKlxuICogQ3JlYXRlIGFuIGh0bWwgY2FudmFzIGVsZW1lbnQgYW5kIHJldHVybnMgaXRzIDJkIGNvbnRleHQuXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF93aWR0aCBDYW52YXMgd2lkdGguXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9oZWlnaHQgQ2FudmFzIGhlaWdodC5cbiAqIEByZXR1cm4ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gVGhlIGNvbnRleHQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDYW52YXNDb250ZXh0MkQob3B0X3dpZHRoLCBvcHRfaGVpZ2h0KSB7XG4gIHZhciBjYW52YXMgPSAvKiogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fSAqLyAoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykpO1xuICBpZiAob3B0X3dpZHRoKSB7XG4gICAgY2FudmFzLndpZHRoID0gb3B0X3dpZHRoO1xuICB9XG4gIGlmIChvcHRfaGVpZ2h0KSB7XG4gICAgY2FudmFzLmhlaWdodCA9IG9wdF9oZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIC8qKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAqLyAoY2FudmFzLmdldENvbnRleHQoJzJkJykpO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IGNvbXB1dGVkIHdpZHRoIGZvciB0aGUgZ2l2ZW4gZWxlbWVudCBpbmNsdWRpbmcgbWFyZ2luLFxuICogcGFkZGluZyBhbmQgYm9yZGVyLlxuICogRXF1aXZhbGVudCB0byBqUXVlcnkncyBgJChlbCkub3V0ZXJXaWR0aCh0cnVlKWAuXG4gKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gZWxlbWVudCBFbGVtZW50LlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgd2lkdGguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvdXRlcldpZHRoKGVsZW1lbnQpIHtcbiAgdmFyIHdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgd2lkdGggKz0gcGFyc2VJbnQoc3R5bGUubWFyZ2luTGVmdCwgMTApICsgcGFyc2VJbnQoc3R5bGUubWFyZ2luUmlnaHQsIDEwKTtcblxuICByZXR1cm4gd2lkdGg7XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgY29tcHV0ZWQgaGVpZ2h0IGZvciB0aGUgZ2l2ZW4gZWxlbWVudCBpbmNsdWRpbmcgbWFyZ2luLFxuICogcGFkZGluZyBhbmQgYm9yZGVyLlxuICogRXF1aXZhbGVudCB0byBqUXVlcnkncyBgJChlbCkub3V0ZXJIZWlnaHQodHJ1ZSlgLlxuICogQHBhcmFtIHshSFRNTEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGhlaWdodC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG91dGVySGVpZ2h0KGVsZW1lbnQpIHtcbiAgdmFyIGhlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICBoZWlnaHQgKz0gcGFyc2VJbnQoc3R5bGUubWFyZ2luVG9wLCAxMCkgKyBwYXJzZUludChzdHlsZS5tYXJnaW5Cb3R0b20sIDEwKTtcblxuICByZXR1cm4gaGVpZ2h0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbmV3Tm9kZSBOb2RlIHRvIHJlcGxhY2Ugb2xkIG5vZGVcbiAqIEBwYXJhbSB7Tm9kZX0gb2xkTm9kZSBUaGUgbm9kZSB0byBiZSByZXBsYWNlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZU5vZGUobmV3Tm9kZSwgb2xkTm9kZSkge1xuICB2YXIgcGFyZW50ID0gb2xkTm9kZS5wYXJlbnROb2RlO1xuICBpZiAocGFyZW50KSB7XG4gICAgcGFyZW50LnJlcGxhY2VDaGlsZChuZXdOb2RlLCBvbGROb2RlKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUaGUgbm9kZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Tm9kZX0gVGhlIG5vZGUgdGhhdCB3YXMgcmVtb3ZlZCBvciBudWxsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlICYmIG5vZGUucGFyZW50Tm9kZSA/IG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKSA6IG51bGw7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBub2RlIHRvIHJlbW92ZSB0aGUgY2hpbGRyZW4gZnJvbS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUNoaWxkcmVuKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUubGFzdENoaWxkKSB7XG4gICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmxhc3RDaGlsZCk7XG4gIH1cbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZG9tLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9lYXNpbmdcbiAqL1xuXG5cbi8qKlxuICogU3RhcnQgc2xvdyBhbmQgc3BlZWQgdXAuXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlYXNlSW4odCkge1xuICByZXR1cm4gTWF0aC5wb3codCwgMyk7XG59XG5cblxuLyoqXG4gKiBTdGFydCBmYXN0IGFuZCBzbG93IGRvd24uXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlYXNlT3V0KHQpIHtcbiAgcmV0dXJuIDEgLSBlYXNlSW4oMSAtIHQpO1xufVxuXG5cbi8qKlxuICogU3RhcnQgc2xvdywgc3BlZWQgdXAsIGFuZCB0aGVuIHNsb3cgZG93biBhZ2Fpbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEByZXR1cm4ge251bWJlcn0gT3V0cHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluQW5kT3V0KHQpIHtcbiAgcmV0dXJuIDMgKiB0ICogdCAtIDIgKiB0ICogdCAqIHQ7XG59XG5cblxuLyoqXG4gKiBNYWludGFpbiBhIGNvbnN0YW50IHNwZWVkIG92ZXIgdGltZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEByZXR1cm4ge251bWJlcn0gT3V0cHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhcih0KSB7XG4gIHJldHVybiB0O1xufVxuXG5cbi8qKlxuICogU3RhcnQgc2xvdywgc3BlZWQgdXAsIGFuZCBhdCB0aGUgdmVyeSBlbmQgc2xvdyBkb3duIGFnYWluLiAgVGhpcyBoYXMgdGhlXG4gKiBzYW1lIGdlbmVyYWwgYmVoYXZpb3IgYXMge0BsaW5rIG1vZHVsZTpvbC9lYXNpbmd+aW5BbmRPdXR9LCBidXQgdGhlIGZpbmFsXG4gKiBzbG93ZG93biBpcyBkZWxheWVkLlxuICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBBbmREb3duKHQpIHtcbiAgaWYgKHQgPCAwLjUpIHtcbiAgICByZXR1cm4gaW5BbmRPdXQoMiAqIHQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAxIC0gaW5BbmRPdXQoMiAqICh0IC0gMC41KSk7XG4gIH1cbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWFzaW5nLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9ldmVudHNcbiAqL1xuaW1wb3J0IHtjbGVhcn0gZnJvbSAnLi9vYmouanMnO1xuXG5cbi8qKlxuICogS2V5IHRvIHVzZSB3aXRoIHtAbGluayBtb2R1bGU6b2wvT2JzZXJ2YWJsZX5PYnNlcnZhYmxlI3VuQnlLZXl9LlxuICogQHR5cGVkZWYge09iamVjdH0gRXZlbnRzS2V5XG4gKiBAcHJvcGVydHkge09iamVjdH0gW2JpbmRUb11cbiAqIEBwcm9wZXJ0eSB7TGlzdGVuZXJGdW5jdGlvbn0gW2JvdW5kTGlzdGVuZXJdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGNhbGxPbmNlXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2RlbGV0ZUluZGV4XVxuICogQHByb3BlcnR5IHtMaXN0ZW5lckZ1bmN0aW9ufSBsaXN0ZW5lclxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2V2ZW50cy9UYXJnZXQuanNcIikuRXZlbnRUYXJnZXRMaWtlfSB0YXJnZXRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlXG4gKiBAYXBpXG4gKi9cblxuXG4vKipcbiAqIExpc3RlbmVyIGZ1bmN0aW9uLiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGFuIGV2ZW50IG9iamVjdCBhcyBhcmd1bWVudC5cbiAqIFdoZW4gdGhlIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYCwgZXZlbnQgcHJvcGFnYXRpb24gd2lsbCBzdG9wLlxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbigoRXZlbnR8aW1wb3J0KFwiLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdCkpOiAodm9pZHxib29sZWFuKX0gTGlzdGVuZXJGdW5jdGlvblxuICogQGFwaVxuICovXG5cblxuLyoqXG4gKiBAcGFyYW0ge0V2ZW50c0tleX0gbGlzdGVuZXJPYmogTGlzdGVuZXIgb2JqZWN0LlxuICogQHJldHVybiB7TGlzdGVuZXJGdW5jdGlvbn0gQm91bmQgbGlzdGVuZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kTGlzdGVuZXIobGlzdGVuZXJPYmopIHtcbiAgdmFyIGJvdW5kTGlzdGVuZXIgPSBmdW5jdGlvbihldnQpIHtcbiAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lck9iai5saXN0ZW5lcjtcbiAgICB2YXIgYmluZFRvID0gbGlzdGVuZXJPYmouYmluZFRvIHx8IGxpc3RlbmVyT2JqLnRhcmdldDtcbiAgICBpZiAobGlzdGVuZXJPYmouY2FsbE9uY2UpIHtcbiAgICAgIHVubGlzdGVuQnlLZXkobGlzdGVuZXJPYmopO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdGVuZXIuY2FsbChiaW5kVG8sIGV2dCk7XG4gIH07XG4gIGxpc3RlbmVyT2JqLmJvdW5kTGlzdGVuZXIgPSBib3VuZExpc3RlbmVyO1xuICByZXR1cm4gYm91bmRMaXN0ZW5lcjtcbn1cblxuXG4vKipcbiAqIEZpbmRzIHRoZSBtYXRjaGluZyB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50c35FdmVudHNLZXl9IGluIHRoZSBnaXZlbiBsaXN0ZW5lclxuICogYXJyYXkuXG4gKlxuICogQHBhcmFtIHshQXJyYXk8IUV2ZW50c0tleT59IGxpc3RlbmVycyBBcnJheSBvZiBsaXN0ZW5lcnMuXG4gKiBAcGFyYW0geyFGdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfdGhpcyBUaGUgYHRoaXNgIHZhbHVlIGluc2lkZSB0aGUgbGlzdGVuZXIuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfc2V0RGVsZXRlSW5kZXggU2V0IHRoZSBkZWxldGVJbmRleCBvbiB0aGUgbWF0Y2hpbmdcbiAqICAgICBsaXN0ZW5lciwgZm9yIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzfnVubGlzdGVuQnlLZXl9LlxuICogQHJldHVybiB7RXZlbnRzS2V5fHVuZGVmaW5lZH0gVGhlIG1hdGNoaW5nIGxpc3RlbmVyIG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRMaXN0ZW5lcihsaXN0ZW5lcnMsIGxpc3RlbmVyLCBvcHRfdGhpcywgb3B0X3NldERlbGV0ZUluZGV4KSB7XG4gIHZhciBsaXN0ZW5lck9iajtcbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBsaXN0ZW5lck9iaiA9IGxpc3RlbmVyc1tpXTtcbiAgICBpZiAobGlzdGVuZXJPYmoubGlzdGVuZXIgPT09IGxpc3RlbmVyICYmXG4gICAgICAgIGxpc3RlbmVyT2JqLmJpbmRUbyA9PT0gb3B0X3RoaXMpIHtcbiAgICAgIGlmIChvcHRfc2V0RGVsZXRlSW5kZXgpIHtcbiAgICAgICAgbGlzdGVuZXJPYmouZGVsZXRlSW5kZXggPSBpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpc3RlbmVyT2JqO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V2ZW50cy9UYXJnZXQuanNcIikuRXZlbnRUYXJnZXRMaWtlfSB0YXJnZXQgVGFyZ2V0LlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVHlwZS5cbiAqIEByZXR1cm4ge0FycmF5PEV2ZW50c0tleT58dW5kZWZpbmVkfSBMaXN0ZW5lcnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMaXN0ZW5lcnModGFyZ2V0LCB0eXBlKSB7XG4gIHZhciBsaXN0ZW5lck1hcCA9IGdldExpc3RlbmVyTWFwKHRhcmdldCk7XG4gIHJldHVybiBsaXN0ZW5lck1hcCA/IGxpc3RlbmVyTWFwW3R5cGVdIDogdW5kZWZpbmVkO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBsb29rdXAgb2YgbGlzdGVuZXJzLlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUYXJnZXQuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfY3JlYXRlIElmIGEgbWFwIHNob3VsZCBiZSBjcmVhdGVkIGlmIGl0IGRvZXNuJ3QgZXhpc3QuXG4gKiBAcmV0dXJuIHshT2JqZWN0PHN0cmluZywgQXJyYXk8RXZlbnRzS2V5Pj59IE1hcCBvZlxuICogICAgIGxpc3RlbmVycyBieSBldmVudCB0eXBlLlxuICovXG5mdW5jdGlvbiBnZXRMaXN0ZW5lck1hcCh0YXJnZXQsIG9wdF9jcmVhdGUpIHtcbiAgdmFyIGxpc3RlbmVyTWFwID0gdGFyZ2V0Lm9sX2xtO1xuICBpZiAoIWxpc3RlbmVyTWFwICYmIG9wdF9jcmVhdGUpIHtcbiAgICBsaXN0ZW5lck1hcCA9IHRhcmdldC5vbF9sbSA9IHt9O1xuICB9XG4gIHJldHVybiBsaXN0ZW5lck1hcDtcbn1cblxuXG4vKipcbiAqIFJlbW92ZSB0aGUgbGlzdGVuZXIgbWFwIGZyb20gYSB0YXJnZXQuXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRhcmdldC5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJNYXAodGFyZ2V0KSB7XG4gIGRlbGV0ZSB0YXJnZXQub2xfbG07XG59XG5cblxuLyoqXG4gKiBDbGVhbiB1cCBhbGwgbGlzdGVuZXIgb2JqZWN0cyBvZiB0aGUgZ2l2ZW4gdHlwZS4gIEFsbCBwcm9wZXJ0aWVzIG9uIHRoZVxuICogbGlzdGVuZXIgb2JqZWN0cyB3aWxsIGJlIHJlbW92ZWQsIGFuZCBpZiBubyBsaXN0ZW5lcnMgcmVtYWluIGluIHRoZSBsaXN0ZW5lclxuICogbWFwLCBpdCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgdGFyZ2V0LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V2ZW50cy9UYXJnZXQuanNcIikuRXZlbnRUYXJnZXRMaWtlfSB0YXJnZXQgVGFyZ2V0LlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVHlwZS5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJzKHRhcmdldCwgdHlwZSkge1xuICB2YXIgbGlzdGVuZXJzID0gZ2V0TGlzdGVuZXJzKHRhcmdldCwgdHlwZSk7XG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuL2V2ZW50cy9UYXJnZXQuanNcIikuZGVmYXVsdH0gKi8gKHRhcmdldCkuXG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldLmJvdW5kTGlzdGVuZXIpO1xuICAgICAgY2xlYXIobGlzdGVuZXJzW2ldKTtcbiAgICB9XG4gICAgbGlzdGVuZXJzLmxlbmd0aCA9IDA7XG4gICAgdmFyIGxpc3RlbmVyTWFwID0gZ2V0TGlzdGVuZXJNYXAodGFyZ2V0KTtcbiAgICBpZiAobGlzdGVuZXJNYXApIHtcbiAgICAgIGRlbGV0ZSBsaXN0ZW5lck1hcFt0eXBlXTtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhsaXN0ZW5lck1hcCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJlbW92ZUxpc3RlbmVyTWFwKHRhcmdldCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblxuLyoqXG4gKiBSZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgb24gYW4gZXZlbnQgdGFyZ2V0LiBJbnNwaXJlZCBieVxuICogaHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2Nsb3N1cmUtbGlicmFyeS9hcGkvc291cmNlL2Nsb3N1cmUvZ29vZy9ldmVudHMvZXZlbnRzLmpzLnNyYy5odG1sXG4gKlxuICogVGhpcyBmdW5jdGlvbiBlZmZpY2llbnRseSBiaW5kcyBhIGBsaXN0ZW5lcmAgdG8gYSBgdGhpc2Agb2JqZWN0LCBhbmQgcmV0dXJuc1xuICogYSBrZXkgZm9yIHVzZSB3aXRoIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzfnVubGlzdGVuQnlLZXl9LlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9ldmVudHMvVGFyZ2V0LmpzXCIpLkV2ZW50VGFyZ2V0TGlrZX0gdGFyZ2V0IEV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEV2ZW50IHR5cGUuXG4gKiBAcGFyYW0ge0xpc3RlbmVyRnVuY3Rpb259IGxpc3RlbmVyIExpc3RlbmVyLlxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfdGhpcyBPYmplY3QgcmVmZXJlbmNlZCBieSB0aGUgYHRoaXNgIGtleXdvcmQgaW4gdGhlXG4gKiAgICAgbGlzdGVuZXIuIERlZmF1bHQgaXMgdGhlIGB0YXJnZXRgLlxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X29uY2UgSWYgdHJ1ZSwgYWRkIHRoZSBsaXN0ZW5lciBhcyBvbmUtb2ZmIGxpc3RlbmVyLlxuICogQHJldHVybiB7RXZlbnRzS2V5fSBVbmlxdWUga2V5IGZvciB0aGUgbGlzdGVuZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaXN0ZW4odGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgb3B0X3RoaXMsIG9wdF9vbmNlKSB7XG4gIHZhciBsaXN0ZW5lck1hcCA9IGdldExpc3RlbmVyTWFwKHRhcmdldCwgdHJ1ZSk7XG4gIHZhciBsaXN0ZW5lcnMgPSBsaXN0ZW5lck1hcFt0eXBlXTtcbiAgaWYgKCFsaXN0ZW5lcnMpIHtcbiAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lck1hcFt0eXBlXSA9IFtdO1xuICB9XG4gIHZhciBsaXN0ZW5lck9iaiA9IGZpbmRMaXN0ZW5lcihsaXN0ZW5lcnMsIGxpc3RlbmVyLCBvcHRfdGhpcywgZmFsc2UpO1xuICBpZiAobGlzdGVuZXJPYmopIHtcbiAgICBpZiAoIW9wdF9vbmNlKSB7XG4gICAgICAvLyBUdXJuIG9uZS1vZmYgbGlzdGVuZXIgaW50byBhIHBlcm1hbmVudCBvbmUuXG4gICAgICBsaXN0ZW5lck9iai5jYWxsT25jZSA9IGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsaXN0ZW5lck9iaiA9IC8qKiBAdHlwZSB7RXZlbnRzS2V5fSAqLyAoe1xuICAgICAgYmluZFRvOiBvcHRfdGhpcyxcbiAgICAgIGNhbGxPbmNlOiAhIW9wdF9vbmNlLFxuICAgICAgbGlzdGVuZXI6IGxpc3RlbmVyLFxuICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICB0eXBlOiB0eXBlXG4gICAgfSk7XG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuL2V2ZW50cy9UYXJnZXQuanNcIikuZGVmYXVsdH0gKi8gKHRhcmdldCkuXG4gICAgICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGJpbmRMaXN0ZW5lcihsaXN0ZW5lck9iaikpO1xuICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyT2JqKTtcbiAgfVxuXG4gIHJldHVybiBsaXN0ZW5lck9iajtcbn1cblxuXG4vKipcbiAqIFJlZ2lzdGVycyBhIG9uZS1vZmYgZXZlbnQgbGlzdGVuZXIgb24gYW4gZXZlbnQgdGFyZ2V0LiBJbnNwaXJlZCBieVxuICogaHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2Nsb3N1cmUtbGlicmFyeS9hcGkvc291cmNlL2Nsb3N1cmUvZ29vZy9ldmVudHMvZXZlbnRzLmpzLnNyYy5odG1sXG4gKlxuICogVGhpcyBmdW5jdGlvbiBlZmZpY2llbnRseSBiaW5kcyBhIGBsaXN0ZW5lcmAgYXMgc2VsZi11bnJlZ2lzdGVyaW5nIGxpc3RlbmVyXG4gKiB0byBhIGB0aGlzYCBvYmplY3QsIGFuZCByZXR1cm5zIGEga2V5IGZvciB1c2Ugd2l0aFxuICoge0BsaW5rIG1vZHVsZTpvbC9ldmVudHN+dW5saXN0ZW5CeUtleX0gaW4gY2FzZSB0aGUgbGlzdGVuZXIgbmVlZHMgdG8gYmVcbiAqIHVucmVnaXN0ZXJlZCBiZWZvcmUgaXQgaXMgY2FsbGVkLlxuICpcbiAqIFdoZW4ge0BsaW5rIG1vZHVsZTpvbC9ldmVudHN+bGlzdGVufSBpcyBjYWxsZWQgd2l0aCB0aGUgc2FtZSBhcmd1bWVudHMgYWZ0ZXIgdGhpc1xuICogZnVuY3Rpb24sIHRoZSBzZWxmLXVucmVnaXN0ZXJpbmcgbGlzdGVuZXIgd2lsbCBiZSB0dXJuZWQgaW50byBhIHBlcm1hbmVudFxuICogbGlzdGVuZXIuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V2ZW50cy9UYXJnZXQuanNcIikuRXZlbnRUYXJnZXRMaWtlfSB0YXJnZXQgRXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZS5cbiAqIEBwYXJhbSB7TGlzdGVuZXJGdW5jdGlvbn0gbGlzdGVuZXIgTGlzdGVuZXIuXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdF90aGlzIE9iamVjdCByZWZlcmVuY2VkIGJ5IHRoZSBgdGhpc2Aga2V5d29yZCBpbiB0aGVcbiAqICAgICBsaXN0ZW5lci4gRGVmYXVsdCBpcyB0aGUgYHRhcmdldGAuXG4gKiBAcmV0dXJuIHtFdmVudHNLZXl9IEtleSBmb3IgdW5saXN0ZW5CeUtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpc3Rlbk9uY2UodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgb3B0X3RoaXMpIHtcbiAgcmV0dXJuIGxpc3Rlbih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBvcHRfdGhpcywgdHJ1ZSk7XG59XG5cblxuLyoqXG4gKiBVbnJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lciBvbiBhbiBldmVudCB0YXJnZXQuIEluc3BpcmVkIGJ5XG4gKiBodHRwczovL2dvb2dsZS5naXRodWIuaW8vY2xvc3VyZS1saWJyYXJ5L2FwaS9zb3VyY2UvY2xvc3VyZS9nb29nL2V2ZW50cy9ldmVudHMuanMuc3JjLmh0bWxcbiAqXG4gKiBUbyByZXR1cm4gYSBsaXN0ZW5lciwgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSBjYWxsZWQgd2l0aCB0aGUgZXhhY3Qgc2FtZVxuICogYXJndW1lbnRzIHRoYXQgd2VyZSB1c2VkIGZvciBhIHByZXZpb3VzIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzfmxpc3Rlbn0gY2FsbC5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXZlbnRzL1RhcmdldC5qc1wiKS5FdmVudFRhcmdldExpa2V9IHRhcmdldCBFdmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlLlxuICogQHBhcmFtIHtMaXN0ZW5lckZ1bmN0aW9ufSBsaXN0ZW5lciBMaXN0ZW5lci5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X3RoaXMgT2JqZWN0IHJlZmVyZW5jZWQgYnkgdGhlIGB0aGlzYCBrZXl3b3JkIGluIHRoZVxuICogICAgIGxpc3RlbmVyLiBEZWZhdWx0IGlzIHRoZSBgdGFyZ2V0YC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVubGlzdGVuKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIG9wdF90aGlzKSB7XG4gIHZhciBsaXN0ZW5lcnMgPSBnZXRMaXN0ZW5lcnModGFyZ2V0LCB0eXBlKTtcbiAgaWYgKGxpc3RlbmVycykge1xuICAgIHZhciBsaXN0ZW5lck9iaiA9IGZpbmRMaXN0ZW5lcihsaXN0ZW5lcnMsIGxpc3RlbmVyLCBvcHRfdGhpcywgdHJ1ZSk7XG4gICAgaWYgKGxpc3RlbmVyT2JqKSB7XG4gICAgICB1bmxpc3RlbkJ5S2V5KGxpc3RlbmVyT2JqKTtcbiAgICB9XG4gIH1cbn1cblxuXG4vKipcbiAqIFVucmVnaXN0ZXJzIGV2ZW50IGxpc3RlbmVycyBvbiBhbiBldmVudCB0YXJnZXQuIEluc3BpcmVkIGJ5XG4gKiBodHRwczovL2dvb2dsZS5naXRodWIuaW8vY2xvc3VyZS1saWJyYXJ5L2FwaS9zb3VyY2UvY2xvc3VyZS9nb29nL2V2ZW50cy9ldmVudHMuanMuc3JjLmh0bWxcbiAqXG4gKiBUaGUgYXJndW1lbnQgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24gaXMgdGhlIGtleSByZXR1cm5lZCBmcm9tXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50c35saXN0ZW59IG9yIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzfmxpc3Rlbk9uY2V9LlxuICpcbiAqIEBwYXJhbSB7RXZlbnRzS2V5fSBrZXkgVGhlIGtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVubGlzdGVuQnlLZXkoa2V5KSB7XG4gIGlmIChrZXkgJiYga2V5LnRhcmdldCkge1xuICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9ldmVudHMvVGFyZ2V0LmpzXCIpLmRlZmF1bHR9ICovIChrZXkudGFyZ2V0KS5cbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoa2V5LnR5cGUsIGtleS5ib3VuZExpc3RlbmVyKTtcbiAgICB2YXIgbGlzdGVuZXJzID0gZ2V0TGlzdGVuZXJzKGtleS50YXJnZXQsIGtleS50eXBlKTtcbiAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICB2YXIgaSA9ICdkZWxldGVJbmRleCcgaW4ga2V5ID8ga2V5LmRlbGV0ZUluZGV4IDogbGlzdGVuZXJzLmluZGV4T2Yoa2V5KTtcbiAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgfVxuICAgICAgaWYgKGxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXJzKGtleS50YXJnZXQsIGtleS50eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY2xlYXIoa2V5KTtcbiAgfVxufVxuXG5cbi8qKlxuICogVW5yZWdpc3RlcnMgYWxsIGV2ZW50IGxpc3RlbmVycyBvbiBhbiBldmVudCB0YXJnZXQuIEluc3BpcmVkIGJ5XG4gKiBodHRwczovL2dvb2dsZS5naXRodWIuaW8vY2xvc3VyZS1saWJyYXJ5L2FwaS9zb3VyY2UvY2xvc3VyZS9nb29nL2V2ZW50cy9ldmVudHMuanMuc3JjLmh0bWxcbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXZlbnRzL1RhcmdldC5qc1wiKS5FdmVudFRhcmdldExpa2V9IHRhcmdldCBUYXJnZXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bmxpc3RlbkFsbCh0YXJnZXQpIHtcbiAgdmFyIGxpc3RlbmVyTWFwID0gZ2V0TGlzdGVuZXJNYXAodGFyZ2V0KTtcbiAgaWYgKGxpc3RlbmVyTWFwKSB7XG4gICAgZm9yICh2YXIgdHlwZSBpbiBsaXN0ZW5lck1hcCkge1xuICAgICAgcmVtb3ZlTGlzdGVuZXJzKHRhcmdldCwgdHlwZSk7XG4gICAgfVxuICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZW50cy5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvZXZlbnRzL0V2ZW50XG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBTdHJpcHBlZCBkb3duIGltcGxlbWVudGF0aW9uIG9mIHRoZSBXM0MgRE9NIExldmVsIDIgRXZlbnQgaW50ZXJmYWNlLlxuICogU2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMi1FdmVudHMvZXZlbnRzLmh0bWwjRXZlbnRzLWludGVyZmFjZS5cbiAqXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIG9ubHkgcHJvdmlkZXMgYHR5cGVgIGFuZCBgdGFyZ2V0YCBwcm9wZXJ0aWVzLCBhbmRcbiAqIGBzdG9wUHJvcGFnYXRpb25gIGFuZCBgcHJldmVudERlZmF1bHRgIG1ldGhvZHMuIEl0IGlzIG1lYW50IGFzIGJhc2UgY2xhc3NcbiAqIGZvciBoaWdoZXIgbGV2ZWwgZXZlbnRzIGRlZmluZWQgaW4gdGhlIGxpYnJhcnksIGFuZCB3b3JrcyB3aXRoXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9UYXJnZXR+VGFyZ2V0fS5cbiAqL1xudmFyIEV2ZW50ID0gZnVuY3Rpb24gRXZlbnQodHlwZSkge1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHRoaXMucHJvcGFnYXRpb25TdG9wcGVkO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZS5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGFwaVxuICAgKi9cbiAgdGhpcy50eXBlID0gdHlwZTtcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHRhcmdldC5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGFwaVxuICAgKi9cbiAgdGhpcy50YXJnZXQgPSBudWxsO1xufTtcblxuLyoqXG4gKiBTdG9wIGV2ZW50IHByb3BhZ2F0aW9uLlxuICogQGFwaVxuICovXG5FdmVudC5wcm90b3R5cGUucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdCAoKSB7XG4gIHRoaXMucHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogU3RvcCBldmVudCBwcm9wYWdhdGlvbi5cbiAqIEBhcGlcbiAqL1xuRXZlbnQucHJvdG90eXBlLnN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbiAoKSB7XG4gIHRoaXMucHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge0V2ZW50fGltcG9ydChcIi4vRXZlbnQuanNcIikuZGVmYXVsdH0gZXZ0IEV2ZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oZXZ0KSB7XG4gIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7RXZlbnR8aW1wb3J0KFwiLi9FdmVudC5qc1wiKS5kZWZhdWx0fSBldnQgRXZlbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2dCkge1xuICBldnQucHJldmVudERlZmF1bHQoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgRXZlbnQ7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUV2ZW50LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9ldmVudHMvRXZlbnRUeXBlXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICogQGNvbnN0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgLyoqXG4gICAqIEdlbmVyaWMgY2hhbmdlIGV2ZW50LiBUcmlnZ2VyZWQgd2hlbiB0aGUgcmV2aXNpb24gY291bnRlciBpcyBpbmNyZWFzZWQuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvZXZlbnRzL0V2ZW50fkV2ZW50I2NoYW5nZVxuICAgKiBAYXBpXG4gICAqL1xuICBDSEFOR0U6ICdjaGFuZ2UnLFxuXG4gIENMRUFSOiAnY2xlYXInLFxuICBDT05URVhUTUVOVTogJ2NvbnRleHRtZW51JyxcbiAgQ0xJQ0s6ICdjbGljaycsXG4gIERCTENMSUNLOiAnZGJsY2xpY2snLFxuICBEUkFHRU5URVI6ICdkcmFnZW50ZXInLFxuICBEUkFHT1ZFUjogJ2RyYWdvdmVyJyxcbiAgRFJPUDogJ2Ryb3AnLFxuICBFUlJPUjogJ2Vycm9yJyxcbiAgS0VZRE9XTjogJ2tleWRvd24nLFxuICBLRVlQUkVTUzogJ2tleXByZXNzJyxcbiAgTE9BRDogJ2xvYWQnLFxuICBNT1VTRURPV046ICdtb3VzZWRvd24nLFxuICBNT1VTRU1PVkU6ICdtb3VzZW1vdmUnLFxuICBNT1VTRU9VVDogJ21vdXNlb3V0JyxcbiAgTU9VU0VVUDogJ21vdXNldXAnLFxuICBNT1VTRVdIRUVMOiAnbW91c2V3aGVlbCcsXG4gIE1TUE9JTlRFUkRPV046ICdNU1BvaW50ZXJEb3duJyxcbiAgUkVTSVpFOiAncmVzaXplJyxcbiAgVE9VQ0hTVEFSVDogJ3RvdWNoc3RhcnQnLFxuICBUT1VDSE1PVkU6ICd0b3VjaG1vdmUnLFxuICBUT1VDSEVORDogJ3RvdWNoZW5kJyxcbiAgV0hFRUw6ICd3aGVlbCdcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUV2ZW50VHlwZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvZXZlbnRzL0tleUNvZGVcbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKiBAY29uc3RcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBMRUZUOiAzNyxcbiAgVVA6IDM4LFxuICBSSUdIVDogMzksXG4gIERPV046IDQwXG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1LZXlDb2RlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9ldmVudHMvVGFyZ2V0XG4gKi9cbmltcG9ydCBEaXNwb3NhYmxlIGZyb20gJy4uL0Rpc3Bvc2FibGUuanMnO1xuaW1wb3J0IHt1bmxpc3RlbkFsbH0gZnJvbSAnLi4vZXZlbnRzLmpzJztcbmltcG9ydCB7Vk9JRH0gZnJvbSAnLi4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCBFdmVudCBmcm9tICcuL0V2ZW50LmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtFdmVudFRhcmdldHxUYXJnZXR9IEV2ZW50VGFyZ2V0TGlrZVxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBIHNpbXBsaWZpZWQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFczQyBET00gTGV2ZWwgMiBFdmVudFRhcmdldCBpbnRlcmZhY2UuXG4gKiBTZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDAvUkVDLURPTS1MZXZlbC0yLUV2ZW50cy0yMDAwMTExMy9ldmVudHMuaHRtbCNFdmVudHMtRXZlbnRUYXJnZXQuXG4gKlxuICogVGhlcmUgYXJlIHR3byBpbXBvcnRhbnQgc2ltcGxpZmljYXRpb25zIGNvbXBhcmVkIHRvIHRoZSBzcGVjaWZpY2F0aW9uOlxuICpcbiAqIDEuIFRoZSBoYW5kbGluZyBvZiBgdXNlQ2FwdHVyZWAgaW4gYGFkZEV2ZW50TGlzdGVuZXJgIGFuZFxuICogICAgYHJlbW92ZUV2ZW50TGlzdGVuZXJgLiBUaGVyZSBpcyBubyByZWFsIGNhcHR1cmUgbW9kZWwuXG4gKiAyLiBUaGUgaGFuZGxpbmcgb2YgYHN0b3BQcm9wYWdhdGlvbmAgYW5kIGBwcmV2ZW50RGVmYXVsdGAgb24gYGRpc3BhdGNoRXZlbnRgLlxuICogICAgVGhlcmUgaXMgbm8gZXZlbnQgdGFyZ2V0IGhpZXJhcmNoeS4gV2hlbiBhIGxpc3RlbmVyIGNhbGxzXG4gKiAgICBgc3RvcFByb3BhZ2F0aW9uYCBvciBgcHJldmVudERlZmF1bHRgIG9uIGFuIGV2ZW50IG9iamVjdCwgaXQgbWVhbnMgdGhhdCBub1xuICogICAgbW9yZSBsaXN0ZW5lcnMgYWZ0ZXIgdGhpcyBvbmUgd2lsbCBiZSBjYWxsZWQuIFNhbWUgYXMgd2hlbiB0aGUgbGlzdGVuZXJcbiAqICAgIHJldHVybnMgZmFsc2UuXG4gKi9cbnZhciBUYXJnZXQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChEaXNwb3NhYmxlKSB7XG4gIGZ1bmN0aW9uIFRhcmdldCgpIHtcblxuICAgIERpc3Bvc2FibGUuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMucGVuZGluZ1JlbW92YWxzXyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5kaXNwYXRjaGluZ18gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBBcnJheTxpbXBvcnQoXCIuLi9ldmVudHMuanNcIikuTGlzdGVuZXJGdW5jdGlvbj4+fVxuICAgICAqL1xuICAgIHRoaXMubGlzdGVuZXJzXyA9IHt9O1xuXG4gIH1cblxuICBpZiAoIERpc3Bvc2FibGUgKSBUYXJnZXQuX19wcm90b19fID0gRGlzcG9zYWJsZTtcbiAgVGFyZ2V0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIERpc3Bvc2FibGUgJiYgRGlzcG9zYWJsZS5wcm90b3R5cGUgKTtcbiAgVGFyZ2V0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRhcmdldDtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVHlwZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9ldmVudHMuanNcIikuTGlzdGVuZXJGdW5jdGlvbn0gbGlzdGVuZXIgTGlzdGVuZXIuXG4gICAqL1xuICBUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyICh0eXBlLCBsaXN0ZW5lcikge1xuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVyc19bdHlwZV07XG4gICAgaWYgKCFsaXN0ZW5lcnMpIHtcbiAgICAgIGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzX1t0eXBlXSA9IFtdO1xuICAgIH1cbiAgICBpZiAobGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpID09PSAtMSkge1xuICAgICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhbiBldmVudCBhbmQgY2FsbHMgYWxsIGxpc3RlbmVycyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgKiBvZiB0aGlzIHR5cGUuIFRoZSBldmVudCBwYXJhbWV0ZXIgY2FuIGVpdGhlciBiZSBhIHN0cmluZyBvciBhblxuICAgKiBPYmplY3Qgd2l0aCBhIGB0eXBlYCBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHt7dHlwZTogc3RyaW5nLFxuICAgKiAgICAgdGFyZ2V0OiAoRXZlbnRUYXJnZXRMaWtlfHVuZGVmaW5lZCksXG4gICAqICAgICBwcm9wYWdhdGlvblN0b3BwZWQ6IChib29sZWFufHVuZGVmaW5lZCl9fFxuICAgKiAgICAgaW1wb3J0KFwiLi9FdmVudC5qc1wiKS5kZWZhdWx0fHN0cmluZ30gZXZlbnQgRXZlbnQgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufHVuZGVmaW5lZH0gYGZhbHNlYCBpZiBhbnlvbmUgY2FsbGVkIHByZXZlbnREZWZhdWx0IG9uIHRoZVxuICAgKiAgICAgZXZlbnQgb2JqZWN0IG9yIGlmIGFueSBvZiB0aGUgbGlzdGVuZXJzIHJldHVybmVkIGZhbHNlLlxuICAgKiBAYXBpXG4gICAqL1xuICBUYXJnZXQucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50IChldmVudCkge1xuICAgIHZhciBldnQgPSB0eXBlb2YgZXZlbnQgPT09ICdzdHJpbmcnID8gbmV3IEV2ZW50KGV2ZW50KSA6IGV2ZW50O1xuICAgIHZhciB0eXBlID0gZXZ0LnR5cGU7XG4gICAgZXZ0LnRhcmdldCA9IHRoaXM7XG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzX1t0eXBlXTtcbiAgICB2YXIgcHJvcGFnYXRlO1xuICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgIGlmICghKHR5cGUgaW4gdGhpcy5kaXNwYXRjaGluZ18pKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hpbmdfW3R5cGVdID0gMDtcbiAgICAgICAgdGhpcy5wZW5kaW5nUmVtb3ZhbHNfW3R5cGVdID0gMDtcbiAgICAgIH1cbiAgICAgICsrdGhpcy5kaXNwYXRjaGluZ19bdHlwZV07XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBpZiAobGlzdGVuZXJzW2ldLmNhbGwodGhpcywgZXZ0KSA9PT0gZmFsc2UgfHwgZXZ0LnByb3BhZ2F0aW9uU3RvcHBlZCkge1xuICAgICAgICAgIHByb3BhZ2F0ZSA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAtLXRoaXMuZGlzcGF0Y2hpbmdfW3R5cGVdO1xuICAgICAgaWYgKHRoaXMuZGlzcGF0Y2hpbmdfW3R5cGVdID09PSAwKSB7XG4gICAgICAgIHZhciBwZW5kaW5nUmVtb3ZhbHMgPSB0aGlzLnBlbmRpbmdSZW1vdmFsc19bdHlwZV07XG4gICAgICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdSZW1vdmFsc19bdHlwZV07XG4gICAgICAgIHdoaWxlIChwZW5kaW5nUmVtb3ZhbHMtLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBWT0lEKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5kaXNwYXRjaGluZ19bdHlwZV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvcGFnYXRlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIFRhcmdldC5wcm90b3R5cGUuZGlzcG9zZUludGVybmFsID0gZnVuY3Rpb24gZGlzcG9zZUludGVybmFsICgpIHtcbiAgICB1bmxpc3RlbkFsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBsaXN0ZW5lcnMgZm9yIGEgc3BlY2lmaWVkIGV2ZW50IHR5cGUuIExpc3RlbmVycyBhcmUgcmV0dXJuZWQgaW4gdGhlXG4gICAqIG9yZGVyIHRoYXQgdGhleSB3aWxsIGJlIGNhbGxlZCBpbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVHlwZS5cbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi4vZXZlbnRzLmpzXCIpLkxpc3RlbmVyRnVuY3Rpb24+fSBMaXN0ZW5lcnMuXG4gICAqL1xuICBUYXJnZXQucHJvdG90eXBlLmdldExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldExpc3RlbmVycyAodHlwZSkge1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVyc19bdHlwZV07XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3R5cGUgVHlwZS4gSWYgbm90IHByb3ZpZGVkLFxuICAgKiAgICAgYHRydWVgIHdpbGwgYmUgcmV0dXJuZWQgaWYgdGhpcyBldmVudCB0YXJnZXQgaGFzIGFueSBsaXN0ZW5lcnMuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IEhhcyBsaXN0ZW5lcnMuXG4gICAqL1xuICBUYXJnZXQucHJvdG90eXBlLmhhc0xpc3RlbmVyID0gZnVuY3Rpb24gaGFzTGlzdGVuZXIgKG9wdF90eXBlKSB7XG4gICAgcmV0dXJuIG9wdF90eXBlID9cbiAgICAgIG9wdF90eXBlIGluIHRoaXMubGlzdGVuZXJzXyA6XG4gICAgICBPYmplY3Qua2V5cyh0aGlzLmxpc3RlbmVyc18pLmxlbmd0aCA+IDA7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFR5cGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXZlbnRzLmpzXCIpLkxpc3RlbmVyRnVuY3Rpb259IGxpc3RlbmVyIExpc3RlbmVyLlxuICAgKi9cbiAgVGFyZ2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lciAodHlwZSwgbGlzdGVuZXIpIHtcbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnNfW3R5cGVdO1xuICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgIHZhciBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgIGlmICh0eXBlIGluIHRoaXMucGVuZGluZ1JlbW92YWxzXykge1xuICAgICAgICAvLyBtYWtlIGxpc3RlbmVyIGEgbm8tb3AsIGFuZCByZW1vdmUgbGF0ZXIgaW4gI2Rpc3BhdGNoRXZlbnQoKVxuICAgICAgICBsaXN0ZW5lcnNbaW5kZXhdID0gVk9JRDtcbiAgICAgICAgKyt0aGlzLnBlbmRpbmdSZW1vdmFsc19bdHlwZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaWYgKGxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5saXN0ZW5lcnNfW3R5cGVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBUYXJnZXQ7XG59KERpc3Bvc2FibGUpKTtcblxuXG5leHBvcnQgZGVmYXVsdCBUYXJnZXQ7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRhcmdldC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvZXZlbnRzL2NvbmRpdGlvblxuICovXG5pbXBvcnQgTWFwQnJvd3NlckV2ZW50VHlwZSBmcm9tICcuLi9NYXBCcm93c2VyRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuLi9hc3NlcnRzLmpzJztcbmltcG9ydCB7VFJVRSwgRkFMU0V9IGZyb20gJy4uL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQge1dFQktJVCwgTUFDfSBmcm9tICcuLi9oYXMuanMnO1xuXG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fSBhbmQgcmV0dXJucyBhXG4gKiBge2Jvb2xlYW59YC4gSWYgdGhlIGNvbmRpdGlvbiBpcyBtZXQsIHRydWUgc2hvdWxkIGJlIHJldHVybmVkLlxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbih0aGlzOiA/LCBpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdCk6IGJvb2xlYW59IENvbmRpdGlvblxuICovXG5cblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIG9ubHkgdGhlIGFsdC1rZXkgaXMgcHJlc3NlZCwgYGZhbHNlYCBvdGhlcndpc2UgKGUuZy4gd2hlblxuICogYWRkaXRpb25hbGx5IHRoZSBzaGlmdC1rZXkgaXMgcHJlc3NlZCkuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBvbmx5IHRoZSBhbHQga2V5IGlzIHByZXNzZWQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCB2YXIgYWx0S2V5T25seSA9IGZ1bmN0aW9uKG1hcEJyb3dzZXJFdmVudCkge1xuICB2YXIgb3JpZ2luYWxFdmVudCA9IC8qKiBAdHlwZSB7S2V5Ym9hcmRFdmVudHxNb3VzZUV2ZW50fFRvdWNoRXZlbnR9ICovIChtYXBCcm93c2VyRXZlbnQub3JpZ2luYWxFdmVudCk7XG4gIHJldHVybiAoXG4gICAgb3JpZ2luYWxFdmVudC5hbHRLZXkgJiZcbiAgICAgICEob3JpZ2luYWxFdmVudC5tZXRhS2V5IHx8IG9yaWdpbmFsRXZlbnQuY3RybEtleSkgJiZcbiAgICAgICFvcmlnaW5hbEV2ZW50LnNoaWZ0S2V5KTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIG9ubHkgdGhlIGFsdC1rZXkgYW5kIHNoaWZ0LWtleSBpcyBwcmVzc2VkLCBgZmFsc2VgIG90aGVyd2lzZVxuICogKGUuZy4gd2hlbiBhZGRpdGlvbmFsbHkgdGhlIHBsYXRmb3JtLW1vZGlmaWVyLWtleSBpcyBwcmVzc2VkKS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG9ubHkgdGhlIGFsdCBhbmQgc2hpZnQga2V5cyBhcmUgcHJlc3NlZC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IHZhciBhbHRTaGlmdEtleXNPbmx5ID0gZnVuY3Rpb24obWFwQnJvd3NlckV2ZW50KSB7XG4gIHZhciBvcmlnaW5hbEV2ZW50ID0gLyoqIEB0eXBlIHtLZXlib2FyZEV2ZW50fE1vdXNlRXZlbnR8VG91Y2hFdmVudH0gKi8gKG1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50KTtcbiAgcmV0dXJuIChcbiAgICBvcmlnaW5hbEV2ZW50LmFsdEtleSAmJlxuICAgICAgIShvcmlnaW5hbEV2ZW50Lm1ldGFLZXkgfHwgb3JpZ2luYWxFdmVudC5jdHJsS2V5KSAmJlxuICAgICAgb3JpZ2luYWxFdmVudC5zaGlmdEtleSk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgbWFwIGhhcyB0aGUgZm9jdXMuIFRoaXMgY29uZGl0aW9uIHJlcXVpcmVzIGEgbWFwIHRhcmdldFxuICogZWxlbWVudCB3aXRoIGEgYHRhYmluZGV4YCBhdHRyaWJ1dGUsIGUuZy4gYDxkaXYgaWQ9XCJtYXBcIiB0YWJpbmRleD1cIjFcIj5gLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IGV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIG1hcCBoYXMgdGhlIGZvY3VzLlxuICogQGFwaVxuICovXG5leHBvcnQgdmFyIGZvY3VzID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LnRhcmdldC5nZXRUYXJnZXRFbGVtZW50KCkgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG59O1xuXG5cbi8qKlxuICogUmV0dXJuIGFsd2F5cyB0cnVlLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCB2YXIgYWx3YXlzID0gVFJVRTtcblxuXG4vKipcbiAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIGV2ZW50IGlzIGEgYGNsaWNrYCBldmVudCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgaXMgYSBtYXAgYGNsaWNrYCBldmVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IHZhciBjbGljayA9IGZ1bmN0aW9uKG1hcEJyb3dzZXJFdmVudCkge1xuICByZXR1cm4gbWFwQnJvd3NlckV2ZW50LnR5cGUgPT0gTWFwQnJvd3NlckV2ZW50VHlwZS5DTElDSztcbn07XG5cblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBldmVudCBoYXMgYW4gXCJhY3Rpb25cIi1wcm9kdWNpbmcgbW91c2UgYnV0dG9uLlxuICpcbiAqIEJ5IGRlZmluaXRpb24sIHRoaXMgaW5jbHVkZXMgbGVmdC1jbGljayBvbiB3aW5kb3dzL2xpbnV4LCBhbmQgbGVmdC1jbGlja1xuICogd2l0aG91dCB0aGUgY3RybCBrZXkgb24gTWFjcy5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgcmVzdWx0LlxuICovXG5leHBvcnQgdmFyIG1vdXNlQWN0aW9uQnV0dG9uID0gZnVuY3Rpb24obWFwQnJvd3NlckV2ZW50KSB7XG4gIHZhciBvcmlnaW5hbEV2ZW50ID0gLyoqIEB0eXBlIHtNb3VzZUV2ZW50fSAqLyAobWFwQnJvd3NlckV2ZW50Lm9yaWdpbmFsRXZlbnQpO1xuICByZXR1cm4gb3JpZ2luYWxFdmVudC5idXR0b24gPT0gMCAmJlxuICAgICAgIShXRUJLSVQgJiYgTUFDICYmIG9yaWdpbmFsRXZlbnQuY3RybEtleSk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJuIGFsd2F5cyBmYWxzZS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBGYWxzZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IHZhciBuZXZlciA9IEZBTFNFO1xuXG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgYnJvd3NlciBldmVudCBpcyBhIGBwb2ludGVybW92ZWAgZXZlbnQsIGBmYWxzZWBcbiAqIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBicm93c2VyIGV2ZW50IGlzIGEgYHBvaW50ZXJtb3ZlYCBldmVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IHZhciBwb2ludGVyTW92ZSA9IGZ1bmN0aW9uKG1hcEJyb3dzZXJFdmVudCkge1xuICByZXR1cm4gbWFwQnJvd3NlckV2ZW50LnR5cGUgPT0gJ3BvaW50ZXJtb3ZlJztcbn07XG5cblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBldmVudCBpcyBhIG1hcCBgc2luZ2xlY2xpY2tgIGV2ZW50LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBpcyBhIG1hcCBgc2luZ2xlY2xpY2tgIGV2ZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgdmFyIHNpbmdsZUNsaWNrID0gZnVuY3Rpb24obWFwQnJvd3NlckV2ZW50KSB7XG4gIHJldHVybiBtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBNYXBCcm93c2VyRXZlbnRUeXBlLlNJTkdMRUNMSUNLO1xufTtcblxuXG4vKipcbiAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIGV2ZW50IGlzIGEgbWFwIGBkYmxjbGlja2AgZXZlbnQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IGlzIGEgbWFwIGBkYmxjbGlja2AgZXZlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCB2YXIgZG91YmxlQ2xpY2sgPSBmdW5jdGlvbihtYXBCcm93c2VyRXZlbnQpIHtcbiAgcmV0dXJuIG1hcEJyb3dzZXJFdmVudC50eXBlID09IE1hcEJyb3dzZXJFdmVudFR5cGUuREJMQ0xJQ0s7XG59O1xuXG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiBubyBtb2RpZmllciBrZXkgKGFsdC0sIHNoaWZ0LSBvciBwbGF0Zm9ybS1tb2RpZmllci1rZXkpIGlzXG4gKiBwcmVzc2VkLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgb25seSBpZiB0aGVyZSBubyBtb2RpZmllciBrZXlzIGFyZSBwcmVzc2VkLlxuICogQGFwaVxuICovXG5leHBvcnQgdmFyIG5vTW9kaWZpZXJLZXlzID0gZnVuY3Rpb24obWFwQnJvd3NlckV2ZW50KSB7XG4gIHZhciBvcmlnaW5hbEV2ZW50ID0gLyoqIEB0eXBlIHtLZXlib2FyZEV2ZW50fE1vdXNlRXZlbnR8VG91Y2hFdmVudH0gKi8gKG1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50KTtcbiAgcmV0dXJuIChcbiAgICAhb3JpZ2luYWxFdmVudC5hbHRLZXkgJiZcbiAgICAgICEob3JpZ2luYWxFdmVudC5tZXRhS2V5IHx8IG9yaWdpbmFsRXZlbnQuY3RybEtleSkgJiZcbiAgICAgICFvcmlnaW5hbEV2ZW50LnNoaWZ0S2V5KTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIG9ubHkgdGhlIHBsYXRmb3JtLW1vZGlmaWVyLWtleSAodGhlIG1ldGEta2V5IG9uIE1hYyxcbiAqIGN0cmwta2V5IG90aGVyd2lzZSkgaXMgcHJlc3NlZCwgYGZhbHNlYCBvdGhlcndpc2UgKGUuZy4gd2hlbiBhZGRpdGlvbmFsbHlcbiAqIHRoZSBzaGlmdC1rZXkgaXMgcHJlc3NlZCkuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBvbmx5IHRoZSBwbGF0Zm9ybSBtb2RpZmllciBrZXkgaXMgcHJlc3NlZC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IHZhciBwbGF0Zm9ybU1vZGlmaWVyS2V5T25seSA9IGZ1bmN0aW9uKG1hcEJyb3dzZXJFdmVudCkge1xuICB2YXIgb3JpZ2luYWxFdmVudCA9IC8qKiBAdHlwZSB7S2V5Ym9hcmRFdmVudHxNb3VzZUV2ZW50fFRvdWNoRXZlbnR9ICovIChtYXBCcm93c2VyRXZlbnQub3JpZ2luYWxFdmVudCk7XG4gIHJldHVybiAhb3JpZ2luYWxFdmVudC5hbHRLZXkgJiZcbiAgICAoTUFDID8gb3JpZ2luYWxFdmVudC5tZXRhS2V5IDogb3JpZ2luYWxFdmVudC5jdHJsS2V5KSAmJlxuICAgICFvcmlnaW5hbEV2ZW50LnNoaWZ0S2V5O1xufTtcblxuXG4vKipcbiAqIFJldHVybiBgdHJ1ZWAgaWYgb25seSB0aGUgc2hpZnQta2V5IGlzIHByZXNzZWQsIGBmYWxzZWAgb3RoZXJ3aXNlIChlLmcuIHdoZW5cbiAqIGFkZGl0aW9uYWxseSB0aGUgYWx0LWtleSBpcyBwcmVzc2VkKS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG9ubHkgdGhlIHNoaWZ0IGtleSBpcyBwcmVzc2VkLlxuICogQGFwaVxuICovXG5leHBvcnQgdmFyIHNoaWZ0S2V5T25seSA9IGZ1bmN0aW9uKG1hcEJyb3dzZXJFdmVudCkge1xuICB2YXIgb3JpZ2luYWxFdmVudCA9IC8qKiBAdHlwZSB7S2V5Ym9hcmRFdmVudHxNb3VzZUV2ZW50fFRvdWNoRXZlbnR9ICovIChtYXBCcm93c2VyRXZlbnQub3JpZ2luYWxFdmVudCk7XG4gIHJldHVybiAoXG4gICAgIW9yaWdpbmFsRXZlbnQuYWx0S2V5ICYmXG4gICAgICAhKG9yaWdpbmFsRXZlbnQubWV0YUtleSB8fCBvcmlnaW5hbEV2ZW50LmN0cmxLZXkpICYmXG4gICAgICBvcmlnaW5hbEV2ZW50LnNoaWZ0S2V5KTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoZSB0YXJnZXQgZWxlbWVudCBpcyBub3QgZWRpdGFibGUsIGkuZS4gbm90IGEgYDxpbnB1dD5gLSxcbiAqIGA8c2VsZWN0PmAtIG9yIGA8dGV4dGFyZWE+YC1lbGVtZW50LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIG9ubHkgaWYgdGhlIHRhcmdldCBlbGVtZW50IGlzIG5vdCBlZGl0YWJsZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IHZhciB0YXJnZXROb3RFZGl0YWJsZSA9IGZ1bmN0aW9uKG1hcEJyb3dzZXJFdmVudCkge1xuICB2YXIgdGFyZ2V0ID0gbWFwQnJvd3NlckV2ZW50Lm9yaWdpbmFsRXZlbnQudGFyZ2V0O1xuICB2YXIgdGFnTmFtZSA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKHRhcmdldCkudGFnTmFtZTtcbiAgcmV0dXJuIChcbiAgICB0YWdOYW1lICE9PSAnSU5QVVQnICYmXG4gICAgICB0YWdOYW1lICE9PSAnU0VMRUNUJyAmJlxuICAgICAgdGFnTmFtZSAhPT0gJ1RFWFRBUkVBJyk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgZXZlbnQgb3JpZ2luYXRlcyBmcm9tIGEgbW91c2UgZGV2aWNlLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IG9yaWdpbmF0ZXMgZnJvbSBhIG1vdXNlIGRldmljZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IHZhciBtb3VzZU9ubHkgPSBmdW5jdGlvbihtYXBCcm93c2VyRXZlbnQpIHtcbiAgdmFyIHBvaW50ZXJFdmVudCA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlclBvaW50ZXJFdmVudFwiKS5kZWZhdWx0fSAqLyAobWFwQnJvd3NlckV2ZW50KS5wb2ludGVyRXZlbnQ7XG4gIGFzc2VydChwb2ludGVyRXZlbnQgIT09IHVuZGVmaW5lZCwgNTYpOyAvLyBtYXBCcm93c2VyRXZlbnQgbXVzdCBvcmlnaW5hdGUgZnJvbSBhIHBvaW50ZXIgZXZlbnRcbiAgLy8gc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3BvaW50ZXJldmVudHMvI3dpZGwtUG9pbnRlckV2ZW50LXBvaW50ZXJUeXBlXG4gIHJldHVybiBwb2ludGVyRXZlbnQucG9pbnRlclR5cGUgPT0gJ21vdXNlJztcbn07XG5cblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBldmVudCBvcmlnaW5hdGVzIGZyb20gYSBwcmltYXJ5IHBvaW50ZXIgaW5cbiAqIGNvbnRhY3Qgd2l0aCB0aGUgc3VyZmFjZSBvciBpZiB0aGUgbGVmdCBtb3VzZSBidXR0b24gaXMgcHJlc3NlZC5cbiAqIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9wb2ludGVyZXZlbnRzLyNidXR0b24tc3RhdGVzLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IG9yaWdpbmF0ZXMgZnJvbSBhIHByaW1hcnkgcG9pbnRlci5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IHZhciBwcmltYXJ5QWN0aW9uID0gZnVuY3Rpb24obWFwQnJvd3NlckV2ZW50KSB7XG4gIHZhciBwb2ludGVyRXZlbnQgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL01hcEJyb3dzZXJQb2ludGVyRXZlbnRcIikuZGVmYXVsdH0gKi8gKG1hcEJyb3dzZXJFdmVudCkucG9pbnRlckV2ZW50O1xuICBhc3NlcnQocG9pbnRlckV2ZW50ICE9PSB1bmRlZmluZWQsIDU2KTsgLy8gbWFwQnJvd3NlckV2ZW50IG11c3Qgb3JpZ2luYXRlIGZyb20gYSBwb2ludGVyIGV2ZW50XG4gIHJldHVybiBwb2ludGVyRXZlbnQuaXNQcmltYXJ5ICYmIHBvaW50ZXJFdmVudC5idXR0b24gPT09IDA7XG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25kaXRpb24uanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2V4dGVudFxuICovXG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi9hc3NlcnRzLmpzJztcbmltcG9ydCBDb3JuZXIgZnJvbSAnLi9leHRlbnQvQ29ybmVyLmpzJztcbmltcG9ydCBSZWxhdGlvbnNoaXAgZnJvbSAnLi9leHRlbnQvUmVsYXRpb25zaGlwLmpzJztcblxuXG4vKipcbiAqIEFuIGFycmF5IG9mIG51bWJlcnMgcmVwcmVzZW50aW5nIGFuIGV4dGVudDogYFttaW54LCBtaW55LCBtYXh4LCBtYXh5XWAuXG4gKiBAdHlwZWRlZiB7QXJyYXk8bnVtYmVyPn0gRXh0ZW50XG4gKiBAYXBpXG4gKi9cblxuLyoqXG4gKiBCdWlsZCBhbiBleHRlbnQgdGhhdCBpbmNsdWRlcyBhbGwgZ2l2ZW4gY29vcmRpbmF0ZXMuXG4gKlxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59IGNvb3JkaW5hdGVzIENvb3JkaW5hdGVzLlxuICogQHJldHVybiB7RXh0ZW50fSBCb3VuZGluZyBleHRlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBib3VuZGluZ0V4dGVudChjb29yZGluYXRlcykge1xuICB2YXIgZXh0ZW50ID0gY3JlYXRlRW1wdHkoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGV4dGVuZENvb3JkaW5hdGUoZXh0ZW50LCBjb29yZGluYXRlc1tpXSk7XG4gIH1cbiAgcmV0dXJuIGV4dGVudDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geHMgWHMuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHlzIFlzLlxuICogQHBhcmFtIHtFeHRlbnQ9fSBvcHRfZXh0ZW50IERlc3RpbmF0aW9uIGV4dGVudC5cbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEV4dGVudC5cbiAqL1xuZnVuY3Rpb24gX2JvdW5kaW5nRXh0ZW50WFlzKHhzLCB5cywgb3B0X2V4dGVudCkge1xuICB2YXIgbWluWCA9IE1hdGgubWluLmFwcGx5KG51bGwsIHhzKTtcbiAgdmFyIG1pblkgPSBNYXRoLm1pbi5hcHBseShudWxsLCB5cyk7XG4gIHZhciBtYXhYID0gTWF0aC5tYXguYXBwbHkobnVsbCwgeHMpO1xuICB2YXIgbWF4WSA9IE1hdGgubWF4LmFwcGx5KG51bGwsIHlzKTtcbiAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlKG1pblgsIG1pblksIG1heFgsIG1heFksIG9wdF9leHRlbnQpO1xufVxuXG5cbi8qKlxuICogUmV0dXJuIGV4dGVudCBpbmNyZWFzZWQgYnkgdGhlIHByb3ZpZGVkIHZhbHVlLlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGFtb3VudCBieSB3aGljaCB0aGUgZXh0ZW50IHNob3VsZCBiZSBidWZmZXJlZC5cbiAqIEBwYXJhbSB7RXh0ZW50PX0gb3B0X2V4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEV4dGVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1ZmZlcihleHRlbnQsIHZhbHVlLCBvcHRfZXh0ZW50KSB7XG4gIGlmIChvcHRfZXh0ZW50KSB7XG4gICAgb3B0X2V4dGVudFswXSA9IGV4dGVudFswXSAtIHZhbHVlO1xuICAgIG9wdF9leHRlbnRbMV0gPSBleHRlbnRbMV0gLSB2YWx1ZTtcbiAgICBvcHRfZXh0ZW50WzJdID0gZXh0ZW50WzJdICsgdmFsdWU7XG4gICAgb3B0X2V4dGVudFszXSA9IGV4dGVudFszXSArIHZhbHVlO1xuICAgIHJldHVybiBvcHRfZXh0ZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbXG4gICAgICBleHRlbnRbMF0gLSB2YWx1ZSxcbiAgICAgIGV4dGVudFsxXSAtIHZhbHVlLFxuICAgICAgZXh0ZW50WzJdICsgdmFsdWUsXG4gICAgICBleHRlbnRbM10gKyB2YWx1ZVxuICAgIF07XG4gIH1cbn1cblxuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBhbiBleHRlbnQuXG4gKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge0V4dGVudD19IG9wdF9leHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7RXh0ZW50fSBUaGUgY2xvbmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShleHRlbnQsIG9wdF9leHRlbnQpIHtcbiAgaWYgKG9wdF9leHRlbnQpIHtcbiAgICBvcHRfZXh0ZW50WzBdID0gZXh0ZW50WzBdO1xuICAgIG9wdF9leHRlbnRbMV0gPSBleHRlbnRbMV07XG4gICAgb3B0X2V4dGVudFsyXSA9IGV4dGVudFsyXTtcbiAgICBvcHRfZXh0ZW50WzNdID0gZXh0ZW50WzNdO1xuICAgIHJldHVybiBvcHRfZXh0ZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBleHRlbnQuc2xpY2UoKTtcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqIEByZXR1cm4ge251bWJlcn0gQ2xvc2VzdCBzcXVhcmVkIGRpc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvc2VzdFNxdWFyZWREaXN0YW5jZVhZKGV4dGVudCwgeCwgeSkge1xuICB2YXIgZHgsIGR5O1xuICBpZiAoeCA8IGV4dGVudFswXSkge1xuICAgIGR4ID0gZXh0ZW50WzBdIC0geDtcbiAgfSBlbHNlIGlmIChleHRlbnRbMl0gPCB4KSB7XG4gICAgZHggPSB4IC0gZXh0ZW50WzJdO1xuICB9IGVsc2Uge1xuICAgIGR4ID0gMDtcbiAgfVxuICBpZiAoeSA8IGV4dGVudFsxXSkge1xuICAgIGR5ID0gZXh0ZW50WzFdIC0geTtcbiAgfSBlbHNlIGlmIChleHRlbnRbM10gPCB5KSB7XG4gICAgZHkgPSB5IC0gZXh0ZW50WzNdO1xuICB9IGVsc2Uge1xuICAgIGR5ID0gMDtcbiAgfVxuICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59XG5cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgcGFzc2VkIGNvb3JkaW5hdGUgaXMgY29udGFpbmVkIG9yIG9uIHRoZSBlZGdlIG9mIHRoZSBleHRlbnQuXG4gKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgY29vcmRpbmF0ZSBpcyBjb250YWluZWQgaW4gdGhlIGV4dGVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zQ29vcmRpbmF0ZShleHRlbnQsIGNvb3JkaW5hdGUpIHtcbiAgcmV0dXJuIGNvbnRhaW5zWFkoZXh0ZW50LCBjb29yZGluYXRlWzBdLCBjb29yZGluYXRlWzFdKTtcbn1cblxuXG4vKipcbiAqIENoZWNrIGlmIG9uZSBleHRlbnQgY29udGFpbnMgYW5vdGhlci5cbiAqXG4gKiBBbiBleHRlbnQgaXMgZGVlbWVkIGNvbnRhaW5lZCBpZiBpdCBsaWVzIGNvbXBsZXRlbHkgd2l0aGluIHRoZSBvdGhlciBleHRlbnQsXG4gKiBpbmNsdWRpbmcgaWYgdGhleSBzaGFyZSBvbmUgb3IgbW9yZSBlZGdlcy5cbiAqXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50MSBFeHRlbnQgMS5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQyIEV4dGVudCAyLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHNlY29uZCBleHRlbnQgaXMgY29udGFpbmVkIGJ5IG9yIG9uIHRoZSBlZGdlIG9mIHRoZVxuICogICAgIGZpcnN0LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udGFpbnNFeHRlbnQoZXh0ZW50MSwgZXh0ZW50Mikge1xuICByZXR1cm4gZXh0ZW50MVswXSA8PSBleHRlbnQyWzBdICYmIGV4dGVudDJbMl0gPD0gZXh0ZW50MVsyXSAmJlxuICAgICAgZXh0ZW50MVsxXSA8PSBleHRlbnQyWzFdICYmIGV4dGVudDJbM10gPD0gZXh0ZW50MVszXTtcbn1cblxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBwYXNzZWQgY29vcmRpbmF0ZSBpcyBjb250YWluZWQgb3Igb24gdGhlIGVkZ2Ugb2YgdGhlIGV4dGVudC5cbiAqXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFggY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkgY29vcmRpbmF0ZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB4LCB5IHZhbHVlcyBhcmUgY29udGFpbmVkIGluIHRoZSBleHRlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb250YWluc1hZKGV4dGVudCwgeCwgeSkge1xuICByZXR1cm4gZXh0ZW50WzBdIDw9IHggJiYgeCA8PSBleHRlbnRbMl0gJiYgZXh0ZW50WzFdIDw9IHkgJiYgeSA8PSBleHRlbnRbM107XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIGEgY29vcmRpbmF0ZSBhbmQgZXh0ZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBUaGUgZXh0ZW50LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBUaGUgY29vcmRpbmF0ZS5cbiAqIEByZXR1cm4ge1JlbGF0aW9uc2hpcH0gVGhlIHJlbGF0aW9uc2hpcCAoYml0d2lzZSBjb21wYXJlIHdpdGhcbiAqICAgICBpbXBvcnQoXCIuL2V4dGVudC9SZWxhdGlvbnNoaXAuanNcIikuUmVsYXRpb25zaGlwKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvb3JkaW5hdGVSZWxhdGlvbnNoaXAoZXh0ZW50LCBjb29yZGluYXRlKSB7XG4gIHZhciBtaW5YID0gZXh0ZW50WzBdO1xuICB2YXIgbWluWSA9IGV4dGVudFsxXTtcbiAgdmFyIG1heFggPSBleHRlbnRbMl07XG4gIHZhciBtYXhZID0gZXh0ZW50WzNdO1xuICB2YXIgeCA9IGNvb3JkaW5hdGVbMF07XG4gIHZhciB5ID0gY29vcmRpbmF0ZVsxXTtcbiAgdmFyIHJlbGF0aW9uc2hpcCA9IFJlbGF0aW9uc2hpcC5VTktOT1dOO1xuICBpZiAoeCA8IG1pblgpIHtcbiAgICByZWxhdGlvbnNoaXAgPSByZWxhdGlvbnNoaXAgfCBSZWxhdGlvbnNoaXAuTEVGVDtcbiAgfSBlbHNlIGlmICh4ID4gbWF4WCkge1xuICAgIHJlbGF0aW9uc2hpcCA9IHJlbGF0aW9uc2hpcCB8IFJlbGF0aW9uc2hpcC5SSUdIVDtcbiAgfVxuICBpZiAoeSA8IG1pblkpIHtcbiAgICByZWxhdGlvbnNoaXAgPSByZWxhdGlvbnNoaXAgfCBSZWxhdGlvbnNoaXAuQkVMT1c7XG4gIH0gZWxzZSBpZiAoeSA+IG1heFkpIHtcbiAgICByZWxhdGlvbnNoaXAgPSByZWxhdGlvbnNoaXAgfCBSZWxhdGlvbnNoaXAuQUJPVkU7XG4gIH1cbiAgaWYgKHJlbGF0aW9uc2hpcCA9PT0gUmVsYXRpb25zaGlwLlVOS05PV04pIHtcbiAgICByZWxhdGlvbnNoaXAgPSBSZWxhdGlvbnNoaXAuSU5URVJTRUNUSU5HO1xuICB9XG4gIHJldHVybiByZWxhdGlvbnNoaXA7XG59XG5cblxuLyoqXG4gKiBDcmVhdGUgYW4gZW1wdHkgZXh0ZW50LlxuICogQHJldHVybiB7RXh0ZW50fSBFbXB0eSBleHRlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFbXB0eSgpIHtcbiAgcmV0dXJuIFtJbmZpbml0eSwgSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5XTtcbn1cblxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBleHRlbnQgb3IgdXBkYXRlIHRoZSBwcm92aWRlZCBleHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gbWluWCBNaW5pbXVtIFguXG4gKiBAcGFyYW0ge251bWJlcn0gbWluWSBNaW5pbXVtIFkuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4WCBNYXhpbXVtIFguXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4WSBNYXhpbXVtIFkuXG4gKiBAcGFyYW0ge0V4dGVudD19IG9wdF9leHRlbnQgRGVzdGluYXRpb24gZXh0ZW50LlxuICogQHJldHVybiB7RXh0ZW50fSBFeHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVPclVwZGF0ZShtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZLCBvcHRfZXh0ZW50KSB7XG4gIGlmIChvcHRfZXh0ZW50KSB7XG4gICAgb3B0X2V4dGVudFswXSA9IG1pblg7XG4gICAgb3B0X2V4dGVudFsxXSA9IG1pblk7XG4gICAgb3B0X2V4dGVudFsyXSA9IG1heFg7XG4gICAgb3B0X2V4dGVudFszXSA9IG1heFk7XG4gICAgcmV0dXJuIG9wdF9leHRlbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXTtcbiAgfVxufVxuXG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGVtcHR5IGV4dGVudCBvciBtYWtlIHRoZSBwcm92aWRlZCBvbmUgZW1wdHkuXG4gKiBAcGFyYW0ge0V4dGVudD19IG9wdF9leHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7RXh0ZW50fSBFeHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVPclVwZGF0ZUVtcHR5KG9wdF9leHRlbnQpIHtcbiAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlKFxuICAgIEluZmluaXR5LCBJbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHksIG9wdF9leHRlbnQpO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtFeHRlbnQ9fSBvcHRfZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge0V4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVGcm9tQ29vcmRpbmF0ZShjb29yZGluYXRlLCBvcHRfZXh0ZW50KSB7XG4gIHZhciB4ID0gY29vcmRpbmF0ZVswXTtcbiAgdmFyIHkgPSBjb29yZGluYXRlWzFdO1xuICByZXR1cm4gY3JlYXRlT3JVcGRhdGUoeCwgeSwgeCwgeSwgb3B0X2V4dGVudCk7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge0V4dGVudD19IG9wdF9leHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7RXh0ZW50fSBFeHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVPclVwZGF0ZUZyb21Db29yZGluYXRlcyhjb29yZGluYXRlcywgb3B0X2V4dGVudCkge1xuICB2YXIgZXh0ZW50ID0gY3JlYXRlT3JVcGRhdGVFbXB0eShvcHRfZXh0ZW50KTtcbiAgcmV0dXJuIGV4dGVuZENvb3JkaW5hdGVzKGV4dGVudCwgY29vcmRpbmF0ZXMpO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7RXh0ZW50PX0gb3B0X2V4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlRnJvbUZsYXRDb29yZGluYXRlcyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIG9wdF9leHRlbnQpIHtcbiAgdmFyIGV4dGVudCA9IGNyZWF0ZU9yVXBkYXRlRW1wdHkob3B0X2V4dGVudCk7XG4gIHJldHVybiBleHRlbmRGbGF0Q29vcmRpbmF0ZXMoZXh0ZW50LCBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+Pn0gcmluZ3MgUmluZ3MuXG4gKiBAcGFyYW0ge0V4dGVudD19IG9wdF9leHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7RXh0ZW50fSBFeHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVPclVwZGF0ZUZyb21SaW5ncyhyaW5ncywgb3B0X2V4dGVudCkge1xuICB2YXIgZXh0ZW50ID0gY3JlYXRlT3JVcGRhdGVFbXB0eShvcHRfZXh0ZW50KTtcbiAgcmV0dXJuIGV4dGVuZFJpbmdzKGV4dGVudCwgcmluZ3MpO1xufVxuXG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHR3byBleHRlbnRzIGFyZSBlcXVpdmFsZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDEgRXh0ZW50IDEuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50MiBFeHRlbnQgMi5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB0d28gZXh0ZW50cyBhcmUgZXF1aXZhbGVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhleHRlbnQxLCBleHRlbnQyKSB7XG4gIHJldHVybiBleHRlbnQxWzBdID09IGV4dGVudDJbMF0gJiYgZXh0ZW50MVsyXSA9PSBleHRlbnQyWzJdICYmXG4gICAgICBleHRlbnQxWzFdID09IGV4dGVudDJbMV0gJiYgZXh0ZW50MVszXSA9PSBleHRlbnQyWzNdO1xufVxuXG5cbi8qKlxuICogTW9kaWZ5IGFuIGV4dGVudCB0byBpbmNsdWRlIGFub3RoZXIgZXh0ZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDEgVGhlIGV4dGVudCB0byBiZSBtb2RpZmllZC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQyIFRoZSBleHRlbnQgdGhhdCB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBmaXJzdC5cbiAqIEByZXR1cm4ge0V4dGVudH0gQSByZWZlcmVuY2UgdG8gdGhlIGZpcnN0IChleHRlbmRlZCkgZXh0ZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKGV4dGVudDEsIGV4dGVudDIpIHtcbiAgaWYgKGV4dGVudDJbMF0gPCBleHRlbnQxWzBdKSB7XG4gICAgZXh0ZW50MVswXSA9IGV4dGVudDJbMF07XG4gIH1cbiAgaWYgKGV4dGVudDJbMl0gPiBleHRlbnQxWzJdKSB7XG4gICAgZXh0ZW50MVsyXSA9IGV4dGVudDJbMl07XG4gIH1cbiAgaWYgKGV4dGVudDJbMV0gPCBleHRlbnQxWzFdKSB7XG4gICAgZXh0ZW50MVsxXSA9IGV4dGVudDJbMV07XG4gIH1cbiAgaWYgKGV4dGVudDJbM10gPiBleHRlbnQxWzNdKSB7XG4gICAgZXh0ZW50MVszXSA9IGV4dGVudDJbM107XG4gIH1cbiAgcmV0dXJuIGV4dGVudDE7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZENvb3JkaW5hdGUoZXh0ZW50LCBjb29yZGluYXRlKSB7XG4gIGlmIChjb29yZGluYXRlWzBdIDwgZXh0ZW50WzBdKSB7XG4gICAgZXh0ZW50WzBdID0gY29vcmRpbmF0ZVswXTtcbiAgfVxuICBpZiAoY29vcmRpbmF0ZVswXSA+IGV4dGVudFsyXSkge1xuICAgIGV4dGVudFsyXSA9IGNvb3JkaW5hdGVbMF07XG4gIH1cbiAgaWYgKGNvb3JkaW5hdGVbMV0gPCBleHRlbnRbMV0pIHtcbiAgICBleHRlbnRbMV0gPSBjb29yZGluYXRlWzFdO1xuICB9XG4gIGlmIChjb29yZGluYXRlWzFdID4gZXh0ZW50WzNdKSB7XG4gICAgZXh0ZW50WzNdID0gY29vcmRpbmF0ZVsxXTtcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXMuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZENvb3JkaW5hdGVzKGV4dGVudCwgY29vcmRpbmF0ZXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGV4dGVuZENvb3JkaW5hdGUoZXh0ZW50LCBjb29yZGluYXRlc1tpXSk7XG4gIH1cbiAgcmV0dXJuIGV4dGVudDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEByZXR1cm4ge0V4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kRmxhdENvb3JkaW5hdGVzKGV4dGVudCwgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKSB7XG4gIGZvciAoOyBvZmZzZXQgPCBlbmQ7IG9mZnNldCArPSBzdHJpZGUpIHtcbiAgICBleHRlbmRYWShleHRlbnQsIGZsYXRDb29yZGluYXRlc1tvZmZzZXRdLCBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV0pO1xuICB9XG4gIHJldHVybiBleHRlbnQ7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+Pn0gcmluZ3MgUmluZ3MuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZFJpbmdzKGV4dGVudCwgcmluZ3MpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gcmluZ3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGV4dGVuZENvb3JkaW5hdGVzKGV4dGVudCwgcmluZ3NbaV0pO1xuICB9XG4gIHJldHVybiBleHRlbnQ7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kWFkoZXh0ZW50LCB4LCB5KSB7XG4gIGV4dGVudFswXSA9IE1hdGgubWluKGV4dGVudFswXSwgeCk7XG4gIGV4dGVudFsxXSA9IE1hdGgubWluKGV4dGVudFsxXSwgeSk7XG4gIGV4dGVudFsyXSA9IE1hdGgubWF4KGV4dGVudFsyXSwgeCk7XG4gIGV4dGVudFszXSA9IE1hdGgubWF4KGV4dGVudFszXSwgeSk7XG59XG5cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbGxzIGBjYWxsYmFja2AgZm9yIGVhY2ggY29ybmVyIG9mIHRoZSBleHRlbnQuIElmIHRoZVxuICogY2FsbGJhY2sgcmV0dXJucyBhIHRydXRoeSB2YWx1ZSB0aGUgZnVuY3Rpb24gcmV0dXJucyB0aGF0IHZhbHVlXG4gKiBpbW1lZGlhdGVseS4gT3RoZXJ3aXNlIHRoZSBmdW5jdGlvbiByZXR1cm5zIGBmYWxzZWAuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczpULCBpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZSk6IFN9IGNhbGxiYWNrIENhbGxiYWNrLlxuICogQHBhcmFtIHtUPX0gb3B0X3RoaXMgVmFsdWUgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyBgY2FsbGJhY2tgLlxuICogQHJldHVybiB7U3xib29sZWFufSBWYWx1ZS5cbiAqIEB0ZW1wbGF0ZSBTLCBUXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JFYWNoQ29ybmVyKGV4dGVudCwgY2FsbGJhY2ssIG9wdF90aGlzKSB7XG4gIHZhciB2YWw7XG4gIHZhbCA9IGNhbGxiYWNrLmNhbGwob3B0X3RoaXMsIGdldEJvdHRvbUxlZnQoZXh0ZW50KSk7XG4gIGlmICh2YWwpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIHZhbCA9IGNhbGxiYWNrLmNhbGwob3B0X3RoaXMsIGdldEJvdHRvbVJpZ2h0KGV4dGVudCkpO1xuICBpZiAodmFsKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICB2YWwgPSBjYWxsYmFjay5jYWxsKG9wdF90aGlzLCBnZXRUb3BSaWdodChleHRlbnQpKTtcbiAgaWYgKHZhbCkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgdmFsID0gY2FsbGJhY2suY2FsbChvcHRfdGhpcywgZ2V0VG9wTGVmdChleHRlbnQpKTtcbiAgaWYgKHZhbCkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBzaXplIG9mIGFuIGV4dGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7bnVtYmVyfSBBcmVhLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXJlYShleHRlbnQpIHtcbiAgdmFyIGFyZWEgPSAwO1xuICBpZiAoIWlzRW1wdHkoZXh0ZW50KSkge1xuICAgIGFyZWEgPSBnZXRXaWR0aChleHRlbnQpICogZ2V0SGVpZ2h0KGV4dGVudCk7XG4gIH1cbiAgcmV0dXJuIGFyZWE7XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIGJvdHRvbSBsZWZ0IGNvb3JkaW5hdGUgb2YgYW4gZXh0ZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gQm90dG9tIGxlZnQgY29vcmRpbmF0ZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJvdHRvbUxlZnQoZXh0ZW50KSB7XG4gIHJldHVybiBbZXh0ZW50WzBdLCBleHRlbnRbMV1dO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBib3R0b20gcmlnaHQgY29vcmRpbmF0ZSBvZiBhbiBleHRlbnQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBCb3R0b20gcmlnaHQgY29vcmRpbmF0ZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJvdHRvbVJpZ2h0KGV4dGVudCkge1xuICByZXR1cm4gW2V4dGVudFsyXSwgZXh0ZW50WzFdXTtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgY2VudGVyIGNvb3JkaW5hdGUgb2YgYW4gZXh0ZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gQ2VudGVyLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2VudGVyKGV4dGVudCkge1xuICByZXR1cm4gWyhleHRlbnRbMF0gKyBleHRlbnRbMl0pIC8gMiwgKGV4dGVudFsxXSArIGV4dGVudFszXSkgLyAyXTtcbn1cblxuXG4vKipcbiAqIEdldCBhIGNvcm5lciBjb29yZGluYXRlIG9mIGFuIGV4dGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtDb3JuZXJ9IGNvcm5lciBDb3JuZXIuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gQ29ybmVyIGNvb3JkaW5hdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb3JuZXIoZXh0ZW50LCBjb3JuZXIpIHtcbiAgdmFyIGNvb3JkaW5hdGU7XG4gIGlmIChjb3JuZXIgPT09IENvcm5lci5CT1RUT01fTEVGVCkge1xuICAgIGNvb3JkaW5hdGUgPSBnZXRCb3R0b21MZWZ0KGV4dGVudCk7XG4gIH0gZWxzZSBpZiAoY29ybmVyID09PSBDb3JuZXIuQk9UVE9NX1JJR0hUKSB7XG4gICAgY29vcmRpbmF0ZSA9IGdldEJvdHRvbVJpZ2h0KGV4dGVudCk7XG4gIH0gZWxzZSBpZiAoY29ybmVyID09PSBDb3JuZXIuVE9QX0xFRlQpIHtcbiAgICBjb29yZGluYXRlID0gZ2V0VG9wTGVmdChleHRlbnQpO1xuICB9IGVsc2UgaWYgKGNvcm5lciA9PT0gQ29ybmVyLlRPUF9SSUdIVCkge1xuICAgIGNvb3JkaW5hdGUgPSBnZXRUb3BSaWdodChleHRlbnQpO1xuICB9IGVsc2Uge1xuICAgIGFzc2VydChmYWxzZSwgMTMpOyAvLyBJbnZhbGlkIGNvcm5lclxuICB9XG4gIHJldHVybiBjb29yZGluYXRlO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDEgRXh0ZW50IDEuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50MiBFeHRlbnQgMi5cbiAqIEByZXR1cm4ge251bWJlcn0gRW5sYXJnZWQgYXJlYS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEVubGFyZ2VkQXJlYShleHRlbnQxLCBleHRlbnQyKSB7XG4gIHZhciBtaW5YID0gTWF0aC5taW4oZXh0ZW50MVswXSwgZXh0ZW50MlswXSk7XG4gIHZhciBtaW5ZID0gTWF0aC5taW4oZXh0ZW50MVsxXSwgZXh0ZW50MlsxXSk7XG4gIHZhciBtYXhYID0gTWF0aC5tYXgoZXh0ZW50MVsyXSwgZXh0ZW50MlsyXSk7XG4gIHZhciBtYXhZID0gTWF0aC5tYXgoZXh0ZW50MVszXSwgZXh0ZW50MlszXSk7XG4gIHJldHVybiAobWF4WCAtIG1pblgpICogKG1heFkgLSBtaW5ZKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNlbnRlciBDZW50ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gc2l6ZSBTaXplLlxuICogQHBhcmFtIHtFeHRlbnQ9fSBvcHRfZXh0ZW50IERlc3RpbmF0aW9uIGV4dGVudC5cbiAqIEByZXR1cm4ge0V4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Rm9yVmlld0FuZFNpemUoY2VudGVyLCByZXNvbHV0aW9uLCByb3RhdGlvbiwgc2l6ZSwgb3B0X2V4dGVudCkge1xuICB2YXIgZHggPSByZXNvbHV0aW9uICogc2l6ZVswXSAvIDI7XG4gIHZhciBkeSA9IHJlc29sdXRpb24gKiBzaXplWzFdIC8gMjtcbiAgdmFyIGNvc1JvdGF0aW9uID0gTWF0aC5jb3Mocm90YXRpb24pO1xuICB2YXIgc2luUm90YXRpb24gPSBNYXRoLnNpbihyb3RhdGlvbik7XG4gIHZhciB4Q29zID0gZHggKiBjb3NSb3RhdGlvbjtcbiAgdmFyIHhTaW4gPSBkeCAqIHNpblJvdGF0aW9uO1xuICB2YXIgeUNvcyA9IGR5ICogY29zUm90YXRpb247XG4gIHZhciB5U2luID0gZHkgKiBzaW5Sb3RhdGlvbjtcbiAgdmFyIHggPSBjZW50ZXJbMF07XG4gIHZhciB5ID0gY2VudGVyWzFdO1xuICB2YXIgeDAgPSB4IC0geENvcyArIHlTaW47XG4gIHZhciB4MSA9IHggLSB4Q29zIC0geVNpbjtcbiAgdmFyIHgyID0geCArIHhDb3MgLSB5U2luO1xuICB2YXIgeDMgPSB4ICsgeENvcyArIHlTaW47XG4gIHZhciB5MCA9IHkgLSB4U2luIC0geUNvcztcbiAgdmFyIHkxID0geSAtIHhTaW4gKyB5Q29zO1xuICB2YXIgeTIgPSB5ICsgeFNpbiArIHlDb3M7XG4gIHZhciB5MyA9IHkgKyB4U2luIC0geUNvcztcbiAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlKFxuICAgIE1hdGgubWluKHgwLCB4MSwgeDIsIHgzKSwgTWF0aC5taW4oeTAsIHkxLCB5MiwgeTMpLFxuICAgIE1hdGgubWF4KHgwLCB4MSwgeDIsIHgzKSwgTWF0aC5tYXgoeTAsIHkxLCB5MiwgeTMpLFxuICAgIG9wdF9leHRlbnQpO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBoZWlnaHQgb2YgYW4gZXh0ZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEhlaWdodC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhlaWdodChleHRlbnQpIHtcbiAgcmV0dXJuIGV4dGVudFszXSAtIGV4dGVudFsxXTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQxIEV4dGVudCAxLlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDIgRXh0ZW50IDIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEludGVyc2VjdGlvbiBhcmVhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW50ZXJzZWN0aW9uQXJlYShleHRlbnQxLCBleHRlbnQyKSB7XG4gIHZhciBpbnRlcnNlY3Rpb24gPSBnZXRJbnRlcnNlY3Rpb24oZXh0ZW50MSwgZXh0ZW50Mik7XG4gIHJldHVybiBnZXRBcmVhKGludGVyc2VjdGlvbik7XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIGludGVyc2VjdGlvbiBvZiB0d28gZXh0ZW50cy5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQxIEV4dGVudCAxLlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDIgRXh0ZW50IDIuXG4gKiBAcGFyYW0ge0V4dGVudD19IG9wdF9leHRlbnQgT3B0aW9uYWwgZXh0ZW50IHRvIHBvcHVsYXRlIHdpdGggaW50ZXJzZWN0aW9uLlxuICogQHJldHVybiB7RXh0ZW50fSBJbnRlcnNlY3RpbmcgZXh0ZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW50ZXJzZWN0aW9uKGV4dGVudDEsIGV4dGVudDIsIG9wdF9leHRlbnQpIHtcbiAgdmFyIGludGVyc2VjdGlvbiA9IG9wdF9leHRlbnQgPyBvcHRfZXh0ZW50IDogY3JlYXRlRW1wdHkoKTtcbiAgaWYgKGludGVyc2VjdHMoZXh0ZW50MSwgZXh0ZW50MikpIHtcbiAgICBpZiAoZXh0ZW50MVswXSA+IGV4dGVudDJbMF0pIHtcbiAgICAgIGludGVyc2VjdGlvblswXSA9IGV4dGVudDFbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGludGVyc2VjdGlvblswXSA9IGV4dGVudDJbMF07XG4gICAgfVxuICAgIGlmIChleHRlbnQxWzFdID4gZXh0ZW50MlsxXSkge1xuICAgICAgaW50ZXJzZWN0aW9uWzFdID0gZXh0ZW50MVsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW50ZXJzZWN0aW9uWzFdID0gZXh0ZW50MlsxXTtcbiAgICB9XG4gICAgaWYgKGV4dGVudDFbMl0gPCBleHRlbnQyWzJdKSB7XG4gICAgICBpbnRlcnNlY3Rpb25bMl0gPSBleHRlbnQxWzJdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnRlcnNlY3Rpb25bMl0gPSBleHRlbnQyWzJdO1xuICAgIH1cbiAgICBpZiAoZXh0ZW50MVszXSA8IGV4dGVudDJbM10pIHtcbiAgICAgIGludGVyc2VjdGlvblszXSA9IGV4dGVudDFbM107XG4gICAgfSBlbHNlIHtcbiAgICAgIGludGVyc2VjdGlvblszXSA9IGV4dGVudDJbM107XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNyZWF0ZU9yVXBkYXRlRW1wdHkoaW50ZXJzZWN0aW9uKTtcbiAgfVxuICByZXR1cm4gaW50ZXJzZWN0aW9uO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE1hcmdpbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1hcmdpbihleHRlbnQpIHtcbiAgcmV0dXJuIGdldFdpZHRoKGV4dGVudCkgKyBnZXRIZWlnaHQoZXh0ZW50KTtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgc2l6ZSAod2lkdGgsIGhlaWdodCkgb2YgYW4gZXh0ZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBUaGUgZXh0ZW50LlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9IFRoZSBleHRlbnQgc2l6ZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNpemUoZXh0ZW50KSB7XG4gIHJldHVybiBbZXh0ZW50WzJdIC0gZXh0ZW50WzBdLCBleHRlbnRbM10gLSBleHRlbnRbMV1dO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSB0b3AgbGVmdCBjb29yZGluYXRlIG9mIGFuIGV4dGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFRvcCBsZWZ0IGNvb3JkaW5hdGUuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUb3BMZWZ0KGV4dGVudCkge1xuICByZXR1cm4gW2V4dGVudFswXSwgZXh0ZW50WzNdXTtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgdG9wIHJpZ2h0IGNvb3JkaW5hdGUgb2YgYW4gZXh0ZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gVG9wIHJpZ2h0IGNvb3JkaW5hdGUuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUb3BSaWdodChleHRlbnQpIHtcbiAgcmV0dXJuIFtleHRlbnRbMl0sIGV4dGVudFszXV07XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIHdpZHRoIG9mIGFuIGV4dGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7bnVtYmVyfSBXaWR0aC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFdpZHRoKGV4dGVudCkge1xuICByZXR1cm4gZXh0ZW50WzJdIC0gZXh0ZW50WzBdO1xufVxuXG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIG9uZSBleHRlbnQgaW50ZXJzZWN0cyBhbm90aGVyLlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDEgRXh0ZW50IDEuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50MiBFeHRlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgdHdvIGV4dGVudHMgaW50ZXJzZWN0LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJzZWN0cyhleHRlbnQxLCBleHRlbnQyKSB7XG4gIHJldHVybiBleHRlbnQxWzBdIDw9IGV4dGVudDJbMl0gJiZcbiAgICAgIGV4dGVudDFbMl0gPj0gZXh0ZW50MlswXSAmJlxuICAgICAgZXh0ZW50MVsxXSA8PSBleHRlbnQyWzNdICYmXG4gICAgICBleHRlbnQxWzNdID49IGV4dGVudDJbMV07XG59XG5cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYW4gZXh0ZW50IGlzIGVtcHR5LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBJcyBlbXB0eS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRW1wdHkoZXh0ZW50KSB7XG4gIHJldHVybiBleHRlbnRbMl0gPCBleHRlbnRbMF0gfHwgZXh0ZW50WzNdIDwgZXh0ZW50WzFdO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge0V4dGVudD19IG9wdF9leHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7RXh0ZW50fSBFeHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5PclVwZGF0ZShleHRlbnQsIG9wdF9leHRlbnQpIHtcbiAgaWYgKG9wdF9leHRlbnQpIHtcbiAgICBvcHRfZXh0ZW50WzBdID0gZXh0ZW50WzBdO1xuICAgIG9wdF9leHRlbnRbMV0gPSBleHRlbnRbMV07XG4gICAgb3B0X2V4dGVudFsyXSA9IGV4dGVudFsyXTtcbiAgICBvcHRfZXh0ZW50WzNdID0gZXh0ZW50WzNdO1xuICAgIHJldHVybiBvcHRfZXh0ZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBleHRlbnQ7XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGVGcm9tQ2VudGVyKGV4dGVudCwgdmFsdWUpIHtcbiAgdmFyIGRlbHRhWCA9ICgoZXh0ZW50WzJdIC0gZXh0ZW50WzBdKSAvIDIpICogKHZhbHVlIC0gMSk7XG4gIHZhciBkZWx0YVkgPSAoKGV4dGVudFszXSAtIGV4dGVudFsxXSkgLyAyKSAqICh2YWx1ZSAtIDEpO1xuICBleHRlbnRbMF0gLT0gZGVsdGFYO1xuICBleHRlbnRbMl0gKz0gZGVsdGFYO1xuICBleHRlbnRbMV0gLT0gZGVsdGFZO1xuICBleHRlbnRbM10gKz0gZGVsdGFZO1xufVxuXG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHRoZSBzZWdtZW50IGJldHdlZW4gdHdvIGNvb3JkaW5hdGVzIGludGVyc2VjdHMgKGNyb3NzZXMsXG4gKiB0b3VjaGVzLCBvciBpcyBjb250YWluZWQgYnkpIHRoZSBwcm92aWRlZCBleHRlbnQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IFRoZSBleHRlbnQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBzdGFydCBTZWdtZW50IHN0YXJ0IGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBlbmQgU2VnbWVudCBlbmQgY29vcmRpbmF0ZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBzZWdtZW50IGludGVyc2VjdHMgdGhlIGV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdHNTZWdtZW50KGV4dGVudCwgc3RhcnQsIGVuZCkge1xuICB2YXIgaW50ZXJzZWN0cyA9IGZhbHNlO1xuICB2YXIgc3RhcnRSZWwgPSBjb29yZGluYXRlUmVsYXRpb25zaGlwKGV4dGVudCwgc3RhcnQpO1xuICB2YXIgZW5kUmVsID0gY29vcmRpbmF0ZVJlbGF0aW9uc2hpcChleHRlbnQsIGVuZCk7XG4gIGlmIChzdGFydFJlbCA9PT0gUmVsYXRpb25zaGlwLklOVEVSU0VDVElORyB8fFxuICAgICAgZW5kUmVsID09PSBSZWxhdGlvbnNoaXAuSU5URVJTRUNUSU5HKSB7XG4gICAgaW50ZXJzZWN0cyA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG1pblggPSBleHRlbnRbMF07XG4gICAgdmFyIG1pblkgPSBleHRlbnRbMV07XG4gICAgdmFyIG1heFggPSBleHRlbnRbMl07XG4gICAgdmFyIG1heFkgPSBleHRlbnRbM107XG4gICAgdmFyIHN0YXJ0WCA9IHN0YXJ0WzBdO1xuICAgIHZhciBzdGFydFkgPSBzdGFydFsxXTtcbiAgICB2YXIgZW5kWCA9IGVuZFswXTtcbiAgICB2YXIgZW5kWSA9IGVuZFsxXTtcbiAgICB2YXIgc2xvcGUgPSAoZW5kWSAtIHN0YXJ0WSkgLyAoZW5kWCAtIHN0YXJ0WCk7XG4gICAgdmFyIHgsIHk7XG4gICAgaWYgKCEhKGVuZFJlbCAmIFJlbGF0aW9uc2hpcC5BQk9WRSkgJiZcbiAgICAgICAgIShzdGFydFJlbCAmIFJlbGF0aW9uc2hpcC5BQk9WRSkpIHtcbiAgICAgIC8vIHBvdGVudGlhbGx5IGludGVyc2VjdHMgdG9wXG4gICAgICB4ID0gZW5kWCAtICgoZW5kWSAtIG1heFkpIC8gc2xvcGUpO1xuICAgICAgaW50ZXJzZWN0cyA9IHggPj0gbWluWCAmJiB4IDw9IG1heFg7XG4gICAgfVxuICAgIGlmICghaW50ZXJzZWN0cyAmJiAhIShlbmRSZWwgJiBSZWxhdGlvbnNoaXAuUklHSFQpICYmXG4gICAgICAgICEoc3RhcnRSZWwgJiBSZWxhdGlvbnNoaXAuUklHSFQpKSB7XG4gICAgICAvLyBwb3RlbnRpYWxseSBpbnRlcnNlY3RzIHJpZ2h0XG4gICAgICB5ID0gZW5kWSAtICgoZW5kWCAtIG1heFgpICogc2xvcGUpO1xuICAgICAgaW50ZXJzZWN0cyA9IHkgPj0gbWluWSAmJiB5IDw9IG1heFk7XG4gICAgfVxuICAgIGlmICghaW50ZXJzZWN0cyAmJiAhIShlbmRSZWwgJiBSZWxhdGlvbnNoaXAuQkVMT1cpICYmXG4gICAgICAgICEoc3RhcnRSZWwgJiBSZWxhdGlvbnNoaXAuQkVMT1cpKSB7XG4gICAgICAvLyBwb3RlbnRpYWxseSBpbnRlcnNlY3RzIGJvdHRvbVxuICAgICAgeCA9IGVuZFggLSAoKGVuZFkgLSBtaW5ZKSAvIHNsb3BlKTtcbiAgICAgIGludGVyc2VjdHMgPSB4ID49IG1pblggJiYgeCA8PSBtYXhYO1xuICAgIH1cbiAgICBpZiAoIWludGVyc2VjdHMgJiYgISEoZW5kUmVsICYgUmVsYXRpb25zaGlwLkxFRlQpICYmXG4gICAgICAgICEoc3RhcnRSZWwgJiBSZWxhdGlvbnNoaXAuTEVGVCkpIHtcbiAgICAgIC8vIHBvdGVudGlhbGx5IGludGVyc2VjdHMgbGVmdFxuICAgICAgeSA9IGVuZFkgLSAoKGVuZFggLSBtaW5YKSAqIHNsb3BlKTtcbiAgICAgIGludGVyc2VjdHMgPSB5ID49IG1pblkgJiYgeSA8PSBtYXhZO1xuICAgIH1cblxuICB9XG4gIHJldHVybiBpbnRlcnNlY3RzO1xufVxuXG5cbi8qKlxuICogQXBwbHkgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gdGhlIGV4dGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ouanNcIikuVHJhbnNmb3JtRnVuY3Rpb259IHRyYW5zZm9ybUZuIFRyYW5zZm9ybSBmdW5jdGlvbi5cbiAqIENhbGxlZCB3aXRoIGBbbWluWCwgbWluWSwgbWF4WCwgbWF4WV1gIGV4dGVudCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7RXh0ZW50PX0gb3B0X2V4dGVudCBEZXN0aW5hdGlvbiBleHRlbnQuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEV4dGVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5VHJhbnNmb3JtKGV4dGVudCwgdHJhbnNmb3JtRm4sIG9wdF9leHRlbnQpIHtcbiAgdmFyIGNvb3JkaW5hdGVzID0gW1xuICAgIGV4dGVudFswXSwgZXh0ZW50WzFdLFxuICAgIGV4dGVudFswXSwgZXh0ZW50WzNdLFxuICAgIGV4dGVudFsyXSwgZXh0ZW50WzFdLFxuICAgIGV4dGVudFsyXSwgZXh0ZW50WzNdXG4gIF07XG4gIHRyYW5zZm9ybUZuKGNvb3JkaW5hdGVzLCBjb29yZGluYXRlcywgMik7XG4gIHZhciB4cyA9IFtjb29yZGluYXRlc1swXSwgY29vcmRpbmF0ZXNbMl0sIGNvb3JkaW5hdGVzWzRdLCBjb29yZGluYXRlc1s2XV07XG4gIHZhciB5cyA9IFtjb29yZGluYXRlc1sxXSwgY29vcmRpbmF0ZXNbM10sIGNvb3JkaW5hdGVzWzVdLCBjb29yZGluYXRlc1s3XV07XG4gIHJldHVybiBfYm91bmRpbmdFeHRlbnRYWXMoeHMsIHlzLCBvcHRfZXh0ZW50KTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXh0ZW50LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9leHRlbnQvQ29ybmVyXG4gKi9cblxuLyoqXG4gKiBFeHRlbnQgY29ybmVyLlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBCT1RUT01fTEVGVDogJ2JvdHRvbS1sZWZ0JyxcbiAgQk9UVE9NX1JJR0hUOiAnYm90dG9tLXJpZ2h0JyxcbiAgVE9QX0xFRlQ6ICd0b3AtbGVmdCcsXG4gIFRPUF9SSUdIVDogJ3RvcC1yaWdodCdcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvcm5lci5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvZXh0ZW50L1JlbGF0aW9uc2hpcFxuICovXG5cbi8qKlxuICogUmVsYXRpb25zaGlwIHRvIGFuIGV4dGVudC5cbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgVU5LTk9XTjogMCxcbiAgSU5URVJTRUNUSU5HOiAxLFxuICBBQk9WRTogMixcbiAgUklHSFQ6IDQsXG4gIEJFTE9XOiA4LFxuICBMRUZUOiAxNlxufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVsYXRpb25zaGlwLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9mZWF0dXJlbG9hZGVyXG4gKi9cbmltcG9ydCB7Vk9JRH0gZnJvbSAnLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IEZvcm1hdFR5cGUgZnJvbSAnLi9mb3JtYXQvRm9ybWF0VHlwZS5qcyc7XG5cbi8qKlxuICoge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yfSBzb3VyY2VzIHVzZSBhIGZ1bmN0aW9uIG9mIHRoaXMgdHlwZSB0b1xuICogbG9hZCBmZWF0dXJlcy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gcmVwcmVzZW50aW5nIHRoZSBhcmVhIHRvIGJlIGxvYWRlZCxcbiAqIGEgYHtudW1iZXJ9YCByZXByZXNlbnRpbmcgdGhlIHJlc29sdXRpb24gKG1hcCB1bml0cyBwZXIgcGl4ZWwpIGFuZCBhblxuICoge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IGZvciB0aGUgcHJvamVjdGlvbiAgYXNcbiAqIGFyZ3VtZW50cy4gYHRoaXNgIHdpdGhpbiB0aGUgZnVuY3Rpb24gaXMgYm91bmQgdG8gdGhlXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3J9IGl0J3MgY2FsbGVkIGZyb20uXG4gKlxuICogVGhlIGZ1bmN0aW9uIGlzIHJlc3BvbnNpYmxlIGZvciBsb2FkaW5nIHRoZSBmZWF0dXJlcyBhbmQgYWRkaW5nIHRoZW0gdG8gdGhlXG4gKiBzb3VyY2UuXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24odGhpczooaW1wb3J0KFwiLi9zb3VyY2UvVmVjdG9yXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi9WZWN0b3JUaWxlLmpzXCIpLmRlZmF1bHQpLCBpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnQsIG51bWJlcixcbiAqICAgICAgICAgICAgICAgICAgICBpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0KX0gRmVhdHVyZUxvYWRlclxuICogQGFwaVxuICovXG5cblxuLyoqXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3J9IHNvdXJjZXMgdXNlIGEgZnVuY3Rpb24gb2YgdGhpcyB0eXBlIHRvXG4gKiBnZXQgdGhlIHVybCB0byBsb2FkIGZlYXR1cmVzIGZyb20uXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IHJlcHJlc2VudGluZyB0aGUgYXJlYVxuICogdG8gYmUgbG9hZGVkLCBhIGB7bnVtYmVyfWAgcmVwcmVzZW50aW5nIHRoZSByZXNvbHV0aW9uIChtYXAgdW5pdHMgcGVyIHBpeGVsKVxuICogYW5kIGFuIHtAbGluayBtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBmb3IgdGhlIHByb2plY3Rpb24gIGFzXG4gKiBhcmd1bWVudHMgYW5kIHJldHVybnMgYSBge3N0cmluZ31gIHJlcHJlc2VudGluZyB0aGUgVVJMLlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKGltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudCwgbnVtYmVyLCBpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0KTogc3RyaW5nfSBGZWF0dXJlVXJsRnVuY3Rpb25cbiAqIEBhcGlcbiAqL1xuXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8RmVhdHVyZVVybEZ1bmN0aW9ufSB1cmwgRmVhdHVyZSBVUkwgc2VydmljZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9mb3JtYXQvRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmb3JtYXQgRmVhdHVyZSBmb3JtYXQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6aW1wb3J0KFwiLi9WZWN0b3JUaWxlLmpzXCIpLmRlZmF1bHQsIEFycmF5PGltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0PiwgaW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdCwgaW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50KXxmdW5jdGlvbih0aGlzOmltcG9ydChcIi4vc291cmNlL1ZlY3RvclwiKS5kZWZhdWx0LCBBcnJheTxpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuZGVmYXVsdD4pfSBzdWNjZXNzXG4gKiAgICAgRnVuY3Rpb24gY2FsbGVkIHdpdGggdGhlIGxvYWRlZCBmZWF0dXJlcyBhbmQgb3B0aW9uYWxseSB3aXRoIHRoZSBkYXRhXG4gKiAgICAgcHJvamVjdGlvbi4gQ2FsbGVkIHdpdGggdGhlIHZlY3RvciB0aWxlIG9yIHNvdXJjZSBhcyBgdGhpc2AuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6aW1wb3J0KFwiLi9WZWN0b3JUaWxlLmpzXCIpLmRlZmF1bHQpfGZ1bmN0aW9uKHRoaXM6aW1wb3J0KFwiLi9zb3VyY2UvVmVjdG9yXCIpLmRlZmF1bHQpfSBmYWlsdXJlXG4gKiAgICAgRnVuY3Rpb24gY2FsbGVkIHdoZW4gbG9hZGluZyBmYWlsZWQuIENhbGxlZCB3aXRoIHRoZSB2ZWN0b3IgdGlsZSBvclxuICogICAgIHNvdXJjZSBhcyBgdGhpc2AuXG4gKiBAcmV0dXJuIHtGZWF0dXJlTG9hZGVyfSBUaGUgZmVhdHVyZSBsb2FkZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2FkRmVhdHVyZXNYaHIodXJsLCBmb3JtYXQsIHN1Y2Nlc3MsIGZhaWx1cmUpIHtcbiAgcmV0dXJuIChcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgICAqIEB0aGlzIHtpbXBvcnQoXCIuL3NvdXJjZS9WZWN0b3JcIikuZGVmYXVsdHxpbXBvcnQoXCIuL1ZlY3RvclRpbGUuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbihleHRlbnQsIHJlc29sdXRpb24sIHByb2plY3Rpb24pIHtcbiAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgIHhoci5vcGVuKCdHRVQnLFxuICAgICAgICB0eXBlb2YgdXJsID09PSAnZnVuY3Rpb24nID8gdXJsKGV4dGVudCwgcmVzb2x1dGlvbiwgcHJvamVjdGlvbikgOiB1cmwsXG4gICAgICAgIHRydWUpO1xuICAgICAgaWYgKGZvcm1hdC5nZXRUeXBlKCkgPT0gRm9ybWF0VHlwZS5BUlJBWV9CVUZGRVIpIHtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IEV2ZW50LlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIC8vIHN0YXR1cyB3aWxsIGJlIDAgZm9yIGZpbGU6Ly8gdXJsc1xuICAgICAgICBpZiAoIXhoci5zdGF0dXMgfHwgeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCkge1xuICAgICAgICAgIHZhciB0eXBlID0gZm9ybWF0LmdldFR5cGUoKTtcbiAgICAgICAgICAvKiogQHR5cGUge0RvY3VtZW50fE5vZGV8T2JqZWN0fHN0cmluZ3x1bmRlZmluZWR9ICovXG4gICAgICAgICAgdmFyIHNvdXJjZTtcbiAgICAgICAgICBpZiAodHlwZSA9PSBGb3JtYXRUeXBlLkpTT04gfHwgdHlwZSA9PSBGb3JtYXRUeXBlLlRFWFQpIHtcbiAgICAgICAgICAgIHNvdXJjZSA9IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09IEZvcm1hdFR5cGUuWE1MKSB7XG4gICAgICAgICAgICBzb3VyY2UgPSB4aHIucmVzcG9uc2VYTUw7XG4gICAgICAgICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICAgICAgICBzb3VyY2UgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHhoci5yZXNwb25zZVRleHQsICdhcHBsaWNhdGlvbi94bWwnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gRm9ybWF0VHlwZS5BUlJBWV9CVUZGRVIpIHtcbiAgICAgICAgICAgIHNvdXJjZSA9IC8qKiBAdHlwZSB7QXJyYXlCdWZmZXJ9ICovICh4aHIucmVzcG9uc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICBzdWNjZXNzLmNhbGwodGhpcywgZm9ybWF0LnJlYWRGZWF0dXJlcyhzb3VyY2UsXG4gICAgICAgICAgICAgIHtmZWF0dXJlUHJvamVjdGlvbjogcHJvamVjdGlvbn0pLFxuICAgICAgICAgICAgZm9ybWF0LnJlYWRQcm9qZWN0aW9uKHNvdXJjZSksIGZvcm1hdC5nZXRMYXN0RXh0ZW50KCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmYWlsdXJlLmNhbGwodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZhaWx1cmUuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpO1xuICAgICAgLyoqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG4gICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmYWlsdXJlLmNhbGwodGhpcyk7XG4gICAgICB9LmJpbmQodGhpcyk7XG4gICAgICB4aHIuc2VuZCgpO1xuICAgIH1cbiAgKTtcbn1cblxuXG4vKipcbiAqIENyZWF0ZSBhbiBYSFIgZmVhdHVyZSBsb2FkZXIgZm9yIGEgYHVybGAgYW5kIGBmb3JtYXRgLiBUaGUgZmVhdHVyZSBsb2FkZXJcbiAqIGxvYWRzIGZlYXR1cmVzICh3aXRoIFhIUiksIHBhcnNlcyB0aGUgZmVhdHVyZXMsIGFuZCBhZGRzIHRoZW0gdG8gdGhlXG4gKiB2ZWN0b3Igc291cmNlLlxuICogQHBhcmFtIHtzdHJpbmd8RmVhdHVyZVVybEZ1bmN0aW9ufSB1cmwgRmVhdHVyZSBVUkwgc2VydmljZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9mb3JtYXQvRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmb3JtYXQgRmVhdHVyZSBmb3JtYXQuXG4gKiBAcmV0dXJuIHtGZWF0dXJlTG9hZGVyfSBUaGUgZmVhdHVyZSBsb2FkZXIuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB4aHIodXJsLCBmb3JtYXQpIHtcbiAgcmV0dXJuIGxvYWRGZWF0dXJlc1hocih1cmwsIGZvcm1hdCxcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn0gZmVhdHVyZXMgVGhlIGxvYWRlZCBmZWF0dXJlcy5cbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IGRhdGFQcm9qZWN0aW9uIERhdGFcbiAgICAgKiBwcm9qZWN0aW9uLlxuICAgICAqIEB0aGlzIHtpbXBvcnQoXCIuL3NvdXJjZS9WZWN0b3JcIikuZGVmYXVsdHxpbXBvcnQoXCIuL1ZlY3RvclRpbGUuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbihmZWF0dXJlcywgZGF0YVByb2plY3Rpb24pIHtcbiAgICAgIHZhciBzb3VyY2VPclRpbGUgPSAvKiogQHR5cGUgez99ICovICh0aGlzKTtcbiAgICAgIGlmICh0eXBlb2Ygc291cmNlT3JUaWxlLmFkZEZlYXR1cmVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9zb3VyY2UvVmVjdG9yXCIpLmRlZmF1bHR9ICovIChzb3VyY2VPclRpbGUpLmFkZEZlYXR1cmVzKGZlYXR1cmVzKTtcbiAgICAgIH1cbiAgICB9LCAvKiBGSVhNRSBoYW5kbGUgZXJyb3IgKi8gVk9JRCk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZlYXR1cmVsb2FkZXIuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2Zvcm1hdC9Gb3JtYXRUeXBlXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIEFSUkFZX0JVRkZFUjogJ2FycmF5YnVmZmVyJyxcbiAgSlNPTjogJ2pzb24nLFxuICBURVhUOiAndGV4dCcsXG4gIFhNTDogJ3htbCdcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZvcm1hdFR5cGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2Z1bmN0aW9uc1xuICovXG5cbi8qKlxuICogQWx3YXlzIHJldHVybnMgdHJ1ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gVFJVRSgpIHtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQWx3YXlzIHJldHVybnMgZmFsc2UuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gZmFsc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGQUxTRSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEEgcmV1c2FibGUgZnVuY3Rpb24sIHVzZWQgZS5nLiBhcyBhIGRlZmF1bHQgZm9yIGNhbGxiYWNrcy5cbiAqXG4gKiBAcmV0dXJuIHt2b2lkfSBOb3RoaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gVk9JRCgpIHt9XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZ1bmN0aW9ucy5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9DaXJjbGVcbiAqL1xuaW1wb3J0IHtjcmVhdGVPclVwZGF0ZSwgZm9yRWFjaENvcm5lciwgaW50ZXJzZWN0c30gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCBHZW9tZXRyeVR5cGUgZnJvbSAnLi9HZW9tZXRyeVR5cGUuanMnO1xuaW1wb3J0IFNpbXBsZUdlb21ldHJ5IGZyb20gJy4vU2ltcGxlR2VvbWV0cnkuanMnO1xuaW1wb3J0IHtkZWZsYXRlQ29vcmRpbmF0ZX0gZnJvbSAnLi9mbGF0L2RlZmxhdGUuanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIENpcmNsZSBnZW9tZXRyeS5cbiAqXG4gKiBAYXBpXG4gKi9cbnZhciBDaXJjbGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChTaW1wbGVHZW9tZXRyeSkge1xuICBmdW5jdGlvbiBDaXJjbGUoY2VudGVyLCBvcHRfcmFkaXVzLCBvcHRfbGF5b3V0KSB7XG4gICAgU2ltcGxlR2VvbWV0cnkuY2FsbCh0aGlzKTtcbiAgICBpZiAob3B0X2xheW91dCAhPT0gdW5kZWZpbmVkICYmIG9wdF9yYWRpdXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zZXRGbGF0Q29vcmRpbmF0ZXMob3B0X2xheW91dCwgY2VudGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJhZGl1cyA9IG9wdF9yYWRpdXMgPyBvcHRfcmFkaXVzIDogMDtcbiAgICAgIHRoaXMuc2V0Q2VudGVyQW5kUmFkaXVzKGNlbnRlciwgcmFkaXVzLCBvcHRfbGF5b3V0KTtcbiAgICB9XG4gIH1cblxuICBpZiAoIFNpbXBsZUdlb21ldHJ5ICkgQ2lyY2xlLl9fcHJvdG9fXyA9IFNpbXBsZUdlb21ldHJ5O1xuICBDaXJjbGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU2ltcGxlR2VvbWV0cnkgJiYgU2ltcGxlR2VvbWV0cnkucHJvdG90eXBlICk7XG4gIENpcmNsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDaXJjbGU7XG5cbiAgLyoqXG4gICAqIE1ha2UgYSBjb21wbGV0ZSBjb3B5IG9mIHRoZSBnZW9tZXRyeS5cbiAgICogQHJldHVybiB7IUNpcmNsZX0gQ2xvbmUuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBDaXJjbGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgIHJldHVybiBuZXcgQ2lyY2xlKHRoaXMuZmxhdENvb3JkaW5hdGVzLnNsaWNlKCksIHVuZGVmaW5lZCwgdGhpcy5sYXlvdXQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQ2lyY2xlLnByb3RvdHlwZS5jbG9zZXN0UG9pbnRYWSA9IGZ1bmN0aW9uIGNsb3Nlc3RQb2ludFhZICh4LCB5LCBjbG9zZXN0UG9pbnQsIG1pblNxdWFyZWREaXN0YW5jZSkge1xuICAgIHZhciBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmZsYXRDb29yZGluYXRlcztcbiAgICB2YXIgZHggPSB4IC0gZmxhdENvb3JkaW5hdGVzWzBdO1xuICAgIHZhciBkeSA9IHkgLSBmbGF0Q29vcmRpbmF0ZXNbMV07XG4gICAgdmFyIHNxdWFyZWREaXN0YW5jZSA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgIGlmIChzcXVhcmVkRGlzdGFuY2UgPCBtaW5TcXVhcmVkRGlzdGFuY2UpIHtcbiAgICAgIGlmIChzcXVhcmVkRGlzdGFuY2UgPT09IDApIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN0cmlkZTsgKytpKSB7XG4gICAgICAgICAgY2xvc2VzdFBvaW50W2ldID0gZmxhdENvb3JkaW5hdGVzW2ldO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZGVsdGEgPSB0aGlzLmdldFJhZGl1cygpIC8gTWF0aC5zcXJ0KHNxdWFyZWREaXN0YW5jZSk7XG4gICAgICAgIGNsb3Nlc3RQb2ludFswXSA9IGZsYXRDb29yZGluYXRlc1swXSArIGRlbHRhICogZHg7XG4gICAgICAgIGNsb3Nlc3RQb2ludFsxXSA9IGZsYXRDb29yZGluYXRlc1sxXSArIGRlbHRhICogZHk7XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDI7IGkkMSA8IHRoaXMuc3RyaWRlOyArK2kkMSkge1xuICAgICAgICAgIGNsb3Nlc3RQb2ludFtpJDFdID0gZmxhdENvb3JkaW5hdGVzW2kkMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNsb3Nlc3RQb2ludC5sZW5ndGggPSB0aGlzLnN0cmlkZTtcbiAgICAgIHJldHVybiBzcXVhcmVkRGlzdGFuY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtaW5TcXVhcmVkRGlzdGFuY2U7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQ2lyY2xlLnByb3RvdHlwZS5jb250YWluc1hZID0gZnVuY3Rpb24gY29udGFpbnNYWSAoeCwgeSkge1xuICAgIHZhciBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmZsYXRDb29yZGluYXRlcztcbiAgICB2YXIgZHggPSB4IC0gZmxhdENvb3JkaW5hdGVzWzBdO1xuICAgIHZhciBkeSA9IHkgLSBmbGF0Q29vcmRpbmF0ZXNbMV07XG4gICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5IDw9IHRoaXMuZ2V0UmFkaXVzU3F1YXJlZF8oKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZSBhcyB7QGxpbmsgbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZSBjb29yZGluYXRlfS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBDZW50ZXIuXG4gICAqIEBhcGlcbiAgICovXG4gIENpcmNsZS5wcm90b3R5cGUuZ2V0Q2VudGVyID0gZnVuY3Rpb24gZ2V0Q2VudGVyICgpIHtcbiAgICByZXR1cm4gdGhpcy5mbGF0Q29vcmRpbmF0ZXMuc2xpY2UoMCwgdGhpcy5zdHJpZGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQ2lyY2xlLnByb3RvdHlwZS5jb21wdXRlRXh0ZW50ID0gZnVuY3Rpb24gY29tcHV0ZUV4dGVudCAoZXh0ZW50KSB7XG4gICAgdmFyIGZsYXRDb29yZGluYXRlcyA9IHRoaXMuZmxhdENvb3JkaW5hdGVzO1xuICAgIHZhciByYWRpdXMgPSBmbGF0Q29vcmRpbmF0ZXNbdGhpcy5zdHJpZGVdIC0gZmxhdENvb3JkaW5hdGVzWzBdO1xuICAgIHJldHVybiBjcmVhdGVPclVwZGF0ZShcbiAgICAgIGZsYXRDb29yZGluYXRlc1swXSAtIHJhZGl1cywgZmxhdENvb3JkaW5hdGVzWzFdIC0gcmFkaXVzLFxuICAgICAgZmxhdENvb3JkaW5hdGVzWzBdICsgcmFkaXVzLCBmbGF0Q29vcmRpbmF0ZXNbMV0gKyByYWRpdXMsXG4gICAgICBleHRlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFJhZGl1cy5cbiAgICogQGFwaVxuICAgKi9cbiAgQ2lyY2xlLnByb3RvdHlwZS5nZXRSYWRpdXMgPSBmdW5jdGlvbiBnZXRSYWRpdXMgKCkge1xuICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5nZXRSYWRpdXNTcXVhcmVkXygpKTtcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7bnVtYmVyfSBSYWRpdXMgc3F1YXJlZC5cbiAgICovXG4gIENpcmNsZS5wcm90b3R5cGUuZ2V0UmFkaXVzU3F1YXJlZF8gPSBmdW5jdGlvbiBnZXRSYWRpdXNTcXVhcmVkXyAoKSB7XG4gICAgdmFyIGR4ID0gdGhpcy5mbGF0Q29vcmRpbmF0ZXNbdGhpcy5zdHJpZGVdIC0gdGhpcy5mbGF0Q29vcmRpbmF0ZXNbMF07XG4gICAgdmFyIGR5ID0gdGhpcy5mbGF0Q29vcmRpbmF0ZXNbdGhpcy5zdHJpZGUgKyAxXSAtIHRoaXMuZmxhdENvb3JkaW5hdGVzWzFdO1xuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGFwaVxuICAgKi9cbiAgQ2lyY2xlLnByb3RvdHlwZS5nZXRUeXBlID0gZnVuY3Rpb24gZ2V0VHlwZSAoKSB7XG4gICAgcmV0dXJuIEdlb21ldHJ5VHlwZS5DSVJDTEU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqIEBhcGlcbiAgICovXG4gIENpcmNsZS5wcm90b3R5cGUuaW50ZXJzZWN0c0V4dGVudCA9IGZ1bmN0aW9uIGludGVyc2VjdHNFeHRlbnQgKGV4dGVudCkge1xuICAgIHZhciBjaXJjbGVFeHRlbnQgPSB0aGlzLmdldEV4dGVudCgpO1xuICAgIGlmIChpbnRlcnNlY3RzKGV4dGVudCwgY2lyY2xlRXh0ZW50KSkge1xuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyKCk7XG5cbiAgICAgIGlmIChleHRlbnRbMF0gPD0gY2VudGVyWzBdICYmIGV4dGVudFsyXSA+PSBjZW50ZXJbMF0pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoZXh0ZW50WzFdIDw9IGNlbnRlclsxXSAmJiBleHRlbnRbM10gPj0gY2VudGVyWzFdKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm9yRWFjaENvcm5lcihleHRlbnQsIHRoaXMuaW50ZXJzZWN0c0Nvb3JkaW5hdGUsIHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZSBhcyB7QGxpbmsgbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZSBjb29yZGluYXRlfS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNlbnRlciBDZW50ZXIuXG4gICAqIEBhcGlcbiAgICovXG4gIENpcmNsZS5wcm90b3R5cGUuc2V0Q2VudGVyID0gZnVuY3Rpb24gc2V0Q2VudGVyIChjZW50ZXIpIHtcbiAgICB2YXIgc3RyaWRlID0gdGhpcy5zdHJpZGU7XG4gICAgdmFyIHJhZGl1cyA9IHRoaXMuZmxhdENvb3JkaW5hdGVzW3N0cmlkZV0gLSB0aGlzLmZsYXRDb29yZGluYXRlc1swXTtcbiAgICB2YXIgZmxhdENvb3JkaW5hdGVzID0gY2VudGVyLnNsaWNlKCk7XG4gICAgZmxhdENvb3JkaW5hdGVzW3N0cmlkZV0gPSBmbGF0Q29vcmRpbmF0ZXNbMF0gKyByYWRpdXM7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzdHJpZGU7ICsraSkge1xuICAgICAgZmxhdENvb3JkaW5hdGVzW3N0cmlkZSArIGldID0gY2VudGVyW2ldO1xuICAgIH1cbiAgICB0aGlzLnNldEZsYXRDb29yZGluYXRlcyh0aGlzLmxheW91dCwgZmxhdENvb3JkaW5hdGVzKTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBjZW50ZXIgKGFzIHtAbGluayBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlIGNvb3JkaW5hdGV9KSBhbmQgdGhlIHJhZGl1cyAoYXNcbiAgICogbnVtYmVyKSBvZiB0aGUgY2lyY2xlLlxuICAgKiBAcGFyYW0geyFpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNlbnRlciBDZW50ZXIuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgUmFkaXVzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vR2VvbWV0cnlMYXlvdXQuanNcIikuZGVmYXVsdD19IG9wdF9sYXlvdXQgTGF5b3V0LlxuICAgKiBAYXBpXG4gICAqL1xuICBDaXJjbGUucHJvdG90eXBlLnNldENlbnRlckFuZFJhZGl1cyA9IGZ1bmN0aW9uIHNldENlbnRlckFuZFJhZGl1cyAoY2VudGVyLCByYWRpdXMsIG9wdF9sYXlvdXQpIHtcbiAgICB0aGlzLnNldExheW91dChvcHRfbGF5b3V0LCBjZW50ZXIsIDApO1xuICAgIGlmICghdGhpcy5mbGF0Q29vcmRpbmF0ZXMpIHtcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzID0gW107XG4gICAgfVxuICAgIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi9cbiAgICB2YXIgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5mbGF0Q29vcmRpbmF0ZXM7XG4gICAgdmFyIG9mZnNldCA9IGRlZmxhdGVDb29yZGluYXRlKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLCAwLCBjZW50ZXIsIHRoaXMuc3RyaWRlKTtcbiAgICBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0KytdID0gZmxhdENvb3JkaW5hdGVzWzBdICsgcmFkaXVzO1xuICAgIGZvciAodmFyIGkgPSAxLCBpaSA9IHRoaXMuc3RyaWRlOyBpIDwgaWk7ICsraSkge1xuICAgICAgZmxhdENvb3JkaW5hdGVzW29mZnNldCsrXSA9IGZsYXRDb29yZGluYXRlc1tpXTtcbiAgICB9XG4gICAgZmxhdENvb3JkaW5hdGVzLmxlbmd0aCA9IG9mZnNldDtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENpcmNsZS5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlcyAoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDaXJjbGUucHJvdG90eXBlLnNldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gc2V0Q29vcmRpbmF0ZXMgKGNvb3JkaW5hdGVzLCBvcHRfbGF5b3V0KSB7fTtcblxuICAvKipcbiAgICogU2V0IHRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZS4gVGhlIHJhZGl1cyBpcyBpbiB0aGUgdW5pdHMgb2YgdGhlIHByb2plY3Rpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgUmFkaXVzLlxuICAgKiBAYXBpXG4gICAqL1xuICBDaXJjbGUucHJvdG90eXBlLnNldFJhZGl1cyA9IGZ1bmN0aW9uIHNldFJhZGl1cyAocmFkaXVzKSB7XG4gICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXNbdGhpcy5zdHJpZGVdID0gdGhpcy5mbGF0Q29vcmRpbmF0ZXNbMF0gKyByYWRpdXM7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH07XG5cbiAgcmV0dXJuIENpcmNsZTtcbn0oU2ltcGxlR2VvbWV0cnkpKTtcblxuXG4vKipcbiAqIFRyYW5zZm9ybSBlYWNoIGNvb3JkaW5hdGUgb2YgdGhlIGNpcmNsZSBmcm9tIG9uZSBjb29yZGluYXRlIHJlZmVyZW5jZSBzeXN0ZW1cbiAqIHRvIGFub3RoZXIuIFRoZSBnZW9tZXRyeSBpcyBtb2RpZmllZCBpbiBwbGFjZS5cbiAqIElmIHlvdSBkbyBub3Qgd2FudCB0aGUgZ2VvbWV0cnkgbW9kaWZpZWQgaW4gcGxhY2UsIGZpcnN0IGNsb25lKCkgaXQgYW5kXG4gKiB0aGVuIHVzZSB0aGlzIGZ1bmN0aW9uIG9uIHRoZSBjbG9uZS5cbiAqXG4gKiBJbnRlcm5hbGx5IGEgY2lyY2xlIGlzIGN1cnJlbnRseSByZXByZXNlbnRlZCBieSB0d28gcG9pbnRzOiB0aGUgY2VudGVyIG9mXG4gKiB0aGUgY2lyY2xlIGBbY3gsIGN5XWAsIGFuZCB0aGUgcG9pbnQgdG8gdGhlIHJpZ2h0IG9mIHRoZSBjaXJjbGVcbiAqIGBbY3ggKyByLCBjeV1gLiBUaGlzIGB0cmFuc2Zvcm1gIGZ1bmN0aW9uIGp1c3QgdHJhbnNmb3JtcyB0aGVzZSB0d28gcG9pbnRzLlxuICogU28gdGhlIHJlc3VsdGluZyBnZW9tZXRyeSBpcyBhbHNvIGEgY2lyY2xlLCBhbmQgdGhhdCBjaXJjbGUgZG9lcyBub3RcbiAqIGNvcnJlc3BvbmQgdG8gdGhlIHNoYXBlIHRoYXQgd291bGQgYmUgb2J0YWluZWQgYnkgdHJhbnNmb3JtaW5nIGV2ZXJ5IHBvaW50XG4gKiBvZiB0aGUgb3JpZ2luYWwgY2lyY2xlLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gc291cmNlIFRoZSBjdXJyZW50IHByb2plY3Rpb24uICBDYW4gYmUgYVxuICogICAgIHN0cmluZyBpZGVudGlmaWVyIG9yIGEge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb25+UHJvamVjdGlvbn0gb2JqZWN0LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qLmpzXCIpLlByb2plY3Rpb25MaWtlfSBkZXN0aW5hdGlvbiBUaGUgZGVzaXJlZCBwcm9qZWN0aW9uLiAgQ2FuIGJlIGFcbiAqICAgICBzdHJpbmcgaWRlbnRpZmllciBvciBhIHtAbGluayBtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9uflByb2plY3Rpb259IG9iamVjdC5cbiAqIEByZXR1cm4ge0NpcmNsZX0gVGhpcyBnZW9tZXRyeS4gIE5vdGUgdGhhdCBvcmlnaW5hbCBnZW9tZXRyeSBpc1xuICogICAgIG1vZGlmaWVkIGluIHBsYWNlLlxuICogQGZ1bmN0aW9uXG4gKiBAYXBpXG4gKi9cbkNpcmNsZS5wcm90b3R5cGUudHJhbnNmb3JtO1xuZXhwb3J0IGRlZmF1bHQgQ2lyY2xlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1DaXJjbGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vR2VvbWV0cnlcbiAqL1xuaW1wb3J0IHthYnN0cmFjdH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5pbXBvcnQgQmFzZU9iamVjdCBmcm9tICcuLi9PYmplY3QuanMnO1xuaW1wb3J0IHtjcmVhdGVFbXB0eSwgZ2V0SGVpZ2h0LCByZXR1cm5PclVwZGF0ZX0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7dHJhbnNmb3JtMkR9IGZyb20gJy4vZmxhdC90cmFuc2Zvcm0uanMnO1xuaW1wb3J0IHtnZXQgYXMgZ2V0UHJvamVjdGlvbiwgZ2V0VHJhbnNmb3JtfSBmcm9tICcuLi9wcm9qLmpzJztcbmltcG9ydCBVbml0cyBmcm9tICcuLi9wcm9qL1VuaXRzLmpzJztcbmltcG9ydCB7Y3JlYXRlIGFzIGNyZWF0ZVRyYW5zZm9ybSwgY29tcG9zZSBhcyBjb21wb3NlVHJhbnNmb3JtfSBmcm9tICcuLi90cmFuc2Zvcm0uanMnO1xuXG5cbi8qKlxuICogQHR5cGUge2ltcG9ydChcIi4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19XG4gKi9cbnZhciB0bXBUcmFuc2Zvcm0gPSBjcmVhdGVUcmFuc2Zvcm0oKTtcblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3M7IG5vcm1hbGx5IG9ubHkgdXNlZCBmb3IgY3JlYXRpbmcgc3ViY2xhc3NlcyBhbmQgbm90XG4gKiBpbnN0YW50aWF0ZWQgaW4gYXBwcy5cbiAqIEJhc2UgY2xhc3MgZm9yIHZlY3RvciBnZW9tZXRyaWVzLlxuICpcbiAqIFRvIGdldCBub3RpZmllZCBvZiBjaGFuZ2VzIHRvIHRoZSBnZW9tZXRyeSwgcmVnaXN0ZXIgYSBsaXN0ZW5lciBmb3IgdGhlXG4gKiBnZW5lcmljIGBjaGFuZ2VgIGV2ZW50IG9uIHlvdXIgZ2VvbWV0cnkgaW5zdGFuY2UuXG4gKlxuICogQGFic3RyYWN0XG4gKiBAYXBpXG4gKi9cbnZhciBHZW9tZXRyeSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEJhc2VPYmplY3QpIHtcbiAgZnVuY3Rpb24gR2VvbWV0cnkoKSB7XG5cbiAgICBCYXNlT2JqZWN0LmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgICAqL1xuICAgIHRoaXMuZXh0ZW50XyA9IGNyZWF0ZUVtcHR5KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5leHRlbnRSZXZpc2lvbl8gPSAtMTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgR2VvbWV0cnk+fVxuICAgICAqL1xuICAgIHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5Q2FjaGUgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5TWF4TWluU3F1YXJlZFRvbGVyYW5jZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnNpbXBsaWZpZWRHZW9tZXRyeVJldmlzaW9uID0gMDtcblxuICB9XG5cbiAgaWYgKCBCYXNlT2JqZWN0ICkgR2VvbWV0cnkuX19wcm90b19fID0gQmFzZU9iamVjdDtcbiAgR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQmFzZU9iamVjdCAmJiBCYXNlT2JqZWN0LnByb3RvdHlwZSApO1xuICBHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW9tZXRyeTtcblxuICAvKipcbiAgICogTWFrZSBhIGNvbXBsZXRlIGNvcHkgb2YgdGhlIGdlb21ldHJ5LlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7IUdlb21ldHJ5fSBDbG9uZS5cbiAgICovXG4gIEdlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfTtcblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjbG9zZXN0UG9pbnQgQ2xvc2VzdCBwb2ludC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pblNxdWFyZWREaXN0YW5jZSBNaW5pbXVtIHNxdWFyZWQgZGlzdGFuY2UuXG4gICAqIEByZXR1cm4ge251bWJlcn0gTWluaW11bSBzcXVhcmVkIGRpc3RhbmNlLlxuICAgKi9cbiAgR2VvbWV0cnkucHJvdG90eXBlLmNsb3Nlc3RQb2ludFhZID0gZnVuY3Rpb24gY2xvc2VzdFBvaW50WFkgKHgsIHksIGNsb3Nlc3RQb2ludCwgbWluU3F1YXJlZERpc3RhbmNlKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IENvbnRhaW5zICh4LCB5KS5cbiAgICovXG4gIEdlb21ldHJ5LnByb3RvdHlwZS5jb250YWluc1hZID0gZnVuY3Rpb24gY29udGFpbnNYWSAoeCwgeSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjbG9zZXN0IHBvaW50IG9mIHRoZSBnZW9tZXRyeSB0byB0aGUgcGFzc2VkIHBvaW50IGFzXG4gICAqIHtAbGluayBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlIGNvb3JkaW5hdGV9LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gcG9pbnQgUG9pbnQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPX0gb3B0X2Nsb3Nlc3RQb2ludCBDbG9zZXN0IHBvaW50LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IENsb3Nlc3QgcG9pbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIEdlb21ldHJ5LnByb3RvdHlwZS5nZXRDbG9zZXN0UG9pbnQgPSBmdW5jdGlvbiBnZXRDbG9zZXN0UG9pbnQgKHBvaW50LCBvcHRfY2xvc2VzdFBvaW50KSB7XG4gICAgdmFyIGNsb3Nlc3RQb2ludCA9IG9wdF9jbG9zZXN0UG9pbnQgPyBvcHRfY2xvc2VzdFBvaW50IDogW05hTiwgTmFOXTtcbiAgICB0aGlzLmNsb3Nlc3RQb2ludFhZKHBvaW50WzBdLCBwb2ludFsxXSwgY2xvc2VzdFBvaW50LCBJbmZpbml0eSk7XG4gICAgcmV0dXJuIGNsb3Nlc3RQb2ludDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgZ2VvbWV0cnkgaW5jbHVkZXMgdGhlIHNwZWNpZmllZCBjb29yZGluYXRlLiBJZiB0aGVcbiAgICogY29vcmRpbmF0ZSBpcyBvbiB0aGUgYm91bmRhcnkgb2YgdGhlIGdlb21ldHJ5LCByZXR1cm5zIGZhbHNlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBDb250YWlucyBjb29yZGluYXRlLlxuICAgKiBAYXBpXG4gICAqL1xuICBHZW9tZXRyeS5wcm90b3R5cGUuaW50ZXJzZWN0c0Nvb3JkaW5hdGUgPSBmdW5jdGlvbiBpbnRlcnNlY3RzQ29vcmRpbmF0ZSAoY29vcmRpbmF0ZSkge1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5zWFkoY29vcmRpbmF0ZVswXSwgY29vcmRpbmF0ZVsxXSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICovXG4gIEdlb21ldHJ5LnByb3RvdHlwZS5jb21wdXRlRXh0ZW50ID0gZnVuY3Rpb24gY29tcHV0ZUV4dGVudCAoZXh0ZW50KSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZXh0ZW50IG9mIHRoZSBnZW9tZXRyeS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50PX0gb3B0X2V4dGVudCBFeHRlbnQuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIEdlb21ldHJ5LnByb3RvdHlwZS5nZXRFeHRlbnQgPSBmdW5jdGlvbiBnZXRFeHRlbnQgKG9wdF9leHRlbnQpIHtcbiAgICBpZiAodGhpcy5leHRlbnRSZXZpc2lvbl8gIT0gdGhpcy5nZXRSZXZpc2lvbigpKSB7XG4gICAgICB0aGlzLmV4dGVudF8gPSB0aGlzLmNvbXB1dGVFeHRlbnQodGhpcy5leHRlbnRfKTtcbiAgICAgIHRoaXMuZXh0ZW50UmV2aXNpb25fID0gdGhpcy5nZXRSZXZpc2lvbigpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuT3JVcGRhdGUodGhpcy5leHRlbnRfLCBvcHRfZXh0ZW50KTtcbiAgfTtcblxuICAvKipcbiAgICogUm90YXRlIHRoZSBnZW9tZXRyeSBhcm91bmQgYSBnaXZlbiBjb29yZGluYXRlLiBUaGlzIG1vZGlmaWVzIHRoZSBnZW9tZXRyeVxuICAgKiBjb29yZGluYXRlcyBpbiBwbGFjZS5cbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSBSb3RhdGlvbiBhbmdsZSBpbiByYWRpYW5zLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gYW5jaG9yIFRoZSByb3RhdGlvbiBjZW50ZXIuXG4gICAqIEBhcGlcbiAgICovXG4gIEdlb21ldHJ5LnByb3RvdHlwZS5yb3RhdGUgPSBmdW5jdGlvbiByb3RhdGUgKGFuZ2xlLCBhbmNob3IpIHtcbiAgICBhYnN0cmFjdCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTY2FsZSB0aGUgZ2VvbWV0cnkgKHdpdGggYW4gb3B0aW9uYWwgb3JpZ2luKS4gIFRoaXMgbW9kaWZpZXMgdGhlIGdlb21ldHJ5XG4gICAqIGNvb3JkaW5hdGVzIGluIHBsYWNlLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN4IFRoZSBzY2FsaW5nIGZhY3RvciBpbiB0aGUgeC1kaXJlY3Rpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X3N5IFRoZSBzY2FsaW5nIGZhY3RvciBpbiB0aGUgeS1kaXJlY3Rpb24gKGRlZmF1bHRzIHRvXG4gICAqICAgICBzeCkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPX0gb3B0X2FuY2hvciBUaGUgc2NhbGUgb3JpZ2luIChkZWZhdWx0cyB0byB0aGUgY2VudGVyXG4gICAqICAgICBvZiB0aGUgZ2VvbWV0cnkgZXh0ZW50KS5cbiAgICogQGFwaVxuICAgKi9cbiAgR2VvbWV0cnkucHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24gc2NhbGUgKHN4LCBvcHRfc3ksIG9wdF9hbmNob3IpIHtcbiAgICBhYnN0cmFjdCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBzaW1wbGlmaWVkIHZlcnNpb24gb2YgdGhpcyBnZW9tZXRyeS4gIEZvciBsaW5lc3RyaW5ncywgdGhpcyB1c2VzXG4gICAqIHRoZSB0aGUge0BsaW5rXG4gICAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JhbWVyLURvdWdsYXMtUGV1Y2tlcl9hbGdvcml0aG1cbiAgICogRG91Z2xhcyBQZXVja2VyfSBhbGdvcml0aG0uICBGb3IgcG9seWdvbnMsIGEgcXVhbnRpemF0aW9uLWJhc2VkXG4gICAqIHNpbXBsaWZpY2F0aW9uIGlzIHVzZWQgdG8gcHJlc2VydmUgdG9wb2xvZ3kuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0b2xlcmFuY2UgVGhlIHRvbGVyYW5jZSBkaXN0YW5jZSBmb3Igc2ltcGxpZmljYXRpb24uXG4gICAqIEByZXR1cm4ge0dlb21ldHJ5fSBBIG5ldywgc2ltcGxpZmllZCB2ZXJzaW9uIG9mIHRoZSBvcmlnaW5hbCBnZW9tZXRyeS5cbiAgICogQGFwaVxuICAgKi9cbiAgR2VvbWV0cnkucHJvdG90eXBlLnNpbXBsaWZ5ID0gZnVuY3Rpb24gc2ltcGxpZnkgKHRvbGVyYW5jZSkge1xuICAgIHJldHVybiB0aGlzLmdldFNpbXBsaWZpZWRHZW9tZXRyeSh0b2xlcmFuY2UgKiB0b2xlcmFuY2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBzaW1wbGlmaWVkIHZlcnNpb24gb2YgdGhpcyBnZW9tZXRyeSB1c2luZyB0aGUgRG91Z2xhcyBQZXVja2VyXG4gICAqIGFsZ29yaXRobS5cbiAgICogU2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JhbWVyLURvdWdsYXMtUGV1Y2tlcl9hbGdvcml0aG0uXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge251bWJlcn0gc3F1YXJlZFRvbGVyYW5jZSBTcXVhcmVkIHRvbGVyYW5jZS5cbiAgICogQHJldHVybiB7R2VvbWV0cnl9IFNpbXBsaWZpZWQgZ2VvbWV0cnkuXG4gICAqL1xuICBHZW9tZXRyeS5wcm90b3R5cGUuZ2V0U2ltcGxpZmllZEdlb21ldHJ5ID0gZnVuY3Rpb24gZ2V0U2ltcGxpZmllZEdlb21ldHJ5IChzcXVhcmVkVG9sZXJhbmNlKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdHlwZSBvZiB0aGlzIGdlb21ldHJ5LlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9HZW9tZXRyeVR5cGUuanNcIikuZGVmYXVsdH0gR2VvbWV0cnkgdHlwZS5cbiAgICovXG4gIEdlb21ldHJ5LnByb3RvdHlwZS5nZXRUeXBlID0gZnVuY3Rpb24gZ2V0VHlwZSAoKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFwcGx5IGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHRvIGVhY2ggY29vcmRpbmF0ZSBvZiB0aGUgZ2VvbWV0cnkuXG4gICAqIFRoZSBnZW9tZXRyeSBpcyBtb2RpZmllZCBpbiBwbGFjZS5cbiAgICogSWYgeW91IGRvIG5vdCB3YW50IHRoZSBnZW9tZXRyeSBtb2RpZmllZCBpbiBwbGFjZSwgZmlyc3QgYGNsb25lKClgIGl0IGFuZFxuICAgKiB0aGVuIHVzZSB0aGlzIGZ1bmN0aW9uIG9uIHRoZSBjbG9uZS5cbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5UcmFuc2Zvcm1GdW5jdGlvbn0gdHJhbnNmb3JtRm4gVHJhbnNmb3JtLlxuICAgKi9cbiAgR2VvbWV0cnkucHJvdG90eXBlLmFwcGx5VHJhbnNmb3JtID0gZnVuY3Rpb24gYXBwbHlUcmFuc2Zvcm0gKHRyYW5zZm9ybUZuKSB7XG4gICAgYWJzdHJhY3QoKTtcbiAgfTtcblxuICAvKipcbiAgICogVGVzdCBpZiB0aGUgZ2VvbWV0cnkgYW5kIHRoZSBwYXNzZWQgZXh0ZW50IGludGVyc2VjdC5cbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBnZW9tZXRyeSBhbmQgdGhlIGV4dGVudCBpbnRlcnNlY3QuXG4gICAqL1xuICBHZW9tZXRyeS5wcm90b3R5cGUuaW50ZXJzZWN0c0V4dGVudCA9IGZ1bmN0aW9uIGludGVyc2VjdHNFeHRlbnQgKGV4dGVudCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUcmFuc2xhdGUgdGhlIGdlb21ldHJ5LiAgVGhpcyBtb2RpZmllcyB0aGUgZ2VvbWV0cnkgY29vcmRpbmF0ZXMgaW4gcGxhY2UuICBJZlxuICAgKiBpbnN0ZWFkIHlvdSB3YW50IGEgbmV3IGdlb21ldHJ5LCBmaXJzdCBgY2xvbmUoKWAgdGhpcyBnZW9tZXRyeS5cbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVggRGVsdGEgWC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhWSBEZWx0YSBZLlxuICAgKiBAYXBpXG4gICAqL1xuICBHZW9tZXRyeS5wcm90b3R5cGUudHJhbnNsYXRlID0gZnVuY3Rpb24gdHJhbnNsYXRlIChkZWx0YVgsIGRlbHRhWSkge1xuICAgIGFic3RyYWN0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybSBlYWNoIGNvb3JkaW5hdGUgb2YgdGhlIGdlb21ldHJ5IGZyb20gb25lIGNvb3JkaW5hdGUgcmVmZXJlbmNlXG4gICAqIHN5c3RlbSB0byBhbm90aGVyLiBUaGUgZ2VvbWV0cnkgaXMgbW9kaWZpZWQgaW4gcGxhY2UuXG4gICAqIEZvciBleGFtcGxlLCBhIGxpbmUgd2lsbCBiZSB0cmFuc2Zvcm1lZCB0byBhIGxpbmUgYW5kIGEgY2lyY2xlIHRvIGEgY2lyY2xlLlxuICAgKiBJZiB5b3UgZG8gbm90IHdhbnQgdGhlIGdlb21ldHJ5IG1vZGlmaWVkIGluIHBsYWNlLCBmaXJzdCBgY2xvbmUoKWAgaXQgYW5kXG4gICAqIHRoZW4gdXNlIHRoaXMgZnVuY3Rpb24gb24gdGhlIGNsb25lLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ouanNcIikuUHJvamVjdGlvbkxpa2V9IHNvdXJjZSBUaGUgY3VycmVudCBwcm9qZWN0aW9uLiAgQ2FuIGJlIGFcbiAgICogICAgIHN0cmluZyBpZGVudGlmaWVyIG9yIGEge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb25+UHJvamVjdGlvbn0gb2JqZWN0LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ouanNcIikuUHJvamVjdGlvbkxpa2V9IGRlc3RpbmF0aW9uIFRoZSBkZXNpcmVkIHByb2plY3Rpb24uICBDYW4gYmUgYVxuICAgKiAgICAgc3RyaW5nIGlkZW50aWZpZXIgb3IgYSB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn5Qcm9qZWN0aW9ufSBvYmplY3QuXG4gICAqIEByZXR1cm4ge0dlb21ldHJ5fSBUaGlzIGdlb21ldHJ5LiAgTm90ZSB0aGF0IG9yaWdpbmFsIGdlb21ldHJ5IGlzXG4gICAqICAgICBtb2RpZmllZCBpbiBwbGFjZS5cbiAgICogQGFwaVxuICAgKi9cbiAgR2VvbWV0cnkucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIHRyYW5zZm9ybSAoc291cmNlLCBkZXN0aW5hdGlvbikge1xuICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9ICovXG4gICAgdmFyIHNvdXJjZVByb2ogPSBnZXRQcm9qZWN0aW9uKHNvdXJjZSk7XG4gICAgdmFyIHRyYW5zZm9ybUZuID0gc291cmNlUHJvai5nZXRVbml0cygpID09IFVuaXRzLlRJTEVfUElYRUxTID9cbiAgICAgIGZ1bmN0aW9uKGluQ29vcmRpbmF0ZXMsIG91dENvb3JkaW5hdGVzLCBzdHJpZGUpIHtcbiAgICAgICAgdmFyIHBpeGVsRXh0ZW50ID0gc291cmNlUHJvai5nZXRFeHRlbnQoKTtcbiAgICAgICAgdmFyIHByb2plY3RlZEV4dGVudCA9IHNvdXJjZVByb2ouZ2V0V29ybGRFeHRlbnQoKTtcbiAgICAgICAgdmFyIHNjYWxlID0gZ2V0SGVpZ2h0KHByb2plY3RlZEV4dGVudCkgLyBnZXRIZWlnaHQocGl4ZWxFeHRlbnQpO1xuICAgICAgICBjb21wb3NlVHJhbnNmb3JtKHRtcFRyYW5zZm9ybSxcbiAgICAgICAgICBwcm9qZWN0ZWRFeHRlbnRbMF0sIHByb2plY3RlZEV4dGVudFszXSxcbiAgICAgICAgICBzY2FsZSwgLXNjYWxlLCAwLFxuICAgICAgICAgIDAsIDApO1xuICAgICAgICB0cmFuc2Zvcm0yRChpbkNvb3JkaW5hdGVzLCAwLCBpbkNvb3JkaW5hdGVzLmxlbmd0aCwgc3RyaWRlLFxuICAgICAgICAgIHRtcFRyYW5zZm9ybSwgb3V0Q29vcmRpbmF0ZXMpO1xuICAgICAgICByZXR1cm4gZ2V0VHJhbnNmb3JtKHNvdXJjZVByb2osIGRlc3RpbmF0aW9uKShpbkNvb3JkaW5hdGVzLCBvdXRDb29yZGluYXRlcywgc3RyaWRlKTtcbiAgICAgIH0gOlxuICAgICAgZ2V0VHJhbnNmb3JtKHNvdXJjZVByb2osIGRlc3RpbmF0aW9uKTtcbiAgICB0aGlzLmFwcGx5VHJhbnNmb3JtKHRyYW5zZm9ybUZuKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICByZXR1cm4gR2VvbWV0cnk7XG59KEJhc2VPYmplY3QpKTtcblxuXG5leHBvcnQgZGVmYXVsdCBHZW9tZXRyeTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R2VvbWV0cnkuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vR2VvbWV0cnlMYXlvdXRcbiAqL1xuXG4vKipcbiAqIFRoZSBjb29yZGluYXRlIGxheW91dCBmb3IgZ2VvbWV0cmllcywgaW5kaWNhdGluZyB3aGV0aGVyIGEgM3JkIG9yIDR0aCB6ICgnWicpXG4gKiBvciBtZWFzdXJlICgnTScpIGNvb3JkaW5hdGUgaXMgYXZhaWxhYmxlLiBTdXBwb3J0ZWQgdmFsdWVzIGFyZSBgJ1hZJ2AsXG4gKiBgJ1hZWidgLCBgJ1hZTSdgLCBgJ1hZWk0nYC5cbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgWFk6ICdYWScsXG4gIFhZWjogJ1hZWicsXG4gIFhZTTogJ1hZTScsXG4gIFhZWk06ICdYWVpNJ1xufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R2VvbWV0cnlMYXlvdXQuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vR2VvbWV0cnlUeXBlXG4gKi9cblxuLyoqXG4gKiBUaGUgZ2VvbWV0cnkgdHlwZS4gT25lIG9mIGAnUG9pbnQnYCwgYCdMaW5lU3RyaW5nJ2AsIGAnTGluZWFyUmluZydgLFxuICogYCdQb2x5Z29uJ2AsIGAnTXVsdGlQb2ludCdgLCBgJ011bHRpTGluZVN0cmluZydgLCBgJ011bHRpUG9seWdvbidgLFxuICogYCdHZW9tZXRyeUNvbGxlY3Rpb24nYCwgYCdDaXJjbGUnYC5cbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgUE9JTlQ6ICdQb2ludCcsXG4gIExJTkVfU1RSSU5HOiAnTGluZVN0cmluZycsXG4gIExJTkVBUl9SSU5HOiAnTGluZWFyUmluZycsXG4gIFBPTFlHT046ICdQb2x5Z29uJyxcbiAgTVVMVElfUE9JTlQ6ICdNdWx0aVBvaW50JyxcbiAgTVVMVElfTElORV9TVFJJTkc6ICdNdWx0aUxpbmVTdHJpbmcnLFxuICBNVUxUSV9QT0xZR09OOiAnTXVsdGlQb2x5Z29uJyxcbiAgR0VPTUVUUllfQ09MTEVDVElPTjogJ0dlb21ldHJ5Q29sbGVjdGlvbicsXG4gIENJUkNMRTogJ0NpcmNsZSdcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdlb21ldHJ5VHlwZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9MaW5lU3RyaW5nXG4gKi9cbmltcG9ydCB7ZXh0ZW5kfSBmcm9tICcuLi9hcnJheS5qcyc7XG5pbXBvcnQge2Nsb3Nlc3RTcXVhcmVkRGlzdGFuY2VYWX0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCBHZW9tZXRyeUxheW91dCBmcm9tICcuL0dlb21ldHJ5TGF5b3V0LmpzJztcbmltcG9ydCBHZW9tZXRyeVR5cGUgZnJvbSAnLi9HZW9tZXRyeVR5cGUuanMnO1xuaW1wb3J0IFNpbXBsZUdlb21ldHJ5IGZyb20gJy4vU2ltcGxlR2VvbWV0cnkuanMnO1xuaW1wb3J0IHthc3NpZ25DbG9zZXN0UG9pbnQsIG1heFNxdWFyZWREZWx0YX0gZnJvbSAnLi9mbGF0L2Nsb3Nlc3QuanMnO1xuaW1wb3J0IHtkZWZsYXRlQ29vcmRpbmF0ZXN9IGZyb20gJy4vZmxhdC9kZWZsYXRlLmpzJztcbmltcG9ydCB7aW5mbGF0ZUNvb3JkaW5hdGVzfSBmcm9tICcuL2ZsYXQvaW5mbGF0ZS5qcyc7XG5pbXBvcnQge2ludGVycG9sYXRlUG9pbnQsIGxpbmVTdHJpbmdDb29yZGluYXRlQXRNfSBmcm9tICcuL2ZsYXQvaW50ZXJwb2xhdGUuanMnO1xuaW1wb3J0IHtpbnRlcnNlY3RzTGluZVN0cmluZ30gZnJvbSAnLi9mbGF0L2ludGVyc2VjdHNleHRlbnQuanMnO1xuaW1wb3J0IHtsaW5lU3RyaW5nTGVuZ3RofSBmcm9tICcuL2ZsYXQvbGVuZ3RoLmpzJztcbmltcG9ydCB7Zm9yRWFjaCBhcyBmb3JFYWNoU2VnbWVudH0gZnJvbSAnLi9mbGF0L3NlZ21lbnRzLmpzJztcbmltcG9ydCB7ZG91Z2xhc1BldWNrZXJ9IGZyb20gJy4vZmxhdC9zaW1wbGlmeS5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogTGluZXN0cmluZyBnZW9tZXRyeS5cbiAqXG4gKiBAYXBpXG4gKi9cbnZhciBMaW5lU3RyaW5nID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoU2ltcGxlR2VvbWV0cnkpIHtcbiAgZnVuY3Rpb24gTGluZVN0cmluZyhjb29yZGluYXRlcywgb3B0X2xheW91dCkge1xuXG4gICAgU2ltcGxlR2VvbWV0cnkuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLmZsYXRNaWRwb2ludF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZmxhdE1pZHBvaW50UmV2aXNpb25fID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXhEZWx0YV8gPSAtMTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1heERlbHRhUmV2aXNpb25fID0gLTE7XG5cbiAgICBpZiAob3B0X2xheW91dCAhPT0gdW5kZWZpbmVkICYmICFBcnJheS5pc0FycmF5KGNvb3JkaW5hdGVzWzBdKSkge1xuICAgICAgdGhpcy5zZXRGbGF0Q29vcmRpbmF0ZXMob3B0X2xheW91dCwgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqLyAoY29vcmRpbmF0ZXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRDb29yZGluYXRlcygvKiogQHR5cGUge0FycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59ICovIChjb29yZGluYXRlcyksIG9wdF9sYXlvdXQpO1xuICAgIH1cblxuICB9XG5cbiAgaWYgKCBTaW1wbGVHZW9tZXRyeSApIExpbmVTdHJpbmcuX19wcm90b19fID0gU2ltcGxlR2VvbWV0cnk7XG4gIExpbmVTdHJpbmcucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU2ltcGxlR2VvbWV0cnkgJiYgU2ltcGxlR2VvbWV0cnkucHJvdG90eXBlICk7XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGluZVN0cmluZztcblxuICAvKipcbiAgICogQXBwZW5kIHRoZSBwYXNzZWQgY29vcmRpbmF0ZSB0byB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIGxpbmVzdHJpbmcuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gICAqIEBhcGlcbiAgICovXG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmFwcGVuZENvb3JkaW5hdGUgPSBmdW5jdGlvbiBhcHBlbmRDb29yZGluYXRlIChjb29yZGluYXRlKSB7XG4gICAgaWYgKCF0aGlzLmZsYXRDb29yZGluYXRlcykge1xuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMgPSBjb29yZGluYXRlLnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4dGVuZCh0aGlzLmZsYXRDb29yZGluYXRlcywgY29vcmRpbmF0ZSk7XG4gICAgfVxuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNYWtlIGEgY29tcGxldGUgY29weSBvZiB0aGUgZ2VvbWV0cnkuXG4gICAqIEByZXR1cm4geyFMaW5lU3RyaW5nfSBDbG9uZS5cbiAgICogQG92ZXJyaWRlXG4gICAqIEBhcGlcbiAgICovXG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgIHJldHVybiBuZXcgTGluZVN0cmluZyh0aGlzLmZsYXRDb29yZGluYXRlcy5zbGljZSgpLCB0aGlzLmxheW91dCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5jbG9zZXN0UG9pbnRYWSA9IGZ1bmN0aW9uIGNsb3Nlc3RQb2ludFhZICh4LCB5LCBjbG9zZXN0UG9pbnQsIG1pblNxdWFyZWREaXN0YW5jZSkge1xuICAgIGlmIChtaW5TcXVhcmVkRGlzdGFuY2UgPCBjbG9zZXN0U3F1YXJlZERpc3RhbmNlWFkodGhpcy5nZXRFeHRlbnQoKSwgeCwgeSkpIHtcbiAgICAgIHJldHVybiBtaW5TcXVhcmVkRGlzdGFuY2U7XG4gICAgfVxuICAgIGlmICh0aGlzLm1heERlbHRhUmV2aXNpb25fICE9IHRoaXMuZ2V0UmV2aXNpb24oKSkge1xuICAgICAgdGhpcy5tYXhEZWx0YV8gPSBNYXRoLnNxcnQobWF4U3F1YXJlZERlbHRhKFxuICAgICAgICB0aGlzLmZsYXRDb29yZGluYXRlcywgMCwgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLCB0aGlzLnN0cmlkZSwgMCkpO1xuICAgICAgdGhpcy5tYXhEZWx0YVJldmlzaW9uXyA9IHRoaXMuZ2V0UmV2aXNpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIGFzc2lnbkNsb3Nlc3RQb2ludChcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHRoaXMuc3RyaWRlLFxuICAgICAgdGhpcy5tYXhEZWx0YV8sIGZhbHNlLCB4LCB5LCBjbG9zZXN0UG9pbnQsIG1pblNxdWFyZWREaXN0YW5jZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGUgb3ZlciBlYWNoIHNlZ21lbnQsIGNhbGxpbmcgdGhlIHByb3ZpZGVkIGNhbGxiYWNrLlxuICAgKiBJZiB0aGUgY2FsbGJhY2sgcmV0dXJucyBhIHRydXRoeSB2YWx1ZSB0aGUgZnVuY3Rpb24gcmV0dXJucyB0aGF0XG4gICAqIHZhbHVlIGltbWVkaWF0ZWx5LiBPdGhlcndpc2UgdGhlIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYC5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBTLCBpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGUsIGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZSk6IFR9IGNhbGxiYWNrIEZ1bmN0aW9uXG4gICAqICAgICBjYWxsZWQgZm9yIGVhY2ggc2VnbWVudC5cbiAgICogQHJldHVybiB7VHxib29sZWFufSBWYWx1ZS5cbiAgICogQHRlbXBsYXRlIFQsU1xuICAgKiBAYXBpXG4gICAqL1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5mb3JFYWNoU2VnbWVudCA9IGZ1bmN0aW9uIGZvckVhY2hTZWdtZW50JDEgKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZvckVhY2hTZWdtZW50KHRoaXMuZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHRoaXMuc3RyaWRlLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvb3JkaW5hdGUgYXQgYG1gIHVzaW5nIGxpbmVhciBpbnRlcnBvbGF0aW9uLCBvciBgbnVsbGAgaWYgbm9cbiAgICogc3VjaCBjb29yZGluYXRlIGV4aXN0cy5cbiAgICpcbiAgICogYG9wdF9leHRyYXBvbGF0ZWAgY29udHJvbHMgZXh0cmFwb2xhdGlvbiBiZXlvbmQgdGhlIHJhbmdlIG9mIE1zIGluIHRoZVxuICAgKiBNdWx0aUxpbmVTdHJpbmcuIElmIGBvcHRfZXh0cmFwb2xhdGVgIGlzIGB0cnVlYCB0aGVuIE1zIGxlc3MgdGhhbiB0aGUgZmlyc3RcbiAgICogTSB3aWxsIHJldHVybiB0aGUgZmlyc3QgY29vcmRpbmF0ZSBhbmQgTXMgZ3JlYXRlciB0aGFuIHRoZSBsYXN0IE0gd2lsbFxuICAgKiByZXR1cm4gdGhlIGxhc3QgY29vcmRpbmF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG0gTS5cbiAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0X2V4dHJhcG9sYXRlIEV4dHJhcG9sYXRlLiBEZWZhdWx0IGlzIGBmYWxzZWAuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gQ29vcmRpbmF0ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZUF0TSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVBdE0gKG0sIG9wdF9leHRyYXBvbGF0ZSkge1xuICAgIGlmICh0aGlzLmxheW91dCAhPSBHZW9tZXRyeUxheW91dC5YWU0gJiZcbiAgICAgICAgdGhpcy5sYXlvdXQgIT0gR2VvbWV0cnlMYXlvdXQuWFlaTSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBleHRyYXBvbGF0ZSA9IG9wdF9leHRyYXBvbGF0ZSAhPT0gdW5kZWZpbmVkID8gb3B0X2V4dHJhcG9sYXRlIDogZmFsc2U7XG4gICAgcmV0dXJuIGxpbmVTdHJpbmdDb29yZGluYXRlQXRNKHRoaXMuZmxhdENvb3JkaW5hdGVzLCAwLFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLCB0aGlzLnN0cmlkZSwgbSwgZXh0cmFwb2xhdGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBsaW5lc3RyaW5nLlxuICAgKiBAcmV0dXJuIHtBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSBDb29yZGluYXRlcy5cbiAgICogQG92ZXJyaWRlXG4gICAqIEBhcGlcbiAgICovXG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmdldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZXMgKCkge1xuICAgIHJldHVybiBpbmZsYXRlQ29vcmRpbmF0ZXMoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcywgMCwgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLCB0aGlzLnN0cmlkZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY29vcmRpbmF0ZSBhdCB0aGUgcHJvdmlkZWQgZnJhY3Rpb24gYWxvbmcgdGhlIGxpbmVzdHJpbmcuXG4gICAqIFRoZSBgZnJhY3Rpb25gIGlzIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMSwgd2hlcmUgMCBpcyB0aGUgc3RhcnQgb2YgdGhlXG4gICAqIGxpbmVzdHJpbmcgYW5kIDEgaXMgdGhlIGVuZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyYWN0aW9uIEZyYWN0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT19IG9wdF9kZXN0IE9wdGlvbmFsIGNvb3JkaW5hdGUgd2hvc2UgdmFsdWVzIHdpbGxcbiAgICogICAgIGJlIG1vZGlmaWVkLiBJZiBub3QgcHJvdmlkZWQsIGEgbmV3IGNvb3JkaW5hdGUgd2lsbCBiZSByZXR1cm5lZC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBDb29yZGluYXRlIG9mIHRoZSBpbnRlcnBvbGF0ZWQgcG9pbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmdldENvb3JkaW5hdGVBdCA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVBdCAoZnJhY3Rpb24sIG9wdF9kZXN0KSB7XG4gICAgcmV0dXJuIGludGVycG9sYXRlUG9pbnQoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcywgMCwgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLCB0aGlzLnN0cmlkZSxcbiAgICAgIGZyYWN0aW9uLCBvcHRfZGVzdCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBsaW5lc3RyaW5nIG9uIHByb2plY3RlZCBwbGFuZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBMZW5ndGggKG9uIHByb2plY3RlZCBwbGFuZSkuXG4gICAqIEBhcGlcbiAgICovXG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uIGdldExlbmd0aCAoKSB7XG4gICAgcmV0dXJuIGxpbmVTdHJpbmdMZW5ndGgoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcywgMCwgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLCB0aGlzLnN0cmlkZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEZsYXQgbWlkcG9pbnQuXG4gICAqL1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXRGbGF0TWlkcG9pbnQgPSBmdW5jdGlvbiBnZXRGbGF0TWlkcG9pbnQgKCkge1xuICAgIGlmICh0aGlzLmZsYXRNaWRwb2ludFJldmlzaW9uXyAhPSB0aGlzLmdldFJldmlzaW9uKCkpIHtcbiAgICAgIHRoaXMuZmxhdE1pZHBvaW50XyA9IHRoaXMuZ2V0Q29vcmRpbmF0ZUF0KDAuNSwgdGhpcy5mbGF0TWlkcG9pbnRfKTtcbiAgICAgIHRoaXMuZmxhdE1pZHBvaW50UmV2aXNpb25fID0gdGhpcy5nZXRSZXZpc2lvbigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mbGF0TWlkcG9pbnRfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0U2ltcGxpZmllZEdlb21ldHJ5SW50ZXJuYWwgPSBmdW5jdGlvbiBnZXRTaW1wbGlmaWVkR2VvbWV0cnlJbnRlcm5hbCAoc3F1YXJlZFRvbGVyYW5jZSkge1xuICAgIHZhciBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzID0gW107XG4gICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcy5sZW5ndGggPSBkb3VnbGFzUGV1Y2tlcihcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHRoaXMuc3RyaWRlLFxuICAgICAgc3F1YXJlZFRvbGVyYW5jZSwgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcywgMCk7XG4gICAgcmV0dXJuIG5ldyBMaW5lU3RyaW5nKHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsIEdlb21ldHJ5TGF5b3V0LlhZKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGFwaVxuICAgKi9cbiAgTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0VHlwZSA9IGZ1bmN0aW9uIGdldFR5cGUgKCkge1xuICAgIHJldHVybiBHZW9tZXRyeVR5cGUuTElORV9TVFJJTkc7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqIEBhcGlcbiAgICovXG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmludGVyc2VjdHNFeHRlbnQgPSBmdW5jdGlvbiBpbnRlcnNlY3RzRXh0ZW50IChleHRlbnQpIHtcbiAgICByZXR1cm4gaW50ZXJzZWN0c0xpbmVTdHJpbmcoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcywgMCwgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLCB0aGlzLnN0cmlkZSxcbiAgICAgIGV4dGVudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIGxpbmVzdHJpbmcuXG4gICAqIEBwYXJhbSB7IUFycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59IGNvb3JkaW5hdGVzIENvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0ge0dlb21ldHJ5TGF5b3V0PX0gb3B0X2xheW91dCBMYXlvdXQuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5zZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIHNldENvb3JkaW5hdGVzIChjb29yZGluYXRlcywgb3B0X2xheW91dCkge1xuICAgIHRoaXMuc2V0TGF5b3V0KG9wdF9sYXlvdXQsIGNvb3JkaW5hdGVzLCAxKTtcbiAgICBpZiAoIXRoaXMuZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyA9IFtdO1xuICAgIH1cbiAgICB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGggPSBkZWZsYXRlQ29vcmRpbmF0ZXMoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcywgMCwgY29vcmRpbmF0ZXMsIHRoaXMuc3RyaWRlKTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuICByZXR1cm4gTGluZVN0cmluZztcbn0oU2ltcGxlR2VvbWV0cnkpKTtcblxuXG5leHBvcnQgZGVmYXVsdCBMaW5lU3RyaW5nO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1MaW5lU3RyaW5nLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL0xpbmVhclJpbmdcbiAqL1xuaW1wb3J0IHtjbG9zZXN0U3F1YXJlZERpc3RhbmNlWFl9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQgR2VvbWV0cnlMYXlvdXQgZnJvbSAnLi9HZW9tZXRyeUxheW91dC5qcyc7XG5pbXBvcnQgR2VvbWV0cnlUeXBlIGZyb20gJy4vR2VvbWV0cnlUeXBlLmpzJztcbmltcG9ydCBTaW1wbGVHZW9tZXRyeSBmcm9tICcuL1NpbXBsZUdlb21ldHJ5LmpzJztcbmltcG9ydCB7bGluZWFyUmluZyBhcyBsaW5lYXJSaW5nQXJlYX0gZnJvbSAnLi9mbGF0L2FyZWEuanMnO1xuaW1wb3J0IHthc3NpZ25DbG9zZXN0UG9pbnQsIG1heFNxdWFyZWREZWx0YX0gZnJvbSAnLi9mbGF0L2Nsb3Nlc3QuanMnO1xuaW1wb3J0IHtkZWZsYXRlQ29vcmRpbmF0ZXN9IGZyb20gJy4vZmxhdC9kZWZsYXRlLmpzJztcbmltcG9ydCB7aW5mbGF0ZUNvb3JkaW5hdGVzfSBmcm9tICcuL2ZsYXQvaW5mbGF0ZS5qcyc7XG5pbXBvcnQge2RvdWdsYXNQZXVja2VyfSBmcm9tICcuL2ZsYXQvc2ltcGxpZnkuanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIExpbmVhciByaW5nIGdlb21ldHJ5LiBPbmx5IHVzZWQgYXMgcGFydCBvZiBwb2x5Z29uOyBjYW5ub3QgYmUgcmVuZGVyZWRcbiAqIG9uIGl0cyBvd24uXG4gKlxuICogQGFwaVxuICovXG52YXIgTGluZWFyUmluZyA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFNpbXBsZUdlb21ldHJ5KSB7XG4gIGZ1bmN0aW9uIExpbmVhclJpbmcoY29vcmRpbmF0ZXMsIG9wdF9sYXlvdXQpIHtcblxuICAgIFNpbXBsZUdlb21ldHJ5LmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXhEZWx0YV8gPSAtMTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1heERlbHRhUmV2aXNpb25fID0gLTE7XG5cbiAgICBpZiAob3B0X2xheW91dCAhPT0gdW5kZWZpbmVkICYmICFBcnJheS5pc0FycmF5KGNvb3JkaW5hdGVzWzBdKSkge1xuICAgICAgdGhpcy5zZXRGbGF0Q29vcmRpbmF0ZXMob3B0X2xheW91dCwgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqLyAoY29vcmRpbmF0ZXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRDb29yZGluYXRlcygvKiogQHR5cGUge0FycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59ICovIChjb29yZGluYXRlcyksIG9wdF9sYXlvdXQpO1xuICAgIH1cblxuICB9XG5cbiAgaWYgKCBTaW1wbGVHZW9tZXRyeSApIExpbmVhclJpbmcuX19wcm90b19fID0gU2ltcGxlR2VvbWV0cnk7XG4gIExpbmVhclJpbmcucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU2ltcGxlR2VvbWV0cnkgJiYgU2ltcGxlR2VvbWV0cnkucHJvdG90eXBlICk7XG4gIExpbmVhclJpbmcucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGluZWFyUmluZztcblxuICAvKipcbiAgICogTWFrZSBhIGNvbXBsZXRlIGNvcHkgb2YgdGhlIGdlb21ldHJ5LlxuICAgKiBAcmV0dXJuIHshTGluZWFyUmluZ30gQ2xvbmUuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBMaW5lYXJSaW5nLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgICByZXR1cm4gbmV3IExpbmVhclJpbmcodGhpcy5mbGF0Q29vcmRpbmF0ZXMuc2xpY2UoKSwgdGhpcy5sYXlvdXQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgTGluZWFyUmluZy5wcm90b3R5cGUuY2xvc2VzdFBvaW50WFkgPSBmdW5jdGlvbiBjbG9zZXN0UG9pbnRYWSAoeCwgeSwgY2xvc2VzdFBvaW50LCBtaW5TcXVhcmVkRGlzdGFuY2UpIHtcbiAgICBpZiAobWluU3F1YXJlZERpc3RhbmNlIDwgY2xvc2VzdFNxdWFyZWREaXN0YW5jZVhZKHRoaXMuZ2V0RXh0ZW50KCksIHgsIHkpKSB7XG4gICAgICByZXR1cm4gbWluU3F1YXJlZERpc3RhbmNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXhEZWx0YVJldmlzaW9uXyAhPSB0aGlzLmdldFJldmlzaW9uKCkpIHtcbiAgICAgIHRoaXMubWF4RGVsdGFfID0gTWF0aC5zcXJ0KG1heFNxdWFyZWREZWx0YShcbiAgICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCwgdGhpcy5zdHJpZGUsIDApKTtcbiAgICAgIHRoaXMubWF4RGVsdGFSZXZpc2lvbl8gPSB0aGlzLmdldFJldmlzaW9uKCk7XG4gICAgfVxuICAgIHJldHVybiBhc3NpZ25DbG9zZXN0UG9pbnQoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcywgMCwgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLCB0aGlzLnN0cmlkZSxcbiAgICAgIHRoaXMubWF4RGVsdGFfLCB0cnVlLCB4LCB5LCBjbG9zZXN0UG9pbnQsIG1pblNxdWFyZWREaXN0YW5jZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgYXJlYSBvZiB0aGUgbGluZWFyIHJpbmcgb24gcHJvamVjdGVkIHBsYW5lLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEFyZWEgKG9uIHByb2plY3RlZCBwbGFuZSkuXG4gICAqIEBhcGlcbiAgICovXG4gIExpbmVhclJpbmcucHJvdG90eXBlLmdldEFyZWEgPSBmdW5jdGlvbiBnZXRBcmVhICgpIHtcbiAgICByZXR1cm4gbGluZWFyUmluZ0FyZWEodGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCwgdGhpcy5zdHJpZGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBsaW5lYXIgcmluZy5cbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn0gQ29vcmRpbmF0ZXMuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBMaW5lYXJSaW5nLnByb3RvdHlwZS5nZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVzICgpIHtcbiAgICByZXR1cm4gaW5mbGF0ZUNvb3JkaW5hdGVzKFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCwgdGhpcy5zdHJpZGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgTGluZWFyUmluZy5wcm90b3R5cGUuZ2V0U2ltcGxpZmllZEdlb21ldHJ5SW50ZXJuYWwgPSBmdW5jdGlvbiBnZXRTaW1wbGlmaWVkR2VvbWV0cnlJbnRlcm5hbCAoc3F1YXJlZFRvbGVyYW5jZSkge1xuICAgIHZhciBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzID0gW107XG4gICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcy5sZW5ndGggPSBkb3VnbGFzUGV1Y2tlcihcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHRoaXMuc3RyaWRlLFxuICAgICAgc3F1YXJlZFRvbGVyYW5jZSwgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcywgMCk7XG4gICAgcmV0dXJuIG5ldyBMaW5lYXJSaW5nKHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsIEdlb21ldHJ5TGF5b3V0LlhZKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGFwaVxuICAgKi9cbiAgTGluZWFyUmluZy5wcm90b3R5cGUuZ2V0VHlwZSA9IGZ1bmN0aW9uIGdldFR5cGUgKCkge1xuICAgIHJldHVybiBHZW9tZXRyeVR5cGUuTElORUFSX1JJTkc7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBMaW5lYXJSaW5nLnByb3RvdHlwZS5pbnRlcnNlY3RzRXh0ZW50ID0gZnVuY3Rpb24gaW50ZXJzZWN0c0V4dGVudCAoZXh0ZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBsaW5lYXIgcmluZy5cbiAgICogQHBhcmFtIHshQXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7R2VvbWV0cnlMYXlvdXQ9fSBvcHRfbGF5b3V0IExheW91dC5cbiAgICogQG92ZXJyaWRlXG4gICAqIEBhcGlcbiAgICovXG4gIExpbmVhclJpbmcucHJvdG90eXBlLnNldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gc2V0Q29vcmRpbmF0ZXMgKGNvb3JkaW5hdGVzLCBvcHRfbGF5b3V0KSB7XG4gICAgdGhpcy5zZXRMYXlvdXQob3B0X2xheW91dCwgY29vcmRpbmF0ZXMsIDEpO1xuICAgIGlmICghdGhpcy5mbGF0Q29vcmRpbmF0ZXMpIHtcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzID0gW107XG4gICAgfVxuICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCA9IGRlZmxhdGVDb29yZGluYXRlcyhcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLCAwLCBjb29yZGluYXRlcywgdGhpcy5zdHJpZGUpO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9O1xuXG4gIHJldHVybiBMaW5lYXJSaW5nO1xufShTaW1wbGVHZW9tZXRyeSkpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IExpbmVhclJpbmc7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxpbmVhclJpbmcuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vTXVsdGlMaW5lU3RyaW5nXG4gKi9cbmltcG9ydCB7ZXh0ZW5kfSBmcm9tICcuLi9hcnJheS5qcyc7XG5pbXBvcnQge2Nsb3Nlc3RTcXVhcmVkRGlzdGFuY2VYWX0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCBHZW9tZXRyeUxheW91dCBmcm9tICcuL0dlb21ldHJ5TGF5b3V0LmpzJztcbmltcG9ydCBHZW9tZXRyeVR5cGUgZnJvbSAnLi9HZW9tZXRyeVR5cGUuanMnO1xuaW1wb3J0IExpbmVTdHJpbmcgZnJvbSAnLi9MaW5lU3RyaW5nLmpzJztcbmltcG9ydCBTaW1wbGVHZW9tZXRyeSBmcm9tICcuL1NpbXBsZUdlb21ldHJ5LmpzJztcbmltcG9ydCB7YXNzaWduQ2xvc2VzdEFycmF5UG9pbnQsIGFycmF5TWF4U3F1YXJlZERlbHRhfSBmcm9tICcuL2ZsYXQvY2xvc2VzdC5qcyc7XG5pbXBvcnQge2RlZmxhdGVDb29yZGluYXRlc0FycmF5fSBmcm9tICcuL2ZsYXQvZGVmbGF0ZS5qcyc7XG5pbXBvcnQge2luZmxhdGVDb29yZGluYXRlc0FycmF5fSBmcm9tICcuL2ZsYXQvaW5mbGF0ZS5qcyc7XG5pbXBvcnQge2ludGVycG9sYXRlUG9pbnQsIGxpbmVTdHJpbmdzQ29vcmRpbmF0ZUF0TX0gZnJvbSAnLi9mbGF0L2ludGVycG9sYXRlLmpzJztcbmltcG9ydCB7aW50ZXJzZWN0c0xpbmVTdHJpbmdBcnJheX0gZnJvbSAnLi9mbGF0L2ludGVyc2VjdHNleHRlbnQuanMnO1xuaW1wb3J0IHtkb3VnbGFzUGV1Y2tlckFycmF5fSBmcm9tICcuL2ZsYXQvc2ltcGxpZnkuanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIE11bHRpLWxpbmVzdHJpbmcgZ2VvbWV0cnkuXG4gKlxuICogQGFwaVxuICovXG52YXIgTXVsdGlMaW5lU3RyaW5nID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoU2ltcGxlR2VvbWV0cnkpIHtcbiAgZnVuY3Rpb24gTXVsdGlMaW5lU3RyaW5nKGNvb3JkaW5hdGVzLCBvcHRfbGF5b3V0LCBvcHRfZW5kcykge1xuXG4gICAgU2ltcGxlR2VvbWV0cnkuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5lbmRzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4RGVsdGFfID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXhEZWx0YVJldmlzaW9uXyA9IC0xO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29vcmRpbmF0ZXNbMF0pKSB7XG4gICAgICB0aGlzLnNldENvb3JkaW5hdGVzKC8qKiBAdHlwZSB7QXJyYXk8QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj59ICovIChjb29yZGluYXRlcyksIG9wdF9sYXlvdXQpO1xuICAgIH0gZWxzZSBpZiAob3B0X2xheW91dCAhPT0gdW5kZWZpbmVkICYmIG9wdF9lbmRzKSB7XG4gICAgICB0aGlzLnNldEZsYXRDb29yZGluYXRlcyhvcHRfbGF5b3V0LCAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovIChjb29yZGluYXRlcykpO1xuICAgICAgdGhpcy5lbmRzXyA9IG9wdF9lbmRzO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbGF5b3V0ID0gdGhpcy5nZXRMYXlvdXQoKTtcbiAgICAgIHZhciBsaW5lU3RyaW5ncyA9IC8qKiBAdHlwZSB7QXJyYXk8TGluZVN0cmluZz59ICovIChjb29yZGluYXRlcyk7XG4gICAgICB2YXIgZmxhdENvb3JkaW5hdGVzID0gW107XG4gICAgICB2YXIgZW5kcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gbGluZVN0cmluZ3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICB2YXIgbGluZVN0cmluZyA9IGxpbmVTdHJpbmdzW2ldO1xuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgIGxheW91dCA9IGxpbmVTdHJpbmcuZ2V0TGF5b3V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZXh0ZW5kKGZsYXRDb29yZGluYXRlcywgbGluZVN0cmluZy5nZXRGbGF0Q29vcmRpbmF0ZXMoKSk7XG4gICAgICAgIGVuZHMucHVzaChmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0RmxhdENvb3JkaW5hdGVzKGxheW91dCwgZmxhdENvb3JkaW5hdGVzKTtcbiAgICAgIHRoaXMuZW5kc18gPSBlbmRzO1xuICAgIH1cblxuICB9XG5cbiAgaWYgKCBTaW1wbGVHZW9tZXRyeSApIE11bHRpTGluZVN0cmluZy5fX3Byb3RvX18gPSBTaW1wbGVHZW9tZXRyeTtcbiAgTXVsdGlMaW5lU3RyaW5nLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFNpbXBsZUdlb21ldHJ5ICYmIFNpbXBsZUdlb21ldHJ5LnByb3RvdHlwZSApO1xuICBNdWx0aUxpbmVTdHJpbmcucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTXVsdGlMaW5lU3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBcHBlbmQgdGhlIHBhc3NlZCBsaW5lc3RyaW5nIHRvIHRoZSBtdWx0aWxpbmVzdHJpbmcuXG4gICAqIEBwYXJhbSB7TGluZVN0cmluZ30gbGluZVN0cmluZyBMaW5lU3RyaW5nLlxuICAgKiBAYXBpXG4gICAqL1xuICBNdWx0aUxpbmVTdHJpbmcucHJvdG90eXBlLmFwcGVuZExpbmVTdHJpbmcgPSBmdW5jdGlvbiBhcHBlbmRMaW5lU3RyaW5nIChsaW5lU3RyaW5nKSB7XG4gICAgaWYgKCF0aGlzLmZsYXRDb29yZGluYXRlcykge1xuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMgPSBsaW5lU3RyaW5nLmdldEZsYXRDb29yZGluYXRlcygpLnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4dGVuZCh0aGlzLmZsYXRDb29yZGluYXRlcywgbGluZVN0cmluZy5nZXRGbGF0Q29vcmRpbmF0ZXMoKS5zbGljZSgpKTtcbiAgICB9XG4gICAgdGhpcy5lbmRzXy5wdXNoKHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1ha2UgYSBjb21wbGV0ZSBjb3B5IG9mIHRoZSBnZW9tZXRyeS5cbiAgICogQHJldHVybiB7IU11bHRpTGluZVN0cmluZ30gQ2xvbmUuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBNdWx0aUxpbmVTdHJpbmcucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgIHJldHVybiBuZXcgTXVsdGlMaW5lU3RyaW5nKHRoaXMuZmxhdENvb3JkaW5hdGVzLnNsaWNlKCksIHRoaXMubGF5b3V0LCB0aGlzLmVuZHNfLnNsaWNlKCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgTXVsdGlMaW5lU3RyaW5nLnByb3RvdHlwZS5jbG9zZXN0UG9pbnRYWSA9IGZ1bmN0aW9uIGNsb3Nlc3RQb2ludFhZICh4LCB5LCBjbG9zZXN0UG9pbnQsIG1pblNxdWFyZWREaXN0YW5jZSkge1xuICAgIGlmIChtaW5TcXVhcmVkRGlzdGFuY2UgPCBjbG9zZXN0U3F1YXJlZERpc3RhbmNlWFkodGhpcy5nZXRFeHRlbnQoKSwgeCwgeSkpIHtcbiAgICAgIHJldHVybiBtaW5TcXVhcmVkRGlzdGFuY2U7XG4gICAgfVxuICAgIGlmICh0aGlzLm1heERlbHRhUmV2aXNpb25fICE9IHRoaXMuZ2V0UmV2aXNpb24oKSkge1xuICAgICAgdGhpcy5tYXhEZWx0YV8gPSBNYXRoLnNxcnQoYXJyYXlNYXhTcXVhcmVkRGVsdGEoXG4gICAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmVuZHNfLCB0aGlzLnN0cmlkZSwgMCkpO1xuICAgICAgdGhpcy5tYXhEZWx0YVJldmlzaW9uXyA9IHRoaXMuZ2V0UmV2aXNpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIGFzc2lnbkNsb3Nlc3RBcnJheVBvaW50KFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZW5kc18sIHRoaXMuc3RyaWRlLFxuICAgICAgdGhpcy5tYXhEZWx0YV8sIGZhbHNlLCB4LCB5LCBjbG9zZXN0UG9pbnQsIG1pblNxdWFyZWREaXN0YW5jZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvb3JkaW5hdGUgYXQgYG1gIHVzaW5nIGxpbmVhciBpbnRlcnBvbGF0aW9uLCBvciBgbnVsbGAgaWYgbm9cbiAgICogc3VjaCBjb29yZGluYXRlIGV4aXN0cy5cbiAgICpcbiAgICogYG9wdF9leHRyYXBvbGF0ZWAgY29udHJvbHMgZXh0cmFwb2xhdGlvbiBiZXlvbmQgdGhlIHJhbmdlIG9mIE1zIGluIHRoZVxuICAgKiBNdWx0aUxpbmVTdHJpbmcuIElmIGBvcHRfZXh0cmFwb2xhdGVgIGlzIGB0cnVlYCB0aGVuIE1zIGxlc3MgdGhhbiB0aGUgZmlyc3RcbiAgICogTSB3aWxsIHJldHVybiB0aGUgZmlyc3QgY29vcmRpbmF0ZSBhbmQgTXMgZ3JlYXRlciB0aGFuIHRoZSBsYXN0IE0gd2lsbFxuICAgKiByZXR1cm4gdGhlIGxhc3QgY29vcmRpbmF0ZS5cbiAgICpcbiAgICogYG9wdF9pbnRlcnBvbGF0ZWAgY29udHJvbHMgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIGNvbnNlY3V0aXZlIExpbmVTdHJpbmdzXG4gICAqIHdpdGhpbiB0aGUgTXVsdGlMaW5lU3RyaW5nLiBJZiBgb3B0X2ludGVycG9sYXRlYCBpcyBgdHJ1ZWAgdGhlIGNvb3JkaW5hdGVzXG4gICAqIHdpbGwgYmUgbGluZWFybHkgaW50ZXJwb2xhdGVkIGJldHdlZW4gdGhlIGxhc3QgY29vcmRpbmF0ZSBvZiBvbmUgTGluZVN0cmluZ1xuICAgKiBhbmQgdGhlIGZpcnN0IGNvb3JkaW5hdGUgb2YgdGhlIG5leHQgTGluZVN0cmluZy4gIElmIGBvcHRfaW50ZXJwb2xhdGVgIGlzXG4gICAqIGBmYWxzZWAgdGhlbiB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gYG51bGxgIGZvciBNcyBmYWxsaW5nIGJldHdlZW5cbiAgICogTGluZVN0cmluZ3MuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtIE0uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9leHRyYXBvbGF0ZSBFeHRyYXBvbGF0ZS4gRGVmYXVsdCBpcyBgZmFsc2VgLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfaW50ZXJwb2xhdGUgSW50ZXJwb2xhdGUuIERlZmF1bHQgaXMgYGZhbHNlYC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBDb29yZGluYXRlLlxuICAgKiBAYXBpXG4gICAqL1xuICBNdWx0aUxpbmVTdHJpbmcucHJvdG90eXBlLmdldENvb3JkaW5hdGVBdE0gPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlQXRNIChtLCBvcHRfZXh0cmFwb2xhdGUsIG9wdF9pbnRlcnBvbGF0ZSkge1xuICAgIGlmICgodGhpcy5sYXlvdXQgIT0gR2VvbWV0cnlMYXlvdXQuWFlNICYmXG4gICAgICAgICB0aGlzLmxheW91dCAhPSBHZW9tZXRyeUxheW91dC5YWVpNKSB8fFxuICAgICAgICB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgZXh0cmFwb2xhdGUgPSBvcHRfZXh0cmFwb2xhdGUgIT09IHVuZGVmaW5lZCA/IG9wdF9leHRyYXBvbGF0ZSA6IGZhbHNlO1xuICAgIHZhciBpbnRlcnBvbGF0ZSA9IG9wdF9pbnRlcnBvbGF0ZSAhPT0gdW5kZWZpbmVkID8gb3B0X2ludGVycG9sYXRlIDogZmFsc2U7XG4gICAgcmV0dXJuIGxpbmVTdHJpbmdzQ29vcmRpbmF0ZUF0TSh0aGlzLmZsYXRDb29yZGluYXRlcywgMCxcbiAgICAgIHRoaXMuZW5kc18sIHRoaXMuc3RyaWRlLCBtLCBleHRyYXBvbGF0ZSwgaW50ZXJwb2xhdGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBtdWx0aWxpbmVzdHJpbmcuXG4gICAqIEByZXR1cm4ge0FycmF5PEFycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+fSBDb29yZGluYXRlcy5cbiAgICogQG92ZXJyaWRlXG4gICAqIEBhcGlcbiAgICovXG4gIE11bHRpTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlcyAoKSB7XG4gICAgcmV0dXJuIGluZmxhdGVDb29yZGluYXRlc0FycmF5KFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZW5kc18sIHRoaXMuc3RyaWRlKTtcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gRW5kcy5cbiAgICovXG4gIE11bHRpTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0RW5kcyA9IGZ1bmN0aW9uIGdldEVuZHMgKCkge1xuICAgIHJldHVybiB0aGlzLmVuZHNfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGxpbmVzdHJpbmcgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4LlxuICAgKiBAcmV0dXJuIHtMaW5lU3RyaW5nfSBMaW5lU3RyaW5nLlxuICAgKiBAYXBpXG4gICAqL1xuICBNdWx0aUxpbmVTdHJpbmcucHJvdG90eXBlLmdldExpbmVTdHJpbmcgPSBmdW5jdGlvbiBnZXRMaW5lU3RyaW5nIChpbmRleCkge1xuICAgIGlmIChpbmRleCA8IDAgfHwgdGhpcy5lbmRzXy5sZW5ndGggPD0gaW5kZXgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IExpbmVTdHJpbmcodGhpcy5mbGF0Q29vcmRpbmF0ZXMuc2xpY2UoXG4gICAgICBpbmRleCA9PT0gMCA/IDAgOiB0aGlzLmVuZHNfW2luZGV4IC0gMV0sIHRoaXMuZW5kc19baW5kZXhdKSwgdGhpcy5sYXlvdXQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGxpbmVzdHJpbmdzIG9mIHRoaXMgbXVsdGlsaW5lc3RyaW5nLlxuICAgKiBAcmV0dXJuIHtBcnJheTxMaW5lU3RyaW5nPn0gTGluZVN0cmluZ3MuXG4gICAqIEBhcGlcbiAgICovXG4gIE11bHRpTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0TGluZVN0cmluZ3MgPSBmdW5jdGlvbiBnZXRMaW5lU3RyaW5ncyAoKSB7XG4gICAgdmFyIGZsYXRDb29yZGluYXRlcyA9IHRoaXMuZmxhdENvb3JkaW5hdGVzO1xuICAgIHZhciBlbmRzID0gdGhpcy5lbmRzXztcbiAgICB2YXIgbGF5b3V0ID0gdGhpcy5sYXlvdXQ7XG4gICAgLyoqIEB0eXBlIHtBcnJheTxMaW5lU3RyaW5nPn0gKi9cbiAgICB2YXIgbGluZVN0cmluZ3MgPSBbXTtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIHZhciBlbmQgPSBlbmRzW2ldO1xuICAgICAgdmFyIGxpbmVTdHJpbmcgPSBuZXcgTGluZVN0cmluZyhmbGF0Q29vcmRpbmF0ZXMuc2xpY2Uob2Zmc2V0LCBlbmQpLCBsYXlvdXQpO1xuICAgICAgbGluZVN0cmluZ3MucHVzaChsaW5lU3RyaW5nKTtcbiAgICAgIG9mZnNldCA9IGVuZDtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmVTdHJpbmdzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBGbGF0IG1pZHBvaW50cy5cbiAgICovXG4gIE11bHRpTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0RmxhdE1pZHBvaW50cyA9IGZ1bmN0aW9uIGdldEZsYXRNaWRwb2ludHMgKCkge1xuICAgIHZhciBtaWRwb2ludHMgPSBbXTtcbiAgICB2YXIgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5mbGF0Q29vcmRpbmF0ZXM7XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgdmFyIGVuZHMgPSB0aGlzLmVuZHNfO1xuICAgIHZhciBzdHJpZGUgPSB0aGlzLnN0cmlkZTtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIHZhciBlbmQgPSBlbmRzW2ldO1xuICAgICAgdmFyIG1pZHBvaW50ID0gaW50ZXJwb2xhdGVQb2ludChcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCAwLjUpO1xuICAgICAgZXh0ZW5kKG1pZHBvaW50cywgbWlkcG9pbnQpO1xuICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgIH1cbiAgICByZXR1cm4gbWlkcG9pbnRzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgTXVsdGlMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXRTaW1wbGlmaWVkR2VvbWV0cnlJbnRlcm5hbCA9IGZ1bmN0aW9uIGdldFNpbXBsaWZpZWRHZW9tZXRyeUludGVybmFsIChzcXVhcmVkVG9sZXJhbmNlKSB7XG4gICAgdmFyIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMgPSBbXTtcbiAgICB2YXIgc2ltcGxpZmllZEVuZHMgPSBbXTtcbiAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLmxlbmd0aCA9IGRvdWdsYXNQZXVja2VyQXJyYXkoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcywgMCwgdGhpcy5lbmRzXywgdGhpcy5zdHJpZGUsIHNxdWFyZWRUb2xlcmFuY2UsXG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLCAwLCBzaW1wbGlmaWVkRW5kcyk7XG4gICAgcmV0dXJuIG5ldyBNdWx0aUxpbmVTdHJpbmcoc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcywgR2VvbWV0cnlMYXlvdXQuWFksIHNpbXBsaWZpZWRFbmRzKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGFwaVxuICAgKi9cbiAgTXVsdGlMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXRUeXBlID0gZnVuY3Rpb24gZ2V0VHlwZSAoKSB7XG4gICAgcmV0dXJuIEdlb21ldHJ5VHlwZS5NVUxUSV9MSU5FX1NUUklORztcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGFwaVxuICAgKi9cbiAgTXVsdGlMaW5lU3RyaW5nLnByb3RvdHlwZS5pbnRlcnNlY3RzRXh0ZW50ID0gZnVuY3Rpb24gaW50ZXJzZWN0c0V4dGVudCAoZXh0ZW50KSB7XG4gICAgcmV0dXJuIGludGVyc2VjdHNMaW5lU3RyaW5nQXJyYXkoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcywgMCwgdGhpcy5lbmRzXywgdGhpcy5zdHJpZGUsIGV4dGVudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIG11bHRpbGluZXN0cmluZy5cbiAgICogQHBhcmFtIHshQXJyYXk8QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj59IGNvb3JkaW5hdGVzIENvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0ge0dlb21ldHJ5TGF5b3V0PX0gb3B0X2xheW91dCBMYXlvdXQuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBNdWx0aUxpbmVTdHJpbmcucHJvdG90eXBlLnNldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gc2V0Q29vcmRpbmF0ZXMgKGNvb3JkaW5hdGVzLCBvcHRfbGF5b3V0KSB7XG4gICAgdGhpcy5zZXRMYXlvdXQob3B0X2xheW91dCwgY29vcmRpbmF0ZXMsIDIpO1xuICAgIGlmICghdGhpcy5mbGF0Q29vcmRpbmF0ZXMpIHtcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzID0gW107XG4gICAgfVxuICAgIHZhciBlbmRzID0gZGVmbGF0ZUNvb3JkaW5hdGVzQXJyYXkoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcywgMCwgY29vcmRpbmF0ZXMsIHRoaXMuc3RyaWRlLCB0aGlzLmVuZHNfKTtcbiAgICB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGggPSBlbmRzLmxlbmd0aCA9PT0gMCA/IDAgOiBlbmRzW2VuZHMubGVuZ3RoIC0gMV07XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH07XG5cbiAgcmV0dXJuIE11bHRpTGluZVN0cmluZztcbn0oU2ltcGxlR2VvbWV0cnkpKTtcblxuXG5leHBvcnQgZGVmYXVsdCBNdWx0aUxpbmVTdHJpbmc7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU11bHRpTGluZVN0cmluZy5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9NdWx0aVBvaW50XG4gKi9cbmltcG9ydCB7ZXh0ZW5kfSBmcm9tICcuLi9hcnJheS5qcyc7XG5pbXBvcnQge2Nsb3Nlc3RTcXVhcmVkRGlzdGFuY2VYWSwgY29udGFpbnNYWX0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCBHZW9tZXRyeVR5cGUgZnJvbSAnLi9HZW9tZXRyeVR5cGUuanMnO1xuaW1wb3J0IFBvaW50IGZyb20gJy4vUG9pbnQuanMnO1xuaW1wb3J0IFNpbXBsZUdlb21ldHJ5IGZyb20gJy4vU2ltcGxlR2VvbWV0cnkuanMnO1xuaW1wb3J0IHtkZWZsYXRlQ29vcmRpbmF0ZXN9IGZyb20gJy4vZmxhdC9kZWZsYXRlLmpzJztcbmltcG9ydCB7aW5mbGF0ZUNvb3JkaW5hdGVzfSBmcm9tICcuL2ZsYXQvaW5mbGF0ZS5qcyc7XG5pbXBvcnQge3NxdWFyZWREaXN0YW5jZSBhcyBzcXVhcmVkRHh9IGZyb20gJy4uL21hdGguanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIE11bHRpLXBvaW50IGdlb21ldHJ5LlxuICpcbiAqIEBhcGlcbiAqL1xudmFyIE11bHRpUG9pbnQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChTaW1wbGVHZW9tZXRyeSkge1xuICBmdW5jdGlvbiBNdWx0aVBvaW50KGNvb3JkaW5hdGVzLCBvcHRfbGF5b3V0KSB7XG4gICAgU2ltcGxlR2VvbWV0cnkuY2FsbCh0aGlzKTtcbiAgICBpZiAob3B0X2xheW91dCAmJiAhQXJyYXkuaXNBcnJheShjb29yZGluYXRlc1swXSkpIHtcbiAgICAgIHRoaXMuc2V0RmxhdENvb3JkaW5hdGVzKG9wdF9sYXlvdXQsIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi8gKGNvb3JkaW5hdGVzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0Q29vcmRpbmF0ZXMoLyoqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSAqLyAoY29vcmRpbmF0ZXMpLCBvcHRfbGF5b3V0KTtcbiAgICB9XG4gIH1cblxuICBpZiAoIFNpbXBsZUdlb21ldHJ5ICkgTXVsdGlQb2ludC5fX3Byb3RvX18gPSBTaW1wbGVHZW9tZXRyeTtcbiAgTXVsdGlQb2ludC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBTaW1wbGVHZW9tZXRyeSAmJiBTaW1wbGVHZW9tZXRyeS5wcm90b3R5cGUgKTtcbiAgTXVsdGlQb2ludC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNdWx0aVBvaW50O1xuXG4gIC8qKlxuICAgKiBBcHBlbmQgdGhlIHBhc3NlZCBwb2ludCB0byB0aGlzIG11bHRpcG9pbnQuXG4gICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IFBvaW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBNdWx0aVBvaW50LnByb3RvdHlwZS5hcHBlbmRQb2ludCA9IGZ1bmN0aW9uIGFwcGVuZFBvaW50IChwb2ludCkge1xuICAgIGlmICghdGhpcy5mbGF0Q29vcmRpbmF0ZXMpIHtcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzID0gcG9pbnQuZ2V0RmxhdENvb3JkaW5hdGVzKCkuc2xpY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXh0ZW5kKHRoaXMuZmxhdENvb3JkaW5hdGVzLCBwb2ludC5nZXRGbGF0Q29vcmRpbmF0ZXMoKSk7XG4gICAgfVxuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNYWtlIGEgY29tcGxldGUgY29weSBvZiB0aGUgZ2VvbWV0cnkuXG4gICAqIEByZXR1cm4geyFNdWx0aVBvaW50fSBDbG9uZS5cbiAgICogQG92ZXJyaWRlXG4gICAqIEBhcGlcbiAgICovXG4gIE11bHRpUG9pbnQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgIHZhciBtdWx0aVBvaW50ID0gbmV3IE11bHRpUG9pbnQodGhpcy5mbGF0Q29vcmRpbmF0ZXMuc2xpY2UoKSwgdGhpcy5sYXlvdXQpO1xuICAgIHJldHVybiBtdWx0aVBvaW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgTXVsdGlQb2ludC5wcm90b3R5cGUuY2xvc2VzdFBvaW50WFkgPSBmdW5jdGlvbiBjbG9zZXN0UG9pbnRYWSAoeCwgeSwgY2xvc2VzdFBvaW50LCBtaW5TcXVhcmVkRGlzdGFuY2UpIHtcbiAgICBpZiAobWluU3F1YXJlZERpc3RhbmNlIDwgY2xvc2VzdFNxdWFyZWREaXN0YW5jZVhZKHRoaXMuZ2V0RXh0ZW50KCksIHgsIHkpKSB7XG4gICAgICByZXR1cm4gbWluU3F1YXJlZERpc3RhbmNlO1xuICAgIH1cbiAgICB2YXIgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5mbGF0Q29vcmRpbmF0ZXM7XG4gICAgdmFyIHN0cmlkZSA9IHRoaXMuc3RyaWRlO1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGZsYXRDb29yZGluYXRlcy5sZW5ndGg7IGkgPCBpaTsgaSArPSBzdHJpZGUpIHtcbiAgICAgIHZhciBzcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkRHgoXG4gICAgICAgIHgsIHksIGZsYXRDb29yZGluYXRlc1tpXSwgZmxhdENvb3JkaW5hdGVzW2kgKyAxXSk7XG4gICAgICBpZiAoc3F1YXJlZERpc3RhbmNlIDwgbWluU3F1YXJlZERpc3RhbmNlKSB7XG4gICAgICAgIG1pblNxdWFyZWREaXN0YW5jZSA9IHNxdWFyZWREaXN0YW5jZTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdHJpZGU7ICsraikge1xuICAgICAgICAgIGNsb3Nlc3RQb2ludFtqXSA9IGZsYXRDb29yZGluYXRlc1tpICsgal07XG4gICAgICAgIH1cbiAgICAgICAgY2xvc2VzdFBvaW50Lmxlbmd0aCA9IHN0cmlkZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1pblNxdWFyZWREaXN0YW5jZTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgbXVsdGlwb2ludC5cbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn0gQ29vcmRpbmF0ZXMuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBNdWx0aVBvaW50LnByb3RvdHlwZS5nZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVzICgpIHtcbiAgICByZXR1cm4gaW5mbGF0ZUNvb3JkaW5hdGVzKFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCwgdGhpcy5zdHJpZGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHBvaW50IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleC5cbiAgICogQHJldHVybiB7UG9pbnR9IFBvaW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBNdWx0aVBvaW50LnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uIGdldFBvaW50IChpbmRleCkge1xuICAgIHZhciBuID0gIXRoaXMuZmxhdENvb3JkaW5hdGVzID8gMCA6IHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCAvIHRoaXMuc3RyaWRlO1xuICAgIGlmIChpbmRleCA8IDAgfHwgbiA8PSBpbmRleCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy5mbGF0Q29vcmRpbmF0ZXMuc2xpY2UoXG4gICAgICBpbmRleCAqIHRoaXMuc3RyaWRlLCAoaW5kZXggKyAxKSAqIHRoaXMuc3RyaWRlKSwgdGhpcy5sYXlvdXQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHBvaW50cyBvZiB0aGlzIG11bHRpcG9pbnQuXG4gICAqIEByZXR1cm4ge0FycmF5PFBvaW50Pn0gUG9pbnRzLlxuICAgKiBAYXBpXG4gICAqL1xuICBNdWx0aVBvaW50LnByb3RvdHlwZS5nZXRQb2ludHMgPSBmdW5jdGlvbiBnZXRQb2ludHMgKCkge1xuICAgIHZhciBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmZsYXRDb29yZGluYXRlcztcbiAgICB2YXIgbGF5b3V0ID0gdGhpcy5sYXlvdXQ7XG4gICAgdmFyIHN0cmlkZSA9IHRoaXMuc3RyaWRlO1xuICAgIC8qKiBAdHlwZSB7QXJyYXk8UG9pbnQ+fSAqL1xuICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gc3RyaWRlKSB7XG4gICAgICB2YXIgcG9pbnQgPSBuZXcgUG9pbnQoZmxhdENvb3JkaW5hdGVzLnNsaWNlKGksIGkgKyBzdHJpZGUpLCBsYXlvdXQpO1xuICAgICAgcG9pbnRzLnB1c2gocG9pbnQpO1xuICAgIH1cbiAgICByZXR1cm4gcG9pbnRzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKiBAYXBpXG4gICAqL1xuICBNdWx0aVBvaW50LnByb3RvdHlwZS5nZXRUeXBlID0gZnVuY3Rpb24gZ2V0VHlwZSAoKSB7XG4gICAgcmV0dXJuIEdlb21ldHJ5VHlwZS5NVUxUSV9QT0lOVDtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGFwaVxuICAgKi9cbiAgTXVsdGlQb2ludC5wcm90b3R5cGUuaW50ZXJzZWN0c0V4dGVudCA9IGZ1bmN0aW9uIGludGVyc2VjdHNFeHRlbnQgKGV4dGVudCkge1xuICAgIHZhciBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmZsYXRDb29yZGluYXRlcztcbiAgICB2YXIgc3RyaWRlID0gdGhpcy5zdHJpZGU7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZmxhdENvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpOyBpICs9IHN0cmlkZSkge1xuICAgICAgdmFyIHggPSBmbGF0Q29vcmRpbmF0ZXNbaV07XG4gICAgICB2YXIgeSA9IGZsYXRDb29yZGluYXRlc1tpICsgMV07XG4gICAgICBpZiAoY29udGFpbnNYWShleHRlbnQsIHgsIHkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIG11bHRpcG9pbnQuXG4gICAqIEBwYXJhbSB7IUFycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59IGNvb3JkaW5hdGVzIENvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vR2VvbWV0cnlMYXlvdXQuanNcIikuZGVmYXVsdD19IG9wdF9sYXlvdXQgTGF5b3V0LlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGFwaVxuICAgKi9cbiAgTXVsdGlQb2ludC5wcm90b3R5cGUuc2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBzZXRDb29yZGluYXRlcyAoY29vcmRpbmF0ZXMsIG9wdF9sYXlvdXQpIHtcbiAgICB0aGlzLnNldExheW91dChvcHRfbGF5b3V0LCBjb29yZGluYXRlcywgMSk7XG4gICAgaWYgKCF0aGlzLmZsYXRDb29yZGluYXRlcykge1xuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoID0gZGVmbGF0ZUNvb3JkaW5hdGVzKFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIGNvb3JkaW5hdGVzLCB0aGlzLnN0cmlkZSk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH07XG5cbiAgcmV0dXJuIE11bHRpUG9pbnQ7XG59KFNpbXBsZUdlb21ldHJ5KSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgTXVsdGlQb2ludDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TXVsdGlQb2ludC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9NdWx0aVBvbHlnb25cbiAqL1xuaW1wb3J0IHtleHRlbmR9IGZyb20gJy4uL2FycmF5LmpzJztcbmltcG9ydCB7Y2xvc2VzdFNxdWFyZWREaXN0YW5jZVhZfSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IEdlb21ldHJ5TGF5b3V0IGZyb20gJy4vR2VvbWV0cnlMYXlvdXQuanMnO1xuaW1wb3J0IEdlb21ldHJ5VHlwZSBmcm9tICcuL0dlb21ldHJ5VHlwZS5qcyc7XG5pbXBvcnQgTXVsdGlQb2ludCBmcm9tICcuL011bHRpUG9pbnQuanMnO1xuaW1wb3J0IFBvbHlnb24gZnJvbSAnLi9Qb2x5Z29uLmpzJztcbmltcG9ydCBTaW1wbGVHZW9tZXRyeSBmcm9tICcuL1NpbXBsZUdlb21ldHJ5LmpzJztcbmltcG9ydCB7bGluZWFyUmluZ3NzIGFzIGxpbmVhclJpbmdzc0FyZWF9IGZyb20gJy4vZmxhdC9hcmVhLmpzJztcbmltcG9ydCB7bGluZWFyUmluZ3NzIGFzIGxpbmVhclJpbmdzc0NlbnRlcn0gZnJvbSAnLi9mbGF0L2NlbnRlci5qcyc7XG5pbXBvcnQge2Fzc2lnbkNsb3Nlc3RNdWx0aUFycmF5UG9pbnQsIG11bHRpQXJyYXlNYXhTcXVhcmVkRGVsdGF9IGZyb20gJy4vZmxhdC9jbG9zZXN0LmpzJztcbmltcG9ydCB7bGluZWFyUmluZ3NzQ29udGFpbnNYWX0gZnJvbSAnLi9mbGF0L2NvbnRhaW5zLmpzJztcbmltcG9ydCB7ZGVmbGF0ZU11bHRpQ29vcmRpbmF0ZXNBcnJheX0gZnJvbSAnLi9mbGF0L2RlZmxhdGUuanMnO1xuaW1wb3J0IHtpbmZsYXRlTXVsdGlDb29yZGluYXRlc0FycmF5fSBmcm9tICcuL2ZsYXQvaW5mbGF0ZS5qcyc7XG5pbXBvcnQge2dldEludGVyaW9yUG9pbnRzT2ZNdWx0aUFycmF5fSBmcm9tICcuL2ZsYXQvaW50ZXJpb3Jwb2ludC5qcyc7XG5pbXBvcnQge2ludGVyc2VjdHNMaW5lYXJSaW5nTXVsdGlBcnJheX0gZnJvbSAnLi9mbGF0L2ludGVyc2VjdHNleHRlbnQuanMnO1xuaW1wb3J0IHtsaW5lYXJSaW5nc0FyZU9yaWVudGVkLCBvcmllbnRMaW5lYXJSaW5nc0FycmF5fSBmcm9tICcuL2ZsYXQvb3JpZW50LmpzJztcbmltcG9ydCB7cXVhbnRpemVNdWx0aUFycmF5fSBmcm9tICcuL2ZsYXQvc2ltcGxpZnkuanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIE11bHRpLXBvbHlnb24gZ2VvbWV0cnkuXG4gKlxuICogQGFwaVxuICovXG52YXIgTXVsdGlQb2x5Z29uID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoU2ltcGxlR2VvbWV0cnkpIHtcbiAgZnVuY3Rpb24gTXVsdGlQb2x5Z29uKGNvb3JkaW5hdGVzLCBvcHRfbGF5b3V0LCBvcHRfZW5kc3MpIHtcblxuICAgIFNpbXBsZUdlb21ldHJ5LmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmVuZHNzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZmxhdEludGVyaW9yUG9pbnRzUmV2aXNpb25fID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMuZmxhdEludGVyaW9yUG9pbnRzXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXhEZWx0YV8gPSAtMTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1heERlbHRhUmV2aXNpb25fID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5vcmllbnRlZFJldmlzaW9uXyA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLm9yaWVudGVkRmxhdENvb3JkaW5hdGVzXyA9IG51bGw7XG5cbiAgICBpZiAoIW9wdF9lbmRzcyAmJiAhQXJyYXkuaXNBcnJheShjb29yZGluYXRlc1swXSkpIHtcbiAgICAgIHZhciBsYXlvdXQgPSB0aGlzLmdldExheW91dCgpO1xuICAgICAgdmFyIHBvbHlnb25zID0gLyoqIEB0eXBlIHtBcnJheTxQb2x5Z29uPn0gKi8gKGNvb3JkaW5hdGVzKTtcbiAgICAgIHZhciBmbGF0Q29vcmRpbmF0ZXMgPSBbXTtcbiAgICAgIHZhciBlbmRzcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcG9seWdvbnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICB2YXIgcG9seWdvbiA9IHBvbHlnb25zW2ldO1xuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgIGxheW91dCA9IHBvbHlnb24uZ2V0TGF5b3V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9mZnNldCA9IGZsYXRDb29yZGluYXRlcy5sZW5ndGg7XG4gICAgICAgIHZhciBlbmRzID0gcG9seWdvbi5nZXRFbmRzKCk7XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBqaiA9IGVuZHMubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgICAgIGVuZHNbal0gKz0gb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGV4dGVuZChmbGF0Q29vcmRpbmF0ZXMsIHBvbHlnb24uZ2V0RmxhdENvb3JkaW5hdGVzKCkpO1xuICAgICAgICBlbmRzcy5wdXNoKGVuZHMpO1xuICAgICAgfVxuICAgICAgb3B0X2xheW91dCA9IGxheW91dDtcbiAgICAgIGNvb3JkaW5hdGVzID0gZmxhdENvb3JkaW5hdGVzO1xuICAgICAgb3B0X2VuZHNzID0gZW5kc3M7XG4gICAgfVxuICAgIGlmIChvcHRfbGF5b3V0ICE9PSB1bmRlZmluZWQgJiYgb3B0X2VuZHNzKSB7XG4gICAgICB0aGlzLnNldEZsYXRDb29yZGluYXRlcyhvcHRfbGF5b3V0LCAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovIChjb29yZGluYXRlcykpO1xuICAgICAgdGhpcy5lbmRzc18gPSBvcHRfZW5kc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0Q29vcmRpbmF0ZXMoLyoqIEB0eXBlIHtBcnJheTxBcnJheTxBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+Pj59ICovIChjb29yZGluYXRlcyksXG4gICAgICAgIG9wdF9sYXlvdXQpO1xuICAgIH1cblxuICB9XG5cbiAgaWYgKCBTaW1wbGVHZW9tZXRyeSApIE11bHRpUG9seWdvbi5fX3Byb3RvX18gPSBTaW1wbGVHZW9tZXRyeTtcbiAgTXVsdGlQb2x5Z29uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFNpbXBsZUdlb21ldHJ5ICYmIFNpbXBsZUdlb21ldHJ5LnByb3RvdHlwZSApO1xuICBNdWx0aVBvbHlnb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTXVsdGlQb2x5Z29uO1xuXG4gIC8qKlxuICAgKiBBcHBlbmQgdGhlIHBhc3NlZCBwb2x5Z29uIHRvIHRoaXMgbXVsdGlwb2x5Z29uLlxuICAgKiBAcGFyYW0ge1BvbHlnb259IHBvbHlnb24gUG9seWdvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgTXVsdGlQb2x5Z29uLnByb3RvdHlwZS5hcHBlbmRQb2x5Z29uID0gZnVuY3Rpb24gYXBwZW5kUG9seWdvbiAocG9seWdvbikge1xuICAgIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi9cbiAgICB2YXIgZW5kcztcbiAgICBpZiAoIXRoaXMuZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyA9IHBvbHlnb24uZ2V0RmxhdENvb3JkaW5hdGVzKCkuc2xpY2UoKTtcbiAgICAgIGVuZHMgPSBwb2x5Z29uLmdldEVuZHMoKS5zbGljZSgpO1xuICAgICAgdGhpcy5lbmRzc18ucHVzaCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgICAgZXh0ZW5kKHRoaXMuZmxhdENvb3JkaW5hdGVzLCBwb2x5Z29uLmdldEZsYXRDb29yZGluYXRlcygpKTtcbiAgICAgIGVuZHMgPSBwb2x5Z29uLmdldEVuZHMoKS5zbGljZSgpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGVuZHNbaV0gKz0gb2Zmc2V0O1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmVuZHNzXy5wdXNoKGVuZHMpO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNYWtlIGEgY29tcGxldGUgY29weSBvZiB0aGUgZ2VvbWV0cnkuXG4gICAqIEByZXR1cm4geyFNdWx0aVBvbHlnb259IENsb25lLlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGFwaVxuICAgKi9cbiAgTXVsdGlQb2x5Z29uLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgICB2YXIgbGVuID0gdGhpcy5lbmRzc18ubGVuZ3RoO1xuICAgIHZhciBuZXdFbmRzcyA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIG5ld0VuZHNzW2ldID0gdGhpcy5lbmRzc19baV0uc2xpY2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE11bHRpUG9seWdvbihcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLnNsaWNlKCksIHRoaXMubGF5b3V0LCBuZXdFbmRzcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBNdWx0aVBvbHlnb24ucHJvdG90eXBlLmNsb3Nlc3RQb2ludFhZID0gZnVuY3Rpb24gY2xvc2VzdFBvaW50WFkgKHgsIHksIGNsb3Nlc3RQb2ludCwgbWluU3F1YXJlZERpc3RhbmNlKSB7XG4gICAgaWYgKG1pblNxdWFyZWREaXN0YW5jZSA8IGNsb3Nlc3RTcXVhcmVkRGlzdGFuY2VYWSh0aGlzLmdldEV4dGVudCgpLCB4LCB5KSkge1xuICAgICAgcmV0dXJuIG1pblNxdWFyZWREaXN0YW5jZTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF4RGVsdGFSZXZpc2lvbl8gIT0gdGhpcy5nZXRSZXZpc2lvbigpKSB7XG4gICAgICB0aGlzLm1heERlbHRhXyA9IE1hdGguc3FydChtdWx0aUFycmF5TWF4U3F1YXJlZERlbHRhKFxuICAgICAgICB0aGlzLmZsYXRDb29yZGluYXRlcywgMCwgdGhpcy5lbmRzc18sIHRoaXMuc3RyaWRlLCAwKSk7XG4gICAgICB0aGlzLm1heERlbHRhUmV2aXNpb25fID0gdGhpcy5nZXRSZXZpc2lvbigpO1xuICAgIH1cbiAgICByZXR1cm4gYXNzaWduQ2xvc2VzdE11bHRpQXJyYXlQb2ludChcbiAgICAgIHRoaXMuZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMoKSwgMCwgdGhpcy5lbmRzc18sIHRoaXMuc3RyaWRlLFxuICAgICAgdGhpcy5tYXhEZWx0YV8sIHRydWUsIHgsIHksIGNsb3Nlc3RQb2ludCwgbWluU3F1YXJlZERpc3RhbmNlKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIE11bHRpUG9seWdvbi5wcm90b3R5cGUuY29udGFpbnNYWSA9IGZ1bmN0aW9uIGNvbnRhaW5zWFkgKHgsIHkpIHtcbiAgICByZXR1cm4gbGluZWFyUmluZ3NzQ29udGFpbnNYWSh0aGlzLmdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzKCksIDAsIHRoaXMuZW5kc3NfLCB0aGlzLnN0cmlkZSwgeCwgeSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgYXJlYSBvZiB0aGUgbXVsdGlwb2x5Z29uIG9uIHByb2plY3RlZCBwbGFuZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBBcmVhIChvbiBwcm9qZWN0ZWQgcGxhbmUpLlxuICAgKiBAYXBpXG4gICAqL1xuICBNdWx0aVBvbHlnb24ucHJvdG90eXBlLmdldEFyZWEgPSBmdW5jdGlvbiBnZXRBcmVhICgpIHtcbiAgICByZXR1cm4gbGluZWFyUmluZ3NzQXJlYSh0aGlzLmdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzKCksIDAsIHRoaXMuZW5kc3NfLCB0aGlzLnN0cmlkZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY29vcmRpbmF0ZSBhcnJheSBmb3IgdGhpcyBnZW9tZXRyeS4gIFRoaXMgYXJyYXkgaGFzIHRoZSBzdHJ1Y3R1cmVcbiAgICogb2YgYSBHZW9KU09OIGNvb3JkaW5hdGUgYXJyYXkgZm9yIG11bHRpLXBvbHlnb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfcmlnaHQgT3JpZW50IGNvb3JkaW5hdGVzIGFjY29yZGluZyB0byB0aGUgcmlnaHQtaGFuZFxuICAgKiAgICAgcnVsZSAoY291bnRlci1jbG9ja3dpc2UgZm9yIGV4dGVyaW9yIGFuZCBjbG9ja3dpc2UgZm9yIGludGVyaW9yIHJpbmdzKS5cbiAgICogICAgIElmIGBmYWxzZWAsIGNvb3JkaW5hdGVzIHdpbGwgYmUgb3JpZW50ZWQgYWNjb3JkaW5nIHRvIHRoZSBsZWZ0LWhhbmQgcnVsZVxuICAgKiAgICAgKGNsb2Nrd2lzZSBmb3IgZXh0ZXJpb3IgYW5kIGNvdW50ZXItY2xvY2t3aXNlIGZvciBpbnRlcmlvciByaW5ncykuXG4gICAqICAgICBCeSBkZWZhdWx0LCBjb29yZGluYXRlIG9yaWVudGF0aW9uIHdpbGwgZGVwZW5kIG9uIGhvdyB0aGUgZ2VvbWV0cnkgd2FzXG4gICAqICAgICBjb25zdHJ1Y3RlZC5cbiAgICogQHJldHVybiB7QXJyYXk8QXJyYXk8QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj4+fSBDb29yZGluYXRlcy5cbiAgICogQG92ZXJyaWRlXG4gICAqIEBhcGlcbiAgICovXG4gIE11bHRpUG9seWdvbi5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlcyAob3B0X3JpZ2h0KSB7XG4gICAgdmFyIGZsYXRDb29yZGluYXRlcztcbiAgICBpZiAob3B0X3JpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGZsYXRDb29yZGluYXRlcyA9IHRoaXMuZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMoKS5zbGljZSgpO1xuICAgICAgb3JpZW50TGluZWFyUmluZ3NBcnJheShcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmVuZHNzXywgdGhpcy5zdHJpZGUsIG9wdF9yaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZsYXRDb29yZGluYXRlcyA9IHRoaXMuZmxhdENvb3JkaW5hdGVzO1xuICAgIH1cblxuICAgIHJldHVybiBpbmZsYXRlTXVsdGlDb29yZGluYXRlc0FycmF5KFxuICAgICAgZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmVuZHNzXywgdGhpcy5zdHJpZGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gRW5kc3MuXG4gICAqL1xuICBNdWx0aVBvbHlnb24ucHJvdG90eXBlLmdldEVuZHNzID0gZnVuY3Rpb24gZ2V0RW5kc3MgKCkge1xuICAgIHJldHVybiB0aGlzLmVuZHNzXztcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gRmxhdCBpbnRlcmlvciBwb2ludHMuXG4gICAqL1xuICBNdWx0aVBvbHlnb24ucHJvdG90eXBlLmdldEZsYXRJbnRlcmlvclBvaW50cyA9IGZ1bmN0aW9uIGdldEZsYXRJbnRlcmlvclBvaW50cyAoKSB7XG4gICAgaWYgKHRoaXMuZmxhdEludGVyaW9yUG9pbnRzUmV2aXNpb25fICE9IHRoaXMuZ2V0UmV2aXNpb24oKSkge1xuICAgICAgdmFyIGZsYXRDZW50ZXJzID0gbGluZWFyUmluZ3NzQ2VudGVyKFxuICAgICAgICB0aGlzLmZsYXRDb29yZGluYXRlcywgMCwgdGhpcy5lbmRzc18sIHRoaXMuc3RyaWRlKTtcbiAgICAgIHRoaXMuZmxhdEludGVyaW9yUG9pbnRzXyA9IGdldEludGVyaW9yUG9pbnRzT2ZNdWx0aUFycmF5KFxuICAgICAgICB0aGlzLmdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzKCksIDAsIHRoaXMuZW5kc3NfLCB0aGlzLnN0cmlkZSxcbiAgICAgICAgZmxhdENlbnRlcnMpO1xuICAgICAgdGhpcy5mbGF0SW50ZXJpb3JQb2ludHNSZXZpc2lvbl8gPSB0aGlzLmdldFJldmlzaW9uKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZsYXRJbnRlcmlvclBvaW50c187XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgaW50ZXJpb3IgcG9pbnRzIGFzIHtAbGluayBtb2R1bGU6b2wvZ2VvbS9NdWx0aVBvaW50IG11bHRpcG9pbnR9LlxuICAgKiBAcmV0dXJuIHtNdWx0aVBvaW50fSBJbnRlcmlvciBwb2ludHMgYXMgWFlNIGNvb3JkaW5hdGVzLCB3aGVyZSBNIGlzXG4gICAqIHRoZSBsZW5ndGggb2YgdGhlIGhvcml6b250YWwgaW50ZXJzZWN0aW9uIHRoYXQgdGhlIHBvaW50IGJlbG9uZ3MgdG8uXG4gICAqIEBhcGlcbiAgICovXG4gIE11bHRpUG9seWdvbi5wcm90b3R5cGUuZ2V0SW50ZXJpb3JQb2ludHMgPSBmdW5jdGlvbiBnZXRJbnRlcmlvclBvaW50cyAoKSB7XG4gICAgcmV0dXJuIG5ldyBNdWx0aVBvaW50KHRoaXMuZ2V0RmxhdEludGVyaW9yUG9pbnRzKCkuc2xpY2UoKSwgR2VvbWV0cnlMYXlvdXQuWFlNKTtcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gT3JpZW50ZWQgZmxhdCBjb29yZGluYXRlcy5cbiAgICovXG4gIE11bHRpUG9seWdvbi5wcm90b3R5cGUuZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBnZXRPcmllbnRlZEZsYXRDb29yZGluYXRlcyAoKSB7XG4gICAgaWYgKHRoaXMub3JpZW50ZWRSZXZpc2lvbl8gIT0gdGhpcy5nZXRSZXZpc2lvbigpKSB7XG4gICAgICB2YXIgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5mbGF0Q29vcmRpbmF0ZXM7XG4gICAgICBpZiAobGluZWFyUmluZ3NBcmVPcmllbnRlZChcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmVuZHNzXywgdGhpcy5zdHJpZGUpKSB7XG4gICAgICAgIHRoaXMub3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXNfID0gZmxhdENvb3JkaW5hdGVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vcmllbnRlZEZsYXRDb29yZGluYXRlc18gPSBmbGF0Q29vcmRpbmF0ZXMuc2xpY2UoKTtcbiAgICAgICAgdGhpcy5vcmllbnRlZEZsYXRDb29yZGluYXRlc18ubGVuZ3RoID1cbiAgICAgICAgICAgIG9yaWVudExpbmVhclJpbmdzQXJyYXkoXG4gICAgICAgICAgICAgIHRoaXMub3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXNfLCAwLCB0aGlzLmVuZHNzXywgdGhpcy5zdHJpZGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5vcmllbnRlZFJldmlzaW9uXyA9IHRoaXMuZ2V0UmV2aXNpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMub3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXNfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgTXVsdGlQb2x5Z29uLnByb3RvdHlwZS5nZXRTaW1wbGlmaWVkR2VvbWV0cnlJbnRlcm5hbCA9IGZ1bmN0aW9uIGdldFNpbXBsaWZpZWRHZW9tZXRyeUludGVybmFsIChzcXVhcmVkVG9sZXJhbmNlKSB7XG4gICAgdmFyIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMgPSBbXTtcbiAgICB2YXIgc2ltcGxpZmllZEVuZHNzID0gW107XG4gICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcy5sZW5ndGggPSBxdWFudGl6ZU11bHRpQXJyYXkoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcywgMCwgdGhpcy5lbmRzc18sIHRoaXMuc3RyaWRlLFxuICAgICAgTWF0aC5zcXJ0KHNxdWFyZWRUb2xlcmFuY2UpLFxuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcywgMCwgc2ltcGxpZmllZEVuZHNzKTtcbiAgICByZXR1cm4gbmV3IE11bHRpUG9seWdvbihzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLCBHZW9tZXRyeUxheW91dC5YWSwgc2ltcGxpZmllZEVuZHNzKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBwb2x5Z29uIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleC5cbiAgICogQHJldHVybiB7UG9seWdvbn0gUG9seWdvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgTXVsdGlQb2x5Z29uLnByb3RvdHlwZS5nZXRQb2x5Z29uID0gZnVuY3Rpb24gZ2V0UG9seWdvbiAoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPCAwIHx8IHRoaXMuZW5kc3NfLmxlbmd0aCA8PSBpbmRleCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBvZmZzZXQ7XG4gICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHJldkVuZHMgPSB0aGlzLmVuZHNzX1tpbmRleCAtIDFdO1xuICAgICAgb2Zmc2V0ID0gcHJldkVuZHNbcHJldkVuZHMubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHZhciBlbmRzID0gdGhpcy5lbmRzc19baW5kZXhdLnNsaWNlKCk7XG4gICAgdmFyIGVuZCA9IGVuZHNbZW5kcy5sZW5ndGggLSAxXTtcbiAgICBpZiAob2Zmc2V0ICE9PSAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgZW5kc1tpXSAtPSBvZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgUG9seWdvbih0aGlzLmZsYXRDb29yZGluYXRlcy5zbGljZShvZmZzZXQsIGVuZCksIHRoaXMubGF5b3V0LCBlbmRzKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBwb2x5Z29ucyBvZiB0aGlzIG11bHRpcG9seWdvbi5cbiAgICogQHJldHVybiB7QXJyYXk8UG9seWdvbj59IFBvbHlnb25zLlxuICAgKiBAYXBpXG4gICAqL1xuICBNdWx0aVBvbHlnb24ucHJvdG90eXBlLmdldFBvbHlnb25zID0gZnVuY3Rpb24gZ2V0UG9seWdvbnMgKCkge1xuICAgIHZhciBsYXlvdXQgPSB0aGlzLmxheW91dDtcbiAgICB2YXIgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5mbGF0Q29vcmRpbmF0ZXM7XG4gICAgdmFyIGVuZHNzID0gdGhpcy5lbmRzc187XG4gICAgdmFyIHBvbHlnb25zID0gW107XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZW5kc3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgdmFyIGVuZHMgPSBlbmRzc1tpXS5zbGljZSgpO1xuICAgICAgdmFyIGVuZCA9IGVuZHNbZW5kcy5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChvZmZzZXQgIT09IDApIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpqID0gZW5kcy5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgICAgICAgZW5kc1tqXSAtPSBvZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBwb2x5Z29uID0gbmV3IFBvbHlnb24oZmxhdENvb3JkaW5hdGVzLnNsaWNlKG9mZnNldCwgZW5kKSwgbGF5b3V0LCBlbmRzKTtcbiAgICAgIHBvbHlnb25zLnB1c2gocG9seWdvbik7XG4gICAgICBvZmZzZXQgPSBlbmQ7XG4gICAgfVxuICAgIHJldHVybiBwb2x5Z29ucztcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGFwaVxuICAgKi9cbiAgTXVsdGlQb2x5Z29uLnByb3RvdHlwZS5nZXRUeXBlID0gZnVuY3Rpb24gZ2V0VHlwZSAoKSB7XG4gICAgcmV0dXJuIEdlb21ldHJ5VHlwZS5NVUxUSV9QT0xZR09OO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKiBAYXBpXG4gICAqL1xuICBNdWx0aVBvbHlnb24ucHJvdG90eXBlLmludGVyc2VjdHNFeHRlbnQgPSBmdW5jdGlvbiBpbnRlcnNlY3RzRXh0ZW50IChleHRlbnQpIHtcbiAgICByZXR1cm4gaW50ZXJzZWN0c0xpbmVhclJpbmdNdWx0aUFycmF5KFxuICAgICAgdGhpcy5nZXRPcmllbnRlZEZsYXRDb29yZGluYXRlcygpLCAwLCB0aGlzLmVuZHNzXywgdGhpcy5zdHJpZGUsIGV4dGVudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIG11bHRpcG9seWdvbi5cbiAgICogQHBhcmFtIHshQXJyYXk8QXJyYXk8QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj4+fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAgICogQHBhcmFtIHtHZW9tZXRyeUxheW91dD19IG9wdF9sYXlvdXQgTGF5b3V0LlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGFwaVxuICAgKi9cbiAgTXVsdGlQb2x5Z29uLnByb3RvdHlwZS5zZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIHNldENvb3JkaW5hdGVzIChjb29yZGluYXRlcywgb3B0X2xheW91dCkge1xuICAgIHRoaXMuc2V0TGF5b3V0KG9wdF9sYXlvdXQsIGNvb3JkaW5hdGVzLCAzKTtcbiAgICBpZiAoIXRoaXMuZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyA9IFtdO1xuICAgIH1cbiAgICB2YXIgZW5kc3MgPSBkZWZsYXRlTXVsdGlDb29yZGluYXRlc0FycmF5KFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIGNvb3JkaW5hdGVzLCB0aGlzLnN0cmlkZSwgdGhpcy5lbmRzc18pO1xuICAgIGlmIChlbmRzcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsYXN0RW5kcyA9IGVuZHNzW2VuZHNzLmxlbmd0aCAtIDFdO1xuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoID0gbGFzdEVuZHMubGVuZ3RoID09PSAwID9cbiAgICAgICAgMCA6IGxhc3RFbmRzW2xhc3RFbmRzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuICByZXR1cm4gTXVsdGlQb2x5Z29uO1xufShTaW1wbGVHZW9tZXRyeSkpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IE11bHRpUG9seWdvbjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TXVsdGlQb2x5Z29uLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL1BvaW50XG4gKi9cbmltcG9ydCB7Y3JlYXRlT3JVcGRhdGVGcm9tQ29vcmRpbmF0ZSwgY29udGFpbnNYWX0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCBHZW9tZXRyeVR5cGUgZnJvbSAnLi9HZW9tZXRyeVR5cGUuanMnO1xuaW1wb3J0IFNpbXBsZUdlb21ldHJ5IGZyb20gJy4vU2ltcGxlR2VvbWV0cnkuanMnO1xuaW1wb3J0IHtkZWZsYXRlQ29vcmRpbmF0ZX0gZnJvbSAnLi9mbGF0L2RlZmxhdGUuanMnO1xuaW1wb3J0IHtzcXVhcmVkRGlzdGFuY2UgYXMgc3F1YXJlZER4fSBmcm9tICcuLi9tYXRoLmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBQb2ludCBnZW9tZXRyeS5cbiAqXG4gKiBAYXBpXG4gKi9cbnZhciBQb2ludCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFNpbXBsZUdlb21ldHJ5KSB7XG4gIGZ1bmN0aW9uIFBvaW50KGNvb3JkaW5hdGVzLCBvcHRfbGF5b3V0KSB7XG4gICAgU2ltcGxlR2VvbWV0cnkuY2FsbCh0aGlzKTtcbiAgICB0aGlzLnNldENvb3JkaW5hdGVzKGNvb3JkaW5hdGVzLCBvcHRfbGF5b3V0KTtcbiAgfVxuXG4gIGlmICggU2ltcGxlR2VvbWV0cnkgKSBQb2ludC5fX3Byb3RvX18gPSBTaW1wbGVHZW9tZXRyeTtcbiAgUG9pbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU2ltcGxlR2VvbWV0cnkgJiYgU2ltcGxlR2VvbWV0cnkucHJvdG90eXBlICk7XG4gIFBvaW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBvaW50O1xuXG4gIC8qKlxuICAgKiBNYWtlIGEgY29tcGxldGUgY29weSBvZiB0aGUgZ2VvbWV0cnkuXG4gICAqIEByZXR1cm4geyFQb2ludH0gQ2xvbmUuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBQb2ludC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgdmFyIHBvaW50ID0gbmV3IFBvaW50KHRoaXMuZmxhdENvb3JkaW5hdGVzLnNsaWNlKCksIHRoaXMubGF5b3V0KTtcbiAgICByZXR1cm4gcG9pbnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBQb2ludC5wcm90b3R5cGUuY2xvc2VzdFBvaW50WFkgPSBmdW5jdGlvbiBjbG9zZXN0UG9pbnRYWSAoeCwgeSwgY2xvc2VzdFBvaW50LCBtaW5TcXVhcmVkRGlzdGFuY2UpIHtcbiAgICB2YXIgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5mbGF0Q29vcmRpbmF0ZXM7XG4gICAgdmFyIHNxdWFyZWREaXN0YW5jZSA9IHNxdWFyZWREeCh4LCB5LCBmbGF0Q29vcmRpbmF0ZXNbMF0sIGZsYXRDb29yZGluYXRlc1sxXSk7XG4gICAgaWYgKHNxdWFyZWREaXN0YW5jZSA8IG1pblNxdWFyZWREaXN0YW5jZSkge1xuICAgICAgdmFyIHN0cmlkZSA9IHRoaXMuc3RyaWRlO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpZGU7ICsraSkge1xuICAgICAgICBjbG9zZXN0UG9pbnRbaV0gPSBmbGF0Q29vcmRpbmF0ZXNbaV07XG4gICAgICB9XG4gICAgICBjbG9zZXN0UG9pbnQubGVuZ3RoID0gc3RyaWRlO1xuICAgICAgcmV0dXJuIHNxdWFyZWREaXN0YW5jZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1pblNxdWFyZWREaXN0YW5jZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gQ29vcmRpbmF0ZXMuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBQb2ludC5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlcyAoKSB7XG4gICAgcmV0dXJuICF0aGlzLmZsYXRDb29yZGluYXRlcyA/IFtdIDogdGhpcy5mbGF0Q29vcmRpbmF0ZXMuc2xpY2UoKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIFBvaW50LnByb3RvdHlwZS5jb21wdXRlRXh0ZW50ID0gZnVuY3Rpb24gY29tcHV0ZUV4dGVudCAoZXh0ZW50KSB7XG4gICAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlRnJvbUNvb3JkaW5hdGUodGhpcy5mbGF0Q29vcmRpbmF0ZXMsIGV4dGVudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqIEBhcGlcbiAgICovXG4gIFBvaW50LnByb3RvdHlwZS5nZXRUeXBlID0gZnVuY3Rpb24gZ2V0VHlwZSAoKSB7XG4gICAgcmV0dXJuIEdlb21ldHJ5VHlwZS5QT0lOVDtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGFwaVxuICAgKi9cbiAgUG9pbnQucHJvdG90eXBlLmludGVyc2VjdHNFeHRlbnQgPSBmdW5jdGlvbiBpbnRlcnNlY3RzRXh0ZW50IChleHRlbnQpIHtcbiAgICByZXR1cm4gY29udGFpbnNYWShleHRlbnQsIHRoaXMuZmxhdENvb3JkaW5hdGVzWzBdLCB0aGlzLmZsYXRDb29yZGluYXRlc1sxXSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqIEBhcGlcbiAgICovXG4gIFBvaW50LnByb3RvdHlwZS5zZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIHNldENvb3JkaW5hdGVzIChjb29yZGluYXRlcywgb3B0X2xheW91dCkge1xuICAgIHRoaXMuc2V0TGF5b3V0KG9wdF9sYXlvdXQsIGNvb3JkaW5hdGVzLCAwKTtcbiAgICBpZiAoIXRoaXMuZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyA9IFtdO1xuICAgIH1cbiAgICB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGggPSBkZWZsYXRlQ29vcmRpbmF0ZShcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLCAwLCBjb29yZGluYXRlcywgdGhpcy5zdHJpZGUpO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9O1xuXG4gIHJldHVybiBQb2ludDtcbn0oU2ltcGxlR2VvbWV0cnkpKTtcblxuXG5leHBvcnQgZGVmYXVsdCBQb2ludDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UG9pbnQuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vUG9seWdvblxuICovXG5pbXBvcnQge2V4dGVuZH0gZnJvbSAnLi4vYXJyYXkuanMnO1xuaW1wb3J0IHtjbG9zZXN0U3F1YXJlZERpc3RhbmNlWFksIGdldENlbnRlcn0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCBHZW9tZXRyeUxheW91dCBmcm9tICcuL0dlb21ldHJ5TGF5b3V0LmpzJztcbmltcG9ydCBHZW9tZXRyeVR5cGUgZnJvbSAnLi9HZW9tZXRyeVR5cGUuanMnO1xuaW1wb3J0IExpbmVhclJpbmcgZnJvbSAnLi9MaW5lYXJSaW5nLmpzJztcbmltcG9ydCBQb2ludCBmcm9tICcuL1BvaW50LmpzJztcbmltcG9ydCBTaW1wbGVHZW9tZXRyeSBmcm9tICcuL1NpbXBsZUdlb21ldHJ5LmpzJztcbmltcG9ydCB7b2Zmc2V0IGFzIHNwaGVyZU9mZnNldH0gZnJvbSAnLi4vc3BoZXJlLmpzJztcbmltcG9ydCB7bGluZWFyUmluZ3MgYXMgbGluZWFyUmluZ3NBcmVhfSBmcm9tICcuL2ZsYXQvYXJlYS5qcyc7XG5pbXBvcnQge2Fzc2lnbkNsb3Nlc3RBcnJheVBvaW50LCBhcnJheU1heFNxdWFyZWREZWx0YX0gZnJvbSAnLi9mbGF0L2Nsb3Nlc3QuanMnO1xuaW1wb3J0IHtsaW5lYXJSaW5nc0NvbnRhaW5zWFl9IGZyb20gJy4vZmxhdC9jb250YWlucy5qcyc7XG5pbXBvcnQge2RlZmxhdGVDb29yZGluYXRlc0FycmF5fSBmcm9tICcuL2ZsYXQvZGVmbGF0ZS5qcyc7XG5pbXBvcnQge2luZmxhdGVDb29yZGluYXRlc0FycmF5fSBmcm9tICcuL2ZsYXQvaW5mbGF0ZS5qcyc7XG5pbXBvcnQge2dldEludGVyaW9yUG9pbnRPZkFycmF5fSBmcm9tICcuL2ZsYXQvaW50ZXJpb3Jwb2ludC5qcyc7XG5pbXBvcnQge2ludGVyc2VjdHNMaW5lYXJSaW5nQXJyYXl9IGZyb20gJy4vZmxhdC9pbnRlcnNlY3RzZXh0ZW50LmpzJztcbmltcG9ydCB7bGluZWFyUmluZ0lzT3JpZW50ZWQsIG9yaWVudExpbmVhclJpbmdzfSBmcm9tICcuL2ZsYXQvb3JpZW50LmpzJztcbmltcG9ydCB7cXVhbnRpemVBcnJheX0gZnJvbSAnLi9mbGF0L3NpbXBsaWZ5LmpzJztcbmltcG9ydCB7bW9kdWxvfSBmcm9tICcuLi9tYXRoLmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBQb2x5Z29uIGdlb21ldHJ5LlxuICpcbiAqIEBhcGlcbiAqL1xudmFyIFBvbHlnb24gPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChTaW1wbGVHZW9tZXRyeSkge1xuICBmdW5jdGlvbiBQb2x5Z29uKGNvb3JkaW5hdGVzLCBvcHRfbGF5b3V0LCBvcHRfZW5kcykge1xuXG4gICAgU2ltcGxlR2VvbWV0cnkuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5lbmRzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZmxhdEludGVyaW9yUG9pbnRSZXZpc2lvbl8gPSAtMTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLmZsYXRJbnRlcmlvclBvaW50XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXhEZWx0YV8gPSAtMTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1heERlbHRhUmV2aXNpb25fID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5vcmllbnRlZFJldmlzaW9uXyA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLm9yaWVudGVkRmxhdENvb3JkaW5hdGVzXyA9IG51bGw7XG5cbiAgICBpZiAob3B0X2xheW91dCAhPT0gdW5kZWZpbmVkICYmIG9wdF9lbmRzKSB7XG4gICAgICB0aGlzLnNldEZsYXRDb29yZGluYXRlcyhvcHRfbGF5b3V0LCAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovIChjb29yZGluYXRlcykpO1xuICAgICAgdGhpcy5lbmRzXyA9IG9wdF9lbmRzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldENvb3JkaW5hdGVzKC8qKiBAdHlwZSB7QXJyYXk8QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj59ICovIChjb29yZGluYXRlcyksIG9wdF9sYXlvdXQpO1xuICAgIH1cblxuICB9XG5cbiAgaWYgKCBTaW1wbGVHZW9tZXRyeSApIFBvbHlnb24uX19wcm90b19fID0gU2ltcGxlR2VvbWV0cnk7XG4gIFBvbHlnb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU2ltcGxlR2VvbWV0cnkgJiYgU2ltcGxlR2VvbWV0cnkucHJvdG90eXBlICk7XG4gIFBvbHlnb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUG9seWdvbjtcblxuICAvKipcbiAgICogQXBwZW5kIHRoZSBwYXNzZWQgbGluZWFyIHJpbmcgdG8gdGhpcyBwb2x5Z29uLlxuICAgKiBAcGFyYW0ge0xpbmVhclJpbmd9IGxpbmVhclJpbmcgTGluZWFyIHJpbmcuXG4gICAqIEBhcGlcbiAgICovXG4gIFBvbHlnb24ucHJvdG90eXBlLmFwcGVuZExpbmVhclJpbmcgPSBmdW5jdGlvbiBhcHBlbmRMaW5lYXJSaW5nIChsaW5lYXJSaW5nKSB7XG4gICAgaWYgKCF0aGlzLmZsYXRDb29yZGluYXRlcykge1xuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMgPSBsaW5lYXJSaW5nLmdldEZsYXRDb29yZGluYXRlcygpLnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4dGVuZCh0aGlzLmZsYXRDb29yZGluYXRlcywgbGluZWFyUmluZy5nZXRGbGF0Q29vcmRpbmF0ZXMoKSk7XG4gICAgfVxuICAgIHRoaXMuZW5kc18ucHVzaCh0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGgpO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNYWtlIGEgY29tcGxldGUgY29weSBvZiB0aGUgZ2VvbWV0cnkuXG4gICAqIEByZXR1cm4geyFQb2x5Z29ufSBDbG9uZS5cbiAgICogQG92ZXJyaWRlXG4gICAqIEBhcGlcbiAgICovXG4gIFBvbHlnb24ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgIHJldHVybiBuZXcgUG9seWdvbih0aGlzLmZsYXRDb29yZGluYXRlcy5zbGljZSgpLCB0aGlzLmxheW91dCwgdGhpcy5lbmRzXy5zbGljZSgpKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIFBvbHlnb24ucHJvdG90eXBlLmNsb3Nlc3RQb2ludFhZID0gZnVuY3Rpb24gY2xvc2VzdFBvaW50WFkgKHgsIHksIGNsb3Nlc3RQb2ludCwgbWluU3F1YXJlZERpc3RhbmNlKSB7XG4gICAgaWYgKG1pblNxdWFyZWREaXN0YW5jZSA8IGNsb3Nlc3RTcXVhcmVkRGlzdGFuY2VYWSh0aGlzLmdldEV4dGVudCgpLCB4LCB5KSkge1xuICAgICAgcmV0dXJuIG1pblNxdWFyZWREaXN0YW5jZTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF4RGVsdGFSZXZpc2lvbl8gIT0gdGhpcy5nZXRSZXZpc2lvbigpKSB7XG4gICAgICB0aGlzLm1heERlbHRhXyA9IE1hdGguc3FydChhcnJheU1heFNxdWFyZWREZWx0YShcbiAgICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZW5kc18sIHRoaXMuc3RyaWRlLCAwKSk7XG4gICAgICB0aGlzLm1heERlbHRhUmV2aXNpb25fID0gdGhpcy5nZXRSZXZpc2lvbigpO1xuICAgIH1cbiAgICByZXR1cm4gYXNzaWduQ2xvc2VzdEFycmF5UG9pbnQoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcywgMCwgdGhpcy5lbmRzXywgdGhpcy5zdHJpZGUsXG4gICAgICB0aGlzLm1heERlbHRhXywgdHJ1ZSwgeCwgeSwgY2xvc2VzdFBvaW50LCBtaW5TcXVhcmVkRGlzdGFuY2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgUG9seWdvbi5wcm90b3R5cGUuY29udGFpbnNYWSA9IGZ1bmN0aW9uIGNvbnRhaW5zWFkgKHgsIHkpIHtcbiAgICByZXR1cm4gbGluZWFyUmluZ3NDb250YWluc1hZKHRoaXMuZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMoKSwgMCwgdGhpcy5lbmRzXywgdGhpcy5zdHJpZGUsIHgsIHkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGFyZWEgb2YgdGhlIHBvbHlnb24gb24gcHJvamVjdGVkIHBsYW5lLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEFyZWEgKG9uIHByb2plY3RlZCBwbGFuZSkuXG4gICAqIEBhcGlcbiAgICovXG4gIFBvbHlnb24ucHJvdG90eXBlLmdldEFyZWEgPSBmdW5jdGlvbiBnZXRBcmVhICgpIHtcbiAgICByZXR1cm4gbGluZWFyUmluZ3NBcmVhKHRoaXMuZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMoKSwgMCwgdGhpcy5lbmRzXywgdGhpcy5zdHJpZGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvb3JkaW5hdGUgYXJyYXkgZm9yIHRoaXMgZ2VvbWV0cnkuICBUaGlzIGFycmF5IGhhcyB0aGUgc3RydWN0dXJlXG4gICAqIG9mIGEgR2VvSlNPTiBjb29yZGluYXRlIGFycmF5IGZvciBwb2x5Z29ucy5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3JpZ2h0IE9yaWVudCBjb29yZGluYXRlcyBhY2NvcmRpbmcgdG8gdGhlIHJpZ2h0LWhhbmRcbiAgICogICAgIHJ1bGUgKGNvdW50ZXItY2xvY2t3aXNlIGZvciBleHRlcmlvciBhbmQgY2xvY2t3aXNlIGZvciBpbnRlcmlvciByaW5ncykuXG4gICAqICAgICBJZiBgZmFsc2VgLCBjb29yZGluYXRlcyB3aWxsIGJlIG9yaWVudGVkIGFjY29yZGluZyB0byB0aGUgbGVmdC1oYW5kIHJ1bGVcbiAgICogICAgIChjbG9ja3dpc2UgZm9yIGV4dGVyaW9yIGFuZCBjb3VudGVyLWNsb2Nrd2lzZSBmb3IgaW50ZXJpb3IgcmluZ3MpLlxuICAgKiAgICAgQnkgZGVmYXVsdCwgY29vcmRpbmF0ZSBvcmllbnRhdGlvbiB3aWxsIGRlcGVuZCBvbiBob3cgdGhlIGdlb21ldHJ5IHdhc1xuICAgKiAgICAgY29uc3RydWN0ZWQuXG4gICAqIEByZXR1cm4ge0FycmF5PEFycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+fSBDb29yZGluYXRlcy5cbiAgICogQG92ZXJyaWRlXG4gICAqIEBhcGlcbiAgICovXG4gIFBvbHlnb24ucHJvdG90eXBlLmdldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZXMgKG9wdF9yaWdodCkge1xuICAgIHZhciBmbGF0Q29vcmRpbmF0ZXM7XG4gICAgaWYgKG9wdF9yaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzKCkuc2xpY2UoKTtcbiAgICAgIG9yaWVudExpbmVhclJpbmdzKFxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZW5kc18sIHRoaXMuc3RyaWRlLCBvcHRfcmlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmZsYXRDb29yZGluYXRlcztcbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbGF0ZUNvb3JkaW5hdGVzQXJyYXkoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZW5kc18sIHRoaXMuc3RyaWRlKTtcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gRW5kcy5cbiAgICovXG4gIFBvbHlnb24ucHJvdG90eXBlLmdldEVuZHMgPSBmdW5jdGlvbiBnZXRFbmRzICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbmRzXztcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gSW50ZXJpb3IgcG9pbnQuXG4gICAqL1xuICBQb2x5Z29uLnByb3RvdHlwZS5nZXRGbGF0SW50ZXJpb3JQb2ludCA9IGZ1bmN0aW9uIGdldEZsYXRJbnRlcmlvclBvaW50ICgpIHtcbiAgICBpZiAodGhpcy5mbGF0SW50ZXJpb3JQb2ludFJldmlzaW9uXyAhPSB0aGlzLmdldFJldmlzaW9uKCkpIHtcbiAgICAgIHZhciBmbGF0Q2VudGVyID0gZ2V0Q2VudGVyKHRoaXMuZ2V0RXh0ZW50KCkpO1xuICAgICAgdGhpcy5mbGF0SW50ZXJpb3JQb2ludF8gPSBnZXRJbnRlcmlvclBvaW50T2ZBcnJheShcbiAgICAgICAgdGhpcy5nZXRPcmllbnRlZEZsYXRDb29yZGluYXRlcygpLCAwLCB0aGlzLmVuZHNfLCB0aGlzLnN0cmlkZSxcbiAgICAgICAgZmxhdENlbnRlciwgMCk7XG4gICAgICB0aGlzLmZsYXRJbnRlcmlvclBvaW50UmV2aXNpb25fID0gdGhpcy5nZXRSZXZpc2lvbigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mbGF0SW50ZXJpb3JQb2ludF87XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBpbnRlcmlvciBwb2ludCBvZiB0aGUgcG9seWdvbi5cbiAgICogQHJldHVybiB7UG9pbnR9IEludGVyaW9yIHBvaW50IGFzIFhZTSBjb29yZGluYXRlLCB3aGVyZSBNIGlzIHRoZVxuICAgKiBsZW5ndGggb2YgdGhlIGhvcml6b250YWwgaW50ZXJzZWN0aW9uIHRoYXQgdGhlIHBvaW50IGJlbG9uZ3MgdG8uXG4gICAqIEBhcGlcbiAgICovXG4gIFBvbHlnb24ucHJvdG90eXBlLmdldEludGVyaW9yUG9pbnQgPSBmdW5jdGlvbiBnZXRJbnRlcmlvclBvaW50ICgpIHtcbiAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMuZ2V0RmxhdEludGVyaW9yUG9pbnQoKSwgR2VvbWV0cnlMYXlvdXQuWFlNKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBudW1iZXIgb2YgcmluZ3Mgb2YgdGhlIHBvbHlnb24sICB0aGlzIGluY2x1ZGVzIHRoZSBleHRlcmlvclxuICAgKiByaW5nIGFuZCBhbnkgaW50ZXJpb3IgcmluZ3MuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn0gTnVtYmVyIG9mIHJpbmdzLlxuICAgKiBAYXBpXG4gICAqL1xuICBQb2x5Z29uLnByb3RvdHlwZS5nZXRMaW5lYXJSaW5nQ291bnQgPSBmdW5jdGlvbiBnZXRMaW5lYXJSaW5nQ291bnQgKCkge1xuICAgIHJldHVybiB0aGlzLmVuZHNfLmxlbmd0aDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBOdGggbGluZWFyIHJpbmcgb2YgdGhlIHBvbHlnb24gZ2VvbWV0cnkuIFJldHVybiBgbnVsbGAgaWYgdGhlXG4gICAqIGdpdmVuIGluZGV4IGlzIG91dCBvZiByYW5nZS5cbiAgICogVGhlIGV4dGVyaW9yIGxpbmVhciByaW5nIGlzIGF2YWlsYWJsZSBhdCBpbmRleCBgMGAgYW5kIHRoZSBpbnRlcmlvciByaW5nc1xuICAgKiBhdCBpbmRleCBgMWAgYW5kIGJleW9uZC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4LlxuICAgKiBAcmV0dXJuIHtMaW5lYXJSaW5nfSBMaW5lYXIgcmluZy5cbiAgICogQGFwaVxuICAgKi9cbiAgUG9seWdvbi5wcm90b3R5cGUuZ2V0TGluZWFyUmluZyA9IGZ1bmN0aW9uIGdldExpbmVhclJpbmcgKGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCB0aGlzLmVuZHNfLmxlbmd0aCA8PSBpbmRleCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTGluZWFyUmluZyh0aGlzLmZsYXRDb29yZGluYXRlcy5zbGljZShcbiAgICAgIGluZGV4ID09PSAwID8gMCA6IHRoaXMuZW5kc19baW5kZXggLSAxXSwgdGhpcy5lbmRzX1tpbmRleF0pLCB0aGlzLmxheW91dCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbGluZWFyIHJpbmdzIG9mIHRoZSBwb2x5Z29uLlxuICAgKiBAcmV0dXJuIHtBcnJheTxMaW5lYXJSaW5nPn0gTGluZWFyIHJpbmdzLlxuICAgKiBAYXBpXG4gICAqL1xuICBQb2x5Z29uLnByb3RvdHlwZS5nZXRMaW5lYXJSaW5ncyA9IGZ1bmN0aW9uIGdldExpbmVhclJpbmdzICgpIHtcbiAgICB2YXIgbGF5b3V0ID0gdGhpcy5sYXlvdXQ7XG4gICAgdmFyIGZsYXRDb29yZGluYXRlcyA9IHRoaXMuZmxhdENvb3JkaW5hdGVzO1xuICAgIHZhciBlbmRzID0gdGhpcy5lbmRzXztcbiAgICB2YXIgbGluZWFyUmluZ3MgPSBbXTtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIHZhciBlbmQgPSBlbmRzW2ldO1xuICAgICAgdmFyIGxpbmVhclJpbmcgPSBuZXcgTGluZWFyUmluZyhmbGF0Q29vcmRpbmF0ZXMuc2xpY2Uob2Zmc2V0LCBlbmQpLCBsYXlvdXQpO1xuICAgICAgbGluZWFyUmluZ3MucHVzaChsaW5lYXJSaW5nKTtcbiAgICAgIG9mZnNldCA9IGVuZDtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmVhclJpbmdzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBPcmllbnRlZCBmbGF0IGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgUG9seWdvbi5wcm90b3R5cGUuZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBnZXRPcmllbnRlZEZsYXRDb29yZGluYXRlcyAoKSB7XG4gICAgaWYgKHRoaXMub3JpZW50ZWRSZXZpc2lvbl8gIT0gdGhpcy5nZXRSZXZpc2lvbigpKSB7XG4gICAgICB2YXIgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5mbGF0Q29vcmRpbmF0ZXM7XG4gICAgICBpZiAobGluZWFyUmluZ0lzT3JpZW50ZWQoXG4gICAgICAgIGZsYXRDb29yZGluYXRlcywgMCwgdGhpcy5lbmRzXywgdGhpcy5zdHJpZGUpKSB7XG4gICAgICAgIHRoaXMub3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXNfID0gZmxhdENvb3JkaW5hdGVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vcmllbnRlZEZsYXRDb29yZGluYXRlc18gPSBmbGF0Q29vcmRpbmF0ZXMuc2xpY2UoKTtcbiAgICAgICAgdGhpcy5vcmllbnRlZEZsYXRDb29yZGluYXRlc18ubGVuZ3RoID1cbiAgICAgICAgICAgIG9yaWVudExpbmVhclJpbmdzKFxuICAgICAgICAgICAgICB0aGlzLm9yaWVudGVkRmxhdENvb3JkaW5hdGVzXywgMCwgdGhpcy5lbmRzXywgdGhpcy5zdHJpZGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5vcmllbnRlZFJldmlzaW9uXyA9IHRoaXMuZ2V0UmV2aXNpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMub3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXNfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgUG9seWdvbi5wcm90b3R5cGUuZ2V0U2ltcGxpZmllZEdlb21ldHJ5SW50ZXJuYWwgPSBmdW5jdGlvbiBnZXRTaW1wbGlmaWVkR2VvbWV0cnlJbnRlcm5hbCAoc3F1YXJlZFRvbGVyYW5jZSkge1xuICAgIHZhciBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzID0gW107XG4gICAgdmFyIHNpbXBsaWZpZWRFbmRzID0gW107XG4gICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcy5sZW5ndGggPSBxdWFudGl6ZUFycmF5KFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZW5kc18sIHRoaXMuc3RyaWRlLFxuICAgICAgTWF0aC5zcXJ0KHNxdWFyZWRUb2xlcmFuY2UpLFxuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcywgMCwgc2ltcGxpZmllZEVuZHMpO1xuICAgIHJldHVybiBuZXcgUG9seWdvbihzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLCBHZW9tZXRyeUxheW91dC5YWSwgc2ltcGxpZmllZEVuZHMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKiBAYXBpXG4gICAqL1xuICBQb2x5Z29uLnByb3RvdHlwZS5nZXRUeXBlID0gZnVuY3Rpb24gZ2V0VHlwZSAoKSB7XG4gICAgcmV0dXJuIEdlb21ldHJ5VHlwZS5QT0xZR09OO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKiBAYXBpXG4gICAqL1xuICBQb2x5Z29uLnByb3RvdHlwZS5pbnRlcnNlY3RzRXh0ZW50ID0gZnVuY3Rpb24gaW50ZXJzZWN0c0V4dGVudCAoZXh0ZW50KSB7XG4gICAgcmV0dXJuIGludGVyc2VjdHNMaW5lYXJSaW5nQXJyYXkoXG4gICAgICB0aGlzLmdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzKCksIDAsIHRoaXMuZW5kc18sIHRoaXMuc3RyaWRlLCBleHRlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2x5Z29uLlxuICAgKiBAcGFyYW0geyFBcnJheTxBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+Pn0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7R2VvbWV0cnlMYXlvdXQ9fSBvcHRfbGF5b3V0IExheW91dC5cbiAgICogQG92ZXJyaWRlXG4gICAqIEBhcGlcbiAgICovXG4gIFBvbHlnb24ucHJvdG90eXBlLnNldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gc2V0Q29vcmRpbmF0ZXMgKGNvb3JkaW5hdGVzLCBvcHRfbGF5b3V0KSB7XG4gICAgdGhpcy5zZXRMYXlvdXQob3B0X2xheW91dCwgY29vcmRpbmF0ZXMsIDIpO1xuICAgIGlmICghdGhpcy5mbGF0Q29vcmRpbmF0ZXMpIHtcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzID0gW107XG4gICAgfVxuICAgIHZhciBlbmRzID0gZGVmbGF0ZUNvb3JkaW5hdGVzQXJyYXkoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcywgMCwgY29vcmRpbmF0ZXMsIHRoaXMuc3RyaWRlLCB0aGlzLmVuZHNfKTtcbiAgICB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGggPSBlbmRzLmxlbmd0aCA9PT0gMCA/IDAgOiBlbmRzW2VuZHMubGVuZ3RoIC0gMV07XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH07XG5cbiAgcmV0dXJuIFBvbHlnb247XG59KFNpbXBsZUdlb21ldHJ5KSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgUG9seWdvbjtcblxuXG4vKipcbiAqIENyZWF0ZSBhbiBhcHByb3hpbWF0aW9uIG9mIGEgY2lyY2xlIG9uIHRoZSBzdXJmYWNlIG9mIGEgc3BoZXJlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNlbnRlciBDZW50ZXIgKGBbbG9uLCBsYXRdYCBpbiBkZWdyZWVzKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgVGhlIGdyZWF0LWNpcmNsZSBkaXN0YW5jZSBmcm9tIHRoZSBjZW50ZXIgdG9cbiAqICAgICB0aGUgcG9seWdvbiB2ZXJ0aWNlcy5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X24gT3B0aW9uYWwgbnVtYmVyIG9mIHZlcnRpY2VzIGZvciB0aGUgcmVzdWx0aW5nXG4gKiAgICAgcG9seWdvbi4gRGVmYXVsdCBpcyBgMzJgLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfc3BoZXJlUmFkaXVzIE9wdGlvbmFsIHJhZGl1cyBmb3IgdGhlIHNwaGVyZSAoZGVmYXVsdHMgdG9cbiAqICAgICB0aGUgRWFydGgncyBtZWFuIHJhZGl1cyB1c2luZyB0aGUgV0dTODQgZWxsaXBzb2lkKS5cbiAqIEByZXR1cm4ge1BvbHlnb259IFRoZSBcImNpcmN1bGFyXCIgcG9seWdvbi5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNpcmN1bGFyKGNlbnRlciwgcmFkaXVzLCBvcHRfbiwgb3B0X3NwaGVyZVJhZGl1cykge1xuICB2YXIgbiA9IG9wdF9uID8gb3B0X24gOiAzMjtcbiAgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqL1xuICB2YXIgZmxhdENvb3JkaW5hdGVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgZXh0ZW5kKGZsYXRDb29yZGluYXRlcywgc3BoZXJlT2Zmc2V0KGNlbnRlciwgcmFkaXVzLCAyICogTWF0aC5QSSAqIGkgLyBuLCBvcHRfc3BoZXJlUmFkaXVzKSk7XG4gIH1cbiAgZmxhdENvb3JkaW5hdGVzLnB1c2goZmxhdENvb3JkaW5hdGVzWzBdLCBmbGF0Q29vcmRpbmF0ZXNbMV0pO1xuICByZXR1cm4gbmV3IFBvbHlnb24oZmxhdENvb3JkaW5hdGVzLCBHZW9tZXRyeUxheW91dC5YWSwgW2ZsYXRDb29yZGluYXRlcy5sZW5ndGhdKTtcbn1cblxuXG4vKipcbiAqIENyZWF0ZSBhIHBvbHlnb24gZnJvbSBhbiBleHRlbnQuIFRoZSBsYXlvdXQgdXNlZCBpcyBgWFlgLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgVGhlIGV4dGVudC5cbiAqIEByZXR1cm4ge1BvbHlnb259IFRoZSBwb2x5Z29uLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUV4dGVudChleHRlbnQpIHtcbiAgdmFyIG1pblggPSBleHRlbnRbMF07XG4gIHZhciBtaW5ZID0gZXh0ZW50WzFdO1xuICB2YXIgbWF4WCA9IGV4dGVudFsyXTtcbiAgdmFyIG1heFkgPSBleHRlbnRbM107XG4gIHZhciBmbGF0Q29vcmRpbmF0ZXMgPVxuICAgICAgW21pblgsIG1pblksIG1pblgsIG1heFksIG1heFgsIG1heFksIG1heFgsIG1pblksIG1pblgsIG1pblldO1xuICByZXR1cm4gbmV3IFBvbHlnb24oZmxhdENvb3JkaW5hdGVzLCBHZW9tZXRyeUxheW91dC5YWSwgW2ZsYXRDb29yZGluYXRlcy5sZW5ndGhdKTtcbn1cblxuXG4vKipcbiAqIENyZWF0ZSBhIHJlZ3VsYXIgcG9seWdvbiBmcm9tIGEgY2lyY2xlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL0NpcmNsZS5qc1wiKS5kZWZhdWx0fSBjaXJjbGUgQ2lyY2xlIGdlb21ldHJ5LlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfc2lkZXMgTnVtYmVyIG9mIHNpZGVzIG9mIHRoZSBwb2x5Z29uLiBEZWZhdWx0IGlzIDMyLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfYW5nbGUgU3RhcnQgYW5nbGUgZm9yIHRoZSBmaXJzdCB2ZXJ0ZXggb2YgdGhlIHBvbHlnb24gaW5cbiAqICAgICByYWRpYW5zLiBEZWZhdWx0IGlzIDAuXG4gKiBAcmV0dXJuIHtQb2x5Z29ufSBQb2x5Z29uIGdlb21ldHJ5LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUNpcmNsZShjaXJjbGUsIG9wdF9zaWRlcywgb3B0X2FuZ2xlKSB7XG4gIHZhciBzaWRlcyA9IG9wdF9zaWRlcyA/IG9wdF9zaWRlcyA6IDMyO1xuICB2YXIgc3RyaWRlID0gY2lyY2xlLmdldFN0cmlkZSgpO1xuICB2YXIgbGF5b3V0ID0gY2lyY2xlLmdldExheW91dCgpO1xuICB2YXIgY2VudGVyID0gY2lyY2xlLmdldENlbnRlcigpO1xuICB2YXIgYXJyYXlMZW5ndGggPSBzdHJpZGUgKiAoc2lkZXMgKyAxKTtcbiAgdmFyIGZsYXRDb29yZGluYXRlcyA9IG5ldyBBcnJheShhcnJheUxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlMZW5ndGg7IGkgKz0gc3RyaWRlKSB7XG4gICAgZmxhdENvb3JkaW5hdGVzW2ldID0gMDtcbiAgICBmbGF0Q29vcmRpbmF0ZXNbaSArIDFdID0gMDtcbiAgICBmb3IgKHZhciBqID0gMjsgaiA8IHN0cmlkZTsgaisrKSB7XG4gICAgICBmbGF0Q29vcmRpbmF0ZXNbaSArIGpdID0gY2VudGVyW2pdO1xuICAgIH1cbiAgfVxuICB2YXIgZW5kcyA9IFtmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoXTtcbiAgdmFyIHBvbHlnb24gPSBuZXcgUG9seWdvbihmbGF0Q29vcmRpbmF0ZXMsIGxheW91dCwgZW5kcyk7XG4gIG1ha2VSZWd1bGFyKHBvbHlnb24sIGNlbnRlciwgY2lyY2xlLmdldFJhZGl1cygpLCBvcHRfYW5nbGUpO1xuICByZXR1cm4gcG9seWdvbjtcbn1cblxuXG4vKipcbiAqIE1vZGlmeSB0aGUgY29vcmRpbmF0ZXMgb2YgYSBwb2x5Z29uIHRvIG1ha2UgaXQgYSByZWd1bGFyIHBvbHlnb24uXG4gKiBAcGFyYW0ge1BvbHlnb259IHBvbHlnb24gUG9seWdvbiBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjZW50ZXIgQ2VudGVyIG9mIHRoZSByZWd1bGFyIHBvbHlnb24uXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFJhZGl1cyBvZiB0aGUgcmVndWxhciBwb2x5Z29uLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfYW5nbGUgU3RhcnQgYW5nbGUgZm9yIHRoZSBmaXJzdCB2ZXJ0ZXggb2YgdGhlIHBvbHlnb24gaW5cbiAqICAgICByYWRpYW5zLiBEZWZhdWx0IGlzIDAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlUmVndWxhcihwb2x5Z29uLCBjZW50ZXIsIHJhZGl1cywgb3B0X2FuZ2xlKSB7XG4gIHZhciBmbGF0Q29vcmRpbmF0ZXMgPSBwb2x5Z29uLmdldEZsYXRDb29yZGluYXRlcygpO1xuICB2YXIgc3RyaWRlID0gcG9seWdvbi5nZXRTdHJpZGUoKTtcbiAgdmFyIHNpZGVzID0gZmxhdENvb3JkaW5hdGVzLmxlbmd0aCAvIHN0cmlkZSAtIDE7XG4gIHZhciBzdGFydEFuZ2xlID0gb3B0X2FuZ2xlID8gb3B0X2FuZ2xlIDogMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPD0gc2lkZXM7ICsraSkge1xuICAgIHZhciBvZmZzZXQgPSBpICogc3RyaWRlO1xuICAgIHZhciBhbmdsZSA9IHN0YXJ0QW5nbGUgKyAobW9kdWxvKGksIHNpZGVzKSAqIDIgKiBNYXRoLlBJIC8gc2lkZXMpO1xuICAgIGZsYXRDb29yZGluYXRlc1tvZmZzZXRdID0gY2VudGVyWzBdICsgKHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlKSk7XG4gICAgZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdID0gY2VudGVyWzFdICsgKHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlKSk7XG4gIH1cbiAgcG9seWdvbi5jaGFuZ2VkKCk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBvbHlnb24uanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vU2ltcGxlR2VvbWV0cnlcbiAqL1xuaW1wb3J0IHthYnN0cmFjdH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5pbXBvcnQge2NyZWF0ZU9yVXBkYXRlRnJvbUZsYXRDb29yZGluYXRlcywgZ2V0Q2VudGVyfSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IEdlb21ldHJ5IGZyb20gJy4vR2VvbWV0cnkuanMnO1xuaW1wb3J0IEdlb21ldHJ5TGF5b3V0IGZyb20gJy4vR2VvbWV0cnlMYXlvdXQuanMnO1xuaW1wb3J0IHtyb3RhdGUsIHNjYWxlLCB0cmFuc2xhdGUsIHRyYW5zZm9ybTJEfSBmcm9tICcuL2ZsYXQvdHJhbnNmb3JtLmpzJztcbmltcG9ydCB7Y2xlYXJ9IGZyb20gJy4uL29iai5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWJzdHJhY3QgYmFzZSBjbGFzczsgb25seSB1c2VkIGZvciBjcmVhdGluZyBzdWJjbGFzc2VzOyBkbyBub3QgaW5zdGFudGlhdGVcbiAqIGluIGFwcHMsIGFzIGNhbm5vdCBiZSByZW5kZXJlZC5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqIEBhcGlcbiAqL1xudmFyIFNpbXBsZUdlb21ldHJ5ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoR2VvbWV0cnkpIHtcbiAgZnVuY3Rpb24gU2ltcGxlR2VvbWV0cnkoKSB7XG5cbiAgICBHZW9tZXRyeS5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtHZW9tZXRyeUxheW91dH1cbiAgICAgKi9cbiAgICB0aGlzLmxheW91dCA9IEdlb21ldHJ5TGF5b3V0LlhZO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zdHJpZGUgPSAyO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzID0gbnVsbDtcblxuICB9XG5cbiAgaWYgKCBHZW9tZXRyeSApIFNpbXBsZUdlb21ldHJ5Ll9fcHJvdG9fXyA9IEdlb21ldHJ5O1xuICBTaW1wbGVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeSAmJiBHZW9tZXRyeS5wcm90b3R5cGUgKTtcbiAgU2ltcGxlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2ltcGxlR2VvbWV0cnk7XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBTaW1wbGVHZW9tZXRyeS5wcm90b3R5cGUuY29tcHV0ZUV4dGVudCA9IGZ1bmN0aW9uIGNvbXB1dGVFeHRlbnQgKGV4dGVudCkge1xuICAgIHJldHVybiBjcmVhdGVPclVwZGF0ZUZyb21GbGF0Q29vcmRpbmF0ZXModGhpcy5mbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAwLCB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHRoaXMuc3RyaWRlLCBleHRlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7QXJyYXl9IENvb3JkaW5hdGVzLlxuICAgKi9cbiAgU2ltcGxlR2VvbWV0cnkucHJvdG90eXBlLmdldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZXMgKCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGZpcnN0IGNvb3JkaW5hdGUgb2YgdGhlIGdlb21ldHJ5LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IEZpcnN0IGNvb3JkaW5hdGUuXG4gICAqIEBhcGlcbiAgICovXG4gIFNpbXBsZUdlb21ldHJ5LnByb3RvdHlwZS5nZXRGaXJzdENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRGaXJzdENvb3JkaW5hdGUgKCkge1xuICAgIHJldHVybiB0aGlzLmZsYXRDb29yZGluYXRlcy5zbGljZSgwLCB0aGlzLnN0cmlkZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEZsYXQgY29vcmRpbmF0ZXMuXG4gICAqL1xuICBTaW1wbGVHZW9tZXRyeS5wcm90b3R5cGUuZ2V0RmxhdENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZ2V0RmxhdENvb3JkaW5hdGVzICgpIHtcbiAgICByZXR1cm4gdGhpcy5mbGF0Q29vcmRpbmF0ZXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbGFzdCBjb29yZGluYXRlIG9mIHRoZSBnZW9tZXRyeS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBMYXN0IHBvaW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBTaW1wbGVHZW9tZXRyeS5wcm90b3R5cGUuZ2V0TGFzdENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRMYXN0Q29vcmRpbmF0ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmxhdENvb3JkaW5hdGVzLnNsaWNlKHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCAtIHRoaXMuc3RyaWRlKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB7QGxpbmsgbW9kdWxlOm9sL2dlb20vR2VvbWV0cnlMYXlvdXQgbGF5b3V0fSBvZiB0aGUgZ2VvbWV0cnkuXG4gICAqIEByZXR1cm4ge0dlb21ldHJ5TGF5b3V0fSBMYXlvdXQuXG4gICAqIEBhcGlcbiAgICovXG4gIFNpbXBsZUdlb21ldHJ5LnByb3RvdHlwZS5nZXRMYXlvdXQgPSBmdW5jdGlvbiBnZXRMYXlvdXQgKCkge1xuICAgIHJldHVybiB0aGlzLmxheW91dDtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIFNpbXBsZUdlb21ldHJ5LnByb3RvdHlwZS5nZXRTaW1wbGlmaWVkR2VvbWV0cnkgPSBmdW5jdGlvbiBnZXRTaW1wbGlmaWVkR2VvbWV0cnkgKHNxdWFyZWRUb2xlcmFuY2UpIHtcbiAgICBpZiAodGhpcy5zaW1wbGlmaWVkR2VvbWV0cnlSZXZpc2lvbiAhPSB0aGlzLmdldFJldmlzaW9uKCkpIHtcbiAgICAgIGNsZWFyKHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5Q2FjaGUpO1xuICAgICAgdGhpcy5zaW1wbGlmaWVkR2VvbWV0cnlNYXhNaW5TcXVhcmVkVG9sZXJhbmNlID0gMDtcbiAgICAgIHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5UmV2aXNpb24gPSB0aGlzLmdldFJldmlzaW9uKCk7XG4gICAgfVxuICAgIC8vIElmIHNxdWFyZWRUb2xlcmFuY2UgaXMgbmVnYXRpdmUgb3IgaWYgd2Uga25vdyB0aGF0IHNpbXBsaWZpY2F0aW9uIHdpbGwgbm90XG4gICAgLy8gaGF2ZSBhbnkgZWZmZWN0IHRoZW4ganVzdCByZXR1cm4gdGhpcy5cbiAgICBpZiAoc3F1YXJlZFRvbGVyYW5jZSA8IDAgfHxcbiAgICAgICAgKHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5TWF4TWluU3F1YXJlZFRvbGVyYW5jZSAhPT0gMCAmJlxuICAgICAgICAgc3F1YXJlZFRvbGVyYW5jZSA8PSB0aGlzLnNpbXBsaWZpZWRHZW9tZXRyeU1heE1pblNxdWFyZWRUb2xlcmFuY2UpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIGtleSA9IHNxdWFyZWRUb2xlcmFuY2UudG9TdHJpbmcoKTtcbiAgICBpZiAodGhpcy5zaW1wbGlmaWVkR2VvbWV0cnlDYWNoZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaW1wbGlmaWVkR2VvbWV0cnlDYWNoZVtrZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2ltcGxpZmllZEdlb21ldHJ5ID1cbiAgICAgICAgICB0aGlzLmdldFNpbXBsaWZpZWRHZW9tZXRyeUludGVybmFsKHNxdWFyZWRUb2xlcmFuY2UpO1xuICAgICAgdmFyIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMgPSBzaW1wbGlmaWVkR2VvbWV0cnkuZ2V0RmxhdENvb3JkaW5hdGVzKCk7XG4gICAgICBpZiAoc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcy5sZW5ndGggPCB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5zaW1wbGlmaWVkR2VvbWV0cnlDYWNoZVtrZXldID0gc2ltcGxpZmllZEdlb21ldHJ5O1xuICAgICAgICByZXR1cm4gc2ltcGxpZmllZEdlb21ldHJ5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2ltcGxpZmljYXRpb24gZGlkIG5vdCBhY3R1YWxseSByZW1vdmUgYW55IGNvb3JkaW5hdGVzLiAgV2Ugbm93IGtub3dcbiAgICAgICAgLy8gdGhhdCBhbnkgY2FsbHMgdG8gZ2V0U2ltcGxpZmllZEdlb21ldHJ5IHdpdGggYSBzcXVhcmVkVG9sZXJhbmNlIGxlc3NcbiAgICAgICAgLy8gdGhhbiBvciBlcXVhbCB0byB0aGUgY3VycmVudCBzcXVhcmVkVG9sZXJhbmNlIHdpbGwgYWxzbyBub3QgaGF2ZSBhbnlcbiAgICAgICAgLy8gZWZmZWN0LiAgVGhpcyBhbGxvd3MgdXMgdG8gc2hvcnQgY2lyY3VpdCBzaW1wbGlmaWNhdGlvbiAoc2F2aW5nIENQVVxuICAgICAgICAvLyBjeWNsZXMpIGFuZCBwcmV2ZW50cyB0aGUgY2FjaGUgb2Ygc2ltcGxpZmllZCBnZW9tZXRyaWVzIGZyb20gZmlsbGluZ1xuICAgICAgICAvLyB1cCB3aXRoIHVzZWxlc3MgaWRlbnRpY2FsIGNvcGllcyBvZiB0aGlzIGdlb21ldHJ5IChzYXZpbmcgbWVtb3J5KS5cbiAgICAgICAgdGhpcy5zaW1wbGlmaWVkR2VvbWV0cnlNYXhNaW5TcXVhcmVkVG9sZXJhbmNlID0gc3F1YXJlZFRvbGVyYW5jZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3F1YXJlZFRvbGVyYW5jZSBTcXVhcmVkIHRvbGVyYW5jZS5cbiAgICogQHJldHVybiB7U2ltcGxlR2VvbWV0cnl9IFNpbXBsaWZpZWQgZ2VvbWV0cnkuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIFNpbXBsZUdlb21ldHJ5LnByb3RvdHlwZS5nZXRTaW1wbGlmaWVkR2VvbWV0cnlJbnRlcm5hbCA9IGZ1bmN0aW9uIGdldFNpbXBsaWZpZWRHZW9tZXRyeUludGVybmFsIChzcXVhcmVkVG9sZXJhbmNlKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gU3RyaWRlLlxuICAgKi9cbiAgU2ltcGxlR2VvbWV0cnkucHJvdG90eXBlLmdldFN0cmlkZSA9IGZ1bmN0aW9uIGdldFN0cmlkZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyaWRlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0dlb21ldHJ5TGF5b3V0fSBsYXlvdXQgTGF5b3V0LlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgU2ltcGxlR2VvbWV0cnkucHJvdG90eXBlLnNldEZsYXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIHNldEZsYXRDb29yZGluYXRlcyAobGF5b3V0LCBmbGF0Q29vcmRpbmF0ZXMpIHtcbiAgICB0aGlzLnN0cmlkZSA9IGdldFN0cmlkZUZvckxheW91dChsYXlvdXQpO1xuICAgIHRoaXMubGF5b3V0ID0gbGF5b3V0O1xuICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzID0gZmxhdENvb3JkaW5hdGVzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHshQXJyYXl9IGNvb3JkaW5hdGVzIENvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0ge0dlb21ldHJ5TGF5b3V0PX0gb3B0X2xheW91dCBMYXlvdXQuXG4gICAqL1xuICBTaW1wbGVHZW9tZXRyeS5wcm90b3R5cGUuc2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBzZXRDb29yZGluYXRlcyAoY29vcmRpbmF0ZXMsIG9wdF9sYXlvdXQpIHtcbiAgICBhYnN0cmFjdCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0dlb21ldHJ5TGF5b3V0fHVuZGVmaW5lZH0gbGF5b3V0IExheW91dC5cbiAgICogQHBhcmFtIHtBcnJheX0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuZXN0aW5nIE5lc3RpbmcuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIFNpbXBsZUdlb21ldHJ5LnByb3RvdHlwZS5zZXRMYXlvdXQgPSBmdW5jdGlvbiBzZXRMYXlvdXQgKGxheW91dCwgY29vcmRpbmF0ZXMsIG5lc3RpbmcpIHtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB2YXIgc3RyaWRlO1xuICAgIGlmIChsYXlvdXQpIHtcbiAgICAgIHN0cmlkZSA9IGdldFN0cmlkZUZvckxheW91dChsYXlvdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5lc3Rpbmc7ICsraSkge1xuICAgICAgICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5sYXlvdXQgPSBHZW9tZXRyeUxheW91dC5YWTtcbiAgICAgICAgICB0aGlzLnN0cmlkZSA9IDI7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvb3JkaW5hdGVzID0gLyoqIEB0eXBlIHtBcnJheX0gKi8gKGNvb3JkaW5hdGVzWzBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RyaWRlID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgICAgbGF5b3V0ID0gZ2V0TGF5b3V0Rm9yU3RyaWRlKHN0cmlkZSk7XG4gICAgfVxuICAgIHRoaXMubGF5b3V0ID0gbGF5b3V0O1xuICAgIHRoaXMuc3RyaWRlID0gc3RyaWRlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKiBAYXBpXG4gICAqL1xuICBTaW1wbGVHZW9tZXRyeS5wcm90b3R5cGUuYXBwbHlUcmFuc2Zvcm0gPSBmdW5jdGlvbiBhcHBseVRyYW5zZm9ybSAodHJhbnNmb3JtRm4pIHtcbiAgICBpZiAodGhpcy5mbGF0Q29vcmRpbmF0ZXMpIHtcbiAgICAgIHRyYW5zZm9ybUZuKHRoaXMuZmxhdENvb3JkaW5hdGVzLCB0aGlzLmZsYXRDb29yZGluYXRlcywgdGhpcy5zdHJpZGUpO1xuICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKiBAYXBpXG4gICAqL1xuICBTaW1wbGVHZW9tZXRyeS5wcm90b3R5cGUucm90YXRlID0gZnVuY3Rpb24gcm90YXRlJDEgKGFuZ2xlLCBhbmNob3IpIHtcbiAgICB2YXIgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICBpZiAoZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgICB2YXIgc3RyaWRlID0gdGhpcy5nZXRTdHJpZGUoKTtcbiAgICAgIHJvdGF0ZShcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzLCAwLCBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLFxuICAgICAgICBzdHJpZGUsIGFuZ2xlLCBhbmNob3IsIGZsYXRDb29yZGluYXRlcyk7XG4gICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqIEBhcGlcbiAgICovXG4gIFNpbXBsZUdlb21ldHJ5LnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uIHNjYWxlJDEgKHN4LCBvcHRfc3ksIG9wdF9hbmNob3IpIHtcbiAgICB2YXIgc3kgPSBvcHRfc3k7XG4gICAgaWYgKHN5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHN5ID0gc3g7XG4gICAgfVxuICAgIHZhciBhbmNob3IgPSBvcHRfYW5jaG9yO1xuICAgIGlmICghYW5jaG9yKSB7XG4gICAgICBhbmNob3IgPSBnZXRDZW50ZXIodGhpcy5nZXRFeHRlbnQoKSk7XG4gICAgfVxuICAgIHZhciBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgIGlmIChmbGF0Q29vcmRpbmF0ZXMpIHtcbiAgICAgIHZhciBzdHJpZGUgPSB0aGlzLmdldFN0cmlkZSgpO1xuICAgICAgc2NhbGUoXG4gICAgICAgIGZsYXRDb29yZGluYXRlcywgMCwgZmxhdENvb3JkaW5hdGVzLmxlbmd0aCxcbiAgICAgICAgc3RyaWRlLCBzeCwgc3ksIGFuY2hvciwgZmxhdENvb3JkaW5hdGVzKTtcbiAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGFwaVxuICAgKi9cbiAgU2ltcGxlR2VvbWV0cnkucHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIHRyYW5zbGF0ZSQxIChkZWx0YVgsIGRlbHRhWSkge1xuICAgIHZhciBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgIGlmIChmbGF0Q29vcmRpbmF0ZXMpIHtcbiAgICAgIHZhciBzdHJpZGUgPSB0aGlzLmdldFN0cmlkZSgpO1xuICAgICAgdHJhbnNsYXRlKFxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXMsIDAsIGZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHN0cmlkZSxcbiAgICAgICAgZGVsdGFYLCBkZWx0YVksIGZsYXRDb29yZGluYXRlcyk7XG4gICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFNpbXBsZUdlb21ldHJ5O1xufShHZW9tZXRyeSkpO1xuXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcmV0dXJuIHtHZW9tZXRyeUxheW91dH0gbGF5b3V0IExheW91dC5cbiAqL1xuZnVuY3Rpb24gZ2V0TGF5b3V0Rm9yU3RyaWRlKHN0cmlkZSkge1xuICB2YXIgbGF5b3V0O1xuICBpZiAoc3RyaWRlID09IDIpIHtcbiAgICBsYXlvdXQgPSBHZW9tZXRyeUxheW91dC5YWTtcbiAgfSBlbHNlIGlmIChzdHJpZGUgPT0gMykge1xuICAgIGxheW91dCA9IEdlb21ldHJ5TGF5b3V0LlhZWjtcbiAgfSBlbHNlIGlmIChzdHJpZGUgPT0gNCkge1xuICAgIGxheW91dCA9IEdlb21ldHJ5TGF5b3V0LlhZWk07XG4gIH1cbiAgcmV0dXJuIChcbiAgICAvKiogQHR5cGUge0dlb21ldHJ5TGF5b3V0fSAqLyAobGF5b3V0KVxuICApO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtHZW9tZXRyeUxheW91dH0gbGF5b3V0IExheW91dC5cbiAqIEByZXR1cm4ge251bWJlcn0gU3RyaWRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RyaWRlRm9yTGF5b3V0KGxheW91dCkge1xuICB2YXIgc3RyaWRlO1xuICBpZiAobGF5b3V0ID09IEdlb21ldHJ5TGF5b3V0LlhZKSB7XG4gICAgc3RyaWRlID0gMjtcbiAgfSBlbHNlIGlmIChsYXlvdXQgPT0gR2VvbWV0cnlMYXlvdXQuWFlaIHx8IGxheW91dCA9PSBHZW9tZXRyeUxheW91dC5YWU0pIHtcbiAgICBzdHJpZGUgPSAzO1xuICB9IGVsc2UgaWYgKGxheW91dCA9PSBHZW9tZXRyeUxheW91dC5YWVpNKSB7XG4gICAgc3RyaWRlID0gNDtcbiAgfVxuICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChzdHJpZGUpO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtTaW1wbGVHZW9tZXRyeX0gc2ltcGxlR2VvbWV0cnkgU2ltcGxlIGdlb21ldHJ5LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfSB0cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+PX0gb3B0X2Rlc3QgRGVzdGluYXRpb24uXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUcmFuc2Zvcm1lZCBmbGF0IGNvb3JkaW5hdGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtR2VvbTJEKHNpbXBsZUdlb21ldHJ5LCB0cmFuc2Zvcm0sIG9wdF9kZXN0KSB7XG4gIHZhciBmbGF0Q29vcmRpbmF0ZXMgPSBzaW1wbGVHZW9tZXRyeS5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgaWYgKCFmbGF0Q29vcmRpbmF0ZXMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc3RyaWRlID0gc2ltcGxlR2VvbWV0cnkuZ2V0U3RyaWRlKCk7XG4gICAgcmV0dXJuIHRyYW5zZm9ybTJEKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLCAwLCBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLCBzdHJpZGUsXG4gICAgICB0cmFuc2Zvcm0sIG9wdF9kZXN0KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTaW1wbGVHZW9tZXRyeTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2ltcGxlR2VvbWV0cnkuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9hcmVhXG4gKi9cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFyZWEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJSaW5nKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSkge1xuICB2YXIgdHdpY2VBcmVhID0gMDtcbiAgdmFyIHgxID0gZmxhdENvb3JkaW5hdGVzW2VuZCAtIHN0cmlkZV07XG4gIHZhciB5MSA9IGZsYXRDb29yZGluYXRlc1tlbmQgLSBzdHJpZGUgKyAxXTtcbiAgZm9yICg7IG9mZnNldCA8IGVuZDsgb2Zmc2V0ICs9IHN0cmlkZSkge1xuICAgIHZhciB4MiA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXRdO1xuICAgIHZhciB5MiA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXTtcbiAgICB0d2ljZUFyZWEgKz0geTEgKiB4MiAtIHgxICogeTI7XG4gICAgeDEgPSB4MjtcbiAgICB5MSA9IHkyO1xuICB9XG4gIHJldHVybiB0d2ljZUFyZWEgLyAyO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbmRzIEVuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEByZXR1cm4ge251bWJlcn0gQXJlYS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhclJpbmdzKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLCBzdHJpZGUpIHtcbiAgdmFyIGFyZWEgPSAwO1xuICBmb3IgKHZhciBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICB2YXIgZW5kID0gZW5kc1tpXTtcbiAgICBhcmVhICs9IGxpbmVhclJpbmcoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKTtcbiAgICBvZmZzZXQgPSBlbmQ7XG4gIH1cbiAgcmV0dXJuIGFyZWE7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBlbmRzcyBFbmRzcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHJldHVybiB7bnVtYmVyfSBBcmVhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyUmluZ3NzKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzcywgc3RyaWRlKSB7XG4gIHZhciBhcmVhID0gMDtcbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gZW5kc3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIHZhciBlbmRzID0gZW5kc3NbaV07XG4gICAgYXJlYSArPSBsaW5lYXJSaW5ncyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlKTtcbiAgICBvZmZzZXQgPSBlbmRzW2VuZHMubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIGFyZWE7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFyZWEuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9jZW50ZXJcbiAqL1xuaW1wb3J0IHtjcmVhdGVFbXB0eSwgY3JlYXRlT3JVcGRhdGVGcm9tRmxhdENvb3JkaW5hdGVzfSBmcm9tICcuLi8uLi9leHRlbnQuanMnO1xuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gZW5kc3MgRW5kc3MuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEZsYXQgY2VudGVycy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhclJpbmdzcyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kc3MsIHN0cmlkZSkge1xuICB2YXIgZmxhdENlbnRlcnMgPSBbXTtcbiAgdmFyIGV4dGVudCA9IGNyZWF0ZUVtcHR5KCk7XG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IGVuZHNzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICB2YXIgZW5kcyA9IGVuZHNzW2ldO1xuICAgIGV4dGVudCA9IGNyZWF0ZU9yVXBkYXRlRnJvbUZsYXRDb29yZGluYXRlcyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kc1swXSwgc3RyaWRlKTtcbiAgICBmbGF0Q2VudGVycy5wdXNoKChleHRlbnRbMF0gKyBleHRlbnRbMl0pIC8gMiwgKGV4dGVudFsxXSArIGV4dGVudFszXSkgLyAyKTtcbiAgICBvZmZzZXQgPSBlbmRzW2VuZHMubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIGZsYXRDZW50ZXJzO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jZW50ZXIuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9jbG9zZXN0XG4gKi9cbmltcG9ydCB7bGVycCwgc3F1YXJlZERpc3RhbmNlIGFzIHNxdWFyZWREeH0gZnJvbSAnLi4vLi4vbWF0aC5qcyc7XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwb2ludCBvbiB0aGUgMkQgbGluZSBzZWdtZW50IGZsYXRDb29yZGluYXRlc1tvZmZzZXQxXSB0b1xuICogZmxhdENvb3JkaW5hdGVzW29mZnNldDJdIHRoYXQgaXMgY2xvc2VzdCB0byB0aGUgcG9pbnQgKHgsIHkpLiAgRXh0cmFcbiAqIGRpbWVuc2lvbnMgYXJlIGxpbmVhcmx5IGludGVycG9sYXRlZC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0MSBPZmZzZXQgMS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQyIE9mZnNldCAyLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY2xvc2VzdFBvaW50IENsb3Nlc3QgcG9pbnQuXG4gKi9cbmZ1bmN0aW9uIGFzc2lnbkNsb3Nlc3QoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQxLCBvZmZzZXQyLCBzdHJpZGUsIHgsIHksIGNsb3Nlc3RQb2ludCkge1xuICB2YXIgeDEgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0MV07XG4gIHZhciB5MSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQxICsgMV07XG4gIHZhciBkeCA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQyXSAtIHgxO1xuICB2YXIgZHkgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0MiArIDFdIC0geTE7XG4gIHZhciBvZmZzZXQ7XG4gIGlmIChkeCA9PT0gMCAmJiBkeSA9PT0gMCkge1xuICAgIG9mZnNldCA9IG9mZnNldDE7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHQgPSAoKHggLSB4MSkgKiBkeCArICh5IC0geTEpICogZHkpIC8gKGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICBpZiAodCA+IDEpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldDI7XG4gICAgfSBlbHNlIGlmICh0ID4gMCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpZGU7ICsraSkge1xuICAgICAgICBjbG9zZXN0UG9pbnRbaV0gPSBsZXJwKGZsYXRDb29yZGluYXRlc1tvZmZzZXQxICsgaV0sXG4gICAgICAgICAgZmxhdENvb3JkaW5hdGVzW29mZnNldDIgKyBpXSwgdCk7XG4gICAgICB9XG4gICAgICBjbG9zZXN0UG9pbnQubGVuZ3RoID0gc3RyaWRlO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQxO1xuICAgIH1cbiAgfVxuICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBzdHJpZGU7ICsraSQxKSB7XG4gICAgY2xvc2VzdFBvaW50W2kkMV0gPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgaSQxXTtcbiAgfVxuICBjbG9zZXN0UG9pbnQubGVuZ3RoID0gc3RyaWRlO1xufVxuXG5cbi8qKlxuICogUmV0dXJuIHRoZSBzcXVhcmVkIG9mIHRoZSBsYXJnZXN0IGRpc3RhbmNlIGJldHdlZW4gYW55IHBhaXIgb2YgY29uc2VjdXRpdmVcbiAqIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggTWF4IHNxdWFyZWQgZGVsdGEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE1heCBzcXVhcmVkIGRlbHRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF4U3F1YXJlZERlbHRhKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgbWF4KSB7XG4gIHZhciB4MSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXRdO1xuICB2YXIgeTEgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gIGZvciAob2Zmc2V0ICs9IHN0cmlkZTsgb2Zmc2V0IDwgZW5kOyBvZmZzZXQgKz0gc3RyaWRlKSB7XG4gICAgdmFyIHgyID0gZmxhdENvb3JkaW5hdGVzW29mZnNldF07XG4gICAgdmFyIHkyID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdO1xuICAgIHZhciBzcXVhcmVkRGVsdGEgPSBzcXVhcmVkRHgoeDEsIHkxLCB4MiwgeTIpO1xuICAgIGlmIChzcXVhcmVkRGVsdGEgPiBtYXgpIHtcbiAgICAgIG1heCA9IHNxdWFyZWREZWx0YTtcbiAgICB9XG4gICAgeDEgPSB4MjtcbiAgICB5MSA9IHkyO1xuICB9XG4gIHJldHVybiBtYXg7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGVuZHMgRW5kcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heCBNYXggc3F1YXJlZCBkZWx0YS5cbiAqIEByZXR1cm4ge251bWJlcn0gTWF4IHNxdWFyZWQgZGVsdGEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcnJheU1heFNxdWFyZWREZWx0YShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlLCBtYXgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgdmFyIGVuZCA9IGVuZHNbaV07XG4gICAgbWF4ID0gbWF4U3F1YXJlZERlbHRhKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCBtYXgpO1xuICAgIG9mZnNldCA9IGVuZDtcbiAgfVxuICByZXR1cm4gbWF4O1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gZW5kc3MgRW5kc3MuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggTWF4IHNxdWFyZWQgZGVsdGEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE1heCBzcXVhcmVkIGRlbHRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlBcnJheU1heFNxdWFyZWREZWx0YShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kc3MsIHN0cmlkZSwgbWF4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IGVuZHNzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICB2YXIgZW5kcyA9IGVuZHNzW2ldO1xuICAgIG1heCA9IGFycmF5TWF4U3F1YXJlZERlbHRhKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHMsIHN0cmlkZSwgbWF4KTtcbiAgICBvZmZzZXQgPSBlbmRzW2VuZHMubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIG1heDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4RGVsdGEgTWF4IGRlbHRhLlxuICogQHBhcmFtIHtib29sZWFufSBpc1JpbmcgSXMgcmluZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjbG9zZXN0UG9pbnQgQ2xvc2VzdCBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5TcXVhcmVkRGlzdGFuY2UgTWluaW11bSBzcXVhcmVkIGRpc3RhbmNlLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+PX0gb3B0X3RtcFBvaW50IFRlbXBvcmFyeSBwb2ludCBvYmplY3QuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE1pbmltdW0gc3F1YXJlZCBkaXN0YW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbkNsb3Nlc3RQb2ludChmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLFxuICBzdHJpZGUsIG1heERlbHRhLCBpc1JpbmcsIHgsIHksIGNsb3Nlc3RQb2ludCwgbWluU3F1YXJlZERpc3RhbmNlLFxuICBvcHRfdG1wUG9pbnQpIHtcbiAgaWYgKG9mZnNldCA9PSBlbmQpIHtcbiAgICByZXR1cm4gbWluU3F1YXJlZERpc3RhbmNlO1xuICB9XG4gIHZhciBpLCBzcXVhcmVkRGlzdGFuY2U7XG4gIGlmIChtYXhEZWx0YSA9PT0gMCkge1xuICAgIC8vIEFsbCBwb2ludHMgYXJlIGlkZW50aWNhbCwgc28ganVzdCB0ZXN0IHRoZSBmaXJzdCBwb2ludC5cbiAgICBzcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkRHgoXG4gICAgICB4LCB5LCBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XSwgZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdKTtcbiAgICBpZiAoc3F1YXJlZERpc3RhbmNlIDwgbWluU3F1YXJlZERpc3RhbmNlKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc3RyaWRlOyArK2kpIHtcbiAgICAgICAgY2xvc2VzdFBvaW50W2ldID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIGldO1xuICAgICAgfVxuICAgICAgY2xvc2VzdFBvaW50Lmxlbmd0aCA9IHN0cmlkZTtcbiAgICAgIHJldHVybiBzcXVhcmVkRGlzdGFuY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtaW5TcXVhcmVkRGlzdGFuY2U7XG4gICAgfVxuICB9XG4gIHZhciB0bXBQb2ludCA9IG9wdF90bXBQb2ludCA/IG9wdF90bXBQb2ludCA6IFtOYU4sIE5hTl07XG4gIHZhciBpbmRleCA9IG9mZnNldCArIHN0cmlkZTtcbiAgd2hpbGUgKGluZGV4IDwgZW5kKSB7XG4gICAgYXNzaWduQ2xvc2VzdChcbiAgICAgIGZsYXRDb29yZGluYXRlcywgaW5kZXggLSBzdHJpZGUsIGluZGV4LCBzdHJpZGUsIHgsIHksIHRtcFBvaW50KTtcbiAgICBzcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkRHgoeCwgeSwgdG1wUG9pbnRbMF0sIHRtcFBvaW50WzFdKTtcbiAgICBpZiAoc3F1YXJlZERpc3RhbmNlIDwgbWluU3F1YXJlZERpc3RhbmNlKSB7XG4gICAgICBtaW5TcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkRGlzdGFuY2U7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc3RyaWRlOyArK2kpIHtcbiAgICAgICAgY2xvc2VzdFBvaW50W2ldID0gdG1wUG9pbnRbaV07XG4gICAgICB9XG4gICAgICBjbG9zZXN0UG9pbnQubGVuZ3RoID0gc3RyaWRlO1xuICAgICAgaW5kZXggKz0gc3RyaWRlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTa2lwIGFoZWFkIG11bHRpcGxlIHBvaW50cywgYmVjYXVzZSB3ZSBrbm93IHRoYXQgYWxsIHRoZSBza2lwcGVkXG4gICAgICAvLyBwb2ludHMgY2Fubm90IGJlIGFueSBjbG9zZXIgdGhhbiB0aGUgY2xvc2VzdCBwb2ludCB3ZSBoYXZlIGZvdW5kIHNvXG4gICAgICAvLyBmYXIuICBXZSBrbm93IHRoaXMgYmVjYXVzZSB3ZSBrbm93IGhvdyBjbG9zZSB0aGUgY3VycmVudCBwb2ludCBpcywgaG93XG4gICAgICAvLyBjbG9zZSB0aGUgY2xvc2VzdCBwb2ludCB3ZSBoYXZlIGZvdW5kIHNvIGZhciBpcywgYW5kIHRoZSBtYXhpbXVtXG4gICAgICAvLyBkaXN0YW5jZSBiZXR3ZWVuIGNvbnNlY3V0aXZlIHBvaW50cy4gIEZvciBleGFtcGxlLCBpZiB3ZSdyZSBjdXJyZW50bHlcbiAgICAgIC8vIGF0IGRpc3RhbmNlIDEwLCB0aGUgYmVzdCB3ZSd2ZSBmb3VuZCBzbyBmYXIgaXMgMywgYW5kIHRoYXQgdGhlIG1heGltdW1cbiAgICAgIC8vIGRpc3RhbmNlIGJldHdlZW4gY29uc2VjdXRpdmUgcG9pbnRzIGlzIDIsIHRoZW4gd2UnbGwgbmVlZCB0byBza2lwIGF0XG4gICAgICAvLyBsZWFzdCAoMTAgLSAzKSAvIDIgPT0gMyAocm91bmRlZCBkb3duKSBwb2ludHMgdG8gaGF2ZSBhbnkgY2hhbmNlIG9mXG4gICAgICAvLyBmaW5kaW5nIGEgY2xvc2VyIHBvaW50LiAgV2UgdXNlIE1hdGgubWF4KC4uLiwgMSkgdG8gZW5zdXJlIHRoYXQgd2VcbiAgICAgIC8vIGFsd2F5cyBhZHZhbmNlIGF0IGxlYXN0IG9uZSBwb2ludCwgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcC5cbiAgICAgIGluZGV4ICs9IHN0cmlkZSAqIE1hdGgubWF4KFxuICAgICAgICAoKE1hdGguc3FydChzcXVhcmVkRGlzdGFuY2UpIC1cbiAgICAgICAgICAgIE1hdGguc3FydChtaW5TcXVhcmVkRGlzdGFuY2UpKSAvIG1heERlbHRhKSB8IDAsIDEpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNSaW5nKSB7XG4gICAgLy8gQ2hlY2sgdGhlIGNsb3Npbmcgc2VnbWVudC5cbiAgICBhc3NpZ25DbG9zZXN0KFxuICAgICAgZmxhdENvb3JkaW5hdGVzLCBlbmQgLSBzdHJpZGUsIG9mZnNldCwgc3RyaWRlLCB4LCB5LCB0bXBQb2ludCk7XG4gICAgc3F1YXJlZERpc3RhbmNlID0gc3F1YXJlZER4KHgsIHksIHRtcFBvaW50WzBdLCB0bXBQb2ludFsxXSk7XG4gICAgaWYgKHNxdWFyZWREaXN0YW5jZSA8IG1pblNxdWFyZWREaXN0YW5jZSkge1xuICAgICAgbWluU3F1YXJlZERpc3RhbmNlID0gc3F1YXJlZERpc3RhbmNlO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHN0cmlkZTsgKytpKSB7XG4gICAgICAgIGNsb3Nlc3RQb2ludFtpXSA9IHRtcFBvaW50W2ldO1xuICAgICAgfVxuICAgICAgY2xvc2VzdFBvaW50Lmxlbmd0aCA9IHN0cmlkZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1pblNxdWFyZWREaXN0YW5jZTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW5kcyBFbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4RGVsdGEgTWF4IGRlbHRhLlxuICogQHBhcmFtIHtib29sZWFufSBpc1JpbmcgSXMgcmluZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjbG9zZXN0UG9pbnQgQ2xvc2VzdCBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5TcXVhcmVkRGlzdGFuY2UgTWluaW11bSBzcXVhcmVkIGRpc3RhbmNlLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+PX0gb3B0X3RtcFBvaW50IFRlbXBvcmFyeSBwb2ludCBvYmplY3QuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE1pbmltdW0gc3F1YXJlZCBkaXN0YW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbkNsb3Nlc3RBcnJheVBvaW50KGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLFxuICBzdHJpZGUsIG1heERlbHRhLCBpc1JpbmcsIHgsIHksIGNsb3Nlc3RQb2ludCwgbWluU3F1YXJlZERpc3RhbmNlLFxuICBvcHRfdG1wUG9pbnQpIHtcbiAgdmFyIHRtcFBvaW50ID0gb3B0X3RtcFBvaW50ID8gb3B0X3RtcFBvaW50IDogW05hTiwgTmFOXTtcbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgdmFyIGVuZCA9IGVuZHNbaV07XG4gICAgbWluU3F1YXJlZERpc3RhbmNlID0gYXNzaWduQ2xvc2VzdFBvaW50KFxuICAgICAgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLFxuICAgICAgbWF4RGVsdGEsIGlzUmluZywgeCwgeSwgY2xvc2VzdFBvaW50LCBtaW5TcXVhcmVkRGlzdGFuY2UsIHRtcFBvaW50KTtcbiAgICBvZmZzZXQgPSBlbmQ7XG4gIH1cbiAgcmV0dXJuIG1pblNxdWFyZWREaXN0YW5jZTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGVuZHNzIEVuZHNzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4RGVsdGEgTWF4IGRlbHRhLlxuICogQHBhcmFtIHtib29sZWFufSBpc1JpbmcgSXMgcmluZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjbG9zZXN0UG9pbnQgQ2xvc2VzdCBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5TcXVhcmVkRGlzdGFuY2UgTWluaW11bSBzcXVhcmVkIGRpc3RhbmNlLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+PX0gb3B0X3RtcFBvaW50IFRlbXBvcmFyeSBwb2ludCBvYmplY3QuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE1pbmltdW0gc3F1YXJlZCBkaXN0YW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbkNsb3Nlc3RNdWx0aUFycmF5UG9pbnQoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsXG4gIGVuZHNzLCBzdHJpZGUsIG1heERlbHRhLCBpc1JpbmcsIHgsIHksIGNsb3Nlc3RQb2ludCwgbWluU3F1YXJlZERpc3RhbmNlLFxuICBvcHRfdG1wUG9pbnQpIHtcbiAgdmFyIHRtcFBvaW50ID0gb3B0X3RtcFBvaW50ID8gb3B0X3RtcFBvaW50IDogW05hTiwgTmFOXTtcbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gZW5kc3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIHZhciBlbmRzID0gZW5kc3NbaV07XG4gICAgbWluU3F1YXJlZERpc3RhbmNlID0gYXNzaWduQ2xvc2VzdEFycmF5UG9pbnQoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlLFxuICAgICAgbWF4RGVsdGEsIGlzUmluZywgeCwgeSwgY2xvc2VzdFBvaW50LCBtaW5TcXVhcmVkRGlzdGFuY2UsIHRtcFBvaW50KTtcbiAgICBvZmZzZXQgPSBlbmRzW2VuZHMubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIG1pblNxdWFyZWREaXN0YW5jZTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xvc2VzdC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9mbGF0L2NvbnRhaW5zXG4gKi9cbmltcG9ydCB7Zm9yRWFjaENvcm5lcn0gZnJvbSAnLi4vLi4vZXh0ZW50LmpzJztcblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBDb250YWlucyBleHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJSaW5nQ29udGFpbnNFeHRlbnQoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCBleHRlbnQpIHtcbiAgdmFyIG91dHNpZGUgPSBmb3JFYWNoQ29ybmVyKGV4dGVudCxcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IENvbnRhaW5zICh4LCB5KS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbihjb29yZGluYXRlKSB7XG4gICAgICByZXR1cm4gIWxpbmVhclJpbmdDb250YWluc1hZKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgY29vcmRpbmF0ZVswXSwgY29vcmRpbmF0ZVsxXSk7XG4gICAgfSk7XG4gIHJldHVybiAhb3V0c2lkZTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IENvbnRhaW5zICh4LCB5KS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhclJpbmdDb250YWluc1hZKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgeCwgeSkge1xuICAvLyBodHRwOi8vZ2VvbWFsZ29yaXRobXMuY29tL2EwMy1faW5jbHVzaW9uLmh0bWxcbiAgLy8gQ29weXJpZ2h0IDIwMDAgc29mdFN1cmZlciwgMjAxMiBEYW4gU3VuZGF5XG4gIC8vIFRoaXMgY29kZSBtYXkgYmUgZnJlZWx5IHVzZWQgYW5kIG1vZGlmaWVkIGZvciBhbnkgcHVycG9zZVxuICAvLyBwcm92aWRpbmcgdGhhdCB0aGlzIGNvcHlyaWdodCBub3RpY2UgaXMgaW5jbHVkZWQgd2l0aCBpdC5cbiAgLy8gU29mdFN1cmZlciBtYWtlcyBubyB3YXJyYW50eSBmb3IgdGhpcyBjb2RlLCBhbmQgY2Fubm90IGJlIGhlbGRcbiAgLy8gbGlhYmxlIGZvciBhbnkgcmVhbCBvciBpbWFnaW5lZCBkYW1hZ2UgcmVzdWx0aW5nIGZyb20gaXRzIHVzZS5cbiAgLy8gVXNlcnMgb2YgdGhpcyBjb2RlIG11c3QgdmVyaWZ5IGNvcnJlY3RuZXNzIGZvciB0aGVpciBhcHBsaWNhdGlvbi5cbiAgdmFyIHduID0gMDtcbiAgdmFyIHgxID0gZmxhdENvb3JkaW5hdGVzW2VuZCAtIHN0cmlkZV07XG4gIHZhciB5MSA9IGZsYXRDb29yZGluYXRlc1tlbmQgLSBzdHJpZGUgKyAxXTtcbiAgZm9yICg7IG9mZnNldCA8IGVuZDsgb2Zmc2V0ICs9IHN0cmlkZSkge1xuICAgIHZhciB4MiA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXRdO1xuICAgIHZhciB5MiA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXTtcbiAgICBpZiAoeTEgPD0geSkge1xuICAgICAgaWYgKHkyID4geSAmJiAoKHgyIC0geDEpICogKHkgLSB5MSkpIC0gKCh4IC0geDEpICogKHkyIC0geTEpKSA+IDApIHtcbiAgICAgICAgd24rKztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHkyIDw9IHkgJiYgKCh4MiAtIHgxKSAqICh5IC0geTEpKSAtICgoeCAtIHgxKSAqICh5MiAtIHkxKSkgPCAwKSB7XG4gICAgICB3bi0tO1xuICAgIH1cbiAgICB4MSA9IHgyO1xuICAgIHkxID0geTI7XG4gIH1cbiAgcmV0dXJuIHduICE9PSAwO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbmRzIEVuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICogQHJldHVybiB7Ym9vbGVhbn0gQ29udGFpbnMgKHgsIHkpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyUmluZ3NDb250YWluc1hZKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLCBzdHJpZGUsIHgsIHkpIHtcbiAgaWYgKGVuZHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghbGluZWFyUmluZ0NvbnRhaW5zWFkoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHNbMF0sIHN0cmlkZSwgeCwgeSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDEsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgaWYgKGxpbmVhclJpbmdDb250YWluc1hZKGZsYXRDb29yZGluYXRlcywgZW5kc1tpIC0gMV0sIGVuZHNbaV0sIHN0cmlkZSwgeCwgeSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBlbmRzcyBFbmRzcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKiBAcmV0dXJuIHtib29sZWFufSBDb250YWlucyAoeCwgeSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJSaW5nc3NDb250YWluc1hZKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzcywgc3RyaWRlLCB4LCB5KSB7XG4gIGlmIChlbmRzcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gZW5kc3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIHZhciBlbmRzID0gZW5kc3NbaV07XG4gICAgaWYgKGxpbmVhclJpbmdzQ29udGFpbnNYWShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlLCB4LCB5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIG9mZnNldCA9IGVuZHNbZW5kcy5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnRhaW5zLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL2ZsYXQvZGVmbGF0ZVxuICovXG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZsYXRlQ29vcmRpbmF0ZShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgY29vcmRpbmF0ZSwgc3RyaWRlKSB7XG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IGNvb3JkaW5hdGUubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGZsYXRDb29yZGluYXRlc1tvZmZzZXQrK10gPSBjb29yZGluYXRlW2ldO1xuICB9XG4gIHJldHVybiBvZmZzZXQ7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59IGNvb3JkaW5hdGVzIENvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZsYXRlQ29vcmRpbmF0ZXMoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGNvb3JkaW5hdGVzLCBzdHJpZGUpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIHZhciBjb29yZGluYXRlID0gY29vcmRpbmF0ZXNbaV07XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdHJpZGU7ICsraikge1xuICAgICAgZmxhdENvb3JkaW5hdGVzW29mZnNldCsrXSA9IGNvb3JkaW5hdGVbal07XG4gICAgfVxuICB9XG4gIHJldHVybiBvZmZzZXQ7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PGltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+fSBjb29yZGluYXRlc3MgQ29vcmRpbmF0ZXNzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj49fSBvcHRfZW5kcyBFbmRzLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gRW5kcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmxhdGVDb29yZGluYXRlc0FycmF5KGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBjb29yZGluYXRlc3MsIHN0cmlkZSwgb3B0X2VuZHMpIHtcbiAgdmFyIGVuZHMgPSBvcHRfZW5kcyA/IG9wdF9lbmRzIDogW107XG4gIHZhciBpID0gMDtcbiAgZm9yICh2YXIgaiA9IDAsIGpqID0gY29vcmRpbmF0ZXNzLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICB2YXIgZW5kID0gZGVmbGF0ZUNvb3JkaW5hdGVzKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGNvb3JkaW5hdGVzc1tqXSwgc3RyaWRlKTtcbiAgICBlbmRzW2krK10gPSBlbmQ7XG4gICAgb2Zmc2V0ID0gZW5kO1xuICB9XG4gIGVuZHMubGVuZ3RoID0gaTtcbiAgcmV0dXJuIGVuZHM7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PEFycmF5PGltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+Pn0gY29vcmRpbmF0ZXNzcyBDb29yZGluYXRlc3NzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+PX0gb3B0X2VuZHNzIEVuZHNzLlxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IEVuZHNzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVmbGF0ZU11bHRpQ29vcmRpbmF0ZXNBcnJheShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgY29vcmRpbmF0ZXNzcywgc3RyaWRlLCBvcHRfZW5kc3MpIHtcbiAgdmFyIGVuZHNzID0gb3B0X2VuZHNzID8gb3B0X2VuZHNzIDogW107XG4gIHZhciBpID0gMDtcbiAgZm9yICh2YXIgaiA9IDAsIGpqID0gY29vcmRpbmF0ZXNzcy5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgdmFyIGVuZHMgPSBkZWZsYXRlQ29vcmRpbmF0ZXNBcnJheShcbiAgICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBjb29yZGluYXRlc3NzW2pdLCBzdHJpZGUsIGVuZHNzW2ldKTtcbiAgICBlbmRzc1tpKytdID0gZW5kcztcbiAgICBvZmZzZXQgPSBlbmRzW2VuZHMubGVuZ3RoIC0gMV07XG4gIH1cbiAgZW5kc3MubGVuZ3RoID0gaTtcbiAgcmV0dXJuIGVuZHNzO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZsYXRlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL2ZsYXQvaW5mbGF0ZVxuICovXG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+PX0gb3B0X2Nvb3JkaW5hdGVzIENvb3JkaW5hdGVzLlxuICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn0gQ29vcmRpbmF0ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmZsYXRlQ29vcmRpbmF0ZXMoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCBvcHRfY29vcmRpbmF0ZXMpIHtcbiAgdmFyIGNvb3JkaW5hdGVzID0gb3B0X2Nvb3JkaW5hdGVzICE9PSB1bmRlZmluZWQgPyBvcHRfY29vcmRpbmF0ZXMgOiBbXTtcbiAgdmFyIGkgPSAwO1xuICBmb3IgKHZhciBqID0gb2Zmc2V0OyBqIDwgZW5kOyBqICs9IHN0cmlkZSkge1xuICAgIGNvb3JkaW5hdGVzW2krK10gPSBmbGF0Q29vcmRpbmF0ZXMuc2xpY2UoaiwgaiArIHN0cmlkZSk7XG4gIH1cbiAgY29vcmRpbmF0ZXMubGVuZ3RoID0gaTtcbiAgcmV0dXJuIGNvb3JkaW5hdGVzO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbmRzIEVuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj49fSBvcHRfY29vcmRpbmF0ZXNzIENvb3JkaW5hdGVzcy5cbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PGltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+fSBDb29yZGluYXRlc3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmZsYXRlQ29vcmRpbmF0ZXNBcnJheShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlLCBvcHRfY29vcmRpbmF0ZXNzKSB7XG4gIHZhciBjb29yZGluYXRlc3MgPSBvcHRfY29vcmRpbmF0ZXNzICE9PSB1bmRlZmluZWQgPyBvcHRfY29vcmRpbmF0ZXNzIDogW107XG4gIHZhciBpID0gMDtcbiAgZm9yICh2YXIgaiA9IDAsIGpqID0gZW5kcy5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgdmFyIGVuZCA9IGVuZHNbal07XG4gICAgY29vcmRpbmF0ZXNzW2krK10gPSBpbmZsYXRlQ29vcmRpbmF0ZXMoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIGNvb3JkaW5hdGVzc1tpXSk7XG4gICAgb2Zmc2V0ID0gZW5kO1xuICB9XG4gIGNvb3JkaW5hdGVzcy5sZW5ndGggPSBpO1xuICByZXR1cm4gY29vcmRpbmF0ZXNzO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gZW5kc3MgRW5kc3MuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8QXJyYXk8aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj4+PX0gb3B0X2Nvb3JkaW5hdGVzc3NcbiAqICAgICBDb29yZGluYXRlc3NzLlxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8QXJyYXk8aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj4+fSBDb29yZGluYXRlc3NzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5mbGF0ZU11bHRpQ29vcmRpbmF0ZXNBcnJheShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kc3MsIHN0cmlkZSwgb3B0X2Nvb3JkaW5hdGVzc3MpIHtcbiAgdmFyIGNvb3JkaW5hdGVzc3MgPSBvcHRfY29vcmRpbmF0ZXNzcyAhPT0gdW5kZWZpbmVkID8gb3B0X2Nvb3JkaW5hdGVzc3MgOiBbXTtcbiAgdmFyIGkgPSAwO1xuICBmb3IgKHZhciBqID0gMCwgamogPSBlbmRzcy5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgdmFyIGVuZHMgPSBlbmRzc1tqXTtcbiAgICBjb29yZGluYXRlc3NzW2krK10gPSBpbmZsYXRlQ29vcmRpbmF0ZXNBcnJheShcbiAgICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLCBzdHJpZGUsIGNvb3JkaW5hdGVzc3NbaV0pO1xuICAgIG9mZnNldCA9IGVuZHNbZW5kcy5sZW5ndGggLSAxXTtcbiAgfVxuICBjb29yZGluYXRlc3NzLmxlbmd0aCA9IGk7XG4gIHJldHVybiBjb29yZGluYXRlc3NzO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmZsYXRlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL2ZsYXQvaW50ZXJpb3Jwb2ludFxuICovXG5pbXBvcnQge251bWJlclNhZmVDb21wYXJlRnVuY3Rpb259IGZyb20gJy4uLy4uL2FycmF5LmpzJztcbmltcG9ydCB7bGluZWFyUmluZ3NDb250YWluc1hZfSBmcm9tICcuL2NvbnRhaW5zLmpzJztcblxuXG4vKipcbiAqIENhbGN1bGF0ZXMgYSBwb2ludCB0aGF0IGlzIGxpa2VseSB0byBsaWUgaW4gdGhlIGludGVyaW9yIG9mIHRoZSBsaW5lYXIgcmluZ3MuXG4gKiBJbnNwaXJlZCBieSBKVFMncyBjb20udml2aWRzb2x1dGlvbnMuanRzLmdlb20uR2VvbWV0cnkjZ2V0SW50ZXJpb3JQb2ludC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW5kcyBFbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDZW50ZXJzIEZsYXQgY2VudGVycy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGF0Q2VudGVyc09mZnNldCBGbGF0IGNlbnRlciBvZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj49fSBvcHRfZGVzdCBEZXN0aW5hdGlvbi5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IERlc3RpbmF0aW9uIHBvaW50IGFzIFhZTSBjb29yZGluYXRlLCB3aGVyZSBNIGlzIHRoZVxuICogbGVuZ3RoIG9mIHRoZSBob3Jpem9udGFsIGludGVyc2VjdGlvbiB0aGF0IHRoZSBwb2ludCBiZWxvbmdzIHRvLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW50ZXJpb3JQb2ludE9mQXJyYXkoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsXG4gIGVuZHMsIHN0cmlkZSwgZmxhdENlbnRlcnMsIGZsYXRDZW50ZXJzT2Zmc2V0LCBvcHRfZGVzdCkge1xuICB2YXIgaSwgaWksIHgsIHgxLCB4MiwgeTEsIHkyO1xuICB2YXIgeSA9IGZsYXRDZW50ZXJzW2ZsYXRDZW50ZXJzT2Zmc2V0ICsgMV07XG4gIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi9cbiAgdmFyIGludGVyc2VjdGlvbnMgPSBbXTtcbiAgLy8gQ2FsY3VsYXRlIGludGVyc2VjdGlvbnMgd2l0aCB0aGUgaG9yaXpvbnRhbCBsaW5lXG4gIGZvciAodmFyIHIgPSAwLCByciA9IGVuZHMubGVuZ3RoOyByIDwgcnI7ICsrcikge1xuICAgIHZhciBlbmQgPSBlbmRzW3JdO1xuICAgIHgxID0gZmxhdENvb3JkaW5hdGVzW2VuZCAtIHN0cmlkZV07XG4gICAgeTEgPSBmbGF0Q29vcmRpbmF0ZXNbZW5kIC0gc3RyaWRlICsgMV07XG4gICAgZm9yIChpID0gb2Zmc2V0OyBpIDwgZW5kOyBpICs9IHN0cmlkZSkge1xuICAgICAgeDIgPSBmbGF0Q29vcmRpbmF0ZXNbaV07XG4gICAgICB5MiA9IGZsYXRDb29yZGluYXRlc1tpICsgMV07XG4gICAgICBpZiAoKHkgPD0geTEgJiYgeTIgPD0geSkgfHwgKHkxIDw9IHkgJiYgeSA8PSB5MikpIHtcbiAgICAgICAgeCA9ICh5IC0geTEpIC8gKHkyIC0geTEpICogKHgyIC0geDEpICsgeDE7XG4gICAgICAgIGludGVyc2VjdGlvbnMucHVzaCh4KTtcbiAgICAgIH1cbiAgICAgIHgxID0geDI7XG4gICAgICB5MSA9IHkyO1xuICAgIH1cbiAgfVxuICAvLyBGaW5kIHRoZSBsb25nZXN0IHNlZ21lbnQgb2YgdGhlIGhvcml6b250YWwgbGluZSB0aGF0IGhhcyBpdHMgY2VudGVyIHBvaW50XG4gIC8vIGluc2lkZSB0aGUgbGluZWFyIHJpbmcuXG4gIHZhciBwb2ludFggPSBOYU47XG4gIHZhciBtYXhTZWdtZW50TGVuZ3RoID0gLUluZmluaXR5O1xuICBpbnRlcnNlY3Rpb25zLnNvcnQobnVtYmVyU2FmZUNvbXBhcmVGdW5jdGlvbik7XG4gIHgxID0gaW50ZXJzZWN0aW9uc1swXTtcbiAgZm9yIChpID0gMSwgaWkgPSBpbnRlcnNlY3Rpb25zLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICB4MiA9IGludGVyc2VjdGlvbnNbaV07XG4gICAgdmFyIHNlZ21lbnRMZW5ndGggPSBNYXRoLmFicyh4MiAtIHgxKTtcbiAgICBpZiAoc2VnbWVudExlbmd0aCA+IG1heFNlZ21lbnRMZW5ndGgpIHtcbiAgICAgIHggPSAoeDEgKyB4MikgLyAyO1xuICAgICAgaWYgKGxpbmVhclJpbmdzQ29udGFpbnNYWShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlLCB4LCB5KSkge1xuICAgICAgICBwb2ludFggPSB4O1xuICAgICAgICBtYXhTZWdtZW50TGVuZ3RoID0gc2VnbWVudExlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgeDEgPSB4MjtcbiAgfVxuICBpZiAoaXNOYU4ocG9pbnRYKSkge1xuICAgIC8vIFRoZXJlIGlzIG5vIGhvcml6b250YWwgbGluZSB0aGF0IGhhcyBpdHMgY2VudGVyIHBvaW50IGluc2lkZSB0aGUgbGluZWFyXG4gICAgLy8gcmluZy4gIFVzZSB0aGUgY2VudGVyIG9mIHRoZSB0aGUgbGluZWFyIHJpbmcncyBleHRlbnQuXG4gICAgcG9pbnRYID0gZmxhdENlbnRlcnNbZmxhdENlbnRlcnNPZmZzZXRdO1xuICB9XG4gIGlmIChvcHRfZGVzdCkge1xuICAgIG9wdF9kZXN0LnB1c2gocG9pbnRYLCB5LCBtYXhTZWdtZW50TGVuZ3RoKTtcbiAgICByZXR1cm4gb3B0X2Rlc3Q7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtwb2ludFgsIHksIG1heFNlZ21lbnRMZW5ndGhdO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBlbmRzcyBFbmRzcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q2VudGVycyBGbGF0IGNlbnRlcnMuXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBJbnRlcmlvciBwb2ludHMgYXMgWFlNIGNvb3JkaW5hdGVzLCB3aGVyZSBNIGlzIHRoZVxuICogbGVuZ3RoIG9mIHRoZSBob3Jpem9udGFsIGludGVyc2VjdGlvbiB0aGF0IHRoZSBwb2ludCBiZWxvbmdzIHRvLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW50ZXJpb3JQb2ludHNPZk11bHRpQXJyYXkoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHNzLCBzdHJpZGUsIGZsYXRDZW50ZXJzKSB7XG4gIHZhciBpbnRlcmlvclBvaW50cyA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgdmFyIGVuZHMgPSBlbmRzc1tpXTtcbiAgICBpbnRlcmlvclBvaW50cyA9IGdldEludGVyaW9yUG9pbnRPZkFycmF5KGZsYXRDb29yZGluYXRlcyxcbiAgICAgIG9mZnNldCwgZW5kcywgc3RyaWRlLCBmbGF0Q2VudGVycywgMiAqIGksIGludGVyaW9yUG9pbnRzKTtcbiAgICBvZmZzZXQgPSBlbmRzW2VuZHMubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIGludGVyaW9yUG9pbnRzO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcmlvcnBvaW50LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL2ZsYXQvaW50ZXJwb2xhdGVcbiAqL1xuaW1wb3J0IHtiaW5hcnlTZWFyY2h9IGZyb20gJy4uLy4uL2FycmF5LmpzJztcbmltcG9ydCB7bGVycH0gZnJvbSAnLi4vLi4vbWF0aC5qcyc7XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyYWN0aW9uIEZyYWN0aW9uLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+PX0gb3B0X2Rlc3QgRGVzdGluYXRpb24uXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBEZXN0aW5hdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVycG9sYXRlUG9pbnQoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCBmcmFjdGlvbiwgb3B0X2Rlc3QpIHtcbiAgdmFyIHBvaW50WCA9IE5hTjtcbiAgdmFyIHBvaW50WSA9IE5hTjtcbiAgdmFyIG4gPSAoZW5kIC0gb2Zmc2V0KSAvIHN0cmlkZTtcbiAgaWYgKG4gPT09IDEpIHtcbiAgICBwb2ludFggPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XTtcbiAgICBwb2ludFkgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gIH0gZWxzZSBpZiAobiA9PSAyKSB7XG4gICAgcG9pbnRYID0gKDEgLSBmcmFjdGlvbikgKiBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XSArXG4gICAgICAgIGZyYWN0aW9uICogZmxhdENvb3JkaW5hdGVzW29mZnNldCArIHN0cmlkZV07XG4gICAgcG9pbnRZID0gKDEgLSBmcmFjdGlvbikgKiBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV0gK1xuICAgICAgICBmcmFjdGlvbiAqIGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyBzdHJpZGUgKyAxXTtcbiAgfSBlbHNlIGlmIChuICE9PSAwKSB7XG4gICAgdmFyIHgxID0gZmxhdENvb3JkaW5hdGVzW29mZnNldF07XG4gICAgdmFyIHkxID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdO1xuICAgIHZhciBsZW5ndGggPSAwO1xuICAgIHZhciBjdW11bGF0aXZlTGVuZ3RocyA9IFswXTtcbiAgICBmb3IgKHZhciBpID0gb2Zmc2V0ICsgc3RyaWRlOyBpIDwgZW5kOyBpICs9IHN0cmlkZSkge1xuICAgICAgdmFyIHgyID0gZmxhdENvb3JkaW5hdGVzW2ldO1xuICAgICAgdmFyIHkyID0gZmxhdENvb3JkaW5hdGVzW2kgKyAxXTtcbiAgICAgIGxlbmd0aCArPSBNYXRoLnNxcnQoKHgyIC0geDEpICogKHgyIC0geDEpICsgKHkyIC0geTEpICogKHkyIC0geTEpKTtcbiAgICAgIGN1bXVsYXRpdmVMZW5ndGhzLnB1c2gobGVuZ3RoKTtcbiAgICAgIHgxID0geDI7XG4gICAgICB5MSA9IHkyO1xuICAgIH1cbiAgICB2YXIgdGFyZ2V0ID0gZnJhY3Rpb24gKiBsZW5ndGg7XG4gICAgdmFyIGluZGV4ID0gYmluYXJ5U2VhcmNoKGN1bXVsYXRpdmVMZW5ndGhzLCB0YXJnZXQpO1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHZhciB0ID0gKHRhcmdldCAtIGN1bXVsYXRpdmVMZW5ndGhzWy1pbmRleCAtIDJdKSAvXG4gICAgICAgICAgKGN1bXVsYXRpdmVMZW5ndGhzWy1pbmRleCAtIDFdIC0gY3VtdWxhdGl2ZUxlbmd0aHNbLWluZGV4IC0gMl0pO1xuICAgICAgdmFyIG8gPSBvZmZzZXQgKyAoLWluZGV4IC0gMikgKiBzdHJpZGU7XG4gICAgICBwb2ludFggPSBsZXJwKFxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXNbb10sIGZsYXRDb29yZGluYXRlc1tvICsgc3RyaWRlXSwgdCk7XG4gICAgICBwb2ludFkgPSBsZXJwKFxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXNbbyArIDFdLCBmbGF0Q29vcmRpbmF0ZXNbbyArIHN0cmlkZSArIDFdLCB0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnRYID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIGluZGV4ICogc3RyaWRlXTtcbiAgICAgIHBvaW50WSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyBpbmRleCAqIHN0cmlkZSArIDFdO1xuICAgIH1cbiAgfVxuICBpZiAob3B0X2Rlc3QpIHtcbiAgICBvcHRfZGVzdFswXSA9IHBvaW50WDtcbiAgICBvcHRfZGVzdFsxXSA9IHBvaW50WTtcbiAgICByZXR1cm4gb3B0X2Rlc3Q7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtwb2ludFgsIHBvaW50WV07XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gbSBNLlxuICogQHBhcmFtIHtib29sZWFufSBleHRyYXBvbGF0ZSBFeHRyYXBvbGF0ZS5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gQ29vcmRpbmF0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVTdHJpbmdDb29yZGluYXRlQXRNKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgbSwgZXh0cmFwb2xhdGUpIHtcbiAgaWYgKGVuZCA9PSBvZmZzZXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgY29vcmRpbmF0ZTtcbiAgaWYgKG0gPCBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgc3RyaWRlIC0gMV0pIHtcbiAgICBpZiAoZXh0cmFwb2xhdGUpIHtcbiAgICAgIGNvb3JkaW5hdGUgPSBmbGF0Q29vcmRpbmF0ZXMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBzdHJpZGUpO1xuICAgICAgY29vcmRpbmF0ZVtzdHJpZGUgLSAxXSA9IG07XG4gICAgICByZXR1cm4gY29vcmRpbmF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9IGVsc2UgaWYgKGZsYXRDb29yZGluYXRlc1tlbmQgLSAxXSA8IG0pIHtcbiAgICBpZiAoZXh0cmFwb2xhdGUpIHtcbiAgICAgIGNvb3JkaW5hdGUgPSBmbGF0Q29vcmRpbmF0ZXMuc2xpY2UoZW5kIC0gc3RyaWRlLCBlbmQpO1xuICAgICAgY29vcmRpbmF0ZVtzdHJpZGUgLSAxXSA9IG07XG4gICAgICByZXR1cm4gY29vcmRpbmF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIC8vIEZJWE1FIHVzZSBPKDEpIHNlYXJjaFxuICBpZiAobSA9PSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgc3RyaWRlIC0gMV0pIHtcbiAgICByZXR1cm4gZmxhdENvb3JkaW5hdGVzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgc3RyaWRlKTtcbiAgfVxuICB2YXIgbG8gPSBvZmZzZXQgLyBzdHJpZGU7XG4gIHZhciBoaSA9IGVuZCAvIHN0cmlkZTtcbiAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICB2YXIgbWlkID0gKGxvICsgaGkpID4+IDE7XG4gICAgaWYgKG0gPCBmbGF0Q29vcmRpbmF0ZXNbKG1pZCArIDEpICogc3RyaWRlIC0gMV0pIHtcbiAgICAgIGhpID0gbWlkO1xuICAgIH0gZWxzZSB7XG4gICAgICBsbyA9IG1pZCArIDE7XG4gICAgfVxuICB9XG4gIHZhciBtMCA9IGZsYXRDb29yZGluYXRlc1tsbyAqIHN0cmlkZSAtIDFdO1xuICBpZiAobSA9PSBtMCkge1xuICAgIHJldHVybiBmbGF0Q29vcmRpbmF0ZXMuc2xpY2UoKGxvIC0gMSkgKiBzdHJpZGUsIChsbyAtIDEpICogc3RyaWRlICsgc3RyaWRlKTtcbiAgfVxuICB2YXIgbTEgPSBmbGF0Q29vcmRpbmF0ZXNbKGxvICsgMSkgKiBzdHJpZGUgLSAxXTtcbiAgdmFyIHQgPSAobSAtIG0wKSAvIChtMSAtIG0wKTtcbiAgY29vcmRpbmF0ZSA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmlkZSAtIDE7ICsraSkge1xuICAgIGNvb3JkaW5hdGUucHVzaChsZXJwKGZsYXRDb29yZGluYXRlc1sobG8gLSAxKSAqIHN0cmlkZSArIGldLFxuICAgICAgZmxhdENvb3JkaW5hdGVzW2xvICogc3RyaWRlICsgaV0sIHQpKTtcbiAgfVxuICBjb29yZGluYXRlLnB1c2gobSk7XG4gIHJldHVybiBjb29yZGluYXRlO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbmRzIEVuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtIE0uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGV4dHJhcG9sYXRlIEV4dHJhcG9sYXRlLlxuICogQHBhcmFtIHtib29sZWFufSBpbnRlcnBvbGF0ZSBJbnRlcnBvbGF0ZS5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gQ29vcmRpbmF0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVTdHJpbmdzQ29vcmRpbmF0ZUF0TShcbiAgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHMsIHN0cmlkZSwgbSwgZXh0cmFwb2xhdGUsIGludGVycG9sYXRlKSB7XG4gIGlmIChpbnRlcnBvbGF0ZSkge1xuICAgIHJldHVybiBsaW5lU3RyaW5nQ29vcmRpbmF0ZUF0TShcbiAgICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzW2VuZHMubGVuZ3RoIC0gMV0sIHN0cmlkZSwgbSwgZXh0cmFwb2xhdGUpO1xuICB9XG4gIHZhciBjb29yZGluYXRlO1xuICBpZiAobSA8IGZsYXRDb29yZGluYXRlc1tzdHJpZGUgLSAxXSkge1xuICAgIGlmIChleHRyYXBvbGF0ZSkge1xuICAgICAgY29vcmRpbmF0ZSA9IGZsYXRDb29yZGluYXRlcy5zbGljZSgwLCBzdHJpZGUpO1xuICAgICAgY29vcmRpbmF0ZVtzdHJpZGUgLSAxXSA9IG07XG4gICAgICByZXR1cm4gY29vcmRpbmF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGlmIChmbGF0Q29vcmRpbmF0ZXNbZmxhdENvb3JkaW5hdGVzLmxlbmd0aCAtIDFdIDwgbSkge1xuICAgIGlmIChleHRyYXBvbGF0ZSkge1xuICAgICAgY29vcmRpbmF0ZSA9IGZsYXRDb29yZGluYXRlcy5zbGljZShmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoIC0gc3RyaWRlKTtcbiAgICAgIGNvb3JkaW5hdGVbc3RyaWRlIC0gMV0gPSBtO1xuICAgICAgcmV0dXJuIGNvb3JkaW5hdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBmb3IgKHZhciBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICB2YXIgZW5kID0gZW5kc1tpXTtcbiAgICBpZiAob2Zmc2V0ID09IGVuZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChtIDwgZmxhdENvb3JkaW5hdGVzW29mZnNldCArIHN0cmlkZSAtIDFdKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKG0gPD0gZmxhdENvb3JkaW5hdGVzW2VuZCAtIDFdKSB7XG4gICAgICByZXR1cm4gbGluZVN0cmluZ0Nvb3JkaW5hdGVBdE0oXG4gICAgICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgbSwgZmFsc2UpO1xuICAgIH1cbiAgICBvZmZzZXQgPSBlbmQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVycG9sYXRlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL2ZsYXQvaW50ZXJzZWN0c2V4dGVudFxuICovXG5pbXBvcnQge2NvbnRhaW5zRXh0ZW50LCBjcmVhdGVFbXB0eSwgZXh0ZW5kRmxhdENvb3JkaW5hdGVzLCBpbnRlcnNlY3RzLCBpbnRlcnNlY3RzU2VnbWVudH0gZnJvbSAnLi4vLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7bGluZWFyUmluZ0NvbnRhaW5zWFksIGxpbmVhclJpbmdDb250YWluc0V4dGVudH0gZnJvbSAnLi9jb250YWlucy5qcyc7XG5pbXBvcnQge2ZvckVhY2ggYXMgZm9yRWFjaFNlZ21lbnR9IGZyb20gJy4vc2VnbWVudHMuanMnO1xuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGdlb21ldHJ5IGFuZCB0aGUgZXh0ZW50IGludGVyc2VjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdHNMaW5lU3RyaW5nKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgZXh0ZW50KSB7XG4gIHZhciBjb29yZGluYXRlc0V4dGVudCA9IGV4dGVuZEZsYXRDb29yZGluYXRlcyhcbiAgICBjcmVhdGVFbXB0eSgpLCBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUpO1xuICBpZiAoIWludGVyc2VjdHMoZXh0ZW50LCBjb29yZGluYXRlc0V4dGVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGNvbnRhaW5zRXh0ZW50KGV4dGVudCwgY29vcmRpbmF0ZXNFeHRlbnQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGNvb3JkaW5hdGVzRXh0ZW50WzBdID49IGV4dGVudFswXSAmJlxuICAgICAgY29vcmRpbmF0ZXNFeHRlbnRbMl0gPD0gZXh0ZW50WzJdKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGNvb3JkaW5hdGVzRXh0ZW50WzFdID49IGV4dGVudFsxXSAmJlxuICAgICAgY29vcmRpbmF0ZXNFeHRlbnRbM10gPD0gZXh0ZW50WzNdKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZvckVhY2hTZWdtZW50KGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSxcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gcG9pbnQxIFN0YXJ0IHBvaW50LlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBwb2ludDIgRW5kIHBvaW50LlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgc2VnbWVudCBhbmQgdGhlIGV4dGVudCBpbnRlcnNlY3QsXG4gICAgICogICAgIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uKHBvaW50MSwgcG9pbnQyKSB7XG4gICAgICByZXR1cm4gaW50ZXJzZWN0c1NlZ21lbnQoZXh0ZW50LCBwb2ludDEsIHBvaW50Mik7XG4gICAgfSk7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGVuZHMgRW5kcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZ2VvbWV0cnkgYW5kIHRoZSBleHRlbnQgaW50ZXJzZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJzZWN0c0xpbmVTdHJpbmdBcnJheShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlLCBleHRlbnQpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgaWYgKGludGVyc2VjdHNMaW5lU3RyaW5nKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHNbaV0sIHN0cmlkZSwgZXh0ZW50KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIG9mZnNldCA9IGVuZHNbaV07XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGdlb21ldHJ5IGFuZCB0aGUgZXh0ZW50IGludGVyc2VjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdHNMaW5lYXJSaW5nKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgZXh0ZW50KSB7XG4gIGlmIChpbnRlcnNlY3RzTGluZVN0cmluZyhcbiAgICBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIGV4dGVudCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAobGluZWFyUmluZ0NvbnRhaW5zWFkoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCBleHRlbnRbMF0sIGV4dGVudFsxXSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAobGluZWFyUmluZ0NvbnRhaW5zWFkoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCBleHRlbnRbMF0sIGV4dGVudFszXSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAobGluZWFyUmluZ0NvbnRhaW5zWFkoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCBleHRlbnRbMl0sIGV4dGVudFsxXSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAobGluZWFyUmluZ0NvbnRhaW5zWFkoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCBleHRlbnRbMl0sIGV4dGVudFszXSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGVuZHMgRW5kcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZ2VvbWV0cnkgYW5kIHRoZSBleHRlbnQgaW50ZXJzZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJzZWN0c0xpbmVhclJpbmdBcnJheShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlLCBleHRlbnQpIHtcbiAgaWYgKCFpbnRlcnNlY3RzTGluZWFyUmluZyhcbiAgICBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kc1swXSwgc3RyaWRlLCBleHRlbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChlbmRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZvciAodmFyIGkgPSAxLCBpaSA9IGVuZHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGlmIChsaW5lYXJSaW5nQ29udGFpbnNFeHRlbnQoZmxhdENvb3JkaW5hdGVzLCBlbmRzW2kgLSAxXSwgZW5kc1tpXSwgc3RyaWRlLCBleHRlbnQpKSB7XG4gICAgICBpZiAoIWludGVyc2VjdHNMaW5lU3RyaW5nKGZsYXRDb29yZGluYXRlcywgZW5kc1tpIC0gMV0sIGVuZHNbaV0sIHN0cmlkZSwgZXh0ZW50KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gZW5kc3MgRW5kc3MuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGdlb21ldHJ5IGFuZCB0aGUgZXh0ZW50IGludGVyc2VjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdHNMaW5lYXJSaW5nTXVsdGlBcnJheShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kc3MsIHN0cmlkZSwgZXh0ZW50KSB7XG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IGVuZHNzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICB2YXIgZW5kcyA9IGVuZHNzW2ldO1xuICAgIGlmIChpbnRlcnNlY3RzTGluZWFyUmluZ0FycmF5KFxuICAgICAgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHMsIHN0cmlkZSwgZXh0ZW50KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIG9mZnNldCA9IGVuZHNbZW5kcy5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyc2VjdHNleHRlbnQuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9sZW5ndGhcbiAqL1xuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEByZXR1cm4ge251bWJlcn0gTGVuZ3RoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZVN0cmluZ0xlbmd0aChmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUpIHtcbiAgdmFyIHgxID0gZmxhdENvb3JkaW5hdGVzW29mZnNldF07XG4gIHZhciB5MSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXTtcbiAgdmFyIGxlbmd0aCA9IDA7XG4gIGZvciAodmFyIGkgPSBvZmZzZXQgKyBzdHJpZGU7IGkgPCBlbmQ7IGkgKz0gc3RyaWRlKSB7XG4gICAgdmFyIHgyID0gZmxhdENvb3JkaW5hdGVzW2ldO1xuICAgIHZhciB5MiA9IGZsYXRDb29yZGluYXRlc1tpICsgMV07XG4gICAgbGVuZ3RoICs9IE1hdGguc3FydCgoeDIgLSB4MSkgKiAoeDIgLSB4MSkgKyAoeTIgLSB5MSkgKiAoeTIgLSB5MSkpO1xuICAgIHgxID0geDI7XG4gICAgeTEgPSB5MjtcbiAgfVxuICByZXR1cm4gbGVuZ3RoO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEByZXR1cm4ge251bWJlcn0gUGVyaW1ldGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyUmluZ0xlbmd0aChmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUpIHtcbiAgdmFyIHBlcmltZXRlciA9IGxpbmVTdHJpbmdMZW5ndGgoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKTtcbiAgdmFyIGR4ID0gZmxhdENvb3JkaW5hdGVzW2VuZCAtIHN0cmlkZV0gLSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XTtcbiAgdmFyIGR5ID0gZmxhdENvb3JkaW5hdGVzW2VuZCAtIHN0cmlkZSArIDFdIC0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdO1xuICBwZXJpbWV0ZXIgKz0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgcmV0dXJuIHBlcmltZXRlcjtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGVuZ3RoLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL2ZsYXQvb3JpZW50XG4gKi9cbmltcG9ydCB7Y29vcmRpbmF0ZXMgYXMgcmV2ZXJzZUNvb3JkaW5hdGVzfSBmcm9tICcuL3JldmVyc2UuanMnO1xuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IElzIGNsb2Nrd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhclJpbmdJc0Nsb2Nrd2lzZShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUpIHtcbiAgLy8gaHR0cDovL3Rpbnl1cmwuY29tL2Nsb2Nrd2lzZS1tZXRob2RcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL09TR2VvL2dkYWwvYmxvYi90cnVuay9nZGFsL29nci9vZ3JsaW5lYXJyaW5nLmNwcFxuICB2YXIgZWRnZSA9IDA7XG4gIHZhciB4MSA9IGZsYXRDb29yZGluYXRlc1tlbmQgLSBzdHJpZGVdO1xuICB2YXIgeTEgPSBmbGF0Q29vcmRpbmF0ZXNbZW5kIC0gc3RyaWRlICsgMV07XG4gIGZvciAoOyBvZmZzZXQgPCBlbmQ7IG9mZnNldCArPSBzdHJpZGUpIHtcbiAgICB2YXIgeDIgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XTtcbiAgICB2YXIgeTIgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gICAgZWRnZSArPSAoeDIgLSB4MSkgKiAoeTIgKyB5MSk7XG4gICAgeDEgPSB4MjtcbiAgICB5MSA9IHkyO1xuICB9XG4gIHJldHVybiBlZGdlID4gMDtcbn1cblxuXG4vKipcbiAqIERldGVybWluZXMgaWYgbGluZWFyIHJpbmdzIGFyZSBvcmllbnRlZC4gIEJ5IGRlZmF1bHQsIGxlZnQtaGFuZCBvcmllbnRhdGlvblxuICogaXMgdGVzdGVkIChmaXJzdCByaW5nIG11c3QgYmUgY2xvY2t3aXNlLCByZW1haW5pbmcgcmluZ3MgY291bnRlci1jbG9ja3dpc2UpLlxuICogVG8gdGVzdCBmb3IgcmlnaHQtaGFuZCBvcmllbnRhdGlvbiwgdXNlIHRoZSBgb3B0X3JpZ2h0YCBhcmd1bWVudC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGVuZHMgQXJyYXkgb2YgZW5kIGluZGV4ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9yaWdodCBUZXN0IGZvciByaWdodC1oYW5kIG9yaWVudGF0aW9uXG4gKiAgICAgKGNvdW50ZXItY2xvY2t3aXNlIGV4dGVyaW9yIHJpbmcgYW5kIGNsb2Nrd2lzZSBpbnRlcmlvciByaW5ncykuXG4gKiBAcmV0dXJuIHtib29sZWFufSBSaW5ncyBhcmUgY29ycmVjdGx5IG9yaWVudGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyUmluZ0lzT3JpZW50ZWQoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHMsIHN0cmlkZSwgb3B0X3JpZ2h0KSB7XG4gIHZhciByaWdodCA9IG9wdF9yaWdodCAhPT0gdW5kZWZpbmVkID8gb3B0X3JpZ2h0IDogZmFsc2U7XG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IGVuZHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIHZhciBlbmQgPSBlbmRzW2ldO1xuICAgIHZhciBpc0Nsb2Nrd2lzZSA9IGxpbmVhclJpbmdJc0Nsb2Nrd2lzZShcbiAgICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSk7XG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIGlmICgocmlnaHQgJiYgaXNDbG9ja3dpc2UpIHx8ICghcmlnaHQgJiYgIWlzQ2xvY2t3aXNlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICgocmlnaHQgJiYgIWlzQ2xvY2t3aXNlKSB8fCAoIXJpZ2h0ICYmIGlzQ2xvY2t3aXNlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIG9mZnNldCA9IGVuZDtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuXG4vKipcbiAqIERldGVybWluZXMgaWYgbGluZWFyIHJpbmdzIGFyZSBvcmllbnRlZC4gIEJ5IGRlZmF1bHQsIGxlZnQtaGFuZCBvcmllbnRhdGlvblxuICogaXMgdGVzdGVkIChmaXJzdCByaW5nIG11c3QgYmUgY2xvY2t3aXNlLCByZW1haW5pbmcgcmluZ3MgY291bnRlci1jbG9ja3dpc2UpLlxuICogVG8gdGVzdCBmb3IgcmlnaHQtaGFuZCBvcmllbnRhdGlvbiwgdXNlIHRoZSBgb3B0X3JpZ2h0YCBhcmd1bWVudC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBlbmRzcyBBcnJheSBvZiBhcnJheSBvZiBlbmQgaW5kZXhlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3JpZ2h0IFRlc3QgZm9yIHJpZ2h0LWhhbmQgb3JpZW50YXRpb25cbiAqICAgICAoY291bnRlci1jbG9ja3dpc2UgZXh0ZXJpb3IgcmluZyBhbmQgY2xvY2t3aXNlIGludGVyaW9yIHJpbmdzKS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJpbmdzIGFyZSBjb3JyZWN0bHkgb3JpZW50ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJSaW5nc0FyZU9yaWVudGVkKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzcywgc3RyaWRlLCBvcHRfcmlnaHQpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gZW5kc3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGlmICghbGluZWFyUmluZ0lzT3JpZW50ZWQoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kc3NbaV0sIHN0cmlkZSwgb3B0X3JpZ2h0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuXG4vKipcbiAqIE9yaWVudCBjb29yZGluYXRlcyBpbiBhIGZsYXQgYXJyYXkgb2YgbGluZWFyIHJpbmdzLiAgQnkgZGVmYXVsdCwgcmluZ3NcbiAqIGFyZSBvcmllbnRlZCBmb2xsb3dpbmcgdGhlIGxlZnQtaGFuZCBydWxlIChjbG9ja3dpc2UgZm9yIGV4dGVyaW9yIGFuZFxuICogY291bnRlci1jbG9ja3dpc2UgZm9yIGludGVyaW9yIHJpbmdzKS4gIFRvIG9yaWVudCBhY2NvcmRpbmcgdG8gdGhlXG4gKiByaWdodC1oYW5kIHJ1bGUsIHVzZSB0aGUgYG9wdF9yaWdodGAgYXJndW1lbnQuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbmRzIEVuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9yaWdodCBGb2xsb3cgdGhlIHJpZ2h0LWhhbmQgcnVsZSBmb3Igb3JpZW50YXRpb24uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEVuZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9yaWVudExpbmVhclJpbmdzKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLCBzdHJpZGUsIG9wdF9yaWdodCkge1xuICB2YXIgcmlnaHQgPSBvcHRfcmlnaHQgIT09IHVuZGVmaW5lZCA/IG9wdF9yaWdodCA6IGZhbHNlO1xuICBmb3IgKHZhciBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICB2YXIgZW5kID0gZW5kc1tpXTtcbiAgICB2YXIgaXNDbG9ja3dpc2UgPSBsaW5lYXJSaW5nSXNDbG9ja3dpc2UoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUpO1xuICAgIHZhciByZXZlcnNlID0gaSA9PT0gMCA/XG4gICAgICAocmlnaHQgJiYgaXNDbG9ja3dpc2UpIHx8ICghcmlnaHQgJiYgIWlzQ2xvY2t3aXNlKSA6XG4gICAgICAocmlnaHQgJiYgIWlzQ2xvY2t3aXNlKSB8fCAoIXJpZ2h0ICYmIGlzQ2xvY2t3aXNlKTtcbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgcmV2ZXJzZUNvb3JkaW5hdGVzKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSk7XG4gICAgfVxuICAgIG9mZnNldCA9IGVuZDtcbiAgfVxuICByZXR1cm4gb2Zmc2V0O1xufVxuXG5cbi8qKlxuICogT3JpZW50IGNvb3JkaW5hdGVzIGluIGEgZmxhdCBhcnJheSBvZiBsaW5lYXIgcmluZ3MuICBCeSBkZWZhdWx0LCByaW5nc1xuICogYXJlIG9yaWVudGVkIGZvbGxvd2luZyB0aGUgbGVmdC1oYW5kIHJ1bGUgKGNsb2Nrd2lzZSBmb3IgZXh0ZXJpb3IgYW5kXG4gKiBjb3VudGVyLWNsb2Nrd2lzZSBmb3IgaW50ZXJpb3IgcmluZ3MpLiAgVG8gb3JpZW50IGFjY29yZGluZyB0byB0aGVcbiAqIHJpZ2h0LWhhbmQgcnVsZSwgdXNlIHRoZSBgb3B0X3JpZ2h0YCBhcmd1bWVudC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBlbmRzcyBBcnJheSBvZiBhcnJheSBvZiBlbmQgaW5kZXhlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3JpZ2h0IEZvbGxvdyB0aGUgcmlnaHQtaGFuZCBydWxlIGZvciBvcmllbnRhdGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn0gRW5kLlxuICovXG5leHBvcnQgZnVuY3Rpb24gb3JpZW50TGluZWFyUmluZ3NBcnJheShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kc3MsIHN0cmlkZSwgb3B0X3JpZ2h0KSB7XG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IGVuZHNzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBvZmZzZXQgPSBvcmllbnRMaW5lYXJSaW5ncyhcbiAgICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzc1tpXSwgc3RyaWRlLCBvcHRfcmlnaHQpO1xuICB9XG4gIHJldHVybiBvZmZzZXQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9yaWVudC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9mbGF0L3JldmVyc2VcbiAqL1xuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvb3JkaW5hdGVzKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSkge1xuICB3aGlsZSAob2Zmc2V0IDwgZW5kIC0gc3RyaWRlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpZGU7ICsraSkge1xuICAgICAgdmFyIHRtcCA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyBpXTtcbiAgICAgIGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyBpXSA9IGZsYXRDb29yZGluYXRlc1tlbmQgLSBzdHJpZGUgKyBpXTtcbiAgICAgIGZsYXRDb29yZGluYXRlc1tlbmQgLSBzdHJpZGUgKyBpXSA9IHRtcDtcbiAgICB9XG4gICAgb2Zmc2V0ICs9IHN0cmlkZTtcbiAgICBlbmQgLT0gc3RyaWRlO1xuICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJldmVyc2UuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9zZWdtZW50c1xuICovXG5cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbGxzIGBjYWxsYmFja2AgZm9yIGVhY2ggc2VnbWVudCBvZiB0aGUgZmxhdCBjb29yZGluYXRlc1xuICogYXJyYXkuIElmIHRoZSBjYWxsYmFjayByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRoYXRcbiAqIHZhbHVlIGltbWVkaWF0ZWx5LiBPdGhlcndpc2UgdGhlIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6IFMsIGltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZSwgaW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlKTogVH0gY2FsbGJhY2sgRnVuY3Rpb25cbiAqICAgICBjYWxsZWQgZm9yIGVhY2ggc2VnbWVudC5cbiAqIEBwYXJhbSB7Uz19IG9wdF90aGlzIFRoZSBvYmplY3QgdG8gYmUgdXNlZCBhcyB0aGUgdmFsdWUgb2YgJ3RoaXMnXG4gKiAgICAgd2l0aGluIGNhbGxiYWNrLlxuICogQHJldHVybiB7VHxib29sZWFufSBWYWx1ZS5cbiAqIEB0ZW1wbGF0ZSBULFNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvckVhY2goZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCBjYWxsYmFjaywgb3B0X3RoaXMpIHtcbiAgdmFyIHBvaW50MSA9IFtmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XSwgZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdXTtcbiAgdmFyIHBvaW50MiA9IFtdO1xuICB2YXIgcmV0O1xuICBmb3IgKDsgKG9mZnNldCArIHN0cmlkZSkgPCBlbmQ7IG9mZnNldCArPSBzdHJpZGUpIHtcbiAgICBwb2ludDJbMF0gPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgc3RyaWRlXTtcbiAgICBwb2ludDJbMV0gPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgc3RyaWRlICsgMV07XG4gICAgcmV0ID0gY2FsbGJhY2suY2FsbChvcHRfdGhpcywgcG9pbnQxLCBwb2ludDIpO1xuICAgIGlmIChyZXQpIHtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIHBvaW50MVswXSA9IHBvaW50MlswXTtcbiAgICBwb2ludDFbMV0gPSBwb2ludDJbMV07XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWdtZW50cy5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9mbGF0L3NpbXBsaWZ5XG4gKi9cbi8vIEJhc2VkIG9uIHNpbXBsaWZ5LWpzIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3VybmVyL3NpbXBsaWZ5LWpzXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTIsIFZsYWRpbWlyIEFnYWZvbmtpblxuLy8gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vXG4vLyBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbi8vIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuLy9cbi8vICAgIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbi8vICAgICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4vL1xuLy8gICAgMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbi8vICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbi8vICAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4vL1xuLy8gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbi8vIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbi8vIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4vLyBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFXG4vLyBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4vLyBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRlxuLy8gU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXG4vLyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTlxuLy8gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSlcbi8vIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4vLyBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cblxuaW1wb3J0IHtzcXVhcmVkU2VnbWVudERpc3RhbmNlLCBzcXVhcmVkRGlzdGFuY2V9IGZyb20gJy4uLy4uL21hdGguanMnO1xuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcXVhcmVkVG9sZXJhbmNlIFNxdWFyZWQgdG9sZXJhbmNlLlxuICogQHBhcmFtIHtib29sZWFufSBoaWdoUXVhbGl0eSBIaWdoZXN0IHF1YWxpdHkuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj49fSBvcHRfc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyBTaW1wbGlmaWVkIGZsYXRcbiAqICAgICBjb29yZGluYXRlcy5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFNpbXBsaWZpZWQgbGluZSBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaW1wbGlmeUxpbmVTdHJpbmcoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCxcbiAgc3RyaWRlLCBzcXVhcmVkVG9sZXJhbmNlLCBoaWdoUXVhbGl0eSwgb3B0X3NpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMpIHtcbiAgdmFyIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMgPSBvcHRfc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyAhPT0gdW5kZWZpbmVkID9cbiAgICBvcHRfc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyA6IFtdO1xuICBpZiAoIWhpZ2hRdWFsaXR5KSB7XG4gICAgZW5kID0gcmFkaWFsRGlzdGFuY2UoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCxcbiAgICAgIHN0cmlkZSwgc3F1YXJlZFRvbGVyYW5jZSxcbiAgICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsIDApO1xuICAgIGZsYXRDb29yZGluYXRlcyA9IHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXM7XG4gICAgb2Zmc2V0ID0gMDtcbiAgICBzdHJpZGUgPSAyO1xuICB9XG4gIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMubGVuZ3RoID0gZG91Z2xhc1BldWNrZXIoXG4gICAgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCBzcXVhcmVkVG9sZXJhbmNlLFxuICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsIDApO1xuICByZXR1cm4gc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcztcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gc3F1YXJlZFRvbGVyYW5jZSBTcXVhcmVkIHRvbGVyYW5jZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyBTaW1wbGlmaWVkIGZsYXRcbiAqICAgICBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaW1wbGlmaWVkT2Zmc2V0IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICogQHJldHVybiB7bnVtYmVyfSBTaW1wbGlmaWVkIG9mZnNldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRvdWdsYXNQZXVja2VyKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsXG4gIHN0cmlkZSwgc3F1YXJlZFRvbGVyYW5jZSwgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcywgc2ltcGxpZmllZE9mZnNldCkge1xuICB2YXIgbiA9IChlbmQgLSBvZmZzZXQpIC8gc3RyaWRlO1xuICBpZiAobiA8IDMpIHtcbiAgICBmb3IgKDsgb2Zmc2V0IDwgZW5kOyBvZmZzZXQgKz0gc3RyaWRlKSB7XG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPVxuICAgICAgICAgIGZsYXRDb29yZGluYXRlc1tvZmZzZXRdO1xuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID1cbiAgICAgICAgICBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gICAgfVxuICAgIHJldHVybiBzaW1wbGlmaWVkT2Zmc2V0O1xuICB9XG4gIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi9cbiAgdmFyIG1hcmtlcnMgPSBuZXcgQXJyYXkobik7XG4gIG1hcmtlcnNbMF0gPSAxO1xuICBtYXJrZXJzW24gLSAxXSA9IDE7XG4gIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi9cbiAgdmFyIHN0YWNrID0gW29mZnNldCwgZW5kIC0gc3RyaWRlXTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgbGFzdCA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBmaXJzdCA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBtYXhTcXVhcmVkRGlzdGFuY2UgPSAwO1xuICAgIHZhciB4MSA9IGZsYXRDb29yZGluYXRlc1tmaXJzdF07XG4gICAgdmFyIHkxID0gZmxhdENvb3JkaW5hdGVzW2ZpcnN0ICsgMV07XG4gICAgdmFyIHgyID0gZmxhdENvb3JkaW5hdGVzW2xhc3RdO1xuICAgIHZhciB5MiA9IGZsYXRDb29yZGluYXRlc1tsYXN0ICsgMV07XG4gICAgZm9yICh2YXIgaSA9IGZpcnN0ICsgc3RyaWRlOyBpIDwgbGFzdDsgaSArPSBzdHJpZGUpIHtcbiAgICAgIHZhciB4ID0gZmxhdENvb3JkaW5hdGVzW2ldO1xuICAgICAgdmFyIHkgPSBmbGF0Q29vcmRpbmF0ZXNbaSArIDFdO1xuICAgICAgdmFyIHNxdWFyZWREaXN0YW5jZSA9IHNxdWFyZWRTZWdtZW50RGlzdGFuY2UoXG4gICAgICAgIHgsIHksIHgxLCB5MSwgeDIsIHkyKTtcbiAgICAgIGlmIChzcXVhcmVkRGlzdGFuY2UgPiBtYXhTcXVhcmVkRGlzdGFuY2UpIHtcbiAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICBtYXhTcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkRGlzdGFuY2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtYXhTcXVhcmVkRGlzdGFuY2UgPiBzcXVhcmVkVG9sZXJhbmNlKSB7XG4gICAgICBtYXJrZXJzWyhpbmRleCAtIG9mZnNldCkgLyBzdHJpZGVdID0gMTtcbiAgICAgIGlmIChmaXJzdCArIHN0cmlkZSA8IGluZGV4KSB7XG4gICAgICAgIHN0YWNrLnB1c2goZmlyc3QsIGluZGV4KTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmRleCArIHN0cmlkZSA8IGxhc3QpIHtcbiAgICAgICAgc3RhY2sucHVzaChpbmRleCwgbGFzdCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IG47ICsraSQxKSB7XG4gICAgaWYgKG1hcmtlcnNbaSQxXSkge1xuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID1cbiAgICAgICAgICBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgaSQxICogc3RyaWRlXTtcbiAgICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9XG4gICAgICAgICAgZmxhdENvb3JkaW5hdGVzW29mZnNldCArIGkkMSAqIHN0cmlkZSArIDFdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2ltcGxpZmllZE9mZnNldDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW5kcyBFbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gc3F1YXJlZFRvbGVyYW5jZSBTcXVhcmVkIHRvbGVyYW5jZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyBTaW1wbGlmaWVkIGZsYXRcbiAqICAgICBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaW1wbGlmaWVkT2Zmc2V0IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBzaW1wbGlmaWVkRW5kcyBTaW1wbGlmaWVkIGVuZHMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZG91Z2xhc1BldWNrZXJBcnJheShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCxcbiAgZW5kcywgc3RyaWRlLCBzcXVhcmVkVG9sZXJhbmNlLCBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLFxuICBzaW1wbGlmaWVkT2Zmc2V0LCBzaW1wbGlmaWVkRW5kcykge1xuICBmb3IgKHZhciBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICB2YXIgZW5kID0gZW5kc1tpXTtcbiAgICBzaW1wbGlmaWVkT2Zmc2V0ID0gZG91Z2xhc1BldWNrZXIoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIHNxdWFyZWRUb2xlcmFuY2UsXG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLCBzaW1wbGlmaWVkT2Zmc2V0KTtcbiAgICBzaW1wbGlmaWVkRW5kcy5wdXNoKHNpbXBsaWZpZWRPZmZzZXQpO1xuICAgIG9mZnNldCA9IGVuZDtcbiAgfVxuICByZXR1cm4gc2ltcGxpZmllZE9mZnNldDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGVuZHNzIEVuZHNzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gc3F1YXJlZFRvbGVyYW5jZSBTcXVhcmVkIHRvbGVyYW5jZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyBTaW1wbGlmaWVkIGZsYXRcbiAqICAgICBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaW1wbGlmaWVkT2Zmc2V0IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gc2ltcGxpZmllZEVuZHNzIFNpbXBsaWZpZWQgZW5kc3MuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZG91Z2xhc1BldWNrZXJNdWx0aUFycmF5KFxuICBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kc3MsIHN0cmlkZSwgc3F1YXJlZFRvbGVyYW5jZSxcbiAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcywgc2ltcGxpZmllZE9mZnNldCwgc2ltcGxpZmllZEVuZHNzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IGVuZHNzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICB2YXIgZW5kcyA9IGVuZHNzW2ldO1xuICAgIHZhciBzaW1wbGlmaWVkRW5kcyA9IFtdO1xuICAgIHNpbXBsaWZpZWRPZmZzZXQgPSBkb3VnbGFzUGV1Y2tlckFycmF5KFxuICAgICAgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHMsIHN0cmlkZSwgc3F1YXJlZFRvbGVyYW5jZSxcbiAgICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsIHNpbXBsaWZpZWRPZmZzZXQsIHNpbXBsaWZpZWRFbmRzKTtcbiAgICBzaW1wbGlmaWVkRW5kc3MucHVzaChzaW1wbGlmaWVkRW5kcyk7XG4gICAgb2Zmc2V0ID0gZW5kc1tlbmRzLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBzaW1wbGlmaWVkT2Zmc2V0O1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcXVhcmVkVG9sZXJhbmNlIFNxdWFyZWQgdG9sZXJhbmNlLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzIFNpbXBsaWZpZWQgZmxhdFxuICogICAgIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IHNpbXBsaWZpZWRPZmZzZXQgU2ltcGxpZmllZCBvZmZzZXQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFkaWFsRGlzdGFuY2UoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCxcbiAgc3RyaWRlLCBzcXVhcmVkVG9sZXJhbmNlLCBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLCBzaW1wbGlmaWVkT2Zmc2V0KSB7XG4gIGlmIChlbmQgPD0gb2Zmc2V0ICsgc3RyaWRlKSB7XG4gICAgLy8gemVybyBvciBvbmUgcG9pbnQsIG5vIHNpbXBsaWZpY2F0aW9uIHBvc3NpYmxlLCBzbyBjb3B5IGFuZCByZXR1cm5cbiAgICBmb3IgKDsgb2Zmc2V0IDwgZW5kOyBvZmZzZXQgKz0gc3RyaWRlKSB7XG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XTtcbiAgICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9XG4gICAgICAgICAgZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdO1xuICAgIH1cbiAgICByZXR1cm4gc2ltcGxpZmllZE9mZnNldDtcbiAgfVxuICB2YXIgeDEgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XTtcbiAgdmFyIHkxID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdO1xuICAvLyBjb3B5IGZpcnN0IHBvaW50XG4gIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IHgxO1xuICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPSB5MTtcbiAgdmFyIHgyID0geDE7XG4gIHZhciB5MiA9IHkxO1xuICBmb3IgKG9mZnNldCArPSBzdHJpZGU7IG9mZnNldCA8IGVuZDsgb2Zmc2V0ICs9IHN0cmlkZSkge1xuICAgIHgyID0gZmxhdENvb3JkaW5hdGVzW29mZnNldF07XG4gICAgeTIgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gICAgaWYgKHNxdWFyZWREaXN0YW5jZSh4MSwgeTEsIHgyLCB5MikgPiBzcXVhcmVkVG9sZXJhbmNlKSB7XG4gICAgICAvLyBjb3B5IHBvaW50IGF0IG9mZnNldFxuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID0geDI7XG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPSB5MjtcbiAgICAgIHgxID0geDI7XG4gICAgICB5MSA9IHkyO1xuICAgIH1cbiAgfVxuICBpZiAoeDIgIT0geDEgfHwgeTIgIT0geTEpIHtcbiAgICAvLyBjb3B5IGxhc3QgcG9pbnRcbiAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPSB4MjtcbiAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPSB5MjtcbiAgfVxuICByZXR1cm4gc2ltcGxpZmllZE9mZnNldDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b2xlcmFuY2UgVG9sZXJhbmNlLlxuICogQHJldHVybiB7bnVtYmVyfSBSb3VuZGVkIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc25hcCh2YWx1ZSwgdG9sZXJhbmNlKSB7XG4gIHJldHVybiB0b2xlcmFuY2UgKiBNYXRoLnJvdW5kKHZhbHVlIC8gdG9sZXJhbmNlKTtcbn1cblxuXG4vKipcbiAqIFNpbXBsaWZpZXMgYSBsaW5lIHN0cmluZyB1c2luZyBhbiBhbGdvcml0aG0gZGVzaWduZWQgYnkgVGltIFNjaGF1Yi5cbiAqIENvb3JkaW5hdGVzIGFyZSBzbmFwcGVkIHRvIHRoZSBuZWFyZXN0IHZhbHVlIGluIGEgdmlydHVhbCBncmlkIGFuZFxuICogY29uc2VjdXRpdmUgZHVwbGljYXRlIGNvb3JkaW5hdGVzIGFyZSBkaXNjYXJkZWQuICBUaGlzIGVmZmVjdGl2ZWx5IHByZXNlcnZlc1xuICogdG9wb2xvZ3kgYXMgdGhlIHNpbXBsaWZpY2F0aW9uIG9mIGFueSBzdWJzZWN0aW9uIG9mIGEgbGluZSBzdHJpbmcgaXNcbiAqIGluZGVwZW5kZW50IG9mIHRoZSByZXN0IG9mIHRoZSBsaW5lIHN0cmluZy4gIFRoaXMgbWVhbnMgdGhhdCwgZm9yIGV4YW1wbGVzLFxuICogdGhlIGNvbW1vbiBlZGdlIGJldHdlZW4gdHdvIHBvbHlnb25zIHdpbGwgYmUgc2ltcGxpZmllZCB0byB0aGUgc2FtZSBsaW5lXG4gKiBzdHJpbmcgaW5kZXBlbmRlbnRseSBpbiBib3RoIHBvbHlnb25zLiAgVGhpcyBpbXBsZW1lbnRhdGlvbiB1c2VzIGEgc2luZ2xlXG4gKiBwYXNzIG92ZXIgdGhlIGNvb3JkaW5hdGVzIGFuZCBlbGltaW5hdGVzIGludGVybWVkaWF0ZSBjb2xsaW5lYXIgcG9pbnRzLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b2xlcmFuY2UgVG9sZXJhbmNlLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzIFNpbXBsaWZpZWQgZmxhdFxuICogICAgIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IHNpbXBsaWZpZWRPZmZzZXQgU2ltcGxpZmllZCBvZmZzZXQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVhbnRpemUoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLFxuICB0b2xlcmFuY2UsIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsIHNpbXBsaWZpZWRPZmZzZXQpIHtcbiAgLy8gZG8gbm90aGluZyBpZiB0aGUgbGluZSBpcyBlbXB0eVxuICBpZiAob2Zmc2V0ID09IGVuZCkge1xuICAgIHJldHVybiBzaW1wbGlmaWVkT2Zmc2V0O1xuICB9XG4gIC8vIHNuYXAgdGhlIGZpcnN0IGNvb3JkaW5hdGUgKFAxKVxuICB2YXIgeDEgPSBzbmFwKGZsYXRDb29yZGluYXRlc1tvZmZzZXRdLCB0b2xlcmFuY2UpO1xuICB2YXIgeTEgPSBzbmFwKGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXSwgdG9sZXJhbmNlKTtcbiAgb2Zmc2V0ICs9IHN0cmlkZTtcbiAgLy8gYWRkIHRoZSBmaXJzdCBjb29yZGluYXRlIHRvIHRoZSBvdXRwdXRcbiAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID0geDE7XG4gIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IHkxO1xuICAvLyBmaW5kIHRoZSBuZXh0IGNvb3JkaW5hdGUgdGhhdCBkb2VzIG5vdCBzbmFwIHRvIHRoZSBzYW1lIHZhbHVlIGFzIHRoZSBmaXJzdFxuICAvLyBjb29yZGluYXRlIChQMilcbiAgdmFyIHgyLCB5MjtcbiAgZG8ge1xuICAgIHgyID0gc25hcChmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XSwgdG9sZXJhbmNlKTtcbiAgICB5MiA9IHNuYXAoZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdLCB0b2xlcmFuY2UpO1xuICAgIG9mZnNldCArPSBzdHJpZGU7XG4gICAgaWYgKG9mZnNldCA9PSBlbmQpIHtcbiAgICAgIC8vIGFsbCBjb29yZGluYXRlcyBzbmFwIHRvIHRoZSBzYW1lIHZhbHVlLCB0aGUgbGluZSBjb2xsYXBzZXMgdG8gYSBwb2ludFxuICAgICAgLy8gcHVzaCB0aGUgbGFzdCBzbmFwcGVkIHZhbHVlIGFueXdheSB0byBlbnN1cmUgdGhhdCB0aGUgb3V0cHV0IGNvbnRhaW5zXG4gICAgICAvLyBhdCBsZWFzdCB0d28gcG9pbnRzXG4gICAgICAvLyBGSVhNRSBzaG91bGQgd2UgcmVhbGx5IHJldHVybiBhdCBsZWFzdCB0d28gcG9pbnRzIGFueXdheT9cbiAgICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IHgyO1xuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID0geTI7XG4gICAgICByZXR1cm4gc2ltcGxpZmllZE9mZnNldDtcbiAgICB9XG4gIH0gd2hpbGUgKHgyID09IHgxICYmIHkyID09IHkxKTtcbiAgd2hpbGUgKG9mZnNldCA8IGVuZCkge1xuICAgIC8vIHNuYXAgdGhlIG5leHQgY29vcmRpbmF0ZSAoUDMpXG4gICAgdmFyIHgzID0gc25hcChmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XSwgdG9sZXJhbmNlKTtcbiAgICB2YXIgeTMgPSBzbmFwKGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXSwgdG9sZXJhbmNlKTtcbiAgICBvZmZzZXQgKz0gc3RyaWRlO1xuICAgIC8vIHNraXAgUDMgaWYgaXQgaXMgZXF1YWwgdG8gUDJcbiAgICBpZiAoeDMgPT0geDIgJiYgeTMgPT0geTIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBjYWxjdWxhdGUgdGhlIGRlbHRhIGJldHdlZW4gUDEgYW5kIFAyXG4gICAgdmFyIGR4MSA9IHgyIC0geDE7XG4gICAgdmFyIGR5MSA9IHkyIC0geTE7XG4gICAgLy8gY2FsY3VsYXRlIHRoZSBkZWx0YSBiZXR3ZWVuIFAzIGFuZCBQMVxuICAgIHZhciBkeDIgPSB4MyAtIHgxO1xuICAgIHZhciBkeTIgPSB5MyAtIHkxO1xuICAgIC8vIGlmIFAxLCBQMiwgYW5kIFAzIGFyZSBjb2xpbmVhciBhbmQgUDMgaXMgZnVydGhlciBmcm9tIFAxIHRoYW4gUDIgaXMgZnJvbVxuICAgIC8vIFAxIGluIHRoZSBzYW1lIGRpcmVjdGlvbiB0aGVuIFAyIGlzIG9uIHRoZSBzdHJhaWdodCBsaW5lIGJldHdlZW4gUDEgYW5kXG4gICAgLy8gUDNcbiAgICBpZiAoKGR4MSAqIGR5MiA9PSBkeTEgKiBkeDIpICYmXG4gICAgICAgICgoZHgxIDwgMCAmJiBkeDIgPCBkeDEpIHx8IGR4MSA9PSBkeDIgfHwgKGR4MSA+IDAgJiYgZHgyID4gZHgxKSkgJiZcbiAgICAgICAgKChkeTEgPCAwICYmIGR5MiA8IGR5MSkgfHwgZHkxID09IGR5MiB8fCAoZHkxID4gMCAmJiBkeTIgPiBkeTEpKSkge1xuICAgICAgLy8gZGlzY2FyZCBQMiBhbmQgc2V0IFAyID0gUDNcbiAgICAgIHgyID0geDM7XG4gICAgICB5MiA9IHkzO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIGVpdGhlciBQMSwgUDIsIGFuZCBQMyBhcmUgbm90IGNvbGluZWFyLCBvciB0aGV5IGFyZSBjb2xpbmVhciBidXQgUDMgaXNcbiAgICAvLyBiZXR3ZWVuIFAzIGFuZCBQMSBvciBvbiB0aGUgb3Bwb3NpdGUgaGFsZiBvZiB0aGUgbGluZSB0byBQMi4gIGFkZCBQMixcbiAgICAvLyBhbmQgY29udGludWUgd2l0aCBQMSA9IFAyIGFuZCBQMiA9IFAzXG4gICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID0geDI7XG4gICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID0geTI7XG4gICAgeDEgPSB4MjtcbiAgICB5MSA9IHkyO1xuICAgIHgyID0geDM7XG4gICAgeTIgPSB5MztcbiAgfVxuICAvLyBhZGQgdGhlIGxhc3QgcG9pbnQgKFAyKVxuICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPSB4MjtcbiAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID0geTI7XG4gIHJldHVybiBzaW1wbGlmaWVkT2Zmc2V0O1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbmRzIEVuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b2xlcmFuY2UgVG9sZXJhbmNlLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzIFNpbXBsaWZpZWQgZmxhdFxuICogICAgIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IHNpbXBsaWZpZWRPZmZzZXQgU2ltcGxpZmllZCBvZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHNpbXBsaWZpZWRFbmRzIFNpbXBsaWZpZWQgZW5kcy5cbiAqIEByZXR1cm4ge251bWJlcn0gU2ltcGxpZmllZCBvZmZzZXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWFudGl6ZUFycmF5KFxuICBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlLFxuICB0b2xlcmFuY2UsXG4gIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsIHNpbXBsaWZpZWRPZmZzZXQsIHNpbXBsaWZpZWRFbmRzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IGVuZHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIHZhciBlbmQgPSBlbmRzW2ldO1xuICAgIHNpbXBsaWZpZWRPZmZzZXQgPSBxdWFudGl6ZShcbiAgICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSxcbiAgICAgIHRvbGVyYW5jZSxcbiAgICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsIHNpbXBsaWZpZWRPZmZzZXQpO1xuICAgIHNpbXBsaWZpZWRFbmRzLnB1c2goc2ltcGxpZmllZE9mZnNldCk7XG4gICAgb2Zmc2V0ID0gZW5kO1xuICB9XG4gIHJldHVybiBzaW1wbGlmaWVkT2Zmc2V0O1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gZW5kc3MgRW5kc3MuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b2xlcmFuY2UgVG9sZXJhbmNlLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzIFNpbXBsaWZpZWQgZmxhdFxuICogICAgIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IHNpbXBsaWZpZWRPZmZzZXQgU2ltcGxpZmllZCBvZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBzaW1wbGlmaWVkRW5kc3MgU2ltcGxpZmllZCBlbmRzcy5cbiAqIEByZXR1cm4ge251bWJlcn0gU2ltcGxpZmllZCBvZmZzZXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWFudGl6ZU11bHRpQXJyYXkoXG4gIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzcywgc3RyaWRlLFxuICB0b2xlcmFuY2UsXG4gIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsIHNpbXBsaWZpZWRPZmZzZXQsIHNpbXBsaWZpZWRFbmRzcykge1xuICBmb3IgKHZhciBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgdmFyIGVuZHMgPSBlbmRzc1tpXTtcbiAgICB2YXIgc2ltcGxpZmllZEVuZHMgPSBbXTtcbiAgICBzaW1wbGlmaWVkT2Zmc2V0ID0gcXVhbnRpemVBcnJheShcbiAgICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLCBzdHJpZGUsXG4gICAgICB0b2xlcmFuY2UsXG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLCBzaW1wbGlmaWVkT2Zmc2V0LCBzaW1wbGlmaWVkRW5kcyk7XG4gICAgc2ltcGxpZmllZEVuZHNzLnB1c2goc2ltcGxpZmllZEVuZHMpO1xuICAgIG9mZnNldCA9IGVuZHNbZW5kcy5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gc2ltcGxpZmllZE9mZnNldDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2ltcGxpZnkuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9zdHJhaWdodGNodW5rXG4gKi9cblxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhBbmdsZSBNYXhpbXVtIGFjY2VwdGFibGUgYW5nbGUgZGVsdGEgYmV0d2VlbiBzZWdtZW50cy5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBTdGFydCBhbmQgZW5kIG9mIHRoZSBmaXJzdCBzdWl0YWJsZSBjaHVuayBvZiB0aGVcbiAqIGdpdmVuIGBmbGF0Q29vcmRpbmF0ZXNgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0Y2hpbmdDaHVuayhtYXhBbmdsZSwgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKSB7XG4gIHZhciBjaHVua1N0YXJ0ID0gb2Zmc2V0O1xuICB2YXIgY2h1bmtFbmQgPSBvZmZzZXQ7XG4gIHZhciBjaHVua00gPSAwO1xuICB2YXIgbSA9IDA7XG4gIHZhciBzdGFydCA9IG9mZnNldDtcbiAgdmFyIGFjb3MsIGksIG0xMiwgbTIzLCB4MSwgeTEsIHgxMiwgeTEyLCB4MjMsIHkyMztcbiAgZm9yIChpID0gb2Zmc2V0OyBpIDwgZW5kOyBpICs9IHN0cmlkZSkge1xuICAgIHZhciB4MiA9IGZsYXRDb29yZGluYXRlc1tpXTtcbiAgICB2YXIgeTIgPSBmbGF0Q29vcmRpbmF0ZXNbaSArIDFdO1xuICAgIGlmICh4MSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB4MjMgPSB4MiAtIHgxO1xuICAgICAgeTIzID0geTIgLSB5MTtcbiAgICAgIG0yMyA9IE1hdGguc3FydCh4MjMgKiB4MjMgKyB5MjMgKiB5MjMpO1xuICAgICAgaWYgKHgxMiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG0gKz0gbTEyO1xuICAgICAgICBhY29zID0gTWF0aC5hY29zKCh4MTIgKiB4MjMgKyB5MTIgKiB5MjMpIC8gKG0xMiAqIG0yMykpO1xuICAgICAgICBpZiAoYWNvcyA+IG1heEFuZ2xlKSB7XG4gICAgICAgICAgaWYgKG0gPiBjaHVua00pIHtcbiAgICAgICAgICAgIGNodW5rTSA9IG07XG4gICAgICAgICAgICBjaHVua1N0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICBjaHVua0VuZCA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG0gPSAwO1xuICAgICAgICAgIHN0YXJ0ID0gaSAtIHN0cmlkZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbTEyID0gbTIzO1xuICAgICAgeDEyID0geDIzO1xuICAgICAgeTEyID0geTIzO1xuICAgIH1cbiAgICB4MSA9IHgyO1xuICAgIHkxID0geTI7XG4gIH1cbiAgbSArPSBtMjM7XG4gIHJldHVybiBtID4gY2h1bmtNID8gW3N0YXJ0LCBpXSA6IFtjaHVua1N0YXJ0LCBjaHVua0VuZF07XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmFpZ2h0Y2h1bmsuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC90ZXh0cGF0aFxuICovXG5pbXBvcnQge2xlcnB9IGZyb20gJy4uLy4uL21hdGguanMnO1xuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgUGF0aCB0byBwdXQgdGV4dCBvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgU3RhcnQgb2Zmc2V0IG9mIHRoZSBgZmxhdENvb3JkaW5hdGVzYC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kIG9mZnNldCBvZiB0aGUgYGZsYXRDb29yZGluYXRlc2AuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRleHQgdG8gcGxhY2Ugb24gdGhlIHBhdGguXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZyk6bnVtYmVyfSBtZWFzdXJlIE1lYXN1cmUgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZVxuICogd2lkdGggb2YgdGhlIGNoYXJhY3RlciBwYXNzZWQgYXMgMXN0IGFyZ3VtZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0TSBtIGFsb25nIHRoZSBwYXRoIHdoZXJlIHRoZSB0ZXh0IHN0YXJ0cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhBbmdsZSBNYXggYW5nbGUgYmV0d2VlbiBhZGphY2VudCBjaGFycyBpbiByYWRpYW5zLlxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8Kj4+fSBUaGUgcmVzdWx0IGFycmF5IG9mIG51bGwgaWYgYG1heEFuZ2xlYCB3YXNcbiAqIGV4Y2VlZGVkLiBFbnRyaWVzIG9mIHRoZSBhcnJheSBhcmUgeCwgeSwgYW5jaG9yWCwgYW5nbGUsIGNodW5rLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZHJhd1RleHRPblBhdGgoXG4gIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgdGV4dCwgbWVhc3VyZSwgc3RhcnRNLCBtYXhBbmdsZSkge1xuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgLy8gS2VlcCB0ZXh0IHVwcmlnaHRcbiAgdmFyIHJldmVyc2UgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XSA+IGZsYXRDb29yZGluYXRlc1tlbmQgLSBzdHJpZGVdO1xuXG4gIHZhciBudW1DaGFycyA9IHRleHQubGVuZ3RoO1xuXG4gIHZhciB4MSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXRdO1xuICB2YXIgeTEgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gIG9mZnNldCArPSBzdHJpZGU7XG4gIHZhciB4MiA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXRdO1xuICB2YXIgeTIgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gIHZhciBzZWdtZW50TSA9IDA7XG4gIHZhciBzZWdtZW50TGVuZ3RoID0gTWF0aC5zcXJ0KE1hdGgucG93KHgyIC0geDEsIDIpICsgTWF0aC5wb3coeTIgLSB5MSwgMikpO1xuXG4gIHZhciBjaHVuayA9ICcnO1xuICB2YXIgY2h1bmtMZW5ndGggPSAwO1xuICB2YXIgZGF0YSwgaW5kZXgsIHByZXZpb3VzQW5nbGU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtQ2hhcnM7ICsraSkge1xuICAgIGluZGV4ID0gcmV2ZXJzZSA/IG51bUNoYXJzIC0gaSAtIDEgOiBpO1xuICAgIHZhciBjaGFyID0gdGV4dC5jaGFyQXQoaW5kZXgpO1xuICAgIGNodW5rID0gcmV2ZXJzZSA/IGNoYXIgKyBjaHVuayA6IGNodW5rICsgY2hhcjtcbiAgICB2YXIgY2hhckxlbmd0aCA9IG1lYXN1cmUoY2h1bmspIC0gY2h1bmtMZW5ndGg7XG4gICAgY2h1bmtMZW5ndGggKz0gY2hhckxlbmd0aDtcbiAgICB2YXIgY2hhck0gPSBzdGFydE0gKyBjaGFyTGVuZ3RoIC8gMjtcbiAgICB3aGlsZSAob2Zmc2V0IDwgZW5kIC0gc3RyaWRlICYmIHNlZ21lbnRNICsgc2VnbWVudExlbmd0aCA8IGNoYXJNKSB7XG4gICAgICB4MSA9IHgyO1xuICAgICAgeTEgPSB5MjtcbiAgICAgIG9mZnNldCArPSBzdHJpZGU7XG4gICAgICB4MiA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXRdO1xuICAgICAgeTIgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gICAgICBzZWdtZW50TSArPSBzZWdtZW50TGVuZ3RoO1xuICAgICAgc2VnbWVudExlbmd0aCA9IE1hdGguc3FydChNYXRoLnBvdyh4MiAtIHgxLCAyKSArIE1hdGgucG93KHkyIC0geTEsIDIpKTtcbiAgICB9XG4gICAgdmFyIHNlZ21lbnRQb3MgPSBjaGFyTSAtIHNlZ21lbnRNO1xuICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbjIoeTIgLSB5MSwgeDIgLSB4MSk7XG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIGFuZ2xlICs9IGFuZ2xlID4gMCA/IC1NYXRoLlBJIDogTWF0aC5QSTtcbiAgICB9XG4gICAgaWYgKHByZXZpb3VzQW5nbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGRlbHRhID0gYW5nbGUgLSBwcmV2aW91c0FuZ2xlO1xuICAgICAgZGVsdGEgKz0gKGRlbHRhID4gTWF0aC5QSSkgPyAtMiAqIE1hdGguUEkgOiAoZGVsdGEgPCAtTWF0aC5QSSkgPyAyICogTWF0aC5QSSA6IDA7XG4gICAgICBpZiAoTWF0aC5hYnMoZGVsdGEpID4gbWF4QW5nbGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBpbnRlcnBvbGF0ZSA9IHNlZ21lbnRQb3MgLyBzZWdtZW50TGVuZ3RoO1xuICAgIHZhciB4ID0gbGVycCh4MSwgeDIsIGludGVycG9sYXRlKTtcbiAgICB2YXIgeSA9IGxlcnAoeTEsIHkyLCBpbnRlcnBvbGF0ZSk7XG4gICAgaWYgKHByZXZpb3VzQW5nbGUgPT0gYW5nbGUpIHtcbiAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIGRhdGFbMF0gPSB4O1xuICAgICAgICBkYXRhWzFdID0geTtcbiAgICAgICAgZGF0YVsyXSA9IGNoYXJMZW5ndGggLyAyO1xuICAgICAgfVxuICAgICAgZGF0YVs0XSA9IGNodW5rO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaHVuayA9IGNoYXI7XG4gICAgICBjaHVua0xlbmd0aCA9IGNoYXJMZW5ndGg7XG4gICAgICBkYXRhID0gW3gsIHksIGNoYXJMZW5ndGggLyAyLCBhbmdsZSwgY2h1bmtdO1xuICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgcmVzdWx0LnVuc2hpZnQoZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQucHVzaChkYXRhKTtcbiAgICAgIH1cbiAgICAgIHByZXZpb3VzQW5nbGUgPSBhbmdsZTtcbiAgICB9XG4gICAgc3RhcnRNICs9IGNoYXJMZW5ndGg7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGV4dHBhdGguanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC90cmFuc2Zvcm1cbiAqL1xuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPj19IG9wdF9kZXN0IERlc3RpbmF0aW9uLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVHJhbnNmb3JtZWQgY29vcmRpbmF0ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm0yRChmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIHRyYW5zZm9ybSwgb3B0X2Rlc3QpIHtcbiAgdmFyIGRlc3QgPSBvcHRfZGVzdCA/IG9wdF9kZXN0IDogW107XG4gIHZhciBpID0gMDtcbiAgZm9yICh2YXIgaiA9IG9mZnNldDsgaiA8IGVuZDsgaiArPSBzdHJpZGUpIHtcbiAgICB2YXIgeCA9IGZsYXRDb29yZGluYXRlc1tqXTtcbiAgICB2YXIgeSA9IGZsYXRDb29yZGluYXRlc1tqICsgMV07XG4gICAgZGVzdFtpKytdID0gdHJhbnNmb3JtWzBdICogeCArIHRyYW5zZm9ybVsyXSAqIHkgKyB0cmFuc2Zvcm1bNF07XG4gICAgZGVzdFtpKytdID0gdHJhbnNmb3JtWzFdICogeCArIHRyYW5zZm9ybVszXSAqIHkgKyB0cmFuc2Zvcm1bNV07XG4gIH1cbiAgaWYgKG9wdF9kZXN0ICYmIGRlc3QubGVuZ3RoICE9IGkpIHtcbiAgICBkZXN0Lmxlbmd0aCA9IGk7XG4gIH1cbiAgcmV0dXJuIGRlc3Q7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlIEFuZ2xlLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBhbmNob3IgUm90YXRpb24gYW5jaG9yIHBvaW50LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+PX0gb3B0X2Rlc3QgRGVzdGluYXRpb24uXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUcmFuc2Zvcm1lZCBjb29yZGluYXRlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIGFuZ2xlLCBhbmNob3IsIG9wdF9kZXN0KSB7XG4gIHZhciBkZXN0ID0gb3B0X2Rlc3QgPyBvcHRfZGVzdCA6IFtdO1xuICB2YXIgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xuICB2YXIgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuICB2YXIgYW5jaG9yWCA9IGFuY2hvclswXTtcbiAgdmFyIGFuY2hvclkgPSBhbmNob3JbMV07XG4gIHZhciBpID0gMDtcbiAgZm9yICh2YXIgaiA9IG9mZnNldDsgaiA8IGVuZDsgaiArPSBzdHJpZGUpIHtcbiAgICB2YXIgZGVsdGFYID0gZmxhdENvb3JkaW5hdGVzW2pdIC0gYW5jaG9yWDtcbiAgICB2YXIgZGVsdGFZID0gZmxhdENvb3JkaW5hdGVzW2ogKyAxXSAtIGFuY2hvclk7XG4gICAgZGVzdFtpKytdID0gYW5jaG9yWCArIGRlbHRhWCAqIGNvcyAtIGRlbHRhWSAqIHNpbjtcbiAgICBkZXN0W2krK10gPSBhbmNob3JZICsgZGVsdGFYICogc2luICsgZGVsdGFZICogY29zO1xuICAgIGZvciAodmFyIGsgPSBqICsgMjsgayA8IGogKyBzdHJpZGU7ICsraykge1xuICAgICAgZGVzdFtpKytdID0gZmxhdENvb3JkaW5hdGVzW2tdO1xuICAgIH1cbiAgfVxuICBpZiAob3B0X2Rlc3QgJiYgZGVzdC5sZW5ndGggIT0gaSkge1xuICAgIGRlc3QubGVuZ3RoID0gaTtcbiAgfVxuICByZXR1cm4gZGVzdDtcbn1cblxuXG4vKipcbiAqIFNjYWxlIHRoZSBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gc3ggU2NhbGUgZmFjdG9yIGluIHRoZSB4LWRpcmVjdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzeSBTY2FsZSBmYWN0b3IgaW4gdGhlIHktZGlyZWN0aW9uLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBhbmNob3IgU2NhbGUgYW5jaG9yIHBvaW50LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+PX0gb3B0X2Rlc3QgRGVzdGluYXRpb24uXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUcmFuc2Zvcm1lZCBjb29yZGluYXRlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgc3gsIHN5LCBhbmNob3IsIG9wdF9kZXN0KSB7XG4gIHZhciBkZXN0ID0gb3B0X2Rlc3QgPyBvcHRfZGVzdCA6IFtdO1xuICB2YXIgYW5jaG9yWCA9IGFuY2hvclswXTtcbiAgdmFyIGFuY2hvclkgPSBhbmNob3JbMV07XG4gIHZhciBpID0gMDtcbiAgZm9yICh2YXIgaiA9IG9mZnNldDsgaiA8IGVuZDsgaiArPSBzdHJpZGUpIHtcbiAgICB2YXIgZGVsdGFYID0gZmxhdENvb3JkaW5hdGVzW2pdIC0gYW5jaG9yWDtcbiAgICB2YXIgZGVsdGFZID0gZmxhdENvb3JkaW5hdGVzW2ogKyAxXSAtIGFuY2hvclk7XG4gICAgZGVzdFtpKytdID0gYW5jaG9yWCArIHN4ICogZGVsdGFYO1xuICAgIGRlc3RbaSsrXSA9IGFuY2hvclkgKyBzeSAqIGRlbHRhWTtcbiAgICBmb3IgKHZhciBrID0gaiArIDI7IGsgPCBqICsgc3RyaWRlOyArK2spIHtcbiAgICAgIGRlc3RbaSsrXSA9IGZsYXRDb29yZGluYXRlc1trXTtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdF9kZXN0ICYmIGRlc3QubGVuZ3RoICE9IGkpIHtcbiAgICBkZXN0Lmxlbmd0aCA9IGk7XG4gIH1cbiAgcmV0dXJuIGRlc3Q7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhWCBEZWx0YSBYLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhWSBEZWx0YSBZLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+PX0gb3B0X2Rlc3QgRGVzdGluYXRpb24uXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUcmFuc2Zvcm1lZCBjb29yZGluYXRlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIGRlbHRhWCwgZGVsdGFZLCBvcHRfZGVzdCkge1xuICB2YXIgZGVzdCA9IG9wdF9kZXN0ID8gb3B0X2Rlc3QgOiBbXTtcbiAgdmFyIGkgPSAwO1xuICBmb3IgKHZhciBqID0gb2Zmc2V0OyBqIDwgZW5kOyBqICs9IHN0cmlkZSkge1xuICAgIGRlc3RbaSsrXSA9IGZsYXRDb29yZGluYXRlc1tqXSArIGRlbHRhWDtcbiAgICBkZXN0W2krK10gPSBmbGF0Q29vcmRpbmF0ZXNbaiArIDFdICsgZGVsdGFZO1xuICAgIGZvciAodmFyIGsgPSBqICsgMjsgayA8IGogKyBzdHJpZGU7ICsraykge1xuICAgICAgZGVzdFtpKytdID0gZmxhdENvb3JkaW5hdGVzW2tdO1xuICAgIH1cbiAgfVxuICBpZiAob3B0X2Rlc3QgJiYgZGVzdC5sZW5ndGggIT0gaSkge1xuICAgIGRlc3QubGVuZ3RoID0gaTtcbiAgfVxuICByZXR1cm4gZGVzdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNmb3JtLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9oYXNcbiAqL1xuXG52YXIgdWEgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyA/XG4gIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSA6ICcnO1xuXG4vKipcbiAqIFVzZXIgYWdlbnQgc3RyaW5nIHNheXMgd2UgYXJlIGRlYWxpbmcgd2l0aCBGaXJlZm94IGFzIGJyb3dzZXIuXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IHZhciBGSVJFRk9YID0gdWEuaW5kZXhPZignZmlyZWZveCcpICE9PSAtMTtcblxuLyoqXG4gKiBVc2VyIGFnZW50IHN0cmluZyBzYXlzIHdlIGFyZSBkZWFsaW5nIHdpdGggU2FmYXJpIGFzIGJyb3dzZXIuXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IHZhciBTQUZBUkkgPSB1YS5pbmRleE9mKCdzYWZhcmknKSAhPT0gLTEgJiYgdWEuaW5kZXhPZignY2hyb20nKSA9PSAtMTtcblxuLyoqXG4gKiBVc2VyIGFnZW50IHN0cmluZyBzYXlzIHdlIGFyZSBkZWFsaW5nIHdpdGggYSBXZWJLaXQgZW5naW5lLlxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCB2YXIgV0VCS0lUID0gdWEuaW5kZXhPZignd2Via2l0JykgIT09IC0xICYmIHVhLmluZGV4T2YoJ2VkZ2UnKSA9PSAtMTtcblxuLyoqXG4gKiBVc2VyIGFnZW50IHN0cmluZyBzYXlzIHdlIGFyZSBkZWFsaW5nIHdpdGggYSBNYWMgYXMgcGxhdGZvcm0uXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IHZhciBNQUMgPSB1YS5pbmRleE9mKCdtYWNpbnRvc2gnKSAhPT0gLTE7XG5cblxuLyoqXG4gKiBUaGUgcmF0aW8gYmV0d2VlbiBwaHlzaWNhbCBwaXhlbHMgYW5kIGRldmljZS1pbmRlcGVuZGVudCBwaXhlbHNcbiAqIChkaXBzKSBvbiB0aGUgZGV2aWNlIChgd2luZG93LmRldmljZVBpeGVsUmF0aW9gKS5cbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IHZhciBERVZJQ0VfUElYRUxfUkFUSU8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuXG5cbi8qKlxuICogVHJ1ZSBpZiB0aGUgYnJvd3NlcidzIENhbnZhcyBpbXBsZW1lbnRhdGlvbiBpbXBsZW1lbnRzIHtnZXQsc2V0fUxpbmVEYXNoLlxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCB2YXIgQ0FOVkFTX0xJTkVfREFTSCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaGFzID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgaGFzID0gISFkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0KCcyZCcpLnNldExpbmVEYXNoO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gcGFzc1xuICB9XG4gIHJldHVybiBoYXM7XG59KCk7XG5cblxuLyoqXG4gKiBJcyBIVE1MNSBnZW9sb2NhdGlvbiBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgYnJvd3Nlcj9cbiAqIEBjb25zdFxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAYXBpXG4gKi9cbmV4cG9ydCB2YXIgR0VPTE9DQVRJT04gPSAnZ2VvbG9jYXRpb24nIGluIG5hdmlnYXRvcjtcblxuXG4vKipcbiAqIFRydWUgaWYgYnJvd3NlciBzdXBwb3J0cyB0b3VjaCBldmVudHMuXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGFwaVxuICovXG5leHBvcnQgdmFyIFRPVUNIID0gJ29udG91Y2hzdGFydCcgaW4gd2luZG93O1xuXG5cbi8qKlxuICogVHJ1ZSBpZiBicm93c2VyIHN1cHBvcnRzIHBvaW50ZXIgZXZlbnRzLlxuICogQGNvbnN0XG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IHZhciBQT0lOVEVSID0gJ1BvaW50ZXJFdmVudCcgaW4gd2luZG93O1xuXG5cbi8qKlxuICogVHJ1ZSBpZiBicm93c2VyIHN1cHBvcnRzIG1zIHBvaW50ZXIgZXZlbnRzIChJRSAxMCkuXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5leHBvcnQgdmFyIE1TUE9JTlRFUiA9ICEhKG5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkKTtcblxuXG5leHBvcnQge0hBUyBhcyBXRUJHTH0gZnJvbSAnLi93ZWJnbC5qcyc7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhcy5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb25cbiAqL1xuaW1wb3J0IENvbGxlY3Rpb24gZnJvbSAnLi9Db2xsZWN0aW9uLmpzJztcbmltcG9ydCBLaW5ldGljIGZyb20gJy4vS2luZXRpYy5qcyc7XG5pbXBvcnQgRG91YmxlQ2xpY2tab29tIGZyb20gJy4vaW50ZXJhY3Rpb24vRG91YmxlQ2xpY2tab29tLmpzJztcbmltcG9ydCBEcmFnUGFuIGZyb20gJy4vaW50ZXJhY3Rpb24vRHJhZ1Bhbi5qcyc7XG5pbXBvcnQgRHJhZ1JvdGF0ZSBmcm9tICcuL2ludGVyYWN0aW9uL0RyYWdSb3RhdGUuanMnO1xuaW1wb3J0IERyYWdab29tIGZyb20gJy4vaW50ZXJhY3Rpb24vRHJhZ1pvb20uanMnO1xuaW1wb3J0IEtleWJvYXJkUGFuIGZyb20gJy4vaW50ZXJhY3Rpb24vS2V5Ym9hcmRQYW4uanMnO1xuaW1wb3J0IEtleWJvYXJkWm9vbSBmcm9tICcuL2ludGVyYWN0aW9uL0tleWJvYXJkWm9vbS5qcyc7XG5pbXBvcnQgTW91c2VXaGVlbFpvb20gZnJvbSAnLi9pbnRlcmFjdGlvbi9Nb3VzZVdoZWVsWm9vbS5qcyc7XG5pbXBvcnQgUGluY2hSb3RhdGUgZnJvbSAnLi9pbnRlcmFjdGlvbi9QaW5jaFJvdGF0ZS5qcyc7XG5pbXBvcnQgUGluY2hab29tIGZyb20gJy4vaW50ZXJhY3Rpb24vUGluY2hab29tLmpzJztcbmltcG9ydCB7Zm9jdXN9IGZyb20gJy4vZXZlbnRzL2NvbmRpdGlvbi5qcyc7XG5cbmV4cG9ydCB7ZGVmYXVsdCBhcyBEb3VibGVDbGlja1pvb219IGZyb20gJy4vaW50ZXJhY3Rpb24vRG91YmxlQ2xpY2tab29tLmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBEcmFnQW5kRHJvcH0gZnJvbSAnLi9pbnRlcmFjdGlvbi9EcmFnQW5kRHJvcC5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgRHJhZ0JveH0gZnJvbSAnLi9pbnRlcmFjdGlvbi9EcmFnQm94LmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBEcmFnUGFufSBmcm9tICcuL2ludGVyYWN0aW9uL0RyYWdQYW4uanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIERyYWdSb3RhdGV9IGZyb20gJy4vaW50ZXJhY3Rpb24vRHJhZ1JvdGF0ZS5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgRHJhZ1JvdGF0ZUFuZFpvb219IGZyb20gJy4vaW50ZXJhY3Rpb24vRHJhZ1JvdGF0ZUFuZFpvb20uanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIERyYWdab29tfSBmcm9tICcuL2ludGVyYWN0aW9uL0RyYWdab29tLmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBEcmF3fSBmcm9tICcuL2ludGVyYWN0aW9uL0RyYXcuanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEV4dGVudH0gZnJvbSAnLi9pbnRlcmFjdGlvbi9FeHRlbnQuanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEludGVyYWN0aW9ufSBmcm9tICcuL2ludGVyYWN0aW9uL0ludGVyYWN0aW9uLmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBLZXlib2FyZFBhbn0gZnJvbSAnLi9pbnRlcmFjdGlvbi9LZXlib2FyZFBhbi5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgS2V5Ym9hcmRab29tfSBmcm9tICcuL2ludGVyYWN0aW9uL0tleWJvYXJkWm9vbS5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgTW9kaWZ5fSBmcm9tICcuL2ludGVyYWN0aW9uL01vZGlmeS5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgTW91c2VXaGVlbFpvb219IGZyb20gJy4vaW50ZXJhY3Rpb24vTW91c2VXaGVlbFpvb20uanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFBpbmNoUm90YXRlfSBmcm9tICcuL2ludGVyYWN0aW9uL1BpbmNoUm90YXRlLmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBQaW5jaFpvb219IGZyb20gJy4vaW50ZXJhY3Rpb24vUGluY2hab29tLmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBQb2ludGVyfSBmcm9tICcuL2ludGVyYWN0aW9uL1BvaW50ZXIuanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFNlbGVjdH0gZnJvbSAnLi9pbnRlcmFjdGlvbi9TZWxlY3QuanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFNuYXB9IGZyb20gJy4vaW50ZXJhY3Rpb24vU25hcC5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgVHJhbnNsYXRlfSBmcm9tICcuL2ludGVyYWN0aW9uL1RyYW5zbGF0ZS5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEZWZhdWx0c09wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2FsdFNoaWZ0RHJhZ1JvdGF0ZT10cnVlXSBXaGV0aGVyIEFsdC1TaGlmdC1kcmFnIHJvdGF0ZSBpc1xuICogZGVzaXJlZC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW29uRm9jdXNPbmx5PWZhbHNlXSBJbnRlcmFjdCBvbmx5IHdoZW4gdGhlIG1hcCBoYXMgdGhlXG4gKiBmb2N1cy4gVGhpcyBhZmZlY3RzIHRoZSBgTW91c2VXaGVlbFpvb21gIGFuZCBgRHJhZ1BhbmAgaW50ZXJhY3Rpb25zIGFuZCBpc1xuICogdXNlZnVsIHdoZW4gcGFnZSBzY3JvbGwgaXMgZGVzaXJlZCBmb3IgbWFwcyB0aGF0IGRvIG5vdCBoYXZlIHRoZSBicm93c2VyJ3NcbiAqIGZvY3VzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbY29uc3RyYWluUmVzb2x1dGlvbj1mYWxzZV0gWm9vbSB0byB0aGUgY2xvc2VzdCBpbnRlZ2VyXG4gKiB6b29tIGxldmVsIGFmdGVyIHRoZSB3aGVlbC90cmFja3BhZCBvciBwaW5jaCBnZXN0dXJlIGVuZHMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtkb3VibGVDbGlja1pvb209dHJ1ZV0gV2hldGhlciBkb3VibGUgY2xpY2sgem9vbSBpc1xuICogZGVzaXJlZC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2tleWJvYXJkPXRydWVdIFdoZXRoZXIga2V5Ym9hcmQgaW50ZXJhY3Rpb24gaXMgZGVzaXJlZC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW21vdXNlV2hlZWxab29tPXRydWVdIFdoZXRoZXIgbW91c2V3aGVlbCB6b29tIGlzIGRlc2lyZWQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtzaGlmdERyYWdab29tPXRydWVdIFdoZXRoZXIgU2hpZnQtZHJhZyB6b29tIGlzIGRlc2lyZWQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtkcmFnUGFuPXRydWVdIFdoZXRoZXIgZHJhZyBwYW4gaXMgZGVzaXJlZC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3BpbmNoUm90YXRlPXRydWVdIFdoZXRoZXIgcGluY2ggcm90YXRlIGlzIGRlc2lyZWQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtwaW5jaFpvb209dHJ1ZV0gV2hldGhlciBwaW5jaCB6b29tIGlzIGRlc2lyZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3pvb21EZWx0YV0gWm9vbSBsZXZlbCBkZWx0YSB3aGVuIHVzaW5nIGtleWJvYXJkIG9yXG4gKiBtb3VzZXdoZWVsIHpvb20uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3pvb21EdXJhdGlvbl0gRHVyYXRpb24gb2YgdGhlIHpvb20gYW5pbWF0aW9uIGluXG4gKiBtaWxsaXNlY29uZHMuXG4gKi9cblxuXG4vKipcbiAqIFNldCBvZiBpbnRlcmFjdGlvbnMgaW5jbHVkZWQgaW4gbWFwcyBieSBkZWZhdWx0LiBTcGVjaWZpYyBpbnRlcmFjdGlvbnMgY2FuIGJlXG4gKiBleGNsdWRlZCBieSBzZXR0aW5nIHRoZSBhcHByb3ByaWF0ZSBvcHRpb24gdG8gZmFsc2UgaW4gdGhlIGNvbnN0cnVjdG9yXG4gKiBvcHRpb25zLCBidXQgdGhlIG9yZGVyIG9mIHRoZSBpbnRlcmFjdGlvbnMgaXMgZml4ZWQuICBJZiB5b3Ugd2FudCB0byBzcGVjaWZ5XG4gKiBhIGRpZmZlcmVudCBvcmRlciBmb3IgaW50ZXJhY3Rpb25zLCB5b3Ugd2lsbCBuZWVkIHRvIGNyZWF0ZSB5b3VyIG93blxuICoge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbn0gaW5zdGFuY2VzIGFuZCBpbnNlcnRcbiAqIHRoZW0gaW50byBhIHtAbGluayBtb2R1bGU6b2wvQ29sbGVjdGlvbn0gaW4gdGhlIG9yZGVyIHlvdSB3YW50XG4gKiBiZWZvcmUgY3JlYXRpbmcgeW91ciB7QGxpbmsgbW9kdWxlOm9sL01hcH5NYXB9IGluc3RhbmNlLiBUaGUgZGVmYXVsdCBzZXQgb2ZcbiAqIGludGVyYWN0aW9ucywgaW4gc2VxdWVuY2UsIGlzOlxuICogKiB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL0RyYWdSb3RhdGV+RHJhZ1JvdGF0ZX1cbiAqICoge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9Eb3VibGVDbGlja1pvb21+RG91YmxlQ2xpY2tab29tfVxuICogKiB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL0RyYWdQYW5+RHJhZ1Bhbn1cbiAqICoge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9QaW5jaFJvdGF0ZX5QaW5jaFJvdGF0ZX1cbiAqICoge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9QaW5jaFpvb21+UGluY2hab29tfVxuICogKiB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL0tleWJvYXJkUGFufktleWJvYXJkUGFufVxuICogKiB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL0tleWJvYXJkWm9vbX5LZXlib2FyZFpvb219XG4gKiAqIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vTW91c2VXaGVlbFpvb21+TW91c2VXaGVlbFpvb219XG4gKiAqIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vRHJhZ1pvb21+RHJhZ1pvb219XG4gKlxuICogQHBhcmFtIHtEZWZhdWx0c09wdGlvbnM9fSBvcHRfb3B0aW9ucyBEZWZhdWx0cyBvcHRpb25zLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9Db2xsZWN0aW9uLmpzXCIpLmRlZmF1bHQ8aW1wb3J0KFwiLi9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbi5qc1wiKS5kZWZhdWx0Pn1cbiAqIEEgY29sbGVjdGlvbiBvZiBpbnRlcmFjdGlvbnMgdG8gYmUgdXNlZCB3aXRoIHRoZSB7QGxpbmsgbW9kdWxlOm9sL01hcH5NYXB9XG4gKiBjb25zdHJ1Y3RvcidzIGBpbnRlcmFjdGlvbnNgIG9wdGlvbi5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRzKG9wdF9vcHRpb25zKSB7XG5cbiAgdmFyIG9wdGlvbnMgPSBvcHRfb3B0aW9ucyA/IG9wdF9vcHRpb25zIDoge307XG5cbiAgdmFyIGludGVyYWN0aW9ucyA9IG5ldyBDb2xsZWN0aW9uKCk7XG5cbiAgdmFyIGtpbmV0aWMgPSBuZXcgS2luZXRpYygtMC4wMDUsIDAuMDUsIDEwMCk7XG5cbiAgdmFyIGFsdFNoaWZ0RHJhZ1JvdGF0ZSA9IG9wdGlvbnMuYWx0U2hpZnREcmFnUm90YXRlICE9PSB1bmRlZmluZWQgP1xuICAgIG9wdGlvbnMuYWx0U2hpZnREcmFnUm90YXRlIDogdHJ1ZTtcbiAgaWYgKGFsdFNoaWZ0RHJhZ1JvdGF0ZSkge1xuICAgIGludGVyYWN0aW9ucy5wdXNoKG5ldyBEcmFnUm90YXRlKCkpO1xuICB9XG5cbiAgdmFyIGRvdWJsZUNsaWNrWm9vbSA9IG9wdGlvbnMuZG91YmxlQ2xpY2tab29tICE9PSB1bmRlZmluZWQgP1xuICAgIG9wdGlvbnMuZG91YmxlQ2xpY2tab29tIDogdHJ1ZTtcbiAgaWYgKGRvdWJsZUNsaWNrWm9vbSkge1xuICAgIGludGVyYWN0aW9ucy5wdXNoKG5ldyBEb3VibGVDbGlja1pvb20oe1xuICAgICAgZGVsdGE6IG9wdGlvbnMuem9vbURlbHRhLFxuICAgICAgZHVyYXRpb246IG9wdGlvbnMuem9vbUR1cmF0aW9uXG4gICAgfSkpO1xuICB9XG5cbiAgdmFyIGRyYWdQYW4gPSBvcHRpb25zLmRyYWdQYW4gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHJhZ1BhbiA6IHRydWU7XG4gIGlmIChkcmFnUGFuKSB7XG4gICAgaW50ZXJhY3Rpb25zLnB1c2gobmV3IERyYWdQYW4oe1xuICAgICAgY29uZGl0aW9uOiBvcHRpb25zLm9uRm9jdXNPbmx5ID8gZm9jdXMgOiB1bmRlZmluZWQsXG4gICAgICBraW5ldGljOiBraW5ldGljXG4gICAgfSkpO1xuICB9XG5cbiAgdmFyIHBpbmNoUm90YXRlID0gb3B0aW9ucy5waW5jaFJvdGF0ZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5waW5jaFJvdGF0ZSA6XG4gICAgdHJ1ZTtcbiAgaWYgKHBpbmNoUm90YXRlKSB7XG4gICAgaW50ZXJhY3Rpb25zLnB1c2gobmV3IFBpbmNoUm90YXRlKCkpO1xuICB9XG5cbiAgdmFyIHBpbmNoWm9vbSA9IG9wdGlvbnMucGluY2hab29tICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnBpbmNoWm9vbSA6IHRydWU7XG4gIGlmIChwaW5jaFpvb20pIHtcbiAgICBpbnRlcmFjdGlvbnMucHVzaChuZXcgUGluY2hab29tKHtcbiAgICAgIGNvbnN0cmFpblJlc29sdXRpb246IG9wdGlvbnMuY29uc3RyYWluUmVzb2x1dGlvbixcbiAgICAgIGR1cmF0aW9uOiBvcHRpb25zLnpvb21EdXJhdGlvblxuICAgIH0pKTtcbiAgfVxuXG4gIHZhciBrZXlib2FyZCA9IG9wdGlvbnMua2V5Ym9hcmQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMua2V5Ym9hcmQgOiB0cnVlO1xuICBpZiAoa2V5Ym9hcmQpIHtcbiAgICBpbnRlcmFjdGlvbnMucHVzaChuZXcgS2V5Ym9hcmRQYW4oKSk7XG4gICAgaW50ZXJhY3Rpb25zLnB1c2gobmV3IEtleWJvYXJkWm9vbSh7XG4gICAgICBkZWx0YTogb3B0aW9ucy56b29tRGVsdGEsXG4gICAgICBkdXJhdGlvbjogb3B0aW9ucy56b29tRHVyYXRpb25cbiAgICB9KSk7XG4gIH1cblxuICB2YXIgbW91c2VXaGVlbFpvb20gPSBvcHRpb25zLm1vdXNlV2hlZWxab29tICE9PSB1bmRlZmluZWQgP1xuICAgIG9wdGlvbnMubW91c2VXaGVlbFpvb20gOiB0cnVlO1xuICBpZiAobW91c2VXaGVlbFpvb20pIHtcbiAgICBpbnRlcmFjdGlvbnMucHVzaChuZXcgTW91c2VXaGVlbFpvb20oe1xuICAgICAgY29uZGl0aW9uOiBvcHRpb25zLm9uRm9jdXNPbmx5ID8gZm9jdXMgOiB1bmRlZmluZWQsXG4gICAgICBjb25zdHJhaW5SZXNvbHV0aW9uOiBvcHRpb25zLmNvbnN0cmFpblJlc29sdXRpb24sXG4gICAgICBkdXJhdGlvbjogb3B0aW9ucy56b29tRHVyYXRpb25cbiAgICB9KSk7XG4gIH1cblxuICB2YXIgc2hpZnREcmFnWm9vbSA9IG9wdGlvbnMuc2hpZnREcmFnWm9vbSAhPT0gdW5kZWZpbmVkID9cbiAgICBvcHRpb25zLnNoaWZ0RHJhZ1pvb20gOiB0cnVlO1xuICBpZiAoc2hpZnREcmFnWm9vbSkge1xuICAgIGludGVyYWN0aW9ucy5wdXNoKG5ldyBEcmFnWm9vbSh7XG4gICAgICBkdXJhdGlvbjogb3B0aW9ucy56b29tRHVyYXRpb25cbiAgICB9KSk7XG4gIH1cblxuICByZXR1cm4gaW50ZXJhY3Rpb25zO1xuXG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyYWN0aW9uLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9Eb3VibGVDbGlja1pvb21cbiAqL1xuaW1wb3J0IE1hcEJyb3dzZXJFdmVudFR5cGUgZnJvbSAnLi4vTWFwQnJvd3NlckV2ZW50VHlwZS5qcyc7XG5pbXBvcnQgSW50ZXJhY3Rpb24sIHt6b29tQnlEZWx0YX0gZnJvbSAnLi9JbnRlcmFjdGlvbi5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2R1cmF0aW9uPTI1MF0gQW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZGVsdGE9MV0gVGhlIHpvb20gZGVsdGEgYXBwbGllZCBvbiBlYWNoIGRvdWJsZSBjbGljay5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWxsb3dzIHRoZSB1c2VyIHRvIHpvb20gYnkgZG91YmxlLWNsaWNraW5nIG9uIHRoZSBtYXAuXG4gKiBAYXBpXG4gKi9cbnZhciBEb3VibGVDbGlja1pvb20gPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChJbnRlcmFjdGlvbikge1xuICBmdW5jdGlvbiBEb3VibGVDbGlja1pvb20ob3B0X29wdGlvbnMpIHtcbiAgICBJbnRlcmFjdGlvbi5jYWxsKHRoaXMsIHtcbiAgICAgIGhhbmRsZUV2ZW50OiBoYW5kbGVFdmVudFxuICAgIH0pO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBvcHRfb3B0aW9ucyA/IG9wdF9vcHRpb25zIDoge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kZWx0YV8gPSBvcHRpb25zLmRlbHRhID8gb3B0aW9ucy5kZWx0YSA6IDE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kdXJhdGlvbl8gPSBvcHRpb25zLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmR1cmF0aW9uIDogMjUwO1xuXG4gIH1cblxuICBpZiAoIEludGVyYWN0aW9uICkgRG91YmxlQ2xpY2tab29tLl9fcHJvdG9fXyA9IEludGVyYWN0aW9uO1xuICBEb3VibGVDbGlja1pvb20ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSW50ZXJhY3Rpb24gJiYgSW50ZXJhY3Rpb24ucHJvdG90eXBlICk7XG4gIERvdWJsZUNsaWNrWm9vbS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEb3VibGVDbGlja1pvb207XG5cbiAgcmV0dXJuIERvdWJsZUNsaWNrWm9vbTtcbn0oSW50ZXJhY3Rpb24pKTtcblxuXG4vKipcbiAqIEhhbmRsZXMgdGhlIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50IG1hcCBicm93c2VyIGV2ZW50fSAoaWYgaXQgd2FzIGFcbiAqIGRvdWJsZWNsaWNrKSBhbmQgZXZlbnR1YWxseSB6b29tcyB0aGUgbWFwLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gYGZhbHNlYCB0byBzdG9wIGV2ZW50IHByb3BhZ2F0aW9uLlxuICogQHRoaXMge0RvdWJsZUNsaWNrWm9vbX1cbiAqL1xuZnVuY3Rpb24gaGFuZGxlRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gIHZhciBzdG9wRXZlbnQgPSBmYWxzZTtcbiAgaWYgKG1hcEJyb3dzZXJFdmVudC50eXBlID09IE1hcEJyb3dzZXJFdmVudFR5cGUuREJMQ0xJQ0spIHtcbiAgICB2YXIgYnJvd3NlckV2ZW50ID0gLyoqIEB0eXBlIHtNb3VzZUV2ZW50fSAqLyAobWFwQnJvd3NlckV2ZW50Lm9yaWdpbmFsRXZlbnQpO1xuICAgIHZhciBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuICAgIHZhciBhbmNob3IgPSBtYXBCcm93c2VyRXZlbnQuY29vcmRpbmF0ZTtcbiAgICB2YXIgZGVsdGEgPSBicm93c2VyRXZlbnQuc2hpZnRLZXkgPyAtdGhpcy5kZWx0YV8gOiB0aGlzLmRlbHRhXztcbiAgICB2YXIgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgem9vbUJ5RGVsdGEodmlldywgZGVsdGEsIGFuY2hvciwgdGhpcy5kdXJhdGlvbl8pO1xuICAgIG1hcEJyb3dzZXJFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHN0b3BFdmVudCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuICFzdG9wRXZlbnQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IERvdWJsZUNsaWNrWm9vbTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RG91YmxlQ2xpY2tab29tLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9EcmFnQW5kRHJvcFxuICovXG4vLyBGSVhNRSBzaG91bGQgaGFuZGxlIGFsbCBnZW8tcmVmZXJlbmNlZCBkYXRhLCBub3QganVzdCB2ZWN0b3IgZGF0YVxuXG5pbXBvcnQge1RSVUV9IGZyb20gJy4uL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQge2xpc3RlbiwgdW5saXN0ZW5CeUtleX0gZnJvbSAnLi4vZXZlbnRzLmpzJztcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMvRXZlbnQuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBJbnRlcmFjdGlvbiBmcm9tICcuL0ludGVyYWN0aW9uLmpzJztcbmltcG9ydCB7Z2V0IGFzIGdldFByb2plY3Rpb259IGZyb20gJy4uL3Byb2ouanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtBcnJheTx0eXBlb2YgaW1wb3J0KFwiLi4vZm9ybWF0L0ZlYXR1cmUuanNcIikuZGVmYXVsdD59IFtmb3JtYXRDb25zdHJ1Y3RvcnNdIEZvcm1hdCBjb25zdHJ1Y3RvcnMuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3NvdXJjZS9WZWN0b3IuanNcIikuZGVmYXVsdH0gW3NvdXJjZV0gT3B0aW9uYWwgdmVjdG9yIHNvdXJjZSB3aGVyZSBmZWF0dXJlcyB3aWxsIGJlIGFkZGVkLiAgSWYgYSBzb3VyY2UgaXMgcHJvdmlkZWRcbiAqIGFsbCBleGlzdGluZyBmZWF0dXJlcyB3aWxsIGJlIHJlbW92ZWQgYW5kIG5ldyBmZWF0dXJlcyB3aWxsIGJlIGFkZGVkIHdoZW5cbiAqIHRoZXkgYXJlIGRyb3BwZWQgb24gdGhlIHRhcmdldC4gIElmIHlvdSB3YW50IHRvIGFkZCBmZWF0dXJlcyB0byBhIHZlY3RvclxuICogc291cmNlIHdpdGhvdXQgcmVtb3ZpbmcgdGhlIGV4aXN0aW5nIGZlYXR1cmVzIChhcHBlbmQgb25seSksIGluc3RlYWQgb2ZcbiAqIHByb3ZpZGluZyB0aGUgc291cmNlIG9wdGlvbiBsaXN0ZW4gZm9yIHRoZSBcImFkZGZlYXR1cmVzXCIgZXZlbnQuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3Byb2ouanNcIikuUHJvamVjdGlvbkxpa2V9IFtwcm9qZWN0aW9uXSBUYXJnZXQgcHJvamVjdGlvbi4gQnkgZGVmYXVsdCwgdGhlIG1hcCdzIHZpZXcncyBwcm9qZWN0aW9uIGlzIHVzZWQuXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBbdGFyZ2V0XSBUaGUgZWxlbWVudCB0aGF0IGlzIHVzZWQgYXMgdGhlIGRyb3AgdGFyZ2V0LCBkZWZhdWx0IGlzIHRoZSB2aWV3cG9ydCBlbGVtZW50LlxuICovXG5cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG52YXIgRHJhZ0FuZERyb3BFdmVudFR5cGUgPSB7XG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiBmZWF0dXJlcyBhcmUgYWRkZWRcbiAgICogQGV2ZW50IERyYWdBbmREcm9wRXZlbnQjYWRkZmVhdHVyZXNcbiAgICogQGFwaVxuICAgKi9cbiAgQUREX0ZFQVRVUkVTOiAnYWRkZmVhdHVyZXMnXG59O1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogRXZlbnRzIGVtaXR0ZWQgYnkge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9EcmFnQW5kRHJvcH5EcmFnQW5kRHJvcH0gaW5zdGFuY2VzIGFyZSBpbnN0YW5jZXNcbiAqIG9mIHRoaXMgdHlwZS5cbiAqL1xudmFyIERyYWdBbmREcm9wRXZlbnQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChFdmVudCkge1xuICBmdW5jdGlvbiBEcmFnQW5kRHJvcEV2ZW50KHR5cGUsIGZpbGUsIG9wdF9mZWF0dXJlcywgb3B0X3Byb2plY3Rpb24pIHtcblxuICAgIEV2ZW50LmNhbGwodGhpcywgdHlwZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmVhdHVyZXMgcGFyc2VkIGZyb20gZHJvcHBlZCBkYXRhLlxuICAgICAqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlPnx1bmRlZmluZWR9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMuZmVhdHVyZXMgPSBvcHRfZmVhdHVyZXM7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZHJvcHBlZCBmaWxlLlxuICAgICAqIEB0eXBlIHtGaWxlfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLmZpbGUgPSBmaWxlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZlYXR1cmUgcHJvamVjdGlvbi5cbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR8dW5kZWZpbmVkfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLnByb2plY3Rpb24gPSBvcHRfcHJvamVjdGlvbjtcblxuICB9XG5cbiAgaWYgKCBFdmVudCApIERyYWdBbmREcm9wRXZlbnQuX19wcm90b19fID0gRXZlbnQ7XG4gIERyYWdBbmREcm9wRXZlbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXZlbnQgJiYgRXZlbnQucHJvdG90eXBlICk7XG4gIERyYWdBbmREcm9wRXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRHJhZ0FuZERyb3BFdmVudDtcblxuICByZXR1cm4gRHJhZ0FuZERyb3BFdmVudDtcbn0oRXZlbnQpKTtcblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEhhbmRsZXMgaW5wdXQgb2YgdmVjdG9yIGRhdGEgYnkgZHJhZyBhbmQgZHJvcC5cbiAqIEBhcGlcbiAqXG4gKiBAZmlyZXMgRHJhZ0FuZERyb3BFdmVudFxuICovXG52YXIgRHJhZ0FuZERyb3AgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChJbnRlcmFjdGlvbikge1xuICBmdW5jdGlvbiBEcmFnQW5kRHJvcChvcHRfb3B0aW9ucykge1xuXG4gICAgdmFyIG9wdGlvbnMgPSBvcHRfb3B0aW9ucyA/IG9wdF9vcHRpb25zIDoge307XG5cbiAgICBJbnRlcmFjdGlvbi5jYWxsKHRoaXMsIHtcbiAgICAgIGhhbmRsZUV2ZW50OiBUUlVFXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTx0eXBlb2YgaW1wb3J0KFwiLi4vZm9ybWF0L0ZlYXR1cmUuanNcIikuZGVmYXVsdD59XG4gICAgICovXG4gICAgdGhpcy5mb3JtYXRDb25zdHJ1Y3RvcnNfID0gb3B0aW9ucy5mb3JtYXRDb25zdHJ1Y3RvcnMgP1xuICAgICAgb3B0aW9ucy5mb3JtYXRDb25zdHJ1Y3RvcnMgOiBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMucHJvamVjdGlvbl8gPSBvcHRpb25zLnByb2plY3Rpb24gP1xuICAgICAgZ2V0UHJvamVjdGlvbihvcHRpb25zLnByb2plY3Rpb24pIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PGltcG9ydChcIi4uL2V2ZW50cy5qc1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMuZHJvcExpc3RlbktleXNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3NvdXJjZS9WZWN0b3IuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLnNvdXJjZV8gPSBvcHRpb25zLnNvdXJjZSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy50YXJnZXQgPSBvcHRpb25zLnRhcmdldCA/IG9wdGlvbnMudGFyZ2V0IDogbnVsbDtcblxuICB9XG5cbiAgaWYgKCBJbnRlcmFjdGlvbiApIERyYWdBbmREcm9wLl9fcHJvdG9fXyA9IEludGVyYWN0aW9uO1xuICBEcmFnQW5kRHJvcC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbnRlcmFjdGlvbiAmJiBJbnRlcmFjdGlvbi5wcm90b3R5cGUgKTtcbiAgRHJhZ0FuZERyb3AucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRHJhZ0FuZERyb3A7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RmlsZX0gZmlsZSBGaWxlLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBMb2FkIGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgRHJhZ0FuZERyb3AucHJvdG90eXBlLmhhbmRsZVJlc3VsdF8gPSBmdW5jdGlvbiBoYW5kbGVSZXN1bHRfIChmaWxlLCBldmVudCkge1xuICAgIHZhciByZXN1bHQgPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgIHZhciBtYXAgPSB0aGlzLmdldE1hcCgpO1xuICAgIHZhciBwcm9qZWN0aW9uID0gdGhpcy5wcm9qZWN0aW9uXztcbiAgICBpZiAoIXByb2plY3Rpb24pIHtcbiAgICAgIHZhciB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICAgIHByb2plY3Rpb24gPSB2aWV3LmdldFByb2plY3Rpb24oKTtcbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0Q29uc3RydWN0b3JzID0gdGhpcy5mb3JtYXRDb25zdHJ1Y3RvcnNfO1xuICAgIHZhciBmZWF0dXJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGZvcm1hdENvbnN0cnVjdG9ycy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB2YXIgZm9ybWF0ID0gbmV3IGZvcm1hdENvbnN0cnVjdG9yc1tpXSgpO1xuICAgICAgZmVhdHVyZXMgPSB0aGlzLnRyeVJlYWRGZWF0dXJlc18oZm9ybWF0LCByZXN1bHQsIHtcbiAgICAgICAgZmVhdHVyZVByb2plY3Rpb246IHByb2plY3Rpb25cbiAgICAgIH0pO1xuICAgICAgaWYgKGZlYXR1cmVzICYmIGZlYXR1cmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnNvdXJjZV8pIHtcbiAgICAgIHRoaXMuc291cmNlXy5jbGVhcigpO1xuICAgICAgdGhpcy5zb3VyY2VfLmFkZEZlYXR1cmVzKGZlYXR1cmVzKTtcbiAgICB9XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgbmV3IERyYWdBbmREcm9wRXZlbnQoXG4gICAgICAgIERyYWdBbmREcm9wRXZlbnRUeXBlLkFERF9GRUFUVVJFUywgZmlsZSxcbiAgICAgICAgZmVhdHVyZXMsIHByb2plY3Rpb24pKTtcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIERyYWdBbmREcm9wLnByb3RvdHlwZS5yZWdpc3Rlckxpc3RlbmVyc18gPSBmdW5jdGlvbiByZWdpc3Rlckxpc3RlbmVyc18gKCkge1xuICAgIHZhciBtYXAgPSB0aGlzLmdldE1hcCgpO1xuICAgIGlmIChtYXApIHtcbiAgICAgIHZhciBkcm9wQXJlYSA9IHRoaXMudGFyZ2V0ID8gdGhpcy50YXJnZXQgOiBtYXAuZ2V0Vmlld3BvcnQoKTtcbiAgICAgIHRoaXMuZHJvcExpc3RlbktleXNfID0gW1xuICAgICAgICBsaXN0ZW4oZHJvcEFyZWEsIEV2ZW50VHlwZS5EUk9QLCBoYW5kbGVEcm9wLCB0aGlzKSxcbiAgICAgICAgbGlzdGVuKGRyb3BBcmVhLCBFdmVudFR5cGUuRFJBR0VOVEVSLCBoYW5kbGVTdG9wLCB0aGlzKSxcbiAgICAgICAgbGlzdGVuKGRyb3BBcmVhLCBFdmVudFR5cGUuRFJBR09WRVIsIGhhbmRsZVN0b3AsIHRoaXMpLFxuICAgICAgICBsaXN0ZW4oZHJvcEFyZWEsIEV2ZW50VHlwZS5EUk9QLCBoYW5kbGVTdG9wLCB0aGlzKVxuICAgICAgXTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBEcmFnQW5kRHJvcC5wcm90b3R5cGUuc2V0QWN0aXZlID0gZnVuY3Rpb24gc2V0QWN0aXZlIChhY3RpdmUpIHtcbiAgICBJbnRlcmFjdGlvbi5wcm90b3R5cGUuc2V0QWN0aXZlLmNhbGwodGhpcywgYWN0aXZlKTtcbiAgICBpZiAoYWN0aXZlKSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzXygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnNfKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgRHJhZ0FuZERyb3AucHJvdG90eXBlLnNldE1hcCA9IGZ1bmN0aW9uIHNldE1hcCAobWFwKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzXygpO1xuICAgIEludGVyYWN0aW9uLnByb3RvdHlwZS5zZXRNYXAuY2FsbCh0aGlzLCBtYXApO1xuICAgIGlmICh0aGlzLmdldEFjdGl2ZSgpKSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzXygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9mb3JtYXQvRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmb3JtYXQgRm9ybWF0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUZXh0LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Zvcm1hdC9GZWF0dXJlLmpzXCIpLlJlYWRPcHRpb25zfSBvcHRpb25zIFJlYWQgb3B0aW9ucy5cbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZT59IEZlYXR1cmVzLlxuICAgKi9cbiAgRHJhZ0FuZERyb3AucHJvdG90eXBlLnRyeVJlYWRGZWF0dXJlc18gPSBmdW5jdGlvbiB0cnlSZWFkRmVhdHVyZXNfIChmb3JtYXQsIHRleHQsIG9wdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZvcm1hdC5yZWFkRmVhdHVyZXModGV4dCwgb3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgRHJhZ0FuZERyb3AucHJvdG90eXBlLnVucmVnaXN0ZXJMaXN0ZW5lcnNfID0gZnVuY3Rpb24gdW5yZWdpc3Rlckxpc3RlbmVyc18gKCkge1xuICAgIGlmICh0aGlzLmRyb3BMaXN0ZW5LZXlzXykge1xuICAgICAgdGhpcy5kcm9wTGlzdGVuS2V5c18uZm9yRWFjaCh1bmxpc3RlbkJ5S2V5KTtcbiAgICAgIHRoaXMuZHJvcExpc3RlbktleXNfID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIERyYWdBbmREcm9wO1xufShJbnRlcmFjdGlvbikpO1xuXG5cbi8qKlxuICogQHBhcmFtIHtEcmFnRXZlbnR9IGV2ZW50IEV2ZW50LlxuICogQHRoaXMge0RyYWdBbmREcm9wfVxuICovXG5mdW5jdGlvbiBoYW5kbGVEcm9wKGV2ZW50KSB7XG4gIHZhciBmaWxlcyA9IGV2ZW50LmRhdGFUcmFuc2Zlci5maWxlcztcbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gZmlsZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIHZhciBmaWxlID0gZmlsZXMuaXRlbShpKTtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICByZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudFR5cGUuTE9BRCwgdGhpcy5oYW5kbGVSZXN1bHRfLmJpbmQodGhpcywgZmlsZSkpO1xuICAgIHJlYWRlci5yZWFkQXNUZXh0KGZpbGUpO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0RyYWdFdmVudH0gZXZlbnQgRXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZVN0b3AoZXZlbnQpIHtcbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGV2ZW50LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gJ2NvcHknO1xufVxuXG5cbmV4cG9ydCBkZWZhdWx0IERyYWdBbmREcm9wO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1EcmFnQW5kRHJvcC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vRHJhZ0JveFxuICovXG4vLyBGSVhNRSBkcmF3IGRyYWcgYm94XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzL0V2ZW50LmpzJztcbmltcG9ydCB7YWx3YXlzLCBtb3VzZU9ubHksIG1vdXNlQWN0aW9uQnV0dG9ufSBmcm9tICcuLi9ldmVudHMvY29uZGl0aW9uLmpzJztcbmltcG9ydCB7Vk9JRH0gZnJvbSAnLi4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCBQb2ludGVySW50ZXJhY3Rpb24gZnJvbSAnLi9Qb2ludGVyLmpzJztcbmltcG9ydCBSZW5kZXJCb3ggZnJvbSAnLi4vcmVuZGVyL0JveC5qcyc7XG5cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH0gYW5kIHR3b1xuICoge0BsaW5rIG1vZHVsZTpvbC9waXhlbH5QaXhlbH1zIGFuZCByZXR1cm5zIGEgYHtib29sZWFufWAuIElmIHRoZSBjb25kaXRpb24gaXMgbWV0LFxuICogdHJ1ZSBzaG91bGQgYmUgcmV0dXJuZWQuXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24odGhpczogPywgaW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHQsIGltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsLCBpbXBvcnQoXCIuLi9waXhlbC5qc1wiKS5QaXhlbCk6Ym9vbGVhbn0gRW5kQ29uZGl0aW9uXG4gKi9cblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3NOYW1lPSdvbC1kcmFnYm94J10gQ1NTIGNsYXNzIG5hbWUgZm9yIHN0eWxpbmcgdGhlIGJveC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259IFtjb25kaXRpb25dIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnR9IGFuZCByZXR1cm5zIGEgYm9vbGVhblxuICogdG8gaW5kaWNhdGUgd2hldGhlciB0aGF0IGV2ZW50IHNob3VsZCBiZSBoYW5kbGVkLlxuICogRGVmYXVsdCBpcyB7QGxpbmsgb2wvZXZlbnRzL2NvbmRpdGlvbn5hbHdheXN9LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5BcmVhPTY0XSBUaGUgbWluaW11bSBhcmVhIG9mIHRoZSBib3ggaW4gcGl4ZWwsIHRoaXMgdmFsdWUgaXMgdXNlZCBieSB0aGUgZGVmYXVsdFxuICogYGJveEVuZENvbmRpdGlvbmAgZnVuY3Rpb24uXG4gKiBAcHJvcGVydHkge0VuZENvbmRpdGlvbn0gW2JveEVuZENvbmRpdGlvbl0gQSBmdW5jdGlvbiB0aGF0IHRha2VzIGEge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmQgdHdvXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3BpeGVsflBpeGVsfXMgdG8gaW5kaWNhdGUgd2hldGhlciBhIGBib3hlbmRgIGV2ZW50IHNob3VsZCBiZSBmaXJlZC5cbiAqIERlZmF1bHQgaXMgYHRydWVgIGlmIHRoZSBhcmVhIG9mIHRoZSBib3ggaXMgYmlnZ2VyIHRoYW4gdGhlIGBtaW5BcmVhYCBvcHRpb24uXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKHRoaXM6RHJhZ0JveCwgaW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHQpfSBvbkJveEVuZCBDb2RlIHRvIGV4ZWN1dGUganVzdFxuICogYmVmb3JlIGBib3hlbmRgIGlzIGZpcmVkLlxuICovXG5cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG52YXIgRHJhZ0JveEV2ZW50VHlwZSA9IHtcbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB1cG9uIGRyYWcgYm94IHN0YXJ0LlxuICAgKiBAZXZlbnQgRHJhZ0JveEV2ZW50I2JveHN0YXJ0XG4gICAqIEBhcGlcbiAgICovXG4gIEJPWFNUQVJUOiAnYm94c3RhcnQnLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgb24gZHJhZyB3aGVuIGJveCBpcyBhY3RpdmUuXG4gICAqIEBldmVudCBEcmFnQm94RXZlbnQjYm94ZHJhZ1xuICAgKiBAYXBpXG4gICAqL1xuICBCT1hEUkFHOiAnYm94ZHJhZycsXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB1cG9uIGRyYWcgYm94IGVuZC5cbiAgICogQGV2ZW50IERyYWdCb3hFdmVudCNib3hlbmRcbiAgICogQGFwaVxuICAgKi9cbiAgQk9YRU5EOiAnYm94ZW5kJ1xufTtcblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEV2ZW50cyBlbWl0dGVkIGJ5IHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vRHJhZ0JveH5EcmFnQm94fSBpbnN0YW5jZXMgYXJlIGluc3RhbmNlcyBvZlxuICogdGhpcyB0eXBlLlxuICovXG52YXIgRHJhZ0JveEV2ZW50ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoRXZlbnQpIHtcbiAgZnVuY3Rpb24gRHJhZ0JveEV2ZW50KHR5cGUsIGNvb3JkaW5hdGUsIG1hcEJyb3dzZXJFdmVudCkge1xuICAgIEV2ZW50LmNhbGwodGhpcywgdHlwZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgZHJhZyBldmVudC5cbiAgICAgKiBAY29uc3RcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLmNvb3JkaW5hdGUgPSBjb29yZGluYXRlO1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0XG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLm1hcEJyb3dzZXJFdmVudCA9IG1hcEJyb3dzZXJFdmVudDtcblxuICB9XG5cbiAgaWYgKCBFdmVudCApIERyYWdCb3hFdmVudC5fX3Byb3RvX18gPSBFdmVudDtcbiAgRHJhZ0JveEV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEV2ZW50ICYmIEV2ZW50LnByb3RvdHlwZSApO1xuICBEcmFnQm94RXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRHJhZ0JveEV2ZW50O1xuXG4gIHJldHVybiBEcmFnQm94RXZlbnQ7XG59KEV2ZW50KSk7XG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBbGxvd3MgdGhlIHVzZXIgdG8gZHJhdyBhIHZlY3RvciBib3ggYnkgY2xpY2tpbmcgYW5kIGRyYWdnaW5nIG9uIHRoZSBtYXAsXG4gKiBub3JtYWxseSBjb21iaW5lZCB3aXRoIGFuIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbn0gdGhhdCBsaW1pdHNcbiAqIGl0IHRvIHdoZW4gdGhlIHNoaWZ0IG9yIG90aGVyIGtleSBpcyBoZWxkIGRvd24uIFRoaXMgaXMgdXNlZCwgZm9yIGV4YW1wbGUsXG4gKiBmb3Igem9vbWluZyB0byBhIHNwZWNpZmljIGFyZWEgb2YgdGhlIG1hcFxuICogKHNlZSB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL0RyYWdab29tfkRyYWdab29tfSBhbmRcbiAqIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vRHJhZ1JvdGF0ZUFuZFpvb219KS5cbiAqXG4gKiBUaGlzIGludGVyYWN0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBtb3VzZSBkZXZpY2VzLlxuICpcbiAqIEBmaXJlcyBEcmFnQm94RXZlbnRcbiAqIEBhcGlcbiAqL1xudmFyIERyYWdCb3ggPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChQb2ludGVySW50ZXJhY3Rpb24pIHtcbiAgZnVuY3Rpb24gRHJhZ0JveChvcHRfb3B0aW9ucykge1xuXG4gICAgUG9pbnRlckludGVyYWN0aW9uLmNhbGwodGhpcyk7XG5cbiAgICB2YXIgb3B0aW9ucyA9IG9wdF9vcHRpb25zID8gb3B0X29wdGlvbnMgOiB7fTtcblxuICAgIC8qKlxuICAgICogQHR5cGUge2ltcG9ydChcIi4uL3JlbmRlci9Cb3guanNcIikuZGVmYXVsdH1cbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICB0aGlzLmJveF8gPSBuZXcgUmVuZGVyQm94KG9wdGlvbnMuY2xhc3NOYW1lIHx8ICdvbC1kcmFnYm94Jyk7XG5cbiAgICAvKipcbiAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgdGhpcy5taW5BcmVhXyA9IG9wdGlvbnMubWluQXJlYSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5taW5BcmVhIDogNjQ7XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0byBleGVjdXRlIGp1c3QgYmVmb3JlIGBvbmJveGVuZGAgaXMgZmlyZWRcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24odGhpczpEcmFnQm94LCBpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdCl9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLm9uQm94RW5kXyA9IG9wdGlvbnMub25Cb3hFbmQgPyBvcHRpb25zLm9uQm94RW5kIDogVk9JRDtcblxuICAgIC8qKlxuICAgICogQHR5cGUge2ltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsfVxuICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIHRoaXMuc3RhcnRQaXhlbF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgKiBAcHJpdmF0ZVxuICAgICogQHR5cGUge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufVxuICAgICovXG4gICAgdGhpcy5jb25kaXRpb25fID0gb3B0aW9ucy5jb25kaXRpb24gPyBvcHRpb25zLmNvbmRpdGlvbiA6IGFsd2F5cztcblxuICAgIC8qKlxuICAgICogQHByaXZhdGVcbiAgICAqIEB0eXBlIHtFbmRDb25kaXRpb259XG4gICAgKi9cbiAgICB0aGlzLmJveEVuZENvbmRpdGlvbl8gPSBvcHRpb25zLmJveEVuZENvbmRpdGlvbiA/XG4gICAgICBvcHRpb25zLmJveEVuZENvbmRpdGlvbiA6IHRoaXMuZGVmYXVsdEJveEVuZENvbmRpdGlvbjtcbiAgfVxuXG4gIGlmICggUG9pbnRlckludGVyYWN0aW9uICkgRHJhZ0JveC5fX3Byb3RvX18gPSBQb2ludGVySW50ZXJhY3Rpb247XG4gIERyYWdCb3gucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUG9pbnRlckludGVyYWN0aW9uICYmIFBvaW50ZXJJbnRlcmFjdGlvbi5wcm90b3R5cGUgKTtcbiAgRHJhZ0JveC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEcmFnQm94O1xuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBjb25kaXRpb24gZm9yIGRldGVybWluaW5nIHdoZXRoZXIgdGhlIGJveGVuZCBldmVudFxuICAgKiBzaG91bGQgZmlyZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IFRoZSBvcmlnaW5hdGluZyBNYXBCcm93c2VyRXZlbnRcbiAgICogICAgIGxlYWRpbmcgdG8gdGhlIGJveCBlbmQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcGl4ZWwuanNcIikuUGl4ZWx9IHN0YXJ0UGl4ZWwgVGhlIHN0YXJ0aW5nIHBpeGVsIG9mIHRoZSBib3guXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcGl4ZWwuanNcIikuUGl4ZWx9IGVuZFBpeGVsIFRoZSBlbmQgcGl4ZWwgb2YgdGhlIGJveC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIGJveGVuZCBjb25kaXRpb24gc2hvdWxkIGJlIGZpcmVkLlxuICAgKi9cbiAgRHJhZ0JveC5wcm90b3R5cGUuZGVmYXVsdEJveEVuZENvbmRpdGlvbiA9IGZ1bmN0aW9uIGRlZmF1bHRCb3hFbmRDb25kaXRpb24gKG1hcEJyb3dzZXJFdmVudCwgc3RhcnRQaXhlbCwgZW5kUGl4ZWwpIHtcbiAgICB2YXIgd2lkdGggPSBlbmRQaXhlbFswXSAtIHN0YXJ0UGl4ZWxbMF07XG4gICAgdmFyIGhlaWdodCA9IGVuZFBpeGVsWzFdIC0gc3RhcnRQaXhlbFsxXTtcbiAgICByZXR1cm4gd2lkdGggKiB3aWR0aCArIGhlaWdodCAqIGhlaWdodCA+PSB0aGlzLm1pbkFyZWFfO1xuICB9O1xuXG4gIC8qKlxuICAqIFJldHVybnMgZ2VvbWV0cnkgb2YgbGFzdCBkcmF3biBib3guXG4gICogQHJldHVybiB7aW1wb3J0KFwiLi4vZ2VvbS9Qb2x5Z29uLmpzXCIpLmRlZmF1bHR9IEdlb21ldHJ5LlxuICAqIEBhcGlcbiAgKi9cbiAgRHJhZ0JveC5wcm90b3R5cGUuZ2V0R2VvbWV0cnkgPSBmdW5jdGlvbiBnZXRHZW9tZXRyeSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYm94Xy5nZXRHZW9tZXRyeSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgRHJhZ0JveC5wcm90b3R5cGUuaGFuZGxlRHJhZ0V2ZW50ID0gZnVuY3Rpb24gaGFuZGxlRHJhZ0V2ZW50IChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBpZiAoIW1vdXNlT25seShtYXBCcm93c2VyRXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5ib3hfLnNldFBpeGVscyh0aGlzLnN0YXJ0UGl4ZWxfLCBtYXBCcm93c2VyRXZlbnQucGl4ZWwpO1xuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBEcmFnQm94RXZlbnQoRHJhZ0JveEV2ZW50VHlwZS5CT1hEUkFHLFxuICAgICAgbWFwQnJvd3NlckV2ZW50LmNvb3JkaW5hdGUsIG1hcEJyb3dzZXJFdmVudCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgRHJhZ0JveC5wcm90b3R5cGUuaGFuZGxlVXBFdmVudCA9IGZ1bmN0aW9uIGhhbmRsZVVwRXZlbnQgKG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGlmICghbW91c2VPbmx5KG1hcEJyb3dzZXJFdmVudCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuYm94Xy5zZXRNYXAobnVsbCk7XG5cbiAgICBpZiAodGhpcy5ib3hFbmRDb25kaXRpb25fKG1hcEJyb3dzZXJFdmVudCwgdGhpcy5zdGFydFBpeGVsXywgbWFwQnJvd3NlckV2ZW50LnBpeGVsKSkge1xuICAgICAgdGhpcy5vbkJveEVuZF8obWFwQnJvd3NlckV2ZW50KTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRHJhZ0JveEV2ZW50KERyYWdCb3hFdmVudFR5cGUuQk9YRU5ELFxuICAgICAgICBtYXBCcm93c2VyRXZlbnQuY29vcmRpbmF0ZSwgbWFwQnJvd3NlckV2ZW50KSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIERyYWdCb3gucHJvdG90eXBlLmhhbmRsZURvd25FdmVudCA9IGZ1bmN0aW9uIGhhbmRsZURvd25FdmVudCAobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKCFtb3VzZU9ubHkobWFwQnJvd3NlckV2ZW50KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChtb3VzZUFjdGlvbkJ1dHRvbihtYXBCcm93c2VyRXZlbnQpICYmXG4gICAgICAgIHRoaXMuY29uZGl0aW9uXyhtYXBCcm93c2VyRXZlbnQpKSB7XG4gICAgICB0aGlzLnN0YXJ0UGl4ZWxfID0gbWFwQnJvd3NlckV2ZW50LnBpeGVsO1xuICAgICAgdGhpcy5ib3hfLnNldE1hcChtYXBCcm93c2VyRXZlbnQubWFwKTtcbiAgICAgIHRoaXMuYm94Xy5zZXRQaXhlbHModGhpcy5zdGFydFBpeGVsXywgdGhpcy5zdGFydFBpeGVsXyk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IERyYWdCb3hFdmVudChEcmFnQm94RXZlbnRUeXBlLkJPWFNUQVJULFxuICAgICAgICBtYXBCcm93c2VyRXZlbnQuY29vcmRpbmF0ZSwgbWFwQnJvd3NlckV2ZW50KSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gRHJhZ0JveDtcbn0oUG9pbnRlckludGVyYWN0aW9uKSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgRHJhZ0JveDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RHJhZ0JveC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vRHJhZ1BhblxuICovXG5pbXBvcnQgVmlld0hpbnQgZnJvbSAnLi4vVmlld0hpbnQuanMnO1xuaW1wb3J0IHtzY2FsZSBhcyBzY2FsZUNvb3JkaW5hdGUsIHJvdGF0ZSBhcyByb3RhdGVDb29yZGluYXRlLCBhZGQgYXMgYWRkQ29vcmRpbmF0ZX0gZnJvbSAnLi4vY29vcmRpbmF0ZS5qcyc7XG5pbXBvcnQge2Vhc2VPdXR9IGZyb20gJy4uL2Vhc2luZy5qcyc7XG5pbXBvcnQge25vTW9kaWZpZXJLZXlzfSBmcm9tICcuLi9ldmVudHMvY29uZGl0aW9uLmpzJztcbmltcG9ydCB7RkFMU0V9IGZyb20gJy4uL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQgUG9pbnRlckludGVyYWN0aW9uLCB7Y2VudHJvaWQgYXMgY2VudHJvaWRGcm9tUG9pbnRlcnN9IGZyb20gJy4vUG9pbnRlci5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufSBbY29uZGl0aW9uXSBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmQgcmV0dXJucyBhIGJvb2xlYW5cbiAqIHRvIGluZGljYXRlIHdoZXRoZXIgdGhhdCBldmVudCBzaG91bGQgYmUgaGFuZGxlZC5cbiAqIERlZmF1bHQgaXMge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9ufm5vTW9kaWZpZXJLZXlzfS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vS2luZXRpYy5qc1wiKS5kZWZhdWx0fSBba2luZXRpY10gS2luZXRpYyBpbmVydGlhIHRvIGFwcGx5IHRvIHRoZSBwYW4uXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFsbG93cyB0aGUgdXNlciB0byBwYW4gdGhlIG1hcCBieSBkcmFnZ2luZyB0aGUgbWFwLlxuICogQGFwaVxuICovXG52YXIgRHJhZ1BhbiA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFBvaW50ZXJJbnRlcmFjdGlvbikge1xuICBmdW5jdGlvbiBEcmFnUGFuKG9wdF9vcHRpb25zKSB7XG5cbiAgICBQb2ludGVySW50ZXJhY3Rpb24uY2FsbCh0aGlzLCB7XG4gICAgICBzdG9wRG93bjogRkFMU0VcbiAgICB9KTtcblxuICAgIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgPyBvcHRfb3B0aW9ucyA6IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vS2luZXRpYy5qc1wiKS5kZWZhdWx0fHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmtpbmV0aWNfID0gb3B0aW9ucy5raW5ldGljO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsfVxuICAgICAqL1xuICAgIHRoaXMubGFzdENlbnRyb2lkID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sYXN0UG9pbnRlcnNDb3VudF87XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnBhbm5pbmdfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbmRpdGlvbl8gPSBvcHRpb25zLmNvbmRpdGlvbiA/IG9wdGlvbnMuY29uZGl0aW9uIDogbm9Nb2RpZmllcktleXM7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMubm9LaW5ldGljXyA9IGZhbHNlO1xuXG4gIH1cblxuICBpZiAoIFBvaW50ZXJJbnRlcmFjdGlvbiApIERyYWdQYW4uX19wcm90b19fID0gUG9pbnRlckludGVyYWN0aW9uO1xuICBEcmFnUGFuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBvaW50ZXJJbnRlcmFjdGlvbiAmJiBQb2ludGVySW50ZXJhY3Rpb24ucHJvdG90eXBlICk7XG4gIERyYWdQYW4ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRHJhZ1BhbjtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIERyYWdQYW4ucHJvdG90eXBlLmhhbmRsZURyYWdFdmVudCA9IGZ1bmN0aW9uIGhhbmRsZURyYWdFdmVudCAobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLnBhbm5pbmdfKSB7XG4gICAgICB0aGlzLnBhbm5pbmdfID0gdHJ1ZTtcbiAgICAgIHRoaXMuZ2V0TWFwKCkuZ2V0VmlldygpLnNldEhpbnQoVmlld0hpbnQuSU5URVJBQ1RJTkcsIDEpO1xuICAgIH1cbiAgICB2YXIgdGFyZ2V0UG9pbnRlcnMgPSB0aGlzLnRhcmdldFBvaW50ZXJzO1xuICAgIHZhciBjZW50cm9pZCA9IGNlbnRyb2lkRnJvbVBvaW50ZXJzKHRhcmdldFBvaW50ZXJzKTtcbiAgICBpZiAodGFyZ2V0UG9pbnRlcnMubGVuZ3RoID09IHRoaXMubGFzdFBvaW50ZXJzQ291bnRfKSB7XG4gICAgICBpZiAodGhpcy5raW5ldGljXykge1xuICAgICAgICB0aGlzLmtpbmV0aWNfLnVwZGF0ZShjZW50cm9pZFswXSwgY2VudHJvaWRbMV0pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubGFzdENlbnRyb2lkKSB7XG4gICAgICAgIHZhciBkZWx0YVggPSB0aGlzLmxhc3RDZW50cm9pZFswXSAtIGNlbnRyb2lkWzBdO1xuICAgICAgICB2YXIgZGVsdGFZID0gY2VudHJvaWRbMV0gLSB0aGlzLmxhc3RDZW50cm9pZFsxXTtcbiAgICAgICAgdmFyIG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgICAgIHZhciB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICAgICAgdmFyIGNlbnRlciA9IFtkZWx0YVgsIGRlbHRhWV07XG4gICAgICAgIHNjYWxlQ29vcmRpbmF0ZShjZW50ZXIsIHZpZXcuZ2V0UmVzb2x1dGlvbigpKTtcbiAgICAgICAgcm90YXRlQ29vcmRpbmF0ZShjZW50ZXIsIHZpZXcuZ2V0Um90YXRpb24oKSk7XG4gICAgICAgIGFkZENvb3JkaW5hdGUoY2VudGVyLCB2aWV3LmdldENlbnRlcigpKTtcbiAgICAgICAgY2VudGVyID0gdmlldy5jb25zdHJhaW5DZW50ZXIoY2VudGVyKTtcbiAgICAgICAgdmlldy5zZXRDZW50ZXIoY2VudGVyKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMua2luZXRpY18pIHtcbiAgICAgIC8vIHJlc2V0IHNvIHdlIGRvbid0IG92ZXJlc3RpbWF0ZSB0aGUga2luZXRpYyBlbmVyZ3kgYWZ0ZXJcbiAgICAgIC8vIGFmdGVyIG9uZSBmaW5nZXIgZG93biwgdGlueSBkcmFnLCBzZWNvbmQgZmluZ2VyIGRvd25cbiAgICAgIHRoaXMua2luZXRpY18uYmVnaW4oKTtcbiAgICB9XG4gICAgdGhpcy5sYXN0Q2VudHJvaWQgPSBjZW50cm9pZDtcbiAgICB0aGlzLmxhc3RQb2ludGVyc0NvdW50XyA9IHRhcmdldFBvaW50ZXJzLmxlbmd0aDtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIERyYWdQYW4ucHJvdG90eXBlLmhhbmRsZVVwRXZlbnQgPSBmdW5jdGlvbiBoYW5kbGVVcEV2ZW50IChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICB2YXIgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgICB2YXIgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgaWYgKHRoaXMudGFyZ2V0UG9pbnRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAoIXRoaXMubm9LaW5ldGljXyAmJiB0aGlzLmtpbmV0aWNfICYmIHRoaXMua2luZXRpY18uZW5kKCkpIHtcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gdGhpcy5raW5ldGljXy5nZXREaXN0YW5jZSgpO1xuICAgICAgICB2YXIgYW5nbGUgPSB0aGlzLmtpbmV0aWNfLmdldEFuZ2xlKCk7XG4gICAgICAgIHZhciBjZW50ZXIgPSAvKiogQHR5cGUgeyFpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9ICovICh2aWV3LmdldENlbnRlcigpKTtcbiAgICAgICAgdmFyIGNlbnRlcnB4ID0gbWFwLmdldFBpeGVsRnJvbUNvb3JkaW5hdGUoY2VudGVyKTtcbiAgICAgICAgdmFyIGRlc3QgPSBtYXAuZ2V0Q29vcmRpbmF0ZUZyb21QaXhlbChbXG4gICAgICAgICAgY2VudGVycHhbMF0gLSBkaXN0YW5jZSAqIE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgICBjZW50ZXJweFsxXSAtIGRpc3RhbmNlICogTWF0aC5zaW4oYW5nbGUpXG4gICAgICAgIF0pO1xuICAgICAgICB2aWV3LmFuaW1hdGUoe1xuICAgICAgICAgIGNlbnRlcjogdmlldy5jb25zdHJhaW5DZW50ZXIoZGVzdCksXG4gICAgICAgICAgZHVyYXRpb246IDUwMCxcbiAgICAgICAgICBlYXNpbmc6IGVhc2VPdXRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wYW5uaW5nXykge1xuICAgICAgICB0aGlzLnBhbm5pbmdfID0gZmFsc2U7XG4gICAgICAgIHZpZXcuc2V0SGludChWaWV3SGludC5JTlRFUkFDVElORywgLTEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5raW5ldGljXykge1xuICAgICAgICAvLyByZXNldCBzbyB3ZSBkb24ndCBvdmVyZXN0aW1hdGUgdGhlIGtpbmV0aWMgZW5lcmd5IGFmdGVyXG4gICAgICAgIC8vIGFmdGVyIG9uZSBmaW5nZXIgdXAsIHRpbnkgZHJhZywgc2Vjb25kIGZpbmdlciB1cFxuICAgICAgICB0aGlzLmtpbmV0aWNfLmJlZ2luKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmxhc3RDZW50cm9pZCA9IG51bGw7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBEcmFnUGFuLnByb3RvdHlwZS5oYW5kbGVEb3duRXZlbnQgPSBmdW5jdGlvbiBoYW5kbGVEb3duRXZlbnQgKG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGlmICh0aGlzLnRhcmdldFBvaW50ZXJzLmxlbmd0aCA+IDAgJiYgdGhpcy5jb25kaXRpb25fKG1hcEJyb3dzZXJFdmVudCkpIHtcbiAgICAgIHZhciBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuICAgICAgdmFyIHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgICAgdGhpcy5sYXN0Q2VudHJvaWQgPSBudWxsO1xuICAgICAgLy8gc3RvcCBhbnkgY3VycmVudCBhbmltYXRpb25cbiAgICAgIGlmICh2aWV3LmdldEFuaW1hdGluZygpKSB7XG4gICAgICAgIHZpZXcuc2V0Q2VudGVyKG1hcEJyb3dzZXJFdmVudC5mcmFtZVN0YXRlLnZpZXdTdGF0ZS5jZW50ZXIpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMua2luZXRpY18pIHtcbiAgICAgICAgdGhpcy5raW5ldGljXy5iZWdpbigpO1xuICAgICAgfVxuICAgICAgLy8gTm8ga2luZXRpYyBhcyBzb29uIGFzIG1vcmUgdGhhbiBvbmUgcG9pbnRlciBvbiB0aGUgc2NyZWVuIGlzXG4gICAgICAvLyBkZXRlY3RlZC4gVGhpcyBpcyB0byBwcmV2ZW50IG5hc3R5IHBhbnMgYWZ0ZXIgcGluY2guXG4gICAgICB0aGlzLm5vS2luZXRpY18gPSB0aGlzLnRhcmdldFBvaW50ZXJzLmxlbmd0aCA+IDE7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gRHJhZ1Bhbjtcbn0oUG9pbnRlckludGVyYWN0aW9uKSk7XG5cbmV4cG9ydCBkZWZhdWx0IERyYWdQYW47XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURyYWdQYW4uanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL0RyYWdSb3RhdGVcbiAqL1xuaW1wb3J0IHtkaXNhYmxlfSBmcm9tICcuLi9yb3RhdGlvbmNvbnN0cmFpbnQuanMnO1xuaW1wb3J0IFZpZXdIaW50IGZyb20gJy4uL1ZpZXdIaW50LmpzJztcbmltcG9ydCB7YWx0U2hpZnRLZXlzT25seSwgbW91c2VPbmx5LCBtb3VzZUFjdGlvbkJ1dHRvbn0gZnJvbSAnLi4vZXZlbnRzL2NvbmRpdGlvbi5qcyc7XG5pbXBvcnQge0ZBTFNFfSBmcm9tICcuLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IHtyb3RhdGUsIHJvdGF0ZVdpdGhvdXRDb25zdHJhaW50c30gZnJvbSAnLi9JbnRlcmFjdGlvbi5qcyc7XG5pbXBvcnQgUG9pbnRlckludGVyYWN0aW9uIGZyb20gJy4vUG9pbnRlci5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufSBbY29uZGl0aW9uXSBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW5cbiAqIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0gYW5kIHJldHVybnMgYSBib29sZWFuXG4gKiB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoYXQgZXZlbnQgc2hvdWxkIGJlIGhhbmRsZWQuXG4gKiBEZWZhdWx0IGlzIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbn5hbHRTaGlmdEtleXNPbmx5fS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHVyYXRpb249MjUwXSBBbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBbGxvd3MgdGhlIHVzZXIgdG8gcm90YXRlIHRoZSBtYXAgYnkgY2xpY2tpbmcgYW5kIGRyYWdnaW5nIG9uIHRoZSBtYXAsXG4gKiBub3JtYWxseSBjb21iaW5lZCB3aXRoIGFuIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbn0gdGhhdCBsaW1pdHNcbiAqIGl0IHRvIHdoZW4gdGhlIGFsdCBhbmQgc2hpZnQga2V5cyBhcmUgaGVsZCBkb3duLlxuICpcbiAqIFRoaXMgaW50ZXJhY3Rpb24gaXMgb25seSBzdXBwb3J0ZWQgZm9yIG1vdXNlIGRldmljZXMuXG4gKiBAYXBpXG4gKi9cbnZhciBEcmFnUm90YXRlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoUG9pbnRlckludGVyYWN0aW9uKSB7XG4gIGZ1bmN0aW9uIERyYWdSb3RhdGUob3B0X29wdGlvbnMpIHtcblxuICAgIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgPyBvcHRfb3B0aW9ucyA6IHt9O1xuXG4gICAgUG9pbnRlckludGVyYWN0aW9uLmNhbGwodGhpcywge1xuICAgICAgc3RvcERvd246IEZBTFNFXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbmRpdGlvbl8gPSBvcHRpb25zLmNvbmRpdGlvbiA/IG9wdGlvbnMuY29uZGl0aW9uIDogYWx0U2hpZnRLZXlzT25seTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5sYXN0QW5nbGVfID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZHVyYXRpb25fID0gb3B0aW9ucy5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kdXJhdGlvbiA6IDI1MDtcblxuICB9XG5cbiAgaWYgKCBQb2ludGVySW50ZXJhY3Rpb24gKSBEcmFnUm90YXRlLl9fcHJvdG9fXyA9IFBvaW50ZXJJbnRlcmFjdGlvbjtcbiAgRHJhZ1JvdGF0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQb2ludGVySW50ZXJhY3Rpb24gJiYgUG9pbnRlckludGVyYWN0aW9uLnByb3RvdHlwZSApO1xuICBEcmFnUm90YXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERyYWdSb3RhdGU7XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBEcmFnUm90YXRlLnByb3RvdHlwZS5oYW5kbGVEcmFnRXZlbnQgPSBmdW5jdGlvbiBoYW5kbGVEcmFnRXZlbnQgKG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGlmICghbW91c2VPbmx5KG1hcEJyb3dzZXJFdmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgICB2YXIgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgaWYgKHZpZXcuZ2V0Q29uc3RyYWludHMoKS5yb3RhdGlvbiA9PT0gZGlzYWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgc2l6ZSA9IG1hcC5nZXRTaXplKCk7XG4gICAgdmFyIG9mZnNldCA9IG1hcEJyb3dzZXJFdmVudC5waXhlbDtcbiAgICB2YXIgdGhldGEgPVxuICAgICAgICBNYXRoLmF0YW4yKHNpemVbMV0gLyAyIC0gb2Zmc2V0WzFdLCBvZmZzZXRbMF0gLSBzaXplWzBdIC8gMik7XG4gICAgaWYgKHRoaXMubGFzdEFuZ2xlXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgZGVsdGEgPSB0aGV0YSAtIHRoaXMubGFzdEFuZ2xlXztcbiAgICAgIHZhciByb3RhdGlvbiA9IHZpZXcuZ2V0Um90YXRpb24oKTtcbiAgICAgIHJvdGF0ZVdpdGhvdXRDb25zdHJhaW50cyh2aWV3LCByb3RhdGlvbiAtIGRlbHRhKTtcbiAgICB9XG4gICAgdGhpcy5sYXN0QW5nbGVfID0gdGhldGE7XG4gIH07XG5cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIERyYWdSb3RhdGUucHJvdG90eXBlLmhhbmRsZVVwRXZlbnQgPSBmdW5jdGlvbiBoYW5kbGVVcEV2ZW50IChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBpZiAoIW1vdXNlT25seShtYXBCcm93c2VyRXZlbnQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgICB2YXIgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgdmlldy5zZXRIaW50KFZpZXdIaW50LklOVEVSQUNUSU5HLCAtMSk7XG4gICAgdmFyIHJvdGF0aW9uID0gdmlldy5nZXRSb3RhdGlvbigpO1xuICAgIHJvdGF0ZSh2aWV3LCByb3RhdGlvbiwgdW5kZWZpbmVkLCB0aGlzLmR1cmF0aW9uXyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBEcmFnUm90YXRlLnByb3RvdHlwZS5oYW5kbGVEb3duRXZlbnQgPSBmdW5jdGlvbiBoYW5kbGVEb3duRXZlbnQgKG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGlmICghbW91c2VPbmx5KG1hcEJyb3dzZXJFdmVudCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAobW91c2VBY3Rpb25CdXR0b24obWFwQnJvd3NlckV2ZW50KSAmJiB0aGlzLmNvbmRpdGlvbl8obWFwQnJvd3NlckV2ZW50KSkge1xuICAgICAgdmFyIG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgICBtYXAuZ2V0VmlldygpLnNldEhpbnQoVmlld0hpbnQuSU5URVJBQ1RJTkcsIDEpO1xuICAgICAgdGhpcy5sYXN0QW5nbGVfID0gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIERyYWdSb3RhdGU7XG59KFBvaW50ZXJJbnRlcmFjdGlvbikpO1xuXG5leHBvcnQgZGVmYXVsdCBEcmFnUm90YXRlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1EcmFnUm90YXRlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9EcmFnUm90YXRlQW5kWm9vbVxuICovXG5pbXBvcnQge2Rpc2FibGV9IGZyb20gJy4uL3JvdGF0aW9uY29uc3RyYWludC5qcyc7XG5pbXBvcnQgVmlld0hpbnQgZnJvbSAnLi4vVmlld0hpbnQuanMnO1xuaW1wb3J0IHtzaGlmdEtleU9ubHksIG1vdXNlT25seX0gZnJvbSAnLi4vZXZlbnRzL2NvbmRpdGlvbi5qcyc7XG5pbXBvcnQge3JvdGF0ZSwgcm90YXRlV2l0aG91dENvbnN0cmFpbnRzLCB6b29tLCB6b29tV2l0aG91dENvbnN0cmFpbnRzfSBmcm9tICcuL0ludGVyYWN0aW9uLmpzJztcbmltcG9ydCBQb2ludGVySW50ZXJhY3Rpb24gZnJvbSAnLi9Qb2ludGVyLmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259IFtjb25kaXRpb25dIEEgZnVuY3Rpb24gdGhhdFxuICogdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmQgcmV0dXJucyBhXG4gKiBib29sZWFuIHRvIGluZGljYXRlIHdoZXRoZXIgdGhhdCBldmVudCBzaG91bGQgYmUgaGFuZGxlZC5cbiAqIERlZmF1bHQgaXMge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9ufnNoaWZ0S2V5T25seX0uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2R1cmF0aW9uPTQwMF0gQW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWxsb3dzIHRoZSB1c2VyIHRvIHpvb20gYW5kIHJvdGF0ZSB0aGUgbWFwIGJ5IGNsaWNraW5nIGFuZCBkcmFnZ2luZ1xuICogb24gdGhlIG1hcC4gIEJ5IGRlZmF1bHQsIHRoaXMgaW50ZXJhY3Rpb24gaXMgbGltaXRlZCB0byB3aGVuIHRoZSBzaGlmdFxuICoga2V5IGlzIGhlbGQgZG93bi5cbiAqXG4gKiBUaGlzIGludGVyYWN0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBtb3VzZSBkZXZpY2VzLlxuICpcbiAqIEFuZCB0aGlzIGludGVyYWN0aW9uIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgZGVmYXVsdCBpbnRlcmFjdGlvbnMuXG4gKiBAYXBpXG4gKi9cbnZhciBEcmFnUm90YXRlQW5kWm9vbSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFBvaW50ZXJJbnRlcmFjdGlvbikge1xuICBmdW5jdGlvbiBEcmFnUm90YXRlQW5kWm9vbShvcHRfb3B0aW9ucykge1xuXG4gICAgdmFyIG9wdGlvbnMgPSBvcHRfb3B0aW9ucyA/IG9wdF9vcHRpb25zIDoge307XG5cbiAgICBQb2ludGVySW50ZXJhY3Rpb24uY2FsbCgvKiogQHR5cGUge2ltcG9ydChcIi4vUG9pbnRlci5qc1wiKS5PcHRpb25zfSAqLyB0aGlzLCAob3B0aW9ucykpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259XG4gICAgICovXG4gICAgdGhpcy5jb25kaXRpb25fID0gb3B0aW9ucy5jb25kaXRpb24gPyBvcHRpb25zLmNvbmRpdGlvbiA6IHNoaWZ0S2V5T25seTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5sYXN0QW5nbGVfID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmxhc3RNYWduaXR1ZGVfID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGFzdFNjYWxlRGVsdGFfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmR1cmF0aW9uXyA9IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiA0MDA7XG5cbiAgfVxuXG4gIGlmICggUG9pbnRlckludGVyYWN0aW9uICkgRHJhZ1JvdGF0ZUFuZFpvb20uX19wcm90b19fID0gUG9pbnRlckludGVyYWN0aW9uO1xuICBEcmFnUm90YXRlQW5kWm9vbS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQb2ludGVySW50ZXJhY3Rpb24gJiYgUG9pbnRlckludGVyYWN0aW9uLnByb3RvdHlwZSApO1xuICBEcmFnUm90YXRlQW5kWm9vbS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEcmFnUm90YXRlQW5kWm9vbTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIERyYWdSb3RhdGVBbmRab29tLnByb3RvdHlwZS5oYW5kbGVEcmFnRXZlbnQgPSBmdW5jdGlvbiBoYW5kbGVEcmFnRXZlbnQgKG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGlmICghbW91c2VPbmx5KG1hcEJyb3dzZXJFdmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgICB2YXIgc2l6ZSA9IG1hcC5nZXRTaXplKCk7XG4gICAgdmFyIG9mZnNldCA9IG1hcEJyb3dzZXJFdmVudC5waXhlbDtcbiAgICB2YXIgZGVsdGFYID0gb2Zmc2V0WzBdIC0gc2l6ZVswXSAvIDI7XG4gICAgdmFyIGRlbHRhWSA9IHNpemVbMV0gLyAyIC0gb2Zmc2V0WzFdO1xuICAgIHZhciB0aGV0YSA9IE1hdGguYXRhbjIoZGVsdGFZLCBkZWx0YVgpO1xuICAgIHZhciBtYWduaXR1ZGUgPSBNYXRoLnNxcnQoZGVsdGFYICogZGVsdGFYICsgZGVsdGFZICogZGVsdGFZKTtcbiAgICB2YXIgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgaWYgKHZpZXcuZ2V0Q29uc3RyYWludHMoKS5yb3RhdGlvbiAhPT0gZGlzYWJsZSAmJiB0aGlzLmxhc3RBbmdsZV8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGFuZ2xlRGVsdGEgPSB0aGV0YSAtIHRoaXMubGFzdEFuZ2xlXztcbiAgICAgIHJvdGF0ZVdpdGhvdXRDb25zdHJhaW50cyh2aWV3LCB2aWV3LmdldFJvdGF0aW9uKCkgLSBhbmdsZURlbHRhKTtcbiAgICB9XG4gICAgdGhpcy5sYXN0QW5nbGVfID0gdGhldGE7XG4gICAgaWYgKHRoaXMubGFzdE1hZ25pdHVkZV8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHJlc29sdXRpb24gPSB0aGlzLmxhc3RNYWduaXR1ZGVfICogKHZpZXcuZ2V0UmVzb2x1dGlvbigpIC8gbWFnbml0dWRlKTtcbiAgICAgIHpvb21XaXRob3V0Q29uc3RyYWludHModmlldywgcmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGlmICh0aGlzLmxhc3RNYWduaXR1ZGVfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMubGFzdFNjYWxlRGVsdGFfID0gdGhpcy5sYXN0TWFnbml0dWRlXyAvIG1hZ25pdHVkZTtcbiAgICB9XG4gICAgdGhpcy5sYXN0TWFnbml0dWRlXyA9IG1hZ25pdHVkZTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIERyYWdSb3RhdGVBbmRab29tLnByb3RvdHlwZS5oYW5kbGVVcEV2ZW50ID0gZnVuY3Rpb24gaGFuZGxlVXBFdmVudCAobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKCFtb3VzZU9ubHkobWFwQnJvd3NlckV2ZW50KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgdmFyIHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgIHZpZXcuc2V0SGludChWaWV3SGludC5JTlRFUkFDVElORywgLTEpO1xuICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLmxhc3RTY2FsZURlbHRhXyAtIDE7XG4gICAgcm90YXRlKHZpZXcsIHZpZXcuZ2V0Um90YXRpb24oKSk7XG4gICAgem9vbSh2aWV3LCB2aWV3LmdldFJlc29sdXRpb24oKSwgdW5kZWZpbmVkLCB0aGlzLmR1cmF0aW9uXywgZGlyZWN0aW9uKTtcbiAgICB0aGlzLmxhc3RTY2FsZURlbHRhXyA9IDA7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgRHJhZ1JvdGF0ZUFuZFpvb20ucHJvdG90eXBlLmhhbmRsZURvd25FdmVudCA9IGZ1bmN0aW9uIGhhbmRsZURvd25FdmVudCAobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKCFtb3VzZU9ubHkobWFwQnJvd3NlckV2ZW50KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNvbmRpdGlvbl8obWFwQnJvd3NlckV2ZW50KSkge1xuICAgICAgbWFwQnJvd3NlckV2ZW50Lm1hcC5nZXRWaWV3KCkuc2V0SGludChWaWV3SGludC5JTlRFUkFDVElORywgMSk7XG4gICAgICB0aGlzLmxhc3RBbmdsZV8gPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmxhc3RNYWduaXR1ZGVfID0gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIERyYWdSb3RhdGVBbmRab29tO1xufShQb2ludGVySW50ZXJhY3Rpb24pKTtcblxuZXhwb3J0IGRlZmF1bHQgRHJhZ1JvdGF0ZUFuZFpvb207XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURyYWdSb3RhdGVBbmRab29tLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9EcmFnWm9vbVxuICovXG5pbXBvcnQge2Vhc2VPdXR9IGZyb20gJy4uL2Vhc2luZy5qcyc7XG5pbXBvcnQge3NoaWZ0S2V5T25seX0gZnJvbSAnLi4vZXZlbnRzL2NvbmRpdGlvbi5qcyc7XG5pbXBvcnQge2NyZWF0ZU9yVXBkYXRlRnJvbUNvb3JkaW5hdGVzLCBnZXRCb3R0b21MZWZ0LCBnZXRDZW50ZXIsIGdldFRvcFJpZ2h0LCBzY2FsZUZyb21DZW50ZXJ9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQgRHJhZ0JveCBmcm9tICcuL0RyYWdCb3guanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc05hbWU9J29sLWRyYWd6b29tJ10gQ1NTIGNsYXNzIG5hbWUgZm9yIHN0eWxpbmcgdGhlXG4gKiBib3guXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufSBbY29uZGl0aW9uXSBBIGZ1bmN0aW9uIHRoYXRcbiAqIHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0gYW5kIHJldHVybnMgYVxuICogYm9vbGVhbiB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoYXQgZXZlbnQgc2hvdWxkIGJlIGhhbmRsZWQuXG4gKiBEZWZhdWx0IGlzIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbn5zaGlmdEtleU9ubHl9LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkdXJhdGlvbj0yMDBdIEFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtvdXQ9ZmFsc2VdIFVzZSBpbnRlcmFjdGlvbiBmb3Igem9vbWluZyBvdXQuXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFsbG93cyB0aGUgdXNlciB0byB6b29tIHRoZSBtYXAgYnkgY2xpY2tpbmcgYW5kIGRyYWdnaW5nIG9uIHRoZSBtYXAsXG4gKiBub3JtYWxseSBjb21iaW5lZCB3aXRoIGFuIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbn0gdGhhdCBsaW1pdHNcbiAqIGl0IHRvIHdoZW4gYSBrZXksIHNoaWZ0IGJ5IGRlZmF1bHQsIGlzIGhlbGQgZG93bi5cbiAqXG4gKiBUbyBjaGFuZ2UgdGhlIHN0eWxlIG9mIHRoZSBib3gsIHVzZSBDU1MgYW5kIHRoZSBgLm9sLWRyYWd6b29tYCBzZWxlY3Rvciwgb3JcbiAqIHlvdXIgY3VzdG9tIG9uZSBjb25maWd1cmVkIHdpdGggYGNsYXNzTmFtZWAuXG4gKiBAYXBpXG4gKi9cbnZhciBEcmFnWm9vbSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKERyYWdCb3gpIHtcbiAgZnVuY3Rpb24gRHJhZ1pvb20ob3B0X29wdGlvbnMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IG9wdF9vcHRpb25zID8gb3B0X29wdGlvbnMgOiB7fTtcblxuICAgIHZhciBjb25kaXRpb24gPSBvcHRpb25zLmNvbmRpdGlvbiA/IG9wdGlvbnMuY29uZGl0aW9uIDogc2hpZnRLZXlPbmx5O1xuXG4gICAgRHJhZ0JveC5jYWxsKHRoaXMsIHtcbiAgICAgIGNvbmRpdGlvbjogY29uZGl0aW9uLFxuICAgICAgY2xhc3NOYW1lOiBvcHRpb25zLmNsYXNzTmFtZSB8fCAnb2wtZHJhZ3pvb20nLFxuICAgICAgb25Cb3hFbmQ6IG9uQm94RW5kXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kdXJhdGlvbl8gPSBvcHRpb25zLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmR1cmF0aW9uIDogMjAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLm91dF8gPSBvcHRpb25zLm91dCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5vdXQgOiBmYWxzZTtcbiAgfVxuXG4gIGlmICggRHJhZ0JveCApIERyYWdab29tLl9fcHJvdG9fXyA9IERyYWdCb3g7XG4gIERyYWdab29tLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIERyYWdCb3ggJiYgRHJhZ0JveC5wcm90b3R5cGUgKTtcbiAgRHJhZ1pvb20ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRHJhZ1pvb207XG5cbiAgcmV0dXJuIERyYWdab29tO1xufShEcmFnQm94KSk7XG5cblxuLyoqXG4gKiBAdGhpcyB7RHJhZ1pvb219XG4gKi9cbmZ1bmN0aW9uIG9uQm94RW5kKCkge1xuICB2YXIgbWFwID0gdGhpcy5nZXRNYXAoKTtcbiAgdmFyIHZpZXcgPSAvKiogQHR5cGUgeyFpbXBvcnQoXCIuLi9WaWV3LmpzXCIpLmRlZmF1bHR9ICovIChtYXAuZ2V0VmlldygpKTtcbiAgdmFyIHNpemUgPSAvKiogQHR5cGUgeyFpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9ICovIChtYXAuZ2V0U2l6ZSgpKTtcbiAgdmFyIGV4dGVudCA9IHRoaXMuZ2V0R2VvbWV0cnkoKS5nZXRFeHRlbnQoKTtcblxuICBpZiAodGhpcy5vdXRfKSB7XG4gICAgdmFyIG1hcEV4dGVudCA9IHZpZXcuY2FsY3VsYXRlRXh0ZW50KHNpemUpO1xuICAgIHZhciBib3hQaXhlbEV4dGVudCA9IGNyZWF0ZU9yVXBkYXRlRnJvbUNvb3JkaW5hdGVzKFtcbiAgICAgIG1hcC5nZXRQaXhlbEZyb21Db29yZGluYXRlKGdldEJvdHRvbUxlZnQoZXh0ZW50KSksXG4gICAgICBtYXAuZ2V0UGl4ZWxGcm9tQ29vcmRpbmF0ZShnZXRUb3BSaWdodChleHRlbnQpKV0pO1xuICAgIHZhciBmYWN0b3IgPSB2aWV3LmdldFJlc29sdXRpb25Gb3JFeHRlbnQoYm94UGl4ZWxFeHRlbnQsIHNpemUpO1xuXG4gICAgc2NhbGVGcm9tQ2VudGVyKG1hcEV4dGVudCwgMSAvIGZhY3Rvcik7XG4gICAgZXh0ZW50ID0gbWFwRXh0ZW50O1xuICB9XG5cbiAgdmFyIHJlc29sdXRpb24gPSB2aWV3LmNvbnN0cmFpblJlc29sdXRpb24oXG4gICAgdmlldy5nZXRSZXNvbHV0aW9uRm9yRXh0ZW50KGV4dGVudCwgc2l6ZSkpO1xuXG4gIHZhciBjZW50ZXIgPSBnZXRDZW50ZXIoZXh0ZW50KTtcbiAgY2VudGVyID0gdmlldy5jb25zdHJhaW5DZW50ZXIoY2VudGVyKTtcblxuICB2aWV3LmFuaW1hdGUoe1xuICAgIHJlc29sdXRpb246IHJlc29sdXRpb24sXG4gICAgY2VudGVyOiBjZW50ZXIsXG4gICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb25fLFxuICAgIGVhc2luZzogZWFzZU91dFxuICB9KTtcbn1cblxuXG5leHBvcnQgZGVmYXVsdCBEcmFnWm9vbTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RHJhZ1pvb20uanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL0RyYXdcbiAqL1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBGZWF0dXJlIGZyb20gJy4uL0ZlYXR1cmUuanMnO1xuaW1wb3J0IE1hcEJyb3dzZXJFdmVudFR5cGUgZnJvbSAnLi4vTWFwQnJvd3NlckV2ZW50VHlwZS5qcyc7XG5pbXBvcnQgTWFwQnJvd3NlclBvaW50ZXJFdmVudCBmcm9tICcuLi9NYXBCcm93c2VyUG9pbnRlckV2ZW50LmpzJztcbmltcG9ydCB7Z2V0Q2hhbmdlRXZlbnRUeXBlfSBmcm9tICcuLi9PYmplY3QuanMnO1xuaW1wb3J0IHtzcXVhcmVkRGlzdGFuY2UgYXMgc3F1YXJlZENvb3JkaW5hdGVEaXN0YW5jZX0gZnJvbSAnLi4vY29vcmRpbmF0ZS5qcyc7XG5pbXBvcnQge2xpc3Rlbn0gZnJvbSAnLi4vZXZlbnRzLmpzJztcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMvRXZlbnQuanMnO1xuaW1wb3J0IHtub01vZGlmaWVyS2V5cywgYWx3YXlzLCBzaGlmdEtleU9ubHl9IGZyb20gJy4uL2V2ZW50cy9jb25kaXRpb24uanMnO1xuaW1wb3J0IHtib3VuZGluZ0V4dGVudCwgZ2V0Qm90dG9tTGVmdCwgZ2V0Qm90dG9tUmlnaHQsIGdldFRvcExlZnQsIGdldFRvcFJpZ2h0fSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IHtUUlVFLCBGQUxTRX0gZnJvbSAnLi4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCBDaXJjbGUgZnJvbSAnLi4vZ2VvbS9DaXJjbGUuanMnO1xuaW1wb3J0IEdlb21ldHJ5VHlwZSBmcm9tICcuLi9nZW9tL0dlb21ldHJ5VHlwZS5qcyc7XG5pbXBvcnQgTGluZVN0cmluZyBmcm9tICcuLi9nZW9tL0xpbmVTdHJpbmcuanMnO1xuaW1wb3J0IE11bHRpTGluZVN0cmluZyBmcm9tICcuLi9nZW9tL011bHRpTGluZVN0cmluZy5qcyc7XG5pbXBvcnQgTXVsdGlQb2ludCBmcm9tICcuLi9nZW9tL011bHRpUG9pbnQuanMnO1xuaW1wb3J0IE11bHRpUG9seWdvbiBmcm9tICcuLi9nZW9tL011bHRpUG9seWdvbi5qcyc7XG5pbXBvcnQge1BPSU5URVJfVFlQRX0gZnJvbSAnLi4vcG9pbnRlci9Nb3VzZVNvdXJjZS5qcyc7XG5pbXBvcnQgUG9pbnQgZnJvbSAnLi4vZ2VvbS9Qb2ludC5qcyc7XG5pbXBvcnQgUG9seWdvbiwge2Zyb21DaXJjbGUsIG1ha2VSZWd1bGFyfSBmcm9tICcuLi9nZW9tL1BvbHlnb24uanMnO1xuaW1wb3J0IFBvaW50ZXJJbnRlcmFjdGlvbiBmcm9tICcuL1BvaW50ZXIuanMnO1xuaW1wb3J0IEludGVyYWN0aW9uUHJvcGVydHkgZnJvbSAnLi9Qcm9wZXJ0eS5qcyc7XG5pbXBvcnQgVmVjdG9yTGF5ZXIgZnJvbSAnLi4vbGF5ZXIvVmVjdG9yLmpzJztcbmltcG9ydCBWZWN0b3JTb3VyY2UgZnJvbSAnLi4vc291cmNlL1ZlY3Rvci5qcyc7XG5pbXBvcnQge2NyZWF0ZUVkaXRpbmdTdHlsZX0gZnJvbSAnLi4vc3R5bGUvU3R5bGUuanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtHZW9tZXRyeVR5cGV9IHR5cGUgR2VvbWV0cnkgdHlwZSBvZlxuICogdGhlIGdlb21ldHJpZXMgYmVpbmcgZHJhd24gd2l0aCB0aGlzIGluc3RhbmNlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtjbGlja1RvbGVyYW5jZT02XSBUaGUgbWF4aW11bSBkaXN0YW5jZSBpbiBwaXhlbHMgYmV0d2VlblxuICogXCJkb3duXCIgYW5kIFwidXBcIiBmb3IgYSBcInVwXCIgZXZlbnQgdG8gYmUgY29uc2lkZXJlZCBhIFwiY2xpY2tcIiBldmVudCBhbmRcbiAqIGFjdHVhbGx5IGFkZCBhIHBvaW50L3ZlcnRleCB0byB0aGUgZ2VvbWV0cnkgYmVpbmcgZHJhd24uICBUaGUgZGVmYXVsdCBvZiBgNmBcbiAqIHdhcyBjaG9zZW4gZm9yIHRoZSBkcmF3IGludGVyYWN0aW9uIHRvIGJlaGF2ZSBjb3JyZWN0bHkgb24gbW91c2UgYXMgd2VsbCBhc1xuICogb24gdG91Y2ggZGV2aWNlcy5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vQ29sbGVjdGlvbi5qc1wiKS5kZWZhdWx0PEZlYXR1cmU+fSBbZmVhdHVyZXNdXG4gKiBEZXN0aW5hdGlvbiBjb2xsZWN0aW9uIGZvciB0aGUgZHJhd24gZmVhdHVyZXMuXG4gKiBAcHJvcGVydHkge1ZlY3RvclNvdXJjZX0gW3NvdXJjZV0gRGVzdGluYXRpb24gc291cmNlIGZvclxuICogdGhlIGRyYXduIGZlYXR1cmVzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkcmFnVmVydGV4RGVsYXk9NTAwXSBEZWxheSBpbiBtaWxsaXNlY29uZHMgYWZ0ZXIgcG9pbnRlcmRvd25cbiAqIGJlZm9yZSB0aGUgY3VycmVudCB2ZXJ0ZXggY2FuIGJlIGRyYWdnZWQgdG8gaXRzIGV4YWN0IHBvc2l0aW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtzbmFwVG9sZXJhbmNlPTEyXSBQaXhlbCBkaXN0YW5jZSBmb3Igc25hcHBpbmcgdG8gdGhlXG4gKiBkcmF3aW5nIGZpbmlzaC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3N0b3BDbGljaz1mYWxzZV0gU3RvcCBjbGljaywgc2luZ2xlY2xpY2ssIGFuZFxuICogZG91YmxlY2xpY2sgZXZlbnRzIGZyb20gZmlyaW5nIGR1cmluZyBkcmF3aW5nLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhQb2ludHNdIFRoZSBudW1iZXIgb2YgcG9pbnRzIHRoYXQgY2FuIGJlIGRyYXduIGJlZm9yZVxuICogYSBwb2x5Z29uIHJpbmcgb3IgbGluZSBzdHJpbmcgaXMgZmluaXNoZWQuIEJ5IGRlZmF1bHQgdGhlcmUgaXMgbm9cbiAqIHJlc3RyaWN0aW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5Qb2ludHNdIFRoZSBudW1iZXIgb2YgcG9pbnRzIHRoYXQgbXVzdCBiZSBkcmF3blxuICogYmVmb3JlIGEgcG9seWdvbiByaW5nIG9yIGxpbmUgc3RyaW5nIGNhbiBiZSBmaW5pc2hlZC4gRGVmYXVsdCBpcyBgM2AgZm9yXG4gKiBwb2x5Z29uIHJpbmdzIGFuZCBgMmAgZm9yIGxpbmUgc3RyaW5ncy5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259IFtmaW5pc2hDb25kaXRpb25dIEEgZnVuY3Rpb25cbiAqIHRoYXQgdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmQgcmV0dXJucyBhXG4gKiBib29sZWFuIHRvIGluZGljYXRlIHdoZXRoZXIgdGhlIGRyYXdpbmcgY2FuIGJlIGZpbmlzaGVkLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUxpa2V9IFtzdHlsZV1cbiAqIFN0eWxlIGZvciBza2V0Y2ggZmVhdHVyZXMuXG4gKiBAcHJvcGVydHkge0dlb21ldHJ5RnVuY3Rpb259IFtnZW9tZXRyeUZ1bmN0aW9uXVxuICogRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiBhIGdlb21ldHJ5J3MgY29vcmRpbmF0ZXMgYXJlIHVwZGF0ZWQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2dlb21ldHJ5TmFtZV0gR2VvbWV0cnkgbmFtZSB0byB1c2UgZm9yIGZlYXR1cmVzIGNyZWF0ZWRcbiAqIGJ5IHRoZSBkcmF3IGludGVyYWN0aW9uLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn0gW2NvbmRpdGlvbl0gQSBmdW5jdGlvbiB0aGF0XG4gKiB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnR9IGFuZCByZXR1cm5zIGFcbiAqIGJvb2xlYW4gdG8gaW5kaWNhdGUgd2hldGhlciB0aGF0IGV2ZW50IHNob3VsZCBiZSBoYW5kbGVkLlxuICogQnkgZGVmYXVsdCB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb25+bm9Nb2RpZmllcktleXN9LCBpLmUuIGEgY2xpY2ssXG4gKiBhZGRzIGEgdmVydGV4IG9yIGRlYWN0aXZhdGVzIGZyZWVoYW5kIGRyYXdpbmcuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtmcmVlaGFuZD1mYWxzZV0gT3BlcmF0ZSBpbiBmcmVlaGFuZCBtb2RlIGZvciBsaW5lcyxcbiAqIHBvbHlnb25zLCBhbmQgY2lyY2xlcy4gIFRoaXMgbWFrZXMgdGhlIGludGVyYWN0aW9uIGFsd2F5cyBvcGVyYXRlIGluIGZyZWVoYW5kXG4gKiBtb2RlIGFuZCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgYW55IGBmcmVlaGFuZENvbmRpdGlvbmAgb3B0aW9uLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn0gW2ZyZWVoYW5kQ29uZGl0aW9uXVxuICogQ29uZGl0aW9uIHRoYXQgYWN0aXZhdGVzIGZyZWVoYW5kIGRyYXdpbmcgZm9yIGxpbmVzIGFuZCBwb2x5Z29ucy4gVGhpc1xuICogZnVuY3Rpb24gdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmRcbiAqIHJldHVybnMgYSBib29sZWFuIHRvIGluZGljYXRlIHdoZXRoZXIgdGhhdCBldmVudCBzaG91bGQgYmUgaGFuZGxlZC4gVGhlXG4gKiBkZWZhdWx0IGlzIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbn5zaGlmdEtleU9ubHl9LCBtZWFuaW5nIHRoYXQgdGhlXG4gKiBTaGlmdCBrZXkgYWN0aXZhdGVzIGZyZWVoYW5kIGRyYXdpbmcuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt3cmFwWD1mYWxzZV0gV3JhcCB0aGUgd29ybGQgaG9yaXpvbnRhbGx5IG9uIHRoZSBza2V0Y2hcbiAqIG92ZXJsYXkuXG4gKi9cblxuXG4vKipcbiAqIENvb3JkaW5hdGUgdHlwZSB3aGVuIGRyYXdpbmcgcG9pbnRzLlxuICogQHR5cGVkZWYge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gUG9pbnRDb29yZFR5cGVcbiAqL1xuXG5cbi8qKlxuICogQ29vcmRpbmF0ZSB0eXBlIHdoZW4gZHJhd2luZyBsaW5lcy5cbiAqIEB0eXBlZGVmIHtBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSBMaW5lQ29vcmRUeXBlXG4gKi9cblxuXG4vKipcbiAqIENvb3JkaW5hdGUgdHlwZSB3aGVuIGRyYXdpbmcgcG9seWdvbnMuXG4gKiBAdHlwZWRlZiB7QXJyYXk8QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj59IFBvbHlDb29yZFR5cGVcbiAqL1xuXG5cbi8qKlxuICogVHlwZXMgdXNlZCBmb3IgZHJhd2luZyBjb29yZGluYXRlcy5cbiAqIEB0eXBlZGVmIHtQb2ludENvb3JkVHlwZXxMaW5lQ29vcmRUeXBlfFBvbHlDb29yZFR5cGV9IFNrZXRjaENvb3JkVHlwZVxuICovXG5cblxuLyoqXG4gKiBGdW5jdGlvbiB0aGF0IHRha2VzIGFuIGFycmF5IG9mIGNvb3JkaW5hdGVzIGFuZCBhbiBvcHRpb25hbCBleGlzdGluZyBnZW9tZXRyeSBhc1xuICogYXJndW1lbnRzLCBhbmQgcmV0dXJucyBhIGdlb21ldHJ5LiBUaGUgb3B0aW9uYWwgZXhpc3RpbmcgZ2VvbWV0cnkgaXMgdGhlXG4gKiBnZW9tZXRyeSB0aGF0IGlzIHJldHVybmVkIHdoZW4gdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRob3V0IGEgc2Vjb25kXG4gKiBhcmd1bWVudC5cbiAqIEB0eXBlZGVmIHtmdW5jdGlvbighU2tldGNoQ29vcmRUeXBlLCBpbXBvcnQoXCIuLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHQ9KTpcbiAqICAgICBpbXBvcnQoXCIuLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IEdlb21ldHJ5RnVuY3Rpb25cbiAqL1xuXG5cbi8qKlxuICogRHJhdyBtb2RlLiAgVGhpcyBjb2xsYXBzZXMgbXVsdGktcGFydCBnZW9tZXRyeSB0eXBlcyB3aXRoIHRoZWlyIHNpbmdsZS1wYXJ0XG4gKiBjb3VzaW5zLlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xudmFyIE1vZGUgPSB7XG4gIFBPSU5UOiAnUG9pbnQnLFxuICBMSU5FX1NUUklORzogJ0xpbmVTdHJpbmcnLFxuICBQT0xZR09OOiAnUG9seWdvbicsXG4gIENJUkNMRTogJ0NpcmNsZSdcbn07XG5cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG52YXIgRHJhd0V2ZW50VHlwZSA9IHtcbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB1cG9uIGZlYXR1cmUgZHJhdyBzdGFydFxuICAgKiBAZXZlbnQgRHJhd0V2ZW50I2RyYXdzdGFydFxuICAgKiBAYXBpXG4gICAqL1xuICBEUkFXU1RBUlQ6ICdkcmF3c3RhcnQnLFxuICAvKipcbiAgICogVHJpZ2dlcmVkIHVwb24gZmVhdHVyZSBkcmF3IGVuZFxuICAgKiBAZXZlbnQgRHJhd0V2ZW50I2RyYXdlbmRcbiAgICogQGFwaVxuICAgKi9cbiAgRFJBV0VORDogJ2RyYXdlbmQnXG59O1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogRXZlbnRzIGVtaXR0ZWQgYnkge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9EcmF3fkRyYXd9IGluc3RhbmNlcyBhcmVcbiAqIGluc3RhbmNlcyBvZiB0aGlzIHR5cGUuXG4gKi9cbnZhciBEcmF3RXZlbnQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChFdmVudCkge1xuICBmdW5jdGlvbiBEcmF3RXZlbnQodHlwZSwgZmVhdHVyZSkge1xuXG4gICAgRXZlbnQuY2FsbCh0aGlzLCB0eXBlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmZWF0dXJlIGJlaW5nIGRyYXduLlxuICAgICAqIEB0eXBlIHtGZWF0dXJlfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLmZlYXR1cmUgPSBmZWF0dXJlO1xuXG4gIH1cblxuICBpZiAoIEV2ZW50ICkgRHJhd0V2ZW50Ll9fcHJvdG9fXyA9IEV2ZW50O1xuICBEcmF3RXZlbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXZlbnQgJiYgRXZlbnQucHJvdG90eXBlICk7XG4gIERyYXdFdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEcmF3RXZlbnQ7XG5cbiAgcmV0dXJuIERyYXdFdmVudDtcbn0oRXZlbnQpKTtcblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEludGVyYWN0aW9uIGZvciBkcmF3aW5nIGZlYXR1cmUgZ2VvbWV0cmllcy5cbiAqXG4gKiBAZmlyZXMgRHJhd0V2ZW50XG4gKiBAYXBpXG4gKi9cbnZhciBEcmF3ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoUG9pbnRlckludGVyYWN0aW9uKSB7XG4gIGZ1bmN0aW9uIERyYXcob3B0aW9ucykge1xuXG4gICAgdmFyIHBvaW50ZXJPcHRpb25zID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL1BvaW50ZXIuanNcIikuT3B0aW9uc30gKi8gKG9wdGlvbnMpO1xuICAgIGlmICghcG9pbnRlck9wdGlvbnMuc3RvcERvd24pIHtcbiAgICAgIHBvaW50ZXJPcHRpb25zLnN0b3BEb3duID0gRkFMU0U7XG4gICAgfVxuXG4gICAgUG9pbnRlckludGVyYWN0aW9uLmNhbGwodGhpcywgcG9pbnRlck9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnNob3VsZEhhbmRsZV8gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9waXhlbC5qc1wiKS5QaXhlbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZG93blB4XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZG93blRpbWVvdXRfO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmxhc3REcmFnVGltZV87XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZnJlZWhhbmRfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUYXJnZXQgc291cmNlIGZvciBkcmF3biBmZWF0dXJlcy5cbiAgICAgKiBAdHlwZSB7VmVjdG9yU291cmNlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5zb3VyY2VfID0gb3B0aW9ucy5zb3VyY2UgPyBvcHRpb25zLnNvdXJjZSA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUYXJnZXQgY29sbGVjdGlvbiBmb3IgZHJhd24gZmVhdHVyZXMuXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL0NvbGxlY3Rpb24uanNcIikuZGVmYXVsdDxGZWF0dXJlPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZmVhdHVyZXNfID0gb3B0aW9ucy5mZWF0dXJlcyA/IG9wdGlvbnMuZmVhdHVyZXMgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogUGl4ZWwgZGlzdGFuY2UgZm9yIHNuYXBwaW5nLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnNuYXBUb2xlcmFuY2VfID0gb3B0aW9ucy5zbmFwVG9sZXJhbmNlID8gb3B0aW9ucy5zbmFwVG9sZXJhbmNlIDogMTI7XG5cbiAgICAvKipcbiAgICAgKiBHZW9tZXRyeSB0eXBlLlxuICAgICAqIEB0eXBlIHtHZW9tZXRyeVR5cGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnR5cGVfID0gLyoqIEB0eXBlIHtHZW9tZXRyeVR5cGV9ICovIChvcHRpb25zLnR5cGUpO1xuXG4gICAgLyoqXG4gICAgICogRHJhd2luZyBtb2RlIChkZXJpdmVkIGZyb20gZ2VvbWV0cnkgdHlwZS5cbiAgICAgKiBAdHlwZSB7TW9kZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubW9kZV8gPSBnZXRNb2RlKHRoaXMudHlwZV8pO1xuXG4gICAgLyoqXG4gICAgICogU3RvcCBjbGljaywgc2luZ2xlY2xpY2ssIGFuZCBkb3VibGVjbGljayBldmVudHMgZnJvbSBmaXJpbmcgZHVyaW5nIGRyYXdpbmcuXG4gICAgICogRGVmYXVsdCBpcyBgZmFsc2VgLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5zdG9wQ2xpY2tfID0gISFvcHRpb25zLnN0b3BDbGljaztcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgcG9pbnRzIHRoYXQgbXVzdCBiZSBkcmF3biBiZWZvcmUgYSBwb2x5Z29uIHJpbmcgb3IgbGluZVxuICAgICAqIHN0cmluZyBjYW4gYmUgZmluaXNoZWQuICBUaGUgZGVmYXVsdCBpcyAzIGZvciBwb2x5Z29uIHJpbmdzIGFuZCAyIGZvclxuICAgICAqIGxpbmUgc3RyaW5ncy5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5taW5Qb2ludHNfID0gb3B0aW9ucy5taW5Qb2ludHMgP1xuICAgICAgb3B0aW9ucy5taW5Qb2ludHMgOlxuICAgICAgKHRoaXMubW9kZV8gPT09IE1vZGUuUE9MWUdPTiA/IDMgOiAyKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgcG9pbnRzIHRoYXQgY2FuIGJlIGRyYXduIGJlZm9yZSBhIHBvbHlnb24gcmluZyBvciBsaW5lIHN0cmluZ1xuICAgICAqIGlzIGZpbmlzaGVkLiBUaGUgZGVmYXVsdCBpcyBubyByZXN0cmljdGlvbi5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5tYXhQb2ludHNfID0gb3B0aW9ucy5tYXhQb2ludHMgPyBvcHRpb25zLm1heFBvaW50cyA6IEluZmluaXR5O1xuXG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0byBkZWNpZGUgaWYgYSBwb3RlbnRpYWwgZmluaXNoIGNvb3JkaW5hdGUgaXMgcGVybWlzc2libGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmZpbmlzaENvbmRpdGlvbl8gPSBvcHRpb25zLmZpbmlzaENvbmRpdGlvbiA/IG9wdGlvbnMuZmluaXNoQ29uZGl0aW9uIDogVFJVRTtcblxuICAgIHZhciBnZW9tZXRyeUZ1bmN0aW9uID0gb3B0aW9ucy5nZW9tZXRyeUZ1bmN0aW9uO1xuICAgIGlmICghZ2VvbWV0cnlGdW5jdGlvbikge1xuICAgICAgaWYgKHRoaXMudHlwZV8gPT09IEdlb21ldHJ5VHlwZS5DSVJDTEUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7IUxpbmVDb29yZFR5cGV9IGNvb3JkaW5hdGVzIFRoZSBjb29yZGluYXRlcy5cbiAgICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHQ9fSBvcHRfZ2VvbWV0cnkgT3B0aW9uYWwgZ2VvbWV0cnkuXG4gICAgICAgICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2dlb20vU2ltcGxlR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gQSBnZW9tZXRyeS5cbiAgICAgICAgICovXG4gICAgICAgIGdlb21ldHJ5RnVuY3Rpb24gPSBmdW5jdGlvbihjb29yZGluYXRlcywgb3B0X2dlb21ldHJ5KSB7XG4gICAgICAgICAgdmFyIGNpcmNsZSA9IG9wdF9nZW9tZXRyeSA/IC8qKiBAdHlwZSB7Q2lyY2xlfSAqLyAob3B0X2dlb21ldHJ5KSA6XG4gICAgICAgICAgICBuZXcgQ2lyY2xlKFtOYU4sIE5hTl0pO1xuICAgICAgICAgIHZhciBzcXVhcmVkTGVuZ3RoID0gc3F1YXJlZENvb3JkaW5hdGVEaXN0YW5jZShcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzWzBdLCBjb29yZGluYXRlc1sxXSk7XG4gICAgICAgICAgY2lyY2xlLnNldENlbnRlckFuZFJhZGl1cyhjb29yZGluYXRlc1swXSwgTWF0aC5zcXJ0KHNxdWFyZWRMZW5ndGgpKTtcbiAgICAgICAgICByZXR1cm4gY2lyY2xlO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIENvbnN0cnVjdG9yO1xuICAgICAgICB2YXIgbW9kZSA9IHRoaXMubW9kZV87XG4gICAgICAgIGlmIChtb2RlID09PSBNb2RlLlBPSU5UKSB7XG4gICAgICAgICAgQ29uc3RydWN0b3IgPSBQb2ludDtcbiAgICAgICAgfSBlbHNlIGlmIChtb2RlID09PSBNb2RlLkxJTkVfU1RSSU5HKSB7XG4gICAgICAgICAgQ29uc3RydWN0b3IgPSBMaW5lU3RyaW5nO1xuICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT09IE1vZGUuUE9MWUdPTikge1xuICAgICAgICAgIENvbnN0cnVjdG9yID0gUG9seWdvbjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHshTGluZUNvb3JkVHlwZX0gY29vcmRpbmF0ZXMgVGhlIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vU2ltcGxlR2VvbWV0cnkuanNcIikuZGVmYXVsdD19IG9wdF9nZW9tZXRyeSBPcHRpb25hbCBnZW9tZXRyeS5cbiAgICAgICAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSBBIGdlb21ldHJ5LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2VvbWV0cnlGdW5jdGlvbiA9IGZ1bmN0aW9uKGNvb3JkaW5hdGVzLCBvcHRfZ2VvbWV0cnkpIHtcbiAgICAgICAgICB2YXIgZ2VvbWV0cnkgPSBvcHRfZ2VvbWV0cnk7XG4gICAgICAgICAgaWYgKGdlb21ldHJ5KSB7XG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gTW9kZS5QT0xZR09OKSB7XG4gICAgICAgICAgICAgIGlmIChjb29yZGluYXRlc1swXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgYSBjbG9zaW5nIGNvb3JkaW5hdGUgdG8gbWF0Y2ggdGhlIGZpcnN0XG4gICAgICAgICAgICAgICAgZ2VvbWV0cnkuc2V0Q29vcmRpbmF0ZXMoW2Nvb3JkaW5hdGVzWzBdLmNvbmNhdChbY29vcmRpbmF0ZXNbMF1bMF1dKV0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdlb21ldHJ5LnNldENvb3JkaW5hdGVzKFtdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZ2VvbWV0cnkuc2V0Q29vcmRpbmF0ZXMoY29vcmRpbmF0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBDb25zdHJ1Y3Rvcihjb29yZGluYXRlcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBnZW9tZXRyeTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7R2VvbWV0cnlGdW5jdGlvbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZ2VvbWV0cnlGdW5jdGlvbl8gPSBnZW9tZXRyeUZ1bmN0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZHJhZ1ZlcnRleERlbGF5XyA9IG9wdGlvbnMuZHJhZ1ZlcnRleERlbGF5ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRyYWdWZXJ0ZXhEZWxheSA6IDUwMDtcblxuICAgIC8qKlxuICAgICAqIEZpbmlzaCBjb29yZGluYXRlIGZvciB0aGUgZmVhdHVyZSAoZmlyc3QgcG9pbnQgZm9yIHBvbHlnb25zLCBsYXN0IHBvaW50IGZvclxuICAgICAqIGxpbmVzdHJpbmdzKS5cbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5maW5pc2hDb29yZGluYXRlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBTa2V0Y2ggZmVhdHVyZS5cbiAgICAgKiBAdHlwZSB7RmVhdHVyZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc2tldGNoRmVhdHVyZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogU2tldGNoIHBvaW50LlxuICAgICAqIEB0eXBlIHtGZWF0dXJlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5za2V0Y2hQb2ludF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogU2tldGNoIGNvb3JkaW5hdGVzLiBVc2VkIHdoZW4gZHJhd2luZyBhIGxpbmUgb3IgcG9seWdvbi5cbiAgICAgKiBAdHlwZSB7U2tldGNoQ29vcmRUeXBlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5za2V0Y2hDb29yZHNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFNrZXRjaCBsaW5lLiBVc2VkIHdoZW4gZHJhd2luZyBwb2x5Z29uLlxuICAgICAqIEB0eXBlIHtGZWF0dXJlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5za2V0Y2hMaW5lXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBTa2V0Y2ggbGluZSBjb29yZGluYXRlcy4gVXNlZCB3aGVuIGRyYXdpbmcgYSBwb2x5Z29uIG9yIGNpcmNsZS5cbiAgICAgKiBAdHlwZSB7TGluZUNvb3JkVHlwZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc2tldGNoTGluZUNvb3Jkc18gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogU3F1YXJlZCB0b2xlcmFuY2UgZm9yIGhhbmRsaW5nIHVwIGV2ZW50cy4gIElmIHRoZSBzcXVhcmVkIGRpc3RhbmNlXG4gICAgICogYmV0d2VlbiBhIGRvd24gYW5kIHVwIGV2ZW50IGlzIGdyZWF0ZXIgdGhhbiB0aGlzIHRvbGVyYW5jZSwgdXAgZXZlbnRzXG4gICAgICogd2lsbCBub3QgYmUgaGFuZGxlZC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5zcXVhcmVkQ2xpY2tUb2xlcmFuY2VfID0gb3B0aW9ucy5jbGlja1RvbGVyYW5jZSA/XG4gICAgICBvcHRpb25zLmNsaWNrVG9sZXJhbmNlICogb3B0aW9ucy5jbGlja1RvbGVyYW5jZSA6IDM2O1xuXG4gICAgLyoqXG4gICAgICogRHJhdyBvdmVybGF5IHdoZXJlIG91ciBza2V0Y2ggZmVhdHVyZXMgYXJlIGRyYXduLlxuICAgICAqIEB0eXBlIHtWZWN0b3JMYXllcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMub3ZlcmxheV8gPSBuZXcgVmVjdG9yTGF5ZXIoe1xuICAgICAgc291cmNlOiBuZXcgVmVjdG9yU291cmNlKHtcbiAgICAgICAgdXNlU3BhdGlhbEluZGV4OiBmYWxzZSxcbiAgICAgICAgd3JhcFg6IG9wdGlvbnMud3JhcFggPyBvcHRpb25zLndyYXBYIDogZmFsc2VcbiAgICAgIH0pLFxuICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUgPyBvcHRpb25zLnN0eWxlIDpcbiAgICAgICAgZ2V0RGVmYXVsdFN0eWxlRnVuY3Rpb24oKSxcbiAgICAgIHVwZGF0ZVdoaWxlSW50ZXJhY3Rpbmc6IHRydWVcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIE5hbWUgb2YgdGhlIGdlb21ldHJ5IGF0dHJpYnV0ZSBmb3IgbmV3bHkgY3JlYXRlZCBmZWF0dXJlcy5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfHVuZGVmaW5lZH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZ2VvbWV0cnlOYW1lXyA9IG9wdGlvbnMuZ2VvbWV0cnlOYW1lO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259XG4gICAgICovXG4gICAgdGhpcy5jb25kaXRpb25fID0gb3B0aW9ucy5jb25kaXRpb24gPyBvcHRpb25zLmNvbmRpdGlvbiA6IG5vTW9kaWZpZXJLZXlzO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259XG4gICAgICovXG4gICAgdGhpcy5mcmVlaGFuZENvbmRpdGlvbl87XG4gICAgaWYgKG9wdGlvbnMuZnJlZWhhbmQpIHtcbiAgICAgIHRoaXMuZnJlZWhhbmRDb25kaXRpb25fID0gYWx3YXlzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZyZWVoYW5kQ29uZGl0aW9uXyA9IG9wdGlvbnMuZnJlZWhhbmRDb25kaXRpb24gP1xuICAgICAgICBvcHRpb25zLmZyZWVoYW5kQ29uZGl0aW9uIDogc2hpZnRLZXlPbmx5O1xuICAgIH1cblxuICAgIGxpc3Rlbih0aGlzLFxuICAgICAgZ2V0Q2hhbmdlRXZlbnRUeXBlKEludGVyYWN0aW9uUHJvcGVydHkuQUNUSVZFKSxcbiAgICAgIHRoaXMudXBkYXRlU3RhdGVfLCB0aGlzKTtcblxuICB9XG5cbiAgaWYgKCBQb2ludGVySW50ZXJhY3Rpb24gKSBEcmF3Ll9fcHJvdG9fXyA9IFBvaW50ZXJJbnRlcmFjdGlvbjtcbiAgRHJhdy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQb2ludGVySW50ZXJhY3Rpb24gJiYgUG9pbnRlckludGVyYWN0aW9uLnByb3RvdHlwZSApO1xuICBEcmF3LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERyYXc7XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBEcmF3LnByb3RvdHlwZS5zZXRNYXAgPSBmdW5jdGlvbiBzZXRNYXAgKG1hcCkge1xuICAgIFBvaW50ZXJJbnRlcmFjdGlvbi5wcm90b3R5cGUuc2V0TWFwLmNhbGwodGhpcywgbWFwKTtcbiAgICB0aGlzLnVwZGF0ZVN0YXRlXygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG92ZXJsYXkgbGF5ZXIgdGhhdCB0aGlzIGludGVyYWN0aW9uIHJlbmRlcnMgc2tldGNoIGZlYXR1cmVzIHRvLlxuICAgKiBAcmV0dXJuIHtWZWN0b3JMYXllcn0gT3ZlcmxheSBsYXllci5cbiAgICogQGFwaVxuICAgKi9cbiAgRHJhdy5wcm90b3R5cGUuZ2V0T3ZlcmxheSA9IGZ1bmN0aW9uIGdldE92ZXJsYXkgKCkge1xuICAgIHJldHVybiB0aGlzLm92ZXJsYXlfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudCBtYXAgYnJvd3NlciBldmVudH0gYW5kIG1heSBhY3R1YWxseSBkcmF3IG9yIGZpbmlzaCB0aGUgZHJhd2luZy5cbiAgICogQG92ZXJyaWRlXG4gICAqIEBhcGlcbiAgICovXG4gIERyYXcucHJvdG90eXBlLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24gaGFuZGxlRXZlbnQgKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50Lm9yaWdpbmFsRXZlbnQudHlwZSA9PT0gRXZlbnRUeXBlLkNPTlRFWFRNRU5VKSB7XG4gICAgICAvLyBBdm9pZCBjb250ZXh0IG1lbnUgZm9yIGxvbmcgdGFwcyB3aGVuIGRyYXdpbmcgb24gbW9iaWxlXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICB0aGlzLmZyZWVoYW5kXyA9IHRoaXMubW9kZV8gIT09IE1vZGUuUE9JTlQgJiYgdGhpcy5mcmVlaGFuZENvbmRpdGlvbl8oZXZlbnQpO1xuICAgIHZhciBtb3ZlID0gZXZlbnQudHlwZSA9PT0gTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSTU9WRTtcbiAgICB2YXIgcGFzcyA9IHRydWU7XG4gICAgaWYgKCF0aGlzLmZyZWVoYW5kXyAmJiB0aGlzLmxhc3REcmFnVGltZV8gJiYgZXZlbnQudHlwZSA9PT0gTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSRFJBRykge1xuICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICBpZiAobm93IC0gdGhpcy5sYXN0RHJhZ1RpbWVfID49IHRoaXMuZHJhZ1ZlcnRleERlbGF5Xykge1xuICAgICAgICB0aGlzLmRvd25QeF8gPSBldmVudC5waXhlbDtcbiAgICAgICAgdGhpcy5zaG91bGRIYW5kbGVfID0gIXRoaXMuZnJlZWhhbmRfO1xuICAgICAgICBtb3ZlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGFzdERyYWdUaW1lXyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNob3VsZEhhbmRsZV8gJiYgdGhpcy5kb3duVGltZW91dF8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kb3duVGltZW91dF8pO1xuICAgICAgICB0aGlzLmRvd25UaW1lb3V0XyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuZnJlZWhhbmRfICYmXG4gICAgICAgIGV2ZW50LnR5cGUgPT09IE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUkRSQUcgJiZcbiAgICAgICAgdGhpcy5za2V0Y2hGZWF0dXJlXyAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5hZGRUb0RyYXdpbmdfKGV2ZW50KTtcbiAgICAgIHBhc3MgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZnJlZWhhbmRfICYmXG4gICAgICAgIGV2ZW50LnR5cGUgPT09IE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUkRPV04pIHtcbiAgICAgIHBhc3MgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKG1vdmUpIHtcbiAgICAgIHBhc3MgPSBldmVudC50eXBlID09PSBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJNT1ZFO1xuICAgICAgaWYgKHBhc3MgJiYgdGhpcy5mcmVlaGFuZF8pIHtcbiAgICAgICAgcGFzcyA9IHRoaXMuaGFuZGxlUG9pbnRlck1vdmVfKGV2ZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoLyoqIEB0eXBlIHtNYXBCcm93c2VyUG9pbnRlckV2ZW50fSAqLyAoZXZlbnQpLnBvaW50ZXJFdmVudC5wb2ludGVyVHlwZSA9PSBQT0lOVEVSX1RZUEUgfHxcbiAgICAgICAgICAoZXZlbnQudHlwZSA9PT0gTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSRFJBRyAmJiB0aGlzLmRvd25UaW1lb3V0XyA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJNb3ZlXyhldmVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChldmVudC50eXBlID09PSBNYXBCcm93c2VyRXZlbnRUeXBlLkRCTENMSUNLKSB7XG4gICAgICBwYXNzID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIFBvaW50ZXJJbnRlcmFjdGlvbi5wcm90b3R5cGUuaGFuZGxlRXZlbnQuY2FsbCh0aGlzLCBldmVudCkgJiYgcGFzcztcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIERyYXcucHJvdG90eXBlLmhhbmRsZURvd25FdmVudCA9IGZ1bmN0aW9uIGhhbmRsZURvd25FdmVudCAoZXZlbnQpIHtcbiAgICB0aGlzLnNob3VsZEhhbmRsZV8gPSAhdGhpcy5mcmVlaGFuZF87XG5cbiAgICBpZiAodGhpcy5mcmVlaGFuZF8pIHtcbiAgICAgIHRoaXMuZG93blB4XyA9IGV2ZW50LnBpeGVsO1xuICAgICAgaWYgKCF0aGlzLmZpbmlzaENvb3JkaW5hdGVfKSB7XG4gICAgICAgIHRoaXMuc3RhcnREcmF3aW5nXyhldmVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY29uZGl0aW9uXyhldmVudCkpIHtcbiAgICAgIHRoaXMubGFzdERyYWdUaW1lXyA9IERhdGUubm93KCk7XG4gICAgICB0aGlzLmRvd25UaW1lb3V0XyA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlck1vdmVfKG5ldyBNYXBCcm93c2VyUG9pbnRlckV2ZW50KFxuICAgICAgICAgIE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUk1PVkUsIGV2ZW50Lm1hcCwgZXZlbnQucG9pbnRlckV2ZW50LCBmYWxzZSwgZXZlbnQuZnJhbWVTdGF0ZSkpO1xuICAgICAgfS5iaW5kKHRoaXMpLCB0aGlzLmRyYWdWZXJ0ZXhEZWxheV8pO1xuICAgICAgdGhpcy5kb3duUHhfID0gZXZlbnQucGl4ZWw7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgRHJhdy5wcm90b3R5cGUuaGFuZGxlVXBFdmVudCA9IGZ1bmN0aW9uIGhhbmRsZVVwRXZlbnQgKGV2ZW50KSB7XG4gICAgdmFyIHBhc3MgPSB0cnVlO1xuXG4gICAgaWYgKHRoaXMuZG93blRpbWVvdXRfKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5kb3duVGltZW91dF8pO1xuICAgICAgdGhpcy5kb3duVGltZW91dF8gPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdGhpcy5oYW5kbGVQb2ludGVyTW92ZV8oZXZlbnQpO1xuXG4gICAgdmFyIGNpcmNsZU1vZGUgPSB0aGlzLm1vZGVfID09PSBNb2RlLkNJUkNMRTtcblxuICAgIGlmICh0aGlzLnNob3VsZEhhbmRsZV8pIHtcbiAgICAgIGlmICghdGhpcy5maW5pc2hDb29yZGluYXRlXykge1xuICAgICAgICB0aGlzLnN0YXJ0RHJhd2luZ18oZXZlbnQpO1xuICAgICAgICBpZiAodGhpcy5tb2RlXyA9PT0gTW9kZS5QT0lOVCkge1xuICAgICAgICAgIHRoaXMuZmluaXNoRHJhd2luZygpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZnJlZWhhbmRfIHx8IGNpcmNsZU1vZGUpIHtcbiAgICAgICAgdGhpcy5maW5pc2hEcmF3aW5nKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuYXRGaW5pc2hfKGV2ZW50KSkge1xuICAgICAgICBpZiAodGhpcy5maW5pc2hDb25kaXRpb25fKGV2ZW50KSkge1xuICAgICAgICAgIHRoaXMuZmluaXNoRHJhd2luZygpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFkZFRvRHJhd2luZ18oZXZlbnQpO1xuICAgICAgfVxuICAgICAgcGFzcyA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5mcmVlaGFuZF8pIHtcbiAgICAgIHRoaXMuZmluaXNoQ29vcmRpbmF0ZV8gPSBudWxsO1xuICAgICAgdGhpcy5hYm9ydERyYXdpbmdfKCk7XG4gICAgfVxuICAgIGlmICghcGFzcyAmJiB0aGlzLnN0b3BDbGlja18pIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cbiAgICByZXR1cm4gcGFzcztcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIG1vdmUgZXZlbnRzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBldmVudCBBIG1vdmUgZXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFBhc3MgdGhlIGV2ZW50IHRvIG90aGVyIGludGVyYWN0aW9ucy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIERyYXcucHJvdG90eXBlLmhhbmRsZVBvaW50ZXJNb3ZlXyA9IGZ1bmN0aW9uIGhhbmRsZVBvaW50ZXJNb3ZlXyAoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5kb3duUHhfICYmXG4gICAgICAgICgoIXRoaXMuZnJlZWhhbmRfICYmIHRoaXMuc2hvdWxkSGFuZGxlXykgfHxcbiAgICAgICAgKHRoaXMuZnJlZWhhbmRfICYmICF0aGlzLnNob3VsZEhhbmRsZV8pKSkge1xuICAgICAgdmFyIGRvd25QeCA9IHRoaXMuZG93blB4XztcbiAgICAgIHZhciBjbGlja1B4ID0gZXZlbnQucGl4ZWw7XG4gICAgICB2YXIgZHggPSBkb3duUHhbMF0gLSBjbGlja1B4WzBdO1xuICAgICAgdmFyIGR5ID0gZG93blB4WzFdIC0gY2xpY2tQeFsxXTtcbiAgICAgIHZhciBzcXVhcmVkRGlzdGFuY2UgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgIHRoaXMuc2hvdWxkSGFuZGxlXyA9IHRoaXMuZnJlZWhhbmRfID9cbiAgICAgICAgc3F1YXJlZERpc3RhbmNlID4gdGhpcy5zcXVhcmVkQ2xpY2tUb2xlcmFuY2VfIDpcbiAgICAgICAgc3F1YXJlZERpc3RhbmNlIDw9IHRoaXMuc3F1YXJlZENsaWNrVG9sZXJhbmNlXztcbiAgICAgIGlmICghdGhpcy5zaG91bGRIYW5kbGVfKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmZpbmlzaENvb3JkaW5hdGVfKSB7XG4gICAgICB0aGlzLm1vZGlmeURyYXdpbmdfKGV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jcmVhdGVPclVwZGF0ZVNrZXRjaFBvaW50XyhldmVudCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgYW4gZXZlbnQgaXMgd2l0aGluIHRoZSBzbmFwcGluZyB0b2xlcmFuY2Ugb2YgdGhlIHN0YXJ0IGNvb3JkLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBldmVudCBFdmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGV2ZW50IGlzIHdpdGhpbiB0aGUgc25hcHBpbmcgdG9sZXJhbmNlIG9mIHRoZSBzdGFydC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIERyYXcucHJvdG90eXBlLmF0RmluaXNoXyA9IGZ1bmN0aW9uIGF0RmluaXNoXyAoZXZlbnQpIHtcbiAgICB2YXIgYXQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5za2V0Y2hGZWF0dXJlXykge1xuICAgICAgdmFyIHBvdGVudGlhbGx5RG9uZSA9IGZhbHNlO1xuICAgICAgdmFyIHBvdGVudGlhbGx5RmluaXNoQ29vcmRpbmF0ZXMgPSBbdGhpcy5maW5pc2hDb29yZGluYXRlX107XG4gICAgICBpZiAodGhpcy5tb2RlXyA9PT0gTW9kZS5MSU5FX1NUUklORykge1xuICAgICAgICBwb3RlbnRpYWxseURvbmUgPSB0aGlzLnNrZXRjaENvb3Jkc18ubGVuZ3RoID4gdGhpcy5taW5Qb2ludHNfO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm1vZGVfID09PSBNb2RlLlBPTFlHT04pIHtcbiAgICAgICAgdmFyIHNrZXRjaENvb3JkcyA9IC8qKiBAdHlwZSB7UG9seUNvb3JkVHlwZX0gKi8gKHRoaXMuc2tldGNoQ29vcmRzXyk7XG4gICAgICAgIHBvdGVudGlhbGx5RG9uZSA9IHNrZXRjaENvb3Jkc1swXS5sZW5ndGggPiB0aGlzLm1pblBvaW50c187XG4gICAgICAgIHBvdGVudGlhbGx5RmluaXNoQ29vcmRpbmF0ZXMgPSBbc2tldGNoQ29vcmRzWzBdWzBdLCBza2V0Y2hDb29yZHNbMF1bc2tldGNoQ29vcmRzWzBdLmxlbmd0aCAtIDJdXTtcbiAgICAgIH1cbiAgICAgIGlmIChwb3RlbnRpYWxseURvbmUpIHtcbiAgICAgICAgdmFyIG1hcCA9IGV2ZW50Lm1hcDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcG90ZW50aWFsbHlGaW5pc2hDb29yZGluYXRlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgdmFyIGZpbmlzaENvb3JkaW5hdGUgPSBwb3RlbnRpYWxseUZpbmlzaENvb3JkaW5hdGVzW2ldO1xuICAgICAgICAgIHZhciBmaW5pc2hQaXhlbCA9IG1hcC5nZXRQaXhlbEZyb21Db29yZGluYXRlKGZpbmlzaENvb3JkaW5hdGUpO1xuICAgICAgICAgIHZhciBwaXhlbCA9IGV2ZW50LnBpeGVsO1xuICAgICAgICAgIHZhciBkeCA9IHBpeGVsWzBdIC0gZmluaXNoUGl4ZWxbMF07XG4gICAgICAgICAgdmFyIGR5ID0gcGl4ZWxbMV0gLSBmaW5pc2hQaXhlbFsxXTtcbiAgICAgICAgICB2YXIgc25hcFRvbGVyYW5jZSA9IHRoaXMuZnJlZWhhbmRfID8gMSA6IHRoaXMuc25hcFRvbGVyYW5jZV87XG4gICAgICAgICAgYXQgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpIDw9IHNuYXBUb2xlcmFuY2U7XG4gICAgICAgICAgaWYgKGF0KSB7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaENvb3JkaW5hdGVfID0gZmluaXNoQ29vcmRpbmF0ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IGV2ZW50IEV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgRHJhdy5wcm90b3R5cGUuY3JlYXRlT3JVcGRhdGVTa2V0Y2hQb2ludF8gPSBmdW5jdGlvbiBjcmVhdGVPclVwZGF0ZVNrZXRjaFBvaW50XyAoZXZlbnQpIHtcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBldmVudC5jb29yZGluYXRlLnNsaWNlKCk7XG4gICAgaWYgKCF0aGlzLnNrZXRjaFBvaW50Xykge1xuICAgICAgdGhpcy5za2V0Y2hQb2ludF8gPSBuZXcgRmVhdHVyZShuZXcgUG9pbnQoY29vcmRpbmF0ZXMpKTtcbiAgICAgIHRoaXMudXBkYXRlU2tldGNoRmVhdHVyZXNfKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBza2V0Y2hQb2ludEdlb20gPSAvKiogQHR5cGUge1BvaW50fSAqLyAodGhpcy5za2V0Y2hQb2ludF8uZ2V0R2VvbWV0cnkoKSk7XG4gICAgICBza2V0Y2hQb2ludEdlb20uc2V0Q29vcmRpbmF0ZXMoY29vcmRpbmF0ZXMpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU3RhcnQgdGhlIGRyYXdpbmcuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IGV2ZW50IEV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgRHJhdy5wcm90b3R5cGUuc3RhcnREcmF3aW5nXyA9IGZ1bmN0aW9uIHN0YXJ0RHJhd2luZ18gKGV2ZW50KSB7XG4gICAgdmFyIHN0YXJ0ID0gZXZlbnQuY29vcmRpbmF0ZTtcbiAgICB0aGlzLmZpbmlzaENvb3JkaW5hdGVfID0gc3RhcnQ7XG4gICAgaWYgKHRoaXMubW9kZV8gPT09IE1vZGUuUE9JTlQpIHtcbiAgICAgIHRoaXMuc2tldGNoQ29vcmRzXyA9IHN0YXJ0LnNsaWNlKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1vZGVfID09PSBNb2RlLlBPTFlHT04pIHtcbiAgICAgIHRoaXMuc2tldGNoQ29vcmRzXyA9IFtbc3RhcnQuc2xpY2UoKSwgc3RhcnQuc2xpY2UoKV1dO1xuICAgICAgdGhpcy5za2V0Y2hMaW5lQ29vcmRzXyA9IHRoaXMuc2tldGNoQ29vcmRzX1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5za2V0Y2hDb29yZHNfID0gW3N0YXJ0LnNsaWNlKCksIHN0YXJ0LnNsaWNlKCldO1xuICAgIH1cbiAgICBpZiAodGhpcy5za2V0Y2hMaW5lQ29vcmRzXykge1xuICAgICAgdGhpcy5za2V0Y2hMaW5lXyA9IG5ldyBGZWF0dXJlKFxuICAgICAgICBuZXcgTGluZVN0cmluZyh0aGlzLnNrZXRjaExpbmVDb29yZHNfKSk7XG4gICAgfVxuICAgIHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnlGdW5jdGlvbl8odGhpcy5za2V0Y2hDb29yZHNfKTtcbiAgICB0aGlzLnNrZXRjaEZlYXR1cmVfID0gbmV3IEZlYXR1cmUoKTtcbiAgICBpZiAodGhpcy5nZW9tZXRyeU5hbWVfKSB7XG4gICAgICB0aGlzLnNrZXRjaEZlYXR1cmVfLnNldEdlb21ldHJ5TmFtZSh0aGlzLmdlb21ldHJ5TmFtZV8pO1xuICAgIH1cbiAgICB0aGlzLnNrZXRjaEZlYXR1cmVfLnNldEdlb21ldHJ5KGdlb21ldHJ5KTtcbiAgICB0aGlzLnVwZGF0ZVNrZXRjaEZlYXR1cmVzXygpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRHJhd0V2ZW50KERyYXdFdmVudFR5cGUuRFJBV1NUQVJULCB0aGlzLnNrZXRjaEZlYXR1cmVfKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1vZGlmeSB0aGUgZHJhd2luZy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gZXZlbnQgRXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBEcmF3LnByb3RvdHlwZS5tb2RpZnlEcmF3aW5nXyA9IGZ1bmN0aW9uIG1vZGlmeURyYXdpbmdfIChldmVudCkge1xuICAgIHZhciBjb29yZGluYXRlID0gZXZlbnQuY29vcmRpbmF0ZTtcbiAgICB2YXIgZ2VvbWV0cnkgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL2dlb20vU2ltcGxlR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gKi8gKHRoaXMuc2tldGNoRmVhdHVyZV8uZ2V0R2VvbWV0cnkoKSk7XG4gICAgdmFyIGNvb3JkaW5hdGVzLCBsYXN0O1xuICAgIGlmICh0aGlzLm1vZGVfID09PSBNb2RlLlBPSU5UKSB7XG4gICAgICBsYXN0ID0gdGhpcy5za2V0Y2hDb29yZHNfO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tb2RlXyA9PT0gTW9kZS5QT0xZR09OKSB7XG4gICAgICBjb29yZGluYXRlcyA9IC8qKiBAdHlwZSB7UG9seUNvb3JkVHlwZX0gKi8gKHRoaXMuc2tldGNoQ29vcmRzXylbMF07XG4gICAgICBsYXN0ID0gY29vcmRpbmF0ZXNbY29vcmRpbmF0ZXMubGVuZ3RoIC0gMV07XG4gICAgICBpZiAodGhpcy5hdEZpbmlzaF8oZXZlbnQpKSB7XG4gICAgICAgIC8vIHNuYXAgdG8gZmluaXNoXG4gICAgICAgIGNvb3JkaW5hdGUgPSB0aGlzLmZpbmlzaENvb3JkaW5hdGVfLnNsaWNlKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvb3JkaW5hdGVzID0gdGhpcy5za2V0Y2hDb29yZHNfO1xuICAgICAgbGFzdCA9IGNvb3JkaW5hdGVzW2Nvb3JkaW5hdGVzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBsYXN0WzBdID0gY29vcmRpbmF0ZVswXTtcbiAgICBsYXN0WzFdID0gY29vcmRpbmF0ZVsxXTtcbiAgICB0aGlzLmdlb21ldHJ5RnVuY3Rpb25fKC8qKiBAdHlwZSB7IUxpbmVDb29yZFR5cGV9ICovICh0aGlzLnNrZXRjaENvb3Jkc18pLCBnZW9tZXRyeSk7XG4gICAgaWYgKHRoaXMuc2tldGNoUG9pbnRfKSB7XG4gICAgICB2YXIgc2tldGNoUG9pbnRHZW9tID0gLyoqIEB0eXBlIHtQb2ludH0gKi8gKHRoaXMuc2tldGNoUG9pbnRfLmdldEdlb21ldHJ5KCkpO1xuICAgICAgc2tldGNoUG9pbnRHZW9tLnNldENvb3JkaW5hdGVzKGNvb3JkaW5hdGUpO1xuICAgIH1cbiAgICAvKiogQHR5cGUge0xpbmVTdHJpbmd9ICovXG4gICAgdmFyIHNrZXRjaExpbmVHZW9tO1xuICAgIGlmIChnZW9tZXRyeS5nZXRUeXBlKCkgPT0gR2VvbWV0cnlUeXBlLlBPTFlHT04gJiZcbiAgICAgICAgdGhpcy5tb2RlXyAhPT0gTW9kZS5QT0xZR09OKSB7XG4gICAgICBpZiAoIXRoaXMuc2tldGNoTGluZV8pIHtcbiAgICAgICAgdGhpcy5za2V0Y2hMaW5lXyA9IG5ldyBGZWF0dXJlKCk7XG4gICAgICB9XG4gICAgICB2YXIgcmluZyA9IC8qKiBAdHlwZSB7UG9seWdvbn0gKi8gKGdlb21ldHJ5KS5nZXRMaW5lYXJSaW5nKDApO1xuICAgICAgc2tldGNoTGluZUdlb20gPSAvKiogQHR5cGUge0xpbmVTdHJpbmd9ICovICh0aGlzLnNrZXRjaExpbmVfLmdldEdlb21ldHJ5KCkpO1xuICAgICAgaWYgKCFza2V0Y2hMaW5lR2VvbSkge1xuICAgICAgICBza2V0Y2hMaW5lR2VvbSA9IG5ldyBMaW5lU3RyaW5nKHJpbmcuZ2V0RmxhdENvb3JkaW5hdGVzKCksIHJpbmcuZ2V0TGF5b3V0KCkpO1xuICAgICAgICB0aGlzLnNrZXRjaExpbmVfLnNldEdlb21ldHJ5KHNrZXRjaExpbmVHZW9tKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNrZXRjaExpbmVHZW9tLnNldEZsYXRDb29yZGluYXRlcyhcbiAgICAgICAgICByaW5nLmdldExheW91dCgpLCByaW5nLmdldEZsYXRDb29yZGluYXRlcygpKTtcbiAgICAgICAgc2tldGNoTGluZUdlb20uY2hhbmdlZCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5za2V0Y2hMaW5lQ29vcmRzXykge1xuICAgICAgc2tldGNoTGluZUdlb20gPSAvKiogQHR5cGUge0xpbmVTdHJpbmd9ICovICh0aGlzLnNrZXRjaExpbmVfLmdldEdlb21ldHJ5KCkpO1xuICAgICAgc2tldGNoTGluZUdlb20uc2V0Q29vcmRpbmF0ZXModGhpcy5za2V0Y2hMaW5lQ29vcmRzXyk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlU2tldGNoRmVhdHVyZXNfKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIG5ldyBjb29yZGluYXRlIHRvIHRoZSBkcmF3aW5nLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBldmVudCBFdmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIERyYXcucHJvdG90eXBlLmFkZFRvRHJhd2luZ18gPSBmdW5jdGlvbiBhZGRUb0RyYXdpbmdfIChldmVudCkge1xuICAgIHZhciBjb29yZGluYXRlID0gZXZlbnQuY29vcmRpbmF0ZTtcbiAgICB2YXIgZ2VvbWV0cnkgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL2dlb20vU2ltcGxlR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gKi8gKHRoaXMuc2tldGNoRmVhdHVyZV8uZ2V0R2VvbWV0cnkoKSk7XG4gICAgdmFyIGRvbmU7XG4gICAgdmFyIGNvb3JkaW5hdGVzO1xuICAgIGlmICh0aGlzLm1vZGVfID09PSBNb2RlLkxJTkVfU1RSSU5HKSB7XG4gICAgICB0aGlzLmZpbmlzaENvb3JkaW5hdGVfID0gY29vcmRpbmF0ZS5zbGljZSgpO1xuICAgICAgY29vcmRpbmF0ZXMgPSAvKiogQHR5cGUge0xpbmVDb29yZFR5cGV9ICovICh0aGlzLnNrZXRjaENvb3Jkc18pO1xuICAgICAgaWYgKGNvb3JkaW5hdGVzLmxlbmd0aCA+PSB0aGlzLm1heFBvaW50c18pIHtcbiAgICAgICAgaWYgKHRoaXMuZnJlZWhhbmRfKSB7XG4gICAgICAgICAgY29vcmRpbmF0ZXMucG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvb3JkaW5hdGVzLnB1c2goY29vcmRpbmF0ZS5zbGljZSgpKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnlGdW5jdGlvbl8oY29vcmRpbmF0ZXMsIGdlb21ldHJ5KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubW9kZV8gPT09IE1vZGUuUE9MWUdPTikge1xuICAgICAgY29vcmRpbmF0ZXMgPSAvKiogQHR5cGUge1BvbHlDb29yZFR5cGV9ICovICh0aGlzLnNrZXRjaENvb3Jkc18pWzBdO1xuICAgICAgaWYgKGNvb3JkaW5hdGVzLmxlbmd0aCA+PSB0aGlzLm1heFBvaW50c18pIHtcbiAgICAgICAgaWYgKHRoaXMuZnJlZWhhbmRfKSB7XG4gICAgICAgICAgY29vcmRpbmF0ZXMucG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvb3JkaW5hdGVzLnB1c2goY29vcmRpbmF0ZS5zbGljZSgpKTtcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIHRoaXMuZmluaXNoQ29vcmRpbmF0ZV8gPSBjb29yZGluYXRlc1swXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZ2VvbWV0cnlGdW5jdGlvbl8odGhpcy5za2V0Y2hDb29yZHNfLCBnZW9tZXRyeSk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlU2tldGNoRmVhdHVyZXNfKCk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIHRoaXMuZmluaXNoRHJhd2luZygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGxhc3QgcG9pbnQgb2YgdGhlIGZlYXR1cmUgY3VycmVudGx5IGJlaW5nIGRyYXduLlxuICAgKiBAYXBpXG4gICAqL1xuICBEcmF3LnByb3RvdHlwZS5yZW1vdmVMYXN0UG9pbnQgPSBmdW5jdGlvbiByZW1vdmVMYXN0UG9pbnQgKCkge1xuICAgIGlmICghdGhpcy5za2V0Y2hGZWF0dXJlXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZ2VvbWV0cnkgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL2dlb20vU2ltcGxlR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gKi8gKHRoaXMuc2tldGNoRmVhdHVyZV8uZ2V0R2VvbWV0cnkoKSk7XG4gICAgdmFyIGNvb3JkaW5hdGVzO1xuICAgIC8qKiBAdHlwZSB7TGluZVN0cmluZ30gKi9cbiAgICB2YXIgc2tldGNoTGluZUdlb207XG4gICAgaWYgKHRoaXMubW9kZV8gPT09IE1vZGUuTElORV9TVFJJTkcpIHtcbiAgICAgIGNvb3JkaW5hdGVzID0gLyoqIEB0eXBlIHtMaW5lQ29vcmRUeXBlfSAqLyAodGhpcy5za2V0Y2hDb29yZHNfKTtcbiAgICAgIGNvb3JkaW5hdGVzLnNwbGljZSgtMiwgMSk7XG4gICAgICB0aGlzLmdlb21ldHJ5RnVuY3Rpb25fKGNvb3JkaW5hdGVzLCBnZW9tZXRyeSk7XG4gICAgICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgdGhpcy5maW5pc2hDb29yZGluYXRlXyA9IGNvb3JkaW5hdGVzW2Nvb3JkaW5hdGVzLmxlbmd0aCAtIDJdLnNsaWNlKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLm1vZGVfID09PSBNb2RlLlBPTFlHT04pIHtcbiAgICAgIGNvb3JkaW5hdGVzID0gLyoqIEB0eXBlIHtQb2x5Q29vcmRUeXBlfSAqLyAodGhpcy5za2V0Y2hDb29yZHNfKVswXTtcbiAgICAgIGNvb3JkaW5hdGVzLnNwbGljZSgtMiwgMSk7XG4gICAgICBza2V0Y2hMaW5lR2VvbSA9IC8qKiBAdHlwZSB7TGluZVN0cmluZ30gKi8gKHRoaXMuc2tldGNoTGluZV8uZ2V0R2VvbWV0cnkoKSk7XG4gICAgICBza2V0Y2hMaW5lR2VvbS5zZXRDb29yZGluYXRlcyhjb29yZGluYXRlcyk7XG4gICAgICB0aGlzLmdlb21ldHJ5RnVuY3Rpb25fKHRoaXMuc2tldGNoQ29vcmRzXywgZ2VvbWV0cnkpO1xuICAgIH1cblxuICAgIGlmIChjb29yZGluYXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuZmluaXNoQ29vcmRpbmF0ZV8gPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlU2tldGNoRmVhdHVyZXNfKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0b3AgZHJhd2luZyBhbmQgYWRkIHRoZSBza2V0Y2ggZmVhdHVyZSB0byB0aGUgdGFyZ2V0IGxheWVyLlxuICAgKiBUaGUge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9EcmF3fkRyYXdFdmVudFR5cGUuRFJBV0VORH0gZXZlbnQgaXNcbiAgICogZGlzcGF0Y2hlZCBiZWZvcmUgaW5zZXJ0aW5nIHRoZSBmZWF0dXJlLlxuICAgKiBAYXBpXG4gICAqL1xuICBEcmF3LnByb3RvdHlwZS5maW5pc2hEcmF3aW5nID0gZnVuY3Rpb24gZmluaXNoRHJhd2luZyAoKSB7XG4gICAgdmFyIHNrZXRjaEZlYXR1cmUgPSB0aGlzLmFib3J0RHJhd2luZ18oKTtcbiAgICBpZiAoIXNrZXRjaEZlYXR1cmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gdGhpcy5za2V0Y2hDb29yZHNfO1xuICAgIHZhciBnZW9tZXRyeSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSAqLyAoc2tldGNoRmVhdHVyZS5nZXRHZW9tZXRyeSgpKTtcbiAgICBpZiAodGhpcy5tb2RlXyA9PT0gTW9kZS5MSU5FX1NUUklORykge1xuICAgICAgLy8gcmVtb3ZlIHRoZSByZWR1bmRhbnQgbGFzdCBwb2ludFxuICAgICAgY29vcmRpbmF0ZXMucG9wKCk7XG4gICAgICB0aGlzLmdlb21ldHJ5RnVuY3Rpb25fKGNvb3JkaW5hdGVzLCBnZW9tZXRyeSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1vZGVfID09PSBNb2RlLlBPTFlHT04pIHtcbiAgICAgIC8vIHJlbW92ZSB0aGUgcmVkdW5kYW50IGxhc3QgcG9pbnQgaW4gcmluZ1xuICAgICAgLyoqIEB0eXBlIHtQb2x5Q29vcmRUeXBlfSAqLyAoY29vcmRpbmF0ZXMpWzBdLnBvcCgpO1xuICAgICAgdGhpcy5nZW9tZXRyeUZ1bmN0aW9uXyhjb29yZGluYXRlcywgZ2VvbWV0cnkpO1xuICAgICAgY29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRDb29yZGluYXRlcygpO1xuICAgIH1cblxuICAgIC8vIGNhc3QgbXVsdGktcGFydCBnZW9tZXRyaWVzXG4gICAgaWYgKHRoaXMudHlwZV8gPT09IEdlb21ldHJ5VHlwZS5NVUxUSV9QT0lOVCkge1xuICAgICAgc2tldGNoRmVhdHVyZS5zZXRHZW9tZXRyeShuZXcgTXVsdGlQb2ludChbLyoqIEB0eXBlIHtQb2ludENvb3JkVHlwZX0gKi8oY29vcmRpbmF0ZXMpXSkpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlXyA9PT0gR2VvbWV0cnlUeXBlLk1VTFRJX0xJTkVfU1RSSU5HKSB7XG4gICAgICBza2V0Y2hGZWF0dXJlLnNldEdlb21ldHJ5KG5ldyBNdWx0aUxpbmVTdHJpbmcoWy8qKiBAdHlwZSB7TGluZUNvb3JkVHlwZX0gKi8oY29vcmRpbmF0ZXMpXSkpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlXyA9PT0gR2VvbWV0cnlUeXBlLk1VTFRJX1BPTFlHT04pIHtcbiAgICAgIHNrZXRjaEZlYXR1cmUuc2V0R2VvbWV0cnkobmV3IE11bHRpUG9seWdvbihbLyoqIEB0eXBlIHtQb2x5Q29vcmRUeXBlfSAqLyhjb29yZGluYXRlcyldKSk7XG4gICAgfVxuXG4gICAgLy8gRmlyc3QgZGlzcGF0Y2ggZXZlbnQgdG8gYWxsb3cgZnVsbCBzZXQgdXAgb2YgZmVhdHVyZVxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRHJhd0V2ZW50KERyYXdFdmVudFR5cGUuRFJBV0VORCwgc2tldGNoRmVhdHVyZSkpO1xuXG4gICAgLy8gVGhlbiBpbnNlcnQgZmVhdHVyZVxuICAgIGlmICh0aGlzLmZlYXR1cmVzXykge1xuICAgICAgdGhpcy5mZWF0dXJlc18ucHVzaChza2V0Y2hGZWF0dXJlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc291cmNlXykge1xuICAgICAgdGhpcy5zb3VyY2VfLmFkZEZlYXR1cmUoc2tldGNoRmVhdHVyZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTdG9wIGRyYXdpbmcgd2l0aG91dCBhZGRpbmcgdGhlIHNrZXRjaCBmZWF0dXJlIHRvIHRoZSB0YXJnZXQgbGF5ZXIuXG4gICAqIEByZXR1cm4ge0ZlYXR1cmV9IFRoZSBza2V0Y2ggZmVhdHVyZSAob3IgbnVsbCBpZiBub25lKS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIERyYXcucHJvdG90eXBlLmFib3J0RHJhd2luZ18gPSBmdW5jdGlvbiBhYm9ydERyYXdpbmdfICgpIHtcbiAgICB0aGlzLmZpbmlzaENvb3JkaW5hdGVfID0gbnVsbDtcbiAgICB2YXIgc2tldGNoRmVhdHVyZSA9IHRoaXMuc2tldGNoRmVhdHVyZV87XG4gICAgaWYgKHNrZXRjaEZlYXR1cmUpIHtcbiAgICAgIHRoaXMuc2tldGNoRmVhdHVyZV8gPSBudWxsO1xuICAgICAgdGhpcy5za2V0Y2hQb2ludF8gPSBudWxsO1xuICAgICAgdGhpcy5za2V0Y2hMaW5lXyA9IG51bGw7XG4gICAgICAvKiogQHR5cGUge1ZlY3RvclNvdXJjZX0gKi8gKHRoaXMub3ZlcmxheV8uZ2V0U291cmNlKCkpLmNsZWFyKHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gc2tldGNoRmVhdHVyZTtcbiAgfTtcblxuICAvKipcbiAgICogRXh0ZW5kIGFuIGV4aXN0aW5nIGdlb21ldHJ5IGJ5IGFkZGluZyBhZGRpdGlvbmFsIHBvaW50cy4gVGhpcyBvbmx5IHdvcmtzXG4gICAqIG9uIGZlYXR1cmVzIHdpdGggYExpbmVTdHJpbmdgIGdlb21ldHJpZXMsIHdoZXJlIHRoZSBpbnRlcmFjdGlvbiB3aWxsXG4gICAqIGV4dGVuZCBsaW5lcyBieSBhZGRpbmcgcG9pbnRzIHRvIHRoZSBlbmQgb2YgdGhlIGNvb3JkaW5hdGVzIGFycmF5LlxuICAgKiBAcGFyYW0geyFGZWF0dXJlfSBmZWF0dXJlIEZlYXR1cmUgdG8gYmUgZXh0ZW5kZWQuXG4gICAqIEBhcGlcbiAgICovXG4gIERyYXcucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uIGV4dGVuZCAoZmVhdHVyZSkge1xuICAgIHZhciBnZW9tZXRyeSA9IGZlYXR1cmUuZ2V0R2VvbWV0cnkoKTtcbiAgICB2YXIgbGluZVN0cmluZyA9IC8qKiBAdHlwZSB7TGluZVN0cmluZ30gKi8gKGdlb21ldHJ5KTtcbiAgICB0aGlzLnNrZXRjaEZlYXR1cmVfID0gZmVhdHVyZTtcbiAgICB0aGlzLnNrZXRjaENvb3Jkc18gPSBsaW5lU3RyaW5nLmdldENvb3JkaW5hdGVzKCk7XG4gICAgdmFyIGxhc3QgPSB0aGlzLnNrZXRjaENvb3Jkc19bdGhpcy5za2V0Y2hDb29yZHNfLmxlbmd0aCAtIDFdO1xuICAgIHRoaXMuZmluaXNoQ29vcmRpbmF0ZV8gPSBsYXN0LnNsaWNlKCk7XG4gICAgdGhpcy5za2V0Y2hDb29yZHNfLnB1c2gobGFzdC5zbGljZSgpKTtcbiAgICB0aGlzLnVwZGF0ZVNrZXRjaEZlYXR1cmVzXygpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRHJhd0V2ZW50KERyYXdFdmVudFR5cGUuRFJBV1NUQVJULCB0aGlzLnNrZXRjaEZlYXR1cmVfKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlZHJhdyB0aGUgc2tldGNoIGZlYXR1cmVzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgRHJhdy5wcm90b3R5cGUudXBkYXRlU2tldGNoRmVhdHVyZXNfID0gZnVuY3Rpb24gdXBkYXRlU2tldGNoRmVhdHVyZXNfICgpIHtcbiAgICB2YXIgc2tldGNoRmVhdHVyZXMgPSBbXTtcbiAgICBpZiAodGhpcy5za2V0Y2hGZWF0dXJlXykge1xuICAgICAgc2tldGNoRmVhdHVyZXMucHVzaCh0aGlzLnNrZXRjaEZlYXR1cmVfKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc2tldGNoTGluZV8pIHtcbiAgICAgIHNrZXRjaEZlYXR1cmVzLnB1c2godGhpcy5za2V0Y2hMaW5lXyk7XG4gICAgfVxuICAgIGlmICh0aGlzLnNrZXRjaFBvaW50Xykge1xuICAgICAgc2tldGNoRmVhdHVyZXMucHVzaCh0aGlzLnNrZXRjaFBvaW50Xyk7XG4gICAgfVxuICAgIHZhciBvdmVybGF5U291cmNlID0gLyoqIEB0eXBlIHtWZWN0b3JTb3VyY2V9ICovICh0aGlzLm92ZXJsYXlfLmdldFNvdXJjZSgpKTtcbiAgICBvdmVybGF5U291cmNlLmNsZWFyKHRydWUpO1xuICAgIG92ZXJsYXlTb3VyY2UuYWRkRmVhdHVyZXMoc2tldGNoRmVhdHVyZXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgRHJhdy5wcm90b3R5cGUudXBkYXRlU3RhdGVfID0gZnVuY3Rpb24gdXBkYXRlU3RhdGVfICgpIHtcbiAgICB2YXIgbWFwID0gdGhpcy5nZXRNYXAoKTtcbiAgICB2YXIgYWN0aXZlID0gdGhpcy5nZXRBY3RpdmUoKTtcbiAgICBpZiAoIW1hcCB8fCAhYWN0aXZlKSB7XG4gICAgICB0aGlzLmFib3J0RHJhd2luZ18oKTtcbiAgICB9XG4gICAgdGhpcy5vdmVybGF5Xy5zZXRNYXAoYWN0aXZlID8gbWFwIDogbnVsbCk7XG4gIH07XG5cbiAgcmV0dXJuIERyYXc7XG59KFBvaW50ZXJJbnRlcmFjdGlvbikpO1xuXG5cbi8qKlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVGdW5jdGlvbn0gU3R5bGVzLlxuICovXG5mdW5jdGlvbiBnZXREZWZhdWx0U3R5bGVGdW5jdGlvbigpIHtcbiAgdmFyIHN0eWxlcyA9IGNyZWF0ZUVkaXRpbmdTdHlsZSgpO1xuICByZXR1cm4gZnVuY3Rpb24oZmVhdHVyZSwgcmVzb2x1dGlvbikge1xuICAgIHJldHVybiBzdHlsZXNbZmVhdHVyZS5nZXRHZW9tZXRyeSgpLmdldFR5cGUoKV07XG4gIH07XG59XG5cblxuLyoqXG4gKiBDcmVhdGUgYSBgZ2VvbWV0cnlGdW5jdGlvbmAgZm9yIGB0eXBlOiAnQ2lyY2xlJ2AgdGhhdCB3aWxsIGNyZWF0ZSBhIHJlZ3VsYXJcbiAqIHBvbHlnb24gd2l0aCBhIHVzZXIgc3BlY2lmaWVkIG51bWJlciBvZiBzaWRlcyBhbmQgc3RhcnQgYW5nbGUgaW5zdGVhZCBvZiBhblxuICogYGltcG9ydChcIi4uL2dlb20vQ2lyY2xlLmpzXCIpLkNpcmNsZWAgZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9zaWRlcyBOdW1iZXIgb2Ygc2lkZXMgb2YgdGhlIHJlZ3VsYXIgcG9seWdvbi4gRGVmYXVsdCBpc1xuICogICAgIDMyLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfYW5nbGUgQW5nbGUgb2YgdGhlIGZpcnN0IHBvaW50IGluIHJhZGlhbnMuIDAgbWVhbnMgRWFzdC5cbiAqICAgICBEZWZhdWx0IGlzIHRoZSBhbmdsZSBkZWZpbmVkIGJ5IHRoZSBoZWFkaW5nIGZyb20gdGhlIGNlbnRlciBvZiB0aGVcbiAqICAgICByZWd1bGFyIHBvbHlnb24gdG8gdGhlIGN1cnJlbnQgcG9pbnRlciBwb3NpdGlvbi5cbiAqIEByZXR1cm4ge0dlb21ldHJ5RnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgZHJhd3MgYVxuICogICAgIHBvbHlnb24uXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSZWd1bGFyUG9seWdvbihvcHRfc2lkZXMsIG9wdF9hbmdsZSkge1xuICByZXR1cm4gZnVuY3Rpb24oY29vcmRpbmF0ZXMsIG9wdF9nZW9tZXRyeSkge1xuICAgIHZhciBjZW50ZXIgPSAvKiogQHR5cGUge0xpbmVDb29yZFR5cGV9ICovIChjb29yZGluYXRlcylbMF07XG4gICAgdmFyIGVuZCA9IC8qKiBAdHlwZSB7TGluZUNvb3JkVHlwZX0gKi8gKGNvb3JkaW5hdGVzKVsxXTtcbiAgICB2YXIgcmFkaXVzID0gTWF0aC5zcXJ0KFxuICAgICAgc3F1YXJlZENvb3JkaW5hdGVEaXN0YW5jZShjZW50ZXIsIGVuZCkpO1xuICAgIHZhciBnZW9tZXRyeSA9IG9wdF9nZW9tZXRyeSA/IC8qKiBAdHlwZSB7UG9seWdvbn0gKi8gKG9wdF9nZW9tZXRyeSkgOlxuICAgICAgZnJvbUNpcmNsZShuZXcgQ2lyY2xlKGNlbnRlciksIG9wdF9zaWRlcyk7XG4gICAgdmFyIGFuZ2xlID0gb3B0X2FuZ2xlO1xuICAgIGlmICghb3B0X2FuZ2xlKSB7XG4gICAgICB2YXIgeCA9IGVuZFswXSAtIGNlbnRlclswXTtcbiAgICAgIHZhciB5ID0gZW5kWzFdIC0gY2VudGVyWzFdO1xuICAgICAgYW5nbGUgPSBNYXRoLmF0YW4oeSAvIHgpIC0gKHggPCAwID8gTWF0aC5QSSA6IDApO1xuICAgIH1cbiAgICBtYWtlUmVndWxhcihnZW9tZXRyeSwgY2VudGVyLCByYWRpdXMsIGFuZ2xlKTtcbiAgICByZXR1cm4gZ2VvbWV0cnk7XG4gIH07XG59XG5cblxuLyoqXG4gKiBDcmVhdGUgYSBgZ2VvbWV0cnlGdW5jdGlvbmAgdGhhdCB3aWxsIGNyZWF0ZSBhIGJveC1zaGFwZWQgcG9seWdvbiAoYWxpZ25lZFxuICogd2l0aCB0aGUgY29vcmRpbmF0ZSBzeXN0ZW0gYXhlcykuICBVc2UgdGhpcyB3aXRoIHRoZSBkcmF3IGludGVyYWN0aW9uIGFuZFxuICogYHR5cGU6ICdDaXJjbGUnYCB0byByZXR1cm4gYSBib3ggaW5zdGVhZCBvZiBhIGNpcmNsZSBnZW9tZXRyeS5cbiAqIEByZXR1cm4ge0dlb21ldHJ5RnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgZHJhd3MgYSBib3gtc2hhcGVkIHBvbHlnb24uXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVCb3goKSB7XG4gIHJldHVybiAoXG4gICAgZnVuY3Rpb24oY29vcmRpbmF0ZXMsIG9wdF9nZW9tZXRyeSkge1xuICAgICAgdmFyIGV4dGVudCA9IGJvdW5kaW5nRXh0ZW50KC8qKiBAdHlwZSB7TGluZUNvb3JkVHlwZX0gKi8gKGNvb3JkaW5hdGVzKSk7XG4gICAgICB2YXIgYm94Q29vcmRpbmF0ZXMgPSBbW1xuICAgICAgICBnZXRCb3R0b21MZWZ0KGV4dGVudCksXG4gICAgICAgIGdldEJvdHRvbVJpZ2h0KGV4dGVudCksXG4gICAgICAgIGdldFRvcFJpZ2h0KGV4dGVudCksXG4gICAgICAgIGdldFRvcExlZnQoZXh0ZW50KSxcbiAgICAgICAgZ2V0Qm90dG9tTGVmdChleHRlbnQpXG4gICAgICBdXTtcbiAgICAgIHZhciBnZW9tZXRyeSA9IG9wdF9nZW9tZXRyeTtcbiAgICAgIGlmIChnZW9tZXRyeSkge1xuICAgICAgICBnZW9tZXRyeS5zZXRDb29yZGluYXRlcyhib3hDb29yZGluYXRlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZW9tZXRyeSA9IG5ldyBQb2x5Z29uKGJveENvb3JkaW5hdGVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZW9tZXRyeTtcbiAgICB9XG4gICk7XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIGRyYXdpbmcgbW9kZS4gIFRoZSBtb2RlIGZvciBtdWx0LXBhcnQgZ2VvbWV0cmllcyBpcyB0aGUgc2FtZSBhcyBmb3JcbiAqIHRoZWlyIHNpbmdsZS1wYXJ0IGNvdXNpbnMuXG4gKiBAcGFyYW0ge0dlb21ldHJ5VHlwZX0gdHlwZSBHZW9tZXRyeSB0eXBlLlxuICogQHJldHVybiB7TW9kZX0gRHJhd2luZyBtb2RlLlxuICovXG5mdW5jdGlvbiBnZXRNb2RlKHR5cGUpIHtcbiAgdmFyIG1vZGU7XG4gIGlmICh0eXBlID09PSBHZW9tZXRyeVR5cGUuUE9JTlQgfHxcbiAgICAgIHR5cGUgPT09IEdlb21ldHJ5VHlwZS5NVUxUSV9QT0lOVCkge1xuICAgIG1vZGUgPSBNb2RlLlBPSU5UO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IEdlb21ldHJ5VHlwZS5MSU5FX1NUUklORyB8fFxuICAgICAgdHlwZSA9PT0gR2VvbWV0cnlUeXBlLk1VTFRJX0xJTkVfU1RSSU5HKSB7XG4gICAgbW9kZSA9IE1vZGUuTElORV9TVFJJTkc7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gR2VvbWV0cnlUeXBlLlBPTFlHT04gfHxcbiAgICAgIHR5cGUgPT09IEdlb21ldHJ5VHlwZS5NVUxUSV9QT0xZR09OKSB7XG4gICAgbW9kZSA9IE1vZGUuUE9MWUdPTjtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBHZW9tZXRyeVR5cGUuQ0lSQ0xFKSB7XG4gICAgbW9kZSA9IE1vZGUuQ0lSQ0xFO1xuICB9XG4gIHJldHVybiAoXG4gICAgLyoqIEB0eXBlIHshTW9kZX0gKi8gKG1vZGUpXG4gICk7XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgRHJhdztcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RHJhdy5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vRXh0ZW50XG4gKi9cbmltcG9ydCBGZWF0dXJlIGZyb20gJy4uL0ZlYXR1cmUuanMnO1xuaW1wb3J0IE1hcEJyb3dzZXJFdmVudFR5cGUgZnJvbSAnLi4vTWFwQnJvd3NlckV2ZW50VHlwZS5qcyc7XG5pbXBvcnQge3NxdWFyZWREaXN0YW5jZVRvU2VnbWVudCwgY2xvc2VzdE9uU2VnbWVudCwgZGlzdGFuY2UgYXMgY29vcmRpbmF0ZURpc3RhbmNlLCBzcXVhcmVkRGlzdGFuY2UgYXMgc3F1YXJlZENvb3JkaW5hdGVEaXN0YW5jZX0gZnJvbSAnLi4vY29vcmRpbmF0ZS5qcyc7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzL0V2ZW50LmpzJztcbmltcG9ydCB7Ym91bmRpbmdFeHRlbnQsIGdldEFyZWF9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQgR2VvbWV0cnlUeXBlIGZyb20gJy4uL2dlb20vR2VvbWV0cnlUeXBlLmpzJztcbmltcG9ydCBQb2ludCBmcm9tICcuLi9nZW9tL1BvaW50LmpzJztcbmltcG9ydCB7ZnJvbUV4dGVudCBhcyBwb2x5Z29uRnJvbUV4dGVudH0gZnJvbSAnLi4vZ2VvbS9Qb2x5Z29uLmpzJztcbmltcG9ydCBQb2ludGVySW50ZXJhY3Rpb24gZnJvbSAnLi9Qb2ludGVyLmpzJztcbmltcG9ydCBWZWN0b3JMYXllciBmcm9tICcuLi9sYXllci9WZWN0b3IuanMnO1xuaW1wb3J0IFZlY3RvclNvdXJjZSBmcm9tICcuLi9zb3VyY2UvVmVjdG9yLmpzJztcbmltcG9ydCB7Y3JlYXRlRWRpdGluZ1N0eWxlfSBmcm9tICcuLi9zdHlsZS9TdHlsZS5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IFtleHRlbnRdIEluaXRpYWwgZXh0ZW50LiBEZWZhdWx0cyB0byBub1xuICogaW5pdGlhbCBleHRlbnQuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLlN0eWxlTGlrZX0gW2JveFN0eWxlXVxuICogU3R5bGUgZm9yIHRoZSBkcmF3biBleHRlbnQgYm94LiBEZWZhdWx0cyB0b1xuICoge0BsaW5rIG1vZHVsZTpvbC9zdHlsZS9TdHlsZX5jcmVhdGVFZGl0aW5nKClbJ1BvbHlnb24nXX1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcGl4ZWxUb2xlcmFuY2U9MTBdIFBpeGVsIHRvbGVyYW5jZSBmb3IgY29uc2lkZXJpbmcgdGhlXG4gKiBwb2ludGVyIGNsb3NlIGVub3VnaCB0byBhIHNlZ21lbnQgb3IgdmVydGV4IGZvciBlZGl0aW5nLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUxpa2V9IFtwb2ludGVyU3R5bGVdXG4gKiBTdHlsZSBmb3IgdGhlIGN1cnNvciB1c2VkIHRvIGRyYXcgdGhlIGV4dGVudC4gRGVmYXVsdHMgdG9cbiAqIHtAbGluayBtb2R1bGU6b2wvc3R5bGUvU3R5bGV+Y3JlYXRlRWRpdGluZygpWydQb2ludCddfVxuICogQHByb3BlcnR5IHtib29sZWFufSBbd3JhcFg9ZmFsc2VdIFdyYXAgdGhlIGRyYXduIGV4dGVudCBhY3Jvc3MgbXVsdGlwbGUgbWFwc1xuICogaW4gdGhlIFggZGlyZWN0aW9uPyBPbmx5IGFmZmVjdHMgdmlzdWFscywgbm90IGZ1bmN0aW9uYWxpdHkuXG4gKi9cblxuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbnZhciBFeHRlbnRFdmVudFR5cGUgPSB7XG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIGV4dGVudCBpcyBjaGFuZ2VkXG4gICAqIEBldmVudCBFeHRlbnRFdmVudFR5cGUjZXh0ZW50Y2hhbmdlZFxuICAgKiBAYXBpXG4gICAqL1xuICBFWFRFTlRDSEFOR0VEOiAnZXh0ZW50Y2hhbmdlZCdcbn07XG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBFdmVudHMgZW1pdHRlZCBieSB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL0V4dGVudH5FeHRlbnRJbnRlcmFjdGlvbn0gaW5zdGFuY2VzIGFyZVxuICogaW5zdGFuY2VzIG9mIHRoaXMgdHlwZS5cbiAqL1xudmFyIEV4dGVudEludGVyYWN0aW9uRXZlbnQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChFdmVudCkge1xuICBmdW5jdGlvbiBFeHRlbnRJbnRlcmFjdGlvbkV2ZW50KGV4dGVudCkge1xuICAgIEV2ZW50LmNhbGwodGhpcywgRXh0ZW50RXZlbnRUeXBlLkVYVEVOVENIQU5HRUQpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgZXh0ZW50LlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLmV4dGVudCA9IGV4dGVudDtcbiAgfVxuXG4gIGlmICggRXZlbnQgKSBFeHRlbnRJbnRlcmFjdGlvbkV2ZW50Ll9fcHJvdG9fXyA9IEV2ZW50O1xuICBFeHRlbnRJbnRlcmFjdGlvbkV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEV2ZW50ICYmIEV2ZW50LnByb3RvdHlwZSApO1xuICBFeHRlbnRJbnRlcmFjdGlvbkV2ZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEV4dGVudEludGVyYWN0aW9uRXZlbnQ7XG5cbiAgcmV0dXJuIEV4dGVudEludGVyYWN0aW9uRXZlbnQ7XG59KEV2ZW50KSk7XG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBbGxvd3MgdGhlIHVzZXIgdG8gZHJhdyBhIHZlY3RvciBib3ggYnkgY2xpY2tpbmcgYW5kIGRyYWdnaW5nIG9uIHRoZSBtYXAuXG4gKiBPbmNlIGRyYXduLCB0aGUgdmVjdG9yIGJveCBjYW4gYmUgbW9kaWZpZWQgYnkgZHJhZ2dpbmcgaXRzIHZlcnRpY2VzIG9yIGVkZ2VzLlxuICogVGhpcyBpbnRlcmFjdGlvbiBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgbW91c2UgZGV2aWNlcy5cbiAqXG4gKiBAZmlyZXMgRXZlbnRcbiAqIEBhcGlcbiAqL1xudmFyIEV4dGVudEludGVyYWN0aW9uID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoUG9pbnRlckludGVyYWN0aW9uKSB7XG4gIGZ1bmN0aW9uIEV4dGVudEludGVyYWN0aW9uKG9wdF9vcHRpb25zKSB7XG5cbiAgICB2YXIgb3B0aW9ucyA9IG9wdF9vcHRpb25zIHx8IHt9O1xuXG4gICAgUG9pbnRlckludGVyYWN0aW9uLmNhbGwoLyoqIEB0eXBlIHtpbXBvcnQoXCIuL1BvaW50ZXIuanNcIikuT3B0aW9uc30gKi8gdGhpcywgKG9wdGlvbnMpKTtcblxuICAgIC8qKlxuICAgICAqIEV4dGVudCBvZiB0aGUgZHJhd24gYm94XG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmV4dGVudF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogSGFuZGxlciBmb3IgcG9pbnRlciBtb3ZlIGV2ZW50c1xuICAgICAqIEB0eXBlIHtmdW5jdGlvbiAoaW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlKTogaW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudHxudWxsfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5wb2ludGVySGFuZGxlcl8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogUGl4ZWwgdGhyZXNob2xkIHRvIHNuYXAgdG8gZXh0ZW50XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucGl4ZWxUb2xlcmFuY2VfID0gb3B0aW9ucy5waXhlbFRvbGVyYW5jZSAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdGlvbnMucGl4ZWxUb2xlcmFuY2UgOiAxMDtcblxuICAgIC8qKlxuICAgICAqIElzIHRoZSBwb2ludGVyIHNuYXBwZWQgdG8gYW4gZXh0ZW50IHZlcnRleFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5zbmFwcGVkVG9WZXJ0ZXhfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBGZWF0dXJlIGZvciBkaXNwbGF5aW5nIHRoZSB2aXNpYmxlIGV4dGVudFxuICAgICAqIEB0eXBlIHtGZWF0dXJlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5leHRlbnRGZWF0dXJlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBGZWF0dXJlIGZvciBkaXNwbGF5aW5nIHRoZSB2aXNpYmxlIHBvaW50ZXJcbiAgICAgKiBAdHlwZSB7RmVhdHVyZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudmVydGV4RmVhdHVyZV8gPSBudWxsO1xuXG4gICAgaWYgKCFvcHRfb3B0aW9ucykge1xuICAgICAgb3B0X29wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMYXllciBmb3IgdGhlIGV4dGVudEZlYXR1cmVcbiAgICAgKiBAdHlwZSB7VmVjdG9yTGF5ZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmV4dGVudE92ZXJsYXlfID0gbmV3IFZlY3RvckxheWVyKHtcbiAgICAgIHNvdXJjZTogbmV3IFZlY3RvclNvdXJjZSh7XG4gICAgICAgIHVzZVNwYXRpYWxJbmRleDogZmFsc2UsXG4gICAgICAgIHdyYXBYOiAhIW9wdF9vcHRpb25zLndyYXBYXG4gICAgICB9KSxcbiAgICAgIHN0eWxlOiBvcHRfb3B0aW9ucy5ib3hTdHlsZSA/IG9wdF9vcHRpb25zLmJveFN0eWxlIDogZ2V0RGVmYXVsdEV4dGVudFN0eWxlRnVuY3Rpb24oKSxcbiAgICAgIHVwZGF0ZVdoaWxlQW5pbWF0aW5nOiB0cnVlLFxuICAgICAgdXBkYXRlV2hpbGVJbnRlcmFjdGluZzogdHJ1ZVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogTGF5ZXIgZm9yIHRoZSB2ZXJ0ZXhGZWF0dXJlXG4gICAgICogQHR5cGUge1ZlY3RvckxheWVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy52ZXJ0ZXhPdmVybGF5XyA9IG5ldyBWZWN0b3JMYXllcih7XG4gICAgICBzb3VyY2U6IG5ldyBWZWN0b3JTb3VyY2Uoe1xuICAgICAgICB1c2VTcGF0aWFsSW5kZXg6IGZhbHNlLFxuICAgICAgICB3cmFwWDogISFvcHRfb3B0aW9ucy53cmFwWFxuICAgICAgfSksXG4gICAgICBzdHlsZTogb3B0X29wdGlvbnMucG9pbnRlclN0eWxlID8gb3B0X29wdGlvbnMucG9pbnRlclN0eWxlIDogZ2V0RGVmYXVsdFBvaW50ZXJTdHlsZUZ1bmN0aW9uKCksXG4gICAgICB1cGRhdGVXaGlsZUFuaW1hdGluZzogdHJ1ZSxcbiAgICAgIHVwZGF0ZVdoaWxlSW50ZXJhY3Rpbmc6IHRydWVcbiAgICB9KTtcblxuICAgIGlmIChvcHRfb3B0aW9ucy5leHRlbnQpIHtcbiAgICAgIHRoaXMuc2V0RXh0ZW50KG9wdF9vcHRpb25zLmV4dGVudCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCBQb2ludGVySW50ZXJhY3Rpb24gKSBFeHRlbnRJbnRlcmFjdGlvbi5fX3Byb3RvX18gPSBQb2ludGVySW50ZXJhY3Rpb247XG4gIEV4dGVudEludGVyYWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBvaW50ZXJJbnRlcmFjdGlvbiAmJiBQb2ludGVySW50ZXJhY3Rpb24ucHJvdG90eXBlICk7XG4gIEV4dGVudEludGVyYWN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEV4dGVudEludGVyYWN0aW9uO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsfSBwaXhlbCBjdXJzb3IgbG9jYXRpb25cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuZGVmYXVsdH0gbWFwIG1hcFxuICAgKiBAcmV0dXJucyB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfG51bGx9IHNuYXBwZWQgdmVydGV4IG9uIGV4dGVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgRXh0ZW50SW50ZXJhY3Rpb24ucHJvdG90eXBlLnNuYXBUb1ZlcnRleF8gPSBmdW5jdGlvbiBzbmFwVG9WZXJ0ZXhfIChwaXhlbCwgbWFwKSB7XG4gICAgdmFyIHBpeGVsQ29vcmRpbmF0ZSA9IG1hcC5nZXRDb29yZGluYXRlRnJvbVBpeGVsKHBpeGVsKTtcbiAgICB2YXIgc29ydEJ5RGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgICByZXR1cm4gc3F1YXJlZERpc3RhbmNlVG9TZWdtZW50KHBpeGVsQ29vcmRpbmF0ZSwgYSkgLVxuICAgICAgICAgIHNxdWFyZWREaXN0YW5jZVRvU2VnbWVudChwaXhlbENvb3JkaW5hdGUsIGIpO1xuICAgIH07XG4gICAgdmFyIGV4dGVudCA9IHRoaXMuZ2V0RXh0ZW50KCk7XG4gICAgaWYgKGV4dGVudCkge1xuICAgICAgLy9jb252ZXJ0IGV4dGVudHMgdG8gbGluZSBzZWdtZW50cyBhbmQgZmluZCB0aGUgc2VnbWVudCBjbG9zZXN0IHRvIHBpeGVsQ29vcmRpbmF0ZVxuICAgICAgdmFyIHNlZ21lbnRzID0gZ2V0U2VnbWVudHMoZXh0ZW50KTtcbiAgICAgIHNlZ21lbnRzLnNvcnQoc29ydEJ5RGlzdGFuY2UpO1xuICAgICAgdmFyIGNsb3Nlc3RTZWdtZW50ID0gc2VnbWVudHNbMF07XG5cbiAgICAgIHZhciB2ZXJ0ZXggPSAoY2xvc2VzdE9uU2VnbWVudChwaXhlbENvb3JkaW5hdGUsXG4gICAgICAgIGNsb3Nlc3RTZWdtZW50KSk7XG4gICAgICB2YXIgdmVydGV4UGl4ZWwgPSBtYXAuZ2V0UGl4ZWxGcm9tQ29vcmRpbmF0ZSh2ZXJ0ZXgpO1xuXG4gICAgICAvL2lmIHRoZSBkaXN0YW5jZSBpcyB3aXRoaW4gdG9sZXJhbmNlLCBzbmFwIHRvIHRoZSBzZWdtZW50XG4gICAgICBpZiAoY29vcmRpbmF0ZURpc3RhbmNlKHBpeGVsLCB2ZXJ0ZXhQaXhlbCkgPD0gdGhpcy5waXhlbFRvbGVyYW5jZV8pIHtcbiAgICAgICAgLy90ZXN0IGlmIHdlIHNob3VsZCBmdXJ0aGVyIHNuYXAgdG8gYSB2ZXJ0ZXhcbiAgICAgICAgdmFyIHBpeGVsMSA9IG1hcC5nZXRQaXhlbEZyb21Db29yZGluYXRlKGNsb3Nlc3RTZWdtZW50WzBdKTtcbiAgICAgICAgdmFyIHBpeGVsMiA9IG1hcC5nZXRQaXhlbEZyb21Db29yZGluYXRlKGNsb3Nlc3RTZWdtZW50WzFdKTtcbiAgICAgICAgdmFyIHNxdWFyZWREaXN0MSA9IHNxdWFyZWRDb29yZGluYXRlRGlzdGFuY2UodmVydGV4UGl4ZWwsIHBpeGVsMSk7XG4gICAgICAgIHZhciBzcXVhcmVkRGlzdDIgPSBzcXVhcmVkQ29vcmRpbmF0ZURpc3RhbmNlKHZlcnRleFBpeGVsLCBwaXhlbDIpO1xuICAgICAgICB2YXIgZGlzdCA9IE1hdGguc3FydChNYXRoLm1pbihzcXVhcmVkRGlzdDEsIHNxdWFyZWREaXN0MikpO1xuICAgICAgICB0aGlzLnNuYXBwZWRUb1ZlcnRleF8gPSBkaXN0IDw9IHRoaXMucGl4ZWxUb2xlcmFuY2VfO1xuICAgICAgICBpZiAodGhpcy5zbmFwcGVkVG9WZXJ0ZXhfKSB7XG4gICAgICAgICAgdmVydGV4ID0gc3F1YXJlZERpc3QxID4gc3F1YXJlZERpc3QyID9cbiAgICAgICAgICAgIGNsb3Nlc3RTZWdtZW50WzFdIDogY2xvc2VzdFNlZ21lbnRbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZlcnRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBwb2ludGVyIG1vdmUgZXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEV4dGVudEludGVyYWN0aW9uLnByb3RvdHlwZS5oYW5kbGVQb2ludGVyTW92ZV8gPSBmdW5jdGlvbiBoYW5kbGVQb2ludGVyTW92ZV8gKG1hcEJyb3dzZXJFdmVudCkge1xuICAgIHZhciBwaXhlbCA9IG1hcEJyb3dzZXJFdmVudC5waXhlbDtcbiAgICB2YXIgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcblxuICAgIHZhciB2ZXJ0ZXggPSB0aGlzLnNuYXBUb1ZlcnRleF8ocGl4ZWwsIG1hcCk7XG4gICAgaWYgKCF2ZXJ0ZXgpIHtcbiAgICAgIHZlcnRleCA9IG1hcC5nZXRDb29yZGluYXRlRnJvbVBpeGVsKHBpeGVsKTtcbiAgICB9XG4gICAgdGhpcy5jcmVhdGVPclVwZGF0ZVBvaW50ZXJGZWF0dXJlXyh2ZXJ0ZXgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBleHRlbnRcbiAgICogQHJldHVybnMge0ZlYXR1cmV9IGV4dGVudCBhcyBmZWF0cnVlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBFeHRlbnRJbnRlcmFjdGlvbi5wcm90b3R5cGUuY3JlYXRlT3JVcGRhdGVFeHRlbnRGZWF0dXJlXyA9IGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlRXh0ZW50RmVhdHVyZV8gKGV4dGVudCkge1xuICAgIHZhciBleHRlbnRGZWF0dXJlID0gdGhpcy5leHRlbnRGZWF0dXJlXztcblxuICAgIGlmICghZXh0ZW50RmVhdHVyZSkge1xuICAgICAgaWYgKCFleHRlbnQpIHtcbiAgICAgICAgZXh0ZW50RmVhdHVyZSA9IG5ldyBGZWF0dXJlKHt9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4dGVudEZlYXR1cmUgPSBuZXcgRmVhdHVyZShwb2x5Z29uRnJvbUV4dGVudChleHRlbnQpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXh0ZW50RmVhdHVyZV8gPSBleHRlbnRGZWF0dXJlO1xuICAgICAgLyoqIEB0eXBlIHtWZWN0b3JTb3VyY2V9ICovICh0aGlzLmV4dGVudE92ZXJsYXlfLmdldFNvdXJjZSgpKS5hZGRGZWF0dXJlKGV4dGVudEZlYXR1cmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWV4dGVudCkge1xuICAgICAgICBleHRlbnRGZWF0dXJlLnNldEdlb21ldHJ5KHVuZGVmaW5lZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleHRlbnRGZWF0dXJlLnNldEdlb21ldHJ5KHBvbHlnb25Gcm9tRXh0ZW50KGV4dGVudCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXh0ZW50RmVhdHVyZTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IHZlcnRleCBsb2NhdGlvbiBvZiBmZWF0dXJlXG4gICAqIEByZXR1cm5zIHtGZWF0dXJlfSB2ZXJ0ZXggYXMgZmVhdHVyZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgRXh0ZW50SW50ZXJhY3Rpb24ucHJvdG90eXBlLmNyZWF0ZU9yVXBkYXRlUG9pbnRlckZlYXR1cmVfID0gZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVQb2ludGVyRmVhdHVyZV8gKHZlcnRleCkge1xuICAgIHZhciB2ZXJ0ZXhGZWF0dXJlID0gdGhpcy52ZXJ0ZXhGZWF0dXJlXztcbiAgICBpZiAoIXZlcnRleEZlYXR1cmUpIHtcbiAgICAgIHZlcnRleEZlYXR1cmUgPSBuZXcgRmVhdHVyZShuZXcgUG9pbnQodmVydGV4KSk7XG4gICAgICB0aGlzLnZlcnRleEZlYXR1cmVfID0gdmVydGV4RmVhdHVyZTtcbiAgICAgIC8qKiBAdHlwZSB7VmVjdG9yU291cmNlfSAqLyAodGhpcy52ZXJ0ZXhPdmVybGF5Xy5nZXRTb3VyY2UoKSkuYWRkRmVhdHVyZSh2ZXJ0ZXhGZWF0dXJlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGdlb21ldHJ5ID0gLyoqIEB0eXBlIHtQb2ludH0gKi8gKHZlcnRleEZlYXR1cmUuZ2V0R2VvbWV0cnkoKSk7XG4gICAgICBnZW9tZXRyeS5zZXRDb29yZGluYXRlcyh2ZXJ0ZXgpO1xuICAgIH1cbiAgICByZXR1cm4gdmVydGV4RmVhdHVyZTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIEV4dGVudEludGVyYWN0aW9uLnByb3RvdHlwZS5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uIGhhbmRsZUV2ZW50IChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBpZiAoISgvKiogQHR5cGUge2ltcG9ydChcIi4uL01hcEJyb3dzZXJQb2ludGVyRXZlbnQuanNcIikuZGVmYXVsdH0gKi8gKG1hcEJyb3dzZXJFdmVudCkucG9pbnRlckV2ZW50KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vZGlzcGxheSBwb2ludGVyIChpZiBub3QgZHJhZ2dpbmcpXG4gICAgaWYgKG1hcEJyb3dzZXJFdmVudC50eXBlID09IE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUk1PVkUgJiYgIXRoaXMuaGFuZGxpbmdEb3duVXBTZXF1ZW5jZSkge1xuICAgICAgdGhpcy5oYW5kbGVQb2ludGVyTW92ZV8obWFwQnJvd3NlckV2ZW50KTtcbiAgICB9XG4gICAgLy9jYWxsIHBvaW50ZXIgdG8gZGV0ZXJtaW5lIHVwL2Rvd24vZHJhZ1xuICAgIFBvaW50ZXJJbnRlcmFjdGlvbi5wcm90b3R5cGUuaGFuZGxlRXZlbnQuY2FsbCh0aGlzLCBtYXBCcm93c2VyRXZlbnQpO1xuICAgIC8vcmV0dXJuIGZhbHNlIHRvIHN0b3AgcHJvcGFnYXRpb25cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBFeHRlbnRJbnRlcmFjdGlvbi5wcm90b3R5cGUuaGFuZGxlRG93bkV2ZW50ID0gZnVuY3Rpb24gaGFuZGxlRG93bkV2ZW50IChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICB2YXIgcGl4ZWwgPSBtYXBCcm93c2VyRXZlbnQucGl4ZWw7XG4gICAgdmFyIG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG5cbiAgICB2YXIgZXh0ZW50ID0gdGhpcy5nZXRFeHRlbnQoKTtcbiAgICB2YXIgdmVydGV4ID0gdGhpcy5zbmFwVG9WZXJ0ZXhfKHBpeGVsLCBtYXApO1xuXG4gICAgLy9maW5kIHRoZSBleHRlbnQgY29ybmVyIG9wcG9zaXRlIHRoZSBwYXNzZWQgY29ybmVyXG4gICAgdmFyIGdldE9wcG9zaW5nUG9pbnQgPSBmdW5jdGlvbihwb2ludCkge1xuICAgICAgdmFyIHhfID0gbnVsbDtcbiAgICAgIHZhciB5XyA9IG51bGw7XG4gICAgICBpZiAocG9pbnRbMF0gPT0gZXh0ZW50WzBdKSB7XG4gICAgICAgIHhfID0gZXh0ZW50WzJdO1xuICAgICAgfSBlbHNlIGlmIChwb2ludFswXSA9PSBleHRlbnRbMl0pIHtcbiAgICAgICAgeF8gPSBleHRlbnRbMF07XG4gICAgICB9XG4gICAgICBpZiAocG9pbnRbMV0gPT0gZXh0ZW50WzFdKSB7XG4gICAgICAgIHlfID0gZXh0ZW50WzNdO1xuICAgICAgfSBlbHNlIGlmIChwb2ludFsxXSA9PSBleHRlbnRbM10pIHtcbiAgICAgICAgeV8gPSBleHRlbnRbMV07XG4gICAgICB9XG4gICAgICBpZiAoeF8gIT09IG51bGwgJiYgeV8gIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFt4XywgeV9dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBpZiAodmVydGV4ICYmIGV4dGVudCkge1xuICAgICAgdmFyIHggPSAodmVydGV4WzBdID09IGV4dGVudFswXSB8fCB2ZXJ0ZXhbMF0gPT0gZXh0ZW50WzJdKSA/IHZlcnRleFswXSA6IG51bGw7XG4gICAgICB2YXIgeSA9ICh2ZXJ0ZXhbMV0gPT0gZXh0ZW50WzFdIHx8IHZlcnRleFsxXSA9PSBleHRlbnRbM10pID8gdmVydGV4WzFdIDogbnVsbDtcblxuICAgICAgLy9zbmFwIHRvIHBvaW50XG4gICAgICBpZiAoeCAhPT0gbnVsbCAmJiB5ICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMucG9pbnRlckhhbmRsZXJfID0gZ2V0UG9pbnRIYW5kbGVyKGdldE9wcG9zaW5nUG9pbnQodmVydGV4KSk7XG4gICAgICAvL3NuYXAgdG8gZWRnZVxuICAgICAgfSBlbHNlIGlmICh4ICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMucG9pbnRlckhhbmRsZXJfID0gZ2V0RWRnZUhhbmRsZXIoXG4gICAgICAgICAgZ2V0T3Bwb3NpbmdQb2ludChbeCwgZXh0ZW50WzFdXSksXG4gICAgICAgICAgZ2V0T3Bwb3NpbmdQb2ludChbeCwgZXh0ZW50WzNdXSlcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoeSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnBvaW50ZXJIYW5kbGVyXyA9IGdldEVkZ2VIYW5kbGVyKFxuICAgICAgICAgIGdldE9wcG9zaW5nUG9pbnQoW2V4dGVudFswXSwgeV0pLFxuICAgICAgICAgIGdldE9wcG9zaW5nUG9pbnQoW2V4dGVudFsyXSwgeV0pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgLy9ubyBzbmFwIC0gbmV3IGJib3hcbiAgICB9IGVsc2Uge1xuICAgICAgdmVydGV4ID0gbWFwLmdldENvb3JkaW5hdGVGcm9tUGl4ZWwocGl4ZWwpO1xuICAgICAgdGhpcy5zZXRFeHRlbnQoW3ZlcnRleFswXSwgdmVydGV4WzFdLCB2ZXJ0ZXhbMF0sIHZlcnRleFsxXV0pO1xuICAgICAgdGhpcy5wb2ludGVySGFuZGxlcl8gPSBnZXRQb2ludEhhbmRsZXIodmVydGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7IC8vZXZlbnQgaGFuZGxlZDsgc3RhcnQgZG93bnVwIHNlcXVlbmNlXG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBFeHRlbnRJbnRlcmFjdGlvbi5wcm90b3R5cGUuaGFuZGxlRHJhZ0V2ZW50ID0gZnVuY3Rpb24gaGFuZGxlRHJhZ0V2ZW50IChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBpZiAodGhpcy5wb2ludGVySGFuZGxlcl8pIHtcbiAgICAgIHZhciBwaXhlbENvb3JkaW5hdGUgPSBtYXBCcm93c2VyRXZlbnQuY29vcmRpbmF0ZTtcbiAgICAgIHRoaXMuc2V0RXh0ZW50KHRoaXMucG9pbnRlckhhbmRsZXJfKHBpeGVsQ29vcmRpbmF0ZSkpO1xuICAgICAgdGhpcy5jcmVhdGVPclVwZGF0ZVBvaW50ZXJGZWF0dXJlXyhwaXhlbENvb3JkaW5hdGUpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIEV4dGVudEludGVyYWN0aW9uLnByb3RvdHlwZS5oYW5kbGVVcEV2ZW50ID0gZnVuY3Rpb24gaGFuZGxlVXBFdmVudCAobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgdGhpcy5wb2ludGVySGFuZGxlcl8gPSBudWxsO1xuICAgIC8vSWYgYmJveCBpcyB6ZXJvIGFyZWEsIHNldCB0byBudWxsO1xuICAgIHZhciBleHRlbnQgPSB0aGlzLmdldEV4dGVudCgpO1xuICAgIGlmICghZXh0ZW50IHx8IGdldEFyZWEoZXh0ZW50KSA9PT0gMCkge1xuICAgICAgdGhpcy5zZXRFeHRlbnQobnVsbCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTsgLy9TdG9wIGhhbmRsaW5nIGRvd251cCBzZXF1ZW5jZVxuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgRXh0ZW50SW50ZXJhY3Rpb24ucHJvdG90eXBlLnNldE1hcCA9IGZ1bmN0aW9uIHNldE1hcCAobWFwKSB7XG4gICAgdGhpcy5leHRlbnRPdmVybGF5Xy5zZXRNYXAobWFwKTtcbiAgICB0aGlzLnZlcnRleE92ZXJsYXlfLnNldE1hcChtYXApO1xuICAgIFBvaW50ZXJJbnRlcmFjdGlvbi5wcm90b3R5cGUuc2V0TWFwLmNhbGwodGhpcywgbWFwKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBkcmF3biBleHRlbnQgaW4gdGhlIHZpZXcgcHJvamVjdGlvblxuICAgKlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBEcmF3biBleHRlbnQgaW4gdGhlIHZpZXcgcHJvamVjdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgRXh0ZW50SW50ZXJhY3Rpb24ucHJvdG90eXBlLmdldEV4dGVudCA9IGZ1bmN0aW9uIGdldEV4dGVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW50XztcbiAgfTtcblxuICAvKipcbiAgICogTWFudWFsbHkgc2V0cyB0aGUgZHJhd24gZXh0ZW50LCB1c2luZyB0aGUgdmlldyBwcm9qZWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnRcbiAgICogQGFwaVxuICAgKi9cbiAgRXh0ZW50SW50ZXJhY3Rpb24ucHJvdG90eXBlLnNldEV4dGVudCA9IGZ1bmN0aW9uIHNldEV4dGVudCAoZXh0ZW50KSB7XG4gICAgLy9OdWxsIGV4dGVudCBtZWFucyBubyBiYm94XG4gICAgdGhpcy5leHRlbnRfID0gZXh0ZW50ID8gZXh0ZW50IDogbnVsbDtcbiAgICB0aGlzLmNyZWF0ZU9yVXBkYXRlRXh0ZW50RmVhdHVyZV8oZXh0ZW50KTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV4dGVudEludGVyYWN0aW9uRXZlbnQodGhpcy5leHRlbnRfKSk7XG4gIH07XG5cbiAgcmV0dXJuIEV4dGVudEludGVyYWN0aW9uO1xufShQb2ludGVySW50ZXJhY3Rpb24pKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkZWZhdWx0IHN0eWxlIGZvciB0aGUgZHJhd24gYmJveFxuICpcbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLlN0eWxlRnVuY3Rpb259IERlZmF1bHQgRXh0ZW50IHN0eWxlXG4gKi9cbmZ1bmN0aW9uIGdldERlZmF1bHRFeHRlbnRTdHlsZUZ1bmN0aW9uKCkge1xuICB2YXIgc3R5bGUgPSBjcmVhdGVFZGl0aW5nU3R5bGUoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGZlYXR1cmUsIHJlc29sdXRpb24pIHtcbiAgICByZXR1cm4gc3R5bGVbR2VvbWV0cnlUeXBlLlBPTFlHT05dO1xuICB9O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGRlZmF1bHQgc3R5bGUgZm9yIHRoZSBwb2ludGVyXG4gKlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVGdW5jdGlvbn0gRGVmYXVsdCBwb2ludGVyIHN0eWxlXG4gKi9cbmZ1bmN0aW9uIGdldERlZmF1bHRQb2ludGVyU3R5bGVGdW5jdGlvbigpIHtcbiAgdmFyIHN0eWxlID0gY3JlYXRlRWRpdGluZ1N0eWxlKCk7XG4gIHJldHVybiBmdW5jdGlvbihmZWF0dXJlLCByZXNvbHV0aW9uKSB7XG4gICAgcmV0dXJuIHN0eWxlW0dlb21ldHJ5VHlwZS5QT0lOVF07XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGZpeGVkUG9pbnQgY29ybmVyIHRoYXQgd2lsbCBiZSB1bmNoYW5nZWQgaW4gdGhlIG5ldyBleHRlbnRcbiAqIEByZXR1cm5zIHtmdW5jdGlvbiAoaW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlKTogaW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXZlbnQgaGFuZGxlclxuICovXG5mdW5jdGlvbiBnZXRQb2ludEhhbmRsZXIoZml4ZWRQb2ludCkge1xuICByZXR1cm4gZnVuY3Rpb24ocG9pbnQpIHtcbiAgICByZXR1cm4gYm91bmRpbmdFeHRlbnQoW2ZpeGVkUG9pbnQsIHBvaW50XSk7XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGZpeGVkUDEgZmlyc3QgY29ybmVyIHRoYXQgd2lsbCBiZSB1bmNoYW5nZWQgaW4gdGhlIG5ldyBleHRlbnRcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBmaXhlZFAyIHNlY29uZCBjb3JuZXIgdGhhdCB3aWxsIGJlIHVuY2hhbmdlZCBpbiB0aGUgbmV3IGV4dGVudFxuICogQHJldHVybnMge2Z1bmN0aW9uIChpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGUpOiBpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fG51bGx9IGV2ZW50IGhhbmRsZXJcbiAqL1xuZnVuY3Rpb24gZ2V0RWRnZUhhbmRsZXIoZml4ZWRQMSwgZml4ZWRQMikge1xuICBpZiAoZml4ZWRQMVswXSA9PSBmaXhlZFAyWzBdKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICByZXR1cm4gYm91bmRpbmdFeHRlbnQoW2ZpeGVkUDEsIFtwb2ludFswXSwgZml4ZWRQMlsxXV1dKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKGZpeGVkUDFbMV0gPT0gZml4ZWRQMlsxXSkge1xuICAgIHJldHVybiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgcmV0dXJuIGJvdW5kaW5nRXh0ZW50KFtmaXhlZFAxLCBbZml4ZWRQMlswXSwgcG9pbnRbMV1dXSk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IGV4dGVudFxuICogQHJldHVybnMge0FycmF5PEFycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+fSBleHRlbnQgbGluZSBzZWdtZW50c1xuICovXG5mdW5jdGlvbiBnZXRTZWdtZW50cyhleHRlbnQpIHtcbiAgcmV0dXJuIFtcbiAgICBbW2V4dGVudFswXSwgZXh0ZW50WzFdXSwgW2V4dGVudFswXSwgZXh0ZW50WzNdXV0sXG4gICAgW1tleHRlbnRbMF0sIGV4dGVudFszXV0sIFtleHRlbnRbMl0sIGV4dGVudFszXV1dLFxuICAgIFtbZXh0ZW50WzJdLCBleHRlbnRbM11dLCBbZXh0ZW50WzJdLCBleHRlbnRbMV1dXSxcbiAgICBbW2V4dGVudFsyXSwgZXh0ZW50WzFdXSwgW2V4dGVudFswXSwgZXh0ZW50WzFdXV1cbiAgXTtcbn1cblxuXG5leHBvcnQgZGVmYXVsdCBFeHRlbnRJbnRlcmFjdGlvbjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXh0ZW50LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvblxuICovXG5pbXBvcnQgQmFzZU9iamVjdCBmcm9tICcuLi9PYmplY3QuanMnO1xuaW1wb3J0IHtlYXNlT3V0LCBsaW5lYXJ9IGZyb20gJy4uL2Vhc2luZy5qcyc7XG5pbXBvcnQgSW50ZXJhY3Rpb25Qcm9wZXJ0eSBmcm9tICcuL1Byb3BlcnR5LmpzJztcbmltcG9ydCB7Y2xhbXB9IGZyb20gJy4uL21hdGguanMnO1xuXG5cbi8qKlxuICogT2JqZWN0IGxpdGVyYWwgd2l0aCBjb25maWcgb3B0aW9ucyBmb3IgaW50ZXJhY3Rpb25zLlxuICogQHR5cGVkZWYge09iamVjdH0gSW50ZXJhY3Rpb25PcHRpb25zXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0KTpib29sZWFufSBoYW5kbGVFdmVudFxuICogTWV0aG9kIGNhbGxlZCBieSB0aGUgbWFwIHRvIG5vdGlmeSB0aGUgaW50ZXJhY3Rpb24gdGhhdCBhIGJyb3dzZXIgZXZlbnQgd2FzXG4gKiBkaXNwYXRjaGVkIHRvIHRoZSBtYXAuIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIHByb3BhZ2F0aW9uIG9mXG4gKiB0aGUgZXZlbnQgdG8gb3RoZXIgaW50ZXJhY3Rpb25zIGluIHRoZSBtYXAncyBpbnRlcmFjdGlvbnMgY2hhaW4gd2lsbCBiZVxuICogcHJldmVudGVkICh0aGlzIGluY2x1ZGVzIGZ1bmN0aW9ucyB3aXRoIG5vIGV4cGxpY2l0IHJldHVybikuXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3M7IG5vcm1hbGx5IG9ubHkgdXNlZCBmb3IgY3JlYXRpbmcgc3ViY2xhc3NlcyBhbmQgbm90XG4gKiBpbnN0YW50aWF0ZWQgaW4gYXBwcy5cbiAqIFVzZXIgYWN0aW9ucyB0aGF0IGNoYW5nZSB0aGUgc3RhdGUgb2YgdGhlIG1hcC4gU29tZSBhcmUgc2ltaWxhciB0byBjb250cm9scyxcbiAqIGJ1dCBhcmUgbm90IGFzc29jaWF0ZWQgd2l0aCBhIERPTSBlbGVtZW50LlxuICogRm9yIGV4YW1wbGUsIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vS2V5Ym9hcmRab29tfktleWJvYXJkWm9vbX0gaXNcbiAqIGZ1bmN0aW9uYWxseSB0aGUgc2FtZSBhcyB7QGxpbmsgbW9kdWxlOm9sL2NvbnRyb2wvWm9vbX5ab29tfSwgYnV0IHRyaWdnZXJlZFxuICogYnkgYSBrZXlib2FyZCBldmVudCBub3QgYSBidXR0b24gZWxlbWVudCBldmVudC5cbiAqIEFsdGhvdWdoIGludGVyYWN0aW9ucyBkbyBub3QgaGF2ZSBhIERPTSBlbGVtZW50LCBzb21lIG9mIHRoZW0gZG8gcmVuZGVyXG4gKiB2ZWN0b3JzIGFuZCBzbyBhcmUgdmlzaWJsZSBvbiB0aGUgc2NyZWVuLlxuICogQGFwaVxuICovXG52YXIgSW50ZXJhY3Rpb24gPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChCYXNlT2JqZWN0KSB7XG4gIGZ1bmN0aW9uIEludGVyYWN0aW9uKG9wdGlvbnMpIHtcbiAgICBCYXNlT2JqZWN0LmNhbGwodGhpcyk7XG5cbiAgICBpZiAob3B0aW9ucy5oYW5kbGVFdmVudCkge1xuICAgICAgdGhpcy5oYW5kbGVFdmVudCA9IG9wdGlvbnMuaGFuZGxlRXZlbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5tYXBfID0gbnVsbDtcblxuICAgIHRoaXMuc2V0QWN0aXZlKHRydWUpO1xuICB9XG5cbiAgaWYgKCBCYXNlT2JqZWN0ICkgSW50ZXJhY3Rpb24uX19wcm90b19fID0gQmFzZU9iamVjdDtcbiAgSW50ZXJhY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQmFzZU9iamVjdCAmJiBCYXNlT2JqZWN0LnByb3RvdHlwZSApO1xuICBJbnRlcmFjdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbnRlcmFjdGlvbjtcblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhlIGludGVyYWN0aW9uIGlzIGN1cnJlbnRseSBhY3RpdmUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgaW50ZXJhY3Rpb24gaXMgYWN0aXZlLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgSW50ZXJhY3Rpb24ucHJvdG90eXBlLmdldEFjdGl2ZSA9IGZ1bmN0aW9uIGdldEFjdGl2ZSAoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi8gKHRoaXMuZ2V0KEludGVyYWN0aW9uUHJvcGVydHkuQUNUSVZFKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWFwIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGludGVyYWN0aW9uLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuZGVmYXVsdH0gTWFwLlxuICAgKiBAYXBpXG4gICAqL1xuICBJbnRlcmFjdGlvbi5wcm90b3R5cGUuZ2V0TWFwID0gZnVuY3Rpb24gZ2V0TWFwICgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXBfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudCBtYXAgYnJvd3NlciBldmVudH0uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gYGZhbHNlYCB0byBzdG9wIGV2ZW50IHByb3BhZ2F0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBJbnRlcmFjdGlvbi5wcm90b3R5cGUuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiBoYW5kbGVFdmVudCAobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFjdGl2YXRlIG9yIGRlYWN0aXZhdGUgdGhlIGludGVyYWN0aW9uLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFjdGl2ZSBBY3RpdmUuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIEludGVyYWN0aW9uLnByb3RvdHlwZS5zZXRBY3RpdmUgPSBmdW5jdGlvbiBzZXRBY3RpdmUgKGFjdGl2ZSkge1xuICAgIHRoaXMuc2V0KEludGVyYWN0aW9uUHJvcGVydHkuQUNUSVZFLCBhY3RpdmUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGludGVyYWN0aW9uIGZyb20gaXRzIGN1cnJlbnQgbWFwIGFuZCBhdHRhY2ggaXQgdG8gdGhlIG5ldyBtYXAuXG4gICAqIFN1YmNsYXNzZXMgbWF5IHNldCB1cCBldmVudCBoYW5kbGVycyB0byBnZXQgbm90aWZpZWQgYWJvdXQgY2hhbmdlcyB0b1xuICAgKiB0aGUgbWFwIGhlcmUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLmRlZmF1bHR9IG1hcCBNYXAuXG4gICAqL1xuICBJbnRlcmFjdGlvbi5wcm90b3R5cGUuc2V0TWFwID0gZnVuY3Rpb24gc2V0TWFwIChtYXApIHtcbiAgICB0aGlzLm1hcF8gPSBtYXA7XG4gIH07XG5cbiAgcmV0dXJuIEludGVyYWN0aW9uO1xufShCYXNlT2JqZWN0KSk7XG5cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL1ZpZXcuanNcIikuZGVmYXVsdH0gdmlldyBWaWV3LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGRlbHRhIERlbHRhLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZHVyYXRpb24gRHVyYXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYW4odmlldywgZGVsdGEsIG9wdF9kdXJhdGlvbikge1xuICB2YXIgY3VycmVudENlbnRlciA9IHZpZXcuZ2V0Q2VudGVyKCk7XG4gIGlmIChjdXJyZW50Q2VudGVyKSB7XG4gICAgdmFyIGNlbnRlciA9IHZpZXcuY29uc3RyYWluQ2VudGVyKFxuICAgICAgW2N1cnJlbnRDZW50ZXJbMF0gKyBkZWx0YVswXSwgY3VycmVudENlbnRlclsxXSArIGRlbHRhWzFdXSk7XG4gICAgaWYgKG9wdF9kdXJhdGlvbikge1xuICAgICAgdmlldy5hbmltYXRlKHtcbiAgICAgICAgZHVyYXRpb246IG9wdF9kdXJhdGlvbixcbiAgICAgICAgZWFzaW5nOiBsaW5lYXIsXG4gICAgICAgIGNlbnRlcjogY2VudGVyXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmlldy5zZXRDZW50ZXIoY2VudGVyKTtcbiAgICB9XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vVmlldy5qc1wiKS5kZWZhdWx0fSB2aWV3IFZpZXcuXG4gKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU9fSBvcHRfYW5jaG9yIEFuY2hvciBjb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZHVyYXRpb24gRHVyYXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGUodmlldywgcm90YXRpb24sIG9wdF9hbmNob3IsIG9wdF9kdXJhdGlvbikge1xuICByb3RhdGlvbiA9IHZpZXcuY29uc3RyYWluUm90YXRpb24ocm90YXRpb24sIDApO1xuICByb3RhdGVXaXRob3V0Q29uc3RyYWludHModmlldywgcm90YXRpb24sIG9wdF9hbmNob3IsIG9wdF9kdXJhdGlvbik7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL1ZpZXcuanNcIikuZGVmYXVsdH0gdmlldyBWaWV3LlxuICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPX0gb3B0X2FuY2hvciBBbmNob3IgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2R1cmF0aW9uIER1cmF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlV2l0aG91dENvbnN0cmFpbnRzKHZpZXcsIHJvdGF0aW9uLCBvcHRfYW5jaG9yLCBvcHRfZHVyYXRpb24pIHtcbiAgaWYgKHJvdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgY3VycmVudFJvdGF0aW9uID0gdmlldy5nZXRSb3RhdGlvbigpO1xuICAgIHZhciBjdXJyZW50Q2VudGVyID0gdmlldy5nZXRDZW50ZXIoKTtcbiAgICBpZiAoY3VycmVudFJvdGF0aW9uICE9PSB1bmRlZmluZWQgJiYgY3VycmVudENlbnRlciAmJiBvcHRfZHVyYXRpb24gPiAwKSB7XG4gICAgICB2aWV3LmFuaW1hdGUoe1xuICAgICAgICByb3RhdGlvbjogcm90YXRpb24sXG4gICAgICAgIGFuY2hvcjogb3B0X2FuY2hvcixcbiAgICAgICAgZHVyYXRpb246IG9wdF9kdXJhdGlvbixcbiAgICAgICAgZWFzaW5nOiBlYXNlT3V0XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmlldy5yb3RhdGUocm90YXRpb24sIG9wdF9hbmNob3IpO1xuICAgIH1cbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9WaWV3LmpzXCIpLmRlZmF1bHR9IHZpZXcgVmlldy5cbiAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uIHRvIGdvIHRvLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU9fSBvcHRfYW5jaG9yIEFuY2hvciBjb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZHVyYXRpb24gRHVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9kaXJlY3Rpb24gWm9vbWluZyBkaXJlY3Rpb247ID4gMCBpbmRpY2F0ZXNcbiAqICAgICB6b29taW5nIG91dCwgaW4gd2hpY2ggY2FzZSB0aGUgY29uc3RyYWludHMgc3lzdGVtIHdpbGwgc2VsZWN0XG4gKiAgICAgdGhlIGxhcmdlc3QgbmVhcmVzdCByZXNvbHV0aW9uOyA8IDAgaW5kaWNhdGVzIHpvb21pbmcgaW4sIGluXG4gKiAgICAgd2hpY2ggY2FzZSB0aGUgY29uc3RyYWludHMgc3lzdGVtIHdpbGwgc2VsZWN0IHRoZSBzbWFsbGVzdFxuICogICAgIG5lYXJlc3QgcmVzb2x1dGlvbjsgPT0gMCBpbmRpY2F0ZXMgdGhhdCB0aGUgem9vbWluZyBkaXJlY3Rpb25cbiAqICAgICBpcyB1bmtub3duL25vdCByZWxldmFudCwgaW4gd2hpY2ggY2FzZSB0aGUgY29uc3RyYWludHMgc3lzdGVtXG4gKiAgICAgd2lsbCBzZWxlY3QgdGhlIG5lYXJlc3QgcmVzb2x1dGlvbi4gSWYgbm90IGRlZmluZWQgMCBpc1xuICogICAgIGFzc3VtZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB6b29tKHZpZXcsIHJlc29sdXRpb24sIG9wdF9hbmNob3IsIG9wdF9kdXJhdGlvbiwgb3B0X2RpcmVjdGlvbikge1xuICByZXNvbHV0aW9uID0gdmlldy5jb25zdHJhaW5SZXNvbHV0aW9uKHJlc29sdXRpb24sIDAsIG9wdF9kaXJlY3Rpb24pO1xuICB6b29tV2l0aG91dENvbnN0cmFpbnRzKHZpZXcsIHJlc29sdXRpb24sIG9wdF9hbmNob3IsIG9wdF9kdXJhdGlvbik7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL1ZpZXcuanNcIikuZGVmYXVsdH0gdmlldyBWaWV3LlxuICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhIERlbHRhIGZyb20gcHJldmlvdXMgem9vbSBsZXZlbC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPX0gb3B0X2FuY2hvciBBbmNob3IgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2R1cmF0aW9uIER1cmF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gem9vbUJ5RGVsdGEodmlldywgZGVsdGEsIG9wdF9hbmNob3IsIG9wdF9kdXJhdGlvbikge1xuICB2YXIgY3VycmVudFJlc29sdXRpb24gPSB2aWV3LmdldFJlc29sdXRpb24oKTtcbiAgdmFyIHJlc29sdXRpb24gPSB2aWV3LmNvbnN0cmFpblJlc29sdXRpb24oY3VycmVudFJlc29sdXRpb24sIGRlbHRhLCAwKTtcblxuICBpZiAocmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHJlc29sdXRpb25zID0gdmlldy5nZXRSZXNvbHV0aW9ucygpO1xuICAgIHJlc29sdXRpb24gPSBjbGFtcChcbiAgICAgIHJlc29sdXRpb24sXG4gICAgICB2aWV3LmdldE1pblJlc29sdXRpb24oKSB8fCByZXNvbHV0aW9uc1tyZXNvbHV0aW9ucy5sZW5ndGggLSAxXSxcbiAgICAgIHZpZXcuZ2V0TWF4UmVzb2x1dGlvbigpIHx8IHJlc29sdXRpb25zWzBdKTtcbiAgfVxuXG4gIC8vIElmIHdlIGhhdmUgYSBjb25zdHJhaW50IG9uIGNlbnRlciwgd2UgbmVlZCB0byBjaGFuZ2UgdGhlIGFuY2hvciBzbyB0aGF0IHRoZVxuICAvLyBuZXcgY2VudGVyIGlzIHdpdGhpbiB0aGUgZXh0ZW50LiBXZSBmaXJzdCBjYWxjdWxhdGUgdGhlIG5ldyBjZW50ZXIsIGFwcGx5XG4gIC8vIHRoZSBjb25zdHJhaW50IHRvIGl0LCBhbmQgdGhlbiBjYWxjdWxhdGUgYmFjayB0aGUgYW5jaG9yXG4gIGlmIChvcHRfYW5jaG9yICYmIHJlc29sdXRpb24gIT09IHVuZGVmaW5lZCAmJiByZXNvbHV0aW9uICE9PSBjdXJyZW50UmVzb2x1dGlvbikge1xuICAgIHZhciBjdXJyZW50Q2VudGVyID0gdmlldy5nZXRDZW50ZXIoKTtcbiAgICB2YXIgY2VudGVyID0gdmlldy5jYWxjdWxhdGVDZW50ZXJab29tKHJlc29sdXRpb24sIG9wdF9hbmNob3IpO1xuICAgIGNlbnRlciA9IHZpZXcuY29uc3RyYWluQ2VudGVyKGNlbnRlcik7XG5cbiAgICBvcHRfYW5jaG9yID0gW1xuICAgICAgKHJlc29sdXRpb24gKiBjdXJyZW50Q2VudGVyWzBdIC0gY3VycmVudFJlc29sdXRpb24gKiBjZW50ZXJbMF0pIC9cbiAgICAgICAgICAocmVzb2x1dGlvbiAtIGN1cnJlbnRSZXNvbHV0aW9uKSxcbiAgICAgIChyZXNvbHV0aW9uICogY3VycmVudENlbnRlclsxXSAtIGN1cnJlbnRSZXNvbHV0aW9uICogY2VudGVyWzFdKSAvXG4gICAgICAgICAgKHJlc29sdXRpb24gLSBjdXJyZW50UmVzb2x1dGlvbilcbiAgICBdO1xuICB9XG5cbiAgem9vbVdpdGhvdXRDb25zdHJhaW50cyh2aWV3LCByZXNvbHV0aW9uLCBvcHRfYW5jaG9yLCBvcHRfZHVyYXRpb24pO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9WaWV3LmpzXCIpLmRlZmF1bHR9IHZpZXcgVmlldy5cbiAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uIHRvIGdvIHRvLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU9fSBvcHRfYW5jaG9yIEFuY2hvciBjb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZHVyYXRpb24gRHVyYXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB6b29tV2l0aG91dENvbnN0cmFpbnRzKHZpZXcsIHJlc29sdXRpb24sIG9wdF9hbmNob3IsIG9wdF9kdXJhdGlvbikge1xuICBpZiAocmVzb2x1dGlvbikge1xuICAgIHZhciBjdXJyZW50UmVzb2x1dGlvbiA9IHZpZXcuZ2V0UmVzb2x1dGlvbigpO1xuICAgIHZhciBjdXJyZW50Q2VudGVyID0gdmlldy5nZXRDZW50ZXIoKTtcbiAgICBpZiAoY3VycmVudFJlc29sdXRpb24gIT09IHVuZGVmaW5lZCAmJiBjdXJyZW50Q2VudGVyICYmXG4gICAgICAgIHJlc29sdXRpb24gIT09IGN1cnJlbnRSZXNvbHV0aW9uICYmIG9wdF9kdXJhdGlvbikge1xuICAgICAgdmlldy5hbmltYXRlKHtcbiAgICAgICAgcmVzb2x1dGlvbjogcmVzb2x1dGlvbixcbiAgICAgICAgYW5jaG9yOiBvcHRfYW5jaG9yLFxuICAgICAgICBkdXJhdGlvbjogb3B0X2R1cmF0aW9uLFxuICAgICAgICBlYXNpbmc6IGVhc2VPdXRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3B0X2FuY2hvcikge1xuICAgICAgICB2YXIgY2VudGVyID0gdmlldy5jYWxjdWxhdGVDZW50ZXJab29tKHJlc29sdXRpb24sIG9wdF9hbmNob3IpO1xuICAgICAgICB2aWV3LnNldENlbnRlcihjZW50ZXIpO1xuICAgICAgfVxuICAgICAgdmlldy5zZXRSZXNvbHV0aW9uKHJlc29sdXRpb24pO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBJbnRlcmFjdGlvbjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW50ZXJhY3Rpb24uanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL0tleWJvYXJkUGFuXG4gKi9cbmltcG9ydCB7cm90YXRlIGFzIHJvdGF0ZUNvb3JkaW5hdGV9IGZyb20gJy4uL2Nvb3JkaW5hdGUuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBLZXlDb2RlIGZyb20gJy4uL2V2ZW50cy9LZXlDb2RlLmpzJztcbmltcG9ydCB7bm9Nb2RpZmllcktleXMsIHRhcmdldE5vdEVkaXRhYmxlfSBmcm9tICcuLi9ldmVudHMvY29uZGl0aW9uLmpzJztcbmltcG9ydCBJbnRlcmFjdGlvbiwge3Bhbn0gZnJvbSAnLi9JbnRlcmFjdGlvbi5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufSBbY29uZGl0aW9uXSBBIGZ1bmN0aW9uIHRoYXRcbiAqIHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0gYW5kIHJldHVybnMgYVxuICogYm9vbGVhbiB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoYXQgZXZlbnQgc2hvdWxkIGJlIGhhbmRsZWQuIERlZmF1bHQgaXNcbiAqIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbn5ub01vZGlmaWVyS2V5c30gYW5kXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb25+dGFyZ2V0Tm90RWRpdGFibGV9LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkdXJhdGlvbj0xMDBdIEFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3BpeGVsRGVsdGE9MTI4XSBUaGUgYW1vdW50IG9mIHBpeGVscyB0byBwYW4gb24gZWFjaCBrZXlcbiAqIHByZXNzLlxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBbGxvd3MgdGhlIHVzZXIgdG8gcGFuIHRoZSBtYXAgdXNpbmcga2V5Ym9hcmQgYXJyb3dzLlxuICogTm90ZSB0aGF0LCBhbHRob3VnaCB0aGlzIGludGVyYWN0aW9uIGlzIGJ5IGRlZmF1bHQgaW5jbHVkZWQgaW4gbWFwcyxcbiAqIHRoZSBrZXlzIGNhbiBvbmx5IGJlIHVzZWQgd2hlbiBicm93c2VyIGZvY3VzIGlzIG9uIHRoZSBlbGVtZW50IHRvIHdoaWNoXG4gKiB0aGUga2V5Ym9hcmQgZXZlbnRzIGFyZSBhdHRhY2hlZC4gQnkgZGVmYXVsdCwgdGhpcyBpcyB0aGUgbWFwIGRpdixcbiAqIHRob3VnaCB5b3UgY2FuIGNoYW5nZSB0aGlzIHdpdGggdGhlIGBrZXlib2FyZEV2ZW50VGFyZ2V0YCBpblxuICoge0BsaW5rIG1vZHVsZTpvbC9NYXB+TWFwfS4gYGRvY3VtZW50YCBuZXZlciBsb3NlcyBmb2N1cyBidXQsIGZvciBhbnkgb3RoZXJcbiAqIGVsZW1lbnQsIGZvY3VzIHdpbGwgaGF2ZSB0byBiZSBvbiwgYW5kIHJldHVybmVkIHRvLCB0aGlzIGVsZW1lbnQgaWYgdGhlIGtleXNcbiAqIGFyZSB0byBmdW5jdGlvbi5cbiAqIFNlZSBhbHNvIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vS2V5Ym9hcmRab29tfktleWJvYXJkWm9vbX0uXG4gKiBAYXBpXG4gKi9cbnZhciBLZXlib2FyZFBhbiA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEludGVyYWN0aW9uKSB7XG4gIGZ1bmN0aW9uIEtleWJvYXJkUGFuKG9wdF9vcHRpb25zKSB7XG5cbiAgICBJbnRlcmFjdGlvbi5jYWxsKHRoaXMsIHtcbiAgICAgIGhhbmRsZUV2ZW50OiBoYW5kbGVFdmVudFxuICAgIH0pO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBvcHRfb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IEJyb3dzZXIgZXZlbnQuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gQ29tYmluZWQgY29uZGl0aW9uIHJlc3VsdC5cbiAgICAgKi9cbiAgICB0aGlzLmRlZmF1bHRDb25kaXRpb25fID0gZnVuY3Rpb24obWFwQnJvd3NlckV2ZW50KSB7XG4gICAgICByZXR1cm4gbm9Nb2RpZmllcktleXMobWFwQnJvd3NlckV2ZW50KSAmJlxuICAgICAgICB0YXJnZXROb3RFZGl0YWJsZShtYXBCcm93c2VyRXZlbnQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbmRpdGlvbl8gPSBvcHRpb25zLmNvbmRpdGlvbiAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdGlvbnMuY29uZGl0aW9uIDogdGhpcy5kZWZhdWx0Q29uZGl0aW9uXztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmR1cmF0aW9uXyA9IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiAxMDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5waXhlbERlbHRhXyA9IG9wdGlvbnMucGl4ZWxEZWx0YSAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdGlvbnMucGl4ZWxEZWx0YSA6IDEyODtcblxuICB9XG5cbiAgaWYgKCBJbnRlcmFjdGlvbiApIEtleWJvYXJkUGFuLl9fcHJvdG9fXyA9IEludGVyYWN0aW9uO1xuICBLZXlib2FyZFBhbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbnRlcmFjdGlvbiAmJiBJbnRlcmFjdGlvbi5wcm90b3R5cGUgKTtcbiAgS2V5Ym9hcmRQYW4ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gS2V5Ym9hcmRQYW47XG5cbiAgcmV0dXJuIEtleWJvYXJkUGFuO1xufShJbnRlcmFjdGlvbikpO1xuXG5cbi8qKlxuICogSGFuZGxlcyB0aGUge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnQgbWFwIGJyb3dzZXIgZXZlbnR9IGlmIGl0IHdhcyBhXG4gKiBgS2V5RXZlbnRgLCBhbmQgZGVjaWRlcyB0aGUgZGlyZWN0aW9uIHRvIHBhbiB0byAoaWYgYW4gYXJyb3cga2V5IHdhc1xuICogcHJlc3NlZCkuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBgZmFsc2VgIHRvIHN0b3AgZXZlbnQgcHJvcGFnYXRpb24uXG4gKiBAdGhpcyB7S2V5Ym9hcmRQYW59XG4gKi9cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICB2YXIgc3RvcEV2ZW50ID0gZmFsc2U7XG4gIGlmIChtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBFdmVudFR5cGUuS0VZRE9XTikge1xuICAgIHZhciBrZXlFdmVudCA9IC8qKiBAdHlwZSB7S2V5Ym9hcmRFdmVudH0gKi8gKG1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50KTtcbiAgICB2YXIga2V5Q29kZSA9IGtleUV2ZW50LmtleUNvZGU7XG4gICAgaWYgKHRoaXMuY29uZGl0aW9uXyhtYXBCcm93c2VyRXZlbnQpICYmXG4gICAgICAgIChrZXlDb2RlID09IEtleUNvZGUuRE9XTiB8fFxuICAgICAgICBrZXlDb2RlID09IEtleUNvZGUuTEVGVCB8fFxuICAgICAgICBrZXlDb2RlID09IEtleUNvZGUuUklHSFQgfHxcbiAgICAgICAga2V5Q29kZSA9PSBLZXlDb2RlLlVQKSkge1xuICAgICAgdmFyIG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgICB2YXIgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgICB2YXIgbWFwVW5pdHNEZWx0YSA9IHZpZXcuZ2V0UmVzb2x1dGlvbigpICogdGhpcy5waXhlbERlbHRhXztcbiAgICAgIHZhciBkZWx0YVggPSAwLCBkZWx0YVkgPSAwO1xuICAgICAgaWYgKGtleUNvZGUgPT0gS2V5Q29kZS5ET1dOKSB7XG4gICAgICAgIGRlbHRhWSA9IC1tYXBVbml0c0RlbHRhO1xuICAgICAgfSBlbHNlIGlmIChrZXlDb2RlID09IEtleUNvZGUuTEVGVCkge1xuICAgICAgICBkZWx0YVggPSAtbWFwVW5pdHNEZWx0YTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA9PSBLZXlDb2RlLlJJR0hUKSB7XG4gICAgICAgIGRlbHRhWCA9IG1hcFVuaXRzRGVsdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWx0YVkgPSBtYXBVbml0c0RlbHRhO1xuICAgICAgfVxuICAgICAgdmFyIGRlbHRhID0gW2RlbHRhWCwgZGVsdGFZXTtcbiAgICAgIHJvdGF0ZUNvb3JkaW5hdGUoZGVsdGEsIHZpZXcuZ2V0Um90YXRpb24oKSk7XG4gICAgICBwYW4odmlldywgZGVsdGEsIHRoaXMuZHVyYXRpb25fKTtcbiAgICAgIG1hcEJyb3dzZXJFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgc3RvcEV2ZW50ID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuICFzdG9wRXZlbnQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IEtleWJvYXJkUGFuO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1LZXlib2FyZFBhbi5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vS2V5Ym9hcmRab29tXG4gKi9cbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQge3RhcmdldE5vdEVkaXRhYmxlfSBmcm9tICcuLi9ldmVudHMvY29uZGl0aW9uLmpzJztcbmltcG9ydCBJbnRlcmFjdGlvbiwge3pvb21CeURlbHRhfSBmcm9tICcuL0ludGVyYWN0aW9uLmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHVyYXRpb249MTAwXSBBbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn0gW2NvbmRpdGlvbl0gQSBmdW5jdGlvbiB0aGF0XG4gKiB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnR9IGFuZCByZXR1cm5zIGFcbiAqIGJvb2xlYW4gdG8gaW5kaWNhdGUgd2hldGhlciB0aGF0IGV2ZW50IHNob3VsZCBiZSBoYW5kbGVkLiBEZWZhdWx0IGlzXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb25+dGFyZ2V0Tm90RWRpdGFibGV9LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkZWx0YT0xXSBUaGUgem9vbSBsZXZlbCBkZWx0YSBvbiBlYWNoIGtleSBwcmVzcy5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWxsb3dzIHRoZSB1c2VyIHRvIHpvb20gdGhlIG1hcCB1c2luZyBrZXlib2FyZCArIGFuZCAtLlxuICogTm90ZSB0aGF0LCBhbHRob3VnaCB0aGlzIGludGVyYWN0aW9uIGlzIGJ5IGRlZmF1bHQgaW5jbHVkZWQgaW4gbWFwcyxcbiAqIHRoZSBrZXlzIGNhbiBvbmx5IGJlIHVzZWQgd2hlbiBicm93c2VyIGZvY3VzIGlzIG9uIHRoZSBlbGVtZW50IHRvIHdoaWNoXG4gKiB0aGUga2V5Ym9hcmQgZXZlbnRzIGFyZSBhdHRhY2hlZC4gQnkgZGVmYXVsdCwgdGhpcyBpcyB0aGUgbWFwIGRpdixcbiAqIHRob3VnaCB5b3UgY2FuIGNoYW5nZSB0aGlzIHdpdGggdGhlIGBrZXlib2FyZEV2ZW50VGFyZ2V0YCBpblxuICoge0BsaW5rIG1vZHVsZTpvbC9NYXB+TWFwfS4gYGRvY3VtZW50YCBuZXZlciBsb3NlcyBmb2N1cyBidXQsIGZvciBhbnkgb3RoZXJcbiAqIGVsZW1lbnQsIGZvY3VzIHdpbGwgaGF2ZSB0byBiZSBvbiwgYW5kIHJldHVybmVkIHRvLCB0aGlzIGVsZW1lbnQgaWYgdGhlIGtleXNcbiAqIGFyZSB0byBmdW5jdGlvbi5cbiAqIFNlZSBhbHNvIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vS2V5Ym9hcmRQYW5+S2V5Ym9hcmRQYW59LlxuICogQGFwaVxuICovXG52YXIgS2V5Ym9hcmRab29tID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoSW50ZXJhY3Rpb24pIHtcbiAgZnVuY3Rpb24gS2V5Ym9hcmRab29tKG9wdF9vcHRpb25zKSB7XG5cbiAgICBJbnRlcmFjdGlvbi5jYWxsKHRoaXMsIHtcbiAgICAgIGhhbmRsZUV2ZW50OiBoYW5kbGVFdmVudFxuICAgIH0pO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBvcHRfb3B0aW9ucyA/IG9wdF9vcHRpb25zIDoge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbmRpdGlvbl8gPSBvcHRpb25zLmNvbmRpdGlvbiA/IG9wdGlvbnMuY29uZGl0aW9uIDogdGFyZ2V0Tm90RWRpdGFibGU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kZWx0YV8gPSBvcHRpb25zLmRlbHRhID8gb3B0aW9ucy5kZWx0YSA6IDE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kdXJhdGlvbl8gPSBvcHRpb25zLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmR1cmF0aW9uIDogMTAwO1xuXG4gIH1cblxuICBpZiAoIEludGVyYWN0aW9uICkgS2V5Ym9hcmRab29tLl9fcHJvdG9fXyA9IEludGVyYWN0aW9uO1xuICBLZXlib2FyZFpvb20ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSW50ZXJhY3Rpb24gJiYgSW50ZXJhY3Rpb24ucHJvdG90eXBlICk7XG4gIEtleWJvYXJkWm9vbS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBLZXlib2FyZFpvb207XG5cbiAgcmV0dXJuIEtleWJvYXJkWm9vbTtcbn0oSW50ZXJhY3Rpb24pKTtcblxuXG4vKipcbiAqIEhhbmRsZXMgdGhlIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50IG1hcCBicm93c2VyIGV2ZW50fSBpZiBpdCB3YXMgYVxuICogYEtleUV2ZW50YCwgYW5kIGRlY2lkZXMgd2hldGhlciB0byB6b29tIGluIG9yIG91dCAoZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlXG4gKiBrZXkgcHJlc3NlZCB3YXMgJysnIG9yICctJykuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBgZmFsc2VgIHRvIHN0b3AgZXZlbnQgcHJvcGFnYXRpb24uXG4gKiBAdGhpcyB7S2V5Ym9hcmRab29tfVxuICovXG5mdW5jdGlvbiBoYW5kbGVFdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgdmFyIHN0b3BFdmVudCA9IGZhbHNlO1xuICBpZiAobWFwQnJvd3NlckV2ZW50LnR5cGUgPT0gRXZlbnRUeXBlLktFWURPV04gfHxcbiAgICAgIG1hcEJyb3dzZXJFdmVudC50eXBlID09IEV2ZW50VHlwZS5LRVlQUkVTUykge1xuICAgIHZhciBrZXlFdmVudCA9IC8qKiBAdHlwZSB7S2V5Ym9hcmRFdmVudH0gKi8gKG1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50KTtcbiAgICB2YXIgY2hhckNvZGUgPSBrZXlFdmVudC5jaGFyQ29kZTtcbiAgICBpZiAodGhpcy5jb25kaXRpb25fKG1hcEJyb3dzZXJFdmVudCkgJiZcbiAgICAgICAgKGNoYXJDb2RlID09ICcrJy5jaGFyQ29kZUF0KDApIHx8IGNoYXJDb2RlID09ICctJy5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgdmFyIG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgICB2YXIgZGVsdGEgPSAoY2hhckNvZGUgPT0gJysnLmNoYXJDb2RlQXQoMCkpID8gdGhpcy5kZWx0YV8gOiAtdGhpcy5kZWx0YV87XG4gICAgICB2YXIgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgICB6b29tQnlEZWx0YSh2aWV3LCBkZWx0YSwgdW5kZWZpbmVkLCB0aGlzLmR1cmF0aW9uXyk7XG4gICAgICBtYXBCcm93c2VyRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHN0b3BFdmVudCA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiAhc3RvcEV2ZW50O1xufVxuXG5leHBvcnQgZGVmYXVsdCBLZXlib2FyZFpvb207XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUtleWJvYXJkWm9vbS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vTW9kaWZ5XG4gKi9cbmltcG9ydCB7Z2V0VWlkfSBmcm9tICcuLi91dGlsLmpzJztcbmltcG9ydCBDb2xsZWN0aW9uIGZyb20gJy4uL0NvbGxlY3Rpb24uanMnO1xuaW1wb3J0IENvbGxlY3Rpb25FdmVudFR5cGUgZnJvbSAnLi4vQ29sbGVjdGlvbkV2ZW50VHlwZS5qcyc7XG5pbXBvcnQgRmVhdHVyZSBmcm9tICcuLi9GZWF0dXJlLmpzJztcbmltcG9ydCBNYXBCcm93c2VyRXZlbnRUeXBlIGZyb20gJy4uL01hcEJyb3dzZXJFdmVudFR5cGUuanMnO1xuaW1wb3J0IHtlcXVhbHN9IGZyb20gJy4uL2FycmF5LmpzJztcbmltcG9ydCB7ZXF1YWxzIGFzIGNvb3JkaW5hdGVzRXF1YWwsIGRpc3RhbmNlIGFzIGNvb3JkaW5hdGVEaXN0YW5jZSwgc3F1YXJlZERpc3RhbmNlIGFzIHNxdWFyZWRDb29yZGluYXRlRGlzdGFuY2UsIHNxdWFyZWREaXN0YW5jZVRvU2VnbWVudCwgY2xvc2VzdE9uU2VnbWVudH0gZnJvbSAnLi4vY29vcmRpbmF0ZS5qcyc7XG5pbXBvcnQge2xpc3RlbiwgdW5saXN0ZW59IGZyb20gJy4uL2V2ZW50cy5qcyc7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzL0V2ZW50LmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQge2Fsd2F5cywgcHJpbWFyeUFjdGlvbiwgYWx0S2V5T25seSwgc2luZ2xlQ2xpY2t9IGZyb20gJy4uL2V2ZW50cy9jb25kaXRpb24uanMnO1xuaW1wb3J0IHtib3VuZGluZ0V4dGVudCwgYnVmZmVyLCBjcmVhdGVPclVwZGF0ZUZyb21Db29yZGluYXRlfSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IEdlb21ldHJ5VHlwZSBmcm9tICcuLi9nZW9tL0dlb21ldHJ5VHlwZS5qcyc7XG5pbXBvcnQgUG9pbnQgZnJvbSAnLi4vZ2VvbS9Qb2ludC5qcyc7XG5pbXBvcnQgUG9pbnRlckludGVyYWN0aW9uIGZyb20gJy4vUG9pbnRlci5qcyc7XG5pbXBvcnQgVmVjdG9yTGF5ZXIgZnJvbSAnLi4vbGF5ZXIvVmVjdG9yLmpzJztcbmltcG9ydCBWZWN0b3JTb3VyY2UgZnJvbSAnLi4vc291cmNlL1ZlY3Rvci5qcyc7XG5pbXBvcnQgVmVjdG9yRXZlbnRUeXBlIGZyb20gJy4uL3NvdXJjZS9WZWN0b3JFdmVudFR5cGUuanMnO1xuaW1wb3J0IFJCdXNoIGZyb20gJy4uL3N0cnVjdHMvUkJ1c2guanMnO1xuaW1wb3J0IHtjcmVhdGVFZGl0aW5nU3R5bGV9IGZyb20gJy4uL3N0eWxlL1N0eWxlLmpzJztcblxuXG4vKipcbiAqIFRoZSBzZWdtZW50IGluZGV4IGFzc2lnbmVkIHRvIGEgY2lyY2xlJ3MgY2VudGVyIHdoZW5cbiAqIGJyZWFraW5nIHVwIGEgY2lyY2xlIGludG8gTW9kaWZ5U2VnbWVudERhdGFUeXBlIHNlZ21lbnRzLlxuICogQHR5cGUge251bWJlcn1cbiAqL1xudmFyIENJUkNMRV9DRU5URVJfSU5ERVggPSAwO1xuXG4vKipcbiAqIFRoZSBzZWdtZW50IGluZGV4IGFzc2lnbmVkIHRvIGEgY2lyY2xlJ3MgY2lyY3VtZmVyZW5jZSB3aGVuXG4gKiBicmVha2luZyB1cCBhIGNpcmNsZSBpbnRvIE1vZGlmeVNlZ21lbnREYXRhVHlwZSBzZWdtZW50cy5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbnZhciBDSVJDTEVfQ0lSQ1VNRkVSRU5DRV9JTkRFWCA9IDE7XG5cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG52YXIgTW9kaWZ5RXZlbnRUeXBlID0ge1xuICAvKipcbiAgICogVHJpZ2dlcmVkIHVwb24gZmVhdHVyZSBtb2RpZmljYXRpb24gc3RhcnRcbiAgICogQGV2ZW50IE1vZGlmeUV2ZW50I21vZGlmeXN0YXJ0XG4gICAqIEBhcGlcbiAgICovXG4gIE1PRElGWVNUQVJUOiAnbW9kaWZ5c3RhcnQnLFxuICAvKipcbiAgICogVHJpZ2dlcmVkIHVwb24gZmVhdHVyZSBtb2RpZmljYXRpb24gZW5kXG4gICAqIEBldmVudCBNb2RpZnlFdmVudCNtb2RpZnllbmRcbiAgICogQGFwaVxuICAgKi9cbiAgTU9ESUZZRU5EOiAnbW9kaWZ5ZW5kJ1xufTtcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNlZ21lbnREYXRhXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IFtkZXB0aF1cbiAqIEBwcm9wZXJ0eSB7RmVhdHVyZX0gZmVhdHVyZVxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5XG4gKiBAcHJvcGVydHkge251bWJlcn0gW2luZGV4XVxuICogQHByb3BlcnR5IHtBcnJheTxpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50Pn0gc2VnbWVudFxuICogQHByb3BlcnR5IHtBcnJheTxTZWdtZW50RGF0YT59IFtmZWF0dXJlU2VnbWVudHNdXG4gKi9cblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259IFtjb25kaXRpb25dIEEgZnVuY3Rpb24gdGhhdFxuICogdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmQgcmV0dXJucyBhXG4gKiBib29sZWFuIHRvIGluZGljYXRlIHdoZXRoZXIgdGhhdCBldmVudCB3aWxsIGJlIGNvbnNpZGVyZWQgdG8gYWRkIG9yIG1vdmUgYVxuICogdmVydGV4IHRvIHRoZSBza2V0Y2guIERlZmF1bHQgaXNcbiAqIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbn5wcmltYXJ5QWN0aW9ufS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259IFtkZWxldGVDb25kaXRpb25dIEEgZnVuY3Rpb25cbiAqIHRoYXQgdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmQgcmV0dXJucyBhXG4gKiBib29sZWFuIHRvIGluZGljYXRlIHdoZXRoZXIgdGhhdCBldmVudCBzaG91bGQgYmUgaGFuZGxlZC4gQnkgZGVmYXVsdCxcbiAqIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbn5zaW5nbGVDbGlja30gd2l0aFxuICoge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9ufmFsdEtleU9ubHl9IHJlc3VsdHMgaW4gYSB2ZXJ0ZXggZGVsZXRpb24uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufSBbaW5zZXJ0VmVydGV4Q29uZGl0aW9uXSBBXG4gKiBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0gYW5kXG4gKiByZXR1cm5zIGEgYm9vbGVhbiB0byBpbmRpY2F0ZSB3aGV0aGVyIGEgbmV3IHZlcnRleCBjYW4gYmUgYWRkZWQgdG8gdGhlIHNrZXRjaFxuICogZmVhdHVyZXMuIERlZmF1bHQgaXMge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9ufmFsd2F5c30uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3BpeGVsVG9sZXJhbmNlPTEwXSBQaXhlbCB0b2xlcmFuY2UgZm9yIGNvbnNpZGVyaW5nIHRoZVxuICogcG9pbnRlciBjbG9zZSBlbm91Z2ggdG8gYSBzZWdtZW50IG9yIHZlcnRleCBmb3IgZWRpdGluZy5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVMaWtlfSBbc3R5bGVdXG4gKiBTdHlsZSB1c2VkIGZvciB0aGUgZmVhdHVyZXMgYmVpbmcgbW9kaWZpZWQuIEJ5IGRlZmF1bHQgdGhlIGRlZmF1bHQgZWRpdFxuICogc3R5bGUgaXMgdXNlZCAoc2VlIHtAbGluayBtb2R1bGU6b2wvc3R5bGV9KS5cbiAqIEBwcm9wZXJ0eSB7VmVjdG9yU291cmNlfSBbc291cmNlXSBUaGUgdmVjdG9yIHNvdXJjZSB3aXRoXG4gKiBmZWF0dXJlcyB0byBtb2RpZnkuICBJZiBhIHZlY3RvciBzb3VyY2UgaXMgbm90IHByb3ZpZGVkLCBhIGZlYXR1cmUgY29sbGVjdGlvblxuICogbXVzdCBiZSBwcm92aWRlZCB3aXRoIHRoZSBmZWF0dXJlcyBvcHRpb24uXG4gKiBAcHJvcGVydHkge0NvbGxlY3Rpb248RmVhdHVyZT59IFtmZWF0dXJlc11cbiAqIFRoZSBmZWF0dXJlcyB0aGUgaW50ZXJhY3Rpb24gd29ya3Mgb24uICBJZiBhIGZlYXR1cmUgY29sbGVjdGlvbiBpcyBub3RcbiAqIHByb3ZpZGVkLCBhIHZlY3RvciBzb3VyY2UgbXVzdCBiZSBwcm92aWRlZCB3aXRoIHRoZSBzb3VyY2Ugb3B0aW9uLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbd3JhcFg9ZmFsc2VdIFdyYXAgdGhlIHdvcmxkIGhvcml6b250YWxseSBvbiB0aGUgc2tldGNoXG4gKiBvdmVybGF5LlxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBFdmVudHMgZW1pdHRlZCBieSB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL01vZGlmeX5Nb2RpZnl9IGluc3RhbmNlcyBhcmVcbiAqIGluc3RhbmNlcyBvZiB0aGlzIHR5cGUuXG4gKi9cbmV4cG9ydCB2YXIgTW9kaWZ5RXZlbnQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChFdmVudCkge1xuICBmdW5jdGlvbiBNb2RpZnlFdmVudCh0eXBlLCBmZWF0dXJlcywgbWFwQnJvd3NlclBvaW50ZXJFdmVudCkge1xuICAgIEV2ZW50LmNhbGwodGhpcywgdHlwZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmVhdHVyZXMgYmVpbmcgbW9kaWZpZWQuXG4gICAgICogQHR5cGUge0NvbGxlY3Rpb248RmVhdHVyZT59XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMuZmVhdHVyZXMgPSBmZWF0dXJlcztcblxuICAgIC8qKlxuICAgICAqIEFzc29jaWF0ZWQge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR9LlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5tYXBCcm93c2VyRXZlbnQgPSBtYXBCcm93c2VyUG9pbnRlckV2ZW50O1xuXG4gIH1cblxuICBpZiAoIEV2ZW50ICkgTW9kaWZ5RXZlbnQuX19wcm90b19fID0gRXZlbnQ7XG4gIE1vZGlmeUV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEV2ZW50ICYmIEV2ZW50LnByb3RvdHlwZSApO1xuICBNb2RpZnlFdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNb2RpZnlFdmVudDtcblxuICByZXR1cm4gTW9kaWZ5RXZlbnQ7XG59KEV2ZW50KSk7XG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBJbnRlcmFjdGlvbiBmb3IgbW9kaWZ5aW5nIGZlYXR1cmUgZ2VvbWV0cmllcy4gIFRvIG1vZGlmeSBmZWF0dXJlcyB0aGF0IGhhdmVcbiAqIGJlZW4gYWRkZWQgdG8gYW4gZXhpc3Rpbmcgc291cmNlLCBjb25zdHJ1Y3QgdGhlIG1vZGlmeSBpbnRlcmFjdGlvbiB3aXRoIHRoZVxuICogYHNvdXJjZWAgb3B0aW9uLiAgSWYgeW91IHdhbnQgdG8gbW9kaWZ5IGZlYXR1cmVzIGluIGEgY29sbGVjdGlvbiAoZm9yIGV4YW1wbGUsXG4gKiB0aGUgY29sbGVjdGlvbiB1c2VkIGJ5IGEgc2VsZWN0IGludGVyYWN0aW9uKSwgY29uc3RydWN0IHRoZSBpbnRlcmFjdGlvbiB3aXRoXG4gKiB0aGUgYGZlYXR1cmVzYCBvcHRpb24uICBUaGUgaW50ZXJhY3Rpb24gbXVzdCBiZSBjb25zdHJ1Y3RlZCB3aXRoIGVpdGhlciBhXG4gKiBgc291cmNlYCBvciBgZmVhdHVyZXNgIG9wdGlvbi5cbiAqXG4gKiBCeSBkZWZhdWx0LCB0aGUgaW50ZXJhY3Rpb24gd2lsbCBhbGxvdyBkZWxldGlvbiBvZiB2ZXJ0aWNlcyB3aGVuIHRoZSBgYWx0YFxuICoga2V5IGlzIHByZXNzZWQuICBUbyBjb25maWd1cmUgdGhlIGludGVyYWN0aW9uIHdpdGggYSBkaWZmZXJlbnQgY29uZGl0aW9uXG4gKiBmb3IgZGVsZXRpb24sIHVzZSB0aGUgYGRlbGV0ZUNvbmRpdGlvbmAgb3B0aW9uLlxuICogQGZpcmVzIE1vZGlmeUV2ZW50XG4gKiBAYXBpXG4gKi9cbnZhciBNb2RpZnkgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChQb2ludGVySW50ZXJhY3Rpb24pIHtcbiAgZnVuY3Rpb24gTW9kaWZ5KG9wdGlvbnMpIHtcblxuICAgIFBvaW50ZXJJbnRlcmFjdGlvbi5jYWxsKC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9Qb2ludGVyLmpzXCIpLk9wdGlvbnN9ICovIHRoaXMsIChvcHRpb25zKSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbmRpdGlvbl8gPSBvcHRpb25zLmNvbmRpdGlvbiA/IG9wdGlvbnMuY29uZGl0aW9uIDogcHJpbWFyeUFjdGlvbjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IEJyb3dzZXIgZXZlbnQuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gQ29tYmluZWQgY29uZGl0aW9uIHJlc3VsdC5cbiAgICAgKi9cbiAgICB0aGlzLmRlZmF1bHREZWxldGVDb25kaXRpb25fID0gZnVuY3Rpb24obWFwQnJvd3NlckV2ZW50KSB7XG4gICAgICByZXR1cm4gYWx0S2V5T25seShtYXBCcm93c2VyRXZlbnQpICYmIHNpbmdsZUNsaWNrKG1hcEJyb3dzZXJFdmVudCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZGVsZXRlQ29uZGl0aW9uXyA9IG9wdGlvbnMuZGVsZXRlQ29uZGl0aW9uID9cbiAgICAgIG9wdGlvbnMuZGVsZXRlQ29uZGl0aW9uIDogdGhpcy5kZWZhdWx0RGVsZXRlQ29uZGl0aW9uXztcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaW5zZXJ0VmVydGV4Q29uZGl0aW9uXyA9IG9wdGlvbnMuaW5zZXJ0VmVydGV4Q29uZGl0aW9uID9cbiAgICAgIG9wdGlvbnMuaW5zZXJ0VmVydGV4Q29uZGl0aW9uIDogYWx3YXlzO1xuXG4gICAgLyoqXG4gICAgICogRWRpdGluZyB2ZXJ0ZXguXG4gICAgICogQHR5cGUge0ZlYXR1cmV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnZlcnRleEZlYXR1cmVfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFNlZ21lbnRzIGludGVyc2VjdGluZyB7QGxpbmsgdGhpcy52ZXJ0ZXhGZWF0dXJlX30gYnkgc2VnbWVudCB1aWQuXG4gICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsIGJvb2xlYW4+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy52ZXJ0ZXhTZWdtZW50c18gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5sYXN0UGl4ZWxfID0gWzAsIDBdO1xuXG4gICAgLyoqXG4gICAgICogVHJhY2tzIGlmIHRoZSBuZXh0IGBzaW5nbGVjbGlja2AgZXZlbnQgc2hvdWxkIGJlIGlnbm9yZWQgdG8gcHJldmVudFxuICAgICAqIGFjY2lkZW50YWwgZGVsZXRpb24gcmlnaHQgYWZ0ZXIgdmVydGV4IGNyZWF0aW9uLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5pZ25vcmVOZXh0U2luZ2xlQ2xpY2tfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubW9kaWZpZWRfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBTZWdtZW50IFJUcmVlIGZvciBlYWNoIGxheWVyXG4gICAgICogQHR5cGUge1JCdXNoPFNlZ21lbnREYXRhPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuckJ1c2hfID0gbmV3IFJCdXNoKCk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5waXhlbFRvbGVyYW5jZV8gPSBvcHRpb25zLnBpeGVsVG9sZXJhbmNlICE9PSB1bmRlZmluZWQgP1xuICAgICAgb3B0aW9ucy5waXhlbFRvbGVyYW5jZSA6IDEwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnNuYXBwZWRUb1ZlcnRleF8gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlIHdoZXRoZXIgdGhlIGludGVyYWN0aW9uIGlzIGN1cnJlbnRseSBjaGFuZ2luZyBhIGZlYXR1cmUnc1xuICAgICAqIGNvb3JkaW5hdGVzLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jaGFuZ2luZ0ZlYXR1cmVfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmRyYWdTZWdtZW50c18gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIERyYXcgb3ZlcmxheSB3aGVyZSBza2V0Y2ggZmVhdHVyZXMgYXJlIGRyYXduLlxuICAgICAqIEB0eXBlIHtWZWN0b3JMYXllcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMub3ZlcmxheV8gPSBuZXcgVmVjdG9yTGF5ZXIoe1xuICAgICAgc291cmNlOiBuZXcgVmVjdG9yU291cmNlKHtcbiAgICAgICAgdXNlU3BhdGlhbEluZGV4OiBmYWxzZSxcbiAgICAgICAgd3JhcFg6ICEhb3B0aW9ucy53cmFwWFxuICAgICAgfSksXG4gICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSA/IG9wdGlvbnMuc3R5bGUgOlxuICAgICAgICBnZXREZWZhdWx0U3R5bGVGdW5jdGlvbigpLFxuICAgICAgdXBkYXRlV2hpbGVBbmltYXRpbmc6IHRydWUsXG4gICAgICB1cGRhdGVXaGlsZUludGVyYWN0aW5nOiB0cnVlXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgZnVuY3Rpb24oRmVhdHVyZSwgaW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0KT59XG4gICAgICovXG4gICAgdGhpcy5TRUdNRU5UX1dSSVRFUlNfID0ge1xuICAgICAgJ1BvaW50JzogdGhpcy53cml0ZVBvaW50R2VvbWV0cnlfLFxuICAgICAgJ0xpbmVTdHJpbmcnOiB0aGlzLndyaXRlTGluZVN0cmluZ0dlb21ldHJ5XyxcbiAgICAgICdMaW5lYXJSaW5nJzogdGhpcy53cml0ZUxpbmVTdHJpbmdHZW9tZXRyeV8sXG4gICAgICAnUG9seWdvbic6IHRoaXMud3JpdGVQb2x5Z29uR2VvbWV0cnlfLFxuICAgICAgJ011bHRpUG9pbnQnOiB0aGlzLndyaXRlTXVsdGlQb2ludEdlb21ldHJ5XyxcbiAgICAgICdNdWx0aUxpbmVTdHJpbmcnOiB0aGlzLndyaXRlTXVsdGlMaW5lU3RyaW5nR2VvbWV0cnlfLFxuICAgICAgJ011bHRpUG9seWdvbic6IHRoaXMud3JpdGVNdWx0aVBvbHlnb25HZW9tZXRyeV8sXG4gICAgICAnQ2lyY2xlJzogdGhpcy53cml0ZUNpcmNsZUdlb21ldHJ5XyxcbiAgICAgICdHZW9tZXRyeUNvbGxlY3Rpb24nOiB0aGlzLndyaXRlR2VvbWV0cnlDb2xsZWN0aW9uR2VvbWV0cnlfXG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge1ZlY3RvclNvdXJjZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc291cmNlXyA9IG51bGw7XG5cbiAgICB2YXIgZmVhdHVyZXM7XG4gICAgaWYgKG9wdGlvbnMuc291cmNlKSB7XG4gICAgICB0aGlzLnNvdXJjZV8gPSBvcHRpb25zLnNvdXJjZTtcbiAgICAgIGZlYXR1cmVzID0gbmV3IENvbGxlY3Rpb24odGhpcy5zb3VyY2VfLmdldEZlYXR1cmVzKCkpO1xuICAgICAgbGlzdGVuKHRoaXMuc291cmNlXywgVmVjdG9yRXZlbnRUeXBlLkFEREZFQVRVUkUsXG4gICAgICAgIHRoaXMuaGFuZGxlU291cmNlQWRkXywgdGhpcyk7XG4gICAgICBsaXN0ZW4odGhpcy5zb3VyY2VfLCBWZWN0b3JFdmVudFR5cGUuUkVNT1ZFRkVBVFVSRSxcbiAgICAgICAgdGhpcy5oYW5kbGVTb3VyY2VSZW1vdmVfLCB0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmVhdHVyZXMgPSBvcHRpb25zLmZlYXR1cmVzO1xuICAgIH1cbiAgICBpZiAoIWZlYXR1cmVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBtb2RpZnkgaW50ZXJhY3Rpb24gcmVxdWlyZXMgZmVhdHVyZXMgb3IgYSBzb3VyY2UnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Q29sbGVjdGlvbjxGZWF0dXJlPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZmVhdHVyZXNfID0gZmVhdHVyZXM7XG5cbiAgICB0aGlzLmZlYXR1cmVzXy5mb3JFYWNoKHRoaXMuYWRkRmVhdHVyZV8uYmluZCh0aGlzKSk7XG4gICAgbGlzdGVuKHRoaXMuZmVhdHVyZXNfLCBDb2xsZWN0aW9uRXZlbnRUeXBlLkFERCxcbiAgICAgIHRoaXMuaGFuZGxlRmVhdHVyZUFkZF8sIHRoaXMpO1xuICAgIGxpc3Rlbih0aGlzLmZlYXR1cmVzXywgQ29sbGVjdGlvbkV2ZW50VHlwZS5SRU1PVkUsXG4gICAgICB0aGlzLmhhbmRsZUZlYXR1cmVSZW1vdmVfLCB0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyUG9pbnRlckV2ZW50LmpzXCIpLmRlZmF1bHR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmxhc3RQb2ludGVyRXZlbnRfID0gbnVsbDtcblxuICB9XG5cbiAgaWYgKCBQb2ludGVySW50ZXJhY3Rpb24gKSBNb2RpZnkuX19wcm90b19fID0gUG9pbnRlckludGVyYWN0aW9uO1xuICBNb2RpZnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUG9pbnRlckludGVyYWN0aW9uICYmIFBvaW50ZXJJbnRlcmFjdGlvbi5wcm90b3R5cGUgKTtcbiAgTW9kaWZ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1vZGlmeTtcblxuICAvKipcbiAgICogQHBhcmFtIHtGZWF0dXJlfSBmZWF0dXJlIEZlYXR1cmUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBNb2RpZnkucHJvdG90eXBlLmFkZEZlYXR1cmVfID0gZnVuY3Rpb24gYWRkRmVhdHVyZV8gKGZlYXR1cmUpIHtcbiAgICB2YXIgZ2VvbWV0cnkgPSBmZWF0dXJlLmdldEdlb21ldHJ5KCk7XG4gICAgaWYgKGdlb21ldHJ5ICYmIGdlb21ldHJ5LmdldFR5cGUoKSBpbiB0aGlzLlNFR01FTlRfV1JJVEVSU18pIHtcbiAgICAgIHRoaXMuU0VHTUVOVF9XUklURVJTX1tnZW9tZXRyeS5nZXRUeXBlKCldLmNhbGwodGhpcywgZmVhdHVyZSwgZ2VvbWV0cnkpO1xuICAgIH1cbiAgICB2YXIgbWFwID0gdGhpcy5nZXRNYXAoKTtcbiAgICBpZiAobWFwICYmIG1hcC5pc1JlbmRlcmVkKCkgJiYgdGhpcy5nZXRBY3RpdmUoKSkge1xuICAgICAgdGhpcy5oYW5kbGVQb2ludGVyQXRQaXhlbF8odGhpcy5sYXN0UGl4ZWxfLCBtYXApO1xuICAgIH1cbiAgICBsaXN0ZW4oZmVhdHVyZSwgRXZlbnRUeXBlLkNIQU5HRSxcbiAgICAgIHRoaXMuaGFuZGxlRmVhdHVyZUNoYW5nZV8sIHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJQb2ludGVyRXZlbnQuanNcIikuZGVmYXVsdH0gZXZ0IE1hcCBicm93c2VyIGV2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBNb2RpZnkucHJvdG90eXBlLndpbGxNb2RpZnlGZWF0dXJlc18gPSBmdW5jdGlvbiB3aWxsTW9kaWZ5RmVhdHVyZXNfIChldnQpIHtcbiAgICBpZiAoIXRoaXMubW9kaWZpZWRfKSB7XG4gICAgICB0aGlzLm1vZGlmaWVkXyA9IHRydWU7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IE1vZGlmeUV2ZW50KFxuICAgICAgICBNb2RpZnlFdmVudFR5cGUuTU9ESUZZU1RBUlQsIHRoaXMuZmVhdHVyZXNfLCBldnQpKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTW9kaWZ5LnByb3RvdHlwZS5yZW1vdmVGZWF0dXJlXyA9IGZ1bmN0aW9uIHJlbW92ZUZlYXR1cmVfIChmZWF0dXJlKSB7XG4gICAgdGhpcy5yZW1vdmVGZWF0dXJlU2VnbWVudERhdGFfKGZlYXR1cmUpO1xuICAgIC8vIFJlbW92ZSB0aGUgdmVydGV4IGZlYXR1cmUgaWYgdGhlIGNvbGxlY3Rpb24gb2YgY2FuZGl0YXRlIGZlYXR1cmVzXG4gICAgLy8gaXMgZW1wdHkuXG4gICAgaWYgKHRoaXMudmVydGV4RmVhdHVyZV8gJiYgdGhpcy5mZWF0dXJlc18uZ2V0TGVuZ3RoKCkgPT09IDApIHtcbiAgICAgIC8qKiBAdHlwZSB7VmVjdG9yU291cmNlfSAqLyAodGhpcy5vdmVybGF5Xy5nZXRTb3VyY2UoKSkucmVtb3ZlRmVhdHVyZSh0aGlzLnZlcnRleEZlYXR1cmVfKTtcbiAgICAgIHRoaXMudmVydGV4RmVhdHVyZV8gPSBudWxsO1xuICAgIH1cbiAgICB1bmxpc3RlbihmZWF0dXJlLCBFdmVudFR5cGUuQ0hBTkdFLFxuICAgICAgdGhpcy5oYW5kbGVGZWF0dXJlQ2hhbmdlXywgdGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTW9kaWZ5LnByb3RvdHlwZS5yZW1vdmVGZWF0dXJlU2VnbWVudERhdGFfID0gZnVuY3Rpb24gcmVtb3ZlRmVhdHVyZVNlZ21lbnREYXRhXyAoZmVhdHVyZSkge1xuICAgIHZhciByQnVzaCA9IHRoaXMuckJ1c2hfO1xuICAgIHZhciAvKiogQHR5cGUge0FycmF5PFNlZ21lbnREYXRhPn0gKi8gbm9kZXNUb1JlbW92ZSA9IFtdO1xuICAgIHJCdXNoLmZvckVhY2goXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7U2VnbWVudERhdGF9IG5vZGUgUlRyZWUgbm9kZS5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBpZiAoZmVhdHVyZSA9PT0gbm9kZS5mZWF0dXJlKSB7XG4gICAgICAgICAgbm9kZXNUb1JlbW92ZS5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICBmb3IgKHZhciBpID0gbm9kZXNUb1JlbW92ZS5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgckJ1c2gucmVtb3ZlKG5vZGVzVG9SZW1vdmVbaV0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIE1vZGlmeS5wcm90b3R5cGUuc2V0QWN0aXZlID0gZnVuY3Rpb24gc2V0QWN0aXZlIChhY3RpdmUpIHtcbiAgICBpZiAodGhpcy52ZXJ0ZXhGZWF0dXJlXyAmJiAhYWN0aXZlKSB7XG4gICAgICAvKiogQHR5cGUge1ZlY3RvclNvdXJjZX0gKi8gKHRoaXMub3ZlcmxheV8uZ2V0U291cmNlKCkpLnJlbW92ZUZlYXR1cmUodGhpcy52ZXJ0ZXhGZWF0dXJlXyk7XG4gICAgICB0aGlzLnZlcnRleEZlYXR1cmVfID0gbnVsbDtcbiAgICB9XG4gICAgUG9pbnRlckludGVyYWN0aW9uLnByb3RvdHlwZS5zZXRBY3RpdmUuY2FsbCh0aGlzLCBhY3RpdmUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgTW9kaWZ5LnByb3RvdHlwZS5zZXRNYXAgPSBmdW5jdGlvbiBzZXRNYXAgKG1hcCkge1xuICAgIHRoaXMub3ZlcmxheV8uc2V0TWFwKG1hcCk7XG4gICAgUG9pbnRlckludGVyYWN0aW9uLnByb3RvdHlwZS5zZXRNYXAuY2FsbCh0aGlzLCBtYXApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG92ZXJsYXkgbGF5ZXIgdGhhdCB0aGlzIGludGVyYWN0aW9uIHJlbmRlcnMgc2tldGNoIGZlYXR1cmVzIHRvLlxuICAgKiBAcmV0dXJuIHtWZWN0b3JMYXllcn0gT3ZlcmxheSBsYXllci5cbiAgICogQGFwaVxuICAgKi9cbiAgTW9kaWZ5LnByb3RvdHlwZS5nZXRPdmVybGF5ID0gZnVuY3Rpb24gZ2V0T3ZlcmxheSAoKSB7XG4gICAgcmV0dXJuIHRoaXMub3ZlcmxheV87XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc291cmNlL1ZlY3Rvci5qc1wiKS5WZWN0b3JTb3VyY2VFdmVudH0gZXZlbnQgRXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBNb2RpZnkucHJvdG90eXBlLmhhbmRsZVNvdXJjZUFkZF8gPSBmdW5jdGlvbiBoYW5kbGVTb3VyY2VBZGRfIChldmVudCkge1xuICAgIGlmIChldmVudC5mZWF0dXJlKSB7XG4gICAgICB0aGlzLmZlYXR1cmVzXy5wdXNoKGV2ZW50LmZlYXR1cmUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zb3VyY2UvVmVjdG9yLmpzXCIpLlZlY3RvclNvdXJjZUV2ZW50fSBldmVudCBFdmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIE1vZGlmeS5wcm90b3R5cGUuaGFuZGxlU291cmNlUmVtb3ZlXyA9IGZ1bmN0aW9uIGhhbmRsZVNvdXJjZVJlbW92ZV8gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmZlYXR1cmUpIHtcbiAgICAgIHRoaXMuZmVhdHVyZXNfLnJlbW92ZShldmVudC5mZWF0dXJlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vQ29sbGVjdGlvbi5qc1wiKS5Db2xsZWN0aW9uRXZlbnR9IGV2dCBFdmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIE1vZGlmeS5wcm90b3R5cGUuaGFuZGxlRmVhdHVyZUFkZF8gPSBmdW5jdGlvbiBoYW5kbGVGZWF0dXJlQWRkXyAoZXZ0KSB7XG4gICAgdGhpcy5hZGRGZWF0dXJlXygvKiogQHR5cGUge0ZlYXR1cmV9ICovIChldnQuZWxlbWVudCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0fSBldnQgRXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBNb2RpZnkucHJvdG90eXBlLmhhbmRsZUZlYXR1cmVDaGFuZ2VfID0gZnVuY3Rpb24gaGFuZGxlRmVhdHVyZUNoYW5nZV8gKGV2dCkge1xuICAgIGlmICghdGhpcy5jaGFuZ2luZ0ZlYXR1cmVfKSB7XG4gICAgICB2YXIgZmVhdHVyZSA9IC8qKiBAdHlwZSB7RmVhdHVyZX0gKi8gKGV2dC50YXJnZXQpO1xuICAgICAgdGhpcy5yZW1vdmVGZWF0dXJlXyhmZWF0dXJlKTtcbiAgICAgIHRoaXMuYWRkRmVhdHVyZV8oZmVhdHVyZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0NvbGxlY3Rpb24uanNcIikuQ29sbGVjdGlvbkV2ZW50fSBldnQgRXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBNb2RpZnkucHJvdG90eXBlLmhhbmRsZUZlYXR1cmVSZW1vdmVfID0gZnVuY3Rpb24gaGFuZGxlRmVhdHVyZVJlbW92ZV8gKGV2dCkge1xuICAgIHZhciBmZWF0dXJlID0gLyoqIEB0eXBlIHtGZWF0dXJlfSAqLyAoZXZ0LmVsZW1lbnQpO1xuICAgIHRoaXMucmVtb3ZlRmVhdHVyZV8oZmVhdHVyZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlXG4gICAqIEBwYXJhbSB7UG9pbnR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTW9kaWZ5LnByb3RvdHlwZS53cml0ZVBvaW50R2VvbWV0cnlfID0gZnVuY3Rpb24gd3JpdGVQb2ludEdlb21ldHJ5XyAoZmVhdHVyZSwgZ2VvbWV0cnkpIHtcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRDb29yZGluYXRlcygpO1xuICAgIHZhciBzZWdtZW50RGF0YSA9IC8qKiBAdHlwZSB7U2VnbWVudERhdGF9ICovICh7XG4gICAgICBmZWF0dXJlOiBmZWF0dXJlLFxuICAgICAgZ2VvbWV0cnk6IGdlb21ldHJ5LFxuICAgICAgc2VnbWVudDogW2Nvb3JkaW5hdGVzLCBjb29yZGluYXRlc11cbiAgICB9KTtcbiAgICB0aGlzLnJCdXNoXy5pbnNlcnQoZ2VvbWV0cnkuZ2V0RXh0ZW50KCksIHNlZ21lbnREYXRhKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtGZWF0dXJlfSBmZWF0dXJlIEZlYXR1cmVcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL011bHRpUG9pbnQuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBNb2RpZnkucHJvdG90eXBlLndyaXRlTXVsdGlQb2ludEdlb21ldHJ5XyA9IGZ1bmN0aW9uIHdyaXRlTXVsdGlQb2ludEdlb21ldHJ5XyAoZmVhdHVyZSwgZ2VvbWV0cnkpIHtcbiAgICB2YXIgcG9pbnRzID0gZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgdmFyIGNvb3JkaW5hdGVzID0gcG9pbnRzW2ldO1xuICAgICAgdmFyIHNlZ21lbnREYXRhID0gLyoqIEB0eXBlIHtTZWdtZW50RGF0YX0gKi8gKHtcbiAgICAgICAgZmVhdHVyZTogZmVhdHVyZSxcbiAgICAgICAgZ2VvbWV0cnk6IGdlb21ldHJ5LFxuICAgICAgICBkZXB0aDogW2ldLFxuICAgICAgICBpbmRleDogaSxcbiAgICAgICAgc2VnbWVudDogW2Nvb3JkaW5hdGVzLCBjb29yZGluYXRlc11cbiAgICAgIH0pO1xuICAgICAgdGhpcy5yQnVzaF8uaW5zZXJ0KGdlb21ldHJ5LmdldEV4dGVudCgpLCBzZWdtZW50RGF0YSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0ZlYXR1cmV9IGZlYXR1cmUgRmVhdHVyZVxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vTGluZVN0cmluZy5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIE1vZGlmeS5wcm90b3R5cGUud3JpdGVMaW5lU3RyaW5nR2VvbWV0cnlfID0gZnVuY3Rpb24gd3JpdGVMaW5lU3RyaW5nR2VvbWV0cnlfIChmZWF0dXJlLCBnZW9tZXRyeSkge1xuICAgIHZhciBjb29yZGluYXRlcyA9IGdlb21ldHJ5LmdldENvb3JkaW5hdGVzKCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoIC0gMTsgaSA8IGlpOyArK2kpIHtcbiAgICAgIHZhciBzZWdtZW50ID0gY29vcmRpbmF0ZXMuc2xpY2UoaSwgaSArIDIpO1xuICAgICAgdmFyIHNlZ21lbnREYXRhID0gLyoqIEB0eXBlIHtTZWdtZW50RGF0YX0gKi8gKHtcbiAgICAgICAgZmVhdHVyZTogZmVhdHVyZSxcbiAgICAgICAgZ2VvbWV0cnk6IGdlb21ldHJ5LFxuICAgICAgICBpbmRleDogaSxcbiAgICAgICAgc2VnbWVudDogc2VnbWVudFxuICAgICAgfSk7XG4gICAgICB0aGlzLnJCdXNoXy5pbnNlcnQoYm91bmRpbmdFeHRlbnQoc2VnbWVudCksIHNlZ21lbnREYXRhKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9NdWx0aUxpbmVTdHJpbmcuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBNb2RpZnkucHJvdG90eXBlLndyaXRlTXVsdGlMaW5lU3RyaW5nR2VvbWV0cnlfID0gZnVuY3Rpb24gd3JpdGVNdWx0aUxpbmVTdHJpbmdHZW9tZXRyeV8gKGZlYXR1cmUsIGdlb21ldHJ5KSB7XG4gICAgdmFyIGxpbmVzID0gZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICBmb3IgKHZhciBqID0gMCwgamogPSBsaW5lcy5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgICB2YXIgY29vcmRpbmF0ZXMgPSBsaW5lc1tqXTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aCAtIDE7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIHZhciBzZWdtZW50ID0gY29vcmRpbmF0ZXMuc2xpY2UoaSwgaSArIDIpO1xuICAgICAgICB2YXIgc2VnbWVudERhdGEgPSAvKiogQHR5cGUge1NlZ21lbnREYXRhfSAqLyAoe1xuICAgICAgICAgIGZlYXR1cmU6IGZlYXR1cmUsXG4gICAgICAgICAgZ2VvbWV0cnk6IGdlb21ldHJ5LFxuICAgICAgICAgIGRlcHRoOiBbal0sXG4gICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgc2VnbWVudDogc2VnbWVudFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yQnVzaF8uaW5zZXJ0KGJvdW5kaW5nRXh0ZW50KHNlZ21lbnQpLCBzZWdtZW50RGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0ZlYXR1cmV9IGZlYXR1cmUgRmVhdHVyZVxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vUG9seWdvbi5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIE1vZGlmeS5wcm90b3R5cGUud3JpdGVQb2x5Z29uR2VvbWV0cnlfID0gZnVuY3Rpb24gd3JpdGVQb2x5Z29uR2VvbWV0cnlfIChmZWF0dXJlLCBnZW9tZXRyeSkge1xuICAgIHZhciByaW5ncyA9IGdlb21ldHJ5LmdldENvb3JkaW5hdGVzKCk7XG4gICAgZm9yICh2YXIgaiA9IDAsIGpqID0gcmluZ3MubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgdmFyIGNvb3JkaW5hdGVzID0gcmluZ3Nbal07XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBjb29yZGluYXRlcy5sZW5ndGggLSAxOyBpIDwgaWk7ICsraSkge1xuICAgICAgICB2YXIgc2VnbWVudCA9IGNvb3JkaW5hdGVzLnNsaWNlKGksIGkgKyAyKTtcbiAgICAgICAgdmFyIHNlZ21lbnREYXRhID0gLyoqIEB0eXBlIHtTZWdtZW50RGF0YX0gKi8gKHtcbiAgICAgICAgICBmZWF0dXJlOiBmZWF0dXJlLFxuICAgICAgICAgIGdlb21ldHJ5OiBnZW9tZXRyeSxcbiAgICAgICAgICBkZXB0aDogW2pdLFxuICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgIHNlZ21lbnQ6IHNlZ21lbnRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuckJ1c2hfLmluc2VydChib3VuZGluZ0V4dGVudChzZWdtZW50KSwgc2VnbWVudERhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtGZWF0dXJlfSBmZWF0dXJlIEZlYXR1cmVcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL011bHRpUG9seWdvbi5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIE1vZGlmeS5wcm90b3R5cGUud3JpdGVNdWx0aVBvbHlnb25HZW9tZXRyeV8gPSBmdW5jdGlvbiB3cml0ZU11bHRpUG9seWdvbkdlb21ldHJ5XyAoZmVhdHVyZSwgZ2VvbWV0cnkpIHtcbiAgICB2YXIgcG9seWdvbnMgPSBnZW9tZXRyeS5nZXRDb29yZGluYXRlcygpO1xuICAgIGZvciAodmFyIGsgPSAwLCBrayA9IHBvbHlnb25zLmxlbmd0aDsgayA8IGtrOyArK2spIHtcbiAgICAgIHZhciByaW5ncyA9IHBvbHlnb25zW2tdO1xuICAgICAgZm9yICh2YXIgaiA9IDAsIGpqID0gcmluZ3MubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSByaW5nc1tqXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoIC0gMTsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICB2YXIgc2VnbWVudCA9IGNvb3JkaW5hdGVzLnNsaWNlKGksIGkgKyAyKTtcbiAgICAgICAgICB2YXIgc2VnbWVudERhdGEgPSAvKiogQHR5cGUge1NlZ21lbnREYXRhfSAqLyAoe1xuICAgICAgICAgICAgZmVhdHVyZTogZmVhdHVyZSxcbiAgICAgICAgICAgIGdlb21ldHJ5OiBnZW9tZXRyeSxcbiAgICAgICAgICAgIGRlcHRoOiBbaiwga10sXG4gICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgIHNlZ21lbnQ6IHNlZ21lbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnJCdXNoXy5pbnNlcnQoYm91bmRpbmdFeHRlbnQoc2VnbWVudCksIHNlZ21lbnREYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogV2UgY29udmVydCBhIGNpcmNsZSBpbnRvIHR3byBzZWdtZW50cy4gIFRoZSBzZWdtZW50IGF0IGluZGV4XG4gICAqIHtAbGluayBDSVJDTEVfQ0VOVEVSX0lOREVYfSBpcyB0aGVcbiAgICogY2lyY2xlJ3MgY2VudGVyIChhIHBvaW50KS4gIFRoZSBzZWdtZW50IGF0IGluZGV4XG4gICAqIHtAbGluayBDSVJDTEVfQ0lSQ1VNRkVSRU5DRV9JTkRFWH0gaXNcbiAgICogdGhlIGNpcmN1bWZlcmVuY2UsIGFuZCBpcyBub3QgYSBsaW5lIHNlZ21lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7RmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vQ2lyY2xlLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTW9kaWZ5LnByb3RvdHlwZS53cml0ZUNpcmNsZUdlb21ldHJ5XyA9IGZ1bmN0aW9uIHdyaXRlQ2lyY2xlR2VvbWV0cnlfIChmZWF0dXJlLCBnZW9tZXRyeSkge1xuICAgIHZhciBjb29yZGluYXRlcyA9IGdlb21ldHJ5LmdldENlbnRlcigpO1xuICAgIHZhciBjZW50ZXJTZWdtZW50RGF0YSA9IC8qKiBAdHlwZSB7U2VnbWVudERhdGF9ICovICh7XG4gICAgICBmZWF0dXJlOiBmZWF0dXJlLFxuICAgICAgZ2VvbWV0cnk6IGdlb21ldHJ5LFxuICAgICAgaW5kZXg6IENJUkNMRV9DRU5URVJfSU5ERVgsXG4gICAgICBzZWdtZW50OiBbY29vcmRpbmF0ZXMsIGNvb3JkaW5hdGVzXVxuICAgIH0pO1xuICAgIHZhciBjaXJjdW1mZXJlbmNlU2VnbWVudERhdGEgPSAvKiogQHR5cGUge1NlZ21lbnREYXRhfSAqLyAoe1xuICAgICAgZmVhdHVyZTogZmVhdHVyZSxcbiAgICAgIGdlb21ldHJ5OiBnZW9tZXRyeSxcbiAgICAgIGluZGV4OiBDSVJDTEVfQ0lSQ1VNRkVSRU5DRV9JTkRFWCxcbiAgICAgIHNlZ21lbnQ6IFtjb29yZGluYXRlcywgY29vcmRpbmF0ZXNdXG4gICAgfSk7XG4gICAgdmFyIGZlYXR1cmVTZWdtZW50cyA9IFtjZW50ZXJTZWdtZW50RGF0YSwgY2lyY3VtZmVyZW5jZVNlZ21lbnREYXRhXTtcbiAgICBjZW50ZXJTZWdtZW50RGF0YS5mZWF0dXJlU2VnbWVudHMgPSBjaXJjdW1mZXJlbmNlU2VnbWVudERhdGEuZmVhdHVyZVNlZ21lbnRzID0gZmVhdHVyZVNlZ21lbnRzO1xuICAgIHRoaXMuckJ1c2hfLmluc2VydChjcmVhdGVPclVwZGF0ZUZyb21Db29yZGluYXRlKGNvb3JkaW5hdGVzKSwgY2VudGVyU2VnbWVudERhdGEpO1xuICAgIHRoaXMuckJ1c2hfLmluc2VydChnZW9tZXRyeS5nZXRFeHRlbnQoKSwgY2lyY3VtZmVyZW5jZVNlZ21lbnREYXRhKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtGZWF0dXJlfSBmZWF0dXJlIEZlYXR1cmVcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5Q29sbGVjdGlvbi5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIE1vZGlmeS5wcm90b3R5cGUud3JpdGVHZW9tZXRyeUNvbGxlY3Rpb25HZW9tZXRyeV8gPSBmdW5jdGlvbiB3cml0ZUdlb21ldHJ5Q29sbGVjdGlvbkdlb21ldHJ5XyAoZmVhdHVyZSwgZ2VvbWV0cnkpIHtcbiAgICB2YXIgZ2VvbWV0cmllcyA9IGdlb21ldHJ5LmdldEdlb21ldHJpZXNBcnJheSgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbWV0cmllcy5sZW5ndGg7ICsraSkge1xuICAgICAgdGhpcy5TRUdNRU5UX1dSSVRFUlNfW2dlb21ldHJpZXNbaV0uZ2V0VHlwZSgpXS5jYWxsKHRoaXMsIGZlYXR1cmUsIGdlb21ldHJpZXNbaV0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGVzIENvb3JkaW5hdGVzLlxuICAgKiBAcmV0dXJuIHtGZWF0dXJlfSBWZXJ0ZXggZmVhdHVyZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIE1vZGlmeS5wcm90b3R5cGUuY3JlYXRlT3JVcGRhdGVWZXJ0ZXhGZWF0dXJlXyA9IGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlVmVydGV4RmVhdHVyZV8gKGNvb3JkaW5hdGVzKSB7XG4gICAgdmFyIHZlcnRleEZlYXR1cmUgPSB0aGlzLnZlcnRleEZlYXR1cmVfO1xuICAgIGlmICghdmVydGV4RmVhdHVyZSkge1xuICAgICAgdmVydGV4RmVhdHVyZSA9IG5ldyBGZWF0dXJlKG5ldyBQb2ludChjb29yZGluYXRlcykpO1xuICAgICAgdGhpcy52ZXJ0ZXhGZWF0dXJlXyA9IHZlcnRleEZlYXR1cmU7XG4gICAgICAvKiogQHR5cGUge1ZlY3RvclNvdXJjZX0gKi8gKHRoaXMub3ZlcmxheV8uZ2V0U291cmNlKCkpLmFkZEZlYXR1cmUodmVydGV4RmVhdHVyZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBnZW9tZXRyeSA9IC8qKiBAdHlwZSB7UG9pbnR9ICovICh2ZXJ0ZXhGZWF0dXJlLmdldEdlb21ldHJ5KCkpO1xuICAgICAgZ2VvbWV0cnkuc2V0Q29vcmRpbmF0ZXMoY29vcmRpbmF0ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gdmVydGV4RmVhdHVyZTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnQgbWFwIGJyb3dzZXIgZXZlbnR9IGFuZCBtYXkgbW9kaWZ5IHRoZSBnZW9tZXRyeS5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBNb2RpZnkucHJvdG90eXBlLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24gaGFuZGxlRXZlbnQgKG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGlmICghKC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlclBvaW50ZXJFdmVudC5qc1wiKS5kZWZhdWx0fSAqLyAobWFwQnJvd3NlckV2ZW50KS5wb2ludGVyRXZlbnQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5sYXN0UG9pbnRlckV2ZW50XyA9IG1hcEJyb3dzZXJFdmVudDtcblxuICAgIHZhciBoYW5kbGVkO1xuICAgIGlmICghbWFwQnJvd3NlckV2ZW50Lm1hcC5nZXRWaWV3KCkuZ2V0SW50ZXJhY3RpbmcoKSAmJlxuICAgICAgICBtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJNT1ZFICYmXG4gICAgICAgICF0aGlzLmhhbmRsaW5nRG93blVwU2VxdWVuY2UpIHtcbiAgICAgIHRoaXMuaGFuZGxlUG9pbnRlck1vdmVfKG1hcEJyb3dzZXJFdmVudCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnZlcnRleEZlYXR1cmVfICYmIHRoaXMuZGVsZXRlQ29uZGl0aW9uXyhtYXBCcm93c2VyRXZlbnQpKSB7XG4gICAgICBpZiAobWFwQnJvd3NlckV2ZW50LnR5cGUgIT0gTWFwQnJvd3NlckV2ZW50VHlwZS5TSU5HTEVDTElDSyB8fCAhdGhpcy5pZ25vcmVOZXh0U2luZ2xlQ2xpY2tfKSB7XG4gICAgICAgIGhhbmRsZWQgPSB0aGlzLnJlbW92ZVBvaW50KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWFwQnJvd3NlckV2ZW50LnR5cGUgPT0gTWFwQnJvd3NlckV2ZW50VHlwZS5TSU5HTEVDTElDSykge1xuICAgICAgdGhpcy5pZ25vcmVOZXh0U2luZ2xlQ2xpY2tfID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIFBvaW50ZXJJbnRlcmFjdGlvbi5wcm90b3R5cGUuaGFuZGxlRXZlbnQuY2FsbCh0aGlzLCBtYXBCcm93c2VyRXZlbnQpICYmICFoYW5kbGVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgTW9kaWZ5LnByb3RvdHlwZS5oYW5kbGVEcmFnRXZlbnQgPSBmdW5jdGlvbiBoYW5kbGVEcmFnRXZlbnQgKGV2dCkge1xuICAgIHRoaXMuaWdub3JlTmV4dFNpbmdsZUNsaWNrXyA9IGZhbHNlO1xuICAgIHRoaXMud2lsbE1vZGlmeUZlYXR1cmVzXyhldnQpO1xuXG4gICAgdmFyIHZlcnRleCA9IGV2dC5jb29yZGluYXRlO1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHRoaXMuZHJhZ1NlZ21lbnRzXy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB2YXIgZHJhZ1NlZ21lbnQgPSB0aGlzLmRyYWdTZWdtZW50c19baV07XG4gICAgICB2YXIgc2VnbWVudERhdGEgPSBkcmFnU2VnbWVudFswXTtcbiAgICAgIHZhciBkZXB0aCA9IHNlZ21lbnREYXRhLmRlcHRoO1xuICAgICAgdmFyIGdlb21ldHJ5ID0gc2VnbWVudERhdGEuZ2VvbWV0cnk7XG4gICAgICB2YXIgY29vcmRpbmF0ZXMgPSAodm9pZCAwKTtcbiAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudERhdGEuc2VnbWVudDtcbiAgICAgIHZhciBpbmRleCA9IGRyYWdTZWdtZW50WzFdO1xuXG4gICAgICB3aGlsZSAodmVydGV4Lmxlbmd0aCA8IGdlb21ldHJ5LmdldFN0cmlkZSgpKSB7XG4gICAgICAgIHZlcnRleC5wdXNoKHNlZ21lbnRbaW5kZXhdW3ZlcnRleC5sZW5ndGhdKTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChnZW9tZXRyeS5nZXRUeXBlKCkpIHtcbiAgICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuUE9JTlQ6XG4gICAgICAgICAgY29vcmRpbmF0ZXMgPSB2ZXJ0ZXg7XG4gICAgICAgICAgc2VnbWVudFswXSA9IHNlZ21lbnRbMV0gPSB2ZXJ0ZXg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR2VvbWV0cnlUeXBlLk1VTFRJX1BPSU5UOlxuICAgICAgICAgIGNvb3JkaW5hdGVzID0gZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgICAgICBjb29yZGluYXRlc1tzZWdtZW50RGF0YS5pbmRleF0gPSB2ZXJ0ZXg7XG4gICAgICAgICAgc2VnbWVudFswXSA9IHNlZ21lbnRbMV0gPSB2ZXJ0ZXg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR2VvbWV0cnlUeXBlLkxJTkVfU1RSSU5HOlxuICAgICAgICAgIGNvb3JkaW5hdGVzID0gZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgICAgICBjb29yZGluYXRlc1tzZWdtZW50RGF0YS5pbmRleCArIGluZGV4XSA9IHZlcnRleDtcbiAgICAgICAgICBzZWdtZW50W2luZGV4XSA9IHZlcnRleDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuTVVMVElfTElORV9TVFJJTkc6XG4gICAgICAgICAgY29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgICAgIGNvb3JkaW5hdGVzW2RlcHRoWzBdXVtzZWdtZW50RGF0YS5pbmRleCArIGluZGV4XSA9IHZlcnRleDtcbiAgICAgICAgICBzZWdtZW50W2luZGV4XSA9IHZlcnRleDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuUE9MWUdPTjpcbiAgICAgICAgICBjb29yZGluYXRlcyA9IGdlb21ldHJ5LmdldENvb3JkaW5hdGVzKCk7XG4gICAgICAgICAgY29vcmRpbmF0ZXNbZGVwdGhbMF1dW3NlZ21lbnREYXRhLmluZGV4ICsgaW5kZXhdID0gdmVydGV4O1xuICAgICAgICAgIHNlZ21lbnRbaW5kZXhdID0gdmVydGV4O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdlb21ldHJ5VHlwZS5NVUxUSV9QT0xZR09OOlxuICAgICAgICAgIGNvb3JkaW5hdGVzID0gZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgICAgICBjb29yZGluYXRlc1tkZXB0aFsxXV1bZGVwdGhbMF1dW3NlZ21lbnREYXRhLmluZGV4ICsgaW5kZXhdID0gdmVydGV4O1xuICAgICAgICAgIHNlZ21lbnRbaW5kZXhdID0gdmVydGV4O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdlb21ldHJ5VHlwZS5DSVJDTEU6XG4gICAgICAgICAgc2VnbWVudFswXSA9IHNlZ21lbnRbMV0gPSB2ZXJ0ZXg7XG4gICAgICAgICAgaWYgKHNlZ21lbnREYXRhLmluZGV4ID09PSBDSVJDTEVfQ0VOVEVSX0lOREVYKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5naW5nRmVhdHVyZV8gPSB0cnVlO1xuICAgICAgICAgICAgZ2VvbWV0cnkuc2V0Q2VudGVyKHZlcnRleCk7XG4gICAgICAgICAgICB0aGlzLmNoYW5naW5nRmVhdHVyZV8gPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2UgeyAvLyBXZSdyZSBkcmFnZ2luZyB0aGUgY2lyY2xlJ3MgY2lyY3VtZmVyZW5jZTpcbiAgICAgICAgICAgIHRoaXMuY2hhbmdpbmdGZWF0dXJlXyA9IHRydWU7XG4gICAgICAgICAgICBnZW9tZXRyeS5zZXRSYWRpdXMoY29vcmRpbmF0ZURpc3RhbmNlKGdlb21ldHJ5LmdldENlbnRlcigpLCB2ZXJ0ZXgpKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdpbmdGZWF0dXJlXyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBwYXNzXG4gICAgICB9XG5cbiAgICAgIGlmIChjb29yZGluYXRlcykge1xuICAgICAgICB0aGlzLnNldEdlb21ldHJ5Q29vcmRpbmF0ZXNfKGdlb21ldHJ5LCBjb29yZGluYXRlcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY3JlYXRlT3JVcGRhdGVWZXJ0ZXhGZWF0dXJlXyh2ZXJ0ZXgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgTW9kaWZ5LnByb3RvdHlwZS5oYW5kbGVEb3duRXZlbnQgPSBmdW5jdGlvbiBoYW5kbGVEb3duRXZlbnQgKGV2dCkge1xuICAgIGlmICghdGhpcy5jb25kaXRpb25fKGV2dCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5oYW5kbGVQb2ludGVyQXRQaXhlbF8oZXZ0LnBpeGVsLCBldnQubWFwKTtcbiAgICB2YXIgcGl4ZWxDb29yZGluYXRlID0gZXZ0Lm1hcC5nZXRDb29yZGluYXRlRnJvbVBpeGVsKGV2dC5waXhlbCk7XG4gICAgdGhpcy5kcmFnU2VnbWVudHNfLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5tb2RpZmllZF8gPSBmYWxzZTtcbiAgICB2YXIgdmVydGV4RmVhdHVyZSA9IHRoaXMudmVydGV4RmVhdHVyZV87XG4gICAgaWYgKHZlcnRleEZlYXR1cmUpIHtcbiAgICAgIHZhciBpbnNlcnRWZXJ0aWNlcyA9IFtdO1xuICAgICAgdmFyIGdlb21ldHJ5ID0gLyoqIEB0eXBlIHtQb2ludH0gKi8gKHZlcnRleEZlYXR1cmUuZ2V0R2VvbWV0cnkoKSk7XG4gICAgICB2YXIgdmVydGV4ID0gZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIHZhciB2ZXJ0ZXhFeHRlbnQgPSBib3VuZGluZ0V4dGVudChbdmVydGV4XSk7XG4gICAgICB2YXIgc2VnbWVudERhdGFNYXRjaGVzID0gdGhpcy5yQnVzaF8uZ2V0SW5FeHRlbnQodmVydGV4RXh0ZW50KTtcbiAgICAgIHZhciBjb21wb25lbnRTZWdtZW50cyA9IHt9O1xuICAgICAgc2VnbWVudERhdGFNYXRjaGVzLnNvcnQoY29tcGFyZUluZGV4ZXMpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gc2VnbWVudERhdGFNYXRjaGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgdmFyIHNlZ21lbnREYXRhTWF0Y2ggPSBzZWdtZW50RGF0YU1hdGNoZXNbaV07XG4gICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudERhdGFNYXRjaC5zZWdtZW50O1xuICAgICAgICB2YXIgdWlkID0gZ2V0VWlkKHNlZ21lbnREYXRhTWF0Y2guZmVhdHVyZSk7XG4gICAgICAgIHZhciBkZXB0aCA9IHNlZ21lbnREYXRhTWF0Y2guZGVwdGg7XG4gICAgICAgIGlmIChkZXB0aCkge1xuICAgICAgICAgIHVpZCArPSAnLScgKyBkZXB0aC5qb2luKCctJyk7IC8vIHNlcGFyYXRlIGZlYXR1cmUgY29tcG9uZW50c1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29tcG9uZW50U2VnbWVudHNbdWlkXSkge1xuICAgICAgICAgIGNvbXBvbmVudFNlZ21lbnRzW3VpZF0gPSBuZXcgQXJyYXkoMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlZ21lbnREYXRhTWF0Y2guZ2VvbWV0cnkuZ2V0VHlwZSgpID09PSBHZW9tZXRyeVR5cGUuQ0lSQ0xFICYmXG4gICAgICAgIHNlZ21lbnREYXRhTWF0Y2guaW5kZXggPT09IENJUkNMRV9DSVJDVU1GRVJFTkNFX0lOREVYKSB7XG5cbiAgICAgICAgICB2YXIgY2xvc2VzdFZlcnRleCA9IGNsb3Nlc3RPblNlZ21lbnREYXRhKHBpeGVsQ29vcmRpbmF0ZSwgc2VnbWVudERhdGFNYXRjaCk7XG4gICAgICAgICAgaWYgKGNvb3JkaW5hdGVzRXF1YWwoY2xvc2VzdFZlcnRleCwgdmVydGV4KSAmJiAhY29tcG9uZW50U2VnbWVudHNbdWlkXVswXSkge1xuICAgICAgICAgICAgdGhpcy5kcmFnU2VnbWVudHNfLnB1c2goW3NlZ21lbnREYXRhTWF0Y2gsIDBdKTtcbiAgICAgICAgICAgIGNvbXBvbmVudFNlZ21lbnRzW3VpZF1bMF0gPSBzZWdtZW50RGF0YU1hdGNoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjb29yZGluYXRlc0VxdWFsKHNlZ21lbnRbMF0sIHZlcnRleCkgJiZcbiAgICAgICAgICAgICFjb21wb25lbnRTZWdtZW50c1t1aWRdWzBdKSB7XG4gICAgICAgICAgdGhpcy5kcmFnU2VnbWVudHNfLnB1c2goW3NlZ21lbnREYXRhTWF0Y2gsIDBdKTtcbiAgICAgICAgICBjb21wb25lbnRTZWdtZW50c1t1aWRdWzBdID0gc2VnbWVudERhdGFNYXRjaDtcbiAgICAgICAgfSBlbHNlIGlmIChjb29yZGluYXRlc0VxdWFsKHNlZ21lbnRbMV0sIHZlcnRleCkgJiZcbiAgICAgICAgICAgICFjb21wb25lbnRTZWdtZW50c1t1aWRdWzFdKSB7XG5cbiAgICAgICAgICAvLyBwcmV2ZW50IGRyYWdnaW5nIGNsb3NlZCBsaW5lc3RyaW5ncyBieSB0aGUgY29ubmVjdGluZyBub2RlXG4gICAgICAgICAgaWYgKChzZWdtZW50RGF0YU1hdGNoLmdlb21ldHJ5LmdldFR5cGUoKSA9PT1cbiAgICAgICAgICAgICAgR2VvbWV0cnlUeXBlLkxJTkVfU1RSSU5HIHx8XG4gICAgICAgICAgICAgIHNlZ21lbnREYXRhTWF0Y2guZ2VvbWV0cnkuZ2V0VHlwZSgpID09PVxuICAgICAgICAgICAgICBHZW9tZXRyeVR5cGUuTVVMVElfTElORV9TVFJJTkcpICYmXG4gICAgICAgICAgICAgIGNvbXBvbmVudFNlZ21lbnRzW3VpZF1bMF0gJiZcbiAgICAgICAgICAgICAgY29tcG9uZW50U2VnbWVudHNbdWlkXVswXS5pbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5kcmFnU2VnbWVudHNfLnB1c2goW3NlZ21lbnREYXRhTWF0Y2gsIDFdKTtcbiAgICAgICAgICBjb21wb25lbnRTZWdtZW50c1t1aWRdWzFdID0gc2VnbWVudERhdGFNYXRjaDtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmluc2VydFZlcnRleENvbmRpdGlvbl8oZXZ0KSAmJiBnZXRVaWQoc2VnbWVudCkgaW4gdGhpcy52ZXJ0ZXhTZWdtZW50c18gJiZcbiAgICAgICAgICAgICghY29tcG9uZW50U2VnbWVudHNbdWlkXVswXSAmJiAhY29tcG9uZW50U2VnbWVudHNbdWlkXVsxXSkpIHtcbiAgICAgICAgICBpbnNlcnRWZXJ0aWNlcy5wdXNoKFtzZWdtZW50RGF0YU1hdGNoLCB2ZXJ0ZXhdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGluc2VydFZlcnRpY2VzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLndpbGxNb2RpZnlGZWF0dXJlc18oZXZ0KTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGogPSBpbnNlcnRWZXJ0aWNlcy5sZW5ndGggLSAxOyBqID49IDA7IC0taikge1xuICAgICAgICB0aGlzLmluc2VydFZlcnRleF8uYXBwbHkodGhpcywgaW5zZXJ0VmVydGljZXNbal0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gISF0aGlzLnZlcnRleEZlYXR1cmVfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgTW9kaWZ5LnByb3RvdHlwZS5oYW5kbGVVcEV2ZW50ID0gZnVuY3Rpb24gaGFuZGxlVXBFdmVudCAoZXZ0KSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuZHJhZ1NlZ21lbnRzXy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdmFyIHNlZ21lbnREYXRhID0gdGhpcy5kcmFnU2VnbWVudHNfW2ldWzBdO1xuICAgICAgdmFyIGdlb21ldHJ5ID0gc2VnbWVudERhdGEuZ2VvbWV0cnk7XG4gICAgICBpZiAoZ2VvbWV0cnkuZ2V0VHlwZSgpID09PSBHZW9tZXRyeVR5cGUuQ0lSQ0xFKSB7XG4gICAgICAgIC8vIFVwZGF0ZSBhIGNpcmNsZSBvYmplY3QgaW4gdGhlIFIqIGJ1c2g6XG4gICAgICAgIHZhciBjb29yZGluYXRlcyA9IGdlb21ldHJ5LmdldENlbnRlcigpO1xuICAgICAgICB2YXIgY2VudGVyU2VnbWVudERhdGEgPSBzZWdtZW50RGF0YS5mZWF0dXJlU2VnbWVudHNbMF07XG4gICAgICAgIHZhciBjaXJjdW1mZXJlbmNlU2VnbWVudERhdGEgPSBzZWdtZW50RGF0YS5mZWF0dXJlU2VnbWVudHNbMV07XG4gICAgICAgIGNlbnRlclNlZ21lbnREYXRhLnNlZ21lbnRbMF0gPSBjZW50ZXJTZWdtZW50RGF0YS5zZWdtZW50WzFdID0gY29vcmRpbmF0ZXM7XG4gICAgICAgIGNpcmN1bWZlcmVuY2VTZWdtZW50RGF0YS5zZWdtZW50WzBdID0gY2lyY3VtZmVyZW5jZVNlZ21lbnREYXRhLnNlZ21lbnRbMV0gPSBjb29yZGluYXRlcztcbiAgICAgICAgdGhpcy5yQnVzaF8udXBkYXRlKGNyZWF0ZU9yVXBkYXRlRnJvbUNvb3JkaW5hdGUoY29vcmRpbmF0ZXMpLCBjZW50ZXJTZWdtZW50RGF0YSk7XG4gICAgICAgIHRoaXMuckJ1c2hfLnVwZGF0ZShnZW9tZXRyeS5nZXRFeHRlbnQoKSwgY2lyY3VtZmVyZW5jZVNlZ21lbnREYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuckJ1c2hfLnVwZGF0ZShib3VuZGluZ0V4dGVudChzZWdtZW50RGF0YS5zZWdtZW50KSwgc2VnbWVudERhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5tb2RpZmllZF8pIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgTW9kaWZ5RXZlbnQoTW9kaWZ5RXZlbnRUeXBlLk1PRElGWUVORCwgdGhpcy5mZWF0dXJlc18sIGV2dCkpO1xuICAgICAgdGhpcy5tb2RpZmllZF8gPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBldnQgRXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBNb2RpZnkucHJvdG90eXBlLmhhbmRsZVBvaW50ZXJNb3ZlXyA9IGZ1bmN0aW9uIGhhbmRsZVBvaW50ZXJNb3ZlXyAoZXZ0KSB7XG4gICAgdGhpcy5sYXN0UGl4ZWxfID0gZXZ0LnBpeGVsO1xuICAgIHRoaXMuaGFuZGxlUG9pbnRlckF0UGl4ZWxfKGV2dC5waXhlbCwgZXZ0Lm1hcCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcGl4ZWwuanNcIikuUGl4ZWx9IHBpeGVsIFBpeGVsXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLmRlZmF1bHR9IG1hcCBNYXAuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBNb2RpZnkucHJvdG90eXBlLmhhbmRsZVBvaW50ZXJBdFBpeGVsXyA9IGZ1bmN0aW9uIGhhbmRsZVBvaW50ZXJBdFBpeGVsXyAocGl4ZWwsIG1hcCkge1xuICAgIHZhciBwaXhlbENvb3JkaW5hdGUgPSBtYXAuZ2V0Q29vcmRpbmF0ZUZyb21QaXhlbChwaXhlbCk7XG4gICAgdmFyIHNvcnRCeURpc3RhbmNlID0gZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIHBvaW50RGlzdGFuY2VUb1NlZ21lbnREYXRhU3F1YXJlZChwaXhlbENvb3JkaW5hdGUsIGEpIC1cbiAgICAgICAgICBwb2ludERpc3RhbmNlVG9TZWdtZW50RGF0YVNxdWFyZWQocGl4ZWxDb29yZGluYXRlLCBiKTtcbiAgICB9O1xuXG4gICAgdmFyIGJveCA9IGJ1ZmZlcihjcmVhdGVPclVwZGF0ZUZyb21Db29yZGluYXRlKHBpeGVsQ29vcmRpbmF0ZSksXG4gICAgICBtYXAuZ2V0VmlldygpLmdldFJlc29sdXRpb24oKSAqIHRoaXMucGl4ZWxUb2xlcmFuY2VfKTtcblxuICAgIHZhciByQnVzaCA9IHRoaXMuckJ1c2hfO1xuICAgIHZhciBub2RlcyA9IHJCdXNoLmdldEluRXh0ZW50KGJveCk7XG4gICAgaWYgKG5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIG5vZGVzLnNvcnQoc29ydEJ5RGlzdGFuY2UpO1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1swXTtcbiAgICAgIHZhciBjbG9zZXN0U2VnbWVudCA9IG5vZGUuc2VnbWVudDtcbiAgICAgIHZhciB2ZXJ0ZXggPSBjbG9zZXN0T25TZWdtZW50RGF0YShwaXhlbENvb3JkaW5hdGUsIG5vZGUpO1xuICAgICAgdmFyIHZlcnRleFBpeGVsID0gbWFwLmdldFBpeGVsRnJvbUNvb3JkaW5hdGUodmVydGV4KTtcbiAgICAgIHZhciBkaXN0ID0gY29vcmRpbmF0ZURpc3RhbmNlKHBpeGVsLCB2ZXJ0ZXhQaXhlbCk7XG4gICAgICBpZiAoZGlzdCA8PSB0aGlzLnBpeGVsVG9sZXJhbmNlXykge1xuICAgICAgICAvKiogQHR5cGUge09iamVjdDxzdHJpbmcsIGJvb2xlYW4+fSAqL1xuICAgICAgICB2YXIgdmVydGV4U2VnbWVudHMgPSB7fTtcblxuICAgICAgICBpZiAobm9kZS5nZW9tZXRyeS5nZXRUeXBlKCkgPT09IEdlb21ldHJ5VHlwZS5DSVJDTEUgJiZcbiAgICAgICAgbm9kZS5pbmRleCA9PT0gQ0lSQ0xFX0NJUkNVTUZFUkVOQ0VfSU5ERVgpIHtcblxuICAgICAgICAgIHRoaXMuc25hcHBlZFRvVmVydGV4XyA9IHRydWU7XG4gICAgICAgICAgdGhpcy5jcmVhdGVPclVwZGF0ZVZlcnRleEZlYXR1cmVfKHZlcnRleCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHBpeGVsMSA9IG1hcC5nZXRQaXhlbEZyb21Db29yZGluYXRlKGNsb3Nlc3RTZWdtZW50WzBdKTtcbiAgICAgICAgICB2YXIgcGl4ZWwyID0gbWFwLmdldFBpeGVsRnJvbUNvb3JkaW5hdGUoY2xvc2VzdFNlZ21lbnRbMV0pO1xuICAgICAgICAgIHZhciBzcXVhcmVkRGlzdDEgPSBzcXVhcmVkQ29vcmRpbmF0ZURpc3RhbmNlKHZlcnRleFBpeGVsLCBwaXhlbDEpO1xuICAgICAgICAgIHZhciBzcXVhcmVkRGlzdDIgPSBzcXVhcmVkQ29vcmRpbmF0ZURpc3RhbmNlKHZlcnRleFBpeGVsLCBwaXhlbDIpO1xuICAgICAgICAgIGRpc3QgPSBNYXRoLnNxcnQoTWF0aC5taW4oc3F1YXJlZERpc3QxLCBzcXVhcmVkRGlzdDIpKTtcbiAgICAgICAgICB0aGlzLnNuYXBwZWRUb1ZlcnRleF8gPSBkaXN0IDw9IHRoaXMucGl4ZWxUb2xlcmFuY2VfO1xuICAgICAgICAgIGlmICh0aGlzLnNuYXBwZWRUb1ZlcnRleF8pIHtcbiAgICAgICAgICAgIHZlcnRleCA9IHNxdWFyZWREaXN0MSA+IHNxdWFyZWREaXN0MiA/IGNsb3Nlc3RTZWdtZW50WzFdIDogY2xvc2VzdFNlZ21lbnRbMF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuY3JlYXRlT3JVcGRhdGVWZXJ0ZXhGZWF0dXJlXyh2ZXJ0ZXgpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxLCBpaSA9IG5vZGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gbm9kZXNbaV0uc2VnbWVudDtcbiAgICAgICAgICAgIGlmICgoY29vcmRpbmF0ZXNFcXVhbChjbG9zZXN0U2VnbWVudFswXSwgc2VnbWVudFswXSkgJiZcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlc0VxdWFsKGNsb3Nlc3RTZWdtZW50WzFdLCBzZWdtZW50WzFdKSB8fFxuICAgICAgICAgICAgICAgIChjb29yZGluYXRlc0VxdWFsKGNsb3Nlc3RTZWdtZW50WzBdLCBzZWdtZW50WzFdKSAmJlxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzRXF1YWwoY2xvc2VzdFNlZ21lbnRbMV0sIHNlZ21lbnRbMF0pKSkpIHtcbiAgICAgICAgICAgICAgdmVydGV4U2VnbWVudHNbZ2V0VWlkKHNlZ21lbnQpXSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2ZXJ0ZXhTZWdtZW50c1tnZXRVaWQoY2xvc2VzdFNlZ21lbnQpXSA9IHRydWU7XG4gICAgICAgIHRoaXMudmVydGV4U2VnbWVudHNfID0gdmVydGV4U2VnbWVudHM7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMudmVydGV4RmVhdHVyZV8pIHtcbiAgICAgIC8qKiBAdHlwZSB7VmVjdG9yU291cmNlfSAqLyAodGhpcy5vdmVybGF5Xy5nZXRTb3VyY2UoKSkucmVtb3ZlRmVhdHVyZSh0aGlzLnZlcnRleEZlYXR1cmVfKTtcbiAgICAgIHRoaXMudmVydGV4RmVhdHVyZV8gPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtTZWdtZW50RGF0YX0gc2VnbWVudERhdGEgU2VnbWVudCBkYXRhLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gdmVydGV4IFZlcnRleC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIE1vZGlmeS5wcm90b3R5cGUuaW5zZXJ0VmVydGV4XyA9IGZ1bmN0aW9uIGluc2VydFZlcnRleF8gKHNlZ21lbnREYXRhLCB2ZXJ0ZXgpIHtcbiAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnREYXRhLnNlZ21lbnQ7XG4gICAgdmFyIGZlYXR1cmUgPSBzZWdtZW50RGF0YS5mZWF0dXJlO1xuICAgIHZhciBnZW9tZXRyeSA9IHNlZ21lbnREYXRhLmdlb21ldHJ5O1xuICAgIHZhciBkZXB0aCA9IHNlZ21lbnREYXRhLmRlcHRoO1xuICAgIHZhciBpbmRleCA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoc2VnbWVudERhdGEuaW5kZXgpO1xuICAgIHZhciBjb29yZGluYXRlcztcblxuICAgIHdoaWxlICh2ZXJ0ZXgubGVuZ3RoIDwgZ2VvbWV0cnkuZ2V0U3RyaWRlKCkpIHtcbiAgICAgIHZlcnRleC5wdXNoKDApO1xuICAgIH1cblxuICAgIHN3aXRjaCAoZ2VvbWV0cnkuZ2V0VHlwZSgpKSB7XG4gICAgICBjYXNlIEdlb21ldHJ5VHlwZS5NVUxUSV9MSU5FX1NUUklORzpcbiAgICAgICAgY29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgICBjb29yZGluYXRlc1tkZXB0aFswXV0uc3BsaWNlKGluZGV4ICsgMSwgMCwgdmVydGV4KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEdlb21ldHJ5VHlwZS5QT0xZR09OOlxuICAgICAgICBjb29yZGluYXRlcyA9IGdlb21ldHJ5LmdldENvb3JkaW5hdGVzKCk7XG4gICAgICAgIGNvb3JkaW5hdGVzW2RlcHRoWzBdXS5zcGxpY2UoaW5kZXggKyAxLCAwLCB2ZXJ0ZXgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgR2VvbWV0cnlUeXBlLk1VTFRJX1BPTFlHT046XG4gICAgICAgIGNvb3JkaW5hdGVzID0gZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgICAgY29vcmRpbmF0ZXNbZGVwdGhbMV1dW2RlcHRoWzBdXS5zcGxpY2UoaW5kZXggKyAxLCAwLCB2ZXJ0ZXgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgR2VvbWV0cnlUeXBlLkxJTkVfU1RSSU5HOlxuICAgICAgICBjb29yZGluYXRlcyA9IGdlb21ldHJ5LmdldENvb3JkaW5hdGVzKCk7XG4gICAgICAgIGNvb3JkaW5hdGVzLnNwbGljZShpbmRleCArIDEsIDAsIHZlcnRleCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc2V0R2VvbWV0cnlDb29yZGluYXRlc18oZ2VvbWV0cnksIGNvb3JkaW5hdGVzKTtcbiAgICB2YXIgclRyZWUgPSB0aGlzLnJCdXNoXztcbiAgICByVHJlZS5yZW1vdmUoc2VnbWVudERhdGEpO1xuICAgIHRoaXMudXBkYXRlU2VnbWVudEluZGljZXNfKGdlb21ldHJ5LCBpbmRleCwgZGVwdGgsIDEpO1xuICAgIHZhciBuZXdTZWdtZW50RGF0YSA9IC8qKiBAdHlwZSB7U2VnbWVudERhdGF9ICovICh7XG4gICAgICBzZWdtZW50OiBbc2VnbWVudFswXSwgdmVydGV4XSxcbiAgICAgIGZlYXR1cmU6IGZlYXR1cmUsXG4gICAgICBnZW9tZXRyeTogZ2VvbWV0cnksXG4gICAgICBkZXB0aDogZGVwdGgsXG4gICAgICBpbmRleDogaW5kZXhcbiAgICB9KTtcbiAgICByVHJlZS5pbnNlcnQoYm91bmRpbmdFeHRlbnQobmV3U2VnbWVudERhdGEuc2VnbWVudCksXG4gICAgICBuZXdTZWdtZW50RGF0YSk7XG4gICAgdGhpcy5kcmFnU2VnbWVudHNfLnB1c2goW25ld1NlZ21lbnREYXRhLCAxXSk7XG5cbiAgICB2YXIgbmV3U2VnbWVudERhdGEyID0gLyoqIEB0eXBlIHtTZWdtZW50RGF0YX0gKi8gKHtcbiAgICAgIHNlZ21lbnQ6IFt2ZXJ0ZXgsIHNlZ21lbnRbMV1dLFxuICAgICAgZmVhdHVyZTogZmVhdHVyZSxcbiAgICAgIGdlb21ldHJ5OiBnZW9tZXRyeSxcbiAgICAgIGRlcHRoOiBkZXB0aCxcbiAgICAgIGluZGV4OiBpbmRleCArIDFcbiAgICB9KTtcbiAgICByVHJlZS5pbnNlcnQoYm91bmRpbmdFeHRlbnQobmV3U2VnbWVudERhdGEyLnNlZ21lbnQpLCBuZXdTZWdtZW50RGF0YTIpO1xuICAgIHRoaXMuZHJhZ1NlZ21lbnRzXy5wdXNoKFtuZXdTZWdtZW50RGF0YTIsIDBdKTtcbiAgICB0aGlzLmlnbm9yZU5leHRTaW5nbGVDbGlja18gPSB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSB2ZXJ0ZXggY3VycmVudGx5IGJlaW5nIHBvaW50ZWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgd2hlbiBhIHZlcnRleCB3YXMgcmVtb3ZlZC5cbiAgICogQGFwaVxuICAgKi9cbiAgTW9kaWZ5LnByb3RvdHlwZS5yZW1vdmVQb2ludCA9IGZ1bmN0aW9uIHJlbW92ZVBvaW50ICgpIHtcbiAgICBpZiAodGhpcy5sYXN0UG9pbnRlckV2ZW50XyAmJiB0aGlzLmxhc3RQb2ludGVyRXZlbnRfLnR5cGUgIT0gTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSRFJBRykge1xuICAgICAgdmFyIGV2dCA9IHRoaXMubGFzdFBvaW50ZXJFdmVudF87XG4gICAgICB0aGlzLndpbGxNb2RpZnlGZWF0dXJlc18oZXZ0KTtcbiAgICAgIHRoaXMucmVtb3ZlVmVydGV4XygpO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBNb2RpZnlFdmVudChNb2RpZnlFdmVudFR5cGUuTU9ESUZZRU5ELCB0aGlzLmZlYXR1cmVzXywgZXZ0KSk7XG4gICAgICB0aGlzLm1vZGlmaWVkXyA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlcyBhIHZlcnRleCBmcm9tIGFsbCBtYXRjaGluZyBmZWF0dXJlcy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSB3aGVuIGEgdmVydGV4IHdhcyByZW1vdmVkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTW9kaWZ5LnByb3RvdHlwZS5yZW1vdmVWZXJ0ZXhfID0gZnVuY3Rpb24gcmVtb3ZlVmVydGV4XyAoKSB7XG4gICAgdmFyIGRyYWdTZWdtZW50cyA9IHRoaXMuZHJhZ1NlZ21lbnRzXztcbiAgICB2YXIgc2VnbWVudHNCeUZlYXR1cmUgPSB7fTtcbiAgICB2YXIgZGVsZXRlZCA9IGZhbHNlO1xuICAgIHZhciBjb21wb25lbnQsIGNvb3JkaW5hdGVzLCBkcmFnU2VnbWVudCwgZ2VvbWV0cnksIGksIGluZGV4LCBsZWZ0O1xuICAgIHZhciBuZXdJbmRleCwgcmlnaHQsIHNlZ21lbnREYXRhLCB1aWQ7XG4gICAgZm9yIChpID0gZHJhZ1NlZ21lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBkcmFnU2VnbWVudCA9IGRyYWdTZWdtZW50c1tpXTtcbiAgICAgIHNlZ21lbnREYXRhID0gZHJhZ1NlZ21lbnRbMF07XG4gICAgICB1aWQgPSBnZXRVaWQoc2VnbWVudERhdGEuZmVhdHVyZSk7XG4gICAgICBpZiAoc2VnbWVudERhdGEuZGVwdGgpIHtcbiAgICAgICAgLy8gc2VwYXJhdGUgZmVhdHVyZSBjb21wb25lbnRzXG4gICAgICAgIHVpZCArPSAnLScgKyBzZWdtZW50RGF0YS5kZXB0aC5qb2luKCctJyk7XG4gICAgICB9XG4gICAgICBpZiAoISh1aWQgaW4gc2VnbWVudHNCeUZlYXR1cmUpKSB7XG4gICAgICAgIHNlZ21lbnRzQnlGZWF0dXJlW3VpZF0gPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChkcmFnU2VnbWVudFsxXSA9PT0gMCkge1xuICAgICAgICBzZWdtZW50c0J5RmVhdHVyZVt1aWRdLnJpZ2h0ID0gc2VnbWVudERhdGE7XG4gICAgICAgIHNlZ21lbnRzQnlGZWF0dXJlW3VpZF0uaW5kZXggPSBzZWdtZW50RGF0YS5pbmRleDtcbiAgICAgIH0gZWxzZSBpZiAoZHJhZ1NlZ21lbnRbMV0gPT0gMSkge1xuICAgICAgICBzZWdtZW50c0J5RmVhdHVyZVt1aWRdLmxlZnQgPSBzZWdtZW50RGF0YTtcbiAgICAgICAgc2VnbWVudHNCeUZlYXR1cmVbdWlkXS5pbmRleCA9IHNlZ21lbnREYXRhLmluZGV4ICsgMTtcbiAgICAgIH1cblxuICAgIH1cbiAgICBmb3IgKHVpZCBpbiBzZWdtZW50c0J5RmVhdHVyZSkge1xuICAgICAgcmlnaHQgPSBzZWdtZW50c0J5RmVhdHVyZVt1aWRdLnJpZ2h0O1xuICAgICAgbGVmdCA9IHNlZ21lbnRzQnlGZWF0dXJlW3VpZF0ubGVmdDtcbiAgICAgIGluZGV4ID0gc2VnbWVudHNCeUZlYXR1cmVbdWlkXS5pbmRleDtcbiAgICAgIG5ld0luZGV4ID0gaW5kZXggLSAxO1xuICAgICAgaWYgKGxlZnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZWdtZW50RGF0YSA9IGxlZnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWdtZW50RGF0YSA9IHJpZ2h0O1xuICAgICAgfVxuICAgICAgaWYgKG5ld0luZGV4IDwgMCkge1xuICAgICAgICBuZXdJbmRleCA9IDA7XG4gICAgICB9XG4gICAgICBnZW9tZXRyeSA9IHNlZ21lbnREYXRhLmdlb21ldHJ5O1xuICAgICAgY29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgY29tcG9uZW50ID0gY29vcmRpbmF0ZXM7XG4gICAgICBkZWxldGVkID0gZmFsc2U7XG4gICAgICBzd2l0Y2ggKGdlb21ldHJ5LmdldFR5cGUoKSkge1xuICAgICAgICBjYXNlIEdlb21ldHJ5VHlwZS5NVUxUSV9MSU5FX1NUUklORzpcbiAgICAgICAgICBpZiAoY29vcmRpbmF0ZXNbc2VnbWVudERhdGEuZGVwdGhbMF1dLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzW3NlZ21lbnREYXRhLmRlcHRoWzBdXS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgZGVsZXRlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdlb21ldHJ5VHlwZS5MSU5FX1NUUklORzpcbiAgICAgICAgICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgY29vcmRpbmF0ZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIGRlbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuTVVMVElfUE9MWUdPTjpcbiAgICAgICAgICBjb21wb25lbnQgPSBjb21wb25lbnRbc2VnbWVudERhdGEuZGVwdGhbMV1dO1xuICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuUE9MWUdPTjpcbiAgICAgICAgICBjb21wb25lbnQgPSBjb21wb25lbnRbc2VnbWVudERhdGEuZGVwdGhbMF1dO1xuICAgICAgICAgIGlmIChjb21wb25lbnQubGVuZ3RoID4gNCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IGNvbXBvbmVudC5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbXBvbmVudC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgZGVsZXRlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgLy8gY2xvc2UgdGhlIHJpbmcgYWdhaW5cbiAgICAgICAgICAgICAgY29tcG9uZW50LnBvcCgpO1xuICAgICAgICAgICAgICBjb21wb25lbnQucHVzaChjb21wb25lbnRbMF0pO1xuICAgICAgICAgICAgICBuZXdJbmRleCA9IGNvbXBvbmVudC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBwYXNzXG4gICAgICB9XG5cbiAgICAgIGlmIChkZWxldGVkKSB7XG4gICAgICAgIHRoaXMuc2V0R2VvbWV0cnlDb29yZGluYXRlc18oZ2VvbWV0cnksIGNvb3JkaW5hdGVzKTtcbiAgICAgICAgdmFyIHNlZ21lbnRzID0gW107XG4gICAgICAgIGlmIChsZWZ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnJCdXNoXy5yZW1vdmUobGVmdCk7XG4gICAgICAgICAgc2VnbWVudHMucHVzaChsZWZ0LnNlZ21lbnRbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5yQnVzaF8ucmVtb3ZlKHJpZ2h0KTtcbiAgICAgICAgICBzZWdtZW50cy5wdXNoKHJpZ2h0LnNlZ21lbnRbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWZ0ICE9PSB1bmRlZmluZWQgJiYgcmlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBuZXdTZWdtZW50RGF0YSA9IC8qKiBAdHlwZSB7U2VnbWVudERhdGF9ICovICh7XG4gICAgICAgICAgICBkZXB0aDogc2VnbWVudERhdGEuZGVwdGgsXG4gICAgICAgICAgICBmZWF0dXJlOiBzZWdtZW50RGF0YS5mZWF0dXJlLFxuICAgICAgICAgICAgZ2VvbWV0cnk6IHNlZ21lbnREYXRhLmdlb21ldHJ5LFxuICAgICAgICAgICAgaW5kZXg6IG5ld0luZGV4LFxuICAgICAgICAgICAgc2VnbWVudDogc2VnbWVudHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnJCdXNoXy5pbnNlcnQoYm91bmRpbmdFeHRlbnQobmV3U2VnbWVudERhdGEuc2VnbWVudCksXG4gICAgICAgICAgICBuZXdTZWdtZW50RGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVTZWdtZW50SW5kaWNlc18oZ2VvbWV0cnksIGluZGV4LCBzZWdtZW50RGF0YS5kZXB0aCwgLTEpO1xuICAgICAgICBpZiAodGhpcy52ZXJ0ZXhGZWF0dXJlXykge1xuICAgICAgICAgIC8qKiBAdHlwZSB7VmVjdG9yU291cmNlfSAqLyAodGhpcy5vdmVybGF5Xy5nZXRTb3VyY2UoKSkucmVtb3ZlRmVhdHVyZSh0aGlzLnZlcnRleEZlYXR1cmVfKTtcbiAgICAgICAgICB0aGlzLnZlcnRleEZlYXR1cmVfID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBkcmFnU2VnbWVudHMubGVuZ3RoID0gMDtcbiAgICAgIH1cblxuICAgIH1cbiAgICByZXR1cm4gZGVsZXRlZDtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge0FycmF5fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIE1vZGlmeS5wcm90b3R5cGUuc2V0R2VvbWV0cnlDb29yZGluYXRlc18gPSBmdW5jdGlvbiBzZXRHZW9tZXRyeUNvb3JkaW5hdGVzXyAoZ2VvbWV0cnksIGNvb3JkaW5hdGVzKSB7XG4gICAgdGhpcy5jaGFuZ2luZ0ZlYXR1cmVfID0gdHJ1ZTtcbiAgICBnZW9tZXRyeS5zZXRDb29yZGluYXRlcyhjb29yZGluYXRlcyk7XG4gICAgdGhpcy5jaGFuZ2luZ0ZlYXR1cmVfID0gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4LlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj58dW5kZWZpbmVkfSBkZXB0aCBEZXB0aC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhIERlbHRhICgxIG9yIC0xKS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIE1vZGlmeS5wcm90b3R5cGUudXBkYXRlU2VnbWVudEluZGljZXNfID0gZnVuY3Rpb24gdXBkYXRlU2VnbWVudEluZGljZXNfIChnZW9tZXRyeSwgaW5kZXgsIGRlcHRoLCBkZWx0YSkge1xuICAgIHRoaXMuckJ1c2hfLmZvckVhY2hJbkV4dGVudChnZW9tZXRyeS5nZXRFeHRlbnQoKSwgZnVuY3Rpb24oc2VnbWVudERhdGFNYXRjaCkge1xuICAgICAgaWYgKHNlZ21lbnREYXRhTWF0Y2guZ2VvbWV0cnkgPT09IGdlb21ldHJ5ICYmXG4gICAgICAgICAgKGRlcHRoID09PSB1bmRlZmluZWQgfHwgc2VnbWVudERhdGFNYXRjaC5kZXB0aCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgZXF1YWxzKHNlZ21lbnREYXRhTWF0Y2guZGVwdGgsIGRlcHRoKSkgJiZcbiAgICAgICAgICBzZWdtZW50RGF0YU1hdGNoLmluZGV4ID4gaW5kZXgpIHtcbiAgICAgICAgc2VnbWVudERhdGFNYXRjaC5pbmRleCArPSBkZWx0YTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gTW9kaWZ5O1xufShQb2ludGVySW50ZXJhY3Rpb24pKTtcblxuXG4vKipcbiAqIEBwYXJhbSB7U2VnbWVudERhdGF9IGEgVGhlIGZpcnN0IHNlZ21lbnQgZGF0YS5cbiAqIEBwYXJhbSB7U2VnbWVudERhdGF9IGIgVGhlIHNlY29uZCBzZWdtZW50IGRhdGEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBkaWZmZXJlbmNlIGluIGluZGV4ZXMuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVJbmRleGVzKGEsIGIpIHtcbiAgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4O1xufVxuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgZGlzdGFuY2UgZnJvbSBhIHBvaW50IHRvIGEgbGluZSBzZWdtZW50LlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBwb2ludENvb3JkaW5hdGVzIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQgZnJvbVxuICogICAgICAgIHdoaWNoIHRvIGNhbGN1bGF0ZSB0aGUgZGlzdGFuY2UuXG4gKiBAcGFyYW0ge1NlZ21lbnREYXRhfSBzZWdtZW50RGF0YSBUaGUgb2JqZWN0IGRlc2NyaWJpbmcgdGhlIGxpbmVcbiAqICAgICAgICBzZWdtZW50IHdlIGFyZSBjYWxjdWxhdGluZyB0aGUgZGlzdGFuY2UgdG8uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzcXVhcmUgb2YgdGhlIGRpc3RhbmNlIGJldHdlZW4gYSBwb2ludCBhbmQgYSBsaW5lIHNlZ21lbnQuXG4gKi9cbmZ1bmN0aW9uIHBvaW50RGlzdGFuY2VUb1NlZ21lbnREYXRhU3F1YXJlZChwb2ludENvb3JkaW5hdGVzLCBzZWdtZW50RGF0YSkge1xuICB2YXIgZ2VvbWV0cnkgPSBzZWdtZW50RGF0YS5nZW9tZXRyeTtcblxuICBpZiAoZ2VvbWV0cnkuZ2V0VHlwZSgpID09PSBHZW9tZXRyeVR5cGUuQ0lSQ0xFKSB7XG4gICAgdmFyIGNpcmNsZUdlb21ldHJ5ID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9nZW9tL0NpcmNsZS5qc1wiKS5kZWZhdWx0fSAqLyAoZ2VvbWV0cnkpO1xuXG4gICAgaWYgKHNlZ21lbnREYXRhLmluZGV4ID09PSBDSVJDTEVfQ0lSQ1VNRkVSRU5DRV9JTkRFWCkge1xuICAgICAgdmFyIGRpc3RhbmNlVG9DZW50ZXJTcXVhcmVkID1cbiAgICAgICAgICAgIHNxdWFyZWRDb29yZGluYXRlRGlzdGFuY2UoY2lyY2xlR2VvbWV0cnkuZ2V0Q2VudGVyKCksIHBvaW50Q29vcmRpbmF0ZXMpO1xuICAgICAgdmFyIGRpc3RhbmNlVG9DaXJjdW1mZXJlbmNlID1cbiAgICAgICAgICAgIE1hdGguc3FydChkaXN0YW5jZVRvQ2VudGVyU3F1YXJlZCkgLSBjaXJjbGVHZW9tZXRyeS5nZXRSYWRpdXMoKTtcbiAgICAgIHJldHVybiBkaXN0YW5jZVRvQ2lyY3VtZmVyZW5jZSAqIGRpc3RhbmNlVG9DaXJjdW1mZXJlbmNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3F1YXJlZERpc3RhbmNlVG9TZWdtZW50KHBvaW50Q29vcmRpbmF0ZXMsIHNlZ21lbnREYXRhLnNlZ21lbnQpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHBvaW50IGNsb3Nlc3QgdG8gYSBnaXZlbiBsaW5lIHNlZ21lbnQuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IHBvaW50Q29vcmRpbmF0ZXMgVGhlIHBvaW50IHRvIHdoaWNoIGEgY2xvc2VzdCBwb2ludFxuICogICAgICAgIHNob3VsZCBiZSBmb3VuZC5cbiAqIEBwYXJhbSB7U2VnbWVudERhdGF9IHNlZ21lbnREYXRhIFRoZSBvYmplY3QgZGVzY3JpYmluZyB0aGUgbGluZVxuICogICAgICAgIHNlZ21lbnQgd2hpY2ggc2hvdWxkIGNvbnRhaW4gdGhlIGNsb3Nlc3QgcG9pbnQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFRoZSBwb2ludCBjbG9zZXN0IHRvIHRoZSBzcGVjaWZpZWQgbGluZSBzZWdtZW50LlxuICovXG5mdW5jdGlvbiBjbG9zZXN0T25TZWdtZW50RGF0YShwb2ludENvb3JkaW5hdGVzLCBzZWdtZW50RGF0YSkge1xuICB2YXIgZ2VvbWV0cnkgPSBzZWdtZW50RGF0YS5nZW9tZXRyeTtcblxuICBpZiAoZ2VvbWV0cnkuZ2V0VHlwZSgpID09PSBHZW9tZXRyeVR5cGUuQ0lSQ0xFICYmXG4gIHNlZ21lbnREYXRhLmluZGV4ID09PSBDSVJDTEVfQ0lSQ1VNRkVSRU5DRV9JTkRFWCkge1xuICAgIHJldHVybiBnZW9tZXRyeS5nZXRDbG9zZXN0UG9pbnQocG9pbnRDb29yZGluYXRlcyk7XG4gIH1cbiAgcmV0dXJuIGNsb3Nlc3RPblNlZ21lbnQocG9pbnRDb29yZGluYXRlcywgc2VnbWVudERhdGEuc2VnbWVudCk7XG59XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUZ1bmN0aW9ufSBTdHlsZXMuXG4gKi9cbmZ1bmN0aW9uIGdldERlZmF1bHRTdHlsZUZ1bmN0aW9uKCkge1xuICB2YXIgc3R5bGUgPSBjcmVhdGVFZGl0aW5nU3R5bGUoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGZlYXR1cmUsIHJlc29sdXRpb24pIHtcbiAgICByZXR1cm4gc3R5bGVbR2VvbWV0cnlUeXBlLlBPSU5UXTtcbiAgfTtcbn1cblxuXG5leHBvcnQgZGVmYXVsdCBNb2RpZnk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1vZGlmeS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vTW91c2VXaGVlbFpvb21cbiAqL1xuaW1wb3J0IFZpZXdIaW50IGZyb20gJy4uL1ZpZXdIaW50LmpzJztcbmltcG9ydCB7YWx3YXlzfSBmcm9tICcuLi9ldmVudHMvY29uZGl0aW9uLmpzJztcbmltcG9ydCB7ZWFzZU91dH0gZnJvbSAnLi4vZWFzaW5nLmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQge0RFVklDRV9QSVhFTF9SQVRJTywgRklSRUZPWCwgU0FGQVJJfSBmcm9tICcuLi9oYXMuanMnO1xuaW1wb3J0IEludGVyYWN0aW9uLCB7em9vbUJ5RGVsdGF9IGZyb20gJy4vSW50ZXJhY3Rpb24uanMnO1xuaW1wb3J0IHtjbGFtcH0gZnJvbSAnLi4vbWF0aC5qcyc7XG5cblxuLyoqXG4gKiBNYXhpbXVtIG1vdXNlIHdoZWVsIGRlbHRhLlxuICogQHR5cGUge251bWJlcn1cbiAqL1xudmFyIE1BWF9ERUxUQSA9IDE7XG5cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgdmFyIE1vZGUgPSB7XG4gIFRSQUNLUEFEOiAndHJhY2twYWQnLFxuICBXSEVFTDogJ3doZWVsJ1xufTtcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259IFtjb25kaXRpb25dIEEgZnVuY3Rpb24gdGhhdFxuICogdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmQgcmV0dXJucyBhXG4gKiBib29sZWFuIHRvIGluZGljYXRlIHdoZXRoZXIgdGhhdCBldmVudCBzaG91bGQgYmUgaGFuZGxlZC4gRGVmYXVsdCBpc1xuICoge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9ufmFsd2F5c30uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2R1cmF0aW9uPTI1MF0gQW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdGltZW91dD04MF0gTW91c2Ugd2hlZWwgdGltZW91dCBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjb25zdHJhaW5SZXNvbHV0aW9uPWZhbHNlXSBXaGVuIHVzaW5nIGEgdHJhY2twYWQgb3JcbiAqIG1hZ2ljIG1vdXNlLCB6b29tIHRvIHRoZSBjbG9zZXN0IGludGVnZXIgem9vbSBsZXZlbCBhZnRlciB0aGUgc2Nyb2xsIGdlc3R1cmVcbiAqIGVuZHMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt1c2VBbmNob3I9dHJ1ZV0gRW5hYmxlIHpvb21pbmcgdXNpbmcgdGhlIG1vdXNlJ3NcbiAqIGxvY2F0aW9uIGFzIHRoZSBhbmNob3IuIFdoZW4gc2V0IHRvIGBmYWxzZWAsIHpvb21pbmcgaW4gYW5kIG91dCB3aWxsIHpvb20gdG9cbiAqIHRoZSBjZW50ZXIgb2YgdGhlIHNjcmVlbiBpbnN0ZWFkIG9mIHpvb21pbmcgb24gdGhlIG1vdXNlJ3MgbG9jYXRpb24uXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFsbG93cyB0aGUgdXNlciB0byB6b29tIHRoZSBtYXAgYnkgc2Nyb2xsaW5nIHRoZSBtb3VzZSB3aGVlbC5cbiAqIEBhcGlcbiAqL1xudmFyIE1vdXNlV2hlZWxab29tID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoSW50ZXJhY3Rpb24pIHtcbiAgZnVuY3Rpb24gTW91c2VXaGVlbFpvb20ob3B0X29wdGlvbnMpIHtcblxuICAgIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgPyBvcHRfb3B0aW9ucyA6IHt9O1xuXG4gICAgSW50ZXJhY3Rpb24uY2FsbCgvKiogQHR5cGUge2ltcG9ydChcIi4vSW50ZXJhY3Rpb24uanNcIikuSW50ZXJhY3Rpb25PcHRpb25zfSAqLyB0aGlzLCAob3B0aW9ucykpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZGVsdGFfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmR1cmF0aW9uXyA9IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiAyNTA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50aW1lb3V0XyA9IG9wdGlvbnMudGltZW91dCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy50aW1lb3V0IDogODA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMudXNlQW5jaG9yXyA9IG9wdGlvbnMudXNlQW5jaG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnVzZUFuY2hvciA6IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuY29uc3RyYWluUmVzb2x1dGlvbl8gPSBvcHRpb25zLmNvbnN0cmFpblJlc29sdXRpb24gfHwgZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbmRpdGlvbl8gPSBvcHRpb25zLmNvbmRpdGlvbiA/IG9wdGlvbnMuY29uZGl0aW9uIDogYWx3YXlzO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLmxhc3RBbmNob3JfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5zdGFydFRpbWVfID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICB0aGlzLnRpbWVvdXRJZF87XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtNb2RlfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLm1vZGVfID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogVHJhY2twYWQgZXZlbnRzIHNlcGFyYXRlZCBieSB0aGlzIGRlbGF5IHdpbGwgYmUgY29uc2lkZXJlZCBzZXBhcmF0ZVxuICAgICAqIGludGVyYWN0aW9ucy5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudHJhY2twYWRFdmVudEdhcF8gPSA0MDA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICB0aGlzLnRyYWNrcGFkVGltZW91dElkXztcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgZGVsdGEgdmFsdWVzIHBlciB6b29tIGxldmVsXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudHJhY2twYWREZWx0YVBlclpvb21fID0gMzAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHpvb20gZmFjdG9yIGJ5IHdoaWNoIHNjcm9sbCB6b29taW5nIGlzIGFsbG93ZWQgdG8gZXhjZWVkIHRoZSBsaW1pdHMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudHJhY2twYWRab29tQnVmZmVyXyA9IDEuNTtcblxuICB9XG5cbiAgaWYgKCBJbnRlcmFjdGlvbiApIE1vdXNlV2hlZWxab29tLl9fcHJvdG9fXyA9IEludGVyYWN0aW9uO1xuICBNb3VzZVdoZWVsWm9vbS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbnRlcmFjdGlvbiAmJiBJbnRlcmFjdGlvbi5wcm90b3R5cGUgKTtcbiAgTW91c2VXaGVlbFpvb20ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTW91c2VXaGVlbFpvb207XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBNb3VzZVdoZWVsWm9vbS5wcm90b3R5cGUuZGVjcmVtZW50SW50ZXJhY3RpbmdIaW50XyA9IGZ1bmN0aW9uIGRlY3JlbWVudEludGVyYWN0aW5nSGludF8gKCkge1xuICAgIHRoaXMudHJhY2twYWRUaW1lb3V0SWRfID0gdW5kZWZpbmVkO1xuICAgIHZhciB2aWV3ID0gdGhpcy5nZXRNYXAoKS5nZXRWaWV3KCk7XG4gICAgdmlldy5zZXRIaW50KFZpZXdIaW50LklOVEVSQUNUSU5HLCAtMSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50IG1hcCBicm93c2VyIGV2ZW50fSAoaWYgaXQgd2FzIGEgbW91c2V3aGVlbC1ldmVudCkgYW5kIGV2ZW50dWFsbHlcbiAgICogem9vbXMgdGhlIG1hcC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBNb3VzZVdoZWVsWm9vbS5wcm90b3R5cGUuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiBoYW5kbGVFdmVudCAobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmNvbmRpdGlvbl8obWFwQnJvd3NlckV2ZW50KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciB0eXBlID0gbWFwQnJvd3NlckV2ZW50LnR5cGU7XG4gICAgaWYgKHR5cGUgIT09IEV2ZW50VHlwZS5XSEVFTCAmJiB0eXBlICE9PSBFdmVudFR5cGUuTU9VU0VXSEVFTCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgbWFwQnJvd3NlckV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICB2YXIgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgICB2YXIgd2hlZWxFdmVudCA9IC8qKiBAdHlwZSB7V2hlZWxFdmVudH0gKi8gKG1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50KTtcblxuICAgIGlmICh0aGlzLnVzZUFuY2hvcl8pIHtcbiAgICAgIHRoaXMubGFzdEFuY2hvcl8gPSBtYXBCcm93c2VyRXZlbnQuY29vcmRpbmF0ZTtcbiAgICB9XG5cbiAgICAvLyBEZWx0YSBub3JtYWxpc2F0aW9uIGluc3BpcmVkIGJ5XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9tYXBib3gtZ2wtanMvYmxvYi8wMDFjN2I5L2pzL3VpL2hhbmRsZXIvc2Nyb2xsX3pvb20uanNcbiAgICB2YXIgZGVsdGE7XG4gICAgaWYgKG1hcEJyb3dzZXJFdmVudC50eXBlID09IEV2ZW50VHlwZS5XSEVFTCkge1xuICAgICAgZGVsdGEgPSB3aGVlbEV2ZW50LmRlbHRhWTtcbiAgICAgIGlmIChGSVJFRk9YICYmXG4gICAgICAgICAgd2hlZWxFdmVudC5kZWx0YU1vZGUgPT09IFdoZWVsRXZlbnQuRE9NX0RFTFRBX1BJWEVMKSB7XG4gICAgICAgIGRlbHRhIC89IERFVklDRV9QSVhFTF9SQVRJTztcbiAgICAgIH1cbiAgICAgIGlmICh3aGVlbEV2ZW50LmRlbHRhTW9kZSA9PT0gV2hlZWxFdmVudC5ET01fREVMVEFfTElORSkge1xuICAgICAgICBkZWx0YSAqPSA0MDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1hcEJyb3dzZXJFdmVudC50eXBlID09IEV2ZW50VHlwZS5NT1VTRVdIRUVMKSB7XG4gICAgICBkZWx0YSA9IC13aGVlbEV2ZW50LndoZWVsRGVsdGFZO1xuICAgICAgaWYgKFNBRkFSSSkge1xuICAgICAgICBkZWx0YSAvPSAzO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkZWx0YSA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuXG4gICAgaWYgKHRoaXMuc3RhcnRUaW1lXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnN0YXJ0VGltZV8gPSBub3c7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm1vZGVfIHx8IG5vdyAtIHRoaXMuc3RhcnRUaW1lXyA+IHRoaXMudHJhY2twYWRFdmVudEdhcF8pIHtcbiAgICAgIHRoaXMubW9kZV8gPSBNYXRoLmFicyhkZWx0YSkgPCA0ID9cbiAgICAgICAgTW9kZS5UUkFDS1BBRCA6XG4gICAgICAgIE1vZGUuV0hFRUw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubW9kZV8gPT09IE1vZGUuVFJBQ0tQQUQpIHtcbiAgICAgIHZhciB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICAgIGlmICh0aGlzLnRyYWNrcGFkVGltZW91dElkXykge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50cmFja3BhZFRpbWVvdXRJZF8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmlldy5zZXRIaW50KFZpZXdIaW50LklOVEVSQUNUSU5HLCAxKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudHJhY2twYWRUaW1lb3V0SWRfID0gc2V0VGltZW91dCh0aGlzLmRlY3JlbWVudEludGVyYWN0aW5nSGludF8uYmluZCh0aGlzKSwgdGhpcy50cmFja3BhZEV2ZW50R2FwXyk7XG4gICAgICB2YXIgcmVzb2x1dGlvbiA9IHZpZXcuZ2V0UmVzb2x1dGlvbigpICogTWF0aC5wb3coMiwgZGVsdGEgLyB0aGlzLnRyYWNrcGFkRGVsdGFQZXJab29tXyk7XG4gICAgICB2YXIgbWluUmVzb2x1dGlvbiA9IHZpZXcuZ2V0TWluUmVzb2x1dGlvbigpO1xuICAgICAgdmFyIG1heFJlc29sdXRpb24gPSB2aWV3LmdldE1heFJlc29sdXRpb24oKTtcbiAgICAgIHZhciByZWJvdW5kID0gMDtcbiAgICAgIGlmIChyZXNvbHV0aW9uIDwgbWluUmVzb2x1dGlvbikge1xuICAgICAgICByZXNvbHV0aW9uID0gTWF0aC5tYXgocmVzb2x1dGlvbiwgbWluUmVzb2x1dGlvbiAvIHRoaXMudHJhY2twYWRab29tQnVmZmVyXyk7XG4gICAgICAgIHJlYm91bmQgPSAxO1xuICAgICAgfSBlbHNlIGlmIChyZXNvbHV0aW9uID4gbWF4UmVzb2x1dGlvbikge1xuICAgICAgICByZXNvbHV0aW9uID0gTWF0aC5taW4ocmVzb2x1dGlvbiwgbWF4UmVzb2x1dGlvbiAqIHRoaXMudHJhY2twYWRab29tQnVmZmVyXyk7XG4gICAgICAgIHJlYm91bmQgPSAtMTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmxhc3RBbmNob3JfKSB7XG4gICAgICAgIHZhciBjZW50ZXIgPSB2aWV3LmNhbGN1bGF0ZUNlbnRlclpvb20ocmVzb2x1dGlvbiwgdGhpcy5sYXN0QW5jaG9yXyk7XG4gICAgICAgIHZpZXcuc2V0Q2VudGVyKHZpZXcuY29uc3RyYWluQ2VudGVyKGNlbnRlcikpO1xuICAgICAgfVxuICAgICAgdmlldy5zZXRSZXNvbHV0aW9uKHJlc29sdXRpb24pO1xuXG4gICAgICBpZiAocmVib3VuZCA9PT0gMCAmJiB0aGlzLmNvbnN0cmFpblJlc29sdXRpb25fKSB7XG4gICAgICAgIHZpZXcuYW5pbWF0ZSh7XG4gICAgICAgICAgcmVzb2x1dGlvbjogdmlldy5jb25zdHJhaW5SZXNvbHV0aW9uKHJlc29sdXRpb24sIGRlbHRhID4gMCA/IC0xIDogMSksXG4gICAgICAgICAgZWFzaW5nOiBlYXNlT3V0LFxuICAgICAgICAgIGFuY2hvcjogdGhpcy5sYXN0QW5jaG9yXyxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbl9cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWJvdW5kID4gMCkge1xuICAgICAgICB2aWV3LmFuaW1hdGUoe1xuICAgICAgICAgIHJlc29sdXRpb246IG1pblJlc29sdXRpb24sXG4gICAgICAgICAgZWFzaW5nOiBlYXNlT3V0LFxuICAgICAgICAgIGFuY2hvcjogdGhpcy5sYXN0QW5jaG9yXyxcbiAgICAgICAgICBkdXJhdGlvbjogNTAwXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChyZWJvdW5kIDwgMCkge1xuICAgICAgICB2aWV3LmFuaW1hdGUoe1xuICAgICAgICAgIHJlc29sdXRpb246IG1heFJlc29sdXRpb24sXG4gICAgICAgICAgZWFzaW5nOiBlYXNlT3V0LFxuICAgICAgICAgIGFuY2hvcjogdGhpcy5sYXN0QW5jaG9yXyxcbiAgICAgICAgICBkdXJhdGlvbjogNTAwXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGFydFRpbWVfID0gbm93O1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuZGVsdGFfICs9IGRlbHRhO1xuXG4gICAgdmFyIHRpbWVMZWZ0ID0gTWF0aC5tYXgodGhpcy50aW1lb3V0XyAtIChub3cgLSB0aGlzLnN0YXJ0VGltZV8pLCAwKTtcblxuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZF8pO1xuICAgIHRoaXMudGltZW91dElkXyA9IHNldFRpbWVvdXQodGhpcy5oYW5kbGVXaGVlbFpvb21fLmJpbmQodGhpcywgbWFwKSwgdGltZUxlZnQpO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1BsdWdnYWJsZU1hcC5qc1wiKS5kZWZhdWx0fSBtYXAgTWFwLlxuICAgKi9cbiAgTW91c2VXaGVlbFpvb20ucHJvdG90eXBlLmhhbmRsZVdoZWVsWm9vbV8gPSBmdW5jdGlvbiBoYW5kbGVXaGVlbFpvb21fIChtYXApIHtcbiAgICB2YXIgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgaWYgKHZpZXcuZ2V0QW5pbWF0aW5nKCkpIHtcbiAgICAgIHZpZXcuY2FuY2VsQW5pbWF0aW9ucygpO1xuICAgIH1cbiAgICB2YXIgbWF4RGVsdGEgPSBNQVhfREVMVEE7XG4gICAgdmFyIGRlbHRhID0gY2xhbXAodGhpcy5kZWx0YV8sIC1tYXhEZWx0YSwgbWF4RGVsdGEpO1xuICAgIHpvb21CeURlbHRhKHZpZXcsIC1kZWx0YSwgdGhpcy5sYXN0QW5jaG9yXywgdGhpcy5kdXJhdGlvbl8pO1xuICAgIHRoaXMubW9kZV8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5kZWx0YV8gPSAwO1xuICAgIHRoaXMubGFzdEFuY2hvcl8gPSBudWxsO1xuICAgIHRoaXMuc3RhcnRUaW1lXyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRpbWVvdXRJZF8gPSB1bmRlZmluZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVuYWJsZSBvciBkaXNhYmxlIHVzaW5nIHRoZSBtb3VzZSdzIGxvY2F0aW9uIGFzIGFuIGFuY2hvciB3aGVuIHpvb21pbmdcbiAgICogQHBhcmFtIHtib29sZWFufSB1c2VBbmNob3IgdHJ1ZSB0byB6b29tIHRvIHRoZSBtb3VzZSdzIGxvY2F0aW9uLCBmYWxzZVxuICAgKiB0byB6b29tIHRvIHRoZSBjZW50ZXIgb2YgdGhlIG1hcFxuICAgKiBAYXBpXG4gICAqL1xuICBNb3VzZVdoZWVsWm9vbS5wcm90b3R5cGUuc2V0TW91c2VBbmNob3IgPSBmdW5jdGlvbiBzZXRNb3VzZUFuY2hvciAodXNlQW5jaG9yKSB7XG4gICAgdGhpcy51c2VBbmNob3JfID0gdXNlQW5jaG9yO1xuICAgIGlmICghdXNlQW5jaG9yKSB7XG4gICAgICB0aGlzLmxhc3RBbmNob3JfID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIE1vdXNlV2hlZWxab29tO1xufShJbnRlcmFjdGlvbikpO1xuXG5leHBvcnQgZGVmYXVsdCBNb3VzZVdoZWVsWm9vbTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TW91c2VXaGVlbFpvb20uanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL1BpbmNoUm90YXRlXG4gKi9cbmltcG9ydCBWaWV3SGludCBmcm9tICcuLi9WaWV3SGludC5qcyc7XG5pbXBvcnQge0ZBTFNFfSBmcm9tICcuLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IHtyb3RhdGUsIHJvdGF0ZVdpdGhvdXRDb25zdHJhaW50c30gZnJvbSAnLi9JbnRlcmFjdGlvbi5qcyc7XG5pbXBvcnQgUG9pbnRlckludGVyYWN0aW9uLCB7Y2VudHJvaWQgYXMgY2VudHJvaWRGcm9tUG9pbnRlcnN9IGZyb20gJy4vUG9pbnRlci5qcyc7XG5pbXBvcnQge2Rpc2FibGV9IGZyb20gJy4uL3JvdGF0aW9uY29uc3RyYWludC5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2R1cmF0aW9uPTI1MF0gVGhlIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24gaW5cbiAqIG1pbGxpc2Vjb25kcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdGhyZXNob2xkPTAuM10gTWluaW1hbCBhbmdsZSBpbiByYWRpYW5zIHRvIHN0YXJ0IGEgcm90YXRpb24uXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFsbG93cyB0aGUgdXNlciB0byByb3RhdGUgdGhlIG1hcCBieSB0d2lzdGluZyB3aXRoIHR3byBmaW5nZXJzXG4gKiBvbiBhIHRvdWNoIHNjcmVlbi5cbiAqIEBhcGlcbiAqL1xudmFyIFBpbmNoUm90YXRlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoUG9pbnRlckludGVyYWN0aW9uKSB7XG4gIGZ1bmN0aW9uIFBpbmNoUm90YXRlKG9wdF9vcHRpb25zKSB7XG5cbiAgICB2YXIgb3B0aW9ucyA9IG9wdF9vcHRpb25zID8gb3B0X29wdGlvbnMgOiB7fTtcblxuICAgIHZhciBwb2ludGVyT3B0aW9ucyA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9Qb2ludGVyLmpzXCIpLk9wdGlvbnN9ICovIChvcHRpb25zKTtcblxuICAgIGlmICghcG9pbnRlck9wdGlvbnMuc3RvcERvd24pIHtcbiAgICAgIHBvaW50ZXJPcHRpb25zLnN0b3BEb3duID0gRkFMU0U7XG4gICAgfVxuXG4gICAgUG9pbnRlckludGVyYWN0aW9uLmNhbGwodGhpcywgcG9pbnRlck9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfVxuICAgICAqL1xuICAgIHRoaXMuYW5jaG9yXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMubGFzdEFuZ2xlXyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yb3RhdGluZ18gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJvdGF0aW9uRGVsdGFfID0gMC4wO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudGhyZXNob2xkXyA9IG9wdGlvbnMudGhyZXNob2xkICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnRocmVzaG9sZCA6IDAuMztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmR1cmF0aW9uXyA9IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiAyNTA7XG5cbiAgfVxuXG4gIGlmICggUG9pbnRlckludGVyYWN0aW9uICkgUGluY2hSb3RhdGUuX19wcm90b19fID0gUG9pbnRlckludGVyYWN0aW9uO1xuICBQaW5jaFJvdGF0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQb2ludGVySW50ZXJhY3Rpb24gJiYgUG9pbnRlckludGVyYWN0aW9uLnByb3RvdHlwZSApO1xuICBQaW5jaFJvdGF0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQaW5jaFJvdGF0ZTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIFBpbmNoUm90YXRlLnByb3RvdHlwZS5oYW5kbGVEcmFnRXZlbnQgPSBmdW5jdGlvbiBoYW5kbGVEcmFnRXZlbnQgKG1hcEJyb3dzZXJFdmVudCkge1xuICAgIHZhciByb3RhdGlvbkRlbHRhID0gMC4wO1xuXG4gICAgdmFyIHRvdWNoMCA9IHRoaXMudGFyZ2V0UG9pbnRlcnNbMF07XG4gICAgdmFyIHRvdWNoMSA9IHRoaXMudGFyZ2V0UG9pbnRlcnNbMV07XG5cbiAgICAvLyBhbmdsZSBiZXR3ZWVuIHRvdWNoZXNcbiAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKFxuICAgICAgdG91Y2gxLmNsaWVudFkgLSB0b3VjaDAuY2xpZW50WSxcbiAgICAgIHRvdWNoMS5jbGllbnRYIC0gdG91Y2gwLmNsaWVudFgpO1xuXG4gICAgaWYgKHRoaXMubGFzdEFuZ2xlXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgZGVsdGEgPSBhbmdsZSAtIHRoaXMubGFzdEFuZ2xlXztcbiAgICAgIHRoaXMucm90YXRpb25EZWx0YV8gKz0gZGVsdGE7XG4gICAgICBpZiAoIXRoaXMucm90YXRpbmdfICYmXG4gICAgICAgICAgTWF0aC5hYnModGhpcy5yb3RhdGlvbkRlbHRhXykgPiB0aGlzLnRocmVzaG9sZF8pIHtcbiAgICAgICAgdGhpcy5yb3RhdGluZ18gPSB0cnVlO1xuICAgICAgfVxuICAgICAgcm90YXRpb25EZWx0YSA9IGRlbHRhO1xuICAgIH1cbiAgICB0aGlzLmxhc3RBbmdsZV8gPSBhbmdsZTtcblxuICAgIHZhciBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuICAgIHZhciB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICBpZiAodmlldy5nZXRDb25zdHJhaW50cygpLnJvdGF0aW9uID09PSBkaXNhYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gcm90YXRlIGFuY2hvciBwb2ludC5cbiAgICAvLyBGSVhNRTogc2hvdWxkIGJlIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnQgYmV0d2VlbiB0aGUgbGluZXM6XG4gICAgLy8gICAgIHRvdWNoMCx0b3VjaDEgYW5kIHByZXZpb3VzVG91Y2gwLHByZXZpb3VzVG91Y2gxXG4gICAgdmFyIHZpZXdwb3J0UG9zaXRpb24gPSBtYXAuZ2V0Vmlld3BvcnQoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgY2VudHJvaWQgPSBjZW50cm9pZEZyb21Qb2ludGVycyh0aGlzLnRhcmdldFBvaW50ZXJzKTtcbiAgICBjZW50cm9pZFswXSAtPSB2aWV3cG9ydFBvc2l0aW9uLmxlZnQ7XG4gICAgY2VudHJvaWRbMV0gLT0gdmlld3BvcnRQb3NpdGlvbi50b3A7XG4gICAgdGhpcy5hbmNob3JfID0gbWFwLmdldENvb3JkaW5hdGVGcm9tUGl4ZWwoY2VudHJvaWQpO1xuXG4gICAgLy8gcm90YXRlXG4gICAgaWYgKHRoaXMucm90YXRpbmdfKSB7XG4gICAgICB2YXIgcm90YXRpb24gPSB2aWV3LmdldFJvdGF0aW9uKCk7XG4gICAgICBtYXAucmVuZGVyKCk7XG4gICAgICByb3RhdGVXaXRob3V0Q29uc3RyYWludHModmlldywgcm90YXRpb24gKyByb3RhdGlvbkRlbHRhLCB0aGlzLmFuY2hvcl8pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIFBpbmNoUm90YXRlLnByb3RvdHlwZS5oYW5kbGVVcEV2ZW50ID0gZnVuY3Rpb24gaGFuZGxlVXBFdmVudCAobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKHRoaXMudGFyZ2V0UG9pbnRlcnMubGVuZ3RoIDwgMikge1xuICAgICAgdmFyIG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgICB2YXIgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgICB2aWV3LnNldEhpbnQoVmlld0hpbnQuSU5URVJBQ1RJTkcsIC0xKTtcbiAgICAgIGlmICh0aGlzLnJvdGF0aW5nXykge1xuICAgICAgICB2YXIgcm90YXRpb24gPSB2aWV3LmdldFJvdGF0aW9uKCk7XG4gICAgICAgIHJvdGF0ZSh2aWV3LCByb3RhdGlvbiwgdGhpcy5hbmNob3JfLCB0aGlzLmR1cmF0aW9uXyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIFBpbmNoUm90YXRlLnByb3RvdHlwZS5oYW5kbGVEb3duRXZlbnQgPSBmdW5jdGlvbiBoYW5kbGVEb3duRXZlbnQgKG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGlmICh0aGlzLnRhcmdldFBvaW50ZXJzLmxlbmd0aCA+PSAyKSB7XG4gICAgICB2YXIgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgICAgIHRoaXMuYW5jaG9yXyA9IG51bGw7XG4gICAgICB0aGlzLmxhc3RBbmdsZV8gPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnJvdGF0aW5nXyA9IGZhbHNlO1xuICAgICAgdGhpcy5yb3RhdGlvbkRlbHRhXyA9IDAuMDtcbiAgICAgIGlmICghdGhpcy5oYW5kbGluZ0Rvd25VcFNlcXVlbmNlKSB7XG4gICAgICAgIG1hcC5nZXRWaWV3KCkuc2V0SGludChWaWV3SGludC5JTlRFUkFDVElORywgMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gUGluY2hSb3RhdGU7XG59KFBvaW50ZXJJbnRlcmFjdGlvbikpO1xuXG5leHBvcnQgZGVmYXVsdCBQaW5jaFJvdGF0ZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGluY2hSb3RhdGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL1BpbmNoWm9vbVxuICovXG5pbXBvcnQgVmlld0hpbnQgZnJvbSAnLi4vVmlld0hpbnQuanMnO1xuaW1wb3J0IHtGQUxTRX0gZnJvbSAnLi4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCB7em9vbSwgem9vbVdpdGhvdXRDb25zdHJhaW50c30gZnJvbSAnLi9JbnRlcmFjdGlvbi5qcyc7XG5pbXBvcnQgUG9pbnRlckludGVyYWN0aW9uLCB7Y2VudHJvaWQgYXMgY2VudHJvaWRGcm9tUG9pbnRlcnN9IGZyb20gJy4vUG9pbnRlci5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2R1cmF0aW9uPTQwMF0gQW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2NvbnN0cmFpblJlc29sdXRpb249ZmFsc2VdIFpvb20gdG8gdGhlIGNsb3Nlc3QgaW50ZWdlclxuICogem9vbSBsZXZlbCBhZnRlciB0aGUgcGluY2ggZ2VzdHVyZSBlbmRzLlxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBbGxvd3MgdGhlIHVzZXIgdG8gem9vbSB0aGUgbWFwIGJ5IHBpbmNoaW5nIHdpdGggdHdvIGZpbmdlcnNcbiAqIG9uIGEgdG91Y2ggc2NyZWVuLlxuICogQGFwaVxuICovXG52YXIgUGluY2hab29tID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoUG9pbnRlckludGVyYWN0aW9uKSB7XG4gIGZ1bmN0aW9uIFBpbmNoWm9vbShvcHRfb3B0aW9ucykge1xuXG4gICAgdmFyIG9wdGlvbnMgPSBvcHRfb3B0aW9ucyA/IG9wdF9vcHRpb25zIDoge307XG5cbiAgICB2YXIgcG9pbnRlck9wdGlvbnMgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vUG9pbnRlci5qc1wiKS5PcHRpb25zfSAqLyAob3B0aW9ucyk7XG5cbiAgICBpZiAoIXBvaW50ZXJPcHRpb25zLnN0b3BEb3duKSB7XG4gICAgICBwb2ludGVyT3B0aW9ucy5zdG9wRG93biA9IEZBTFNFO1xuICAgIH1cblxuICAgIFBvaW50ZXJJbnRlcmFjdGlvbi5jYWxsKHRoaXMsIHBvaW50ZXJPcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5jb25zdHJhaW5SZXNvbHV0aW9uXyA9IG9wdGlvbnMuY29uc3RyYWluUmVzb2x1dGlvbiB8fCBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLmFuY2hvcl8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZHVyYXRpb25fID0gb3B0aW9ucy5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kdXJhdGlvbiA6IDQwMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5sYXN0RGlzdGFuY2VfID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGFzdFNjYWxlRGVsdGFfID0gMTtcblxuICB9XG5cbiAgaWYgKCBQb2ludGVySW50ZXJhY3Rpb24gKSBQaW5jaFpvb20uX19wcm90b19fID0gUG9pbnRlckludGVyYWN0aW9uO1xuICBQaW5jaFpvb20ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUG9pbnRlckludGVyYWN0aW9uICYmIFBvaW50ZXJJbnRlcmFjdGlvbi5wcm90b3R5cGUgKTtcbiAgUGluY2hab29tLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBpbmNoWm9vbTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIFBpbmNoWm9vbS5wcm90b3R5cGUuaGFuZGxlRHJhZ0V2ZW50ID0gZnVuY3Rpb24gaGFuZGxlRHJhZ0V2ZW50IChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICB2YXIgc2NhbGVEZWx0YSA9IDEuMDtcblxuICAgIHZhciB0b3VjaDAgPSB0aGlzLnRhcmdldFBvaW50ZXJzWzBdO1xuICAgIHZhciB0b3VjaDEgPSB0aGlzLnRhcmdldFBvaW50ZXJzWzFdO1xuICAgIHZhciBkeCA9IHRvdWNoMC5jbGllbnRYIC0gdG91Y2gxLmNsaWVudFg7XG4gICAgdmFyIGR5ID0gdG91Y2gwLmNsaWVudFkgLSB0b3VjaDEuY2xpZW50WTtcblxuICAgIC8vIGRpc3RhbmNlIGJldHdlZW4gdG91Y2hlc1xuICAgIHZhciBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgICBpZiAodGhpcy5sYXN0RGlzdGFuY2VfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHNjYWxlRGVsdGEgPSB0aGlzLmxhc3REaXN0YW5jZV8gLyBkaXN0YW5jZTtcbiAgICB9XG4gICAgdGhpcy5sYXN0RGlzdGFuY2VfID0gZGlzdGFuY2U7XG5cblxuICAgIHZhciBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuICAgIHZhciB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICB2YXIgcmVzb2x1dGlvbiA9IHZpZXcuZ2V0UmVzb2x1dGlvbigpO1xuICAgIHZhciBtYXhSZXNvbHV0aW9uID0gdmlldy5nZXRNYXhSZXNvbHV0aW9uKCk7XG4gICAgdmFyIG1pblJlc29sdXRpb24gPSB2aWV3LmdldE1pblJlc29sdXRpb24oKTtcbiAgICB2YXIgbmV3UmVzb2x1dGlvbiA9IHJlc29sdXRpb24gKiBzY2FsZURlbHRhO1xuICAgIGlmIChuZXdSZXNvbHV0aW9uID4gbWF4UmVzb2x1dGlvbikge1xuICAgICAgc2NhbGVEZWx0YSA9IG1heFJlc29sdXRpb24gLyByZXNvbHV0aW9uO1xuICAgICAgbmV3UmVzb2x1dGlvbiA9IG1heFJlc29sdXRpb247XG4gICAgfSBlbHNlIGlmIChuZXdSZXNvbHV0aW9uIDwgbWluUmVzb2x1dGlvbikge1xuICAgICAgc2NhbGVEZWx0YSA9IG1pblJlc29sdXRpb24gLyByZXNvbHV0aW9uO1xuICAgICAgbmV3UmVzb2x1dGlvbiA9IG1pblJlc29sdXRpb247XG4gICAgfVxuXG4gICAgaWYgKHNjYWxlRGVsdGEgIT0gMS4wKSB7XG4gICAgICB0aGlzLmxhc3RTY2FsZURlbHRhXyA9IHNjYWxlRGVsdGE7XG4gICAgfVxuXG4gICAgLy8gc2NhbGUgYW5jaG9yIHBvaW50LlxuICAgIHZhciB2aWV3cG9ydFBvc2l0aW9uID0gbWFwLmdldFZpZXdwb3J0KCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIGNlbnRyb2lkID0gY2VudHJvaWRGcm9tUG9pbnRlcnModGhpcy50YXJnZXRQb2ludGVycyk7XG4gICAgY2VudHJvaWRbMF0gLT0gdmlld3BvcnRQb3NpdGlvbi5sZWZ0O1xuICAgIGNlbnRyb2lkWzFdIC09IHZpZXdwb3J0UG9zaXRpb24udG9wO1xuICAgIHRoaXMuYW5jaG9yXyA9IG1hcC5nZXRDb29yZGluYXRlRnJvbVBpeGVsKGNlbnRyb2lkKTtcblxuICAgIC8vIHNjYWxlLCBieXBhc3MgdGhlIHJlc29sdXRpb24gY29uc3RyYWludFxuICAgIG1hcC5yZW5kZXIoKTtcbiAgICB6b29tV2l0aG91dENvbnN0cmFpbnRzKHZpZXcsIG5ld1Jlc29sdXRpb24sIHRoaXMuYW5jaG9yXyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBQaW5jaFpvb20ucHJvdG90eXBlLmhhbmRsZVVwRXZlbnQgPSBmdW5jdGlvbiBoYW5kbGVVcEV2ZW50IChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBpZiAodGhpcy50YXJnZXRQb2ludGVycy5sZW5ndGggPCAyKSB7XG4gICAgICB2YXIgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgICAgIHZhciB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICAgIHZpZXcuc2V0SGludChWaWV3SGludC5JTlRFUkFDVElORywgLTEpO1xuICAgICAgdmFyIHJlc29sdXRpb24gPSB2aWV3LmdldFJlc29sdXRpb24oKTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cmFpblJlc29sdXRpb25fIHx8XG4gICAgICAgICAgcmVzb2x1dGlvbiA8IHZpZXcuZ2V0TWluUmVzb2x1dGlvbigpIHx8XG4gICAgICAgICAgcmVzb2x1dGlvbiA+IHZpZXcuZ2V0TWF4UmVzb2x1dGlvbigpKSB7XG4gICAgICAgIC8vIFpvb20gdG8gZmluYWwgcmVzb2x1dGlvbiwgd2l0aCBhbiBhbmltYXRpb24sIGFuZCBwcm92aWRlIGFcbiAgICAgICAgLy8gZGlyZWN0aW9uIG5vdCB0byB6b29tIG91dC9pbiBpZiB1c2VyIHdhcyBwaW5jaGluZyBpbi9vdXQuXG4gICAgICAgIC8vIERpcmVjdGlvbiBpcyA+IDAgaWYgcGluY2hpbmcgb3V0LCBhbmQgPCAwIGlmIHBpbmNoaW5nIGluLlxuICAgICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5sYXN0U2NhbGVEZWx0YV8gLSAxO1xuICAgICAgICB6b29tKHZpZXcsIHJlc29sdXRpb24sIHRoaXMuYW5jaG9yXywgdGhpcy5kdXJhdGlvbl8sIGRpcmVjdGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIFBpbmNoWm9vbS5wcm90b3R5cGUuaGFuZGxlRG93bkV2ZW50ID0gZnVuY3Rpb24gaGFuZGxlRG93bkV2ZW50IChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBpZiAodGhpcy50YXJnZXRQb2ludGVycy5sZW5ndGggPj0gMikge1xuICAgICAgdmFyIG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgICB0aGlzLmFuY2hvcl8gPSBudWxsO1xuICAgICAgdGhpcy5sYXN0RGlzdGFuY2VfID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5sYXN0U2NhbGVEZWx0YV8gPSAxO1xuICAgICAgaWYgKCF0aGlzLmhhbmRsaW5nRG93blVwU2VxdWVuY2UpIHtcbiAgICAgICAgbWFwLmdldFZpZXcoKS5zZXRIaW50KFZpZXdIaW50LklOVEVSQUNUSU5HLCAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBQaW5jaFpvb207XG59KFBvaW50ZXJJbnRlcmFjdGlvbikpO1xuXG5leHBvcnQgZGVmYXVsdCBQaW5jaFpvb207XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBpbmNoWm9vbS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vUG9pbnRlclxuICovXG5pbXBvcnQgTWFwQnJvd3NlckV2ZW50VHlwZSBmcm9tICcuLi9NYXBCcm93c2VyRXZlbnRUeXBlLmpzJztcbmltcG9ydCBJbnRlcmFjdGlvbiBmcm9tICcuL0ludGVyYWN0aW9uLmpzJztcbmltcG9ydCB7Z2V0VmFsdWVzfSBmcm9tICcuLi9vYmouanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtmdW5jdGlvbihpbXBvcnQoXCIuLi9NYXBCcm93c2VyUG9pbnRlckV2ZW50LmpzXCIpLmRlZmF1bHQpOmJvb2xlYW59IFtoYW5kbGVEb3duRXZlbnRdXG4gKiBGdW5jdGlvbiBoYW5kbGluZyBcImRvd25cIiBldmVudHMuIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIGB0cnVlYCB0aGVuIGEgZHJhZ1xuICogc2VxdWVuY2UgaXMgc3RhcnRlZC5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vTWFwQnJvd3NlclBvaW50ZXJFdmVudC5qc1wiKS5kZWZhdWx0KX0gW2hhbmRsZURyYWdFdmVudF1cbiAqIEZ1bmN0aW9uIGhhbmRsaW5nIFwiZHJhZ1wiIGV2ZW50cy4gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gXCJtb3ZlXCIgZXZlbnRzXG4gKiBkdXJpbmcgYSBkcmFnIHNlcXVlbmNlLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbihpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdCk6Ym9vbGVhbn0gW2hhbmRsZUV2ZW50XVxuICogTWV0aG9kIGNhbGxlZCBieSB0aGUgbWFwIHRvIG5vdGlmeSB0aGUgaW50ZXJhY3Rpb24gdGhhdCBhIGJyb3dzZXIgZXZlbnQgd2FzXG4gKiBkaXNwYXRjaGVkIHRvIHRoZSBtYXAuIFRoZSBmdW5jdGlvbiBtYXkgcmV0dXJuIGBmYWxzZWAgdG8gcHJldmVudCB0aGVcbiAqIHByb3BhZ2F0aW9uIG9mIHRoZSBldmVudCB0byBvdGhlciBpbnRlcmFjdGlvbnMgaW4gdGhlIG1hcCdzIGludGVyYWN0aW9uc1xuICogY2hhaW4uXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGltcG9ydChcIi4uL01hcEJyb3dzZXJQb2ludGVyRXZlbnQuanNcIikuZGVmYXVsdCl9IFtoYW5kbGVNb3ZlRXZlbnRdXG4gKiBGdW5jdGlvbiBoYW5kbGluZyBcIm1vdmVcIiBldmVudHMuIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIFwibW92ZVwiIGV2ZW50cyxcbiAqIGFsc28gZHVyaW5nIGEgZHJhZyBzZXF1ZW5jZSAoc28gZHVyaW5nIGEgZHJhZyBzZXF1ZW5jZSBib3RoIHRoZVxuICogYGhhbmRsZURyYWdFdmVudGAgZnVuY3Rpb24gYW5kIHRoaXMgZnVuY3Rpb24gYXJlIGNhbGxlZCkuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGltcG9ydChcIi4uL01hcEJyb3dzZXJQb2ludGVyRXZlbnQuanNcIikuZGVmYXVsdCk6Ym9vbGVhbn0gW2hhbmRsZVVwRXZlbnRdXG4gKiAgRnVuY3Rpb24gaGFuZGxpbmcgXCJ1cFwiIGV2ZW50cy4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYCB0aGVuIHRoZVxuICogY3VycmVudCBkcmFnIHNlcXVlbmNlIGlzIHN0b3BwZWQuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGJvb2xlYW4pOmJvb2xlYW59IFtzdG9wRG93bl1cbiAqIFNob3VsZCB0aGUgZG93biBldmVudCBiZSBwcm9wYWdhdGVkIHRvIG90aGVyIGludGVyYWN0aW9ucywgb3Igc2hvdWxkIGJlXG4gKiBzdG9wcGVkP1xuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBCYXNlIGNsYXNzIHRoYXQgY2FsbHMgdXNlci1kZWZpbmVkIGZ1bmN0aW9ucyBvbiBgZG93bmAsIGBtb3ZlYCBhbmQgYHVwYFxuICogZXZlbnRzLiBUaGlzIGNsYXNzIGFsc28gbWFuYWdlcyBcImRyYWcgc2VxdWVuY2VzXCIuXG4gKlxuICogV2hlbiB0aGUgYGhhbmRsZURvd25FdmVudGAgdXNlciBmdW5jdGlvbiByZXR1cm5zIGB0cnVlYCBhIGRyYWcgc2VxdWVuY2UgaXNcbiAqIHN0YXJ0ZWQuIER1cmluZyBhIGRyYWcgc2VxdWVuY2UgdGhlIGBoYW5kbGVEcmFnRXZlbnRgIHVzZXIgZnVuY3Rpb24gaXNcbiAqIGNhbGxlZCBvbiBgbW92ZWAgZXZlbnRzLiBUaGUgZHJhZyBzZXF1ZW5jZSBlbmRzIHdoZW4gdGhlIGBoYW5kbGVVcEV2ZW50YFxuICogdXNlciBmdW5jdGlvbiBpcyBjYWxsZWQgYW5kIHJldHVybnMgYGZhbHNlYC5cbiAqIEBhcGlcbiAqL1xudmFyIFBvaW50ZXJJbnRlcmFjdGlvbiA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEludGVyYWN0aW9uKSB7XG4gIGZ1bmN0aW9uIFBvaW50ZXJJbnRlcmFjdGlvbihvcHRfb3B0aW9ucykge1xuXG4gICAgdmFyIG9wdGlvbnMgPSBvcHRfb3B0aW9ucyA/IG9wdF9vcHRpb25zIDoge307XG5cbiAgICBJbnRlcmFjdGlvbi5jYWxsKC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9JbnRlcmFjdGlvbi5qc1wiKS5JbnRlcmFjdGlvbk9wdGlvbnN9ICovIHRoaXMsIChvcHRpb25zKSk7XG5cbiAgICBpZiAob3B0aW9ucy5oYW5kbGVEb3duRXZlbnQpIHtcbiAgICAgIHRoaXMuaGFuZGxlRG93bkV2ZW50ID0gb3B0aW9ucy5oYW5kbGVEb3duRXZlbnQ7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaGFuZGxlRHJhZ0V2ZW50KSB7XG4gICAgICB0aGlzLmhhbmRsZURyYWdFdmVudCA9IG9wdGlvbnMuaGFuZGxlRHJhZ0V2ZW50O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmhhbmRsZU1vdmVFdmVudCkge1xuICAgICAgdGhpcy5oYW5kbGVNb3ZlRXZlbnQgPSBvcHRpb25zLmhhbmRsZU1vdmVFdmVudDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5oYW5kbGVVcEV2ZW50KSB7XG4gICAgICB0aGlzLmhhbmRsZVVwRXZlbnQgPSBvcHRpb25zLmhhbmRsZVVwRXZlbnQ7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc3RvcERvd24pIHtcbiAgICAgIHRoaXMuc3RvcERvd24gPSBvcHRpb25zLnN0b3BEb3duO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0aGlzLmhhbmRsaW5nRG93blVwU2VxdWVuY2UgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4vcG9pbnRlci9Qb2ludGVyRXZlbnQuanNcIikuZGVmYXVsdD59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnRyYWNrZWRQb2ludGVyc18gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuLi9wb2ludGVyL1BvaW50ZXJFdmVudC5qc1wiKS5kZWZhdWx0Pn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdGhpcy50YXJnZXRQb2ludGVycyA9IFtdO1xuXG4gIH1cblxuICBpZiAoIEludGVyYWN0aW9uICkgUG9pbnRlckludGVyYWN0aW9uLl9fcHJvdG9fXyA9IEludGVyYWN0aW9uO1xuICBQb2ludGVySW50ZXJhY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSW50ZXJhY3Rpb24gJiYgSW50ZXJhY3Rpb24ucHJvdG90eXBlICk7XG4gIFBvaW50ZXJJbnRlcmFjdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQb2ludGVySW50ZXJhY3Rpb247XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBwb2ludGVyIGRvd24gZXZlbnRzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJQb2ludGVyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IEV2ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJZiB0aGUgZXZlbnQgd2FzIGNvbnN1bWVkLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBQb2ludGVySW50ZXJhY3Rpb24ucHJvdG90eXBlLmhhbmRsZURvd25FdmVudCA9IGZ1bmN0aW9uIGhhbmRsZURvd25FdmVudCAobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgcG9pbnRlciBkcmFnIGV2ZW50cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyUG9pbnRlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgUG9pbnRlckludGVyYWN0aW9uLnByb3RvdHlwZS5oYW5kbGVEcmFnRXZlbnQgPSBmdW5jdGlvbiBoYW5kbGVEcmFnRXZlbnQgKG1hcEJyb3dzZXJFdmVudCkge307XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50IG1hcCBicm93c2VyIGV2ZW50fSBhbmQgbWF5IGNhbGwgaW50b1xuICAgKiBvdGhlciBmdW5jdGlvbnMsIGlmIGV2ZW50IHNlcXVlbmNlcyBsaWtlIGUuZy4gJ2RyYWcnIG9yICdkb3duLXVwJyBldGMuIGFyZVxuICAgKiBkZXRlY3RlZC5cbiAgICogQG92ZXJyaWRlXG4gICAqIEBhcGlcbiAgICovXG4gIFBvaW50ZXJJbnRlcmFjdGlvbi5wcm90b3R5cGUuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiBoYW5kbGVFdmVudCAobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKCEoLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyUG9pbnRlckV2ZW50LmpzXCIpLmRlZmF1bHR9ICovIChtYXBCcm93c2VyRXZlbnQpLnBvaW50ZXJFdmVudCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBzdG9wRXZlbnQgPSBmYWxzZTtcbiAgICB0aGlzLnVwZGF0ZVRyYWNrZWRQb2ludGVyc18obWFwQnJvd3NlckV2ZW50KTtcbiAgICBpZiAodGhpcy5oYW5kbGluZ0Rvd25VcFNlcXVlbmNlKSB7XG4gICAgICBpZiAobWFwQnJvd3NlckV2ZW50LnR5cGUgPT0gTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSRFJBRykge1xuICAgICAgICB0aGlzLmhhbmRsZURyYWdFdmVudChtYXBCcm93c2VyRXZlbnQpO1xuICAgICAgfSBlbHNlIGlmIChtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJVUCkge1xuICAgICAgICB2YXIgaGFuZGxlZFVwID0gdGhpcy5oYW5kbGVVcEV2ZW50KG1hcEJyb3dzZXJFdmVudCk7XG4gICAgICAgIHRoaXMuaGFuZGxpbmdEb3duVXBTZXF1ZW5jZSA9IGhhbmRsZWRVcCAmJiB0aGlzLnRhcmdldFBvaW50ZXJzLmxlbmd0aCA+IDA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJET1dOKSB7XG4gICAgICAgIHZhciBoYW5kbGVkID0gdGhpcy5oYW5kbGVEb3duRXZlbnQobWFwQnJvd3NlckV2ZW50KTtcbiAgICAgICAgaWYgKGhhbmRsZWQpIHtcbiAgICAgICAgICBtYXBCcm93c2VyRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhbmRsaW5nRG93blVwU2VxdWVuY2UgPSBoYW5kbGVkO1xuICAgICAgICBzdG9wRXZlbnQgPSB0aGlzLnN0b3BEb3duKGhhbmRsZWQpO1xuICAgICAgfSBlbHNlIGlmIChtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJNT1ZFKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlTW92ZUV2ZW50KG1hcEJyb3dzZXJFdmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAhc3RvcEV2ZW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgcG9pbnRlciBtb3ZlIGV2ZW50cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyUG9pbnRlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgUG9pbnRlckludGVyYWN0aW9uLnByb3RvdHlwZS5oYW5kbGVNb3ZlRXZlbnQgPSBmdW5jdGlvbiBoYW5kbGVNb3ZlRXZlbnQgKG1hcEJyb3dzZXJFdmVudCkge307XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBwb2ludGVyIHVwIGV2ZW50cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyUG9pbnRlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIGV2ZW50IHdhcyBjb25zdW1lZC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgUG9pbnRlckludGVyYWN0aW9uLnByb3RvdHlwZS5oYW5kbGVVcEV2ZW50ID0gZnVuY3Rpb24gaGFuZGxlVXBFdmVudCAobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIFwiZG93blwiIGV2ZW50cyBzaG91bGQgYmUgcHJvcGFnYXRlZFxuICAgKiB0byBvdGhlciBpbnRlcmFjdGlvbnMgb3Igc2hvdWxkIGJlIHN0b3BwZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFuZGxlZCBXYXMgdGhlIGV2ZW50IGhhbmRsZWQgYnkgdGhlIGludGVyYWN0aW9uP1xuICAgKiBAcmV0dXJuIHtib29sZWFufSBTaG91bGQgdGhlIGBkb3duYCBldmVudCBiZSBzdG9wcGVkP1xuICAgKi9cbiAgUG9pbnRlckludGVyYWN0aW9uLnByb3RvdHlwZS5zdG9wRG93biA9IGZ1bmN0aW9uIHN0b3BEb3duIChoYW5kbGVkKSB7XG4gICAgcmV0dXJuIGhhbmRsZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlclBvaW50ZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgRXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBQb2ludGVySW50ZXJhY3Rpb24ucHJvdG90eXBlLnVwZGF0ZVRyYWNrZWRQb2ludGVyc18gPSBmdW5jdGlvbiB1cGRhdGVUcmFja2VkUG9pbnRlcnNfIChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBpZiAoaXNQb2ludGVyRHJhZ2dpbmdFdmVudChtYXBCcm93c2VyRXZlbnQpKSB7XG4gICAgICB2YXIgZXZlbnQgPSBtYXBCcm93c2VyRXZlbnQucG9pbnRlckV2ZW50O1xuXG4gICAgICB2YXIgaWQgPSBldmVudC5wb2ludGVySWQudG9TdHJpbmcoKTtcbiAgICAgIGlmIChtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJVUCkge1xuICAgICAgICBkZWxldGUgdGhpcy50cmFja2VkUG9pbnRlcnNfW2lkXTtcbiAgICAgIH0gZWxzZSBpZiAobWFwQnJvd3NlckV2ZW50LnR5cGUgPT1cbiAgICAgICAgICBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJET1dOKSB7XG4gICAgICAgIHRoaXMudHJhY2tlZFBvaW50ZXJzX1tpZF0gPSBldmVudDtcbiAgICAgIH0gZWxzZSBpZiAoaWQgaW4gdGhpcy50cmFja2VkUG9pbnRlcnNfKSB7XG4gICAgICAgIC8vIHVwZGF0ZSBvbmx5IHdoZW4gdGhlcmUgd2FzIGEgcG9pbnRlcmRvd24gZXZlbnQgZm9yIHRoaXMgcG9pbnRlclxuICAgICAgICB0aGlzLnRyYWNrZWRQb2ludGVyc19baWRdID0gZXZlbnQ7XG4gICAgICB9XG4gICAgICB0aGlzLnRhcmdldFBvaW50ZXJzID0gZ2V0VmFsdWVzKHRoaXMudHJhY2tlZFBvaW50ZXJzXyk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBQb2ludGVySW50ZXJhY3Rpb247XG59KEludGVyYWN0aW9uKSk7XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4uL3BvaW50ZXIvUG9pbnRlckV2ZW50LmpzXCIpLmRlZmF1bHQ+fSBwb2ludGVyRXZlbnRzIExpc3Qgb2YgZXZlbnRzLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vcGl4ZWwuanNcIikuUGl4ZWx9IENlbnRyb2lkIHBpeGVsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2VudHJvaWQocG9pbnRlckV2ZW50cykge1xuICB2YXIgbGVuZ3RoID0gcG9pbnRlckV2ZW50cy5sZW5ndGg7XG4gIHZhciBjbGllbnRYID0gMDtcbiAgdmFyIGNsaWVudFkgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY2xpZW50WCArPSBwb2ludGVyRXZlbnRzW2ldLmNsaWVudFg7XG4gICAgY2xpZW50WSArPSBwb2ludGVyRXZlbnRzW2ldLmNsaWVudFk7XG4gIH1cbiAgcmV0dXJuIFtjbGllbnRYIC8gbGVuZ3RoLCBjbGllbnRZIC8gbGVuZ3RoXTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlclBvaW50ZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgRXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBldmVudCBpcyBhIHBvaW50ZXJkb3duLCBwb2ludGVyZHJhZ1xuICogICAgIG9yIHBvaW50ZXJ1cCBldmVudC5cbiAqL1xuZnVuY3Rpb24gaXNQb2ludGVyRHJhZ2dpbmdFdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgdmFyIHR5cGUgPSBtYXBCcm93c2VyRXZlbnQudHlwZTtcbiAgcmV0dXJuIHR5cGUgPT09IE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUkRPV04gfHxcbiAgICB0eXBlID09PSBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJEUkFHIHx8XG4gICAgdHlwZSA9PT0gTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSVVA7XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgUG9pbnRlckludGVyYWN0aW9uO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qb2ludGVyLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9Qcm9wZXJ0eVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBBQ1RJVkU6ICdhY3RpdmUnXG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qcm9wZXJ0eS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vU2VsZWN0XG4gKi9cbmltcG9ydCB7Z2V0VWlkfSBmcm9tICcuLi91dGlsLmpzJztcbmltcG9ydCBDb2xsZWN0aW9uRXZlbnRUeXBlIGZyb20gJy4uL0NvbGxlY3Rpb25FdmVudFR5cGUuanMnO1xuaW1wb3J0IHtleHRlbmQsIGluY2x1ZGVzfSBmcm9tICcuLi9hcnJheS5qcyc7XG5pbXBvcnQge2xpc3Rlbn0gZnJvbSAnLi4vZXZlbnRzLmpzJztcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMvRXZlbnQuanMnO1xuaW1wb3J0IHtzaW5nbGVDbGljaywgbmV2ZXIsIHNoaWZ0S2V5T25seSwgcG9pbnRlck1vdmV9IGZyb20gJy4uL2V2ZW50cy9jb25kaXRpb24uanMnO1xuaW1wb3J0IHtUUlVFfSBmcm9tICcuLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IEdlb21ldHJ5VHlwZSBmcm9tICcuLi9nZW9tL0dlb21ldHJ5VHlwZS5qcyc7XG5pbXBvcnQgSW50ZXJhY3Rpb24gZnJvbSAnLi9JbnRlcmFjdGlvbi5qcyc7XG5pbXBvcnQgVmVjdG9yTGF5ZXIgZnJvbSAnLi4vbGF5ZXIvVmVjdG9yLmpzJztcbmltcG9ydCB7Y2xlYXJ9IGZyb20gJy4uL29iai5qcyc7XG5pbXBvcnQgVmVjdG9yU291cmNlIGZyb20gJy4uL3NvdXJjZS9WZWN0b3IuanMnO1xuaW1wb3J0IHtjcmVhdGVFZGl0aW5nU3R5bGV9IGZyb20gJy4uL3N0eWxlL1N0eWxlLmpzJztcblxuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbnZhciBTZWxlY3RFdmVudFR5cGUgPSB7XG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiBmZWF0dXJlKHMpIGhhcyBiZWVuIChkZSlzZWxlY3RlZC5cbiAgICogQGV2ZW50IFNlbGVjdEV2ZW50I3NlbGVjdFxuICAgKiBAYXBpXG4gICAqL1xuICBTRUxFQ1Q6ICdzZWxlY3QnXG59O1xuXG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvRmVhdHVyZX0gb3JcbiAqIHtAbGluayBtb2R1bGU6b2wvcmVuZGVyL0ZlYXR1cmV9IGFuZCBhblxuICoge0BsaW5rIG1vZHVsZTpvbC9sYXllci9MYXllcn0gYW5kIHJldHVybnMgYHRydWVgIGlmIHRoZSBmZWF0dXJlIG1heSBiZVxuICogc2VsZWN0ZWQgb3IgYGZhbHNlYCBvdGhlcndpc2UuXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZSwgaW1wb3J0KFwiLi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdCk6Ym9vbGVhbn0gRmlsdGVyRnVuY3Rpb25cbiAqL1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn0gW2FkZENvbmRpdGlvbl0gQSBmdW5jdGlvblxuICogdGhhdCB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnR9IGFuZCByZXR1cm5zIGFcbiAqIGJvb2xlYW4gdG8gaW5kaWNhdGUgd2hldGhlciB0aGF0IGV2ZW50IHNob3VsZCBiZSBoYW5kbGVkLlxuICogQnkgZGVmYXVsdCwgdGhpcyBpcyB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb25+bmV2ZXJ9LiBVc2UgdGhpcyBpZiB5b3VcbiAqIHdhbnQgdG8gdXNlIGRpZmZlcmVudCBldmVudHMgZm9yIGFkZCBhbmQgcmVtb3ZlIGluc3RlYWQgb2YgYHRvZ2dsZWAuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufSBbY29uZGl0aW9uXSBBIGZ1bmN0aW9uIHRoYXRcbiAqIHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0gYW5kIHJldHVybnMgYVxuICogYm9vbGVhbiB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoYXQgZXZlbnQgc2hvdWxkIGJlIGhhbmRsZWQuIFRoaXMgaXMgdGhlIGV2ZW50XG4gKiBmb3IgdGhlIHNlbGVjdGVkIGZlYXR1cmVzIGFzIGEgd2hvbGUuIEJ5IGRlZmF1bHQsIHRoaXMgaXNcbiAqIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbn5zaW5nbGVDbGlja30uIENsaWNraW5nIG9uIGEgZmVhdHVyZSBzZWxlY3RzIHRoYXRcbiAqIGZlYXR1cmUgYW5kIHJlbW92ZXMgYW55IHRoYXQgd2VyZSBpbiB0aGUgc2VsZWN0aW9uLiBDbGlja2luZyBvdXRzaWRlIGFueVxuICogZmVhdHVyZSByZW1vdmVzIGFsbCBmcm9tIHRoZSBzZWxlY3Rpb24uXG4gKiBTZWUgYHRvZ2dsZWAsIGBhZGRgLCBgcmVtb3ZlYCBvcHRpb25zIGZvciBhZGRpbmcvcmVtb3ZpbmcgZXh0cmEgZmVhdHVyZXMgdG8vXG4gKiBmcm9tIHRoZSBzZWxlY3Rpb24uXG4gKiBAcHJvcGVydHkge0FycmF5PGltcG9ydChcIi4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHQ+fGZ1bmN0aW9uKGltcG9ydChcIi4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHQpOiBib29sZWFufSBbbGF5ZXJzXVxuICogQSBsaXN0IG9mIGxheWVycyBmcm9tIHdoaWNoIGZlYXR1cmVzIHNob3VsZCBiZSBzZWxlY3RlZC4gQWx0ZXJuYXRpdmVseSwgYVxuICogZmlsdGVyIGZ1bmN0aW9uIGNhbiBiZSBwcm92aWRlZC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIGxheWVyXG4gKiBpbiB0aGUgbWFwIGFuZCBzaG91bGQgcmV0dXJuIGB0cnVlYCBmb3IgbGF5ZXJzIHRoYXQgeW91IHdhbnQgdG8gYmVcbiAqIHNlbGVjdGFibGUuIElmIHRoZSBvcHRpb24gaXMgYWJzZW50LCBhbGwgdmlzaWJsZSBsYXllcnMgd2lsbCBiZSBjb25zaWRlcmVkXG4gKiBzZWxlY3RhYmxlLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUxpa2V9IFtzdHlsZV1cbiAqIFN0eWxlIGZvciB0aGUgc2VsZWN0ZWQgZmVhdHVyZXMuIEJ5IGRlZmF1bHQgdGhlIGRlZmF1bHQgZWRpdCBzdHlsZSBpcyB1c2VkXG4gKiAoc2VlIHtAbGluayBtb2R1bGU6b2wvc3R5bGV9KS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259IFtyZW1vdmVDb25kaXRpb25dIEEgZnVuY3Rpb25cbiAqIHRoYXQgdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmQgcmV0dXJucyBhXG4gKiBib29sZWFuIHRvIGluZGljYXRlIHdoZXRoZXIgdGhhdCBldmVudCBzaG91bGQgYmUgaGFuZGxlZC5cbiAqIEJ5IGRlZmF1bHQsIHRoaXMgaXMge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9ufm5ldmVyfS4gVXNlIHRoaXMgaWYgeW91XG4gKiB3YW50IHRvIHVzZSBkaWZmZXJlbnQgZXZlbnRzIGZvciBhZGQgYW5kIHJlbW92ZSBpbnN0ZWFkIG9mIGB0b2dnbGVgLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn0gW3RvZ2dsZUNvbmRpdGlvbl0gQSBmdW5jdGlvblxuICogdGhhdCB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnR9IGFuZCByZXR1cm5zIGFcbiAqIGJvb2xlYW4gdG8gaW5kaWNhdGUgd2hldGhlciB0aGF0IGV2ZW50IHNob3VsZCBiZSBoYW5kbGVkLiBUaGlzIGlzIGluIGFkZGl0aW9uXG4gKiB0byB0aGUgYGNvbmRpdGlvbmAgZXZlbnQuIEJ5IGRlZmF1bHQsXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb25+c2hpZnRLZXlPbmx5fSwgaS5lLiBwcmVzc2luZyBgc2hpZnRgIGFzXG4gKiB3ZWxsIGFzIHRoZSBgY29uZGl0aW9uYCBldmVudCwgYWRkcyB0aGF0IGZlYXR1cmUgdG8gdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGlmXG4gKiBpdCBpcyBub3QgY3VycmVudGx5IHNlbGVjdGVkLCBhbmQgcmVtb3ZlcyBpdCBpZiBpdCBpcy4gU2VlIGBhZGRgIGFuZCBgcmVtb3ZlYFxuICogaWYgeW91IHdhbnQgdG8gdXNlIGRpZmZlcmVudCBldmVudHMgaW5zdGVhZCBvZiBhIHRvZ2dsZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW211bHRpPWZhbHNlXSBBIGJvb2xlYW4gdGhhdCBkZXRlcm1pbmVzIGlmIHRoZSBkZWZhdWx0XG4gKiBiZWhhdmlvdXIgc2hvdWxkIHNlbGVjdCBvbmx5IHNpbmdsZSBmZWF0dXJlcyBvciBhbGwgKG92ZXJsYXBwaW5nKSBmZWF0dXJlcyBhdFxuICogdGhlIGNsaWNrZWQgbWFwIHBvc2l0aW9uLiBUaGUgZGVmYXVsdCBvZiBgZmFsc2VgIG1lYW5zIHNpbmdsZSBzZWxlY3QuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL0NvbGxlY3Rpb24uanNcIikuZGVmYXVsdDxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fSBbZmVhdHVyZXNdXG4gKiBDb2xsZWN0aW9uIHdoZXJlIHRoZSBpbnRlcmFjdGlvbiB3aWxsIHBsYWNlIHNlbGVjdGVkIGZlYXR1cmVzLiBPcHRpb25hbC4gSWZcbiAqIG5vdCBzZXQgdGhlIGludGVyYWN0aW9uIHdpbGwgY3JlYXRlIGEgY29sbGVjdGlvbi4gSW4gYW55IGNhc2UgdGhlIGNvbGxlY3Rpb25cbiAqIHVzZWQgYnkgdGhlIGludGVyYWN0aW9uIGlzIHJldHVybmVkIGJ5XG4gKiB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL1NlbGVjdH5TZWxlY3QjZ2V0RmVhdHVyZXN9LlxuICogQHByb3BlcnR5IHtGaWx0ZXJGdW5jdGlvbn0gW2ZpbHRlcl0gQSBmdW5jdGlvblxuICogdGhhdCB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL0ZlYXR1cmV9IGFuZCBhblxuICoge0BsaW5rIG1vZHVsZTpvbC9sYXllci9MYXllcn0gYW5kIHJldHVybnMgYHRydWVgIGlmIHRoZSBmZWF0dXJlIG1heSBiZVxuICogc2VsZWN0ZWQgb3IgYGZhbHNlYCBvdGhlcndpc2UuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt3cmFwWD10cnVlXSBXcmFwIHRoZSB3b3JsZCBob3Jpem9udGFsbHkgb24gdGhlIHNlbGVjdGlvblxuICogb3ZlcmxheS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbaGl0VG9sZXJhbmNlPTBdIEhpdC1kZXRlY3Rpb24gdG9sZXJhbmNlLiBQaXhlbHMgaW5zaWRlXG4gKiB0aGUgcmFkaXVzIGFyb3VuZCB0aGUgZ2l2ZW4gcG9zaXRpb24gd2lsbCBiZSBjaGVja2VkIGZvciBmZWF0dXJlcy4gVGhpcyBvbmx5XG4gKiB3b3JrcyBmb3IgdGhlIGNhbnZhcyByZW5kZXJlciBhbmQgbm90IGZvciBXZWJHTC5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogRXZlbnRzIGVtaXR0ZWQgYnkge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9TZWxlY3R+U2VsZWN0fSBpbnN0YW5jZXMgYXJlIGluc3RhbmNlcyBvZlxuICogdGhpcyB0eXBlLlxuICovXG52YXIgU2VsZWN0RXZlbnQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChFdmVudCkge1xuICBmdW5jdGlvbiBTZWxlY3RFdmVudCh0eXBlLCBzZWxlY3RlZCwgZGVzZWxlY3RlZCwgbWFwQnJvd3NlckV2ZW50KSB7XG4gICAgRXZlbnQuY2FsbCh0aGlzLCB0eXBlKTtcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdGVkIGZlYXR1cmVzIGFycmF5LlxuICAgICAqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG5cbiAgICAvKipcbiAgICAgKiBEZXNlbGVjdGVkIGZlYXR1cmVzIGFycmF5LlxuICAgICAqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLmRlc2VsZWN0ZWQgPSBkZXNlbGVjdGVkO1xuXG4gICAgLyoqXG4gICAgICogQXNzb2NpYXRlZCB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH0uXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLm1hcEJyb3dzZXJFdmVudCA9IG1hcEJyb3dzZXJFdmVudDtcblxuICB9XG5cbiAgaWYgKCBFdmVudCApIFNlbGVjdEV2ZW50Ll9fcHJvdG9fXyA9IEV2ZW50O1xuICBTZWxlY3RFdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFdmVudCAmJiBFdmVudC5wcm90b3R5cGUgKTtcbiAgU2VsZWN0RXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2VsZWN0RXZlbnQ7XG5cbiAgcmV0dXJuIFNlbGVjdEV2ZW50O1xufShFdmVudCkpO1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogSW50ZXJhY3Rpb24gZm9yIHNlbGVjdGluZyB2ZWN0b3IgZmVhdHVyZXMuIEJ5IGRlZmF1bHQsIHNlbGVjdGVkIGZlYXR1cmVzIGFyZVxuICogc3R5bGVkIGRpZmZlcmVudGx5LCBzbyB0aGlzIGludGVyYWN0aW9uIGNhbiBiZSB1c2VkIGZvciB2aXN1YWwgaGlnaGxpZ2h0aW5nLFxuICogYXMgd2VsbCBhcyBzZWxlY3RpbmcgZmVhdHVyZXMgZm9yIG90aGVyIGFjdGlvbnMsIHN1Y2ggYXMgbW9kaWZpY2F0aW9uIG9yXG4gKiBvdXRwdXQuIFRoZXJlIGFyZSB0aHJlZSB3YXlzIG9mIGNvbnRyb2xsaW5nIHdoaWNoIGZlYXR1cmVzIGFyZSBzZWxlY3RlZDpcbiAqIHVzaW5nIHRoZSBicm93c2VyIGV2ZW50IGFzIGRlZmluZWQgYnkgdGhlIGBjb25kaXRpb25gIGFuZCBvcHRpb25hbGx5IHRoZVxuICogYHRvZ2dsZWAsIGBhZGRgL2ByZW1vdmVgLCBhbmQgYG11bHRpYCBvcHRpb25zOyBhIGBsYXllcnNgIGZpbHRlcjsgYW5kIGFcbiAqIGZ1cnRoZXIgZmVhdHVyZSBmaWx0ZXIgdXNpbmcgdGhlIGBmaWx0ZXJgIG9wdGlvbi5cbiAqXG4gKiBTZWxlY3RlZCBmZWF0dXJlcyBhcmUgYWRkZWQgdG8gYW4gaW50ZXJuYWwgdW5tYW5hZ2VkIGxheWVyLlxuICpcbiAqIEBmaXJlcyBTZWxlY3RFdmVudFxuICogQGFwaVxuICovXG52YXIgU2VsZWN0ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoSW50ZXJhY3Rpb24pIHtcbiAgZnVuY3Rpb24gU2VsZWN0KG9wdF9vcHRpb25zKSB7XG5cbiAgICBJbnRlcmFjdGlvbi5jYWxsKHRoaXMsIHtcbiAgICAgIGhhbmRsZUV2ZW50OiBoYW5kbGVFdmVudFxuICAgIH0pO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBvcHRfb3B0aW9ucyA/IG9wdF9vcHRpb25zIDoge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbmRpdGlvbl8gPSBvcHRpb25zLmNvbmRpdGlvbiA/IG9wdGlvbnMuY29uZGl0aW9uIDogc2luZ2xlQ2xpY2s7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmFkZENvbmRpdGlvbl8gPSBvcHRpb25zLmFkZENvbmRpdGlvbiA/IG9wdGlvbnMuYWRkQ29uZGl0aW9uIDogbmV2ZXI7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbW92ZUNvbmRpdGlvbl8gPSBvcHRpb25zLnJlbW92ZUNvbmRpdGlvbiA/IG9wdGlvbnMucmVtb3ZlQ29uZGl0aW9uIDogbmV2ZXI7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLnRvZ2dsZUNvbmRpdGlvbl8gPSBvcHRpb25zLnRvZ2dsZUNvbmRpdGlvbiA/IG9wdGlvbnMudG9nZ2xlQ29uZGl0aW9uIDogc2hpZnRLZXlPbmx5O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLm11bHRpXyA9IG9wdGlvbnMubXVsdGkgPyBvcHRpb25zLm11bHRpIDogZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtGaWx0ZXJGdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmZpbHRlcl8gPSBvcHRpb25zLmZpbHRlciA/IG9wdGlvbnMuZmlsdGVyIDogVFJVRTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmhpdFRvbGVyYW5jZV8gPSBvcHRpb25zLmhpdFRvbGVyYW5jZSA/IG9wdGlvbnMuaGl0VG9sZXJhbmNlIDogMDtcblxuICAgIHZhciBmZWF0dXJlT3ZlcmxheSA9IG5ldyBWZWN0b3JMYXllcih7XG4gICAgICBzb3VyY2U6IG5ldyBWZWN0b3JTb3VyY2Uoe1xuICAgICAgICB1c2VTcGF0aWFsSW5kZXg6IGZhbHNlLFxuICAgICAgICBmZWF0dXJlczogb3B0aW9ucy5mZWF0dXJlcyxcbiAgICAgICAgd3JhcFg6IG9wdGlvbnMud3JhcFhcbiAgICAgIH0pLFxuICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUgPyBvcHRpb25zLnN0eWxlIDpcbiAgICAgICAgZ2V0RGVmYXVsdFN0eWxlRnVuY3Rpb24oKSxcbiAgICAgIHVwZGF0ZVdoaWxlQW5pbWF0aW5nOiB0cnVlLFxuICAgICAgdXBkYXRlV2hpbGVJbnRlcmFjdGluZzogdHJ1ZVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7VmVjdG9yTGF5ZXJ9XG4gICAgICovXG4gICAgdGhpcy5mZWF0dXJlT3ZlcmxheV8gPSBmZWF0dXJlT3ZlcmxheTtcblxuICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdCk6IGJvb2xlYW59ICovXG4gICAgdmFyIGxheWVyRmlsdGVyO1xuICAgIGlmIChvcHRpb25zLmxheWVycykge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmxheWVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBsYXllckZpbHRlciA9IG9wdGlvbnMubGF5ZXJzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGxheWVycyA9IG9wdGlvbnMubGF5ZXJzO1xuICAgICAgICBsYXllckZpbHRlciA9IGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgICAgICAgcmV0dXJuIGluY2x1ZGVzKGxheWVycywgbGF5ZXIpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsYXllckZpbHRlciA9IFRSVUU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdCk6IGJvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5sYXllckZpbHRlcl8gPSBsYXllckZpbHRlcjtcblxuICAgIC8qKlxuICAgICAqIEFuIGFzc29jaWF0aW9uIGJldHdlZW4gc2VsZWN0ZWQgZmVhdHVyZSAoa2V5KVxuICAgICAqIGFuZCBsYXllciAodmFsdWUpXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdD59XG4gICAgICovXG4gICAgdGhpcy5mZWF0dXJlTGF5ZXJBc3NvY2lhdGlvbl8gPSB7fTtcblxuICAgIHZhciBmZWF0dXJlcyA9IHRoaXMuZ2V0RmVhdHVyZXMoKTtcbiAgICBsaXN0ZW4oZmVhdHVyZXMsIENvbGxlY3Rpb25FdmVudFR5cGUuQURELFxuICAgICAgdGhpcy5hZGRGZWF0dXJlXywgdGhpcyk7XG4gICAgbGlzdGVuKGZlYXR1cmVzLCBDb2xsZWN0aW9uRXZlbnRUeXBlLlJFTU9WRSxcbiAgICAgIHRoaXMucmVtb3ZlRmVhdHVyZV8sIHRoaXMpO1xuICB9XG5cbiAgaWYgKCBJbnRlcmFjdGlvbiApIFNlbGVjdC5fX3Byb3RvX18gPSBJbnRlcmFjdGlvbjtcbiAgU2VsZWN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEludGVyYWN0aW9uICYmIEludGVyYWN0aW9uLnByb3RvdHlwZSApO1xuICBTZWxlY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2VsZWN0O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0fSBsYXllciBMYXllci5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFNlbGVjdC5wcm90b3R5cGUuYWRkRmVhdHVyZUxheWVyQXNzb2NpYXRpb25fID0gZnVuY3Rpb24gYWRkRmVhdHVyZUxheWVyQXNzb2NpYXRpb25fIChmZWF0dXJlLCBsYXllcikge1xuICAgIHRoaXMuZmVhdHVyZUxheWVyQXNzb2NpYXRpb25fW2dldFVpZChmZWF0dXJlKV0gPSBsYXllcjtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBzZWxlY3RlZCBmZWF0dXJlcy5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vQ29sbGVjdGlvbi5qc1wiKS5kZWZhdWx0PGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59IEZlYXR1cmVzIGNvbGxlY3Rpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIFNlbGVjdC5wcm90b3R5cGUuZ2V0RmVhdHVyZXMgPSBmdW5jdGlvbiBnZXRGZWF0dXJlcyAoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7VmVjdG9yU291cmNlfSAqLyAodGhpcy5mZWF0dXJlT3ZlcmxheV8uZ2V0U291cmNlKCkpLmdldEZlYXR1cmVzQ29sbGVjdGlvbigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBIaXQtZGV0ZWN0aW9uIHRvbGVyYW5jZS5cbiAgICogQHJldHVybnMge251bWJlcn0gSGl0IHRvbGVyYW5jZSBpbiBwaXhlbHMuXG4gICAqIEBhcGlcbiAgICovXG4gIFNlbGVjdC5wcm90b3R5cGUuZ2V0SGl0VG9sZXJhbmNlID0gZnVuY3Rpb24gZ2V0SGl0VG9sZXJhbmNlICgpIHtcbiAgICByZXR1cm4gdGhpcy5oaXRUb2xlcmFuY2VfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhc3NvY2lhdGVkIHtAbGluayBtb2R1bGU6b2wvbGF5ZXIvVmVjdG9yflZlY3RvciB2ZWN0b3JsYXllcn0gb2ZcbiAgICogdGhlIChsYXN0KSBzZWxlY3RlZCBmZWF0dXJlLiBOb3RlIHRoYXQgdGhpcyB3aWxsIG5vdCB3b3JrIHdpdGggYW55XG4gICAqIHByb2dyYW1tYXRpYyBtZXRob2QgbGlrZSBwdXNoaW5nIGZlYXR1cmVzIHRvXG4gICAqIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vU2VsZWN0flNlbGVjdCNnZXRGZWF0dXJlcyBjb2xsZWN0aW9ufS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmVcbiAgICogQHJldHVybiB7VmVjdG9yTGF5ZXJ9IExheWVyLlxuICAgKiBAYXBpXG4gICAqL1xuICBTZWxlY3QucHJvdG90eXBlLmdldExheWVyID0gZnVuY3Rpb24gZ2V0TGF5ZXIgKGZlYXR1cmUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgLyoqIEB0eXBlIHtWZWN0b3JMYXllcn0gKi8gKHRoaXMuZmVhdHVyZUxheWVyQXNzb2NpYXRpb25fW2dldFVpZChmZWF0dXJlKV0pXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBvdmVybGF5IGxheWVyIHRoYXQgdGhpcyBpbnRlcmFjdGlvbiByZW5kZXJzIHNlbGVjdGVkIGZlYXR1cmVzIHRvLlxuICAgKiBAcmV0dXJuIHtWZWN0b3JMYXllcn0gT3ZlcmxheSBsYXllci5cbiAgICogQGFwaVxuICAgKi9cbiAgU2VsZWN0LnByb3RvdHlwZS5nZXRPdmVybGF5ID0gZnVuY3Rpb24gZ2V0T3ZlcmxheSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmVhdHVyZU92ZXJsYXlfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIaXQtZGV0ZWN0aW9uIHRvbGVyYW5jZS4gUGl4ZWxzIGluc2lkZSB0aGUgcmFkaXVzIGFyb3VuZCB0aGUgZ2l2ZW4gcG9zaXRpb25cbiAgICogd2lsbCBiZSBjaGVja2VkIGZvciBmZWF0dXJlcy4gVGhpcyBvbmx5IHdvcmtzIGZvciB0aGUgY2FudmFzIHJlbmRlcmVyIGFuZFxuICAgKiBub3QgZm9yIFdlYkdMLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaGl0VG9sZXJhbmNlIEhpdCB0b2xlcmFuY2UgaW4gcGl4ZWxzLlxuICAgKiBAYXBpXG4gICAqL1xuICBTZWxlY3QucHJvdG90eXBlLnNldEhpdFRvbGVyYW5jZSA9IGZ1bmN0aW9uIHNldEhpdFRvbGVyYW5jZSAoaGl0VG9sZXJhbmNlKSB7XG4gICAgdGhpcy5oaXRUb2xlcmFuY2VfID0gaGl0VG9sZXJhbmNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGludGVyYWN0aW9uIGZyb20gaXRzIGN1cnJlbnQgbWFwLCBpZiBhbnksICBhbmQgYXR0YWNoIGl0IHRvIGEgbmV3XG4gICAqIG1hcCwgaWYgYW55LiBQYXNzIGBudWxsYCB0byBqdXN0IHJlbW92ZSB0aGUgaW50ZXJhY3Rpb24gZnJvbSB0aGUgY3VycmVudCBtYXAuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLmRlZmF1bHR9IG1hcCBNYXAuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBTZWxlY3QucHJvdG90eXBlLnNldE1hcCA9IGZ1bmN0aW9uIHNldE1hcCAobWFwKSB7XG4gICAgdmFyIGN1cnJlbnRNYXAgPSB0aGlzLmdldE1hcCgpO1xuICAgIHZhciBzZWxlY3RlZEZlYXR1cmVzID0gdGhpcy5nZXRGZWF0dXJlcygpO1xuICAgIGlmIChjdXJyZW50TWFwKSB7XG4gICAgICBzZWxlY3RlZEZlYXR1cmVzLmZvckVhY2goY3VycmVudE1hcC51bnNraXBGZWF0dXJlLmJpbmQoY3VycmVudE1hcCkpO1xuICAgIH1cbiAgICBJbnRlcmFjdGlvbi5wcm90b3R5cGUuc2V0TWFwLmNhbGwodGhpcywgbWFwKTtcbiAgICB0aGlzLmZlYXR1cmVPdmVybGF5Xy5zZXRNYXAobWFwKTtcbiAgICBpZiAobWFwKSB7XG4gICAgICBzZWxlY3RlZEZlYXR1cmVzLmZvckVhY2gobWFwLnNraXBGZWF0dXJlLmJpbmQobWFwKSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0NvbGxlY3Rpb24uanNcIikuQ29sbGVjdGlvbkV2ZW50fSBldnQgRXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBTZWxlY3QucHJvdG90eXBlLmFkZEZlYXR1cmVfID0gZnVuY3Rpb24gYWRkRmVhdHVyZV8gKGV2dCkge1xuICAgIHZhciBtYXAgPSB0aGlzLmdldE1hcCgpO1xuICAgIGlmIChtYXApIHtcbiAgICAgIG1hcC5za2lwRmVhdHVyZSgvKiogQHR5cGUge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gKi8gKGV2dC5lbGVtZW50KSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0NvbGxlY3Rpb24uanNcIikuQ29sbGVjdGlvbkV2ZW50fSBldnQgRXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBTZWxlY3QucHJvdG90eXBlLnJlbW92ZUZlYXR1cmVfID0gZnVuY3Rpb24gcmVtb3ZlRmVhdHVyZV8gKGV2dCkge1xuICAgIHZhciBtYXAgPSB0aGlzLmdldE1hcCgpO1xuICAgIGlmIChtYXApIHtcbiAgICAgIG1hcC51bnNraXBGZWF0dXJlKC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSAqLyAoZXZ0LmVsZW1lbnQpKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgU2VsZWN0LnByb3RvdHlwZS5yZW1vdmVGZWF0dXJlTGF5ZXJBc3NvY2lhdGlvbl8gPSBmdW5jdGlvbiByZW1vdmVGZWF0dXJlTGF5ZXJBc3NvY2lhdGlvbl8gKGZlYXR1cmUpIHtcbiAgICBkZWxldGUgdGhpcy5mZWF0dXJlTGF5ZXJBc3NvY2lhdGlvbl9bZ2V0VWlkKGZlYXR1cmUpXTtcbiAgfTtcblxuICByZXR1cm4gU2VsZWN0O1xufShJbnRlcmFjdGlvbikpO1xuXG5cbi8qKlxuICogSGFuZGxlcyB0aGUge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnQgbWFwIGJyb3dzZXIgZXZlbnR9IGFuZCBtYXkgY2hhbmdlIHRoZVxuICogc2VsZWN0ZWQgc3RhdGUgb2YgZmVhdHVyZXMuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBgZmFsc2VgIHRvIHN0b3AgZXZlbnQgcHJvcGFnYXRpb24uXG4gKiBAdGhpcyB7U2VsZWN0fVxuICovXG5mdW5jdGlvbiBoYW5kbGVFdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgaWYgKCF0aGlzLmNvbmRpdGlvbl8obWFwQnJvd3NlckV2ZW50KSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBhZGQgPSB0aGlzLmFkZENvbmRpdGlvbl8obWFwQnJvd3NlckV2ZW50KTtcbiAgdmFyIHJlbW92ZSA9IHRoaXMucmVtb3ZlQ29uZGl0aW9uXyhtYXBCcm93c2VyRXZlbnQpO1xuICB2YXIgdG9nZ2xlID0gdGhpcy50b2dnbGVDb25kaXRpb25fKG1hcEJyb3dzZXJFdmVudCk7XG4gIHZhciBzZXQgPSAhYWRkICYmICFyZW1vdmUgJiYgIXRvZ2dsZTtcbiAgdmFyIG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gIHZhciBmZWF0dXJlcyA9IHRoaXMuZ2V0RmVhdHVyZXMoKTtcbiAgdmFyIGRlc2VsZWN0ZWQgPSBbXTtcbiAgdmFyIHNlbGVjdGVkID0gW107XG4gIGlmIChzZXQpIHtcbiAgICAvLyBSZXBsYWNlIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZmVhdHVyZShzKSB3aXRoIHRoZSBmZWF0dXJlKHMpIGF0IHRoZVxuICAgIC8vIHBpeGVsLCBvciBjbGVhciB0aGUgc2VsZWN0ZWQgZmVhdHVyZShzKSBpZiB0aGVyZSBpcyBubyBmZWF0dXJlIGF0XG4gICAgLy8gdGhlIHBpeGVsLlxuICAgIGNsZWFyKHRoaXMuZmVhdHVyZUxheWVyQXNzb2NpYXRpb25fKTtcbiAgICBtYXAuZm9yRWFjaEZlYXR1cmVBdFBpeGVsKG1hcEJyb3dzZXJFdmVudC5waXhlbCxcbiAgICAgIChcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHR9IGxheWVyIExheWVyLlxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufHVuZGVmaW5lZH0gQ29udGludWUgdG8gaXRlcmF0ZSBvdmVyIHRoZSBmZWF0dXJlcy5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uKGZlYXR1cmUsIGxheWVyKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZmlsdGVyXyhmZWF0dXJlLCBsYXllcikpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkLnB1c2goZmVhdHVyZSk7XG4gICAgICAgICAgICB0aGlzLmFkZEZlYXR1cmVMYXllckFzc29jaWF0aW9uXyhmZWF0dXJlLCBsYXllcik7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXMubXVsdGlfO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkuYmluZCh0aGlzKSwge1xuICAgICAgICBsYXllckZpbHRlcjogdGhpcy5sYXllckZpbHRlcl8sXG4gICAgICAgIGhpdFRvbGVyYW5jZTogdGhpcy5oaXRUb2xlcmFuY2VfXG4gICAgICB9KTtcbiAgICBmb3IgKHZhciBpID0gZmVhdHVyZXMuZ2V0TGVuZ3RoKCkgLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdmFyIGZlYXR1cmUgPSBmZWF0dXJlcy5pdGVtKGkpO1xuICAgICAgdmFyIGluZGV4ID0gc2VsZWN0ZWQuaW5kZXhPZihmZWF0dXJlKTtcbiAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgIC8vIGZlYXR1cmUgaXMgYWxyZWFkeSBzZWxlY3RlZFxuICAgICAgICBzZWxlY3RlZC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmVhdHVyZXMucmVtb3ZlKGZlYXR1cmUpO1xuICAgICAgICBkZXNlbGVjdGVkLnB1c2goZmVhdHVyZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzZWxlY3RlZC5sZW5ndGggIT09IDApIHtcbiAgICAgIGZlYXR1cmVzLmV4dGVuZChzZWxlY3RlZCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIE1vZGlmeSB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGZlYXR1cmUocykuXG4gICAgbWFwLmZvckVhY2hGZWF0dXJlQXRQaXhlbChtYXBCcm93c2VyRXZlbnQucGl4ZWwsXG4gICAgICAoXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0fSBsYXllciBMYXllci5cbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbnx1bmRlZmluZWR9IENvbnRpbnVlIHRvIGl0ZXJhdGUgb3ZlciB0aGUgZmVhdHVyZXMuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbihmZWF0dXJlLCBsYXllcikge1xuICAgICAgICAgIGlmICh0aGlzLmZpbHRlcl8oZmVhdHVyZSwgbGF5ZXIpKSB7XG4gICAgICAgICAgICBpZiAoKGFkZCB8fCB0b2dnbGUpICYmICFpbmNsdWRlcyhmZWF0dXJlcy5nZXRBcnJheSgpLCBmZWF0dXJlKSkge1xuICAgICAgICAgICAgICBzZWxlY3RlZC5wdXNoKGZlYXR1cmUpO1xuICAgICAgICAgICAgICB0aGlzLmFkZEZlYXR1cmVMYXllckFzc29jaWF0aW9uXyhmZWF0dXJlLCBsYXllcik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChyZW1vdmUgfHwgdG9nZ2xlKSAmJiBpbmNsdWRlcyhmZWF0dXJlcy5nZXRBcnJheSgpLCBmZWF0dXJlKSkge1xuICAgICAgICAgICAgICBkZXNlbGVjdGVkLnB1c2goZmVhdHVyZSk7XG4gICAgICAgICAgICAgIHRoaXMucmVtb3ZlRmVhdHVyZUxheWVyQXNzb2NpYXRpb25fKGZlYXR1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICF0aGlzLm11bHRpXztcbiAgICAgICAgICB9XG4gICAgICAgIH0pLmJpbmQodGhpcyksIHtcbiAgICAgICAgbGF5ZXJGaWx0ZXI6IHRoaXMubGF5ZXJGaWx0ZXJfLFxuICAgICAgICBoaXRUb2xlcmFuY2U6IHRoaXMuaGl0VG9sZXJhbmNlX1xuICAgICAgfSk7XG4gICAgZm9yICh2YXIgaiA9IGRlc2VsZWN0ZWQubGVuZ3RoIC0gMTsgaiA+PSAwOyAtLWopIHtcbiAgICAgIGZlYXR1cmVzLnJlbW92ZShkZXNlbGVjdGVkW2pdKTtcbiAgICB9XG4gICAgZmVhdHVyZXMuZXh0ZW5kKHNlbGVjdGVkKTtcbiAgfVxuICBpZiAoc2VsZWN0ZWQubGVuZ3RoID4gMCB8fCBkZXNlbGVjdGVkLmxlbmd0aCA+IDApIHtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICBuZXcgU2VsZWN0RXZlbnQoU2VsZWN0RXZlbnRUeXBlLlNFTEVDVCxcbiAgICAgICAgc2VsZWN0ZWQsIGRlc2VsZWN0ZWQsIG1hcEJyb3dzZXJFdmVudCkpO1xuICB9XG4gIHJldHVybiBwb2ludGVyTW92ZShtYXBCcm93c2VyRXZlbnQpO1xufVxuXG5cbi8qKlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVGdW5jdGlvbn0gU3R5bGVzLlxuICovXG5mdW5jdGlvbiBnZXREZWZhdWx0U3R5bGVGdW5jdGlvbigpIHtcbiAgdmFyIHN0eWxlcyA9IGNyZWF0ZUVkaXRpbmdTdHlsZSgpO1xuICBleHRlbmQoc3R5bGVzW0dlb21ldHJ5VHlwZS5QT0xZR09OXSwgc3R5bGVzW0dlb21ldHJ5VHlwZS5MSU5FX1NUUklOR10pO1xuICBleHRlbmQoc3R5bGVzW0dlb21ldHJ5VHlwZS5HRU9NRVRSWV9DT0xMRUNUSU9OXSwgc3R5bGVzW0dlb21ldHJ5VHlwZS5MSU5FX1NUUklOR10pO1xuXG4gIHJldHVybiBmdW5jdGlvbihmZWF0dXJlLCByZXNvbHV0aW9uKSB7XG4gICAgaWYgKCFmZWF0dXJlLmdldEdlb21ldHJ5KCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gc3R5bGVzW2ZlYXR1cmUuZ2V0R2VvbWV0cnkoKS5nZXRUeXBlKCldO1xuICB9O1xufVxuXG5cbmV4cG9ydCBkZWZhdWx0IFNlbGVjdDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2VsZWN0LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9TbmFwXG4gKi9cbmltcG9ydCB7Z2V0VWlkfSBmcm9tICcuLi91dGlsLmpzJztcbmltcG9ydCBDb2xsZWN0aW9uRXZlbnRUeXBlIGZyb20gJy4uL0NvbGxlY3Rpb25FdmVudFR5cGUuanMnO1xuaW1wb3J0IHtkaXN0YW5jZSBhcyBjb29yZGluYXRlRGlzdGFuY2UsIHNxdWFyZWREaXN0YW5jZSBhcyBzcXVhcmVkQ29vcmRpbmF0ZURpc3RhbmNlLCBjbG9zZXN0T25DaXJjbGUsIGNsb3Nlc3RPblNlZ21lbnQsIHNxdWFyZWREaXN0YW5jZVRvU2VnbWVudH0gZnJvbSAnLi4vY29vcmRpbmF0ZS5qcyc7XG5pbXBvcnQge2xpc3RlbiwgdW5saXN0ZW5CeUtleX0gZnJvbSAnLi4vZXZlbnRzLmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQge2JvdW5kaW5nRXh0ZW50LCBjcmVhdGVFbXB0eX0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7VFJVRSwgRkFMU0V9IGZyb20gJy4uL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQgR2VvbWV0cnlUeXBlIGZyb20gJy4uL2dlb20vR2VvbWV0cnlUeXBlLmpzJztcbmltcG9ydCB7ZnJvbUNpcmNsZX0gZnJvbSAnLi4vZ2VvbS9Qb2x5Z29uLmpzJztcbmltcG9ydCBQb2ludGVySW50ZXJhY3Rpb24gZnJvbSAnLi9Qb2ludGVyLmpzJztcbmltcG9ydCB7Z2V0VmFsdWVzfSBmcm9tICcuLi9vYmouanMnO1xuaW1wb3J0IFZlY3RvckV2ZW50VHlwZSBmcm9tICcuLi9zb3VyY2UvVmVjdG9yRXZlbnRUeXBlLmpzJztcbmltcG9ydCBSQnVzaCBmcm9tICcuLi9zdHJ1Y3RzL1JCdXNoLmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFJlc3VsdFxuICogQHByb3BlcnR5IHtib29sZWFufSBzbmFwcGVkXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZXxudWxsfSB2ZXJ0ZXhcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vcGl4ZWwuanNcIikuUGl4ZWx8bnVsbH0gdmVydGV4UGl4ZWxcbiAqL1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU2VnbWVudERhdGFcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlXG4gKiBAcHJvcGVydHkge0FycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59IHNlZ21lbnRcbiAqL1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9Db2xsZWN0aW9uLmpzXCIpLmRlZmF1bHQ8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn0gW2ZlYXR1cmVzXSBTbmFwIHRvIHRoZXNlIGZlYXR1cmVzLiBFaXRoZXIgdGhpcyBvcHRpb24gb3Igc291cmNlIHNob3VsZCBiZSBwcm92aWRlZC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2VkZ2U9dHJ1ZV0gU25hcCB0byBlZGdlcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3ZlcnRleD10cnVlXSBTbmFwIHRvIHZlcnRpY2VzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtwaXhlbFRvbGVyYW5jZT0xMF0gUGl4ZWwgdG9sZXJhbmNlIGZvciBjb25zaWRlcmluZyB0aGUgcG9pbnRlciBjbG9zZSBlbm91Z2ggdG8gYSBzZWdtZW50IG9yXG4gKiB2ZXJ0ZXggZm9yIHNuYXBwaW5nLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9zb3VyY2UvVmVjdG9yLmpzXCIpLmRlZmF1bHR9IFtzb3VyY2VdIFNuYXAgdG8gZmVhdHVyZXMgZnJvbSB0aGlzIHNvdXJjZS4gRWl0aGVyIHRoaXMgb3B0aW9uIG9yIGZlYXR1cmVzIHNob3VsZCBiZSBwcm92aWRlZFxuICovXG5cblxuLyoqXG4gKiBAcGFyYW0gIHtpbXBvcnQoXCIuLi9zb3VyY2UvVmVjdG9yLmpzXCIpLlZlY3RvclNvdXJjZUV2ZW50fGltcG9ydChcIi4uL0NvbGxlY3Rpb24uanNcIikuQ29sbGVjdGlvbkV2ZW50fSBldnQgRXZlbnQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IEZlYXR1cmUuXG4gKi9cbmZ1bmN0aW9uIGdldEZlYXR1cmVGcm9tRXZlbnQoZXZ0KSB7XG4gIGlmICgvKiogQHR5cGUge2ltcG9ydChcIi4uL3NvdXJjZS9WZWN0b3IuanNcIikuVmVjdG9yU291cmNlRXZlbnR9ICovIChldnQpLmZlYXR1cmUpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9zb3VyY2UvVmVjdG9yLmpzXCIpLlZlY3RvclNvdXJjZUV2ZW50fSAqLyAoZXZ0KS5mZWF0dXJlO1xuICB9IGVsc2UgaWYgKC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vQ29sbGVjdGlvbi5qc1wiKS5Db2xsZWN0aW9uRXZlbnR9ICovIChldnQpLmVsZW1lbnQpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9ICovICgvKiogQHR5cGUge2ltcG9ydChcIi4uL0NvbGxlY3Rpb24uanNcIikuQ29sbGVjdGlvbkV2ZW50fSAqLyAoZXZ0KS5lbGVtZW50KTtcbiAgfVxuXG59XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogSGFuZGxlcyBzbmFwcGluZyBvZiB2ZWN0b3IgZmVhdHVyZXMgd2hpbGUgbW9kaWZ5aW5nIG9yIGRyYXdpbmcgdGhlbS4gIFRoZVxuICogZmVhdHVyZXMgY2FuIGNvbWUgZnJvbSBhIHtAbGluayBtb2R1bGU6b2wvc291cmNlL1ZlY3Rvcn0gb3Ige0BsaW5rIG1vZHVsZTpvbC9Db2xsZWN0aW9ufkNvbGxlY3Rpb259XG4gKiBBbnkgaW50ZXJhY3Rpb24gb2JqZWN0IHRoYXQgYWxsb3dzIHRoZSB1c2VyIHRvIGludGVyYWN0XG4gKiB3aXRoIHRoZSBmZWF0dXJlcyB1c2luZyB0aGUgbW91c2UgY2FuIGJlbmVmaXQgZnJvbSB0aGUgc25hcHBpbmcsIGFzIGxvbmdcbiAqIGFzIGl0IGlzIGFkZGVkIGJlZm9yZS5cbiAqXG4gKiBUaGUgc25hcCBpbnRlcmFjdGlvbiBtb2RpZmllcyBtYXAgYnJvd3NlciBldmVudCBgY29vcmRpbmF0ZWAgYW5kIGBwaXhlbGBcbiAqIHByb3BlcnRpZXMgdG8gZm9yY2UgdGhlIHNuYXAgdG8gb2NjdXIgdG8gYW55IGludGVyYWN0aW9uIHRoYXQgdGhlbS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICBpbXBvcnQgU25hcCBmcm9tICdvbC9pbnRlcmFjdGlvbi9TbmFwJztcbiAqXG4gKiAgICAgdmFyIHNuYXAgPSBuZXcgU25hcCh7XG4gKiAgICAgICBzb3VyY2U6IHNvdXJjZVxuICogICAgIH0pO1xuICpcbiAqIEBhcGlcbiAqL1xudmFyIFNuYXAgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChQb2ludGVySW50ZXJhY3Rpb24pIHtcbiAgZnVuY3Rpb24gU25hcChvcHRfb3B0aW9ucykge1xuXG4gICAgdmFyIG9wdGlvbnMgPSBvcHRfb3B0aW9ucyA/IG9wdF9vcHRpb25zIDoge307XG5cbiAgICB2YXIgcG9pbnRlck9wdGlvbnMgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vUG9pbnRlci5qc1wiKS5PcHRpb25zfSAqLyAob3B0aW9ucyk7XG5cbiAgICBpZiAoIXBvaW50ZXJPcHRpb25zLmhhbmRsZURvd25FdmVudCkge1xuICAgICAgcG9pbnRlck9wdGlvbnMuaGFuZGxlRG93bkV2ZW50ID0gVFJVRTtcbiAgICB9XG5cbiAgICBpZiAoIXBvaW50ZXJPcHRpb25zLnN0b3BEb3duKSB7XG4gICAgICBwb2ludGVyT3B0aW9ucy5zdG9wRG93biA9IEZBTFNFO1xuICAgIH1cblxuICAgIFBvaW50ZXJJbnRlcmFjdGlvbi5jYWxsKHRoaXMsIHBvaW50ZXJPcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9zb3VyY2UvVmVjdG9yLmpzXCIpLmRlZmF1bHR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnNvdXJjZV8gPSBvcHRpb25zLnNvdXJjZSA/IG9wdGlvbnMuc291cmNlIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy52ZXJ0ZXhfID0gb3B0aW9ucy52ZXJ0ZXggIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudmVydGV4IDogdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5lZGdlXyA9IG9wdGlvbnMuZWRnZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5lZGdlIDogdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9Db2xsZWN0aW9uLmpzXCIpLmRlZmF1bHQ8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZmVhdHVyZXNfID0gb3B0aW9ucy5mZWF0dXJlcyA/IG9wdGlvbnMuZmVhdHVyZXMgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PGltcG9ydChcIi4uL2V2ZW50cy5qc1wiKS5FdmVudHNLZXk+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5mZWF0dXJlc0xpc3RlbmVyS2V5c18gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi9ldmVudHMuanNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZmVhdHVyZUNoYW5nZUxpc3RlbmVyS2V5c18gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEV4dGVudHMgYXJlIHByZXNlcnZlZCBzbyBpbmRleGVkIHNlZ21lbnQgY2FuIGJlIHF1aWNrbHkgcmVtb3ZlZFxuICAgICAqIHdoZW4gaXRzIGZlYXR1cmUgZ2VvbWV0cnkgY2hhbmdlc1xuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50Pn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaW5kZXhlZEZlYXR1cmVzRXh0ZW50c18gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIElmIGEgZmVhdHVyZSBnZW9tZXRyeSBjaGFuZ2VzIHdoaWxlIGEgcG9pbnRlciBkcmFnfG1vdmUgZXZlbnQgb2NjdXJzLCB0aGVcbiAgICAgKiBmZWF0dXJlIGRvZXNuJ3QgZ2V0IHVwZGF0ZWQgcmlnaHQgYXdheS4gIEl0IHdpbGwgYmUgYXQgdGhlIG5leHQgJ3BvaW50ZXJ1cCdcbiAgICAgKiBldmVudCBmaXJlZC5cbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnBlbmRpbmdGZWF0dXJlc18gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIGRpc3RhbmNlIHNvcnRpbmcgaW4gc29ydEJ5RGlzdGFuY2VfXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucGl4ZWxDb29yZGluYXRlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5waXhlbFRvbGVyYW5jZV8gPSBvcHRpb25zLnBpeGVsVG9sZXJhbmNlICE9PSB1bmRlZmluZWQgP1xuICAgICAgb3B0aW9ucy5waXhlbFRvbGVyYW5jZSA6IDEwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKFNlZ21lbnREYXRhLCBTZWdtZW50RGF0YSk6IG51bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc29ydEJ5RGlzdGFuY2VfID0gc29ydEJ5RGlzdGFuY2UuYmluZCh0aGlzKTtcblxuXG4gICAgLyoqXG4gICAgKiBTZWdtZW50IFJUcmVlIGZvciBlYWNoIGxheWVyXG4gICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vc3RydWN0cy9SQnVzaC5qc1wiKS5kZWZhdWx0PFNlZ21lbnREYXRhPn1cbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICB0aGlzLnJCdXNoXyA9IG5ldyBSQnVzaCgpO1xuXG5cbiAgICAvKipcbiAgICAqIEBjb25zdFxuICAgICogQHByaXZhdGVcbiAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBmdW5jdGlvbihpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQsIGltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdCk+fVxuICAgICovXG4gICAgdGhpcy5TRUdNRU5UX1dSSVRFUlNfID0ge1xuICAgICAgJ1BvaW50JzogdGhpcy53cml0ZVBvaW50R2VvbWV0cnlfLFxuICAgICAgJ0xpbmVTdHJpbmcnOiB0aGlzLndyaXRlTGluZVN0cmluZ0dlb21ldHJ5XyxcbiAgICAgICdMaW5lYXJSaW5nJzogdGhpcy53cml0ZUxpbmVTdHJpbmdHZW9tZXRyeV8sXG4gICAgICAnUG9seWdvbic6IHRoaXMud3JpdGVQb2x5Z29uR2VvbWV0cnlfLFxuICAgICAgJ011bHRpUG9pbnQnOiB0aGlzLndyaXRlTXVsdGlQb2ludEdlb21ldHJ5XyxcbiAgICAgICdNdWx0aUxpbmVTdHJpbmcnOiB0aGlzLndyaXRlTXVsdGlMaW5lU3RyaW5nR2VvbWV0cnlfLFxuICAgICAgJ011bHRpUG9seWdvbic6IHRoaXMud3JpdGVNdWx0aVBvbHlnb25HZW9tZXRyeV8sXG4gICAgICAnR2VvbWV0cnlDb2xsZWN0aW9uJzogdGhpcy53cml0ZUdlb21ldHJ5Q29sbGVjdGlvbkdlb21ldHJ5XyxcbiAgICAgICdDaXJjbGUnOiB0aGlzLndyaXRlQ2lyY2xlR2VvbWV0cnlfXG4gICAgfTtcbiAgfVxuXG4gIGlmICggUG9pbnRlckludGVyYWN0aW9uICkgU25hcC5fX3Byb3RvX18gPSBQb2ludGVySW50ZXJhY3Rpb247XG4gIFNuYXAucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUG9pbnRlckludGVyYWN0aW9uICYmIFBvaW50ZXJJbnRlcmFjdGlvbi5wcm90b3R5cGUgKTtcbiAgU25hcC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTbmFwO1xuXG4gIC8qKlxuICAgKiBBZGQgYSBmZWF0dXJlIHRvIHRoZSBjb2xsZWN0aW9uIG9mIGZlYXR1cmVzIHRoYXQgd2UgbWF5IHNuYXAgdG8uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9saXN0ZW4gV2hldGhlciB0byBsaXN0ZW4gdG8gdGhlIGZlYXR1cmUgY2hhbmdlIG9yIG5vdFxuICAgKiAgICAgRGVmYXVsdHMgdG8gYHRydWVgLlxuICAgKiBAYXBpXG4gICAqL1xuICBTbmFwLnByb3RvdHlwZS5hZGRGZWF0dXJlID0gZnVuY3Rpb24gYWRkRmVhdHVyZSAoZmVhdHVyZSwgb3B0X2xpc3Rlbikge1xuICAgIHZhciByZWdpc3RlciA9IG9wdF9saXN0ZW4gIT09IHVuZGVmaW5lZCA/IG9wdF9saXN0ZW4gOiB0cnVlO1xuICAgIHZhciBmZWF0dXJlX3VpZCA9IGdldFVpZChmZWF0dXJlKTtcbiAgICB2YXIgZ2VvbWV0cnkgPSBmZWF0dXJlLmdldEdlb21ldHJ5KCk7XG4gICAgaWYgKGdlb21ldHJ5KSB7XG4gICAgICB2YXIgc2VnbWVudFdyaXRlciA9IHRoaXMuU0VHTUVOVF9XUklURVJTX1tnZW9tZXRyeS5nZXRUeXBlKCldO1xuICAgICAgaWYgKHNlZ21lbnRXcml0ZXIpIHtcbiAgICAgICAgdGhpcy5pbmRleGVkRmVhdHVyZXNFeHRlbnRzX1tmZWF0dXJlX3VpZF0gPSBnZW9tZXRyeS5nZXRFeHRlbnQoY3JlYXRlRW1wdHkoKSk7XG4gICAgICAgIHNlZ21lbnRXcml0ZXIuY2FsbCh0aGlzLCBmZWF0dXJlLCBnZW9tZXRyeSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlZ2lzdGVyKSB7XG4gICAgICB0aGlzLmZlYXR1cmVDaGFuZ2VMaXN0ZW5lcktleXNfW2ZlYXR1cmVfdWlkXSA9IGxpc3RlbihcbiAgICAgICAgZmVhdHVyZSxcbiAgICAgICAgRXZlbnRUeXBlLkNIQU5HRSxcbiAgICAgICAgdGhpcy5oYW5kbGVGZWF0dXJlQ2hhbmdlXywgdGhpcyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgU25hcC5wcm90b3R5cGUuZm9yRWFjaEZlYXR1cmVBZGRfID0gZnVuY3Rpb24gZm9yRWFjaEZlYXR1cmVBZGRfIChmZWF0dXJlKSB7XG4gICAgdGhpcy5hZGRGZWF0dXJlKGZlYXR1cmUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgU25hcC5wcm90b3R5cGUuZm9yRWFjaEZlYXR1cmVSZW1vdmVfID0gZnVuY3Rpb24gZm9yRWFjaEZlYXR1cmVSZW1vdmVfIChmZWF0dXJlKSB7XG4gICAgdGhpcy5yZW1vdmVGZWF0dXJlKGZlYXR1cmUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9Db2xsZWN0aW9uLmpzXCIpLmRlZmF1bHQ8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0PnxBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fSBGZWF0dXJlcy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFNuYXAucHJvdG90eXBlLmdldEZlYXR1cmVzXyA9IGZ1bmN0aW9uIGdldEZlYXR1cmVzXyAoKSB7XG4gICAgdmFyIGZlYXR1cmVzO1xuICAgIGlmICh0aGlzLmZlYXR1cmVzXykge1xuICAgICAgZmVhdHVyZXMgPSB0aGlzLmZlYXR1cmVzXztcbiAgICB9IGVsc2UgaWYgKHRoaXMuc291cmNlXykge1xuICAgICAgZmVhdHVyZXMgPSB0aGlzLnNvdXJjZV8uZ2V0RmVhdHVyZXMoKTtcbiAgICB9XG4gICAgcmV0dXJuIGZlYXR1cmVzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgU25hcC5wcm90b3R5cGUuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiBoYW5kbGVFdmVudCAoZXZ0KSB7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuc25hcFRvKGV2dC5waXhlbCwgZXZ0LmNvb3JkaW5hdGUsIGV2dC5tYXApO1xuICAgIGlmIChyZXN1bHQuc25hcHBlZCkge1xuICAgICAgZXZ0LmNvb3JkaW5hdGUgPSByZXN1bHQudmVydGV4LnNsaWNlKDAsIDIpO1xuICAgICAgZXZ0LnBpeGVsID0gcmVzdWx0LnZlcnRleFBpeGVsO1xuICAgIH1cbiAgICByZXR1cm4gUG9pbnRlckludGVyYWN0aW9uLnByb3RvdHlwZS5oYW5kbGVFdmVudC5jYWxsKHRoaXMsIGV2dCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc291cmNlL1ZlY3Rvci5qc1wiKS5WZWN0b3JTb3VyY2VFdmVudHxpbXBvcnQoXCIuLi9Db2xsZWN0aW9uLmpzXCIpLkNvbGxlY3Rpb25FdmVudH0gZXZ0IEV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgU25hcC5wcm90b3R5cGUuaGFuZGxlRmVhdHVyZUFkZF8gPSBmdW5jdGlvbiBoYW5kbGVGZWF0dXJlQWRkXyAoZXZ0KSB7XG4gICAgdmFyIGZlYXR1cmUgPSBnZXRGZWF0dXJlRnJvbUV2ZW50KGV2dCk7XG4gICAgdGhpcy5hZGRGZWF0dXJlKGZlYXR1cmUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3NvdXJjZS9WZWN0b3IuanNcIikuVmVjdG9yU291cmNlRXZlbnR8aW1wb3J0KFwiLi4vQ29sbGVjdGlvbi5qc1wiKS5Db2xsZWN0aW9uRXZlbnR9IGV2dCBFdmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFNuYXAucHJvdG90eXBlLmhhbmRsZUZlYXR1cmVSZW1vdmVfID0gZnVuY3Rpb24gaGFuZGxlRmVhdHVyZVJlbW92ZV8gKGV2dCkge1xuICAgIHZhciBmZWF0dXJlID0gZ2V0RmVhdHVyZUZyb21FdmVudChldnQpO1xuICAgIHRoaXMucmVtb3ZlRmVhdHVyZShmZWF0dXJlKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdH0gZXZ0IEV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgU25hcC5wcm90b3R5cGUuaGFuZGxlRmVhdHVyZUNoYW5nZV8gPSBmdW5jdGlvbiBoYW5kbGVGZWF0dXJlQ2hhbmdlXyAoZXZ0KSB7XG4gICAgdmFyIGZlYXR1cmUgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gKi8gKGV2dC50YXJnZXQpO1xuICAgIGlmICh0aGlzLmhhbmRsaW5nRG93blVwU2VxdWVuY2UpIHtcbiAgICAgIHZhciB1aWQgPSBnZXRVaWQoZmVhdHVyZSk7XG4gICAgICBpZiAoISh1aWQgaW4gdGhpcy5wZW5kaW5nRmVhdHVyZXNfKSkge1xuICAgICAgICB0aGlzLnBlbmRpbmdGZWF0dXJlc19bdWlkXSA9IGZlYXR1cmU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXBkYXRlRmVhdHVyZV8oZmVhdHVyZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgU25hcC5wcm90b3R5cGUuaGFuZGxlVXBFdmVudCA9IGZ1bmN0aW9uIGhhbmRsZVVwRXZlbnQgKGV2dCkge1xuICAgIHZhciBmZWF0dXJlc1RvVXBkYXRlID0gZ2V0VmFsdWVzKHRoaXMucGVuZGluZ0ZlYXR1cmVzXyk7XG4gICAgaWYgKGZlYXR1cmVzVG9VcGRhdGUubGVuZ3RoKSB7XG4gICAgICBmZWF0dXJlc1RvVXBkYXRlLmZvckVhY2godGhpcy51cGRhdGVGZWF0dXJlXy5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMucGVuZGluZ0ZlYXR1cmVzXyA9IHt9O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGZlYXR1cmUgZnJvbSB0aGUgY29sbGVjdGlvbiBvZiBmZWF0dXJlcyB0aGF0IHdlIG1heSBzbmFwIHRvLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF91bmxpc3RlbiBXaGV0aGVyIHRvIHVubGlzdGVuIHRvIHRoZSBmZWF0dXJlIGNoYW5nZVxuICAgKiAgICAgb3Igbm90LiBEZWZhdWx0cyB0byBgdHJ1ZWAuXG4gICAqIEBhcGlcbiAgICovXG4gIFNuYXAucHJvdG90eXBlLnJlbW92ZUZlYXR1cmUgPSBmdW5jdGlvbiByZW1vdmVGZWF0dXJlIChmZWF0dXJlLCBvcHRfdW5saXN0ZW4pIHtcbiAgICB2YXIgdW5yZWdpc3RlciA9IG9wdF91bmxpc3RlbiAhPT0gdW5kZWZpbmVkID8gb3B0X3VubGlzdGVuIDogdHJ1ZTtcbiAgICB2YXIgZmVhdHVyZV91aWQgPSBnZXRVaWQoZmVhdHVyZSk7XG4gICAgdmFyIGV4dGVudCA9IHRoaXMuaW5kZXhlZEZlYXR1cmVzRXh0ZW50c19bZmVhdHVyZV91aWRdO1xuICAgIGlmIChleHRlbnQpIHtcbiAgICAgIHZhciByQnVzaCA9IHRoaXMuckJ1c2hfO1xuICAgICAgdmFyIG5vZGVzVG9SZW1vdmUgPSBbXTtcbiAgICAgIHJCdXNoLmZvckVhY2hJbkV4dGVudChleHRlbnQsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgaWYgKGZlYXR1cmUgPT09IG5vZGUuZmVhdHVyZSkge1xuICAgICAgICAgIG5vZGVzVG9SZW1vdmUucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBmb3IgKHZhciBpID0gbm9kZXNUb1JlbW92ZS5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICByQnVzaC5yZW1vdmUobm9kZXNUb1JlbW92ZVtpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHVucmVnaXN0ZXIpIHtcbiAgICAgIHVubGlzdGVuQnlLZXkodGhpcy5mZWF0dXJlQ2hhbmdlTGlzdGVuZXJLZXlzX1tmZWF0dXJlX3VpZF0pO1xuICAgICAgZGVsZXRlIHRoaXMuZmVhdHVyZUNoYW5nZUxpc3RlbmVyS2V5c19bZmVhdHVyZV91aWRdO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIFNuYXAucHJvdG90eXBlLnNldE1hcCA9IGZ1bmN0aW9uIHNldE1hcCAobWFwKSB7XG4gICAgdmFyIGN1cnJlbnRNYXAgPSB0aGlzLmdldE1hcCgpO1xuICAgIHZhciBrZXlzID0gdGhpcy5mZWF0dXJlc0xpc3RlbmVyS2V5c187XG4gICAgdmFyIGZlYXR1cmVzID0gLyoqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fSAqLyAodGhpcy5nZXRGZWF0dXJlc18oKSk7XG5cbiAgICBpZiAoY3VycmVudE1hcCkge1xuICAgICAga2V5cy5mb3JFYWNoKHVubGlzdGVuQnlLZXkpO1xuICAgICAga2V5cy5sZW5ndGggPSAwO1xuICAgICAgZmVhdHVyZXMuZm9yRWFjaCh0aGlzLmZvckVhY2hGZWF0dXJlUmVtb3ZlXy5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgUG9pbnRlckludGVyYWN0aW9uLnByb3RvdHlwZS5zZXRNYXAuY2FsbCh0aGlzLCBtYXApO1xuXG4gICAgaWYgKG1hcCkge1xuICAgICAgaWYgKHRoaXMuZmVhdHVyZXNfKSB7XG4gICAgICAgIGtleXMucHVzaChcbiAgICAgICAgICBsaXN0ZW4odGhpcy5mZWF0dXJlc18sIENvbGxlY3Rpb25FdmVudFR5cGUuQURELFxuICAgICAgICAgICAgdGhpcy5oYW5kbGVGZWF0dXJlQWRkXywgdGhpcyksXG4gICAgICAgICAgbGlzdGVuKHRoaXMuZmVhdHVyZXNfLCBDb2xsZWN0aW9uRXZlbnRUeXBlLlJFTU9WRSxcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRmVhdHVyZVJlbW92ZV8sIHRoaXMpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc291cmNlXykge1xuICAgICAgICBrZXlzLnB1c2goXG4gICAgICAgICAgbGlzdGVuKHRoaXMuc291cmNlXywgVmVjdG9yRXZlbnRUeXBlLkFEREZFQVRVUkUsXG4gICAgICAgICAgICB0aGlzLmhhbmRsZUZlYXR1cmVBZGRfLCB0aGlzKSxcbiAgICAgICAgICBsaXN0ZW4odGhpcy5zb3VyY2VfLCBWZWN0b3JFdmVudFR5cGUuUkVNT1ZFRkVBVFVSRSxcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRmVhdHVyZVJlbW92ZV8sIHRoaXMpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBmZWF0dXJlcy5mb3JFYWNoKHRoaXMuZm9yRWFjaEZlYXR1cmVBZGRfLmJpbmQodGhpcykpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9waXhlbC5qc1wiKS5QaXhlbH0gcGl4ZWwgUGl4ZWxcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IHBpeGVsQ29vcmRpbmF0ZSBDb29yZGluYXRlXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLmRlZmF1bHR9IG1hcCBNYXAuXG4gICAqIEByZXR1cm4ge1Jlc3VsdH0gU25hcCByZXN1bHRcbiAgICovXG4gIFNuYXAucHJvdG90eXBlLnNuYXBUbyA9IGZ1bmN0aW9uIHNuYXBUbyAocGl4ZWwsIHBpeGVsQ29vcmRpbmF0ZSwgbWFwKSB7XG5cbiAgICB2YXIgbG93ZXJMZWZ0ID0gbWFwLmdldENvb3JkaW5hdGVGcm9tUGl4ZWwoXG4gICAgICBbcGl4ZWxbMF0gLSB0aGlzLnBpeGVsVG9sZXJhbmNlXywgcGl4ZWxbMV0gKyB0aGlzLnBpeGVsVG9sZXJhbmNlX10pO1xuICAgIHZhciB1cHBlclJpZ2h0ID0gbWFwLmdldENvb3JkaW5hdGVGcm9tUGl4ZWwoXG4gICAgICBbcGl4ZWxbMF0gKyB0aGlzLnBpeGVsVG9sZXJhbmNlXywgcGl4ZWxbMV0gLSB0aGlzLnBpeGVsVG9sZXJhbmNlX10pO1xuICAgIHZhciBib3ggPSBib3VuZGluZ0V4dGVudChbbG93ZXJMZWZ0LCB1cHBlclJpZ2h0XSk7XG5cbiAgICB2YXIgc2VnbWVudHMgPSB0aGlzLnJCdXNoXy5nZXRJbkV4dGVudChib3gpO1xuXG4gICAgLy8gSWYgc25hcHBpbmcgb24gdmVydGljZXMgb25seSwgZG9uJ3QgY29uc2lkZXIgY2lyY2xlc1xuICAgIGlmICh0aGlzLnZlcnRleF8gJiYgIXRoaXMuZWRnZV8pIHtcbiAgICAgIHNlZ21lbnRzID0gc2VnbWVudHMuZmlsdGVyKGZ1bmN0aW9uKHNlZ21lbnQpIHtcbiAgICAgICAgcmV0dXJuIHNlZ21lbnQuZmVhdHVyZS5nZXRHZW9tZXRyeSgpLmdldFR5cGUoKSAhPT1cbiAgICAgICAgICAgIEdlb21ldHJ5VHlwZS5DSVJDTEU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgc25hcHBlZFRvVmVydGV4ID0gZmFsc2U7XG4gICAgdmFyIHNuYXBwZWQgPSBmYWxzZTtcbiAgICB2YXIgdmVydGV4ID0gbnVsbDtcbiAgICB2YXIgdmVydGV4UGl4ZWwgPSBudWxsO1xuICAgIHZhciBkaXN0LCBwaXhlbDEsIHBpeGVsMiwgc3F1YXJlZERpc3QxLCBzcXVhcmVkRGlzdDI7XG4gICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMucGl4ZWxDb29yZGluYXRlXyA9IHBpeGVsQ29vcmRpbmF0ZTtcbiAgICAgIHNlZ21lbnRzLnNvcnQodGhpcy5zb3J0QnlEaXN0YW5jZV8pO1xuICAgICAgdmFyIGNsb3Nlc3RTZWdtZW50ID0gc2VnbWVudHNbMF0uc2VnbWVudDtcbiAgICAgIHZhciBpc0NpcmNsZSA9IHNlZ21lbnRzWzBdLmZlYXR1cmUuZ2V0R2VvbWV0cnkoKS5nZXRUeXBlKCkgPT09XG4gICAgICAgICAgR2VvbWV0cnlUeXBlLkNJUkNMRTtcbiAgICAgIGlmICh0aGlzLnZlcnRleF8gJiYgIXRoaXMuZWRnZV8pIHtcbiAgICAgICAgcGl4ZWwxID0gbWFwLmdldFBpeGVsRnJvbUNvb3JkaW5hdGUoY2xvc2VzdFNlZ21lbnRbMF0pO1xuICAgICAgICBwaXhlbDIgPSBtYXAuZ2V0UGl4ZWxGcm9tQ29vcmRpbmF0ZShjbG9zZXN0U2VnbWVudFsxXSk7XG4gICAgICAgIHNxdWFyZWREaXN0MSA9IHNxdWFyZWRDb29yZGluYXRlRGlzdGFuY2UocGl4ZWwsIHBpeGVsMSk7XG4gICAgICAgIHNxdWFyZWREaXN0MiA9IHNxdWFyZWRDb29yZGluYXRlRGlzdGFuY2UocGl4ZWwsIHBpeGVsMik7XG4gICAgICAgIGRpc3QgPSBNYXRoLnNxcnQoTWF0aC5taW4oc3F1YXJlZERpc3QxLCBzcXVhcmVkRGlzdDIpKTtcbiAgICAgICAgc25hcHBlZFRvVmVydGV4ID0gZGlzdCA8PSB0aGlzLnBpeGVsVG9sZXJhbmNlXztcbiAgICAgICAgaWYgKHNuYXBwZWRUb1ZlcnRleCkge1xuICAgICAgICAgIHNuYXBwZWQgPSB0cnVlO1xuICAgICAgICAgIHZlcnRleCA9IHNxdWFyZWREaXN0MSA+IHNxdWFyZWREaXN0MiA/IGNsb3Nlc3RTZWdtZW50WzFdIDogY2xvc2VzdFNlZ21lbnRbMF07XG4gICAgICAgICAgdmVydGV4UGl4ZWwgPSBtYXAuZ2V0UGl4ZWxGcm9tQ29vcmRpbmF0ZSh2ZXJ0ZXgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZWRnZV8pIHtcbiAgICAgICAgaWYgKGlzQ2lyY2xlKSB7XG4gICAgICAgICAgdmVydGV4ID0gY2xvc2VzdE9uQ2lyY2xlKHBpeGVsQ29vcmRpbmF0ZSxcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vZ2VvbS9DaXJjbGUuanNcIikuZGVmYXVsdH0gKi8gKHNlZ21lbnRzWzBdLmZlYXR1cmUuZ2V0R2VvbWV0cnkoKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZlcnRleCA9IGNsb3Nlc3RPblNlZ21lbnQocGl4ZWxDb29yZGluYXRlLCBjbG9zZXN0U2VnbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdmVydGV4UGl4ZWwgPSBtYXAuZ2V0UGl4ZWxGcm9tQ29vcmRpbmF0ZSh2ZXJ0ZXgpO1xuICAgICAgICBpZiAoY29vcmRpbmF0ZURpc3RhbmNlKHBpeGVsLCB2ZXJ0ZXhQaXhlbCkgPD0gdGhpcy5waXhlbFRvbGVyYW5jZV8pIHtcbiAgICAgICAgICBzbmFwcGVkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAodGhpcy52ZXJ0ZXhfICYmICFpc0NpcmNsZSkge1xuICAgICAgICAgICAgcGl4ZWwxID0gbWFwLmdldFBpeGVsRnJvbUNvb3JkaW5hdGUoY2xvc2VzdFNlZ21lbnRbMF0pO1xuICAgICAgICAgICAgcGl4ZWwyID0gbWFwLmdldFBpeGVsRnJvbUNvb3JkaW5hdGUoY2xvc2VzdFNlZ21lbnRbMV0pO1xuICAgICAgICAgICAgc3F1YXJlZERpc3QxID0gc3F1YXJlZENvb3JkaW5hdGVEaXN0YW5jZSh2ZXJ0ZXhQaXhlbCwgcGl4ZWwxKTtcbiAgICAgICAgICAgIHNxdWFyZWREaXN0MiA9IHNxdWFyZWRDb29yZGluYXRlRGlzdGFuY2UodmVydGV4UGl4ZWwsIHBpeGVsMik7XG4gICAgICAgICAgICBkaXN0ID0gTWF0aC5zcXJ0KE1hdGgubWluKHNxdWFyZWREaXN0MSwgc3F1YXJlZERpc3QyKSk7XG4gICAgICAgICAgICBzbmFwcGVkVG9WZXJ0ZXggPSBkaXN0IDw9IHRoaXMucGl4ZWxUb2xlcmFuY2VfO1xuICAgICAgICAgICAgaWYgKHNuYXBwZWRUb1ZlcnRleCkge1xuICAgICAgICAgICAgICB2ZXJ0ZXggPSBzcXVhcmVkRGlzdDEgPiBzcXVhcmVkRGlzdDIgPyBjbG9zZXN0U2VnbWVudFsxXSA6IGNsb3Nlc3RTZWdtZW50WzBdO1xuICAgICAgICAgICAgICB2ZXJ0ZXhQaXhlbCA9IG1hcC5nZXRQaXhlbEZyb21Db29yZGluYXRlKHZlcnRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc25hcHBlZCkge1xuICAgICAgICB2ZXJ0ZXhQaXhlbCA9IFtNYXRoLnJvdW5kKHZlcnRleFBpeGVsWzBdKSwgTWF0aC5yb3VuZCh2ZXJ0ZXhQaXhlbFsxXSldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgLyoqIEB0eXBlIHtSZXN1bHR9ICovICh7XG4gICAgICAgIHNuYXBwZWQ6IHNuYXBwZWQsXG4gICAgICAgIHZlcnRleDogdmVydGV4LFxuICAgICAgICB2ZXJ0ZXhQaXhlbDogdmVydGV4UGl4ZWxcbiAgICAgIH0pXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgU25hcC5wcm90b3R5cGUudXBkYXRlRmVhdHVyZV8gPSBmdW5jdGlvbiB1cGRhdGVGZWF0dXJlXyAoZmVhdHVyZSkge1xuICAgIHRoaXMucmVtb3ZlRmVhdHVyZShmZWF0dXJlLCBmYWxzZSk7XG4gICAgdGhpcy5hZGRGZWF0dXJlKGZlYXR1cmUsIGZhbHNlKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZVxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vQ2lyY2xlLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgU25hcC5wcm90b3R5cGUud3JpdGVDaXJjbGVHZW9tZXRyeV8gPSBmdW5jdGlvbiB3cml0ZUNpcmNsZUdlb21ldHJ5XyAoZmVhdHVyZSwgZ2VvbWV0cnkpIHtcbiAgICB2YXIgcG9seWdvbiA9IGZyb21DaXJjbGUoZ2VvbWV0cnkpO1xuICAgIHZhciBjb29yZGluYXRlcyA9IHBvbHlnb24uZ2V0Q29vcmRpbmF0ZXMoKVswXTtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBjb29yZGluYXRlcy5sZW5ndGggLSAxOyBpIDwgaWk7ICsraSkge1xuICAgICAgdmFyIHNlZ21lbnQgPSBjb29yZGluYXRlcy5zbGljZShpLCBpICsgMik7XG4gICAgICB2YXIgc2VnbWVudERhdGEgPSAvKiogQHR5cGUge1NlZ21lbnREYXRhfSAqLyAoe1xuICAgICAgICBmZWF0dXJlOiBmZWF0dXJlLFxuICAgICAgICBzZWdtZW50OiBzZWdtZW50XG4gICAgICB9KTtcbiAgICAgIHRoaXMuckJ1c2hfLmluc2VydChib3VuZGluZ0V4dGVudChzZWdtZW50KSwgc2VnbWVudERhdGEpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZVxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnlDb2xsZWN0aW9uLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgU25hcC5wcm90b3R5cGUud3JpdGVHZW9tZXRyeUNvbGxlY3Rpb25HZW9tZXRyeV8gPSBmdW5jdGlvbiB3cml0ZUdlb21ldHJ5Q29sbGVjdGlvbkdlb21ldHJ5XyAoZmVhdHVyZSwgZ2VvbWV0cnkpIHtcbiAgICB2YXIgZ2VvbWV0cmllcyA9IGdlb21ldHJ5LmdldEdlb21ldHJpZXNBcnJheSgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbWV0cmllcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHNlZ21lbnRXcml0ZXIgPSB0aGlzLlNFR01FTlRfV1JJVEVSU19bZ2VvbWV0cmllc1tpXS5nZXRUeXBlKCldO1xuICAgICAgaWYgKHNlZ21lbnRXcml0ZXIpIHtcbiAgICAgICAgc2VnbWVudFdyaXRlci5jYWxsKHRoaXMsIGZlYXR1cmUsIGdlb21ldHJpZXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZVxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vTGluZVN0cmluZy5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFNuYXAucHJvdG90eXBlLndyaXRlTGluZVN0cmluZ0dlb21ldHJ5XyA9IGZ1bmN0aW9uIHdyaXRlTGluZVN0cmluZ0dlb21ldHJ5XyAoZmVhdHVyZSwgZ2VvbWV0cnkpIHtcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRDb29yZGluYXRlcygpO1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aCAtIDE7IGkgPCBpaTsgKytpKSB7XG4gICAgICB2YXIgc2VnbWVudCA9IGNvb3JkaW5hdGVzLnNsaWNlKGksIGkgKyAyKTtcbiAgICAgIHZhciBzZWdtZW50RGF0YSA9IC8qKiBAdHlwZSB7U2VnbWVudERhdGF9ICovICh7XG4gICAgICAgIGZlYXR1cmU6IGZlYXR1cmUsXG4gICAgICAgIHNlZ21lbnQ6IHNlZ21lbnRcbiAgICAgIH0pO1xuICAgICAgdGhpcy5yQnVzaF8uaW5zZXJ0KGJvdW5kaW5nRXh0ZW50KHNlZ21lbnQpLCBzZWdtZW50RGF0YSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9NdWx0aUxpbmVTdHJpbmcuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBTbmFwLnByb3RvdHlwZS53cml0ZU11bHRpTGluZVN0cmluZ0dlb21ldHJ5XyA9IGZ1bmN0aW9uIHdyaXRlTXVsdGlMaW5lU3RyaW5nR2VvbWV0cnlfIChmZWF0dXJlLCBnZW9tZXRyeSkge1xuICAgIHZhciBsaW5lcyA9IGdlb21ldHJ5LmdldENvb3JkaW5hdGVzKCk7XG4gICAgZm9yICh2YXIgaiA9IDAsIGpqID0gbGluZXMubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgdmFyIGNvb3JkaW5hdGVzID0gbGluZXNbal07XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBjb29yZGluYXRlcy5sZW5ndGggLSAxOyBpIDwgaWk7ICsraSkge1xuICAgICAgICB2YXIgc2VnbWVudCA9IGNvb3JkaW5hdGVzLnNsaWNlKGksIGkgKyAyKTtcbiAgICAgICAgdmFyIHNlZ21lbnREYXRhID0gLyoqIEB0eXBlIHtTZWdtZW50RGF0YX0gKi8gKHtcbiAgICAgICAgICBmZWF0dXJlOiBmZWF0dXJlLFxuICAgICAgICAgIHNlZ21lbnQ6IHNlZ21lbnRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuckJ1c2hfLmluc2VydChib3VuZGluZ0V4dGVudChzZWdtZW50KSwgc2VnbWVudERhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZVxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vTXVsdGlQb2ludC5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFNuYXAucHJvdG90eXBlLndyaXRlTXVsdGlQb2ludEdlb21ldHJ5XyA9IGZ1bmN0aW9uIHdyaXRlTXVsdGlQb2ludEdlb21ldHJ5XyAoZmVhdHVyZSwgZ2VvbWV0cnkpIHtcbiAgICB2YXIgcG9pbnRzID0gZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgdmFyIGNvb3JkaW5hdGVzID0gcG9pbnRzW2ldO1xuICAgICAgdmFyIHNlZ21lbnREYXRhID0gLyoqIEB0eXBlIHtTZWdtZW50RGF0YX0gKi8gKHtcbiAgICAgICAgZmVhdHVyZTogZmVhdHVyZSxcbiAgICAgICAgc2VnbWVudDogW2Nvb3JkaW5hdGVzLCBjb29yZGluYXRlc11cbiAgICAgIH0pO1xuICAgICAgdGhpcy5yQnVzaF8uaW5zZXJ0KGdlb21ldHJ5LmdldEV4dGVudCgpLCBzZWdtZW50RGF0YSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9NdWx0aVBvbHlnb24uanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBTbmFwLnByb3RvdHlwZS53cml0ZU11bHRpUG9seWdvbkdlb21ldHJ5XyA9IGZ1bmN0aW9uIHdyaXRlTXVsdGlQb2x5Z29uR2VvbWV0cnlfIChmZWF0dXJlLCBnZW9tZXRyeSkge1xuICAgIHZhciBwb2x5Z29ucyA9IGdlb21ldHJ5LmdldENvb3JkaW5hdGVzKCk7XG4gICAgZm9yICh2YXIgayA9IDAsIGtrID0gcG9seWdvbnMubGVuZ3RoOyBrIDwga2s7ICsraykge1xuICAgICAgdmFyIHJpbmdzID0gcG9seWdvbnNba107XG4gICAgICBmb3IgKHZhciBqID0gMCwgamogPSByaW5ncy5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgICAgIHZhciBjb29yZGluYXRlcyA9IHJpbmdzW2pdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBjb29yZGluYXRlcy5sZW5ndGggLSAxOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgIHZhciBzZWdtZW50ID0gY29vcmRpbmF0ZXMuc2xpY2UoaSwgaSArIDIpO1xuICAgICAgICAgIHZhciBzZWdtZW50RGF0YSA9IC8qKiBAdHlwZSB7U2VnbWVudERhdGF9ICovICh7XG4gICAgICAgICAgICBmZWF0dXJlOiBmZWF0dXJlLFxuICAgICAgICAgICAgc2VnbWVudDogc2VnbWVudFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuckJ1c2hfLmluc2VydChib3VuZGluZ0V4dGVudChzZWdtZW50KSwgc2VnbWVudERhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9Qb2ludC5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFNuYXAucHJvdG90eXBlLndyaXRlUG9pbnRHZW9tZXRyeV8gPSBmdW5jdGlvbiB3cml0ZVBvaW50R2VvbWV0cnlfIChmZWF0dXJlLCBnZW9tZXRyeSkge1xuICAgIHZhciBjb29yZGluYXRlcyA9IGdlb21ldHJ5LmdldENvb3JkaW5hdGVzKCk7XG4gICAgdmFyIHNlZ21lbnREYXRhID0gLyoqIEB0eXBlIHtTZWdtZW50RGF0YX0gKi8gKHtcbiAgICAgIGZlYXR1cmU6IGZlYXR1cmUsXG4gICAgICBzZWdtZW50OiBbY29vcmRpbmF0ZXMsIGNvb3JkaW5hdGVzXVxuICAgIH0pO1xuICAgIHRoaXMuckJ1c2hfLmluc2VydChnZW9tZXRyeS5nZXRFeHRlbnQoKSwgc2VnbWVudERhdGEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9Qb2x5Z29uLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgU25hcC5wcm90b3R5cGUud3JpdGVQb2x5Z29uR2VvbWV0cnlfID0gZnVuY3Rpb24gd3JpdGVQb2x5Z29uR2VvbWV0cnlfIChmZWF0dXJlLCBnZW9tZXRyeSkge1xuICAgIHZhciByaW5ncyA9IGdlb21ldHJ5LmdldENvb3JkaW5hdGVzKCk7XG4gICAgZm9yICh2YXIgaiA9IDAsIGpqID0gcmluZ3MubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgdmFyIGNvb3JkaW5hdGVzID0gcmluZ3Nbal07XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBjb29yZGluYXRlcy5sZW5ndGggLSAxOyBpIDwgaWk7ICsraSkge1xuICAgICAgICB2YXIgc2VnbWVudCA9IGNvb3JkaW5hdGVzLnNsaWNlKGksIGkgKyAyKTtcbiAgICAgICAgdmFyIHNlZ21lbnREYXRhID0gLyoqIEB0eXBlIHtTZWdtZW50RGF0YX0gKi8gKHtcbiAgICAgICAgICBmZWF0dXJlOiBmZWF0dXJlLFxuICAgICAgICAgIHNlZ21lbnQ6IHNlZ21lbnRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuckJ1c2hfLmluc2VydChib3VuZGluZ0V4dGVudChzZWdtZW50KSwgc2VnbWVudERhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gU25hcDtcbn0oUG9pbnRlckludGVyYWN0aW9uKSk7XG5cblxuLyoqXG4gKiBTb3J0IHNlZ21lbnRzIGJ5IGRpc3RhbmNlLCBoZWxwZXIgZnVuY3Rpb25cbiAqIEBwYXJhbSB7U2VnbWVudERhdGF9IGEgVGhlIGZpcnN0IHNlZ21lbnQgZGF0YS5cbiAqIEBwYXJhbSB7U2VnbWVudERhdGF9IGIgVGhlIHNlY29uZCBzZWdtZW50IGRhdGEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBkaWZmZXJlbmNlIGluIGRpc3RhbmNlLlxuICogQHRoaXMge1NuYXB9XG4gKi9cbmZ1bmN0aW9uIHNvcnRCeURpc3RhbmNlKGEsIGIpIHtcbiAgdmFyIGRlbHRhQSA9IHNxdWFyZWREaXN0YW5jZVRvU2VnbWVudCh0aGlzLnBpeGVsQ29vcmRpbmF0ZV8sIGEuc2VnbWVudCk7XG4gIHZhciBkZWx0YUIgPSBzcXVhcmVkRGlzdGFuY2VUb1NlZ21lbnQodGhpcy5waXhlbENvb3JkaW5hdGVfLCBiLnNlZ21lbnQpO1xuICByZXR1cm4gZGVsdGFBIC0gZGVsdGFCO1xufVxuXG5leHBvcnQgZGVmYXVsdCBTbmFwO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1TbmFwLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9UcmFuc2xhdGVcbiAqL1xuaW1wb3J0IENvbGxlY3Rpb24gZnJvbSAnLi4vQ29sbGVjdGlvbi5qcyc7XG5pbXBvcnQge2dldENoYW5nZUV2ZW50VHlwZX0gZnJvbSAnLi4vT2JqZWN0LmpzJztcbmltcG9ydCB7bGlzdGVufSBmcm9tICcuLi9ldmVudHMuanMnO1xuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cy9FdmVudC5qcyc7XG5pbXBvcnQge1RSVUV9IGZyb20gJy4uL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQge2luY2x1ZGVzfSBmcm9tICcuLi9hcnJheS5qcyc7XG5pbXBvcnQgUG9pbnRlckludGVyYWN0aW9uIGZyb20gJy4vUG9pbnRlci5qcyc7XG5pbXBvcnQgSW50ZXJhY3Rpb25Qcm9wZXJ0eSBmcm9tICcuL1Byb3BlcnR5LmpzJztcblxuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbnZhciBUcmFuc2xhdGVFdmVudFR5cGUgPSB7XG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgdXBvbiBmZWF0dXJlIHRyYW5zbGF0aW9uIHN0YXJ0LlxuICAgKiBAZXZlbnQgVHJhbnNsYXRlRXZlbnQjdHJhbnNsYXRlc3RhcnRcbiAgICogQGFwaVxuICAgKi9cbiAgVFJBTlNMQVRFU1RBUlQ6ICd0cmFuc2xhdGVzdGFydCcsXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgdXBvbiBmZWF0dXJlIHRyYW5zbGF0aW9uLlxuICAgKiBAZXZlbnQgVHJhbnNsYXRlRXZlbnQjdHJhbnNsYXRpbmdcbiAgICogQGFwaVxuICAgKi9cbiAgVFJBTlNMQVRJTkc6ICd0cmFuc2xhdGluZycsXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgdXBvbiBmZWF0dXJlIHRyYW5zbGF0aW9uIGVuZC5cbiAgICogQGV2ZW50IFRyYW5zbGF0ZUV2ZW50I3RyYW5zbGF0ZWVuZFxuICAgKiBAYXBpXG4gICAqL1xuICBUUkFOU0xBVEVFTkQ6ICd0cmFuc2xhdGVlbmQnXG59O1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtDb2xsZWN0aW9uPGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59IFtmZWF0dXJlc10gT25seSBmZWF0dXJlcyBjb250YWluZWQgaW4gdGhpcyBjb2xsZWN0aW9uIHdpbGwgYmUgYWJsZSB0byBiZSB0cmFuc2xhdGVkLiBJZlxuICogbm90IHNwZWNpZmllZCwgYWxsIGZlYXR1cmVzIG9uIHRoZSBtYXAgd2lsbCBiZSBhYmxlIHRvIGJlIHRyYW5zbGF0ZWQuXG4gKiBAcHJvcGVydHkge0FycmF5PGltcG9ydChcIi4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHQ+fGZ1bmN0aW9uKGltcG9ydChcIi4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHQpOiBib29sZWFufSBbbGF5ZXJzXSBBIGxpc3Qgb2YgbGF5ZXJzIGZyb20gd2hpY2ggZmVhdHVyZXMgc2hvdWxkIGJlXG4gKiB0cmFuc2xhdGVkLiBBbHRlcm5hdGl2ZWx5LCBhIGZpbHRlciBmdW5jdGlvbiBjYW4gYmUgcHJvdmlkZWQuIFRoZVxuICogZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggbGF5ZXIgaW4gdGhlIG1hcCBhbmQgc2hvdWxkIHJldHVyblxuICogYHRydWVgIGZvciBsYXllcnMgdGhhdCB5b3Ugd2FudCB0byBiZSB0cmFuc2xhdGFibGUuIElmIHRoZSBvcHRpb24gaXNcbiAqIGFic2VudCwgYWxsIHZpc2libGUgbGF5ZXJzIHdpbGwgYmUgY29uc2lkZXJlZCB0cmFuc2xhdGFibGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2hpdFRvbGVyYW5jZT0wXSBIaXQtZGV0ZWN0aW9uIHRvbGVyYW5jZS4gUGl4ZWxzIGluc2lkZSB0aGUgcmFkaXVzIGFyb3VuZCB0aGUgZ2l2ZW4gcG9zaXRpb25cbiAqIHdpbGwgYmUgY2hlY2tlZCBmb3IgZmVhdHVyZXMuIFRoaXMgb25seSB3b3JrcyBmb3IgdGhlIGNhbnZhcyByZW5kZXJlciBhbmRcbiAqIG5vdCBmb3IgV2ViR0wuXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEV2ZW50cyBlbWl0dGVkIGJ5IHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vVHJhbnNsYXRlflRyYW5zbGF0ZX0gaW5zdGFuY2VzXG4gKiBhcmUgaW5zdGFuY2VzIG9mIHRoaXMgdHlwZS5cbiAqL1xuZXhwb3J0IHZhciBUcmFuc2xhdGVFdmVudCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEV2ZW50KSB7XG4gIGZ1bmN0aW9uIFRyYW5zbGF0ZUV2ZW50KHR5cGUsIGZlYXR1cmVzLCBjb29yZGluYXRlKSB7XG5cbiAgICBFdmVudC5jYWxsKHRoaXMsIHR5cGUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZlYXR1cmVzIGJlaW5nIHRyYW5zbGF0ZWQuXG4gICAgICogQHR5cGUge0NvbGxlY3Rpb248aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5mZWF0dXJlcyA9IGZlYXR1cmVzO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNvb3JkaW5hdGUgb2YgdGhlIGRyYWcgZXZlbnQuXG4gICAgICogQGNvbnN0XG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5jb29yZGluYXRlID0gY29vcmRpbmF0ZTtcblxuICB9XG5cbiAgaWYgKCBFdmVudCApIFRyYW5zbGF0ZUV2ZW50Ll9fcHJvdG9fXyA9IEV2ZW50O1xuICBUcmFuc2xhdGVFdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFdmVudCAmJiBFdmVudC5wcm90b3R5cGUgKTtcbiAgVHJhbnNsYXRlRXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHJhbnNsYXRlRXZlbnQ7XG5cbiAgcmV0dXJuIFRyYW5zbGF0ZUV2ZW50O1xufShFdmVudCkpO1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogSW50ZXJhY3Rpb24gZm9yIHRyYW5zbGF0aW5nIChtb3ZpbmcpIGZlYXR1cmVzLlxuICpcbiAqIEBmaXJlcyBUcmFuc2xhdGVFdmVudFxuICogQGFwaVxuICovXG52YXIgVHJhbnNsYXRlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoUG9pbnRlckludGVyYWN0aW9uKSB7XG4gIGZ1bmN0aW9uIFRyYW5zbGF0ZShvcHRfb3B0aW9ucykge1xuICAgIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgPyBvcHRfb3B0aW9ucyA6IHt9O1xuXG4gICAgUG9pbnRlckludGVyYWN0aW9uLmNhbGwoLyoqIEB0eXBlIHtpbXBvcnQoXCIuL1BvaW50ZXIuanNcIikuT3B0aW9uc30gKi8gdGhpcywgKG9wdGlvbnMpKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsYXN0IHBvc2l0aW9uIHdlIHRyYW5zbGF0ZWQgdG8uXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubGFzdENvb3JkaW5hdGVfID0gbnVsbDtcblxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0NvbGxlY3Rpb248aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZmVhdHVyZXNfID0gb3B0aW9ucy5mZWF0dXJlcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5mZWF0dXJlcyA6IG51bGw7XG5cbiAgICAvKiogQHR5cGUge2Z1bmN0aW9uKGltcG9ydChcIi4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHQpOiBib29sZWFufSAqL1xuICAgIHZhciBsYXllckZpbHRlcjtcbiAgICBpZiAob3B0aW9ucy5sYXllcnMpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5sYXllcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbGF5ZXJGaWx0ZXIgPSBvcHRpb25zLmxheWVycztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBsYXllcnMgPSBvcHRpb25zLmxheWVycztcbiAgICAgICAgbGF5ZXJGaWx0ZXIgPSBmdW5jdGlvbihsYXllcikge1xuICAgICAgICAgIHJldHVybiBpbmNsdWRlcyhsYXllcnMsIGxheWVyKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGF5ZXJGaWx0ZXIgPSBUUlVFO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydChcIi4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHQpOiBib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMubGF5ZXJGaWx0ZXJfID0gbGF5ZXJGaWx0ZXI7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5oaXRUb2xlcmFuY2VfID0gb3B0aW9ucy5oaXRUb2xlcmFuY2UgPyBvcHRpb25zLmhpdFRvbGVyYW5jZSA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5sYXN0RmVhdHVyZV8gPSBudWxsO1xuXG4gICAgbGlzdGVuKHRoaXMsXG4gICAgICBnZXRDaGFuZ2VFdmVudFR5cGUoSW50ZXJhY3Rpb25Qcm9wZXJ0eS5BQ1RJVkUpLFxuICAgICAgdGhpcy5oYW5kbGVBY3RpdmVDaGFuZ2VkXywgdGhpcyk7XG5cbiAgfVxuXG4gIGlmICggUG9pbnRlckludGVyYWN0aW9uICkgVHJhbnNsYXRlLl9fcHJvdG9fXyA9IFBvaW50ZXJJbnRlcmFjdGlvbjtcbiAgVHJhbnNsYXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBvaW50ZXJJbnRlcmFjdGlvbiAmJiBQb2ludGVySW50ZXJhY3Rpb24ucHJvdG90eXBlICk7XG4gIFRyYW5zbGF0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUcmFuc2xhdGU7XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBUcmFuc2xhdGUucHJvdG90eXBlLmhhbmRsZURvd25FdmVudCA9IGZ1bmN0aW9uIGhhbmRsZURvd25FdmVudCAoZXZlbnQpIHtcbiAgICB0aGlzLmxhc3RGZWF0dXJlXyA9IHRoaXMuZmVhdHVyZXNBdFBpeGVsXyhldmVudC5waXhlbCwgZXZlbnQubWFwKTtcbiAgICBpZiAoIXRoaXMubGFzdENvb3JkaW5hdGVfICYmIHRoaXMubGFzdEZlYXR1cmVfKSB7XG4gICAgICB0aGlzLmxhc3RDb29yZGluYXRlXyA9IGV2ZW50LmNvb3JkaW5hdGU7XG4gICAgICB0aGlzLmhhbmRsZU1vdmVFdmVudChldmVudCk7XG5cbiAgICAgIHZhciBmZWF0dXJlcyA9IHRoaXMuZmVhdHVyZXNfIHx8IG5ldyBDb2xsZWN0aW9uKFt0aGlzLmxhc3RGZWF0dXJlX10pO1xuXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICAgIG5ldyBUcmFuc2xhdGVFdmVudChcbiAgICAgICAgICBUcmFuc2xhdGVFdmVudFR5cGUuVFJBTlNMQVRFU1RBUlQsIGZlYXR1cmVzLFxuICAgICAgICAgIGV2ZW50LmNvb3JkaW5hdGUpKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBUcmFuc2xhdGUucHJvdG90eXBlLmhhbmRsZVVwRXZlbnQgPSBmdW5jdGlvbiBoYW5kbGVVcEV2ZW50IChldmVudCkge1xuICAgIGlmICh0aGlzLmxhc3RDb29yZGluYXRlXykge1xuICAgICAgdGhpcy5sYXN0Q29vcmRpbmF0ZV8gPSBudWxsO1xuICAgICAgdGhpcy5oYW5kbGVNb3ZlRXZlbnQoZXZlbnQpO1xuXG4gICAgICB2YXIgZmVhdHVyZXMgPSB0aGlzLmZlYXR1cmVzXyB8fCBuZXcgQ29sbGVjdGlvbihbdGhpcy5sYXN0RmVhdHVyZV9dKTtcblxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgICBuZXcgVHJhbnNsYXRlRXZlbnQoXG4gICAgICAgICAgVHJhbnNsYXRlRXZlbnRUeXBlLlRSQU5TTEFURUVORCwgZmVhdHVyZXMsXG4gICAgICAgICAgZXZlbnQuY29vcmRpbmF0ZSkpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIFRyYW5zbGF0ZS5wcm90b3R5cGUuaGFuZGxlRHJhZ0V2ZW50ID0gZnVuY3Rpb24gaGFuZGxlRHJhZ0V2ZW50IChldmVudCkge1xuICAgIGlmICh0aGlzLmxhc3RDb29yZGluYXRlXykge1xuICAgICAgdmFyIG5ld0Nvb3JkaW5hdGUgPSBldmVudC5jb29yZGluYXRlO1xuICAgICAgdmFyIGRlbHRhWCA9IG5ld0Nvb3JkaW5hdGVbMF0gLSB0aGlzLmxhc3RDb29yZGluYXRlX1swXTtcbiAgICAgIHZhciBkZWx0YVkgPSBuZXdDb29yZGluYXRlWzFdIC0gdGhpcy5sYXN0Q29vcmRpbmF0ZV9bMV07XG5cbiAgICAgIHZhciBmZWF0dXJlcyA9IHRoaXMuZmVhdHVyZXNfIHx8IG5ldyBDb2xsZWN0aW9uKFt0aGlzLmxhc3RGZWF0dXJlX10pO1xuXG4gICAgICBmZWF0dXJlcy5mb3JFYWNoKGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgICAgICAgdmFyIGdlb20gPSBmZWF0dXJlLmdldEdlb21ldHJ5KCk7XG4gICAgICAgIGdlb20udHJhbnNsYXRlKGRlbHRhWCwgZGVsdGFZKTtcbiAgICAgICAgZmVhdHVyZS5zZXRHZW9tZXRyeShnZW9tKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmxhc3RDb29yZGluYXRlXyA9IG5ld0Nvb3JkaW5hdGU7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICAgIG5ldyBUcmFuc2xhdGVFdmVudChcbiAgICAgICAgICBUcmFuc2xhdGVFdmVudFR5cGUuVFJBTlNMQVRJTkcsIGZlYXR1cmVzLFxuICAgICAgICAgIG5ld0Nvb3JkaW5hdGUpKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBUcmFuc2xhdGUucHJvdG90eXBlLmhhbmRsZU1vdmVFdmVudCA9IGZ1bmN0aW9uIGhhbmRsZU1vdmVFdmVudCAoZXZlbnQpIHtcbiAgICB2YXIgZWxlbSA9IGV2ZW50Lm1hcC5nZXRWaWV3cG9ydCgpO1xuXG4gICAgLy8gQ2hhbmdlIHRoZSBjdXJzb3IgdG8gZ3JhYi9ncmFiYmluZyBpZiBob3ZlcmluZyBhbnkgb2YgdGhlIGZlYXR1cmVzIG1hbmFnZWRcbiAgICAvLyBieSB0aGUgaW50ZXJhY3Rpb25cbiAgICBpZiAodGhpcy5mZWF0dXJlc0F0UGl4ZWxfKGV2ZW50LnBpeGVsLCBldmVudC5tYXApKSB7XG4gICAgICBlbGVtLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5sYXN0Q29vcmRpbmF0ZV8gPyAnb2wtZ3JhYicgOiAnb2wtZ3JhYmJpbmcnKTtcbiAgICAgIGVsZW0uY2xhc3NMaXN0LmFkZCh0aGlzLmxhc3RDb29yZGluYXRlXyA/ICdvbC1ncmFiYmluZycgOiAnb2wtZ3JhYicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtLmNsYXNzTGlzdC5yZW1vdmUoJ29sLWdyYWInLCAnb2wtZ3JhYmJpbmcnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFRlc3RzIHRvIHNlZSBpZiB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXMgaW50ZXJzZWN0cyBhbnkgb2Ygb3VyIHNlbGVjdGVkXG4gICAqIGZlYXR1cmVzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsfSBwaXhlbCBQaXhlbCBjb29yZGluYXRlIHRvIHRlc3QgZm9yIGludGVyc2VjdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuZGVmYXVsdH0gbWFwIE1hcCB0byB0ZXN0IHRoZSBpbnRlcnNlY3Rpb24gb24uXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gUmV0dXJucyB0aGUgZmVhdHVyZSBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIHBpeGVsXG4gICAqIGNvb3JkaW5hdGVzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgVHJhbnNsYXRlLnByb3RvdHlwZS5mZWF0dXJlc0F0UGl4ZWxfID0gZnVuY3Rpb24gZmVhdHVyZXNBdFBpeGVsXyAocGl4ZWwsIG1hcCkge1xuICAgIHJldHVybiBtYXAuZm9yRWFjaEZlYXR1cmVBdFBpeGVsKHBpeGVsLFxuICAgICAgZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgICAgICBpZiAoIXRoaXMuZmVhdHVyZXNfIHx8IGluY2x1ZGVzKHRoaXMuZmVhdHVyZXNfLmdldEFycmF5KCksIGZlYXR1cmUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZlYXR1cmU7XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKSwge1xuICAgICAgICBsYXllckZpbHRlcjogdGhpcy5sYXllckZpbHRlcl8sXG4gICAgICAgIGhpdFRvbGVyYW5jZTogdGhpcy5oaXRUb2xlcmFuY2VfXG4gICAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgSGl0LWRldGVjdGlvbiB0b2xlcmFuY2UuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IEhpdCB0b2xlcmFuY2UgaW4gcGl4ZWxzLlxuICAgKiBAYXBpXG4gICAqL1xuICBUcmFuc2xhdGUucHJvdG90eXBlLmdldEhpdFRvbGVyYW5jZSA9IGZ1bmN0aW9uIGdldEhpdFRvbGVyYW5jZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGl0VG9sZXJhbmNlXztcbiAgfTtcblxuICAvKipcbiAgICogSGl0LWRldGVjdGlvbiB0b2xlcmFuY2UuIFBpeGVscyBpbnNpZGUgdGhlIHJhZGl1cyBhcm91bmQgdGhlIGdpdmVuIHBvc2l0aW9uXG4gICAqIHdpbGwgYmUgY2hlY2tlZCBmb3IgZmVhdHVyZXMuIFRoaXMgb25seSB3b3JrcyBmb3IgdGhlIGNhbnZhcyByZW5kZXJlciBhbmRcbiAgICogbm90IGZvciBXZWJHTC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGhpdFRvbGVyYW5jZSBIaXQgdG9sZXJhbmNlIGluIHBpeGVscy5cbiAgICogQGFwaVxuICAgKi9cbiAgVHJhbnNsYXRlLnByb3RvdHlwZS5zZXRIaXRUb2xlcmFuY2UgPSBmdW5jdGlvbiBzZXRIaXRUb2xlcmFuY2UgKGhpdFRvbGVyYW5jZSkge1xuICAgIHRoaXMuaGl0VG9sZXJhbmNlXyA9IGhpdFRvbGVyYW5jZTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIFRyYW5zbGF0ZS5wcm90b3R5cGUuc2V0TWFwID0gZnVuY3Rpb24gc2V0TWFwIChtYXApIHtcbiAgICB2YXIgb2xkTWFwID0gdGhpcy5nZXRNYXAoKTtcbiAgICBQb2ludGVySW50ZXJhY3Rpb24ucHJvdG90eXBlLnNldE1hcC5jYWxsKHRoaXMsIG1hcCk7XG4gICAgdGhpcy51cGRhdGVTdGF0ZV8ob2xkTWFwKTtcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFRyYW5zbGF0ZS5wcm90b3R5cGUuaGFuZGxlQWN0aXZlQ2hhbmdlZF8gPSBmdW5jdGlvbiBoYW5kbGVBY3RpdmVDaGFuZ2VkXyAoKSB7XG4gICAgdGhpcy51cGRhdGVTdGF0ZV8obnVsbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLmRlZmF1bHR9IG9sZE1hcCBPbGQgbWFwLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgVHJhbnNsYXRlLnByb3RvdHlwZS51cGRhdGVTdGF0ZV8gPSBmdW5jdGlvbiB1cGRhdGVTdGF0ZV8gKG9sZE1hcCkge1xuICAgIHZhciBtYXAgPSB0aGlzLmdldE1hcCgpO1xuICAgIHZhciBhY3RpdmUgPSB0aGlzLmdldEFjdGl2ZSgpO1xuICAgIGlmICghbWFwIHx8ICFhY3RpdmUpIHtcbiAgICAgIG1hcCA9IG1hcCB8fCBvbGRNYXA7XG4gICAgICBpZiAobWFwKSB7XG4gICAgICAgIHZhciBlbGVtID0gbWFwLmdldFZpZXdwb3J0KCk7XG4gICAgICAgIGVsZW0uY2xhc3NMaXN0LnJlbW92ZSgnb2wtZ3JhYicsICdvbC1ncmFiYmluZycpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVHJhbnNsYXRlO1xufShQb2ludGVySW50ZXJhY3Rpb24pKTtcblxuZXhwb3J0IGRlZmF1bHQgVHJhbnNsYXRlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1UcmFuc2xhdGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2xheWVyL0Jhc2VcbiAqL1xuaW1wb3J0IHthYnN0cmFjdH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5pbXBvcnQgQmFzZU9iamVjdCBmcm9tICcuLi9PYmplY3QuanMnO1xuaW1wb3J0IExheWVyUHJvcGVydHkgZnJvbSAnLi9Qcm9wZXJ0eS5qcyc7XG5pbXBvcnQge2NsYW1wfSBmcm9tICcuLi9tYXRoLmpzJztcbmltcG9ydCB7YXNzaWdufSBmcm9tICcuLi9vYmouanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtvcGFjaXR5PTFdIE9wYWNpdHkgKDAsIDEpLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbdmlzaWJsZT10cnVlXSBWaXNpYmlsaXR5LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBbZXh0ZW50XSBUaGUgYm91bmRpbmcgZXh0ZW50IGZvciBsYXllciByZW5kZXJpbmcuICBUaGUgbGF5ZXIgd2lsbCBub3QgYmVcbiAqIHJlbmRlcmVkIG91dHNpZGUgb2YgdGhpcyBleHRlbnQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3pJbmRleF0gVGhlIHotaW5kZXggZm9yIGxheWVyIHJlbmRlcmluZy4gIEF0IHJlbmRlcmluZyB0aW1lLCB0aGUgbGF5ZXJzXG4gKiB3aWxsIGJlIG9yZGVyZWQsIGZpcnN0IGJ5IFotaW5kZXggYW5kIHRoZW4gYnkgcG9zaXRpb24uIFdoZW4gYHVuZGVmaW5lZGAsIGEgYHpJbmRleGAgb2YgMCBpcyBhc3N1bWVkXG4gKiBmb3IgbGF5ZXJzIHRoYXQgYXJlIGFkZGVkIHRvIHRoZSBtYXAncyBgbGF5ZXJzYCBjb2xsZWN0aW9uLCBvciBgSW5maW5pdHlgIHdoZW4gdGhlIGxheWVyJ3MgYHNldE1hcCgpYFxuICogbWV0aG9kIHdhcyB1c2VkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5SZXNvbHV0aW9uXSBUaGUgbWluaW11bSByZXNvbHV0aW9uIChpbmNsdXNpdmUpIGF0IHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZVxuICogdmlzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4UmVzb2x1dGlvbl0gVGhlIG1heGltdW0gcmVzb2x1dGlvbiAoZXhjbHVzaXZlKSBiZWxvdyB3aGljaCB0aGlzIGxheWVyIHdpbGxcbiAqIGJlIHZpc2libGUuXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3M7IG5vcm1hbGx5IG9ubHkgdXNlZCBmb3IgY3JlYXRpbmcgc3ViY2xhc3NlcyBhbmQgbm90XG4gKiBpbnN0YW50aWF0ZWQgaW4gYXBwcy5cbiAqIE5vdGUgdGhhdCB3aXRoIHtAbGluayBtb2R1bGU6b2wvbGF5ZXIvQmFzZX0gYW5kIGFsbCBpdHMgc3ViY2xhc3NlcywgYW55IHByb3BlcnR5IHNldCBpblxuICogdGhlIG9wdGlvbnMgaXMgc2V0IGFzIGEge0BsaW5rIG1vZHVsZTpvbC9PYmplY3R9IHByb3BlcnR5IG9uIHRoZSBsYXllciBvYmplY3QsIHNvXG4gKiBpcyBvYnNlcnZhYmxlLCBhbmQgaGFzIGdldC9zZXQgYWNjZXNzb3JzLlxuICpcbiAqIEBhcGlcbiAqL1xudmFyIEJhc2VMYXllciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEJhc2VPYmplY3QpIHtcbiAgZnVuY3Rpb24gQmFzZUxheWVyKG9wdGlvbnMpIHtcblxuICAgIEJhc2VPYmplY3QuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCAqPn1cbiAgICAgKi9cbiAgICB2YXIgcHJvcGVydGllcyA9IGFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgcHJvcGVydGllc1tMYXllclByb3BlcnR5Lk9QQUNJVFldID1cbiAgICAgICBvcHRpb25zLm9wYWNpdHkgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMub3BhY2l0eSA6IDE7XG4gICAgcHJvcGVydGllc1tMYXllclByb3BlcnR5LlZJU0lCTEVdID1cbiAgICAgICBvcHRpb25zLnZpc2libGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudmlzaWJsZSA6IHRydWU7XG4gICAgcHJvcGVydGllc1tMYXllclByb3BlcnR5LlpfSU5ERVhdID0gb3B0aW9ucy56SW5kZXg7XG4gICAgcHJvcGVydGllc1tMYXllclByb3BlcnR5Lk1BWF9SRVNPTFVUSU9OXSA9XG4gICAgICAgb3B0aW9ucy5tYXhSZXNvbHV0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1heFJlc29sdXRpb24gOiBJbmZpbml0eTtcbiAgICBwcm9wZXJ0aWVzW0xheWVyUHJvcGVydHkuTUlOX1JFU09MVVRJT05dID1cbiAgICAgICBvcHRpb25zLm1pblJlc29sdXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubWluUmVzb2x1dGlvbiA6IDA7XG5cbiAgICB0aGlzLnNldFByb3BlcnRpZXMocHJvcGVydGllcyk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9MYXllci5qc1wiKS5TdGF0ZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc3RhdGVfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsYXllciB0eXBlLlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9MYXllclR5cGUuanNcIikuZGVmYXVsdH1cbiAgICAgKiBAcHJvdGVjdGVkO1xuICAgICAqL1xuICAgIHRoaXMudHlwZTtcblxuICB9XG5cbiAgaWYgKCBCYXNlT2JqZWN0ICkgQmFzZUxheWVyLl9fcHJvdG9fXyA9IEJhc2VPYmplY3Q7XG4gIEJhc2VMYXllci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCYXNlT2JqZWN0ICYmIEJhc2VPYmplY3QucHJvdG90eXBlICk7XG4gIEJhc2VMYXllci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCYXNlTGF5ZXI7XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGF5ZXIgdHlwZSAodXNlZCB3aGVuIGNyZWF0aW5nIGEgbGF5ZXIgcmVuZGVyZXIpLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9MYXllclR5cGUuanNcIikuZGVmYXVsdH0gVGhlIGxheWVyIHR5cGUuXG4gICAqL1xuICBCYXNlTGF5ZXIucHJvdG90eXBlLmdldFR5cGUgPSBmdW5jdGlvbiBnZXRUeXBlICgpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL0xheWVyLmpzXCIpLlN0YXRlfSBMYXllciBzdGF0ZS5cbiAgICovXG4gIEJhc2VMYXllci5wcm90b3R5cGUuZ2V0TGF5ZXJTdGF0ZSA9IGZ1bmN0aW9uIGdldExheWVyU3RhdGUgKCkge1xuICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9MYXllci5qc1wiKS5TdGF0ZX0gKi9cbiAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlXyB8fCAvKiogQHR5cGUgez99ICovICh7XG4gICAgICBsYXllcjogdGhpcyxcbiAgICAgIG1hbmFnZWQ6IHRydWVcbiAgICB9KTtcbiAgICBzdGF0ZS5vcGFjaXR5ID0gY2xhbXAodGhpcy5nZXRPcGFjaXR5KCksIDAsIDEpO1xuICAgIHN0YXRlLnNvdXJjZVN0YXRlID0gdGhpcy5nZXRTb3VyY2VTdGF0ZSgpO1xuICAgIHN0YXRlLnZpc2libGUgPSB0aGlzLmdldFZpc2libGUoKTtcbiAgICBzdGF0ZS5leHRlbnQgPSB0aGlzLmdldEV4dGVudCgpO1xuICAgIHN0YXRlLnpJbmRleCA9IHRoaXMuZ2V0WkluZGV4KCkgfHwgMDtcbiAgICBzdGF0ZS5tYXhSZXNvbHV0aW9uID0gdGhpcy5nZXRNYXhSZXNvbHV0aW9uKCk7XG4gICAgc3RhdGUubWluUmVzb2x1dGlvbiA9IE1hdGgubWF4KHRoaXMuZ2V0TWluUmVzb2x1dGlvbigpLCAwKTtcbiAgICB0aGlzLnN0YXRlXyA9IHN0YXRlO1xuXG4gICAgcmV0dXJuIHN0YXRlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuL0xheWVyLmpzXCIpLmRlZmF1bHQ+PX0gb3B0X2FycmF5IEFycmF5IG9mIGxheWVycyAodG8gYmVcbiAgICogICAgIG1vZGlmaWVkIGluIHBsYWNlKS5cbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi9MYXllci5qc1wiKS5kZWZhdWx0Pn0gQXJyYXkgb2YgbGF5ZXJzLlxuICAgKi9cbiAgQmFzZUxheWVyLnByb3RvdHlwZS5nZXRMYXllcnNBcnJheSA9IGZ1bmN0aW9uIGdldExheWVyc0FycmF5IChvcHRfYXJyYXkpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfTtcblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi9MYXllci5qc1wiKS5TdGF0ZT49fSBvcHRfc3RhdGVzIE9wdGlvbmFsIGxpc3Qgb2YgbGF5ZXJcbiAgICogICAgIHN0YXRlcyAodG8gYmUgbW9kaWZpZWQgaW4gcGxhY2UpLlxuICAgKiBAcmV0dXJuIHtBcnJheTxpbXBvcnQoXCIuL0xheWVyLmpzXCIpLlN0YXRlPn0gTGlzdCBvZiBsYXllciBzdGF0ZXMuXG4gICAqL1xuICBCYXNlTGF5ZXIucHJvdG90eXBlLmdldExheWVyU3RhdGVzQXJyYXkgPSBmdW5jdGlvbiBnZXRMYXllclN0YXRlc0FycmF5IChvcHRfc3RhdGVzKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUge0BsaW5rIG1vZHVsZTpvbC9leHRlbnR+RXh0ZW50IGV4dGVudH0gb2YgdGhlIGxheWVyIG9yIGB1bmRlZmluZWRgIGlmIGl0XG4gICAqIHdpbGwgYmUgdmlzaWJsZSByZWdhcmRsZXNzIG9mIGV4dGVudC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudHx1bmRlZmluZWR9IFRoZSBsYXllciBleHRlbnQuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIEJhc2VMYXllci5wcm90b3R5cGUuZ2V0RXh0ZW50ID0gZnVuY3Rpb24gZ2V0RXh0ZW50ICgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fHVuZGVmaW5lZH0gKi8gKHRoaXMuZ2V0KExheWVyUHJvcGVydHkuRVhURU5UKSlcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG1heGltdW0gcmVzb2x1dGlvbiBvZiB0aGUgbGF5ZXIuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1heGltdW0gcmVzb2x1dGlvbiBvZiB0aGUgbGF5ZXIuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIEJhc2VMYXllci5wcm90b3R5cGUuZ2V0TWF4UmVzb2x1dGlvbiA9IGZ1bmN0aW9uIGdldE1heFJlc29sdXRpb24gKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge251bWJlcn0gKi8gKHRoaXMuZ2V0KExheWVyUHJvcGVydHkuTUFYX1JFU09MVVRJT04pKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBtaW5pbXVtIHJlc29sdXRpb24gb2YgdGhlIGxheWVyLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBtaW5pbXVtIHJlc29sdXRpb24gb2YgdGhlIGxheWVyLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBCYXNlTGF5ZXIucHJvdG90eXBlLmdldE1pblJlc29sdXRpb24gPSBmdW5jdGlvbiBnZXRNaW5SZXNvbHV0aW9uICgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ9ICovICh0aGlzLmdldChMYXllclByb3BlcnR5Lk1JTl9SRVNPTFVUSU9OKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgb3BhY2l0eSBvZiB0aGUgbGF5ZXIgKGJldHdlZW4gMCBhbmQgMSkuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG9wYWNpdHkgb2YgdGhlIGxheWVyLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBCYXNlTGF5ZXIucHJvdG90eXBlLmdldE9wYWNpdHkgPSBmdW5jdGlvbiBnZXRPcGFjaXR5ICgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ9ICovICh0aGlzLmdldChMYXllclByb3BlcnR5Lk9QQUNJVFkpKTtcbiAgfTtcblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3NvdXJjZS9TdGF0ZS5qc1wiKS5kZWZhdWx0fSBTb3VyY2Ugc3RhdGUuXG4gICAqL1xuICBCYXNlTGF5ZXIucHJvdG90eXBlLmdldFNvdXJjZVN0YXRlID0gZnVuY3Rpb24gZ2V0U291cmNlU3RhdGUgKCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHZpc2liaWxpdHkgb2YgdGhlIGxheWVyIChgdHJ1ZWAgb3IgYGZhbHNlYCkuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB2aXNpYmlsaXR5IG9mIHRoZSBsYXllci5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgQmFzZUxheWVyLnByb3RvdHlwZS5nZXRWaXNpYmxlID0gZnVuY3Rpb24gZ2V0VmlzaWJsZSAoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi8gKHRoaXMuZ2V0KExheWVyUHJvcGVydHkuVklTSUJMRSkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIFotaW5kZXggb2YgdGhlIGxheWVyLCB3aGljaCBpcyB1c2VkIHRvIG9yZGVyIGxheWVycyBiZWZvcmVcbiAgICogcmVuZGVyaW5nLiBUaGUgZGVmYXVsdCBaLWluZGV4IGlzIDAuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIFotaW5kZXggb2YgdGhlIGxheWVyLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBCYXNlTGF5ZXIucHJvdG90eXBlLmdldFpJbmRleCA9IGZ1bmN0aW9uIGdldFpJbmRleCAoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5nZXQoTGF5ZXJQcm9wZXJ0eS5aX0lOREVYKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZXh0ZW50IGF0IHdoaWNoIHRoZSBsYXllciBpcyB2aXNpYmxlLiAgSWYgYHVuZGVmaW5lZGAsIHRoZSBsYXllclxuICAgKiB3aWxsIGJlIHZpc2libGUgYXQgYWxsIGV4dGVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudHx1bmRlZmluZWR9IGV4dGVudCBUaGUgZXh0ZW50IG9mIHRoZSBsYXllci5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgQmFzZUxheWVyLnByb3RvdHlwZS5zZXRFeHRlbnQgPSBmdW5jdGlvbiBzZXRFeHRlbnQgKGV4dGVudCkge1xuICAgIHRoaXMuc2V0KExheWVyUHJvcGVydHkuRVhURU5ULCBleHRlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIG1heGltdW0gcmVzb2x1dGlvbiBhdCB3aGljaCB0aGUgbGF5ZXIgaXMgdmlzaWJsZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heFJlc29sdXRpb24gVGhlIG1heGltdW0gcmVzb2x1dGlvbiBvZiB0aGUgbGF5ZXIuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIEJhc2VMYXllci5wcm90b3R5cGUuc2V0TWF4UmVzb2x1dGlvbiA9IGZ1bmN0aW9uIHNldE1heFJlc29sdXRpb24gKG1heFJlc29sdXRpb24pIHtcbiAgICB0aGlzLnNldChMYXllclByb3BlcnR5Lk1BWF9SRVNPTFVUSU9OLCBtYXhSZXNvbHV0aW9uKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBtaW5pbXVtIHJlc29sdXRpb24gYXQgd2hpY2ggdGhlIGxheWVyIGlzIHZpc2libGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5SZXNvbHV0aW9uIFRoZSBtaW5pbXVtIHJlc29sdXRpb24gb2YgdGhlIGxheWVyLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBCYXNlTGF5ZXIucHJvdG90eXBlLnNldE1pblJlc29sdXRpb24gPSBmdW5jdGlvbiBzZXRNaW5SZXNvbHV0aW9uIChtaW5SZXNvbHV0aW9uKSB7XG4gICAgdGhpcy5zZXQoTGF5ZXJQcm9wZXJ0eS5NSU5fUkVTT0xVVElPTiwgbWluUmVzb2x1dGlvbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgb3BhY2l0eSBvZiB0aGUgbGF5ZXIsIGFsbG93ZWQgdmFsdWVzIHJhbmdlIGZyb20gMCB0byAxLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb3BhY2l0eSBUaGUgb3BhY2l0eSBvZiB0aGUgbGF5ZXIuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIEJhc2VMYXllci5wcm90b3R5cGUuc2V0T3BhY2l0eSA9IGZ1bmN0aW9uIHNldE9wYWNpdHkgKG9wYWNpdHkpIHtcbiAgICB0aGlzLnNldChMYXllclByb3BlcnR5Lk9QQUNJVFksIG9wYWNpdHkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGxheWVyIChgdHJ1ZWAgb3IgYGZhbHNlYCkuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmlzaWJsZSBUaGUgdmlzaWJpbGl0eSBvZiB0aGUgbGF5ZXIuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIEJhc2VMYXllci5wcm90b3R5cGUuc2V0VmlzaWJsZSA9IGZ1bmN0aW9uIHNldFZpc2libGUgKHZpc2libGUpIHtcbiAgICB0aGlzLnNldChMYXllclByb3BlcnR5LlZJU0lCTEUsIHZpc2libGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgWi1pbmRleCBvZiB0aGUgbGF5ZXIsIHdoaWNoIGlzIHVzZWQgdG8gb3JkZXIgbGF5ZXJzIGJlZm9yZSByZW5kZXJpbmcuXG4gICAqIFRoZSBkZWZhdWx0IFotaW5kZXggaXMgMC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHppbmRleCBUaGUgei1pbmRleCBvZiB0aGUgbGF5ZXIuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIEJhc2VMYXllci5wcm90b3R5cGUuc2V0WkluZGV4ID0gZnVuY3Rpb24gc2V0WkluZGV4ICh6aW5kZXgpIHtcbiAgICB0aGlzLnNldChMYXllclByb3BlcnR5LlpfSU5ERVgsIHppbmRleCk7XG4gIH07XG5cbiAgcmV0dXJuIEJhc2VMYXllcjtcbn0oQmFzZU9iamVjdCkpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VMYXllcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmFzZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvbGF5ZXIvR3JvdXBcbiAqL1xuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4uL3V0aWwuanMnO1xuaW1wb3J0IENvbGxlY3Rpb24gZnJvbSAnLi4vQ29sbGVjdGlvbi5qcyc7XG5pbXBvcnQgQ29sbGVjdGlvbkV2ZW50VHlwZSBmcm9tICcuLi9Db2xsZWN0aW9uRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7Z2V0Q2hhbmdlRXZlbnRUeXBlfSBmcm9tICcuLi9PYmplY3QuanMnO1xuaW1wb3J0IE9iamVjdEV2ZW50VHlwZSBmcm9tICcuLi9PYmplY3RFdmVudFR5cGUuanMnO1xuaW1wb3J0IHthc3NlcnR9IGZyb20gJy4uL2Fzc2VydHMuanMnO1xuaW1wb3J0IHtsaXN0ZW4sIHVubGlzdGVuQnlLZXl9IGZyb20gJy4uL2V2ZW50cy5qcyc7XG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4uL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IHtnZXRJbnRlcnNlY3Rpb259IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQgQmFzZUxheWVyIGZyb20gJy4vQmFzZS5qcyc7XG5pbXBvcnQge2Fzc2lnbiwgY2xlYXJ9IGZyb20gJy4uL29iai5qcyc7XG5pbXBvcnQgU291cmNlU3RhdGUgZnJvbSAnLi4vc291cmNlL1N0YXRlLmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbb3BhY2l0eT0xXSBPcGFjaXR5ICgwLCAxKS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Zpc2libGU9dHJ1ZV0gVmlzaWJpbGl0eS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW2V4dGVudF0gVGhlIGJvdW5kaW5nIGV4dGVudCBmb3IgbGF5ZXIgcmVuZGVyaW5nLiAgVGhlIGxheWVyIHdpbGwgbm90IGJlXG4gKiByZW5kZXJlZCBvdXRzaWRlIG9mIHRoaXMgZXh0ZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt6SW5kZXhdIFRoZSB6LWluZGV4IGZvciBsYXllciByZW5kZXJpbmcuICBBdCByZW5kZXJpbmcgdGltZSwgdGhlIGxheWVyc1xuICogd2lsbCBiZSBvcmRlcmVkLCBmaXJzdCBieSBaLWluZGV4IGFuZCB0aGVuIGJ5IHBvc2l0aW9uLiBXaGVuIGB1bmRlZmluZWRgLCBhIGB6SW5kZXhgIG9mIDAgaXMgYXNzdW1lZFxuICogZm9yIGxheWVycyB0aGF0IGFyZSBhZGRlZCB0byB0aGUgbWFwJ3MgYGxheWVyc2AgY29sbGVjdGlvbiwgb3IgYEluZmluaXR5YCB3aGVuIHRoZSBsYXllcidzIGBzZXRNYXAoKWBcbiAqIG1ldGhvZCB3YXMgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluUmVzb2x1dGlvbl0gVGhlIG1pbmltdW0gcmVzb2x1dGlvbiAoaW5jbHVzaXZlKSBhdCB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmVcbiAqIHZpc2libGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFJlc29sdXRpb25dIFRoZSBtYXhpbXVtIHJlc29sdXRpb24gKGV4Y2x1c2l2ZSkgYmVsb3cgd2hpY2ggdGhpcyBsYXllciB3aWxsXG4gKiBiZSB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtBcnJheTxpbXBvcnQoXCIuL0Jhc2UuanNcIikuZGVmYXVsdD58aW1wb3J0KFwiLi4vQ29sbGVjdGlvbi5qc1wiKS5kZWZhdWx0PGltcG9ydChcIi4vQmFzZS5qc1wiKS5kZWZhdWx0Pn0gW2xheWVyc10gQ2hpbGQgbGF5ZXJzLlxuICovXG5cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xudmFyIFByb3BlcnR5ID0ge1xuICBMQVlFUlM6ICdsYXllcnMnXG59O1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQSB7QGxpbmsgbW9kdWxlOm9sL0NvbGxlY3Rpb25+Q29sbGVjdGlvbn0gb2YgbGF5ZXJzIHRoYXQgYXJlIGhhbmRsZWQgdG9nZXRoZXIuXG4gKlxuICogQSBnZW5lcmljIGBjaGFuZ2VgIGV2ZW50IGlzIHRyaWdnZXJlZCB3aGVuIHRoZSBncm91cC9Db2xsZWN0aW9uIGNoYW5nZXMuXG4gKlxuICogQGFwaVxuICovXG52YXIgTGF5ZXJHcm91cCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEJhc2VMYXllcikge1xuICBmdW5jdGlvbiBMYXllckdyb3VwKG9wdF9vcHRpb25zKSB7XG5cbiAgICB2YXIgb3B0aW9ucyA9IG9wdF9vcHRpb25zIHx8IHt9O1xuICAgIHZhciBiYXNlT3B0aW9ucyA9IC8qKiBAdHlwZSB7T3B0aW9uc30gKi8gKGFzc2lnbih7fSwgb3B0aW9ucykpO1xuICAgIGRlbGV0ZSBiYXNlT3B0aW9ucy5sYXllcnM7XG5cbiAgICB2YXIgbGF5ZXJzID0gb3B0aW9ucy5sYXllcnM7XG5cbiAgICBCYXNlTGF5ZXIuY2FsbCh0aGlzLCBiYXNlT3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuLi9ldmVudHMuanNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLmxheWVyc0xpc3RlbmVyS2V5c18gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsIEFycmF5PGltcG9ydChcIi4uL2V2ZW50cy5qc1wiKS5FdmVudHNLZXk+Pn1cbiAgICAgKi9cbiAgICB0aGlzLmxpc3RlbmVyS2V5c18gPSB7fTtcblxuICAgIGxpc3Rlbih0aGlzLFxuICAgICAgZ2V0Q2hhbmdlRXZlbnRUeXBlKFByb3BlcnR5LkxBWUVSUyksXG4gICAgICB0aGlzLmhhbmRsZUxheWVyc0NoYW5nZWRfLCB0aGlzKTtcblxuICAgIGlmIChsYXllcnMpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGxheWVycykpIHtcbiAgICAgICAgbGF5ZXJzID0gbmV3IENvbGxlY3Rpb24obGF5ZXJzLnNsaWNlKCksIHt1bmlxdWU6IHRydWV9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzc2VydCh0eXBlb2YgLyoqIEB0eXBlIHs/fSAqLyAobGF5ZXJzKS5nZXRBcnJheSA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgICA0Myk7IC8vIEV4cGVjdGVkIGBsYXllcnNgIHRvIGJlIGFuIGFycmF5IG9yIGEgYENvbGxlY3Rpb25gXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxheWVycyA9IG5ldyBDb2xsZWN0aW9uKHVuZGVmaW5lZCwge3VuaXF1ZTogdHJ1ZX0pO1xuICAgIH1cblxuICAgIHRoaXMuc2V0TGF5ZXJzKGxheWVycyk7XG5cbiAgfVxuXG4gIGlmICggQmFzZUxheWVyICkgTGF5ZXJHcm91cC5fX3Byb3RvX18gPSBCYXNlTGF5ZXI7XG4gIExheWVyR3JvdXAucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQmFzZUxheWVyICYmIEJhc2VMYXllci5wcm90b3R5cGUgKTtcbiAgTGF5ZXJHcm91cC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMYXllckdyb3VwO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTGF5ZXJHcm91cC5wcm90b3R5cGUuaGFuZGxlTGF5ZXJDaGFuZ2VfID0gZnVuY3Rpb24gaGFuZGxlTGF5ZXJDaGFuZ2VfICgpIHtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIExheWVyR3JvdXAucHJvdG90eXBlLmhhbmRsZUxheWVyc0NoYW5nZWRfID0gZnVuY3Rpb24gaGFuZGxlTGF5ZXJzQ2hhbmdlZF8gKCkge1xuICAgIHRoaXMubGF5ZXJzTGlzdGVuZXJLZXlzXy5mb3JFYWNoKHVubGlzdGVuQnlLZXkpO1xuICAgIHRoaXMubGF5ZXJzTGlzdGVuZXJLZXlzXy5sZW5ndGggPSAwO1xuXG4gICAgdmFyIGxheWVycyA9IHRoaXMuZ2V0TGF5ZXJzKCk7XG4gICAgdGhpcy5sYXllcnNMaXN0ZW5lcktleXNfLnB1c2goXG4gICAgICBsaXN0ZW4obGF5ZXJzLCBDb2xsZWN0aW9uRXZlbnRUeXBlLkFERCwgdGhpcy5oYW5kbGVMYXllcnNBZGRfLCB0aGlzKSxcbiAgICAgIGxpc3RlbihsYXllcnMsIENvbGxlY3Rpb25FdmVudFR5cGUuUkVNT1ZFLCB0aGlzLmhhbmRsZUxheWVyc1JlbW92ZV8sIHRoaXMpXG4gICAgKTtcblxuICAgIGZvciAodmFyIGlkIGluIHRoaXMubGlzdGVuZXJLZXlzXykge1xuICAgICAgdGhpcy5saXN0ZW5lcktleXNfW2lkXS5mb3JFYWNoKHVubGlzdGVuQnlLZXkpO1xuICAgIH1cbiAgICBjbGVhcih0aGlzLmxpc3RlbmVyS2V5c18pO1xuXG4gICAgdmFyIGxheWVyc0FycmF5ID0gbGF5ZXJzLmdldEFycmF5KCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gbGF5ZXJzQXJyYXkubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgdmFyIGxheWVyID0gbGF5ZXJzQXJyYXlbaV07XG4gICAgICB0aGlzLmxpc3RlbmVyS2V5c19bZ2V0VWlkKGxheWVyKV0gPSBbXG4gICAgICAgIGxpc3RlbihsYXllciwgT2JqZWN0RXZlbnRUeXBlLlBST1BFUlRZQ0hBTkdFLCB0aGlzLmhhbmRsZUxheWVyQ2hhbmdlXywgdGhpcyksXG4gICAgICAgIGxpc3RlbihsYXllciwgRXZlbnRUeXBlLkNIQU5HRSwgdGhpcy5oYW5kbGVMYXllckNoYW5nZV8sIHRoaXMpXG4gICAgICBdO1xuICAgIH1cblxuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0NvbGxlY3Rpb24uanNcIikuQ29sbGVjdGlvbkV2ZW50fSBjb2xsZWN0aW9uRXZlbnQgQ29sbGVjdGlvbkV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTGF5ZXJHcm91cC5wcm90b3R5cGUuaGFuZGxlTGF5ZXJzQWRkXyA9IGZ1bmN0aW9uIGhhbmRsZUxheWVyc0FkZF8gKGNvbGxlY3Rpb25FdmVudCkge1xuICAgIHZhciBsYXllciA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9CYXNlLmpzXCIpLmRlZmF1bHR9ICovIChjb2xsZWN0aW9uRXZlbnQuZWxlbWVudCk7XG4gICAgdGhpcy5saXN0ZW5lcktleXNfW2dldFVpZChsYXllcildID0gW1xuICAgICAgbGlzdGVuKGxheWVyLCBPYmplY3RFdmVudFR5cGUuUFJPUEVSVFlDSEFOR0UsIHRoaXMuaGFuZGxlTGF5ZXJDaGFuZ2VfLCB0aGlzKSxcbiAgICAgIGxpc3RlbihsYXllciwgRXZlbnRUeXBlLkNIQU5HRSwgdGhpcy5oYW5kbGVMYXllckNoYW5nZV8sIHRoaXMpXG4gICAgXTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9Db2xsZWN0aW9uLmpzXCIpLkNvbGxlY3Rpb25FdmVudH0gY29sbGVjdGlvbkV2ZW50IENvbGxlY3Rpb25FdmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIExheWVyR3JvdXAucHJvdG90eXBlLmhhbmRsZUxheWVyc1JlbW92ZV8gPSBmdW5jdGlvbiBoYW5kbGVMYXllcnNSZW1vdmVfIChjb2xsZWN0aW9uRXZlbnQpIHtcbiAgICB2YXIgbGF5ZXIgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vQmFzZS5qc1wiKS5kZWZhdWx0fSAqLyAoY29sbGVjdGlvbkV2ZW50LmVsZW1lbnQpO1xuICAgIHZhciBrZXkgPSBnZXRVaWQobGF5ZXIpO1xuICAgIHRoaXMubGlzdGVuZXJLZXlzX1trZXldLmZvckVhY2godW5saXN0ZW5CeUtleSk7XG4gICAgZGVsZXRlIHRoaXMubGlzdGVuZXJLZXlzX1trZXldO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB7QGxpbmsgbW9kdWxlOm9sL0NvbGxlY3Rpb24gY29sbGVjdGlvbn0gb2Yge0BsaW5rIG1vZHVsZTpvbC9sYXllci9MYXllcn5MYXllciBsYXllcnN9XG4gICAqIGluIHRoaXMgZ3JvdXAuXG4gICAqIEByZXR1cm4geyFpbXBvcnQoXCIuLi9Db2xsZWN0aW9uLmpzXCIpLmRlZmF1bHQ8aW1wb3J0KFwiLi9CYXNlLmpzXCIpLmRlZmF1bHQ+fSBDb2xsZWN0aW9uIG9mXG4gICAqICAge0BsaW5rIG1vZHVsZTpvbC9sYXllci9CYXNlIGxheWVyc30gdGhhdCBhcmUgcGFydCBvZiB0aGlzIGdyb3VwLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBMYXllckdyb3VwLnByb3RvdHlwZS5nZXRMYXllcnMgPSBmdW5jdGlvbiBnZXRMYXllcnMgKCkge1xuICAgIHJldHVybiAoXG4gICAgICAvKiogQHR5cGUgeyFpbXBvcnQoXCIuLi9Db2xsZWN0aW9uLmpzXCIpLmRlZmF1bHQ8aW1wb3J0KFwiLi9CYXNlLmpzXCIpLmRlZmF1bHQ+fSAqLyAodGhpcy5nZXQoUHJvcGVydHkuTEFZRVJTKSlcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHtAbGluayBtb2R1bGU6b2wvQ29sbGVjdGlvbiBjb2xsZWN0aW9ufSBvZiB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL0xheWVyfkxheWVyIGxheWVyc31cbiAgICogaW4gdGhpcyBncm91cC5cbiAgICogQHBhcmFtIHshaW1wb3J0KFwiLi4vQ29sbGVjdGlvbi5qc1wiKS5kZWZhdWx0PGltcG9ydChcIi4vQmFzZS5qc1wiKS5kZWZhdWx0Pn0gbGF5ZXJzIENvbGxlY3Rpb24gb2ZcbiAgICogICB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL0Jhc2UgbGF5ZXJzfSB0aGF0IGFyZSBwYXJ0IG9mIHRoaXMgZ3JvdXAuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIExheWVyR3JvdXAucHJvdG90eXBlLnNldExheWVycyA9IGZ1bmN0aW9uIHNldExheWVycyAobGF5ZXJzKSB7XG4gICAgdGhpcy5zZXQoUHJvcGVydHkuTEFZRVJTLCBsYXllcnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgTGF5ZXJHcm91cC5wcm90b3R5cGUuZ2V0TGF5ZXJzQXJyYXkgPSBmdW5jdGlvbiBnZXRMYXllcnNBcnJheSAob3B0X2FycmF5KSB7XG4gICAgdmFyIGFycmF5ID0gb3B0X2FycmF5ICE9PSB1bmRlZmluZWQgPyBvcHRfYXJyYXkgOiBbXTtcbiAgICB0aGlzLmdldExheWVycygpLmZvckVhY2goZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgIGxheWVyLmdldExheWVyc0FycmF5KGFycmF5KTtcbiAgICB9KTtcbiAgICByZXR1cm4gYXJyYXk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBMYXllckdyb3VwLnByb3RvdHlwZS5nZXRMYXllclN0YXRlc0FycmF5ID0gZnVuY3Rpb24gZ2V0TGF5ZXJTdGF0ZXNBcnJheSAob3B0X3N0YXRlcykge1xuICAgIHZhciBzdGF0ZXMgPSBvcHRfc3RhdGVzICE9PSB1bmRlZmluZWQgPyBvcHRfc3RhdGVzIDogW107XG5cbiAgICB2YXIgcG9zID0gc3RhdGVzLmxlbmd0aDtcblxuICAgIHRoaXMuZ2V0TGF5ZXJzKCkuZm9yRWFjaChmdW5jdGlvbihsYXllcikge1xuICAgICAgbGF5ZXIuZ2V0TGF5ZXJTdGF0ZXNBcnJheShzdGF0ZXMpO1xuICAgIH0pO1xuXG4gICAgdmFyIG93bkxheWVyU3RhdGUgPSB0aGlzLmdldExheWVyU3RhdGUoKTtcbiAgICBmb3IgKHZhciBpID0gcG9zLCBpaSA9IHN0YXRlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICB2YXIgbGF5ZXJTdGF0ZSA9IHN0YXRlc1tpXTtcbiAgICAgIGxheWVyU3RhdGUub3BhY2l0eSAqPSBvd25MYXllclN0YXRlLm9wYWNpdHk7XG4gICAgICBsYXllclN0YXRlLnZpc2libGUgPSBsYXllclN0YXRlLnZpc2libGUgJiYgb3duTGF5ZXJTdGF0ZS52aXNpYmxlO1xuICAgICAgbGF5ZXJTdGF0ZS5tYXhSZXNvbHV0aW9uID0gTWF0aC5taW4oXG4gICAgICAgIGxheWVyU3RhdGUubWF4UmVzb2x1dGlvbiwgb3duTGF5ZXJTdGF0ZS5tYXhSZXNvbHV0aW9uKTtcbiAgICAgIGxheWVyU3RhdGUubWluUmVzb2x1dGlvbiA9IE1hdGgubWF4KFxuICAgICAgICBsYXllclN0YXRlLm1pblJlc29sdXRpb24sIG93bkxheWVyU3RhdGUubWluUmVzb2x1dGlvbik7XG4gICAgICBpZiAob3duTGF5ZXJTdGF0ZS5leHRlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAobGF5ZXJTdGF0ZS5leHRlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGxheWVyU3RhdGUuZXh0ZW50ID0gZ2V0SW50ZXJzZWN0aW9uKGxheWVyU3RhdGUuZXh0ZW50LCBvd25MYXllclN0YXRlLmV4dGVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGF5ZXJTdGF0ZS5leHRlbnQgPSBvd25MYXllclN0YXRlLmV4dGVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdGF0ZXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBMYXllckdyb3VwLnByb3RvdHlwZS5nZXRTb3VyY2VTdGF0ZSA9IGZ1bmN0aW9uIGdldFNvdXJjZVN0YXRlICgpIHtcbiAgICByZXR1cm4gU291cmNlU3RhdGUuUkVBRFk7XG4gIH07XG5cbiAgcmV0dXJuIExheWVyR3JvdXA7XG59KEJhc2VMYXllcikpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IExheWVyR3JvdXA7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyb3VwLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9sYXllci9MYXllclxuICovXG5pbXBvcnQge2xpc3RlbiwgdW5saXN0ZW5CeUtleX0gZnJvbSAnLi4vZXZlbnRzLmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5pbXBvcnQge2dldENoYW5nZUV2ZW50VHlwZX0gZnJvbSAnLi4vT2JqZWN0LmpzJztcbmltcG9ydCBCYXNlTGF5ZXIgZnJvbSAnLi9CYXNlLmpzJztcbmltcG9ydCBMYXllclByb3BlcnR5IGZyb20gJy4vUHJvcGVydHkuanMnO1xuaW1wb3J0IHthc3NpZ259IGZyb20gJy4uL29iai5qcyc7XG5pbXBvcnQgUmVuZGVyRXZlbnRUeXBlIGZyb20gJy4uL3JlbmRlci9FdmVudFR5cGUuanMnO1xuaW1wb3J0IFNvdXJjZVN0YXRlIGZyb20gJy4uL3NvdXJjZS9TdGF0ZS5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW29wYWNpdHk9MV0gT3BhY2l0eSAoMCwgMSkuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt2aXNpYmxlPXRydWVdIFZpc2liaWxpdHkuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IFtleHRlbnRdIFRoZSBib3VuZGluZyBleHRlbnQgZm9yIGxheWVyIHJlbmRlcmluZy4gIFRoZSBsYXllciB3aWxsIG5vdCBiZVxuICogcmVuZGVyZWQgb3V0c2lkZSBvZiB0aGlzIGV4dGVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbekluZGV4XSBUaGUgei1pbmRleCBmb3IgbGF5ZXIgcmVuZGVyaW5nLiAgQXQgcmVuZGVyaW5nIHRpbWUsIHRoZSBsYXllcnNcbiAqIHdpbGwgYmUgb3JkZXJlZCwgZmlyc3QgYnkgWi1pbmRleCBhbmQgdGhlbiBieSBwb3NpdGlvbi4gV2hlbiBgdW5kZWZpbmVkYCwgYSBgekluZGV4YCBvZiAwIGlzIGFzc3VtZWRcbiAqIGZvciBsYXllcnMgdGhhdCBhcmUgYWRkZWQgdG8gdGhlIG1hcCdzIGBsYXllcnNgIGNvbGxlY3Rpb24sIG9yIGBJbmZpbml0eWAgd2hlbiB0aGUgbGF5ZXIncyBgc2V0TWFwKClgXG4gKiBtZXRob2Qgd2FzIHVzZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pblJlc29sdXRpb25dIFRoZSBtaW5pbXVtIHJlc29sdXRpb24gKGluY2x1c2l2ZSkgYXQgd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlXG4gKiB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhSZXNvbHV0aW9uXSBUaGUgbWF4aW11bSByZXNvbHV0aW9uIChleGNsdXNpdmUpIGJlbG93IHdoaWNoIHRoaXMgbGF5ZXIgd2lsbFxuICogYmUgdmlzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vc291cmNlL1NvdXJjZS5qc1wiKS5kZWZhdWx0fSBbc291cmNlXSBTb3VyY2UgZm9yIHRoaXMgbGF5ZXIuICBJZiBub3QgcHJvdmlkZWQgdG8gdGhlIGNvbnN0cnVjdG9yLFxuICogdGhlIHNvdXJjZSBjYW4gYmUgc2V0IGJ5IGNhbGxpbmcge0BsaW5rIG1vZHVsZTpvbC9sYXllci9MYXllciNzZXRTb3VyY2UgbGF5ZXIuc2V0U291cmNlKHNvdXJjZSl9IGFmdGVyXG4gKiBjb25zdHJ1Y3Rpb24uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL1BsdWdnYWJsZU1hcC5qc1wiKS5kZWZhdWx0fSBbbWFwXSBNYXAuXG4gKi9cblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFN0YXRlXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vQmFzZS5qc1wiKS5kZWZhdWx0fSBsYXllclxuICogQHByb3BlcnR5IHtudW1iZXJ9IG9wYWNpdHlcbiAqIEBwcm9wZXJ0eSB7U291cmNlU3RhdGV9IHNvdXJjZVN0YXRlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHZpc2libGVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbWFuYWdlZFxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBbZXh0ZW50XVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHpJbmRleFxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1heFJlc29sdXRpb25cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW5SZXNvbHV0aW9uXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzOyBub3JtYWxseSBvbmx5IHVzZWQgZm9yIGNyZWF0aW5nIHN1YmNsYXNzZXMgYW5kIG5vdFxuICogaW5zdGFudGlhdGVkIGluIGFwcHMuXG4gKiBBIHZpc3VhbCByZXByZXNlbnRhdGlvbiBvZiByYXN0ZXIgb3IgdmVjdG9yIG1hcCBkYXRhLlxuICogTGF5ZXJzIGdyb3VwIHRvZ2V0aGVyIHRob3NlIHByb3BlcnRpZXMgdGhhdCBwZXJ0YWluIHRvIGhvdyB0aGUgZGF0YSBpcyB0byBiZVxuICogZGlzcGxheWVkLCBpcnJlc3BlY3RpdmUgb2YgdGhlIHNvdXJjZSBvZiB0aGF0IGRhdGEuXG4gKlxuICogTGF5ZXJzIGFyZSB1c3VhbGx5IGFkZGVkIHRvIGEgbWFwIHdpdGgge0BsaW5rIG1vZHVsZTpvbC9NYXAjYWRkTGF5ZXJ9LiBDb21wb25lbnRzXG4gKiBsaWtlIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vU2VsZWN0flNlbGVjdH0gdXNlIHVubWFuYWdlZCBsYXllcnNcbiAqIGludGVybmFsbHkuIFRoZXNlIHVubWFuYWdlZCBsYXllcnMgYXJlIGFzc29jaWF0ZWQgd2l0aCB0aGUgbWFwIHVzaW5nXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL0xheWVyfkxheWVyI3NldE1hcH0gaW5zdGVhZC5cbiAqXG4gKiBBIGdlbmVyaWMgYGNoYW5nZWAgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgc3RhdGUgb2YgdGhlIHNvdXJjZSBjaGFuZ2VzLlxuICpcbiAqIEBmaXJlcyBpbXBvcnQoXCIuLi9yZW5kZXIvRXZlbnQuanNcIikuUmVuZGVyRXZlbnRcbiAqL1xudmFyIExheWVyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoQmFzZUxheWVyKSB7XG4gIGZ1bmN0aW9uIExheWVyKG9wdGlvbnMpIHtcblxuICAgIHZhciBiYXNlT3B0aW9ucyA9IGFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgZGVsZXRlIGJhc2VPcHRpb25zLnNvdXJjZTtcblxuICAgIEJhc2VMYXllci5jYWxsKHRoaXMsIGJhc2VPcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuLi9ldmVudHMuanNcIikuRXZlbnRzS2V5fVxuICAgICAqL1xuICAgIHRoaXMubWFwUHJlY29tcG9zZUtleV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4uL2V2ZW50cy5qc1wiKS5FdmVudHNLZXl9XG4gICAgICovXG4gICAgdGhpcy5tYXBSZW5kZXJLZXlfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuLi9ldmVudHMuanNcIikuRXZlbnRzS2V5fVxuICAgICAqL1xuICAgIHRoaXMuc291cmNlQ2hhbmdlS2V5XyA9IG51bGw7XG5cbiAgICBpZiAob3B0aW9ucy5tYXApIHtcbiAgICAgIHRoaXMuc2V0TWFwKG9wdGlvbnMubWFwKTtcbiAgICB9XG5cbiAgICBsaXN0ZW4odGhpcyxcbiAgICAgIGdldENoYW5nZUV2ZW50VHlwZShMYXllclByb3BlcnR5LlNPVVJDRSksXG4gICAgICB0aGlzLmhhbmRsZVNvdXJjZVByb3BlcnR5Q2hhbmdlXywgdGhpcyk7XG5cbiAgICB2YXIgc291cmNlID0gb3B0aW9ucy5zb3VyY2UgPyBvcHRpb25zLnNvdXJjZSA6IG51bGw7XG4gICAgdGhpcy5zZXRTb3VyY2Uoc291cmNlKTtcbiAgfVxuXG4gIGlmICggQmFzZUxheWVyICkgTGF5ZXIuX19wcm90b19fID0gQmFzZUxheWVyO1xuICBMYXllci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCYXNlTGF5ZXIgJiYgQmFzZUxheWVyLnByb3RvdHlwZSApO1xuICBMYXllci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMYXllcjtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIExheWVyLnByb3RvdHlwZS5nZXRMYXllcnNBcnJheSA9IGZ1bmN0aW9uIGdldExheWVyc0FycmF5IChvcHRfYXJyYXkpIHtcbiAgICB2YXIgYXJyYXkgPSBvcHRfYXJyYXkgPyBvcHRfYXJyYXkgOiBbXTtcbiAgICBhcnJheS5wdXNoKHRoaXMpO1xuICAgIHJldHVybiBhcnJheTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIExheWVyLnByb3RvdHlwZS5nZXRMYXllclN0YXRlc0FycmF5ID0gZnVuY3Rpb24gZ2V0TGF5ZXJTdGF0ZXNBcnJheSAob3B0X3N0YXRlcykge1xuICAgIHZhciBzdGF0ZXMgPSBvcHRfc3RhdGVzID8gb3B0X3N0YXRlcyA6IFtdO1xuICAgIHN0YXRlcy5wdXNoKHRoaXMuZ2V0TGF5ZXJTdGF0ZSgpKTtcbiAgICByZXR1cm4gc3RhdGVzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxheWVyIHNvdXJjZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vc291cmNlL1NvdXJjZS5qc1wiKS5kZWZhdWx0fSBUaGUgbGF5ZXIgc291cmNlIChvciBgbnVsbGAgaWYgbm90IHlldCBzZXQpLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBMYXllci5wcm90b3R5cGUuZ2V0U291cmNlID0gZnVuY3Rpb24gZ2V0U291cmNlICgpIHtcbiAgICB2YXIgc291cmNlID0gdGhpcy5nZXQoTGF5ZXJQcm9wZXJ0eS5TT1VSQ0UpO1xuICAgIHJldHVybiAoXG4gICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uL3NvdXJjZS9Tb3VyY2UuanNcIikuZGVmYXVsdH0gKi8gKHNvdXJjZSkgfHwgbnVsbFxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAgKiBAaW5oZXJpdERvY1xuICAgICovXG4gIExheWVyLnByb3RvdHlwZS5nZXRTb3VyY2VTdGF0ZSA9IGZ1bmN0aW9uIGdldFNvdXJjZVN0YXRlICgpIHtcbiAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKTtcbiAgICByZXR1cm4gIXNvdXJjZSA/IFNvdXJjZVN0YXRlLlVOREVGSU5FRCA6IHNvdXJjZS5nZXRTdGF0ZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTGF5ZXIucHJvdG90eXBlLmhhbmRsZVNvdXJjZUNoYW5nZV8gPSBmdW5jdGlvbiBoYW5kbGVTb3VyY2VDaGFuZ2VfICgpIHtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIExheWVyLnByb3RvdHlwZS5oYW5kbGVTb3VyY2VQcm9wZXJ0eUNoYW5nZV8gPSBmdW5jdGlvbiBoYW5kbGVTb3VyY2VQcm9wZXJ0eUNoYW5nZV8gKCkge1xuICAgIGlmICh0aGlzLnNvdXJjZUNoYW5nZUtleV8pIHtcbiAgICAgIHVubGlzdGVuQnlLZXkodGhpcy5zb3VyY2VDaGFuZ2VLZXlfKTtcbiAgICAgIHRoaXMuc291cmNlQ2hhbmdlS2V5XyA9IG51bGw7XG4gICAgfVxuICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpO1xuICAgIGlmIChzb3VyY2UpIHtcbiAgICAgIHRoaXMuc291cmNlQ2hhbmdlS2V5XyA9IGxpc3Rlbihzb3VyY2UsXG4gICAgICAgIEV2ZW50VHlwZS5DSEFOR0UsIHRoaXMuaGFuZGxlU291cmNlQ2hhbmdlXywgdGhpcyk7XG4gICAgfVxuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBsYXllciB0byBiZSByZW5kZXJlZCBvbiB0b3Agb2Ygb3RoZXIgbGF5ZXJzIG9uIGEgbWFwLiBUaGUgbWFwIHdpbGxcbiAgICogbm90IG1hbmFnZSB0aGlzIGxheWVyIGluIGl0cyBsYXllcnMgY29sbGVjdGlvbiwgYW5kIHRoZSBjYWxsYmFjayBpblxuICAgKiB7QGxpbmsgbW9kdWxlOm9sL01hcCNmb3JFYWNoTGF5ZXJBdFBpeGVsfSB3aWxsIHJlY2VpdmUgYG51bGxgIGFzIGxheWVyLiBUaGlzXG4gICAqIGlzIHVzZWZ1bCBmb3IgdGVtcG9yYXJ5IGxheWVycy4gVG8gcmVtb3ZlIGFuIHVubWFuYWdlZCBsYXllciBmcm9tIHRoZSBtYXAsXG4gICAqIHVzZSBgI3NldE1hcChudWxsKWAuXG4gICAqXG4gICAqIFRvIGFkZCB0aGUgbGF5ZXIgdG8gYSBtYXAgYW5kIGhhdmUgaXQgbWFuYWdlZCBieSB0aGUgbWFwLCB1c2VcbiAgICoge0BsaW5rIG1vZHVsZTpvbC9NYXAjYWRkTGF5ZXJ9IGluc3RlYWQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLmRlZmF1bHR9IG1hcCBNYXAuXG4gICAqIEBhcGlcbiAgICovXG4gIExheWVyLnByb3RvdHlwZS5zZXRNYXAgPSBmdW5jdGlvbiBzZXRNYXAgKG1hcCkge1xuICAgIGlmICh0aGlzLm1hcFByZWNvbXBvc2VLZXlfKSB7XG4gICAgICB1bmxpc3RlbkJ5S2V5KHRoaXMubWFwUHJlY29tcG9zZUtleV8pO1xuICAgICAgdGhpcy5tYXBQcmVjb21wb3NlS2V5XyA9IG51bGw7XG4gICAgfVxuICAgIGlmICghbWFwKSB7XG4gICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWFwUmVuZGVyS2V5Xykge1xuICAgICAgdW5saXN0ZW5CeUtleSh0aGlzLm1hcFJlbmRlcktleV8pO1xuICAgICAgdGhpcy5tYXBSZW5kZXJLZXlfID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKG1hcCkge1xuICAgICAgdGhpcy5tYXBQcmVjb21wb3NlS2V5XyA9IGxpc3RlbihtYXAsIFJlbmRlckV2ZW50VHlwZS5QUkVDT01QT1NFLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgdmFyIHJlbmRlckV2ZW50ID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9yZW5kZXIvRXZlbnQuanNcIikuZGVmYXVsdH0gKi8gKGV2dCk7XG4gICAgICAgIHZhciBsYXllclN0YXRlID0gdGhpcy5nZXRMYXllclN0YXRlKCk7XG4gICAgICAgIGxheWVyU3RhdGUubWFuYWdlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5nZXRaSW5kZXgoKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGF5ZXJTdGF0ZS56SW5kZXggPSBJbmZpbml0eTtcbiAgICAgICAgfVxuICAgICAgICByZW5kZXJFdmVudC5mcmFtZVN0YXRlLmxheWVyU3RhdGVzQXJyYXkucHVzaChsYXllclN0YXRlKTtcbiAgICAgICAgcmVuZGVyRXZlbnQuZnJhbWVTdGF0ZS5sYXllclN0YXRlc1tnZXRVaWQodGhpcyldID0gbGF5ZXJTdGF0ZTtcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgdGhpcy5tYXBSZW5kZXJLZXlfID0gbGlzdGVuKHRoaXMsIEV2ZW50VHlwZS5DSEFOR0UsIG1hcC5yZW5kZXIsIG1hcCk7XG4gICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbGF5ZXIgc291cmNlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3NvdXJjZS9Tb3VyY2UuanNcIikuZGVmYXVsdH0gc291cmNlIFRoZSBsYXllciBzb3VyY2UuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIExheWVyLnByb3RvdHlwZS5zZXRTb3VyY2UgPSBmdW5jdGlvbiBzZXRTb3VyY2UgKHNvdXJjZSkge1xuICAgIHRoaXMuc2V0KExheWVyUHJvcGVydHkuU09VUkNFLCBzb3VyY2UpO1xuICB9O1xuXG4gIHJldHVybiBMYXllcjtcbn0oQmFzZUxheWVyKSk7XG5cblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBsYXllciBpcyB2aXNpYmxlLCBhbmQgaWYgdGhlIHBhc3NlZCByZXNvbHV0aW9uIGlzXG4gKiBiZXR3ZWVuIHRoZSBsYXllcidzIG1pblJlc29sdXRpb24gYW5kIG1heFJlc29sdXRpb24uIFRoZSBjb21wYXJpc29uIGlzXG4gKiBpbmNsdXNpdmUgZm9yIGBtaW5SZXNvbHV0aW9uYCBhbmQgZXhjbHVzaXZlIGZvciBgbWF4UmVzb2x1dGlvbmAuXG4gKiBAcGFyYW0ge1N0YXRlfSBsYXllclN0YXRlIExheWVyIHN0YXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBsYXllciBpcyB2aXNpYmxlIGF0IHRoZSBnaXZlbiByZXNvbHV0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmlzaWJsZUF0UmVzb2x1dGlvbihsYXllclN0YXRlLCByZXNvbHV0aW9uKSB7XG4gIHJldHVybiBsYXllclN0YXRlLnZpc2libGUgJiYgcmVzb2x1dGlvbiA+PSBsYXllclN0YXRlLm1pblJlc29sdXRpb24gJiZcbiAgICAgIHJlc29sdXRpb24gPCBsYXllclN0YXRlLm1heFJlc29sdXRpb247XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgTGF5ZXI7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxheWVyLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9sYXllci9Qcm9wZXJ0eVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBPUEFDSVRZOiAnb3BhY2l0eScsXG4gIFZJU0lCTEU6ICd2aXNpYmxlJyxcbiAgRVhURU5UOiAnZXh0ZW50JyxcbiAgWl9JTkRFWDogJ3pJbmRleCcsXG4gIE1BWF9SRVNPTFVUSU9OOiAnbWF4UmVzb2x1dGlvbicsXG4gIE1JTl9SRVNPTFVUSU9OOiAnbWluUmVzb2x1dGlvbicsXG4gIFNPVVJDRTogJ3NvdXJjZSdcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVByb3BlcnR5LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9sYXllci9UaWxlXG4gKi9cbmltcG9ydCBMYXllclR5cGUgZnJvbSAnLi4vTGF5ZXJUeXBlLmpzJztcbmltcG9ydCBMYXllciBmcm9tICcuL0xheWVyLmpzJztcbmltcG9ydCBUaWxlUHJvcGVydHkgZnJvbSAnLi9UaWxlUHJvcGVydHkuanMnO1xuaW1wb3J0IHthc3NpZ259IGZyb20gJy4uL29iai5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW29wYWNpdHk9MV0gT3BhY2l0eSAoMCwgMSkuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt2aXNpYmxlPXRydWVdIFZpc2liaWxpdHkuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IFtleHRlbnRdIFRoZSBib3VuZGluZyBleHRlbnQgZm9yIGxheWVyIHJlbmRlcmluZy4gIFRoZSBsYXllciB3aWxsIG5vdCBiZVxuICogcmVuZGVyZWQgb3V0c2lkZSBvZiB0aGlzIGV4dGVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbekluZGV4XSBUaGUgei1pbmRleCBmb3IgbGF5ZXIgcmVuZGVyaW5nLiAgQXQgcmVuZGVyaW5nIHRpbWUsIHRoZSBsYXllcnNcbiAqIHdpbGwgYmUgb3JkZXJlZCwgZmlyc3QgYnkgWi1pbmRleCBhbmQgdGhlbiBieSBwb3NpdGlvbi4gV2hlbiBgdW5kZWZpbmVkYCwgYSBgekluZGV4YCBvZiAwIGlzIGFzc3VtZWRcbiAqIGZvciBsYXllcnMgdGhhdCBhcmUgYWRkZWQgdG8gdGhlIG1hcCdzIGBsYXllcnNgIGNvbGxlY3Rpb24sIG9yIGBJbmZpbml0eWAgd2hlbiB0aGUgbGF5ZXIncyBgc2V0TWFwKClgXG4gKiBtZXRob2Qgd2FzIHVzZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pblJlc29sdXRpb25dIFRoZSBtaW5pbXVtIHJlc29sdXRpb24gKGluY2x1c2l2ZSkgYXQgd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlXG4gKiB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhSZXNvbHV0aW9uXSBUaGUgbWF4aW11bSByZXNvbHV0aW9uIChleGNsdXNpdmUpIGJlbG93IHdoaWNoIHRoaXMgbGF5ZXIgd2lsbFxuICogYmUgdmlzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcHJlbG9hZD0wXSBQcmVsb2FkLiBMb2FkIGxvdy1yZXNvbHV0aW9uIHRpbGVzIHVwIHRvIGBwcmVsb2FkYCBsZXZlbHMuIGAwYFxuICogbWVhbnMgbm8gcHJlbG9hZGluZy5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vc291cmNlL1RpbGUuanNcIikuZGVmYXVsdH0gW3NvdXJjZV0gU291cmNlIGZvciB0aGlzIGxheWVyLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuZGVmYXVsdH0gW21hcF0gU2V0cyB0aGUgbGF5ZXIgYXMgb3ZlcmxheSBvbiBhIG1hcC4gVGhlIG1hcCB3aWxsIG5vdCBtYW5hZ2VcbiAqIHRoaXMgbGF5ZXIgaW4gaXRzIGxheWVycyBjb2xsZWN0aW9uLCBhbmQgdGhlIGxheWVyIHdpbGwgYmUgcmVuZGVyZWQgb24gdG9wLiBUaGlzIGlzIHVzZWZ1bCBmb3JcbiAqIHRlbXBvcmFyeSBsYXllcnMuIFRoZSBzdGFuZGFyZCB3YXkgdG8gYWRkIGEgbGF5ZXIgdG8gYSBtYXAgYW5kIGhhdmUgaXQgbWFuYWdlZCBieSB0aGUgbWFwIGlzIHRvXG4gKiB1c2Uge0BsaW5rIG1vZHVsZTpvbC9NYXAjYWRkTGF5ZXJ9LlxuICogQHByb3BlcnR5IHtib29sZWFufSBbdXNlSW50ZXJpbVRpbGVzT25FcnJvcj10cnVlXSBVc2UgaW50ZXJpbSB0aWxlcyBvbiBlcnJvci5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEZvciBsYXllciBzb3VyY2VzIHRoYXQgcHJvdmlkZSBwcmUtcmVuZGVyZWQsIHRpbGVkIGltYWdlcyBpbiBncmlkcyB0aGF0IGFyZVxuICogb3JnYW5pemVkIGJ5IHpvb20gbGV2ZWxzIGZvciBzcGVjaWZpYyByZXNvbHV0aW9ucy5cbiAqIE5vdGUgdGhhdCBhbnkgcHJvcGVydHkgc2V0IGluIHRoZSBvcHRpb25zIGlzIHNldCBhcyBhIHtAbGluayBtb2R1bGU6b2wvT2JqZWN0fkJhc2VPYmplY3R9XG4gKiBwcm9wZXJ0eSBvbiB0aGUgbGF5ZXIgb2JqZWN0OyBmb3IgZXhhbXBsZSwgc2V0dGluZyBgdGl0bGU6ICdNeSBUaXRsZSdgIGluIHRoZVxuICogb3B0aW9ucyBtZWFucyB0aGF0IGB0aXRsZWAgaXMgb2JzZXJ2YWJsZSwgYW5kIGhhcyBnZXQvc2V0IGFjY2Vzc29ycy5cbiAqXG4gKiBAYXBpXG4gKi9cbnZhciBUaWxlTGF5ZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChMYXllcikge1xuICBmdW5jdGlvbiBUaWxlTGF5ZXIob3B0X29wdGlvbnMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IG9wdF9vcHRpb25zID8gb3B0X29wdGlvbnMgOiB7fTtcblxuICAgIHZhciBiYXNlT3B0aW9ucyA9IGFzc2lnbih7fSwgb3B0aW9ucyk7XG5cbiAgICBkZWxldGUgYmFzZU9wdGlvbnMucHJlbG9hZDtcbiAgICBkZWxldGUgYmFzZU9wdGlvbnMudXNlSW50ZXJpbVRpbGVzT25FcnJvcjtcbiAgICBMYXllci5jYWxsKHRoaXMsIGJhc2VPcHRpb25zKTtcblxuICAgIHRoaXMuc2V0UHJlbG9hZChvcHRpb25zLnByZWxvYWQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucHJlbG9hZCA6IDApO1xuICAgIHRoaXMuc2V0VXNlSW50ZXJpbVRpbGVzT25FcnJvcihvcHRpb25zLnVzZUludGVyaW1UaWxlc09uRXJyb3IgIT09IHVuZGVmaW5lZCA/XG4gICAgICBvcHRpb25zLnVzZUludGVyaW1UaWxlc09uRXJyb3IgOiB0cnVlKTtcblxuICAgIC8qKlxuICAgICogVGhlIGxheWVyIHR5cGUuXG4gICAgKiBAcHJvdGVjdGVkXG4gICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vTGF5ZXJUeXBlLmpzXCIpLmRlZmF1bHR9XG4gICAgKi9cbiAgICB0aGlzLnR5cGUgPSBMYXllclR5cGUuVElMRTtcblxuICB9XG5cbiAgaWYgKCBMYXllciApIFRpbGVMYXllci5fX3Byb3RvX18gPSBMYXllcjtcbiAgVGlsZUxheWVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIExheWVyICYmIExheWVyLnByb3RvdHlwZSApO1xuICBUaWxlTGF5ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGlsZUxheWVyO1xuXG4gIC8qKlxuICAqIFJldHVybiB0aGUgbGV2ZWwgYXMgbnVtYmVyIHRvIHdoaWNoIHdlIHdpbGwgcHJlbG9hZCB0aWxlcyB1cCB0by5cbiAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBsZXZlbCB0byBwcmVsb2FkIHRpbGVzIHVwIHRvLlxuICAqIEBvYnNlcnZhYmxlXG4gICogQGFwaVxuICAqL1xuICBUaWxlTGF5ZXIucHJvdG90eXBlLmdldFByZWxvYWQgPSBmdW5jdGlvbiBnZXRQcmVsb2FkICgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ9ICovICh0aGlzLmdldChUaWxlUHJvcGVydHkuUFJFTE9BRCkpO1xuICB9O1xuXG4gIC8qKlxuICAqIFNldCB0aGUgbGV2ZWwgYXMgbnVtYmVyIHRvIHdoaWNoIHdlIHdpbGwgcHJlbG9hZCB0aWxlcyB1cCB0by5cbiAgKiBAcGFyYW0ge251bWJlcn0gcHJlbG9hZCBUaGUgbGV2ZWwgdG8gcHJlbG9hZCB0aWxlcyB1cCB0by5cbiAgKiBAb2JzZXJ2YWJsZVxuICAqIEBhcGlcbiAgKi9cbiAgVGlsZUxheWVyLnByb3RvdHlwZS5zZXRQcmVsb2FkID0gZnVuY3Rpb24gc2V0UHJlbG9hZCAocHJlbG9hZCkge1xuICAgIHRoaXMuc2V0KFRpbGVQcm9wZXJ0eS5QUkVMT0FELCBwcmVsb2FkKTtcbiAgfTtcblxuICAvKipcbiAgKiBXaGV0aGVyIHdlIHVzZSBpbnRlcmltIHRpbGVzIG9uIGVycm9yLlxuICAqIEByZXR1cm4ge2Jvb2xlYW59IFVzZSBpbnRlcmltIHRpbGVzIG9uIGVycm9yLlxuICAqIEBvYnNlcnZhYmxlXG4gICogQGFwaVxuICAqL1xuICBUaWxlTGF5ZXIucHJvdG90eXBlLmdldFVzZUludGVyaW1UaWxlc09uRXJyb3IgPSBmdW5jdGlvbiBnZXRVc2VJbnRlcmltVGlsZXNPbkVycm9yICgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtib29sZWFufSAqLyAodGhpcy5nZXQoVGlsZVByb3BlcnR5LlVTRV9JTlRFUklNX1RJTEVTX09OX0VSUk9SKSk7XG4gIH07XG5cbiAgLyoqXG4gICogU2V0IHdoZXRoZXIgd2UgdXNlIGludGVyaW0gdGlsZXMgb24gZXJyb3IuXG4gICogQHBhcmFtIHtib29sZWFufSB1c2VJbnRlcmltVGlsZXNPbkVycm9yIFVzZSBpbnRlcmltIHRpbGVzIG9uIGVycm9yLlxuICAqIEBvYnNlcnZhYmxlXG4gICogQGFwaVxuICAqL1xuICBUaWxlTGF5ZXIucHJvdG90eXBlLnNldFVzZUludGVyaW1UaWxlc09uRXJyb3IgPSBmdW5jdGlvbiBzZXRVc2VJbnRlcmltVGlsZXNPbkVycm9yICh1c2VJbnRlcmltVGlsZXNPbkVycm9yKSB7XG4gICAgdGhpcy5zZXQoVGlsZVByb3BlcnR5LlVTRV9JTlRFUklNX1RJTEVTX09OX0VSUk9SLCB1c2VJbnRlcmltVGlsZXNPbkVycm9yKTtcbiAgfTtcblxuICByZXR1cm4gVGlsZUxheWVyO1xufShMYXllcikpO1xuXG5cbi8qKlxuICogUmV0dXJuIHRoZSBhc3NvY2lhdGVkIHtAbGluayBtb2R1bGU6b2wvc291cmNlL1RpbGUgdGlsZXNvdXJjZX0gb2YgdGhlIGxheWVyLlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zb3VyY2UvVGlsZS5qc1wiKS5kZWZhdWx0fSBTb3VyY2UuXG4gKiBAYXBpXG4gKi9cblRpbGVMYXllci5wcm90b3R5cGUuZ2V0U291cmNlO1xuXG5cbmV4cG9ydCBkZWZhdWx0IFRpbGVMYXllcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGlsZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvbGF5ZXIvVGlsZVByb3BlcnR5XG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIFBSRUxPQUQ6ICdwcmVsb2FkJyxcbiAgVVNFX0lOVEVSSU1fVElMRVNfT05fRVJST1I6ICd1c2VJbnRlcmltVGlsZXNPbkVycm9yJ1xufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGlsZVByb3BlcnR5LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9sYXllci9WZWN0b3JcbiAqL1xuaW1wb3J0IExheWVyVHlwZSBmcm9tICcuLi9MYXllclR5cGUuanMnO1xuaW1wb3J0IExheWVyIGZyb20gJy4vTGF5ZXIuanMnO1xuaW1wb3J0IFZlY3RvclJlbmRlclR5cGUgZnJvbSAnLi9WZWN0b3JSZW5kZXJUeXBlLmpzJztcbmltcG9ydCB7YXNzaWdufSBmcm9tICcuLi9vYmouanMnO1xuaW1wb3J0IHtjcmVhdGVEZWZhdWx0U3R5bGUsIHRvRnVuY3Rpb24gYXMgdG9TdHlsZUZ1bmN0aW9ufSBmcm9tICcuLi9zdHlsZS9TdHlsZS5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW29wYWNpdHk9MV0gT3BhY2l0eSAoMCwgMSkuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt2aXNpYmxlPXRydWVdIFZpc2liaWxpdHkuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IFtleHRlbnRdIFRoZSBib3VuZGluZyBleHRlbnQgZm9yIGxheWVyIHJlbmRlcmluZy4gIFRoZSBsYXllciB3aWxsIG5vdCBiZVxuICogcmVuZGVyZWQgb3V0c2lkZSBvZiB0aGlzIGV4dGVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbekluZGV4XSBUaGUgei1pbmRleCBmb3IgbGF5ZXIgcmVuZGVyaW5nLiAgQXQgcmVuZGVyaW5nIHRpbWUsIHRoZSBsYXllcnNcbiAqIHdpbGwgYmUgb3JkZXJlZCwgZmlyc3QgYnkgWi1pbmRleCBhbmQgdGhlbiBieSBwb3NpdGlvbi4gV2hlbiBgdW5kZWZpbmVkYCwgYSBgekluZGV4YCBvZiAwIGlzIGFzc3VtZWRcbiAqIGZvciBsYXllcnMgdGhhdCBhcmUgYWRkZWQgdG8gdGhlIG1hcCdzIGBsYXllcnNgIGNvbGxlY3Rpb24sIG9yIGBJbmZpbml0eWAgd2hlbiB0aGUgbGF5ZXIncyBgc2V0TWFwKClgXG4gKiBtZXRob2Qgd2FzIHVzZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pblJlc29sdXRpb25dIFRoZSBtaW5pbXVtIHJlc29sdXRpb24gKGluY2x1c2l2ZSkgYXQgd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlXG4gKiB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhSZXNvbHV0aW9uXSBUaGUgbWF4aW11bSByZXNvbHV0aW9uIChleGNsdXNpdmUpIGJlbG93IHdoaWNoIHRoaXMgbGF5ZXIgd2lsbFxuICogYmUgdmlzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vcmVuZGVyLmpzXCIpLk9yZGVyRnVuY3Rpb259IFtyZW5kZXJPcmRlcl0gUmVuZGVyIG9yZGVyLiBGdW5jdGlvbiB0byBiZSB1c2VkIHdoZW4gc29ydGluZ1xuICogZmVhdHVyZXMgYmVmb3JlIHJlbmRlcmluZy4gQnkgZGVmYXVsdCBmZWF0dXJlcyBhcmUgZHJhd24gaW4gdGhlIG9yZGVyIHRoYXQgdGhleSBhcmUgY3JlYXRlZC4gVXNlXG4gKiBgbnVsbGAgdG8gYXZvaWQgdGhlIHNvcnQsIGJ1dCBnZXQgYW4gdW5kZWZpbmVkIGRyYXcgb3JkZXIuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JlbmRlckJ1ZmZlcj0xMDBdIFRoZSBidWZmZXIgaW4gcGl4ZWxzIGFyb3VuZCB0aGUgdmlld3BvcnQgZXh0ZW50IHVzZWQgYnkgdGhlXG4gKiByZW5kZXJlciB3aGVuIGdldHRpbmcgZmVhdHVyZXMgZnJvbSB0aGUgdmVjdG9yIHNvdXJjZSBmb3IgdGhlIHJlbmRlcmluZyBvciBoaXQtZGV0ZWN0aW9uLlxuICogUmVjb21tZW5kZWQgdmFsdWU6IHRoZSBzaXplIG9mIHRoZSBsYXJnZXN0IHN5bWJvbCwgbGluZSB3aWR0aCBvciBsYWJlbC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9WZWN0b3JSZW5kZXJUeXBlLmpzXCIpLmRlZmF1bHR8c3RyaW5nfSBbcmVuZGVyTW9kZT0ndmVjdG9yJ10gUmVuZGVyIG1vZGUgZm9yIHZlY3RvciBsYXllcnM6XG4gKiAgKiBgJ2ltYWdlJ2A6IFZlY3RvciBsYXllcnMgYXJlIHJlbmRlcmVkIGFzIGltYWdlcy4gR3JlYXQgcGVyZm9ybWFuY2UsIGJ1dCBwb2ludCBzeW1ib2xzIGFuZFxuICogICAgdGV4dHMgYXJlIGFsd2F5cyByb3RhdGVkIHdpdGggdGhlIHZpZXcgYW5kIHBpeGVscyBhcmUgc2NhbGVkIGR1cmluZyB6b29tIGFuaW1hdGlvbnMuXG4gKiAgKiBgJ3ZlY3RvcidgOiBWZWN0b3IgbGF5ZXJzIGFyZSByZW5kZXJlZCBhcyB2ZWN0b3JzLiBNb3N0IGFjY3VyYXRlIHJlbmRlcmluZyBldmVuIGR1cmluZ1xuICogICAgYW5pbWF0aW9ucywgYnV0IHNsb3dlciBwZXJmb3JtYW5jZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vc291cmNlL1ZlY3Rvci5qc1wiKS5kZWZhdWx0fSBbc291cmNlXSBTb3VyY2UuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL1BsdWdnYWJsZU1hcC5qc1wiKS5kZWZhdWx0fSBbbWFwXSBTZXRzIHRoZSBsYXllciBhcyBvdmVybGF5IG9uIGEgbWFwLiBUaGUgbWFwIHdpbGwgbm90IG1hbmFnZVxuICogdGhpcyBsYXllciBpbiBpdHMgbGF5ZXJzIGNvbGxlY3Rpb24sIGFuZCB0aGUgbGF5ZXIgd2lsbCBiZSByZW5kZXJlZCBvbiB0b3AuIFRoaXMgaXMgdXNlZnVsIGZvclxuICogdGVtcG9yYXJ5IGxheWVycy4gVGhlIHN0YW5kYXJkIHdheSB0byBhZGQgYSBsYXllciB0byBhIG1hcCBhbmQgaGF2ZSBpdCBtYW5hZ2VkIGJ5IHRoZSBtYXAgaXMgdG9cbiAqIHVzZSB7QGxpbmsgbW9kdWxlOm9sL01hcCNhZGRMYXllcn0uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtkZWNsdXR0ZXI9ZmFsc2VdIERlY2x1dHRlciBpbWFnZXMgYW5kIHRleHQuIERlY2x1dHRlcmluZyBpcyBhcHBsaWVkIHRvIGFsbFxuICogaW1hZ2UgYW5kIHRleHQgc3R5bGVzLCBhbmQgdGhlIHByaW9yaXR5IGlzIGRlZmluZWQgYnkgdGhlIHotaW5kZXggb2YgdGhlIHN0eWxlLiBMb3dlciB6LWluZGV4XG4gKiBtZWFucyBoaWdoZXIgcHJpb3JpdHkuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLlN0eWxlTGlrZX0gW3N0eWxlXSBMYXllciBzdHlsZS4gU2VlXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3N0eWxlfSBmb3IgZGVmYXVsdCBzdHlsZSB3aGljaCB3aWxsIGJlIHVzZWQgaWYgdGhpcyBpcyBub3QgZGVmaW5lZC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3VwZGF0ZVdoaWxlQW5pbWF0aW5nPWZhbHNlXSBXaGVuIHNldCB0byBgdHJ1ZWAgYW5kIGByZW5kZXJNb2RlYFxuICogaXMgYHZlY3RvcmAsIGZlYXR1cmUgYmF0Y2hlcyB3aWxsIGJlIHJlY3JlYXRlZCBkdXJpbmcgYW5pbWF0aW9ucy4gVGhpcyBtZWFucyB0aGF0IG5vXG4gKiB2ZWN0b3JzIHdpbGwgYmUgc2hvd24gY2xpcHBlZCwgYnV0IHRoZSBzZXR0aW5nIHdpbGwgaGF2ZSBhIHBlcmZvcm1hbmNlIGltcGFjdCBmb3IgbGFyZ2VcbiAqIGFtb3VudHMgb2YgdmVjdG9yIGRhdGEuIFdoZW4gc2V0IHRvIGBmYWxzZWAsIGJhdGNoZXMgd2lsbCBiZSByZWNyZWF0ZWQgd2hlbiBubyBhbmltYXRpb25cbiAqIGlzIGFjdGl2ZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3VwZGF0ZVdoaWxlSW50ZXJhY3Rpbmc9ZmFsc2VdIFdoZW4gc2V0IHRvIGB0cnVlYCBhbmQgYHJlbmRlck1vZGVgXG4gKiBpcyBgdmVjdG9yYCwgZmVhdHVyZSBiYXRjaGVzIHdpbGwgYmUgcmVjcmVhdGVkIGR1cmluZyBpbnRlcmFjdGlvbnMuIFNlZSBhbHNvXG4gKiBgdXBkYXRlV2hpbGVBbmltYXRpbmdgLlxuICovXG5cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xudmFyIFByb3BlcnR5ID0ge1xuICBSRU5ERVJfT1JERVI6ICdyZW5kZXJPcmRlcidcbn07XG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBWZWN0b3IgZGF0YSB0aGF0IGlzIHJlbmRlcmVkIGNsaWVudC1zaWRlLlxuICogTm90ZSB0aGF0IGFueSBwcm9wZXJ0eSBzZXQgaW4gdGhlIG9wdGlvbnMgaXMgc2V0IGFzIGEge0BsaW5rIG1vZHVsZTpvbC9PYmplY3R+QmFzZU9iamVjdH1cbiAqIHByb3BlcnR5IG9uIHRoZSBsYXllciBvYmplY3Q7IGZvciBleGFtcGxlLCBzZXR0aW5nIGB0aXRsZTogJ015IFRpdGxlJ2AgaW4gdGhlXG4gKiBvcHRpb25zIG1lYW5zIHRoYXQgYHRpdGxlYCBpcyBvYnNlcnZhYmxlLCBhbmQgaGFzIGdldC9zZXQgYWNjZXNzb3JzLlxuICpcbiAqIEBhcGlcbiAqL1xudmFyIFZlY3RvckxheWVyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoTGF5ZXIpIHtcbiAgZnVuY3Rpb24gVmVjdG9yTGF5ZXIob3B0X29wdGlvbnMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IG9wdF9vcHRpb25zID9cbiAgICAgIG9wdF9vcHRpb25zIDogLyoqIEB0eXBlIHtPcHRpb25zfSAqLyAoe30pO1xuXG4gICAgdmFyIGJhc2VPcHRpb25zID0gYXNzaWduKHt9LCBvcHRpb25zKTtcblxuICAgIGRlbGV0ZSBiYXNlT3B0aW9ucy5zdHlsZTtcbiAgICBkZWxldGUgYmFzZU9wdGlvbnMucmVuZGVyQnVmZmVyO1xuICAgIGRlbGV0ZSBiYXNlT3B0aW9ucy51cGRhdGVXaGlsZUFuaW1hdGluZztcbiAgICBkZWxldGUgYmFzZU9wdGlvbnMudXBkYXRlV2hpbGVJbnRlcmFjdGluZztcbiAgICBMYXllci5jYWxsKHRoaXMsIGJhc2VPcHRpb25zKTtcblxuICAgIC8qKlxuICAgICogQHByaXZhdGVcbiAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICovXG4gICAgdGhpcy5kZWNsdXR0ZXJfID0gb3B0aW9ucy5kZWNsdXR0ZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZGVjbHV0dGVyIDogZmFsc2U7XG5cbiAgICAvKipcbiAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgdGhpcy5yZW5kZXJCdWZmZXJfID0gb3B0aW9ucy5yZW5kZXJCdWZmZXIgIT09IHVuZGVmaW5lZCA/XG4gICAgICBvcHRpb25zLnJlbmRlckJ1ZmZlciA6IDEwMDtcblxuICAgIC8qKlxuICAgICogVXNlciBwcm92aWRlZCBzdHlsZS5cbiAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUxpa2V9XG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgdGhpcy5zdHlsZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgKiBTdHlsZSBmdW5jdGlvbiBmb3IgdXNlIHdpdGhpbiB0aGUgbGlicmFyeS5cbiAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUZ1bmN0aW9ufHVuZGVmaW5lZH1cbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICB0aGlzLnN0eWxlRnVuY3Rpb25fID0gdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5zZXRTdHlsZShvcHRpb25zLnN0eWxlKTtcblxuICAgIC8qKlxuICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgdGhpcy51cGRhdGVXaGlsZUFuaW1hdGluZ18gPSBvcHRpb25zLnVwZGF0ZVdoaWxlQW5pbWF0aW5nICE9PSB1bmRlZmluZWQgP1xuICAgICAgb3B0aW9ucy51cGRhdGVXaGlsZUFuaW1hdGluZyA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICB0aGlzLnVwZGF0ZVdoaWxlSW50ZXJhY3RpbmdfID0gb3B0aW9ucy51cGRhdGVXaGlsZUludGVyYWN0aW5nICE9PSB1bmRlZmluZWQgP1xuICAgICAgb3B0aW9ucy51cGRhdGVXaGlsZUludGVyYWN0aW5nIDogZmFsc2U7XG5cbiAgICAvKipcbiAgICAqIEBwcml2YXRlXG4gICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9WZWN0b3JUaWxlUmVuZGVyVHlwZS5qc1wiKS5kZWZhdWx0fHN0cmluZ31cbiAgICAqL1xuICAgIHRoaXMucmVuZGVyTW9kZV8gPSBvcHRpb25zLnJlbmRlck1vZGUgfHwgVmVjdG9yUmVuZGVyVHlwZS5WRUNUT1I7XG5cbiAgICAvKipcbiAgICAqIFRoZSBsYXllciB0eXBlLlxuICAgICogQHByb3RlY3RlZFxuICAgICogQHR5cGUge2ltcG9ydChcIi4uL0xheWVyVHlwZS5qc1wiKS5kZWZhdWx0fVxuICAgICovXG4gICAgdGhpcy50eXBlID0gTGF5ZXJUeXBlLlZFQ1RPUjtcblxuICB9XG5cbiAgaWYgKCBMYXllciApIFZlY3RvckxheWVyLl9fcHJvdG9fXyA9IExheWVyO1xuICBWZWN0b3JMYXllci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBMYXllciAmJiBMYXllci5wcm90b3R5cGUgKTtcbiAgVmVjdG9yTGF5ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVmVjdG9yTGF5ZXI7XG5cbiAgLyoqXG4gICogQHJldHVybiB7Ym9vbGVhbn0gRGVjbHV0dGVyLlxuICAqL1xuICBWZWN0b3JMYXllci5wcm90b3R5cGUuZ2V0RGVjbHV0dGVyID0gZnVuY3Rpb24gZ2V0RGVjbHV0dGVyICgpIHtcbiAgICByZXR1cm4gdGhpcy5kZWNsdXR0ZXJfO1xuICB9O1xuXG4gIC8qKlxuICAqIEBwYXJhbSB7Ym9vbGVhbn0gZGVjbHV0dGVyIERlY2x1dHRlci5cbiAgKi9cbiAgVmVjdG9yTGF5ZXIucHJvdG90eXBlLnNldERlY2x1dHRlciA9IGZ1bmN0aW9uIHNldERlY2x1dHRlciAoZGVjbHV0dGVyKSB7XG4gICAgdGhpcy5kZWNsdXR0ZXJfID0gZGVjbHV0dGVyO1xuICB9O1xuXG4gIC8qKlxuICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFJlbmRlciBidWZmZXIuXG4gICovXG4gIFZlY3RvckxheWVyLnByb3RvdHlwZS5nZXRSZW5kZXJCdWZmZXIgPSBmdW5jdGlvbiBnZXRSZW5kZXJCdWZmZXIgKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlckJ1ZmZlcl87XG4gIH07XG5cbiAgLyoqXG4gICogQHJldHVybiB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0LCBpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQpOiBudW1iZXJ8bnVsbHx1bmRlZmluZWR9IFJlbmRlclxuICAqICAgICBvcmRlci5cbiAgKi9cbiAgVmVjdG9yTGF5ZXIucHJvdG90eXBlLmdldFJlbmRlck9yZGVyID0gZnVuY3Rpb24gZ2V0UmVuZGVyT3JkZXIgKCkge1xuICAgIHJldHVybiAoXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9yZW5kZXIuanNcIikuT3JkZXJGdW5jdGlvbnxudWxsfHVuZGVmaW5lZH0gKi8gKHRoaXMuZ2V0KFByb3BlcnR5LlJFTkRFUl9PUkRFUikpXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgKiBHZXQgdGhlIHN0eWxlIGZvciBmZWF0dXJlcy4gIFRoaXMgcmV0dXJucyB3aGF0ZXZlciB3YXMgcGFzc2VkIHRvIHRoZSBgc3R5bGVgXG4gICogb3B0aW9uIGF0IGNvbnN0cnVjdGlvbiBvciB0byB0aGUgYHNldFN0eWxlYCBtZXRob2QuXG4gICogQHJldHVybiB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVMaWtlfVxuICAqICAgICBMYXllciBzdHlsZS5cbiAgKiBAYXBpXG4gICovXG4gIFZlY3RvckxheWVyLnByb3RvdHlwZS5nZXRTdHlsZSA9IGZ1bmN0aW9uIGdldFN0eWxlICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHlsZV87XG4gIH07XG5cbiAgLyoqXG4gICogR2V0IHRoZSBzdHlsZSBmdW5jdGlvbi5cbiAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUZ1bmN0aW9ufHVuZGVmaW5lZH0gTGF5ZXIgc3R5bGUgZnVuY3Rpb24uXG4gICogQGFwaVxuICAqL1xuICBWZWN0b3JMYXllci5wcm90b3R5cGUuZ2V0U3R5bGVGdW5jdGlvbiA9IGZ1bmN0aW9uIGdldFN0eWxlRnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnN0eWxlRnVuY3Rpb25fO1xuICB9O1xuXG4gIC8qKlxuICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHJlbmRlcmVkIGxheWVyIHNob3VsZCBiZSB1cGRhdGVkIHdoaWxlXG4gICogICAgIGFuaW1hdGluZy5cbiAgKi9cbiAgVmVjdG9yTGF5ZXIucHJvdG90eXBlLmdldFVwZGF0ZVdoaWxlQW5pbWF0aW5nID0gZnVuY3Rpb24gZ2V0VXBkYXRlV2hpbGVBbmltYXRpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVdoaWxlQW5pbWF0aW5nXztcbiAgfTtcblxuICAvKipcbiAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSByZW5kZXJlZCBsYXllciBzaG91bGQgYmUgdXBkYXRlZCB3aGlsZVxuICAqICAgICBpbnRlcmFjdGluZy5cbiAgKi9cbiAgVmVjdG9yTGF5ZXIucHJvdG90eXBlLmdldFVwZGF0ZVdoaWxlSW50ZXJhY3RpbmcgPSBmdW5jdGlvbiBnZXRVcGRhdGVXaGlsZUludGVyYWN0aW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVXaGlsZUludGVyYWN0aW5nXztcbiAgfTtcblxuICAvKipcbiAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3JlbmRlci5qc1wiKS5PcmRlckZ1bmN0aW9ufG51bGx8dW5kZWZpbmVkfSByZW5kZXJPcmRlclxuICAqICAgICBSZW5kZXIgb3JkZXIuXG4gICovXG4gIFZlY3RvckxheWVyLnByb3RvdHlwZS5zZXRSZW5kZXJPcmRlciA9IGZ1bmN0aW9uIHNldFJlbmRlck9yZGVyIChyZW5kZXJPcmRlcikge1xuICAgIHRoaXMuc2V0KFByb3BlcnR5LlJFTkRFUl9PUkRFUiwgcmVuZGVyT3JkZXIpO1xuICB9O1xuXG4gIC8qKlxuICAqIFNldCB0aGUgc3R5bGUgZm9yIGZlYXR1cmVzLiAgVGhpcyBjYW4gYmUgYSBzaW5nbGUgc3R5bGUgb2JqZWN0LCBhbiBhcnJheVxuICAqIG9mIHN0eWxlcywgb3IgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgZmVhdHVyZSBhbmQgcmVzb2x1dGlvbiBhbmQgcmV0dXJuc1xuICAqIGFuIGFycmF5IG9mIHN0eWxlcy4gSWYgaXQgaXMgYHVuZGVmaW5lZGAgdGhlIGRlZmF1bHQgc3R5bGUgaXMgdXNlZC4gSWZcbiAgKiBpdCBpcyBgbnVsbGAgdGhlIGxheWVyIGhhcyBubyBzdHlsZSAoYSBgbnVsbGAgc3R5bGUpLCBzbyBvbmx5IGZlYXR1cmVzXG4gICogdGhhdCBoYXZlIHRoZWlyIG93biBzdHlsZXMgd2lsbCBiZSByZW5kZXJlZCBpbiB0aGUgbGF5ZXIuIFNlZVxuICAqIHtAbGluayBtb2R1bGU6b2wvc3R5bGV9IGZvciBpbmZvcm1hdGlvbiBvbiB0aGUgZGVmYXVsdCBzdHlsZS5cbiAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHR8QXJyYXk8aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdD58aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVGdW5jdGlvbnxudWxsfHVuZGVmaW5lZH0gc3R5bGUgTGF5ZXIgc3R5bGUuXG4gICogQGFwaVxuICAqL1xuICBWZWN0b3JMYXllci5wcm90b3R5cGUuc2V0U3R5bGUgPSBmdW5jdGlvbiBzZXRTdHlsZSAoc3R5bGUpIHtcbiAgICB0aGlzLnN0eWxlXyA9IHN0eWxlICE9PSB1bmRlZmluZWQgPyBzdHlsZSA6IGNyZWF0ZURlZmF1bHRTdHlsZTtcbiAgICB0aGlzLnN0eWxlRnVuY3Rpb25fID0gc3R5bGUgPT09IG51bGwgP1xuICAgICAgdW5kZWZpbmVkIDogdG9TdHlsZUZ1bmN0aW9uKHRoaXMuc3R5bGVfKTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuICAvKipcbiAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL1ZlY3RvclJlbmRlclR5cGUuanNcIikuZGVmYXVsdHxzdHJpbmd9IFRoZSByZW5kZXIgbW9kZS5cbiAgKi9cbiAgVmVjdG9yTGF5ZXIucHJvdG90eXBlLmdldFJlbmRlck1vZGUgPSBmdW5jdGlvbiBnZXRSZW5kZXJNb2RlICgpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJNb2RlXztcbiAgfTtcblxuICByZXR1cm4gVmVjdG9yTGF5ZXI7XG59KExheWVyKSk7XG5cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGFzc29jaWF0ZWQge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yIHZlY3RvcnNvdXJjZX0gb2YgdGhlIGxheWVyLlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zb3VyY2UvVmVjdG9yLmpzXCIpLmRlZmF1bHR9IFNvdXJjZS5cbiAqIEBhcGlcbiAqL1xuVmVjdG9yTGF5ZXIucHJvdG90eXBlLmdldFNvdXJjZTtcblxuXG5leHBvcnQgZGVmYXVsdCBWZWN0b3JMYXllcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VmVjdG9yLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9sYXllci9WZWN0b3JSZW5kZXJUeXBlXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICogUmVuZGVyIG1vZGUgZm9yIHZlY3RvciBsYXllcnM6XG4gKiAgKiBgJ2ltYWdlJ2A6IFZlY3RvciBsYXllcnMgYXJlIHJlbmRlcmVkIGFzIGltYWdlcy4gR3JlYXQgcGVyZm9ybWFuY2UsIGJ1dFxuICogICAgcG9pbnQgc3ltYm9scyBhbmQgdGV4dHMgYXJlIGFsd2F5cyByb3RhdGVkIHdpdGggdGhlIHZpZXcgYW5kIHBpeGVscyBhcmVcbiAqICAgIHNjYWxlZCBkdXJpbmcgem9vbSBhbmltYXRpb25zLlxuICogICogYCd2ZWN0b3InYDogVmVjdG9yIGxheWVycyBhcmUgcmVuZGVyZWQgYXMgdmVjdG9ycy4gTW9zdCBhY2N1cmF0ZSByZW5kZXJpbmdcbiAqICAgIGV2ZW4gZHVyaW5nIGFuaW1hdGlvbnMsIGJ1dCBzbG93ZXIgcGVyZm9ybWFuY2UuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgSU1BR0U6ICdpbWFnZScsXG4gIFZFQ1RPUjogJ3ZlY3Rvcidcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZlY3RvclJlbmRlclR5cGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2xheWVyL1ZlY3RvclRpbGVSZW5kZXJUeXBlXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICogUmVuZGVyIG1vZGUgZm9yIHZlY3RvciB0aWxlczpcbiAqICAqIGAnaW1hZ2UnYDogVmVjdG9yIHRpbGVzIGFyZSByZW5kZXJlZCBhcyBpbWFnZXMuIEdyZWF0IHBlcmZvcm1hbmNlLCBidXRcbiAqICAgIHBvaW50IHN5bWJvbHMgYW5kIHRleHRzIGFyZSBhbHdheXMgcm90YXRlZCB3aXRoIHRoZSB2aWV3IGFuZCBwaXhlbHMgYXJlXG4gKiAgICBzY2FsZWQgZHVyaW5nIHpvb20gYW5pbWF0aW9ucy5cbiAqICAqIGAnaHlicmlkJ2A6IFBvbHlnb24gYW5kIGxpbmUgZWxlbWVudHMgYXJlIHJlbmRlcmVkIGFzIGltYWdlcywgc28gcGl4ZWxzXG4gKiAgICBhcmUgc2NhbGVkIGR1cmluZyB6b29tIGFuaW1hdGlvbnMuIFBvaW50IHN5bWJvbHMgYW5kIHRleHRzIGFyZSBhY2N1cmF0ZWx5XG4gKiAgICByZW5kZXJlZCBhcyB2ZWN0b3JzIGFuZCBjYW4gc3RheSB1cHJpZ2h0IG9uIHJvdGF0ZWQgdmlld3MuXG4gKiAgKiBgJ3ZlY3RvcidgOiBWZWN0b3IgdGlsZXMgYXJlIHJlbmRlcmVkIGFzIHZlY3RvcnMuIE1vc3QgYWNjdXJhdGUgcmVuZGVyaW5nXG4gKiAgICBldmVuIGR1cmluZyBhbmltYXRpb25zLCBidXQgc2xvd2VyIHBlcmZvcm1hbmNlIHRoYW4gdGhlIG90aGVyIG9wdGlvbnMuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgSU1BR0U6ICdpbWFnZScsXG4gIEhZQlJJRDogJ2h5YnJpZCcsXG4gIFZFQ1RPUjogJ3ZlY3Rvcidcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZlY3RvclRpbGVSZW5kZXJUeXBlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9sb2FkaW5nc3RyYXRlZ3lcbiAqL1xuXG5cbi8qKlxuICogU3RyYXRlZ3kgZnVuY3Rpb24gZm9yIGxvYWRpbmcgYWxsIGZlYXR1cmVzIHdpdGggYSBzaW5nbGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAqIEByZXR1cm4ge0FycmF5PGltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudD59IEV4dGVudHMuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbGwoZXh0ZW50LCByZXNvbHV0aW9uKSB7XG4gIHJldHVybiBbWy1JbmZpbml0eSwgLUluZmluaXR5LCBJbmZpbml0eSwgSW5maW5pdHldXTtcbn1cblxuXG4vKipcbiAqIFN0cmF0ZWd5IGZ1bmN0aW9uIGZvciBsb2FkaW5nIGZlYXR1cmVzIGJhc2VkIG9uIHRoZSB2aWV3J3MgZXh0ZW50IGFuZFxuICogcmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAqIEByZXR1cm4ge0FycmF5PGltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudD59IEV4dGVudHMuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiYm94KGV4dGVudCwgcmVzb2x1dGlvbikge1xuICByZXR1cm4gW2V4dGVudF07XG59XG5cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RyYXRlZ3kgZnVuY3Rpb24gZm9yIGxvYWRpbmcgZmVhdHVyZXMgYmFzZWQgb24gYSB0aWxlIGdyaWQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH0gdGlsZUdyaWQgVGlsZSBncmlkLlxuICogQHJldHVybiB7ZnVuY3Rpb24oaW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50LCBudW1iZXIpOiBBcnJheTxpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnQ+fSBMb2FkaW5nIHN0cmF0ZWd5LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gdGlsZSh0aWxlR3JpZCkge1xuICByZXR1cm4gKFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50Pn0gRXh0ZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbihleHRlbnQsIHJlc29sdXRpb24pIHtcbiAgICAgIHZhciB6ID0gdGlsZUdyaWQuZ2V0WkZvclJlc29sdXRpb24ocmVzb2x1dGlvbik7XG4gICAgICB2YXIgdGlsZVJhbmdlID0gdGlsZUdyaWQuZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWihleHRlbnQsIHopO1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnQ+fSAqL1xuICAgICAgdmFyIGV4dGVudHMgPSBbXTtcbiAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSAqL1xuICAgICAgdmFyIHRpbGVDb29yZCA9IFt6LCAwLCAwXTtcbiAgICAgIGZvciAodGlsZUNvb3JkWzFdID0gdGlsZVJhbmdlLm1pblg7IHRpbGVDb29yZFsxXSA8PSB0aWxlUmFuZ2UubWF4WDsgKyt0aWxlQ29vcmRbMV0pIHtcbiAgICAgICAgZm9yICh0aWxlQ29vcmRbMl0gPSB0aWxlUmFuZ2UubWluWTsgdGlsZUNvb3JkWzJdIDw9IHRpbGVSYW5nZS5tYXhZOyArK3RpbGVDb29yZFsyXSkge1xuICAgICAgICAgIGV4dGVudHMucHVzaCh0aWxlR3JpZC5nZXRUaWxlQ29vcmRFeHRlbnQodGlsZUNvb3JkKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBleHRlbnRzO1xuICAgIH1cbiAgKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZGluZ3N0cmF0ZWd5LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9tYXRoXG4gKi9cbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuL2Fzc2VydHMuanMnO1xuXG4vKipcbiAqIFRha2VzIGEgbnVtYmVyIGFuZCBjbGFtcHMgaXQgdG8gd2l0aGluIHRoZSBwcm92aWRlZCBib3VuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGlucHV0IG51bWJlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIG1pbmltdW0gdmFsdWUgdG8gcmV0dXJuLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSB2YWx1ZSB0byByZXR1cm4uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbnB1dCBudW1iZXIgaWYgaXQgaXMgd2l0aGluIGJvdW5kcywgb3IgdGhlIG5lYXJlc3RcbiAqICAgICBudW1iZXIgd2l0aGluIHRoZSBib3VuZHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGFtcCh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCBtaW4pLCBtYXgpO1xufVxuXG5cbi8qKlxuICogUmV0dXJuIHRoZSBoeXBlcmJvbGljIGNvc2luZSBvZiBhIGdpdmVuIG51bWJlci4gVGhlIG1ldGhvZCB3aWxsIHVzZSB0aGVcbiAqIG5hdGl2ZSBgTWF0aC5jb3NoYCBmdW5jdGlvbiBpZiBpdCBpcyBhdmFpbGFibGUsIG90aGVyd2lzZSB0aGUgaHlwZXJib2xpY1xuICogY29zaW5lIHdpbGwgYmUgY2FsY3VsYXRlZCB2aWEgdGhlIHJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgTW96aWxsYVxuICogZGV2ZWxvcGVyIG5ldHdvcmsuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEByZXR1cm4ge251bWJlcn0gSHlwZXJib2xpYyBjb3NpbmUgb2YgeC5cbiAqL1xuZXhwb3J0IHZhciBjb3NoID0gKGZ1bmN0aW9uKCkge1xuICAvLyBXcmFwcGVkIGluIGEgaWlmZSwgdG8gc2F2ZSB0aGUgb3ZlcmhlYWQgb2YgY2hlY2tpbmcgZm9yIHRoZSBuYXRpdmVcbiAgLy8gaW1wbGVtZW50YXRpb24gb24gZXZlcnkgaW52b2NhdGlvbi5cbiAgdmFyIGNvc2g7XG4gIGlmICgnY29zaCcgaW4gTWF0aCkge1xuICAgIC8vIFRoZSBlbnZpcm9ubWVudCBzdXBwb3J0cyB0aGUgbmF0aXZlIE1hdGguY29zaCBmdW5jdGlvbiwgdXNlIGl04oCmXG4gICAgY29zaCA9IE1hdGguY29zaDtcbiAgfSBlbHNlIHtcbiAgICAvLyDigKYgZWxzZSwgdXNlIHRoZSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24gb2YgTUROOlxuICAgIGNvc2ggPSBmdW5jdGlvbih4KSB7XG4gICAgICB2YXIgeSA9IC8qKiBAdHlwZSB7TWF0aH0gKi8gKE1hdGgpLmV4cCh4KTtcbiAgICAgIHJldHVybiAoeSArIDEgLyB5KSAvIDI7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gY29zaDtcbn0oKSk7XG5cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgc21hbGxlc3QgcG93ZXIgb2YgdHdvIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB4LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcm91bmRVcFRvUG93ZXJPZlR3byh4KSB7XG4gIGFzc2VydCgwIDwgeCwgMjkpOyAvLyBgeGAgbXVzdCBiZSBncmVhdGVyIHRoYW4gYDBgXG4gIHJldHVybiBNYXRoLnBvdygyLCBNYXRoLmNlaWwoTWF0aC5sb2coeCkgLyBNYXRoLkxOMikpO1xufVxuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgc3F1YXJlIG9mIHRoZSBjbG9zZXN0IGRpc3RhbmNlIGJldHdlZW4gdGhlIHBvaW50ICh4LCB5KSBhbmQgdGhlXG4gKiBsaW5lIHNlZ21lbnQgKHgxLCB5MSkgdG8gKHgyLCB5MikuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4MSBYMS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5MSBZMS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4MiBYMi5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5MiBZMi5cbiAqIEByZXR1cm4ge251bWJlcn0gU3F1YXJlZCBkaXN0YW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWRTZWdtZW50RGlzdGFuY2UoeCwgeSwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgdmFyIGR4ID0geDIgLSB4MTtcbiAgdmFyIGR5ID0geTIgLSB5MTtcbiAgaWYgKGR4ICE9PSAwIHx8IGR5ICE9PSAwKSB7XG4gICAgdmFyIHQgPSAoKHggLSB4MSkgKiBkeCArICh5IC0geTEpICogZHkpIC8gKGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICBpZiAodCA+IDEpIHtcbiAgICAgIHgxID0geDI7XG4gICAgICB5MSA9IHkyO1xuICAgIH0gZWxzZSBpZiAodCA+IDApIHtcbiAgICAgIHgxICs9IGR4ICogdDtcbiAgICAgIHkxICs9IGR5ICogdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNxdWFyZWREaXN0YW5jZSh4LCB5LCB4MSwgeTEpO1xufVxuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgc3F1YXJlIG9mIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBwb2ludHMgKHgxLCB5MSkgYW5kICh4MiwgeTIpLlxuICogQHBhcmFtIHtudW1iZXJ9IHgxIFgxLlxuICogQHBhcmFtIHtudW1iZXJ9IHkxIFkxLlxuICogQHBhcmFtIHtudW1iZXJ9IHgyIFgyLlxuICogQHBhcmFtIHtudW1iZXJ9IHkyIFkyLlxuICogQHJldHVybiB7bnVtYmVyfSBTcXVhcmVkIGRpc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZERpc3RhbmNlKHgxLCB5MSwgeDIsIHkyKSB7XG4gIHZhciBkeCA9IHgyIC0geDE7XG4gIHZhciBkeSA9IHkyIC0geTE7XG4gIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuXG4vKipcbiAqIFNvbHZlcyBzeXN0ZW0gb2YgbGluZWFyIGVxdWF0aW9ucyB1c2luZyBHYXVzc2lhbiBlbGltaW5hdGlvbiBtZXRob2QuXG4gKlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gbWF0IEF1Z21lbnRlZCBtYXRyaXggKG4geCBuICsgMSBjb2x1bW4pXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiByb3ctbWFqb3Igb3JkZXIuXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUaGUgcmVzdWx0aW5nIHZlY3Rvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNvbHZlTGluZWFyU3lzdGVtKG1hdCkge1xuICB2YXIgbiA9IG1hdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAvLyBGaW5kIG1heCBpbiB0aGUgaS10aCBjb2x1bW4gKGlnbm9yaW5nIGkgLSAxIGZpcnN0IHJvd3MpXG4gICAgdmFyIG1heFJvdyA9IGk7XG4gICAgdmFyIG1heEVsID0gTWF0aC5hYnMobWF0W2ldW2ldKTtcbiAgICBmb3IgKHZhciByID0gaSArIDE7IHIgPCBuOyByKyspIHtcbiAgICAgIHZhciBhYnNWYWx1ZSA9IE1hdGguYWJzKG1hdFtyXVtpXSk7XG4gICAgICBpZiAoYWJzVmFsdWUgPiBtYXhFbCkge1xuICAgICAgICBtYXhFbCA9IGFic1ZhbHVlO1xuICAgICAgICBtYXhSb3cgPSByO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtYXhFbCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7IC8vIG1hdHJpeCBpcyBzaW5ndWxhclxuICAgIH1cblxuICAgIC8vIFN3YXAgbWF4IHJvdyB3aXRoIGktdGggKGN1cnJlbnQpIHJvd1xuICAgIHZhciB0bXAgPSBtYXRbbWF4Um93XTtcbiAgICBtYXRbbWF4Um93XSA9IG1hdFtpXTtcbiAgICBtYXRbaV0gPSB0bXA7XG5cbiAgICAvLyBTdWJ0cmFjdCB0aGUgaS10aCByb3cgdG8gbWFrZSBhbGwgdGhlIHJlbWFpbmluZyByb3dzIDAgaW4gdGhlIGktdGggY29sdW1uXG4gICAgZm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgbjsgaisrKSB7XG4gICAgICB2YXIgY29lZiA9IC1tYXRbal1baV0gLyBtYXRbaV1baV07XG4gICAgICBmb3IgKHZhciBrID0gaTsgayA8IG4gKyAxOyBrKyspIHtcbiAgICAgICAgaWYgKGkgPT0gaykge1xuICAgICAgICAgIG1hdFtqXVtrXSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0W2pdW2tdICs9IGNvZWYgKiBtYXRbaV1ba107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBTb2x2ZSBBeD1iIGZvciB1cHBlciB0cmlhbmd1bGFyIG1hdHJpeCBBIChtYXQpXG4gIHZhciB4ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBsID0gbiAtIDE7IGwgPj0gMDsgbC0tKSB7XG4gICAgeFtsXSA9IG1hdFtsXVtuXSAvIG1hdFtsXVtsXTtcbiAgICBmb3IgKHZhciBtID0gbCAtIDE7IG0gPj0gMDsgbS0tKSB7XG4gICAgICBtYXRbbV1bbl0gLT0gbWF0W21dW2xdICogeFtsXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5cblxuLyoqXG4gKiBDb252ZXJ0cyByYWRpYW5zIHRvIHRvIGRlZ3JlZXMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlSW5SYWRpYW5zIEFuZ2xlIGluIHJhZGlhbnMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuZ2xlIGluIGRlZ3JlZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0RlZ3JlZXMoYW5nbGVJblJhZGlhbnMpIHtcbiAgcmV0dXJuIGFuZ2xlSW5SYWRpYW5zICogMTgwIC8gTWF0aC5QSTtcbn1cblxuXG4vKipcbiAqIENvbnZlcnRzIGRlZ3JlZXMgdG8gcmFkaWFucy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGVJbkRlZ3JlZXMgQW5nbGUgaW4gZGVncmVlcy5cbiAqIEByZXR1cm4ge251bWJlcn0gQW5nbGUgaW4gcmFkaWFucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUmFkaWFucyhhbmdsZUluRGVncmVlcykge1xuICByZXR1cm4gYW5nbGVJbkRlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG1vZHVsbyBvZiBhIC8gYiwgZGVwZW5kaW5nIG9uIHRoZSBzaWduIG9mIGIuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGEgRGl2aWRlbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gYiBEaXZpc29yLlxuICogQHJldHVybiB7bnVtYmVyfSBNb2R1bG8uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtb2R1bG8oYSwgYikge1xuICB2YXIgciA9IGEgJSBiO1xuICByZXR1cm4gciAqIGIgPCAwID8gciArIGIgOiByO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxpbmVhcmx5IGludGVycG9sYXRlZCB2YWx1ZSBvZiB4IGJldHdlZW4gYSBhbmQgYi5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gYSBOdW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIE51bWJlclxuICogQHBhcmFtIHtudW1iZXJ9IHggVmFsdWUgdG8gYmUgaW50ZXJwb2xhdGVkLlxuICogQHJldHVybiB7bnVtYmVyfSBJbnRlcnBvbGF0ZWQgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZXJwKGEsIGIsIHgpIHtcbiAgcmV0dXJuIGEgKyB4ICogKGIgLSBhKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF0aC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvb2JqXG4gKi9cblxuXG4vKipcbiAqIFBvbHlmaWxsIGZvciBPYmplY3QuYXNzaWduKCkuICBBc3NpZ25zIGVudW1lcmFibGUgYW5kIG93biBwcm9wZXJ0aWVzIGZyb21cbiAqIG9uZSBvciBtb3JlIHNvdXJjZSBvYmplY3RzIHRvIGEgdGFyZ2V0IG9iamVjdC5cbiAqIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvYXNzaWduLlxuICpcbiAqIEBwYXJhbSB7IU9iamVjdH0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IHZhcl9zb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0KHMpLlxuICogQHJldHVybiB7IU9iamVjdH0gVGhlIG1vZGlmaWVkIHRhcmdldCBvYmplY3QuXG4gKi9cbmV4cG9ydCB2YXIgYXNzaWduID0gKHR5cGVvZiBPYmplY3QuYXNzaWduID09PSAnZnVuY3Rpb24nKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbih0YXJnZXQsIHZhcl9zb3VyY2VzKSB7XG4gIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0Jyk7XG4gIH1cblxuICB2YXIgb3V0cHV0ID0gT2JqZWN0KHRhcmdldCk7XG4gIGZvciAodmFyIGkgPSAxLCBpaSA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50cyQxW2ldO1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCAmJiBzb3VyY2UgIT09IG51bGwpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgb3V0cHV0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufTtcblxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIHByb3BlcnRpZXMgZnJvbSBhbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xlYXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhcihvYmplY3QpIHtcbiAgZm9yICh2YXIgcHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgZGVsZXRlIG9iamVjdFtwcm9wZXJ0eV07XG4gIH1cbn1cblxuXG4vKipcbiAqIEdldCBhbiBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMgZnJvbSBhbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdDxLLFY+fSBvYmplY3QgVGhlIG9iamVjdCBmcm9tIHdoaWNoIHRvIGdldCB0aGUgdmFsdWVzLlxuICogQHJldHVybiB7IUFycmF5PFY+fSBUaGUgcHJvcGVydHkgdmFsdWVzLlxuICogQHRlbXBsYXRlIEssVlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmFsdWVzKG9iamVjdCkge1xuICB2YXIgdmFsdWVzID0gW107XG4gIGZvciAodmFyIHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgIHZhbHVlcy5wdXNoKG9iamVjdFtwcm9wZXJ0eV0pO1xuICB9XG4gIHJldHVybiB2YWx1ZXM7XG59XG5cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGhhcyBhbnkgcHJvcGVydGllcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBvYmplY3QgaXMgZW1wdHkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VtcHR5KG9iamVjdCkge1xuICB2YXIgcHJvcGVydHk7XG4gIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAhcHJvcGVydHk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9iai5qcy5tYXAiLCJcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL29sLmNzc1wiKTtcblxuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5cbnZhciB0cmFuc2Zvcm07XG52YXIgaW5zZXJ0SW50bztcblxuXG5cbnZhciBvcHRpb25zID0ge1wiaG1yXCI6dHJ1ZX1cblxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbm9wdGlvbnMuaW5zZXJ0SW50byA9IHVuZGVmaW5lZDtcblxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5cbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuXG5pZihtb2R1bGUuaG90KSB7XG5cdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vb2wuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL29sLmNzc1wiKTtcblxuXHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXG5cdFx0dmFyIGxvY2FscyA9IChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIga2V5LCBpZHggPSAwO1xuXG5cdFx0XHRmb3Ioa2V5IGluIGEpIHtcblx0XHRcdFx0aWYoIWIgfHwgYVtrZXldICE9PSBiW2tleV0pIHJldHVybiBmYWxzZTtcblx0XHRcdFx0aWR4Kys7XG5cdFx0XHR9XG5cblx0XHRcdGZvcihrZXkgaW4gYikgaWR4LS07XG5cblx0XHRcdHJldHVybiBpZHggPT09IDA7XG5cdFx0fShjb250ZW50LmxvY2FscywgbmV3Q29udGVudC5sb2NhbHMpKTtcblxuXHRcdGlmKCFsb2NhbHMpIHRocm93IG5ldyBFcnJvcignQWJvcnRpbmcgQ1NTIEhNUiBkdWUgdG8gY2hhbmdlZCBjc3MtbW9kdWxlcyBsb2NhbHMuJyk7XG5cblx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdH0pO1xuXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSIsIi8qKlxuICogQG1vZHVsZSBvbC9wb2ludGVyL0V2ZW50U291cmNlXG4gKi9cblxudmFyIEV2ZW50U291cmNlID0gZnVuY3Rpb24gRXZlbnRTb3VyY2UoZGlzcGF0Y2hlciwgbWFwcGluZykge1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9Qb2ludGVyRXZlbnRIYW5kbGVyLmpzXCIpLmRlZmF1bHR9XG4gICAqL1xuICB0aGlzLmRpc3BhdGNoZXIgPSBkaXNwYXRjaGVyO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAY29uc3RcbiAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBmdW5jdGlvbihFdmVudCk+fVxuICAgKi9cbiAgdGhpcy5tYXBwaW5nXyA9IG1hcHBpbmc7XG59O1xuXG4vKipcbiAqIExpc3Qgb2YgZXZlbnRzIHN1cHBvcnRlZCBieSB0aGlzIHNvdXJjZS5cbiAqIEByZXR1cm4ge0FycmF5PHN0cmluZz59IEV2ZW50IG5hbWVzXG4gKi9cbkV2ZW50U291cmNlLnByb3RvdHlwZS5nZXRFdmVudHMgPSBmdW5jdGlvbiBnZXRFdmVudHMgKCkge1xuICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5tYXBwaW5nXyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGhhbmRsZXIgdGhhdCBzaG91bGQgaGFuZGxlIGEgZ2l2ZW4gZXZlbnQgdHlwZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgVGhlIGV2ZW50IHR5cGUuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbihFdmVudCl9IEhhbmRsZXJcbiAqL1xuRXZlbnRTb3VyY2UucHJvdG90eXBlLmdldEhhbmRsZXJGb3JFdmVudCA9IGZ1bmN0aW9uIGdldEhhbmRsZXJGb3JFdmVudCAoZXZlbnRUeXBlKSB7XG4gIHJldHVybiB0aGlzLm1hcHBpbmdfW2V2ZW50VHlwZV07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBFdmVudFNvdXJjZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXZlbnRTb3VyY2UuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3BvaW50ZXIvRXZlbnRUeXBlXG4gKi9cblxuLyoqXG4gKiBDb25zdGFudHMgZm9yIGV2ZW50IG5hbWVzLlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBQT0lOVEVSTU9WRTogJ3BvaW50ZXJtb3ZlJyxcbiAgUE9JTlRFUkRPV046ICdwb2ludGVyZG93bicsXG4gIFBPSU5URVJVUDogJ3BvaW50ZXJ1cCcsXG4gIFBPSU5URVJPVkVSOiAncG9pbnRlcm92ZXInLFxuICBQT0lOVEVST1VUOiAncG9pbnRlcm91dCcsXG4gIFBPSU5URVJFTlRFUjogJ3BvaW50ZXJlbnRlcicsXG4gIFBPSU5URVJMRUFWRTogJ3BvaW50ZXJsZWF2ZScsXG4gIFBPSU5URVJDQU5DRUw6ICdwb2ludGVyY2FuY2VsJ1xufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXZlbnRUeXBlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9wb2ludGVyL01vdXNlU291cmNlXG4gKi9cblxuLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL1BvbHltZXIvUG9pbnRlckV2ZW50c1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgVGhlIFBvbHltZXIgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vXG4vLyBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbi8vIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbi8vIG1ldDpcbi8vXG4vLyAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4vLyBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4vLyAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbi8vIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXJcbi8vIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGVcbi8vIGRpc3RyaWJ1dGlvbi5cbi8vICogTmVpdGhlciB0aGUgbmFtZSBvZiBHb29nbGUgSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuLy8gY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbi8vIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4vL1xuLy8gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuLy8gXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuLy8gTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4vLyBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuLy8gT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4vLyBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4vLyBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbi8vIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuLy8gVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuLy8gKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4vLyBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuXG5pbXBvcnQgRXZlbnRTb3VyY2UgZnJvbSAnLi9FdmVudFNvdXJjZS5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIFBPSU5URVJfSUQgPSAxO1xuXG5cbi8qKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IHZhciBQT0lOVEVSX1RZUEUgPSAnbW91c2UnO1xuXG5cbi8qKlxuICogUmFkaXVzIGFyb3VuZCB0b3VjaGVuZCB0aGF0IHN3YWxsb3dzIG1vdXNlIGV2ZW50cy5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG52YXIgREVEVVBfRElTVCA9IDI1O1xuXG4vKipcbiAqIEhhbmRsZXIgZm9yIGBtb3VzZWRvd25gLlxuICpcbiAqIEB0aGlzIHtNb3VzZVNvdXJjZX1cbiAqIEBwYXJhbSB7TW91c2VFdmVudH0gaW5FdmVudCBUaGUgaW4gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIG1vdXNlZG93bihpbkV2ZW50KSB7XG4gIGlmICghdGhpcy5pc0V2ZW50U2ltdWxhdGVkRnJvbVRvdWNoXyhpbkV2ZW50KSkge1xuICAgIC8vIFRPRE8oZGZyZWVkbWFuKSB3b3JrYXJvdW5kIGZvciBzb21lIGVsZW1lbnRzIG5vdCBzZW5kaW5nIG1vdXNldXBcbiAgICAvLyBodHRwOi8vY3JidWcvMTQ5MDkxXG4gICAgaWYgKFBPSU5URVJfSUQudG9TdHJpbmcoKSBpbiB0aGlzLnBvaW50ZXJNYXApIHtcbiAgICAgIHRoaXMuY2FuY2VsKGluRXZlbnQpO1xuICAgIH1cbiAgICB2YXIgZSA9IHByZXBhcmVFdmVudChpbkV2ZW50LCB0aGlzLmRpc3BhdGNoZXIpO1xuICAgIHRoaXMucG9pbnRlck1hcFtQT0lOVEVSX0lELnRvU3RyaW5nKCldID0gaW5FdmVudDtcbiAgICB0aGlzLmRpc3BhdGNoZXIuZG93bihlLCBpbkV2ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIEhhbmRsZXIgZm9yIGBtb3VzZW1vdmVgLlxuICpcbiAqIEB0aGlzIHtNb3VzZVNvdXJjZX1cbiAqIEBwYXJhbSB7TW91c2VFdmVudH0gaW5FdmVudCBUaGUgaW4gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIG1vdXNlbW92ZShpbkV2ZW50KSB7XG4gIGlmICghdGhpcy5pc0V2ZW50U2ltdWxhdGVkRnJvbVRvdWNoXyhpbkV2ZW50KSkge1xuICAgIHZhciBlID0gcHJlcGFyZUV2ZW50KGluRXZlbnQsIHRoaXMuZGlzcGF0Y2hlcik7XG4gICAgdGhpcy5kaXNwYXRjaGVyLm1vdmUoZSwgaW5FdmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgbW91c2V1cGAuXG4gKlxuICogQHRoaXMge01vdXNlU291cmNlfVxuICogQHBhcmFtIHtNb3VzZUV2ZW50fSBpbkV2ZW50IFRoZSBpbiBldmVudC5cbiAqL1xuZnVuY3Rpb24gbW91c2V1cChpbkV2ZW50KSB7XG4gIGlmICghdGhpcy5pc0V2ZW50U2ltdWxhdGVkRnJvbVRvdWNoXyhpbkV2ZW50KSkge1xuICAgIHZhciBwID0gdGhpcy5wb2ludGVyTWFwW1BPSU5URVJfSUQudG9TdHJpbmcoKV07XG5cbiAgICBpZiAocCAmJiBwLmJ1dHRvbiA9PT0gaW5FdmVudC5idXR0b24pIHtcbiAgICAgIHZhciBlID0gcHJlcGFyZUV2ZW50KGluRXZlbnQsIHRoaXMuZGlzcGF0Y2hlcik7XG4gICAgICB0aGlzLmRpc3BhdGNoZXIudXAoZSwgaW5FdmVudCk7XG4gICAgICB0aGlzLmNsZWFudXBNb3VzZSgpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEhhbmRsZXIgZm9yIGBtb3VzZW92ZXJgLlxuICpcbiAqIEB0aGlzIHtNb3VzZVNvdXJjZX1cbiAqIEBwYXJhbSB7TW91c2VFdmVudH0gaW5FdmVudCBUaGUgaW4gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIG1vdXNlb3ZlcihpbkV2ZW50KSB7XG4gIGlmICghdGhpcy5pc0V2ZW50U2ltdWxhdGVkRnJvbVRvdWNoXyhpbkV2ZW50KSkge1xuICAgIHZhciBlID0gcHJlcGFyZUV2ZW50KGluRXZlbnQsIHRoaXMuZGlzcGF0Y2hlcik7XG4gICAgdGhpcy5kaXNwYXRjaGVyLmVudGVyT3ZlcihlLCBpbkV2ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIEhhbmRsZXIgZm9yIGBtb3VzZW91dGAuXG4gKlxuICogQHRoaXMge01vdXNlU291cmNlfVxuICogQHBhcmFtIHtNb3VzZUV2ZW50fSBpbkV2ZW50IFRoZSBpbiBldmVudC5cbiAqL1xuZnVuY3Rpb24gbW91c2VvdXQoaW5FdmVudCkge1xuICBpZiAoIXRoaXMuaXNFdmVudFNpbXVsYXRlZEZyb21Ub3VjaF8oaW5FdmVudCkpIHtcbiAgICB2YXIgZSA9IHByZXBhcmVFdmVudChpbkV2ZW50LCB0aGlzLmRpc3BhdGNoZXIpO1xuICAgIHRoaXMuZGlzcGF0Y2hlci5sZWF2ZU91dChlLCBpbkV2ZW50KTtcbiAgfVxufVxuXG5cbnZhciBNb3VzZVNvdXJjZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEV2ZW50U291cmNlKSB7XG4gIGZ1bmN0aW9uIE1vdXNlU291cmNlKGRpc3BhdGNoZXIpIHtcbiAgICB2YXIgbWFwcGluZyA9IHtcbiAgICAgICdtb3VzZWRvd24nOiBtb3VzZWRvd24sXG4gICAgICAnbW91c2Vtb3ZlJzogbW91c2Vtb3ZlLFxuICAgICAgJ21vdXNldXAnOiBtb3VzZXVwLFxuICAgICAgJ21vdXNlb3Zlcic6IG1vdXNlb3ZlcixcbiAgICAgICdtb3VzZW91dCc6IG1vdXNlb3V0XG4gICAgfTtcbiAgICBFdmVudFNvdXJjZS5jYWxsKHRoaXMsIGRpc3BhdGNoZXIsIG1hcHBpbmcpO1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0XG4gICAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBFdmVudHxPYmplY3Q+fVxuICAgICAqL1xuICAgIHRoaXMucG9pbnRlck1hcCA9IGRpc3BhdGNoZXIucG9pbnRlck1hcDtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdFxuICAgICAqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuLi9waXhlbC5qc1wiKS5QaXhlbD59XG4gICAgICovXG4gICAgdGhpcy5sYXN0VG91Y2hlcyA9IFtdO1xuICB9XG5cbiAgaWYgKCBFdmVudFNvdXJjZSApIE1vdXNlU291cmNlLl9fcHJvdG9fXyA9IEV2ZW50U291cmNlO1xuICBNb3VzZVNvdXJjZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFdmVudFNvdXJjZSAmJiBFdmVudFNvdXJjZS5wcm90b3R5cGUgKTtcbiAgTW91c2VTb3VyY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTW91c2VTb3VyY2U7XG5cbiAgLyoqXG4gICAqIERldGVjdCBpZiBhIG1vdXNlIGV2ZW50IHdhcyBzaW11bGF0ZWQgZnJvbSBhIHRvdWNoIGJ5XG4gICAqIGNoZWNraW5nIGlmIHByZXZpb3VzbHkgdGhlcmUgd2FzIGEgdG91Y2ggZXZlbnQgYXQgdGhlXG4gICAqIHNhbWUgcG9zaXRpb24uXG4gICAqXG4gICAqIEZJWE1FIC0gS25vd24gcHJvYmxlbSB3aXRoIHRoZSBuYXRpdmUgQW5kcm9pZCBicm93c2VyIG9uXG4gICAqIFNhbXN1bmcgR1QtSTkxMDAgKEFuZHJvaWQgNC4xLjIpOlxuICAgKiBJbiBjYXNlIHRoZSBwYWdlIGlzIHNjcm9sbGVkLCB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IHdvcmtcbiAgICogY29ycmVjdGx5IHdoZW4gYSBjYW52YXMgaXMgdXNlZCAoV2ViR0wgb3IgY2FudmFzIHJlbmRlcmVyKS5cbiAgICogTW91c2UgbGlzdGVuZXJzIG9uIGNhbnZhcyBlbGVtZW50cyAoZm9yIHRoaXMgYnJvd3NlciksIGNyZWF0ZVxuICAgKiB0d28gbW91c2UgZXZlbnRzOiBPbmUgJ2dvb2QnIGFuZCBvbmUgJ2JhZCcgb25lIChvbiBvdGhlciBicm93c2VycyBvclxuICAgKiB3aGVuIGEgZGl2IGlzIHVzZWQsIHRoZXJlIGlzIG9ubHkgb25lIGV2ZW50KS4gRm9yIHRoZSAnYmFkJyBvbmUsXG4gICAqIGNsaWVudFgvY2xpZW50WSBhbmQgYWxzbyBwYWdlWC9wYWdlWSBhcmUgd3Jvbmcgd2hlbiB0aGUgcGFnZVxuICAgKiBpcyBzY3JvbGxlZC4gQmVjYXVzZSBvZiB0aGF0LCB0aGlzIGZ1bmN0aW9uIGNhbiBub3QgZGV0ZWN0IGlmXG4gICAqIHRoZSBldmVudHMgd2VyZSBzaW11bGF0ZWQgZnJvbSBhIHRvdWNoIGV2ZW50LiBBcyByZXN1bHQsIGFcbiAgICogcG9pbnRlciBldmVudCBhdCBhIHdyb25nIHBvc2l0aW9uIGlzIGRpc3BhdGNoZWQsIHdoaWNoIGNvbmZ1c2VzXG4gICAqIHRoZSBtYXAgaW50ZXJhY3Rpb25zLlxuICAgKiBJdCBpcyB1bmNsZWFyLCBob3cgb25lIGNhbiBnZXQgdGhlIGNvcnJlY3QgcG9zaXRpb24gZm9yIHRoZSBldmVudFxuICAgKiBvciBkZXRlY3QgdGhhdCB0aGUgcG9zaXRpb25zIGFyZSBpbnZhbGlkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGluRXZlbnQgVGhlIGluIGV2ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlLCBpZiB0aGUgZXZlbnQgd2FzIGdlbmVyYXRlZCBieSBhIHRvdWNoLlxuICAgKi9cbiAgTW91c2VTb3VyY2UucHJvdG90eXBlLmlzRXZlbnRTaW11bGF0ZWRGcm9tVG91Y2hfID0gZnVuY3Rpb24gaXNFdmVudFNpbXVsYXRlZEZyb21Ub3VjaF8gKGluRXZlbnQpIHtcbiAgICB2YXIgbHRzID0gdGhpcy5sYXN0VG91Y2hlcztcbiAgICB2YXIgeCA9IGluRXZlbnQuY2xpZW50WDtcbiAgICB2YXIgeSA9IGluRXZlbnQuY2xpZW50WTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGx0cy5sZW5ndGgsIHQgPSAodm9pZCAwKTsgaSA8IGwgJiYgKHQgPSBsdHNbaV0pOyBpKyspIHtcbiAgICAgIC8vIHNpbXVsYXRlZCBtb3VzZSBldmVudHMgd2lsbCBiZSBzd2FsbG93ZWQgbmVhciBhIHByaW1hcnkgdG91Y2hlbmRcbiAgICAgIHZhciBkeCA9IE1hdGguYWJzKHggLSB0WzBdKTtcbiAgICAgIHZhciBkeSA9IE1hdGguYWJzKHkgLSB0WzFdKTtcbiAgICAgIGlmIChkeCA8PSBERURVUF9ESVNUICYmIGR5IDw9IERFRFVQX0RJU1QpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhIGBwb2ludGVyY2FuY2VsYCBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gaW5FdmVudCBUaGUgaW4gZXZlbnQuXG4gICAqL1xuICBNb3VzZVNvdXJjZS5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gY2FuY2VsIChpbkV2ZW50KSB7XG4gICAgdmFyIGUgPSBwcmVwYXJlRXZlbnQoaW5FdmVudCwgdGhpcy5kaXNwYXRjaGVyKTtcbiAgICB0aGlzLmRpc3BhdGNoZXIuY2FuY2VsKGUsIGluRXZlbnQpO1xuICAgIHRoaXMuY2xlYW51cE1vdXNlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgbW91c2UgZnJvbSB0aGUgbGlzdCBvZiBhY3RpdmUgcG9pbnRlcnMuXG4gICAqL1xuICBNb3VzZVNvdXJjZS5wcm90b3R5cGUuY2xlYW51cE1vdXNlID0gZnVuY3Rpb24gY2xlYW51cE1vdXNlICgpIHtcbiAgICBkZWxldGUgdGhpcy5wb2ludGVyTWFwW1BPSU5URVJfSUQudG9TdHJpbmcoKV07XG4gIH07XG5cbiAgcmV0dXJuIE1vdXNlU291cmNlO1xufShFdmVudFNvdXJjZSkpO1xuXG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhlIG9yaWdpbmFsIGV2ZW50IHRoYXQgd2lsbCBiZSB1c2VkXG4gKiBmb3IgdGhlIGZha2UgcG9pbnRlciBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50fSBpbkV2ZW50IFRoZSBpbiBldmVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9Qb2ludGVyRXZlbnRIYW5kbGVyLmpzXCIpLmRlZmF1bHR9IGRpc3BhdGNoZXIgRXZlbnQgaGFuZGxlci5cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvcGllZCBldmVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZXBhcmVFdmVudChpbkV2ZW50LCBkaXNwYXRjaGVyKSB7XG4gIHZhciBlID0gZGlzcGF0Y2hlci5jbG9uZUV2ZW50KGluRXZlbnQsIGluRXZlbnQpO1xuXG4gIC8vIGZvcndhcmQgbW91c2UgcHJldmVudERlZmF1bHRcbiAgdmFyIHBkID0gZS5wcmV2ZW50RGVmYXVsdDtcbiAgZS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuICAgIGluRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBwZCgpO1xuICB9O1xuXG4gIGUucG9pbnRlcklkID0gUE9JTlRFUl9JRDtcbiAgZS5pc1ByaW1hcnkgPSB0cnVlO1xuICBlLnBvaW50ZXJUeXBlID0gUE9JTlRFUl9UWVBFO1xuXG4gIHJldHVybiBlO1xufVxuXG5cbmV4cG9ydCBkZWZhdWx0IE1vdXNlU291cmNlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Nb3VzZVNvdXJjZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcG9pbnRlci9Nc1NvdXJjZVxuICovXG4vLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vUG9seW1lci9Qb2ludGVyRXZlbnRzXG5cbi8vIENvcHlyaWdodCAoYykgMjAxMyBUaGUgUG9seW1lciBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy9cbi8vIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuLy8gbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuLy8gbWV0OlxuLy9cbi8vICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbi8vIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbi8vICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuLy8gY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lclxuLy8gaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZVxuLy8gZGlzdHJpYnV0aW9uLlxuLy8gKiBOZWl0aGVyIHRoZSBuYW1lIG9mIEdvb2dsZSBJbmMuIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4vLyBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbVxuLy8gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbi8vXG4vLyBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4vLyBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4vLyBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1Jcbi8vIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4vLyBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbi8vIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1Rcbi8vIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuLy8gREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4vLyBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4vLyAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0Vcbi8vIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG5cbmltcG9ydCBFdmVudFNvdXJjZSBmcm9tICcuL0V2ZW50U291cmNlLmpzJztcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge0FycmF5PHN0cmluZz59XG4gKi9cbnZhciBQT0lOVEVSX1RZUEVTID0gW1xuICAnJyxcbiAgJ3VuYXZhaWxhYmxlJyxcbiAgJ3RvdWNoJyxcbiAgJ3BlbicsXG4gICdtb3VzZSdcbl07XG5cbi8qKlxuICogSGFuZGxlciBmb3IgYG1zUG9pbnRlckRvd25gLlxuICpcbiAqIEB0aGlzIHtNc1NvdXJjZX1cbiAqIEBwYXJhbSB7TVNQb2ludGVyRXZlbnR9IGluRXZlbnQgVGhlIGluIGV2ZW50LlxuICovXG5mdW5jdGlvbiBtc1BvaW50ZXJEb3duKGluRXZlbnQpIHtcbiAgdGhpcy5wb2ludGVyTWFwW2luRXZlbnQucG9pbnRlcklkLnRvU3RyaW5nKCldID0gaW5FdmVudDtcbiAgdmFyIGUgPSB0aGlzLnByZXBhcmVFdmVudF8oaW5FdmVudCk7XG4gIHRoaXMuZGlzcGF0Y2hlci5kb3duKGUsIGluRXZlbnQpO1xufVxuXG4vKipcbiAqIEhhbmRsZXIgZm9yIGBtc1BvaW50ZXJNb3ZlYC5cbiAqXG4gKiBAdGhpcyB7TXNTb3VyY2V9XG4gKiBAcGFyYW0ge01TUG9pbnRlckV2ZW50fSBpbkV2ZW50IFRoZSBpbiBldmVudC5cbiAqL1xuZnVuY3Rpb24gbXNQb2ludGVyTW92ZShpbkV2ZW50KSB7XG4gIHZhciBlID0gdGhpcy5wcmVwYXJlRXZlbnRfKGluRXZlbnQpO1xuICB0aGlzLmRpc3BhdGNoZXIubW92ZShlLCBpbkV2ZW50KTtcbn1cblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgbXNQb2ludGVyVXBgLlxuICpcbiAqIEB0aGlzIHtNc1NvdXJjZX1cbiAqIEBwYXJhbSB7TVNQb2ludGVyRXZlbnR9IGluRXZlbnQgVGhlIGluIGV2ZW50LlxuICovXG5mdW5jdGlvbiBtc1BvaW50ZXJVcChpbkV2ZW50KSB7XG4gIHZhciBlID0gdGhpcy5wcmVwYXJlRXZlbnRfKGluRXZlbnQpO1xuICB0aGlzLmRpc3BhdGNoZXIudXAoZSwgaW5FdmVudCk7XG4gIHRoaXMuY2xlYW51cChpbkV2ZW50LnBvaW50ZXJJZCk7XG59XG5cbi8qKlxuICogSGFuZGxlciBmb3IgYG1zUG9pbnRlck91dGAuXG4gKlxuICogQHRoaXMge01zU291cmNlfVxuICogQHBhcmFtIHtNU1BvaW50ZXJFdmVudH0gaW5FdmVudCBUaGUgaW4gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIG1zUG9pbnRlck91dChpbkV2ZW50KSB7XG4gIHZhciBlID0gdGhpcy5wcmVwYXJlRXZlbnRfKGluRXZlbnQpO1xuICB0aGlzLmRpc3BhdGNoZXIubGVhdmVPdXQoZSwgaW5FdmVudCk7XG59XG5cbi8qKlxuICogSGFuZGxlciBmb3IgYG1zUG9pbnRlck92ZXJgLlxuICpcbiAqIEB0aGlzIHtNc1NvdXJjZX1cbiAqIEBwYXJhbSB7TVNQb2ludGVyRXZlbnR9IGluRXZlbnQgVGhlIGluIGV2ZW50LlxuICovXG5mdW5jdGlvbiBtc1BvaW50ZXJPdmVyKGluRXZlbnQpIHtcbiAgdmFyIGUgPSB0aGlzLnByZXBhcmVFdmVudF8oaW5FdmVudCk7XG4gIHRoaXMuZGlzcGF0Y2hlci5lbnRlck92ZXIoZSwgaW5FdmVudCk7XG59XG5cbi8qKlxuICogSGFuZGxlciBmb3IgYG1zUG9pbnRlckNhbmNlbGAuXG4gKlxuICogQHRoaXMge01zU291cmNlfVxuICogQHBhcmFtIHtNU1BvaW50ZXJFdmVudH0gaW5FdmVudCBUaGUgaW4gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIG1zUG9pbnRlckNhbmNlbChpbkV2ZW50KSB7XG4gIHZhciBlID0gdGhpcy5wcmVwYXJlRXZlbnRfKGluRXZlbnQpO1xuICB0aGlzLmRpc3BhdGNoZXIuY2FuY2VsKGUsIGluRXZlbnQpO1xuICB0aGlzLmNsZWFudXAoaW5FdmVudC5wb2ludGVySWQpO1xufVxuXG4vKipcbiAqIEhhbmRsZXIgZm9yIGBtc0xvc3RQb2ludGVyQ2FwdHVyZWAuXG4gKlxuICogQHRoaXMge01zU291cmNlfVxuICogQHBhcmFtIHtNU1BvaW50ZXJFdmVudH0gaW5FdmVudCBUaGUgaW4gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIG1zTG9zdFBvaW50ZXJDYXB0dXJlKGluRXZlbnQpIHtcbiAgdmFyIGUgPSB0aGlzLmRpc3BhdGNoZXIubWFrZUV2ZW50KCdsb3N0cG9pbnRlcmNhcHR1cmUnLCBpbkV2ZW50LCBpbkV2ZW50KTtcbiAgdGhpcy5kaXNwYXRjaGVyLmRpc3BhdGNoRXZlbnQoZSk7XG59XG5cbi8qKlxuICogSGFuZGxlciBmb3IgYG1zR290UG9pbnRlckNhcHR1cmVgLlxuICpcbiAqIEB0aGlzIHtNc1NvdXJjZX1cbiAqIEBwYXJhbSB7TVNQb2ludGVyRXZlbnR9IGluRXZlbnQgVGhlIGluIGV2ZW50LlxuICovXG5mdW5jdGlvbiBtc0dvdFBvaW50ZXJDYXB0dXJlKGluRXZlbnQpIHtcbiAgdmFyIGUgPSB0aGlzLmRpc3BhdGNoZXIubWFrZUV2ZW50KCdnb3Rwb2ludGVyY2FwdHVyZScsIGluRXZlbnQsIGluRXZlbnQpO1xuICB0aGlzLmRpc3BhdGNoZXIuZGlzcGF0Y2hFdmVudChlKTtcbn1cblxudmFyIE1zU291cmNlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoRXZlbnRTb3VyY2UpIHtcbiAgZnVuY3Rpb24gTXNTb3VyY2UoZGlzcGF0Y2hlcikge1xuICAgIHZhciBtYXBwaW5nID0ge1xuICAgICAgJ01TUG9pbnRlckRvd24nOiBtc1BvaW50ZXJEb3duLFxuICAgICAgJ01TUG9pbnRlck1vdmUnOiBtc1BvaW50ZXJNb3ZlLFxuICAgICAgJ01TUG9pbnRlclVwJzogbXNQb2ludGVyVXAsXG4gICAgICAnTVNQb2ludGVyT3V0JzogbXNQb2ludGVyT3V0LFxuICAgICAgJ01TUG9pbnRlck92ZXInOiBtc1BvaW50ZXJPdmVyLFxuICAgICAgJ01TUG9pbnRlckNhbmNlbCc6IG1zUG9pbnRlckNhbmNlbCxcbiAgICAgICdNU0dvdFBvaW50ZXJDYXB0dXJlJzogbXNHb3RQb2ludGVyQ2FwdHVyZSxcbiAgICAgICdNU0xvc3RQb2ludGVyQ2FwdHVyZSc6IG1zTG9zdFBvaW50ZXJDYXB0dXJlXG4gICAgfTtcbiAgICBFdmVudFNvdXJjZS5jYWxsKHRoaXMsIGRpc3BhdGNoZXIsIG1hcHBpbmcpO1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0XG4gICAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBNU1BvaW50ZXJFdmVudHxPYmplY3Q+fVxuICAgICAqL1xuICAgIHRoaXMucG9pbnRlck1hcCA9IGRpc3BhdGNoZXIucG9pbnRlck1hcDtcbiAgfVxuXG4gIGlmICggRXZlbnRTb3VyY2UgKSBNc1NvdXJjZS5fX3Byb3RvX18gPSBFdmVudFNvdXJjZTtcbiAgTXNTb3VyY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXZlbnRTb3VyY2UgJiYgRXZlbnRTb3VyY2UucHJvdG90eXBlICk7XG4gIE1zU291cmNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1zU291cmNlO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGUgb3JpZ2luYWwgZXZlbnQgdGhhdCB3aWxsIGJlIHVzZWRcbiAgICogZm9yIHRoZSBmYWtlIHBvaW50ZXIgZXZlbnQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7TVNQb2ludGVyRXZlbnR9IGluRXZlbnQgVGhlIGluIGV2ZW50LlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb3BpZWQgZXZlbnQuXG4gICAqL1xuICBNc1NvdXJjZS5wcm90b3R5cGUucHJlcGFyZUV2ZW50XyA9IGZ1bmN0aW9uIHByZXBhcmVFdmVudF8gKGluRXZlbnQpIHtcbiAgICAvKiogQHR5cGUge01TUG9pbnRlckV2ZW50fE9iamVjdH0gKi9cbiAgICB2YXIgZSA9IGluRXZlbnQ7XG4gICAgaWYgKHR5cGVvZiBpbkV2ZW50LnBvaW50ZXJUeXBlID09PSAnbnVtYmVyJykge1xuICAgICAgZSA9IHRoaXMuZGlzcGF0Y2hlci5jbG9uZUV2ZW50KGluRXZlbnQsIGluRXZlbnQpO1xuICAgICAgZS5wb2ludGVyVHlwZSA9IFBPSU5URVJfVFlQRVNbaW5FdmVudC5wb2ludGVyVHlwZV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGlzIHBvaW50ZXIgZnJvbSB0aGUgbGlzdCBvZiBhY3RpdmUgcG9pbnRlcnMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwb2ludGVySWQgUG9pbnRlciBpZGVudGlmaWVyLlxuICAgKi9cbiAgTXNTb3VyY2UucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbiBjbGVhbnVwIChwb2ludGVySWQpIHtcbiAgICBkZWxldGUgdGhpcy5wb2ludGVyTWFwW3BvaW50ZXJJZC50b1N0cmluZygpXTtcbiAgfTtcblxuICByZXR1cm4gTXNTb3VyY2U7XG59KEV2ZW50U291cmNlKSk7XG5cbmV4cG9ydCBkZWZhdWx0IE1zU291cmNlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Nc1NvdXJjZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcG9pbnRlci9OYXRpdmVTb3VyY2VcbiAqL1xuXG4vLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vUG9seW1lci9Qb2ludGVyRXZlbnRzXG5cbi8vIENvcHlyaWdodCAoYykgMjAxMyBUaGUgUG9seW1lciBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy9cbi8vIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuLy8gbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuLy8gbWV0OlxuLy9cbi8vICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbi8vIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbi8vICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuLy8gY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lclxuLy8gaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZVxuLy8gZGlzdHJpYnV0aW9uLlxuLy8gKiBOZWl0aGVyIHRoZSBuYW1lIG9mIEdvb2dsZSBJbmMuIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4vLyBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbVxuLy8gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbi8vXG4vLyBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4vLyBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4vLyBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1Jcbi8vIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4vLyBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbi8vIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1Rcbi8vIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuLy8gREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4vLyBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4vLyAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0Vcbi8vIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG5cbmltcG9ydCBFdmVudFNvdXJjZSBmcm9tICcuL0V2ZW50U291cmNlLmpzJztcblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgcG9pbnRlcmRvd25gLlxuICpcbiAqIEB0aGlzIHtOYXRpdmVTb3VyY2V9XG4gKiBAcGFyYW0ge0V2ZW50fSBpbkV2ZW50IFRoZSBpbiBldmVudC5cbiAqL1xuZnVuY3Rpb24gcG9pbnRlckRvd24oaW5FdmVudCkge1xuICB0aGlzLmRpc3BhdGNoZXIuZmlyZU5hdGl2ZUV2ZW50KGluRXZlbnQpO1xufVxuXG4vKipcbiAqIEhhbmRsZXIgZm9yIGBwb2ludGVybW92ZWAuXG4gKlxuICogQHRoaXMge05hdGl2ZVNvdXJjZX1cbiAqIEBwYXJhbSB7RXZlbnR9IGluRXZlbnQgVGhlIGluIGV2ZW50LlxuICovXG5mdW5jdGlvbiBwb2ludGVyTW92ZShpbkV2ZW50KSB7XG4gIHRoaXMuZGlzcGF0Y2hlci5maXJlTmF0aXZlRXZlbnQoaW5FdmVudCk7XG59XG5cbi8qKlxuICogSGFuZGxlciBmb3IgYHBvaW50ZXJ1cGAuXG4gKlxuICogQHRoaXMge05hdGl2ZVNvdXJjZX1cbiAqIEBwYXJhbSB7RXZlbnR9IGluRXZlbnQgVGhlIGluIGV2ZW50LlxuICovXG5mdW5jdGlvbiBwb2ludGVyVXAoaW5FdmVudCkge1xuICB0aGlzLmRpc3BhdGNoZXIuZmlyZU5hdGl2ZUV2ZW50KGluRXZlbnQpO1xufVxuXG4vKipcbiAqIEhhbmRsZXIgZm9yIGBwb2ludGVyb3V0YC5cbiAqXG4gKiBAdGhpcyB7TmF0aXZlU291cmNlfVxuICogQHBhcmFtIHtFdmVudH0gaW5FdmVudCBUaGUgaW4gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIHBvaW50ZXJPdXQoaW5FdmVudCkge1xuICB0aGlzLmRpc3BhdGNoZXIuZmlyZU5hdGl2ZUV2ZW50KGluRXZlbnQpO1xufVxuXG4vKipcbiAqIEhhbmRsZXIgZm9yIGBwb2ludGVyb3ZlcmAuXG4gKlxuICogQHRoaXMge05hdGl2ZVNvdXJjZX1cbiAqIEBwYXJhbSB7RXZlbnR9IGluRXZlbnQgVGhlIGluIGV2ZW50LlxuICovXG5mdW5jdGlvbiBwb2ludGVyT3ZlcihpbkV2ZW50KSB7XG4gIHRoaXMuZGlzcGF0Y2hlci5maXJlTmF0aXZlRXZlbnQoaW5FdmVudCk7XG59XG5cbi8qKlxuICogSGFuZGxlciBmb3IgYHBvaW50ZXJjYW5jZWxgLlxuICpcbiAqIEB0aGlzIHtOYXRpdmVTb3VyY2V9XG4gKiBAcGFyYW0ge0V2ZW50fSBpbkV2ZW50IFRoZSBpbiBldmVudC5cbiAqL1xuZnVuY3Rpb24gcG9pbnRlckNhbmNlbChpbkV2ZW50KSB7XG4gIHRoaXMuZGlzcGF0Y2hlci5maXJlTmF0aXZlRXZlbnQoaW5FdmVudCk7XG59XG5cbi8qKlxuICogSGFuZGxlciBmb3IgYGxvc3Rwb2ludGVyY2FwdHVyZWAuXG4gKlxuICogQHRoaXMge05hdGl2ZVNvdXJjZX1cbiAqIEBwYXJhbSB7RXZlbnR9IGluRXZlbnQgVGhlIGluIGV2ZW50LlxuICovXG5mdW5jdGlvbiBsb3N0UG9pbnRlckNhcHR1cmUoaW5FdmVudCkge1xuICB0aGlzLmRpc3BhdGNoZXIuZmlyZU5hdGl2ZUV2ZW50KGluRXZlbnQpO1xufVxuXG4vKipcbiAqIEhhbmRsZXIgZm9yIGBnb3Rwb2ludGVyY2FwdHVyZWAuXG4gKlxuICogQHRoaXMge05hdGl2ZVNvdXJjZX1cbiAqIEBwYXJhbSB7RXZlbnR9IGluRXZlbnQgVGhlIGluIGV2ZW50LlxuICovXG5mdW5jdGlvbiBnb3RQb2ludGVyQ2FwdHVyZShpbkV2ZW50KSB7XG4gIHRoaXMuZGlzcGF0Y2hlci5maXJlTmF0aXZlRXZlbnQoaW5FdmVudCk7XG59XG5cbnZhciBOYXRpdmVTb3VyY2UgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChFdmVudFNvdXJjZSkge1xuICBmdW5jdGlvbiBOYXRpdmVTb3VyY2UoZGlzcGF0Y2hlcikge1xuICAgIHZhciBtYXBwaW5nID0ge1xuICAgICAgJ3BvaW50ZXJkb3duJzogcG9pbnRlckRvd24sXG4gICAgICAncG9pbnRlcm1vdmUnOiBwb2ludGVyTW92ZSxcbiAgICAgICdwb2ludGVydXAnOiBwb2ludGVyVXAsXG4gICAgICAncG9pbnRlcm91dCc6IHBvaW50ZXJPdXQsXG4gICAgICAncG9pbnRlcm92ZXInOiBwb2ludGVyT3ZlcixcbiAgICAgICdwb2ludGVyY2FuY2VsJzogcG9pbnRlckNhbmNlbCxcbiAgICAgICdnb3Rwb2ludGVyY2FwdHVyZSc6IGdvdFBvaW50ZXJDYXB0dXJlLFxuICAgICAgJ2xvc3Rwb2ludGVyY2FwdHVyZSc6IGxvc3RQb2ludGVyQ2FwdHVyZVxuICAgIH07XG4gICAgRXZlbnRTb3VyY2UuY2FsbCh0aGlzLCBkaXNwYXRjaGVyLCBtYXBwaW5nKTtcbiAgfVxuXG4gIGlmICggRXZlbnRTb3VyY2UgKSBOYXRpdmVTb3VyY2UuX19wcm90b19fID0gRXZlbnRTb3VyY2U7XG4gIE5hdGl2ZVNvdXJjZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFdmVudFNvdXJjZSAmJiBFdmVudFNvdXJjZS5wcm90b3R5cGUgKTtcbiAgTmF0aXZlU291cmNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE5hdGl2ZVNvdXJjZTtcblxuICByZXR1cm4gTmF0aXZlU291cmNlO1xufShFdmVudFNvdXJjZSkpO1xuXG5leHBvcnQgZGVmYXVsdCBOYXRpdmVTb3VyY2U7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU5hdGl2ZVNvdXJjZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcG9pbnRlci9Qb2ludGVyRXZlbnRcbiAqL1xuXG4vLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vUG9seW1lci9Qb2ludGVyRXZlbnRzXG5cbi8vIENvcHlyaWdodCAoYykgMjAxMyBUaGUgUG9seW1lciBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy9cbi8vIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuLy8gbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuLy8gbWV0OlxuLy9cbi8vICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbi8vIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbi8vICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuLy8gY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lclxuLy8gaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZVxuLy8gZGlzdHJpYnV0aW9uLlxuLy8gKiBOZWl0aGVyIHRoZSBuYW1lIG9mIEdvb2dsZSBJbmMuIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4vLyBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbVxuLy8gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbi8vXG4vLyBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4vLyBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4vLyBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1Jcbi8vIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4vLyBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbi8vIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1Rcbi8vIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuLy8gREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4vLyBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4vLyAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0Vcbi8vIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG5cbmltcG9ydCBfRXZlbnQgZnJvbSAnLi4vZXZlbnRzL0V2ZW50LmpzJztcblxuXG4vKipcbiAqIElzIHRoZSBgYnV0dG9uc2AgcHJvcGVydHkgc3VwcG9ydGVkP1xuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbnZhciBIQVNfQlVUVE9OUyA9IGZhbHNlO1xuXG5cbnZhciBQb2ludGVyRXZlbnQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChfRXZlbnQpIHtcbiAgZnVuY3Rpb24gUG9pbnRlckV2ZW50KHR5cGUsIG9yaWdpbmFsRXZlbnQsIG9wdF9ldmVudERpY3QpIHtcbiAgICBfRXZlbnQuY2FsbCh0aGlzLCB0eXBlKTtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdFxuICAgICAqIEB0eXBlIHtFdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLm9yaWdpbmFsRXZlbnQgPSBvcmlnaW5hbEV2ZW50O1xuXG4gICAgdmFyIGV2ZW50RGljdCA9IG9wdF9ldmVudERpY3QgPyBvcHRfZXZlbnREaWN0IDoge307XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuYnV0dG9ucyA9IGdldEJ1dHRvbnMoZXZlbnREaWN0KTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5wcmVzc3VyZSA9IGdldFByZXNzdXJlKGV2ZW50RGljdCwgdGhpcy5idXR0b25zKTtcblxuICAgIC8vIE1vdXNlRXZlbnQgcmVsYXRlZCBwcm9wZXJ0aWVzXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmJ1YmJsZXMgPSAnYnViYmxlcycgaW4gZXZlbnREaWN0ID8gZXZlbnREaWN0WydidWJibGVzJ10gOiBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuY2FuY2VsYWJsZSA9ICdjYW5jZWxhYmxlJyBpbiBldmVudERpY3QgPyBldmVudERpY3RbJ2NhbmNlbGFibGUnXSA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLnZpZXcgPSAndmlldycgaW4gZXZlbnREaWN0ID8gZXZlbnREaWN0Wyd2aWV3J10gOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmRldGFpbCA9ICdkZXRhaWwnIGluIGV2ZW50RGljdCA/IGV2ZW50RGljdFsnZGV0YWlsJ10gOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnNjcmVlblggPSAnc2NyZWVuWCcgaW4gZXZlbnREaWN0ID8gZXZlbnREaWN0WydzY3JlZW5YJ10gOiAwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnNjcmVlblkgPSAnc2NyZWVuWScgaW4gZXZlbnREaWN0ID8gZXZlbnREaWN0WydzY3JlZW5ZJ10gOiAwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmNsaWVudFggPSAnY2xpZW50WCcgaW4gZXZlbnREaWN0ID8gZXZlbnREaWN0WydjbGllbnRYJ10gOiAwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmNsaWVudFkgPSAnY2xpZW50WScgaW4gZXZlbnREaWN0ID8gZXZlbnREaWN0WydjbGllbnRZJ10gOiAwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5jdHJsS2V5ID0gJ2N0cmxLZXknIGluIGV2ZW50RGljdCA/IGV2ZW50RGljdFsnY3RybEtleSddIDogZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmFsdEtleSA9ICdhbHRLZXknIGluIGV2ZW50RGljdCA/IGV2ZW50RGljdFsnYWx0S2V5J10gOiBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuc2hpZnRLZXkgPSAnc2hpZnRLZXknIGluIGV2ZW50RGljdCA/IGV2ZW50RGljdFsnc2hpZnRLZXknXSA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5tZXRhS2V5ID0gJ21ldGFLZXknIGluIGV2ZW50RGljdCA/IGV2ZW50RGljdFsnbWV0YUtleSddIDogZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuYnV0dG9uID0gJ2J1dHRvbicgaW4gZXZlbnREaWN0ID8gZXZlbnREaWN0WydidXR0b24nXSA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Tm9kZX1cbiAgICAgKi9cbiAgICB0aGlzLnJlbGF0ZWRUYXJnZXQgPSAncmVsYXRlZFRhcmdldCcgaW4gZXZlbnREaWN0ID9cbiAgICAgIGV2ZW50RGljdFsncmVsYXRlZFRhcmdldCddIDogbnVsbDtcblxuICAgIC8vIFBvaW50ZXJFdmVudCByZWxhdGVkIHByb3BlcnRpZXNcblxuICAgIC8qKlxuICAgICAqIEBjb25zdFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5wb2ludGVySWQgPSAncG9pbnRlcklkJyBpbiBldmVudERpY3QgPyBldmVudERpY3RbJ3BvaW50ZXJJZCddIDogMDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy53aWR0aCA9ICd3aWR0aCcgaW4gZXZlbnREaWN0ID8gZXZlbnREaWN0Wyd3aWR0aCddIDogMDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5oZWlnaHQgPSAnaGVpZ2h0JyBpbiBldmVudERpY3QgPyBldmVudERpY3RbJ2hlaWdodCddIDogMDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50aWx0WCA9ICd0aWx0WCcgaW4gZXZlbnREaWN0ID8gZXZlbnREaWN0Wyd0aWx0WCddIDogMDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50aWx0WSA9ICd0aWx0WScgaW4gZXZlbnREaWN0ID8gZXZlbnREaWN0Wyd0aWx0WSddIDogMDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5wb2ludGVyVHlwZSA9ICdwb2ludGVyVHlwZScgaW4gZXZlbnREaWN0ID8gZXZlbnREaWN0Wydwb2ludGVyVHlwZSddIDogJyc7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaHdUaW1lc3RhbXAgPSAnaHdUaW1lc3RhbXAnIGluIGV2ZW50RGljdCA/IGV2ZW50RGljdFsnaHdUaW1lc3RhbXAnXSA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmlzUHJpbWFyeSA9ICdpc1ByaW1hcnknIGluIGV2ZW50RGljdCA/IGV2ZW50RGljdFsnaXNQcmltYXJ5J10gOiBmYWxzZTtcblxuICAgIC8vIGtlZXAgdGhlIHNlbWFudGljcyBvZiBwcmV2ZW50RGVmYXVsdFxuICAgIGlmIChvcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0KSB7XG4gICAgICB0aGlzLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIG9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgaWYgKCBfRXZlbnQgKSBQb2ludGVyRXZlbnQuX19wcm90b19fID0gX0V2ZW50O1xuICBQb2ludGVyRXZlbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggX0V2ZW50ICYmIF9FdmVudC5wcm90b3R5cGUgKTtcbiAgUG9pbnRlckV2ZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBvaW50ZXJFdmVudDtcblxuICByZXR1cm4gUG9pbnRlckV2ZW50O1xufShfRXZlbnQpKTtcblxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgPz59IGV2ZW50RGljdCBUaGUgZXZlbnQgZGljdGlvbmFyeS5cbiAqIEByZXR1cm4ge251bWJlcn0gQnV0dG9uIGluZGljYXRvci5cbiAqL1xuZnVuY3Rpb24gZ2V0QnV0dG9ucyhldmVudERpY3QpIHtcbiAgLy8gQWNjb3JkaW5nIHRvIHRoZSB3M2Mgc3BlYyxcbiAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtTW91c2VFdmVudC1idXR0b25cbiAgLy8gTW91c2VFdmVudC5idXR0b24gPT0gMCBjYW4gbWVhbiBlaXRoZXIgbm8gbW91c2UgYnV0dG9uIGRlcHJlc3NlZCwgb3IgdGhlXG4gIC8vIGxlZnQgbW91c2UgYnV0dG9uIGRlcHJlc3NlZC5cbiAgLy9cbiAgLy8gQXMgb2Ygbm93LCB0aGUgb25seSB3YXkgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiB0aGUgdHdvIHN0YXRlcyBvZlxuICAvLyBNb3VzZUV2ZW50LmJ1dHRvbiBpcyBieSB1c2luZyB0aGUgZGVwcmVjYXRlZCBNb3VzZUV2ZW50LndoaWNoIHByb3BlcnR5LCBhc1xuICAvLyB0aGlzIG1hcHMgbW91c2UgYnV0dG9ucyB0byBwb3NpdGl2ZSBpbnRlZ2VycyA+IDAsIGFuZCB1c2VzIDAgdG8gbWVhbiB0aGF0XG4gIC8vIG5vIG1vdXNlIGJ1dHRvbiBpcyBoZWxkLlxuICAvL1xuICAvLyBNb3VzZUV2ZW50LndoaWNoIGlzIGRlcml2ZWQgZnJvbSBNb3VzZUV2ZW50LmJ1dHRvbiBhdCBNb3VzZUV2ZW50IGNyZWF0aW9uLFxuICAvLyBidXQgaW5pdE1vdXNlRXZlbnQgZG9lcyBub3QgZXhwb3NlIGFuIGFyZ3VtZW50IHdpdGggd2hpY2ggdG8gc2V0XG4gIC8vIE1vdXNlRXZlbnQud2hpY2guIENhbGxpbmcgaW5pdE1vdXNlRXZlbnQgd2l0aCBhIGJ1dHRvbkFyZyBvZiAwIHdpbGwgc2V0XG4gIC8vIE1vdXNlRXZlbnQuYnV0dG9uID09IDAgYW5kIE1vdXNlRXZlbnQud2hpY2ggPT0gMSwgYnJlYWtpbmcgdGhlIGV4cGVjdGF0aW9uc1xuICAvLyBvZiBhcHAgZGV2ZWxvcGVycy5cbiAgLy9cbiAgLy8gVGhlIG9ubHkgd2F5IHRvIHByb3BhZ2F0ZSB0aGUgY29ycmVjdCBzdGF0ZSBvZiBNb3VzZUV2ZW50LndoaWNoIGFuZFxuICAvLyBNb3VzZUV2ZW50LmJ1dHRvbiB0byBhIG5ldyBNb3VzZUV2ZW50LmJ1dHRvbiA9PSAwIGFuZCBNb3VzZUV2ZW50LndoaWNoID09IDBcbiAgLy8gaXMgdG8gY2FsbCBpbml0TW91c2VFdmVudCB3aXRoIGEgYnV0dG9uQXJnIHZhbHVlIG9mIC0xLlxuICAvL1xuICAvLyBUaGlzIGlzIGZpeGVkIHdpdGggRE9NIExldmVsIDQncyB1c2Ugb2YgYnV0dG9uc1xuICB2YXIgYnV0dG9ucztcbiAgaWYgKGV2ZW50RGljdC5idXR0b25zIHx8IEhBU19CVVRUT05TKSB7XG4gICAgYnV0dG9ucyA9IGV2ZW50RGljdC5idXR0b25zO1xuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAoZXZlbnREaWN0LndoaWNoKSB7XG4gICAgICBjYXNlIDE6IGJ1dHRvbnMgPSAxOyBicmVhaztcbiAgICAgIGNhc2UgMjogYnV0dG9ucyA9IDQ7IGJyZWFrO1xuICAgICAgY2FzZSAzOiBidXR0b25zID0gMjsgYnJlYWs7XG4gICAgICBkZWZhdWx0OiBidXR0b25zID0gMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ1dHRvbnM7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsID8+fSBldmVudERpY3QgVGhlIGV2ZW50IGRpY3Rpb25hcnkuXG4gKiBAcGFyYW0ge251bWJlcn0gYnV0dG9ucyBCdXR0b24gaW5kaWNhdG9yLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgcHJlc3N1cmUuXG4gKi9cbmZ1bmN0aW9uIGdldFByZXNzdXJlKGV2ZW50RGljdCwgYnV0dG9ucykge1xuICAvLyBTcGVjIHJlcXVpcmVzIHRoYXQgcG9pbnRlcnMgd2l0aG91dCBwcmVzc3VyZSBzcGVjaWZpZWQgdXNlIDAuNSBmb3IgZG93blxuICAvLyBzdGF0ZSBhbmQgMCBmb3IgdXAgc3RhdGUuXG4gIHZhciBwcmVzc3VyZSA9IDA7XG4gIGlmIChldmVudERpY3QucHJlc3N1cmUpIHtcbiAgICBwcmVzc3VyZSA9IGV2ZW50RGljdC5wcmVzc3VyZTtcbiAgfSBlbHNlIHtcbiAgICBwcmVzc3VyZSA9IGJ1dHRvbnMgPyAwLjUgOiAwO1xuICB9XG4gIHJldHVybiBwcmVzc3VyZTtcbn1cblxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgYGJ1dHRvbnNgIHByb3BlcnR5IGlzIHN1cHBvcnRlZC5cbiAqL1xuKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBldiA9IG5ldyBNb3VzZUV2ZW50KCdjbGljaycsIHtidXR0b25zOiAxfSk7XG4gICAgSEFTX0JVVFRPTlMgPSBldi5idXR0b25zID09PSAxO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gcGFzc1xuICB9XG59KSgpO1xuXG5leHBvcnQgZGVmYXVsdCBQb2ludGVyRXZlbnQ7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBvaW50ZXJFdmVudC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcG9pbnRlci9Qb2ludGVyRXZlbnRIYW5kbGVyXG4gKi9cblxuLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL1BvbHltZXIvUG9pbnRlckV2ZW50c1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgVGhlIFBvbHltZXIgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vXG4vLyBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbi8vIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbi8vIG1ldDpcbi8vXG4vLyAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4vLyBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4vLyAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbi8vIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXJcbi8vIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGVcbi8vIGRpc3RyaWJ1dGlvbi5cbi8vICogTmVpdGhlciB0aGUgbmFtZSBvZiBHb29nbGUgSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuLy8gY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbi8vIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4vL1xuLy8gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuLy8gXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuLy8gTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4vLyBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuLy8gT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4vLyBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4vLyBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbi8vIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuLy8gVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuLy8gKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4vLyBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuXG5pbXBvcnQge2xpc3RlbiwgdW5saXN0ZW59IGZyb20gJy4uL2V2ZW50cy5qcyc7XG5pbXBvcnQgRXZlbnRUYXJnZXQgZnJvbSAnLi4vZXZlbnRzL1RhcmdldC5qcyc7XG5pbXBvcnQge1BPSU5URVIsIE1TUE9JTlRFUiwgVE9VQ0h9IGZyb20gJy4uL2hhcy5qcyc7XG5pbXBvcnQgUG9pbnRlckV2ZW50VHlwZSBmcm9tICcuL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgTW91c2VTb3VyY2UsIHtwcmVwYXJlRXZlbnQgYXMgcHJlcGFyZU1vdXNlRXZlbnR9IGZyb20gJy4vTW91c2VTb3VyY2UuanMnO1xuaW1wb3J0IE1zU291cmNlIGZyb20gJy4vTXNTb3VyY2UuanMnO1xuaW1wb3J0IE5hdGl2ZVNvdXJjZSBmcm9tICcuL05hdGl2ZVNvdXJjZS5qcyc7XG5pbXBvcnQgUG9pbnRlckV2ZW50IGZyb20gJy4vUG9pbnRlckV2ZW50LmpzJztcbmltcG9ydCBUb3VjaFNvdXJjZSBmcm9tICcuL1RvdWNoU291cmNlLmpzJztcblxuXG4vKipcbiAqIFByb3BlcnRpZXMgdG8gY29weSB3aGVuIGNsb25pbmcgYW4gZXZlbnQsIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gKiBAdHlwZSB7QXJyYXk8QXJyYXk+fVxuICovXG52YXIgQ0xPTkVfUFJPUFMgPSBbXG4gIC8vIE1vdXNlRXZlbnRcbiAgWydidWJibGVzJywgZmFsc2VdLFxuICBbJ2NhbmNlbGFibGUnLCBmYWxzZV0sXG4gIFsndmlldycsIG51bGxdLFxuICBbJ2RldGFpbCcsIG51bGxdLFxuICBbJ3NjcmVlblgnLCAwXSxcbiAgWydzY3JlZW5ZJywgMF0sXG4gIFsnY2xpZW50WCcsIDBdLFxuICBbJ2NsaWVudFknLCAwXSxcbiAgWydjdHJsS2V5JywgZmFsc2VdLFxuICBbJ2FsdEtleScsIGZhbHNlXSxcbiAgWydzaGlmdEtleScsIGZhbHNlXSxcbiAgWydtZXRhS2V5JywgZmFsc2VdLFxuICBbJ2J1dHRvbicsIDBdLFxuICBbJ3JlbGF0ZWRUYXJnZXQnLCBudWxsXSxcbiAgLy8gRE9NIExldmVsIDNcbiAgWydidXR0b25zJywgMF0sXG4gIC8vIFBvaW50ZXJFdmVudFxuICBbJ3BvaW50ZXJJZCcsIDBdLFxuICBbJ3dpZHRoJywgMF0sXG4gIFsnaGVpZ2h0JywgMF0sXG4gIFsncHJlc3N1cmUnLCAwXSxcbiAgWyd0aWx0WCcsIDBdLFxuICBbJ3RpbHRZJywgMF0sXG4gIFsncG9pbnRlclR5cGUnLCAnJ10sXG4gIFsnaHdUaW1lc3RhbXAnLCAwXSxcbiAgWydpc1ByaW1hcnknLCBmYWxzZV0sXG4gIC8vIGV2ZW50IGluc3RhbmNlXG4gIFsndHlwZScsICcnXSxcbiAgWyd0YXJnZXQnLCBudWxsXSxcbiAgWydjdXJyZW50VGFyZ2V0JywgbnVsbF0sXG4gIFsnd2hpY2gnLCAwXVxuXTtcblxuXG52YXIgUG9pbnRlckV2ZW50SGFuZGxlciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEV2ZW50VGFyZ2V0KSB7XG4gIGZ1bmN0aW9uIFBvaW50ZXJFdmVudEhhbmRsZXIoZWxlbWVudCkge1xuICAgIEV2ZW50VGFyZ2V0LmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtFbGVtZW50fEhUTUxEb2N1bWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmVsZW1lbnRfID0gZWxlbWVudDtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdFxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgRXZlbnR8T2JqZWN0Pn1cbiAgICAgKi9cbiAgICB0aGlzLnBvaW50ZXJNYXAgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBmdW5jdGlvbihFdmVudCk+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5ldmVudE1hcF8gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuL0V2ZW50U291cmNlLmpzXCIpLmRlZmF1bHQ+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5ldmVudFNvdXJjZUxpc3RfID0gW107XG5cbiAgICB0aGlzLnJlZ2lzdGVyU291cmNlcygpO1xuICB9XG5cbiAgaWYgKCBFdmVudFRhcmdldCApIFBvaW50ZXJFdmVudEhhbmRsZXIuX19wcm90b19fID0gRXZlbnRUYXJnZXQ7XG4gIFBvaW50ZXJFdmVudEhhbmRsZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXZlbnRUYXJnZXQgJiYgRXZlbnRUYXJnZXQucHJvdG90eXBlICk7XG4gIFBvaW50ZXJFdmVudEhhbmRsZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUG9pbnRlckV2ZW50SGFuZGxlcjtcblxuICAvKipcbiAgICogU2V0IHVwIHRoZSBldmVudCBzb3VyY2VzIChtb3VzZSwgdG91Y2ggYW5kIG5hdGl2ZSBwb2ludGVycylcbiAgICogdGhhdCBnZW5lcmF0ZSBwb2ludGVyIGV2ZW50cy5cbiAgICovXG4gIFBvaW50ZXJFdmVudEhhbmRsZXIucHJvdG90eXBlLnJlZ2lzdGVyU291cmNlcyA9IGZ1bmN0aW9uIHJlZ2lzdGVyU291cmNlcyAoKSB7XG4gICAgaWYgKFBPSU5URVIpIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJTb3VyY2UoJ25hdGl2ZScsIG5ldyBOYXRpdmVTb3VyY2UodGhpcykpO1xuICAgIH0gZWxzZSBpZiAoTVNQT0lOVEVSKSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyU291cmNlKCdtcycsIG5ldyBNc1NvdXJjZSh0aGlzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtb3VzZVNvdXJjZSA9IG5ldyBNb3VzZVNvdXJjZSh0aGlzKTtcbiAgICAgIHRoaXMucmVnaXN0ZXJTb3VyY2UoJ21vdXNlJywgbW91c2VTb3VyY2UpO1xuXG4gICAgICBpZiAoVE9VQ0gpIHtcbiAgICAgICAgdGhpcy5yZWdpc3RlclNvdXJjZSgndG91Y2gnLCBuZXcgVG91Y2hTb3VyY2UodGhpcywgbW91c2VTb3VyY2UpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZWdpc3RlciBldmVudHMgb24gdGhlIHZpZXdwb3J0IGVsZW1lbnRcbiAgICB0aGlzLnJlZ2lzdGVyXygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSBuZXcgZXZlbnQgc291cmNlIHRoYXQgd2lsbCBnZW5lcmF0ZSBwb2ludGVyIGV2ZW50cy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQSBuYW1lIGZvciB0aGUgZXZlbnQgc291cmNlXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9FdmVudFNvdXJjZS5qc1wiKS5kZWZhdWx0fSBzb3VyY2UgVGhlIHNvdXJjZSBldmVudC5cbiAgICovXG4gIFBvaW50ZXJFdmVudEhhbmRsZXIucHJvdG90eXBlLnJlZ2lzdGVyU291cmNlID0gZnVuY3Rpb24gcmVnaXN0ZXJTb3VyY2UgKG5hbWUsIHNvdXJjZSkge1xuICAgIHZhciBzID0gc291cmNlO1xuICAgIHZhciBuZXdFdmVudHMgPSBzLmdldEV2ZW50cygpO1xuXG4gICAgaWYgKG5ld0V2ZW50cykge1xuICAgICAgbmV3RXZlbnRzLmZvckVhY2goZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgaGFuZGxlciA9IHMuZ2V0SGFuZGxlckZvckV2ZW50KGUpO1xuXG4gICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgdGhpcy5ldmVudE1hcF9bZV0gPSBoYW5kbGVyLmJpbmQocyk7XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmV2ZW50U291cmNlTGlzdF8ucHVzaChzKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB1cCB0aGUgZXZlbnRzIGZvciBhbGwgcmVnaXN0ZXJlZCBldmVudCBzb3VyY2VzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgUG9pbnRlckV2ZW50SGFuZGxlci5wcm90b3R5cGUucmVnaXN0ZXJfID0gZnVuY3Rpb24gcmVnaXN0ZXJfICgpIHtcbiAgICB2YXIgbCA9IHRoaXMuZXZlbnRTb3VyY2VMaXN0Xy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBldmVudFNvdXJjZSA9IHRoaXMuZXZlbnRTb3VyY2VMaXN0X1tpXTtcbiAgICAgIHRoaXMuYWRkRXZlbnRzXyhldmVudFNvdXJjZS5nZXRFdmVudHMoKSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYWxsIHJlZ2lzdGVyZWQgZXZlbnRzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgUG9pbnRlckV2ZW50SGFuZGxlci5wcm90b3R5cGUudW5yZWdpc3Rlcl8gPSBmdW5jdGlvbiB1bnJlZ2lzdGVyXyAoKSB7XG4gICAgdmFyIGwgPSB0aGlzLmV2ZW50U291cmNlTGlzdF8ubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgZXZlbnRTb3VyY2UgPSB0aGlzLmV2ZW50U291cmNlTGlzdF9baV07XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50c18oZXZlbnRTb3VyY2UuZ2V0RXZlbnRzKCkpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2FsbHMgdGhlIHJpZ2h0IGhhbmRsZXIgZm9yIGEgbmV3IGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBpbkV2ZW50IEJyb3dzZXIgZXZlbnQuXG4gICAqL1xuICBQb2ludGVyRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5ldmVudEhhbmRsZXJfID0gZnVuY3Rpb24gZXZlbnRIYW5kbGVyXyAoaW5FdmVudCkge1xuICAgIHZhciB0eXBlID0gaW5FdmVudC50eXBlO1xuICAgIHZhciBoYW5kbGVyID0gdGhpcy5ldmVudE1hcF9bdHlwZV07XG4gICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgIGhhbmRsZXIoaW5FdmVudCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXR1cCBsaXN0ZW5lcnMgZm9yIHRoZSBnaXZlbiBldmVudHMuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gZXZlbnRzIExpc3Qgb2YgZXZlbnRzLlxuICAgKi9cbiAgUG9pbnRlckV2ZW50SGFuZGxlci5wcm90b3R5cGUuYWRkRXZlbnRzXyA9IGZ1bmN0aW9uIGFkZEV2ZW50c18gKGV2ZW50cykge1xuICAgIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuICAgICAgbGlzdGVuKHRoaXMuZWxlbWVudF8sIGV2ZW50TmFtZSwgdGhpcy5ldmVudEhhbmRsZXJfLCB0aGlzKTtcbiAgICB9LmJpbmQodGhpcykpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVbnJlZ2lzdGVyIGxpc3RlbmVycyBmb3IgdGhlIGdpdmVuIGV2ZW50cy5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBldmVudHMgTGlzdCBvZiBldmVudHMuXG4gICAqL1xuICBQb2ludGVyRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudHNfID0gZnVuY3Rpb24gcmVtb3ZlRXZlbnRzXyAoZXZlbnRzKSB7XG4gICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24oZSkge1xuICAgICAgdW5saXN0ZW4odGhpcy5lbGVtZW50XywgZSwgdGhpcy5ldmVudEhhbmRsZXJfLCB0aGlzKTtcbiAgICB9LmJpbmQodGhpcykpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc25hcHNob3Qgb2YgaW5FdmVudCwgd2l0aCB3cml0YWJsZSBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBCcm93c2VyIGV2ZW50LlxuICAgKiBAcGFyYW0ge0V2ZW50fFRvdWNofSBpbkV2ZW50IEFuIGV2ZW50IHRoYXQgY29udGFpbnNcbiAgICogICAgcHJvcGVydGllcyB0byBjb3B5LlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIHNoYWxsb3cgY29waWVzIG9mXG4gICAqICAgIGBpbkV2ZW50YCdzIHByb3BlcnRpZXMuXG4gICAqL1xuICBQb2ludGVyRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5jbG9uZUV2ZW50ID0gZnVuY3Rpb24gY2xvbmVFdmVudCAoZXZlbnQsIGluRXZlbnQpIHtcbiAgICB2YXIgZXZlbnRDb3B5ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gQ0xPTkVfUFJPUFMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgdmFyIHAgPSBDTE9ORV9QUk9QU1tpXVswXTtcbiAgICAgIGV2ZW50Q29weVtwXSA9IGV2ZW50W3BdIHx8IGluRXZlbnRbcF0gfHwgQ0xPTkVfUFJPUFNbaV1bMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGV2ZW50Q29weTtcbiAgfTtcblxuICAvLyBFVkVOVFNcblxuXG4gIC8qKlxuICAgKiBUcmlnZ2VycyBhICdwb2ludGVyZG93bicgZXZlbnQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFBvaW50ZXIgZXZlbnQgZGF0YS5cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50LlxuICAgKi9cbiAgUG9pbnRlckV2ZW50SGFuZGxlci5wcm90b3R5cGUuZG93biA9IGZ1bmN0aW9uIGRvd24gKGRhdGEsIGV2ZW50KSB7XG4gICAgdGhpcy5maXJlRXZlbnQoUG9pbnRlckV2ZW50VHlwZS5QT0lOVEVSRE9XTiwgZGF0YSwgZXZlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUcmlnZ2VycyBhICdwb2ludGVybW92ZScgZXZlbnQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFBvaW50ZXIgZXZlbnQgZGF0YS5cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50LlxuICAgKi9cbiAgUG9pbnRlckV2ZW50SGFuZGxlci5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uIG1vdmUgKGRhdGEsIGV2ZW50KSB7XG4gICAgdGhpcy5maXJlRXZlbnQoUG9pbnRlckV2ZW50VHlwZS5QT0lOVEVSTU9WRSwgZGF0YSwgZXZlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUcmlnZ2VycyBhICdwb2ludGVydXAnIGV2ZW50LlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBQb2ludGVyIGV2ZW50IGRhdGEuXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudC5cbiAgICovXG4gIFBvaW50ZXJFdmVudEhhbmRsZXIucHJvdG90eXBlLnVwID0gZnVuY3Rpb24gdXAgKGRhdGEsIGV2ZW50KSB7XG4gICAgdGhpcy5maXJlRXZlbnQoUG9pbnRlckV2ZW50VHlwZS5QT0lOVEVSVVAsIGRhdGEsIGV2ZW50KTtcbiAgfTtcblxuICAvKipcbiAgICogVHJpZ2dlcnMgYSAncG9pbnRlcmVudGVyJyBldmVudC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgUG9pbnRlciBldmVudCBkYXRhLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQuXG4gICAqL1xuICBQb2ludGVyRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5lbnRlciA9IGZ1bmN0aW9uIGVudGVyIChkYXRhLCBldmVudCkge1xuICAgIGRhdGEuYnViYmxlcyA9IGZhbHNlO1xuICAgIHRoaXMuZmlyZUV2ZW50KFBvaW50ZXJFdmVudFR5cGUuUE9JTlRFUkVOVEVSLCBkYXRhLCBldmVudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRyaWdnZXJzIGEgJ3BvaW50ZXJsZWF2ZScgZXZlbnQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFBvaW50ZXIgZXZlbnQgZGF0YS5cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50LlxuICAgKi9cbiAgUG9pbnRlckV2ZW50SGFuZGxlci5wcm90b3R5cGUubGVhdmUgPSBmdW5jdGlvbiBsZWF2ZSAoZGF0YSwgZXZlbnQpIHtcbiAgICBkYXRhLmJ1YmJsZXMgPSBmYWxzZTtcbiAgICB0aGlzLmZpcmVFdmVudChQb2ludGVyRXZlbnRUeXBlLlBPSU5URVJMRUFWRSwgZGF0YSwgZXZlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUcmlnZ2VycyBhICdwb2ludGVyb3ZlcicgZXZlbnQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFBvaW50ZXIgZXZlbnQgZGF0YS5cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50LlxuICAgKi9cbiAgUG9pbnRlckV2ZW50SGFuZGxlci5wcm90b3R5cGUub3ZlciA9IGZ1bmN0aW9uIG92ZXIgKGRhdGEsIGV2ZW50KSB7XG4gICAgZGF0YS5idWJibGVzID0gdHJ1ZTtcbiAgICB0aGlzLmZpcmVFdmVudChQb2ludGVyRXZlbnRUeXBlLlBPSU5URVJPVkVSLCBkYXRhLCBldmVudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRyaWdnZXJzIGEgJ3BvaW50ZXJvdXQnIGV2ZW50LlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBQb2ludGVyIGV2ZW50IGRhdGEuXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudC5cbiAgICovXG4gIFBvaW50ZXJFdmVudEhhbmRsZXIucHJvdG90eXBlLm91dCA9IGZ1bmN0aW9uIG91dCAoZGF0YSwgZXZlbnQpIHtcbiAgICBkYXRhLmJ1YmJsZXMgPSB0cnVlO1xuICAgIHRoaXMuZmlyZUV2ZW50KFBvaW50ZXJFdmVudFR5cGUuUE9JTlRFUk9VVCwgZGF0YSwgZXZlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUcmlnZ2VycyBhICdwb2ludGVyY2FuY2VsJyBldmVudC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgUG9pbnRlciBldmVudCBkYXRhLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQuXG4gICAqL1xuICBQb2ludGVyRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiBjYW5jZWwgKGRhdGEsIGV2ZW50KSB7XG4gICAgdGhpcy5maXJlRXZlbnQoUG9pbnRlckV2ZW50VHlwZS5QT0lOVEVSQ0FOQ0VMLCBkYXRhLCBldmVudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRyaWdnZXJzIGEgY29tYmluYXRpb24gb2YgJ3BvaW50ZXJvdXQnIGFuZCAncG9pbnRlcmxlYXZlJyBldmVudHMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFBvaW50ZXIgZXZlbnQgZGF0YS5cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50LlxuICAgKi9cbiAgUG9pbnRlckV2ZW50SGFuZGxlci5wcm90b3R5cGUubGVhdmVPdXQgPSBmdW5jdGlvbiBsZWF2ZU91dCAoZGF0YSwgZXZlbnQpIHtcbiAgICB0aGlzLm91dChkYXRhLCBldmVudCk7XG4gICAgaWYgKCF0aGlzLmNvbnRhaW5zXyhkYXRhLnRhcmdldCwgZGF0YS5yZWxhdGVkVGFyZ2V0KSkge1xuICAgICAgdGhpcy5sZWF2ZShkYXRhLCBldmVudCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUcmlnZ2VycyBhIGNvbWJpbmF0aW9uIG9mICdwb2ludGVyb3ZlcicgYW5kICdwb2ludGVyZXZlbnRzJyBldmVudHMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFBvaW50ZXIgZXZlbnQgZGF0YS5cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50LlxuICAgKi9cbiAgUG9pbnRlckV2ZW50SGFuZGxlci5wcm90b3R5cGUuZW50ZXJPdmVyID0gZnVuY3Rpb24gZW50ZXJPdmVyIChkYXRhLCBldmVudCkge1xuICAgIHRoaXMub3ZlcihkYXRhLCBldmVudCk7XG4gICAgaWYgKCF0aGlzLmNvbnRhaW5zXyhkYXRhLnRhcmdldCwgZGF0YS5yZWxhdGVkVGFyZ2V0KSkge1xuICAgICAgdGhpcy5lbnRlcihkYXRhLCBldmVudCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRhaW5lciBUaGUgY29udGFpbmVyIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gY29udGFpbmVkIFRoZSBjb250YWluZWQgZWxlbWVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBjb250YWluZXIgZWxlbWVudFxuICAgKiAgIGNvbnRhaW5zIHRoZSBvdGhlciBlbGVtZW50LlxuICAgKi9cbiAgUG9pbnRlckV2ZW50SGFuZGxlci5wcm90b3R5cGUuY29udGFpbnNfID0gZnVuY3Rpb24gY29udGFpbnNfIChjb250YWluZXIsIGNvbnRhaW5lZCkge1xuICAgIGlmICghY29udGFpbmVyIHx8ICFjb250YWluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRhaW5lci5jb250YWlucyhjb250YWluZWQpO1xuICB9O1xuXG4gIC8vIEVWRU5UIENSRUFUSU9OIEFORCBUUkFDS0lOR1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBFdmVudCBvZiB0eXBlIGBpblR5cGVgLCBiYXNlZCBvbiB0aGUgaW5mb3JtYXRpb24gaW5cbiAgICogYGRhdGFgLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5UeXBlIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdHlwZSBvZiBldmVudCB0byBjcmVhdGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFBvaW50ZXIgZXZlbnQgZGF0YS5cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50LlxuICAgKiBAcmV0dXJuIHtQb2ludGVyRXZlbnR9IEEgUG9pbnRlckV2ZW50IG9mIHR5cGUgYGluVHlwZWAuXG4gICAqL1xuICBQb2ludGVyRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5tYWtlRXZlbnQgPSBmdW5jdGlvbiBtYWtlRXZlbnQgKGluVHlwZSwgZGF0YSwgZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IFBvaW50ZXJFdmVudChpblR5cGUsIGV2ZW50LCBkYXRhKTtcbiAgfTtcblxuICAvKipcbiAgICogTWFrZSBhbmQgZGlzcGF0Y2ggYW4gZXZlbnQgaW4gb25lIGNhbGwuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpblR5cGUgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB0eXBlIG9mIGV2ZW50LlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBQb2ludGVyIGV2ZW50IGRhdGEuXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudC5cbiAgICovXG4gIFBvaW50ZXJFdmVudEhhbmRsZXIucHJvdG90eXBlLmZpcmVFdmVudCA9IGZ1bmN0aW9uIGZpcmVFdmVudCAoaW5UeXBlLCBkYXRhLCBldmVudCkge1xuICAgIHZhciBlID0gdGhpcy5tYWtlRXZlbnQoaW5UeXBlLCBkYXRhLCBldmVudCk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcG9pbnRlciBldmVudCBmcm9tIGEgbmF0aXZlIHBvaW50ZXIgZXZlbnRcbiAgICogYW5kIGRpc3BhdGNoZXMgdGhpcyBldmVudC5cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgQSBwbGF0Zm9ybSBldmVudCB3aXRoIGEgdGFyZ2V0LlxuICAgKi9cbiAgUG9pbnRlckV2ZW50SGFuZGxlci5wcm90b3R5cGUuZmlyZU5hdGl2ZUV2ZW50ID0gZnVuY3Rpb24gZmlyZU5hdGl2ZUV2ZW50IChldmVudCkge1xuICAgIHZhciBlID0gdGhpcy5tYWtlRXZlbnQoZXZlbnQudHlwZSwgZXZlbnQsIGV2ZW50KTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdyYXAgYSBuYXRpdmUgbW91c2UgZXZlbnQgaW50byBhIHBvaW50ZXIgZXZlbnQuXG4gICAqIFRoaXMgcHJveHkgbWV0aG9kIGlzIHJlcXVpcmVkIGZvciB0aGUgbGVnYWN5IElFIHN1cHBvcnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgVGhlIHBvaW50ZXIgZXZlbnQgdHlwZS5cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50LlxuICAgKiBAcmV0dXJuIHtQb2ludGVyRXZlbnR9IFRoZSB3cmFwcGVkIGV2ZW50LlxuICAgKi9cbiAgUG9pbnRlckV2ZW50SGFuZGxlci5wcm90b3R5cGUud3JhcE1vdXNlRXZlbnQgPSBmdW5jdGlvbiB3cmFwTW91c2VFdmVudCAoZXZlbnRUeXBlLCBldmVudCkge1xuICAgIHZhciBwb2ludGVyRXZlbnQgPSB0aGlzLm1ha2VFdmVudChcbiAgICAgIGV2ZW50VHlwZSwgcHJlcGFyZU1vdXNlRXZlbnQoZXZlbnQsIHRoaXMpLCBldmVudCk7XG4gICAgcmV0dXJuIHBvaW50ZXJFdmVudDtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIFBvaW50ZXJFdmVudEhhbmRsZXIucHJvdG90eXBlLmRpc3Bvc2VJbnRlcm5hbCA9IGZ1bmN0aW9uIGRpc3Bvc2VJbnRlcm5hbCAoKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyXygpO1xuICAgIEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5kaXNwb3NlSW50ZXJuYWwuY2FsbCh0aGlzKTtcbiAgfTtcblxuICByZXR1cm4gUG9pbnRlckV2ZW50SGFuZGxlcjtcbn0oRXZlbnRUYXJnZXQpKTtcblxuZXhwb3J0IGRlZmF1bHQgUG9pbnRlckV2ZW50SGFuZGxlcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UG9pbnRlckV2ZW50SGFuZGxlci5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcG9pbnRlci9Ub3VjaFNvdXJjZVxuICovXG5cbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9Qb2x5bWVyL1BvaW50ZXJFdmVudHNcblxuLy8gQ29weXJpZ2h0IChjKSAyMDEzIFRoZSBQb2x5bWVyIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4vLyBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4vLyBtZXQ6XG4vL1xuLy8gKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuLy8gbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuLy8gKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4vLyBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyXG4vLyBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlXG4vLyBkaXN0cmlidXRpb24uXG4vLyAqIE5laXRoZXIgdGhlIG5hbWUgb2YgR29vZ2xlIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbi8vIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4vLyB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuLy9cbi8vIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbi8vIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1Rcbi8vIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuLy8gQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbi8vIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuLy8gU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuLy8gTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4vLyBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbi8vIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbi8vIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuLy8gT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cblxuaW1wb3J0IHtyZW1vdmV9IGZyb20gJy4uL2FycmF5LmpzJztcbmltcG9ydCBFdmVudFNvdXJjZSBmcm9tICcuL0V2ZW50U291cmNlLmpzJztcbmltcG9ydCB7UE9JTlRFUl9JRH0gZnJvbSAnLi9Nb3VzZVNvdXJjZS5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG52YXIgQ0xJQ0tfQ09VTlRfVElNRU9VVCA9IDIwMDtcblxuLyoqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG52YXIgUE9JTlRFUl9UWVBFID0gJ3RvdWNoJztcblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgdG91Y2hzdGFydGAsIHRyaWdnZXJzIGBwb2ludGVyb3ZlcmAsXG4gKiBgcG9pbnRlcmVudGVyYCBhbmQgYHBvaW50ZXJkb3duYCBldmVudHMuXG4gKlxuICogQHRoaXMge1RvdWNoU291cmNlfVxuICogQHBhcmFtIHtUb3VjaEV2ZW50fSBpbkV2ZW50IFRoZSBpbiBldmVudC5cbiAqL1xuZnVuY3Rpb24gdG91Y2hzdGFydChpbkV2ZW50KSB7XG4gIHRoaXMudmFjdXVtVG91Y2hlc18oaW5FdmVudCk7XG4gIHRoaXMuc2V0UHJpbWFyeVRvdWNoXyhpbkV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdKTtcbiAgdGhpcy5kZWR1cFN5bnRoTW91c2VfKGluRXZlbnQpO1xuICB0aGlzLmNsaWNrQ291bnRfKys7XG4gIHRoaXMucHJvY2Vzc1RvdWNoZXNfKGluRXZlbnQsIHRoaXMub3ZlckRvd25fKTtcbn1cblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgdG91Y2htb3ZlYC5cbiAqXG4gKiBAdGhpcyB7VG91Y2hTb3VyY2V9XG4gKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGluRXZlbnQgVGhlIGluIGV2ZW50LlxuICovXG5mdW5jdGlvbiB0b3VjaG1vdmUoaW5FdmVudCkge1xuICB0aGlzLnByb2Nlc3NUb3VjaGVzXyhpbkV2ZW50LCB0aGlzLm1vdmVPdmVyT3V0Xyk7XG59XG5cbi8qKlxuICogSGFuZGxlciBmb3IgYHRvdWNoZW5kYCwgdHJpZ2dlcnMgYHBvaW50ZXJ1cGAsXG4gKiBgcG9pbnRlcm91dGAgYW5kIGBwb2ludGVybGVhdmVgIGV2ZW50cy5cbiAqXG4gKiBAdGhpcyB7VG91Y2hTb3VyY2V9XG4gKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGluRXZlbnQgVGhlIGV2ZW50LlxuICovXG5mdW5jdGlvbiB0b3VjaGVuZChpbkV2ZW50KSB7XG4gIHRoaXMuZGVkdXBTeW50aE1vdXNlXyhpbkV2ZW50KTtcbiAgdGhpcy5wcm9jZXNzVG91Y2hlc18oaW5FdmVudCwgdGhpcy51cE91dF8pO1xufVxuXG4vKipcbiAqIEhhbmRsZXIgZm9yIGB0b3VjaGNhbmNlbGAsIHRyaWdnZXJzIGBwb2ludGVyY2FuY2VsYCxcbiAqIGBwb2ludGVyb3V0YCBhbmQgYHBvaW50ZXJsZWF2ZWAgZXZlbnRzLlxuICpcbiAqIEB0aGlzIHtUb3VjaFNvdXJjZX1cbiAqIEBwYXJhbSB7VG91Y2hFdmVudH0gaW5FdmVudCBUaGUgaW4gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIHRvdWNoY2FuY2VsKGluRXZlbnQpIHtcbiAgdGhpcy5wcm9jZXNzVG91Y2hlc18oaW5FdmVudCwgdGhpcy5jYW5jZWxPdXRfKTtcbn1cblxuXG52YXIgVG91Y2hTb3VyY2UgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChFdmVudFNvdXJjZSkge1xuICBmdW5jdGlvbiBUb3VjaFNvdXJjZShkaXNwYXRjaGVyLCBtb3VzZVNvdXJjZSkge1xuICAgIHZhciBtYXBwaW5nID0ge1xuICAgICAgJ3RvdWNoc3RhcnQnOiB0b3VjaHN0YXJ0LFxuICAgICAgJ3RvdWNobW92ZSc6IHRvdWNobW92ZSxcbiAgICAgICd0b3VjaGVuZCc6IHRvdWNoZW5kLFxuICAgICAgJ3RvdWNoY2FuY2VsJzogdG91Y2hjYW5jZWxcbiAgICB9O1xuICAgIEV2ZW50U291cmNlLmNhbGwodGhpcywgZGlzcGF0Y2hlciwgbWFwcGluZyk7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIEV2ZW50fE9iamVjdD59XG4gICAgICovXG4gICAgdGhpcy5wb2ludGVyTWFwID0gZGlzcGF0Y2hlci5wb2ludGVyTWFwO1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0XG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vTW91c2VTb3VyY2UuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLm1vdXNlU291cmNlID0gbW91c2VTb3VyY2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuZmlyc3RUb3VjaElkXyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmNsaWNrQ291bnRfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgdGhpcy5yZXNldElkXztcblxuICAgIC8qKlxuICAgICAqIE1vdXNlIGV2ZW50IHRpbWVvdXQ6IFRoaXMgc2hvdWxkIGJlIGxvbmcgZW5vdWdoIHRvXG4gICAgICogaWdub3JlIGNvbXBhdCBtb3VzZSBldmVudHMgbWFkZSBieSB0b3VjaC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kZWR1cFRpbWVvdXRfID0gMjUwMDtcbiAgfVxuXG4gIGlmICggRXZlbnRTb3VyY2UgKSBUb3VjaFNvdXJjZS5fX3Byb3RvX18gPSBFdmVudFNvdXJjZTtcbiAgVG91Y2hTb3VyY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXZlbnRTb3VyY2UgJiYgRXZlbnRTb3VyY2UucHJvdG90eXBlICk7XG4gIFRvdWNoU291cmNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRvdWNoU291cmNlO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1RvdWNofSBpblRvdWNoIFRoZSBpbiB0b3VjaC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSwgaWYgdGhpcyBpcyB0aGUgcHJpbWFyeSB0b3VjaC5cbiAgICovXG4gIFRvdWNoU291cmNlLnByb3RvdHlwZS5pc1ByaW1hcnlUb3VjaF8gPSBmdW5jdGlvbiBpc1ByaW1hcnlUb3VjaF8gKGluVG91Y2gpIHtcbiAgICByZXR1cm4gdGhpcy5maXJzdFRvdWNoSWRfID09PSBpblRvdWNoLmlkZW50aWZpZXI7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBwcmltYXJ5IHRvdWNoIGlmIHRoZXJlIGFyZSBubyBwb2ludGVycywgb3IgdGhlIG9ubHkgcG9pbnRlciBpcyB0aGUgbW91c2UuXG4gICAqIEBwYXJhbSB7VG91Y2h9IGluVG91Y2ggVGhlIGluIHRvdWNoLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgVG91Y2hTb3VyY2UucHJvdG90eXBlLnNldFByaW1hcnlUb3VjaF8gPSBmdW5jdGlvbiBzZXRQcmltYXJ5VG91Y2hfIChpblRvdWNoKSB7XG4gICAgdmFyIGNvdW50ID0gT2JqZWN0LmtleXModGhpcy5wb2ludGVyTWFwKS5sZW5ndGg7XG4gICAgaWYgKGNvdW50ID09PSAwIHx8IChjb3VudCA9PT0gMSAmJiBQT0lOVEVSX0lELnRvU3RyaW5nKCkgaW4gdGhpcy5wb2ludGVyTWFwKSkge1xuICAgICAgdGhpcy5maXJzdFRvdWNoSWRfID0gaW5Ub3VjaC5pZGVudGlmaWVyO1xuICAgICAgdGhpcy5jYW5jZWxSZXNldENsaWNrQ291bnRfKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gaW5Qb2ludGVyIFRoZSBpbiBwb2ludGVyIG9iamVjdC5cbiAgICovXG4gIFRvdWNoU291cmNlLnByb3RvdHlwZS5yZW1vdmVQcmltYXJ5UG9pbnRlcl8gPSBmdW5jdGlvbiByZW1vdmVQcmltYXJ5UG9pbnRlcl8gKGluUG9pbnRlcikge1xuICAgIGlmIChpblBvaW50ZXIuaXNQcmltYXJ5KSB7XG4gICAgICB0aGlzLmZpcnN0VG91Y2hJZF8gPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnJlc2V0Q2xpY2tDb3VudF8oKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBUb3VjaFNvdXJjZS5wcm90b3R5cGUucmVzZXRDbGlja0NvdW50XyA9IGZ1bmN0aW9uIHJlc2V0Q2xpY2tDb3VudF8gKCkge1xuICAgIHRoaXMucmVzZXRJZF8gPSBzZXRUaW1lb3V0KFxuICAgICAgdGhpcy5yZXNldENsaWNrQ291bnRIYW5kbGVyXy5iaW5kKHRoaXMpLFxuICAgICAgQ0xJQ0tfQ09VTlRfVElNRU9VVCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBUb3VjaFNvdXJjZS5wcm90b3R5cGUucmVzZXRDbGlja0NvdW50SGFuZGxlcl8gPSBmdW5jdGlvbiByZXNldENsaWNrQ291bnRIYW5kbGVyXyAoKSB7XG4gICAgdGhpcy5jbGlja0NvdW50XyA9IDA7XG4gICAgdGhpcy5yZXNldElkXyA9IHVuZGVmaW5lZDtcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFRvdWNoU291cmNlLnByb3RvdHlwZS5jYW5jZWxSZXNldENsaWNrQ291bnRfID0gZnVuY3Rpb24gY2FuY2VsUmVzZXRDbGlja0NvdW50XyAoKSB7XG4gICAgaWYgKHRoaXMucmVzZXRJZF8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVzZXRJZF8pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBicm93c2VyRXZlbnQgQnJvd3NlciBldmVudFxuICAgKiBAcGFyYW0ge1RvdWNofSBpblRvdWNoIFRvdWNoIGV2ZW50XG4gICAqIEByZXR1cm4ge1BvaW50ZXJFdmVudH0gQSBwb2ludGVyIG9iamVjdC5cbiAgICovXG4gIFRvdWNoU291cmNlLnByb3RvdHlwZS50b3VjaFRvUG9pbnRlcl8gPSBmdW5jdGlvbiB0b3VjaFRvUG9pbnRlcl8gKGJyb3dzZXJFdmVudCwgaW5Ub3VjaCkge1xuICAgIHZhciBlID0gdGhpcy5kaXNwYXRjaGVyLmNsb25lRXZlbnQoYnJvd3NlckV2ZW50LCBpblRvdWNoKTtcbiAgICAvLyBTcGVjIHNwZWNpZmllcyB0aGF0IHBvaW50ZXJJZCAxIGlzIHJlc2VydmVkIGZvciBNb3VzZS5cbiAgICAvLyBUb3VjaCBpZGVudGlmaWVycyBjYW4gc3RhcnQgYXQgMC5cbiAgICAvLyBBZGQgMiB0byB0aGUgdG91Y2ggaWRlbnRpZmllciBmb3IgY29tcGF0aWJpbGl0eS5cbiAgICBlLnBvaW50ZXJJZCA9IGluVG91Y2guaWRlbnRpZmllciArIDI7XG4gICAgLy8gVE9ETzogY2hlY2sgaWYgdGhpcyBpcyBuZWNlc3Nhcnk/XG4gICAgLy9lLnRhcmdldCA9IGZpbmRUYXJnZXQoZSk7XG4gICAgZS5idWJibGVzID0gdHJ1ZTtcbiAgICBlLmNhbmNlbGFibGUgPSB0cnVlO1xuICAgIGUuZGV0YWlsID0gdGhpcy5jbGlja0NvdW50XztcbiAgICBlLmJ1dHRvbiA9IDA7XG4gICAgZS5idXR0b25zID0gMTtcbiAgICBlLndpZHRoID0gaW5Ub3VjaC5yYWRpdXNYIHx8IDA7XG4gICAgZS5oZWlnaHQgPSBpblRvdWNoLnJhZGl1c1kgfHwgMDtcbiAgICBlLnByZXNzdXJlID0gaW5Ub3VjaC5mb3JjZSB8fCAwLjU7XG4gICAgZS5pc1ByaW1hcnkgPSB0aGlzLmlzUHJpbWFyeVRvdWNoXyhpblRvdWNoKTtcbiAgICBlLnBvaW50ZXJUeXBlID0gUE9JTlRFUl9UWVBFO1xuXG4gICAgLy8gbWFrZSBzdXJlIHRoYXQgdGhlIHByb3BlcnRpZXMgdGhhdCBhcmUgZGlmZmVyZW50IGZvclxuICAgIC8vIGVhY2ggYFRvdWNoYCBvYmplY3QgYXJlIG5vdCBjb3BpZWQgZnJvbSB0aGUgQnJvd3NlckV2ZW50IG9iamVjdFxuICAgIGUuY2xpZW50WCA9IGluVG91Y2guY2xpZW50WDtcbiAgICBlLmNsaWVudFkgPSBpblRvdWNoLmNsaWVudFk7XG4gICAgZS5zY3JlZW5YID0gaW5Ub3VjaC5zY3JlZW5YO1xuICAgIGUuc2NyZWVuWSA9IGluVG91Y2guc2NyZWVuWTtcblxuICAgIHJldHVybiBlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGluRXZlbnQgVG91Y2ggZXZlbnRcbiAgICogQHBhcmFtIHtmdW5jdGlvbihUb3VjaEV2ZW50LCBQb2ludGVyRXZlbnQpfSBpbkZ1bmN0aW9uIEluIGZ1bmN0aW9uLlxuICAgKi9cbiAgVG91Y2hTb3VyY2UucHJvdG90eXBlLnByb2Nlc3NUb3VjaGVzXyA9IGZ1bmN0aW9uIHByb2Nlc3NUb3VjaGVzXyAoaW5FdmVudCwgaW5GdW5jdGlvbikge1xuICAgIHZhciB0b3VjaGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaW5FdmVudC5jaGFuZ2VkVG91Y2hlcyk7XG4gICAgdmFyIGNvdW50ID0gdG91Y2hlcy5sZW5ndGg7XG4gICAgZnVuY3Rpb24gcHJldmVudERlZmF1bHQoKSB7XG4gICAgICBpbkV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLnRvdWNoVG9Qb2ludGVyXyhpbkV2ZW50LCB0b3VjaGVzW2ldKTtcbiAgICAgIC8vIGZvcndhcmQgdG91Y2ggcHJldmVudERlZmF1bHRzXG4gICAgICBwb2ludGVyLnByZXZlbnREZWZhdWx0ID0gcHJldmVudERlZmF1bHQ7XG4gICAgICBpbkZ1bmN0aW9uLmNhbGwodGhpcywgaW5FdmVudCwgcG9pbnRlcik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1RvdWNoTGlzdH0gdG91Y2hMaXN0IFRoZSB0b3VjaCBsaXN0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2VhcmNoSWQgU2VhcmNoIGlkZW50aWZpZXIuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUsIGlmIHRoZSBgVG91Y2hgIHdpdGggdGhlIGdpdmVuIGlkIGlzIGluIHRoZSBsaXN0LlxuICAgKi9cbiAgVG91Y2hTb3VyY2UucHJvdG90eXBlLmZpbmRUb3VjaF8gPSBmdW5jdGlvbiBmaW5kVG91Y2hfICh0b3VjaExpc3QsIHNlYXJjaElkKSB7XG4gICAgdmFyIGwgPSB0b3VjaExpc3QubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgdG91Y2ggPSB0b3VjaExpc3RbaV07XG4gICAgICBpZiAodG91Y2guaWRlbnRpZmllciA9PT0gc2VhcmNoSWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogSW4gc29tZSBpbnN0YW5jZXMsIGEgdG91Y2hzdGFydCBjYW4gaGFwcGVuIHdpdGhvdXQgYSB0b3VjaGVuZC4gVGhpc1xuICAgKiBsZWF2ZXMgdGhlIHBvaW50ZXJtYXAgaW4gYSBicm9rZW4gc3RhdGUuXG4gICAqIFRoZXJlZm9yZSwgb24gZXZlcnkgdG91Y2hzdGFydCwgd2UgcmVtb3ZlIHRoZSB0b3VjaGVzIHRoYXQgZGlkIG5vdCBmaXJlIGFcbiAgICogdG91Y2hlbmQgZXZlbnQuXG4gICAqIFRvIGtlZXAgc3RhdGUgZ2xvYmFsbHkgY29uc2lzdGVudCwgd2UgZmlyZSBhIHBvaW50ZXJjYW5jZWwgZm9yXG4gICAqIHRoaXMgXCJhYmFuZG9uZWRcIiB0b3VjaFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGluRXZlbnQgVGhlIGluIGV2ZW50LlxuICAgKi9cbiAgVG91Y2hTb3VyY2UucHJvdG90eXBlLnZhY3V1bVRvdWNoZXNfID0gZnVuY3Rpb24gdmFjdXVtVG91Y2hlc18gKGluRXZlbnQpIHtcbiAgICB2YXIgdG91Y2hMaXN0ID0gaW5FdmVudC50b3VjaGVzO1xuICAgIC8vIHBvaW50ZXJNYXAuZ2V0Q291bnQoKSBzaG91bGQgYmUgPCB0b3VjaExpc3QubGVuZ3RoIGhlcmUsXG4gICAgLy8gYXMgdGhlIHRvdWNoc3RhcnQgaGFzIG5vdCBiZWVuIHByb2Nlc3NlZCB5ZXQuXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLnBvaW50ZXJNYXApO1xuICAgIHZhciBjb3VudCA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChjb3VudCA+PSB0b3VjaExpc3QubGVuZ3RoKSB7XG4gICAgICB2YXIgZCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgIHZhciBrZXkgPSBOdW1iZXIoa2V5c1tpXSk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMucG9pbnRlck1hcFtrZXldO1xuICAgICAgICAvLyBOZXZlciByZW1vdmUgcG9pbnRlcklkID09IDEsIHdoaWNoIGlzIG1vdXNlLlxuICAgICAgICAvLyBUb3VjaCBpZGVudGlmaWVycyBhcmUgMiBzbWFsbGVyIHRoYW4gdGhlaXIgcG9pbnRlcklkLCB3aGljaCBpcyB0aGVcbiAgICAgICAgLy8gaW5kZXggaW4gcG9pbnRlcm1hcC5cbiAgICAgICAgaWYgKGtleSAhPSBQT0lOVEVSX0lEICYmICF0aGlzLmZpbmRUb3VjaF8odG91Y2hMaXN0LCBrZXkgLSAyKSkge1xuICAgICAgICAgIGQucHVzaCh2YWx1ZS5vdXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBkLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgICAgdGhpcy5jYW5jZWxPdXRfKGluRXZlbnQsIGRbaSQxXSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGJyb3dzZXJFdmVudCBUaGUgZXZlbnQuXG4gICAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBpblBvaW50ZXIgVGhlIGluIHBvaW50ZXIgb2JqZWN0LlxuICAgKi9cbiAgVG91Y2hTb3VyY2UucHJvdG90eXBlLm92ZXJEb3duXyA9IGZ1bmN0aW9uIG92ZXJEb3duXyAoYnJvd3NlckV2ZW50LCBpblBvaW50ZXIpIHtcbiAgICB0aGlzLnBvaW50ZXJNYXBbaW5Qb2ludGVyLnBvaW50ZXJJZF0gPSB7XG4gICAgICB0YXJnZXQ6IGluUG9pbnRlci50YXJnZXQsXG4gICAgICBvdXQ6IGluUG9pbnRlcixcbiAgICAgIG91dFRhcmdldDogaW5Qb2ludGVyLnRhcmdldFxuICAgIH07XG4gICAgdGhpcy5kaXNwYXRjaGVyLm92ZXIoaW5Qb2ludGVyLCBicm93c2VyRXZlbnQpO1xuICAgIHRoaXMuZGlzcGF0Y2hlci5lbnRlcihpblBvaW50ZXIsIGJyb3dzZXJFdmVudCk7XG4gICAgdGhpcy5kaXNwYXRjaGVyLmRvd24oaW5Qb2ludGVyLCBicm93c2VyRXZlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGJyb3dzZXJFdmVudCBUaGUgZXZlbnQuXG4gICAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBpblBvaW50ZXIgVGhlIGluIHBvaW50ZXIuXG4gICAqL1xuICBUb3VjaFNvdXJjZS5wcm90b3R5cGUubW92ZU92ZXJPdXRfID0gZnVuY3Rpb24gbW92ZU92ZXJPdXRfIChicm93c2VyRXZlbnQsIGluUG9pbnRlcikge1xuICAgIHZhciBldmVudCA9IGluUG9pbnRlcjtcbiAgICB2YXIgcG9pbnRlciA9IHRoaXMucG9pbnRlck1hcFtldmVudC5wb2ludGVySWRdO1xuICAgIC8vIGEgZmluZ2VyIGRyaWZ0ZWQgb2ZmIHRoZSBzY3JlZW4sIGlnbm9yZSBpdFxuICAgIGlmICghcG9pbnRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgb3V0RXZlbnQgPSBwb2ludGVyLm91dDtcbiAgICB2YXIgb3V0VGFyZ2V0ID0gcG9pbnRlci5vdXRUYXJnZXQ7XG4gICAgdGhpcy5kaXNwYXRjaGVyLm1vdmUoZXZlbnQsIGJyb3dzZXJFdmVudCk7XG4gICAgaWYgKG91dEV2ZW50ICYmIG91dFRhcmdldCAhPT0gZXZlbnQudGFyZ2V0KSB7XG4gICAgICBvdXRFdmVudC5yZWxhdGVkVGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovIChldmVudCkucmVsYXRlZFRhcmdldCA9IG91dFRhcmdldDtcbiAgICAgIC8vIHJlY292ZXIgZnJvbSByZXRhcmdldGluZyBieSBzaGFkb3dcbiAgICAgIG91dEV2ZW50LnRhcmdldCA9IG91dFRhcmdldDtcbiAgICAgIGlmIChldmVudC50YXJnZXQpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaGVyLmxlYXZlT3V0KG91dEV2ZW50LCBicm93c2VyRXZlbnQpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoZXIuZW50ZXJPdmVyKGV2ZW50LCBicm93c2VyRXZlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY2xlYW4gdXAgY2FzZSB3aGVuIGZpbmdlciBsZWF2ZXMgdGhlIHNjcmVlblxuICAgICAgICAvKiogQHR5cGUge09iamVjdH0gKi8gKGV2ZW50KS50YXJnZXQgPSBvdXRUYXJnZXQ7XG4gICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqLyAoZXZlbnQpLnJlbGF0ZWRUYXJnZXQgPSBudWxsO1xuICAgICAgICB0aGlzLmNhbmNlbE91dF8oYnJvd3NlckV2ZW50LCBldmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIHBvaW50ZXIub3V0ID0gZXZlbnQ7XG4gICAgcG9pbnRlci5vdXRUYXJnZXQgPSBldmVudC50YXJnZXQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gYnJvd3NlckV2ZW50IEFuIGV2ZW50LlxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gaW5Qb2ludGVyIFRoZSBpblBvaW50ZXIgb2JqZWN0LlxuICAgKi9cbiAgVG91Y2hTb3VyY2UucHJvdG90eXBlLnVwT3V0XyA9IGZ1bmN0aW9uIHVwT3V0XyAoYnJvd3NlckV2ZW50LCBpblBvaW50ZXIpIHtcbiAgICB0aGlzLmRpc3BhdGNoZXIudXAoaW5Qb2ludGVyLCBicm93c2VyRXZlbnQpO1xuICAgIHRoaXMuZGlzcGF0Y2hlci5vdXQoaW5Qb2ludGVyLCBicm93c2VyRXZlbnQpO1xuICAgIHRoaXMuZGlzcGF0Y2hlci5sZWF2ZShpblBvaW50ZXIsIGJyb3dzZXJFdmVudCk7XG4gICAgdGhpcy5jbGVhblVwUG9pbnRlcl8oaW5Qb2ludGVyKTtcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBicm93c2VyRXZlbnQgVGhlIGV2ZW50LlxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gaW5Qb2ludGVyIFRoZSBpbiBwb2ludGVyLlxuICAgKi9cbiAgVG91Y2hTb3VyY2UucHJvdG90eXBlLmNhbmNlbE91dF8gPSBmdW5jdGlvbiBjYW5jZWxPdXRfIChicm93c2VyRXZlbnQsIGluUG9pbnRlcikge1xuICAgIHRoaXMuZGlzcGF0Y2hlci5jYW5jZWwoaW5Qb2ludGVyLCBicm93c2VyRXZlbnQpO1xuICAgIHRoaXMuZGlzcGF0Y2hlci5vdXQoaW5Qb2ludGVyLCBicm93c2VyRXZlbnQpO1xuICAgIHRoaXMuZGlzcGF0Y2hlci5sZWF2ZShpblBvaW50ZXIsIGJyb3dzZXJFdmVudCk7XG4gICAgdGhpcy5jbGVhblVwUG9pbnRlcl8oaW5Qb2ludGVyKTtcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtQb2ludGVyRXZlbnR9IGluUG9pbnRlciBUaGUgaW5Qb2ludGVyIG9iamVjdC5cbiAgICovXG4gIFRvdWNoU291cmNlLnByb3RvdHlwZS5jbGVhblVwUG9pbnRlcl8gPSBmdW5jdGlvbiBjbGVhblVwUG9pbnRlcl8gKGluUG9pbnRlcikge1xuICAgIGRlbGV0ZSB0aGlzLnBvaW50ZXJNYXBbaW5Qb2ludGVyLnBvaW50ZXJJZF07XG4gICAgdGhpcy5yZW1vdmVQcmltYXJ5UG9pbnRlcl8oaW5Qb2ludGVyKTtcbiAgfTtcblxuICAvKipcbiAgICogUHJldmVudCBzeW50aCBtb3VzZSBldmVudHMgZnJvbSBjcmVhdGluZyBwb2ludGVyIGV2ZW50cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBpbkV2ZW50IFRoZSBpbiBldmVudC5cbiAgICovXG4gIFRvdWNoU291cmNlLnByb3RvdHlwZS5kZWR1cFN5bnRoTW91c2VfID0gZnVuY3Rpb24gZGVkdXBTeW50aE1vdXNlXyAoaW5FdmVudCkge1xuICAgIHZhciBsdHMgPSB0aGlzLm1vdXNlU291cmNlLmxhc3RUb3VjaGVzO1xuICAgIHZhciB0ID0gaW5FdmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAvLyBvbmx5IHRoZSBwcmltYXJ5IGZpbmdlciB3aWxsIHN5bnRoIG1vdXNlIGV2ZW50c1xuICAgIGlmICh0aGlzLmlzUHJpbWFyeVRvdWNoXyh0KSkge1xuICAgICAgLy8gcmVtZW1iZXIgeC95IG9mIGxhc3QgdG91Y2hcbiAgICAgIHZhciBsdCA9IFt0LmNsaWVudFgsIHQuY2xpZW50WV07XG4gICAgICBsdHMucHVzaChsdCk7XG5cbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIHJlbW92ZSB0b3VjaCBhZnRlciB0aW1lb3V0XG4gICAgICAgIHJlbW92ZShsdHMsIGx0KTtcbiAgICAgIH0sIHRoaXMuZGVkdXBUaW1lb3V0Xyk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBUb3VjaFNvdXJjZTtcbn0oRXZlbnRTb3VyY2UpKTtcblxuZXhwb3J0IGRlZmF1bHQgVG91Y2hTb3VyY2U7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRvdWNoU291cmNlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9wcm9qXG4gKi9cblxuLyoqXG4gKiBUaGUgb2wvcHJvaiBtb2R1bGUgc3RvcmVzOlxuICogKiBhIGxpc3Qgb2Yge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259XG4gKiBvYmplY3RzLCBvbmUgZm9yIGVhY2ggcHJvamVjdGlvbiBzdXBwb3J0ZWQgYnkgdGhlIGFwcGxpY2F0aW9uXG4gKiAqIGEgbGlzdCBvZiB0cmFuc2Zvcm0gZnVuY3Rpb25zIG5lZWRlZCB0byBjb252ZXJ0IGNvb3JkaW5hdGVzIGluIG9uZSBwcm9qZWN0aW9uXG4gKiBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIHN0YXRpYyBmdW5jdGlvbnMgYXJlIHRoZSBtZXRob2RzIHVzZWQgdG8gbWFpbnRhaW4gdGhlc2UuXG4gKiBFYWNoIHRyYW5zZm9ybSBmdW5jdGlvbiBjYW4gaGFuZGxlIG5vdCBvbmx5IHNpbXBsZSBjb29yZGluYXRlIHBhaXJzLCBidXQgYWxzb1xuICogbGFyZ2UgYXJyYXlzIG9mIGNvb3JkaW5hdGVzIHN1Y2ggYXMgdmVjdG9yIGdlb21ldHJpZXMuXG4gKlxuICogV2hlbiBsb2FkZWQsIHRoZSBsaWJyYXJ5IGFkZHMgcHJvamVjdGlvbiBvYmplY3RzIGZvciBFUFNHOjQzMjYgKFdHUzg0XG4gKiBnZW9ncmFwaGljIGNvb3JkaW5hdGVzKSBhbmQgRVBTRzozODU3IChXZWIgb3IgU3BoZXJpY2FsIE1lcmNhdG9yLCBhcyB1c2VkXG4gKiBmb3IgZXhhbXBsZSBieSBCaW5nIE1hcHMgb3IgT3BlblN0cmVldE1hcCksIHRvZ2V0aGVyIHdpdGggdGhlIHJlbGV2YW50XG4gKiB0cmFuc2Zvcm0gZnVuY3Rpb25zLlxuICpcbiAqIEFkZGl0aW9uYWwgdHJhbnNmb3JtcyBtYXkgYmUgYWRkZWQgYnkgdXNpbmcgdGhlIGh0dHA6Ly9wcm9qNGpzLm9yZy9cbiAqIGxpYnJhcnkgKHZlcnNpb24gMi4yIG9yIGxhdGVyKS4gWW91IGNhbiB1c2UgdGhlIGZ1bGwgYnVpbGQgc3VwcGxpZWQgYnlcbiAqIFByb2o0anMsIG9yIGNyZWF0ZSBhIGN1c3RvbSBidWlsZCB0byBzdXBwb3J0IHRob3NlIHByb2plY3Rpb25zIHlvdSBuZWVkOyBzZWVcbiAqIHRoZSBQcm9qNGpzIHdlYnNpdGUgZm9yIGhvdyB0byBkbyB0aGlzLiBZb3UgYWxzbyBuZWVkIHRoZSBQcm9qNGpzIGRlZmluaXRpb25zXG4gKiBmb3IgdGhlIHJlcXVpcmVkIHByb2plY3Rpb25zLiBUaGVzZSBkZWZpbml0aW9ucyBjYW4gYmUgb2J0YWluZWQgZnJvbVxuICogaHR0cHM6Ly9lcHNnLmlvLywgYW5kIGFyZSBhIEpTIGZ1bmN0aW9uLCBzbyBjYW4gYmUgbG9hZGVkIGluIGEgc2NyaXB0XG4gKiB0YWcgKGFzIGluIHRoZSBleGFtcGxlcykgb3IgcGFzdGVkIGludG8geW91ciBhcHBsaWNhdGlvbi5cbiAqXG4gKiBBZnRlciBhbGwgcmVxdWlyZWQgcHJvamVjdGlvbiBkZWZpbml0aW9ucyBhcmUgYWRkZWQgdG8gcHJvajQncyByZWdpc3RyeSAoYnlcbiAqIHVzaW5nIGBwcm9qNC5kZWZzKClgKSwgc2ltcGx5IGNhbGwgYHJlZ2lzdGVyKHByb2o0KWAgZnJvbSB0aGUgYG9sL3Byb2ovcHJvajRgXG4gKiBwYWNrYWdlLiBFeGlzdGluZyB0cmFuc2Zvcm1zIGFyZSBub3QgY2hhbmdlZCBieSB0aGlzIGZ1bmN0aW9uLiBTZWVcbiAqIGV4YW1wbGVzL3dtcy1pbWFnZS1jdXN0b20tcHJvaiBmb3IgYW4gZXhhbXBsZSBvZiB0aGlzLlxuICpcbiAqIEFkZGl0aW9uYWwgcHJvamVjdGlvbiBkZWZpbml0aW9ucyBjYW4gYmUgcmVnaXN0ZXJlZCB3aXRoIGBwcm9qNC5kZWZzKClgIGFueVxuICogdGltZS4gSnVzdCBtYWtlIHN1cmUgdG8gY2FsbCBgcmVnaXN0ZXIocHJvajQpYCBhZ2FpbjsgZm9yIGV4YW1wbGUsIHdpdGggdXNlci1zdXBwbGllZCBkYXRhIHdoZXJlIHlvdSBkb24ndFxuICoga25vdyBpbiBhZHZhbmNlIHdoYXQgcHJvamVjdGlvbnMgYXJlIG5lZWRlZCwgeW91IGNhbiBpbml0aWFsbHkgbG9hZCBtaW5pbWFsXG4gKiBzdXBwb3J0IGFuZCB0aGVuIGxvYWQgd2hpY2hldmVyIGFyZSByZXF1ZXN0ZWQuXG4gKlxuICogTm90ZSB0aGF0IFByb2o0anMgZG9lcyBub3Qgc3VwcG9ydCBwcm9qZWN0aW9uIGV4dGVudHMuIElmIHlvdSB3YW50IHRvIGFkZFxuICogb25lIGZvciBjcmVhdGluZyBkZWZhdWx0IHRpbGUgZ3JpZHMsIHlvdSBjYW4gYWRkIGl0IGFmdGVyIHRoZSBQcm9qZWN0aW9uXG4gKiBvYmplY3QgaGFzIGJlZW4gY3JlYXRlZCB3aXRoIGBzZXRFeHRlbnRgLCBmb3IgZXhhbXBsZSxcbiAqIGBnZXQoJ0VQU0c6MTIzNCcpLnNldEV4dGVudChleHRlbnQpYC5cbiAqXG4gKiBJbiBhZGRpdGlvbiB0byBQcm9qNGpzIHN1cHBvcnQsIGFueSB0cmFuc2Zvcm0gZnVuY3Rpb25zIGNhbiBiZSBhZGRlZCB3aXRoXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3Byb2p+YWRkQ29vcmRpbmF0ZVRyYW5zZm9ybXN9LiBUbyB1c2UgdGhpcywgeW91IG11c3QgZmlyc3QgY3JlYXRlXG4gKiBhIHtAbGluayBtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBvYmplY3QgZm9yIHRoZSBuZXcgcHJvamVjdGlvbiBhbmQgYWRkIGl0IHdpdGhcbiAqIHtAbGluayBtb2R1bGU6b2wvcHJvan5hZGRQcm9qZWN0aW9ufS4gWW91IGNhbiB0aGVuIGFkZCB0aGUgZm9yd2FyZCBhbmQgaW52ZXJzZVxuICogZnVuY3Rpb25zIHdpdGgge0BsaW5rIG1vZHVsZTpvbC9wcm9qfmFkZENvb3JkaW5hdGVUcmFuc2Zvcm1zfS4gU2VlXG4gKiBleGFtcGxlcy93bXMtY3VzdG9tLXByb2ogZm9yIGFuIGV4YW1wbGUgb2YgdGhpcy5cbiAqXG4gKiBOb3RlIHRoYXQgaWYgbm8gdHJhbnNmb3JtcyBhcmUgbmVlZGVkIGFuZCB5b3Ugb25seSBuZWVkIHRvIGRlZmluZSB0aGVcbiAqIHByb2plY3Rpb24sIGp1c3QgYWRkIGEge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IHdpdGhcbiAqIHtAbGluayBtb2R1bGU6b2wvcHJvan5hZGRQcm9qZWN0aW9ufS4gU2VlIGV4YW1wbGVzL3dtcy1uby1wcm9qIGZvciBhbiBleGFtcGxlIG9mXG4gKiB0aGlzLlxuICovXG5pbXBvcnQge2dldERpc3RhbmNlfSBmcm9tICcuL3NwaGVyZS5qcyc7XG5pbXBvcnQge2FwcGx5VHJhbnNmb3JtfSBmcm9tICcuL2V4dGVudC5qcyc7XG5pbXBvcnQge21vZHVsb30gZnJvbSAnLi9tYXRoLmpzJztcbmltcG9ydCB7dG9FUFNHNDMyNiwgZnJvbUVQU0c0MzI2LCBQUk9KRUNUSU9OUyBhcyBFUFNHMzg1N19QUk9KRUNUSU9OU30gZnJvbSAnLi9wcm9qL2Vwc2czODU3LmpzJztcbmltcG9ydCB7UFJPSkVDVElPTlMgYXMgRVBTRzQzMjZfUFJPSkVDVElPTlN9IGZyb20gJy4vcHJvai9lcHNnNDMyNi5qcyc7XG5pbXBvcnQgUHJvamVjdGlvbiBmcm9tICcuL3Byb2ovUHJvamVjdGlvbi5qcyc7XG5pbXBvcnQgVW5pdHMsIHtNRVRFUlNfUEVSX1VOSVR9IGZyb20gJy4vcHJvai9Vbml0cy5qcyc7XG5pbXBvcnQgKiBhcyBwcm9qZWN0aW9ucyBmcm9tICcuL3Byb2ovcHJvamVjdGlvbnMuanMnO1xuaW1wb3J0IHthZGQgYXMgYWRkVHJhbnNmb3JtRnVuYywgY2xlYXIgYXMgY2xlYXJUcmFuc2Zvcm1GdW5jcywgZ2V0IGFzIGdldFRyYW5zZm9ybUZ1bmN9IGZyb20gJy4vcHJvai90cmFuc2Zvcm1zLmpzJztcblxuXG4vKipcbiAqIEEgcHJvamVjdGlvbiBhcyB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0sIFNSUyBpZGVudGlmaWVyXG4gKiBzdHJpbmcgb3IgdW5kZWZpbmVkLlxuICogQHR5cGVkZWYge1Byb2plY3Rpb258c3RyaW5nfHVuZGVmaW5lZH0gUHJvamVjdGlvbkxpa2VcbiAqIEBhcGlcbiAqL1xuXG5cbi8qKlxuICogQSB0cmFuc2Zvcm0gZnVuY3Rpb24gYWNjZXB0cyBhbiBhcnJheSBvZiBpbnB1dCBjb29yZGluYXRlIHZhbHVlcywgYW4gb3B0aW9uYWxcbiAqIG91dHB1dCBhcnJheSwgYW5kIGFuIG9wdGlvbmFsIGRpbWVuc2lvbiAoZGVmYXVsdCBzaG91bGQgYmUgMikuICBUaGUgZnVuY3Rpb25cbiAqIHRyYW5zZm9ybXMgdGhlIGlucHV0IGNvb3JkaW5hdGUgdmFsdWVzLCBwb3B1bGF0ZXMgdGhlIG91dHB1dCBhcnJheSwgYW5kXG4gKiByZXR1cm5zIHRoZSBvdXRwdXQgYXJyYXkuXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKEFycmF5PG51bWJlcj4sIEFycmF5PG51bWJlcj49LCBudW1iZXI9KTogQXJyYXk8bnVtYmVyPn0gVHJhbnNmb3JtRnVuY3Rpb25cbiAqIEBhcGlcbiAqL1xuXG5cbmV4cG9ydCB7TUVURVJTX1BFUl9VTklUfTtcblxuZXhwb3J0IHtQcm9qZWN0aW9ufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGlucHV0IElucHV0IGNvb3JkaW5hdGUgYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj49fSBvcHRfb3V0cHV0IE91dHB1dCBhcnJheSBvZiBjb29yZGluYXRlIHZhbHVlcy5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2RpbWVuc2lvbiBEaW1lbnNpb24uXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBPdXRwdXQgY29vcmRpbmF0ZSBhcnJheSAobmV3IGFycmF5LCBzYW1lIGNvb3JkaW5hdGVcbiAqICAgICB2YWx1ZXMpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvbmVUcmFuc2Zvcm0oaW5wdXQsIG9wdF9vdXRwdXQsIG9wdF9kaW1lbnNpb24pIHtcbiAgdmFyIG91dHB1dDtcbiAgaWYgKG9wdF9vdXRwdXQgIT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGlucHV0Lmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIG9wdF9vdXRwdXRbaV0gPSBpbnB1dFtpXTtcbiAgICB9XG4gICAgb3V0cHV0ID0gb3B0X291dHB1dDtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBpbnB1dC5zbGljZSgpO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGlucHV0IElucHV0IGNvb3JkaW5hdGUgYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj49fSBvcHRfb3V0cHV0IE91dHB1dCBhcnJheSBvZiBjb29yZGluYXRlIHZhbHVlcy5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2RpbWVuc2lvbiBEaW1lbnNpb24uXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBJbnB1dCBjb29yZGluYXRlIGFycmF5IChzYW1lIGFycmF5IGFzIGlucHV0KS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aXR5VHJhbnNmb3JtKGlucHV0LCBvcHRfb3V0cHV0LCBvcHRfZGltZW5zaW9uKSB7XG4gIGlmIChvcHRfb3V0cHV0ICE9PSB1bmRlZmluZWQgJiYgaW5wdXQgIT09IG9wdF9vdXRwdXQpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBpbnB1dC5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBvcHRfb3V0cHV0W2ldID0gaW5wdXRbaV07XG4gICAgfVxuICAgIGlucHV0ID0gb3B0X291dHB1dDtcbiAgfVxuICByZXR1cm4gaW5wdXQ7XG59XG5cblxuLyoqXG4gKiBBZGQgYSBQcm9qZWN0aW9uIG9iamVjdCB0byB0aGUgbGlzdCBvZiBzdXBwb3J0ZWQgcHJvamVjdGlvbnMgdGhhdCBjYW4gYmVcbiAqIGxvb2tlZCB1cCBieSB0aGVpciBjb2RlLlxuICpcbiAqIEBwYXJhbSB7UHJvamVjdGlvbn0gcHJvamVjdGlvbiBQcm9qZWN0aW9uIGluc3RhbmNlLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkUHJvamVjdGlvbihwcm9qZWN0aW9uKSB7XG4gIHByb2plY3Rpb25zLmFkZChwcm9qZWN0aW9uLmdldENvZGUoKSwgcHJvamVjdGlvbik7XG4gIGFkZFRyYW5zZm9ybUZ1bmMocHJvamVjdGlvbiwgcHJvamVjdGlvbiwgY2xvbmVUcmFuc2Zvcm0pO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxQcm9qZWN0aW9uPn0gcHJvamVjdGlvbnMgUHJvamVjdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRQcm9qZWN0aW9ucyhwcm9qZWN0aW9ucykge1xuICBwcm9qZWN0aW9ucy5mb3JFYWNoKGFkZFByb2plY3Rpb24pO1xufVxuXG5cbi8qKlxuICogRmV0Y2hlcyBhIFByb2plY3Rpb24gb2JqZWN0IGZvciB0aGUgY29kZSBzcGVjaWZpZWQuXG4gKlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gcHJvamVjdGlvbkxpa2UgRWl0aGVyIGEgY29kZSBzdHJpbmcgd2hpY2ggaXNcbiAqICAgICBhIGNvbWJpbmF0aW9uIG9mIGF1dGhvcml0eSBhbmQgaWRlbnRpZmllciBzdWNoIGFzIFwiRVBTRzo0MzI2XCIsIG9yIGFuXG4gKiAgICAgZXhpc3RpbmcgcHJvamVjdGlvbiBvYmplY3QsIG9yIHVuZGVmaW5lZC5cbiAqIEByZXR1cm4ge1Byb2plY3Rpb259IFByb2plY3Rpb24gb2JqZWN0LCBvciBudWxsIGlmIG5vdCBpbiBsaXN0LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0KHByb2plY3Rpb25MaWtlKSB7XG4gIHJldHVybiB0eXBlb2YgcHJvamVjdGlvbkxpa2UgPT09ICdzdHJpbmcnID9cbiAgICBwcm9qZWN0aW9ucy5nZXQoLyoqIEB0eXBlIHtzdHJpbmd9ICovIChwcm9qZWN0aW9uTGlrZSkpIDpcbiAgICAoLyoqIEB0eXBlIHtQcm9qZWN0aW9ufSAqLyAocHJvamVjdGlvbkxpa2UpIHx8IG51bGwpO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSByZXNvbHV0aW9uIG9mIHRoZSBwb2ludCBpbiBkZWdyZWVzIG9yIGRpc3RhbmNlIHVuaXRzLlxuICogRm9yIHByb2plY3Rpb25zIHdpdGggZGVncmVlcyBhcyB0aGUgdW5pdCB0aGlzIHdpbGwgc2ltcGx5IHJldHVybiB0aGVcbiAqIHByb3ZpZGVkIHJlc29sdXRpb24uIEZvciBvdGhlciBwcm9qZWN0aW9ucyB0aGUgcG9pbnQgcmVzb2x1dGlvbiBpc1xuICogYnkgZGVmYXVsdCBlc3RpbWF0ZWQgYnkgdHJhbnNmb3JtaW5nIHRoZSAncG9pbnQnIHBpeGVsIHRvIEVQU0c6NDMyNixcbiAqIG1lYXN1cmluZyBpdHMgd2lkdGggYW5kIGhlaWdodCBvbiB0aGUgbm9ybWFsIHNwaGVyZSxcbiAqIGFuZCB0YWtpbmcgdGhlIGF2ZXJhZ2Ugb2YgdGhlIHdpZHRoIGFuZCBoZWlnaHQuXG4gKiBBIGN1c3RvbSBmdW5jdGlvbiBjYW4gYmUgcHJvdmlkZWQgZm9yIGEgc3BlY2lmaWMgcHJvamVjdGlvbiwgZWl0aGVyXG4gKiBieSBzZXR0aW5nIHRoZSBgZ2V0UG9pbnRSZXNvbHV0aW9uYCBvcHRpb24gaW4gdGhlXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn5Qcm9qZWN0aW9ufSBjb25zdHJ1Y3RvciBvciBieSB1c2luZ1xuICoge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb25+UHJvamVjdGlvbiNzZXRHZXRQb2ludFJlc29sdXRpb259IHRvIGNoYW5nZSBhbiBleGlzdGluZ1xuICogcHJvamVjdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBwcm9qZWN0aW9uIFRoZSBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gTm9taW5hbCByZXNvbHV0aW9uIGluIHByb2plY3Rpb24gdW5pdHMuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBwb2ludCBQb2ludCB0byBmaW5kIGFkanVzdGVkIHJlc29sdXRpb24gYXQuXG4gKiBAcGFyYW0ge1VuaXRzPX0gb3B0X3VuaXRzIFVuaXRzIHRvIGdldCB0aGUgcG9pbnQgcmVzb2x1dGlvbiBpbi5cbiAqIERlZmF1bHQgaXMgdGhlIHByb2plY3Rpb24ncyB1bml0cy5cbiAqIEByZXR1cm4ge251bWJlcn0gUG9pbnQgcmVzb2x1dGlvbi5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFBvaW50UmVzb2x1dGlvbihwcm9qZWN0aW9uLCByZXNvbHV0aW9uLCBwb2ludCwgb3B0X3VuaXRzKSB7XG4gIHByb2plY3Rpb24gPSBnZXQocHJvamVjdGlvbik7XG4gIHZhciBwb2ludFJlc29sdXRpb247XG4gIHZhciBnZXR0ZXIgPSBwcm9qZWN0aW9uLmdldFBvaW50UmVzb2x1dGlvbkZ1bmMoKTtcbiAgaWYgKGdldHRlcikge1xuICAgIHBvaW50UmVzb2x1dGlvbiA9IGdldHRlcihyZXNvbHV0aW9uLCBwb2ludCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHVuaXRzID0gcHJvamVjdGlvbi5nZXRVbml0cygpO1xuICAgIGlmICh1bml0cyA9PSBVbml0cy5ERUdSRUVTICYmICFvcHRfdW5pdHMgfHwgb3B0X3VuaXRzID09IFVuaXRzLkRFR1JFRVMpIHtcbiAgICAgIHBvaW50UmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEVzdGltYXRlIHBvaW50IHJlc29sdXRpb24gYnkgdHJhbnNmb3JtaW5nIHRoZSBjZW50ZXIgcGl4ZWwgdG8gRVBTRzo0MzI2LFxuICAgICAgLy8gbWVhc3VyaW5nIGl0cyB3aWR0aCBhbmQgaGVpZ2h0IG9uIHRoZSBub3JtYWwgc3BoZXJlLCBhbmQgdGFraW5nIHRoZVxuICAgICAgLy8gYXZlcmFnZSBvZiB0aGUgd2lkdGggYW5kIGhlaWdodC5cbiAgICAgIHZhciB0b0VQU0c0MzI2ID0gZ2V0VHJhbnNmb3JtRnJvbVByb2plY3Rpb25zKHByb2plY3Rpb24sIGdldCgnRVBTRzo0MzI2JykpO1xuICAgICAgdmFyIHZlcnRpY2VzID0gW1xuICAgICAgICBwb2ludFswXSAtIHJlc29sdXRpb24gLyAyLCBwb2ludFsxXSxcbiAgICAgICAgcG9pbnRbMF0gKyByZXNvbHV0aW9uIC8gMiwgcG9pbnRbMV0sXG4gICAgICAgIHBvaW50WzBdLCBwb2ludFsxXSAtIHJlc29sdXRpb24gLyAyLFxuICAgICAgICBwb2ludFswXSwgcG9pbnRbMV0gKyByZXNvbHV0aW9uIC8gMlxuICAgICAgXTtcbiAgICAgIHZlcnRpY2VzID0gdG9FUFNHNDMyNih2ZXJ0aWNlcywgdmVydGljZXMsIDIpO1xuICAgICAgdmFyIHdpZHRoID0gZ2V0RGlzdGFuY2UodmVydGljZXMuc2xpY2UoMCwgMiksIHZlcnRpY2VzLnNsaWNlKDIsIDQpKTtcbiAgICAgIHZhciBoZWlnaHQgPSBnZXREaXN0YW5jZSh2ZXJ0aWNlcy5zbGljZSg0LCA2KSwgdmVydGljZXMuc2xpY2UoNiwgOCkpO1xuICAgICAgcG9pbnRSZXNvbHV0aW9uID0gKHdpZHRoICsgaGVpZ2h0KSAvIDI7XG4gICAgICB2YXIgbWV0ZXJzUGVyVW5pdCA9IG9wdF91bml0cyA/XG4gICAgICAgIE1FVEVSU19QRVJfVU5JVFtvcHRfdW5pdHNdIDpcbiAgICAgICAgcHJvamVjdGlvbi5nZXRNZXRlcnNQZXJVbml0KCk7XG4gICAgICBpZiAobWV0ZXJzUGVyVW5pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBvaW50UmVzb2x1dGlvbiAvPSBtZXRlcnNQZXJVbml0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcG9pbnRSZXNvbHV0aW9uO1xufVxuXG5cbi8qKlxuICogUmVnaXN0ZXJzIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9ucyB0aGF0IGRvbid0IGFsdGVyIGNvb3JkaW5hdGVzLiBUaG9zZSBhbGxvd1xuICogdG8gdHJhbnNmb3JtIGJldHdlZW4gcHJvamVjdGlvbnMgd2l0aCBlcXVhbCBtZWFuaW5nLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8UHJvamVjdGlvbj59IHByb2plY3Rpb25zIFByb2plY3Rpb25zLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkRXF1aXZhbGVudFByb2plY3Rpb25zKHByb2plY3Rpb25zKSB7XG4gIGFkZFByb2plY3Rpb25zKHByb2plY3Rpb25zKTtcbiAgcHJvamVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihzb3VyY2UpIHtcbiAgICBwcm9qZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGRlc3RpbmF0aW9uKSB7XG4gICAgICBpZiAoc291cmNlICE9PSBkZXN0aW5hdGlvbikge1xuICAgICAgICBhZGRUcmFuc2Zvcm1GdW5jKHNvdXJjZSwgZGVzdGluYXRpb24sIGNsb25lVHJhbnNmb3JtKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cblxuLyoqXG4gKiBSZWdpc3RlcnMgdHJhbnNmb3JtYXRpb24gZnVuY3Rpb25zIHRvIGNvbnZlcnQgY29vcmRpbmF0ZXMgaW4gYW55IHByb2plY3Rpb25cbiAqIGluIHByb2plY3Rpb24xIHRvIGFueSBwcm9qZWN0aW9uIGluIHByb2plY3Rpb24yLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8UHJvamVjdGlvbj59IHByb2plY3Rpb25zMSBQcm9qZWN0aW9ucyB3aXRoIGVxdWFsXG4gKiAgICAgbWVhbmluZy5cbiAqIEBwYXJhbSB7QXJyYXk8UHJvamVjdGlvbj59IHByb2plY3Rpb25zMiBQcm9qZWN0aW9ucyB3aXRoIGVxdWFsXG4gKiAgICAgbWVhbmluZy5cbiAqIEBwYXJhbSB7VHJhbnNmb3JtRnVuY3Rpb259IGZvcndhcmRUcmFuc2Zvcm0gVHJhbnNmb3JtYXRpb24gZnJvbSBhbnlcbiAqICAgcHJvamVjdGlvbiBpbiBwcm9qZWN0aW9uMSB0byBhbnkgcHJvamVjdGlvbiBpbiBwcm9qZWN0aW9uMi5cbiAqIEBwYXJhbSB7VHJhbnNmb3JtRnVuY3Rpb259IGludmVyc2VUcmFuc2Zvcm0gVHJhbnNmb3JtIGZyb20gYW55IHByb2plY3Rpb25cbiAqICAgaW4gcHJvamVjdGlvbjIgdG8gYW55IHByb2plY3Rpb24gaW4gcHJvamVjdGlvbjEuLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkRXF1aXZhbGVudFRyYW5zZm9ybXMocHJvamVjdGlvbnMxLCBwcm9qZWN0aW9uczIsIGZvcndhcmRUcmFuc2Zvcm0sIGludmVyc2VUcmFuc2Zvcm0pIHtcbiAgcHJvamVjdGlvbnMxLmZvckVhY2goZnVuY3Rpb24ocHJvamVjdGlvbjEpIHtcbiAgICBwcm9qZWN0aW9uczIuZm9yRWFjaChmdW5jdGlvbihwcm9qZWN0aW9uMikge1xuICAgICAgYWRkVHJhbnNmb3JtRnVuYyhwcm9qZWN0aW9uMSwgcHJvamVjdGlvbjIsIGZvcndhcmRUcmFuc2Zvcm0pO1xuICAgICAgYWRkVHJhbnNmb3JtRnVuYyhwcm9qZWN0aW9uMiwgcHJvamVjdGlvbjEsIGludmVyc2VUcmFuc2Zvcm0pO1xuICAgIH0pO1xuICB9KTtcbn1cblxuXG4vKipcbiAqIENsZWFyIGFsbCBjYWNoZWQgcHJvamVjdGlvbnMgYW5kIHRyYW5zZm9ybXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhckFsbFByb2plY3Rpb25zKCkge1xuICBwcm9qZWN0aW9ucy5jbGVhcigpO1xuICBjbGVhclRyYW5zZm9ybUZ1bmNzKCk7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge1Byb2plY3Rpb258c3RyaW5nfHVuZGVmaW5lZH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IGRlZmF1bHRDb2RlIERlZmF1bHQgY29kZS5cbiAqIEByZXR1cm4ge1Byb2plY3Rpb259IFByb2plY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQcm9qZWN0aW9uKHByb2plY3Rpb24sIGRlZmF1bHRDb2RlKSB7XG4gIGlmICghcHJvamVjdGlvbikge1xuICAgIHJldHVybiBnZXQoZGVmYXVsdENvZGUpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9qZWN0aW9uID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBnZXQocHJvamVjdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcbiAgICAgIC8qKiBAdHlwZSB7UHJvamVjdGlvbn0gKi8gKHByb2plY3Rpb24pXG4gICAgKTtcbiAgfVxufVxuXG5cbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBtb2R1bGU6b2wvcHJvan5UcmFuc2Zvcm1GdW5jdGlvbn0gZnJvbSBhIHNpbXBsZSAyRCBjb29yZGluYXRlIHRyYW5zZm9ybVxuICogZnVuY3Rpb24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlKTogaW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkVHJhbnNmb3JtIENvb3JkaW5hdGVcbiAqICAgICB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJuIHtUcmFuc2Zvcm1GdW5jdGlvbn0gVHJhbnNmb3JtIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVHJhbnNmb3JtRnJvbUNvb3JkaW5hdGVUcmFuc2Zvcm0oY29vcmRUcmFuc2Zvcm0pIHtcbiAgcmV0dXJuIChcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGlucHV0IElucHV0LlxuICAgICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPj19IG9wdF9vdXRwdXQgT3V0cHV0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2RpbWVuc2lvbiBEaW1lbnNpb24uXG4gICAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gT3V0cHV0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uKGlucHV0LCBvcHRfb3V0cHV0LCBvcHRfZGltZW5zaW9uKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgICAgdmFyIGRpbWVuc2lvbiA9IG9wdF9kaW1lbnNpb24gIT09IHVuZGVmaW5lZCA/IG9wdF9kaW1lbnNpb24gOiAyO1xuICAgICAgdmFyIG91dHB1dCA9IG9wdF9vdXRwdXQgIT09IHVuZGVmaW5lZCA/IG9wdF9vdXRwdXQgOiBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IGRpbWVuc2lvbikge1xuICAgICAgICB2YXIgcG9pbnQgPSBjb29yZFRyYW5zZm9ybShbaW5wdXRbaV0sIGlucHV0W2kgKyAxXV0pO1xuICAgICAgICBvdXRwdXRbaV0gPSBwb2ludFswXTtcbiAgICAgICAgb3V0cHV0W2kgKyAxXSA9IHBvaW50WzFdO1xuICAgICAgICBmb3IgKHZhciBqID0gZGltZW5zaW9uIC0gMTsgaiA+PSAyOyAtLWopIHtcbiAgICAgICAgICBvdXRwdXRbaSArIGpdID0gaW5wdXRbaSArIGpdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0pO1xufVxuXG5cbi8qKlxuICogUmVnaXN0ZXJzIGNvb3JkaW5hdGUgdHJhbnNmb3JtIGZ1bmN0aW9ucyB0byBjb252ZXJ0IGNvb3JkaW5hdGVzIGJldHdlZW4gdGhlXG4gKiBzb3VyY2UgcHJvamVjdGlvbiBhbmQgdGhlIGRlc3RpbmF0aW9uIHByb2plY3Rpb24uXG4gKiBUaGUgZm9yd2FyZCBhbmQgaW52ZXJzZSBmdW5jdGlvbnMgY29udmVydCBjb29yZGluYXRlIHBhaXJzOyB0aGlzIGZ1bmN0aW9uXG4gKiBjb252ZXJ0cyB0aGVzZSBpbnRvIHRoZSBmdW5jdGlvbnMgdXNlZCBpbnRlcm5hbGx5IHdoaWNoIGFsc28gaGFuZGxlXG4gKiBleHRlbnRzIGFuZCBjb29yZGluYXRlIGFycmF5cy5cbiAqXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBzb3VyY2UgU291cmNlIHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBkZXN0aW5hdGlvbiBEZXN0aW5hdGlvbiBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbihpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZSk6IGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBmb3J3YXJkIFRoZSBmb3J3YXJkIHRyYW5zZm9ybVxuICogICAgIGZ1bmN0aW9uICh0aGF0IGlzLCBmcm9tIHRoZSBzb3VyY2UgcHJvamVjdGlvbiB0byB0aGUgZGVzdGluYXRpb25cbiAqICAgICBwcm9qZWN0aW9uKSB0aGF0IHRha2VzIGEge0BsaW5rIG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGFzIGFyZ3VtZW50IGFuZCByZXR1cm5zXG4gKiAgICAgdGhlIHRyYW5zZm9ybWVkIHtAbGluayBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGUpOiBpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gaW52ZXJzZSBUaGUgaW52ZXJzZSB0cmFuc2Zvcm1cbiAqICAgICBmdW5jdGlvbiAodGhhdCBpcywgZnJvbSB0aGUgZGVzdGluYXRpb24gcHJvamVjdGlvbiB0byB0aGUgc291cmNlXG4gKiAgICAgcHJvamVjdGlvbikgdGhhdCB0YWtlcyBhIHtAbGluayBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBhcyBhcmd1bWVudCBhbmQgcmV0dXJuc1xuICogICAgIHRoZSB0cmFuc2Zvcm1lZCB7QGxpbmsgbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0uXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRDb29yZGluYXRlVHJhbnNmb3Jtcyhzb3VyY2UsIGRlc3RpbmF0aW9uLCBmb3J3YXJkLCBpbnZlcnNlKSB7XG4gIHZhciBzb3VyY2VQcm9qID0gZ2V0KHNvdXJjZSk7XG4gIHZhciBkZXN0UHJvaiA9IGdldChkZXN0aW5hdGlvbik7XG4gIGFkZFRyYW5zZm9ybUZ1bmMoc291cmNlUHJvaiwgZGVzdFByb2osIGNyZWF0ZVRyYW5zZm9ybUZyb21Db29yZGluYXRlVHJhbnNmb3JtKGZvcndhcmQpKTtcbiAgYWRkVHJhbnNmb3JtRnVuYyhkZXN0UHJvaiwgc291cmNlUHJvaiwgY3JlYXRlVHJhbnNmb3JtRnJvbUNvb3JkaW5hdGVUcmFuc2Zvcm0oaW52ZXJzZSkpO1xufVxuXG5cbi8qKlxuICogVHJhbnNmb3JtcyBhIGNvb3JkaW5hdGUgZnJvbSBsb25naXR1ZGUvbGF0aXR1ZGUgdG8gYSBkaWZmZXJlbnQgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZSBhcyBsb25naXR1ZGUgYW5kIGxhdGl0dWRlLCBpLmUuXG4gKiAgICAgYW4gYXJyYXkgd2l0aCBsb25naXR1ZGUgYXMgMXN0IGFuZCBsYXRpdHVkZSBhcyAybmQgZWxlbWVudC5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2U9fSBvcHRfcHJvamVjdGlvbiBUYXJnZXQgcHJvamVjdGlvbi4gVGhlXG4gKiAgICAgZGVmYXVsdCBpcyBXZWIgTWVyY2F0b3IsIGkuZS4gJ0VQU0c6Mzg1NycuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gQ29vcmRpbmF0ZSBwcm9qZWN0ZWQgdG8gdGhlIHRhcmdldCBwcm9qZWN0aW9uLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUxvbkxhdChjb29yZGluYXRlLCBvcHRfcHJvamVjdGlvbikge1xuICByZXR1cm4gdHJhbnNmb3JtKGNvb3JkaW5hdGUsICdFUFNHOjQzMjYnLFxuICAgIG9wdF9wcm9qZWN0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRfcHJvamVjdGlvbiA6ICdFUFNHOjM4NTcnKTtcbn1cblxuXG4vKipcbiAqIFRyYW5zZm9ybXMgYSBjb29yZGluYXRlIHRvIGxvbmdpdHVkZS9sYXRpdHVkZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgUHJvamVjdGVkIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlPX0gb3B0X3Byb2plY3Rpb24gUHJvamVjdGlvbiBvZiB0aGUgY29vcmRpbmF0ZS5cbiAqICAgICBUaGUgZGVmYXVsdCBpcyBXZWIgTWVyY2F0b3IsIGkuZS4gJ0VQU0c6Mzg1NycuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gQ29vcmRpbmF0ZSBhcyBsb25naXR1ZGUgYW5kIGxhdGl0dWRlLCBpLmUuIGFuIGFycmF5XG4gKiAgICAgd2l0aCBsb25naXR1ZGUgYXMgMXN0IGFuZCBsYXRpdHVkZSBhcyAybmQgZWxlbWVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvTG9uTGF0KGNvb3JkaW5hdGUsIG9wdF9wcm9qZWN0aW9uKSB7XG4gIHZhciBsb25MYXQgPSB0cmFuc2Zvcm0oY29vcmRpbmF0ZSxcbiAgICBvcHRfcHJvamVjdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0X3Byb2plY3Rpb24gOiAnRVBTRzozODU3JywgJ0VQU0c6NDMyNicpO1xuICB2YXIgbG9uID0gbG9uTGF0WzBdO1xuICBpZiAobG9uIDwgLTE4MCB8fCBsb24gPiAxODApIHtcbiAgICBsb25MYXRbMF0gPSBtb2R1bG8obG9uICsgMTgwLCAzNjApIC0gMTgwO1xuICB9XG4gIHJldHVybiBsb25MYXQ7XG59XG5cblxuLyoqXG4gKiBDaGVja3MgaWYgdHdvIHByb2plY3Rpb25zIGFyZSB0aGUgc2FtZSwgdGhhdCBpcyBldmVyeSBjb29yZGluYXRlIGluIG9uZVxuICogcHJvamVjdGlvbiBkb2VzIHJlcHJlc2VudCB0aGUgc2FtZSBnZW9ncmFwaGljIHBvaW50IGFzIHRoZSBzYW1lIGNvb3JkaW5hdGUgaW5cbiAqIHRoZSBvdGhlciBwcm9qZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7UHJvamVjdGlvbn0gcHJvamVjdGlvbjEgUHJvamVjdGlvbiAxLlxuICogQHBhcmFtIHtQcm9qZWN0aW9ufSBwcm9qZWN0aW9uMiBQcm9qZWN0aW9uIDIuXG4gKiBAcmV0dXJuIHtib29sZWFufSBFcXVpdmFsZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1aXZhbGVudChwcm9qZWN0aW9uMSwgcHJvamVjdGlvbjIpIHtcbiAgaWYgKHByb2plY3Rpb24xID09PSBwcm9qZWN0aW9uMikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBlcXVhbFVuaXRzID0gcHJvamVjdGlvbjEuZ2V0VW5pdHMoKSA9PT0gcHJvamVjdGlvbjIuZ2V0VW5pdHMoKTtcbiAgaWYgKHByb2plY3Rpb24xLmdldENvZGUoKSA9PT0gcHJvamVjdGlvbjIuZ2V0Q29kZSgpKSB7XG4gICAgcmV0dXJuIGVxdWFsVW5pdHM7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRyYW5zZm9ybUZ1bmMgPSBnZXRUcmFuc2Zvcm1Gcm9tUHJvamVjdGlvbnMocHJvamVjdGlvbjEsIHByb2plY3Rpb24yKTtcbiAgICByZXR1cm4gdHJhbnNmb3JtRnVuYyA9PT0gY2xvbmVUcmFuc2Zvcm0gJiYgZXF1YWxVbml0cztcbiAgfVxufVxuXG5cbi8qKlxuICogU2VhcmNoZXMgaW4gdGhlIGxpc3Qgb2YgdHJhbnNmb3JtIGZ1bmN0aW9ucyBmb3IgdGhlIGZ1bmN0aW9uIGZvciBjb252ZXJ0aW5nXG4gKiBjb29yZGluYXRlcyBmcm9tIHRoZSBzb3VyY2UgcHJvamVjdGlvbiB0byB0aGUgZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1Byb2plY3Rpb259IHNvdXJjZVByb2plY3Rpb24gU291cmNlIFByb2plY3Rpb24gb2JqZWN0LlxuICogQHBhcmFtIHtQcm9qZWN0aW9ufSBkZXN0aW5hdGlvblByb2plY3Rpb24gRGVzdGluYXRpb24gUHJvamVjdGlvblxuICogICAgIG9iamVjdC5cbiAqIEByZXR1cm4ge1RyYW5zZm9ybUZ1bmN0aW9ufSBUcmFuc2Zvcm0gZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUcmFuc2Zvcm1Gcm9tUHJvamVjdGlvbnMoc291cmNlUHJvamVjdGlvbiwgZGVzdGluYXRpb25Qcm9qZWN0aW9uKSB7XG4gIHZhciBzb3VyY2VDb2RlID0gc291cmNlUHJvamVjdGlvbi5nZXRDb2RlKCk7XG4gIHZhciBkZXN0aW5hdGlvbkNvZGUgPSBkZXN0aW5hdGlvblByb2plY3Rpb24uZ2V0Q29kZSgpO1xuICB2YXIgdHJhbnNmb3JtRnVuYyA9IGdldFRyYW5zZm9ybUZ1bmMoc291cmNlQ29kZSwgZGVzdGluYXRpb25Db2RlKTtcbiAgaWYgKCF0cmFuc2Zvcm1GdW5jKSB7XG4gICAgdHJhbnNmb3JtRnVuYyA9IGlkZW50aXR5VHJhbnNmb3JtO1xuICB9XG4gIHJldHVybiB0cmFuc2Zvcm1GdW5jO1xufVxuXG5cbi8qKlxuICogR2l2ZW4gdGhlIHByb2plY3Rpb24tbGlrZSBvYmplY3RzLCBzZWFyY2hlcyBmb3IgYSB0cmFuc2Zvcm1hdGlvblxuICogZnVuY3Rpb24gdG8gY29udmVydCBhIGNvb3JkaW5hdGVzIGFycmF5IGZyb20gdGhlIHNvdXJjZSBwcm9qZWN0aW9uIHRvIHRoZVxuICogZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBzb3VyY2UgU291cmNlLlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gZGVzdGluYXRpb24gRGVzdGluYXRpb24uXG4gKiBAcmV0dXJuIHtUcmFuc2Zvcm1GdW5jdGlvbn0gVHJhbnNmb3JtIGZ1bmN0aW9uLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHJhbnNmb3JtKHNvdXJjZSwgZGVzdGluYXRpb24pIHtcbiAgdmFyIHNvdXJjZVByb2plY3Rpb24gPSBnZXQoc291cmNlKTtcbiAgdmFyIGRlc3RpbmF0aW9uUHJvamVjdGlvbiA9IGdldChkZXN0aW5hdGlvbik7XG4gIHJldHVybiBnZXRUcmFuc2Zvcm1Gcm9tUHJvamVjdGlvbnMoc291cmNlUHJvamVjdGlvbiwgZGVzdGluYXRpb25Qcm9qZWN0aW9uKTtcbn1cblxuXG4vKipcbiAqIFRyYW5zZm9ybXMgYSBjb29yZGluYXRlIGZyb20gc291cmNlIHByb2plY3Rpb24gdG8gZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIFRoaXMgcmV0dXJucyBhIG5ldyBjb29yZGluYXRlIChhbmQgZG9lcyBub3QgbW9kaWZ5IHRoZSBvcmlnaW5hbCkuXG4gKlxuICogU2VlIHtAbGluayBtb2R1bGU6b2wvcHJvan50cmFuc2Zvcm1FeHRlbnR9IGZvciBleHRlbnQgdHJhbnNmb3JtYXRpb24uXG4gKiBTZWUgdGhlIHRyYW5zZm9ybSBtZXRob2Qgb2Yge0BsaW5rIG1vZHVsZTpvbC9nZW9tL0dlb21ldHJ5fkdlb21ldHJ5fSBhbmQgaXRzXG4gKiBzdWJjbGFzc2VzIGZvciBnZW9tZXRyeSB0cmFuc2Zvcm1zLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2V9IHNvdXJjZSBTb3VyY2UgcHJvamVjdGlvbi1saWtlLlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gZGVzdGluYXRpb24gRGVzdGluYXRpb24gcHJvamVjdGlvbi1saWtlLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IENvb3JkaW5hdGUuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm0oY29vcmRpbmF0ZSwgc291cmNlLCBkZXN0aW5hdGlvbikge1xuICB2YXIgdHJhbnNmb3JtRnVuYyA9IGdldFRyYW5zZm9ybShzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgcmV0dXJuIHRyYW5zZm9ybUZ1bmMoY29vcmRpbmF0ZSwgdW5kZWZpbmVkLCBjb29yZGluYXRlLmxlbmd0aCk7XG59XG5cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIGFuIGV4dGVudCBmcm9tIHNvdXJjZSBwcm9qZWN0aW9uIHRvIGRlc3RpbmF0aW9uIHByb2plY3Rpb24uICBUaGlzXG4gKiByZXR1cm5zIGEgbmV3IGV4dGVudCAoYW5kIGRvZXMgbm90IG1vZGlmeSB0aGUgb3JpZ2luYWwpLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgVGhlIGV4dGVudCB0byB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBzb3VyY2UgU291cmNlIHByb2plY3Rpb24tbGlrZS5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2V9IGRlc3RpbmF0aW9uIERlc3RpbmF0aW9uIHByb2plY3Rpb24tbGlrZS5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gVGhlIHRyYW5zZm9ybWVkIGV4dGVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybUV4dGVudChleHRlbnQsIHNvdXJjZSwgZGVzdGluYXRpb24pIHtcbiAgdmFyIHRyYW5zZm9ybUZ1bmMgPSBnZXRUcmFuc2Zvcm0oc291cmNlLCBkZXN0aW5hdGlvbik7XG4gIHJldHVybiBhcHBseVRyYW5zZm9ybShleHRlbnQsIHRyYW5zZm9ybUZ1bmMpO1xufVxuXG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgZ2l2ZW4gcG9pbnQgdG8gdGhlIGRlc3RpbmF0aW9uIHByb2plY3Rpb24uXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gcG9pbnQgUG9pbnQuXG4gKiBAcGFyYW0ge1Byb2plY3Rpb259IHNvdXJjZVByb2plY3Rpb24gU291cmNlIHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge1Byb2plY3Rpb259IGRlc3RpbmF0aW9uUHJvamVjdGlvbiBEZXN0aW5hdGlvbiBwcm9qZWN0aW9uLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFBvaW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtV2l0aFByb2plY3Rpb25zKHBvaW50LCBzb3VyY2VQcm9qZWN0aW9uLCBkZXN0aW5hdGlvblByb2plY3Rpb24pIHtcbiAgdmFyIHRyYW5zZm9ybUZ1bmMgPSBnZXRUcmFuc2Zvcm1Gcm9tUHJvamVjdGlvbnMoc291cmNlUHJvamVjdGlvbiwgZGVzdGluYXRpb25Qcm9qZWN0aW9uKTtcbiAgcmV0dXJuIHRyYW5zZm9ybUZ1bmMocG9pbnQpO1xufVxuXG4vKipcbiAqIEFkZCB0cmFuc2Zvcm1zIHRvIGFuZCBmcm9tIEVQU0c6NDMyNiBhbmQgRVBTRzozODU3LiAgVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWRcbiAqIGJ5IHdoZW4gdGhpcyBtb2R1bGUgaXMgZXhlY3V0ZWQgYW5kIHNob3VsZCBvbmx5IG5lZWQgdG8gYmUgY2FsbGVkIGFnYWluIGFmdGVyXG4gKiBgY2xlYXJBbGxQcm9qZWN0aW9ucygpYCBpcyBjYWxsZWQgKGUuZy4gaW4gdGVzdHMpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkQ29tbW9uKCkge1xuICAvLyBBZGQgdHJhbnNmb3JtYXRpb25zIHRoYXQgZG9uJ3QgYWx0ZXIgY29vcmRpbmF0ZXMgdG8gY29udmVydCB3aXRoaW4gc2V0IG9mXG4gIC8vIHByb2plY3Rpb25zIHdpdGggZXF1YWwgbWVhbmluZy5cbiAgYWRkRXF1aXZhbGVudFByb2plY3Rpb25zKEVQU0czODU3X1BST0pFQ1RJT05TKTtcbiAgYWRkRXF1aXZhbGVudFByb2plY3Rpb25zKEVQU0c0MzI2X1BST0pFQ1RJT05TKTtcbiAgLy8gQWRkIHRyYW5zZm9ybWF0aW9ucyB0byBjb252ZXJ0IEVQU0c6NDMyNiBsaWtlIGNvb3JkaW5hdGVzIHRvIEVQU0c6Mzg1NyBsaWtlXG4gIC8vIGNvb3JkaW5hdGVzIGFuZCBiYWNrLlxuICBhZGRFcXVpdmFsZW50VHJhbnNmb3JtcyhFUFNHNDMyNl9QUk9KRUNUSU9OUywgRVBTRzM4NTdfUFJPSkVDVElPTlMsIGZyb21FUFNHNDMyNiwgdG9FUFNHNDMyNik7XG59XG5cbmFkZENvbW1vbigpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9qLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9wcm9qL1Byb2plY3Rpb25cbiAqL1xuaW1wb3J0IHtNRVRFUlNfUEVSX1VOSVR9IGZyb20gJy4vVW5pdHMuanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IGNvZGUgVGhlIFNSUyBpZGVudGlmaWVyIGNvZGUsIGUuZy4gYEVQU0c6NDMyNmAuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vVW5pdHMuanNcIikuZGVmYXVsdHxzdHJpbmd9IFt1bml0c10gVW5pdHMuIFJlcXVpcmVkIHVubGVzcyBhXG4gKiBwcm9qNCBwcm9qZWN0aW9uIGlzIGRlZmluZWQgZm9yIGBjb2RlYC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW2V4dGVudF0gVGhlIHZhbGlkaXR5IGV4dGVudCBmb3IgdGhlIFNSUy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYXhpc09yaWVudGF0aW9uPSdlbnUnXSBUaGUgYXhpcyBvcmllbnRhdGlvbiBhcyBzcGVjaWZpZWQgaW4gUHJvajQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtnbG9iYWw9ZmFsc2VdIFdoZXRoZXIgdGhlIHByb2plY3Rpb24gaXMgdmFsaWQgZm9yIHRoZSB3aG9sZSBnbG9iZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWV0ZXJzUGVyVW5pdF0gVGhlIG1ldGVycyBwZXIgdW5pdCBmb3IgdGhlIFNSUy5cbiAqIElmIG5vdCBwcm92aWRlZCwgdGhlIGB1bml0c2AgYXJlIHVzZWQgdG8gZ2V0IHRoZSBtZXRlcnMgcGVyIHVuaXQgZnJvbSB0aGUge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1VuaXRzfk1FVEVSU19QRVJfVU5JVH1cbiAqIGxvb2t1cCB0YWJsZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW3dvcmxkRXh0ZW50XSBUaGUgd29ybGQgZXh0ZW50IGZvciB0aGUgU1JTLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbihudW1iZXIsIGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZSk6bnVtYmVyfSBbZ2V0UG9pbnRSZXNvbHV0aW9uXVxuICogRnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHJlc29sdXRpb24gYXQgYSBwb2ludC4gVGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGFcbiAqIGB7bnVtYmVyfWAgdmlldyByZXNvbHV0aW9uIGFuZCBhbiBge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX1gIGFzIGFyZ3VtZW50cywgYW5kIHJldHVybnNcbiAqIHRoZSBge251bWJlcn1gIHJlc29sdXRpb24gYXQgdGhlIHBhc3NlZCBjb29yZGluYXRlLiBJZiB0aGlzIGlzIGB1bmRlZmluZWRgLFxuICogdGhlIGRlZmF1bHQge0BsaW5rIG1vZHVsZTpvbC9wcm9qI2dldFBvaW50UmVzb2x1dGlvbn0gZnVuY3Rpb24gd2lsbCBiZSB1c2VkLlxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBQcm9qZWN0aW9uIGRlZmluaXRpb24gY2xhc3MuIE9uZSBvZiB0aGVzZSBpcyBjcmVhdGVkIGZvciBlYWNoIHByb2plY3Rpb25cbiAqIHN1cHBvcnRlZCBpbiB0aGUgYXBwbGljYXRpb24gYW5kIHN0b3JlZCBpbiB0aGUge0BsaW5rIG1vZHVsZTpvbC9wcm9qfSBuYW1lc3BhY2UuXG4gKiBZb3UgY2FuIHVzZSB0aGVzZSBpbiBhcHBsaWNhdGlvbnMsIGJ1dCB0aGlzIGlzIG5vdCByZXF1aXJlZCwgYXMgQVBJIHBhcmFtc1xuICogYW5kIG9wdGlvbnMgdXNlIHtAbGluayBtb2R1bGU6b2wvcHJvan5Qcm9qZWN0aW9uTGlrZX0gd2hpY2ggbWVhbnMgdGhlIHNpbXBsZSBzdHJpbmdcbiAqIGNvZGUgd2lsbCBzdWZmaWNlLlxuICpcbiAqIFlvdSBjYW4gdXNlIHtAbGluayBtb2R1bGU6b2wvcHJvan5nZXR9IHRvIHJldHJpZXZlIHRoZSBvYmplY3QgZm9yIGEgcGFydGljdWxhclxuICogcHJvamVjdGlvbi5cbiAqXG4gKiBUaGUgbGlicmFyeSBpbmNsdWRlcyBkZWZpbml0aW9ucyBmb3IgYEVQU0c6NDMyNmAgYW5kIGBFUFNHOjM4NTdgLCB0b2dldGhlclxuICogd2l0aCB0aGUgZm9sbG93aW5nIGFsaWFzZXM6XG4gKiAqIGBFUFNHOjQzMjZgOiBDUlM6ODQsIHVybjpvZ2M6ZGVmOmNyczpFUFNHOjYuNjo0MzI2LFxuICogICAgIHVybjpvZ2M6ZGVmOmNyczpPR0M6MS4zOkNSUzg0LCB1cm46b2djOmRlZjpjcnM6T0dDOjI6ODQsXG4gKiAgICAgaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwvc3JzL2Vwc2cueG1sIzQzMjYsXG4gKiAgICAgdXJuOngtb2djOmRlZjpjcnM6RVBTRzo0MzI2XG4gKiAqIGBFUFNHOjM4NTdgOiBFUFNHOjEwMjEwMCwgRVBTRzoxMDIxMTMsIEVQU0c6OTAwOTEzLFxuICogICAgIHVybjpvZ2M6ZGVmOmNyczpFUFNHOjYuMTg6MzozODU3LFxuICogICAgIGh0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sL3Nycy9lcHNnLnhtbCMzODU3XG4gKlxuICogSWYgeW91IHVzZSBbcHJvajRqc10oaHR0cHM6Ly9naXRodWIuY29tL3Byb2o0anMvcHJvajRqcyksIGFsaWFzZXMgY2FuXG4gKiBiZSBhZGRlZCB1c2luZyBgcHJvajQuZGVmcygpYC4gQWZ0ZXIgYWxsIHJlcXVpcmVkIHByb2plY3Rpb24gZGVmaW5pdGlvbnMgYXJlXG4gKiBhZGRlZCwgY2FsbCB0aGUge0BsaW5rIG1vZHVsZTpvbC9wcm9qL3Byb2o0fnJlZ2lzdGVyfSBmdW5jdGlvbi5cbiAqXG4gKiBAYXBpXG4gKi9cbnZhciBQcm9qZWN0aW9uID0gZnVuY3Rpb24gUHJvamVjdGlvbihvcHRpb25zKSB7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGhpcy5jb2RlXyA9IG9wdGlvbnMuY29kZTtcblxuICAvKipcbiAgICogVW5pdHMgb2YgcHJvamVjdGVkIGNvb3JkaW5hdGVzLiBXaGVuIHNldCB0byBgVElMRV9QSVhFTFNgLCBhXG4gICAqIGB0aGlzLmV4dGVudF9gIGFuZCBgdGhpcy53b3JsZEV4dGVudF9gIG11c3QgYmUgY29uZmlndXJlZCBwcm9wZXJseSBmb3IgZWFjaFxuICAgKiB0aWxlLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9Vbml0cy5qc1wiKS5kZWZhdWx0fVxuICAgKi9cbiAgdGhpcy51bml0c18gPSAvKiogQHR5cGUge2ltcG9ydChcIi4vVW5pdHMuanNcIikuZGVmYXVsdH0gKi8gKG9wdGlvbnMudW5pdHMpO1xuXG4gIC8qKlxuICAgKiBWYWxpZGl0eSBleHRlbnQgb2YgdGhlIHByb2plY3Rpb24gaW4gcHJvamVjdGVkIGNvb3JkaW5hdGVzLiBGb3IgcHJvamVjdGlvbnNcbiAgICogd2l0aCBgVElMRV9QSVhFTFNgIHVuaXRzLCB0aGlzIGlzIHRoZSBleHRlbnQgb2YgdGhlIHRpbGUgaW5cbiAgICogdGlsZSBwaXhlbCBzcGFjZS5cbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gICAqL1xuICB0aGlzLmV4dGVudF8gPSBvcHRpb25zLmV4dGVudCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5leHRlbnQgOiBudWxsO1xuXG4gIC8qKlxuICAgKiBFeHRlbnQgb2YgdGhlIHdvcmxkIGluIEVQU0c6NDMyNi4gRm9yIHByb2plY3Rpb25zIHdpdGhcbiAgICogYFRJTEVfUElYRUxTYCB1bml0cywgdGhpcyBpcyB0aGUgZXh0ZW50IG9mIHRoZSB0aWxlIGluXG4gICAqIHByb2plY3RlZCBjb29yZGluYXRlIHNwYWNlLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAgICovXG4gIHRoaXMud29ybGRFeHRlbnRfID0gb3B0aW9ucy53b3JsZEV4dGVudCAhPT0gdW5kZWZpbmVkID9cbiAgICBvcHRpb25zLndvcmxkRXh0ZW50IDogbnVsbDtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRoaXMuYXhpc09yaWVudGF0aW9uXyA9IG9wdGlvbnMuYXhpc09yaWVudGF0aW9uICE9PSB1bmRlZmluZWQgP1xuICAgIG9wdGlvbnMuYXhpc09yaWVudGF0aW9uIDogJ2VudSc7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgdGhpcy5nbG9iYWxfID0gb3B0aW9ucy5nbG9iYWwgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZ2xvYmFsIDogZmFsc2U7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgdGhpcy5jYW5XcmFwWF8gPSAhISh0aGlzLmdsb2JhbF8gJiYgdGhpcy5leHRlbnRfKTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlciwgaW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlKTpudW1iZXJ8dW5kZWZpbmVkfVxuICAgKi9cbiAgdGhpcy5nZXRQb2ludFJlc29sdXRpb25GdW5jXyA9IG9wdGlvbnMuZ2V0UG9pbnRSZXNvbHV0aW9uO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH1cbiAgICovXG4gIHRoaXMuZGVmYXVsdFRpbGVHcmlkXyA9IG51bGw7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgKi9cbiAgdGhpcy5tZXRlcnNQZXJVbml0XyA9IG9wdGlvbnMubWV0ZXJzUGVyVW5pdDtcbn07XG5cbi8qKlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHByb2plY3Rpb24gaXMgc3VpdGFibGUgZm9yIHdyYXBwaW5nIHRoZSB4LWF4aXNcbiAqL1xuUHJvamVjdGlvbi5wcm90b3R5cGUuY2FuV3JhcFggPSBmdW5jdGlvbiBjYW5XcmFwWCAoKSB7XG4gIHJldHVybiB0aGlzLmNhbldyYXBYXztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjb2RlIGZvciB0aGlzIHByb2plY3Rpb24sIGUuZy4gJ0VQU0c6NDMyNicuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IENvZGUuXG4gKiBAYXBpXG4gKi9cblByb2plY3Rpb24ucHJvdG90eXBlLmdldENvZGUgPSBmdW5jdGlvbiBnZXRDb2RlICgpIHtcbiAgcmV0dXJuIHRoaXMuY29kZV87XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdmFsaWRpdHkgZXh0ZW50IGZvciB0aGlzIHByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBFeHRlbnQuXG4gKiBAYXBpXG4gKi9cblByb2plY3Rpb24ucHJvdG90eXBlLmdldEV4dGVudCA9IGZ1bmN0aW9uIGdldEV4dGVudCAoKSB7XG4gIHJldHVybiB0aGlzLmV4dGVudF87XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdW5pdHMgb2YgdGhpcyBwcm9qZWN0aW9uLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9Vbml0cy5qc1wiKS5kZWZhdWx0fSBVbml0cy5cbiAqIEBhcGlcbiAqL1xuUHJvamVjdGlvbi5wcm90b3R5cGUuZ2V0VW5pdHMgPSBmdW5jdGlvbiBnZXRVbml0cyAoKSB7XG4gIHJldHVybiB0aGlzLnVuaXRzXztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBhbW91bnQgb2YgbWV0ZXJzIHBlciB1bml0IG9mIHRoaXMgcHJvamVjdGlvbi5JZiB0aGUgcHJvamVjdGlvbiBpc1xuICogbm90IGNvbmZpZ3VyZWQgd2l0aCBgbWV0ZXJzUGVyVW5pdGAgb3IgYSB1bml0cyBpZGVudGlmaWVyLCB0aGUgcmV0dXJuIGlzXG4gKiBgdW5kZWZpbmVkYC5cbiAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IE1ldGVycy5cbiAqIEBhcGlcbiAqL1xuUHJvamVjdGlvbi5wcm90b3R5cGUuZ2V0TWV0ZXJzUGVyVW5pdCA9IGZ1bmN0aW9uIGdldE1ldGVyc1BlclVuaXQgKCkge1xuICByZXR1cm4gdGhpcy5tZXRlcnNQZXJVbml0XyB8fCBNRVRFUlNfUEVSX1VOSVRbdGhpcy51bml0c19dO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHdvcmxkIGV4dGVudCBmb3IgdGhpcyBwcm9qZWN0aW9uLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gRXh0ZW50LlxuICogQGFwaVxuICovXG5Qcm9qZWN0aW9uLnByb3RvdHlwZS5nZXRXb3JsZEV4dGVudCA9IGZ1bmN0aW9uIGdldFdvcmxkRXh0ZW50ICgpIHtcbiAgcmV0dXJuIHRoaXMud29ybGRFeHRlbnRfO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGF4aXMgb3JpZW50YXRpb24gb2YgdGhpcyBwcm9qZWN0aW9uLlxuICogRXhhbXBsZSB2YWx1ZXMgYXJlOlxuICogZW51IC0gdGhlIGRlZmF1bHQgZWFzdGluZywgbm9ydGhpbmcsIGVsZXZhdGlvbi5cbiAqIG5ldSAtIG5vcnRoaW5nLCBlYXN0aW5nLCB1cCAtIHVzZWZ1bCBmb3IgXCJsYXQvbG9uZ1wiIGdlb2dyYXBoaWMgY29vcmRpbmF0ZXMsXG4gKiAgIG9yIHNvdXRoIG9yaWVudGF0ZWQgdHJhbnN2ZXJzZSBtZXJjYXRvci5cbiAqIHdudSAtIHdlc3RpbmcsIG5vcnRoaW5nLCB1cCAtIHNvbWUgcGxhbmV0YXJ5IGNvb3JkaW5hdGUgc3lzdGVtcyBoYXZlXG4gKiAgIFwid2VzdCBwb3NpdGl2ZVwiIGNvb3JkaW5hdGUgc3lzdGVtc1xuICogQHJldHVybiB7c3RyaW5nfSBBeGlzIG9yaWVudGF0aW9uLlxuICogQGFwaVxuICovXG5Qcm9qZWN0aW9uLnByb3RvdHlwZS5nZXRBeGlzT3JpZW50YXRpb24gPSBmdW5jdGlvbiBnZXRBeGlzT3JpZW50YXRpb24gKCkge1xuICByZXR1cm4gdGhpcy5heGlzT3JpZW50YXRpb25fO1xufTtcblxuLyoqXG4gKiBJcyB0aGlzIHByb2plY3Rpb24gYSBnbG9iYWwgcHJvamVjdGlvbiB3aGljaCBzcGFucyB0aGUgd2hvbGUgd29ybGQ/XG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwcm9qZWN0aW9uIGlzIGdsb2JhbC5cbiAqIEBhcGlcbiAqL1xuUHJvamVjdGlvbi5wcm90b3R5cGUuaXNHbG9iYWwgPSBmdW5jdGlvbiBpc0dsb2JhbCAoKSB7XG4gIHJldHVybiB0aGlzLmdsb2JhbF87XG59O1xuXG4vKipcbiAqIFNldCBpZiB0aGUgcHJvamVjdGlvbiBpcyBhIGdsb2JhbCBwcm9qZWN0aW9uIHdoaWNoIHNwYW5zIHRoZSB3aG9sZSB3b3JsZFxuICogQHBhcmFtIHtib29sZWFufSBnbG9iYWwgV2hldGhlciB0aGUgcHJvamVjdGlvbiBpcyBnbG9iYWwuXG4gKiBAYXBpXG4gKi9cblByb2plY3Rpb24ucHJvdG90eXBlLnNldEdsb2JhbCA9IGZ1bmN0aW9uIHNldEdsb2JhbCAoZ2xvYmFsKSB7XG4gIHRoaXMuZ2xvYmFsXyA9IGdsb2JhbDtcbiAgdGhpcy5jYW5XcmFwWF8gPSAhIShnbG9iYWwgJiYgdGhpcy5leHRlbnRfKTtcbn07XG5cbi8qKlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH0gVGhlIGRlZmF1bHQgdGlsZSBncmlkLlxuICovXG5Qcm9qZWN0aW9uLnByb3RvdHlwZS5nZXREZWZhdWx0VGlsZUdyaWQgPSBmdW5jdGlvbiBnZXREZWZhdWx0VGlsZUdyaWQgKCkge1xuICByZXR1cm4gdGhpcy5kZWZhdWx0VGlsZUdyaWRfO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9IHRpbGVHcmlkIFRoZSBkZWZhdWx0IHRpbGUgZ3JpZC5cbiAqL1xuUHJvamVjdGlvbi5wcm90b3R5cGUuc2V0RGVmYXVsdFRpbGVHcmlkID0gZnVuY3Rpb24gc2V0RGVmYXVsdFRpbGVHcmlkICh0aWxlR3JpZCkge1xuICB0aGlzLmRlZmF1bHRUaWxlR3JpZF8gPSB0aWxlR3JpZDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSB2YWxpZGl0eSBleHRlbnQgZm9yIHRoaXMgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBhcGlcbiAqL1xuUHJvamVjdGlvbi5wcm90b3R5cGUuc2V0RXh0ZW50ID0gZnVuY3Rpb24gc2V0RXh0ZW50IChleHRlbnQpIHtcbiAgdGhpcy5leHRlbnRfID0gZXh0ZW50O1xuICB0aGlzLmNhbldyYXBYXyA9ICEhKHRoaXMuZ2xvYmFsXyAmJiBleHRlbnQpO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHdvcmxkIGV4dGVudCBmb3IgdGhpcyBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSB3b3JsZEV4dGVudCBXb3JsZCBleHRlbnRcbiAqICAgW21pbmxvbiwgbWlubGF0LCBtYXhsb24sIG1heGxhdF0uXG4gKiBAYXBpXG4gKi9cblByb2plY3Rpb24ucHJvdG90eXBlLnNldFdvcmxkRXh0ZW50ID0gZnVuY3Rpb24gc2V0V29ybGRFeHRlbnQgKHdvcmxkRXh0ZW50KSB7XG4gIHRoaXMud29ybGRFeHRlbnRfID0gd29ybGRFeHRlbnQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgZ2V0UG9pbnRSZXNvbHV0aW9uIGZ1bmN0aW9uIChzZWUge0BsaW5rIG1vZHVsZTpvbC9wcm9qfmdldFBvaW50UmVzb2x1dGlvbn1cbiAqIGZvciB0aGlzIHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlciwgaW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlKTpudW1iZXJ9IGZ1bmMgRnVuY3Rpb25cbiAqIEBhcGlcbiAqL1xuUHJvamVjdGlvbi5wcm90b3R5cGUuc2V0R2V0UG9pbnRSZXNvbHV0aW9uID0gZnVuY3Rpb24gc2V0R2V0UG9pbnRSZXNvbHV0aW9uIChmdW5jKSB7XG4gIHRoaXMuZ2V0UG9pbnRSZXNvbHV0aW9uRnVuY18gPSBmdW5jO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGN1c3RvbSBwb2ludCByZXNvbHV0aW9uIGZ1bmN0aW9uIGZvciB0aGlzIHByb2plY3Rpb24gKGlmIHNldCkuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbihudW1iZXIsIGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZSk6bnVtYmVyfHVuZGVmaW5lZH0gVGhlIGN1c3RvbSBwb2ludFxuICogcmVzb2x1dGlvbiBmdW5jdGlvbiAoaWYgc2V0KS5cbiAqL1xuUHJvamVjdGlvbi5wcm90b3R5cGUuZ2V0UG9pbnRSZXNvbHV0aW9uRnVuYyA9IGZ1bmN0aW9uIGdldFBvaW50UmVzb2x1dGlvbkZ1bmMgKCkge1xuICByZXR1cm4gdGhpcy5nZXRQb2ludFJlc29sdXRpb25GdW5jXztcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFByb2plY3Rpb247XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVByb2plY3Rpb24uanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3Byb2ovVW5pdHNcbiAqL1xuXG4vKipcbiAqIFByb2plY3Rpb24gdW5pdHM6IGAnZGVncmVlcydgLCBgJ2Z0J2AsIGAnbSdgLCBgJ3BpeGVscydgLCBgJ3RpbGUtcGl4ZWxzJ2Agb3JcbiAqIGAndXMtZnQnYC5cbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbnZhciBVbml0cyA9IHtcbiAgREVHUkVFUzogJ2RlZ3JlZXMnLFxuICBGRUVUOiAnZnQnLFxuICBNRVRFUlM6ICdtJyxcbiAgUElYRUxTOiAncGl4ZWxzJyxcbiAgVElMRV9QSVhFTFM6ICd0aWxlLXBpeGVscycsXG4gIFVTRkVFVDogJ3VzLWZ0J1xufTtcblxuXG4vKipcbiAqIE1ldGVycyBwZXIgdW5pdCBsb29rdXAgdGFibGUuXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8VW5pdHMsIG51bWJlcj59XG4gKiBAYXBpXG4gKi9cbmV4cG9ydCB2YXIgTUVURVJTX1BFUl9VTklUID0ge307XG4vLyB1c2UgdGhlIHJhZGl1cyBvZiB0aGUgTm9ybWFsIHNwaGVyZVxuTUVURVJTX1BFUl9VTklUW1VuaXRzLkRFR1JFRVNdID0gMiAqIE1hdGguUEkgKiA2MzcwOTk3IC8gMzYwO1xuTUVURVJTX1BFUl9VTklUW1VuaXRzLkZFRVRdID0gMC4zMDQ4O1xuTUVURVJTX1BFUl9VTklUW1VuaXRzLk1FVEVSU10gPSAxO1xuTUVURVJTX1BFUl9VTklUW1VuaXRzLlVTRkVFVF0gPSAxMjAwIC8gMzkzNztcblxuZXhwb3J0IGRlZmF1bHQgVW5pdHM7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVVuaXRzLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9wcm9qL2Vwc2czODU3XG4gKi9cbmltcG9ydCB7Y29zaH0gZnJvbSAnLi4vbWF0aC5qcyc7XG5pbXBvcnQgUHJvamVjdGlvbiBmcm9tICcuL1Byb2plY3Rpb24uanMnO1xuaW1wb3J0IFVuaXRzIGZyb20gJy4vVW5pdHMuanMnO1xuXG5cbi8qKlxuICogUmFkaXVzIG9mIFdHUzg0IHNwaGVyZVxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBSQURJVVMgPSA2Mzc4MTM3O1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIEhBTEZfU0laRSA9IE1hdGguUEkgKiBSQURJVVM7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICovXG5leHBvcnQgdmFyIEVYVEVOVCA9IFtcbiAgLUhBTEZfU0laRSwgLUhBTEZfU0laRSxcbiAgSEFMRl9TSVpFLCBIQUxGX1NJWkVcbl07XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICovXG5leHBvcnQgdmFyIFdPUkxEX0VYVEVOVCA9IFstMTgwLCAtODUsIDE4MCwgODVdO1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogUHJvamVjdGlvbiBvYmplY3QgZm9yIHdlYi9zcGhlcmljYWwgTWVyY2F0b3IgKEVQU0c6Mzg1NykuXG4gKi9cbnZhciBFUFNHMzg1N1Byb2plY3Rpb24gPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChQcm9qZWN0aW9uKSB7XG4gIGZ1bmN0aW9uIEVQU0czODU3UHJvamVjdGlvbihjb2RlKSB7XG4gICAgUHJvamVjdGlvbi5jYWxsKHRoaXMsIHtcbiAgICAgIGNvZGU6IGNvZGUsXG4gICAgICB1bml0czogVW5pdHMuTUVURVJTLFxuICAgICAgZXh0ZW50OiBFWFRFTlQsXG4gICAgICBnbG9iYWw6IHRydWUsXG4gICAgICB3b3JsZEV4dGVudDogV09STERfRVhURU5ULFxuICAgICAgZ2V0UG9pbnRSZXNvbHV0aW9uOiBmdW5jdGlvbihyZXNvbHV0aW9uLCBwb2ludCkge1xuICAgICAgICByZXR1cm4gcmVzb2x1dGlvbiAvIGNvc2gocG9pbnRbMV0gLyBSQURJVVMpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gIH1cblxuICBpZiAoIFByb2plY3Rpb24gKSBFUFNHMzg1N1Byb2plY3Rpb24uX19wcm90b19fID0gUHJvamVjdGlvbjtcbiAgRVBTRzM4NTdQcm9qZWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFByb2plY3Rpb24gJiYgUHJvamVjdGlvbi5wcm90b3R5cGUgKTtcbiAgRVBTRzM4NTdQcm9qZWN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEVQU0czODU3UHJvamVjdGlvbjtcblxuICByZXR1cm4gRVBTRzM4NTdQcm9qZWN0aW9uO1xufShQcm9qZWN0aW9uKSk7XG5cblxuLyoqXG4gKiBQcm9qZWN0aW9ucyBlcXVhbCB0byBFUFNHOjM4NTcuXG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHQ+fVxuICovXG5leHBvcnQgdmFyIFBST0pFQ1RJT05TID0gW1xuICBuZXcgRVBTRzM4NTdQcm9qZWN0aW9uKCdFUFNHOjM4NTcnKSxcbiAgbmV3IEVQU0czODU3UHJvamVjdGlvbignRVBTRzoxMDIxMDAnKSxcbiAgbmV3IEVQU0czODU3UHJvamVjdGlvbignRVBTRzoxMDIxMTMnKSxcbiAgbmV3IEVQU0czODU3UHJvamVjdGlvbignRVBTRzo5MDA5MTMnKSxcbiAgbmV3IEVQU0czODU3UHJvamVjdGlvbigndXJuOm9nYzpkZWY6Y3JzOkVQU0c6Ni4xODozOjM4NTcnKSxcbiAgbmV3IEVQU0czODU3UHJvamVjdGlvbigndXJuOm9nYzpkZWY6Y3JzOkVQU0c6OjM4NTcnKSxcbiAgbmV3IEVQU0czODU3UHJvamVjdGlvbignaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwvc3JzL2Vwc2cueG1sIzM4NTcnKVxuXTtcblxuXG4vKipcbiAqIFRyYW5zZm9ybWF0aW9uIGZyb20gRVBTRzo0MzI2IHRvIEVQU0c6Mzg1Ny5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGlucHV0IElucHV0IGFycmF5IG9mIGNvb3JkaW5hdGUgdmFsdWVzLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+PX0gb3B0X291dHB1dCBPdXRwdXQgYXJyYXkgb2YgY29vcmRpbmF0ZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9kaW1lbnNpb24gRGltZW5zaW9uIChkZWZhdWx0IGlzIGAyYCkuXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBPdXRwdXQgYXJyYXkgb2YgY29vcmRpbmF0ZSB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tRVBTRzQzMjYoaW5wdXQsIG9wdF9vdXRwdXQsIG9wdF9kaW1lbnNpb24pIHtcbiAgdmFyIGxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgdmFyIGRpbWVuc2lvbiA9IG9wdF9kaW1lbnNpb24gPiAxID8gb3B0X2RpbWVuc2lvbiA6IDI7XG4gIHZhciBvdXRwdXQgPSBvcHRfb3V0cHV0O1xuICBpZiAob3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoZGltZW5zaW9uID4gMikge1xuICAgICAgLy8gcHJlc2VydmUgdmFsdWVzIGJleW9uZCBzZWNvbmQgZGltZW5zaW9uXG4gICAgICBvdXRwdXQgPSBpbnB1dC5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICB9XG4gIH1cbiAgdmFyIGhhbGZTaXplID0gSEFMRl9TSVpFO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSBkaW1lbnNpb24pIHtcbiAgICBvdXRwdXRbaV0gPSBoYWxmU2l6ZSAqIGlucHV0W2ldIC8gMTgwO1xuICAgIHZhciB5ID0gUkFESVVTICpcbiAgICAgICAgTWF0aC5sb2coTWF0aC50YW4oTWF0aC5QSSAqIChpbnB1dFtpICsgMV0gKyA5MCkgLyAzNjApKTtcbiAgICBpZiAoeSA+IGhhbGZTaXplKSB7XG4gICAgICB5ID0gaGFsZlNpemU7XG4gICAgfSBlbHNlIGlmICh5IDwgLWhhbGZTaXplKSB7XG4gICAgICB5ID0gLWhhbGZTaXplO1xuICAgIH1cbiAgICBvdXRwdXRbaSArIDFdID0geTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbi8qKlxuICogVHJhbnNmb3JtYXRpb24gZnJvbSBFUFNHOjM4NTcgdG8gRVBTRzo0MzI2LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gaW5wdXQgSW5wdXQgYXJyYXkgb2YgY29vcmRpbmF0ZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj49fSBvcHRfb3V0cHV0IE91dHB1dCBhcnJheSBvZiBjb29yZGluYXRlIHZhbHVlcy5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2RpbWVuc2lvbiBEaW1lbnNpb24gKGRlZmF1bHQgaXMgYDJgKS5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IE91dHB1dCBhcnJheSBvZiBjb29yZGluYXRlIHZhbHVlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvRVBTRzQzMjYoaW5wdXQsIG9wdF9vdXRwdXQsIG9wdF9kaW1lbnNpb24pIHtcbiAgdmFyIGxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgdmFyIGRpbWVuc2lvbiA9IG9wdF9kaW1lbnNpb24gPiAxID8gb3B0X2RpbWVuc2lvbiA6IDI7XG4gIHZhciBvdXRwdXQgPSBvcHRfb3V0cHV0O1xuICBpZiAob3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoZGltZW5zaW9uID4gMikge1xuICAgICAgLy8gcHJlc2VydmUgdmFsdWVzIGJleW9uZCBzZWNvbmQgZGltZW5zaW9uXG4gICAgICBvdXRwdXQgPSBpbnB1dC5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICB9XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gZGltZW5zaW9uKSB7XG4gICAgb3V0cHV0W2ldID0gMTgwICogaW5wdXRbaV0gLyBIQUxGX1NJWkU7XG4gICAgb3V0cHV0W2kgKyAxXSA9IDM2MCAqIE1hdGguYXRhbihcbiAgICAgIE1hdGguZXhwKGlucHV0W2kgKyAxXSAvIFJBRElVUykpIC8gTWF0aC5QSSAtIDkwO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVwc2czODU3LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9wcm9qL2Vwc2c0MzI2XG4gKi9cbmltcG9ydCBQcm9qZWN0aW9uIGZyb20gJy4vUHJvamVjdGlvbi5qcyc7XG5pbXBvcnQgVW5pdHMgZnJvbSAnLi9Vbml0cy5qcyc7XG5cblxuLyoqXG4gKiBTZW1pLW1ham9yIHJhZGl1cyBvZiB0aGUgV0dTODQgZWxsaXBzb2lkLlxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBSQURJVVMgPSA2Mzc4MTM3O1xuXG5cbi8qKlxuICogRXh0ZW50IG9mIHRoZSBFUFNHOjQzMjYgcHJvamVjdGlvbiB3aGljaCBpcyB0aGUgd2hvbGUgd29ybGQuXG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAqL1xuZXhwb3J0IHZhciBFWFRFTlQgPSBbLTE4MCwgLTkwLCAxODAsIDkwXTtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBNRVRFUlNfUEVSX1VOSVQgPSBNYXRoLlBJICogUkFESVVTIC8gMTgwO1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogUHJvamVjdGlvbiBvYmplY3QgZm9yIFdHUzg0IGdlb2dyYXBoaWMgY29vcmRpbmF0ZXMgKEVQU0c6NDMyNikuXG4gKlxuICogTm90ZSB0aGF0IE9wZW5MYXllcnMgZG9lcyBub3Qgc3RyaWN0bHkgY29tcGx5IHdpdGggdGhlIEVQU0cgZGVmaW5pdGlvbi5cbiAqIFRoZSBFUFNHIHJlZ2lzdHJ5IGRlZmluZXMgNDMyNiBhcyBhIENSUyBmb3IgTGF0aXR1ZGUsTG9uZ2l0dWRlICh5LHgpLlxuICogT3BlbkxheWVycyB0cmVhdHMgRVBTRzo0MzI2IGFzIGEgcHNldWRvLXByb2plY3Rpb24sIHdpdGggeCx5IGNvb3JkaW5hdGVzLlxuICovXG52YXIgRVBTRzQzMjZQcm9qZWN0aW9uID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoUHJvamVjdGlvbikge1xuICBmdW5jdGlvbiBFUFNHNDMyNlByb2plY3Rpb24oY29kZSwgb3B0X2F4aXNPcmllbnRhdGlvbikge1xuICAgIFByb2plY3Rpb24uY2FsbCh0aGlzLCB7XG4gICAgICBjb2RlOiBjb2RlLFxuICAgICAgdW5pdHM6IFVuaXRzLkRFR1JFRVMsXG4gICAgICBleHRlbnQ6IEVYVEVOVCxcbiAgICAgIGF4aXNPcmllbnRhdGlvbjogb3B0X2F4aXNPcmllbnRhdGlvbixcbiAgICAgIGdsb2JhbDogdHJ1ZSxcbiAgICAgIG1ldGVyc1BlclVuaXQ6IE1FVEVSU19QRVJfVU5JVCxcbiAgICAgIHdvcmxkRXh0ZW50OiBFWFRFTlRcbiAgICB9KTtcblxuICB9XG5cbiAgaWYgKCBQcm9qZWN0aW9uICkgRVBTRzQzMjZQcm9qZWN0aW9uLl9fcHJvdG9fXyA9IFByb2plY3Rpb247XG4gIEVQU0c0MzI2UHJvamVjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQcm9qZWN0aW9uICYmIFByb2plY3Rpb24ucHJvdG90eXBlICk7XG4gIEVQU0c0MzI2UHJvamVjdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFUFNHNDMyNlByb2plY3Rpb247XG5cbiAgcmV0dXJuIEVQU0c0MzI2UHJvamVjdGlvbjtcbn0oUHJvamVjdGlvbikpO1xuXG5cbi8qKlxuICogUHJvamVjdGlvbnMgZXF1YWwgdG8gRVBTRzo0MzI2LlxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge0FycmF5PGltcG9ydChcIi4vUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0Pn1cbiAqL1xuZXhwb3J0IHZhciBQUk9KRUNUSU9OUyA9IFtcbiAgbmV3IEVQU0c0MzI2UHJvamVjdGlvbignQ1JTOjg0JyksXG4gIG5ldyBFUFNHNDMyNlByb2plY3Rpb24oJ0VQU0c6NDMyNicsICduZXUnKSxcbiAgbmV3IEVQU0c0MzI2UHJvamVjdGlvbigndXJuOm9nYzpkZWY6Y3JzOkVQU0c6OjQzMjYnLCAnbmV1JyksXG4gIG5ldyBFUFNHNDMyNlByb2plY3Rpb24oJ3VybjpvZ2M6ZGVmOmNyczpFUFNHOjYuNjo0MzI2JywgJ25ldScpLFxuICBuZXcgRVBTRzQzMjZQcm9qZWN0aW9uKCd1cm46b2djOmRlZjpjcnM6T0dDOjEuMzpDUlM4NCcpLFxuICBuZXcgRVBTRzQzMjZQcm9qZWN0aW9uKCd1cm46b2djOmRlZjpjcnM6T0dDOjI6ODQnKSxcbiAgbmV3IEVQU0c0MzI2UHJvamVjdGlvbignaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwvc3JzL2Vwc2cueG1sIzQzMjYnLCAnbmV1JyksXG4gIG5ldyBFUFNHNDMyNlByb2plY3Rpb24oJ3Vybjp4LW9nYzpkZWY6Y3JzOkVQU0c6NDMyNicsICduZXUnKVxuXTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXBzZzQzMjYuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3Byb2ovcHJvamVjdGlvbnNcbiAqL1xuXG5cbi8qKlxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIGltcG9ydChcIi4vUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0Pn1cbiAqL1xudmFyIGNhY2hlID0ge307XG5cblxuLyoqXG4gKiBDbGVhciB0aGUgcHJvamVjdGlvbnMgY2FjaGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhcigpIHtcbiAgY2FjaGUgPSB7fTtcbn1cblxuXG4vKipcbiAqIEdldCBhIGNhY2hlZCBwcm9qZWN0aW9uIGJ5IGNvZGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29kZSBUaGUgY29kZSBmb3IgdGhlIHByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gVGhlIHByb2plY3Rpb24gKGlmIGNhY2hlZCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXQoY29kZSkge1xuICByZXR1cm4gY2FjaGVbY29kZV0gfHwgbnVsbDtcbn1cblxuXG4vKipcbiAqIEFkZCBhIHByb2plY3Rpb24gdG8gdGhlIGNhY2hlLlxuICogQHBhcmFtIHtzdHJpbmd9IGNvZGUgVGhlIHByb2plY3Rpb24gY29kZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gVGhlIHByb2plY3Rpb24gdG8gY2FjaGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGQoY29kZSwgcHJvamVjdGlvbikge1xuICBjYWNoZVtjb2RlXSA9IHByb2plY3Rpb247XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb2plY3Rpb25zLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9wcm9qL3RyYW5zZm9ybXNcbiAqL1xuaW1wb3J0IHtpc0VtcHR5fSBmcm9tICcuLi9vYmouanMnO1xuXG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4vcHJvai5qc1wiKS5UcmFuc2Zvcm1GdW5jdGlvbj4+fVxuICovXG52YXIgdHJhbnNmb3JtcyA9IHt9O1xuXG5cbi8qKlxuICogQ2xlYXIgdGhlIHRyYW5zZm9ybSBjYWNoZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyKCkge1xuICB0cmFuc2Zvcm1zID0ge307XG59XG5cblxuLyoqXG4gKiBSZWdpc3RlcnMgYSBjb252ZXJzaW9uIGZ1bmN0aW9uIHRvIGNvbnZlcnQgY29vcmRpbmF0ZXMgZnJvbSB0aGUgc291cmNlXG4gKiBwcm9qZWN0aW9uIHRvIHRoZSBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHNvdXJjZSBTb3VyY2UuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBkZXN0aW5hdGlvbiBEZXN0aW5hdGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5UcmFuc2Zvcm1GdW5jdGlvbn0gdHJhbnNmb3JtRm4gVHJhbnNmb3JtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkKHNvdXJjZSwgZGVzdGluYXRpb24sIHRyYW5zZm9ybUZuKSB7XG4gIHZhciBzb3VyY2VDb2RlID0gc291cmNlLmdldENvZGUoKTtcbiAgdmFyIGRlc3RpbmF0aW9uQ29kZSA9IGRlc3RpbmF0aW9uLmdldENvZGUoKTtcbiAgaWYgKCEoc291cmNlQ29kZSBpbiB0cmFuc2Zvcm1zKSkge1xuICAgIHRyYW5zZm9ybXNbc291cmNlQ29kZV0gPSB7fTtcbiAgfVxuICB0cmFuc2Zvcm1zW3NvdXJjZUNvZGVdW2Rlc3RpbmF0aW9uQ29kZV0gPSB0cmFuc2Zvcm1Gbjtcbn1cblxuXG4vKipcbiAqIFVucmVnaXN0ZXJzIHRoZSBjb252ZXJzaW9uIGZ1bmN0aW9uIHRvIGNvbnZlcnQgY29vcmRpbmF0ZXMgZnJvbSB0aGUgc291cmNlXG4gKiBwcm9qZWN0aW9uIHRvIHRoZSBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uLiAgVGhpcyBtZXRob2QgaXMgdXNlZCB0byBjbGVhbiB1cFxuICogY2FjaGVkIHRyYW5zZm9ybXMgZHVyaW5nIHRlc3RpbmcuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gc291cmNlIFNvdXJjZSBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gZGVzdGluYXRpb24gRGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3Byb2ouanNcIikuVHJhbnNmb3JtRnVuY3Rpb259IHRyYW5zZm9ybUZuIFRoZSB1bnJlZ2lzdGVyZWQgdHJhbnNmb3JtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlKHNvdXJjZSwgZGVzdGluYXRpb24pIHtcbiAgdmFyIHNvdXJjZUNvZGUgPSBzb3VyY2UuZ2V0Q29kZSgpO1xuICB2YXIgZGVzdGluYXRpb25Db2RlID0gZGVzdGluYXRpb24uZ2V0Q29kZSgpO1xuICB2YXIgdHJhbnNmb3JtID0gdHJhbnNmb3Jtc1tzb3VyY2VDb2RlXVtkZXN0aW5hdGlvbkNvZGVdO1xuICBkZWxldGUgdHJhbnNmb3Jtc1tzb3VyY2VDb2RlXVtkZXN0aW5hdGlvbkNvZGVdO1xuICBpZiAoaXNFbXB0eSh0cmFuc2Zvcm1zW3NvdXJjZUNvZGVdKSkge1xuICAgIGRlbGV0ZSB0cmFuc2Zvcm1zW3NvdXJjZUNvZGVdO1xuICB9XG4gIHJldHVybiB0cmFuc2Zvcm07XG59XG5cblxuLyoqXG4gKiBHZXQgYSB0cmFuc2Zvcm0gZ2l2ZW4gYSBzb3VyY2UgY29kZSBhbmQgYSBkZXN0aW5hdGlvbiBjb2RlLlxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZUNvZGUgVGhlIGNvZGUgZm9yIHRoZSBzb3VyY2UgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkZXN0aW5hdGlvbkNvZGUgVGhlIGNvZGUgZm9yIHRoZSBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5UcmFuc2Zvcm1GdW5jdGlvbnx1bmRlZmluZWR9IFRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gKGlmIGZvdW5kKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldChzb3VyY2VDb2RlLCBkZXN0aW5hdGlvbkNvZGUpIHtcbiAgdmFyIHRyYW5zZm9ybTtcbiAgaWYgKHNvdXJjZUNvZGUgaW4gdHJhbnNmb3JtcyAmJiBkZXN0aW5hdGlvbkNvZGUgaW4gdHJhbnNmb3Jtc1tzb3VyY2VDb2RlXSkge1xuICAgIHRyYW5zZm9ybSA9IHRyYW5zZm9ybXNbc291cmNlQ29kZV1bZGVzdGluYXRpb25Db2RlXTtcbiAgfVxuICByZXR1cm4gdHJhbnNmb3JtO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2Zvcm1zLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXIvQm94XG4gKi9cblxuaW1wb3J0IERpc3Bvc2FibGUgZnJvbSAnLi4vRGlzcG9zYWJsZS5qcyc7XG5pbXBvcnQgUG9seWdvbiBmcm9tICcuLi9nZW9tL1BvbHlnb24uanMnO1xuXG52YXIgUmVuZGVyQm94ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoRGlzcG9zYWJsZSkge1xuICBmdW5jdGlvbiBSZW5kZXJCb3goY2xhc3NOYW1lKSB7XG4gICAgRGlzcG9zYWJsZS5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2dlb20vUG9seWdvbi5qc1wiKS5kZWZhdWx0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5nZW9tZXRyeV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0hUTUxEaXZFbGVtZW50fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5lbGVtZW50XyA9IC8qKiBAdHlwZSB7SFRNTERpdkVsZW1lbnR9ICovIChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XG4gICAgdGhpcy5lbGVtZW50Xy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgdGhpcy5lbGVtZW50Xy5jbGFzc05hbWUgPSAnb2wtYm94ICcgKyBjbGFzc05hbWU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLm1hcF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vcGl4ZWwuanNcIikuUGl4ZWx9XG4gICAgICovXG4gICAgdGhpcy5zdGFydFBpeGVsXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9waXhlbC5qc1wiKS5QaXhlbH1cbiAgICAgKi9cbiAgICB0aGlzLmVuZFBpeGVsXyA9IG51bGw7XG5cbiAgfVxuXG4gIGlmICggRGlzcG9zYWJsZSApIFJlbmRlckJveC5fX3Byb3RvX18gPSBEaXNwb3NhYmxlO1xuICBSZW5kZXJCb3gucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRGlzcG9zYWJsZSAmJiBEaXNwb3NhYmxlLnByb3RvdHlwZSApO1xuICBSZW5kZXJCb3gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVuZGVyQm94O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgUmVuZGVyQm94LnByb3RvdHlwZS5kaXNwb3NlSW50ZXJuYWwgPSBmdW5jdGlvbiBkaXNwb3NlSW50ZXJuYWwgKCkge1xuICAgIHRoaXMuc2V0TWFwKG51bGwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgUmVuZGVyQm94LnByb3RvdHlwZS5yZW5kZXJfID0gZnVuY3Rpb24gcmVuZGVyXyAoKSB7XG4gICAgdmFyIHN0YXJ0UGl4ZWwgPSB0aGlzLnN0YXJ0UGl4ZWxfO1xuICAgIHZhciBlbmRQaXhlbCA9IHRoaXMuZW5kUGl4ZWxfO1xuICAgIHZhciBweCA9ICdweCc7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5lbGVtZW50Xy5zdHlsZTtcbiAgICBzdHlsZS5sZWZ0ID0gTWF0aC5taW4oc3RhcnRQaXhlbFswXSwgZW5kUGl4ZWxbMF0pICsgcHg7XG4gICAgc3R5bGUudG9wID0gTWF0aC5taW4oc3RhcnRQaXhlbFsxXSwgZW5kUGl4ZWxbMV0pICsgcHg7XG4gICAgc3R5bGUud2lkdGggPSBNYXRoLmFicyhlbmRQaXhlbFswXSAtIHN0YXJ0UGl4ZWxbMF0pICsgcHg7XG4gICAgc3R5bGUuaGVpZ2h0ID0gTWF0aC5hYnMoZW5kUGl4ZWxbMV0gLSBzdGFydFBpeGVsWzFdKSArIHB4O1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1BsdWdnYWJsZU1hcC5qc1wiKS5kZWZhdWx0fSBtYXAgTWFwLlxuICAgKi9cbiAgUmVuZGVyQm94LnByb3RvdHlwZS5zZXRNYXAgPSBmdW5jdGlvbiBzZXRNYXAgKG1hcCkge1xuICAgIGlmICh0aGlzLm1hcF8pIHtcbiAgICAgIHRoaXMubWFwXy5nZXRPdmVybGF5Q29udGFpbmVyKCkucmVtb3ZlQ2hpbGQodGhpcy5lbGVtZW50Xyk7XG4gICAgICB2YXIgc3R5bGUgPSB0aGlzLmVsZW1lbnRfLnN0eWxlO1xuICAgICAgc3R5bGUubGVmdCA9IHN0eWxlLnRvcCA9IHN0eWxlLndpZHRoID0gc3R5bGUuaGVpZ2h0ID0gJ2luaGVyaXQnO1xuICAgIH1cbiAgICB0aGlzLm1hcF8gPSBtYXA7XG4gICAgaWYgKHRoaXMubWFwXykge1xuICAgICAgdGhpcy5tYXBfLmdldE92ZXJsYXlDb250YWluZXIoKS5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnRfKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcGl4ZWwuanNcIikuUGl4ZWx9IHN0YXJ0UGl4ZWwgU3RhcnQgcGl4ZWwuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcGl4ZWwuanNcIikuUGl4ZWx9IGVuZFBpeGVsIEVuZCBwaXhlbC5cbiAgICovXG4gIFJlbmRlckJveC5wcm90b3R5cGUuc2V0UGl4ZWxzID0gZnVuY3Rpb24gc2V0UGl4ZWxzIChzdGFydFBpeGVsLCBlbmRQaXhlbCkge1xuICAgIHRoaXMuc3RhcnRQaXhlbF8gPSBzdGFydFBpeGVsO1xuICAgIHRoaXMuZW5kUGl4ZWxfID0gZW5kUGl4ZWw7XG4gICAgdGhpcy5jcmVhdGVPclVwZGF0ZUdlb21ldHJ5KCk7XG4gICAgdGhpcy5yZW5kZXJfKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgb3IgdXBkYXRlcyB0aGUgY2FjaGVkIGdlb21ldHJ5LlxuICAgKi9cbiAgUmVuZGVyQm94LnByb3RvdHlwZS5jcmVhdGVPclVwZGF0ZUdlb21ldHJ5ID0gZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVHZW9tZXRyeSAoKSB7XG4gICAgdmFyIHN0YXJ0UGl4ZWwgPSB0aGlzLnN0YXJ0UGl4ZWxfO1xuICAgIHZhciBlbmRQaXhlbCA9IHRoaXMuZW5kUGl4ZWxfO1xuICAgIHZhciBwaXhlbHMgPSBbXG4gICAgICBzdGFydFBpeGVsLFxuICAgICAgW3N0YXJ0UGl4ZWxbMF0sIGVuZFBpeGVsWzFdXSxcbiAgICAgIGVuZFBpeGVsLFxuICAgICAgW2VuZFBpeGVsWzBdLCBzdGFydFBpeGVsWzFdXVxuICAgIF07XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gcGl4ZWxzLm1hcCh0aGlzLm1hcF8uZ2V0Q29vcmRpbmF0ZUZyb21QaXhlbCwgdGhpcy5tYXBfKTtcbiAgICAvLyBjbG9zZSB0aGUgcG9seWdvblxuICAgIGNvb3JkaW5hdGVzWzRdID0gY29vcmRpbmF0ZXNbMF0uc2xpY2UoKTtcbiAgICBpZiAoIXRoaXMuZ2VvbWV0cnlfKSB7XG4gICAgICB0aGlzLmdlb21ldHJ5XyA9IG5ldyBQb2x5Z29uKFtjb29yZGluYXRlc10pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmdlb21ldHJ5Xy5zZXRDb29yZGluYXRlcyhbY29vcmRpbmF0ZXNdKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2dlb20vUG9seWdvbi5qc1wiKS5kZWZhdWx0fSBHZW9tZXRyeS5cbiAgICovXG4gIFJlbmRlckJveC5wcm90b3R5cGUuZ2V0R2VvbWV0cnkgPSBmdW5jdGlvbiBnZXRHZW9tZXRyeSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlfO1xuICB9O1xuXG4gIHJldHVybiBSZW5kZXJCb3g7XG59KERpc3Bvc2FibGUpKTtcblxuXG5leHBvcnQgZGVmYXVsdCBSZW5kZXJCb3g7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJveC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyL0V2ZW50XG4gKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cy9FdmVudC5qcyc7XG5cbnZhciBSZW5kZXJFdmVudCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEV2ZW50KSB7XG4gIGZ1bmN0aW9uIFJlbmRlckV2ZW50KHR5cGUsIG9wdF92ZWN0b3JDb250ZXh0LCBvcHRfZnJhbWVTdGF0ZSwgb3B0X2NvbnRleHQsIG9wdF9nbENvbnRleHQpIHtcblxuICAgIEV2ZW50LmNhbGwodGhpcywgdHlwZSk7XG5cbiAgICAvKipcbiAgICAgKiBGb3IgY2FudmFzLCB0aGlzIGlzIGFuIGluc3RhbmNlIG9mIHtAbGluayBtb2R1bGU6b2wvcmVuZGVyL2NhbnZhcy9JbW1lZGlhdGV9LlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL1ZlY3RvckNvbnRleHQuanNcIikuZGVmYXVsdHx1bmRlZmluZWR9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMudmVjdG9yQ29udGV4dCA9IG9wdF92ZWN0b3JDb250ZXh0O1xuXG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgY3VycmVudCByZW5kZXIgZnJhbWUgc3RhdGUuXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL1BsdWdnYWJsZU1hcC5qc1wiKS5GcmFtZVN0YXRlfHVuZGVmaW5lZH1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5mcmFtZVN0YXRlID0gb3B0X2ZyYW1lU3RhdGU7XG5cbiAgICAvKipcbiAgICAgKiBDYW52YXMgY29udGV4dC4gT25seSBhdmFpbGFibGUgd2hlbiBhIENhbnZhcyByZW5kZXJlciBpcyB1c2VkLCBudWxsXG4gICAgICogb3RoZXJ3aXNlLlxuICAgICAqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR8bnVsbHx1bmRlZmluZWR9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMuY29udGV4dCA9IG9wdF9jb250ZXh0O1xuXG4gICAgLyoqXG4gICAgICogV2ViR0wgY29udGV4dC4gT25seSBhdmFpbGFibGUgd2hlbiBhIFdlYkdMIHJlbmRlcmVyIGlzIHVzZWQsIG51bGxcbiAgICAgKiBvdGhlcndpc2UuXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3dlYmdsL0NvbnRleHQuanNcIikuZGVmYXVsdHxudWxsfHVuZGVmaW5lZH1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5nbENvbnRleHQgPSBvcHRfZ2xDb250ZXh0O1xuXG4gIH1cblxuICBpZiAoIEV2ZW50ICkgUmVuZGVyRXZlbnQuX19wcm90b19fID0gRXZlbnQ7XG4gIFJlbmRlckV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEV2ZW50ICYmIEV2ZW50LnByb3RvdHlwZSApO1xuICBSZW5kZXJFdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZW5kZXJFdmVudDtcblxuICByZXR1cm4gUmVuZGVyRXZlbnQ7XG59KEV2ZW50KSk7XG5cbmV4cG9ydCBkZWZhdWx0IFJlbmRlckV2ZW50O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1FdmVudC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyL0V2ZW50VHlwZVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICAvKipcbiAgICogQGV2ZW50IG1vZHVsZTpvbC9yZW5kZXIvRXZlbnR+UmVuZGVyRXZlbnQjcG9zdGNvbXBvc2VcbiAgICogQGFwaVxuICAgKi9cbiAgUE9TVENPTVBPU0U6ICdwb3N0Y29tcG9zZScsXG4gIC8qKlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL3JlbmRlci9FdmVudH5SZW5kZXJFdmVudCNwcmVjb21wb3NlXG4gICAqIEBhcGlcbiAgICovXG4gIFBSRUNPTVBPU0U6ICdwcmVjb21wb3NlJyxcbiAgLyoqXG4gICAqIEBldmVudCBtb2R1bGU6b2wvcmVuZGVyL0V2ZW50flJlbmRlckV2ZW50I3JlbmRlclxuICAgKiBAYXBpXG4gICAqL1xuICBSRU5ERVI6ICdyZW5kZXInLFxuICAvKipcbiAgICogVHJpZ2dlcmVkIHdoZW4gcmVuZGVyaW5nIGlzIGNvbXBsZXRlLCBpLmUuIGFsbCBzb3VyY2VzIGFuZCB0aWxlcyBoYXZlXG4gICAqIGZpbmlzaGVkIGxvYWRpbmcgZm9yIHRoZSBjdXJyZW50IHZpZXdwb3J0LCBhbmQgYWxsIHRpbGVzIGFyZSBmYWRlZCBpbi5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9yZW5kZXIvRXZlbnR+UmVuZGVyRXZlbnQjcmVuZGVyY29tcGxldGVcbiAgICogQGFwaVxuICAgKi9cbiAgUkVOREVSQ09NUExFVEU6ICdyZW5kZXJjb21wbGV0ZSdcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUV2ZW50VHlwZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyL1JlcGxheUdyb3VwXG4gKi9cbmltcG9ydCB7YWJzdHJhY3R9IGZyb20gJy4uL3V0aWwuanMnO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIHJlcGxheSBncm91cHMuXG4gKi9cbnZhciBSZXBsYXlHcm91cCA9IGZ1bmN0aW9uIFJlcGxheUdyb3VwICgpIHt9O1xuXG5SZXBsYXlHcm91cC5wcm90b3R5cGUuZ2V0UmVwbGF5ID0gZnVuY3Rpb24gZ2V0UmVwbGF5ICh6SW5kZXgsIHJlcGxheVR5cGUpIHtcbiAgcmV0dXJuIGFic3RyYWN0KCk7XG59O1xuXG4vKipcbiAqIEBhYnN0cmFjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gSXMgZW1wdHkuXG4gKi9cblJlcGxheUdyb3VwLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSAoKSB7XG4gIHJldHVybiBhYnN0cmFjdCgpO1xufTtcblxuLyoqXG4gKiBAYWJzdHJhY3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZ3JvdXAgR3JvdXAgd2l0aCBwcmV2aW91cyByZXBsYXlcbiAqIEByZXR1cm4ge0FycmF5PCo+fSBUaGUgcmVzdWx0aW5nIGluc3RydWN0aW9uIGdyb3VwXG4gKi9cblJlcGxheUdyb3VwLnByb3RvdHlwZS5hZGREZWNsdXR0ZXIgPSBmdW5jdGlvbiBhZGREZWNsdXR0ZXIgKGdyb3VwKSB7XG4gIHJldHVybiBhYnN0cmFjdCgpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgUmVwbGF5R3JvdXA7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlcGxheUdyb3VwLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXIvUmVwbGF5VHlwZVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBDSVJDTEU6ICdDaXJjbGUnLFxuICBERUZBVUxUOiAnRGVmYXVsdCcsXG4gIElNQUdFOiAnSW1hZ2UnLFxuICBMSU5FX1NUUklORzogJ0xpbmVTdHJpbmcnLFxuICBQT0xZR09OOiAnUG9seWdvbicsXG4gIFRFWFQ6ICdUZXh0J1xufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVwbGF5VHlwZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyL1ZlY3RvckNvbnRleHRcbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIENvbnRleHQgZm9yIGRyYXdpbmcgZ2VvbWV0cmllcy4gIEEgdmVjdG9yIGNvbnRleHQgaXMgYXZhaWxhYmxlIG9uIHJlbmRlclxuICogZXZlbnRzIGFuZCBkb2VzIG5vdCBuZWVkIHRvIGJlIGNvbnN0cnVjdGVkIGRpcmVjdGx5LlxuICogQGFwaVxuICovXG52YXIgVmVjdG9yQ29udGV4dCA9IGZ1bmN0aW9uIFZlY3RvckNvbnRleHQgKCkge307XG5cblZlY3RvckNvbnRleHQucHJvdG90eXBlLmRyYXdDdXN0b20gPSBmdW5jdGlvbiBkcmF3Q3VzdG9tIChnZW9tZXRyeSwgZmVhdHVyZSwgcmVuZGVyZXIpIHt9O1xuXG4vKipcbiAqIFJlbmRlciBhIGdlb21ldHJ5LlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBUaGUgZ2VvbWV0cnkgdG8gcmVuZGVyLlxuICovXG5WZWN0b3JDb250ZXh0LnByb3RvdHlwZS5kcmF3R2VvbWV0cnkgPSBmdW5jdGlvbiBkcmF3R2VvbWV0cnkgKGdlb21ldHJ5KSB7fTtcblxuLyoqXG4gKiBTZXQgdGhlIHJlbmRlcmluZyBzdHlsZS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHR9IHN0eWxlIFRoZSByZW5kZXJpbmcgc3R5bGUuXG4gKi9cblZlY3RvckNvbnRleHQucHJvdG90eXBlLnNldFN0eWxlID0gZnVuY3Rpb24gc2V0U3R5bGUgKHN0eWxlKSB7fTtcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vQ2lyY2xlLmpzXCIpLmRlZmF1bHR9IGNpcmNsZUdlb21ldHJ5IENpcmNsZSBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmUuXG4gKi9cblZlY3RvckNvbnRleHQucHJvdG90eXBlLmRyYXdDaXJjbGUgPSBmdW5jdGlvbiBkcmF3Q2lyY2xlIChjaXJjbGVHZW9tZXRyeSwgZmVhdHVyZSkge307XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdH0gc3R5bGUgU3R5bGUuXG4gKi9cblZlY3RvckNvbnRleHQucHJvdG90eXBlLmRyYXdGZWF0dXJlID0gZnVuY3Rpb24gZHJhd0ZlYXR1cmUgKGZlYXR1cmUsIHN0eWxlKSB7fTtcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnlDb2xsZWN0aW9uLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5Q29sbGVjdGlvbkdlb21ldHJ5IEdlb21ldHJ5IGNvbGxlY3Rpb24uXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICovXG5WZWN0b3JDb250ZXh0LnByb3RvdHlwZS5kcmF3R2VvbWV0cnlDb2xsZWN0aW9uID0gZnVuY3Rpb24gZHJhd0dlb21ldHJ5Q29sbGVjdGlvbiAoZ2VvbWV0cnlDb2xsZWN0aW9uR2VvbWV0cnksIGZlYXR1cmUpIHt9O1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9MaW5lU3RyaW5nLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGxpbmVTdHJpbmdHZW9tZXRyeSBMaW5lIHN0cmluZyBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmUuXG4gKi9cblZlY3RvckNvbnRleHQucHJvdG90eXBlLmRyYXdMaW5lU3RyaW5nID0gZnVuY3Rpb24gZHJhd0xpbmVTdHJpbmcgKGxpbmVTdHJpbmdHZW9tZXRyeSwgZmVhdHVyZSkge307XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL011bHRpTGluZVN0cmluZy5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBtdWx0aUxpbmVTdHJpbmdHZW9tZXRyeSBNdWx0aUxpbmVTdHJpbmcgZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICovXG5WZWN0b3JDb250ZXh0LnByb3RvdHlwZS5kcmF3TXVsdGlMaW5lU3RyaW5nID0gZnVuY3Rpb24gZHJhd011bHRpTGluZVN0cmluZyAobXVsdGlMaW5lU3RyaW5nR2VvbWV0cnksIGZlYXR1cmUpIHt9O1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9NdWx0aVBvaW50LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IG11bHRpUG9pbnRHZW9tZXRyeSBNdWx0aVBvaW50IGdlb21ldHJ5LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAqL1xuVmVjdG9yQ29udGV4dC5wcm90b3R5cGUuZHJhd011bHRpUG9pbnQgPSBmdW5jdGlvbiBkcmF3TXVsdGlQb2ludCAobXVsdGlQb2ludEdlb21ldHJ5LCBmZWF0dXJlKSB7fTtcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vTXVsdGlQb2x5Z29uLmpzXCIpLmRlZmF1bHR9IG11bHRpUG9seWdvbkdlb21ldHJ5IE11bHRpUG9seWdvbiBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmUuXG4gKi9cblZlY3RvckNvbnRleHQucHJvdG90eXBlLmRyYXdNdWx0aVBvbHlnb24gPSBmdW5jdGlvbiBkcmF3TXVsdGlQb2x5Z29uIChtdWx0aVBvbHlnb25HZW9tZXRyeSwgZmVhdHVyZSkge307XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL1BvaW50LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IHBvaW50R2VvbWV0cnkgUG9pbnQgZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICovXG5WZWN0b3JDb250ZXh0LnByb3RvdHlwZS5kcmF3UG9pbnQgPSBmdW5jdGlvbiBkcmF3UG9pbnQgKHBvaW50R2VvbWV0cnksIGZlYXR1cmUpIHt9O1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9Qb2x5Z29uLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IHBvbHlnb25HZW9tZXRyeSBQb2x5Z29uIGdlb21ldHJ5LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAqL1xuVmVjdG9yQ29udGV4dC5wcm90b3R5cGUuZHJhd1BvbHlnb24gPSBmdW5jdGlvbiBkcmF3UG9seWdvbiAocG9seWdvbkdlb21ldHJ5LCBmZWF0dXJlKSB7fTtcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICovXG5WZWN0b3JDb250ZXh0LnByb3RvdHlwZS5kcmF3VGV4dCA9IGZ1bmN0aW9uIGRyYXdUZXh0IChnZW9tZXRyeSwgZmVhdHVyZSkge307XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zdHlsZS9GaWxsLmpzXCIpLmRlZmF1bHR9IGZpbGxTdHlsZSBGaWxsIHN0eWxlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zdHlsZS9TdHJva2UuanNcIikuZGVmYXVsdH0gc3Ryb2tlU3R5bGUgU3Ryb2tlIHN0eWxlLlxuICovXG5WZWN0b3JDb250ZXh0LnByb3RvdHlwZS5zZXRGaWxsU3Ryb2tlU3R5bGUgPSBmdW5jdGlvbiBzZXRGaWxsU3Ryb2tlU3R5bGUgKGZpbGxTdHlsZSwgc3Ryb2tlU3R5bGUpIHt9O1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc3R5bGUvSW1hZ2UuanNcIikuZGVmYXVsdH0gaW1hZ2VTdHlsZSBJbWFnZSBzdHlsZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jYW52YXMuanNcIikuRGVjbHV0dGVyR3JvdXA9fSBvcHRfZGVjbHV0dGVyR3JvdXAgRGVjbHV0dGVyLlxuICovXG5WZWN0b3JDb250ZXh0LnByb3RvdHlwZS5zZXRJbWFnZVN0eWxlID0gZnVuY3Rpb24gc2V0SW1hZ2VTdHlsZSAoaW1hZ2VTdHlsZSwgb3B0X2RlY2x1dHRlckdyb3VwKSB7fTtcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3N0eWxlL1RleHQuanNcIikuZGVmYXVsdH0gdGV4dFN0eWxlIFRleHQgc3R5bGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY2FudmFzLmpzXCIpLkRlY2x1dHRlckdyb3VwPX0gb3B0X2RlY2x1dHRlckdyb3VwIERlY2x1dHRlci5cbiAqL1xuVmVjdG9yQ29udGV4dC5wcm90b3R5cGUuc2V0VGV4dFN0eWxlID0gZnVuY3Rpb24gc2V0VGV4dFN0eWxlICh0ZXh0U3R5bGUsIG9wdF9kZWNsdXR0ZXJHcm91cCkge307XG5cbmV4cG9ydCBkZWZhdWx0IFZlY3RvckNvbnRleHQ7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZlY3RvckNvbnRleHQuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9jYW52YXNcbiAqL1xuaW1wb3J0IHtnZXRGb250RmFtaWxpZXN9IGZyb20gJy4uL2Nzcy5qcyc7XG5pbXBvcnQge2NyZWF0ZUNhbnZhc0NvbnRleHQyRH0gZnJvbSAnLi4vZG9tLmpzJztcbmltcG9ydCB7Y2xlYXJ9IGZyb20gJy4uL29iai5qcyc7XG5pbXBvcnQgTFJVQ2FjaGUgZnJvbSAnLi4vc3RydWN0cy9MUlVDYWNoZS5qcyc7XG5pbXBvcnQge2NyZWF0ZSBhcyBjcmVhdGVUcmFuc2Zvcm19IGZyb20gJy4uL3RyYW5zZm9ybS5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBGaWxsU3RhdGVcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vY29sb3JsaWtlLmpzXCIpLkNvbG9yTGlrZX0gZmlsbFN0eWxlXG4gKi9cblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEZpbGxTdHJva2VTdGF0ZVxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfSBbY3VycmVudEZpbGxTdHlsZV1cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vY29sb3JsaWtlLmpzXCIpLkNvbG9yTGlrZX0gW2N1cnJlbnRTdHJva2VTdHlsZV1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY3VycmVudExpbmVDYXBdXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IGN1cnJlbnRMaW5lRGFzaFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtjdXJyZW50TGluZURhc2hPZmZzZXRdXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2N1cnJlbnRMaW5lSm9pbl1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY3VycmVudExpbmVXaWR0aF1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY3VycmVudE1pdGVyTGltaXRdXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2xhc3RTdHJva2VdXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9IFtmaWxsU3R5bGVdXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9IFtzdHJva2VTdHlsZV1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbGluZUNhcF1cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gbGluZURhc2hcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbGluZURhc2hPZmZzZXRdXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2xpbmVKb2luXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtsaW5lV2lkdGhdXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pdGVyTGltaXRdXG4gKi9cblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFN0cm9rZVN0YXRlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbGluZUNhcFxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBsaW5lRGFzaFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxpbmVEYXNoT2Zmc2V0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbGluZUpvaW5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsaW5lV2lkdGhcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaXRlckxpbWl0XG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9IHN0cm9rZVN0eWxlXG4gKi9cblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRleHRTdGF0ZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGZvbnRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdGV4dEFsaWduXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRleHRCYXNlbGluZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtwbGFjZW1lbnRdXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heEFuZ2xlXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbb3ZlcmZsb3ddXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3N0eWxlL0ZpbGwuanNcIikuZGVmYXVsdH0gW2JhY2tncm91bmRGaWxsXVxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9zdHlsZS9TdHJva2UuanNcIikuZGVmYXVsdH0gW2JhY2tncm91bmRTdHJva2VdXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3NjYWxlXVxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBbcGFkZGluZ11cbiAqL1xuXG5cbi8qKlxuICogQ29udGFpbmVyIGZvciBkZWNsdXR0ZXJlZCByZXBsYXkgaW5zdHJ1Y3Rpb25zIHRoYXQgbmVlZCB0byBiZSByZW5kZXJlZCBvclxuICogb21pdHRlZCB0b2dldGhlciwgaS5lLiB3aGVuIHN0eWxlcyByZW5kZXIgYm90aCBhbiBpbWFnZSBhbmQgdGV4dCwgb3IgZm9yIHRoZVxuICogY2hhcmFjdGVycyB0aGF0IGZvcm0gdGV4dCBhbG9uZyBsaW5lcy4gVGhlIGJhc2ljIGVsZW1lbnRzIG9mIHRoaXMgYXJyYXkgYXJlXG4gKiBgW21pblgsIG1pblksIG1heFgsIG1heFksIGNvdW50XWAsIHdoZXJlIHRoZSBmaXJzdCBmb3VyIGVudHJpZXMgYXJlIHRoZVxuICogcmVuZGVyZWQgZXh0ZW50IG9mIHRoZSBncm91cCBpbiBwaXhlbCBzcGFjZS4gYGNvdW50YCBpcyB0aGUgbnVtYmVyIG9mIHN0eWxlc1xuICogaW4gdGhlIGdyb3VwLCBpLmUuIDIgd2hlbiBhbiBpbWFnZSBhbmQgYSB0ZXh0IGFyZSBncm91cGVkLCBvciAxIG90aGVyd2lzZS5cbiAqIEluIGFkZGl0aW9uIHRvIHRoZXNlIGZvdXIgZWxlbWVudHMsIGRlY2x1dHRlciBpbnN0cnVjdGlvbiBhcnJheXMgKGkuZS4gdGhlXG4gKiBhcmd1bWVudHMgdG8ge0BsaW5rIG1vZHVsZTpvbC9yZW5kZXIvY2FudmFzfmRyYXdJbWFnZX0gYXJlIGFwcGVuZGVkIHRvIHRoZSBhcnJheS5cbiAqIEB0eXBlZGVmIHtBcnJheTwqPn0gRGVjbHV0dGVyR3JvdXBcbiAqL1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgdmFyIGRlZmF1bHRGb250ID0gJzEwcHggc2Fucy1zZXJpZic7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcn1cbiAqL1xuZXhwb3J0IHZhciBkZWZhdWx0RmlsbFN0eWxlID0gWzAsIDAsIDAsIDFdO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgdmFyIGRlZmF1bHRMaW5lQ2FwID0gJ3JvdW5kJztcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gKi9cbmV4cG9ydCB2YXIgZGVmYXVsdExpbmVEYXNoID0gW107XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgZGVmYXVsdExpbmVEYXNoT2Zmc2V0ID0gMDtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IHZhciBkZWZhdWx0TGluZUpvaW4gPSAncm91bmQnO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIGRlZmF1bHRNaXRlckxpbWl0ID0gMTA7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcn1cbiAqL1xuZXhwb3J0IHZhciBkZWZhdWx0U3Ryb2tlU3R5bGUgPSBbMCwgMCwgMCwgMV07XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCB2YXIgZGVmYXVsdFRleHRBbGlnbiA9ICdjZW50ZXInO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgdmFyIGRlZmF1bHRUZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gKi9cbmV4cG9ydCB2YXIgZGVmYXVsdFBhZGRpbmcgPSBbMCwgMCwgMCwgMF07XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgZGVmYXVsdExpbmVXaWR0aCA9IDE7XG5cblxuLyoqXG4gKiBUaGUgbGFiZWwgY2FjaGUgZm9yIHRleHQgcmVuZGVyaW5nLiBUbyBjaGFuZ2UgdGhlIGRlZmF1bHQgY2FjaGUgc2l6ZSBvZiAyMDQ4XG4gKiBlbnRyaWVzLCB1c2Uge0BsaW5rIG1vZHVsZTpvbC9zdHJ1Y3RzL0xSVUNhY2hlI3NldFNpemV9LlxuICogQHR5cGUge0xSVUNhY2hlPEhUTUxDYW52YXNFbGVtZW50Pn1cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IHZhciBsYWJlbENhY2hlID0gbmV3IExSVUNhY2hlKCk7XG5cblxuLyoqXG4gKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIG51bWJlcj59XG4gKi9cbmV4cG9ydCB2YXIgY2hlY2tlZEZvbnRzID0ge307XG5cblxuLyoqXG4gKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICovXG52YXIgbWVhc3VyZUNvbnRleHQgPSBudWxsO1xuXG5cbi8qKlxuICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBudW1iZXI+fVxuICovXG5leHBvcnQgdmFyIHRleHRIZWlnaHRzID0ge307XG5cblxuLyoqXG4gKiBDbGVhcnMgdGhlIGxhYmVsIGNhY2hlIHdoZW4gYSBmb250IGJlY29tZXMgYXZhaWxhYmxlLlxuICogQHBhcmFtIHtzdHJpbmd9IGZvbnRTcGVjIENTUyBmb250IHNwZWMuXG4gKi9cbmV4cG9ydCB2YXIgY2hlY2tGb250ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgcmV0cmllcyA9IDYwO1xuICB2YXIgY2hlY2tlZCA9IGNoZWNrZWRGb250cztcbiAgdmFyIHNpemUgPSAnMzJweCAnO1xuICB2YXIgcmVmZXJlbmNlRm9udHMgPSBbJ21vbm9zcGFjZScsICdzZXJpZiddO1xuICB2YXIgbGVuID0gcmVmZXJlbmNlRm9udHMubGVuZ3RoO1xuICB2YXIgdGV4dCA9ICd3bXl0emlsV01ZVFpJTEAjLyY/JCUxMFxcdUYwMTMnO1xuICB2YXIgaW50ZXJ2YWwsIHJlZmVyZW5jZVdpZHRoO1xuXG4gIGZ1bmN0aW9uIGlzQXZhaWxhYmxlKGZvbnQpIHtcbiAgICB2YXIgY29udGV4dCA9IGdldE1lYXN1cmVDb250ZXh0KCk7XG4gICAgLy8gQ2hlY2sgd2VpZ2h0IHJhbmdlcyBhY2NvcmRpbmcgdG9cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvZm9udC13ZWlnaHQjRmFsbGJhY2tfd2VpZ2h0c1xuICAgIGZvciAodmFyIHdlaWdodCA9IDEwMDsgd2VpZ2h0IDw9IDcwMDsgd2VpZ2h0ICs9IDMwMCkge1xuICAgICAgdmFyIGZvbnRXZWlnaHQgPSB3ZWlnaHQgKyAnICc7XG4gICAgICB2YXIgYXZhaWxhYmxlID0gdHJ1ZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgdmFyIHJlZmVyZW5jZUZvbnQgPSByZWZlcmVuY2VGb250c1tpXTtcbiAgICAgICAgY29udGV4dC5mb250ID0gZm9udFdlaWdodCArIHNpemUgKyByZWZlcmVuY2VGb250O1xuICAgICAgICByZWZlcmVuY2VXaWR0aCA9IGNvbnRleHQubWVhc3VyZVRleHQodGV4dCkud2lkdGg7XG4gICAgICAgIGlmIChmb250ICE9IHJlZmVyZW5jZUZvbnQpIHtcbiAgICAgICAgICBjb250ZXh0LmZvbnQgPSBmb250V2VpZ2h0ICsgc2l6ZSArIGZvbnQgKyAnLCcgKyByZWZlcmVuY2VGb250O1xuICAgICAgICAgIHZhciB3aWR0aCA9IGNvbnRleHQubWVhc3VyZVRleHQodGV4dCkud2lkdGg7XG4gICAgICAgICAgLy8gSWYgd2lkdGggYW5kIHJlZmVyZW5jZVdpZHRoIGFyZSB0aGUgc2FtZSwgdGhlbiB0aGUgZmFsbGJhY2sgd2FzIHVzZWRcbiAgICAgICAgICAvLyBpbnN0ZWFkIG9mIHRoZSBmb250IHdlIHdhbnRlZCwgc28gdGhlIGZvbnQgaXMgbm90IGF2YWlsYWJsZS5cbiAgICAgICAgICBhdmFpbGFibGUgPSBhdmFpbGFibGUgJiYgd2lkdGggIT0gcmVmZXJlbmNlV2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhdmFpbGFibGUpIHtcbiAgICAgICAgLy8gQ29uc2lkZXIgZm9udCBhdmFpbGFibGUgd2hlbiBpdCBpcyBhdmFpbGFibGUgaW4gb25lIHdlaWdodCByYW5nZS5cbiAgICAgICAgLy9GSVhNRSBXaXRoIHRoaXMgd2UgbWlzcyByYXJlIGNvcm5lciBjYXNlcywgc28gd2Ugc2hvdWxkIGNvbnNpZGVyXG4gICAgICAgIC8vRklYTUUgY2hlY2tpbmcgYXZhaWxhYmlsaXR5IGZvciBlYWNoIHJlcXVlc3RlZCB3ZWlnaHQgcmFuZ2UuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVjaygpIHtcbiAgICB2YXIgZG9uZSA9IHRydWU7XG4gICAgZm9yICh2YXIgZm9udCBpbiBjaGVja2VkKSB7XG4gICAgICBpZiAoY2hlY2tlZFtmb250XSA8IHJldHJpZXMpIHtcbiAgICAgICAgaWYgKGlzQXZhaWxhYmxlKGZvbnQpKSB7XG4gICAgICAgICAgY2hlY2tlZFtmb250XSA9IHJldHJpZXM7XG4gICAgICAgICAgY2xlYXIodGV4dEhlaWdodHMpO1xuICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IGxvYWRlZCBmb250cyBhcmUgcGlja2VkIHVwIGJ5IFNhZmFyaVxuICAgICAgICAgIG1lYXN1cmVDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgICBsYWJlbENhY2hlLmNsZWFyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKytjaGVja2VkW2ZvbnRdO1xuICAgICAgICAgIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZG9uZSkge1xuICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICBpbnRlcnZhbCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oZm9udFNwZWMpIHtcbiAgICB2YXIgZm9udEZhbWlsaWVzID0gZ2V0Rm9udEZhbWlsaWVzKGZvbnRTcGVjKTtcbiAgICBpZiAoIWZvbnRGYW1pbGllcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBmb250RmFtaWxpZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgdmFyIGZvbnRGYW1pbHkgPSBmb250RmFtaWxpZXNbaV07XG4gICAgICBpZiAoIShmb250RmFtaWx5IGluIGNoZWNrZWQpKSB7XG4gICAgICAgIGNoZWNrZWRbZm9udEZhbWlseV0gPSByZXRyaWVzO1xuICAgICAgICBpZiAoIWlzQXZhaWxhYmxlKGZvbnRGYW1pbHkpKSB7XG4gICAgICAgICAgY2hlY2tlZFtmb250RmFtaWx5XSA9IDA7XG4gICAgICAgICAgaWYgKGludGVydmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGludGVydmFsID0gc2V0SW50ZXJ2YWwoY2hlY2ssIDMyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59KSgpO1xuXG5cbi8qKlxuICogQHJldHVybiB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBNZWFzdXJlIGNvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIGdldE1lYXN1cmVDb250ZXh0KCkge1xuICBpZiAoIW1lYXN1cmVDb250ZXh0KSB7XG4gICAgbWVhc3VyZUNvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0MkQoMSwgMSk7XG4gIH1cbiAgcmV0dXJuIG1lYXN1cmVDb250ZXh0O1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGZvbnQgRm9udCB0byB1c2UgZm9yIG1lYXN1cmluZy5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gTWVhc3VyZW1lbnQuXG4gKi9cbmV4cG9ydCB2YXIgbWVhc3VyZVRleHRIZWlnaHQgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBzcGFuO1xuICB2YXIgaGVpZ2h0cyA9IHRleHRIZWlnaHRzO1xuICByZXR1cm4gZnVuY3Rpb24oZm9udCkge1xuICAgIHZhciBoZWlnaHQgPSBoZWlnaHRzW2ZvbnRdO1xuICAgIGlmIChoZWlnaHQgPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIXNwYW4pIHtcbiAgICAgICAgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgc3Bhbi50ZXh0Q29udGVudCA9ICdNJztcbiAgICAgICAgc3Bhbi5zdHlsZS5tYXJnaW4gPSBzcGFuLnN0eWxlLnBhZGRpbmcgPSAnMCAhaW1wb3J0YW50JztcbiAgICAgICAgc3Bhbi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSAhaW1wb3J0YW50JztcbiAgICAgICAgc3Bhbi5zdHlsZS5sZWZ0ID0gJy05OTk5OXB4ICFpbXBvcnRhbnQnO1xuICAgICAgfVxuICAgICAgc3Bhbi5zdHlsZS5mb250ID0gZm9udDtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3Bhbik7XG4gICAgICBoZWlnaHQgPSBoZWlnaHRzW2ZvbnRdID0gc3Bhbi5vZmZzZXRIZWlnaHQ7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHNwYW4pO1xuICAgIH1cbiAgICByZXR1cm4gaGVpZ2h0O1xuICB9O1xufSkoKTtcblxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250IEZvbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUZXh0LlxuICogQHJldHVybiB7bnVtYmVyfSBXaWR0aC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lYXN1cmVUZXh0V2lkdGgoZm9udCwgdGV4dCkge1xuICB2YXIgbWVhc3VyZUNvbnRleHQgPSBnZXRNZWFzdXJlQ29udGV4dCgpO1xuICBpZiAoZm9udCAhPSBtZWFzdXJlQ29udGV4dC5mb250KSB7XG4gICAgbWVhc3VyZUNvbnRleHQuZm9udCA9IGZvbnQ7XG4gIH1cbiAgcmV0dXJuIG1lYXN1cmVDb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRYIFggb2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFkgWSBvZmZzZXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVBdE9mZnNldChjb250ZXh0LCByb3RhdGlvbiwgb2Zmc2V0WCwgb2Zmc2V0WSkge1xuICBpZiAocm90YXRpb24gIT09IDApIHtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZShvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICBjb250ZXh0LnJvdGF0ZShyb3RhdGlvbik7XG4gICAgY29udGV4dC50cmFuc2xhdGUoLW9mZnNldFgsIC1vZmZzZXRZKTtcbiAgfVxufVxuXG5cbmV4cG9ydCB2YXIgcmVzZXRUcmFuc2Zvcm0gPSBjcmVhdGVUcmFuc2Zvcm0oKTtcblxuXG4vKipcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IENvbnRleHQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm18bnVsbH0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvcGFjaXR5IE9wYWNpdHkuXG4gKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8SFRNTFZpZGVvRWxlbWVudH0gaW1hZ2UgSW1hZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0gb3JpZ2luWCBPcmlnaW4gWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvcmlnaW5ZIE9yaWdpbiBZLlxuICogQHBhcmFtIHtudW1iZXJ9IHcgV2lkdGguXG4gKiBAcGFyYW0ge251bWJlcn0gaCBIZWlnaHQuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZSBTY2FsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRyYXdJbWFnZShjb250ZXh0LFxuICB0cmFuc2Zvcm0sIG9wYWNpdHksIGltYWdlLCBvcmlnaW5YLCBvcmlnaW5ZLCB3LCBoLCB4LCB5LCBzY2FsZSkge1xuICB2YXIgYWxwaGE7XG4gIGlmIChvcGFjaXR5ICE9IDEpIHtcbiAgICBhbHBoYSA9IGNvbnRleHQuZ2xvYmFsQWxwaGE7XG4gICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGFscGhhICogb3BhY2l0eTtcbiAgfVxuICBpZiAodHJhbnNmb3JtKSB7XG4gICAgY29udGV4dC5zZXRUcmFuc2Zvcm0uYXBwbHkoY29udGV4dCwgdHJhbnNmb3JtKTtcbiAgfVxuXG4gIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLCBvcmlnaW5YLCBvcmlnaW5ZLCB3LCBoLCB4LCB5LCB3ICogc2NhbGUsIGggKiBzY2FsZSk7XG5cbiAgaWYgKGFscGhhKSB7XG4gICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGFscGhhO1xuICB9XG4gIGlmICh0cmFuc2Zvcm0pIHtcbiAgICBjb250ZXh0LnNldFRyYW5zZm9ybS5hcHBseShjb250ZXh0LCByZXNldFRyYW5zZm9ybSk7XG4gIH1cbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FudmFzLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXIvY2FudmFzL0ltYWdlUmVwbGF5XG4gKi9cbmltcG9ydCBDYW52YXNJbnN0cnVjdGlvbiBmcm9tICcuL0luc3RydWN0aW9uLmpzJztcbmltcG9ydCBDYW52YXNSZXBsYXkgZnJvbSAnLi9SZXBsYXkuanMnO1xuXG52YXIgQ2FudmFzSW1hZ2VSZXBsYXkgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChDYW52YXNSZXBsYXkpIHtcbiAgZnVuY3Rpb24gQ2FudmFzSW1hZ2VSZXBsYXkodG9sZXJhbmNlLCBtYXhFeHRlbnQsIHJlc29sdXRpb24sIHBpeGVsUmF0aW8sIG92ZXJsYXBzLCBkZWNsdXR0ZXJUcmVlKSB7XG4gICAgQ2FudmFzUmVwbGF5LmNhbGwodGhpcywgdG9sZXJhbmNlLCBtYXhFeHRlbnQsIHJlc29sdXRpb24sIHBpeGVsUmF0aW8sIG92ZXJsYXBzLCBkZWNsdXR0ZXJUcmVlKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5EZWNsdXR0ZXJHcm91cH1cbiAgICAgKi9cbiAgICB0aGlzLmRlY2x1dHRlckdyb3VwXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fEhUTUxJbWFnZUVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5oaXREZXRlY3Rpb25JbWFnZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnR8SFRNTFZpZGVvRWxlbWVudHxIVE1MSW1hZ2VFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5hbmNob3JYXyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5hbmNob3JZXyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5oZWlnaHRfID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLm9wYWNpdHlfID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLm9yaWdpblhfID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLm9yaWdpbllfID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5yb3RhdGVXaXRoVmlld18gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMucm90YXRpb25fID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnNjYWxlXyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy53aWR0aF8gPSB1bmRlZmluZWQ7XG5cbiAgfVxuXG4gIGlmICggQ2FudmFzUmVwbGF5ICkgQ2FudmFzSW1hZ2VSZXBsYXkuX19wcm90b19fID0gQ2FudmFzUmVwbGF5O1xuICBDYW52YXNJbWFnZVJlcGxheS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDYW52YXNSZXBsYXkgJiYgQ2FudmFzUmVwbGF5LnByb3RvdHlwZSApO1xuICBDYW52YXNJbWFnZVJlcGxheS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYW52YXNJbWFnZVJlcGxheTtcblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7bnVtYmVyfSBNeSBlbmQuXG4gICAqL1xuICBDYW52YXNJbWFnZVJlcGxheS5wcm90b3R5cGUuZHJhd0Nvb3JkaW5hdGVzXyA9IGZ1bmN0aW9uIGRyYXdDb29yZGluYXRlc18gKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSkge1xuICAgIHJldHVybiB0aGlzLmFwcGVuZEZsYXRDb29yZGluYXRlcyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIGZhbHNlLCBmYWxzZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNJbWFnZVJlcGxheS5wcm90b3R5cGUuZHJhd1BvaW50ID0gZnVuY3Rpb24gZHJhd1BvaW50IChwb2ludEdlb21ldHJ5LCBmZWF0dXJlKSB7XG4gICAgaWYgKCF0aGlzLmltYWdlXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmJlZ2luR2VvbWV0cnkocG9pbnRHZW9tZXRyeSwgZmVhdHVyZSk7XG4gICAgdmFyIGZsYXRDb29yZGluYXRlcyA9IHBvaW50R2VvbWV0cnkuZ2V0RmxhdENvb3JkaW5hdGVzKCk7XG4gICAgdmFyIHN0cmlkZSA9IHBvaW50R2VvbWV0cnkuZ2V0U3RyaWRlKCk7XG4gICAgdmFyIG15QmVnaW4gPSB0aGlzLmNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICB2YXIgbXlFbmQgPSB0aGlzLmRyYXdDb29yZGluYXRlc18oZmxhdENvb3JkaW5hdGVzLCAwLCBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLCBzdHJpZGUpO1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goW1xuICAgICAgQ2FudmFzSW5zdHJ1Y3Rpb24uRFJBV19JTUFHRSwgbXlCZWdpbiwgbXlFbmQsIHRoaXMuaW1hZ2VfLFxuICAgICAgLy8gUmVtYWluaW5nIGFyZ3VtZW50cyB0byBEUkFXX0lNQUdFIGFyZSBpbiBhbHBoYWJldGljYWwgb3JkZXJcbiAgICAgIHRoaXMuYW5jaG9yWF8sIHRoaXMuYW5jaG9yWV8sIHRoaXMuZGVjbHV0dGVyR3JvdXBfLCB0aGlzLmhlaWdodF8sIHRoaXMub3BhY2l0eV8sXG4gICAgICB0aGlzLm9yaWdpblhfLCB0aGlzLm9yaWdpbllfLCB0aGlzLnJvdGF0ZVdpdGhWaWV3XywgdGhpcy5yb3RhdGlvbl8sXG4gICAgICB0aGlzLnNjYWxlXyAqIHRoaXMucGl4ZWxSYXRpbywgdGhpcy53aWR0aF9cbiAgICBdKTtcbiAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKFtcbiAgICAgIENhbnZhc0luc3RydWN0aW9uLkRSQVdfSU1BR0UsIG15QmVnaW4sIG15RW5kLCB0aGlzLmhpdERldGVjdGlvbkltYWdlXyxcbiAgICAgIC8vIFJlbWFpbmluZyBhcmd1bWVudHMgdG8gRFJBV19JTUFHRSBhcmUgaW4gYWxwaGFiZXRpY2FsIG9yZGVyXG4gICAgICB0aGlzLmFuY2hvclhfLCB0aGlzLmFuY2hvcllfLCB0aGlzLmRlY2x1dHRlckdyb3VwXywgdGhpcy5oZWlnaHRfLCB0aGlzLm9wYWNpdHlfLFxuICAgICAgdGhpcy5vcmlnaW5YXywgdGhpcy5vcmlnaW5ZXywgdGhpcy5yb3RhdGVXaXRoVmlld18sIHRoaXMucm90YXRpb25fLFxuICAgICAgdGhpcy5zY2FsZV8sIHRoaXMud2lkdGhfXG4gICAgXSk7XG4gICAgdGhpcy5lbmRHZW9tZXRyeShwb2ludEdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENhbnZhc0ltYWdlUmVwbGF5LnByb3RvdHlwZS5kcmF3TXVsdGlQb2ludCA9IGZ1bmN0aW9uIGRyYXdNdWx0aVBvaW50IChtdWx0aVBvaW50R2VvbWV0cnksIGZlYXR1cmUpIHtcbiAgICBpZiAoIXRoaXMuaW1hZ2VfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYmVnaW5HZW9tZXRyeShtdWx0aVBvaW50R2VvbWV0cnksIGZlYXR1cmUpO1xuICAgIHZhciBmbGF0Q29vcmRpbmF0ZXMgPSBtdWx0aVBvaW50R2VvbWV0cnkuZ2V0RmxhdENvb3JkaW5hdGVzKCk7XG4gICAgdmFyIHN0cmlkZSA9IG11bHRpUG9pbnRHZW9tZXRyeS5nZXRTdHJpZGUoKTtcbiAgICB2YXIgbXlCZWdpbiA9IHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIHZhciBteUVuZCA9IHRoaXMuZHJhd0Nvb3JkaW5hdGVzXyhcbiAgICAgIGZsYXRDb29yZGluYXRlcywgMCwgZmxhdENvb3JkaW5hdGVzLmxlbmd0aCwgc3RyaWRlKTtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKFtcbiAgICAgIENhbnZhc0luc3RydWN0aW9uLkRSQVdfSU1BR0UsIG15QmVnaW4sIG15RW5kLCB0aGlzLmltYWdlXyxcbiAgICAgIC8vIFJlbWFpbmluZyBhcmd1bWVudHMgdG8gRFJBV19JTUFHRSBhcmUgaW4gYWxwaGFiZXRpY2FsIG9yZGVyXG4gICAgICB0aGlzLmFuY2hvclhfLCB0aGlzLmFuY2hvcllfLCB0aGlzLmRlY2x1dHRlckdyb3VwXywgdGhpcy5oZWlnaHRfLCB0aGlzLm9wYWNpdHlfLFxuICAgICAgdGhpcy5vcmlnaW5YXywgdGhpcy5vcmlnaW5ZXywgdGhpcy5yb3RhdGVXaXRoVmlld18sIHRoaXMucm90YXRpb25fLFxuICAgICAgdGhpcy5zY2FsZV8gKiB0aGlzLnBpeGVsUmF0aW8sIHRoaXMud2lkdGhfXG4gICAgXSk7XG4gICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChbXG4gICAgICBDYW52YXNJbnN0cnVjdGlvbi5EUkFXX0lNQUdFLCBteUJlZ2luLCBteUVuZCwgdGhpcy5oaXREZXRlY3Rpb25JbWFnZV8sXG4gICAgICAvLyBSZW1haW5pbmcgYXJndW1lbnRzIHRvIERSQVdfSU1BR0UgYXJlIGluIGFscGhhYmV0aWNhbCBvcmRlclxuICAgICAgdGhpcy5hbmNob3JYXywgdGhpcy5hbmNob3JZXywgdGhpcy5kZWNsdXR0ZXJHcm91cF8sIHRoaXMuaGVpZ2h0XywgdGhpcy5vcGFjaXR5XyxcbiAgICAgIHRoaXMub3JpZ2luWF8sIHRoaXMub3JpZ2luWV8sIHRoaXMucm90YXRlV2l0aFZpZXdfLCB0aGlzLnJvdGF0aW9uXyxcbiAgICAgIHRoaXMuc2NhbGVfLCB0aGlzLndpZHRoX1xuICAgIF0pO1xuICAgIHRoaXMuZW5kR2VvbWV0cnkobXVsdGlQb2ludEdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENhbnZhc0ltYWdlUmVwbGF5LnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiBmaW5pc2ggKCkge1xuICAgIHRoaXMucmV2ZXJzZUhpdERldGVjdGlvbkluc3RydWN0aW9ucygpO1xuICAgIC8vIEZJWE1FIHRoaXMgZG9lc24ndCByZWFsbHkgcHJvdGVjdCB1cyBhZ2FpbnN0IGZ1cnRoZXIgY2FsbHMgdG8gZHJhdypHZW9tZXRyeVxuICAgIHRoaXMuYW5jaG9yWF8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5hbmNob3JZXyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhpdERldGVjdGlvbkltYWdlXyA9IG51bGw7XG4gICAgdGhpcy5pbWFnZV8gPSBudWxsO1xuICAgIHRoaXMuaGVpZ2h0XyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNjYWxlXyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9wYWNpdHlfID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub3JpZ2luWF8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vcmlnaW5ZXyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJvdGF0ZVdpdGhWaWV3XyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJvdGF0aW9uXyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoXyA9IHVuZGVmaW5lZDtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENhbnZhc0ltYWdlUmVwbGF5LnByb3RvdHlwZS5zZXRJbWFnZVN0eWxlID0gZnVuY3Rpb24gc2V0SW1hZ2VTdHlsZSAoaW1hZ2VTdHlsZSwgZGVjbHV0dGVyR3JvdXApIHtcbiAgICB2YXIgYW5jaG9yID0gaW1hZ2VTdHlsZS5nZXRBbmNob3IoKTtcbiAgICB2YXIgc2l6ZSA9IGltYWdlU3R5bGUuZ2V0U2l6ZSgpO1xuICAgIHZhciBoaXREZXRlY3Rpb25JbWFnZSA9IGltYWdlU3R5bGUuZ2V0SGl0RGV0ZWN0aW9uSW1hZ2UoMSk7XG4gICAgdmFyIGltYWdlID0gaW1hZ2VTdHlsZS5nZXRJbWFnZSgxKTtcbiAgICB2YXIgb3JpZ2luID0gaW1hZ2VTdHlsZS5nZXRPcmlnaW4oKTtcbiAgICB0aGlzLmFuY2hvclhfID0gYW5jaG9yWzBdO1xuICAgIHRoaXMuYW5jaG9yWV8gPSBhbmNob3JbMV07XG4gICAgdGhpcy5kZWNsdXR0ZXJHcm91cF8gPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5EZWNsdXR0ZXJHcm91cH0gKi8gKGRlY2x1dHRlckdyb3VwKTtcbiAgICB0aGlzLmhpdERldGVjdGlvbkltYWdlXyA9IGhpdERldGVjdGlvbkltYWdlO1xuICAgIHRoaXMuaW1hZ2VfID0gaW1hZ2U7XG4gICAgdGhpcy5oZWlnaHRfID0gc2l6ZVsxXTtcbiAgICB0aGlzLm9wYWNpdHlfID0gaW1hZ2VTdHlsZS5nZXRPcGFjaXR5KCk7XG4gICAgdGhpcy5vcmlnaW5YXyA9IG9yaWdpblswXTtcbiAgICB0aGlzLm9yaWdpbllfID0gb3JpZ2luWzFdO1xuICAgIHRoaXMucm90YXRlV2l0aFZpZXdfID0gaW1hZ2VTdHlsZS5nZXRSb3RhdGVXaXRoVmlldygpO1xuICAgIHRoaXMucm90YXRpb25fID0gaW1hZ2VTdHlsZS5nZXRSb3RhdGlvbigpO1xuICAgIHRoaXMuc2NhbGVfID0gaW1hZ2VTdHlsZS5nZXRTY2FsZSgpO1xuICAgIHRoaXMud2lkdGhfID0gc2l6ZVswXTtcbiAgfTtcblxuICByZXR1cm4gQ2FudmFzSW1hZ2VSZXBsYXk7XG59KENhbnZhc1JlcGxheSkpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IENhbnZhc0ltYWdlUmVwbGF5O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbWFnZVJlcGxheS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyL2NhbnZhcy9JbW1lZGlhdGVcbiAqL1xuLy8gRklYTUUgdGVzdCwgZXNwZWNpYWxseSBwb2x5Z29ucyB3aXRoIGhvbGVzIGFuZCBtdWx0aXBvbHlnb25zXG4vLyBGSVhNRSBuZWVkIHRvIGhhbmRsZSBsYXJnZSB0aGljayBmZWF0dXJlcyAod2hlcmUgcGl4ZWwgc2l6ZSBtYXR0ZXJzKVxuLy8gRklYTUUgYWRkIG9mZnNldCBhbmQgZW5kIHRvIG9sL2dlb20vZmxhdC90cmFuc2Zvcm1+dHJhbnNmb3JtMkQ/XG5cbmltcG9ydCB7ZXF1YWxzfSBmcm9tICcuLi8uLi9hcnJheS5qcyc7XG5pbXBvcnQge2FzQ29sb3JMaWtlfSBmcm9tICcuLi8uLi9jb2xvcmxpa2UuanMnO1xuaW1wb3J0IHtpbnRlcnNlY3RzfSBmcm9tICcuLi8uLi9leHRlbnQuanMnO1xuaW1wb3J0IEdlb21ldHJ5VHlwZSBmcm9tICcuLi8uLi9nZW9tL0dlb21ldHJ5VHlwZS5qcyc7XG5pbXBvcnQge3RyYW5zZm9ybUdlb20yRH0gZnJvbSAnLi4vLi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qcyc7XG5pbXBvcnQge3RyYW5zZm9ybTJEfSBmcm9tICcuLi8uLi9nZW9tL2ZsYXQvdHJhbnNmb3JtLmpzJztcbmltcG9ydCB7Q0FOVkFTX0xJTkVfREFTSH0gZnJvbSAnLi4vLi4vaGFzLmpzJztcbmltcG9ydCBWZWN0b3JDb250ZXh0IGZyb20gJy4uL1ZlY3RvckNvbnRleHQuanMnO1xuaW1wb3J0IHtkZWZhdWx0VGV4dEFsaWduLCBkZWZhdWx0RmlsbFN0eWxlLCBkZWZhdWx0TGluZUNhcCwgZGVmYXVsdExpbmVEYXNoLCBkZWZhdWx0TGluZURhc2hPZmZzZXQsIGRlZmF1bHRMaW5lSm9pbiwgZGVmYXVsdExpbmVXaWR0aCwgZGVmYXVsdE1pdGVyTGltaXQsIGRlZmF1bHRTdHJva2VTdHlsZSwgZGVmYXVsdFRleHRCYXNlbGluZSwgZGVmYXVsdEZvbnR9IGZyb20gJy4uL2NhbnZhcy5qcyc7XG5pbXBvcnQge2NyZWF0ZSBhcyBjcmVhdGVUcmFuc2Zvcm0sIGNvbXBvc2UgYXMgY29tcG9zZVRyYW5zZm9ybX0gZnJvbSAnLi4vLi4vdHJhbnNmb3JtLmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBIGNvbmNyZXRlIHN1YmNsYXNzIG9mIHtAbGluayBtb2R1bGU6b2wvcmVuZGVyL1ZlY3RvckNvbnRleHR9IHRoYXQgaW1wbGVtZW50c1xuICogZGlyZWN0IHJlbmRlcmluZyBvZiBmZWF0dXJlcyBhbmQgZ2VvbWV0cmllcyB0byBhbiBIVE1MNSBDYW52YXMgY29udGV4dC5cbiAqIEluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIGFyZSBjcmVhdGVkIGludGVybmFsbHkgYnkgdGhlIGxpYnJhcnkgYW5kXG4gKiBwcm92aWRlZCB0byBhcHBsaWNhdGlvbiBjb2RlIGFzIHZlY3RvckNvbnRleHQgbWVtYmVyIG9mIHRoZVxuICoge0BsaW5rIG1vZHVsZTpvbC9yZW5kZXIvRXZlbnR+UmVuZGVyRXZlbnR9IG9iamVjdCBhc3NvY2lhdGVkIHdpdGggcG9zdGNvbXBvc2UsIHByZWNvbXBvc2UgYW5kXG4gKiByZW5kZXIgZXZlbnRzIGVtaXR0ZWQgYnkgbGF5ZXJzIGFuZCBtYXBzLlxuICovXG52YXIgQ2FudmFzSW1tZWRpYXRlUmVuZGVyZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChWZWN0b3JDb250ZXh0KSB7XG4gIGZ1bmN0aW9uIENhbnZhc0ltbWVkaWF0ZVJlbmRlcmVyKGNvbnRleHQsIHBpeGVsUmF0aW8sIGV4dGVudCwgdHJhbnNmb3JtLCB2aWV3Um90YXRpb24pIHtcbiAgICBWZWN0b3JDb250ZXh0LmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gICAgICovXG4gICAgdGhpcy5jb250ZXh0XyA9IGNvbnRleHQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5waXhlbFJhdGlvXyA9IHBpeGVsUmF0aW87XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgICAqL1xuICAgIHRoaXMuZXh0ZW50XyA9IGV4dGVudDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uLy4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19XG4gICAgICovXG4gICAgdGhpcy50cmFuc2Zvcm1fID0gdHJhbnNmb3JtO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudmlld1JvdGF0aW9uXyA9IHZpZXdSb3RhdGlvbjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRmlsbFN0YXRlfVxuICAgICAqL1xuICAgIHRoaXMuY29udGV4dEZpbGxTdGF0ZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5TdHJva2VTdGF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRleHRTdHJva2VTdGF0ZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5UZXh0U3RhdGV9XG4gICAgICovXG4gICAgdGhpcy5jb250ZXh0VGV4dFN0YXRlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkZpbGxTdGF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLmZpbGxTdGF0ZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5TdHJva2VTdGF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLnN0cm9rZVN0YXRlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fEhUTUxJbWFnZUVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5pbWFnZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VBbmNob3JYXyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbWFnZUFuY2hvcllfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlSGVpZ2h0XyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbWFnZU9wYWNpdHlfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlT3JpZ2luWF8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VPcmlnaW5ZXyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VSb3RhdGVXaXRoVmlld18gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlUm90YXRpb25fID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlU2NhbGVfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlV2lkdGhfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnRleHRfID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50ZXh0T2Zmc2V0WF8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudGV4dE9mZnNldFlfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy50ZXh0Um90YXRlV2l0aFZpZXdfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50ZXh0Um90YXRpb25fID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRleHRTY2FsZV8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5GaWxsU3RhdGV9XG4gICAgICovXG4gICAgdGhpcy50ZXh0RmlsbFN0YXRlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLlN0cm9rZVN0YXRlfVxuICAgICAqL1xuICAgIHRoaXMudGV4dFN0cm9rZVN0YXRlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLlRleHRTdGF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLnRleHRTdGF0ZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLnBpeGVsQ29vcmRpbmF0ZXNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfVxuICAgICAqL1xuICAgIHRoaXMudG1wTG9jYWxUcmFuc2Zvcm1fID0gY3JlYXRlVHJhbnNmb3JtKCk7XG5cbiAgfVxuXG4gIGlmICggVmVjdG9yQ29udGV4dCApIENhbnZhc0ltbWVkaWF0ZVJlbmRlcmVyLl9fcHJvdG9fXyA9IFZlY3RvckNvbnRleHQ7XG4gIENhbnZhc0ltbWVkaWF0ZVJlbmRlcmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFZlY3RvckNvbnRleHQgJiYgVmVjdG9yQ29udGV4dC5wcm90b3R5cGUgKTtcbiAgQ2FudmFzSW1tZWRpYXRlUmVuZGVyZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2FudmFzSW1tZWRpYXRlUmVuZGVyZXI7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBDYW52YXNJbW1lZGlhdGVSZW5kZXJlci5wcm90b3R5cGUuZHJhd0ltYWdlc18gPSBmdW5jdGlvbiBkcmF3SW1hZ2VzXyAoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKSB7XG4gICAgaWYgKCF0aGlzLmltYWdlXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcGl4ZWxDb29yZGluYXRlcyA9IHRyYW5zZm9ybTJEKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgMiwgdGhpcy50cmFuc2Zvcm1fLFxuICAgICAgdGhpcy5waXhlbENvb3JkaW5hdGVzXyk7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHRfO1xuICAgIHZhciBsb2NhbFRyYW5zZm9ybSA9IHRoaXMudG1wTG9jYWxUcmFuc2Zvcm1fO1xuICAgIHZhciBhbHBoYSA9IGNvbnRleHQuZ2xvYmFsQWxwaGE7XG4gICAgaWYgKHRoaXMuaW1hZ2VPcGFjaXR5XyAhPSAxKSB7XG4gICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gYWxwaGEgKiB0aGlzLmltYWdlT3BhY2l0eV87XG4gICAgfVxuICAgIHZhciByb3RhdGlvbiA9IHRoaXMuaW1hZ2VSb3RhdGlvbl87XG4gICAgaWYgKHRoaXMuaW1hZ2VSb3RhdGVXaXRoVmlld18pIHtcbiAgICAgIHJvdGF0aW9uICs9IHRoaXMudmlld1JvdGF0aW9uXztcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGl4ZWxDb29yZGluYXRlcy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICB2YXIgeCA9IHBpeGVsQ29vcmRpbmF0ZXNbaV0gLSB0aGlzLmltYWdlQW5jaG9yWF87XG4gICAgICB2YXIgeSA9IHBpeGVsQ29vcmRpbmF0ZXNbaSArIDFdIC0gdGhpcy5pbWFnZUFuY2hvcllfO1xuICAgICAgaWYgKHJvdGF0aW9uICE9PSAwIHx8IHRoaXMuaW1hZ2VTY2FsZV8gIT0gMSkge1xuICAgICAgICB2YXIgY2VudGVyWCA9IHggKyB0aGlzLmltYWdlQW5jaG9yWF87XG4gICAgICAgIHZhciBjZW50ZXJZID0geSArIHRoaXMuaW1hZ2VBbmNob3JZXztcbiAgICAgICAgY29tcG9zZVRyYW5zZm9ybShsb2NhbFRyYW5zZm9ybSxcbiAgICAgICAgICBjZW50ZXJYLCBjZW50ZXJZLFxuICAgICAgICAgIHRoaXMuaW1hZ2VTY2FsZV8sIHRoaXMuaW1hZ2VTY2FsZV8sXG4gICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgLWNlbnRlclgsIC1jZW50ZXJZKTtcbiAgICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0uYXBwbHkoY29udGV4dCwgbG9jYWxUcmFuc2Zvcm0pO1xuICAgICAgfVxuICAgICAgY29udGV4dC5kcmF3SW1hZ2UodGhpcy5pbWFnZV8sIHRoaXMuaW1hZ2VPcmlnaW5YXywgdGhpcy5pbWFnZU9yaWdpbllfLFxuICAgICAgICB0aGlzLmltYWdlV2lkdGhfLCB0aGlzLmltYWdlSGVpZ2h0XywgeCwgeSxcbiAgICAgICAgdGhpcy5pbWFnZVdpZHRoXywgdGhpcy5pbWFnZUhlaWdodF8pO1xuICAgIH1cbiAgICBpZiAocm90YXRpb24gIT09IDAgfHwgdGhpcy5pbWFnZVNjYWxlXyAhPSAxKSB7XG4gICAgICBjb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaW1hZ2VPcGFjaXR5XyAhPSAxKSB7XG4gICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gYWxwaGE7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQ2FudmFzSW1tZWRpYXRlUmVuZGVyZXIucHJvdG90eXBlLmRyYXdUZXh0XyA9IGZ1bmN0aW9uIGRyYXdUZXh0XyAoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKSB7XG4gICAgaWYgKCF0aGlzLnRleHRTdGF0ZV8gfHwgdGhpcy50ZXh0XyA9PT0gJycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMudGV4dEZpbGxTdGF0ZV8pIHtcbiAgICAgIHRoaXMuc2V0Q29udGV4dEZpbGxTdGF0ZV8odGhpcy50ZXh0RmlsbFN0YXRlXyk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRleHRTdHJva2VTdGF0ZV8pIHtcbiAgICAgIHRoaXMuc2V0Q29udGV4dFN0cm9rZVN0YXRlXyh0aGlzLnRleHRTdHJva2VTdGF0ZV8pO1xuICAgIH1cbiAgICB0aGlzLnNldENvbnRleHRUZXh0U3RhdGVfKHRoaXMudGV4dFN0YXRlXyk7XG4gICAgdmFyIHBpeGVsQ29vcmRpbmF0ZXMgPSB0cmFuc2Zvcm0yRChcbiAgICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgdGhpcy50cmFuc2Zvcm1fLFxuICAgICAgdGhpcy5waXhlbENvb3JkaW5hdGVzXyk7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHRfO1xuICAgIHZhciByb3RhdGlvbiA9IHRoaXMudGV4dFJvdGF0aW9uXztcbiAgICBpZiAodGhpcy50ZXh0Um90YXRlV2l0aFZpZXdfKSB7XG4gICAgICByb3RhdGlvbiArPSB0aGlzLnZpZXdSb3RhdGlvbl87XG4gICAgfVxuICAgIGZvciAoOyBvZmZzZXQgPCBlbmQ7IG9mZnNldCArPSBzdHJpZGUpIHtcbiAgICAgIHZhciB4ID0gcGl4ZWxDb29yZGluYXRlc1tvZmZzZXRdICsgdGhpcy50ZXh0T2Zmc2V0WF87XG4gICAgICB2YXIgeSA9IHBpeGVsQ29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV0gKyB0aGlzLnRleHRPZmZzZXRZXztcbiAgICAgIGlmIChyb3RhdGlvbiAhPT0gMCB8fCB0aGlzLnRleHRTY2FsZV8gIT0gMSkge1xuICAgICAgICB2YXIgbG9jYWxUcmFuc2Zvcm0gPSBjb21wb3NlVHJhbnNmb3JtKHRoaXMudG1wTG9jYWxUcmFuc2Zvcm1fLFxuICAgICAgICAgIHgsIHksXG4gICAgICAgICAgdGhpcy50ZXh0U2NhbGVfLCB0aGlzLnRleHRTY2FsZV8sXG4gICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgLXgsIC15KTtcbiAgICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0uYXBwbHkoY29udGV4dCwgbG9jYWxUcmFuc2Zvcm0pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudGV4dFN0cm9rZVN0YXRlXykge1xuICAgICAgICBjb250ZXh0LnN0cm9rZVRleHQodGhpcy50ZXh0XywgeCwgeSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50ZXh0RmlsbFN0YXRlXykge1xuICAgICAgICBjb250ZXh0LmZpbGxUZXh0KHRoaXMudGV4dF8sIHgsIHkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocm90YXRpb24gIT09IDAgfHwgdGhpcy50ZXh0U2NhbGVfICE9IDEpIHtcbiAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBjbG9zZSBDbG9zZS5cbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7bnVtYmVyfSBlbmQgRW5kLlxuICAgKi9cbiAgQ2FudmFzSW1tZWRpYXRlUmVuZGVyZXIucHJvdG90eXBlLm1vdmVUb0xpbmVUb18gPSBmdW5jdGlvbiBtb3ZlVG9MaW5lVG9fIChmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIGNsb3NlKSB7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHRfO1xuICAgIHZhciBwaXhlbENvb3JkaW5hdGVzID0gdHJhbnNmb3JtMkQoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIHRoaXMudHJhbnNmb3JtXyxcbiAgICAgIHRoaXMucGl4ZWxDb29yZGluYXRlc18pO1xuICAgIGNvbnRleHQubW92ZVRvKHBpeGVsQ29vcmRpbmF0ZXNbMF0sIHBpeGVsQ29vcmRpbmF0ZXNbMV0pO1xuICAgIHZhciBsZW5ndGggPSBwaXhlbENvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICBpZiAoY2xvc2UpIHtcbiAgICAgIGxlbmd0aCAtPSAyO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IGxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBjb250ZXh0LmxpbmVUbyhwaXhlbENvb3JkaW5hdGVzW2ldLCBwaXhlbENvb3JkaW5hdGVzW2kgKyAxXSk7XG4gICAgfVxuICAgIGlmIChjbG9zZSkge1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gICAgcmV0dXJuIGVuZDtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW5kcyBFbmRzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7bnVtYmVyfSBFbmQuXG4gICAqL1xuICBDYW52YXNJbW1lZGlhdGVSZW5kZXJlci5wcm90b3R5cGUuZHJhd1JpbmdzXyA9IGZ1bmN0aW9uIGRyYXdSaW5nc18gKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLCBzdHJpZGUpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIG9mZnNldCA9IHRoaXMubW92ZVRvTGluZVRvXyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kc1tpXSwgc3RyaWRlLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVyIGEgY2lyY2xlIGdlb21ldHJ5IGludG8gdGhlIGNhbnZhcy4gIFJlbmRlcmluZyBpcyBpbW1lZGlhdGUgYW5kIHVzZXNcbiAgICogdGhlIGN1cnJlbnQgZmlsbCBhbmQgc3Ryb2tlIHN0eWxlcy5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9nZW9tL0NpcmNsZS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBDaXJjbGUgZ2VvbWV0cnkuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBDYW52YXNJbW1lZGlhdGVSZW5kZXJlci5wcm90b3R5cGUuZHJhd0NpcmNsZSA9IGZ1bmN0aW9uIGRyYXdDaXJjbGUgKGdlb21ldHJ5KSB7XG4gICAgaWYgKCFpbnRlcnNlY3RzKHRoaXMuZXh0ZW50XywgZ2VvbWV0cnkuZ2V0RXh0ZW50KCkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmZpbGxTdGF0ZV8gfHwgdGhpcy5zdHJva2VTdGF0ZV8pIHtcbiAgICAgIGlmICh0aGlzLmZpbGxTdGF0ZV8pIHtcbiAgICAgICAgdGhpcy5zZXRDb250ZXh0RmlsbFN0YXRlXyh0aGlzLmZpbGxTdGF0ZV8pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3Ryb2tlU3RhdGVfKSB7XG4gICAgICAgIHRoaXMuc2V0Q29udGV4dFN0cm9rZVN0YXRlXyh0aGlzLnN0cm9rZVN0YXRlXyk7XG4gICAgICB9XG4gICAgICB2YXIgcGl4ZWxDb29yZGluYXRlcyA9IHRyYW5zZm9ybUdlb20yRChcbiAgICAgICAgZ2VvbWV0cnksIHRoaXMudHJhbnNmb3JtXywgdGhpcy5waXhlbENvb3JkaW5hdGVzXyk7XG4gICAgICB2YXIgZHggPSBwaXhlbENvb3JkaW5hdGVzWzJdIC0gcGl4ZWxDb29yZGluYXRlc1swXTtcbiAgICAgIHZhciBkeSA9IHBpeGVsQ29vcmRpbmF0ZXNbM10gLSBwaXhlbENvb3JkaW5hdGVzWzFdO1xuICAgICAgdmFyIHJhZGl1cyA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dF87XG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgY29udGV4dC5hcmMoXG4gICAgICAgIHBpeGVsQ29vcmRpbmF0ZXNbMF0sIHBpeGVsQ29vcmRpbmF0ZXNbMV0sIHJhZGl1cywgMCwgMiAqIE1hdGguUEkpO1xuICAgICAgaWYgKHRoaXMuZmlsbFN0YXRlXykge1xuICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0cm9rZVN0YXRlXykge1xuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy50ZXh0XyAhPT0gJycpIHtcbiAgICAgIHRoaXMuZHJhd1RleHRfKGdlb21ldHJ5LmdldENlbnRlcigpLCAwLCAyLCAyKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcmVuZGVyaW5nIHN0eWxlLiAgTm90ZSB0aGF0IHNpbmNlIHRoaXMgaXMgYW4gaW1tZWRpYXRlIHJlbmRlcmluZyBBUEksXG4gICAqIGFueSBgekluZGV4YCBvbiB0aGUgcHJvdmlkZWQgc3R5bGUgd2lsbCBiZSBpZ25vcmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHR9IHN0eWxlIFRoZSByZW5kZXJpbmcgc3R5bGUuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBDYW52YXNJbW1lZGlhdGVSZW5kZXJlci5wcm90b3R5cGUuc2V0U3R5bGUgPSBmdW5jdGlvbiBzZXRTdHlsZSAoc3R5bGUpIHtcbiAgICB0aGlzLnNldEZpbGxTdHJva2VTdHlsZShzdHlsZS5nZXRGaWxsKCksIHN0eWxlLmdldFN0cm9rZSgpKTtcbiAgICB0aGlzLnNldEltYWdlU3R5bGUoc3R5bGUuZ2V0SW1hZ2UoKSk7XG4gICAgdGhpcy5zZXRUZXh0U3R5bGUoc3R5bGUuZ2V0VGV4dCgpKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVyIGEgZ2VvbWV0cnkgaW50byB0aGUgY2FudmFzLiAgQ2FsbFxuICAgKiB7QGxpbmsgbW9kdWxlOm9sL3JlbmRlci9jYW52YXMvSW1tZWRpYXRlI3NldFN0eWxlfSBmaXJzdCB0byBzZXQgdGhlIHJlbmRlcmluZyBzdHlsZS5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBUaGUgZ2VvbWV0cnkgdG8gcmVuZGVyLlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGFwaVxuICAgKi9cbiAgQ2FudmFzSW1tZWRpYXRlUmVuZGVyZXIucHJvdG90eXBlLmRyYXdHZW9tZXRyeSA9IGZ1bmN0aW9uIGRyYXdHZW9tZXRyeSAoZ2VvbWV0cnkpIHtcbiAgICB2YXIgdHlwZSA9IGdlb21ldHJ5LmdldFR5cGUoKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgR2VvbWV0cnlUeXBlLlBPSU5UOlxuICAgICAgICB0aGlzLmRyYXdQb2ludCgvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2dlb20vUG9pbnQuanNcIikuZGVmYXVsdH0gKi8gKGdlb21ldHJ5KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuTElORV9TVFJJTkc6XG4gICAgICAgIHRoaXMuZHJhd0xpbmVTdHJpbmcoLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9nZW9tL0xpbmVTdHJpbmcuanNcIikuZGVmYXVsdH0gKi8gKGdlb21ldHJ5KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuUE9MWUdPTjpcbiAgICAgICAgdGhpcy5kcmF3UG9seWdvbigvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2dlb20vUG9seWdvbi5qc1wiKS5kZWZhdWx0fSAqLyAoZ2VvbWV0cnkpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEdlb21ldHJ5VHlwZS5NVUxUSV9QT0lOVDpcbiAgICAgICAgdGhpcy5kcmF3TXVsdGlQb2ludCgvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2dlb20vTXVsdGlQb2ludC5qc1wiKS5kZWZhdWx0fSAqLyAoZ2VvbWV0cnkpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEdlb21ldHJ5VHlwZS5NVUxUSV9MSU5FX1NUUklORzpcbiAgICAgICAgdGhpcy5kcmF3TXVsdGlMaW5lU3RyaW5nKC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9NdWx0aUxpbmVTdHJpbmcuanNcIikuZGVmYXVsdH0gKi8gKGdlb21ldHJ5KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuTVVMVElfUE9MWUdPTjpcbiAgICAgICAgdGhpcy5kcmF3TXVsdGlQb2x5Z29uKC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9NdWx0aVBvbHlnb24uanNcIikuZGVmYXVsdH0gKi8gKGdlb21ldHJ5KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuR0VPTUVUUllfQ09MTEVDVElPTjpcbiAgICAgICAgdGhpcy5kcmF3R2VvbWV0cnlDb2xsZWN0aW9uKC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9HZW9tZXRyeUNvbGxlY3Rpb24uanNcIikuZGVmYXVsdH0gKi8gKGdlb21ldHJ5KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuQ0lSQ0xFOlxuICAgICAgICB0aGlzLmRyYXdDaXJjbGUoLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9nZW9tL0NpcmNsZS5qc1wiKS5kZWZhdWx0fSAqLyAoZ2VvbWV0cnkpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVyIGEgZmVhdHVyZSBpbnRvIHRoZSBjYW52YXMuICBOb3RlIHRoYXQgYW55IGB6SW5kZXhgIG9uIHRoZSBwcm92aWRlZFxuICAgKiBzdHlsZSB3aWxsIGJlIGlnbm9yZWQgLSBmZWF0dXJlcyBhcmUgcmVuZGVyZWQgaW1tZWRpYXRlbHkgaW4gdGhlIG9yZGVyIHRoYXRcbiAgICogdGhpcyBtZXRob2QgaXMgY2FsbGVkLiAgSWYgeW91IG5lZWQgYHpJbmRleGAgc3VwcG9ydCwgeW91IHNob3VsZCBiZSB1c2luZyBhblxuICAgKiB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL1ZlY3Rvcn5WZWN0b3JMYXllcn0gaW5zdGVhZC5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9zdHlsZS9TdHlsZS5qc1wiKS5kZWZhdWx0fSBzdHlsZSBTdHlsZS5cbiAgICogQG92ZXJyaWRlXG4gICAqIEBhcGlcbiAgICovXG4gIENhbnZhc0ltbWVkaWF0ZVJlbmRlcmVyLnByb3RvdHlwZS5kcmF3RmVhdHVyZSA9IGZ1bmN0aW9uIGRyYXdGZWF0dXJlIChmZWF0dXJlLCBzdHlsZSkge1xuICAgIHZhciBnZW9tZXRyeSA9IHN0eWxlLmdldEdlb21ldHJ5RnVuY3Rpb24oKShmZWF0dXJlKTtcbiAgICBpZiAoIWdlb21ldHJ5IHx8ICFpbnRlcnNlY3RzKHRoaXMuZXh0ZW50XywgZ2VvbWV0cnkuZ2V0RXh0ZW50KCkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2V0U3R5bGUoc3R5bGUpO1xuICAgIHRoaXMuZHJhd0dlb21ldHJ5KGdlb21ldHJ5KTtcbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVyIGEgR2VvbWV0cnlDb2xsZWN0aW9uIHRvIHRoZSBjYW52YXMuICBSZW5kZXJpbmcgaXMgaW1tZWRpYXRlIGFuZFxuICAgKiB1c2VzIHRoZSBjdXJyZW50IHN0eWxlcyBhcHByb3ByaWF0ZSBmb3IgZWFjaCBnZW9tZXRyeSBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9nZW9tL0dlb21ldHJ5Q29sbGVjdGlvbi5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeSBjb2xsZWN0aW9uLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIENhbnZhc0ltbWVkaWF0ZVJlbmRlcmVyLnByb3RvdHlwZS5kcmF3R2VvbWV0cnlDb2xsZWN0aW9uID0gZnVuY3Rpb24gZHJhd0dlb21ldHJ5Q29sbGVjdGlvbiAoZ2VvbWV0cnkpIHtcbiAgICB2YXIgZ2VvbWV0cmllcyA9IGdlb21ldHJ5LmdldEdlb21ldHJpZXNBcnJheSgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGdlb21ldHJpZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgdGhpcy5kcmF3R2VvbWV0cnkoZ2VvbWV0cmllc1tpXSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgYSBQb2ludCBnZW9tZXRyeSBpbnRvIHRoZSBjYW52YXMuICBSZW5kZXJpbmcgaXMgaW1tZWRpYXRlIGFuZCB1c2VzXG4gICAqIHRoZSBjdXJyZW50IHN0eWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2dlb20vUG9pbnQuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IFBvaW50IGdlb21ldHJ5LlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIENhbnZhc0ltbWVkaWF0ZVJlbmRlcmVyLnByb3RvdHlwZS5kcmF3UG9pbnQgPSBmdW5jdGlvbiBkcmF3UG9pbnQgKGdlb21ldHJ5KSB7XG4gICAgdmFyIGZsYXRDb29yZGluYXRlcyA9IGdlb21ldHJ5LmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgIHZhciBzdHJpZGUgPSBnZW9tZXRyeS5nZXRTdHJpZGUoKTtcbiAgICBpZiAodGhpcy5pbWFnZV8pIHtcbiAgICAgIHRoaXMuZHJhd0ltYWdlc18oZmxhdENvb3JkaW5hdGVzLCAwLCBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLCBzdHJpZGUpO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXh0XyAhPT0gJycpIHtcbiAgICAgIHRoaXMuZHJhd1RleHRfKGZsYXRDb29yZGluYXRlcywgMCwgZmxhdENvb3JkaW5hdGVzLmxlbmd0aCwgc3RyaWRlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlciBhIE11bHRpUG9pbnQgZ2VvbWV0cnkgIGludG8gdGhlIGNhbnZhcy4gIFJlbmRlcmluZyBpcyBpbW1lZGlhdGUgYW5kXG4gICAqIHVzZXMgdGhlIGN1cnJlbnQgc3R5bGUuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9NdWx0aVBvaW50LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBNdWx0aVBvaW50IGdlb21ldHJ5LlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIENhbnZhc0ltbWVkaWF0ZVJlbmRlcmVyLnByb3RvdHlwZS5kcmF3TXVsdGlQb2ludCA9IGZ1bmN0aW9uIGRyYXdNdWx0aVBvaW50IChnZW9tZXRyeSkge1xuICAgIHZhciBmbGF0Q29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICB2YXIgc3RyaWRlID0gZ2VvbWV0cnkuZ2V0U3RyaWRlKCk7XG4gICAgaWYgKHRoaXMuaW1hZ2VfKSB7XG4gICAgICB0aGlzLmRyYXdJbWFnZXNfKGZsYXRDb29yZGluYXRlcywgMCwgZmxhdENvb3JkaW5hdGVzLmxlbmd0aCwgc3RyaWRlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGV4dF8gIT09ICcnKSB7XG4gICAgICB0aGlzLmRyYXdUZXh0XyhmbGF0Q29vcmRpbmF0ZXMsIDAsIGZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHN0cmlkZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgYSBMaW5lU3RyaW5nIGludG8gdGhlIGNhbnZhcy4gIFJlbmRlcmluZyBpcyBpbW1lZGlhdGUgYW5kIHVzZXNcbiAgICogdGhlIGN1cnJlbnQgc3R5bGUuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9MaW5lU3RyaW5nLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBMaW5lU3RyaW5nIGdlb21ldHJ5LlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIENhbnZhc0ltbWVkaWF0ZVJlbmRlcmVyLnByb3RvdHlwZS5kcmF3TGluZVN0cmluZyA9IGZ1bmN0aW9uIGRyYXdMaW5lU3RyaW5nIChnZW9tZXRyeSkge1xuICAgIGlmICghaW50ZXJzZWN0cyh0aGlzLmV4dGVudF8sIGdlb21ldHJ5LmdldEV4dGVudCgpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdHJva2VTdGF0ZV8pIHtcbiAgICAgIHRoaXMuc2V0Q29udGV4dFN0cm9rZVN0YXRlXyh0aGlzLnN0cm9rZVN0YXRlXyk7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dF87XG4gICAgICB2YXIgZmxhdENvb3JkaW5hdGVzID0gZ2VvbWV0cnkuZ2V0RmxhdENvb3JkaW5hdGVzKCk7XG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgdGhpcy5tb3ZlVG9MaW5lVG9fKGZsYXRDb29yZGluYXRlcywgMCwgZmxhdENvb3JkaW5hdGVzLmxlbmd0aCxcbiAgICAgICAgZ2VvbWV0cnkuZ2V0U3RyaWRlKCksIGZhbHNlKTtcbiAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRleHRfICE9PSAnJykge1xuICAgICAgdmFyIGZsYXRNaWRwb2ludCA9IGdlb21ldHJ5LmdldEZsYXRNaWRwb2ludCgpO1xuICAgICAgdGhpcy5kcmF3VGV4dF8oZmxhdE1pZHBvaW50LCAwLCAyLCAyKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlciBhIE11bHRpTGluZVN0cmluZyBnZW9tZXRyeSBpbnRvIHRoZSBjYW52YXMuICBSZW5kZXJpbmcgaXMgaW1tZWRpYXRlXG4gICAqIGFuZCB1c2VzIHRoZSBjdXJyZW50IHN0eWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2dlb20vTXVsdGlMaW5lU3RyaW5nLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBNdWx0aUxpbmVTdHJpbmcgZ2VvbWV0cnkuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgQ2FudmFzSW1tZWRpYXRlUmVuZGVyZXIucHJvdG90eXBlLmRyYXdNdWx0aUxpbmVTdHJpbmcgPSBmdW5jdGlvbiBkcmF3TXVsdGlMaW5lU3RyaW5nIChnZW9tZXRyeSkge1xuICAgIHZhciBnZW9tZXRyeUV4dGVudCA9IGdlb21ldHJ5LmdldEV4dGVudCgpO1xuICAgIGlmICghaW50ZXJzZWN0cyh0aGlzLmV4dGVudF8sIGdlb21ldHJ5RXh0ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdHJva2VTdGF0ZV8pIHtcbiAgICAgIHRoaXMuc2V0Q29udGV4dFN0cm9rZVN0YXRlXyh0aGlzLnN0cm9rZVN0YXRlXyk7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dF87XG4gICAgICB2YXIgZmxhdENvb3JkaW5hdGVzID0gZ2VvbWV0cnkuZ2V0RmxhdENvb3JkaW5hdGVzKCk7XG4gICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgIHZhciBlbmRzID0gLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqLyAoZ2VvbWV0cnkuZ2V0RW5kcygpKTtcbiAgICAgIHZhciBzdHJpZGUgPSBnZW9tZXRyeS5nZXRTdHJpZGUoKTtcbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgb2Zmc2V0ID0gdGhpcy5tb3ZlVG9MaW5lVG9fKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzW2ldLCBzdHJpZGUsIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRleHRfICE9PSAnJykge1xuICAgICAgdmFyIGZsYXRNaWRwb2ludHMgPSBnZW9tZXRyeS5nZXRGbGF0TWlkcG9pbnRzKCk7XG4gICAgICB0aGlzLmRyYXdUZXh0XyhmbGF0TWlkcG9pbnRzLCAwLCBmbGF0TWlkcG9pbnRzLmxlbmd0aCwgMik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgYSBQb2x5Z29uIGdlb21ldHJ5IGludG8gdGhlIGNhbnZhcy4gIFJlbmRlcmluZyBpcyBpbW1lZGlhdGUgYW5kIHVzZXNcbiAgICogdGhlIGN1cnJlbnQgc3R5bGUuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9Qb2x5Z29uLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBQb2x5Z29uIGdlb21ldHJ5LlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIENhbnZhc0ltbWVkaWF0ZVJlbmRlcmVyLnByb3RvdHlwZS5kcmF3UG9seWdvbiA9IGZ1bmN0aW9uIGRyYXdQb2x5Z29uIChnZW9tZXRyeSkge1xuICAgIGlmICghaW50ZXJzZWN0cyh0aGlzLmV4dGVudF8sIGdlb21ldHJ5LmdldEV4dGVudCgpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdHJva2VTdGF0ZV8gfHwgdGhpcy5maWxsU3RhdGVfKSB7XG4gICAgICBpZiAodGhpcy5maWxsU3RhdGVfKSB7XG4gICAgICAgIHRoaXMuc2V0Q29udGV4dEZpbGxTdGF0ZV8odGhpcy5maWxsU3RhdGVfKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0cm9rZVN0YXRlXykge1xuICAgICAgICB0aGlzLnNldENvbnRleHRTdHJva2VTdGF0ZV8odGhpcy5zdHJva2VTdGF0ZV8pO1xuICAgICAgfVxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHRfO1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIHRoaXMuZHJhd1JpbmdzXyhnZW9tZXRyeS5nZXRPcmllbnRlZEZsYXRDb29yZGluYXRlcygpLFxuICAgICAgICAwLCAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovIChnZW9tZXRyeS5nZXRFbmRzKCkpLCBnZW9tZXRyeS5nZXRTdHJpZGUoKSk7XG4gICAgICBpZiAodGhpcy5maWxsU3RhdGVfKSB7XG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3Ryb2tlU3RhdGVfKSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnRleHRfICE9PSAnJykge1xuICAgICAgdmFyIGZsYXRJbnRlcmlvclBvaW50ID0gZ2VvbWV0cnkuZ2V0RmxhdEludGVyaW9yUG9pbnQoKTtcbiAgICAgIHRoaXMuZHJhd1RleHRfKGZsYXRJbnRlcmlvclBvaW50LCAwLCAyLCAyKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlciBNdWx0aVBvbHlnb24gZ2VvbWV0cnkgaW50byB0aGUgY2FudmFzLiAgUmVuZGVyaW5nIGlzIGltbWVkaWF0ZSBhbmRcbiAgICogdXNlcyB0aGUgY3VycmVudCBzdHlsZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9nZW9tL011bHRpUG9seWdvbi5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBNdWx0aVBvbHlnb24gZ2VvbWV0cnkuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgQ2FudmFzSW1tZWRpYXRlUmVuZGVyZXIucHJvdG90eXBlLmRyYXdNdWx0aVBvbHlnb24gPSBmdW5jdGlvbiBkcmF3TXVsdGlQb2x5Z29uIChnZW9tZXRyeSkge1xuICAgIGlmICghaW50ZXJzZWN0cyh0aGlzLmV4dGVudF8sIGdlb21ldHJ5LmdldEV4dGVudCgpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdHJva2VTdGF0ZV8gfHwgdGhpcy5maWxsU3RhdGVfKSB7XG4gICAgICBpZiAodGhpcy5maWxsU3RhdGVfKSB7XG4gICAgICAgIHRoaXMuc2V0Q29udGV4dEZpbGxTdGF0ZV8odGhpcy5maWxsU3RhdGVfKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0cm9rZVN0YXRlXykge1xuICAgICAgICB0aGlzLnNldENvbnRleHRTdHJva2VTdGF0ZV8odGhpcy5zdHJva2VTdGF0ZV8pO1xuICAgICAgfVxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHRfO1xuICAgICAgdmFyIGZsYXRDb29yZGluYXRlcyA9IGdlb21ldHJ5LmdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzKCk7XG4gICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgIHZhciBlbmRzcyA9IGdlb21ldHJ5LmdldEVuZHNzKCk7XG4gICAgICB2YXIgc3RyaWRlID0gZ2VvbWV0cnkuZ2V0U3RyaWRlKCk7XG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZW5kc3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICB2YXIgZW5kcyA9IGVuZHNzW2ldO1xuICAgICAgICBvZmZzZXQgPSB0aGlzLmRyYXdSaW5nc18oZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHMsIHN0cmlkZSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5maWxsU3RhdGVfKSB7XG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3Ryb2tlU3RhdGVfKSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnRleHRfICE9PSAnJykge1xuICAgICAgdmFyIGZsYXRJbnRlcmlvclBvaW50cyA9IGdlb21ldHJ5LmdldEZsYXRJbnRlcmlvclBvaW50cygpO1xuICAgICAgdGhpcy5kcmF3VGV4dF8oZmxhdEludGVyaW9yUG9pbnRzLCAwLCBmbGF0SW50ZXJpb3JQb2ludHMubGVuZ3RoLCAyKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkZpbGxTdGF0ZX0gZmlsbFN0YXRlIEZpbGwgc3RhdGUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBDYW52YXNJbW1lZGlhdGVSZW5kZXJlci5wcm90b3R5cGUuc2V0Q29udGV4dEZpbGxTdGF0ZV8gPSBmdW5jdGlvbiBzZXRDb250ZXh0RmlsbFN0YXRlXyAoZmlsbFN0YXRlKSB7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHRfO1xuICAgIHZhciBjb250ZXh0RmlsbFN0YXRlID0gdGhpcy5jb250ZXh0RmlsbFN0YXRlXztcbiAgICBpZiAoIWNvbnRleHRGaWxsU3RhdGUpIHtcbiAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gZmlsbFN0YXRlLmZpbGxTdHlsZTtcbiAgICAgIHRoaXMuY29udGV4dEZpbGxTdGF0ZV8gPSB7XG4gICAgICAgIGZpbGxTdHlsZTogZmlsbFN0YXRlLmZpbGxTdHlsZVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNvbnRleHRGaWxsU3RhdGUuZmlsbFN0eWxlICE9IGZpbGxTdGF0ZS5maWxsU3R5bGUpIHtcbiAgICAgICAgY29udGV4dEZpbGxTdGF0ZS5maWxsU3R5bGUgPSBjb250ZXh0LmZpbGxTdHlsZSA9IGZpbGxTdGF0ZS5maWxsU3R5bGU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5TdHJva2VTdGF0ZX0gc3Ryb2tlU3RhdGUgU3Ryb2tlIHN0YXRlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQ2FudmFzSW1tZWRpYXRlUmVuZGVyZXIucHJvdG90eXBlLnNldENvbnRleHRTdHJva2VTdGF0ZV8gPSBmdW5jdGlvbiBzZXRDb250ZXh0U3Ryb2tlU3RhdGVfIChzdHJva2VTdGF0ZSkge1xuICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0XztcbiAgICB2YXIgY29udGV4dFN0cm9rZVN0YXRlID0gdGhpcy5jb250ZXh0U3Ryb2tlU3RhdGVfO1xuICAgIGlmICghY29udGV4dFN0cm9rZVN0YXRlKSB7XG4gICAgICBjb250ZXh0LmxpbmVDYXAgPSAvKiogQHR5cGUge0NhbnZhc0xpbmVDYXB9ICovIChzdHJva2VTdGF0ZS5saW5lQ2FwKTtcbiAgICAgIGlmIChDQU5WQVNfTElORV9EQVNIKSB7XG4gICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goc3Ryb2tlU3RhdGUubGluZURhc2gpO1xuICAgICAgICBjb250ZXh0LmxpbmVEYXNoT2Zmc2V0ID0gc3Ryb2tlU3RhdGUubGluZURhc2hPZmZzZXQ7XG4gICAgICB9XG4gICAgICBjb250ZXh0LmxpbmVKb2luID0gLyoqIEB0eXBlIHtDYW52YXNMaW5lSm9pbn0gKi8gKHN0cm9rZVN0YXRlLmxpbmVKb2luKTtcbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gc3Ryb2tlU3RhdGUubGluZVdpZHRoO1xuICAgICAgY29udGV4dC5taXRlckxpbWl0ID0gc3Ryb2tlU3RhdGUubWl0ZXJMaW1pdDtcbiAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBzdHJva2VTdGF0ZS5zdHJva2VTdHlsZTtcbiAgICAgIHRoaXMuY29udGV4dFN0cm9rZVN0YXRlXyA9IHtcbiAgICAgICAgbGluZUNhcDogc3Ryb2tlU3RhdGUubGluZUNhcCxcbiAgICAgICAgbGluZURhc2g6IHN0cm9rZVN0YXRlLmxpbmVEYXNoLFxuICAgICAgICBsaW5lRGFzaE9mZnNldDogc3Ryb2tlU3RhdGUubGluZURhc2hPZmZzZXQsXG4gICAgICAgIGxpbmVKb2luOiBzdHJva2VTdGF0ZS5saW5lSm9pbixcbiAgICAgICAgbGluZVdpZHRoOiBzdHJva2VTdGF0ZS5saW5lV2lkdGgsXG4gICAgICAgIG1pdGVyTGltaXQ6IHN0cm9rZVN0YXRlLm1pdGVyTGltaXQsXG4gICAgICAgIHN0cm9rZVN0eWxlOiBzdHJva2VTdGF0ZS5zdHJva2VTdHlsZVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNvbnRleHRTdHJva2VTdGF0ZS5saW5lQ2FwICE9IHN0cm9rZVN0YXRlLmxpbmVDYXApIHtcbiAgICAgICAgY29udGV4dFN0cm9rZVN0YXRlLmxpbmVDYXAgPSBjb250ZXh0LmxpbmVDYXAgPSAvKiogQHR5cGUge0NhbnZhc0xpbmVDYXB9ICovIChzdHJva2VTdGF0ZS5saW5lQ2FwKTtcbiAgICAgIH1cbiAgICAgIGlmIChDQU5WQVNfTElORV9EQVNIKSB7XG4gICAgICAgIGlmICghZXF1YWxzKGNvbnRleHRTdHJva2VTdGF0ZS5saW5lRGFzaCwgc3Ryb2tlU3RhdGUubGluZURhc2gpKSB7XG4gICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChjb250ZXh0U3Ryb2tlU3RhdGUubGluZURhc2ggPSBzdHJva2VTdGF0ZS5saW5lRGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRleHRTdHJva2VTdGF0ZS5saW5lRGFzaE9mZnNldCAhPSBzdHJva2VTdGF0ZS5saW5lRGFzaE9mZnNldCkge1xuICAgICAgICAgIGNvbnRleHRTdHJva2VTdGF0ZS5saW5lRGFzaE9mZnNldCA9IGNvbnRleHQubGluZURhc2hPZmZzZXQgPVxuICAgICAgICAgICAgICBzdHJva2VTdGF0ZS5saW5lRGFzaE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNvbnRleHRTdHJva2VTdGF0ZS5saW5lSm9pbiAhPSBzdHJva2VTdGF0ZS5saW5lSm9pbikge1xuICAgICAgICBjb250ZXh0U3Ryb2tlU3RhdGUubGluZUpvaW4gPSBjb250ZXh0LmxpbmVKb2luID0gLyoqIEB0eXBlIHtDYW52YXNMaW5lSm9pbn0gKi8gKHN0cm9rZVN0YXRlLmxpbmVKb2luKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb250ZXh0U3Ryb2tlU3RhdGUubGluZVdpZHRoICE9IHN0cm9rZVN0YXRlLmxpbmVXaWR0aCkge1xuICAgICAgICBjb250ZXh0U3Ryb2tlU3RhdGUubGluZVdpZHRoID0gY29udGV4dC5saW5lV2lkdGggPSBzdHJva2VTdGF0ZS5saW5lV2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAoY29udGV4dFN0cm9rZVN0YXRlLm1pdGVyTGltaXQgIT0gc3Ryb2tlU3RhdGUubWl0ZXJMaW1pdCkge1xuICAgICAgICBjb250ZXh0U3Ryb2tlU3RhdGUubWl0ZXJMaW1pdCA9IGNvbnRleHQubWl0ZXJMaW1pdCA9XG4gICAgICAgICAgICBzdHJva2VTdGF0ZS5taXRlckxpbWl0O1xuICAgICAgfVxuICAgICAgaWYgKGNvbnRleHRTdHJva2VTdGF0ZS5zdHJva2VTdHlsZSAhPSBzdHJva2VTdGF0ZS5zdHJva2VTdHlsZSkge1xuICAgICAgICBjb250ZXh0U3Ryb2tlU3RhdGUuc3Ryb2tlU3R5bGUgPSBjb250ZXh0LnN0cm9rZVN0eWxlID1cbiAgICAgICAgICAgIHN0cm9rZVN0YXRlLnN0cm9rZVN0eWxlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuVGV4dFN0YXRlfSB0ZXh0U3RhdGUgVGV4dCBzdGF0ZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIENhbnZhc0ltbWVkaWF0ZVJlbmRlcmVyLnByb3RvdHlwZS5zZXRDb250ZXh0VGV4dFN0YXRlXyA9IGZ1bmN0aW9uIHNldENvbnRleHRUZXh0U3RhdGVfICh0ZXh0U3RhdGUpIHtcbiAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dF87XG4gICAgdmFyIGNvbnRleHRUZXh0U3RhdGUgPSB0aGlzLmNvbnRleHRUZXh0U3RhdGVfO1xuICAgIHZhciB0ZXh0QWxpZ24gPSB0ZXh0U3RhdGUudGV4dEFsaWduID9cbiAgICAgIHRleHRTdGF0ZS50ZXh0QWxpZ24gOiBkZWZhdWx0VGV4dEFsaWduO1xuICAgIGlmICghY29udGV4dFRleHRTdGF0ZSkge1xuICAgICAgY29udGV4dC5mb250ID0gdGV4dFN0YXRlLmZvbnQ7XG4gICAgICBjb250ZXh0LnRleHRBbGlnbiA9IC8qKiBAdHlwZSB7Q2FudmFzVGV4dEFsaWdufSAqLyAodGV4dEFsaWduKTtcbiAgICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gLyoqIEB0eXBlIHtDYW52YXNUZXh0QmFzZWxpbmV9ICovICh0ZXh0U3RhdGUudGV4dEJhc2VsaW5lKTtcbiAgICAgIHRoaXMuY29udGV4dFRleHRTdGF0ZV8gPSB7XG4gICAgICAgIGZvbnQ6IHRleHRTdGF0ZS5mb250LFxuICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgdGV4dEJhc2VsaW5lOiB0ZXh0U3RhdGUudGV4dEJhc2VsaW5lXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY29udGV4dFRleHRTdGF0ZS5mb250ICE9IHRleHRTdGF0ZS5mb250KSB7XG4gICAgICAgIGNvbnRleHRUZXh0U3RhdGUuZm9udCA9IGNvbnRleHQuZm9udCA9IHRleHRTdGF0ZS5mb250O1xuICAgICAgfVxuICAgICAgaWYgKGNvbnRleHRUZXh0U3RhdGUudGV4dEFsaWduICE9IHRleHRBbGlnbikge1xuICAgICAgICBjb250ZXh0VGV4dFN0YXRlLnRleHRBbGlnbiA9IGNvbnRleHQudGV4dEFsaWduID0gLyoqIEB0eXBlIHtDYW52YXNUZXh0QWxpZ259ICovICh0ZXh0QWxpZ24pO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnRleHRUZXh0U3RhdGUudGV4dEJhc2VsaW5lICE9IHRleHRTdGF0ZS50ZXh0QmFzZWxpbmUpIHtcbiAgICAgICAgY29udGV4dFRleHRTdGF0ZS50ZXh0QmFzZWxpbmUgPSBjb250ZXh0LnRleHRCYXNlbGluZSA9XG4gICAgICAgICAgLyoqIEB0eXBlIHtDYW52YXNUZXh0QmFzZWxpbmV9ICovICh0ZXh0U3RhdGUudGV4dEJhc2VsaW5lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZmlsbCBhbmQgc3Ryb2tlIHN0eWxlIGZvciBzdWJzZXF1ZW50IGRyYXcgb3BlcmF0aW9ucy4gIFRvIGNsZWFyXG4gICAqIGVpdGhlciBmaWxsIG9yIHN0cm9rZSBzdHlsZXMsIHBhc3MgbnVsbCBmb3IgdGhlIGFwcHJvcHJpYXRlIHBhcmFtZXRlci5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9zdHlsZS9GaWxsLmpzXCIpLmRlZmF1bHR9IGZpbGxTdHlsZSBGaWxsIHN0eWxlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3N0eWxlL1N0cm9rZS5qc1wiKS5kZWZhdWx0fSBzdHJva2VTdHlsZSBTdHJva2Ugc3R5bGUuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgQ2FudmFzSW1tZWRpYXRlUmVuZGVyZXIucHJvdG90eXBlLnNldEZpbGxTdHJva2VTdHlsZSA9IGZ1bmN0aW9uIHNldEZpbGxTdHJva2VTdHlsZSAoZmlsbFN0eWxlLCBzdHJva2VTdHlsZSkge1xuICAgIGlmICghZmlsbFN0eWxlKSB7XG4gICAgICB0aGlzLmZpbGxTdGF0ZV8gPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZmlsbFN0eWxlQ29sb3IgPSBmaWxsU3R5bGUuZ2V0Q29sb3IoKTtcbiAgICAgIHRoaXMuZmlsbFN0YXRlXyA9IHtcbiAgICAgICAgZmlsbFN0eWxlOiBhc0NvbG9yTGlrZShmaWxsU3R5bGVDb2xvciA/XG4gICAgICAgICAgZmlsbFN0eWxlQ29sb3IgOiBkZWZhdWx0RmlsbFN0eWxlKVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFzdHJva2VTdHlsZSkge1xuICAgICAgdGhpcy5zdHJva2VTdGF0ZV8gPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3Ryb2tlU3R5bGVDb2xvciA9IHN0cm9rZVN0eWxlLmdldENvbG9yKCk7XG4gICAgICB2YXIgc3Ryb2tlU3R5bGVMaW5lQ2FwID0gc3Ryb2tlU3R5bGUuZ2V0TGluZUNhcCgpO1xuICAgICAgdmFyIHN0cm9rZVN0eWxlTGluZURhc2ggPSBzdHJva2VTdHlsZS5nZXRMaW5lRGFzaCgpO1xuICAgICAgdmFyIHN0cm9rZVN0eWxlTGluZURhc2hPZmZzZXQgPSBzdHJva2VTdHlsZS5nZXRMaW5lRGFzaE9mZnNldCgpO1xuICAgICAgdmFyIHN0cm9rZVN0eWxlTGluZUpvaW4gPSBzdHJva2VTdHlsZS5nZXRMaW5lSm9pbigpO1xuICAgICAgdmFyIHN0cm9rZVN0eWxlV2lkdGggPSBzdHJva2VTdHlsZS5nZXRXaWR0aCgpO1xuICAgICAgdmFyIHN0cm9rZVN0eWxlTWl0ZXJMaW1pdCA9IHN0cm9rZVN0eWxlLmdldE1pdGVyTGltaXQoKTtcbiAgICAgIHRoaXMuc3Ryb2tlU3RhdGVfID0ge1xuICAgICAgICBsaW5lQ2FwOiBzdHJva2VTdHlsZUxpbmVDYXAgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgc3Ryb2tlU3R5bGVMaW5lQ2FwIDogZGVmYXVsdExpbmVDYXAsXG4gICAgICAgIGxpbmVEYXNoOiBzdHJva2VTdHlsZUxpbmVEYXNoID9cbiAgICAgICAgICBzdHJva2VTdHlsZUxpbmVEYXNoIDogZGVmYXVsdExpbmVEYXNoLFxuICAgICAgICBsaW5lRGFzaE9mZnNldDogc3Ryb2tlU3R5bGVMaW5lRGFzaE9mZnNldCA/XG4gICAgICAgICAgc3Ryb2tlU3R5bGVMaW5lRGFzaE9mZnNldCA6IGRlZmF1bHRMaW5lRGFzaE9mZnNldCxcbiAgICAgICAgbGluZUpvaW46IHN0cm9rZVN0eWxlTGluZUpvaW4gIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgc3Ryb2tlU3R5bGVMaW5lSm9pbiA6IGRlZmF1bHRMaW5lSm9pbixcbiAgICAgICAgbGluZVdpZHRoOiB0aGlzLnBpeGVsUmF0aW9fICogKHN0cm9rZVN0eWxlV2lkdGggIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgc3Ryb2tlU3R5bGVXaWR0aCA6IGRlZmF1bHRMaW5lV2lkdGgpLFxuICAgICAgICBtaXRlckxpbWl0OiBzdHJva2VTdHlsZU1pdGVyTGltaXQgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgc3Ryb2tlU3R5bGVNaXRlckxpbWl0IDogZGVmYXVsdE1pdGVyTGltaXQsXG4gICAgICAgIHN0cm9rZVN0eWxlOiBhc0NvbG9yTGlrZShzdHJva2VTdHlsZUNvbG9yID9cbiAgICAgICAgICBzdHJva2VTdHlsZUNvbG9yIDogZGVmYXVsdFN0cm9rZVN0eWxlKVxuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgaW1hZ2Ugc3R5bGUgZm9yIHN1YnNlcXVlbnQgZHJhdyBvcGVyYXRpb25zLiAgUGFzcyBudWxsIHRvIHJlbW92ZVxuICAgKiB0aGUgaW1hZ2Ugc3R5bGUuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vc3R5bGUvSW1hZ2UuanNcIikuZGVmYXVsdH0gaW1hZ2VTdHlsZSBJbWFnZSBzdHlsZS5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBDYW52YXNJbW1lZGlhdGVSZW5kZXJlci5wcm90b3R5cGUuc2V0SW1hZ2VTdHlsZSA9IGZ1bmN0aW9uIHNldEltYWdlU3R5bGUgKGltYWdlU3R5bGUpIHtcbiAgICBpZiAoIWltYWdlU3R5bGUpIHtcbiAgICAgIHRoaXMuaW1hZ2VfID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGltYWdlQW5jaG9yID0gaW1hZ2VTdHlsZS5nZXRBbmNob3IoKTtcbiAgICAgIC8vIEZJWE1FIHBpeGVsIHJhdGlvXG4gICAgICB2YXIgaW1hZ2VJbWFnZSA9IGltYWdlU3R5bGUuZ2V0SW1hZ2UoMSk7XG4gICAgICB2YXIgaW1hZ2VPcmlnaW4gPSBpbWFnZVN0eWxlLmdldE9yaWdpbigpO1xuICAgICAgdmFyIGltYWdlU2l6ZSA9IGltYWdlU3R5bGUuZ2V0U2l6ZSgpO1xuICAgICAgdGhpcy5pbWFnZUFuY2hvclhfID0gaW1hZ2VBbmNob3JbMF07XG4gICAgICB0aGlzLmltYWdlQW5jaG9yWV8gPSBpbWFnZUFuY2hvclsxXTtcbiAgICAgIHRoaXMuaW1hZ2VIZWlnaHRfID0gaW1hZ2VTaXplWzFdO1xuICAgICAgdGhpcy5pbWFnZV8gPSBpbWFnZUltYWdlO1xuICAgICAgdGhpcy5pbWFnZU9wYWNpdHlfID0gaW1hZ2VTdHlsZS5nZXRPcGFjaXR5KCk7XG4gICAgICB0aGlzLmltYWdlT3JpZ2luWF8gPSBpbWFnZU9yaWdpblswXTtcbiAgICAgIHRoaXMuaW1hZ2VPcmlnaW5ZXyA9IGltYWdlT3JpZ2luWzFdO1xuICAgICAgdGhpcy5pbWFnZVJvdGF0ZVdpdGhWaWV3XyA9IGltYWdlU3R5bGUuZ2V0Um90YXRlV2l0aFZpZXcoKTtcbiAgICAgIHRoaXMuaW1hZ2VSb3RhdGlvbl8gPSBpbWFnZVN0eWxlLmdldFJvdGF0aW9uKCk7XG4gICAgICB0aGlzLmltYWdlU2NhbGVfID0gaW1hZ2VTdHlsZS5nZXRTY2FsZSgpICogdGhpcy5waXhlbFJhdGlvXztcbiAgICAgIHRoaXMuaW1hZ2VXaWR0aF8gPSBpbWFnZVNpemVbMF07XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRleHQgc3R5bGUgZm9yIHN1YnNlcXVlbnQgZHJhdyBvcGVyYXRpb25zLiAgUGFzcyBudWxsIHRvXG4gICAqIHJlbW92ZSB0aGUgdGV4dCBzdHlsZS5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9zdHlsZS9UZXh0LmpzXCIpLmRlZmF1bHR9IHRleHRTdHlsZSBUZXh0IHN0eWxlLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIENhbnZhc0ltbWVkaWF0ZVJlbmRlcmVyLnByb3RvdHlwZS5zZXRUZXh0U3R5bGUgPSBmdW5jdGlvbiBzZXRUZXh0U3R5bGUgKHRleHRTdHlsZSkge1xuICAgIGlmICghdGV4dFN0eWxlKSB7XG4gICAgICB0aGlzLnRleHRfID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0ZXh0RmlsbFN0eWxlID0gdGV4dFN0eWxlLmdldEZpbGwoKTtcbiAgICAgIGlmICghdGV4dEZpbGxTdHlsZSkge1xuICAgICAgICB0aGlzLnRleHRGaWxsU3RhdGVfID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0ZXh0RmlsbFN0eWxlQ29sb3IgPSB0ZXh0RmlsbFN0eWxlLmdldENvbG9yKCk7XG4gICAgICAgIHRoaXMudGV4dEZpbGxTdGF0ZV8gPSB7XG4gICAgICAgICAgZmlsbFN0eWxlOiBhc0NvbG9yTGlrZSh0ZXh0RmlsbFN0eWxlQ29sb3IgP1xuICAgICAgICAgICAgdGV4dEZpbGxTdHlsZUNvbG9yIDogZGVmYXVsdEZpbGxTdHlsZSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHZhciB0ZXh0U3Ryb2tlU3R5bGUgPSB0ZXh0U3R5bGUuZ2V0U3Ryb2tlKCk7XG4gICAgICBpZiAoIXRleHRTdHJva2VTdHlsZSkge1xuICAgICAgICB0aGlzLnRleHRTdHJva2VTdGF0ZV8gPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRleHRTdHJva2VTdHlsZUNvbG9yID0gdGV4dFN0cm9rZVN0eWxlLmdldENvbG9yKCk7XG4gICAgICAgIHZhciB0ZXh0U3Ryb2tlU3R5bGVMaW5lQ2FwID0gdGV4dFN0cm9rZVN0eWxlLmdldExpbmVDYXAoKTtcbiAgICAgICAgdmFyIHRleHRTdHJva2VTdHlsZUxpbmVEYXNoID0gdGV4dFN0cm9rZVN0eWxlLmdldExpbmVEYXNoKCk7XG4gICAgICAgIHZhciB0ZXh0U3Ryb2tlU3R5bGVMaW5lRGFzaE9mZnNldCA9IHRleHRTdHJva2VTdHlsZS5nZXRMaW5lRGFzaE9mZnNldCgpO1xuICAgICAgICB2YXIgdGV4dFN0cm9rZVN0eWxlTGluZUpvaW4gPSB0ZXh0U3Ryb2tlU3R5bGUuZ2V0TGluZUpvaW4oKTtcbiAgICAgICAgdmFyIHRleHRTdHJva2VTdHlsZVdpZHRoID0gdGV4dFN0cm9rZVN0eWxlLmdldFdpZHRoKCk7XG4gICAgICAgIHZhciB0ZXh0U3Ryb2tlU3R5bGVNaXRlckxpbWl0ID0gdGV4dFN0cm9rZVN0eWxlLmdldE1pdGVyTGltaXQoKTtcbiAgICAgICAgdGhpcy50ZXh0U3Ryb2tlU3RhdGVfID0ge1xuICAgICAgICAgIGxpbmVDYXA6IHRleHRTdHJva2VTdHlsZUxpbmVDYXAgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICB0ZXh0U3Ryb2tlU3R5bGVMaW5lQ2FwIDogZGVmYXVsdExpbmVDYXAsXG4gICAgICAgICAgbGluZURhc2g6IHRleHRTdHJva2VTdHlsZUxpbmVEYXNoID9cbiAgICAgICAgICAgIHRleHRTdHJva2VTdHlsZUxpbmVEYXNoIDogZGVmYXVsdExpbmVEYXNoLFxuICAgICAgICAgIGxpbmVEYXNoT2Zmc2V0OiB0ZXh0U3Ryb2tlU3R5bGVMaW5lRGFzaE9mZnNldCA/XG4gICAgICAgICAgICB0ZXh0U3Ryb2tlU3R5bGVMaW5lRGFzaE9mZnNldCA6IGRlZmF1bHRMaW5lRGFzaE9mZnNldCxcbiAgICAgICAgICBsaW5lSm9pbjogdGV4dFN0cm9rZVN0eWxlTGluZUpvaW4gIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICB0ZXh0U3Ryb2tlU3R5bGVMaW5lSm9pbiA6IGRlZmF1bHRMaW5lSm9pbixcbiAgICAgICAgICBsaW5lV2lkdGg6IHRleHRTdHJva2VTdHlsZVdpZHRoICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgdGV4dFN0cm9rZVN0eWxlV2lkdGggOiBkZWZhdWx0TGluZVdpZHRoLFxuICAgICAgICAgIG1pdGVyTGltaXQ6IHRleHRTdHJva2VTdHlsZU1pdGVyTGltaXQgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICB0ZXh0U3Ryb2tlU3R5bGVNaXRlckxpbWl0IDogZGVmYXVsdE1pdGVyTGltaXQsXG4gICAgICAgICAgc3Ryb2tlU3R5bGU6IGFzQ29sb3JMaWtlKHRleHRTdHJva2VTdHlsZUNvbG9yID9cbiAgICAgICAgICAgIHRleHRTdHJva2VTdHlsZUNvbG9yIDogZGVmYXVsdFN0cm9rZVN0eWxlKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFyIHRleHRGb250ID0gdGV4dFN0eWxlLmdldEZvbnQoKTtcbiAgICAgIHZhciB0ZXh0T2Zmc2V0WCA9IHRleHRTdHlsZS5nZXRPZmZzZXRYKCk7XG4gICAgICB2YXIgdGV4dE9mZnNldFkgPSB0ZXh0U3R5bGUuZ2V0T2Zmc2V0WSgpO1xuICAgICAgdmFyIHRleHRSb3RhdGVXaXRoVmlldyA9IHRleHRTdHlsZS5nZXRSb3RhdGVXaXRoVmlldygpO1xuICAgICAgdmFyIHRleHRSb3RhdGlvbiA9IHRleHRTdHlsZS5nZXRSb3RhdGlvbigpO1xuICAgICAgdmFyIHRleHRTY2FsZSA9IHRleHRTdHlsZS5nZXRTY2FsZSgpO1xuICAgICAgdmFyIHRleHRUZXh0ID0gdGV4dFN0eWxlLmdldFRleHQoKTtcbiAgICAgIHZhciB0ZXh0VGV4dEFsaWduID0gdGV4dFN0eWxlLmdldFRleHRBbGlnbigpO1xuICAgICAgdmFyIHRleHRUZXh0QmFzZWxpbmUgPSB0ZXh0U3R5bGUuZ2V0VGV4dEJhc2VsaW5lKCk7XG4gICAgICB0aGlzLnRleHRTdGF0ZV8gPSB7XG4gICAgICAgIGZvbnQ6IHRleHRGb250ICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgIHRleHRGb250IDogZGVmYXVsdEZvbnQsXG4gICAgICAgIHRleHRBbGlnbjogdGV4dFRleHRBbGlnbiAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICB0ZXh0VGV4dEFsaWduIDogZGVmYXVsdFRleHRBbGlnbixcbiAgICAgICAgdGV4dEJhc2VsaW5lOiB0ZXh0VGV4dEJhc2VsaW5lICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgIHRleHRUZXh0QmFzZWxpbmUgOiBkZWZhdWx0VGV4dEJhc2VsaW5lXG4gICAgICB9O1xuICAgICAgdGhpcy50ZXh0XyA9IHRleHRUZXh0ICE9PSB1bmRlZmluZWQgPyB0ZXh0VGV4dCA6ICcnO1xuICAgICAgdGhpcy50ZXh0T2Zmc2V0WF8gPVxuICAgICAgICAgIHRleHRPZmZzZXRYICE9PSB1bmRlZmluZWQgPyAodGhpcy5waXhlbFJhdGlvXyAqIHRleHRPZmZzZXRYKSA6IDA7XG4gICAgICB0aGlzLnRleHRPZmZzZXRZXyA9XG4gICAgICAgICAgdGV4dE9mZnNldFkgIT09IHVuZGVmaW5lZCA/ICh0aGlzLnBpeGVsUmF0aW9fICogdGV4dE9mZnNldFkpIDogMDtcbiAgICAgIHRoaXMudGV4dFJvdGF0ZVdpdGhWaWV3XyA9IHRleHRSb3RhdGVXaXRoVmlldyAhPT0gdW5kZWZpbmVkID8gdGV4dFJvdGF0ZVdpdGhWaWV3IDogZmFsc2U7XG4gICAgICB0aGlzLnRleHRSb3RhdGlvbl8gPSB0ZXh0Um90YXRpb24gIT09IHVuZGVmaW5lZCA/IHRleHRSb3RhdGlvbiA6IDA7XG4gICAgICB0aGlzLnRleHRTY2FsZV8gPSB0aGlzLnBpeGVsUmF0aW9fICogKHRleHRTY2FsZSAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgdGV4dFNjYWxlIDogMSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBDYW52YXNJbW1lZGlhdGVSZW5kZXJlcjtcbn0oVmVjdG9yQ29udGV4dCkpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IENhbnZhc0ltbWVkaWF0ZVJlbmRlcmVyO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbW1lZGlhdGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9jYW52YXMvSW5zdHJ1Y3Rpb25cbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbnZhciBJbnN0cnVjdGlvbiA9IHtcbiAgQkVHSU5fR0VPTUVUUlk6IDAsXG4gIEJFR0lOX1BBVEg6IDEsXG4gIENJUkNMRTogMixcbiAgQ0xPU0VfUEFUSDogMyxcbiAgQ1VTVE9NOiA0LFxuICBEUkFXX0NIQVJTOiA1LFxuICBEUkFXX0lNQUdFOiA2LFxuICBFTkRfR0VPTUVUUlk6IDcsXG4gIEZJTEw6IDgsXG4gIE1PVkVfVE9fTElORV9UTzogOSxcbiAgU0VUX0ZJTExfU1RZTEU6IDEwLFxuICBTRVRfU1RST0tFX1NUWUxFOiAxMSxcbiAgU1RST0tFOiAxMlxufTtcblxuXG4vKipcbiAqIEB0eXBlIHtBcnJheTxJbnN0cnVjdGlvbj59XG4gKi9cbmV4cG9ydCB2YXIgZmlsbEluc3RydWN0aW9uID0gW0luc3RydWN0aW9uLkZJTExdO1xuXG5cbi8qKlxuICogQHR5cGUge0FycmF5PEluc3RydWN0aW9uPn1cbiAqL1xuZXhwb3J0IHZhciBzdHJva2VJbnN0cnVjdGlvbiA9IFtJbnN0cnVjdGlvbi5TVFJPS0VdO1xuXG5cbi8qKlxuICogQHR5cGUge0FycmF5PEluc3RydWN0aW9uPn1cbiAqL1xuZXhwb3J0IHZhciBiZWdpblBhdGhJbnN0cnVjdGlvbiA9IFtJbnN0cnVjdGlvbi5CRUdJTl9QQVRIXTtcblxuXG4vKipcbiAqIEB0eXBlIHtBcnJheTxJbnN0cnVjdGlvbj59XG4gKi9cbmV4cG9ydCB2YXIgY2xvc2VQYXRoSW5zdHJ1Y3Rpb24gPSBbSW5zdHJ1Y3Rpb24uQ0xPU0VfUEFUSF07XG5cblxuZXhwb3J0IGRlZmF1bHQgSW5zdHJ1Y3Rpb247XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUluc3RydWN0aW9uLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXIvY2FudmFzL0xpbmVTdHJpbmdSZXBsYXlcbiAqL1xuaW1wb3J0IENhbnZhc0luc3RydWN0aW9uLCB7c3Ryb2tlSW5zdHJ1Y3Rpb24sIGJlZ2luUGF0aEluc3RydWN0aW9ufSBmcm9tICcuL0luc3RydWN0aW9uLmpzJztcbmltcG9ydCBDYW52YXNSZXBsYXkgZnJvbSAnLi9SZXBsYXkuanMnO1xuXG52YXIgQ2FudmFzTGluZVN0cmluZ1JlcGxheSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKENhbnZhc1JlcGxheSkge1xuICBmdW5jdGlvbiBDYW52YXNMaW5lU3RyaW5nUmVwbGF5KHRvbGVyYW5jZSwgbWF4RXh0ZW50LCByZXNvbHV0aW9uLCBwaXhlbFJhdGlvLCBvdmVybGFwcywgZGVjbHV0dGVyVHJlZSkge1xuICAgIENhbnZhc1JlcGxheS5jYWxsKHRoaXMsIHRvbGVyYW5jZSwgbWF4RXh0ZW50LCByZXNvbHV0aW9uLCBwaXhlbFJhdGlvLCBvdmVybGFwcywgZGVjbHV0dGVyVHJlZSk7XG4gIH1cblxuICBpZiAoIENhbnZhc1JlcGxheSApIENhbnZhc0xpbmVTdHJpbmdSZXBsYXkuX19wcm90b19fID0gQ2FudmFzUmVwbGF5O1xuICBDYW52YXNMaW5lU3RyaW5nUmVwbGF5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIENhbnZhc1JlcGxheSAmJiBDYW52YXNSZXBsYXkucHJvdG90eXBlICk7XG4gIENhbnZhc0xpbmVTdHJpbmdSZXBsYXkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2FudmFzTGluZVN0cmluZ1JlcGxheTtcblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7bnVtYmVyfSBlbmQuXG4gICAqL1xuICBDYW52YXNMaW5lU3RyaW5nUmVwbGF5LnByb3RvdHlwZS5kcmF3RmxhdENvb3JkaW5hdGVzXyA9IGZ1bmN0aW9uIGRyYXdGbGF0Q29vcmRpbmF0ZXNfIChmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUpIHtcbiAgICB2YXIgbXlCZWdpbiA9IHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIHZhciBteUVuZCA9IHRoaXMuYXBwZW5kRmxhdENvb3JkaW5hdGVzKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCBmYWxzZSwgZmFsc2UpO1xuICAgIHZhciBtb3ZlVG9MaW5lVG9JbnN0cnVjdGlvbiA9IFtDYW52YXNJbnN0cnVjdGlvbi5NT1ZFX1RPX0xJTkVfVE8sIG15QmVnaW4sIG15RW5kXTtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKG1vdmVUb0xpbmVUb0luc3RydWN0aW9uKTtcbiAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKG1vdmVUb0xpbmVUb0luc3RydWN0aW9uKTtcbiAgICByZXR1cm4gZW5kO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQ2FudmFzTGluZVN0cmluZ1JlcGxheS5wcm90b3R5cGUuZHJhd0xpbmVTdHJpbmcgPSBmdW5jdGlvbiBkcmF3TGluZVN0cmluZyAobGluZVN0cmluZ0dlb21ldHJ5LCBmZWF0dXJlKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB2YXIgc3Ryb2tlU3R5bGUgPSBzdGF0ZS5zdHJva2VTdHlsZTtcbiAgICB2YXIgbGluZVdpZHRoID0gc3RhdGUubGluZVdpZHRoO1xuICAgIGlmIChzdHJva2VTdHlsZSA9PT0gdW5kZWZpbmVkIHx8IGxpbmVXaWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudXBkYXRlU3Ryb2tlU3R5bGUoc3RhdGUsIHRoaXMuYXBwbHlTdHJva2UpO1xuICAgIHRoaXMuYmVnaW5HZW9tZXRyeShsaW5lU3RyaW5nR2VvbWV0cnksIGZlYXR1cmUpO1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goW1xuICAgICAgQ2FudmFzSW5zdHJ1Y3Rpb24uU0VUX1NUUk9LRV9TVFlMRSxcbiAgICAgIHN0YXRlLnN0cm9rZVN0eWxlLCBzdGF0ZS5saW5lV2lkdGgsIHN0YXRlLmxpbmVDYXAsIHN0YXRlLmxpbmVKb2luLFxuICAgICAgc3RhdGUubWl0ZXJMaW1pdCwgc3RhdGUubGluZURhc2gsIHN0YXRlLmxpbmVEYXNoT2Zmc2V0XG4gICAgXSwgYmVnaW5QYXRoSW5zdHJ1Y3Rpb24pO1xuICAgIHZhciBmbGF0Q29vcmRpbmF0ZXMgPSBsaW5lU3RyaW5nR2VvbWV0cnkuZ2V0RmxhdENvb3JkaW5hdGVzKCk7XG4gICAgdmFyIHN0cmlkZSA9IGxpbmVTdHJpbmdHZW9tZXRyeS5nZXRTdHJpZGUoKTtcbiAgICB0aGlzLmRyYXdGbGF0Q29vcmRpbmF0ZXNfKGZsYXRDb29yZGluYXRlcywgMCwgZmxhdENvb3JkaW5hdGVzLmxlbmd0aCwgc3RyaWRlKTtcbiAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKHN0cm9rZUluc3RydWN0aW9uKTtcbiAgICB0aGlzLmVuZEdlb21ldHJ5KGxpbmVTdHJpbmdHZW9tZXRyeSwgZmVhdHVyZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNMaW5lU3RyaW5nUmVwbGF5LnByb3RvdHlwZS5kcmF3TXVsdGlMaW5lU3RyaW5nID0gZnVuY3Rpb24gZHJhd011bHRpTGluZVN0cmluZyAobXVsdGlMaW5lU3RyaW5nR2VvbWV0cnksIGZlYXR1cmUpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHZhciBzdHJva2VTdHlsZSA9IHN0YXRlLnN0cm9rZVN0eWxlO1xuICAgIHZhciBsaW5lV2lkdGggPSBzdGF0ZS5saW5lV2lkdGg7XG4gICAgaWYgKHN0cm9rZVN0eWxlID09PSB1bmRlZmluZWQgfHwgbGluZVdpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVTdHJva2VTdHlsZShzdGF0ZSwgdGhpcy5hcHBseVN0cm9rZSk7XG4gICAgdGhpcy5iZWdpbkdlb21ldHJ5KG11bHRpTGluZVN0cmluZ0dlb21ldHJ5LCBmZWF0dXJlKTtcbiAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKFtcbiAgICAgIENhbnZhc0luc3RydWN0aW9uLlNFVF9TVFJPS0VfU1RZTEUsXG4gICAgICBzdGF0ZS5zdHJva2VTdHlsZSwgc3RhdGUubGluZVdpZHRoLCBzdGF0ZS5saW5lQ2FwLCBzdGF0ZS5saW5lSm9pbixcbiAgICAgIHN0YXRlLm1pdGVyTGltaXQsIHN0YXRlLmxpbmVEYXNoLCBzdGF0ZS5saW5lRGFzaE9mZnNldFxuICAgIF0sIGJlZ2luUGF0aEluc3RydWN0aW9uKTtcbiAgICB2YXIgZW5kcyA9IG11bHRpTGluZVN0cmluZ0dlb21ldHJ5LmdldEVuZHMoKTtcbiAgICB2YXIgZmxhdENvb3JkaW5hdGVzID0gbXVsdGlMaW5lU3RyaW5nR2VvbWV0cnkuZ2V0RmxhdENvb3JkaW5hdGVzKCk7XG4gICAgdmFyIHN0cmlkZSA9IG11bHRpTGluZVN0cmluZ0dlb21ldHJ5LmdldFN0cmlkZSgpO1xuICAgIHZhciBvZmZzZXQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGVuZHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgb2Zmc2V0ID0gdGhpcy5kcmF3RmxhdENvb3JkaW5hdGVzXyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kc1tpXSwgc3RyaWRlKTtcbiAgICB9XG4gICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChzdHJva2VJbnN0cnVjdGlvbik7XG4gICAgdGhpcy5lbmRHZW9tZXRyeShtdWx0aUxpbmVTdHJpbmdHZW9tZXRyeSwgZmVhdHVyZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNMaW5lU3RyaW5nUmVwbGF5LnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiBmaW5pc2ggKCkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHN0YXRlLmxhc3RTdHJva2UgIT0gdW5kZWZpbmVkICYmIHN0YXRlLmxhc3RTdHJva2UgIT0gdGhpcy5jb29yZGluYXRlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goc3Ryb2tlSW5zdHJ1Y3Rpb24pO1xuICAgIH1cbiAgICB0aGlzLnJldmVyc2VIaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMoKTtcbiAgICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2MuXG4gICAqL1xuICBDYW52YXNMaW5lU3RyaW5nUmVwbGF5LnByb3RvdHlwZS5hcHBseVN0cm9rZSA9IGZ1bmN0aW9uIGFwcGx5U3Ryb2tlIChzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5sYXN0U3Ryb2tlICE9IHVuZGVmaW5lZCAmJiBzdGF0ZS5sYXN0U3Ryb2tlICE9IHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKHN0cm9rZUluc3RydWN0aW9uKTtcbiAgICAgIHN0YXRlLmxhc3RTdHJva2UgPSB0aGlzLmNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICB9XG4gICAgc3RhdGUubGFzdFN0cm9rZSA9IDA7XG4gICAgQ2FudmFzUmVwbGF5LnByb3RvdHlwZS5hcHBseVN0cm9rZS5jYWxsKHRoaXMsIHN0YXRlKTtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKGJlZ2luUGF0aEluc3RydWN0aW9uKTtcbiAgfTtcblxuICByZXR1cm4gQ2FudmFzTGluZVN0cmluZ1JlcGxheTtcbn0oQ2FudmFzUmVwbGF5KSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgQ2FudmFzTGluZVN0cmluZ1JlcGxheTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGluZVN0cmluZ1JlcGxheS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyL2NhbnZhcy9Qb2x5Z29uUmVwbGF5XG4gKi9cbmltcG9ydCB7YXNTdHJpbmd9IGZyb20gJy4uLy4uL2NvbG9yLmpzJztcbmltcG9ydCB7c25hcH0gZnJvbSAnLi4vLi4vZ2VvbS9mbGF0L3NpbXBsaWZ5LmpzJztcbmltcG9ydCB7ZGVmYXVsdEZpbGxTdHlsZX0gZnJvbSAnLi4vY2FudmFzLmpzJztcbmltcG9ydCBDYW52YXNJbnN0cnVjdGlvbiwge1xuICBmaWxsSW5zdHJ1Y3Rpb24sIHN0cm9rZUluc3RydWN0aW9uLCBiZWdpblBhdGhJbnN0cnVjdGlvbiwgY2xvc2VQYXRoSW5zdHJ1Y3Rpb25cbn0gZnJvbSAnLi9JbnN0cnVjdGlvbi5qcyc7XG5pbXBvcnQgQ2FudmFzUmVwbGF5IGZyb20gJy4vUmVwbGF5LmpzJztcblxuXG52YXIgQ2FudmFzUG9seWdvblJlcGxheSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKENhbnZhc1JlcGxheSkge1xuICBmdW5jdGlvbiBDYW52YXNQb2x5Z29uUmVwbGF5KHRvbGVyYW5jZSwgbWF4RXh0ZW50LCByZXNvbHV0aW9uLCBwaXhlbFJhdGlvLCBvdmVybGFwcywgZGVjbHV0dGVyVHJlZSkge1xuICAgIENhbnZhc1JlcGxheS5jYWxsKHRoaXMsIHRvbGVyYW5jZSwgbWF4RXh0ZW50LCByZXNvbHV0aW9uLCBwaXhlbFJhdGlvLCBvdmVybGFwcywgZGVjbHV0dGVyVHJlZSk7XG4gIH1cblxuICBpZiAoIENhbnZhc1JlcGxheSApIENhbnZhc1BvbHlnb25SZXBsYXkuX19wcm90b19fID0gQ2FudmFzUmVwbGF5O1xuICBDYW52YXNQb2x5Z29uUmVwbGF5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIENhbnZhc1JlcGxheSAmJiBDYW52YXNSZXBsYXkucHJvdG90eXBlICk7XG4gIENhbnZhc1BvbHlnb25SZXBsYXkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2FudmFzUG9seWdvblJlcGxheTtcblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW5kcyBFbmRzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7bnVtYmVyfSBFbmQuXG4gICAqL1xuICBDYW52YXNQb2x5Z29uUmVwbGF5LnByb3RvdHlwZS5kcmF3RmxhdENvb3JkaW5hdGVzc18gPSBmdW5jdGlvbiBkcmF3RmxhdENvb3JkaW5hdGVzc18gKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLCBzdHJpZGUpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHZhciBmaWxsID0gc3RhdGUuZmlsbFN0eWxlICE9PSB1bmRlZmluZWQ7XG4gICAgdmFyIHN0cm9rZSA9IHN0YXRlLnN0cm9rZVN0eWxlICE9IHVuZGVmaW5lZDtcbiAgICB2YXIgbnVtRW5kcyA9IGVuZHMubGVuZ3RoO1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goYmVnaW5QYXRoSW5zdHJ1Y3Rpb24pO1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goYmVnaW5QYXRoSW5zdHJ1Y3Rpb24pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtRW5kczsgKytpKSB7XG4gICAgICB2YXIgZW5kID0gZW5kc1tpXTtcbiAgICAgIHZhciBteUJlZ2luID0gdGhpcy5jb29yZGluYXRlcy5sZW5ndGg7XG4gICAgICB2YXIgbXlFbmQgPSB0aGlzLmFwcGVuZEZsYXRDb29yZGluYXRlcyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIHRydWUsICFzdHJva2UpO1xuICAgICAgdmFyIG1vdmVUb0xpbmVUb0luc3RydWN0aW9uID0gW0NhbnZhc0luc3RydWN0aW9uLk1PVkVfVE9fTElORV9UTywgbXlCZWdpbiwgbXlFbmRdO1xuICAgICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChtb3ZlVG9MaW5lVG9JbnN0cnVjdGlvbik7XG4gICAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKG1vdmVUb0xpbmVUb0luc3RydWN0aW9uKTtcbiAgICAgIGlmIChzdHJva2UpIHtcbiAgICAgICAgLy8gUGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uOiBvbmx5IGNhbGwgY2xvc2VQYXRoKCkgd2hlbiB3ZSBoYXZlIGEgc3Ryb2tlLlxuICAgICAgICAvLyBPdGhlcndpc2UgdGhlIHJpbmcgaXMgY2xvc2VkIGFscmVhZHkgKHNlZSBhcHBlbmRGbGF0Q29vcmRpbmF0ZXMgYWJvdmUpLlxuICAgICAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKGNsb3NlUGF0aEluc3RydWN0aW9uKTtcbiAgICAgICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChjbG9zZVBhdGhJbnN0cnVjdGlvbik7XG4gICAgICB9XG4gICAgICBvZmZzZXQgPSBlbmQ7XG4gICAgfVxuICAgIGlmIChmaWxsKSB7XG4gICAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKGZpbGxJbnN0cnVjdGlvbik7XG4gICAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKGZpbGxJbnN0cnVjdGlvbik7XG4gICAgfVxuICAgIGlmIChzdHJva2UpIHtcbiAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goc3Ryb2tlSW5zdHJ1Y3Rpb24pO1xuICAgICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChzdHJva2VJbnN0cnVjdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNQb2x5Z29uUmVwbGF5LnByb3RvdHlwZS5kcmF3Q2lyY2xlID0gZnVuY3Rpb24gZHJhd0NpcmNsZSAoY2lyY2xlR2VvbWV0cnksIGZlYXR1cmUpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHZhciBmaWxsU3R5bGUgPSBzdGF0ZS5maWxsU3R5bGU7XG4gICAgdmFyIHN0cm9rZVN0eWxlID0gc3RhdGUuc3Ryb2tlU3R5bGU7XG4gICAgaWYgKGZpbGxTdHlsZSA9PT0gdW5kZWZpbmVkICYmIHN0cm9rZVN0eWxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZXRGaWxsU3Ryb2tlU3R5bGVzXyhjaXJjbGVHZW9tZXRyeSk7XG4gICAgdGhpcy5iZWdpbkdlb21ldHJ5KGNpcmNsZUdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgICBpZiAoc3RhdGUuZmlsbFN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goW1xuICAgICAgICBDYW52YXNJbnN0cnVjdGlvbi5TRVRfRklMTF9TVFlMRSxcbiAgICAgICAgYXNTdHJpbmcoZGVmYXVsdEZpbGxTdHlsZSlcbiAgICAgIF0pO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuc3Ryb2tlU3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChbXG4gICAgICAgIENhbnZhc0luc3RydWN0aW9uLlNFVF9TVFJPS0VfU1RZTEUsXG4gICAgICAgIHN0YXRlLnN0cm9rZVN0eWxlLCBzdGF0ZS5saW5lV2lkdGgsIHN0YXRlLmxpbmVDYXAsIHN0YXRlLmxpbmVKb2luLFxuICAgICAgICBzdGF0ZS5taXRlckxpbWl0LCBzdGF0ZS5saW5lRGFzaCwgc3RhdGUubGluZURhc2hPZmZzZXRcbiAgICAgIF0pO1xuICAgIH1cbiAgICB2YXIgZmxhdENvb3JkaW5hdGVzID0gY2lyY2xlR2VvbWV0cnkuZ2V0RmxhdENvb3JkaW5hdGVzKCk7XG4gICAgdmFyIHN0cmlkZSA9IGNpcmNsZUdlb21ldHJ5LmdldFN0cmlkZSgpO1xuICAgIHZhciBteUJlZ2luID0gdGhpcy5jb29yZGluYXRlcy5sZW5ndGg7XG4gICAgdGhpcy5hcHBlbmRGbGF0Q29vcmRpbmF0ZXMoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsIDAsIGZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHN0cmlkZSwgZmFsc2UsIGZhbHNlKTtcbiAgICB2YXIgY2lyY2xlSW5zdHJ1Y3Rpb24gPSBbQ2FudmFzSW5zdHJ1Y3Rpb24uQ0lSQ0xFLCBteUJlZ2luXTtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKGJlZ2luUGF0aEluc3RydWN0aW9uLCBjaXJjbGVJbnN0cnVjdGlvbik7XG4gICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChiZWdpblBhdGhJbnN0cnVjdGlvbiwgY2lyY2xlSW5zdHJ1Y3Rpb24pO1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goZmlsbEluc3RydWN0aW9uKTtcbiAgICBpZiAoc3RhdGUuZmlsbFN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goZmlsbEluc3RydWN0aW9uKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLnN0cm9rZVN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goc3Ryb2tlSW5zdHJ1Y3Rpb24pO1xuICAgICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChzdHJva2VJbnN0cnVjdGlvbik7XG4gICAgfVxuICAgIHRoaXMuZW5kR2VvbWV0cnkoY2lyY2xlR2VvbWV0cnksIGZlYXR1cmUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQ2FudmFzUG9seWdvblJlcGxheS5wcm90b3R5cGUuZHJhd1BvbHlnb24gPSBmdW5jdGlvbiBkcmF3UG9seWdvbiAocG9seWdvbkdlb21ldHJ5LCBmZWF0dXJlKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB2YXIgZmlsbFN0eWxlID0gc3RhdGUuZmlsbFN0eWxlO1xuICAgIHZhciBzdHJva2VTdHlsZSA9IHN0YXRlLnN0cm9rZVN0eWxlO1xuICAgIGlmIChmaWxsU3R5bGUgPT09IHVuZGVmaW5lZCAmJiBzdHJva2VTdHlsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2V0RmlsbFN0cm9rZVN0eWxlc18ocG9seWdvbkdlb21ldHJ5KTtcbiAgICB0aGlzLmJlZ2luR2VvbWV0cnkocG9seWdvbkdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgICBpZiAoc3RhdGUuZmlsbFN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goW1xuICAgICAgICBDYW52YXNJbnN0cnVjdGlvbi5TRVRfRklMTF9TVFlMRSxcbiAgICAgICAgYXNTdHJpbmcoZGVmYXVsdEZpbGxTdHlsZSlcbiAgICAgIF0pO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuc3Ryb2tlU3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChbXG4gICAgICAgIENhbnZhc0luc3RydWN0aW9uLlNFVF9TVFJPS0VfU1RZTEUsXG4gICAgICAgIHN0YXRlLnN0cm9rZVN0eWxlLCBzdGF0ZS5saW5lV2lkdGgsIHN0YXRlLmxpbmVDYXAsIHN0YXRlLmxpbmVKb2luLFxuICAgICAgICBzdGF0ZS5taXRlckxpbWl0LCBzdGF0ZS5saW5lRGFzaCwgc3RhdGUubGluZURhc2hPZmZzZXRcbiAgICAgIF0pO1xuICAgIH1cbiAgICB2YXIgZW5kcyA9IHBvbHlnb25HZW9tZXRyeS5nZXRFbmRzKCk7XG4gICAgdmFyIGZsYXRDb29yZGluYXRlcyA9IHBvbHlnb25HZW9tZXRyeS5nZXRPcmllbnRlZEZsYXRDb29yZGluYXRlcygpO1xuICAgIHZhciBzdHJpZGUgPSBwb2x5Z29uR2VvbWV0cnkuZ2V0U3RyaWRlKCk7XG4gICAgdGhpcy5kcmF3RmxhdENvb3JkaW5hdGVzc18oZmxhdENvb3JkaW5hdGVzLCAwLCBlbmRzLCBzdHJpZGUpO1xuICAgIHRoaXMuZW5kR2VvbWV0cnkocG9seWdvbkdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENhbnZhc1BvbHlnb25SZXBsYXkucHJvdG90eXBlLmRyYXdNdWx0aVBvbHlnb24gPSBmdW5jdGlvbiBkcmF3TXVsdGlQb2x5Z29uIChtdWx0aVBvbHlnb25HZW9tZXRyeSwgZmVhdHVyZSkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgdmFyIGZpbGxTdHlsZSA9IHN0YXRlLmZpbGxTdHlsZTtcbiAgICB2YXIgc3Ryb2tlU3R5bGUgPSBzdGF0ZS5zdHJva2VTdHlsZTtcbiAgICBpZiAoZmlsbFN0eWxlID09PSB1bmRlZmluZWQgJiYgc3Ryb2tlU3R5bGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNldEZpbGxTdHJva2VTdHlsZXNfKG11bHRpUG9seWdvbkdlb21ldHJ5KTtcbiAgICB0aGlzLmJlZ2luR2VvbWV0cnkobXVsdGlQb2x5Z29uR2VvbWV0cnksIGZlYXR1cmUpO1xuICAgIGlmIChzdGF0ZS5maWxsU3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChbXG4gICAgICAgIENhbnZhc0luc3RydWN0aW9uLlNFVF9GSUxMX1NUWUxFLFxuICAgICAgICBhc1N0cmluZyhkZWZhdWx0RmlsbFN0eWxlKVxuICAgICAgXSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5zdHJva2VTdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKFtcbiAgICAgICAgQ2FudmFzSW5zdHJ1Y3Rpb24uU0VUX1NUUk9LRV9TVFlMRSxcbiAgICAgICAgc3RhdGUuc3Ryb2tlU3R5bGUsIHN0YXRlLmxpbmVXaWR0aCwgc3RhdGUubGluZUNhcCwgc3RhdGUubGluZUpvaW4sXG4gICAgICAgIHN0YXRlLm1pdGVyTGltaXQsIHN0YXRlLmxpbmVEYXNoLCBzdGF0ZS5saW5lRGFzaE9mZnNldFxuICAgICAgXSk7XG4gICAgfVxuICAgIHZhciBlbmRzcyA9IG11bHRpUG9seWdvbkdlb21ldHJ5LmdldEVuZHNzKCk7XG4gICAgdmFyIGZsYXRDb29yZGluYXRlcyA9IG11bHRpUG9seWdvbkdlb21ldHJ5LmdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzKCk7XG4gICAgdmFyIHN0cmlkZSA9IG11bHRpUG9seWdvbkdlb21ldHJ5LmdldFN0cmlkZSgpO1xuICAgIHZhciBvZmZzZXQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGVuZHNzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIG9mZnNldCA9IHRoaXMuZHJhd0ZsYXRDb29yZGluYXRlc3NfKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzc1tpXSwgc3RyaWRlKTtcbiAgICB9XG4gICAgdGhpcy5lbmRHZW9tZXRyeShtdWx0aVBvbHlnb25HZW9tZXRyeSwgZmVhdHVyZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNQb2x5Z29uUmVwbGF5LnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiBmaW5pc2ggKCkge1xuICAgIHRoaXMucmV2ZXJzZUhpdERldGVjdGlvbkluc3RydWN0aW9ucygpO1xuICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuICAgIC8vIFdlIHdhbnQgdG8gcHJlc2VydmUgdG9wb2xvZ3kgd2hlbiBkcmF3aW5nIHBvbHlnb25zLiAgUG9seWdvbnMgYXJlXG4gICAgLy8gc2ltcGxpZmllZCB1c2luZyBxdWFudGl6YXRpb24gYW5kIHBvaW50IGVsaW1pbmF0aW9uLiBIb3dldmVyLCB3ZSBtaWdodFxuICAgIC8vIGhhdmUgcmVjZWl2ZWQgYSBtaXggb2YgcXVhbnRpemVkIGFuZCBub24tcXVhbnRpemVkIGdlb21ldHJpZXMsIHNvIGVuc3VyZVxuICAgIC8vIHRoYXQgYWxsIGFyZSBxdWFudGl6ZWQgYnkgcXVhbnRpemluZyBhbGwgY29vcmRpbmF0ZXMgaW4gdGhlIGJhdGNoLlxuICAgIHZhciB0b2xlcmFuY2UgPSB0aGlzLnRvbGVyYW5jZTtcbiAgICBpZiAodG9sZXJhbmNlICE9PSAwKSB7XG4gICAgICB2YXIgY29vcmRpbmF0ZXMgPSB0aGlzLmNvb3JkaW5hdGVzO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBjb29yZGluYXRlc1tpXSA9IHNuYXAoY29vcmRpbmF0ZXNbaV0sIHRvbGVyYW5jZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKi9cbiAgQ2FudmFzUG9seWdvblJlcGxheS5wcm90b3R5cGUuc2V0RmlsbFN0cm9rZVN0eWxlc18gPSBmdW5jdGlvbiBzZXRGaWxsU3Ryb2tlU3R5bGVzXyAoZ2VvbWV0cnkpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHZhciBmaWxsU3R5bGUgPSBzdGF0ZS5maWxsU3R5bGU7XG4gICAgaWYgKGZpbGxTdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnVwZGF0ZUZpbGxTdHlsZShzdGF0ZSwgdGhpcy5jcmVhdGVGaWxsLCBnZW9tZXRyeSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5zdHJva2VTdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnVwZGF0ZVN0cm9rZVN0eWxlKHN0YXRlLCB0aGlzLmFwcGx5U3Ryb2tlKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIENhbnZhc1BvbHlnb25SZXBsYXk7XG59KENhbnZhc1JlcGxheSkpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IENhbnZhc1BvbHlnb25SZXBsYXk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBvbHlnb25SZXBsYXkuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9jYW52YXMvUmVwbGF5XG4gKi9cbmltcG9ydCB7Z2V0VWlkfSBmcm9tICcuLi8uLi91dGlsLmpzJztcbmltcG9ydCB7ZXF1YWxzLCByZXZlcnNlU3ViQXJyYXl9IGZyb20gJy4uLy4uL2FycmF5LmpzJztcbmltcG9ydCB7YXNDb2xvckxpa2V9IGZyb20gJy4uLy4uL2NvbG9ybGlrZS5qcyc7XG5pbXBvcnQge2J1ZmZlciwgY2xvbmUsIGNvb3JkaW5hdGVSZWxhdGlvbnNoaXAsIGNyZWF0ZUVtcHR5LCBjcmVhdGVPclVwZGF0ZSxcbiAgY3JlYXRlT3JVcGRhdGVFbXB0eSwgZXh0ZW5kLCBleHRlbmRDb29yZGluYXRlLCBpbnRlcnNlY3RzfSBmcm9tICcuLi8uLi9leHRlbnQuanMnO1xuaW1wb3J0IFJlbGF0aW9uc2hpcCBmcm9tICcuLi8uLi9leHRlbnQvUmVsYXRpb25zaGlwLmpzJztcbmltcG9ydCBHZW9tZXRyeVR5cGUgZnJvbSAnLi4vLi4vZ2VvbS9HZW9tZXRyeVR5cGUuanMnO1xuaW1wb3J0IHtpbmZsYXRlQ29vcmRpbmF0ZXMsIGluZmxhdGVDb29yZGluYXRlc0FycmF5LCBpbmZsYXRlTXVsdGlDb29yZGluYXRlc0FycmF5fSBmcm9tICcuLi8uLi9nZW9tL2ZsYXQvaW5mbGF0ZS5qcyc7XG5pbXBvcnQge2xpbmVTdHJpbmdMZW5ndGh9IGZyb20gJy4uLy4uL2dlb20vZmxhdC9sZW5ndGguanMnO1xuaW1wb3J0IHtkcmF3VGV4dE9uUGF0aH0gZnJvbSAnLi4vLi4vZ2VvbS9mbGF0L3RleHRwYXRoLmpzJztcbmltcG9ydCB7dHJhbnNmb3JtMkR9IGZyb20gJy4uLy4uL2dlb20vZmxhdC90cmFuc2Zvcm0uanMnO1xuaW1wb3J0IHtDQU5WQVNfTElORV9EQVNIfSBmcm9tICcuLi8uLi9oYXMuanMnO1xuaW1wb3J0IHtpc0VtcHR5fSBmcm9tICcuLi8uLi9vYmouanMnO1xuaW1wb3J0IFZlY3RvckNvbnRleHQgZnJvbSAnLi4vVmVjdG9yQ29udGV4dC5qcyc7XG5pbXBvcnQge2RyYXdJbWFnZSwgcmVzZXRUcmFuc2Zvcm0sIGRlZmF1bHRQYWRkaW5nLCBkZWZhdWx0RmlsbFN0eWxlLCBkZWZhdWx0U3Ryb2tlU3R5bGUsXG4gIGRlZmF1bHRNaXRlckxpbWl0LCBkZWZhdWx0TGluZVdpZHRoLCBkZWZhdWx0TGluZUpvaW4sIGRlZmF1bHRMaW5lRGFzaE9mZnNldCxcbiAgZGVmYXVsdExpbmVEYXNoLCBkZWZhdWx0TGluZUNhcH0gZnJvbSAnLi4vY2FudmFzLmpzJztcbmltcG9ydCBDYW52YXNJbnN0cnVjdGlvbiBmcm9tICcuL0luc3RydWN0aW9uLmpzJztcbmltcG9ydCB7VEVYVF9BTElHTn0gZnJvbSAnLi4vcmVwbGF5LmpzJztcbmltcG9ydCB7XG4gIGNyZWF0ZSBhcyBjcmVhdGVUcmFuc2Zvcm0sXG4gIGNvbXBvc2UgYXMgY29tcG9zZVRyYW5zZm9ybSxcbiAgYXBwbHkgYXMgYXBwbHlUcmFuc2Zvcm0sXG4gIHNldEZyb21BcnJheSBhcyB0cmFuc2Zvcm1TZXRGcm9tQXJyYXlcbn0gZnJvbSAnLi4vLi4vdHJhbnNmb3JtLmpzJztcblxuXG4vKipcbiAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICovXG52YXIgdG1wRXh0ZW50ID0gY3JlYXRlRW1wdHkoKTtcblxuXG4vKipcbiAqIEB0eXBlIHshaW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX1cbiAqL1xudmFyIHRtcFRyYW5zZm9ybSA9IGNyZWF0ZVRyYW5zZm9ybSgpO1xuXG5cbnZhciBDYW52YXNSZXBsYXkgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChWZWN0b3JDb250ZXh0KSB7XG4gIGZ1bmN0aW9uIENhbnZhc1JlcGxheSh0b2xlcmFuY2UsIG1heEV4dGVudCwgcmVzb2x1dGlvbiwgcGl4ZWxSYXRpbywgb3ZlcmxhcHMsIGRlY2x1dHRlclRyZWUpIHtcbiAgICBWZWN0b3JDb250ZXh0LmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICB0aGlzLmRlY2x1dHRlclRyZWUgPSBkZWNsdXR0ZXJUcmVlO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50b2xlcmFuY2UgPSB0b2xlcmFuY2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQGNvbnN0XG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gICAgICovXG4gICAgdGhpcy5tYXhFeHRlbnQgPSBtYXhFeHRlbnQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5vdmVybGFwcyA9IG92ZXJsYXBzO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5waXhlbFJhdGlvID0gcGl4ZWxSYXRpbztcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4TGluZVdpZHRoID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAY29uc3RcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuYWxpZ25GaWxsXztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PCo+fVxuICAgICAqL1xuICAgIHRoaXMuYmVnaW5HZW9tZXRyeUluc3RydWN0aW9uMV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8Kj59XG4gICAgICovXG4gICAgdGhpcy5iZWdpbkdlb21ldHJ5SW5zdHJ1Y3Rpb24yXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgICAqL1xuICAgIHRoaXMuYnVmZmVyZWRNYXhFeHRlbnRfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7QXJyYXk8Kj59XG4gICAgICovXG4gICAgdGhpcy5pbnN0cnVjdGlvbnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLmNvb3JkaW5hdGVzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshT2JqZWN0PG51bWJlcixpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8QXJyYXk8aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPnxBcnJheTxBcnJheTxpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+Pj59XG4gICAgICovXG4gICAgdGhpcy5jb29yZGluYXRlQ2FjaGVfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshaW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVkVHJhbnNmb3JtXyA9IGNyZWF0ZVRyYW5zZm9ybSgpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtBcnJheTwqPn1cbiAgICAgKi9cbiAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLnBpeGVsQ29vcmRpbmF0ZXNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkZpbGxTdHJva2VTdGF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLnN0YXRlID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRmlsbFN0cm9rZVN0YXRlfSAqLyAoe30pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudmlld1JvdGF0aW9uXyA9IDA7XG5cbiAgfVxuXG4gIGlmICggVmVjdG9yQ29udGV4dCApIENhbnZhc1JlcGxheS5fX3Byb3RvX18gPSBWZWN0b3JDb250ZXh0O1xuICBDYW52YXNSZXBsYXkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVmVjdG9yQ29udGV4dCAmJiBWZWN0b3JDb250ZXh0LnByb3RvdHlwZSApO1xuICBDYW52YXNSZXBsYXkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2FudmFzUmVwbGF5O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBDb250ZXh0LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gcDEgMXN0IHBvaW50IG9mIHRoZSBiYWNrZ3JvdW5kIGJveC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IHAyIDJuZCBwb2ludCBvZiB0aGUgYmFja2dyb3VuZCBib3guXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBwMyAzcmQgcG9pbnQgb2YgdGhlIGJhY2tncm91bmQgYm94LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gcDQgNHRoIHBvaW50IG9mIHRoZSBiYWNrZ3JvdW5kIGJveC5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gZmlsbEluc3RydWN0aW9uIEZpbGwgaW5zdHJ1Y3Rpb24uXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IHN0cm9rZUluc3RydWN0aW9uIFN0cm9rZSBpbnN0cnVjdGlvbi5cbiAgICovXG4gIENhbnZhc1JlcGxheS5wcm90b3R5cGUucmVwbGF5VGV4dEJhY2tncm91bmRfID0gZnVuY3Rpb24gcmVwbGF5VGV4dEJhY2tncm91bmRfIChjb250ZXh0LCBwMSwgcDIsIHAzLCBwNCwgZmlsbEluc3RydWN0aW9uLCBzdHJva2VJbnN0cnVjdGlvbikge1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8uYXBwbHkoY29udGV4dCwgcDEpO1xuICAgIGNvbnRleHQubGluZVRvLmFwcGx5KGNvbnRleHQsIHAyKTtcbiAgICBjb250ZXh0LmxpbmVUby5hcHBseShjb250ZXh0LCBwMyk7XG4gICAgY29udGV4dC5saW5lVG8uYXBwbHkoY29udGV4dCwgcDQpO1xuICAgIGNvbnRleHQubGluZVRvLmFwcGx5KGNvbnRleHQsIHAxKTtcbiAgICBpZiAoZmlsbEluc3RydWN0aW9uKSB7XG4gICAgICB0aGlzLmFsaWduRmlsbF8gPSAvKiogQHR5cGUge2Jvb2xlYW59ICovIChmaWxsSW5zdHJ1Y3Rpb25bMl0pO1xuICAgICAgdGhpcy5maWxsXyhjb250ZXh0KTtcbiAgICB9XG4gICAgaWYgKHN0cm9rZUluc3RydWN0aW9uKSB7XG4gICAgICB0aGlzLnNldFN0cm9rZVN0eWxlXyhjb250ZXh0LCAvKiogQHR5cGUge0FycmF5PCo+fSAqLyAoc3Ryb2tlSW5zdHJ1Y3Rpb24pKTtcbiAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBDb250ZXh0LlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICAgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8SFRNTFZpZGVvRWxlbWVudH0gaW1hZ2UgSW1hZ2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhbmNob3JYIEFuY2hvciBYLlxuICAgKiBAcGFyYW0ge251bWJlcn0gYW5jaG9yWSBBbmNob3IgWS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRGVjbHV0dGVyR3JvdXB9IGRlY2x1dHRlckdyb3VwIERlY2x1dHRlciBncm91cC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBIZWlnaHQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcGFjaXR5IE9wYWNpdHkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcmlnaW5YIE9yaWdpbiBYLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb3JpZ2luWSBPcmlnaW4gWS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGUgU2NhbGUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc25hcFRvUGl4ZWwgU25hcCB0byBwaXhlbC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFdpZHRoLlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHBhZGRpbmcgUGFkZGluZy5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gZmlsbEluc3RydWN0aW9uIEZpbGwgaW5zdHJ1Y3Rpb24uXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IHN0cm9rZUluc3RydWN0aW9uIFN0cm9rZSBpbnN0cnVjdGlvbi5cbiAgICovXG4gIENhbnZhc1JlcGxheS5wcm90b3R5cGUucmVwbGF5SW1hZ2VfID0gZnVuY3Rpb24gcmVwbGF5SW1hZ2VfIChcbiAgICBjb250ZXh0LFxuICAgIHgsXG4gICAgeSxcbiAgICBpbWFnZSxcbiAgICBhbmNob3JYLFxuICAgIGFuY2hvclksXG4gICAgZGVjbHV0dGVyR3JvdXAsXG4gICAgaGVpZ2h0LFxuICAgIG9wYWNpdHksXG4gICAgb3JpZ2luWCxcbiAgICBvcmlnaW5ZLFxuICAgIHJvdGF0aW9uLFxuICAgIHNjYWxlLFxuICAgIHNuYXBUb1BpeGVsLFxuICAgIHdpZHRoLFxuICAgIHBhZGRpbmcsXG4gICAgZmlsbEluc3RydWN0aW9uLFxuICAgIHN0cm9rZUluc3RydWN0aW9uXG4gICkge1xuICAgIHZhciBmaWxsU3Ryb2tlID0gZmlsbEluc3RydWN0aW9uIHx8IHN0cm9rZUluc3RydWN0aW9uO1xuICAgIGFuY2hvclggKj0gc2NhbGU7XG4gICAgYW5jaG9yWSAqPSBzY2FsZTtcbiAgICB4IC09IGFuY2hvclg7XG4gICAgeSAtPSBhbmNob3JZO1xuXG4gICAgdmFyIHcgPSAod2lkdGggKyBvcmlnaW5YID4gaW1hZ2Uud2lkdGgpID8gaW1hZ2Uud2lkdGggLSBvcmlnaW5YIDogd2lkdGg7XG4gICAgdmFyIGggPSAoaGVpZ2h0ICsgb3JpZ2luWSA+IGltYWdlLmhlaWdodCkgPyBpbWFnZS5oZWlnaHQgLSBvcmlnaW5ZIDogaGVpZ2h0O1xuICAgIHZhciBib3hXID0gcGFkZGluZ1szXSArIHcgKiBzY2FsZSArIHBhZGRpbmdbMV07XG4gICAgdmFyIGJveEggPSBwYWRkaW5nWzBdICsgaCAqIHNjYWxlICsgcGFkZGluZ1syXTtcbiAgICB2YXIgYm94WCA9IHggLSBwYWRkaW5nWzNdO1xuICAgIHZhciBib3hZID0geSAtIHBhZGRpbmdbMF07XG5cbiAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gKi9cbiAgICB2YXIgcDE7XG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9ICovXG4gICAgdmFyIHAyO1xuICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSAqL1xuICAgIHZhciBwMztcbiAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gKi9cbiAgICB2YXIgcDQ7XG4gICAgaWYgKGZpbGxTdHJva2UgfHwgcm90YXRpb24gIT09IDApIHtcbiAgICAgIHAxID0gW2JveFgsIGJveFldO1xuICAgICAgcDIgPSBbYm94WCArIGJveFcsIGJveFldO1xuICAgICAgcDMgPSBbYm94WCArIGJveFcsIGJveFkgKyBib3hIXTtcbiAgICAgIHA0ID0gW2JveFgsIGJveFkgKyBib3hIXTtcbiAgICB9XG5cbiAgICB2YXIgdHJhbnNmb3JtID0gbnVsbDtcbiAgICBpZiAocm90YXRpb24gIT09IDApIHtcbiAgICAgIHZhciBjZW50ZXJYID0geCArIGFuY2hvclg7XG4gICAgICB2YXIgY2VudGVyWSA9IHkgKyBhbmNob3JZO1xuICAgICAgdHJhbnNmb3JtID0gY29tcG9zZVRyYW5zZm9ybSh0bXBUcmFuc2Zvcm0sIGNlbnRlclgsIGNlbnRlclksIDEsIDEsIHJvdGF0aW9uLCAtY2VudGVyWCwgLWNlbnRlclkpO1xuXG4gICAgICBjcmVhdGVPclVwZGF0ZUVtcHR5KHRtcEV4dGVudCk7XG4gICAgICBleHRlbmRDb29yZGluYXRlKHRtcEV4dGVudCwgYXBwbHlUcmFuc2Zvcm0odG1wVHJhbnNmb3JtLCBwMSkpO1xuICAgICAgZXh0ZW5kQ29vcmRpbmF0ZSh0bXBFeHRlbnQsIGFwcGx5VHJhbnNmb3JtKHRtcFRyYW5zZm9ybSwgcDIpKTtcbiAgICAgIGV4dGVuZENvb3JkaW5hdGUodG1wRXh0ZW50LCBhcHBseVRyYW5zZm9ybSh0bXBUcmFuc2Zvcm0sIHAzKSk7XG4gICAgICBleHRlbmRDb29yZGluYXRlKHRtcEV4dGVudCwgYXBwbHlUcmFuc2Zvcm0odG1wVHJhbnNmb3JtLCBwNCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjcmVhdGVPclVwZGF0ZShib3hYLCBib3hZLCBib3hYICsgYm94VywgYm94WSArIGJveEgsIHRtcEV4dGVudCk7XG4gICAgfVxuICAgIHZhciBjYW52YXMgPSBjb250ZXh0LmNhbnZhcztcbiAgICB2YXIgc3Ryb2tlUGFkZGluZyA9IHN0cm9rZUluc3RydWN0aW9uID8gKHN0cm9rZUluc3RydWN0aW9uWzJdICogc2NhbGUgLyAyKSA6IDA7XG4gICAgdmFyIGludGVyc2VjdHMgPVxuICAgICAgICB0bXBFeHRlbnRbMF0gLSBzdHJva2VQYWRkaW5nIDw9IGNhbnZhcy53aWR0aCAmJiB0bXBFeHRlbnRbMl0gKyBzdHJva2VQYWRkaW5nID49IDAgJiZcbiAgICAgICAgdG1wRXh0ZW50WzFdIC0gc3Ryb2tlUGFkZGluZyA8PSBjYW52YXMuaGVpZ2h0ICYmIHRtcEV4dGVudFszXSArIHN0cm9rZVBhZGRpbmcgPj0gMDtcblxuICAgIGlmIChzbmFwVG9QaXhlbCkge1xuICAgICAgeCA9IE1hdGgucm91bmQoeCk7XG4gICAgICB5ID0gTWF0aC5yb3VuZCh5KTtcbiAgICB9XG5cbiAgICBpZiAoZGVjbHV0dGVyR3JvdXApIHtcbiAgICAgIGlmICghaW50ZXJzZWN0cyAmJiBkZWNsdXR0ZXJHcm91cFs0XSA9PSAxKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGV4dGVuZChkZWNsdXR0ZXJHcm91cCwgdG1wRXh0ZW50KTtcbiAgICAgIHZhciBkZWNsdXR0ZXJBcmdzID0gaW50ZXJzZWN0cyA/XG4gICAgICAgIFtjb250ZXh0LCB0cmFuc2Zvcm0gPyB0cmFuc2Zvcm0uc2xpY2UoMCkgOiBudWxsLCBvcGFjaXR5LCBpbWFnZSwgb3JpZ2luWCwgb3JpZ2luWSwgdywgaCwgeCwgeSwgc2NhbGVdIDpcbiAgICAgICAgbnVsbDtcbiAgICAgIGlmIChkZWNsdXR0ZXJBcmdzICYmIGZpbGxTdHJva2UpIHtcbiAgICAgICAgZGVjbHV0dGVyQXJncy5wdXNoKGZpbGxJbnN0cnVjdGlvbiwgc3Ryb2tlSW5zdHJ1Y3Rpb24sIHAxLCBwMiwgcDMsIHA0KTtcbiAgICAgIH1cbiAgICAgIGRlY2x1dHRlckdyb3VwLnB1c2goZGVjbHV0dGVyQXJncyk7XG4gICAgfSBlbHNlIGlmIChpbnRlcnNlY3RzKSB7XG4gICAgICBpZiAoZmlsbFN0cm9rZSkge1xuICAgICAgICB0aGlzLnJlcGxheVRleHRCYWNrZ3JvdW5kXyhjb250ZXh0LCBwMSwgcDIsIHAzLCBwNCxcbiAgICAgICAgICAvKiogQHR5cGUge0FycmF5PCo+fSAqLyAoZmlsbEluc3RydWN0aW9uKSxcbiAgICAgICAgICAvKiogQHR5cGUge0FycmF5PCo+fSAqLyAoc3Ryb2tlSW5zdHJ1Y3Rpb24pKTtcbiAgICAgIH1cbiAgICAgIGRyYXdJbWFnZShjb250ZXh0LCB0cmFuc2Zvcm0sIG9wYWNpdHksIGltYWdlLCBvcmlnaW5YLCBvcmlnaW5ZLCB3LCBoLCB4LCB5LCBzY2FsZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZGFzaEFycmF5IERhc2ggYXJyYXkuXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IERhc2ggYXJyYXkgd2l0aCBwaXhlbCByYXRpbyBhcHBsaWVkXG4gICAqL1xuICBDYW52YXNSZXBsYXkucHJvdG90eXBlLmFwcGx5UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uIGFwcGx5UGl4ZWxSYXRpbyAoZGFzaEFycmF5KSB7XG4gICAgdmFyIHBpeGVsUmF0aW8gPSB0aGlzLnBpeGVsUmF0aW87XG4gICAgcmV0dXJuIHBpeGVsUmF0aW8gPT0gMSA/IGRhc2hBcnJheSA6IGRhc2hBcnJheS5tYXAoZnVuY3Rpb24oZGFzaCkge1xuICAgICAgcmV0dXJuIGRhc2ggKiBwaXhlbFJhdGlvO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNsb3NlZCBMYXN0IGlucHV0IGNvb3JkaW5hdGUgZXF1YWxzIGZpcnN0LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNraXBGaXJzdCBTa2lwIGZpcnN0IGNvb3JkaW5hdGUuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHJldHVybiB7bnVtYmVyfSBNeSBlbmQuXG4gICAqL1xuICBDYW52YXNSZXBsYXkucHJvdG90eXBlLmFwcGVuZEZsYXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIGFwcGVuZEZsYXRDb29yZGluYXRlcyAoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCBjbG9zZWQsIHNraXBGaXJzdCkge1xuXG4gICAgdmFyIG15RW5kID0gdGhpcy5jb29yZGluYXRlcy5sZW5ndGg7XG4gICAgdmFyIGV4dGVudCA9IHRoaXMuZ2V0QnVmZmVyZWRNYXhFeHRlbnQoKTtcbiAgICBpZiAoc2tpcEZpcnN0KSB7XG4gICAgICBvZmZzZXQgKz0gc3RyaWRlO1xuICAgIH1cbiAgICB2YXIgbGFzdENvb3JkID0gW2ZsYXRDb29yZGluYXRlc1tvZmZzZXRdLCBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV1dO1xuICAgIHZhciBuZXh0Q29vcmQgPSBbTmFOLCBOYU5dO1xuICAgIHZhciBza2lwcGVkID0gdHJ1ZTtcblxuICAgIHZhciBpLCBsYXN0UmVsLCBuZXh0UmVsO1xuICAgIGZvciAoaSA9IG9mZnNldCArIHN0cmlkZTsgaSA8IGVuZDsgaSArPSBzdHJpZGUpIHtcbiAgICAgIG5leHRDb29yZFswXSA9IGZsYXRDb29yZGluYXRlc1tpXTtcbiAgICAgIG5leHRDb29yZFsxXSA9IGZsYXRDb29yZGluYXRlc1tpICsgMV07XG4gICAgICBuZXh0UmVsID0gY29vcmRpbmF0ZVJlbGF0aW9uc2hpcChleHRlbnQsIG5leHRDb29yZCk7XG4gICAgICBpZiAobmV4dFJlbCAhPT0gbGFzdFJlbCkge1xuICAgICAgICBpZiAoc2tpcHBlZCkge1xuICAgICAgICAgIHRoaXMuY29vcmRpbmF0ZXNbbXlFbmQrK10gPSBsYXN0Q29vcmRbMF07XG4gICAgICAgICAgdGhpcy5jb29yZGluYXRlc1tteUVuZCsrXSA9IGxhc3RDb29yZFsxXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvb3JkaW5hdGVzW215RW5kKytdID0gbmV4dENvb3JkWzBdO1xuICAgICAgICB0aGlzLmNvb3JkaW5hdGVzW215RW5kKytdID0gbmV4dENvb3JkWzFdO1xuICAgICAgICBza2lwcGVkID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKG5leHRSZWwgPT09IFJlbGF0aW9uc2hpcC5JTlRFUlNFQ1RJTkcpIHtcbiAgICAgICAgdGhpcy5jb29yZGluYXRlc1tteUVuZCsrXSA9IG5leHRDb29yZFswXTtcbiAgICAgICAgdGhpcy5jb29yZGluYXRlc1tteUVuZCsrXSA9IG5leHRDb29yZFsxXTtcbiAgICAgICAgc2tpcHBlZCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2tpcHBlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBsYXN0Q29vcmRbMF0gPSBuZXh0Q29vcmRbMF07XG4gICAgICBsYXN0Q29vcmRbMV0gPSBuZXh0Q29vcmRbMV07XG4gICAgICBsYXN0UmVsID0gbmV4dFJlbDtcbiAgICB9XG5cbiAgICAvLyBMYXN0IGNvb3JkaW5hdGUgZXF1YWxzIGZpcnN0IG9yIG9ubHkgb25lIHBvaW50IHRvIGFwcGVuZDpcbiAgICBpZiAoKGNsb3NlZCAmJiBza2lwcGVkKSB8fCBpID09PSBvZmZzZXQgKyBzdHJpZGUpIHtcbiAgICAgIHRoaXMuY29vcmRpbmF0ZXNbbXlFbmQrK10gPSBsYXN0Q29vcmRbMF07XG4gICAgICB0aGlzLmNvb3JkaW5hdGVzW215RW5kKytdID0gbGFzdENvb3JkWzFdO1xuICAgIH1cbiAgICByZXR1cm4gbXlFbmQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGVuZHMgRW5kcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gcmVwbGF5RW5kcyBSZXBsYXkgZW5kcy5cbiAgICogQHJldHVybiB7bnVtYmVyfSBPZmZzZXQuXG4gICAqL1xuICBDYW52YXNSZXBsYXkucHJvdG90eXBlLmRyYXdDdXN0b21Db29yZGluYXRlc18gPSBmdW5jdGlvbiBkcmF3Q3VzdG9tQ29vcmRpbmF0ZXNfIChmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlLCByZXBsYXlFbmRzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB2YXIgZW5kID0gZW5kc1tpXTtcbiAgICAgIHZhciByZXBsYXlFbmQgPSB0aGlzLmFwcGVuZEZsYXRDb29yZGluYXRlcyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIGZhbHNlLCBmYWxzZSk7XG4gICAgICByZXBsYXlFbmRzLnB1c2gocmVwbGF5RW5kKTtcbiAgICAgIG9mZnNldCA9IGVuZDtcbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2MuXG4gICAqL1xuICBDYW52YXNSZXBsYXkucHJvdG90eXBlLmRyYXdDdXN0b20gPSBmdW5jdGlvbiBkcmF3Q3VzdG9tIChnZW9tZXRyeSwgZmVhdHVyZSwgcmVuZGVyZXIpIHtcbiAgICB0aGlzLmJlZ2luR2VvbWV0cnkoZ2VvbWV0cnksIGZlYXR1cmUpO1xuICAgIHZhciB0eXBlID0gZ2VvbWV0cnkuZ2V0VHlwZSgpO1xuICAgIHZhciBzdHJpZGUgPSBnZW9tZXRyeS5nZXRTdHJpZGUoKTtcbiAgICB2YXIgcmVwbGF5QmVnaW4gPSB0aGlzLmNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICB2YXIgZmxhdENvb3JkaW5hdGVzLCByZXBsYXlFbmQsIHJlcGxheUVuZHMsIHJlcGxheUVuZHNzO1xuICAgIHZhciBvZmZzZXQ7XG4gICAgaWYgKHR5cGUgPT0gR2VvbWV0cnlUeXBlLk1VTFRJX1BPTFlHT04pIHtcbiAgICAgIGdlb21ldHJ5ID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9nZW9tL011bHRpUG9seWdvbi5qc1wiKS5kZWZhdWx0fSAqLyAoZ2VvbWV0cnkpO1xuICAgICAgZmxhdENvb3JkaW5hdGVzID0gZ2VvbWV0cnkuZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIHJlcGxheUVuZHNzID0gW107XG4gICAgICB2YXIgZW5kc3MgPSBnZW9tZXRyeS5nZXRFbmRzcygpO1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGVuZHNzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgdmFyIG15RW5kcyA9IFtdO1xuICAgICAgICBvZmZzZXQgPSB0aGlzLmRyYXdDdXN0b21Db29yZGluYXRlc18oZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHNzW2ldLCBzdHJpZGUsIG15RW5kcyk7XG4gICAgICAgIHJlcGxheUVuZHNzLnB1c2gobXlFbmRzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goW0NhbnZhc0luc3RydWN0aW9uLkNVU1RPTSxcbiAgICAgICAgcmVwbGF5QmVnaW4sIHJlcGxheUVuZHNzLCBnZW9tZXRyeSwgcmVuZGVyZXIsIGluZmxhdGVNdWx0aUNvb3JkaW5hdGVzQXJyYXldKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gR2VvbWV0cnlUeXBlLlBPTFlHT04gfHwgdHlwZSA9PSBHZW9tZXRyeVR5cGUuTVVMVElfTElORV9TVFJJTkcpIHtcbiAgICAgIHJlcGxheUVuZHMgPSBbXTtcbiAgICAgIGZsYXRDb29yZGluYXRlcyA9ICh0eXBlID09IEdlb21ldHJ5VHlwZS5QT0xZR09OKSA/XG4gICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9Qb2x5Z29uLmpzXCIpLmRlZmF1bHR9ICovIChnZW9tZXRyeSkuZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMoKSA6XG4gICAgICAgIGdlb21ldHJ5LmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgICAgb2Zmc2V0ID0gdGhpcy5kcmF3Q3VzdG9tQ29vcmRpbmF0ZXNfKGZsYXRDb29yZGluYXRlcywgMCxcbiAgICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9nZW9tL1BvbHlnb24uanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi8uLi9nZW9tL011bHRpTGluZVN0cmluZy5qc1wiKS5kZWZhdWx0fSAqLyAoZ2VvbWV0cnkpLmdldEVuZHMoKSxcbiAgICAgICAgc3RyaWRlLCByZXBsYXlFbmRzKTtcbiAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goW0NhbnZhc0luc3RydWN0aW9uLkNVU1RPTSxcbiAgICAgICAgcmVwbGF5QmVnaW4sIHJlcGxheUVuZHMsIGdlb21ldHJ5LCByZW5kZXJlciwgaW5mbGF0ZUNvb3JkaW5hdGVzQXJyYXldKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gR2VvbWV0cnlUeXBlLkxJTkVfU1RSSU5HIHx8IHR5cGUgPT0gR2VvbWV0cnlUeXBlLk1VTFRJX1BPSU5UKSB7XG4gICAgICBmbGF0Q29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIHJlcGxheUVuZCA9IHRoaXMuYXBwZW5kRmxhdENvb3JkaW5hdGVzKFxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXMsIDAsIGZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHN0cmlkZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goW0NhbnZhc0luc3RydWN0aW9uLkNVU1RPTSxcbiAgICAgICAgcmVwbGF5QmVnaW4sIHJlcGxheUVuZCwgZ2VvbWV0cnksIHJlbmRlcmVyLCBpbmZsYXRlQ29vcmRpbmF0ZXNdKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gR2VvbWV0cnlUeXBlLlBPSU5UKSB7XG4gICAgICBmbGF0Q29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIHRoaXMuY29vcmRpbmF0ZXMucHVzaChmbGF0Q29vcmRpbmF0ZXNbMF0sIGZsYXRDb29yZGluYXRlc1sxXSk7XG4gICAgICByZXBsYXlFbmQgPSB0aGlzLmNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goW0NhbnZhc0luc3RydWN0aW9uLkNVU1RPTSxcbiAgICAgICAgcmVwbGF5QmVnaW4sIHJlcGxheUVuZCwgZ2VvbWV0cnksIHJlbmRlcmVyXSk7XG4gICAgfVxuICAgIHRoaXMuZW5kR2VvbWV0cnkoZ2VvbWV0cnksIGZlYXR1cmUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKi9cbiAgQ2FudmFzUmVwbGF5LnByb3RvdHlwZS5iZWdpbkdlb21ldHJ5ID0gZnVuY3Rpb24gYmVnaW5HZW9tZXRyeSAoZ2VvbWV0cnksIGZlYXR1cmUpIHtcbiAgICB0aGlzLmJlZ2luR2VvbWV0cnlJbnN0cnVjdGlvbjFfID0gW0NhbnZhc0luc3RydWN0aW9uLkJFR0lOX0dFT01FVFJZLCBmZWF0dXJlLCAwXTtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKHRoaXMuYmVnaW5HZW9tZXRyeUluc3RydWN0aW9uMV8pO1xuICAgIHRoaXMuYmVnaW5HZW9tZXRyeUluc3RydWN0aW9uMl8gPSBbQ2FudmFzSW5zdHJ1Y3Rpb24uQkVHSU5fR0VPTUVUUlksIGZlYXR1cmUsIDBdO1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2godGhpcy5iZWdpbkdlb21ldHJ5SW5zdHJ1Y3Rpb24yXyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZJWE1FIGVtcHR5IGRlc2NyaXB0aW9uIGZvciBqc2RvY1xuICAgKi9cbiAgQ2FudmFzUmVwbGF5LnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiBmaW5pc2ggKCkge307XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IENvbnRleHQuXG4gICAqL1xuICBDYW52YXNSZXBsYXkucHJvdG90eXBlLmZpbGxfID0gZnVuY3Rpb24gZmlsbF8gKGNvbnRleHQpIHtcbiAgICBpZiAodGhpcy5hbGlnbkZpbGxfKSB7XG4gICAgICB2YXIgb3JpZ2luID0gYXBwbHlUcmFuc2Zvcm0odGhpcy5yZW5kZXJlZFRyYW5zZm9ybV8sIFswLCAwXSk7XG4gICAgICB2YXIgcmVwZWF0U2l6ZSA9IDUxMiAqIHRoaXMucGl4ZWxSYXRpbztcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKG9yaWdpblswXSAlIHJlcGVhdFNpemUsIG9yaWdpblsxXSAlIHJlcGVhdFNpemUpO1xuICAgICAgY29udGV4dC5yb3RhdGUodGhpcy52aWV3Um90YXRpb25fKTtcbiAgICB9XG4gICAgY29udGV4dC5maWxsKCk7XG4gICAgaWYgKHRoaXMuYWxpZ25GaWxsXykge1xuICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0uYXBwbHkoY29udGV4dCwgcmVzZXRUcmFuc2Zvcm0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gaW5zdHJ1Y3Rpb24gSW5zdHJ1Y3Rpb24uXG4gICAqL1xuICBDYW52YXNSZXBsYXkucHJvdG90eXBlLnNldFN0cm9rZVN0eWxlXyA9IGZ1bmN0aW9uIHNldFN0cm9rZVN0eWxlXyAoY29udGV4dCwgaW5zdHJ1Y3Rpb24pIHtcbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfSAqLyAoaW5zdHJ1Y3Rpb25bMV0pO1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblsyXSk7XG4gICAgY29udGV4dC5saW5lQ2FwID0gLyoqIEB0eXBlIHtDYW52YXNMaW5lQ2FwfSAqLyAoaW5zdHJ1Y3Rpb25bM10pO1xuICAgIGNvbnRleHQubGluZUpvaW4gPSAvKiogQHR5cGUge0NhbnZhc0xpbmVKb2lufSAqLyAoaW5zdHJ1Y3Rpb25bNF0pO1xuICAgIGNvbnRleHQubWl0ZXJMaW1pdCA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bNV0pO1xuICAgIGlmIChDQU5WQVNfTElORV9EQVNIKSB7XG4gICAgICBjb250ZXh0LmxpbmVEYXNoT2Zmc2V0ID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvbls3XSk7XG4gICAgICBjb250ZXh0LnNldExpbmVEYXNoKC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi8gKGluc3RydWN0aW9uWzZdKSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5EZWNsdXR0ZXJHcm91cH0gZGVjbHV0dGVyR3JvdXAgRGVjbHV0dGVyIGdyb3VwLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICovXG4gIENhbnZhc1JlcGxheS5wcm90b3R5cGUucmVuZGVyRGVjbHV0dGVyXyA9IGZ1bmN0aW9uIHJlbmRlckRlY2x1dHRlcl8gKGRlY2x1dHRlckdyb3VwLCBmZWF0dXJlKSB7XG4gICAgaWYgKGRlY2x1dHRlckdyb3VwICYmIGRlY2x1dHRlckdyb3VwLmxlbmd0aCA+IDUpIHtcbiAgICAgIHZhciBncm91cENvdW50ID0gZGVjbHV0dGVyR3JvdXBbNF07XG4gICAgICBpZiAoZ3JvdXBDb3VudCA9PSAxIHx8IGdyb3VwQ291bnQgPT0gZGVjbHV0dGVyR3JvdXAubGVuZ3RoIC0gNSkge1xuICAgICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL3N0cnVjdHMvUkJ1c2guanNcIikuRW50cnl9ICovXG4gICAgICAgIHZhciBib3ggPSB7XG4gICAgICAgICAgbWluWDogLyoqIEB0eXBlIHtudW1iZXJ9ICovIChkZWNsdXR0ZXJHcm91cFswXSksXG4gICAgICAgICAgbWluWTogLyoqIEB0eXBlIHtudW1iZXJ9ICovIChkZWNsdXR0ZXJHcm91cFsxXSksXG4gICAgICAgICAgbWF4WDogLyoqIEB0eXBlIHtudW1iZXJ9ICovIChkZWNsdXR0ZXJHcm91cFsyXSksXG4gICAgICAgICAgbWF4WTogLyoqIEB0eXBlIHtudW1iZXJ9ICovIChkZWNsdXR0ZXJHcm91cFszXSksXG4gICAgICAgICAgdmFsdWU6IGZlYXR1cmVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCF0aGlzLmRlY2x1dHRlclRyZWUuY29sbGlkZXMoYm94KSkge1xuICAgICAgICAgIHRoaXMuZGVjbHV0dGVyVHJlZS5pbnNlcnQoYm94KTtcbiAgICAgICAgICBmb3IgKHZhciBqID0gNSwgamogPSBkZWNsdXR0ZXJHcm91cC5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgICAgICAgICB2YXIgZGVjbHV0dGVyRGF0YSA9IC8qKiBAdHlwZSB7QXJyYXl9ICovIChkZWNsdXR0ZXJHcm91cFtqXSk7XG4gICAgICAgICAgICBpZiAoZGVjbHV0dGVyRGF0YSkge1xuICAgICAgICAgICAgICBpZiAoZGVjbHV0dGVyRGF0YS5sZW5ndGggPiAxMSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVwbGF5VGV4dEJhY2tncm91bmRfKGRlY2x1dHRlckRhdGFbMF0sXG4gICAgICAgICAgICAgICAgICBkZWNsdXR0ZXJEYXRhWzEzXSwgZGVjbHV0dGVyRGF0YVsxNF0sIGRlY2x1dHRlckRhdGFbMTVdLCBkZWNsdXR0ZXJEYXRhWzE2XSxcbiAgICAgICAgICAgICAgICAgIGRlY2x1dHRlckRhdGFbMTFdLCBkZWNsdXR0ZXJEYXRhWzEyXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZHJhd0ltYWdlLmFwcGx5KHVuZGVmaW5lZCwgZGVjbHV0dGVyRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlY2x1dHRlckdyb3VwLmxlbmd0aCA9IDU7XG4gICAgICAgIGNyZWF0ZU9yVXBkYXRlRW1wdHkoZGVjbHV0dGVyR3JvdXApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfSB0cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGJvb2xlYW4+fSBza2lwcGVkRmVhdHVyZXNIYXNoIElkcyBvZiBmZWF0dXJlc1xuICAgKiAgICAgdG8gc2tpcC5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gaW5zdHJ1Y3Rpb25zIEluc3RydWN0aW9ucyBhcnJheS5cbiAgICogQHBhcmFtIHtib29sZWFufSBzbmFwVG9QaXhlbCBTbmFwIHBvaW50IHN5bWJvbHMgYW5kIHRleHQgdG8gaW50ZWdlciBwaXhlbHMuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKGltcG9ydChcIi4uLy4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQpKTogVHx1bmRlZmluZWR9IGZlYXR1cmVDYWxsYmFjayBGZWF0dXJlIGNhbGxiYWNrLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnQ9fSBvcHRfaGl0RXh0ZW50IE9ubHkgY2hlY2sgZmVhdHVyZXMgdGhhdCBpbnRlcnNlY3QgdGhpc1xuICAgKiAgICAgZXh0ZW50LlxuICAgKiBAcmV0dXJuIHtUfHVuZGVmaW5lZH0gQ2FsbGJhY2sgcmVzdWx0LlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKi9cbiAgQ2FudmFzUmVwbGF5LnByb3RvdHlwZS5yZXBsYXlfID0gZnVuY3Rpb24gcmVwbGF5XyAoXG4gICAgY29udGV4dCxcbiAgICB0cmFuc2Zvcm0sXG4gICAgc2tpcHBlZEZlYXR1cmVzSGFzaCxcbiAgICBpbnN0cnVjdGlvbnMsXG4gICAgc25hcFRvUGl4ZWwsXG4gICAgZmVhdHVyZUNhbGxiYWNrLFxuICAgIG9wdF9oaXRFeHRlbnRcbiAgKSB7XG4gICAgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqL1xuICAgIHZhciBwaXhlbENvb3JkaW5hdGVzO1xuICAgIGlmICh0aGlzLnBpeGVsQ29vcmRpbmF0ZXNfICYmIGVxdWFscyh0cmFuc2Zvcm0sIHRoaXMucmVuZGVyZWRUcmFuc2Zvcm1fKSkge1xuICAgICAgcGl4ZWxDb29yZGluYXRlcyA9IHRoaXMucGl4ZWxDb29yZGluYXRlc187XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghdGhpcy5waXhlbENvb3JkaW5hdGVzXykge1xuICAgICAgICB0aGlzLnBpeGVsQ29vcmRpbmF0ZXNfID0gW107XG4gICAgICB9XG4gICAgICBwaXhlbENvb3JkaW5hdGVzID0gdHJhbnNmb3JtMkQoXG4gICAgICAgIHRoaXMuY29vcmRpbmF0ZXMsIDAsIHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoLCAyLFxuICAgICAgICB0cmFuc2Zvcm0sIHRoaXMucGl4ZWxDb29yZGluYXRlc18pO1xuICAgICAgdHJhbnNmb3JtU2V0RnJvbUFycmF5KHRoaXMucmVuZGVyZWRUcmFuc2Zvcm1fLCB0cmFuc2Zvcm0pO1xuICAgIH1cbiAgICB2YXIgc2tpcEZlYXR1cmVzID0gIWlzRW1wdHkoc2tpcHBlZEZlYXR1cmVzSGFzaCk7XG4gICAgdmFyIGkgPSAwOyAvLyBpbnN0cnVjdGlvbiBpbmRleFxuICAgIHZhciBpaSA9IGluc3RydWN0aW9ucy5sZW5ndGg7IC8vIGVuZCBvZiBpbnN0cnVjdGlvbnNcbiAgICB2YXIgZCA9IDA7IC8vIGRhdGEgaW5kZXhcbiAgICB2YXIgZGQ7IC8vIGVuZCBvZiBwZXItaW5zdHJ1Y3Rpb24gZGF0YVxuICAgIHZhciBhbmNob3JYLCBhbmNob3JZLCBwcmV2WCwgcHJldlksIHJvdW5kWCwgcm91bmRZLCBkZWNsdXR0ZXJHcm91cCwgaW1hZ2U7XG4gICAgdmFyIHBlbmRpbmdGaWxsID0gMDtcbiAgICB2YXIgcGVuZGluZ1N0cm9rZSA9IDA7XG4gICAgdmFyIGxhc3RGaWxsSW5zdHJ1Y3Rpb24gPSBudWxsO1xuICAgIHZhciBsYXN0U3Ryb2tlSW5zdHJ1Y3Rpb24gPSBudWxsO1xuICAgIHZhciBjb29yZGluYXRlQ2FjaGUgPSB0aGlzLmNvb3JkaW5hdGVDYWNoZV87XG4gICAgdmFyIHZpZXdSb3RhdGlvbiA9IHRoaXMudmlld1JvdGF0aW9uXztcblxuICAgIHZhciBzdGF0ZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vcmVuZGVyLmpzXCIpLlN0YXRlfSAqLyAoe1xuICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgIHBpeGVsUmF0aW86IHRoaXMucGl4ZWxSYXRpbyxcbiAgICAgIHJlc29sdXRpb246IHRoaXMucmVzb2x1dGlvbixcbiAgICAgIHJvdGF0aW9uOiB2aWV3Um90YXRpb25cbiAgICB9KTtcblxuICAgIC8vIFdoZW4gdGhlIGJhdGNoIHNpemUgZ2V0cyB0b28gYmlnLCBwZXJmb3JtYW5jZSBkZWNyZWFzZXMuIDIwMCBpcyBhIGdvb2RcbiAgICAvLyBiYWxhbmNlIGJldHdlZW4gYmF0Y2ggc2l6ZSBhbmQgbnVtYmVyIG9mIGZpbGwvc3Ryb2tlIGluc3RydWN0aW9ucy5cbiAgICB2YXIgYmF0Y2hTaXplID0gdGhpcy5pbnN0cnVjdGlvbnMgIT0gaW5zdHJ1Y3Rpb25zIHx8IHRoaXMub3ZlcmxhcHMgPyAwIDogMjAwO1xuICAgIHZhciAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9ICovIGZlYXR1cmU7XG4gICAgdmFyIHgsIHk7XG4gICAgd2hpbGUgKGkgPCBpaSkge1xuICAgICAgdmFyIGluc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb25zW2ldO1xuICAgICAgdmFyIHR5cGUgPSAvKiogQHR5cGUge0NhbnZhc0luc3RydWN0aW9ufSAqLyAoaW5zdHJ1Y3Rpb25bMF0pO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgQ2FudmFzSW5zdHJ1Y3Rpb24uQkVHSU5fR0VPTUVUUlk6XG4gICAgICAgICAgZmVhdHVyZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gKi8gKGluc3RydWN0aW9uWzFdKTtcbiAgICAgICAgICBpZiAoKHNraXBGZWF0dXJlcyAmJiBza2lwcGVkRmVhdHVyZXNIYXNoW2dldFVpZChmZWF0dXJlKV0pIHx8ICFmZWF0dXJlLmdldEdlb21ldHJ5KCkpIHtcbiAgICAgICAgICAgIGkgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzJdKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9wdF9oaXRFeHRlbnQgIT09IHVuZGVmaW5lZCAmJiAhaW50ZXJzZWN0cyhcbiAgICAgICAgICAgIG9wdF9oaXRFeHRlbnQsIGZlYXR1cmUuZ2V0R2VvbWV0cnkoKS5nZXRFeHRlbnQoKSkpIHtcbiAgICAgICAgICAgIGkgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzJdKSArIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICsraTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ2FudmFzSW5zdHJ1Y3Rpb24uQkVHSU5fUEFUSDpcbiAgICAgICAgICBpZiAocGVuZGluZ0ZpbGwgPiBiYXRjaFNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsbF8oY29udGV4dCk7XG4gICAgICAgICAgICBwZW5kaW5nRmlsbCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwZW5kaW5nU3Ryb2tlID4gYmF0Y2hTaXplKSB7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICAgICAgcGVuZGluZ1N0cm9rZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcGVuZGluZ0ZpbGwgJiYgIXBlbmRpbmdTdHJva2UpIHtcbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBwcmV2WCA9IHByZXZZID0gTmFOO1xuICAgICAgICAgIH1cbiAgICAgICAgICArK2k7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ2FudmFzSW5zdHJ1Y3Rpb24uQ0lSQ0xFOlxuICAgICAgICAgIGQgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzFdKTtcbiAgICAgICAgICB2YXIgeDEgPSBwaXhlbENvb3JkaW5hdGVzW2RdO1xuICAgICAgICAgIHZhciB5MSA9IHBpeGVsQ29vcmRpbmF0ZXNbZCArIDFdO1xuICAgICAgICAgIHZhciB4MiA9IHBpeGVsQ29vcmRpbmF0ZXNbZCArIDJdO1xuICAgICAgICAgIHZhciB5MiA9IHBpeGVsQ29vcmRpbmF0ZXNbZCArIDNdO1xuICAgICAgICAgIHZhciBkeCA9IHgyIC0geDE7XG4gICAgICAgICAgdmFyIGR5ID0geTIgLSB5MTtcbiAgICAgICAgICB2YXIgciA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgICAgY29udGV4dC5tb3ZlVG8oeDEgKyByLCB5MSk7XG4gICAgICAgICAgY29udGV4dC5hcmMoeDEsIHkxLCByLCAwLCAyICogTWF0aC5QSSwgdHJ1ZSk7XG4gICAgICAgICAgKytpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENhbnZhc0luc3RydWN0aW9uLkNMT1NFX1BBVEg6XG4gICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICArK2k7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ2FudmFzSW5zdHJ1Y3Rpb24uQ1VTVE9NOlxuICAgICAgICAgIGQgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzFdKTtcbiAgICAgICAgICBkZCA9IGluc3RydWN0aW9uWzJdO1xuICAgICAgICAgIHZhciBnZW9tZXRyeSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSAqLyAoaW5zdHJ1Y3Rpb25bM10pO1xuICAgICAgICAgIHZhciByZW5kZXJlciA9IGluc3RydWN0aW9uWzRdO1xuICAgICAgICAgIHZhciBmbiA9IGluc3RydWN0aW9uLmxlbmd0aCA9PSA2ID8gaW5zdHJ1Y3Rpb25bNV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgc3RhdGUuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbiAgICAgICAgICBzdGF0ZS5mZWF0dXJlID0gZmVhdHVyZTtcbiAgICAgICAgICBpZiAoIShpIGluIGNvb3JkaW5hdGVDYWNoZSkpIHtcbiAgICAgICAgICAgIGNvb3JkaW5hdGVDYWNoZVtpXSA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY29vcmRzID0gY29vcmRpbmF0ZUNhY2hlW2ldO1xuICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgZm4ocGl4ZWxDb29yZGluYXRlcywgZCwgZGQsIDIsIGNvb3Jkcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvb3Jkc1swXSA9IHBpeGVsQ29vcmRpbmF0ZXNbZF07XG4gICAgICAgICAgICBjb29yZHNbMV0gPSBwaXhlbENvb3JkaW5hdGVzW2QgKyAxXTtcbiAgICAgICAgICAgIGNvb3Jkcy5sZW5ndGggPSAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZW5kZXJlcihjb29yZHMsIHN0YXRlKTtcbiAgICAgICAgICArK2k7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ2FudmFzSW5zdHJ1Y3Rpb24uRFJBV19JTUFHRTpcbiAgICAgICAgICBkID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblsxXSk7XG4gICAgICAgICAgZGQgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzJdKTtcbiAgICAgICAgICBpbWFnZSA9IC8qKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnR8SFRNTFZpZGVvRWxlbWVudHxIVE1MSW1hZ2VFbGVtZW50fSAqL1xuICAgICAgICAgICAgICAoaW5zdHJ1Y3Rpb25bM10pO1xuICAgICAgICAgIC8vIFJlbWFpbmluZyBhcmd1bWVudHMgaW4gRFJBV19JTUFHRSBhcmUgaW4gYWxwaGFiZXRpY2FsIG9yZGVyXG4gICAgICAgICAgYW5jaG9yWCA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bNF0pO1xuICAgICAgICAgIGFuY2hvclkgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzVdKTtcbiAgICAgICAgICBkZWNsdXR0ZXJHcm91cCA9IGZlYXR1cmVDYWxsYmFjayA/IG51bGwgOiAvKiogQHR5cGUge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5EZWNsdXR0ZXJHcm91cH0gKi8gKGluc3RydWN0aW9uWzZdKTtcbiAgICAgICAgICB2YXIgaGVpZ2h0ID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvbls3XSk7XG4gICAgICAgICAgdmFyIG9wYWNpdHkgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzhdKTtcbiAgICAgICAgICB2YXIgb3JpZ2luWCA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bOV0pO1xuICAgICAgICAgIHZhciBvcmlnaW5ZID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblsxMF0pO1xuICAgICAgICAgIHZhciByb3RhdGVXaXRoVmlldyA9IC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi8gKGluc3RydWN0aW9uWzExXSk7XG4gICAgICAgICAgdmFyIHJvdGF0aW9uID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblsxMl0pO1xuICAgICAgICAgIHZhciBzY2FsZSA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bMTNdKTtcbiAgICAgICAgICB2YXIgd2lkdGggPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzE0XSk7XG5cbiAgICAgICAgICB2YXIgcGFkZGluZyA9ICh2b2lkIDApLCBiYWNrZ3JvdW5kRmlsbCA9ICh2b2lkIDApLCBiYWNrZ3JvdW5kU3Ryb2tlID0gKHZvaWQgMCk7XG4gICAgICAgICAgaWYgKGluc3RydWN0aW9uLmxlbmd0aCA+IDE2KSB7XG4gICAgICAgICAgICBwYWRkaW5nID0gLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqLyAoaW5zdHJ1Y3Rpb25bMTVdKTtcbiAgICAgICAgICAgIGJhY2tncm91bmRGaWxsID0gLyoqIEB0eXBlIHtib29sZWFufSAqLyAoaW5zdHJ1Y3Rpb25bMTZdKTtcbiAgICAgICAgICAgIGJhY2tncm91bmRTdHJva2UgPSAvKiogQHR5cGUge2Jvb2xlYW59ICovIChpbnN0cnVjdGlvblsxN10pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYWRkaW5nID0gZGVmYXVsdFBhZGRpbmc7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kRmlsbCA9IGJhY2tncm91bmRTdHJva2UgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocm90YXRlV2l0aFZpZXcpIHtcbiAgICAgICAgICAgIHJvdGF0aW9uICs9IHZpZXdSb3RhdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICg7IGQgPCBkZDsgZCArPSAyKSB7XG4gICAgICAgICAgICB0aGlzLnJlcGxheUltYWdlXyhjb250ZXh0LFxuICAgICAgICAgICAgICBwaXhlbENvb3JkaW5hdGVzW2RdLCBwaXhlbENvb3JkaW5hdGVzW2QgKyAxXSwgaW1hZ2UsIGFuY2hvclgsIGFuY2hvclksXG4gICAgICAgICAgICAgIGRlY2x1dHRlckdyb3VwLCBoZWlnaHQsIG9wYWNpdHksIG9yaWdpblgsIG9yaWdpblksIHJvdGF0aW9uLCBzY2FsZSxcbiAgICAgICAgICAgICAgc25hcFRvUGl4ZWwsIHdpZHRoLCBwYWRkaW5nLFxuICAgICAgICAgICAgICBiYWNrZ3JvdW5kRmlsbCA/IC8qKiBAdHlwZSB7QXJyYXk8Kj59ICovIChsYXN0RmlsbEluc3RydWN0aW9uKSA6IG51bGwsXG4gICAgICAgICAgICAgIGJhY2tncm91bmRTdHJva2UgPyAvKiogQHR5cGUge0FycmF5PCo+fSAqLyAobGFzdFN0cm9rZUluc3RydWN0aW9uKSA6IG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnJlbmRlckRlY2x1dHRlcl8oZGVjbHV0dGVyR3JvdXAsIGZlYXR1cmUpO1xuICAgICAgICAgICsraTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDYW52YXNJbnN0cnVjdGlvbi5EUkFXX0NIQVJTOlxuICAgICAgICAgIHZhciBiZWdpbiA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bMV0pO1xuICAgICAgICAgIHZhciBlbmQgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzJdKTtcbiAgICAgICAgICB2YXIgYmFzZWxpbmUgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzNdKTtcbiAgICAgICAgICBkZWNsdXR0ZXJHcm91cCA9IGZlYXR1cmVDYWxsYmFjayA/IG51bGwgOiAvKiogQHR5cGUge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5EZWNsdXR0ZXJHcm91cH0gKi8gKGluc3RydWN0aW9uWzRdKTtcbiAgICAgICAgICB2YXIgb3ZlcmZsb3cgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzVdKTtcbiAgICAgICAgICB2YXIgZmlsbEtleSA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoaW5zdHJ1Y3Rpb25bNl0pO1xuICAgICAgICAgIHZhciBtYXhBbmdsZSA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bN10pO1xuICAgICAgICAgIHZhciBtZWFzdXJlID0gLyoqIEB0eXBlIHtmdW5jdGlvbihzdHJpbmcpOm51bWJlcn0gKi8gKGluc3RydWN0aW9uWzhdKTtcbiAgICAgICAgICB2YXIgb2Zmc2V0WSA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bOV0pO1xuICAgICAgICAgIHZhciBzdHJva2VLZXkgPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKGluc3RydWN0aW9uWzEwXSk7XG4gICAgICAgICAgdmFyIHN0cm9rZVdpZHRoID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblsxMV0pO1xuICAgICAgICAgIHZhciB0ZXh0ID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChpbnN0cnVjdGlvblsxMl0pO1xuICAgICAgICAgIHZhciB0ZXh0S2V5ID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChpbnN0cnVjdGlvblsxM10pO1xuICAgICAgICAgIHZhciB0ZXh0U2NhbGUgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzE0XSk7XG5cbiAgICAgICAgICB2YXIgcGF0aExlbmd0aCA9IGxpbmVTdHJpbmdMZW5ndGgocGl4ZWxDb29yZGluYXRlcywgYmVnaW4sIGVuZCwgMik7XG4gICAgICAgICAgdmFyIHRleHRMZW5ndGggPSBtZWFzdXJlKHRleHQpO1xuICAgICAgICAgIGlmIChvdmVyZmxvdyB8fCB0ZXh0TGVuZ3RoIDw9IHBhdGhMZW5ndGgpIHtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9UZXh0UmVwbGF5LmpzXCIpLmRlZmF1bHR9ICovXG4gICAgICAgICAgICB2YXIgdGV4dFJlcGxheSA9IC8qKiBAdHlwZSB7P30gKi8gKHRoaXMpO1xuICAgICAgICAgICAgdmFyIHRleHRBbGlnbiA9IHRleHRSZXBsYXkudGV4dFN0YXRlc1t0ZXh0S2V5XS50ZXh0QWxpZ247XG4gICAgICAgICAgICB2YXIgc3RhcnRNID0gKHBhdGhMZW5ndGggLSB0ZXh0TGVuZ3RoKSAqIFRFWFRfQUxJR05bdGV4dEFsaWduXTtcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IGRyYXdUZXh0T25QYXRoKFxuICAgICAgICAgICAgICBwaXhlbENvb3JkaW5hdGVzLCBiZWdpbiwgZW5kLCAyLCB0ZXh0LCBtZWFzdXJlLCBzdGFydE0sIG1heEFuZ2xlKTtcbiAgICAgICAgICAgIGlmIChwYXJ0cykge1xuICAgICAgICAgICAgICB2YXIgYyA9ICh2b2lkIDApLCBjYyA9ICh2b2lkIDApLCBjaGFycyA9ICh2b2lkIDApLCBsYWJlbCA9ICh2b2lkIDApLCBwYXJ0ID0gKHZvaWQgMCk7XG4gICAgICAgICAgICAgIGlmIChzdHJva2VLZXkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGMgPSAwLCBjYyA9IHBhcnRzLmxlbmd0aDsgYyA8IGNjOyArK2MpIHtcbiAgICAgICAgICAgICAgICAgIHBhcnQgPSBwYXJ0c1tjXTsgLy8geCwgeSwgYW5jaG9yWCwgcm90YXRpb24sIGNodW5rXG4gICAgICAgICAgICAgICAgICBjaGFycyA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAocGFydFs0XSk7XG4gICAgICAgICAgICAgICAgICBsYWJlbCA9IHRleHRSZXBsYXkuZ2V0SW1hZ2UoY2hhcnMsIHRleHRLZXksICcnLCBzdHJva2VLZXkpO1xuICAgICAgICAgICAgICAgICAgYW5jaG9yWCA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAocGFydFsyXSkgKyBzdHJva2VXaWR0aDtcbiAgICAgICAgICAgICAgICAgIGFuY2hvclkgPSBiYXNlbGluZSAqIGxhYmVsLmhlaWdodCArICgwLjUgLSBiYXNlbGluZSkgKiAyICogc3Ryb2tlV2lkdGggLSBvZmZzZXRZO1xuICAgICAgICAgICAgICAgICAgdGhpcy5yZXBsYXlJbWFnZV8oY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovIChwYXJ0WzBdKSwgLyoqIEB0eXBlIHtudW1iZXJ9ICovIChwYXJ0WzFdKSwgbGFiZWwsXG4gICAgICAgICAgICAgICAgICAgIGFuY2hvclgsIGFuY2hvclksIGRlY2x1dHRlckdyb3VwLCBsYWJlbC5oZWlnaHQsIDEsIDAsIDAsXG4gICAgICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAocGFydFszXSksIHRleHRTY2FsZSwgZmFsc2UsIGxhYmVsLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0UGFkZGluZywgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChmaWxsS2V5KSB7XG4gICAgICAgICAgICAgICAgZm9yIChjID0gMCwgY2MgPSBwYXJ0cy5sZW5ndGg7IGMgPCBjYzsgKytjKSB7XG4gICAgICAgICAgICAgICAgICBwYXJ0ID0gcGFydHNbY107IC8vIHgsIHksIGFuY2hvclgsIHJvdGF0aW9uLCBjaHVua1xuICAgICAgICAgICAgICAgICAgY2hhcnMgPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKHBhcnRbNF0pO1xuICAgICAgICAgICAgICAgICAgbGFiZWwgPSB0ZXh0UmVwbGF5LmdldEltYWdlKGNoYXJzLCB0ZXh0S2V5LCBmaWxsS2V5LCAnJyk7XG4gICAgICAgICAgICAgICAgICBhbmNob3JYID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChwYXJ0WzJdKTtcbiAgICAgICAgICAgICAgICAgIGFuY2hvclkgPSBiYXNlbGluZSAqIGxhYmVsLmhlaWdodCAtIG9mZnNldFk7XG4gICAgICAgICAgICAgICAgICB0aGlzLnJlcGxheUltYWdlXyhjb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi8gKHBhcnRbMF0pLCAvKiogQHR5cGUge251bWJlcn0gKi8gKHBhcnRbMV0pLCBsYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgYW5jaG9yWCwgYW5jaG9yWSwgZGVjbHV0dGVyR3JvdXAsIGxhYmVsLmhlaWdodCwgMSwgMCwgMCxcbiAgICAgICAgICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovIChwYXJ0WzNdKSwgdGV4dFNjYWxlLCBmYWxzZSwgbGFiZWwud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRQYWRkaW5nLCBudWxsLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5yZW5kZXJEZWNsdXR0ZXJfKGRlY2x1dHRlckdyb3VwLCBmZWF0dXJlKTtcbiAgICAgICAgICArK2k7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ2FudmFzSW5zdHJ1Y3Rpb24uRU5EX0dFT01FVFJZOlxuICAgICAgICAgIGlmIChmZWF0dXJlQ2FsbGJhY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZmVhdHVyZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gKi8gKGluc3RydWN0aW9uWzFdKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBmZWF0dXJlQ2FsbGJhY2soZmVhdHVyZSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgICsraTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDYW52YXNJbnN0cnVjdGlvbi5GSUxMOlxuICAgICAgICAgIGlmIChiYXRjaFNpemUpIHtcbiAgICAgICAgICAgIHBlbmRpbmdGaWxsKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmlsbF8oY29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgICsraTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDYW52YXNJbnN0cnVjdGlvbi5NT1ZFX1RPX0xJTkVfVE86XG4gICAgICAgICAgZCA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bMV0pO1xuICAgICAgICAgIGRkID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblsyXSk7XG4gICAgICAgICAgeCA9IHBpeGVsQ29vcmRpbmF0ZXNbZF07XG4gICAgICAgICAgeSA9IHBpeGVsQ29vcmRpbmF0ZXNbZCArIDFdO1xuICAgICAgICAgIHJvdW5kWCA9ICh4ICsgMC41KSB8IDA7XG4gICAgICAgICAgcm91bmRZID0gKHkgKyAwLjUpIHwgMDtcbiAgICAgICAgICBpZiAocm91bmRYICE9PSBwcmV2WCB8fCByb3VuZFkgIT09IHByZXZZKSB7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh4LCB5KTtcbiAgICAgICAgICAgIHByZXZYID0gcm91bmRYO1xuICAgICAgICAgICAgcHJldlkgPSByb3VuZFk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoZCArPSAyOyBkIDwgZGQ7IGQgKz0gMikge1xuICAgICAgICAgICAgeCA9IHBpeGVsQ29vcmRpbmF0ZXNbZF07XG4gICAgICAgICAgICB5ID0gcGl4ZWxDb29yZGluYXRlc1tkICsgMV07XG4gICAgICAgICAgICByb3VuZFggPSAoeCArIDAuNSkgfCAwO1xuICAgICAgICAgICAgcm91bmRZID0gKHkgKyAwLjUpIHwgMDtcbiAgICAgICAgICAgIGlmIChkID09IGRkIC0gMiB8fCByb3VuZFggIT09IHByZXZYIHx8IHJvdW5kWSAhPT0gcHJldlkpIHtcbiAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgIHByZXZYID0gcm91bmRYO1xuICAgICAgICAgICAgICBwcmV2WSA9IHJvdW5kWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgKytpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENhbnZhc0luc3RydWN0aW9uLlNFVF9GSUxMX1NUWUxFOlxuICAgICAgICAgIGxhc3RGaWxsSW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbjtcbiAgICAgICAgICB0aGlzLmFsaWduRmlsbF8gPSBpbnN0cnVjdGlvblsyXTtcblxuICAgICAgICAgIGlmIChwZW5kaW5nRmlsbCkge1xuICAgICAgICAgICAgdGhpcy5maWxsXyhjb250ZXh0KTtcbiAgICAgICAgICAgIHBlbmRpbmdGaWxsID0gMDtcbiAgICAgICAgICAgIGlmIChwZW5kaW5nU3Ryb2tlKSB7XG4gICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgICAgICAgIHBlbmRpbmdTdHJva2UgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfSAqLyAoaW5zdHJ1Y3Rpb25bMV0pO1xuICAgICAgICAgICsraTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDYW52YXNJbnN0cnVjdGlvbi5TRVRfU1RST0tFX1NUWUxFOlxuICAgICAgICAgIGxhc3RTdHJva2VJbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uO1xuICAgICAgICAgIGlmIChwZW5kaW5nU3Ryb2tlKSB7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICAgICAgcGVuZGluZ1N0cm9rZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc2V0U3Ryb2tlU3R5bGVfKGNvbnRleHQsIC8qKiBAdHlwZSB7QXJyYXk8Kj59ICovIChpbnN0cnVjdGlvbikpO1xuICAgICAgICAgICsraTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDYW52YXNJbnN0cnVjdGlvbi5TVFJPS0U6XG4gICAgICAgICAgaWYgKGJhdGNoU2l6ZSkge1xuICAgICAgICAgICAgcGVuZGluZ1N0cm9rZSsrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICArK2k7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgKytpOyAvLyBjb25zdW1lIHRoZSBpbnN0cnVjdGlvbiBhbnl3YXksIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBlbmRpbmdGaWxsKSB7XG4gICAgICB0aGlzLmZpbGxfKGNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAocGVuZGluZ1N0cm9rZSkge1xuICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfSB0cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmlld1JvdGF0aW9uIFZpZXcgcm90YXRpb24uXG4gICAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgYm9vbGVhbj59IHNraXBwZWRGZWF0dXJlc0hhc2ggSWRzIG9mIGZlYXR1cmVzXG4gICAqICAgICB0byBza2lwLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNuYXBUb1BpeGVsIFNuYXAgcG9pbnQgc3ltYm9scyBhbmQgdGV4dCB0byBpbnRlZ2VyIHBpeGVscy5cbiAgICovXG4gIENhbnZhc1JlcGxheS5wcm90b3R5cGUucmVwbGF5ID0gZnVuY3Rpb24gcmVwbGF5IChjb250ZXh0LCB0cmFuc2Zvcm0sIHZpZXdSb3RhdGlvbiwgc2tpcHBlZEZlYXR1cmVzSGFzaCwgc25hcFRvUGl4ZWwpIHtcbiAgICB0aGlzLnZpZXdSb3RhdGlvbl8gPSB2aWV3Um90YXRpb247XG4gICAgdGhpcy5yZXBsYXlfKGNvbnRleHQsIHRyYW5zZm9ybSxcbiAgICAgIHNraXBwZWRGZWF0dXJlc0hhc2gsIHRoaXMuaW5zdHJ1Y3Rpb25zLCBzbmFwVG9QaXhlbCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBDb250ZXh0LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19IHRyYW5zZm9ybSBUcmFuc2Zvcm0uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2aWV3Um90YXRpb24gVmlldyByb3RhdGlvbi5cbiAgICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBib29sZWFuPn0gc2tpcHBlZEZlYXR1cmVzSGFzaCBJZHMgb2YgZmVhdHVyZXNcbiAgICogICAgIHRvIHNraXAuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKGltcG9ydChcIi4uLy4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQpKTogVD19IG9wdF9mZWF0dXJlQ2FsbGJhY2tcbiAgICogICAgIEZlYXR1cmUgY2FsbGJhY2suXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudD19IG9wdF9oaXRFeHRlbnQgT25seSBjaGVjayBmZWF0dXJlcyB0aGF0IGludGVyc2VjdCB0aGlzXG4gICAqICAgICBleHRlbnQuXG4gICAqIEByZXR1cm4ge1R8dW5kZWZpbmVkfSBDYWxsYmFjayByZXN1bHQuXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqL1xuICBDYW52YXNSZXBsYXkucHJvdG90eXBlLnJlcGxheUhpdERldGVjdGlvbiA9IGZ1bmN0aW9uIHJlcGxheUhpdERldGVjdGlvbiAoXG4gICAgY29udGV4dCxcbiAgICB0cmFuc2Zvcm0sXG4gICAgdmlld1JvdGF0aW9uLFxuICAgIHNraXBwZWRGZWF0dXJlc0hhc2gsXG4gICAgb3B0X2ZlYXR1cmVDYWxsYmFjayxcbiAgICBvcHRfaGl0RXh0ZW50XG4gICkge1xuICAgIHRoaXMudmlld1JvdGF0aW9uXyA9IHZpZXdSb3RhdGlvbjtcbiAgICByZXR1cm4gdGhpcy5yZXBsYXlfKGNvbnRleHQsIHRyYW5zZm9ybSwgc2tpcHBlZEZlYXR1cmVzSGFzaCxcbiAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLCB0cnVlLCBvcHRfZmVhdHVyZUNhbGxiYWNrLCBvcHRfaGl0RXh0ZW50KTtcbiAgfTtcblxuICAvKipcbiAgICogUmV2ZXJzZSB0aGUgaGl0IGRldGVjdGlvbiBpbnN0cnVjdGlvbnMuXG4gICAqL1xuICBDYW52YXNSZXBsYXkucHJvdG90eXBlLnJldmVyc2VIaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMgPSBmdW5jdGlvbiByZXZlcnNlSGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zICgpIHtcbiAgICB2YXIgaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zID0gdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnM7XG4gICAgLy8gc3RlcCAxIC0gcmV2ZXJzZSBhcnJheVxuICAgIGhpdERldGVjdGlvbkluc3RydWN0aW9ucy5yZXZlcnNlKCk7XG4gICAgLy8gc3RlcCAyIC0gcmV2ZXJzZSBpbnN0cnVjdGlvbnMgd2l0aGluIGdlb21ldHJ5IGJsb2Nrc1xuICAgIHZhciBpO1xuICAgIHZhciBuID0gaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLmxlbmd0aDtcbiAgICB2YXIgaW5zdHJ1Y3Rpb247XG4gICAgdmFyIHR5cGU7XG4gICAgdmFyIGJlZ2luID0gLTE7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaW5zdHJ1Y3Rpb24gPSBoaXREZXRlY3Rpb25JbnN0cnVjdGlvbnNbaV07XG4gICAgICB0eXBlID0gLyoqIEB0eXBlIHtDYW52YXNJbnN0cnVjdGlvbn0gKi8gKGluc3RydWN0aW9uWzBdKTtcbiAgICAgIGlmICh0eXBlID09IENhbnZhc0luc3RydWN0aW9uLkVORF9HRU9NRVRSWSkge1xuICAgICAgICBiZWdpbiA9IGk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gQ2FudmFzSW5zdHJ1Y3Rpb24uQkVHSU5fR0VPTUVUUlkpIHtcbiAgICAgICAgaW5zdHJ1Y3Rpb25bMl0gPSBpO1xuICAgICAgICByZXZlcnNlU3ViQXJyYXkodGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMsIGJlZ2luLCBpKTtcbiAgICAgICAgYmVnaW4gPSAtMTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNSZXBsYXkucHJvdG90eXBlLnNldEZpbGxTdHJva2VTdHlsZSA9IGZ1bmN0aW9uIHNldEZpbGxTdHJva2VTdHlsZSAoZmlsbFN0eWxlLCBzdHJva2VTdHlsZSkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKGZpbGxTdHlsZSkge1xuICAgICAgdmFyIGZpbGxTdHlsZUNvbG9yID0gZmlsbFN0eWxlLmdldENvbG9yKCk7XG4gICAgICBzdGF0ZS5maWxsU3R5bGUgPSBhc0NvbG9yTGlrZShmaWxsU3R5bGVDb2xvciA/XG4gICAgICAgIGZpbGxTdHlsZUNvbG9yIDogZGVmYXVsdEZpbGxTdHlsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmZpbGxTdHlsZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHN0cm9rZVN0eWxlKSB7XG4gICAgICB2YXIgc3Ryb2tlU3R5bGVDb2xvciA9IHN0cm9rZVN0eWxlLmdldENvbG9yKCk7XG4gICAgICBzdGF0ZS5zdHJva2VTdHlsZSA9IGFzQ29sb3JMaWtlKHN0cm9rZVN0eWxlQ29sb3IgP1xuICAgICAgICBzdHJva2VTdHlsZUNvbG9yIDogZGVmYXVsdFN0cm9rZVN0eWxlKTtcbiAgICAgIHZhciBzdHJva2VTdHlsZUxpbmVDYXAgPSBzdHJva2VTdHlsZS5nZXRMaW5lQ2FwKCk7XG4gICAgICBzdGF0ZS5saW5lQ2FwID0gc3Ryb2tlU3R5bGVMaW5lQ2FwICE9PSB1bmRlZmluZWQgP1xuICAgICAgICBzdHJva2VTdHlsZUxpbmVDYXAgOiBkZWZhdWx0TGluZUNhcDtcbiAgICAgIHZhciBzdHJva2VTdHlsZUxpbmVEYXNoID0gc3Ryb2tlU3R5bGUuZ2V0TGluZURhc2goKTtcbiAgICAgIHN0YXRlLmxpbmVEYXNoID0gc3Ryb2tlU3R5bGVMaW5lRGFzaCA/XG4gICAgICAgIHN0cm9rZVN0eWxlTGluZURhc2guc2xpY2UoKSA6IGRlZmF1bHRMaW5lRGFzaDtcbiAgICAgIHZhciBzdHJva2VTdHlsZUxpbmVEYXNoT2Zmc2V0ID0gc3Ryb2tlU3R5bGUuZ2V0TGluZURhc2hPZmZzZXQoKTtcbiAgICAgIHN0YXRlLmxpbmVEYXNoT2Zmc2V0ID0gc3Ryb2tlU3R5bGVMaW5lRGFzaE9mZnNldCA/XG4gICAgICAgIHN0cm9rZVN0eWxlTGluZURhc2hPZmZzZXQgOiBkZWZhdWx0TGluZURhc2hPZmZzZXQ7XG4gICAgICB2YXIgc3Ryb2tlU3R5bGVMaW5lSm9pbiA9IHN0cm9rZVN0eWxlLmdldExpbmVKb2luKCk7XG4gICAgICBzdGF0ZS5saW5lSm9pbiA9IHN0cm9rZVN0eWxlTGluZUpvaW4gIT09IHVuZGVmaW5lZCA/XG4gICAgICAgIHN0cm9rZVN0eWxlTGluZUpvaW4gOiBkZWZhdWx0TGluZUpvaW47XG4gICAgICB2YXIgc3Ryb2tlU3R5bGVXaWR0aCA9IHN0cm9rZVN0eWxlLmdldFdpZHRoKCk7XG4gICAgICBzdGF0ZS5saW5lV2lkdGggPSBzdHJva2VTdHlsZVdpZHRoICE9PSB1bmRlZmluZWQgP1xuICAgICAgICBzdHJva2VTdHlsZVdpZHRoIDogZGVmYXVsdExpbmVXaWR0aDtcbiAgICAgIHZhciBzdHJva2VTdHlsZU1pdGVyTGltaXQgPSBzdHJva2VTdHlsZS5nZXRNaXRlckxpbWl0KCk7XG4gICAgICBzdGF0ZS5taXRlckxpbWl0ID0gc3Ryb2tlU3R5bGVNaXRlckxpbWl0ICE9PSB1bmRlZmluZWQgP1xuICAgICAgICBzdHJva2VTdHlsZU1pdGVyTGltaXQgOiBkZWZhdWx0TWl0ZXJMaW1pdDtcblxuICAgICAgaWYgKHN0YXRlLmxpbmVXaWR0aCA+IHRoaXMubWF4TGluZVdpZHRoKSB7XG4gICAgICAgIHRoaXMubWF4TGluZVdpZHRoID0gc3RhdGUubGluZVdpZHRoO1xuICAgICAgICAvLyBpbnZhbGlkYXRlIHRoZSBidWZmZXJlZCBtYXggZXh0ZW50IGNhY2hlXG4gICAgICAgIHRoaXMuYnVmZmVyZWRNYXhFeHRlbnRfID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuc3Ryb2tlU3R5bGUgPSB1bmRlZmluZWQ7XG4gICAgICBzdGF0ZS5saW5lQ2FwID0gdW5kZWZpbmVkO1xuICAgICAgc3RhdGUubGluZURhc2ggPSBudWxsO1xuICAgICAgc3RhdGUubGluZURhc2hPZmZzZXQgPSB1bmRlZmluZWQ7XG4gICAgICBzdGF0ZS5saW5lSm9pbiA9IHVuZGVmaW5lZDtcbiAgICAgIHN0YXRlLmxpbmVXaWR0aCA9IHVuZGVmaW5lZDtcbiAgICAgIHN0YXRlLm1pdGVyTGltaXQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5GaWxsU3Ryb2tlU3RhdGV9IHN0YXRlIFN0YXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKiBAcmV0dXJuIHtBcnJheTwqPn0gRmlsbCBpbnN0cnVjdGlvbi5cbiAgICovXG4gIENhbnZhc1JlcGxheS5wcm90b3R5cGUuY3JlYXRlRmlsbCA9IGZ1bmN0aW9uIGNyZWF0ZUZpbGwgKHN0YXRlLCBnZW9tZXRyeSkge1xuICAgIHZhciBmaWxsU3R5bGUgPSBzdGF0ZS5maWxsU3R5bGU7XG4gICAgLyoqIEB0eXBlIHtBcnJheTwqPn0gKi9cbiAgICB2YXIgZmlsbEluc3RydWN0aW9uID0gW0NhbnZhc0luc3RydWN0aW9uLlNFVF9GSUxMX1NUWUxFLCBmaWxsU3R5bGVdO1xuICAgIGlmICh0eXBlb2YgZmlsbFN0eWxlICE9PSAnc3RyaW5nJykge1xuICAgICAgLy8gRmlsbCBpcyBhIHBhdHRlcm4gb3IgZ3JhZGllbnQgLSBhbGlnbiBpdCFcbiAgICAgIGZpbGxJbnN0cnVjdGlvbi5wdXNoKHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gZmlsbEluc3RydWN0aW9uO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5GaWxsU3Ryb2tlU3RhdGV9IHN0YXRlIFN0YXRlLlxuICAgKi9cbiAgQ2FudmFzUmVwbGF5LnByb3RvdHlwZS5hcHBseVN0cm9rZSA9IGZ1bmN0aW9uIGFwcGx5U3Ryb2tlIChzdGF0ZSkge1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2godGhpcy5jcmVhdGVTdHJva2Uoc3RhdGUpKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRmlsbFN0cm9rZVN0YXRlfSBzdGF0ZSBTdGF0ZS5cbiAgICogQHJldHVybiB7QXJyYXk8Kj59IFN0cm9rZSBpbnN0cnVjdGlvbi5cbiAgICovXG4gIENhbnZhc1JlcGxheS5wcm90b3R5cGUuY3JlYXRlU3Ryb2tlID0gZnVuY3Rpb24gY3JlYXRlU3Ryb2tlIChzdGF0ZSkge1xuICAgIHJldHVybiBbXG4gICAgICBDYW52YXNJbnN0cnVjdGlvbi5TRVRfU1RST0tFX1NUWUxFLFxuICAgICAgc3RhdGUuc3Ryb2tlU3R5bGUsIHN0YXRlLmxpbmVXaWR0aCAqIHRoaXMucGl4ZWxSYXRpbywgc3RhdGUubGluZUNhcCxcbiAgICAgIHN0YXRlLmxpbmVKb2luLCBzdGF0ZS5taXRlckxpbWl0LFxuICAgICAgdGhpcy5hcHBseVBpeGVsUmF0aW8oc3RhdGUubGluZURhc2gpLCBzdGF0ZS5saW5lRGFzaE9mZnNldCAqIHRoaXMucGl4ZWxSYXRpb1xuICAgIF07XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkZpbGxTdHJva2VTdGF0ZX0gc3RhdGUgU3RhdGUuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczpDYW52YXNSZXBsYXksIGltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5GaWxsU3Ryb2tlU3RhdGUsIChpbXBvcnQoXCIuLi8uLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0KSk6QXJyYXk8Kj59IGNyZWF0ZUZpbGwgQ3JlYXRlIGZpbGwuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gICAqL1xuICBDYW52YXNSZXBsYXkucHJvdG90eXBlLnVwZGF0ZUZpbGxTdHlsZSA9IGZ1bmN0aW9uIHVwZGF0ZUZpbGxTdHlsZSAoc3RhdGUsIGNyZWF0ZUZpbGwsIGdlb21ldHJ5KSB7XG4gICAgdmFyIGZpbGxTdHlsZSA9IHN0YXRlLmZpbGxTdHlsZTtcbiAgICBpZiAodHlwZW9mIGZpbGxTdHlsZSAhPT0gJ3N0cmluZycgfHwgc3RhdGUuY3VycmVudEZpbGxTdHlsZSAhPSBmaWxsU3R5bGUpIHtcbiAgICAgIGlmIChmaWxsU3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKGNyZWF0ZUZpbGwuY2FsbCh0aGlzLCBzdGF0ZSwgZ2VvbWV0cnkpKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLmN1cnJlbnRGaWxsU3R5bGUgPSBmaWxsU3R5bGU7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5GaWxsU3Ryb2tlU3RhdGV9IHN0YXRlIFN0YXRlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6Q2FudmFzUmVwbGF5LCBpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRmlsbFN0cm9rZVN0YXRlKX0gYXBwbHlTdHJva2UgQXBwbHkgc3Ryb2tlLlxuICAgKi9cbiAgQ2FudmFzUmVwbGF5LnByb3RvdHlwZS51cGRhdGVTdHJva2VTdHlsZSA9IGZ1bmN0aW9uIHVwZGF0ZVN0cm9rZVN0eWxlIChzdGF0ZSwgYXBwbHlTdHJva2UpIHtcbiAgICB2YXIgc3Ryb2tlU3R5bGUgPSBzdGF0ZS5zdHJva2VTdHlsZTtcbiAgICB2YXIgbGluZUNhcCA9IHN0YXRlLmxpbmVDYXA7XG4gICAgdmFyIGxpbmVEYXNoID0gc3RhdGUubGluZURhc2g7XG4gICAgdmFyIGxpbmVEYXNoT2Zmc2V0ID0gc3RhdGUubGluZURhc2hPZmZzZXQ7XG4gICAgdmFyIGxpbmVKb2luID0gc3RhdGUubGluZUpvaW47XG4gICAgdmFyIGxpbmVXaWR0aCA9IHN0YXRlLmxpbmVXaWR0aDtcbiAgICB2YXIgbWl0ZXJMaW1pdCA9IHN0YXRlLm1pdGVyTGltaXQ7XG4gICAgaWYgKHN0YXRlLmN1cnJlbnRTdHJva2VTdHlsZSAhPSBzdHJva2VTdHlsZSB8fFxuICAgICAgICBzdGF0ZS5jdXJyZW50TGluZUNhcCAhPSBsaW5lQ2FwIHx8XG4gICAgICAgIChsaW5lRGFzaCAhPSBzdGF0ZS5jdXJyZW50TGluZURhc2ggJiYgIWVxdWFscyhzdGF0ZS5jdXJyZW50TGluZURhc2gsIGxpbmVEYXNoKSkgfHxcbiAgICAgICAgc3RhdGUuY3VycmVudExpbmVEYXNoT2Zmc2V0ICE9IGxpbmVEYXNoT2Zmc2V0IHx8XG4gICAgICAgIHN0YXRlLmN1cnJlbnRMaW5lSm9pbiAhPSBsaW5lSm9pbiB8fFxuICAgICAgICBzdGF0ZS5jdXJyZW50TGluZVdpZHRoICE9IGxpbmVXaWR0aCB8fFxuICAgICAgICBzdGF0ZS5jdXJyZW50TWl0ZXJMaW1pdCAhPSBtaXRlckxpbWl0KSB7XG4gICAgICBpZiAoc3Ryb2tlU3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhcHBseVN0cm9rZS5jYWxsKHRoaXMsIHN0YXRlKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLmN1cnJlbnRTdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICAgICAgc3RhdGUuY3VycmVudExpbmVDYXAgPSBsaW5lQ2FwO1xuICAgICAgc3RhdGUuY3VycmVudExpbmVEYXNoID0gbGluZURhc2g7XG4gICAgICBzdGF0ZS5jdXJyZW50TGluZURhc2hPZmZzZXQgPSBsaW5lRGFzaE9mZnNldDtcbiAgICAgIHN0YXRlLmN1cnJlbnRMaW5lSm9pbiA9IGxpbmVKb2luO1xuICAgICAgc3RhdGUuY3VycmVudExpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgIHN0YXRlLmN1cnJlbnRNaXRlckxpbWl0ID0gbWl0ZXJMaW1pdDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKi9cbiAgQ2FudmFzUmVwbGF5LnByb3RvdHlwZS5lbmRHZW9tZXRyeSA9IGZ1bmN0aW9uIGVuZEdlb21ldHJ5IChnZW9tZXRyeSwgZmVhdHVyZSkge1xuICAgIHRoaXMuYmVnaW5HZW9tZXRyeUluc3RydWN0aW9uMV9bMl0gPSB0aGlzLmluc3RydWN0aW9ucy5sZW5ndGg7XG4gICAgdGhpcy5iZWdpbkdlb21ldHJ5SW5zdHJ1Y3Rpb24xXyA9IG51bGw7XG4gICAgdGhpcy5iZWdpbkdlb21ldHJ5SW5zdHJ1Y3Rpb24yX1syXSA9IHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLmxlbmd0aDtcbiAgICB0aGlzLmJlZ2luR2VvbWV0cnlJbnN0cnVjdGlvbjJfID0gbnVsbDtcbiAgICB2YXIgZW5kR2VvbWV0cnlJbnN0cnVjdGlvbiA9IFtDYW52YXNJbnN0cnVjdGlvbi5FTkRfR0VPTUVUUlksIGZlYXR1cmVdO1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goZW5kR2VvbWV0cnlJbnN0cnVjdGlvbik7XG4gICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChlbmRHZW9tZXRyeUluc3RydWN0aW9uKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBidWZmZXJlZCByZW5kZXJpbmcgZXh0ZW50LiAgUmVuZGVyaW5nIHdpbGwgYmUgY2xpcHBlZCB0byB0aGUgZXh0ZW50XG4gICAqIHByb3ZpZGVkIHRvIHRoZSBjb25zdHJ1Y3Rvci4gIFRvIGFjY291bnQgZm9yIHN5bWJvbGl6ZXJzIHRoYXQgbWF5IGludGVyc2VjdFxuICAgKiB0aGlzIGV4dGVudCwgd2UgY2FsY3VsYXRlIGEgYnVmZmVyZWQgZXh0ZW50IChlLmcuIGJhc2VkIG9uIHN0cm9rZSB3aWR0aCkuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IFRoZSBidWZmZXJlZCByZW5kZXJpbmcgZXh0ZW50LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBDYW52YXNSZXBsYXkucHJvdG90eXBlLmdldEJ1ZmZlcmVkTWF4RXh0ZW50ID0gZnVuY3Rpb24gZ2V0QnVmZmVyZWRNYXhFeHRlbnQgKCkge1xuICAgIGlmICghdGhpcy5idWZmZXJlZE1heEV4dGVudF8pIHtcbiAgICAgIHRoaXMuYnVmZmVyZWRNYXhFeHRlbnRfID0gY2xvbmUodGhpcy5tYXhFeHRlbnQpO1xuICAgICAgaWYgKHRoaXMubWF4TGluZVdpZHRoID4gMCkge1xuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLnJlc29sdXRpb24gKiAodGhpcy5tYXhMaW5lV2lkdGggKyAxKSAvIDI7XG4gICAgICAgIGJ1ZmZlcih0aGlzLmJ1ZmZlcmVkTWF4RXh0ZW50Xywgd2lkdGgsIHRoaXMuYnVmZmVyZWRNYXhFeHRlbnRfKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyZWRNYXhFeHRlbnRfO1xuICB9O1xuXG4gIHJldHVybiBDYW52YXNSZXBsYXk7XG59KFZlY3RvckNvbnRleHQpKTtcblxuXG5leHBvcnQgZGVmYXVsdCBDYW52YXNSZXBsYXk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlcGxheS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyL2NhbnZhcy9SZXBsYXlHcm91cFxuICovXG5cbmltcG9ydCB7bnVtYmVyU2FmZUNvbXBhcmVGdW5jdGlvbn0gZnJvbSAnLi4vLi4vYXJyYXkuanMnO1xuaW1wb3J0IHtjcmVhdGVDYW52YXNDb250ZXh0MkR9IGZyb20gJy4uLy4uL2RvbS5qcyc7XG5pbXBvcnQge2J1ZmZlciwgY3JlYXRlRW1wdHksIGV4dGVuZENvb3JkaW5hdGV9IGZyb20gJy4uLy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge3RyYW5zZm9ybTJEfSBmcm9tICcuLi8uLi9nZW9tL2ZsYXQvdHJhbnNmb3JtLmpzJztcbmltcG9ydCB7aXNFbXB0eX0gZnJvbSAnLi4vLi4vb2JqLmpzJztcbmltcG9ydCBSZXBsYXlHcm91cCBmcm9tICcuLi9SZXBsYXlHcm91cC5qcyc7XG5pbXBvcnQgUmVwbGF5VHlwZSBmcm9tICcuLi9SZXBsYXlUeXBlLmpzJztcbmltcG9ydCBDYW52YXNSZXBsYXkgZnJvbSAnLi9SZXBsYXkuanMnO1xuaW1wb3J0IENhbnZhc0ltYWdlUmVwbGF5IGZyb20gJy4vSW1hZ2VSZXBsYXkuanMnO1xuaW1wb3J0IENhbnZhc0xpbmVTdHJpbmdSZXBsYXkgZnJvbSAnLi9MaW5lU3RyaW5nUmVwbGF5LmpzJztcbmltcG9ydCBDYW52YXNQb2x5Z29uUmVwbGF5IGZyb20gJy4vUG9seWdvblJlcGxheS5qcyc7XG5pbXBvcnQgQ2FudmFzVGV4dFJlcGxheSBmcm9tICcuL1RleHRSZXBsYXkuanMnO1xuaW1wb3J0IHtPUkRFUn0gZnJvbSAnLi4vcmVwbGF5LmpzJztcbmltcG9ydCB7Y3JlYXRlIGFzIGNyZWF0ZVRyYW5zZm9ybSwgY29tcG9zZSBhcyBjb21wb3NlVHJhbnNmb3JtfSBmcm9tICcuLi8uLi90cmFuc2Zvcm0uanMnO1xuXG5cbi8qKlxuICogQHR5cGUge09iamVjdDxSZXBsYXlUeXBlLCB0eXBlb2YgQ2FudmFzUmVwbGF5Pn1cbiAqL1xudmFyIEJBVENIX0NPTlNUUlVDVE9SUyA9IHtcbiAgJ0NpcmNsZSc6IENhbnZhc1BvbHlnb25SZXBsYXksXG4gICdEZWZhdWx0JzogQ2FudmFzUmVwbGF5LFxuICAnSW1hZ2UnOiBDYW52YXNJbWFnZVJlcGxheSxcbiAgJ0xpbmVTdHJpbmcnOiBDYW52YXNMaW5lU3RyaW5nUmVwbGF5LFxuICAnUG9seWdvbic6IENhbnZhc1BvbHlnb25SZXBsYXksXG4gICdUZXh0JzogQ2FudmFzVGV4dFJlcGxheVxufTtcblxuXG52YXIgQ2FudmFzUmVwbGF5R3JvdXAgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChSZXBsYXlHcm91cCkge1xuICBmdW5jdGlvbiBDYW52YXNSZXBsYXlHcm91cChcbiAgICB0b2xlcmFuY2UsXG4gICAgbWF4RXh0ZW50LFxuICAgIHJlc29sdXRpb24sXG4gICAgcGl4ZWxSYXRpbyxcbiAgICBvdmVybGFwcyxcbiAgICBkZWNsdXR0ZXJUcmVlLFxuICAgIG9wdF9yZW5kZXJCdWZmZXJcbiAgKSB7XG4gICAgUmVwbGF5R3JvdXAuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIERlY2x1dHRlciB0cmVlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5kZWNsdXR0ZXJUcmVlXyA9IGRlY2x1dHRlclRyZWU7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkRlY2x1dHRlckdyb3VwfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5kZWNsdXR0ZXJHcm91cF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudG9sZXJhbmNlXyA9IHRvbGVyYW5jZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gICAgICovXG4gICAgdGhpcy5tYXhFeHRlbnRfID0gbWF4RXh0ZW50O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLm92ZXJsYXBzXyA9IG92ZXJsYXBzO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucGl4ZWxSYXRpb18gPSBwaXhlbFJhdGlvO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVzb2x1dGlvbl8gPSByZXNvbHV0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlckJ1ZmZlcl8gPSBvcHRfcmVuZGVyQnVmZmVyO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsICFPYmplY3Q8UmVwbGF5VHlwZSwgQ2FudmFzUmVwbGF5Pj59XG4gICAgICovXG4gICAgdGhpcy5yZXBsYXlzQnlaSW5kZXhfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gICAgICovXG4gICAgdGhpcy5oaXREZXRlY3Rpb25Db250ZXh0XyA9IGNyZWF0ZUNhbnZhc0NvbnRleHQyRCgxLCAxKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uLy4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19XG4gICAgICovXG4gICAgdGhpcy5oaXREZXRlY3Rpb25UcmFuc2Zvcm1fID0gY3JlYXRlVHJhbnNmb3JtKCk7XG4gIH1cblxuICBpZiAoIFJlcGxheUdyb3VwICkgQ2FudmFzUmVwbGF5R3JvdXAuX19wcm90b19fID0gUmVwbGF5R3JvdXA7XG4gIENhbnZhc1JlcGxheUdyb3VwLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFJlcGxheUdyb3VwICYmIFJlcGxheUdyb3VwLnByb3RvdHlwZSApO1xuICBDYW52YXNSZXBsYXlHcm91cC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYW52YXNSZXBsYXlHcm91cDtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENhbnZhc1JlcGxheUdyb3VwLnByb3RvdHlwZS5hZGREZWNsdXR0ZXIgPSBmdW5jdGlvbiBhZGREZWNsdXR0ZXIgKGdyb3VwKSB7XG4gICAgdmFyIGRlY2x1dHRlciA9IG51bGw7XG4gICAgaWYgKHRoaXMuZGVjbHV0dGVyVHJlZV8pIHtcbiAgICAgIGlmIChncm91cCkge1xuICAgICAgICBkZWNsdXR0ZXIgPSB0aGlzLmRlY2x1dHRlckdyb3VwXztcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovIChkZWNsdXR0ZXJbNF0pKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWNsdXR0ZXIgPSB0aGlzLmRlY2x1dHRlckdyb3VwXyA9IGNyZWF0ZUVtcHR5KCk7XG4gICAgICAgIGRlY2x1dHRlci5wdXNoKDEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVjbHV0dGVyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBDb250ZXh0LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19IHRyYW5zZm9ybSBUcmFuc2Zvcm0uXG4gICAqL1xuICBDYW52YXNSZXBsYXlHcm91cC5wcm90b3R5cGUuY2xpcCA9IGZ1bmN0aW9uIGNsaXAgKGNvbnRleHQsIHRyYW5zZm9ybSkge1xuICAgIHZhciBmbGF0Q2xpcENvb3JkcyA9IHRoaXMuZ2V0Q2xpcENvb3Jkcyh0cmFuc2Zvcm0pO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oZmxhdENsaXBDb29yZHNbMF0sIGZsYXRDbGlwQ29vcmRzWzFdKTtcbiAgICBjb250ZXh0LmxpbmVUbyhmbGF0Q2xpcENvb3Jkc1syXSwgZmxhdENsaXBDb29yZHNbM10pO1xuICAgIGNvbnRleHQubGluZVRvKGZsYXRDbGlwQ29vcmRzWzRdLCBmbGF0Q2xpcENvb3Jkc1s1XSk7XG4gICAgY29udGV4dC5saW5lVG8oZmxhdENsaXBDb29yZHNbNl0sIGZsYXRDbGlwQ29vcmRzWzddKTtcbiAgICBjb250ZXh0LmNsaXAoKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxSZXBsYXlUeXBlPn0gcmVwbGF5cyBSZXBsYXlzLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBIYXMgcmVwbGF5cyBvZiB0aGUgcHJvdmlkZWQgdHlwZXMuXG4gICAqL1xuICBDYW52YXNSZXBsYXlHcm91cC5wcm90b3R5cGUuaGFzUmVwbGF5cyA9IGZ1bmN0aW9uIGhhc1JlcGxheXMgKHJlcGxheXMpIHtcbiAgICBmb3IgKHZhciB6SW5kZXggaW4gdGhpcy5yZXBsYXlzQnlaSW5kZXhfKSB7XG4gICAgICB2YXIgY2FuZGlkYXRlcyA9IHRoaXMucmVwbGF5c0J5WkluZGV4X1t6SW5kZXhdO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcmVwbGF5cy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGlmIChyZXBsYXlzW2ldIGluIGNhbmRpZGF0ZXMpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZJWE1FIGVtcHR5IGRlc2NyaXB0aW9uIGZvciBqc2RvY1xuICAgKi9cbiAgQ2FudmFzUmVwbGF5R3JvdXAucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uIGZpbmlzaCAoKSB7XG4gICAgZm9yICh2YXIgektleSBpbiB0aGlzLnJlcGxheXNCeVpJbmRleF8pIHtcbiAgICAgIHZhciByZXBsYXlzID0gdGhpcy5yZXBsYXlzQnlaSW5kZXhfW3pLZXldO1xuICAgICAgZm9yICh2YXIgcmVwbGF5S2V5IGluIHJlcGxheXMpIHtcbiAgICAgICAgcmVwbGF5c1tyZXBsYXlLZXldLmZpbmlzaCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaGl0VG9sZXJhbmNlIEhpdCB0b2xlcmFuY2UgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGJvb2xlYW4+fSBza2lwcGVkRmVhdHVyZXNIYXNoIElkcyBvZiBmZWF0dXJlcyB0byBza2lwLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKChpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0KSk6IFR9IGNhbGxiYWNrIEZlYXR1cmUgY2FsbGJhY2suXG4gICAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkRlY2x1dHRlckdyb3VwPn0gZGVjbHV0dGVyUmVwbGF5cyBEZWNsdXR0ZXIgcmVwbGF5cy5cbiAgICogQHJldHVybiB7VHx1bmRlZmluZWR9IENhbGxiYWNrIHJlc3VsdC5cbiAgICogQHRlbXBsYXRlIFRcbiAgICovXG4gIENhbnZhc1JlcGxheUdyb3VwLnByb3RvdHlwZS5mb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlIChcbiAgICBjb29yZGluYXRlLFxuICAgIHJlc29sdXRpb24sXG4gICAgcm90YXRpb24sXG4gICAgaGl0VG9sZXJhbmNlLFxuICAgIHNraXBwZWRGZWF0dXJlc0hhc2gsXG4gICAgY2FsbGJhY2ssXG4gICAgZGVjbHV0dGVyUmVwbGF5c1xuICApIHtcblxuICAgIGhpdFRvbGVyYW5jZSA9IE1hdGgucm91bmQoaGl0VG9sZXJhbmNlKTtcbiAgICB2YXIgY29udGV4dFNpemUgPSBoaXRUb2xlcmFuY2UgKiAyICsgMTtcbiAgICB2YXIgdHJhbnNmb3JtID0gY29tcG9zZVRyYW5zZm9ybSh0aGlzLmhpdERldGVjdGlvblRyYW5zZm9ybV8sXG4gICAgICBoaXRUb2xlcmFuY2UgKyAwLjUsIGhpdFRvbGVyYW5jZSArIDAuNSxcbiAgICAgIDEgLyByZXNvbHV0aW9uLCAtMSAvIHJlc29sdXRpb24sXG4gICAgICAtcm90YXRpb24sXG4gICAgICAtY29vcmRpbmF0ZVswXSwgLWNvb3JkaW5hdGVbMV0pO1xuICAgIHZhciBjb250ZXh0ID0gdGhpcy5oaXREZXRlY3Rpb25Db250ZXh0XztcblxuICAgIGlmIChjb250ZXh0LmNhbnZhcy53aWR0aCAhPT0gY29udGV4dFNpemUgfHwgY29udGV4dC5jYW52YXMuaGVpZ2h0ICE9PSBjb250ZXh0U2l6ZSkge1xuICAgICAgY29udGV4dC5jYW52YXMud2lkdGggPSBjb250ZXh0U2l6ZTtcbiAgICAgIGNvbnRleHQuY2FudmFzLmhlaWdodCA9IGNvbnRleHRTaXplO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCBjb250ZXh0U2l6ZSwgY29udGV4dFNpemUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgICAqL1xuICAgIHZhciBoaXRFeHRlbnQ7XG4gICAgaWYgKHRoaXMucmVuZGVyQnVmZmVyXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBoaXRFeHRlbnQgPSBjcmVhdGVFbXB0eSgpO1xuICAgICAgZXh0ZW5kQ29vcmRpbmF0ZShoaXRFeHRlbnQsIGNvb3JkaW5hdGUpO1xuICAgICAgYnVmZmVyKGhpdEV4dGVudCwgcmVzb2x1dGlvbiAqICh0aGlzLnJlbmRlckJ1ZmZlcl8gKyBoaXRUb2xlcmFuY2UpLCBoaXRFeHRlbnQpO1xuICAgIH1cblxuICAgIHZhciBtYXNrID0gZ2V0Q2lyY2xlQXJyYXkoaGl0VG9sZXJhbmNlKTtcbiAgICB2YXIgZGVjbHV0dGVyZWRGZWF0dXJlcztcbiAgICBpZiAodGhpcy5kZWNsdXR0ZXJUcmVlXykge1xuICAgICAgZGVjbHV0dGVyZWRGZWF0dXJlcyA9IHRoaXMuZGVjbHV0dGVyVHJlZV8uYWxsKCkubWFwKGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgIHJldHVybiBlbnRyeS52YWx1ZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciByZXBsYXlUeXBlO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmUuXG4gICAgICogQHJldHVybiB7P30gQ2FsbGJhY2sgcmVzdWx0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZlYXR1cmVDYWxsYmFjayhmZWF0dXJlKSB7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY29udGV4dFNpemUsIGNvbnRleHRTaXplKS5kYXRhO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZXh0U2l6ZTsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29udGV4dFNpemU7IGorKykge1xuICAgICAgICAgIGlmIChtYXNrW2ldW2pdKSB7XG4gICAgICAgICAgICBpZiAoaW1hZ2VEYXRhWyhqICogY29udGV4dFNpemUgKyBpKSAqIDQgKyAzXSA+IDApIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICh2b2lkIDApO1xuICAgICAgICAgICAgICBpZiAoIShkZWNsdXR0ZXJlZEZlYXR1cmVzICYmIChyZXBsYXlUeXBlID09IFJlcGxheVR5cGUuSU1BR0UgfHwgcmVwbGF5VHlwZSA9PSBSZXBsYXlUeXBlLlRFWFQpKSB8fFxuICAgICAgICAgICAgICAgICAgZGVjbHV0dGVyZWRGZWF0dXJlcy5pbmRleE9mKGZlYXR1cmUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNhbGxiYWNrKGZlYXR1cmUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIGNvbnRleHRTaXplLCBjb250ZXh0U2l6ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi9cbiAgICB2YXIgenMgPSBPYmplY3Qua2V5cyh0aGlzLnJlcGxheXNCeVpJbmRleF8pLm1hcChOdW1iZXIpO1xuICAgIHpzLnNvcnQobnVtYmVyU2FmZUNvbXBhcmVGdW5jdGlvbik7XG5cbiAgICB2YXIgaSwgaiwgcmVwbGF5cywgcmVwbGF5LCByZXN1bHQ7XG4gICAgZm9yIChpID0genMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHZhciB6SW5kZXhLZXkgPSB6c1tpXS50b1N0cmluZygpO1xuICAgICAgcmVwbGF5cyA9IHRoaXMucmVwbGF5c0J5WkluZGV4X1t6SW5kZXhLZXldO1xuICAgICAgZm9yIChqID0gT1JERVIubGVuZ3RoIC0gMTsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgcmVwbGF5VHlwZSA9IE9SREVSW2pdO1xuICAgICAgICByZXBsYXkgPSByZXBsYXlzW3JlcGxheVR5cGVdO1xuICAgICAgICBpZiAocmVwbGF5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoZGVjbHV0dGVyUmVwbGF5cyAmJlxuICAgICAgICAgICAgICAocmVwbGF5VHlwZSA9PSBSZXBsYXlUeXBlLklNQUdFIHx8IHJlcGxheVR5cGUgPT0gUmVwbGF5VHlwZS5URVhUKSkge1xuICAgICAgICAgICAgdmFyIGRlY2x1dHRlciA9IGRlY2x1dHRlclJlcGxheXNbekluZGV4S2V5XTtcbiAgICAgICAgICAgIGlmICghZGVjbHV0dGVyKSB7XG4gICAgICAgICAgICAgIGRlY2x1dHRlclJlcGxheXNbekluZGV4S2V5XSA9IFtyZXBsYXksIHRyYW5zZm9ybS5zbGljZSgwKV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkZWNsdXR0ZXIucHVzaChyZXBsYXksIHRyYW5zZm9ybS5zbGljZSgwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlcGxheS5yZXBsYXlIaXREZXRlY3Rpb24oY29udGV4dCwgdHJhbnNmb3JtLCByb3RhdGlvbixcbiAgICAgICAgICAgICAgc2tpcHBlZEZlYXR1cmVzSGFzaCwgZmVhdHVyZUNhbGxiYWNrLCBoaXRFeHRlbnQpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19IHRyYW5zZm9ybSBUcmFuc2Zvcm0uXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IENsaXAgY29vcmRpbmF0ZXMuXG4gICAqL1xuICBDYW52YXNSZXBsYXlHcm91cC5wcm90b3R5cGUuZ2V0Q2xpcENvb3JkcyA9IGZ1bmN0aW9uIGdldENsaXBDb29yZHMgKHRyYW5zZm9ybSkge1xuICAgIHZhciBtYXhFeHRlbnQgPSB0aGlzLm1heEV4dGVudF87XG4gICAgdmFyIG1pblggPSBtYXhFeHRlbnRbMF07XG4gICAgdmFyIG1pblkgPSBtYXhFeHRlbnRbMV07XG4gICAgdmFyIG1heFggPSBtYXhFeHRlbnRbMl07XG4gICAgdmFyIG1heFkgPSBtYXhFeHRlbnRbM107XG4gICAgdmFyIGZsYXRDbGlwQ29vcmRzID0gW21pblgsIG1pblksIG1pblgsIG1heFksIG1heFgsIG1heFksIG1heFgsIG1pblldO1xuICAgIHRyYW5zZm9ybTJEKFxuICAgICAgZmxhdENsaXBDb29yZHMsIDAsIDgsIDIsIHRyYW5zZm9ybSwgZmxhdENsaXBDb29yZHMpO1xuICAgIHJldHVybiBmbGF0Q2xpcENvb3JkcztcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENhbnZhc1JlcGxheUdyb3VwLnByb3RvdHlwZS5nZXRSZXBsYXkgPSBmdW5jdGlvbiBnZXRSZXBsYXkgKHpJbmRleCwgcmVwbGF5VHlwZSkge1xuICAgIHZhciB6SW5kZXhLZXkgPSB6SW5kZXggIT09IHVuZGVmaW5lZCA/IHpJbmRleC50b1N0cmluZygpIDogJzAnO1xuICAgIHZhciByZXBsYXlzID0gdGhpcy5yZXBsYXlzQnlaSW5kZXhfW3pJbmRleEtleV07XG4gICAgaWYgKHJlcGxheXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVwbGF5cyA9IHt9O1xuICAgICAgdGhpcy5yZXBsYXlzQnlaSW5kZXhfW3pJbmRleEtleV0gPSByZXBsYXlzO1xuICAgIH1cbiAgICB2YXIgcmVwbGF5ID0gcmVwbGF5c1tyZXBsYXlUeXBlXTtcbiAgICBpZiAocmVwbGF5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBDb25zdHJ1Y3RvciA9IEJBVENIX0NPTlNUUlVDVE9SU1tyZXBsYXlUeXBlXTtcbiAgICAgIHJlcGxheSA9IG5ldyBDb25zdHJ1Y3Rvcih0aGlzLnRvbGVyYW5jZV8sIHRoaXMubWF4RXh0ZW50XyxcbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uXywgdGhpcy5waXhlbFJhdGlvXywgdGhpcy5vdmVybGFwc18sIHRoaXMuZGVjbHV0dGVyVHJlZV8pO1xuICAgICAgcmVwbGF5c1tyZXBsYXlUeXBlXSA9IHJlcGxheTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcGxheTtcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7T2JqZWN0PHN0cmluZywgT2JqZWN0PFJlcGxheVR5cGUsIENhbnZhc1JlcGxheT4+fSBSZXBsYXlzLlxuICAgKi9cbiAgQ2FudmFzUmVwbGF5R3JvdXAucHJvdG90eXBlLmdldFJlcGxheXMgPSBmdW5jdGlvbiBnZXRSZXBsYXlzICgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXBsYXlzQnlaSW5kZXhfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQ2FudmFzUmVwbGF5R3JvdXAucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5JDEgKCkge1xuICAgIHJldHVybiBpc0VtcHR5KHRoaXMucmVwbGF5c0J5WkluZGV4Xyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IENvbnRleHQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHZpZXdSb3RhdGlvbiBWaWV3IHJvdGF0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGJvb2xlYW4+fSBza2lwcGVkRmVhdHVyZXNIYXNoIElkcyBvZiBmZWF0dXJlcyB0byBza2lwLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNuYXBUb1BpeGVsIFNuYXAgcG9pbnQgc3ltYm9scyBhbmQgdGVzdCB0byBpbnRlZ2VyIHBpeGVsLlxuICAgKiBAcGFyYW0ge0FycmF5PFJlcGxheVR5cGU+PX0gb3B0X3JlcGxheVR5cGVzIE9yZGVyZWQgcmVwbGF5IHR5cGVzIHRvIHJlcGxheS5cbiAgICogICAgIERlZmF1bHQgaXMge0BsaW5rIG1vZHVsZTpvbC9yZW5kZXIvcmVwbGF5fk9SREVSfVxuICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5EZWNsdXR0ZXJHcm91cD49fSBvcHRfZGVjbHV0dGVyUmVwbGF5cyBEZWNsdXR0ZXIgcmVwbGF5cy5cbiAgICovXG4gIENhbnZhc1JlcGxheUdyb3VwLnByb3RvdHlwZS5yZXBsYXkgPSBmdW5jdGlvbiByZXBsYXkgKFxuICAgIGNvbnRleHQsXG4gICAgdHJhbnNmb3JtLFxuICAgIHZpZXdSb3RhdGlvbixcbiAgICBza2lwcGVkRmVhdHVyZXNIYXNoLFxuICAgIHNuYXBUb1BpeGVsLFxuICAgIG9wdF9yZXBsYXlUeXBlcyxcbiAgICBvcHRfZGVjbHV0dGVyUmVwbGF5c1xuICApIHtcblxuICAgIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi9cbiAgICB2YXIgenMgPSBPYmplY3Qua2V5cyh0aGlzLnJlcGxheXNCeVpJbmRleF8pLm1hcChOdW1iZXIpO1xuICAgIHpzLnNvcnQobnVtYmVyU2FmZUNvbXBhcmVGdW5jdGlvbik7XG5cbiAgICAvLyBzZXR1cCBjbGlwcGluZyBzbyB0aGF0IHRoZSBwYXJ0cyBvZiBvdmVyLXNpbXBsaWZpZWQgZ2VvbWV0cmllcyBhcmUgbm90XG4gICAgLy8gdmlzaWJsZSBvdXRzaWRlIHRoZSBjdXJyZW50IGV4dGVudCB3aGVuIHBhbm5pbmdcbiAgICBjb250ZXh0LnNhdmUoKTtcbiAgICB0aGlzLmNsaXAoY29udGV4dCwgdHJhbnNmb3JtKTtcblxuICAgIHZhciByZXBsYXlUeXBlcyA9IG9wdF9yZXBsYXlUeXBlcyA/IG9wdF9yZXBsYXlUeXBlcyA6IE9SREVSO1xuICAgIHZhciBpLCBpaSwgaiwgamosIHJlcGxheXMsIHJlcGxheTtcbiAgICBmb3IgKGkgPSAwLCBpaSA9IHpzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIHZhciB6SW5kZXhLZXkgPSB6c1tpXS50b1N0cmluZygpO1xuICAgICAgcmVwbGF5cyA9IHRoaXMucmVwbGF5c0J5WkluZGV4X1t6SW5kZXhLZXldO1xuICAgICAgZm9yIChqID0gMCwgamogPSByZXBsYXlUeXBlcy5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgICAgIHZhciByZXBsYXlUeXBlID0gcmVwbGF5VHlwZXNbal07XG4gICAgICAgIHJlcGxheSA9IHJlcGxheXNbcmVwbGF5VHlwZV07XG4gICAgICAgIGlmIChyZXBsYXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChvcHRfZGVjbHV0dGVyUmVwbGF5cyAmJlxuICAgICAgICAgICAgICAocmVwbGF5VHlwZSA9PSBSZXBsYXlUeXBlLklNQUdFIHx8IHJlcGxheVR5cGUgPT0gUmVwbGF5VHlwZS5URVhUKSkge1xuICAgICAgICAgICAgdmFyIGRlY2x1dHRlciA9IG9wdF9kZWNsdXR0ZXJSZXBsYXlzW3pJbmRleEtleV07XG4gICAgICAgICAgICBpZiAoIWRlY2x1dHRlcikge1xuICAgICAgICAgICAgICBvcHRfZGVjbHV0dGVyUmVwbGF5c1t6SW5kZXhLZXldID0gW3JlcGxheSwgdHJhbnNmb3JtLnNsaWNlKDApXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRlY2x1dHRlci5wdXNoKHJlcGxheSwgdHJhbnNmb3JtLnNsaWNlKDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVwbGF5LnJlcGxheShjb250ZXh0LCB0cmFuc2Zvcm0sIHZpZXdSb3RhdGlvbiwgc2tpcHBlZEZlYXR1cmVzSGFzaCwgc25hcFRvUGl4ZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICB9O1xuXG4gIHJldHVybiBDYW52YXNSZXBsYXlHcm91cDtcbn0oUmVwbGF5R3JvdXApKTtcblxuXG4vKipcbiAqIFRoaXMgY2FjaGUgaXMgdXNlZCBmb3Igc3RvcmluZyBjYWxjdWxhdGVkIHBpeGVsIGNpcmNsZXMgZm9yIGluY3JlYXNpbmcgcGVyZm9ybWFuY2UuXG4gKiBJdCBpcyBhIHN0YXRpYyBwcm9wZXJ0eSB0byBhbGxvdyBlYWNoIFJlcGxheWdyb3VwIHRvIGFjY2VzcyBpdC5cbiAqIEB0eXBlIHtPYmplY3Q8bnVtYmVyLCBBcnJheTxBcnJheTwoYm9vbGVhbnx1bmRlZmluZWQpPj4+fVxuICovXG52YXIgY2lyY2xlQXJyYXlDYWNoZSA9IHtcbiAgMDogW1t0cnVlXV1cbn07XG5cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBmaWxscyBhIHJvdyBpbiB0aGUgYXJyYXkgZnJvbSB0aGUgZ2l2ZW4gY29vcmRpbmF0ZSB0byB0aGVcbiAqIG1pZGRsZSB3aXRoIGB0cnVlYC5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8KGJvb2xlYW58dW5kZWZpbmVkKT4+fSBhcnJheSBUaGUgYXJyYXkgdGhhdCB3aWxsIGJlIGFsdGVyZWQuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0geSBZIGNvb3JkaW5hdGUuXG4gKi9cbmZ1bmN0aW9uIGZpbGxDaXJjbGVBcnJheVJvd1RvTWlkZGxlKGFycmF5LCB4LCB5KSB7XG4gIHZhciBpO1xuICB2YXIgcmFkaXVzID0gTWF0aC5mbG9vcihhcnJheS5sZW5ndGggLyAyKTtcbiAgaWYgKHggPj0gcmFkaXVzKSB7XG4gICAgZm9yIChpID0gcmFkaXVzOyBpIDwgeDsgaSsrKSB7XG4gICAgICBhcnJheVtpXVt5XSA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKHggPCByYWRpdXMpIHtcbiAgICBmb3IgKGkgPSB4ICsgMTsgaSA8IHJhZGl1czsgaSsrKSB7XG4gICAgICBhcnJheVtpXVt5XSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cblxuLyoqXG4gKiBUaGlzIG1ldGhvZHMgY3JlYXRlcyBhIGNpcmNsZSBpbnNpZGUgYSBmaXR0aW5nIGFycmF5LiBQb2ludHMgaW5zaWRlIHRoZVxuICogY2lyY2xlIGFyZSBtYXJrZWQgYnkgdHJ1ZSwgcG9pbnRzIG9uIHRoZSBvdXRzaWRlIGFyZSB1bmRlZmluZWQuXG4gKiBJdCB1c2VzIHRoZSBtaWRwb2ludCBjaXJjbGUgYWxnb3JpdGhtLlxuICogQSBjYWNoZSBpcyB1c2VkIHRvIGluY3JlYXNlIHBlcmZvcm1hbmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBSYWRpdXMuXG4gKiBAcmV0dXJucyB7QXJyYXk8QXJyYXk8KGJvb2xlYW58dW5kZWZpbmVkKT4+fSBBbiBhcnJheSB3aXRoIG1hcmtlZCBjaXJjbGUgcG9pbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2lyY2xlQXJyYXkocmFkaXVzKSB7XG4gIGlmIChjaXJjbGVBcnJheUNhY2hlW3JhZGl1c10gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBjaXJjbGVBcnJheUNhY2hlW3JhZGl1c107XG4gIH1cblxuICB2YXIgYXJyYXlTaXplID0gcmFkaXVzICogMiArIDE7XG4gIHZhciBhcnIgPSBuZXcgQXJyYXkoYXJyYXlTaXplKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheVNpemU7IGkrKykge1xuICAgIGFycltpXSA9IG5ldyBBcnJheShhcnJheVNpemUpO1xuICB9XG5cbiAgdmFyIHggPSByYWRpdXM7XG4gIHZhciB5ID0gMDtcbiAgdmFyIGVycm9yID0gMDtcblxuICB3aGlsZSAoeCA+PSB5KSB7XG4gICAgZmlsbENpcmNsZUFycmF5Um93VG9NaWRkbGUoYXJyLCByYWRpdXMgKyB4LCByYWRpdXMgKyB5KTtcbiAgICBmaWxsQ2lyY2xlQXJyYXlSb3dUb01pZGRsZShhcnIsIHJhZGl1cyArIHksIHJhZGl1cyArIHgpO1xuICAgIGZpbGxDaXJjbGVBcnJheVJvd1RvTWlkZGxlKGFyciwgcmFkaXVzIC0geSwgcmFkaXVzICsgeCk7XG4gICAgZmlsbENpcmNsZUFycmF5Um93VG9NaWRkbGUoYXJyLCByYWRpdXMgLSB4LCByYWRpdXMgKyB5KTtcbiAgICBmaWxsQ2lyY2xlQXJyYXlSb3dUb01pZGRsZShhcnIsIHJhZGl1cyAtIHgsIHJhZGl1cyAtIHkpO1xuICAgIGZpbGxDaXJjbGVBcnJheVJvd1RvTWlkZGxlKGFyciwgcmFkaXVzIC0geSwgcmFkaXVzIC0geCk7XG4gICAgZmlsbENpcmNsZUFycmF5Um93VG9NaWRkbGUoYXJyLCByYWRpdXMgKyB5LCByYWRpdXMgLSB4KTtcbiAgICBmaWxsQ2lyY2xlQXJyYXlSb3dUb01pZGRsZShhcnIsIHJhZGl1cyArIHgsIHJhZGl1cyAtIHkpO1xuXG4gICAgeSsrO1xuICAgIGVycm9yICs9IDEgKyAyICogeTtcbiAgICBpZiAoMiAqIChlcnJvciAtIHgpICsgMSA+IDApIHtcbiAgICAgIHggLT0gMTtcbiAgICAgIGVycm9yICs9IDEgLSAyICogeDtcbiAgICB9XG4gIH1cblxuICBjaXJjbGVBcnJheUNhY2hlW3JhZGl1c10gPSBhcnI7XG4gIHJldHVybiBhcnI7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0geyFPYmplY3Q8c3RyaW5nLCBBcnJheTwqPj59IGRlY2x1dHRlclJlcGxheXMgRGVjbHV0dGVyIHJlcGxheXMuXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBDb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBzbmFwVG9QaXhlbCBTbmFwIHBvaW50IHN5bWJvbHMgYW5kIHRleHQgdG8gaW50ZWdlciBwaXhlbHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXBsYXlEZWNsdXR0ZXIoZGVjbHV0dGVyUmVwbGF5cywgY29udGV4dCwgcm90YXRpb24sIHNuYXBUb1BpeGVsKSB7XG4gIHZhciB6cyA9IE9iamVjdC5rZXlzKGRlY2x1dHRlclJlcGxheXMpLm1hcChOdW1iZXIpLnNvcnQobnVtYmVyU2FmZUNvbXBhcmVGdW5jdGlvbik7XG4gIHZhciBza2lwcGVkRmVhdHVyZVVpZHMgPSB7fTtcbiAgZm9yICh2YXIgeiA9IDAsIHp6ID0genMubGVuZ3RoOyB6IDwgeno7ICsreikge1xuICAgIHZhciByZXBsYXlEYXRhID0gZGVjbHV0dGVyUmVwbGF5c1t6c1t6XS50b1N0cmluZygpXTtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSByZXBsYXlEYXRhLmxlbmd0aDsgaSA8IGlpOykge1xuICAgICAgdmFyIHJlcGxheSA9IHJlcGxheURhdGFbaSsrXTtcbiAgICAgIHZhciB0cmFuc2Zvcm0gPSByZXBsYXlEYXRhW2krK107XG4gICAgICByZXBsYXkucmVwbGF5KGNvbnRleHQsIHRyYW5zZm9ybSwgcm90YXRpb24sIHNraXBwZWRGZWF0dXJlVWlkcywgc25hcFRvUGl4ZWwpO1xuICAgIH1cbiAgfVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IENhbnZhc1JlcGxheUdyb3VwO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZXBsYXlHcm91cC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyL2NhbnZhcy9UZXh0UmVwbGF5XG4gKi9cbmltcG9ydCB7Z2V0VWlkfSBmcm9tICcuLi8uLi91dGlsLmpzJztcbmltcG9ydCB7YXNDb2xvckxpa2V9IGZyb20gJy4uLy4uL2NvbG9ybGlrZS5qcyc7XG5pbXBvcnQge2NyZWF0ZUNhbnZhc0NvbnRleHQyRH0gZnJvbSAnLi4vLi4vZG9tLmpzJztcbmltcG9ydCB7aW50ZXJzZWN0c30gZnJvbSAnLi4vLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7bWF0Y2hpbmdDaHVua30gZnJvbSAnLi4vLi4vZ2VvbS9mbGF0L3N0cmFpZ2h0Y2h1bmsuanMnO1xuaW1wb3J0IEdlb21ldHJ5VHlwZSBmcm9tICcuLi8uLi9nZW9tL0dlb21ldHJ5VHlwZS5qcyc7XG5pbXBvcnQge0NBTlZBU19MSU5FX0RBU0h9IGZyb20gJy4uLy4uL2hhcy5qcyc7XG5pbXBvcnQge2xhYmVsQ2FjaGUsIG1lYXN1cmVUZXh0V2lkdGgsIGRlZmF1bHRUZXh0QWxpZ24sIG1lYXN1cmVUZXh0SGVpZ2h0LCBkZWZhdWx0UGFkZGluZywgZGVmYXVsdExpbmVDYXAsIGRlZmF1bHRMaW5lRGFzaE9mZnNldCwgZGVmYXVsdExpbmVEYXNoLCBkZWZhdWx0TGluZUpvaW4sIGRlZmF1bHRGaWxsU3R5bGUsIGNoZWNrRm9udCwgZGVmYXVsdEZvbnQsIGRlZmF1bHRMaW5lV2lkdGgsIGRlZmF1bHRNaXRlckxpbWl0LCBkZWZhdWx0U3Ryb2tlU3R5bGUsIGRlZmF1bHRUZXh0QmFzZWxpbmV9IGZyb20gJy4uL2NhbnZhcy5qcyc7XG5pbXBvcnQgQ2FudmFzSW5zdHJ1Y3Rpb24gZnJvbSAnLi9JbnN0cnVjdGlvbi5qcyc7XG5pbXBvcnQgQ2FudmFzUmVwbGF5IGZyb20gJy4vUmVwbGF5LmpzJztcbmltcG9ydCB7VEVYVF9BTElHTn0gZnJvbSAnLi4vcmVwbGF5LmpzJztcbmltcG9ydCBUZXh0UGxhY2VtZW50IGZyb20gJy4uLy4uL3N0eWxlL1RleHRQbGFjZW1lbnQuanMnO1xuXG52YXIgQ2FudmFzVGV4dFJlcGxheSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKENhbnZhc1JlcGxheSkge1xuICBmdW5jdGlvbiBDYW52YXNUZXh0UmVwbGF5KHRvbGVyYW5jZSwgbWF4RXh0ZW50LCByZXNvbHV0aW9uLCBwaXhlbFJhdGlvLCBvdmVybGFwcywgZGVjbHV0dGVyVHJlZSkge1xuICAgIENhbnZhc1JlcGxheS5jYWxsKHRoaXMsIHRvbGVyYW5jZSwgbWF4RXh0ZW50LCByZXNvbHV0aW9uLCBwaXhlbFJhdGlvLCBvdmVybGFwcywgZGVjbHV0dGVyVHJlZSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRGVjbHV0dGVyR3JvdXB9XG4gICAgICovXG4gICAgdGhpcy5kZWNsdXR0ZXJHcm91cF87XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxIVE1MQ2FudmFzRWxlbWVudD59XG4gICAgICovXG4gICAgdGhpcy5sYWJlbHNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnRleHRfID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50ZXh0T2Zmc2V0WF8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudGV4dE9mZnNldFlfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMudGV4dFJvdGF0ZVdpdGhWaWV3XyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRleHRSb3RhdGlvbl8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5GaWxsU3RhdGV9XG4gICAgICovXG4gICAgdGhpcy50ZXh0RmlsbFN0YXRlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5GaWxsU3RhdGU+fVxuICAgICAqL1xuICAgIHRoaXMuZmlsbFN0YXRlcyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5TdHJva2VTdGF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLnRleHRTdHJva2VTdGF0ZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuU3Ryb2tlU3RhdGU+fVxuICAgICAqL1xuICAgIHRoaXMuc3Ryb2tlU3RhdGVzID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuVGV4dFN0YXRlfVxuICAgICAqL1xuICAgIHRoaXMudGV4dFN0YXRlXyA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLlRleHRTdGF0ZX0gKi8gKHt9KTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLlRleHRTdGF0ZT59XG4gICAgICovXG4gICAgdGhpcy50ZXh0U3RhdGVzID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy50ZXh0S2V5XyA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZmlsbEtleV8gPSAnJztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnN0cm9rZUtleV8gPSAnJztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIG51bWJlcj4+fVxuICAgICAqL1xuICAgIHRoaXMud2lkdGhzXyA9IHt9O1xuXG4gICAgbGFiZWxDYWNoZS5wcnVuZSgpO1xuXG4gIH1cblxuICBpZiAoIENhbnZhc1JlcGxheSApIENhbnZhc1RleHRSZXBsYXkuX19wcm90b19fID0gQ2FudmFzUmVwbGF5O1xuICBDYW52YXNUZXh0UmVwbGF5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIENhbnZhc1JlcGxheSAmJiBDYW52YXNSZXBsYXkucHJvdG90eXBlICk7XG4gIENhbnZhc1RleHRSZXBsYXkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2FudmFzVGV4dFJlcGxheTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENhbnZhc1RleHRSZXBsYXkucHJvdG90eXBlLmRyYXdUZXh0ID0gZnVuY3Rpb24gZHJhd1RleHQgKGdlb21ldHJ5LCBmZWF0dXJlKSB7XG4gICAgdmFyIGZpbGxTdGF0ZSA9IHRoaXMudGV4dEZpbGxTdGF0ZV87XG4gICAgdmFyIHN0cm9rZVN0YXRlID0gdGhpcy50ZXh0U3Ryb2tlU3RhdGVfO1xuICAgIHZhciB0ZXh0U3RhdGUgPSB0aGlzLnRleHRTdGF0ZV87XG4gICAgaWYgKHRoaXMudGV4dF8gPT09ICcnIHx8ICF0ZXh0U3RhdGUgfHwgKCFmaWxsU3RhdGUgJiYgIXN0cm9rZVN0YXRlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBiZWdpbiA9IHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoO1xuXG4gICAgdmFyIGdlb21ldHJ5VHlwZSA9IGdlb21ldHJ5LmdldFR5cGUoKTtcbiAgICB2YXIgZmxhdENvb3JkaW5hdGVzID0gbnVsbDtcbiAgICB2YXIgZW5kID0gMjtcbiAgICB2YXIgc3RyaWRlID0gMjtcbiAgICB2YXIgaSwgaWk7XG5cbiAgICBpZiAodGV4dFN0YXRlLnBsYWNlbWVudCA9PT0gVGV4dFBsYWNlbWVudC5MSU5FKSB7XG4gICAgICBpZiAoIWludGVyc2VjdHModGhpcy5nZXRCdWZmZXJlZE1heEV4dGVudCgpLCBnZW9tZXRyeS5nZXRFeHRlbnQoKSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGVuZHM7XG4gICAgICBmbGF0Q29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIHN0cmlkZSA9IGdlb21ldHJ5LmdldFN0cmlkZSgpO1xuICAgICAgaWYgKGdlb21ldHJ5VHlwZSA9PSBHZW9tZXRyeVR5cGUuTElORV9TVFJJTkcpIHtcbiAgICAgICAgZW5kcyA9IFtmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoXTtcbiAgICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnlUeXBlID09IEdlb21ldHJ5VHlwZS5NVUxUSV9MSU5FX1NUUklORykge1xuICAgICAgICBlbmRzID0gZ2VvbWV0cnkuZ2V0RW5kcygpO1xuICAgICAgfSBlbHNlIGlmIChnZW9tZXRyeVR5cGUgPT0gR2VvbWV0cnlUeXBlLlBPTFlHT04pIHtcbiAgICAgICAgZW5kcyA9IGdlb21ldHJ5LmdldEVuZHMoKS5zbGljZSgwLCAxKTtcbiAgICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnlUeXBlID09IEdlb21ldHJ5VHlwZS5NVUxUSV9QT0xZR09OKSB7XG4gICAgICAgIHZhciBlbmRzcyA9IGdlb21ldHJ5LmdldEVuZHNzKCk7XG4gICAgICAgIGVuZHMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgZW5kcy5wdXNoKGVuZHNzW2ldWzBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5iZWdpbkdlb21ldHJ5KGdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgICAgIHZhciB0ZXh0QWxpZ24gPSB0ZXh0U3RhdGUudGV4dEFsaWduO1xuICAgICAgdmFyIGZsYXRPZmZzZXQgPSAwO1xuICAgICAgdmFyIGZsYXRFbmQ7XG4gICAgICBmb3IgKHZhciBvID0gMCwgb28gPSBlbmRzLmxlbmd0aDsgbyA8IG9vOyArK28pIHtcbiAgICAgICAgaWYgKHRleHRBbGlnbiA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgcmFuZ2UgPSBtYXRjaGluZ0NodW5rKHRleHRTdGF0ZS5tYXhBbmdsZSwgZmxhdENvb3JkaW5hdGVzLCBmbGF0T2Zmc2V0LCBlbmRzW29dLCBzdHJpZGUpO1xuICAgICAgICAgIGZsYXRPZmZzZXQgPSByYW5nZVswXTtcbiAgICAgICAgICBmbGF0RW5kID0gcmFuZ2VbMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmxhdEVuZCA9IGVuZHNbb107XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gZmxhdE9mZnNldDsgaSA8IGZsYXRFbmQ7IGkgKz0gc3RyaWRlKSB7XG4gICAgICAgICAgdGhpcy5jb29yZGluYXRlcy5wdXNoKGZsYXRDb29yZGluYXRlc1tpXSwgZmxhdENvb3JkaW5hdGVzW2kgKyAxXSk7XG4gICAgICAgIH1cbiAgICAgICAgZW5kID0gdGhpcy5jb29yZGluYXRlcy5sZW5ndGg7XG4gICAgICAgIGZsYXRPZmZzZXQgPSBlbmRzW29dO1xuICAgICAgICB0aGlzLmRyYXdDaGFyc18oYmVnaW4sIGVuZCwgdGhpcy5kZWNsdXR0ZXJHcm91cF8pO1xuICAgICAgICBiZWdpbiA9IGVuZDtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW5kR2VvbWV0cnkoZ2VvbWV0cnksIGZlYXR1cmUpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsYWJlbCA9IHRoaXMuZ2V0SW1hZ2UodGhpcy50ZXh0XywgdGhpcy50ZXh0S2V5XywgdGhpcy5maWxsS2V5XywgdGhpcy5zdHJva2VLZXlfKTtcbiAgICAgIHZhciB3aWR0aCA9IGxhYmVsLndpZHRoIC8gdGhpcy5waXhlbFJhdGlvO1xuICAgICAgc3dpdGNoIChnZW9tZXRyeVR5cGUpIHtcbiAgICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuUE9JTlQ6XG4gICAgICAgIGNhc2UgR2VvbWV0cnlUeXBlLk1VTFRJX1BPSU5UOlxuICAgICAgICAgIGZsYXRDb29yZGluYXRlcyA9IGdlb21ldHJ5LmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgICAgICAgIGVuZCA9IGZsYXRDb29yZGluYXRlcy5sZW5ndGg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR2VvbWV0cnlUeXBlLkxJTkVfU1RSSU5HOlxuICAgICAgICAgIGZsYXRDb29yZGluYXRlcyA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9MaW5lU3RyaW5nLmpzXCIpLmRlZmF1bHR9ICovIChnZW9tZXRyeSkuZ2V0RmxhdE1pZHBvaW50KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR2VvbWV0cnlUeXBlLkNJUkNMRTpcbiAgICAgICAgICBmbGF0Q29vcmRpbmF0ZXMgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2dlb20vQ2lyY2xlLmpzXCIpLmRlZmF1bHR9ICovIChnZW9tZXRyeSkuZ2V0Q2VudGVyKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR2VvbWV0cnlUeXBlLk1VTFRJX0xJTkVfU1RSSU5HOlxuICAgICAgICAgIGZsYXRDb29yZGluYXRlcyA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9NdWx0aUxpbmVTdHJpbmcuanNcIikuZGVmYXVsdH0gKi8gKGdlb21ldHJ5KS5nZXRGbGF0TWlkcG9pbnRzKCk7XG4gICAgICAgICAgZW5kID0gZmxhdENvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuUE9MWUdPTjpcbiAgICAgICAgICBmbGF0Q29vcmRpbmF0ZXMgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2dlb20vUG9seWdvbi5qc1wiKS5kZWZhdWx0fSAqLyAoZ2VvbWV0cnkpLmdldEZsYXRJbnRlcmlvclBvaW50KCk7XG4gICAgICAgICAgaWYgKCF0ZXh0U3RhdGUub3ZlcmZsb3cgJiYgZmxhdENvb3JkaW5hdGVzWzJdIC8gdGhpcy5yZXNvbHV0aW9uIDwgd2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RyaWRlID0gMztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuTVVMVElfUE9MWUdPTjpcbiAgICAgICAgICB2YXIgaW50ZXJpb3JQb2ludHMgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2dlb20vTXVsdGlQb2x5Z29uLmpzXCIpLmRlZmF1bHR9ICovIChnZW9tZXRyeSkuZ2V0RmxhdEludGVyaW9yUG9pbnRzKCk7XG4gICAgICAgICAgZmxhdENvb3JkaW5hdGVzID0gW107XG4gICAgICAgICAgZm9yIChpID0gMCwgaWkgPSBpbnRlcmlvclBvaW50cy5sZW5ndGg7IGkgPCBpaTsgaSArPSAzKSB7XG4gICAgICAgICAgICBpZiAodGV4dFN0YXRlLm92ZXJmbG93IHx8IGludGVyaW9yUG9pbnRzW2kgKyAyXSAvIHRoaXMucmVzb2x1dGlvbiA+PSB3aWR0aCkge1xuICAgICAgICAgICAgICBmbGF0Q29vcmRpbmF0ZXMucHVzaChpbnRlcmlvclBvaW50c1tpXSwgaW50ZXJpb3JQb2ludHNbaSArIDFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZW5kID0gZmxhdENvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICAgICAgICBpZiAoZW5kID09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICB9XG4gICAgICBlbmQgPSB0aGlzLmFwcGVuZEZsYXRDb29yZGluYXRlcyhmbGF0Q29vcmRpbmF0ZXMsIDAsIGVuZCwgc3RyaWRlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgaWYgKHRleHRTdGF0ZS5iYWNrZ3JvdW5kRmlsbCB8fCB0ZXh0U3RhdGUuYmFja2dyb3VuZFN0cm9rZSkge1xuICAgICAgICB0aGlzLnNldEZpbGxTdHJva2VTdHlsZSh0ZXh0U3RhdGUuYmFja2dyb3VuZEZpbGwsIHRleHRTdGF0ZS5iYWNrZ3JvdW5kU3Ryb2tlKTtcbiAgICAgICAgaWYgKHRleHRTdGF0ZS5iYWNrZ3JvdW5kRmlsbCkge1xuICAgICAgICAgIHRoaXMudXBkYXRlRmlsbFN0eWxlKHRoaXMuc3RhdGUsIHRoaXMuY3JlYXRlRmlsbCwgZ2VvbWV0cnkpO1xuICAgICAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2godGhpcy5jcmVhdGVGaWxsKHRoaXMuc3RhdGUsIGdlb21ldHJ5KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRleHRTdGF0ZS5iYWNrZ3JvdW5kU3Ryb2tlKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVTdHJva2VTdHlsZSh0aGlzLnN0YXRlLCB0aGlzLmFwcGx5U3Ryb2tlKTtcbiAgICAgICAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKHRoaXMuY3JlYXRlU3Ryb2tlKHRoaXMuc3RhdGUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5iZWdpbkdlb21ldHJ5KGdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgICAgIHRoaXMuZHJhd1RleHRJbWFnZV8obGFiZWwsIGJlZ2luLCBlbmQpO1xuICAgICAgdGhpcy5lbmRHZW9tZXRyeShnZW9tZXRyeSwgZmVhdHVyZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUZXh0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dEtleSBUZXh0IHN0eWxlIGtleS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGxLZXkgRmlsbCBzdHlsZSBrZXkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJva2VLZXkgU3Ryb2tlIHN0eWxlIGtleS5cbiAgICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR9IEltYWdlLlxuICAgKi9cbiAgQ2FudmFzVGV4dFJlcGxheS5wcm90b3R5cGUuZ2V0SW1hZ2UgPSBmdW5jdGlvbiBnZXRJbWFnZSAodGV4dCwgdGV4dEtleSwgZmlsbEtleSwgc3Ryb2tlS2V5KSB7XG4gICAgdmFyIGxhYmVsO1xuICAgIHZhciBrZXkgPSBzdHJva2VLZXkgKyB0ZXh0S2V5ICsgdGV4dCArIGZpbGxLZXkgKyB0aGlzLnBpeGVsUmF0aW87XG5cbiAgICBpZiAoIWxhYmVsQ2FjaGUuY29udGFpbnNLZXkoa2V5KSkge1xuICAgICAgdmFyIHN0cm9rZVN0YXRlID0gc3Ryb2tlS2V5ID8gdGhpcy5zdHJva2VTdGF0ZXNbc3Ryb2tlS2V5XSB8fCB0aGlzLnRleHRTdHJva2VTdGF0ZV8gOiBudWxsO1xuICAgICAgdmFyIGZpbGxTdGF0ZSA9IGZpbGxLZXkgPyB0aGlzLmZpbGxTdGF0ZXNbZmlsbEtleV0gfHwgdGhpcy50ZXh0RmlsbFN0YXRlXyA6IG51bGw7XG4gICAgICB2YXIgdGV4dFN0YXRlID0gdGhpcy50ZXh0U3RhdGVzW3RleHRLZXldIHx8IHRoaXMudGV4dFN0YXRlXztcbiAgICAgIHZhciBwaXhlbFJhdGlvID0gdGhpcy5waXhlbFJhdGlvO1xuICAgICAgdmFyIHNjYWxlID0gdGV4dFN0YXRlLnNjYWxlICogcGl4ZWxSYXRpbztcbiAgICAgIHZhciBhbGlnbiA9IFRFWFRfQUxJR05bdGV4dFN0YXRlLnRleHRBbGlnbiB8fCBkZWZhdWx0VGV4dEFsaWduXTtcbiAgICAgIHZhciBzdHJva2VXaWR0aCA9IHN0cm9rZUtleSAmJiBzdHJva2VTdGF0ZS5saW5lV2lkdGggPyBzdHJva2VTdGF0ZS5saW5lV2lkdGggOiAwO1xuXG4gICAgICB2YXIgbGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBudW1MaW5lcyA9IGxpbmVzLmxlbmd0aDtcbiAgICAgIHZhciB3aWR0aHMgPSBbXTtcbiAgICAgIHZhciB3aWR0aCA9IG1lYXN1cmVUZXh0V2lkdGhzKHRleHRTdGF0ZS5mb250LCBsaW5lcywgd2lkdGhzKTtcbiAgICAgIHZhciBsaW5lSGVpZ2h0ID0gbWVhc3VyZVRleHRIZWlnaHQodGV4dFN0YXRlLmZvbnQpO1xuICAgICAgdmFyIGhlaWdodCA9IGxpbmVIZWlnaHQgKiBudW1MaW5lcztcbiAgICAgIHZhciByZW5kZXJXaWR0aCA9ICh3aWR0aCArIHN0cm9rZVdpZHRoKTtcbiAgICAgIHZhciBjb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKFxuICAgICAgICBNYXRoLmNlaWwocmVuZGVyV2lkdGggKiBzY2FsZSksXG4gICAgICAgIE1hdGguY2VpbCgoaGVpZ2h0ICsgc3Ryb2tlV2lkdGgpICogc2NhbGUpKTtcbiAgICAgIGxhYmVsID0gY29udGV4dC5jYW52YXM7XG4gICAgICBsYWJlbENhY2hlLnNldChrZXksIGxhYmVsKTtcbiAgICAgIGlmIChzY2FsZSAhPSAxKSB7XG4gICAgICAgIGNvbnRleHQuc2NhbGUoc2NhbGUsIHNjYWxlKTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuZm9udCA9IHRleHRTdGF0ZS5mb250O1xuICAgICAgaWYgKHN0cm9rZUtleSkge1xuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gc3Ryb2tlU3RhdGUuc3Ryb2tlU3R5bGU7XG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gc3Ryb2tlV2lkdGg7XG4gICAgICAgIGNvbnRleHQubGluZUNhcCA9IC8qKiBAdHlwZSB7Q2FudmFzTGluZUNhcH0gKi8gKHN0cm9rZVN0YXRlLmxpbmVDYXApO1xuICAgICAgICBjb250ZXh0LmxpbmVKb2luID0gLyoqIEB0eXBlIHtDYW52YXNMaW5lSm9pbn0gKi8gKHN0cm9rZVN0YXRlLmxpbmVKb2luKTtcbiAgICAgICAgY29udGV4dC5taXRlckxpbWl0ID0gc3Ryb2tlU3RhdGUubWl0ZXJMaW1pdDtcbiAgICAgICAgaWYgKENBTlZBU19MSU5FX0RBU0ggJiYgc3Ryb2tlU3RhdGUubGluZURhc2gubGVuZ3RoKSB7XG4gICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChzdHJva2VTdGF0ZS5saW5lRGFzaCk7XG4gICAgICAgICAgY29udGV4dC5saW5lRGFzaE9mZnNldCA9IHN0cm9rZVN0YXRlLmxpbmVEYXNoT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZmlsbEtleSkge1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGZpbGxTdGF0ZS5maWxsU3R5bGU7XG4gICAgICB9XG4gICAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgY29udGV4dC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgIHZhciBsZWZ0UmlnaHQgPSAoMC41IC0gYWxpZ24pO1xuICAgICAgdmFyIHggPSBhbGlnbiAqIGxhYmVsLndpZHRoIC8gc2NhbGUgKyBsZWZ0UmlnaHQgKiBzdHJva2VXaWR0aDtcbiAgICAgIHZhciBpO1xuICAgICAgaWYgKHN0cm9rZUtleSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtTGluZXM7ICsraSkge1xuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlVGV4dChsaW5lc1tpXSwgeCArIGxlZnRSaWdodCAqIHdpZHRoc1tpXSwgMC41ICogKHN0cm9rZVdpZHRoICsgbGluZUhlaWdodCkgKyBpICogbGluZUhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmaWxsS2V5KSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1MaW5lczsgKytpKSB7XG4gICAgICAgICAgY29udGV4dC5maWxsVGV4dChsaW5lc1tpXSwgeCArIGxlZnRSaWdodCAqIHdpZHRoc1tpXSwgMC41ICogKHN0cm9rZVdpZHRoICsgbGluZUhlaWdodCkgKyBpICogbGluZUhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxhYmVsQ2FjaGUuZ2V0KGtleSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGxhYmVsIExhYmVsLlxuICAgKiBAcGFyYW0ge251bWJlcn0gYmVnaW4gQmVnaW4uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICAgKi9cbiAgQ2FudmFzVGV4dFJlcGxheS5wcm90b3R5cGUuZHJhd1RleHRJbWFnZV8gPSBmdW5jdGlvbiBkcmF3VGV4dEltYWdlXyAobGFiZWwsIGJlZ2luLCBlbmQpIHtcbiAgICB2YXIgdGV4dFN0YXRlID0gdGhpcy50ZXh0U3RhdGVfO1xuICAgIHZhciBzdHJva2VTdGF0ZSA9IHRoaXMudGV4dFN0cm9rZVN0YXRlXztcbiAgICB2YXIgcGl4ZWxSYXRpbyA9IHRoaXMucGl4ZWxSYXRpbztcbiAgICB2YXIgYWxpZ24gPSBURVhUX0FMSUdOW3RleHRTdGF0ZS50ZXh0QWxpZ24gfHwgZGVmYXVsdFRleHRBbGlnbl07XG4gICAgdmFyIGJhc2VsaW5lID0gVEVYVF9BTElHTlt0ZXh0U3RhdGUudGV4dEJhc2VsaW5lXTtcbiAgICB2YXIgc3Ryb2tlV2lkdGggPSBzdHJva2VTdGF0ZSAmJiBzdHJva2VTdGF0ZS5saW5lV2lkdGggPyBzdHJva2VTdGF0ZS5saW5lV2lkdGggOiAwO1xuXG4gICAgdmFyIGFuY2hvclggPSBhbGlnbiAqIGxhYmVsLndpZHRoIC8gcGl4ZWxSYXRpbyArIDIgKiAoMC41IC0gYWxpZ24pICogc3Ryb2tlV2lkdGg7XG4gICAgdmFyIGFuY2hvclkgPSBiYXNlbGluZSAqIGxhYmVsLmhlaWdodCAvIHBpeGVsUmF0aW8gKyAyICogKDAuNSAtIGJhc2VsaW5lKSAqIHN0cm9rZVdpZHRoO1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goW0NhbnZhc0luc3RydWN0aW9uLkRSQVdfSU1BR0UsIGJlZ2luLCBlbmQsXG4gICAgICBsYWJlbCwgKGFuY2hvclggLSB0aGlzLnRleHRPZmZzZXRYXykgKiBwaXhlbFJhdGlvLCAoYW5jaG9yWSAtIHRoaXMudGV4dE9mZnNldFlfKSAqIHBpeGVsUmF0aW8sXG4gICAgICB0aGlzLmRlY2x1dHRlckdyb3VwXywgbGFiZWwuaGVpZ2h0LCAxLCAwLCAwLCB0aGlzLnRleHRSb3RhdGVXaXRoVmlld18sIHRoaXMudGV4dFJvdGF0aW9uXyxcbiAgICAgIDEsIGxhYmVsLndpZHRoLFxuICAgICAgdGV4dFN0YXRlLnBhZGRpbmcgPT0gZGVmYXVsdFBhZGRpbmcgP1xuICAgICAgICBkZWZhdWx0UGFkZGluZyA6IHRleHRTdGF0ZS5wYWRkaW5nLm1hcChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgcmV0dXJuIHAgKiBwaXhlbFJhdGlvO1xuICAgICAgICB9KSxcbiAgICAgICEhdGV4dFN0YXRlLmJhY2tncm91bmRGaWxsLCAhIXRleHRTdGF0ZS5iYWNrZ3JvdW5kU3Ryb2tlXG4gICAgXSk7XG4gICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChbQ2FudmFzSW5zdHJ1Y3Rpb24uRFJBV19JTUFHRSwgYmVnaW4sIGVuZCxcbiAgICAgIGxhYmVsLCAoYW5jaG9yWCAtIHRoaXMudGV4dE9mZnNldFhfKSAqIHBpeGVsUmF0aW8sIChhbmNob3JZIC0gdGhpcy50ZXh0T2Zmc2V0WV8pICogcGl4ZWxSYXRpbyxcbiAgICAgIHRoaXMuZGVjbHV0dGVyR3JvdXBfLCBsYWJlbC5oZWlnaHQsIDEsIDAsIDAsIHRoaXMudGV4dFJvdGF0ZVdpdGhWaWV3XywgdGhpcy50ZXh0Um90YXRpb25fLFxuICAgICAgMSAvIHBpeGVsUmF0aW8sIGxhYmVsLndpZHRoLCB0ZXh0U3RhdGUucGFkZGluZyxcbiAgICAgICEhdGV4dFN0YXRlLmJhY2tncm91bmRGaWxsLCAhIXRleHRTdGF0ZS5iYWNrZ3JvdW5kU3Ryb2tlXG4gICAgXSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBiZWdpbiBCZWdpbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkRlY2x1dHRlckdyb3VwfSBkZWNsdXR0ZXJHcm91cCBEZWNsdXR0ZXIgZ3JvdXAuXG4gICAqL1xuICBDYW52YXNUZXh0UmVwbGF5LnByb3RvdHlwZS5kcmF3Q2hhcnNfID0gZnVuY3Rpb24gZHJhd0NoYXJzXyAoYmVnaW4sIGVuZCwgZGVjbHV0dGVyR3JvdXApIHtcbiAgICB2YXIgc3Ryb2tlU3RhdGUgPSB0aGlzLnRleHRTdHJva2VTdGF0ZV87XG4gICAgdmFyIHRleHRTdGF0ZSA9IHRoaXMudGV4dFN0YXRlXztcbiAgICB2YXIgZmlsbFN0YXRlID0gdGhpcy50ZXh0RmlsbFN0YXRlXztcblxuICAgIHZhciBzdHJva2VLZXkgPSB0aGlzLnN0cm9rZUtleV87XG4gICAgaWYgKHN0cm9rZVN0YXRlKSB7XG4gICAgICBpZiAoIShzdHJva2VLZXkgaW4gdGhpcy5zdHJva2VTdGF0ZXMpKSB7XG4gICAgICAgIHRoaXMuc3Ryb2tlU3RhdGVzW3N0cm9rZUtleV0gPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5TdHJva2VTdGF0ZX0gKi8gKHtcbiAgICAgICAgICBzdHJva2VTdHlsZTogc3Ryb2tlU3RhdGUuc3Ryb2tlU3R5bGUsXG4gICAgICAgICAgbGluZUNhcDogc3Ryb2tlU3RhdGUubGluZUNhcCxcbiAgICAgICAgICBsaW5lRGFzaE9mZnNldDogc3Ryb2tlU3RhdGUubGluZURhc2hPZmZzZXQsXG4gICAgICAgICAgbGluZVdpZHRoOiBzdHJva2VTdGF0ZS5saW5lV2lkdGgsXG4gICAgICAgICAgbGluZUpvaW46IHN0cm9rZVN0YXRlLmxpbmVKb2luLFxuICAgICAgICAgIG1pdGVyTGltaXQ6IHN0cm9rZVN0YXRlLm1pdGVyTGltaXQsXG4gICAgICAgICAgbGluZURhc2g6IHN0cm9rZVN0YXRlLmxpbmVEYXNoXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgdGV4dEtleSA9IHRoaXMudGV4dEtleV87XG4gICAgaWYgKCEodGhpcy50ZXh0S2V5XyBpbiB0aGlzLnRleHRTdGF0ZXMpKSB7XG4gICAgICB0aGlzLnRleHRTdGF0ZXNbdGhpcy50ZXh0S2V5X10gPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5UZXh0U3RhdGV9ICovICh7XG4gICAgICAgIGZvbnQ6IHRleHRTdGF0ZS5mb250LFxuICAgICAgICB0ZXh0QWxpZ246IHRleHRTdGF0ZS50ZXh0QWxpZ24gfHwgZGVmYXVsdFRleHRBbGlnbixcbiAgICAgICAgc2NhbGU6IHRleHRTdGF0ZS5zY2FsZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBmaWxsS2V5ID0gdGhpcy5maWxsS2V5XztcbiAgICBpZiAoZmlsbFN0YXRlKSB7XG4gICAgICBpZiAoIShmaWxsS2V5IGluIHRoaXMuZmlsbFN0YXRlcykpIHtcbiAgICAgICAgdGhpcy5maWxsU3RhdGVzW2ZpbGxLZXldID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRmlsbFN0YXRlfSAqLyAoe1xuICAgICAgICAgIGZpbGxTdHlsZTogZmlsbFN0YXRlLmZpbGxTdHlsZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcGl4ZWxSYXRpbyA9IHRoaXMucGl4ZWxSYXRpbztcbiAgICB2YXIgYmFzZWxpbmUgPSBURVhUX0FMSUdOW3RleHRTdGF0ZS50ZXh0QmFzZWxpbmVdO1xuXG4gICAgdmFyIG9mZnNldFkgPSB0aGlzLnRleHRPZmZzZXRZXyAqIHBpeGVsUmF0aW87XG4gICAgdmFyIHRleHQgPSB0aGlzLnRleHRfO1xuICAgIHZhciBmb250ID0gdGV4dFN0YXRlLmZvbnQ7XG4gICAgdmFyIHRleHRTY2FsZSA9IHRleHRTdGF0ZS5zY2FsZTtcbiAgICB2YXIgc3Ryb2tlV2lkdGggPSBzdHJva2VTdGF0ZSA/IHN0cm9rZVN0YXRlLmxpbmVXaWR0aCAqIHRleHRTY2FsZSAvIDIgOiAwO1xuICAgIHZhciB3aWR0aHMgPSB0aGlzLndpZHRoc19bZm9udF07XG4gICAgaWYgKCF3aWR0aHMpIHtcbiAgICAgIHRoaXMud2lkdGhzX1tmb250XSA9IHdpZHRocyA9IHt9O1xuICAgIH1cbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKFtDYW52YXNJbnN0cnVjdGlvbi5EUkFXX0NIQVJTLFxuICAgICAgYmVnaW4sIGVuZCwgYmFzZWxpbmUsIGRlY2x1dHRlckdyb3VwLFxuICAgICAgdGV4dFN0YXRlLm92ZXJmbG93LCBmaWxsS2V5LCB0ZXh0U3RhdGUubWF4QW5nbGUsXG4gICAgICBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgIHZhciB3aWR0aCA9IHdpZHRoc1t0ZXh0XTtcbiAgICAgICAgaWYgKCF3aWR0aCkge1xuICAgICAgICAgIHdpZHRoID0gd2lkdGhzW3RleHRdID0gbWVhc3VyZVRleHRXaWR0aChmb250LCB0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2lkdGggKiB0ZXh0U2NhbGUgKiBwaXhlbFJhdGlvO1xuICAgICAgfSxcbiAgICAgIG9mZnNldFksIHN0cm9rZUtleSwgc3Ryb2tlV2lkdGggKiBwaXhlbFJhdGlvLCB0ZXh0LCB0ZXh0S2V5LCAxXG4gICAgXSk7XG4gICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChbQ2FudmFzSW5zdHJ1Y3Rpb24uRFJBV19DSEFSUyxcbiAgICAgIGJlZ2luLCBlbmQsIGJhc2VsaW5lLCBkZWNsdXR0ZXJHcm91cCxcbiAgICAgIHRleHRTdGF0ZS5vdmVyZmxvdywgZmlsbEtleSwgdGV4dFN0YXRlLm1heEFuZ2xlLFxuICAgICAgZnVuY3Rpb24odGV4dCkge1xuICAgICAgICB2YXIgd2lkdGggPSB3aWR0aHNbdGV4dF07XG4gICAgICAgIGlmICghd2lkdGgpIHtcbiAgICAgICAgICB3aWR0aCA9IHdpZHRoc1t0ZXh0XSA9IG1lYXN1cmVUZXh0V2lkdGgoZm9udCwgdGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdpZHRoICogdGV4dFNjYWxlO1xuICAgICAgfSxcbiAgICAgIG9mZnNldFksIHN0cm9rZUtleSwgc3Ryb2tlV2lkdGgsIHRleHQsIHRleHRLZXksIDEgLyBwaXhlbFJhdGlvXG4gICAgXSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNUZXh0UmVwbGF5LnByb3RvdHlwZS5zZXRUZXh0U3R5bGUgPSBmdW5jdGlvbiBzZXRUZXh0U3R5bGUgKHRleHRTdHlsZSwgZGVjbHV0dGVyR3JvdXApIHtcbiAgICB2YXIgdGV4dFN0YXRlLCBmaWxsU3RhdGUsIHN0cm9rZVN0YXRlO1xuICAgIGlmICghdGV4dFN0eWxlKSB7XG4gICAgICB0aGlzLnRleHRfID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVjbHV0dGVyR3JvdXBfID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRGVjbHV0dGVyR3JvdXB9ICovIChkZWNsdXR0ZXJHcm91cCk7XG5cbiAgICAgIHZhciB0ZXh0RmlsbFN0eWxlID0gdGV4dFN0eWxlLmdldEZpbGwoKTtcbiAgICAgIGlmICghdGV4dEZpbGxTdHlsZSkge1xuICAgICAgICBmaWxsU3RhdGUgPSB0aGlzLnRleHRGaWxsU3RhdGVfID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpbGxTdGF0ZSA9IHRoaXMudGV4dEZpbGxTdGF0ZV87XG4gICAgICAgIGlmICghZmlsbFN0YXRlKSB7XG4gICAgICAgICAgZmlsbFN0YXRlID0gdGhpcy50ZXh0RmlsbFN0YXRlXyA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkZpbGxTdGF0ZX0gKi8gKHt9KTtcbiAgICAgICAgfVxuICAgICAgICBmaWxsU3RhdGUuZmlsbFN0eWxlID0gYXNDb2xvckxpa2UoXG4gICAgICAgICAgdGV4dEZpbGxTdHlsZS5nZXRDb2xvcigpIHx8IGRlZmF1bHRGaWxsU3R5bGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGV4dFN0cm9rZVN0eWxlID0gdGV4dFN0eWxlLmdldFN0cm9rZSgpO1xuICAgICAgaWYgKCF0ZXh0U3Ryb2tlU3R5bGUpIHtcbiAgICAgICAgc3Ryb2tlU3RhdGUgPSB0aGlzLnRleHRTdHJva2VTdGF0ZV8gPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3Ryb2tlU3RhdGUgPSB0aGlzLnRleHRTdHJva2VTdGF0ZV87XG4gICAgICAgIGlmICghc3Ryb2tlU3RhdGUpIHtcbiAgICAgICAgICBzdHJva2VTdGF0ZSA9IHRoaXMudGV4dFN0cm9rZVN0YXRlXyA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLlN0cm9rZVN0YXRlfSAqLyAoe30pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaW5lRGFzaCA9IHRleHRTdHJva2VTdHlsZS5nZXRMaW5lRGFzaCgpO1xuICAgICAgICB2YXIgbGluZURhc2hPZmZzZXQgPSB0ZXh0U3Ryb2tlU3R5bGUuZ2V0TGluZURhc2hPZmZzZXQoKTtcbiAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHRleHRTdHJva2VTdHlsZS5nZXRXaWR0aCgpO1xuICAgICAgICB2YXIgbWl0ZXJMaW1pdCA9IHRleHRTdHJva2VTdHlsZS5nZXRNaXRlckxpbWl0KCk7XG4gICAgICAgIHN0cm9rZVN0YXRlLmxpbmVDYXAgPSB0ZXh0U3Ryb2tlU3R5bGUuZ2V0TGluZUNhcCgpIHx8IGRlZmF1bHRMaW5lQ2FwO1xuICAgICAgICBzdHJva2VTdGF0ZS5saW5lRGFzaCA9IGxpbmVEYXNoID8gbGluZURhc2guc2xpY2UoKSA6IGRlZmF1bHRMaW5lRGFzaDtcbiAgICAgICAgc3Ryb2tlU3RhdGUubGluZURhc2hPZmZzZXQgPVxuICAgICAgICAgICAgbGluZURhc2hPZmZzZXQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRMaW5lRGFzaE9mZnNldCA6IGxpbmVEYXNoT2Zmc2V0O1xuICAgICAgICBzdHJva2VTdGF0ZS5saW5lSm9pbiA9IHRleHRTdHJva2VTdHlsZS5nZXRMaW5lSm9pbigpIHx8IGRlZmF1bHRMaW5lSm9pbjtcbiAgICAgICAgc3Ryb2tlU3RhdGUubGluZVdpZHRoID1cbiAgICAgICAgICAgIGxpbmVXaWR0aCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdExpbmVXaWR0aCA6IGxpbmVXaWR0aDtcbiAgICAgICAgc3Ryb2tlU3RhdGUubWl0ZXJMaW1pdCA9XG4gICAgICAgICAgICBtaXRlckxpbWl0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0TWl0ZXJMaW1pdCA6IG1pdGVyTGltaXQ7XG4gICAgICAgIHN0cm9rZVN0YXRlLnN0cm9rZVN0eWxlID0gYXNDb2xvckxpa2UoXG4gICAgICAgICAgdGV4dFN0cm9rZVN0eWxlLmdldENvbG9yKCkgfHwgZGVmYXVsdFN0cm9rZVN0eWxlKTtcbiAgICAgIH1cblxuICAgICAgdGV4dFN0YXRlID0gdGhpcy50ZXh0U3RhdGVfO1xuICAgICAgdmFyIGZvbnQgPSB0ZXh0U3R5bGUuZ2V0Rm9udCgpIHx8IGRlZmF1bHRGb250O1xuICAgICAgY2hlY2tGb250KGZvbnQpO1xuICAgICAgdmFyIHRleHRTY2FsZSA9IHRleHRTdHlsZS5nZXRTY2FsZSgpO1xuICAgICAgdGV4dFN0YXRlLm92ZXJmbG93ID0gdGV4dFN0eWxlLmdldE92ZXJmbG93KCk7XG4gICAgICB0ZXh0U3RhdGUuZm9udCA9IGZvbnQ7XG4gICAgICB0ZXh0U3RhdGUubWF4QW5nbGUgPSB0ZXh0U3R5bGUuZ2V0TWF4QW5nbGUoKTtcbiAgICAgIHRleHRTdGF0ZS5wbGFjZW1lbnQgPSB0ZXh0U3R5bGUuZ2V0UGxhY2VtZW50KCk7XG4gICAgICB0ZXh0U3RhdGUudGV4dEFsaWduID0gdGV4dFN0eWxlLmdldFRleHRBbGlnbigpO1xuICAgICAgdGV4dFN0YXRlLnRleHRCYXNlbGluZSA9IHRleHRTdHlsZS5nZXRUZXh0QmFzZWxpbmUoKSB8fCBkZWZhdWx0VGV4dEJhc2VsaW5lO1xuICAgICAgdGV4dFN0YXRlLmJhY2tncm91bmRGaWxsID0gdGV4dFN0eWxlLmdldEJhY2tncm91bmRGaWxsKCk7XG4gICAgICB0ZXh0U3RhdGUuYmFja2dyb3VuZFN0cm9rZSA9IHRleHRTdHlsZS5nZXRCYWNrZ3JvdW5kU3Ryb2tlKCk7XG4gICAgICB0ZXh0U3RhdGUucGFkZGluZyA9IHRleHRTdHlsZS5nZXRQYWRkaW5nKCkgfHwgZGVmYXVsdFBhZGRpbmc7XG4gICAgICB0ZXh0U3RhdGUuc2NhbGUgPSB0ZXh0U2NhbGUgPT09IHVuZGVmaW5lZCA/IDEgOiB0ZXh0U2NhbGU7XG5cbiAgICAgIHZhciB0ZXh0T2Zmc2V0WCA9IHRleHRTdHlsZS5nZXRPZmZzZXRYKCk7XG4gICAgICB2YXIgdGV4dE9mZnNldFkgPSB0ZXh0U3R5bGUuZ2V0T2Zmc2V0WSgpO1xuICAgICAgdmFyIHRleHRSb3RhdGVXaXRoVmlldyA9IHRleHRTdHlsZS5nZXRSb3RhdGVXaXRoVmlldygpO1xuICAgICAgdmFyIHRleHRSb3RhdGlvbiA9IHRleHRTdHlsZS5nZXRSb3RhdGlvbigpO1xuICAgICAgdGhpcy50ZXh0XyA9IHRleHRTdHlsZS5nZXRUZXh0KCkgfHwgJyc7XG4gICAgICB0aGlzLnRleHRPZmZzZXRYXyA9IHRleHRPZmZzZXRYID09PSB1bmRlZmluZWQgPyAwIDogdGV4dE9mZnNldFg7XG4gICAgICB0aGlzLnRleHRPZmZzZXRZXyA9IHRleHRPZmZzZXRZID09PSB1bmRlZmluZWQgPyAwIDogdGV4dE9mZnNldFk7XG4gICAgICB0aGlzLnRleHRSb3RhdGVXaXRoVmlld18gPSB0ZXh0Um90YXRlV2l0aFZpZXcgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogdGV4dFJvdGF0ZVdpdGhWaWV3O1xuICAgICAgdGhpcy50ZXh0Um90YXRpb25fID0gdGV4dFJvdGF0aW9uID09PSB1bmRlZmluZWQgPyAwIDogdGV4dFJvdGF0aW9uO1xuXG4gICAgICB0aGlzLnN0cm9rZUtleV8gPSBzdHJva2VTdGF0ZSA/XG4gICAgICAgICh0eXBlb2Ygc3Ryb2tlU3RhdGUuc3Ryb2tlU3R5bGUgPT0gJ3N0cmluZycgPyBzdHJva2VTdGF0ZS5zdHJva2VTdHlsZSA6IGdldFVpZChzdHJva2VTdGF0ZS5zdHJva2VTdHlsZSkpICtcbiAgICAgICAgc3Ryb2tlU3RhdGUubGluZUNhcCArIHN0cm9rZVN0YXRlLmxpbmVEYXNoT2Zmc2V0ICsgJ3wnICsgc3Ryb2tlU3RhdGUubGluZVdpZHRoICtcbiAgICAgICAgc3Ryb2tlU3RhdGUubGluZUpvaW4gKyBzdHJva2VTdGF0ZS5taXRlckxpbWl0ICsgJ1snICsgc3Ryb2tlU3RhdGUubGluZURhc2guam9pbigpICsgJ10nIDpcbiAgICAgICAgJyc7XG4gICAgICB0aGlzLnRleHRLZXlfID0gdGV4dFN0YXRlLmZvbnQgKyB0ZXh0U3RhdGUuc2NhbGUgKyAodGV4dFN0YXRlLnRleHRBbGlnbiB8fCAnPycpO1xuICAgICAgdGhpcy5maWxsS2V5XyA9IGZpbGxTdGF0ZSA/XG4gICAgICAgICh0eXBlb2YgZmlsbFN0YXRlLmZpbGxTdHlsZSA9PSAnc3RyaW5nJyA/IGZpbGxTdGF0ZS5maWxsU3R5bGUgOiAoJ3wnICsgZ2V0VWlkKGZpbGxTdGF0ZS5maWxsU3R5bGUpKSkgOlxuICAgICAgICAnJztcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIENhbnZhc1RleHRSZXBsYXk7XG59KENhbnZhc1JlcGxheSkpO1xuXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGZvbnQgRm9udCB0byB1c2UgZm9yIG1lYXN1cmluZy5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gbGluZXMgTGluZXMgdG8gbWVhc3VyZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gd2lkdGhzIEFycmF5IHdpbGwgYmUgcG9wdWxhdGVkIHdpdGggdGhlIHdpZHRocyBvZlxuICogZWFjaCBsaW5lLlxuICogQHJldHVybiB7bnVtYmVyfSBXaWR0aCBvZiB0aGUgd2hvbGUgdGV4dC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lYXN1cmVUZXh0V2lkdGhzKGZvbnQsIGxpbmVzLCB3aWR0aHMpIHtcbiAgdmFyIG51bUxpbmVzID0gbGluZXMubGVuZ3RoO1xuICB2YXIgd2lkdGggPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUxpbmVzOyArK2kpIHtcbiAgICB2YXIgY3VycmVudFdpZHRoID0gbWVhc3VyZVRleHRXaWR0aChmb250LCBsaW5lc1tpXSk7XG4gICAgd2lkdGggPSBNYXRoLm1heCh3aWR0aCwgY3VycmVudFdpZHRoKTtcbiAgICB3aWR0aHMucHVzaChjdXJyZW50V2lkdGgpO1xuICB9XG4gIHJldHVybiB3aWR0aDtcbn1cblxuXG5leHBvcnQgZGVmYXVsdCBDYW52YXNUZXh0UmVwbGF5O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1UZXh0UmVwbGF5LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXIvcmVwbGF5XG4gKi9cbmltcG9ydCBSZXBsYXlUeXBlIGZyb20gJy4vUmVwbGF5VHlwZS5qcyc7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtBcnJheTxSZXBsYXlUeXBlPn1cbiAqL1xuZXhwb3J0IHZhciBPUkRFUiA9IFtcbiAgUmVwbGF5VHlwZS5QT0xZR09OLFxuICBSZXBsYXlUeXBlLkNJUkNMRSxcbiAgUmVwbGF5VHlwZS5MSU5FX1NUUklORyxcbiAgUmVwbGF5VHlwZS5JTUFHRSxcbiAgUmVwbGF5VHlwZS5URVhULFxuICBSZXBsYXlUeXBlLkRFRkFVTFRcbl07XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIFRFWFRfQUxJR04gPSB7fTtcblRFWFRfQUxJR05bJ2xlZnQnXSA9IDA7XG5URVhUX0FMSUdOWydlbmQnXSA9IDA7XG5URVhUX0FMSUdOWydjZW50ZXInXSA9IDAuNTtcblRFWFRfQUxJR05bJ3JpZ2h0J10gPSAxO1xuVEVYVF9BTElHTlsnc3RhcnQnXSA9IDE7XG5URVhUX0FMSUdOWyd0b3AnXSA9IDA7XG5URVhUX0FMSUdOWydtaWRkbGUnXSA9IDAuNTtcblRFWFRfQUxJR05bJ2hhbmdpbmcnXSA9IDAuMjtcblRFWFRfQUxJR05bJ2FscGhhYmV0aWMnXSA9IDAuODtcblRFWFRfQUxJR05bJ2lkZW9ncmFwaGljJ10gPSAwLjg7XG5URVhUX0FMSUdOWydib3R0b20nXSA9IDE7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlcGxheS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyZXIvTGF5ZXJcbiAqL1xuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4uL3V0aWwuanMnO1xuaW1wb3J0IEltYWdlU3RhdGUgZnJvbSAnLi4vSW1hZ2VTdGF0ZS5qcyc7XG5pbXBvcnQgT2JzZXJ2YWJsZSBmcm9tICcuLi9PYnNlcnZhYmxlLmpzJztcbmltcG9ydCBUaWxlU3RhdGUgZnJvbSAnLi4vVGlsZVN0YXRlLmpzJztcbmltcG9ydCB7bGlzdGVufSBmcm9tICcuLi9ldmVudHMuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBTb3VyY2VTdGF0ZSBmcm9tICcuLi9zb3VyY2UvU3RhdGUuanMnO1xuXG52YXIgTGF5ZXJSZW5kZXJlciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKE9ic2VydmFibGUpIHtcbiAgZnVuY3Rpb24gTGF5ZXJSZW5kZXJlcihsYXllcikge1xuXG4gICAgT2JzZXJ2YWJsZS5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLmxheWVyXyA9IGxheWVyO1xuXG4gIH1cblxuICBpZiAoIE9ic2VydmFibGUgKSBMYXllclJlbmRlcmVyLl9fcHJvdG9fXyA9IE9ic2VydmFibGU7XG4gIExheWVyUmVuZGVyZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggT2JzZXJ2YWJsZSAmJiBPYnNlcnZhYmxlLnByb3RvdHlwZSApO1xuICBMYXllclJlbmRlcmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExheWVyUmVuZGVyZXI7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGZ1bmN0aW9uIHRoYXQgYWRkcyBsb2FkZWQgdGlsZXMgdG8gdGhlIHRpbGUgbG9va3VwLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3NvdXJjZS9UaWxlLmpzXCIpLmRlZmF1bHR9IHNvdXJjZSBUaWxlIHNvdXJjZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uIG9mIHRoZSB0aWxlcy5cbiAgICogQHBhcmFtIHtPYmplY3Q8bnVtYmVyLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLmRlZmF1bHQ+Pn0gdGlsZXMgTG9va3VwIG9mIGxvYWRlZCB0aWxlcyBieSB6b29tIGxldmVsLlxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbihudW1iZXIsIGltcG9ydChcIi4uL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0KTpib29sZWFufSBBIGZ1bmN0aW9uIHRoYXQgY2FuIGJlXG4gICAqICAgICBjYWxsZWQgd2l0aCBhIHpvb20gbGV2ZWwgYW5kIGEgdGlsZSByYW5nZSB0byBhZGQgbG9hZGVkIHRpbGVzIHRvIHRoZSBsb29rdXAuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIExheWVyUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUxvYWRlZFRpbGVGaW5kZXIgPSBmdW5jdGlvbiBjcmVhdGVMb2FkZWRUaWxlRmluZGVyIChzb3VyY2UsIHByb2plY3Rpb24sIHRpbGVzKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHpvb20gWm9vbSBsZXZlbC5cbiAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHR9IHRpbGVSYW5nZSBUaWxlIHJhbmdlLlxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHRpbGUgcmFuZ2UgaXMgZnVsbHkgbG9hZGVkLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbih6b29tLCB0aWxlUmFuZ2UpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5kZWZhdWx0fSB0aWxlIFRpbGUuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBjYWxsYmFjayh0aWxlKSB7XG4gICAgICAgICAgaWYgKCF0aWxlc1t6b29tXSkge1xuICAgICAgICAgICAgdGlsZXNbem9vbV0gPSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGlsZXNbem9vbV1bdGlsZS50aWxlQ29vcmQudG9TdHJpbmcoKV0gPSB0aWxlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzb3VyY2UuZm9yRWFjaExvYWRlZFRpbGUocHJvamVjdGlvbiwgem9vbSwgdGlsZVJhbmdlLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoaXRUb2xlcmFuY2UgSGl0IHRvbGVyYW5jZSBpbiBwaXhlbHMuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZSwgaW1wb3J0KFwiLi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdCk6IFR9IGNhbGxiYWNrIEZlYXR1cmUgY2FsbGJhY2suXG4gICAqIEByZXR1cm4ge1R8dm9pZH0gQ2FsbGJhY2sgcmVzdWx0LlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKi9cbiAgTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGUgPSBmdW5jdGlvbiBmb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZSAoY29vcmRpbmF0ZSwgZnJhbWVTdGF0ZSwgaGl0VG9sZXJhbmNlLCBjYWxsYmFjaykge307XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHR9IExheWVyLlxuICAgKi9cbiAgTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuZ2V0TGF5ZXIgPSBmdW5jdGlvbiBnZXRMYXllciAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGF5ZXJfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgY2hhbmdlcyBpbiBpbWFnZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdH0gZXZlbnQgSW1hZ2UgY2hhbmdlIGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuaGFuZGxlSW1hZ2VDaGFuZ2VfID0gZnVuY3Rpb24gaGFuZGxlSW1hZ2VDaGFuZ2VfIChldmVudCkge1xuICAgIHZhciBpbWFnZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vSW1hZ2UuanNcIikuZGVmYXVsdH0gKi8gKGV2ZW50LnRhcmdldCk7XG4gICAgaWYgKGltYWdlLmdldFN0YXRlKCkgPT09IEltYWdlU3RhdGUuTE9BREVEKSB7XG4gICAgICB0aGlzLnJlbmRlcklmUmVhZHlBbmRWaXNpYmxlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1BsdWdnYWJsZU1hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJcyB0aGVyZSBhIGZlYXR1cmUgYXQgdGhlIGdpdmVuIGNvb3JkaW5hdGU/XG4gICAqL1xuICBMYXllclJlbmRlcmVyLnByb3RvdHlwZS5oYXNGZWF0dXJlQXRDb29yZGluYXRlID0gZnVuY3Rpb24gaGFzRmVhdHVyZUF0Q29vcmRpbmF0ZSAoY29vcmRpbmF0ZSwgZnJhbWVTdGF0ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogTG9hZCB0aGUgaW1hZ2UgaWYgbm90IGFscmVhZHkgbG9hZGVkLCBhbmQgcmVnaXN0ZXIgdGhlIGltYWdlIGNoYW5nZVxuICAgKiBsaXN0ZW5lciBpZiBuZWVkZWQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vSW1hZ2VCYXNlLmpzXCIpLmRlZmF1bHR9IGltYWdlIEltYWdlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIGltYWdlIGlzIGFscmVhZHkgbG9hZGVkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUubG9hZEltYWdlID0gZnVuY3Rpb24gbG9hZEltYWdlIChpbWFnZSkge1xuICAgIHZhciBpbWFnZVN0YXRlID0gaW1hZ2UuZ2V0U3RhdGUoKTtcbiAgICBpZiAoaW1hZ2VTdGF0ZSAhPSBJbWFnZVN0YXRlLkxPQURFRCAmJiBpbWFnZVN0YXRlICE9IEltYWdlU3RhdGUuRVJST1IpIHtcbiAgICAgIGxpc3RlbihpbWFnZSwgRXZlbnRUeXBlLkNIQU5HRSwgdGhpcy5oYW5kbGVJbWFnZUNoYW5nZV8sIHRoaXMpO1xuICAgIH1cbiAgICBpZiAoaW1hZ2VTdGF0ZSA9PSBJbWFnZVN0YXRlLklETEUpIHtcbiAgICAgIGltYWdlLmxvYWQoKTtcbiAgICAgIGltYWdlU3RhdGUgPSBpbWFnZS5nZXRTdGF0ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gaW1hZ2VTdGF0ZSA9PSBJbWFnZVN0YXRlLkxPQURFRDtcbiAgfTtcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUucmVuZGVySWZSZWFkeUFuZFZpc2libGUgPSBmdW5jdGlvbiByZW5kZXJJZlJlYWR5QW5kVmlzaWJsZSAoKSB7XG4gICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcigpO1xuICAgIGlmIChsYXllci5nZXRWaXNpYmxlKCkgJiYgbGF5ZXIuZ2V0U291cmNlU3RhdGUoKSA9PSBTb3VyY2VTdGF0ZS5SRUFEWSkge1xuICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1BsdWdnYWJsZU1hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3NvdXJjZS9UaWxlLmpzXCIpLmRlZmF1bHR9IHRpbGVTb3VyY2UgVGlsZSBzb3VyY2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIExheWVyUmVuZGVyZXIucHJvdG90eXBlLnNjaGVkdWxlRXhwaXJlQ2FjaGUgPSBmdW5jdGlvbiBzY2hlZHVsZUV4cGlyZUNhY2hlIChmcmFtZVN0YXRlLCB0aWxlU291cmNlKSB7XG4gICAgaWYgKHRpbGVTb3VyY2UuY2FuRXhwaXJlQ2FjaGUoKSkge1xuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3NvdXJjZS9UaWxlLmpzXCIpLmRlZmF1bHR9IHRpbGVTb3VyY2UgVGlsZSBzb3VyY2UuXG4gICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1BsdWdnYWJsZU1hcC5qc1wiKS5kZWZhdWx0fSBtYXAgTWFwLlxuICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICAgICAqL1xuICAgICAgdmFyIHBvc3RSZW5kZXJGdW5jdGlvbiA9IGZ1bmN0aW9uKHRpbGVTb3VyY2UsIG1hcCwgZnJhbWVTdGF0ZSkge1xuICAgICAgICB2YXIgdGlsZVNvdXJjZUtleSA9IGdldFVpZCh0aWxlU291cmNlKTtcbiAgICAgICAgaWYgKHRpbGVTb3VyY2VLZXkgaW4gZnJhbWVTdGF0ZS51c2VkVGlsZXMpIHtcbiAgICAgICAgICB0aWxlU291cmNlLmV4cGlyZUNhY2hlKGZyYW1lU3RhdGUudmlld1N0YXRlLnByb2plY3Rpb24sXG4gICAgICAgICAgICBmcmFtZVN0YXRlLnVzZWRUaWxlc1t0aWxlU291cmNlS2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH0uYmluZChudWxsLCB0aWxlU291cmNlKTtcblxuICAgICAgZnJhbWVTdGF0ZS5wb3N0UmVuZGVyRnVuY3Rpb25zLnB1c2goXG4gICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLlBvc3RSZW5kZXJGdW5jdGlvbn0gKi8gKHBvc3RSZW5kZXJGdW5jdGlvbilcbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFPYmplY3Q8c3RyaW5nLCAhT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHQ+Pn0gdXNlZFRpbGVzIFVzZWQgdGlsZXMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc291cmNlL1RpbGUuanNcIikuZGVmYXVsdH0gdGlsZVNvdXJjZSBUaWxlIHNvdXJjZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHogWi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdH0gdGlsZVJhbmdlIFRpbGUgcmFuZ2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIExheWVyUmVuZGVyZXIucHJvdG90eXBlLnVwZGF0ZVVzZWRUaWxlcyA9IGZ1bmN0aW9uIHVwZGF0ZVVzZWRUaWxlcyAodXNlZFRpbGVzLCB0aWxlU291cmNlLCB6LCB0aWxlUmFuZ2UpIHtcbiAgICAvLyBGSVhNRSBzaG91bGQgd2UgdXNlIHRpbGVzVG9EcmF3QnlaIGluc3RlYWQ/XG4gICAgdmFyIHRpbGVTb3VyY2VLZXkgPSBnZXRVaWQodGlsZVNvdXJjZSk7XG4gICAgdmFyIHpLZXkgPSB6LnRvU3RyaW5nKCk7XG4gICAgaWYgKHRpbGVTb3VyY2VLZXkgaW4gdXNlZFRpbGVzKSB7XG4gICAgICBpZiAoektleSBpbiB1c2VkVGlsZXNbdGlsZVNvdXJjZUtleV0pIHtcbiAgICAgICAgdXNlZFRpbGVzW3RpbGVTb3VyY2VLZXldW3pLZXldLmV4dGVuZCh0aWxlUmFuZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXNlZFRpbGVzW3RpbGVTb3VyY2VLZXldW3pLZXldID0gdGlsZVJhbmdlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB1c2VkVGlsZXNbdGlsZVNvdXJjZUtleV0gPSB7fTtcbiAgICAgIHVzZWRUaWxlc1t0aWxlU291cmNlS2V5XVt6S2V5XSA9IHRpbGVSYW5nZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIE1hbmFnZSB0aWxlIHB5cmFtaWQuXG4gICAqIFRoaXMgZnVuY3Rpb24gcGVyZm9ybXMgYSBudW1iZXIgb2YgZnVuY3Rpb25zIHJlbGF0ZWQgdG8gdGhlIHRpbGVzIGF0IHRoZVxuICAgKiBjdXJyZW50IHpvb20gYW5kIGxvd2VyIHpvb20gbGV2ZWxzOlxuICAgKiAtIHJlZ2lzdGVycyBpZGxlIHRpbGVzIGluIGZyYW1lU3RhdGUud2FudGVkVGlsZXMgc28gdGhhdCB0aGV5IGFyZSBub3RcbiAgICogICBkaXNjYXJkZWQgYnkgdGhlIHRpbGUgcXVldWVcbiAgICogLSBlbnF1ZXVlcyBtaXNzaW5nIHRpbGVzXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc291cmNlL1RpbGUuanNcIikuZGVmYXVsdH0gdGlsZVNvdXJjZSBUaWxlIHNvdXJjZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSB0aWxlR3JpZCBUaWxlIGdyaWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGN1cnJlbnRaIEN1cnJlbnQgWi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHByZWxvYWQgTG9hZCBsb3cgcmVzb2x1dGlvbiB0aWxlcyB1cCB0byAncHJlbG9hZCcgbGV2ZWxzLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6IFQsIGltcG9ydChcIi4uL1RpbGUuanNcIikuZGVmYXVsdCk9fSBvcHRfdGlsZUNhbGxiYWNrIFRpbGUgY2FsbGJhY2suXG4gICAqIEBwYXJhbSB7VD19IG9wdF90aGlzIE9iamVjdCB0byB1c2UgYXMgYHRoaXNgIGluIGBvcHRfdGlsZUNhbGxiYWNrYC5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAdGVtcGxhdGUgVFxuICAgKi9cbiAgTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUubWFuYWdlVGlsZVB5cmFtaWQgPSBmdW5jdGlvbiBtYW5hZ2VUaWxlUHlyYW1pZCAoXG4gICAgZnJhbWVTdGF0ZSxcbiAgICB0aWxlU291cmNlLFxuICAgIHRpbGVHcmlkLFxuICAgIHBpeGVsUmF0aW8sXG4gICAgcHJvamVjdGlvbixcbiAgICBleHRlbnQsXG4gICAgY3VycmVudFosXG4gICAgcHJlbG9hZCxcbiAgICBvcHRfdGlsZUNhbGxiYWNrLFxuICAgIG9wdF90aGlzXG4gICkge1xuICAgIHZhciB0aWxlU291cmNlS2V5ID0gZ2V0VWlkKHRpbGVTb3VyY2UpO1xuICAgIGlmICghKHRpbGVTb3VyY2VLZXkgaW4gZnJhbWVTdGF0ZS53YW50ZWRUaWxlcykpIHtcbiAgICAgIGZyYW1lU3RhdGUud2FudGVkVGlsZXNbdGlsZVNvdXJjZUtleV0gPSB7fTtcbiAgICB9XG4gICAgdmFyIHdhbnRlZFRpbGVzID0gZnJhbWVTdGF0ZS53YW50ZWRUaWxlc1t0aWxlU291cmNlS2V5XTtcbiAgICB2YXIgdGlsZVF1ZXVlID0gZnJhbWVTdGF0ZS50aWxlUXVldWU7XG4gICAgdmFyIG1pblpvb20gPSB0aWxlR3JpZC5nZXRNaW5ab29tKCk7XG4gICAgdmFyIHRpbGUsIHRpbGVSYW5nZSwgdGlsZVJlc29sdXRpb24sIHgsIHksIHo7XG4gICAgZm9yICh6ID0gbWluWm9vbTsgeiA8PSBjdXJyZW50WjsgKyt6KSB7XG4gICAgICB0aWxlUmFuZ2UgPSB0aWxlR3JpZC5nZXRUaWxlUmFuZ2VGb3JFeHRlbnRBbmRaKGV4dGVudCwgeiwgdGlsZVJhbmdlKTtcbiAgICAgIHRpbGVSZXNvbHV0aW9uID0gdGlsZUdyaWQuZ2V0UmVzb2x1dGlvbih6KTtcbiAgICAgIGZvciAoeCA9IHRpbGVSYW5nZS5taW5YOyB4IDw9IHRpbGVSYW5nZS5tYXhYOyArK3gpIHtcbiAgICAgICAgZm9yICh5ID0gdGlsZVJhbmdlLm1pblk7IHkgPD0gdGlsZVJhbmdlLm1heFk7ICsreSkge1xuICAgICAgICAgIGlmIChjdXJyZW50WiAtIHogPD0gcHJlbG9hZCkge1xuICAgICAgICAgICAgdGlsZSA9IHRpbGVTb3VyY2UuZ2V0VGlsZSh6LCB4LCB5LCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKTtcbiAgICAgICAgICAgIGlmICh0aWxlLmdldFN0YXRlKCkgPT0gVGlsZVN0YXRlLklETEUpIHtcbiAgICAgICAgICAgICAgd2FudGVkVGlsZXNbdGlsZS5nZXRLZXkoKV0gPSB0cnVlO1xuICAgICAgICAgICAgICBpZiAoIXRpbGVRdWV1ZS5pc0tleVF1ZXVlZCh0aWxlLmdldEtleSgpKSkge1xuICAgICAgICAgICAgICAgIHRpbGVRdWV1ZS5lbnF1ZXVlKFt0aWxlLCB0aWxlU291cmNlS2V5LFxuICAgICAgICAgICAgICAgICAgdGlsZUdyaWQuZ2V0VGlsZUNvb3JkQ2VudGVyKHRpbGUudGlsZUNvb3JkKSwgdGlsZVJlc29sdXRpb25dKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdF90aWxlQ2FsbGJhY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBvcHRfdGlsZUNhbGxiYWNrLmNhbGwob3B0X3RoaXMsIHRpbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aWxlU291cmNlLnVzZVRpbGUoeiwgeCwgeSwgcHJvamVjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBMYXllclJlbmRlcmVyO1xufShPYnNlcnZhYmxlKSk7XG5cbmV4cG9ydCBkZWZhdWx0IExheWVyUmVuZGVyZXI7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxheWVyLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXJlci9NYXBcbiAqL1xuaW1wb3J0IHthYnN0cmFjdCwgZ2V0VWlkfSBmcm9tICcuLi91dGlsLmpzJztcbmltcG9ydCBEaXNwb3NhYmxlIGZyb20gJy4uL0Rpc3Bvc2FibGUuanMnO1xuaW1wb3J0IHtsaXN0ZW4sIHVubGlzdGVuQnlLZXl9IGZyb20gJy4uL2V2ZW50cy5qcyc7XG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4uL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IHtnZXRXaWR0aH0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7VFJVRX0gZnJvbSAnLi4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCB7dmlzaWJsZUF0UmVzb2x1dGlvbn0gZnJvbSAnLi4vbGF5ZXIvTGF5ZXIuanMnO1xuaW1wb3J0IHtzaGFyZWQgYXMgaWNvbkltYWdlQ2FjaGV9IGZyb20gJy4uL3N0eWxlL0ljb25JbWFnZUNhY2hlLmpzJztcbmltcG9ydCB7Y29tcG9zZSBhcyBjb21wb3NlVHJhbnNmb3JtLCBpbnZlcnQgYXMgaW52ZXJ0VHJhbnNmb3JtLCBzZXRGcm9tQXJyYXkgYXMgdHJhbnNmb3JtU2V0RnJvbUFycmF5fSBmcm9tICcuLi90cmFuc2Zvcm0uanMnO1xuXG4vKipcbiAqIEBhYnN0cmFjdFxuICovXG52YXIgTWFwUmVuZGVyZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChEaXNwb3NhYmxlKSB7XG4gIGZ1bmN0aW9uIE1hcFJlbmRlcmVyKG1hcCkge1xuICAgIERpc3Bvc2FibGUuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL1BsdWdnYWJsZU1hcC5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMubWFwXyA9IG1hcDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuL0xheWVyLmpzXCIpLmRlZmF1bHQ+fVxuICAgICAqL1xuICAgIHRoaXMubGF5ZXJSZW5kZXJlcnNfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi9ldmVudHMuanNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLmxheWVyUmVuZGVyZXJMaXN0ZW5lcnNfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTx0eXBlb2YgaW1wb3J0KFwiLi9MYXllci5qc1wiKS5kZWZhdWx0Pn1cbiAgICAgKi9cbiAgICB0aGlzLmxheWVyUmVuZGVyZXJDb25zdHJ1Y3RvcnNfID0gW107XG5cbiAgfVxuXG4gIGlmICggRGlzcG9zYWJsZSApIE1hcFJlbmRlcmVyLl9fcHJvdG9fXyA9IERpc3Bvc2FibGU7XG4gIE1hcFJlbmRlcmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIERpc3Bvc2FibGUgJiYgRGlzcG9zYWJsZS5wcm90b3R5cGUgKTtcbiAgTWFwUmVuZGVyZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWFwUmVuZGVyZXI7XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3JlbmRlci9FdmVudFR5cGUuanNcIikuZGVmYXVsdH0gdHlwZSBFdmVudCB0eXBlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1BsdWdnYWJsZU1hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKi9cbiAgTWFwUmVuZGVyZXIucHJvdG90eXBlLmRpc3BhdGNoUmVuZGVyRXZlbnQgPSBmdW5jdGlvbiBkaXNwYXRjaFJlbmRlckV2ZW50ICh0eXBlLCBmcmFtZVN0YXRlKSB7XG4gICAgYWJzdHJhY3QoKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVnaXN0ZXIgbGF5ZXIgcmVuZGVyZXIgY29uc3RydWN0b3JzLlxuICAgKiBAcGFyYW0ge0FycmF5PHR5cGVvZiBpbXBvcnQoXCIuL0xheWVyLmpzXCIpLmRlZmF1bHQ+fSBjb25zdHJ1Y3RvcnMgTGF5ZXIgcmVuZGVyZXJzLlxuICAgKi9cbiAgTWFwUmVuZGVyZXIucHJvdG90eXBlLnJlZ2lzdGVyTGF5ZXJSZW5kZXJlcnMgPSBmdW5jdGlvbiByZWdpc3RlckxheWVyUmVuZGVyZXJzIChjb25zdHJ1Y3RvcnMpIHtcbiAgICB0aGlzLmxheWVyUmVuZGVyZXJDb25zdHJ1Y3RvcnNfLnB1c2guYXBwbHkodGhpcy5sYXllclJlbmRlcmVyQ29uc3RydWN0b3JzXywgY29uc3RydWN0b3JzKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZVN0YXRlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBNYXBSZW5kZXJlci5wcm90b3R5cGUuY2FsY3VsYXRlTWF0cmljZXMyRCA9IGZ1bmN0aW9uIGNhbGN1bGF0ZU1hdHJpY2VzMkQgKGZyYW1lU3RhdGUpIHtcbiAgICB2YXIgdmlld1N0YXRlID0gZnJhbWVTdGF0ZS52aWV3U3RhdGU7XG4gICAgdmFyIGNvb3JkaW5hdGVUb1BpeGVsVHJhbnNmb3JtID0gZnJhbWVTdGF0ZS5jb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybTtcbiAgICB2YXIgcGl4ZWxUb0Nvb3JkaW5hdGVUcmFuc2Zvcm0gPSBmcmFtZVN0YXRlLnBpeGVsVG9Db29yZGluYXRlVHJhbnNmb3JtO1xuXG4gICAgY29tcG9zZVRyYW5zZm9ybShjb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybSxcbiAgICAgIGZyYW1lU3RhdGUuc2l6ZVswXSAvIDIsIGZyYW1lU3RhdGUuc2l6ZVsxXSAvIDIsXG4gICAgICAxIC8gdmlld1N0YXRlLnJlc29sdXRpb24sIC0xIC8gdmlld1N0YXRlLnJlc29sdXRpb24sXG4gICAgICAtdmlld1N0YXRlLnJvdGF0aW9uLFxuICAgICAgLXZpZXdTdGF0ZS5jZW50ZXJbMF0sIC12aWV3U3RhdGUuY2VudGVyWzFdKTtcblxuICAgIGludmVydFRyYW5zZm9ybShcbiAgICAgIHRyYW5zZm9ybVNldEZyb21BcnJheShwaXhlbFRvQ29vcmRpbmF0ZVRyYW5zZm9ybSwgY29vcmRpbmF0ZVRvUGl4ZWxUcmFuc2Zvcm0pKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgbGF5ZXIgcmVuZGVyZXJzLlxuICAgKi9cbiAgTWFwUmVuZGVyZXIucHJvdG90eXBlLnJlbW92ZUxheWVyUmVuZGVyZXJzID0gZnVuY3Rpb24gcmVtb3ZlTGF5ZXJSZW5kZXJlcnMgKCkge1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmxheWVyUmVuZGVyZXJzXykge1xuICAgICAgdGhpcy5yZW1vdmVMYXllclJlbmRlcmVyQnlLZXlfKGtleSkuZGlzcG9zZSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZVN0YXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaGl0VG9sZXJhbmNlIEhpdCB0b2xlcmFuY2UgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6IFMsIGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2UsXG4gICAqICAgICBpbXBvcnQoXCIuLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0KTogVH0gY2FsbGJhY2sgRmVhdHVyZSBjYWxsYmFjay5cbiAgICogQHBhcmFtIHtTfSB0aGlzQXJnIFZhbHVlIHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgYGNhbGxiYWNrYC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBVLCBpbXBvcnQoXCIuLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0KTogYm9vbGVhbn0gbGF5ZXJGaWx0ZXIgTGF5ZXIgZmlsdGVyXG4gICAqICAgICBmdW5jdGlvbiwgb25seSBsYXllcnMgd2hpY2ggYXJlIHZpc2libGUgYW5kIGZvciB3aGljaCB0aGlzIGZ1bmN0aW9uXG4gICAqICAgICByZXR1cm5zIGB0cnVlYCB3aWxsIGJlIHRlc3RlZCBmb3IgZmVhdHVyZXMuICBCeSBkZWZhdWx0LCBhbGwgdmlzaWJsZVxuICAgKiAgICAgbGF5ZXJzIHdpbGwgYmUgdGVzdGVkLlxuICAgKiBAcGFyYW0ge1V9IHRoaXNBcmcyIFZhbHVlIHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgYGxheWVyRmlsdGVyYC5cbiAgICogQHJldHVybiB7VHx1bmRlZmluZWR9IENhbGxiYWNrIHJlc3VsdC5cbiAgICogQHRlbXBsYXRlIFMsVCxVXG4gICAqL1xuICBNYXBSZW5kZXJlci5wcm90b3R5cGUuZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGUgPSBmdW5jdGlvbiBmb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZSAoXG4gICAgY29vcmRpbmF0ZSxcbiAgICBmcmFtZVN0YXRlLFxuICAgIGhpdFRvbGVyYW5jZSxcbiAgICBjYWxsYmFjayxcbiAgICB0aGlzQXJnLFxuICAgIGxheWVyRmlsdGVyLFxuICAgIHRoaXNBcmcyXG4gICkge1xuICAgIHZhciByZXN1bHQ7XG4gICAgdmFyIHZpZXdTdGF0ZSA9IGZyYW1lU3RhdGUudmlld1N0YXRlO1xuICAgIHZhciB2aWV3UmVzb2x1dGlvbiA9IHZpZXdTdGF0ZS5yZXNvbHV0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0fSBsYXllciBMYXllci5cbiAgICAgKiBAcmV0dXJuIHs/fSBDYWxsYmFjayByZXN1bHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGUoZmVhdHVyZSwgbGF5ZXIpIHtcbiAgICAgIHZhciBtYW5hZ2VkID0gZnJhbWVTdGF0ZS5sYXllclN0YXRlc1tnZXRVaWQobGF5ZXIpXS5tYW5hZ2VkO1xuICAgICAgaWYgKCEoZ2V0VWlkKGZlYXR1cmUpIGluIGZyYW1lU3RhdGUuc2tpcHBlZEZlYXR1cmVVaWRzICYmICFtYW5hZ2VkKSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzQXJnLCBmZWF0dXJlLCBtYW5hZ2VkID8gbGF5ZXIgOiBudWxsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJvamVjdGlvbiA9IHZpZXdTdGF0ZS5wcm9qZWN0aW9uO1xuXG4gICAgdmFyIHRyYW5zbGF0ZWRDb29yZGluYXRlID0gY29vcmRpbmF0ZTtcbiAgICBpZiAocHJvamVjdGlvbi5jYW5XcmFwWCgpKSB7XG4gICAgICB2YXIgcHJvamVjdGlvbkV4dGVudCA9IHByb2plY3Rpb24uZ2V0RXh0ZW50KCk7XG4gICAgICB2YXIgd29ybGRXaWR0aCA9IGdldFdpZHRoKHByb2plY3Rpb25FeHRlbnQpO1xuICAgICAgdmFyIHggPSBjb29yZGluYXRlWzBdO1xuICAgICAgaWYgKHggPCBwcm9qZWN0aW9uRXh0ZW50WzBdIHx8IHggPiBwcm9qZWN0aW9uRXh0ZW50WzJdKSB7XG4gICAgICAgIHZhciB3b3JsZHNBd2F5ID0gTWF0aC5jZWlsKChwcm9qZWN0aW9uRXh0ZW50WzBdIC0geCkgLyB3b3JsZFdpZHRoKTtcbiAgICAgICAgdHJhbnNsYXRlZENvb3JkaW5hdGUgPSBbeCArIHdvcmxkV2lkdGggKiB3b3JsZHNBd2F5LCBjb29yZGluYXRlWzFdXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGF5ZXJTdGF0ZXMgPSBmcmFtZVN0YXRlLmxheWVyU3RhdGVzQXJyYXk7XG4gICAgdmFyIG51bUxheWVycyA9IGxheWVyU3RhdGVzLmxlbmd0aDtcbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgPSBudW1MYXllcnMgLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdmFyIGxheWVyU3RhdGUgPSBsYXllclN0YXRlc1tpXTtcbiAgICAgIHZhciBsYXllciA9IGxheWVyU3RhdGUubGF5ZXI7XG4gICAgICBpZiAodmlzaWJsZUF0UmVzb2x1dGlvbihsYXllclN0YXRlLCB2aWV3UmVzb2x1dGlvbikgJiYgbGF5ZXJGaWx0ZXIuY2FsbCh0aGlzQXJnMiwgbGF5ZXIpKSB7XG4gICAgICAgIHZhciBsYXllclJlbmRlcmVyID0gdGhpcy5nZXRMYXllclJlbmRlcmVyKGxheWVyKTtcbiAgICAgICAgdmFyIHNvdXJjZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdH0gKi8gKGxheWVyKS5nZXRTb3VyY2UoKTtcbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgIHJlc3VsdCA9IGxheWVyUmVuZGVyZXIuZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGUoXG4gICAgICAgICAgICBzb3VyY2UuZ2V0V3JhcFgoKSA/IHRyYW5zbGF0ZWRDb29yZGluYXRlIDogY29vcmRpbmF0ZSxcbiAgICAgICAgICAgIGZyYW1lU3RhdGUsIGhpdFRvbGVyYW5jZSwgZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsfSBwaXhlbCBQaXhlbC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZVN0YXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaGl0VG9sZXJhbmNlIEhpdCB0b2xlcmFuY2UgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6IFMsIGltcG9ydChcIi4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHQsIChVaW50OENsYW1wZWRBcnJheXxVaW50OEFycmF5KSk6IFR9IGNhbGxiYWNrIExheWVyXG4gICAqICAgICBjYWxsYmFjay5cbiAgICogQHBhcmFtIHtTfSB0aGlzQXJnIFZhbHVlIHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgYGNhbGxiYWNrYC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBVLCBpbXBvcnQoXCIuLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0KTogYm9vbGVhbn0gbGF5ZXJGaWx0ZXIgTGF5ZXIgZmlsdGVyXG4gICAqICAgICBmdW5jdGlvbiwgb25seSBsYXllcnMgd2hpY2ggYXJlIHZpc2libGUgYW5kIGZvciB3aGljaCB0aGlzIGZ1bmN0aW9uXG4gICAqICAgICByZXR1cm5zIGB0cnVlYCB3aWxsIGJlIHRlc3RlZCBmb3IgZmVhdHVyZXMuICBCeSBkZWZhdWx0LCBhbGwgdmlzaWJsZVxuICAgKiAgICAgbGF5ZXJzIHdpbGwgYmUgdGVzdGVkLlxuICAgKiBAcGFyYW0ge1V9IHRoaXNBcmcyIFZhbHVlIHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgYGxheWVyRmlsdGVyYC5cbiAgICogQHJldHVybiB7VHx1bmRlZmluZWR9IENhbGxiYWNrIHJlc3VsdC5cbiAgICogQHRlbXBsYXRlIFMsVCxVXG4gICAqL1xuICBNYXBSZW5kZXJlci5wcm90b3R5cGUuZm9yRWFjaExheWVyQXRQaXhlbCA9IGZ1bmN0aW9uIGZvckVhY2hMYXllckF0UGl4ZWwgKHBpeGVsLCBmcmFtZVN0YXRlLCBoaXRUb2xlcmFuY2UsIGNhbGxiYWNrLCB0aGlzQXJnLCBsYXllckZpbHRlciwgdGhpc0FyZzIpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZVN0YXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaGl0VG9sZXJhbmNlIEhpdCB0b2xlcmFuY2UgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6IFUsIGltcG9ydChcIi4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHQpOiBib29sZWFufSBsYXllckZpbHRlciBMYXllciBmaWx0ZXJcbiAgICogICAgIGZ1bmN0aW9uLCBvbmx5IGxheWVycyB3aGljaCBhcmUgdmlzaWJsZSBhbmQgZm9yIHdoaWNoIHRoaXMgZnVuY3Rpb25cbiAgICogICAgIHJldHVybnMgYHRydWVgIHdpbGwgYmUgdGVzdGVkIGZvciBmZWF0dXJlcy4gIEJ5IGRlZmF1bHQsIGFsbCB2aXNpYmxlXG4gICAqICAgICBsYXllcnMgd2lsbCBiZSB0ZXN0ZWQuXG4gICAqIEBwYXJhbSB7VX0gdGhpc0FyZyBWYWx1ZSB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIGBsYXllckZpbHRlcmAuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIHRoZXJlIGEgZmVhdHVyZSBhdCB0aGUgZ2l2ZW4gY29vcmRpbmF0ZT9cbiAgICogQHRlbXBsYXRlIFVcbiAgICovXG4gIE1hcFJlbmRlcmVyLnByb3RvdHlwZS5oYXNGZWF0dXJlQXRDb29yZGluYXRlID0gZnVuY3Rpb24gaGFzRmVhdHVyZUF0Q29vcmRpbmF0ZSAoY29vcmRpbmF0ZSwgZnJhbWVTdGF0ZSwgaGl0VG9sZXJhbmNlLCBsYXllckZpbHRlciwgdGhpc0FyZykge1xuICAgIHZhciBoYXNGZWF0dXJlID0gdGhpcy5mb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZShcbiAgICAgIGNvb3JkaW5hdGUsIGZyYW1lU3RhdGUsIGhpdFRvbGVyYW5jZSwgVFJVRSwgdGhpcywgbGF5ZXJGaWx0ZXIsIHRoaXNBcmcpO1xuXG4gICAgcmV0dXJuIGhhc0ZlYXR1cmUgIT09IHVuZGVmaW5lZDtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9sYXllci9CYXNlLmpzXCIpLmRlZmF1bHR9IGxheWVyIExheWVyLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vTGF5ZXIuanNcIikuZGVmYXVsdH0gTGF5ZXIgcmVuZGVyZXIuXG4gICAqL1xuICBNYXBSZW5kZXJlci5wcm90b3R5cGUuZ2V0TGF5ZXJSZW5kZXJlciA9IGZ1bmN0aW9uIGdldExheWVyUmVuZGVyZXIgKGxheWVyKSB7XG4gICAgdmFyIGxheWVyS2V5ID0gZ2V0VWlkKGxheWVyKTtcbiAgICBpZiAobGF5ZXJLZXkgaW4gdGhpcy5sYXllclJlbmRlcmVyc18pIHtcbiAgICAgIHJldHVybiB0aGlzLmxheWVyUmVuZGVyZXJzX1tsYXllcktleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZW5kZXJlcjtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHRoaXMubGF5ZXJSZW5kZXJlckNvbnN0cnVjdG9yc18ubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdGhpcy5sYXllclJlbmRlcmVyQ29uc3RydWN0b3JzX1tpXTtcbiAgICAgICAgaWYgKGNhbmRpZGF0ZVsnaGFuZGxlcyddKGxheWVyKSkge1xuICAgICAgICAgIHJlbmRlcmVyID0gY2FuZGlkYXRlWydjcmVhdGUnXSh0aGlzLCBsYXllcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZW5kZXJlcikge1xuICAgICAgICB0aGlzLmxheWVyUmVuZGVyZXJzX1tsYXllcktleV0gPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5sYXllclJlbmRlcmVyTGlzdGVuZXJzX1tsYXllcktleV0gPSBsaXN0ZW4ocmVuZGVyZXIsXG4gICAgICAgICAgRXZlbnRUeXBlLkNIQU5HRSwgdGhpcy5oYW5kbGVMYXllclJlbmRlcmVyQ2hhbmdlXywgdGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBjcmVhdGUgcmVuZGVyZXIgZm9yIGxheWVyOiAnICsgbGF5ZXIuZ2V0VHlwZSgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZW5kZXJlcjtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllcktleSBMYXllciBrZXkuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9MYXllci5qc1wiKS5kZWZhdWx0fSBMYXllciByZW5kZXJlci5cbiAgICovXG4gIE1hcFJlbmRlcmVyLnByb3RvdHlwZS5nZXRMYXllclJlbmRlcmVyQnlLZXkgPSBmdW5jdGlvbiBnZXRMYXllclJlbmRlcmVyQnlLZXkgKGxheWVyS2V5KSB7XG4gICAgcmV0dXJuIHRoaXMubGF5ZXJSZW5kZXJlcnNfW2xheWVyS2V5XTtcbiAgfTtcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuL0xheWVyLmpzXCIpLmRlZmF1bHQ+fSBMYXllciByZW5kZXJlcnMuXG4gICAqL1xuICBNYXBSZW5kZXJlci5wcm90b3R5cGUuZ2V0TGF5ZXJSZW5kZXJlcnMgPSBmdW5jdGlvbiBnZXRMYXllclJlbmRlcmVycyAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGF5ZXJSZW5kZXJlcnNfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuZGVmYXVsdH0gTWFwLlxuICAgKi9cbiAgTWFwUmVuZGVyZXIucHJvdG90eXBlLmdldE1hcCA9IGZ1bmN0aW9uIGdldE1hcCAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwXztcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGNoYW5nZXMgaW4gYSBsYXllciByZW5kZXJlci5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIE1hcFJlbmRlcmVyLnByb3RvdHlwZS5oYW5kbGVMYXllclJlbmRlcmVyQ2hhbmdlXyA9IGZ1bmN0aW9uIGhhbmRsZUxheWVyUmVuZGVyZXJDaGFuZ2VfICgpIHtcbiAgICB0aGlzLm1hcF8ucmVuZGVyKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllcktleSBMYXllciBrZXkuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vTGF5ZXIuanNcIikuZGVmYXVsdH0gTGF5ZXIgcmVuZGVyZXIuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBNYXBSZW5kZXJlci5wcm90b3R5cGUucmVtb3ZlTGF5ZXJSZW5kZXJlckJ5S2V5XyA9IGZ1bmN0aW9uIHJlbW92ZUxheWVyUmVuZGVyZXJCeUtleV8gKGxheWVyS2V5KSB7XG4gICAgdmFyIGxheWVyUmVuZGVyZXIgPSB0aGlzLmxheWVyUmVuZGVyZXJzX1tsYXllcktleV07XG4gICAgZGVsZXRlIHRoaXMubGF5ZXJSZW5kZXJlcnNfW2xheWVyS2V5XTtcblxuICAgIHVubGlzdGVuQnlLZXkodGhpcy5sYXllclJlbmRlcmVyTGlzdGVuZXJzX1tsYXllcktleV0pO1xuICAgIGRlbGV0ZSB0aGlzLmxheWVyUmVuZGVyZXJMaXN0ZW5lcnNfW2xheWVyS2V5XTtcblxuICAgIHJldHVybiBsYXllclJlbmRlcmVyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1BsdWdnYWJsZU1hcC5qc1wiKS5kZWZhdWx0fSBtYXAgTWFwLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1BsdWdnYWJsZU1hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTWFwUmVuZGVyZXIucHJvdG90eXBlLnJlbW92ZVVudXNlZExheWVyUmVuZGVyZXJzXyA9IGZ1bmN0aW9uIHJlbW92ZVVudXNlZExheWVyUmVuZGVyZXJzXyAobWFwLCBmcmFtZVN0YXRlKSB7XG4gICAgZm9yICh2YXIgbGF5ZXJLZXkgaW4gdGhpcy5sYXllclJlbmRlcmVyc18pIHtcbiAgICAgIGlmICghZnJhbWVTdGF0ZSB8fCAhKGxheWVyS2V5IGluIGZyYW1lU3RhdGUubGF5ZXJTdGF0ZXMpKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGF5ZXJSZW5kZXJlckJ5S2V5XyhsYXllcktleSkuZGlzcG9zZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVyLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHs/aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqL1xuICBNYXBSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiByZW5kZXJGcmFtZSAoZnJhbWVTdGF0ZSkge1xuICAgIGFic3RyYWN0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIE1hcFJlbmRlcmVyLnByb3RvdHlwZS5zY2hlZHVsZUV4cGlyZUljb25DYWNoZSA9IGZ1bmN0aW9uIHNjaGVkdWxlRXhwaXJlSWNvbkNhY2hlIChmcmFtZVN0YXRlKSB7XG4gICAgZnJhbWVTdGF0ZS5wb3N0UmVuZGVyRnVuY3Rpb25zLnB1c2goLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuUG9zdFJlbmRlckZ1bmN0aW9ufSAqLyAoZXhwaXJlSWNvbkNhY2hlKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IWltcG9ydChcIi4uL1BsdWdnYWJsZU1hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBNYXBSZW5kZXJlci5wcm90b3R5cGUuc2NoZWR1bGVSZW1vdmVVbnVzZWRMYXllclJlbmRlcmVycyA9IGZ1bmN0aW9uIHNjaGVkdWxlUmVtb3ZlVW51c2VkTGF5ZXJSZW5kZXJlcnMgKGZyYW1lU3RhdGUpIHtcbiAgICBmb3IgKHZhciBsYXllcktleSBpbiB0aGlzLmxheWVyUmVuZGVyZXJzXykge1xuICAgICAgaWYgKCEobGF5ZXJLZXkgaW4gZnJhbWVTdGF0ZS5sYXllclN0YXRlcykpIHtcbiAgICAgICAgZnJhbWVTdGF0ZS5wb3N0UmVuZGVyRnVuY3Rpb25zLnB1c2goXG4gICAgICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuUG9zdFJlbmRlckZ1bmN0aW9ufSAqLyAodGhpcy5yZW1vdmVVbnVzZWRMYXllclJlbmRlcmVyc18uYmluZCh0aGlzKSlcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gTWFwUmVuZGVyZXI7XG59KERpc3Bvc2FibGUpKTtcblxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLmRlZmF1bHR9IG1hcCBNYXAuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL1BsdWdnYWJsZU1hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICovXG5mdW5jdGlvbiBleHBpcmVJY29uQ2FjaGUobWFwLCBmcmFtZVN0YXRlKSB7XG4gIGljb25JbWFnZUNhY2hlLmV4cGlyZSgpO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9sYXllci9MYXllci5qc1wiKS5TdGF0ZX0gc3RhdGUxIEZpcnN0IGxheWVyIHN0YXRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9sYXllci9MYXllci5qc1wiKS5TdGF0ZX0gc3RhdGUyIFNlY29uZCBsYXllciBzdGF0ZS5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHpJbmRleCBkaWZmZXJlbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc29ydEJ5WkluZGV4KHN0YXRlMSwgc3RhdGUyKSB7XG4gIHJldHVybiBzdGF0ZTEuekluZGV4IC0gc3RhdGUyLnpJbmRleDtcbn1cbmV4cG9ydCBkZWZhdWx0IE1hcFJlbmRlcmVyO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXAuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlcmVyL2NhbnZhcy9JbWFnZUxheWVyXG4gKi9cbmltcG9ydCB7RU5BQkxFX1JBU1RFUl9SRVBST0pFQ1RJT059IGZyb20gJy4uLy4uL3JlcHJvai9jb21tb24uanMnO1xuaW1wb3J0IEltYWdlQ2FudmFzIGZyb20gJy4uLy4uL0ltYWdlQ2FudmFzLmpzJztcbmltcG9ydCBMYXllclR5cGUgZnJvbSAnLi4vLi4vTGF5ZXJUeXBlLmpzJztcbmltcG9ydCBWaWV3SGludCBmcm9tICcuLi8uLi9WaWV3SGludC5qcyc7XG5pbXBvcnQge2VxdWFsc30gZnJvbSAnLi4vLi4vYXJyYXkuanMnO1xuaW1wb3J0IHtnZXRIZWlnaHQsIGdldEludGVyc2VjdGlvbiwgZ2V0V2lkdGgsIGlzRW1wdHl9IGZyb20gJy4uLy4uL2V4dGVudC5qcyc7XG5pbXBvcnQgVmVjdG9yUmVuZGVyVHlwZSBmcm9tICcuLi8uLi9sYXllci9WZWN0b3JSZW5kZXJUeXBlLmpzJztcbmltcG9ydCB7YXNzaWdufSBmcm9tICcuLi8uLi9vYmouanMnO1xuaW1wb3J0IHtsYXllclJlbmRlcmVyQ29uc3RydWN0b3JzfSBmcm9tICcuL01hcC5qcyc7XG5pbXBvcnQgSW50ZXJtZWRpYXRlQ2FudmFzUmVuZGVyZXIgZnJvbSAnLi9JbnRlcm1lZGlhdGVDYW52YXMuanMnO1xuaW1wb3J0IHtjcmVhdGUgYXMgY3JlYXRlVHJhbnNmb3JtLCBjb21wb3NlIGFzIGNvbXBvc2VUcmFuc2Zvcm19IGZyb20gJy4uLy4uL3RyYW5zZm9ybS5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQ2FudmFzIHJlbmRlcmVyIGZvciBpbWFnZSBsYXllcnMuXG4gKiBAYXBpXG4gKi9cbnZhciBDYW52YXNJbWFnZUxheWVyUmVuZGVyZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChJbnRlcm1lZGlhdGVDYW52YXNSZW5kZXJlcikge1xuICBmdW5jdGlvbiBDYW52YXNJbWFnZUxheWVyUmVuZGVyZXIoaW1hZ2VMYXllcikge1xuXG4gICAgSW50ZXJtZWRpYXRlQ2FudmFzUmVuZGVyZXIuY2FsbCh0aGlzLCBpbWFnZUxheWVyKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuLi8uLi9JbWFnZUJhc2UuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VUcmFuc2Zvcm1fID0gY3JlYXRlVHJhbnNmb3JtKCk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IUFycmF5PHN0cmluZz59XG4gICAgICovXG4gICAgdGhpcy5za2lwcGVkRmVhdHVyZXNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL1ZlY3RvckxheWVyLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy52ZWN0b3JSZW5kZXJlcl8gPSBudWxsO1xuXG4gICAgaWYgKGltYWdlTGF5ZXIuZ2V0VHlwZSgpID09PSBMYXllclR5cGUuVkVDVE9SKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBsYXllclJlbmRlcmVyQ29uc3RydWN0b3JzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgdmFyIGN0b3IgPSBsYXllclJlbmRlcmVyQ29uc3RydWN0b3JzW2ldO1xuICAgICAgICBpZiAoY3RvciAhPT0gQ2FudmFzSW1hZ2VMYXllclJlbmRlcmVyICYmIGN0b3JbJ2hhbmRsZXMnXShpbWFnZUxheWVyKSkge1xuICAgICAgICAgIHRoaXMudmVjdG9yUmVuZGVyZXJfID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL1ZlY3RvckxheWVyLmpzXCIpLmRlZmF1bHR9ICovIChuZXcgY3RvcihpbWFnZUxheWVyKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuXG4gIGlmICggSW50ZXJtZWRpYXRlQ2FudmFzUmVuZGVyZXIgKSBDYW52YXNJbWFnZUxheWVyUmVuZGVyZXIuX19wcm90b19fID0gSW50ZXJtZWRpYXRlQ2FudmFzUmVuZGVyZXI7XG4gIENhbnZhc0ltYWdlTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbnRlcm1lZGlhdGVDYW52YXNSZW5kZXJlciAmJiBJbnRlcm1lZGlhdGVDYW52YXNSZW5kZXJlci5wcm90b3R5cGUgKTtcbiAgQ2FudmFzSW1hZ2VMYXllclJlbmRlcmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhbnZhc0ltYWdlTGF5ZXJSZW5kZXJlcjtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENhbnZhc0ltYWdlTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuZGlzcG9zZUludGVybmFsID0gZnVuY3Rpb24gZGlzcG9zZUludGVybmFsICgpIHtcbiAgICBpZiAodGhpcy52ZWN0b3JSZW5kZXJlcl8pIHtcbiAgICAgIHRoaXMudmVjdG9yUmVuZGVyZXJfLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgSW50ZXJtZWRpYXRlQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmRpc3Bvc2VJbnRlcm5hbC5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQ2FudmFzSW1hZ2VMYXllclJlbmRlcmVyLnByb3RvdHlwZS5nZXRJbWFnZSA9IGZ1bmN0aW9uIGdldEltYWdlICgpIHtcbiAgICByZXR1cm4gIXRoaXMuaW1hZ2VfID8gbnVsbCA6IHRoaXMuaW1hZ2VfLmdldEltYWdlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNJbWFnZUxheWVyUmVuZGVyZXIucHJvdG90eXBlLmdldEltYWdlVHJhbnNmb3JtID0gZnVuY3Rpb24gZ2V0SW1hZ2VUcmFuc2Zvcm0gKCkge1xuICAgIHJldHVybiB0aGlzLmltYWdlVHJhbnNmb3JtXztcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENhbnZhc0ltYWdlTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUucHJlcGFyZUZyYW1lID0gZnVuY3Rpb24gcHJlcGFyZUZyYW1lIChmcmFtZVN0YXRlLCBsYXllclN0YXRlKSB7XG5cbiAgICB2YXIgcGl4ZWxSYXRpbyA9IGZyYW1lU3RhdGUucGl4ZWxSYXRpbztcbiAgICB2YXIgc2l6ZSA9IGZyYW1lU3RhdGUuc2l6ZTtcbiAgICB2YXIgdmlld1N0YXRlID0gZnJhbWVTdGF0ZS52aWV3U3RhdGU7XG4gICAgdmFyIHZpZXdDZW50ZXIgPSB2aWV3U3RhdGUuY2VudGVyO1xuICAgIHZhciB2aWV3UmVzb2x1dGlvbiA9IHZpZXdTdGF0ZS5yZXNvbHV0aW9uO1xuXG4gICAgdmFyIGltYWdlO1xuICAgIHZhciBpbWFnZUxheWVyID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9sYXllci9JbWFnZS5qc1wiKS5kZWZhdWx0fSAqLyAodGhpcy5nZXRMYXllcigpKTtcbiAgICB2YXIgaW1hZ2VTb3VyY2UgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL3NvdXJjZS9JbWFnZS5qc1wiKS5kZWZhdWx0fSAqLyAoaW1hZ2VMYXllci5nZXRTb3VyY2UoKSk7XG5cbiAgICB2YXIgaGludHMgPSBmcmFtZVN0YXRlLnZpZXdIaW50cztcblxuICAgIHZhciB2ZWN0b3JSZW5kZXJlciA9IHRoaXMudmVjdG9yUmVuZGVyZXJfO1xuICAgIHZhciByZW5kZXJlZEV4dGVudCA9IGZyYW1lU3RhdGUuZXh0ZW50O1xuICAgIGlmICghdmVjdG9yUmVuZGVyZXIgJiYgbGF5ZXJTdGF0ZS5leHRlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVuZGVyZWRFeHRlbnQgPSBnZXRJbnRlcnNlY3Rpb24ocmVuZGVyZWRFeHRlbnQsIGxheWVyU3RhdGUuZXh0ZW50KTtcbiAgICB9XG5cbiAgICBpZiAoIWhpbnRzW1ZpZXdIaW50LkFOSU1BVElOR10gJiYgIWhpbnRzW1ZpZXdIaW50LklOVEVSQUNUSU5HXSAmJlxuICAgICAgICAhaXNFbXB0eShyZW5kZXJlZEV4dGVudCkpIHtcbiAgICAgIHZhciBwcm9qZWN0aW9uID0gdmlld1N0YXRlLnByb2plY3Rpb247XG4gICAgICBpZiAoIUVOQUJMRV9SQVNURVJfUkVQUk9KRUNUSU9OKSB7XG4gICAgICAgIHZhciBzb3VyY2VQcm9qZWN0aW9uID0gaW1hZ2VTb3VyY2UuZ2V0UHJvamVjdGlvbigpO1xuICAgICAgICBpZiAoc291cmNlUHJvamVjdGlvbikge1xuICAgICAgICAgIHByb2plY3Rpb24gPSBzb3VyY2VQcm9qZWN0aW9uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgc2tpcHBlZEZlYXR1cmVzID0gdGhpcy5za2lwcGVkRmVhdHVyZXNfO1xuICAgICAgaWYgKHZlY3RvclJlbmRlcmVyKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdmVjdG9yUmVuZGVyZXIuY29udGV4dDtcbiAgICAgICAgdmFyIGltYWdlRnJhbWVTdGF0ZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLkZyYW1lU3RhdGV9ICovIChhc3NpZ24oe30sIGZyYW1lU3RhdGUsIHtcbiAgICAgICAgICBzaXplOiBbXG4gICAgICAgICAgICBnZXRXaWR0aChyZW5kZXJlZEV4dGVudCkgLyB2aWV3UmVzb2x1dGlvbixcbiAgICAgICAgICAgIGdldEhlaWdodChyZW5kZXJlZEV4dGVudCkgLyB2aWV3UmVzb2x1dGlvblxuICAgICAgICAgIF0sXG4gICAgICAgICAgdmlld1N0YXRlOiAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL1ZpZXcuanNcIikuU3RhdGV9ICovIChhc3NpZ24oe30sIGZyYW1lU3RhdGUudmlld1N0YXRlLCB7XG4gICAgICAgICAgICByb3RhdGlvbjogMFxuICAgICAgICAgIH0pKVxuICAgICAgICB9KSk7XG4gICAgICAgIHZhciBuZXdTa2lwcGVkRmVhdHVyZXMgPSBPYmplY3Qua2V5cyhpbWFnZUZyYW1lU3RhdGUuc2tpcHBlZEZlYXR1cmVVaWRzKS5zb3J0KCk7XG4gICAgICAgIGltYWdlID0gbmV3IEltYWdlQ2FudmFzKHJlbmRlcmVkRXh0ZW50LCB2aWV3UmVzb2x1dGlvbiwgcGl4ZWxSYXRpbywgY29udGV4dC5jYW52YXMsIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgaWYgKHZlY3RvclJlbmRlcmVyLnByZXBhcmVGcmFtZShpbWFnZUZyYW1lU3RhdGUsIGxheWVyU3RhdGUpICYmXG4gICAgICAgICAgICAgICh2ZWN0b3JSZW5kZXJlci5yZXBsYXlHcm91cENoYW5nZWQgfHxcbiAgICAgICAgICAgICAgIWVxdWFscyhza2lwcGVkRmVhdHVyZXMsIG5ld1NraXBwZWRGZWF0dXJlcykpKSB7XG4gICAgICAgICAgICBjb250ZXh0LmNhbnZhcy53aWR0aCA9IGltYWdlRnJhbWVTdGF0ZS5zaXplWzBdICogcGl4ZWxSYXRpbztcbiAgICAgICAgICAgIGNvbnRleHQuY2FudmFzLmhlaWdodCA9IGltYWdlRnJhbWVTdGF0ZS5zaXplWzFdICogcGl4ZWxSYXRpbztcbiAgICAgICAgICAgIHZlY3RvclJlbmRlcmVyLmNvbXBvc2UoY29udGV4dCwgaW1hZ2VGcmFtZVN0YXRlLCBsYXllclN0YXRlKTtcbiAgICAgICAgICAgIHNraXBwZWRGZWF0dXJlcyA9IG5ld1NraXBwZWRGZWF0dXJlcztcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGltYWdlID0gaW1hZ2VTb3VyY2UuZ2V0SW1hZ2UoXG4gICAgICAgICAgcmVuZGVyZWRFeHRlbnQsIHZpZXdSZXNvbHV0aW9uLCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbWFnZSAmJiB0aGlzLmxvYWRJbWFnZShpbWFnZSkpIHtcbiAgICAgICAgdGhpcy5pbWFnZV8gPSBpbWFnZTtcbiAgICAgICAgdGhpcy5za2lwcGVkRmVhdHVyZXNfID0gc2tpcHBlZEZlYXR1cmVzO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmltYWdlXykge1xuICAgICAgaW1hZ2UgPSB0aGlzLmltYWdlXztcbiAgICAgIHZhciBpbWFnZUV4dGVudCA9IGltYWdlLmdldEV4dGVudCgpO1xuICAgICAgdmFyIGltYWdlUmVzb2x1dGlvbiA9IGltYWdlLmdldFJlc29sdXRpb24oKTtcbiAgICAgIHZhciBpbWFnZVBpeGVsUmF0aW8gPSBpbWFnZS5nZXRQaXhlbFJhdGlvKCk7XG4gICAgICB2YXIgc2NhbGUgPSBwaXhlbFJhdGlvICogaW1hZ2VSZXNvbHV0aW9uIC9cbiAgICAgICAgICAodmlld1Jlc29sdXRpb24gKiBpbWFnZVBpeGVsUmF0aW8pO1xuICAgICAgdmFyIHRyYW5zZm9ybSA9IGNvbXBvc2VUcmFuc2Zvcm0odGhpcy5pbWFnZVRyYW5zZm9ybV8sXG4gICAgICAgIHBpeGVsUmF0aW8gKiBzaXplWzBdIC8gMiwgcGl4ZWxSYXRpbyAqIHNpemVbMV0gLyAyLFxuICAgICAgICBzY2FsZSwgc2NhbGUsXG4gICAgICAgIDAsXG4gICAgICAgIGltYWdlUGl4ZWxSYXRpbyAqIChpbWFnZUV4dGVudFswXSAtIHZpZXdDZW50ZXJbMF0pIC8gaW1hZ2VSZXNvbHV0aW9uLFxuICAgICAgICBpbWFnZVBpeGVsUmF0aW8gKiAodmlld0NlbnRlclsxXSAtIGltYWdlRXh0ZW50WzNdKSAvIGltYWdlUmVzb2x1dGlvbik7XG4gICAgICBjb21wb3NlVHJhbnNmb3JtKHRoaXMuY29vcmRpbmF0ZVRvQ2FudmFzUGl4ZWxUcmFuc2Zvcm0sXG4gICAgICAgIHBpeGVsUmF0aW8gKiBzaXplWzBdIC8gMiAtIHRyYW5zZm9ybVs0XSwgcGl4ZWxSYXRpbyAqIHNpemVbMV0gLyAyIC0gdHJhbnNmb3JtWzVdLFxuICAgICAgICBwaXhlbFJhdGlvIC8gdmlld1Jlc29sdXRpb24sIC1waXhlbFJhdGlvIC8gdmlld1Jlc29sdXRpb24sXG4gICAgICAgIDAsXG4gICAgICAgIC12aWV3Q2VudGVyWzBdLCAtdmlld0NlbnRlclsxXSk7XG5cbiAgICAgIHRoaXMucmVuZGVyZWRSZXNvbHV0aW9uID0gaW1hZ2VSZXNvbHV0aW9uICogcGl4ZWxSYXRpbyAvIGltYWdlUGl4ZWxSYXRpbztcbiAgICB9XG5cbiAgICByZXR1cm4gISF0aGlzLmltYWdlXztcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENhbnZhc0ltYWdlTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGUgPSBmdW5jdGlvbiBmb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZSAoY29vcmRpbmF0ZSwgZnJhbWVTdGF0ZSwgaGl0VG9sZXJhbmNlLCBjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLnZlY3RvclJlbmRlcmVyXykge1xuICAgICAgcmV0dXJuIHRoaXMudmVjdG9yUmVuZGVyZXJfLmZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlKGNvb3JkaW5hdGUsIGZyYW1lU3RhdGUsIGhpdFRvbGVyYW5jZSwgY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gSW50ZXJtZWRpYXRlQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlLmNhbGwodGhpcywgY29vcmRpbmF0ZSwgZnJhbWVTdGF0ZSwgaGl0VG9sZXJhbmNlLCBjYWxsYmFjayk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBDYW52YXNJbWFnZUxheWVyUmVuZGVyZXI7XG59KEludGVybWVkaWF0ZUNhbnZhc1JlbmRlcmVyKSk7XG5cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdGhpcyByZW5kZXJlciBoYW5kbGVzIHRoZSBwcm92aWRlZCBsYXllci5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdH0gbGF5ZXIgVGhlIGNhbmRpZGF0ZSBsYXllci5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSByZW5kZXJlciBjYW4gcmVuZGVyIHRoZSBsYXllci5cbiAqL1xuQ2FudmFzSW1hZ2VMYXllclJlbmRlcmVyWydoYW5kbGVzJ10gPSBmdW5jdGlvbihsYXllcikge1xuICByZXR1cm4gbGF5ZXIuZ2V0VHlwZSgpID09PSBMYXllclR5cGUuSU1BR0UgfHxcbiAgICBsYXllci5nZXRUeXBlKCkgPT09IExheWVyVHlwZS5WRUNUT1IgJiZcbiAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2xheWVyL1ZlY3Rvci5qc1wiKS5kZWZhdWx0fSAqLyAobGF5ZXIpLmdldFJlbmRlck1vZGUoKSA9PT0gVmVjdG9yUmVuZGVyVHlwZS5JTUFHRTtcbn07XG5cblxuLyoqXG4gKiBDcmVhdGUgYSBsYXllciByZW5kZXJlci5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHR9IG1hcFJlbmRlcmVyIFRoZSBtYXAgcmVuZGVyZXIuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHR9IGxheWVyIFRoZSBsYXllciB0byBiZSByZW5kZXJlcmQuXG4gKiBAcmV0dXJuIHtDYW52YXNJbWFnZUxheWVyUmVuZGVyZXJ9IFRoZSBsYXllciByZW5kZXJlci5cbiAqL1xuQ2FudmFzSW1hZ2VMYXllclJlbmRlcmVyWydjcmVhdGUnXSA9IGZ1bmN0aW9uKG1hcFJlbmRlcmVyLCBsYXllcikge1xuICByZXR1cm4gbmV3IENhbnZhc0ltYWdlTGF5ZXJSZW5kZXJlcigvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2xheWVyL0ltYWdlLmpzXCIpLmRlZmF1bHR9ICovIChsYXllcikpO1xufTtcblxuXG5leHBvcnQgZGVmYXVsdCBDYW52YXNJbWFnZUxheWVyUmVuZGVyZXI7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUltYWdlTGF5ZXIuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlcmVyL2NhbnZhcy9JbnRlcm1lZGlhdGVDYW52YXNcbiAqL1xuaW1wb3J0IHthYnN0cmFjdH0gZnJvbSAnLi4vLi4vdXRpbC5qcyc7XG5pbXBvcnQge3NjYWxlIGFzIHNjYWxlQ29vcmRpbmF0ZX0gZnJvbSAnLi4vLi4vY29vcmRpbmF0ZS5qcyc7XG5pbXBvcnQge2NyZWF0ZUNhbnZhc0NvbnRleHQyRH0gZnJvbSAnLi4vLi4vZG9tLmpzJztcbmltcG9ydCB7Y29udGFpbnNFeHRlbnQsIGludGVyc2VjdHN9IGZyb20gJy4uLy4uL2V4dGVudC5qcyc7XG5pbXBvcnQgQ2FudmFzTGF5ZXJSZW5kZXJlciBmcm9tICcuL0xheWVyLmpzJztcbmltcG9ydCB7Y3JlYXRlIGFzIGNyZWF0ZVRyYW5zZm9ybSwgYXBwbHkgYXMgYXBwbHlUcmFuc2Zvcm19IGZyb20gJy4uLy4uL3RyYW5zZm9ybS5qcyc7XG5cbi8qKlxuICogQGFic3RyYWN0XG4gKi9cbnZhciBJbnRlcm1lZGlhdGVDYW52YXNSZW5kZXJlciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKENhbnZhc0xheWVyUmVuZGVyZXIpIHtcbiAgZnVuY3Rpb24gSW50ZXJtZWRpYXRlQ2FudmFzUmVuZGVyZXIobGF5ZXIpIHtcblxuICAgIENhbnZhc0xheWVyUmVuZGVyZXIuY2FsbCh0aGlzLCBsYXllcik7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uLy4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19XG4gICAgICovXG4gICAgdGhpcy5jb29yZGluYXRlVG9DYW52YXNQaXhlbFRyYW5zZm9ybSA9IGNyZWF0ZVRyYW5zZm9ybSgpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICAgICAqL1xuICAgIHRoaXMuaGl0Q2FudmFzQ29udGV4dF8gPSBudWxsO1xuXG4gIH1cblxuICBpZiAoIENhbnZhc0xheWVyUmVuZGVyZXIgKSBJbnRlcm1lZGlhdGVDYW52YXNSZW5kZXJlci5fX3Byb3RvX18gPSBDYW52YXNMYXllclJlbmRlcmVyO1xuICBJbnRlcm1lZGlhdGVDYW52YXNSZW5kZXJlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDYW52YXNMYXllclJlbmRlcmVyICYmIENhbnZhc0xheWVyUmVuZGVyZXIucHJvdG90eXBlICk7XG4gIEludGVybWVkaWF0ZUNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEludGVybWVkaWF0ZUNhbnZhc1JlbmRlcmVyO1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgSW50ZXJtZWRpYXRlQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmNvbXBvc2VGcmFtZSA9IGZ1bmN0aW9uIGNvbXBvc2VGcmFtZSAoZnJhbWVTdGF0ZSwgbGF5ZXJTdGF0ZSwgY29udGV4dCkge1xuXG4gICAgdGhpcy5wcmVDb21wb3NlKGNvbnRleHQsIGZyYW1lU3RhdGUpO1xuXG4gICAgdmFyIGltYWdlID0gdGhpcy5nZXRJbWFnZSgpO1xuICAgIGlmIChpbWFnZSkge1xuXG4gICAgICAvLyBjbGlwcGVkIHJlbmRlcmluZyBpZiBsYXllciBleHRlbnQgaXMgc2V0XG4gICAgICB2YXIgZXh0ZW50ID0gbGF5ZXJTdGF0ZS5leHRlbnQ7XG4gICAgICB2YXIgY2xpcHBlZCA9IGV4dGVudCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgIWNvbnRhaW5zRXh0ZW50KGV4dGVudCwgZnJhbWVTdGF0ZS5leHRlbnQpICYmXG4gICAgICAgICAgaW50ZXJzZWN0cyhleHRlbnQsIGZyYW1lU3RhdGUuZXh0ZW50KTtcbiAgICAgIGlmIChjbGlwcGVkKSB7XG4gICAgICAgIHRoaXMuY2xpcChjb250ZXh0LCBmcmFtZVN0YXRlLCAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9ICovIChleHRlbnQpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGltYWdlVHJhbnNmb3JtID0gdGhpcy5nZXRJbWFnZVRyYW5zZm9ybSgpO1xuICAgICAgLy8gZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIGNvbnRleHQuc2F2ZSAvIGNvbnRleHQucmVzdG9yZSBpcyBub3QgdXNlZFxuICAgICAgLy8gdG8gc2F2ZSBhbmQgcmVzdG9yZSB0aGUgdHJhbnNmb3JtYXRpb24gbWF0cml4IGFuZCB0aGUgb3BhY2l0eS5cbiAgICAgIC8vIHNlZSBodHRwOi8vanNwZXJmLmNvbS9jb250ZXh0LXNhdmUtcmVzdG9yZS12ZXJzdXMtdmFyaWFibGVcbiAgICAgIHZhciBhbHBoYSA9IGNvbnRleHQuZ2xvYmFsQWxwaGE7XG4gICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gbGF5ZXJTdGF0ZS5vcGFjaXR5O1xuXG4gICAgICAvLyBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgY29udGV4dC5zZXRUcmFuc2Zvcm0gaXMgb25seSB1c2VkXG4gICAgICAvLyB3aGVuIHRoZSB2aWV3IGlzIHJvdGF0ZWQuIHNlZSBodHRwOi8vanNwZXJmLmNvbS9jYW52YXMtdHJhbnNmb3JtXG4gICAgICB2YXIgZHggPSBpbWFnZVRyYW5zZm9ybVs0XTtcbiAgICAgIHZhciBkeSA9IGltYWdlVHJhbnNmb3JtWzVdO1xuICAgICAgdmFyIGR3ID0gaW1hZ2Uud2lkdGggKiBpbWFnZVRyYW5zZm9ybVswXTtcbiAgICAgIHZhciBkaCA9IGltYWdlLmhlaWdodCAqIGltYWdlVHJhbnNmb3JtWzNdO1xuICAgICAgaWYgKGR3ID49IDAuNSAmJiBkaCA+PSAwLjUpIHtcbiAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsICtpbWFnZS53aWR0aCwgK2ltYWdlLmhlaWdodCxcbiAgICAgICAgICBNYXRoLnJvdW5kKGR4KSwgTWF0aC5yb3VuZChkeSksIE1hdGgucm91bmQoZHcpLCBNYXRoLnJvdW5kKGRoKSk7XG4gICAgICB9XG4gICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gYWxwaGE7XG5cbiAgICAgIGlmIChjbGlwcGVkKSB7XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucG9zdENvbXBvc2UoY29udGV4dCwgZnJhbWVTdGF0ZSwgbGF5ZXJTdGF0ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fEhUTUxJbWFnZUVsZW1lbnR9IENhbnZhcy5cbiAgICovXG4gIEludGVybWVkaWF0ZUNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5nZXRJbWFnZSA9IGZ1bmN0aW9uIGdldEltYWdlICgpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfTtcblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4geyFpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfSBJbWFnZSB0cmFuc2Zvcm0uXG4gICAqL1xuICBJbnRlcm1lZGlhdGVDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuZ2V0SW1hZ2VUcmFuc2Zvcm0gPSBmdW5jdGlvbiBnZXRJbWFnZVRyYW5zZm9ybSAoKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBJbnRlcm1lZGlhdGVDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuZm9yRWFjaExheWVyQXRDb29yZGluYXRlID0gZnVuY3Rpb24gZm9yRWFjaExheWVyQXRDb29yZGluYXRlIChjb29yZGluYXRlLCBmcmFtZVN0YXRlLCBoaXRUb2xlcmFuY2UsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgaWYgKCF0aGlzLmdldEltYWdlKCkpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdmFyIHBpeGVsID0gYXBwbHlUcmFuc2Zvcm0odGhpcy5jb29yZGluYXRlVG9DYW52YXNQaXhlbFRyYW5zZm9ybSwgY29vcmRpbmF0ZS5zbGljZSgpKTtcbiAgICBzY2FsZUNvb3JkaW5hdGUocGl4ZWwsIGZyYW1lU3RhdGUudmlld1N0YXRlLnJlc29sdXRpb24gLyB0aGlzLnJlbmRlcmVkUmVzb2x1dGlvbik7XG5cbiAgICBpZiAoIXRoaXMuaGl0Q2FudmFzQ29udGV4dF8pIHtcbiAgICAgIHRoaXMuaGl0Q2FudmFzQ29udGV4dF8gPSBjcmVhdGVDYW52YXNDb250ZXh0MkQoMSwgMSk7XG4gICAgfVxuXG4gICAgdGhpcy5oaXRDYW52YXNDb250ZXh0Xy5jbGVhclJlY3QoMCwgMCwgMSwgMSk7XG4gICAgdGhpcy5oaXRDYW52YXNDb250ZXh0Xy5kcmF3SW1hZ2UodGhpcy5nZXRJbWFnZSgpLCBwaXhlbFswXSwgcGl4ZWxbMV0sIDEsIDEsIDAsIDAsIDEsIDEpO1xuXG4gICAgdmFyIGltYWdlRGF0YSA9IHRoaXMuaGl0Q2FudmFzQ29udGV4dF8uZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpLmRhdGE7XG4gICAgaWYgKGltYWdlRGF0YVszXSA+IDApIHtcbiAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHRoaXMuZ2V0TGF5ZXIoKSwgaW1hZ2VEYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIEludGVybWVkaWF0ZUNhbnZhc1JlbmRlcmVyO1xufShDYW52YXNMYXllclJlbmRlcmVyKSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgSW50ZXJtZWRpYXRlQ2FudmFzUmVuZGVyZXI7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUludGVybWVkaWF0ZUNhbnZhcy5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyZXIvY2FudmFzL0xheWVyXG4gKi9cbmltcG9ydCB7YWJzdHJhY3R9IGZyb20gJy4uLy4uL3V0aWwuanMnO1xuaW1wb3J0IHtnZXRCb3R0b21MZWZ0LCBnZXRCb3R0b21SaWdodCwgZ2V0VG9wTGVmdCwgZ2V0VG9wUmlnaHR9IGZyb20gJy4uLy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge1RSVUV9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQgUmVuZGVyRXZlbnQgZnJvbSAnLi4vLi4vcmVuZGVyL0V2ZW50LmpzJztcbmltcG9ydCBSZW5kZXJFdmVudFR5cGUgZnJvbSAnLi4vLi4vcmVuZGVyL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQge3JvdGF0ZUF0T2Zmc2V0fSBmcm9tICcuLi8uLi9yZW5kZXIvY2FudmFzLmpzJztcbmltcG9ydCBDYW52YXNJbW1lZGlhdGVSZW5kZXJlciBmcm9tICcuLi8uLi9yZW5kZXIvY2FudmFzL0ltbWVkaWF0ZS5qcyc7XG5pbXBvcnQgTGF5ZXJSZW5kZXJlciBmcm9tICcuLi9MYXllci5qcyc7XG5pbXBvcnQge2NyZWF0ZSBhcyBjcmVhdGVUcmFuc2Zvcm0sIGFwcGx5IGFzIGFwcGx5VHJhbnNmb3JtLCBjb21wb3NlIGFzIGNvbXBvc2VUcmFuc2Zvcm19IGZyb20gJy4uLy4uL3RyYW5zZm9ybS5qcyc7XG5cbi8qKlxuICogQGFic3RyYWN0XG4gKi9cbnZhciBDYW52YXNMYXllclJlbmRlcmVyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoTGF5ZXJSZW5kZXJlcikge1xuICBmdW5jdGlvbiBDYW52YXNMYXllclJlbmRlcmVyKGxheWVyKSB7XG5cbiAgICBMYXllclJlbmRlcmVyLmNhbGwodGhpcywgbGF5ZXIpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZFJlc29sdXRpb247XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfVxuICAgICAqL1xuICAgIHRoaXMudHJhbnNmb3JtXyA9IGNyZWF0ZVRyYW5zZm9ybSgpO1xuXG4gIH1cblxuICBpZiAoIExheWVyUmVuZGVyZXIgKSBDYW52YXNMYXllclJlbmRlcmVyLl9fcHJvdG9fXyA9IExheWVyUmVuZGVyZXI7XG4gIENhbnZhc0xheWVyUmVuZGVyZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTGF5ZXJSZW5kZXJlciAmJiBMYXllclJlbmRlcmVyLnByb3RvdHlwZSApO1xuICBDYW52YXNMYXllclJlbmRlcmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhbnZhc0xheWVyUmVuZGVyZXI7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IENvbnRleHQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IENsaXAgZXh0ZW50LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBDYW52YXNMYXllclJlbmRlcmVyLnByb3RvdHlwZS5jbGlwID0gZnVuY3Rpb24gY2xpcCAoY29udGV4dCwgZnJhbWVTdGF0ZSwgZXh0ZW50KSB7XG4gICAgdmFyIHBpeGVsUmF0aW8gPSBmcmFtZVN0YXRlLnBpeGVsUmF0aW87XG4gICAgdmFyIHdpZHRoID0gZnJhbWVTdGF0ZS5zaXplWzBdICogcGl4ZWxSYXRpbztcbiAgICB2YXIgaGVpZ2h0ID0gZnJhbWVTdGF0ZS5zaXplWzFdICogcGl4ZWxSYXRpbztcbiAgICB2YXIgcm90YXRpb24gPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZS5yb3RhdGlvbjtcbiAgICB2YXIgdG9wTGVmdCA9IGdldFRvcExlZnQoZXh0ZW50KTtcbiAgICB2YXIgdG9wUmlnaHQgPSBnZXRUb3BSaWdodChleHRlbnQpO1xuICAgIHZhciBib3R0b21SaWdodCA9IGdldEJvdHRvbVJpZ2h0KGV4dGVudCk7XG4gICAgdmFyIGJvdHRvbUxlZnQgPSBnZXRCb3R0b21MZWZ0KGV4dGVudCk7XG5cbiAgICBhcHBseVRyYW5zZm9ybShmcmFtZVN0YXRlLmNvb3JkaW5hdGVUb1BpeGVsVHJhbnNmb3JtLCB0b3BMZWZ0KTtcbiAgICBhcHBseVRyYW5zZm9ybShmcmFtZVN0YXRlLmNvb3JkaW5hdGVUb1BpeGVsVHJhbnNmb3JtLCB0b3BSaWdodCk7XG4gICAgYXBwbHlUcmFuc2Zvcm0oZnJhbWVTdGF0ZS5jb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybSwgYm90dG9tUmlnaHQpO1xuICAgIGFwcGx5VHJhbnNmb3JtKGZyYW1lU3RhdGUuY29vcmRpbmF0ZVRvUGl4ZWxUcmFuc2Zvcm0sIGJvdHRvbUxlZnQpO1xuXG4gICAgY29udGV4dC5zYXZlKCk7XG4gICAgcm90YXRlQXRPZmZzZXQoY29udGV4dCwgLXJvdGF0aW9uLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8odG9wTGVmdFswXSAqIHBpeGVsUmF0aW8sIHRvcExlZnRbMV0gKiBwaXhlbFJhdGlvKTtcbiAgICBjb250ZXh0LmxpbmVUbyh0b3BSaWdodFswXSAqIHBpeGVsUmF0aW8sIHRvcFJpZ2h0WzFdICogcGl4ZWxSYXRpbyk7XG4gICAgY29udGV4dC5saW5lVG8oYm90dG9tUmlnaHRbMF0gKiBwaXhlbFJhdGlvLCBib3R0b21SaWdodFsxXSAqIHBpeGVsUmF0aW8pO1xuICAgIGNvbnRleHQubGluZVRvKGJvdHRvbUxlZnRbMF0gKiBwaXhlbFJhdGlvLCBib3R0b21MZWZ0WzFdICogcGl4ZWxSYXRpbyk7XG4gICAgY29udGV4dC5jbGlwKCk7XG4gICAgcm90YXRlQXRPZmZzZXQoY29udGV4dCwgcm90YXRpb24sIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vcmVuZGVyL0V2ZW50VHlwZS5qc1wiKS5kZWZhdWx0fSB0eXBlIEV2ZW50IHR5cGUuXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IENvbnRleHQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybT19IG9wdF90cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQ2FudmFzTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuZGlzcGF0Y2hDb21wb3NlRXZlbnRfID0gZnVuY3Rpb24gZGlzcGF0Y2hDb21wb3NlRXZlbnRfICh0eXBlLCBjb250ZXh0LCBmcmFtZVN0YXRlLCBvcHRfdHJhbnNmb3JtKSB7XG4gICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcigpO1xuICAgIGlmIChsYXllci5oYXNMaXN0ZW5lcih0eXBlKSkge1xuICAgICAgdmFyIHdpZHRoID0gZnJhbWVTdGF0ZS5zaXplWzBdICogZnJhbWVTdGF0ZS5waXhlbFJhdGlvO1xuICAgICAgdmFyIGhlaWdodCA9IGZyYW1lU3RhdGUuc2l6ZVsxXSAqIGZyYW1lU3RhdGUucGl4ZWxSYXRpbztcbiAgICAgIHZhciByb3RhdGlvbiA9IGZyYW1lU3RhdGUudmlld1N0YXRlLnJvdGF0aW9uO1xuICAgICAgcm90YXRlQXRPZmZzZXQoY29udGV4dCwgLXJvdGF0aW9uLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICAgICAgdmFyIHRyYW5zZm9ybSA9IG9wdF90cmFuc2Zvcm0gIT09IHVuZGVmaW5lZCA/XG4gICAgICAgIG9wdF90cmFuc2Zvcm0gOiB0aGlzLmdldFRyYW5zZm9ybShmcmFtZVN0YXRlLCAwKTtcbiAgICAgIHZhciByZW5kZXIgPSBuZXcgQ2FudmFzSW1tZWRpYXRlUmVuZGVyZXIoXG4gICAgICAgIGNvbnRleHQsIGZyYW1lU3RhdGUucGl4ZWxSYXRpbywgZnJhbWVTdGF0ZS5leHRlbnQsIHRyYW5zZm9ybSxcbiAgICAgICAgZnJhbWVTdGF0ZS52aWV3U3RhdGUucm90YXRpb24pO1xuICAgICAgdmFyIGNvbXBvc2VFdmVudCA9IG5ldyBSZW5kZXJFdmVudCh0eXBlLCByZW5kZXIsIGZyYW1lU3RhdGUsXG4gICAgICAgIGNvbnRleHQsIG51bGwpO1xuICAgICAgbGF5ZXIuZGlzcGF0Y2hFdmVudChjb21wb3NlRXZlbnQpO1xuICAgICAgcm90YXRlQXRPZmZzZXQoY29udGV4dCwgcm90YXRpb24sIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL1BsdWdnYWJsZU1hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lU3RhdGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoaXRUb2xlcmFuY2UgSGl0IHRvbGVyYW5jZSBpbiBwaXhlbHMuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczogUywgaW1wb3J0KFwiLi4vLi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdCwgKFVpbnQ4Q2xhbXBlZEFycmF5fFVpbnQ4QXJyYXkpKTogVH0gY2FsbGJhY2sgTGF5ZXJcbiAgICogICAgIGNhbGxiYWNrLlxuICAgKiBAcGFyYW0ge1N9IHRoaXNBcmcgVmFsdWUgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyBgY2FsbGJhY2tgLlxuICAgKiBAcmV0dXJuIHtUfHVuZGVmaW5lZH0gQ2FsbGJhY2sgcmVzdWx0LlxuICAgKiBAdGVtcGxhdGUgUyxULFVcbiAgICovXG4gIENhbnZhc0xheWVyUmVuZGVyZXIucHJvdG90eXBlLmZvckVhY2hMYXllckF0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGZvckVhY2hMYXllckF0Q29vcmRpbmF0ZSAoY29vcmRpbmF0ZSwgZnJhbWVTdGF0ZSwgaGl0VG9sZXJhbmNlLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIHZhciBoYXNGZWF0dXJlID0gdGhpcy5mb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZShjb29yZGluYXRlLCBmcmFtZVN0YXRlLCBoaXRUb2xlcmFuY2UsIFRSVUUpO1xuXG4gICAgaWYgKGhhc0ZlYXR1cmUpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHRoaXMuZ2V0TGF5ZXIoKSwgbnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBDb250ZXh0LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL1BsdWdnYWJsZU1hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2xheWVyL0xheWVyLmpzXCIpLlN0YXRlfSBsYXllclN0YXRlIExheWVyIHN0YXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm09fSBvcHRfdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgQ2FudmFzTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUucG9zdENvbXBvc2UgPSBmdW5jdGlvbiBwb3N0Q29tcG9zZSAoY29udGV4dCwgZnJhbWVTdGF0ZSwgbGF5ZXJTdGF0ZSwgb3B0X3RyYW5zZm9ybSkge1xuICAgIHRoaXMuZGlzcGF0Y2hDb21wb3NlRXZlbnRfKFJlbmRlckV2ZW50VHlwZS5QT1NUQ09NUE9TRSwgY29udGV4dCwgZnJhbWVTdGF0ZSwgb3B0X3RyYW5zZm9ybSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IENvbnRleHQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybT19IG9wdF90cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBDYW52YXNMYXllclJlbmRlcmVyLnByb3RvdHlwZS5wcmVDb21wb3NlID0gZnVuY3Rpb24gcHJlQ29tcG9zZSAoY29udGV4dCwgZnJhbWVTdGF0ZSwgb3B0X3RyYW5zZm9ybSkge1xuICAgIHRoaXMuZGlzcGF0Y2hDb21wb3NlRXZlbnRfKFJlbmRlckV2ZW50VHlwZS5QUkVDT01QT1NFLCBjb250ZXh0LCBmcmFtZVN0YXRlLCBvcHRfdHJhbnNmb3JtKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9QbHVnZ2FibGVNYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtPX0gb3B0X3RyYW5zZm9ybSBUcmFuc2Zvcm0uXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIENhbnZhc0xheWVyUmVuZGVyZXIucHJvdG90eXBlLmRpc3BhdGNoUmVuZGVyRXZlbnQgPSBmdW5jdGlvbiBkaXNwYXRjaFJlbmRlckV2ZW50IChjb250ZXh0LCBmcmFtZVN0YXRlLCBvcHRfdHJhbnNmb3JtKSB7XG4gICAgdGhpcy5kaXNwYXRjaENvbXBvc2VFdmVudF8oUmVuZGVyRXZlbnRUeXBlLlJFTkRFUiwgY29udGV4dCwgZnJhbWVTdGF0ZSwgb3B0X3RyYW5zZm9ybSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRYIE9mZnNldCBvbiB0aGUgeC1heGlzIGluIHZpZXcgY29vcmRpbmF0ZXMuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHJldHVybiB7IWltcG9ydChcIi4uLy4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19IFRyYW5zZm9ybS5cbiAgICovXG4gIENhbnZhc0xheWVyUmVuZGVyZXIucHJvdG90eXBlLmdldFRyYW5zZm9ybSA9IGZ1bmN0aW9uIGdldFRyYW5zZm9ybSAoZnJhbWVTdGF0ZSwgb2Zmc2V0WCkge1xuICAgIHZhciB2aWV3U3RhdGUgPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZTtcbiAgICB2YXIgcGl4ZWxSYXRpbyA9IGZyYW1lU3RhdGUucGl4ZWxSYXRpbztcbiAgICB2YXIgZHgxID0gcGl4ZWxSYXRpbyAqIGZyYW1lU3RhdGUuc2l6ZVswXSAvIDI7XG4gICAgdmFyIGR5MSA9IHBpeGVsUmF0aW8gKiBmcmFtZVN0YXRlLnNpemVbMV0gLyAyO1xuICAgIHZhciBzeCA9IHBpeGVsUmF0aW8gLyB2aWV3U3RhdGUucmVzb2x1dGlvbjtcbiAgICB2YXIgc3kgPSAtc3g7XG4gICAgdmFyIGFuZ2xlID0gLXZpZXdTdGF0ZS5yb3RhdGlvbjtcbiAgICB2YXIgZHgyID0gLXZpZXdTdGF0ZS5jZW50ZXJbMF0gKyBvZmZzZXRYO1xuICAgIHZhciBkeTIgPSAtdmlld1N0YXRlLmNlbnRlclsxXTtcbiAgICByZXR1cm4gY29tcG9zZVRyYW5zZm9ybSh0aGlzLnRyYW5zZm9ybV8sIGR4MSwgZHkxLCBzeCwgc3ksIGFuZ2xlLCBkeDIsIGR5Mik7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL1BsdWdnYWJsZU1hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2xheWVyL0xheWVyLmpzXCIpLlN0YXRlfSBsYXllclN0YXRlIExheWVyIHN0YXRlLlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBDb250ZXh0LlxuICAgKi9cbiAgQ2FudmFzTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuY29tcG9zZUZyYW1lID0gZnVuY3Rpb24gY29tcG9zZUZyYW1lIChmcmFtZVN0YXRlLCBsYXllclN0YXRlLCBjb250ZXh0KSB7XG4gICAgYWJzdHJhY3QoKTtcbiAgfTtcblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vbGF5ZXIvTGF5ZXIuanNcIikuU3RhdGV9IGxheWVyU3RhdGUgTGF5ZXIgc3RhdGUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IHdoZXRoZXIgY29tcG9zZUZyYW1lIHNob3VsZCBiZSBjYWxsZWQuXG4gICAqL1xuICBDYW52YXNMYXllclJlbmRlcmVyLnByb3RvdHlwZS5wcmVwYXJlRnJhbWUgPSBmdW5jdGlvbiBwcmVwYXJlRnJhbWUgKGZyYW1lU3RhdGUsIGxheWVyU3RhdGUpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfTtcblxuICByZXR1cm4gQ2FudmFzTGF5ZXJSZW5kZXJlcjtcbn0oTGF5ZXJSZW5kZXJlcikpO1xuXG5leHBvcnQgZGVmYXVsdCBDYW52YXNMYXllclJlbmRlcmVyO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1MYXllci5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyZXIvY2FudmFzL01hcFxuICovXG5pbXBvcnQge2NyZWF0ZSBhcyBjcmVhdGVUcmFuc2Zvcm0sIGFwcGx5IGFzIGFwcGx5VHJhbnNmb3JtLCBjb21wb3NlIGFzIGNvbXBvc2VUcmFuc2Zvcm19IGZyb20gJy4uLy4uL3RyYW5zZm9ybS5qcyc7XG5pbXBvcnQge2luY2x1ZGVzLCBzdGFibGVTb3J0fSBmcm9tICcuLi8uLi9hcnJheS5qcyc7XG5pbXBvcnQge0NMQVNTX1VOU0VMRUNUQUJMRX0gZnJvbSAnLi4vLi4vY3NzLmpzJztcbmltcG9ydCB7Y3JlYXRlQ2FudmFzQ29udGV4dDJEfSBmcm9tICcuLi8uLi9kb20uanMnO1xuaW1wb3J0IHt2aXNpYmxlQXRSZXNvbHV0aW9ufSBmcm9tICcuLi8uLi9sYXllci9MYXllci5qcyc7XG5pbXBvcnQgUmVuZGVyRXZlbnQgZnJvbSAnLi4vLi4vcmVuZGVyL0V2ZW50LmpzJztcbmltcG9ydCBSZW5kZXJFdmVudFR5cGUgZnJvbSAnLi4vLi4vcmVuZGVyL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQge3JvdGF0ZUF0T2Zmc2V0fSBmcm9tICcuLi8uLi9yZW5kZXIvY2FudmFzLmpzJztcbmltcG9ydCBDYW52YXNJbW1lZGlhdGVSZW5kZXJlciBmcm9tICcuLi8uLi9yZW5kZXIvY2FudmFzL0ltbWVkaWF0ZS5qcyc7XG5pbXBvcnQgTWFwUmVuZGVyZXIsIHtzb3J0QnlaSW5kZXh9IGZyb20gJy4uL01hcC5qcyc7XG5pbXBvcnQgU291cmNlU3RhdGUgZnJvbSAnLi4vLi4vc291cmNlL1N0YXRlLmpzJztcblxuXG4vKipcbiAqIEB0eXBlIHtBcnJheTx0eXBlb2YgaW1wb3J0KFwiLi4vTGF5ZXIuanNcIikuZGVmYXVsdD59XG4gKi9cbmV4cG9ydCB2YXIgbGF5ZXJSZW5kZXJlckNvbnN0cnVjdG9ycyA9IFtdO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIENhbnZhcyBtYXAgcmVuZGVyZXIuXG4gKiBAYXBpXG4gKi9cbnZhciBDYW52YXNNYXBSZW5kZXJlciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKE1hcFJlbmRlcmVyKSB7XG4gIGZ1bmN0aW9uIENhbnZhc01hcFJlbmRlcmVyKG1hcCkge1xuICAgIE1hcFJlbmRlcmVyLmNhbGwodGhpcywgbWFwKTtcblxuICAgIHZhciBjb250YWluZXIgPSBtYXAuZ2V0Vmlld3BvcnQoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRleHRfID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmNhbnZhc18gPSB0aGlzLmNvbnRleHRfLmNhbnZhcztcblxuICAgIHRoaXMuY2FudmFzXy5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICB0aGlzLmNhbnZhc18uc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgIHRoaXMuY2FudmFzXy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICB0aGlzLmNhbnZhc18uY2xhc3NOYW1lID0gQ0xBU1NfVU5TRUxFQ1RBQkxFO1xuICAgIGNvbnRhaW5lci5pbnNlcnRCZWZvcmUodGhpcy5jYW52YXNfLCBjb250YWluZXIuY2hpbGROb2Rlc1swXSB8fCBudWxsKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZFZpc2libGVfID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uLy4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19XG4gICAgICovXG4gICAgdGhpcy50cmFuc2Zvcm1fID0gY3JlYXRlVHJhbnNmb3JtKCk7XG5cbiAgfVxuXG4gIGlmICggTWFwUmVuZGVyZXIgKSBDYW52YXNNYXBSZW5kZXJlci5fX3Byb3RvX18gPSBNYXBSZW5kZXJlcjtcbiAgQ2FudmFzTWFwUmVuZGVyZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWFwUmVuZGVyZXIgJiYgTWFwUmVuZGVyZXIucHJvdG90eXBlICk7XG4gIENhbnZhc01hcFJlbmRlcmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhbnZhc01hcFJlbmRlcmVyO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3JlbmRlci9FdmVudFR5cGUuanNcIikuZGVmYXVsdH0gdHlwZSBFdmVudCB0eXBlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL1BsdWdnYWJsZU1hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKi9cbiAgQ2FudmFzTWFwUmVuZGVyZXIucHJvdG90eXBlLmRpc3BhdGNoUmVuZGVyRXZlbnQgPSBmdW5jdGlvbiBkaXNwYXRjaFJlbmRlckV2ZW50ICh0eXBlLCBmcmFtZVN0YXRlKSB7XG4gICAgdmFyIG1hcCA9IHRoaXMuZ2V0TWFwKCk7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHRfO1xuICAgIGlmIChtYXAuaGFzTGlzdGVuZXIodHlwZSkpIHtcbiAgICAgIHZhciBleHRlbnQgPSBmcmFtZVN0YXRlLmV4dGVudDtcbiAgICAgIHZhciBwaXhlbFJhdGlvID0gZnJhbWVTdGF0ZS5waXhlbFJhdGlvO1xuICAgICAgdmFyIHZpZXdTdGF0ZSA9IGZyYW1lU3RhdGUudmlld1N0YXRlO1xuICAgICAgdmFyIHJvdGF0aW9uID0gdmlld1N0YXRlLnJvdGF0aW9uO1xuXG4gICAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy5nZXRUcmFuc2Zvcm0oZnJhbWVTdGF0ZSk7XG5cbiAgICAgIHZhciB2ZWN0b3JDb250ZXh0ID0gbmV3IENhbnZhc0ltbWVkaWF0ZVJlbmRlcmVyKGNvbnRleHQsIHBpeGVsUmF0aW8sXG4gICAgICAgIGV4dGVudCwgdHJhbnNmb3JtLCByb3RhdGlvbik7XG4gICAgICB2YXIgY29tcG9zZUV2ZW50ID0gbmV3IFJlbmRlckV2ZW50KHR5cGUsIHZlY3RvckNvbnRleHQsXG4gICAgICAgIGZyYW1lU3RhdGUsIGNvbnRleHQsIG51bGwpO1xuICAgICAgbWFwLmRpc3BhdGNoRXZlbnQoY29tcG9zZUV2ZW50KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHJldHVybiB7IWltcG9ydChcIi4uLy4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19IFRyYW5zZm9ybS5cbiAgICovXG4gIENhbnZhc01hcFJlbmRlcmVyLnByb3RvdHlwZS5nZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiBnZXRUcmFuc2Zvcm0gKGZyYW1lU3RhdGUpIHtcbiAgICB2YXIgdmlld1N0YXRlID0gZnJhbWVTdGF0ZS52aWV3U3RhdGU7XG4gICAgdmFyIGR4MSA9IHRoaXMuY2FudmFzXy53aWR0aCAvIDI7XG4gICAgdmFyIGR5MSA9IHRoaXMuY2FudmFzXy5oZWlnaHQgLyAyO1xuICAgIHZhciBzeCA9IGZyYW1lU3RhdGUucGl4ZWxSYXRpbyAvIHZpZXdTdGF0ZS5yZXNvbHV0aW9uO1xuICAgIHZhciBzeSA9IC1zeDtcbiAgICB2YXIgYW5nbGUgPSAtdmlld1N0YXRlLnJvdGF0aW9uO1xuICAgIHZhciBkeDIgPSAtdmlld1N0YXRlLmNlbnRlclswXTtcbiAgICB2YXIgZHkyID0gLXZpZXdTdGF0ZS5jZW50ZXJbMV07XG4gICAgcmV0dXJuIGNvbXBvc2VUcmFuc2Zvcm0odGhpcy50cmFuc2Zvcm1fLCBkeDEsIGR5MSwgc3gsIHN5LCBhbmdsZSwgZHgyLCBkeTIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQ2FudmFzTWFwUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gcmVuZGVyRnJhbWUgKGZyYW1lU3RhdGUpIHtcblxuICAgIGlmICghZnJhbWVTdGF0ZSkge1xuICAgICAgaWYgKHRoaXMucmVuZGVyZWRWaXNpYmxlXykge1xuICAgICAgICB0aGlzLmNhbnZhc18uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgdGhpcy5yZW5kZXJlZFZpc2libGVfID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHRfO1xuICAgIHZhciBwaXhlbFJhdGlvID0gZnJhbWVTdGF0ZS5waXhlbFJhdGlvO1xuICAgIHZhciB3aWR0aCA9IE1hdGgucm91bmQoZnJhbWVTdGF0ZS5zaXplWzBdICogcGl4ZWxSYXRpbyk7XG4gICAgdmFyIGhlaWdodCA9IE1hdGgucm91bmQoZnJhbWVTdGF0ZS5zaXplWzFdICogcGl4ZWxSYXRpbyk7XG4gICAgaWYgKHRoaXMuY2FudmFzXy53aWR0aCAhPSB3aWR0aCB8fCB0aGlzLmNhbnZhc18uaGVpZ2h0ICE9IGhlaWdodCkge1xuICAgICAgdGhpcy5jYW52YXNfLndpZHRoID0gd2lkdGg7XG4gICAgICB0aGlzLmNhbnZhc18uaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG5cbiAgICB2YXIgcm90YXRpb24gPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZS5yb3RhdGlvbjtcblxuICAgIHRoaXMuY2FsY3VsYXRlTWF0cmljZXMyRChmcmFtZVN0YXRlKTtcblxuICAgIHRoaXMuZGlzcGF0Y2hSZW5kZXJFdmVudChSZW5kZXJFdmVudFR5cGUuUFJFQ09NUE9TRSwgZnJhbWVTdGF0ZSk7XG5cbiAgICB2YXIgbGF5ZXJTdGF0ZXNBcnJheSA9IGZyYW1lU3RhdGUubGF5ZXJTdGF0ZXNBcnJheTtcbiAgICBzdGFibGVTb3J0KGxheWVyU3RhdGVzQXJyYXksIHNvcnRCeVpJbmRleCk7XG5cbiAgICBpZiAocm90YXRpb24pIHtcbiAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgcm90YXRlQXRPZmZzZXQoY29udGV4dCwgcm90YXRpb24sIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gICAgfVxuXG4gICAgdmFyIHZpZXdSZXNvbHV0aW9uID0gZnJhbWVTdGF0ZS52aWV3U3RhdGUucmVzb2x1dGlvbjtcbiAgICB2YXIgaSwgaWk7XG4gICAgZm9yIChpID0gMCwgaWkgPSBsYXllclN0YXRlc0FycmF5Lmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIHZhciBsYXllclN0YXRlID0gbGF5ZXJTdGF0ZXNBcnJheVtpXTtcbiAgICAgIHZhciBsYXllciA9IGxheWVyU3RhdGUubGF5ZXI7XG4gICAgICB2YXIgbGF5ZXJSZW5kZXJlciA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9MYXllci5qc1wiKS5kZWZhdWx0fSAqLyAodGhpcy5nZXRMYXllclJlbmRlcmVyKGxheWVyKSk7XG4gICAgICBpZiAoIXZpc2libGVBdFJlc29sdXRpb24obGF5ZXJTdGF0ZSwgdmlld1Jlc29sdXRpb24pIHx8XG4gICAgICAgICAgbGF5ZXJTdGF0ZS5zb3VyY2VTdGF0ZSAhPSBTb3VyY2VTdGF0ZS5SRUFEWSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChsYXllclJlbmRlcmVyLnByZXBhcmVGcmFtZShmcmFtZVN0YXRlLCBsYXllclN0YXRlKSkge1xuICAgICAgICBsYXllclJlbmRlcmVyLmNvbXBvc2VGcmFtZShmcmFtZVN0YXRlLCBsYXllclN0YXRlLCBjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocm90YXRpb24pIHtcbiAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIHRoaXMuZGlzcGF0Y2hSZW5kZXJFdmVudChSZW5kZXJFdmVudFR5cGUuUE9TVENPTVBPU0UsIGZyYW1lU3RhdGUpO1xuXG4gICAgaWYgKCF0aGlzLnJlbmRlcmVkVmlzaWJsZV8pIHtcbiAgICAgIHRoaXMuY2FudmFzXy5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgICB0aGlzLnJlbmRlcmVkVmlzaWJsZV8gPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuc2NoZWR1bGVSZW1vdmVVbnVzZWRMYXllclJlbmRlcmVycyhmcmFtZVN0YXRlKTtcbiAgICB0aGlzLnNjaGVkdWxlRXhwaXJlSWNvbkNhY2hlKGZyYW1lU3RhdGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQ2FudmFzTWFwUmVuZGVyZXIucHJvdG90eXBlLmZvckVhY2hMYXllckF0UGl4ZWwgPSBmdW5jdGlvbiBmb3JFYWNoTGF5ZXJBdFBpeGVsIChwaXhlbCwgZnJhbWVTdGF0ZSwgaGl0VG9sZXJhbmNlLCBjYWxsYmFjaywgdGhpc0FyZywgbGF5ZXJGaWx0ZXIsIHRoaXNBcmcyKSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICB2YXIgdmlld1N0YXRlID0gZnJhbWVTdGF0ZS52aWV3U3RhdGU7XG4gICAgdmFyIHZpZXdSZXNvbHV0aW9uID0gdmlld1N0YXRlLnJlc29sdXRpb247XG5cbiAgICB2YXIgbGF5ZXJTdGF0ZXMgPSBmcmFtZVN0YXRlLmxheWVyU3RhdGVzQXJyYXk7XG4gICAgdmFyIG51bUxheWVycyA9IGxheWVyU3RhdGVzLmxlbmd0aDtcblxuICAgIHZhciBjb29yZGluYXRlID0gYXBwbHlUcmFuc2Zvcm0oXG4gICAgICBmcmFtZVN0YXRlLnBpeGVsVG9Db29yZGluYXRlVHJhbnNmb3JtLCBwaXhlbC5zbGljZSgpKTtcblxuICAgIHZhciBpO1xuICAgIGZvciAoaSA9IG51bUxheWVycyAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB2YXIgbGF5ZXJTdGF0ZSA9IGxheWVyU3RhdGVzW2ldO1xuICAgICAgdmFyIGxheWVyID0gbGF5ZXJTdGF0ZS5sYXllcjtcbiAgICAgIGlmICh2aXNpYmxlQXRSZXNvbHV0aW9uKGxheWVyU3RhdGUsIHZpZXdSZXNvbHV0aW9uKSAmJiBsYXllckZpbHRlci5jYWxsKHRoaXNBcmcyLCBsYXllcikpIHtcbiAgICAgICAgdmFyIGxheWVyUmVuZGVyZXIgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vTGF5ZXIuanNcIikuZGVmYXVsdH0gKi8gKHRoaXMuZ2V0TGF5ZXJSZW5kZXJlcihsYXllcikpO1xuICAgICAgICByZXN1bHQgPSBsYXllclJlbmRlcmVyLmZvckVhY2hMYXllckF0Q29vcmRpbmF0ZShcbiAgICAgICAgICBjb29yZGluYXRlLCBmcmFtZVN0YXRlLCBoaXRUb2xlcmFuY2UsIGNhbGxiYWNrLCB0aGlzQXJnKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENhbnZhc01hcFJlbmRlcmVyLnByb3RvdHlwZS5yZWdpc3RlckxheWVyUmVuZGVyZXJzID0gZnVuY3Rpb24gcmVnaXN0ZXJMYXllclJlbmRlcmVycyAoY29uc3RydWN0b3JzKSB7XG4gICAgTWFwUmVuZGVyZXIucHJvdG90eXBlLnJlZ2lzdGVyTGF5ZXJSZW5kZXJlcnMuY2FsbCh0aGlzLCBjb25zdHJ1Y3RvcnMpO1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGNvbnN0cnVjdG9ycy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB2YXIgY3RvciA9IGNvbnN0cnVjdG9yc1tpXTtcbiAgICAgIGlmICghaW5jbHVkZXMobGF5ZXJSZW5kZXJlckNvbnN0cnVjdG9ycywgY3RvcikpIHtcbiAgICAgICAgbGF5ZXJSZW5kZXJlckNvbnN0cnVjdG9ycy5wdXNoKGN0b3IpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gQ2FudmFzTWFwUmVuZGVyZXI7XG59KE1hcFJlbmRlcmVyKSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgQ2FudmFzTWFwUmVuZGVyZXI7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1hcC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyZXIvY2FudmFzL1RpbGVMYXllclxuICovXG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi4vLi4vdXRpbC5qcyc7XG5pbXBvcnQgTGF5ZXJUeXBlIGZyb20gJy4uLy4uL0xheWVyVHlwZS5qcyc7XG5pbXBvcnQgVGlsZVJhbmdlIGZyb20gJy4uLy4uL1RpbGVSYW5nZS5qcyc7XG5pbXBvcnQgVGlsZVN0YXRlIGZyb20gJy4uLy4uL1RpbGVTdGF0ZS5qcyc7XG5pbXBvcnQgVmlld0hpbnQgZnJvbSAnLi4vLi4vVmlld0hpbnQuanMnO1xuaW1wb3J0IHtjcmVhdGVDYW52YXNDb250ZXh0MkR9IGZyb20gJy4uLy4uL2RvbS5qcyc7XG5pbXBvcnQge2NvbnRhaW5zRXh0ZW50LCBjcmVhdGVFbXB0eSwgZXF1YWxzLCBnZXRJbnRlcnNlY3Rpb24sIGlzRW1wdHl9IGZyb20gJy4uLy4uL2V4dGVudC5qcyc7XG5pbXBvcnQgSW50ZXJtZWRpYXRlQ2FudmFzUmVuZGVyZXIgZnJvbSAnLi9JbnRlcm1lZGlhdGVDYW52YXMuanMnO1xuaW1wb3J0IHtjcmVhdGUgYXMgY3JlYXRlVHJhbnNmb3JtLCBjb21wb3NlIGFzIGNvbXBvc2VUcmFuc2Zvcm19IGZyb20gJy4uLy4uL3RyYW5zZm9ybS5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQ2FudmFzIHJlbmRlcmVyIGZvciB0aWxlIGxheWVycy5cbiAqIEBhcGlcbiAqL1xudmFyIENhbnZhc1RpbGVMYXllclJlbmRlcmVyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoSW50ZXJtZWRpYXRlQ2FudmFzUmVuZGVyZXIpIHtcbiAgZnVuY3Rpb24gQ2FudmFzVGlsZUxheWVyUmVuZGVyZXIodGlsZUxheWVyLCBvcHRfbm9Db250ZXh0KSB7XG5cbiAgICBJbnRlcm1lZGlhdGVDYW52YXNSZW5kZXJlci5jYWxsKHRoaXMsIHRpbGVMYXllcik7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRleHQgPSBvcHRfbm9Db250ZXh0ID8gbnVsbCA6IGNyZWF0ZUNhbnZhc0NvbnRleHQyRCgpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMub3ZlcnNhbXBsaW5nXztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZEV4dGVudF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZFJldmlzaW9uO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHshQXJyYXk8aW1wb3J0KFwiLi4vLi4vVGlsZS5qc1wiKS5kZWZhdWx0Pn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVkVGlsZXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5uZXdUaWxlc18gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRtcEV4dGVudCA9IGNyZWF0ZUVtcHR5KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLnRtcFRpbGVSYW5nZV8gPSBuZXcgVGlsZVJhbmdlKDAsIDAsIDAsIDApO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlVHJhbnNmb3JtXyA9IGNyZWF0ZVRyYW5zZm9ybSgpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy56RGlyZWN0aW9uID0gMDtcblxuICB9XG5cbiAgaWYgKCBJbnRlcm1lZGlhdGVDYW52YXNSZW5kZXJlciApIENhbnZhc1RpbGVMYXllclJlbmRlcmVyLl9fcHJvdG9fXyA9IEludGVybWVkaWF0ZUNhbnZhc1JlbmRlcmVyO1xuICBDYW52YXNUaWxlTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbnRlcm1lZGlhdGVDYW52YXNSZW5kZXJlciAmJiBJbnRlcm1lZGlhdGVDYW52YXNSZW5kZXJlci5wcm90b3R5cGUgKTtcbiAgQ2FudmFzVGlsZUxheWVyUmVuZGVyZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2FudmFzVGlsZUxheWVyUmVuZGVyZXI7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vVGlsZS5qc1wiKS5kZWZhdWx0fSB0aWxlIFRpbGUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRpbGUgaXMgZHJhd2FibGUuXG4gICAqL1xuICBDYW52YXNUaWxlTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuaXNEcmF3YWJsZVRpbGVfID0gZnVuY3Rpb24gaXNEcmF3YWJsZVRpbGVfICh0aWxlKSB7XG4gICAgdmFyIHRpbGVMYXllciA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vbGF5ZXIvVGlsZS5qc1wiKS5kZWZhdWx0fSAqLyAodGhpcy5nZXRMYXllcigpKTtcbiAgICB2YXIgdGlsZVN0YXRlID0gdGlsZS5nZXRTdGF0ZSgpO1xuICAgIHZhciB1c2VJbnRlcmltVGlsZXNPbkVycm9yID0gdGlsZUxheWVyLmdldFVzZUludGVyaW1UaWxlc09uRXJyb3IoKTtcbiAgICByZXR1cm4gdGlsZVN0YXRlID09IFRpbGVTdGF0ZS5MT0FERUQgfHxcbiAgICAgICAgdGlsZVN0YXRlID09IFRpbGVTdGF0ZS5FTVBUWSB8fFxuICAgICAgICB0aWxlU3RhdGUgPT0gVGlsZVN0YXRlLkVSUk9SICYmICF1c2VJbnRlcmltVGlsZXNPbkVycm9yO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0geiBUaWxlIGNvb3JkaW5hdGUgei5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggVGlsZSBjb29yZGluYXRlIHguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IFRpbGUgY29vcmRpbmF0ZSB5LlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgKiBAcmV0dXJuIHshaW1wb3J0KFwiLi4vLi4vVGlsZS5qc1wiKS5kZWZhdWx0fSBUaWxlLlxuICAgKi9cbiAgQ2FudmFzVGlsZUxheWVyUmVuZGVyZXIucHJvdG90eXBlLmdldFRpbGUgPSBmdW5jdGlvbiBnZXRUaWxlICh6LCB4LCB5LCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKSB7XG4gICAgdmFyIHRpbGVMYXllciA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vbGF5ZXIvVGlsZS5qc1wiKS5kZWZhdWx0fSAqLyAodGhpcy5nZXRMYXllcigpKTtcbiAgICB2YXIgdGlsZVNvdXJjZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vc291cmNlL1RpbGUuanNcIikuZGVmYXVsdH0gKi8gKHRpbGVMYXllci5nZXRTb3VyY2UoKSk7XG4gICAgdmFyIHRpbGUgPSB0aWxlU291cmNlLmdldFRpbGUoeiwgeCwgeSwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbik7XG4gICAgaWYgKHRpbGUuZ2V0U3RhdGUoKSA9PSBUaWxlU3RhdGUuRVJST1IpIHtcbiAgICAgIGlmICghdGlsZUxheWVyLmdldFVzZUludGVyaW1UaWxlc09uRXJyb3IoKSkge1xuICAgICAgICAvLyBXaGVuIHVzZUludGVyaW1UaWxlc09uRXJyb3IgaXMgZmFsc2UsIHdlIGNvbnNpZGVyIHRoZSBlcnJvciB0aWxlIGFzIGxvYWRlZC5cbiAgICAgICAgdGlsZS5zZXRTdGF0ZShUaWxlU3RhdGUuTE9BREVEKTtcbiAgICAgIH0gZWxzZSBpZiAodGlsZUxheWVyLmdldFByZWxvYWQoKSA+IDApIHtcbiAgICAgICAgLy8gUHJlbG9hZGVkIHRpbGVzIGZvciBsb3dlciByZXNvbHV0aW9ucyBtaWdodCBoYXZlIGZpbmlzaGVkIGxvYWRpbmcuXG4gICAgICAgIHRoaXMubmV3VGlsZXNfID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzRHJhd2FibGVUaWxlXyh0aWxlKSkge1xuICAgICAgdGlsZSA9IHRpbGUuZ2V0SW50ZXJpbVRpbGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRpbGU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNUaWxlTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUucHJlcGFyZUZyYW1lID0gZnVuY3Rpb24gcHJlcGFyZUZyYW1lIChmcmFtZVN0YXRlLCBsYXllclN0YXRlKSB7XG5cbiAgICB2YXIgcGl4ZWxSYXRpbyA9IGZyYW1lU3RhdGUucGl4ZWxSYXRpbztcbiAgICB2YXIgc2l6ZSA9IGZyYW1lU3RhdGUuc2l6ZTtcbiAgICB2YXIgdmlld1N0YXRlID0gZnJhbWVTdGF0ZS52aWV3U3RhdGU7XG4gICAgdmFyIHByb2plY3Rpb24gPSB2aWV3U3RhdGUucHJvamVjdGlvbjtcbiAgICB2YXIgdmlld1Jlc29sdXRpb24gPSB2aWV3U3RhdGUucmVzb2x1dGlvbjtcbiAgICB2YXIgdmlld0NlbnRlciA9IHZpZXdTdGF0ZS5jZW50ZXI7XG5cbiAgICB2YXIgdGlsZUxheWVyID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9sYXllci9UaWxlLmpzXCIpLmRlZmF1bHR9ICovICh0aGlzLmdldExheWVyKCkpO1xuICAgIHZhciB0aWxlU291cmNlID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9zb3VyY2UvVGlsZS5qc1wiKS5kZWZhdWx0fSAqLyAodGlsZUxheWVyLmdldFNvdXJjZSgpKTtcbiAgICB2YXIgc291cmNlUmV2aXNpb24gPSB0aWxlU291cmNlLmdldFJldmlzaW9uKCk7XG4gICAgdmFyIHRpbGVHcmlkID0gdGlsZVNvdXJjZS5nZXRUaWxlR3JpZEZvclByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gICAgdmFyIHogPSB0aWxlR3JpZC5nZXRaRm9yUmVzb2x1dGlvbih2aWV3UmVzb2x1dGlvbiwgdGhpcy56RGlyZWN0aW9uKTtcbiAgICB2YXIgdGlsZVJlc29sdXRpb24gPSB0aWxlR3JpZC5nZXRSZXNvbHV0aW9uKHopO1xuICAgIHZhciBvdmVyc2FtcGxpbmcgPSBNYXRoLnJvdW5kKHZpZXdSZXNvbHV0aW9uIC8gdGlsZVJlc29sdXRpb24pIHx8IDE7XG4gICAgdmFyIGV4dGVudCA9IGZyYW1lU3RhdGUuZXh0ZW50O1xuXG4gICAgaWYgKGxheWVyU3RhdGUuZXh0ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGV4dGVudCA9IGdldEludGVyc2VjdGlvbihleHRlbnQsIGxheWVyU3RhdGUuZXh0ZW50KTtcbiAgICB9XG4gICAgaWYgKGlzRW1wdHkoZXh0ZW50KSkge1xuICAgICAgLy8gUmV0dXJuIGZhbHNlIHRvIHByZXZlbnQgdGhlIHJlbmRlcmluZyBvZiB0aGUgbGF5ZXIuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHRpbGVSYW5nZSA9IHRpbGVHcmlkLmdldFRpbGVSYW5nZUZvckV4dGVudEFuZFooZXh0ZW50LCB6KTtcbiAgICB2YXIgaW1hZ2VFeHRlbnQgPSB0aWxlR3JpZC5nZXRUaWxlUmFuZ2VFeHRlbnQoeiwgdGlsZVJhbmdlKTtcblxuICAgIHZhciB0aWxlUGl4ZWxSYXRpbyA9IHRpbGVTb3VyY2UuZ2V0VGlsZVBpeGVsUmF0aW8ocGl4ZWxSYXRpbyk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0PG51bWJlciwgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4vLi4vVGlsZS5qc1wiKS5kZWZhdWx0Pj59XG4gICAgICovXG4gICAgdmFyIHRpbGVzVG9EcmF3QnlaID0ge307XG4gICAgdGlsZXNUb0RyYXdCeVpbel0gPSB7fTtcblxuICAgIHZhciBmaW5kTG9hZGVkVGlsZXMgPSB0aGlzLmNyZWF0ZUxvYWRlZFRpbGVGaW5kZXIoXG4gICAgICB0aWxlU291cmNlLCBwcm9qZWN0aW9uLCB0aWxlc1RvRHJhd0J5Wik7XG5cbiAgICB2YXIgaGludHMgPSBmcmFtZVN0YXRlLnZpZXdIaW50cztcbiAgICB2YXIgYW5pbWF0aW5nT3JJbnRlcmFjdGluZyA9IGhpbnRzW1ZpZXdIaW50LkFOSU1BVElOR10gfHwgaGludHNbVmlld0hpbnQuSU5URVJBQ1RJTkddO1xuXG4gICAgdmFyIHRtcEV4dGVudCA9IHRoaXMudG1wRXh0ZW50O1xuICAgIHZhciB0bXBUaWxlUmFuZ2UgPSB0aGlzLnRtcFRpbGVSYW5nZV87XG4gICAgdGhpcy5uZXdUaWxlc18gPSBmYWxzZTtcbiAgICB2YXIgdGlsZSwgeCwgeTtcbiAgICBmb3IgKHggPSB0aWxlUmFuZ2UubWluWDsgeCA8PSB0aWxlUmFuZ2UubWF4WDsgKyt4KSB7XG4gICAgICBmb3IgKHkgPSB0aWxlUmFuZ2UubWluWTsgeSA8PSB0aWxlUmFuZ2UubWF4WTsgKyt5KSB7XG4gICAgICAgIGlmIChEYXRlLm5vdygpIC0gZnJhbWVTdGF0ZS50aW1lID4gMTYgJiYgYW5pbWF0aW5nT3JJbnRlcmFjdGluZykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRpbGUgPSB0aGlzLmdldFRpbGUoeiwgeCwgeSwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbik7XG4gICAgICAgIGlmICh0aGlzLmlzRHJhd2FibGVUaWxlXyh0aWxlKSkge1xuICAgICAgICAgIHZhciB1aWQgPSBnZXRVaWQodGhpcyk7XG4gICAgICAgICAgaWYgKHRpbGUuZ2V0U3RhdGUoKSA9PSBUaWxlU3RhdGUuTE9BREVEKSB7XG4gICAgICAgICAgICB0aWxlc1RvRHJhd0J5Wlt6XVt0aWxlLnRpbGVDb29yZC50b1N0cmluZygpXSA9IHRpbGU7XG4gICAgICAgICAgICB2YXIgaW5UcmFuc2l0aW9uID0gdGlsZS5pblRyYW5zaXRpb24odWlkKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5uZXdUaWxlc18gJiYgKGluVHJhbnNpdGlvbiB8fCB0aGlzLnJlbmRlcmVkVGlsZXMuaW5kZXhPZih0aWxlKSA9PT0gLTEpKSB7XG4gICAgICAgICAgICAgIHRoaXMubmV3VGlsZXNfID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRpbGUuZ2V0QWxwaGEodWlkLCBmcmFtZVN0YXRlLnRpbWUpID09PSAxKSB7XG4gICAgICAgICAgICAvLyBkb24ndCBsb29rIGZvciBhbHQgdGlsZXMgaWYgYWxwaGEgaXMgMVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoaWxkVGlsZVJhbmdlID0gdGlsZUdyaWQuZ2V0VGlsZUNvb3JkQ2hpbGRUaWxlUmFuZ2UoXG4gICAgICAgICAgdGlsZS50aWxlQ29vcmQsIHRtcFRpbGVSYW5nZSwgdG1wRXh0ZW50KTtcbiAgICAgICAgdmFyIGNvdmVyZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGNoaWxkVGlsZVJhbmdlKSB7XG4gICAgICAgICAgY292ZXJlZCA9IGZpbmRMb2FkZWRUaWxlcyh6ICsgMSwgY2hpbGRUaWxlUmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY292ZXJlZCkge1xuICAgICAgICAgIHRpbGVHcmlkLmZvckVhY2hUaWxlQ29vcmRQYXJlbnRUaWxlUmFuZ2UoXG4gICAgICAgICAgICB0aWxlLnRpbGVDb29yZCwgZmluZExvYWRlZFRpbGVzLCBudWxsLCB0bXBUaWxlUmFuZ2UsIHRtcEV4dGVudCk7XG4gICAgICAgIH1cblxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZW5kZXJlZFJlc29sdXRpb24gPSB0aWxlUmVzb2x1dGlvbiAqIHBpeGVsUmF0aW8gLyB0aWxlUGl4ZWxSYXRpbyAqIG92ZXJzYW1wbGluZztcbiAgICBpZiAoISh0aGlzLnJlbmRlcmVkUmVzb2x1dGlvbiAmJiBEYXRlLm5vdygpIC0gZnJhbWVTdGF0ZS50aW1lID4gMTYgJiYgYW5pbWF0aW5nT3JJbnRlcmFjdGluZykgJiYgKFxuICAgICAgdGhpcy5uZXdUaWxlc18gfHxcbiAgICAgICAgICAhKHRoaXMucmVuZGVyZWRFeHRlbnRfICYmIGNvbnRhaW5zRXh0ZW50KHRoaXMucmVuZGVyZWRFeHRlbnRfLCBleHRlbnQpKSB8fFxuICAgICAgICAgIHRoaXMucmVuZGVyZWRSZXZpc2lvbiAhPSBzb3VyY2VSZXZpc2lvbiB8fFxuICAgICAgICAgIG92ZXJzYW1wbGluZyAhPSB0aGlzLm92ZXJzYW1wbGluZ18gfHxcbiAgICAgICAgICAhYW5pbWF0aW5nT3JJbnRlcmFjdGluZyAmJiByZW5kZXJlZFJlc29sdXRpb24gIT0gdGhpcy5yZW5kZXJlZFJlc29sdXRpb25cbiAgICApKSB7XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHRpbGVQaXhlbFNpemUgPSB0aWxlU291cmNlLmdldFRpbGVQaXhlbFNpemUoeiwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbik7XG4gICAgICAgIHZhciB3aWR0aCA9IE1hdGgucm91bmQodGlsZVJhbmdlLmdldFdpZHRoKCkgKiB0aWxlUGl4ZWxTaXplWzBdIC8gb3ZlcnNhbXBsaW5nKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IE1hdGgucm91bmQodGlsZVJhbmdlLmdldEhlaWdodCgpICogdGlsZVBpeGVsU2l6ZVsxXSAvIG92ZXJzYW1wbGluZyk7XG4gICAgICAgIHZhciBjYW52YXMgPSBjb250ZXh0LmNhbnZhcztcbiAgICAgICAgaWYgKGNhbnZhcy53aWR0aCAhPSB3aWR0aCB8fCBjYW52YXMuaGVpZ2h0ICE9IGhlaWdodCkge1xuICAgICAgICAgIHRoaXMub3ZlcnNhbXBsaW5nXyA9IG92ZXJzYW1wbGluZztcbiAgICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICgodGhpcy5yZW5kZXJlZEV4dGVudF8gJiYgIWVxdWFscyhpbWFnZUV4dGVudCwgdGhpcy5yZW5kZXJlZEV4dGVudF8pKSB8fFxuICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVkUmV2aXNpb24gIT0gc291cmNlUmV2aXNpb24pIHtcbiAgICAgICAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdmVyc2FtcGxpbmcgPSB0aGlzLm92ZXJzYW1wbGluZ187XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5yZW5kZXJlZFRpbGVzLmxlbmd0aCA9IDA7XG4gICAgICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovXG4gICAgICB2YXIgenMgPSBPYmplY3Qua2V5cyh0aWxlc1RvRHJhd0J5WikubWFwKE51bWJlcik7XG4gICAgICB6cy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgaWYgKGEgPT09IHopIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfSBlbHNlIGlmIChiID09PSB6KSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgY3VycmVudFJlc29sdXRpb24sIGN1cnJlbnRTY2FsZSwgY3VycmVudFRpbGVQaXhlbFNpemUsIGN1cnJlbnRaLCBpLCBpaTtcbiAgICAgIHZhciB0aWxlRXh0ZW50LCB0aWxlR3V0dGVyLCB0aWxlc1RvRHJhdywgdywgaDtcbiAgICAgIGZvciAoaSA9IDAsIGlpID0genMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBjdXJyZW50WiA9IHpzW2ldO1xuICAgICAgICBjdXJyZW50VGlsZVBpeGVsU2l6ZSA9IHRpbGVTb3VyY2UuZ2V0VGlsZVBpeGVsU2l6ZShjdXJyZW50WiwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbik7XG4gICAgICAgIGN1cnJlbnRSZXNvbHV0aW9uID0gdGlsZUdyaWQuZ2V0UmVzb2x1dGlvbihjdXJyZW50Wik7XG4gICAgICAgIGN1cnJlbnRTY2FsZSA9IGN1cnJlbnRSZXNvbHV0aW9uIC8gdGlsZVJlc29sdXRpb247XG4gICAgICAgIHRpbGVHdXR0ZXIgPSB0aWxlUGl4ZWxSYXRpbyAqIHRpbGVTb3VyY2UuZ2V0R3V0dGVyRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgICAgICAgdGlsZXNUb0RyYXcgPSB0aWxlc1RvRHJhd0J5WltjdXJyZW50Wl07XG4gICAgICAgIGZvciAodmFyIHRpbGVDb29yZEtleSBpbiB0aWxlc1RvRHJhdykge1xuICAgICAgICAgIHRpbGUgPSB0aWxlc1RvRHJhd1t0aWxlQ29vcmRLZXldO1xuICAgICAgICAgIHRpbGVFeHRlbnQgPSB0aWxlR3JpZC5nZXRUaWxlQ29vcmRFeHRlbnQodGlsZS5nZXRUaWxlQ29vcmQoKSwgdG1wRXh0ZW50KTtcbiAgICAgICAgICB4ID0gKHRpbGVFeHRlbnRbMF0gLSBpbWFnZUV4dGVudFswXSkgLyB0aWxlUmVzb2x1dGlvbiAqIHRpbGVQaXhlbFJhdGlvIC8gb3ZlcnNhbXBsaW5nO1xuICAgICAgICAgIHkgPSAoaW1hZ2VFeHRlbnRbM10gLSB0aWxlRXh0ZW50WzNdKSAvIHRpbGVSZXNvbHV0aW9uICogdGlsZVBpeGVsUmF0aW8gLyBvdmVyc2FtcGxpbmc7XG4gICAgICAgICAgdyA9IGN1cnJlbnRUaWxlUGl4ZWxTaXplWzBdICogY3VycmVudFNjYWxlIC8gb3ZlcnNhbXBsaW5nO1xuICAgICAgICAgIGggPSBjdXJyZW50VGlsZVBpeGVsU2l6ZVsxXSAqIGN1cnJlbnRTY2FsZSAvIG92ZXJzYW1wbGluZztcbiAgICAgICAgICB0aGlzLmRyYXdUaWxlSW1hZ2UodGlsZSwgZnJhbWVTdGF0ZSwgbGF5ZXJTdGF0ZSwgeCwgeSwgdywgaCwgdGlsZUd1dHRlciwgeiA9PT0gY3VycmVudFopO1xuICAgICAgICAgIHRoaXMucmVuZGVyZWRUaWxlcy5wdXNoKHRpbGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVuZGVyZWRSZXZpc2lvbiA9IHNvdXJjZVJldmlzaW9uO1xuICAgICAgdGhpcy5yZW5kZXJlZFJlc29sdXRpb24gPSB0aWxlUmVzb2x1dGlvbiAqIHBpeGVsUmF0aW8gLyB0aWxlUGl4ZWxSYXRpbyAqIG92ZXJzYW1wbGluZztcbiAgICAgIHRoaXMucmVuZGVyZWRFeHRlbnRfID0gaW1hZ2VFeHRlbnQ7XG4gICAgfVxuXG4gICAgdmFyIHNjYWxlID0gdGhpcy5yZW5kZXJlZFJlc29sdXRpb24gLyB2aWV3UmVzb2x1dGlvbjtcbiAgICB2YXIgdHJhbnNmb3JtID0gY29tcG9zZVRyYW5zZm9ybSh0aGlzLmltYWdlVHJhbnNmb3JtXyxcbiAgICAgIHBpeGVsUmF0aW8gKiBzaXplWzBdIC8gMiwgcGl4ZWxSYXRpbyAqIHNpemVbMV0gLyAyLFxuICAgICAgc2NhbGUsIHNjYWxlLFxuICAgICAgMCxcbiAgICAgICh0aGlzLnJlbmRlcmVkRXh0ZW50X1swXSAtIHZpZXdDZW50ZXJbMF0pIC8gdGhpcy5yZW5kZXJlZFJlc29sdXRpb24gKiBwaXhlbFJhdGlvLFxuICAgICAgKHZpZXdDZW50ZXJbMV0gLSB0aGlzLnJlbmRlcmVkRXh0ZW50X1szXSkgLyB0aGlzLnJlbmRlcmVkUmVzb2x1dGlvbiAqIHBpeGVsUmF0aW8pO1xuICAgIGNvbXBvc2VUcmFuc2Zvcm0odGhpcy5jb29yZGluYXRlVG9DYW52YXNQaXhlbFRyYW5zZm9ybSxcbiAgICAgIHBpeGVsUmF0aW8gKiBzaXplWzBdIC8gMiAtIHRyYW5zZm9ybVs0XSwgcGl4ZWxSYXRpbyAqIHNpemVbMV0gLyAyIC0gdHJhbnNmb3JtWzVdLFxuICAgICAgcGl4ZWxSYXRpbyAvIHZpZXdSZXNvbHV0aW9uLCAtcGl4ZWxSYXRpbyAvIHZpZXdSZXNvbHV0aW9uLFxuICAgICAgMCxcbiAgICAgIC12aWV3Q2VudGVyWzBdLCAtdmlld0NlbnRlclsxXSk7XG5cblxuICAgIHRoaXMudXBkYXRlVXNlZFRpbGVzKGZyYW1lU3RhdGUudXNlZFRpbGVzLCB0aWxlU291cmNlLCB6LCB0aWxlUmFuZ2UpO1xuICAgIHRoaXMubWFuYWdlVGlsZVB5cmFtaWQoZnJhbWVTdGF0ZSwgdGlsZVNvdXJjZSwgdGlsZUdyaWQsIHBpeGVsUmF0aW8sXG4gICAgICBwcm9qZWN0aW9uLCBleHRlbnQsIHosIHRpbGVMYXllci5nZXRQcmVsb2FkKCkpO1xuICAgIHRoaXMuc2NoZWR1bGVFeHBpcmVDYWNoZShmcmFtZVN0YXRlLCB0aWxlU291cmNlKTtcblxuICAgIHJldHVybiB0aGlzLnJlbmRlcmVkVGlsZXMubGVuZ3RoID4gMDtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9UaWxlLmpzXCIpLmRlZmF1bHR9IHRpbGUgVGlsZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9QbHVnZ2FibGVNYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9sYXllci9MYXllci5qc1wiKS5TdGF0ZX0gbGF5ZXJTdGF0ZSBMYXllciBzdGF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggTGVmdCBvZiB0aGUgdGlsZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgVG9wIG9mIHRoZSB0aWxlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdyBXaWR0aCBvZiB0aGUgdGlsZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGggSGVpZ2h0IG9mIHRoZSB0aWxlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZ3V0dGVyIFRpbGUgZ3V0dGVyLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHRyYW5zaXRpb24gQXBwbHkgYW4gYWxwaGEgdHJhbnNpdGlvbi5cbiAgICovXG4gIENhbnZhc1RpbGVMYXllclJlbmRlcmVyLnByb3RvdHlwZS5kcmF3VGlsZUltYWdlID0gZnVuY3Rpb24gZHJhd1RpbGVJbWFnZSAodGlsZSwgZnJhbWVTdGF0ZSwgbGF5ZXJTdGF0ZSwgeCwgeSwgdywgaCwgZ3V0dGVyLCB0cmFuc2l0aW9uKSB7XG4gICAgdmFyIGltYWdlID0gdGhpcy5nZXRUaWxlSW1hZ2UodGlsZSk7XG4gICAgaWYgKCFpbWFnZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdWlkID0gZ2V0VWlkKHRoaXMpO1xuICAgIHZhciBhbHBoYSA9IHRyYW5zaXRpb24gPyB0aWxlLmdldEFscGhhKHVpZCwgZnJhbWVTdGF0ZS50aW1lKSA6IDE7XG4gICAgdmFyIHRpbGVMYXllciA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vbGF5ZXIvVGlsZS5qc1wiKS5kZWZhdWx0fSAqLyAodGhpcy5nZXRMYXllcigpKTtcbiAgICB2YXIgdGlsZVNvdXJjZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vc291cmNlL1RpbGUuanNcIikuZGVmYXVsdH0gKi8gKHRpbGVMYXllci5nZXRTb3VyY2UoKSk7XG4gICAgaWYgKGFscGhhID09PSAxICYmICF0aWxlU291cmNlLmdldE9wYXF1ZShmcmFtZVN0YXRlLnZpZXdTdGF0ZS5wcm9qZWN0aW9uKSkge1xuICAgICAgdGhpcy5jb250ZXh0LmNsZWFyUmVjdCh4LCB5LCB3LCBoKTtcbiAgICB9XG4gICAgdmFyIGFscGhhQ2hhbmdlZCA9IGFscGhhICE9PSB0aGlzLmNvbnRleHQuZ2xvYmFsQWxwaGE7XG4gICAgaWYgKGFscGhhQ2hhbmdlZCkge1xuICAgICAgdGhpcy5jb250ZXh0LnNhdmUoKTtcbiAgICAgIHRoaXMuY29udGV4dC5nbG9iYWxBbHBoYSA9IGFscGhhO1xuICAgIH1cbiAgICB0aGlzLmNvbnRleHQuZHJhd0ltYWdlKGltYWdlLCBndXR0ZXIsIGd1dHRlcixcbiAgICAgIGltYWdlLndpZHRoIC0gMiAqIGd1dHRlciwgaW1hZ2UuaGVpZ2h0IC0gMiAqIGd1dHRlciwgeCwgeSwgdywgaCk7XG5cbiAgICBpZiAoYWxwaGFDaGFuZ2VkKSB7XG4gICAgICB0aGlzLmNvbnRleHQucmVzdG9yZSgpO1xuICAgIH1cbiAgICBpZiAoYWxwaGEgIT09IDEpIHtcbiAgICAgIGZyYW1lU3RhdGUuYW5pbWF0ZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICB0aWxlLmVuZFRyYW5zaXRpb24odWlkKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNUaWxlTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuZ2V0SW1hZ2UgPSBmdW5jdGlvbiBnZXRJbWFnZSAoKSB7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgcmV0dXJuIGNvbnRleHQgPyBjb250ZXh0LmNhbnZhcyA6IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNUaWxlTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuZ2V0SW1hZ2VUcmFuc2Zvcm0gPSBmdW5jdGlvbiBnZXRJbWFnZVRyYW5zZm9ybSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW1hZ2VUcmFuc2Zvcm1fO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGltYWdlIGZyb20gYSB0aWxlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL1RpbGUuanNcIikuZGVmYXVsdH0gdGlsZSBUaWxlLlxuICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudHxIVE1MSW1hZ2VFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR9IEltYWdlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBDYW52YXNUaWxlTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuZ2V0VGlsZUltYWdlID0gZnVuY3Rpb24gZ2V0VGlsZUltYWdlICh0aWxlKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vSW1hZ2VUaWxlLmpzXCIpLmRlZmF1bHR9ICovICh0aWxlKS5nZXRJbWFnZSgpO1xuICB9O1xuXG4gIHJldHVybiBDYW52YXNUaWxlTGF5ZXJSZW5kZXJlcjtcbn0oSW50ZXJtZWRpYXRlQ2FudmFzUmVuZGVyZXIpKTtcblxuXG4vKipcbiAqIERldGVybWluZSBpZiB0aGlzIHJlbmRlcmVyIGhhbmRsZXMgdGhlIHByb3ZpZGVkIGxheWVyLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0fSBsYXllciBUaGUgY2FuZGlkYXRlIGxheWVyLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHJlbmRlcmVyIGNhbiByZW5kZXIgdGhlIGxheWVyLlxuICovXG5DYW52YXNUaWxlTGF5ZXJSZW5kZXJlclsnaGFuZGxlcyddID0gZnVuY3Rpb24obGF5ZXIpIHtcbiAgcmV0dXJuIGxheWVyLmdldFR5cGUoKSA9PT0gTGF5ZXJUeXBlLlRJTEU7XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlIGEgbGF5ZXIgcmVuZGVyZXIuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcC5qc1wiKS5kZWZhdWx0fSBtYXBSZW5kZXJlciBUaGUgbWFwIHJlbmRlcmVyLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0fSBsYXllciBUaGUgbGF5ZXIgdG8gYmUgcmVuZGVyZXJkLlxuICogQHJldHVybiB7Q2FudmFzVGlsZUxheWVyUmVuZGVyZXJ9IFRoZSBsYXllciByZW5kZXJlci5cbiAqL1xuQ2FudmFzVGlsZUxheWVyUmVuZGVyZXJbJ2NyZWF0ZSddID0gZnVuY3Rpb24obWFwUmVuZGVyZXIsIGxheWVyKSB7XG4gIHJldHVybiBuZXcgQ2FudmFzVGlsZUxheWVyUmVuZGVyZXIoLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9sYXllci9UaWxlLmpzXCIpLmRlZmF1bHR9ICovIChsYXllcikpO1xufTtcblxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vLi4vbGF5ZXIvVGlsZS5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uLy4uL2xheWVyL1ZlY3RvclRpbGUuanNcIikuZGVmYXVsdH1cbiAqL1xuQ2FudmFzVGlsZUxheWVyUmVuZGVyZXIucHJvdG90eXBlLmdldExheWVyO1xuXG5cbmV4cG9ydCBkZWZhdWx0IENhbnZhc1RpbGVMYXllclJlbmRlcmVyO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaWxlTGF5ZXIuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlcmVyL2NhbnZhcy9WZWN0b3JMYXllclxuICovXG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi4vLi4vdXRpbC5qcyc7XG5pbXBvcnQgTGF5ZXJUeXBlIGZyb20gJy4uLy4uL0xheWVyVHlwZS5qcyc7XG5pbXBvcnQgVmlld0hpbnQgZnJvbSAnLi4vLi4vVmlld0hpbnQuanMnO1xuaW1wb3J0IHtjcmVhdGVDYW52YXNDb250ZXh0MkR9IGZyb20gJy4uLy4uL2RvbS5qcyc7XG5pbXBvcnQge2xpc3RlbiwgdW5saXN0ZW59IGZyb20gJy4uLy4uL2V2ZW50cy5qcyc7XG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4uLy4uL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IHJidXNoIGZyb20gJ3JidXNoJztcbmltcG9ydCB7YnVmZmVyLCBjcmVhdGVFbXB0eSwgY29udGFpbnNFeHRlbnQsIGdldFdpZHRofSBmcm9tICcuLi8uLi9leHRlbnQuanMnO1xuaW1wb3J0IFJlbmRlckV2ZW50VHlwZSBmcm9tICcuLi8uLi9yZW5kZXIvRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7bGFiZWxDYWNoZSwgcm90YXRlQXRPZmZzZXR9IGZyb20gJy4uLy4uL3JlbmRlci9jYW52YXMuanMnO1xuaW1wb3J0IENhbnZhc1JlcGxheUdyb3VwIGZyb20gJy4uLy4uL3JlbmRlci9jYW52YXMvUmVwbGF5R3JvdXAuanMnO1xuaW1wb3J0IENhbnZhc0xheWVyUmVuZGVyZXIgZnJvbSAnLi9MYXllci5qcyc7XG5pbXBvcnQge2RlZmF1bHRPcmRlciBhcyBkZWZhdWx0UmVuZGVyT3JkZXIsIGdldFRvbGVyYW5jZSBhcyBnZXRSZW5kZXJUb2xlcmFuY2UsIGdldFNxdWFyZWRUb2xlcmFuY2UgYXMgZ2V0U3F1YXJlZFJlbmRlclRvbGVyYW5jZSwgcmVuZGVyRmVhdHVyZX0gZnJvbSAnLi4vdmVjdG9yLmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBDYW52YXMgcmVuZGVyZXIgZm9yIHZlY3RvciBsYXllcnMuXG4gKiBAYXBpXG4gKi9cbnZhciBDYW52YXNWZWN0b3JMYXllclJlbmRlcmVyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoQ2FudmFzTGF5ZXJSZW5kZXJlcikge1xuICBmdW5jdGlvbiBDYW52YXNWZWN0b3JMYXllclJlbmRlcmVyKHZlY3RvckxheWVyKSB7XG5cbiAgICBDYW52YXNMYXllclJlbmRlcmVyLmNhbGwodGhpcywgdmVjdG9yTGF5ZXIpO1xuXG4gICAgLyoqXG4gICAgICogRGVjbHV0dGVyIHRyZWUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmRlY2x1dHRlclRyZWVfID0gdmVjdG9yTGF5ZXIuZ2V0RGVjbHV0dGVyKCkgPyByYnVzaCg5LCB1bmRlZmluZWQpIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5kaXJ0eV8gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVkUmV2aXNpb25fID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZFJlc29sdXRpb25fID0gTmFOO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVkRXh0ZW50XyA9IGNyZWF0ZUVtcHR5KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQsIGltcG9ydChcIi4uLy4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdCk6IG51bWJlcnxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZWRSZW5kZXJPcmRlcl8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vcmVuZGVyL2NhbnZhcy9SZXBsYXlHcm91cC5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMucmVwbGF5R3JvdXBfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEEgbmV3IHJlcGxheSBncm91cCBoYWQgdG8gYmUgY3JlYXRlZCBieSBgcHJlcGFyZUZyYW1lKClgXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZXBsYXlHcm91cENoYW5nZWQgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0MkQoKTtcblxuICAgIGxpc3RlbihsYWJlbENhY2hlLCBFdmVudFR5cGUuQ0xFQVIsIHRoaXMuaGFuZGxlRm9udHNDaGFuZ2VkXywgdGhpcyk7XG5cbiAgfVxuXG4gIGlmICggQ2FudmFzTGF5ZXJSZW5kZXJlciApIENhbnZhc1ZlY3RvckxheWVyUmVuZGVyZXIuX19wcm90b19fID0gQ2FudmFzTGF5ZXJSZW5kZXJlcjtcbiAgQ2FudmFzVmVjdG9yTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDYW52YXNMYXllclJlbmRlcmVyICYmIENhbnZhc0xheWVyUmVuZGVyZXIucHJvdG90eXBlICk7XG4gIENhbnZhc1ZlY3RvckxheWVyUmVuZGVyZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2FudmFzVmVjdG9yTGF5ZXJSZW5kZXJlcjtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENhbnZhc1ZlY3RvckxheWVyUmVuZGVyZXIucHJvdG90eXBlLmRpc3Bvc2VJbnRlcm5hbCA9IGZ1bmN0aW9uIGRpc3Bvc2VJbnRlcm5hbCAoKSB7XG4gICAgdW5saXN0ZW4obGFiZWxDYWNoZSwgRXZlbnRUeXBlLkNMRUFSLCB0aGlzLmhhbmRsZUZvbnRzQ2hhbmdlZF8sIHRoaXMpO1xuICAgIENhbnZhc0xheWVyUmVuZGVyZXIucHJvdG90eXBlLmRpc3Bvc2VJbnRlcm5hbC5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBDb250ZXh0LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL1BsdWdnYWJsZU1hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2xheWVyL0xheWVyLmpzXCIpLlN0YXRlfSBsYXllclN0YXRlIExheWVyIHN0YXRlLlxuICAgKi9cbiAgQ2FudmFzVmVjdG9yTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuY29tcG9zZSA9IGZ1bmN0aW9uIGNvbXBvc2UgKGNvbnRleHQsIGZyYW1lU3RhdGUsIGxheWVyU3RhdGUpIHtcbiAgICB2YXIgZXh0ZW50ID0gZnJhbWVTdGF0ZS5leHRlbnQ7XG4gICAgdmFyIHBpeGVsUmF0aW8gPSBmcmFtZVN0YXRlLnBpeGVsUmF0aW87XG4gICAgdmFyIHNraXBwZWRGZWF0dXJlVWlkcyA9IGxheWVyU3RhdGUubWFuYWdlZCA/XG4gICAgICBmcmFtZVN0YXRlLnNraXBwZWRGZWF0dXJlVWlkcyA6IHt9O1xuICAgIHZhciB2aWV3U3RhdGUgPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZTtcbiAgICB2YXIgcHJvamVjdGlvbiA9IHZpZXdTdGF0ZS5wcm9qZWN0aW9uO1xuICAgIHZhciByb3RhdGlvbiA9IHZpZXdTdGF0ZS5yb3RhdGlvbjtcbiAgICB2YXIgcHJvamVjdGlvbkV4dGVudCA9IHByb2plY3Rpb24uZ2V0RXh0ZW50KCk7XG4gICAgdmFyIHZlY3RvclNvdXJjZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vc291cmNlL1ZlY3Rvci5qc1wiKS5kZWZhdWx0fSAqLyAodGhpcy5nZXRMYXllcigpLmdldFNvdXJjZSgpKTtcblxuICAgIHZhciB0cmFuc2Zvcm0gPSB0aGlzLmdldFRyYW5zZm9ybShmcmFtZVN0YXRlLCAwKTtcblxuICAgIC8vIGNsaXBwZWQgcmVuZGVyaW5nIGlmIGxheWVyIGV4dGVudCBpcyBzZXRcbiAgICB2YXIgY2xpcEV4dGVudCA9IGxheWVyU3RhdGUuZXh0ZW50O1xuICAgIHZhciBjbGlwcGVkID0gY2xpcEV4dGVudCAhPT0gdW5kZWZpbmVkO1xuICAgIGlmIChjbGlwcGVkKSB7XG4gICAgICB0aGlzLmNsaXAoY29udGV4dCwgZnJhbWVTdGF0ZSwgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fSAqLyAoY2xpcEV4dGVudCkpO1xuICAgIH1cbiAgICB2YXIgcmVwbGF5R3JvdXAgPSB0aGlzLnJlcGxheUdyb3VwXztcbiAgICBpZiAocmVwbGF5R3JvdXAgJiYgIXJlcGxheUdyb3VwLmlzRW1wdHkoKSkge1xuICAgICAgaWYgKHRoaXMuZGVjbHV0dGVyVHJlZV8pIHtcbiAgICAgICAgdGhpcy5kZWNsdXR0ZXJUcmVlXy5jbGVhcigpO1xuICAgICAgfVxuICAgICAgdmFyIGxheWVyID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9sYXllci9WZWN0b3IuanNcIikuZGVmYXVsdH0gKi8gKHRoaXMuZ2V0TGF5ZXIoKSk7XG4gICAgICB2YXIgZHJhd09mZnNldFggPSAwO1xuICAgICAgdmFyIGRyYXdPZmZzZXRZID0gMDtcbiAgICAgIHZhciByZXBsYXlDb250ZXh0O1xuICAgICAgdmFyIHRyYW5zcGFyZW50TGF5ZXIgPSBsYXllclN0YXRlLm9wYWNpdHkgIT09IDE7XG4gICAgICB2YXIgaGFzUmVuZGVyTGlzdGVuZXJzID0gbGF5ZXIuaGFzTGlzdGVuZXIoUmVuZGVyRXZlbnRUeXBlLlJFTkRFUik7XG4gICAgICBpZiAodHJhbnNwYXJlbnRMYXllciB8fCBoYXNSZW5kZXJMaXN0ZW5lcnMpIHtcbiAgICAgICAgdmFyIGRyYXdXaWR0aCA9IGNvbnRleHQuY2FudmFzLndpZHRoO1xuICAgICAgICB2YXIgZHJhd0hlaWdodCA9IGNvbnRleHQuY2FudmFzLmhlaWdodDtcbiAgICAgICAgaWYgKHJvdGF0aW9uKSB7XG4gICAgICAgICAgdmFyIGRyYXdTaXplID0gTWF0aC5yb3VuZChNYXRoLnNxcnQoZHJhd1dpZHRoICogZHJhd1dpZHRoICsgZHJhd0hlaWdodCAqIGRyYXdIZWlnaHQpKTtcbiAgICAgICAgICBkcmF3T2Zmc2V0WCA9IChkcmF3U2l6ZSAtIGRyYXdXaWR0aCkgLyAyO1xuICAgICAgICAgIGRyYXdPZmZzZXRZID0gKGRyYXdTaXplIC0gZHJhd0hlaWdodCkgLyAyO1xuICAgICAgICAgIGRyYXdXaWR0aCA9IGRyYXdIZWlnaHQgPSBkcmF3U2l6ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXNpemUgYW5kIGNsZWFyXG4gICAgICAgIHRoaXMuY29udGV4dC5jYW52YXMud2lkdGggPSBkcmF3V2lkdGg7XG4gICAgICAgIHRoaXMuY29udGV4dC5jYW52YXMuaGVpZ2h0ID0gZHJhd0hlaWdodDtcbiAgICAgICAgcmVwbGF5Q29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcGxheUNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgfVxuXG4gICAgICB2YXIgYWxwaGEgPSByZXBsYXlDb250ZXh0Lmdsb2JhbEFscGhhO1xuICAgICAgaWYgKCF0cmFuc3BhcmVudExheWVyKSB7XG4gICAgICAgIC8vIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLCBjb250ZXh0LnNhdmUgLyBjb250ZXh0LnJlc3RvcmUgaXMgbm90IHVzZWRcbiAgICAgICAgLy8gdG8gc2F2ZSBhbmQgcmVzdG9yZSB0aGUgdHJhbnNmb3JtYXRpb24gbWF0cml4IGFuZCB0aGUgb3BhY2l0eS5cbiAgICAgICAgLy8gc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2NvbnRleHQtc2F2ZS1yZXN0b3JlLXZlcnN1cy12YXJpYWJsZVxuICAgICAgICByZXBsYXlDb250ZXh0Lmdsb2JhbEFscGhhID0gbGF5ZXJTdGF0ZS5vcGFjaXR5O1xuICAgICAgfVxuXG4gICAgICBpZiAocmVwbGF5Q29udGV4dCAhPSBjb250ZXh0KSB7XG4gICAgICAgIHJlcGxheUNvbnRleHQudHJhbnNsYXRlKGRyYXdPZmZzZXRYLCBkcmF3T2Zmc2V0WSk7XG4gICAgICB9XG5cbiAgICAgIHZhciB2aWV3SGludHMgPSBmcmFtZVN0YXRlLnZpZXdIaW50cztcbiAgICAgIHZhciBzbmFwVG9QaXhlbCA9ICEodmlld0hpbnRzW1ZpZXdIaW50LkFOSU1BVElOR10gfHwgdmlld0hpbnRzW1ZpZXdIaW50LklOVEVSQUNUSU5HXSk7XG4gICAgICB2YXIgd2lkdGggPSBmcmFtZVN0YXRlLnNpemVbMF0gKiBwaXhlbFJhdGlvO1xuICAgICAgdmFyIGhlaWdodCA9IGZyYW1lU3RhdGUuc2l6ZVsxXSAqIHBpeGVsUmF0aW87XG4gICAgICByb3RhdGVBdE9mZnNldChyZXBsYXlDb250ZXh0LCAtcm90YXRpb24sXG4gICAgICAgIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gICAgICByZXBsYXlHcm91cC5yZXBsYXkocmVwbGF5Q29udGV4dCwgdHJhbnNmb3JtLCByb3RhdGlvbiwgc2tpcHBlZEZlYXR1cmVVaWRzLCBzbmFwVG9QaXhlbCk7XG4gICAgICBpZiAodmVjdG9yU291cmNlLmdldFdyYXBYKCkgJiYgcHJvamVjdGlvbi5jYW5XcmFwWCgpICYmXG4gICAgICAgICAgIWNvbnRhaW5zRXh0ZW50KHByb2plY3Rpb25FeHRlbnQsIGV4dGVudCkpIHtcbiAgICAgICAgdmFyIHN0YXJ0WCA9IGV4dGVudFswXTtcbiAgICAgICAgdmFyIHdvcmxkV2lkdGggPSBnZXRXaWR0aChwcm9qZWN0aW9uRXh0ZW50KTtcbiAgICAgICAgdmFyIHdvcmxkID0gMDtcbiAgICAgICAgdmFyIG9mZnNldFg7XG4gICAgICAgIHdoaWxlIChzdGFydFggPCBwcm9qZWN0aW9uRXh0ZW50WzBdKSB7XG4gICAgICAgICAgLS13b3JsZDtcbiAgICAgICAgICBvZmZzZXRYID0gd29ybGRXaWR0aCAqIHdvcmxkO1xuICAgICAgICAgIHRyYW5zZm9ybSA9IHRoaXMuZ2V0VHJhbnNmb3JtKGZyYW1lU3RhdGUsIG9mZnNldFgpO1xuICAgICAgICAgIHJlcGxheUdyb3VwLnJlcGxheShyZXBsYXlDb250ZXh0LCB0cmFuc2Zvcm0sIHJvdGF0aW9uLCBza2lwcGVkRmVhdHVyZVVpZHMsIHNuYXBUb1BpeGVsKTtcbiAgICAgICAgICBzdGFydFggKz0gd29ybGRXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICB3b3JsZCA9IDA7XG4gICAgICAgIHN0YXJ0WCA9IGV4dGVudFsyXTtcbiAgICAgICAgd2hpbGUgKHN0YXJ0WCA+IHByb2plY3Rpb25FeHRlbnRbMl0pIHtcbiAgICAgICAgICArK3dvcmxkO1xuICAgICAgICAgIG9mZnNldFggPSB3b3JsZFdpZHRoICogd29ybGQ7XG4gICAgICAgICAgdHJhbnNmb3JtID0gdGhpcy5nZXRUcmFuc2Zvcm0oZnJhbWVTdGF0ZSwgb2Zmc2V0WCk7XG4gICAgICAgICAgcmVwbGF5R3JvdXAucmVwbGF5KHJlcGxheUNvbnRleHQsIHRyYW5zZm9ybSwgcm90YXRpb24sIHNraXBwZWRGZWF0dXJlVWlkcywgc25hcFRvUGl4ZWwpO1xuICAgICAgICAgIHN0YXJ0WCAtPSB3b3JsZFdpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByb3RhdGVBdE9mZnNldChyZXBsYXlDb250ZXh0LCByb3RhdGlvbixcbiAgICAgICAgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcblxuICAgICAgaWYgKGhhc1JlbmRlckxpc3RlbmVycykge1xuICAgICAgICB0aGlzLmRpc3BhdGNoUmVuZGVyRXZlbnQocmVwbGF5Q29udGV4dCwgZnJhbWVTdGF0ZSwgdHJhbnNmb3JtKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXBsYXlDb250ZXh0ICE9IGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHRyYW5zcGFyZW50TGF5ZXIpIHtcbiAgICAgICAgICB2YXIgbWFpbkNvbnRleHRBbHBoYSA9IGNvbnRleHQuZ2xvYmFsQWxwaGE7XG4gICAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGxheWVyU3RhdGUub3BhY2l0eTtcbiAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShyZXBsYXlDb250ZXh0LmNhbnZhcywgLWRyYXdPZmZzZXRYLCAtZHJhd09mZnNldFkpO1xuICAgICAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBtYWluQ29udGV4dEFscGhhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKHJlcGxheUNvbnRleHQuY2FudmFzLCAtZHJhd09mZnNldFgsIC1kcmF3T2Zmc2V0WSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVwbGF5Q29udGV4dC50cmFuc2xhdGUoLWRyYXdPZmZzZXRYLCAtZHJhd09mZnNldFkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRyYW5zcGFyZW50TGF5ZXIpIHtcbiAgICAgICAgcmVwbGF5Q29udGV4dC5nbG9iYWxBbHBoYSA9IGFscGhhO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjbGlwcGVkKSB7XG4gICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNWZWN0b3JMYXllclJlbmRlcmVyLnByb3RvdHlwZS5jb21wb3NlRnJhbWUgPSBmdW5jdGlvbiBjb21wb3NlRnJhbWUgKGZyYW1lU3RhdGUsIGxheWVyU3RhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy5nZXRUcmFuc2Zvcm0oZnJhbWVTdGF0ZSwgMCk7XG4gICAgdGhpcy5wcmVDb21wb3NlKGNvbnRleHQsIGZyYW1lU3RhdGUsIHRyYW5zZm9ybSk7XG4gICAgdGhpcy5jb21wb3NlKGNvbnRleHQsIGZyYW1lU3RhdGUsIGxheWVyU3RhdGUpO1xuICAgIHRoaXMucG9zdENvbXBvc2UoY29udGV4dCwgZnJhbWVTdGF0ZSwgbGF5ZXJTdGF0ZSwgdHJhbnNmb3JtKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENhbnZhc1ZlY3RvckxheWVyUmVuZGVyZXIucHJvdG90eXBlLmZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlID0gZnVuY3Rpb24gZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGUgKGNvb3JkaW5hdGUsIGZyYW1lU3RhdGUsIGhpdFRvbGVyYW5jZSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBpZiAoIXRoaXMucmVwbGF5R3JvdXBfKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmVzb2x1dGlvbiA9IGZyYW1lU3RhdGUudmlld1N0YXRlLnJlc29sdXRpb247XG4gICAgICB2YXIgcm90YXRpb24gPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZS5yb3RhdGlvbjtcbiAgICAgIHZhciBsYXllciA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vbGF5ZXIvVmVjdG9yLmpzXCIpLmRlZmF1bHR9ICovICh0aGlzLmdldExheWVyKCkpO1xuICAgICAgLyoqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgYm9vbGVhbj59ICovXG4gICAgICB2YXIgZmVhdHVyZXMgPSB7fTtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLnJlcGxheUdyb3VwXy5mb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZShjb29yZGluYXRlLCByZXNvbHV0aW9uLCByb3RhdGlvbiwgaGl0VG9sZXJhbmNlLCB7fSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fSBDYWxsYmFjayByZXN1bHQuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbihmZWF0dXJlKSB7XG4gICAgICAgICAgdmFyIGtleSA9IGdldFVpZChmZWF0dXJlKTtcbiAgICAgICAgICBpZiAoIShrZXkgaW4gZmVhdHVyZXMpKSB7XG4gICAgICAgICAgICBmZWF0dXJlc1trZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIGZlYXR1cmUsIGxheWVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIG51bGwpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHR9IGV2ZW50IEV2ZW50LlxuICAgKi9cbiAgQ2FudmFzVmVjdG9yTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuaGFuZGxlRm9udHNDaGFuZ2VkXyA9IGZ1bmN0aW9uIGhhbmRsZUZvbnRzQ2hhbmdlZF8gKGV2ZW50KSB7XG4gICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcigpO1xuICAgIGlmIChsYXllci5nZXRWaXNpYmxlKCkgJiYgdGhpcy5yZXBsYXlHcm91cF8pIHtcbiAgICAgIGxheWVyLmNoYW5nZWQoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBjaGFuZ2VzIGluIGltYWdlIHN0eWxlIHN0YXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0fSBldmVudCBJbWFnZSBzdHlsZSBjaGFuZ2UgZXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBDYW52YXNWZWN0b3JMYXllclJlbmRlcmVyLnByb3RvdHlwZS5oYW5kbGVTdHlsZUltYWdlQ2hhbmdlXyA9IGZ1bmN0aW9uIGhhbmRsZVN0eWxlSW1hZ2VDaGFuZ2VfIChldmVudCkge1xuICAgIHRoaXMucmVuZGVySWZSZWFkeUFuZFZpc2libGUoKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENhbnZhc1ZlY3RvckxheWVyUmVuZGVyZXIucHJvdG90eXBlLnByZXBhcmVGcmFtZSA9IGZ1bmN0aW9uIHByZXBhcmVGcmFtZSAoZnJhbWVTdGF0ZSwgbGF5ZXJTdGF0ZSkge1xuICAgIHZhciB2ZWN0b3JMYXllciA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vbGF5ZXIvVmVjdG9yLmpzXCIpLmRlZmF1bHR9ICovICh0aGlzLmdldExheWVyKCkpO1xuICAgIHZhciB2ZWN0b3JTb3VyY2UgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL3NvdXJjZS9WZWN0b3IuanNcIikuZGVmYXVsdH0gKi8gKHZlY3RvckxheWVyLmdldFNvdXJjZSgpKTtcblxuICAgIHZhciBhbmltYXRpbmcgPSBmcmFtZVN0YXRlLnZpZXdIaW50c1tWaWV3SGludC5BTklNQVRJTkddO1xuICAgIHZhciBpbnRlcmFjdGluZyA9IGZyYW1lU3RhdGUudmlld0hpbnRzW1ZpZXdIaW50LklOVEVSQUNUSU5HXTtcbiAgICB2YXIgdXBkYXRlV2hpbGVBbmltYXRpbmcgPSB2ZWN0b3JMYXllci5nZXRVcGRhdGVXaGlsZUFuaW1hdGluZygpO1xuICAgIHZhciB1cGRhdGVXaGlsZUludGVyYWN0aW5nID0gdmVjdG9yTGF5ZXIuZ2V0VXBkYXRlV2hpbGVJbnRlcmFjdGluZygpO1xuXG4gICAgaWYgKCF0aGlzLmRpcnR5XyAmJiAoIXVwZGF0ZVdoaWxlQW5pbWF0aW5nICYmIGFuaW1hdGluZykgfHxcbiAgICAgICAgKCF1cGRhdGVXaGlsZUludGVyYWN0aW5nICYmIGludGVyYWN0aW5nKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGZyYW1lU3RhdGVFeHRlbnQgPSBmcmFtZVN0YXRlLmV4dGVudDtcbiAgICB2YXIgdmlld1N0YXRlID0gZnJhbWVTdGF0ZS52aWV3U3RhdGU7XG4gICAgdmFyIHByb2plY3Rpb24gPSB2aWV3U3RhdGUucHJvamVjdGlvbjtcbiAgICB2YXIgcmVzb2x1dGlvbiA9IHZpZXdTdGF0ZS5yZXNvbHV0aW9uO1xuICAgIHZhciBwaXhlbFJhdGlvID0gZnJhbWVTdGF0ZS5waXhlbFJhdGlvO1xuICAgIHZhciB2ZWN0b3JMYXllclJldmlzaW9uID0gdmVjdG9yTGF5ZXIuZ2V0UmV2aXNpb24oKTtcbiAgICB2YXIgdmVjdG9yTGF5ZXJSZW5kZXJCdWZmZXIgPSB2ZWN0b3JMYXllci5nZXRSZW5kZXJCdWZmZXIoKTtcbiAgICB2YXIgdmVjdG9yTGF5ZXJSZW5kZXJPcmRlciA9IHZlY3RvckxheWVyLmdldFJlbmRlck9yZGVyKCk7XG5cbiAgICBpZiAodmVjdG9yTGF5ZXJSZW5kZXJPcmRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2ZWN0b3JMYXllclJlbmRlck9yZGVyID0gZGVmYXVsdFJlbmRlck9yZGVyO1xuICAgIH1cblxuICAgIHZhciBleHRlbnQgPSBidWZmZXIoZnJhbWVTdGF0ZUV4dGVudCxcbiAgICAgIHZlY3RvckxheWVyUmVuZGVyQnVmZmVyICogcmVzb2x1dGlvbik7XG4gICAgdmFyIHByb2plY3Rpb25FeHRlbnQgPSB2aWV3U3RhdGUucHJvamVjdGlvbi5nZXRFeHRlbnQoKTtcblxuICAgIGlmICh2ZWN0b3JTb3VyY2UuZ2V0V3JhcFgoKSAmJiB2aWV3U3RhdGUucHJvamVjdGlvbi5jYW5XcmFwWCgpICYmXG4gICAgICAgICFjb250YWluc0V4dGVudChwcm9qZWN0aW9uRXh0ZW50LCBmcmFtZVN0YXRlLmV4dGVudCkpIHtcbiAgICAgIC8vIEZvciB0aGUgcmVwbGF5IGdyb3VwLCB3ZSBuZWVkIGFuIGV4dGVudCB0aGF0IGludGVyc2VjdHMgdGhlIHJlYWwgd29ybGRcbiAgICAgIC8vICgtMTgwwrAgdG8gKzE4MMKwKS4gVG8gc3VwcG9ydCBnZW9tZXRyaWVzIGluIGEgY29vcmRpbmF0ZSByYW5nZSBmcm9tIC01NDDCsFxuICAgICAgLy8gdG8gKzU0MMKwLCB3ZSBhZGQgYXQgbGVhc3QgMSB3b3JsZCB3aWR0aCBvbiBlYWNoIHNpZGUgb2YgdGhlIHByb2plY3Rpb25cbiAgICAgIC8vIGV4dGVudC4gSWYgdGhlIHZpZXdwb3J0IGlzIHdpZGVyIHRoYW4gdGhlIHdvcmxkLCB3ZSBuZWVkIHRvIGFkZCBoYWxmIG9mXG4gICAgICAvLyB0aGUgdmlld3BvcnQgd2lkdGggdG8gbWFrZSBzdXJlIHdlIGNvdmVyIHRoZSB3aG9sZSB2aWV3cG9ydC5cbiAgICAgIHZhciB3b3JsZFdpZHRoID0gZ2V0V2lkdGgocHJvamVjdGlvbkV4dGVudCk7XG4gICAgICB2YXIgZ3V0dGVyID0gTWF0aC5tYXgoZ2V0V2lkdGgoZXh0ZW50KSAvIDIsIHdvcmxkV2lkdGgpO1xuICAgICAgZXh0ZW50WzBdID0gcHJvamVjdGlvbkV4dGVudFswXSAtIGd1dHRlcjtcbiAgICAgIGV4dGVudFsyXSA9IHByb2plY3Rpb25FeHRlbnRbMl0gKyBndXR0ZXI7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmRpcnR5XyAmJlxuICAgICAgICB0aGlzLnJlbmRlcmVkUmVzb2x1dGlvbl8gPT0gcmVzb2x1dGlvbiAmJlxuICAgICAgICB0aGlzLnJlbmRlcmVkUmV2aXNpb25fID09IHZlY3RvckxheWVyUmV2aXNpb24gJiZcbiAgICAgICAgdGhpcy5yZW5kZXJlZFJlbmRlck9yZGVyXyA9PSB2ZWN0b3JMYXllclJlbmRlck9yZGVyICYmXG4gICAgICAgIGNvbnRhaW5zRXh0ZW50KHRoaXMucmVuZGVyZWRFeHRlbnRfLCBleHRlbnQpKSB7XG4gICAgICB0aGlzLnJlcGxheUdyb3VwQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5yZXBsYXlHcm91cF8gPSBudWxsO1xuXG4gICAgdGhpcy5kaXJ0eV8gPSBmYWxzZTtcblxuICAgIHZhciByZXBsYXlHcm91cCA9IG5ldyBDYW52YXNSZXBsYXlHcm91cChcbiAgICAgIGdldFJlbmRlclRvbGVyYW5jZShyZXNvbHV0aW9uLCBwaXhlbFJhdGlvKSwgZXh0ZW50LCByZXNvbHV0aW9uLFxuICAgICAgcGl4ZWxSYXRpbywgdmVjdG9yU291cmNlLmdldE92ZXJsYXBzKCksIHRoaXMuZGVjbHV0dGVyVHJlZV8sIHZlY3RvckxheWVyLmdldFJlbmRlckJ1ZmZlcigpKTtcbiAgICB2ZWN0b3JTb3VyY2UubG9hZEZlYXR1cmVzKGV4dGVudCwgcmVzb2x1dGlvbiwgcHJvamVjdGlvbik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICAgKiBAdGhpcyB7Q2FudmFzVmVjdG9yTGF5ZXJSZW5kZXJlcn1cbiAgICAgKi9cbiAgICB2YXIgcmVuZGVyID0gZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgICAgdmFyIHN0eWxlcztcbiAgICAgIHZhciBzdHlsZUZ1bmN0aW9uID0gZmVhdHVyZS5nZXRTdHlsZUZ1bmN0aW9uKCkgfHwgdmVjdG9yTGF5ZXIuZ2V0U3R5bGVGdW5jdGlvbigpO1xuICAgICAgaWYgKHN0eWxlRnVuY3Rpb24pIHtcbiAgICAgICAgc3R5bGVzID0gc3R5bGVGdW5jdGlvbihmZWF0dXJlLCByZXNvbHV0aW9uKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHlsZXMpIHtcbiAgICAgICAgdmFyIGRpcnR5ID0gdGhpcy5yZW5kZXJGZWF0dXJlKFxuICAgICAgICAgIGZlYXR1cmUsIHJlc29sdXRpb24sIHBpeGVsUmF0aW8sIHN0eWxlcywgcmVwbGF5R3JvdXApO1xuICAgICAgICB0aGlzLmRpcnR5XyA9IHRoaXMuZGlydHlfIHx8IGRpcnR5O1xuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKTtcbiAgICBpZiAodmVjdG9yTGF5ZXJSZW5kZXJPcmRlcikge1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fSAqL1xuICAgICAgdmFyIGZlYXR1cmVzID0gW107XG4gICAgICB2ZWN0b3JTb3VyY2UuZm9yRWFjaEZlYXR1cmVJbkV4dGVudChleHRlbnQsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgICAgICAgIGZlYXR1cmVzLnB1c2goZmVhdHVyZSk7XG4gICAgICAgIH0pO1xuICAgICAgZmVhdHVyZXMuc29ydCh2ZWN0b3JMYXllclJlbmRlck9yZGVyKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGZlYXR1cmVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgcmVuZGVyKGZlYXR1cmVzW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmVjdG9yU291cmNlLmZvckVhY2hGZWF0dXJlSW5FeHRlbnQoZXh0ZW50LCByZW5kZXIpO1xuICAgIH1cbiAgICByZXBsYXlHcm91cC5maW5pc2goKTtcblxuICAgIHRoaXMucmVuZGVyZWRSZXNvbHV0aW9uXyA9IHJlc29sdXRpb247XG4gICAgdGhpcy5yZW5kZXJlZFJldmlzaW9uXyA9IHZlY3RvckxheWVyUmV2aXNpb247XG4gICAgdGhpcy5yZW5kZXJlZFJlbmRlck9yZGVyXyA9IHZlY3RvckxheWVyUmVuZGVyT3JkZXI7XG4gICAgdGhpcy5yZW5kZXJlZEV4dGVudF8gPSBleHRlbnQ7XG4gICAgdGhpcy5yZXBsYXlHcm91cF8gPSByZXBsYXlHcm91cDtcblxuICAgIHRoaXMucmVwbGF5R3JvdXBDaGFuZ2VkID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdHxBcnJheTxpbXBvcnQoXCIuLi8uLi9zdHlsZS9TdHlsZS5qc1wiKS5kZWZhdWx0Pn0gc3R5bGVzIFRoZSBzdHlsZSBvciBhcnJheSBvZiBzdHlsZXMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vcmVuZGVyL2NhbnZhcy9SZXBsYXlHcm91cC5qc1wiKS5kZWZhdWx0fSByZXBsYXlHcm91cCBSZXBsYXkgZ3JvdXAuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiBhbiBpbWFnZSBpcyBsb2FkaW5nLlxuICAgKi9cbiAgQ2FudmFzVmVjdG9yTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRmVhdHVyZSA9IGZ1bmN0aW9uIHJlbmRlckZlYXR1cmUkMSAoZmVhdHVyZSwgcmVzb2x1dGlvbiwgcGl4ZWxSYXRpbywgc3R5bGVzLCByZXBsYXlHcm91cCkge1xuICAgIGlmICghc3R5bGVzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBsb2FkaW5nID0gZmFsc2U7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGVzKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gc3R5bGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgbG9hZGluZyA9IHJlbmRlckZlYXR1cmUoXG4gICAgICAgICAgcmVwbGF5R3JvdXAsIGZlYXR1cmUsIHN0eWxlc1tpXSxcbiAgICAgICAgICBnZXRTcXVhcmVkUmVuZGVyVG9sZXJhbmNlKHJlc29sdXRpb24sIHBpeGVsUmF0aW8pLFxuICAgICAgICAgIHRoaXMuaGFuZGxlU3R5bGVJbWFnZUNoYW5nZV8sIHRoaXMpIHx8IGxvYWRpbmc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvYWRpbmcgPSByZW5kZXJGZWF0dXJlKFxuICAgICAgICByZXBsYXlHcm91cCwgZmVhdHVyZSwgc3R5bGVzLFxuICAgICAgICBnZXRTcXVhcmVkUmVuZGVyVG9sZXJhbmNlKHJlc29sdXRpb24sIHBpeGVsUmF0aW8pLFxuICAgICAgICB0aGlzLmhhbmRsZVN0eWxlSW1hZ2VDaGFuZ2VfLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIGxvYWRpbmc7XG4gIH07XG5cbiAgcmV0dXJuIENhbnZhc1ZlY3RvckxheWVyUmVuZGVyZXI7XG59KENhbnZhc0xheWVyUmVuZGVyZXIpKTtcblxuXG4vKipcbiAqIERldGVybWluZSBpZiB0aGlzIHJlbmRlcmVyIGhhbmRsZXMgdGhlIHByb3ZpZGVkIGxheWVyLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0fSBsYXllciBUaGUgY2FuZGlkYXRlIGxheWVyLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHJlbmRlcmVyIGNhbiByZW5kZXIgdGhlIGxheWVyLlxuICovXG5DYW52YXNWZWN0b3JMYXllclJlbmRlcmVyWydoYW5kbGVzJ10gPSBmdW5jdGlvbihsYXllcikge1xuICByZXR1cm4gbGF5ZXIuZ2V0VHlwZSgpID09PSBMYXllclR5cGUuVkVDVE9SO1xufTtcblxuXG4vKipcbiAqIENyZWF0ZSBhIGxheWVyIHJlbmRlcmVyLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdH0gbWFwUmVuZGVyZXIgVGhlIG1hcCByZW5kZXJlci5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdH0gbGF5ZXIgVGhlIGxheWVyIHRvIGJlIHJlbmRlcmVyZC5cbiAqIEByZXR1cm4ge0NhbnZhc1ZlY3RvckxheWVyUmVuZGVyZXJ9IFRoZSBsYXllciByZW5kZXJlci5cbiAqL1xuQ2FudmFzVmVjdG9yTGF5ZXJSZW5kZXJlclsnY3JlYXRlJ10gPSBmdW5jdGlvbihtYXBSZW5kZXJlciwgbGF5ZXIpIHtcbiAgcmV0dXJuIG5ldyBDYW52YXNWZWN0b3JMYXllclJlbmRlcmVyKC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vbGF5ZXIvVmVjdG9yLmpzXCIpLmRlZmF1bHR9ICovIChsYXllcikpO1xufTtcblxuXG5leHBvcnQgZGVmYXVsdCBDYW52YXNWZWN0b3JMYXllclJlbmRlcmVyO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1WZWN0b3JMYXllci5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyZXIvY2FudmFzL1ZlY3RvclRpbGVMYXllclxuICovXG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi4vLi4vdXRpbC5qcyc7XG5pbXBvcnQgTGF5ZXJUeXBlIGZyb20gJy4uLy4uL0xheWVyVHlwZS5qcyc7XG5pbXBvcnQgVGlsZVN0YXRlIGZyb20gJy4uLy4uL1RpbGVTdGF0ZS5qcyc7XG5pbXBvcnQgVmlld0hpbnQgZnJvbSAnLi4vLi4vVmlld0hpbnQuanMnO1xuaW1wb3J0IHtjcmVhdGVDYW52YXNDb250ZXh0MkR9IGZyb20gJy4uLy4uL2RvbS5qcyc7XG5pbXBvcnQge2xpc3RlbiwgdW5saXN0ZW59IGZyb20gJy4uLy4uL2V2ZW50cy5qcyc7XG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4uLy4uL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IHJidXNoIGZyb20gJ3JidXNoJztcbmltcG9ydCB7YnVmZmVyLCBjb250YWluc0Nvb3JkaW5hdGUsIGVxdWFscywgZ2V0SW50ZXJzZWN0aW9uLCBnZXRUb3BMZWZ0LCBpbnRlcnNlY3RzfSBmcm9tICcuLi8uLi9leHRlbnQuanMnO1xuaW1wb3J0IFZlY3RvclRpbGVSZW5kZXJUeXBlIGZyb20gJy4uLy4uL2xheWVyL1ZlY3RvclRpbGVSZW5kZXJUeXBlLmpzJztcbmltcG9ydCB7ZXF1aXZhbGVudCBhcyBlcXVpdmFsZW50UHJvamVjdGlvbn0gZnJvbSAnLi4vLi4vcHJvai5qcyc7XG5pbXBvcnQgVW5pdHMgZnJvbSAnLi4vLi4vcHJvai9Vbml0cy5qcyc7XG5pbXBvcnQgUmVwbGF5VHlwZSBmcm9tICcuLi8uLi9yZW5kZXIvUmVwbGF5VHlwZS5qcyc7XG5pbXBvcnQge2xhYmVsQ2FjaGUsIHJvdGF0ZUF0T2Zmc2V0fSBmcm9tICcuLi8uLi9yZW5kZXIvY2FudmFzLmpzJztcbmltcG9ydCBDYW52YXNSZXBsYXlHcm91cCwge3JlcGxheURlY2x1dHRlcn0gZnJvbSAnLi4vLi4vcmVuZGVyL2NhbnZhcy9SZXBsYXlHcm91cC5qcyc7XG5pbXBvcnQge09SREVSfSBmcm9tICcuLi8uLi9yZW5kZXIvcmVwbGF5LmpzJztcbmltcG9ydCBDYW52YXNUaWxlTGF5ZXJSZW5kZXJlciBmcm9tICcuL1RpbGVMYXllci5qcyc7XG5pbXBvcnQge2dldFNxdWFyZWRUb2xlcmFuY2UgYXMgZ2V0U3F1YXJlZFJlbmRlclRvbGVyYW5jZSwgcmVuZGVyRmVhdHVyZX0gZnJvbSAnLi4vdmVjdG9yLmpzJztcbmltcG9ydCB7XG4gIGNyZWF0ZSBhcyBjcmVhdGVUcmFuc2Zvcm0sXG4gIGNvbXBvc2UgYXMgY29tcG9zZVRyYW5zZm9ybSxcbiAgcmVzZXQgYXMgcmVzZXRUcmFuc2Zvcm0sXG4gIHNjYWxlIGFzIHNjYWxlVHJhbnNmb3JtLFxuICB0cmFuc2xhdGUgYXMgdHJhbnNsYXRlVHJhbnNmb3JtXG59IGZyb20gJy4uLy4uL3RyYW5zZm9ybS5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIEFycmF5PGltcG9ydChcIi4uLy4uL3JlbmRlci9SZXBsYXlUeXBlLmpzXCIpLmRlZmF1bHQ+Pn1cbiAqL1xudmFyIElNQUdFX1JFUExBWVMgPSB7XG4gICdpbWFnZSc6IFtSZXBsYXlUeXBlLlBPTFlHT04sIFJlcGxheVR5cGUuQ0lSQ0xFLFxuICAgIFJlcGxheVR5cGUuTElORV9TVFJJTkcsIFJlcGxheVR5cGUuSU1BR0UsIFJlcGxheVR5cGUuVEVYVF0sXG4gICdoeWJyaWQnOiBbUmVwbGF5VHlwZS5QT0xZR09OLCBSZXBsYXlUeXBlLkxJTkVfU1RSSU5HXVxufTtcblxuXG4vKipcbiAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgQXJyYXk8aW1wb3J0KFwiLi4vLi4vcmVuZGVyL1JlcGxheVR5cGUuanNcIikuZGVmYXVsdD4+fVxuICovXG52YXIgVkVDVE9SX1JFUExBWVMgPSB7XG4gICdpbWFnZSc6IFtSZXBsYXlUeXBlLkRFRkFVTFRdLFxuICAnaHlicmlkJzogW1JlcGxheVR5cGUuSU1BR0UsIFJlcGxheVR5cGUuVEVYVCwgUmVwbGF5VHlwZS5ERUZBVUxUXSxcbiAgJ3ZlY3Rvcic6IE9SREVSXG59O1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQ2FudmFzIHJlbmRlcmVyIGZvciB2ZWN0b3IgdGlsZSBsYXllcnMuXG4gKiBAYXBpXG4gKi9cbnZhciBDYW52YXNWZWN0b3JUaWxlTGF5ZXJSZW5kZXJlciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKENhbnZhc1RpbGVMYXllclJlbmRlcmVyKSB7XG4gIGZ1bmN0aW9uIENhbnZhc1ZlY3RvclRpbGVMYXllclJlbmRlcmVyKGxheWVyKSB7XG5cbiAgICBDYW52YXNUaWxlTGF5ZXJSZW5kZXJlci5jYWxsKHRoaXMsIGxheWVyLCB0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIERlY2x1dHRlciB0cmVlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5kZWNsdXR0ZXJUcmVlXyA9IGxheWVyLmdldERlY2x1dHRlcigpID8gcmJ1c2goOSwgdW5kZWZpbmVkKSA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZGlydHlfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZExheWVyUmV2aXNpb25fO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX1cbiAgICAgKi9cbiAgICB0aGlzLnRtcFRyYW5zZm9ybV8gPSBjcmVhdGVUcmFuc2Zvcm0oKTtcblxuICAgIHZhciByZW5kZXJNb2RlID0gbGF5ZXIuZ2V0UmVuZGVyTW9kZSgpO1xuXG4gICAgLy8gVXNlIGxvd2VyIHJlc29sdXRpb24gZm9yIHB1cmUgdmVjdG9yIHJlbmRlcmluZy4gQ2xvc2VzdCByZXNvbHV0aW9uIG90aGVyd2lzZS5cbiAgICB0aGlzLnpEaXJlY3Rpb24gPSByZW5kZXJNb2RlID09PSBWZWN0b3JUaWxlUmVuZGVyVHlwZS5WRUNUT1IgPyAxIDogMDtcblxuICAgIGlmIChyZW5kZXJNb2RlICE9PSBWZWN0b3JUaWxlUmVuZGVyVHlwZS5WRUNUT1IpIHtcbiAgICAgIHRoaXMuY29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQyRCgpO1xuICAgIH1cblxuXG4gICAgbGlzdGVuKGxhYmVsQ2FjaGUsIEV2ZW50VHlwZS5DTEVBUiwgdGhpcy5oYW5kbGVGb250c0NoYW5nZWRfLCB0aGlzKTtcblxuICB9XG5cbiAgaWYgKCBDYW52YXNUaWxlTGF5ZXJSZW5kZXJlciApIENhbnZhc1ZlY3RvclRpbGVMYXllclJlbmRlcmVyLl9fcHJvdG9fXyA9IENhbnZhc1RpbGVMYXllclJlbmRlcmVyO1xuICBDYW52YXNWZWN0b3JUaWxlTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDYW52YXNUaWxlTGF5ZXJSZW5kZXJlciAmJiBDYW52YXNUaWxlTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUgKTtcbiAgQ2FudmFzVmVjdG9yVGlsZUxheWVyUmVuZGVyZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2FudmFzVmVjdG9yVGlsZUxheWVyUmVuZGVyZXI7XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNWZWN0b3JUaWxlTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuZGlzcG9zZUludGVybmFsID0gZnVuY3Rpb24gZGlzcG9zZUludGVybmFsICgpIHtcbiAgICB1bmxpc3RlbihsYWJlbENhY2hlLCBFdmVudFR5cGUuQ0xFQVIsIHRoaXMuaGFuZGxlRm9udHNDaGFuZ2VkXywgdGhpcyk7XG4gICAgQ2FudmFzVGlsZUxheWVyUmVuZGVyZXIucHJvdG90eXBlLmRpc3Bvc2VJbnRlcm5hbC5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQ2FudmFzVmVjdG9yVGlsZUxheWVyUmVuZGVyZXIucHJvdG90eXBlLmdldFRpbGUgPSBmdW5jdGlvbiBnZXRUaWxlICh6LCB4LCB5LCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKSB7XG4gICAgdmFyIHRpbGUgPSBDYW52YXNUaWxlTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuZ2V0VGlsZS5jYWxsKHRoaXMsIHosIHgsIHksIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pO1xuICAgIGlmICh0aWxlLmdldFN0YXRlKCkgPT09IFRpbGVTdGF0ZS5MT0FERUQpIHtcbiAgICAgIHRoaXMuY3JlYXRlUmVwbGF5R3JvdXBfKC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vVmVjdG9ySW1hZ2VUaWxlLmpzXCIpLmRlZmF1bHR9ICovICh0aWxlKSwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbik7XG4gICAgICBpZiAodGhpcy5jb250ZXh0KSB7XG4gICAgICAgIHRoaXMucmVuZGVyVGlsZUltYWdlXygvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL1ZlY3RvckltYWdlVGlsZS5qc1wiKS5kZWZhdWx0fSAqLyAodGlsZSksIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGlsZTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENhbnZhc1ZlY3RvclRpbGVMYXllclJlbmRlcmVyLnByb3RvdHlwZS5nZXRUaWxlSW1hZ2UgPSBmdW5jdGlvbiBnZXRUaWxlSW1hZ2UgKHRpbGUpIHtcbiAgICB2YXIgdGlsZUxheWVyID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9sYXllci9UaWxlLmpzXCIpLmRlZmF1bHR9ICovICh0aGlzLmdldExheWVyKCkpO1xuICAgIHJldHVybiAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL1ZlY3RvckltYWdlVGlsZS5qc1wiKS5kZWZhdWx0fSAqLyAodGlsZSkuZ2V0SW1hZ2UodGlsZUxheWVyKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENhbnZhc1ZlY3RvclRpbGVMYXllclJlbmRlcmVyLnByb3RvdHlwZS5wcmVwYXJlRnJhbWUgPSBmdW5jdGlvbiBwcmVwYXJlRnJhbWUgKGZyYW1lU3RhdGUsIGxheWVyU3RhdGUpIHtcbiAgICB2YXIgbGF5ZXIgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2xheWVyL1ZlY3Rvci5qc1wiKS5kZWZhdWx0fSAqLyAodGhpcy5nZXRMYXllcigpKTtcbiAgICB2YXIgbGF5ZXJSZXZpc2lvbiA9IGxheWVyLmdldFJldmlzaW9uKCk7XG4gICAgaWYgKHRoaXMucmVuZGVyZWRMYXllclJldmlzaW9uXyAhPSBsYXllclJldmlzaW9uKSB7XG4gICAgICB0aGlzLnJlbmRlcmVkVGlsZXMubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgdGhpcy5yZW5kZXJlZExheWVyUmV2aXNpb25fID0gbGF5ZXJSZXZpc2lvbjtcbiAgICByZXR1cm4gQ2FudmFzVGlsZUxheWVyUmVuZGVyZXIucHJvdG90eXBlLnByZXBhcmVGcmFtZS5jYWxsKHRoaXMsIGZyYW1lU3RhdGUsIGxheWVyU3RhdGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL1ZlY3RvckltYWdlVGlsZS5qc1wiKS5kZWZhdWx0fSB0aWxlIFRpbGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBDYW52YXNWZWN0b3JUaWxlTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlUmVwbGF5R3JvdXBfID0gZnVuY3Rpb24gY3JlYXRlUmVwbGF5R3JvdXBfICh0aWxlLCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgbGF5ZXIgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2xheWVyL1ZlY3Rvci5qc1wiKS5kZWZhdWx0fSAqLyAodGhpcy5nZXRMYXllcigpKTtcbiAgICB2YXIgcmV2aXNpb24gPSBsYXllci5nZXRSZXZpc2lvbigpO1xuICAgIHZhciByZW5kZXJPcmRlciA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vcmVuZGVyLmpzXCIpLk9yZGVyRnVuY3Rpb259ICovIChsYXllci5nZXRSZW5kZXJPcmRlcigpKSB8fCBudWxsO1xuXG4gICAgdmFyIHJlcGxheVN0YXRlID0gdGlsZS5nZXRSZXBsYXlTdGF0ZShsYXllcik7XG4gICAgaWYgKCFyZXBsYXlTdGF0ZS5kaXJ0eSAmJiByZXBsYXlTdGF0ZS5yZW5kZXJlZFJldmlzaW9uID09IHJldmlzaW9uICYmXG4gICAgICAgIHJlcGxheVN0YXRlLnJlbmRlcmVkUmVuZGVyT3JkZXIgPT0gcmVuZGVyT3JkZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9zb3VyY2UvVmVjdG9yVGlsZS5qc1wiKS5kZWZhdWx0fSAqLyAobGF5ZXIuZ2V0U291cmNlKCkpO1xuICAgIHZhciBzb3VyY2VUaWxlR3JpZCA9IHNvdXJjZS5nZXRUaWxlR3JpZCgpO1xuICAgIHZhciB0aWxlR3JpZCA9IHNvdXJjZS5nZXRUaWxlR3JpZEZvclByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gICAgdmFyIHJlc29sdXRpb24gPSB0aWxlR3JpZC5nZXRSZXNvbHV0aW9uKHRpbGUudGlsZUNvb3JkWzBdKTtcbiAgICB2YXIgdGlsZUV4dGVudCA9IHRpbGUuZXh0ZW50O1xuXG4gICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIHQsIHR0ICkge1xuICAgICAgdmFyIHNvdXJjZVRpbGUgPSB0aWxlLmdldFRpbGUodGlsZS50aWxlS2V5c1t0XSk7XG4gICAgICBpZiAoc291cmNlVGlsZS5nZXRTdGF0ZSgpICE9IFRpbGVTdGF0ZS5MT0FERUQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlVGlsZUNvb3JkID0gc291cmNlVGlsZS50aWxlQ29vcmQ7XG4gICAgICB2YXIgc291cmNlVGlsZUV4dGVudCA9IHNvdXJjZVRpbGVHcmlkLmdldFRpbGVDb29yZEV4dGVudChzb3VyY2VUaWxlQ29vcmQpO1xuICAgICAgdmFyIHNoYXJlZEV4dGVudCA9IGdldEludGVyc2VjdGlvbih0aWxlRXh0ZW50LCBzb3VyY2VUaWxlRXh0ZW50KTtcbiAgICAgIHZhciBidWZmZXJlZEV4dGVudCA9IGVxdWFscyhzb3VyY2VUaWxlRXh0ZW50LCBzaGFyZWRFeHRlbnQpID8gbnVsbCA6XG4gICAgICAgIGJ1ZmZlcihzaGFyZWRFeHRlbnQsIGxheWVyLmdldFJlbmRlckJ1ZmZlcigpICogcmVzb2x1dGlvbiwgdGhpcyQxLnRtcEV4dGVudCk7XG4gICAgICB2YXIgdGlsZVByb2plY3Rpb24gPSBzb3VyY2VUaWxlLmdldFByb2plY3Rpb24oKTtcbiAgICAgIHZhciByZXByb2plY3QgPSBmYWxzZTtcbiAgICAgIGlmICghZXF1aXZhbGVudFByb2plY3Rpb24ocHJvamVjdGlvbiwgdGlsZVByb2plY3Rpb24pKSB7XG4gICAgICAgIHJlcHJvamVjdCA9IHRydWU7XG4gICAgICAgIHNvdXJjZVRpbGUuc2V0UHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJlcGxheVN0YXRlLmRpcnR5ID0gZmFsc2U7XG4gICAgICB2YXIgcmVwbGF5R3JvdXAgPSBuZXcgQ2FudmFzUmVwbGF5R3JvdXAoMCwgc2hhcmVkRXh0ZW50LCByZXNvbHV0aW9uLFxuICAgICAgICBwaXhlbFJhdGlvLCBzb3VyY2UuZ2V0T3ZlcmxhcHMoKSwgdGhpcyQxLmRlY2x1dHRlclRyZWVfLCBsYXllci5nZXRSZW5kZXJCdWZmZXIoKSk7XG4gICAgICB2YXIgc3F1YXJlZFRvbGVyYW5jZSA9IGdldFNxdWFyZWRSZW5kZXJUb2xlcmFuY2UocmVzb2x1dGlvbiwgcGl4ZWxSYXRpbyk7XG5cbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gICAgICAgKiBAdGhpcyB7Q2FudmFzVmVjdG9yVGlsZUxheWVyUmVuZGVyZXJ9XG4gICAgICAgKi9cbiAgICAgIHZhciByZW5kZXIgPSBmdW5jdGlvbihmZWF0dXJlKSB7XG4gICAgICAgIHZhciBzdHlsZXM7XG4gICAgICAgIHZhciBzdHlsZUZ1bmN0aW9uID0gZmVhdHVyZS5nZXRTdHlsZUZ1bmN0aW9uKCkgfHwgbGF5ZXIuZ2V0U3R5bGVGdW5jdGlvbigpO1xuICAgICAgICBpZiAoc3R5bGVGdW5jdGlvbikge1xuICAgICAgICAgIHN0eWxlcyA9IHN0eWxlRnVuY3Rpb24oZmVhdHVyZSwgcmVzb2x1dGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0eWxlcykge1xuICAgICAgICAgIHZhciBkaXJ0eSA9IHRoaXMucmVuZGVyRmVhdHVyZShmZWF0dXJlLCBzcXVhcmVkVG9sZXJhbmNlLCBzdHlsZXMsIHJlcGxheUdyb3VwKTtcbiAgICAgICAgICB0aGlzLmRpcnR5XyA9IHRoaXMuZGlydHlfIHx8IGRpcnR5O1xuICAgICAgICAgIHJlcGxheVN0YXRlLmRpcnR5ID0gcmVwbGF5U3RhdGUuZGlydHkgfHwgZGlydHk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBmZWF0dXJlcyA9IHNvdXJjZVRpbGUuZ2V0RmVhdHVyZXMoKTtcbiAgICAgIGlmIChyZW5kZXJPcmRlciAmJiByZW5kZXJPcmRlciAhPT0gcmVwbGF5U3RhdGUucmVuZGVyZWRSZW5kZXJPcmRlcikge1xuICAgICAgICBmZWF0dXJlcy5zb3J0KHJlbmRlck9yZGVyKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGZlYXR1cmVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgdmFyIGZlYXR1cmUgPSBmZWF0dXJlc1tpXTtcbiAgICAgICAgaWYgKHJlcHJvamVjdCkge1xuICAgICAgICAgIGlmICh0aWxlUHJvamVjdGlvbi5nZXRVbml0cygpID09IFVuaXRzLlRJTEVfUElYRUxTKSB7XG4gICAgICAgICAgICAvLyBwcm9qZWN0ZWQgdGlsZSBleHRlbnRcbiAgICAgICAgICAgIHRpbGVQcm9qZWN0aW9uLnNldFdvcmxkRXh0ZW50KHNvdXJjZVRpbGVFeHRlbnQpO1xuICAgICAgICAgICAgLy8gdGlsZSBleHRlbnQgaW4gdGlsZSBwaXhlbCBzcGFjZVxuICAgICAgICAgICAgdGlsZVByb2plY3Rpb24uc2V0RXh0ZW50KHNvdXJjZVRpbGUuZ2V0RXh0ZW50KCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmZWF0dXJlLmdldEdlb21ldHJ5KCkudHJhbnNmb3JtKHRpbGVQcm9qZWN0aW9uLCBwcm9qZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWJ1ZmZlcmVkRXh0ZW50IHx8IGludGVyc2VjdHMoYnVmZmVyZWRFeHRlbnQsIGZlYXR1cmUuZ2V0R2VvbWV0cnkoKS5nZXRFeHRlbnQoKSkpIHtcbiAgICAgICAgICByZW5kZXIuY2FsbCh0aGlzJDEsIGZlYXR1cmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXBsYXlHcm91cC5maW5pc2goKTtcbiAgICAgIHNvdXJjZVRpbGUuc2V0UmVwbGF5R3JvdXAobGF5ZXIsIHRpbGUudGlsZUNvb3JkLnRvU3RyaW5nKCksIHJlcGxheUdyb3VwKTtcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgdCA9IDAsIHR0ID0gdGlsZS50aWxlS2V5cy5sZW5ndGg7IHQgPCB0dDsgKyt0KSBsb29wKCB0LCB0dCApO1xuICAgIHJlcGxheVN0YXRlLnJlbmRlcmVkUmV2aXNpb24gPSByZXZpc2lvbjtcbiAgICByZXBsYXlTdGF0ZS5yZW5kZXJlZFJlbmRlck9yZGVyID0gcmVuZGVyT3JkZXI7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNWZWN0b3JUaWxlTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGUgPSBmdW5jdGlvbiBmb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZSAoY29vcmRpbmF0ZSwgZnJhbWVTdGF0ZSwgaGl0VG9sZXJhbmNlLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIHZhciByZXNvbHV0aW9uID0gZnJhbWVTdGF0ZS52aWV3U3RhdGUucmVzb2x1dGlvbjtcbiAgICB2YXIgcm90YXRpb24gPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZS5yb3RhdGlvbjtcbiAgICBoaXRUb2xlcmFuY2UgPSBoaXRUb2xlcmFuY2UgPT0gdW5kZWZpbmVkID8gMCA6IGhpdFRvbGVyYW5jZTtcbiAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKCk7XG4gICAgLyoqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgYm9vbGVhbj59ICovXG4gICAgdmFyIGZlYXR1cmVzID0ge307XG5cbiAgICB2YXIgcmVuZGVyZWRUaWxlcyA9IC8qKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi4vLi4vVmVjdG9ySW1hZ2VUaWxlLmpzXCIpLmRlZmF1bHQ+fSAqLyAodGhpcy5yZW5kZXJlZFRpbGVzKTtcblxuICAgIHZhciBidWZmZXJlZEV4dGVudCwgZm91bmQ7XG4gICAgdmFyIGksIGlpO1xuICAgIGZvciAoaSA9IDAsIGlpID0gcmVuZGVyZWRUaWxlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB2YXIgdGlsZSA9IHJlbmRlcmVkVGlsZXNbaV07XG4gICAgICBidWZmZXJlZEV4dGVudCA9IGJ1ZmZlcih0aWxlLmV4dGVudCwgaGl0VG9sZXJhbmNlICogcmVzb2x1dGlvbiwgYnVmZmVyZWRFeHRlbnQpO1xuICAgICAgaWYgKCFjb250YWluc0Nvb3JkaW5hdGUoYnVmZmVyZWRFeHRlbnQsIGNvb3JkaW5hdGUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgdCA9IDAsIHR0ID0gdGlsZS50aWxlS2V5cy5sZW5ndGg7IHQgPCB0dDsgKyt0KSB7XG4gICAgICAgIHZhciBzb3VyY2VUaWxlID0gdGlsZS5nZXRUaWxlKHRpbGUudGlsZUtleXNbdF0pO1xuICAgICAgICBpZiAoc291cmNlVGlsZS5nZXRTdGF0ZSgpICE9IFRpbGVTdGF0ZS5MT0FERUQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVwbGF5R3JvdXAgPSAvKiogQHR5cGUge0NhbnZhc1JlcGxheUdyb3VwfSAqLyAoc291cmNlVGlsZS5nZXRSZXBsYXlHcm91cChsYXllcixcbiAgICAgICAgICB0aWxlLnRpbGVDb29yZC50b1N0cmluZygpKSk7XG4gICAgICAgIGZvdW5kID0gZm91bmQgfHwgcmVwbGF5R3JvdXAuZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGUoY29vcmRpbmF0ZSwgcmVzb2x1dGlvbiwgcm90YXRpb24sIGhpdFRvbGVyYW5jZSwge30sXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gICAgICAgICAgICogQHJldHVybiB7P30gQ2FsbGJhY2sgcmVzdWx0LlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBnZXRVaWQoZmVhdHVyZSk7XG4gICAgICAgICAgICBpZiAoIShrZXkgaW4gZmVhdHVyZXMpKSB7XG4gICAgICAgICAgICAgIGZlYXR1cmVzW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzQXJnLCBmZWF0dXJlLCBsYXllcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgbnVsbCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb3VuZDtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9WZWN0b3JUaWxlLmpzXCIpLmRlZmF1bHR9IHRpbGUgVGlsZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9QbHVnZ2FibGVNYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIENhbnZhc1ZlY3RvclRpbGVMYXllclJlbmRlcmVyLnByb3RvdHlwZS5nZXRSZXBsYXlUcmFuc2Zvcm1fID0gZnVuY3Rpb24gZ2V0UmVwbGF5VHJhbnNmb3JtXyAodGlsZSwgZnJhbWVTdGF0ZSkge1xuICAgIHZhciBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKTtcbiAgICB2YXIgc291cmNlID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9zb3VyY2UvVmVjdG9yVGlsZS5qc1wiKS5kZWZhdWx0fSAqLyAobGF5ZXIuZ2V0U291cmNlKCkpO1xuICAgIHZhciB0aWxlR3JpZCA9IHNvdXJjZS5nZXRUaWxlR3JpZCgpO1xuICAgIHZhciB0aWxlQ29vcmQgPSB0aWxlLnRpbGVDb29yZDtcbiAgICB2YXIgdGlsZVJlc29sdXRpb24gPSB0aWxlR3JpZC5nZXRSZXNvbHV0aW9uKHRpbGVDb29yZFswXSk7XG4gICAgdmFyIHZpZXdTdGF0ZSA9IGZyYW1lU3RhdGUudmlld1N0YXRlO1xuICAgIHZhciBwaXhlbFJhdGlvID0gZnJhbWVTdGF0ZS5waXhlbFJhdGlvO1xuICAgIHZhciByZW5kZXJSZXNvbHV0aW9uID0gdmlld1N0YXRlLnJlc29sdXRpb24gLyBwaXhlbFJhdGlvO1xuICAgIHZhciB0aWxlRXh0ZW50ID0gdGlsZUdyaWQuZ2V0VGlsZUNvb3JkRXh0ZW50KHRpbGVDb29yZCwgdGhpcy50bXBFeHRlbnQpO1xuICAgIHZhciBjZW50ZXIgPSB2aWV3U3RhdGUuY2VudGVyO1xuICAgIHZhciBvcmlnaW4gPSBnZXRUb3BMZWZ0KHRpbGVFeHRlbnQpO1xuICAgIHZhciBzaXplID0gZnJhbWVTdGF0ZS5zaXplO1xuICAgIHZhciBvZmZzZXRYID0gTWF0aC5yb3VuZChwaXhlbFJhdGlvICogc2l6ZVswXSAvIDIpO1xuICAgIHZhciBvZmZzZXRZID0gTWF0aC5yb3VuZChwaXhlbFJhdGlvICogc2l6ZVsxXSAvIDIpO1xuICAgIHJldHVybiBjb21wb3NlVHJhbnNmb3JtKHRoaXMudG1wVHJhbnNmb3JtXyxcbiAgICAgIG9mZnNldFgsIG9mZnNldFksXG4gICAgICB0aWxlUmVzb2x1dGlvbiAvIHJlbmRlclJlc29sdXRpb24sIHRpbGVSZXNvbHV0aW9uIC8gcmVuZGVyUmVzb2x1dGlvbixcbiAgICAgIHZpZXdTdGF0ZS5yb3RhdGlvbixcbiAgICAgIChvcmlnaW5bMF0gLSBjZW50ZXJbMF0pIC8gdGlsZVJlc29sdXRpb24sXG4gICAgICAoY2VudGVyWzFdIC0gb3JpZ2luWzFdKSAvIHRpbGVSZXNvbHV0aW9uKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdH0gZXZlbnQgRXZlbnQuXG4gICAqL1xuICBDYW52YXNWZWN0b3JUaWxlTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuaGFuZGxlRm9udHNDaGFuZ2VkXyA9IGZ1bmN0aW9uIGhhbmRsZUZvbnRzQ2hhbmdlZF8gKGV2ZW50KSB7XG4gICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcigpO1xuICAgIGlmIChsYXllci5nZXRWaXNpYmxlKCkgJiYgdGhpcy5yZW5kZXJlZExheWVyUmV2aXNpb25fICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGxheWVyLmNoYW5nZWQoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBjaGFuZ2VzIGluIGltYWdlIHN0eWxlIHN0YXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0fSBldmVudCBJbWFnZSBzdHlsZSBjaGFuZ2UgZXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBDYW52YXNWZWN0b3JUaWxlTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuaGFuZGxlU3R5bGVJbWFnZUNoYW5nZV8gPSBmdW5jdGlvbiBoYW5kbGVTdHlsZUltYWdlQ2hhbmdlXyAoZXZlbnQpIHtcbiAgICB0aGlzLnJlbmRlcklmUmVhZHlBbmRWaXNpYmxlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNWZWN0b3JUaWxlTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUucG9zdENvbXBvc2UgPSBmdW5jdGlvbiBwb3N0Q29tcG9zZSAoY29udGV4dCwgZnJhbWVTdGF0ZSwgbGF5ZXJTdGF0ZSkge1xuICAgIHZhciBsYXllciA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vbGF5ZXIvVmVjdG9yLmpzXCIpLmRlZmF1bHR9ICovICh0aGlzLmdldExheWVyKCkpO1xuICAgIHZhciByZW5kZXJNb2RlID0gbGF5ZXIuZ2V0UmVuZGVyTW9kZSgpO1xuICAgIGlmIChyZW5kZXJNb2RlICE9IFZlY3RvclRpbGVSZW5kZXJUeXBlLklNQUdFKSB7XG4gICAgICB2YXIgZGVjbHV0dGVyUmVwbGF5cyA9IGxheWVyLmdldERlY2x1dHRlcigpID8ge30gOiBudWxsO1xuICAgICAgdmFyIHNvdXJjZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vc291cmNlL1ZlY3RvclRpbGUuanNcIikuZGVmYXVsdH0gKi8gKGxheWVyLmdldFNvdXJjZSgpKTtcbiAgICAgIHZhciByZXBsYXlUeXBlcyA9IFZFQ1RPUl9SRVBMQVlTW3JlbmRlck1vZGVdO1xuICAgICAgdmFyIHBpeGVsUmF0aW8gPSBmcmFtZVN0YXRlLnBpeGVsUmF0aW87XG4gICAgICB2YXIgcm90YXRpb24gPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZS5yb3RhdGlvbjtcbiAgICAgIHZhciBzaXplID0gZnJhbWVTdGF0ZS5zaXplO1xuICAgICAgdmFyIG9mZnNldFgsIG9mZnNldFk7XG4gICAgICBpZiAocm90YXRpb24pIHtcbiAgICAgICAgb2Zmc2V0WCA9IE1hdGgucm91bmQocGl4ZWxSYXRpbyAqIHNpemVbMF0gLyAyKTtcbiAgICAgICAgb2Zmc2V0WSA9IE1hdGgucm91bmQocGl4ZWxSYXRpbyAqIHNpemVbMV0gLyAyKTtcbiAgICAgICAgcm90YXRlQXRPZmZzZXQoY29udGV4dCwgLXJvdGF0aW9uLCBvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICAgIH1cbiAgICAgIGlmIChkZWNsdXR0ZXJSZXBsYXlzKSB7XG4gICAgICAgIHRoaXMuZGVjbHV0dGVyVHJlZV8uY2xlYXIoKTtcbiAgICAgIH1cbiAgICAgIHZhciB2aWV3SGludHMgPSBmcmFtZVN0YXRlLnZpZXdIaW50cztcbiAgICAgIHZhciBzbmFwVG9QaXhlbCA9ICEodmlld0hpbnRzW1ZpZXdIaW50LkFOSU1BVElOR10gfHwgdmlld0hpbnRzW1ZpZXdIaW50LklOVEVSQUNUSU5HXSk7XG4gICAgICB2YXIgdGlsZXMgPSB0aGlzLnJlbmRlcmVkVGlsZXM7XG4gICAgICB2YXIgdGlsZUdyaWQgPSBzb3VyY2UuZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uKGZyYW1lU3RhdGUudmlld1N0YXRlLnByb2plY3Rpb24pO1xuICAgICAgdmFyIGNsaXBzID0gW107XG4gICAgICB2YXIgenMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSB0aWxlcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgdGlsZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vVmVjdG9ySW1hZ2VUaWxlLmpzXCIpLmRlZmF1bHR9ICovICh0aWxlc1tpXSk7XG4gICAgICAgIGlmICh0aWxlLmdldFN0YXRlKCkgPT0gVGlsZVN0YXRlLkFCT1JUKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRpbGVDb29yZCA9IHRpbGUudGlsZUNvb3JkO1xuICAgICAgICB2YXIgd29ybGRPZmZzZXQgPSB0aWxlR3JpZC5nZXRUaWxlQ29vcmRFeHRlbnQodGlsZUNvb3JkLCB0aGlzLnRtcEV4dGVudClbMF0gLSB0aWxlLmV4dGVudFswXTtcbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yICh2YXIgdCA9IDAsIHR0ID0gdGlsZS50aWxlS2V5cy5sZW5ndGg7IHQgPCB0dDsgKyt0KSB7XG4gICAgICAgICAgdmFyIHNvdXJjZVRpbGUgPSB0aWxlLmdldFRpbGUodGlsZS50aWxlS2V5c1t0XSk7XG4gICAgICAgICAgaWYgKHNvdXJjZVRpbGUuZ2V0U3RhdGUoKSAhPSBUaWxlU3RhdGUuTE9BREVEKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlcGxheUdyb3VwID0gLyoqIEB0eXBlIHtDYW52YXNSZXBsYXlHcm91cH0gKi8gKHNvdXJjZVRpbGUuZ2V0UmVwbGF5R3JvdXAobGF5ZXIsIHRpbGVDb29yZC50b1N0cmluZygpKSk7XG4gICAgICAgICAgaWYgKCFyZXBsYXlHcm91cCB8fCAhcmVwbGF5R3JvdXAuaGFzUmVwbGF5cyhyZXBsYXlUeXBlcykpIHtcbiAgICAgICAgICAgIC8vIHNvdXJjZVRpbGUgd2FzIG5vdCB5ZXQgbG9hZGVkIHdoZW4gdGhpcy5jcmVhdGVSZXBsYXlHcm91cF8oKSB3YXNcbiAgICAgICAgICAgIC8vIGNhbGxlZCwgb3IgaXQgaGFzIG5vIHJlcGxheXMgb2YgdGhlIHR5cGVzIHdlIHdhbnQgdG8gcmVuZGVyXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybSA9IHRoaXMuZ2V0VHJhbnNmb3JtKGZyYW1lU3RhdGUsIHdvcmxkT2Zmc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGN1cnJlbnRaID0gc291cmNlVGlsZS50aWxlQ29vcmRbMF07XG4gICAgICAgICAgdmFyIGN1cnJlbnRDbGlwID0gcmVwbGF5R3JvdXAuZ2V0Q2xpcENvb3Jkcyh0cmFuc2Zvcm0pO1xuICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBsYXllclN0YXRlLm9wYWNpdHk7XG4gICAgICAgICAgLy8gQ3JlYXRlIGEgY2xpcCBtYXNrIGZvciByZWdpb25zIGluIHRoaXMgbG93IHJlc29sdXRpb24gdGlsZSB0aGF0IGFyZVxuICAgICAgICAgIC8vIGFscmVhZHkgZmlsbGVkIGJ5IGEgaGlnaGVyIHJlc29sdXRpb24gdGlsZVxuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBqaiA9IGNsaXBzLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICAgICAgICAgIHZhciBjbGlwID0gY2xpcHNbal07XG4gICAgICAgICAgICBpZiAoY3VycmVudFogPCB6c1tqXSkge1xuICAgICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAvLyBjb3VudGVyLWNsb2Nrd2lzZSAob3V0ZXIgcmluZykgZm9yIGN1cnJlbnQgdGlsZVxuICAgICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhjdXJyZW50Q2xpcFswXSwgY3VycmVudENsaXBbMV0pO1xuICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhjdXJyZW50Q2xpcFsyXSwgY3VycmVudENsaXBbM10pO1xuICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhjdXJyZW50Q2xpcFs0XSwgY3VycmVudENsaXBbNV0pO1xuICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhjdXJyZW50Q2xpcFs2XSwgY3VycmVudENsaXBbN10pO1xuICAgICAgICAgICAgICAvLyBjbG9ja3dpc2UgKGlubmVyIHJpbmcpIGZvciBoaWdoZXIgcmVzb2x1dGlvbiB0aWxlXG4gICAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKGNsaXBbNl0sIGNsaXBbN10pO1xuICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhjbGlwWzRdLCBjbGlwWzVdKTtcbiAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oY2xpcFsyXSwgY2xpcFszXSk7XG4gICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGNsaXBbMF0sIGNsaXBbMV0pO1xuICAgICAgICAgICAgICBjb250ZXh0LmNsaXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVwbGF5R3JvdXAucmVwbGF5KGNvbnRleHQsIHRyYW5zZm9ybSwgcm90YXRpb24sIHt9LCBzbmFwVG9QaXhlbCwgcmVwbGF5VHlwZXMsIGRlY2x1dHRlclJlcGxheXMpO1xuICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICAgIGNsaXBzLnB1c2goY3VycmVudENsaXApO1xuICAgICAgICAgIHpzLnB1c2goY3VycmVudFopO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGVjbHV0dGVyUmVwbGF5cykge1xuICAgICAgICByZXBsYXlEZWNsdXR0ZXIoZGVjbHV0dGVyUmVwbGF5cywgY29udGV4dCwgcm90YXRpb24sIHNuYXBUb1BpeGVsKTtcbiAgICAgIH1cbiAgICAgIGlmIChyb3RhdGlvbikge1xuICAgICAgICByb3RhdGVBdE9mZnNldChjb250ZXh0LCByb3RhdGlvbixcbiAgICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi8gKG9mZnNldFgpLCAvKiogQHR5cGUge251bWJlcn0gKi8gKG9mZnNldFkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgQ2FudmFzVGlsZUxheWVyUmVuZGVyZXIucHJvdG90eXBlLnBvc3RDb21wb3NlLmNhbGwodGhpcywgY29udGV4dCwgZnJhbWVTdGF0ZSwgbGF5ZXJTdGF0ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3F1YXJlZFRvbGVyYW5jZSBTcXVhcmVkIHRvbGVyYW5jZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9zdHlsZS9TdHlsZS5qc1wiKS5kZWZhdWx0fEFycmF5PGltcG9ydChcIi4uLy4uL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHQ+fSBzdHlsZXMgVGhlIHN0eWxlIG9yIGFycmF5IG9mIHN0eWxlcy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9yZW5kZXIvY2FudmFzL1JlcGxheUdyb3VwLmpzXCIpLmRlZmF1bHR9IHJlcGxheUdyb3VwIFJlcGxheSBncm91cC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIGFuIGltYWdlIGlzIGxvYWRpbmcuXG4gICAqL1xuICBDYW52YXNWZWN0b3JUaWxlTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRmVhdHVyZSA9IGZ1bmN0aW9uIHJlbmRlckZlYXR1cmUkMSAoZmVhdHVyZSwgc3F1YXJlZFRvbGVyYW5jZSwgc3R5bGVzLCByZXBsYXlHcm91cCkge1xuICAgIGlmICghc3R5bGVzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBsb2FkaW5nID0gZmFsc2U7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGVzKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gc3R5bGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgbG9hZGluZyA9IHJlbmRlckZlYXR1cmUoXG4gICAgICAgICAgcmVwbGF5R3JvdXAsIGZlYXR1cmUsIHN0eWxlc1tpXSwgc3F1YXJlZFRvbGVyYW5jZSxcbiAgICAgICAgICB0aGlzLmhhbmRsZVN0eWxlSW1hZ2VDaGFuZ2VfLCB0aGlzKSB8fCBsb2FkaW5nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2FkaW5nID0gcmVuZGVyRmVhdHVyZShcbiAgICAgICAgcmVwbGF5R3JvdXAsIGZlYXR1cmUsIHN0eWxlcywgc3F1YXJlZFRvbGVyYW5jZSxcbiAgICAgICAgdGhpcy5oYW5kbGVTdHlsZUltYWdlQ2hhbmdlXywgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBsb2FkaW5nO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL1ZlY3RvckltYWdlVGlsZS5qc1wiKS5kZWZhdWx0fSB0aWxlIFRpbGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBDYW52YXNWZWN0b3JUaWxlTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyVGlsZUltYWdlXyA9IGZ1bmN0aW9uIHJlbmRlclRpbGVJbWFnZV8gKHRpbGUsIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pIHtcbiAgICB2YXIgbGF5ZXIgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2xheWVyL1ZlY3Rvci5qc1wiKS5kZWZhdWx0fSAqLyAodGhpcy5nZXRMYXllcigpKTtcbiAgICB2YXIgcmVwbGF5U3RhdGUgPSB0aWxlLmdldFJlcGxheVN0YXRlKGxheWVyKTtcbiAgICB2YXIgcmV2aXNpb24gPSBsYXllci5nZXRSZXZpc2lvbigpO1xuICAgIHZhciByZXBsYXlzID0gSU1BR0VfUkVQTEFZU1tsYXllci5nZXRSZW5kZXJNb2RlKCldO1xuICAgIGlmIChyZXBsYXlzICYmIHJlcGxheVN0YXRlLnJlbmRlcmVkVGlsZVJldmlzaW9uICE9PSByZXZpc2lvbikge1xuICAgICAgcmVwbGF5U3RhdGUucmVuZGVyZWRUaWxlUmV2aXNpb24gPSByZXZpc2lvbjtcbiAgICAgIHZhciB0aWxlQ29vcmQgPSB0aWxlLndyYXBwZWRUaWxlQ29vcmQ7XG4gICAgICB2YXIgeiA9IHRpbGVDb29yZFswXTtcbiAgICAgIHZhciBzb3VyY2UgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL3NvdXJjZS9WZWN0b3JUaWxlLmpzXCIpLmRlZmF1bHR9ICovIChsYXllci5nZXRTb3VyY2UoKSk7XG4gICAgICB2YXIgdGlsZUdyaWQgPSBzb3VyY2UuZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICAgICAgdmFyIHJlc29sdXRpb24gPSB0aWxlR3JpZC5nZXRSZXNvbHV0aW9uKHopO1xuICAgICAgdmFyIGNvbnRleHQgPSB0aWxlLmdldENvbnRleHQobGF5ZXIpO1xuICAgICAgdmFyIHNpemUgPSBzb3VyY2UuZ2V0VGlsZVBpeGVsU2l6ZSh6LCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKTtcbiAgICAgIGNvbnRleHQuY2FudmFzLndpZHRoID0gc2l6ZVswXTtcbiAgICAgIGNvbnRleHQuY2FudmFzLmhlaWdodCA9IHNpemVbMV07XG4gICAgICB2YXIgdGlsZUV4dGVudCA9IHRpbGVHcmlkLmdldFRpbGVDb29yZEV4dGVudCh0aWxlQ29vcmQsIHRoaXMudG1wRXh0ZW50KTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHRpbGUudGlsZUtleXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICB2YXIgc291cmNlVGlsZSA9IHRpbGUuZ2V0VGlsZSh0aWxlLnRpbGVLZXlzW2ldKTtcbiAgICAgICAgaWYgKHNvdXJjZVRpbGUuZ2V0U3RhdGUoKSAhPSBUaWxlU3RhdGUuTE9BREVEKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBpeGVsU2NhbGUgPSBwaXhlbFJhdGlvIC8gcmVzb2x1dGlvbjtcbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHJlc2V0VHJhbnNmb3JtKHRoaXMudG1wVHJhbnNmb3JtXyk7XG4gICAgICAgIHNjYWxlVHJhbnNmb3JtKHRyYW5zZm9ybSwgcGl4ZWxTY2FsZSwgLXBpeGVsU2NhbGUpO1xuICAgICAgICB0cmFuc2xhdGVUcmFuc2Zvcm0odHJhbnNmb3JtLCAtdGlsZUV4dGVudFswXSwgLXRpbGVFeHRlbnRbM10pO1xuICAgICAgICB2YXIgcmVwbGF5R3JvdXAgPSAvKiogQHR5cGUge0NhbnZhc1JlcGxheUdyb3VwfSAqLyAoc291cmNlVGlsZS5nZXRSZXBsYXlHcm91cChsYXllcixcbiAgICAgICAgICB0aWxlLnRpbGVDb29yZC50b1N0cmluZygpKSk7XG4gICAgICAgIHJlcGxheUdyb3VwLnJlcGxheShjb250ZXh0LCB0cmFuc2Zvcm0sIDAsIHt9LCB0cnVlLCByZXBsYXlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIENhbnZhc1ZlY3RvclRpbGVMYXllclJlbmRlcmVyO1xufShDYW52YXNUaWxlTGF5ZXJSZW5kZXJlcikpO1xuXG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHRoaXMgcmVuZGVyZXIgaGFuZGxlcyB0aGUgcHJvdmlkZWQgbGF5ZXIuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHR9IGxheWVyIFRoZSBjYW5kaWRhdGUgbGF5ZXIuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgcmVuZGVyZXIgY2FuIHJlbmRlciB0aGUgbGF5ZXIuXG4gKi9cbkNhbnZhc1ZlY3RvclRpbGVMYXllclJlbmRlcmVyWydoYW5kbGVzJ10gPSBmdW5jdGlvbihsYXllcikge1xuICByZXR1cm4gbGF5ZXIuZ2V0VHlwZSgpID09PSBMYXllclR5cGUuVkVDVE9SX1RJTEU7XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlIGEgbGF5ZXIgcmVuZGVyZXIuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcC5qc1wiKS5kZWZhdWx0fSBtYXBSZW5kZXJlciBUaGUgbWFwIHJlbmRlcmVyLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0fSBsYXllciBUaGUgbGF5ZXIgdG8gYmUgcmVuZGVyZXJkLlxuICogQHJldHVybiB7Q2FudmFzVmVjdG9yVGlsZUxheWVyUmVuZGVyZXJ9IFRoZSBsYXllciByZW5kZXJlci5cbiAqL1xuQ2FudmFzVmVjdG9yVGlsZUxheWVyUmVuZGVyZXJbJ2NyZWF0ZSddID0gZnVuY3Rpb24obWFwUmVuZGVyZXIsIGxheWVyKSB7XG4gIHJldHVybiBuZXcgQ2FudmFzVmVjdG9yVGlsZUxheWVyUmVuZGVyZXIoLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9sYXllci9WZWN0b3JUaWxlLmpzXCIpLmRlZmF1bHR9ICovIChsYXllcikpO1xufTtcblxuXG5leHBvcnQgZGVmYXVsdCBDYW52YXNWZWN0b3JUaWxlTGF5ZXJSZW5kZXJlcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VmVjdG9yVGlsZUxheWVyLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXJlci92ZWN0b3JcbiAqL1xuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4uL3V0aWwuanMnO1xuaW1wb3J0IEltYWdlU3RhdGUgZnJvbSAnLi4vSW1hZ2VTdGF0ZS5qcyc7XG5pbXBvcnQgR2VvbWV0cnlUeXBlIGZyb20gJy4uL2dlb20vR2VvbWV0cnlUeXBlLmpzJztcbmltcG9ydCBSZXBsYXlUeXBlIGZyb20gJy4uL3JlbmRlci9SZXBsYXlUeXBlLmpzJztcblxuXG4vKipcbiAqIFRvbGVyYW5jZSBmb3IgZ2VvbWV0cnkgc2ltcGxpZmljYXRpb24gaW4gZGV2aWNlIHBpeGVscy5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbnZhciBTSU1QTElGWV9UT0xFUkFOQ0UgPSAwLjU7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3Q8aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeVR5cGUuanNcIikuZGVmYXVsdCxcbiAqICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGltcG9ydChcIi4uL3JlbmRlci9SZXBsYXlHcm91cC5qc1wiKS5kZWZhdWx0LCBpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHQsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5kZWZhdWx0LCBPYmplY3QpPn1cbiAqL1xudmFyIEdFT01FVFJZX1JFTkRFUkVSUyA9IHtcbiAgJ1BvaW50JzogcmVuZGVyUG9pbnRHZW9tZXRyeSxcbiAgJ0xpbmVTdHJpbmcnOiByZW5kZXJMaW5lU3RyaW5nR2VvbWV0cnksXG4gICdQb2x5Z29uJzogcmVuZGVyUG9seWdvbkdlb21ldHJ5LFxuICAnTXVsdGlQb2ludCc6IHJlbmRlck11bHRpUG9pbnRHZW9tZXRyeSxcbiAgJ011bHRpTGluZVN0cmluZyc6IHJlbmRlck11bHRpTGluZVN0cmluZ0dlb21ldHJ5LFxuICAnTXVsdGlQb2x5Z29uJzogcmVuZGVyTXVsdGlQb2x5Z29uR2VvbWV0cnksXG4gICdHZW9tZXRyeUNvbGxlY3Rpb24nOiByZW5kZXJHZW9tZXRyeUNvbGxlY3Rpb25HZW9tZXRyeSxcbiAgJ0NpcmNsZSc6IHJlbmRlckNpcmNsZUdlb21ldHJ5XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlMSBGZWF0dXJlIDEuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUyIEZlYXR1cmUgMi5cbiAqIEByZXR1cm4ge251bWJlcn0gT3JkZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0T3JkZXIoZmVhdHVyZTEsIGZlYXR1cmUyKSB7XG4gIHJldHVybiBwYXJzZUludChnZXRVaWQoZmVhdHVyZTEpLCAxMCkgLSBwYXJzZUludChnZXRVaWQoZmVhdHVyZTIpLCAxMCk7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFNxdWFyZWQgcGl4ZWwgdG9sZXJhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3F1YXJlZFRvbGVyYW5jZShyZXNvbHV0aW9uLCBwaXhlbFJhdGlvKSB7XG4gIHZhciB0b2xlcmFuY2UgPSBnZXRUb2xlcmFuY2UocmVzb2x1dGlvbiwgcGl4ZWxSYXRpbyk7XG4gIHJldHVybiB0b2xlcmFuY2UgKiB0b2xlcmFuY2U7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFBpeGVsIHRvbGVyYW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRvbGVyYW5jZShyZXNvbHV0aW9uLCBwaXhlbFJhdGlvKSB7XG4gIHJldHVybiBTSU1QTElGWV9UT0xFUkFOQ0UgKiByZXNvbHV0aW9uIC8gcGl4ZWxSYXRpbztcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcmVuZGVyL1JlcGxheUdyb3VwLmpzXCIpLmRlZmF1bHR9IHJlcGxheUdyb3VwIFJlcGxheSBncm91cC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9DaXJjbGUuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHR9IHN0eWxlIFN0eWxlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyQ2lyY2xlR2VvbWV0cnkocmVwbGF5R3JvdXAsIGdlb21ldHJ5LCBzdHlsZSwgZmVhdHVyZSkge1xuICB2YXIgZmlsbFN0eWxlID0gc3R5bGUuZ2V0RmlsbCgpO1xuICB2YXIgc3Ryb2tlU3R5bGUgPSBzdHlsZS5nZXRTdHJva2UoKTtcbiAgaWYgKGZpbGxTdHlsZSB8fCBzdHJva2VTdHlsZSkge1xuICAgIHZhciBjaXJjbGVSZXBsYXkgPSByZXBsYXlHcm91cC5nZXRSZXBsYXkoc3R5bGUuZ2V0WkluZGV4KCksIFJlcGxheVR5cGUuQ0lSQ0xFKTtcbiAgICBjaXJjbGVSZXBsYXkuc2V0RmlsbFN0cm9rZVN0eWxlKGZpbGxTdHlsZSwgc3Ryb2tlU3R5bGUpO1xuICAgIGNpcmNsZVJlcGxheS5kcmF3Q2lyY2xlKGdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgfVxuICB2YXIgdGV4dFN0eWxlID0gc3R5bGUuZ2V0VGV4dCgpO1xuICBpZiAodGV4dFN0eWxlKSB7XG4gICAgdmFyIHRleHRSZXBsYXkgPSByZXBsYXlHcm91cC5nZXRSZXBsYXkoc3R5bGUuZ2V0WkluZGV4KCksIFJlcGxheVR5cGUuVEVYVCk7XG4gICAgdGV4dFJlcGxheS5zZXRUZXh0U3R5bGUodGV4dFN0eWxlLCByZXBsYXlHcm91cC5hZGREZWNsdXR0ZXIoZmFsc2UpKTtcbiAgICB0ZXh0UmVwbGF5LmRyYXdUZXh0KGdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9yZW5kZXIvUmVwbGF5R3JvdXAuanNcIikuZGVmYXVsdH0gcmVwbGF5R3JvdXAgUmVwbGF5IGdyb3VwLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHR9IHN0eWxlIFN0eWxlLlxuICogQHBhcmFtIHtudW1iZXJ9IHNxdWFyZWRUb2xlcmFuY2UgU3F1YXJlZCB0b2xlcmFuY2UuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6IFQsIGltcG9ydChcIi4uL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0KX0gbGlzdGVuZXIgTGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge1R9IHRoaXNBcmcgVmFsdWUgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyBgbGlzdGVuZXJgLlxuICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHN0eWxlIGlzIGxvYWRpbmcuXG4gKiBAdGVtcGxhdGUgVFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyRmVhdHVyZShyZXBsYXlHcm91cCwgZmVhdHVyZSwgc3R5bGUsIHNxdWFyZWRUb2xlcmFuY2UsIGxpc3RlbmVyLCB0aGlzQXJnKSB7XG4gIHZhciBsb2FkaW5nID0gZmFsc2U7XG4gIHZhciBpbWFnZVN0eWxlID0gc3R5bGUuZ2V0SW1hZ2UoKTtcbiAgaWYgKGltYWdlU3R5bGUpIHtcbiAgICB2YXIgaW1hZ2VTdGF0ZSA9IGltYWdlU3R5bGUuZ2V0SW1hZ2VTdGF0ZSgpO1xuICAgIGlmIChpbWFnZVN0YXRlID09IEltYWdlU3RhdGUuTE9BREVEIHx8IGltYWdlU3RhdGUgPT0gSW1hZ2VTdGF0ZS5FUlJPUikge1xuICAgICAgaW1hZ2VTdHlsZS51bmxpc3RlbkltYWdlQ2hhbmdlKGxpc3RlbmVyLCB0aGlzQXJnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGltYWdlU3RhdGUgPT0gSW1hZ2VTdGF0ZS5JRExFKSB7XG4gICAgICAgIGltYWdlU3R5bGUubG9hZCgpO1xuICAgICAgfVxuICAgICAgaW1hZ2VTdGF0ZSA9IGltYWdlU3R5bGUuZ2V0SW1hZ2VTdGF0ZSgpO1xuICAgICAgaW1hZ2VTdHlsZS5saXN0ZW5JbWFnZUNoYW5nZShsaXN0ZW5lciwgdGhpc0FyZyk7XG4gICAgICBsb2FkaW5nID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyRmVhdHVyZUludGVybmFsKHJlcGxheUdyb3VwLCBmZWF0dXJlLCBzdHlsZSwgc3F1YXJlZFRvbGVyYW5jZSk7XG5cbiAgcmV0dXJuIGxvYWRpbmc7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3JlbmRlci9SZXBsYXlHcm91cC5qc1wiKS5kZWZhdWx0fSByZXBsYXlHcm91cCBSZXBsYXkgZ3JvdXAuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUgRmVhdHVyZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdH0gc3R5bGUgU3R5bGUuXG4gKiBAcGFyYW0ge251bWJlcn0gc3F1YXJlZFRvbGVyYW5jZSBTcXVhcmVkIHRvbGVyYW5jZS5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyRmVhdHVyZUludGVybmFsKHJlcGxheUdyb3VwLCBmZWF0dXJlLCBzdHlsZSwgc3F1YXJlZFRvbGVyYW5jZSkge1xuICB2YXIgZ2VvbWV0cnkgPSBzdHlsZS5nZXRHZW9tZXRyeUZ1bmN0aW9uKCkoZmVhdHVyZSk7XG4gIGlmICghZ2VvbWV0cnkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHNpbXBsaWZpZWRHZW9tZXRyeSA9IGdlb21ldHJ5LmdldFNpbXBsaWZpZWRHZW9tZXRyeShzcXVhcmVkVG9sZXJhbmNlKTtcbiAgdmFyIHJlbmRlcmVyID0gc3R5bGUuZ2V0UmVuZGVyZXIoKTtcbiAgaWYgKHJlbmRlcmVyKSB7XG4gICAgcmVuZGVyR2VvbWV0cnkocmVwbGF5R3JvdXAsIHNpbXBsaWZpZWRHZW9tZXRyeSwgc3R5bGUsIGZlYXR1cmUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBnZW9tZXRyeVJlbmRlcmVyID0gR0VPTUVUUllfUkVOREVSRVJTW3NpbXBsaWZpZWRHZW9tZXRyeS5nZXRUeXBlKCldO1xuICAgIGdlb21ldHJ5UmVuZGVyZXIocmVwbGF5R3JvdXAsIHNpbXBsaWZpZWRHZW9tZXRyeSwgc3R5bGUsIGZlYXR1cmUpO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3JlbmRlci9SZXBsYXlHcm91cC5qc1wiKS5kZWZhdWx0fSByZXBsYXlHcm91cCBSZXBsYXkgZ3JvdXAuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9yZW5kZXIvRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdH0gc3R5bGUgU3R5bGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUgRmVhdHVyZS5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyR2VvbWV0cnkocmVwbGF5R3JvdXAsIGdlb21ldHJ5LCBzdHlsZSwgZmVhdHVyZSkge1xuICBpZiAoZ2VvbWV0cnkuZ2V0VHlwZSgpID09IEdlb21ldHJ5VHlwZS5HRU9NRVRSWV9DT0xMRUNUSU9OKSB7XG4gICAgdmFyIGdlb21ldHJpZXMgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnlDb2xsZWN0aW9uLmpzXCIpLmRlZmF1bHR9ICovIChnZW9tZXRyeSkuZ2V0R2VvbWV0cmllcygpO1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGdlb21ldHJpZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgcmVuZGVyR2VvbWV0cnkocmVwbGF5R3JvdXAsIGdlb21ldHJpZXNbaV0sIHN0eWxlLCBmZWF0dXJlKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciByZXBsYXkgPSByZXBsYXlHcm91cC5nZXRSZXBsYXkoc3R5bGUuZ2V0WkluZGV4KCksIFJlcGxheVR5cGUuREVGQVVMVCk7XG4gIHJlcGxheS5kcmF3Q3VzdG9tKC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSAqLyAoZ2VvbWV0cnkpLCBmZWF0dXJlLCBzdHlsZS5nZXRSZW5kZXJlcigpKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcmVuZGVyL1JlcGxheUdyb3VwLmpzXCIpLmRlZmF1bHR9IHJlcGxheUdyb3VwIFJlcGxheSBncm91cC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeUNvbGxlY3Rpb24uanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHR9IHN0eWxlIFN0eWxlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyR2VvbWV0cnlDb2xsZWN0aW9uR2VvbWV0cnkocmVwbGF5R3JvdXAsIGdlb21ldHJ5LCBzdHlsZSwgZmVhdHVyZSkge1xuICB2YXIgZ2VvbWV0cmllcyA9IGdlb21ldHJ5LmdldEdlb21ldHJpZXNBcnJheSgpO1xuICB2YXIgaSwgaWk7XG4gIGZvciAoaSA9IDAsIGlpID0gZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgdmFyIGdlb21ldHJ5UmVuZGVyZXIgPVxuICAgICAgICBHRU9NRVRSWV9SRU5ERVJFUlNbZ2VvbWV0cmllc1tpXS5nZXRUeXBlKCldO1xuICAgIGdlb21ldHJ5UmVuZGVyZXIocmVwbGF5R3JvdXAsIGdlb21ldHJpZXNbaV0sIHN0eWxlLCBmZWF0dXJlKTtcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9yZW5kZXIvUmVwbGF5R3JvdXAuanNcIikuZGVmYXVsdH0gcmVwbGF5R3JvdXAgUmVwbGF5IGdyb3VwLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL0xpbmVTdHJpbmcuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9yZW5kZXIvRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdH0gc3R5bGUgU3R5bGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUgRmVhdHVyZS5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyTGluZVN0cmluZ0dlb21ldHJ5KHJlcGxheUdyb3VwLCBnZW9tZXRyeSwgc3R5bGUsIGZlYXR1cmUpIHtcbiAgdmFyIHN0cm9rZVN0eWxlID0gc3R5bGUuZ2V0U3Ryb2tlKCk7XG4gIGlmIChzdHJva2VTdHlsZSkge1xuICAgIHZhciBsaW5lU3RyaW5nUmVwbGF5ID0gcmVwbGF5R3JvdXAuZ2V0UmVwbGF5KHN0eWxlLmdldFpJbmRleCgpLCBSZXBsYXlUeXBlLkxJTkVfU1RSSU5HKTtcbiAgICBsaW5lU3RyaW5nUmVwbGF5LnNldEZpbGxTdHJva2VTdHlsZShudWxsLCBzdHJva2VTdHlsZSk7XG4gICAgbGluZVN0cmluZ1JlcGxheS5kcmF3TGluZVN0cmluZyhnZW9tZXRyeSwgZmVhdHVyZSk7XG4gIH1cbiAgdmFyIHRleHRTdHlsZSA9IHN0eWxlLmdldFRleHQoKTtcbiAgaWYgKHRleHRTdHlsZSkge1xuICAgIHZhciB0ZXh0UmVwbGF5ID0gcmVwbGF5R3JvdXAuZ2V0UmVwbGF5KHN0eWxlLmdldFpJbmRleCgpLCBSZXBsYXlUeXBlLlRFWFQpO1xuICAgIHRleHRSZXBsYXkuc2V0VGV4dFN0eWxlKHRleHRTdHlsZSwgcmVwbGF5R3JvdXAuYWRkRGVjbHV0dGVyKGZhbHNlKSk7XG4gICAgdGV4dFJlcGxheS5kcmF3VGV4dChnZW9tZXRyeSwgZmVhdHVyZSk7XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcmVuZGVyL1JlcGxheUdyb3VwLmpzXCIpLmRlZmF1bHR9IHJlcGxheUdyb3VwIFJlcGxheSBncm91cC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9NdWx0aUxpbmVTdHJpbmcuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9yZW5kZXIvRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdH0gc3R5bGUgU3R5bGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUgRmVhdHVyZS5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyTXVsdGlMaW5lU3RyaW5nR2VvbWV0cnkocmVwbGF5R3JvdXAsIGdlb21ldHJ5LCBzdHlsZSwgZmVhdHVyZSkge1xuICB2YXIgc3Ryb2tlU3R5bGUgPSBzdHlsZS5nZXRTdHJva2UoKTtcbiAgaWYgKHN0cm9rZVN0eWxlKSB7XG4gICAgdmFyIGxpbmVTdHJpbmdSZXBsYXkgPSByZXBsYXlHcm91cC5nZXRSZXBsYXkoc3R5bGUuZ2V0WkluZGV4KCksIFJlcGxheVR5cGUuTElORV9TVFJJTkcpO1xuICAgIGxpbmVTdHJpbmdSZXBsYXkuc2V0RmlsbFN0cm9rZVN0eWxlKG51bGwsIHN0cm9rZVN0eWxlKTtcbiAgICBsaW5lU3RyaW5nUmVwbGF5LmRyYXdNdWx0aUxpbmVTdHJpbmcoZ2VvbWV0cnksIGZlYXR1cmUpO1xuICB9XG4gIHZhciB0ZXh0U3R5bGUgPSBzdHlsZS5nZXRUZXh0KCk7XG4gIGlmICh0ZXh0U3R5bGUpIHtcbiAgICB2YXIgdGV4dFJlcGxheSA9IHJlcGxheUdyb3VwLmdldFJlcGxheShzdHlsZS5nZXRaSW5kZXgoKSwgUmVwbGF5VHlwZS5URVhUKTtcbiAgICB0ZXh0UmVwbGF5LnNldFRleHRTdHlsZSh0ZXh0U3R5bGUsIHJlcGxheUdyb3VwLmFkZERlY2x1dHRlcihmYWxzZSkpO1xuICAgIHRleHRSZXBsYXkuZHJhd1RleHQoZ2VvbWV0cnksIGZlYXR1cmUpO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3JlbmRlci9SZXBsYXlHcm91cC5qc1wiKS5kZWZhdWx0fSByZXBsYXlHcm91cCBSZXBsYXkgZ3JvdXAuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vTXVsdGlQb2x5Z29uLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5kZWZhdWx0fSBzdHlsZSBTdHlsZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmUuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlck11bHRpUG9seWdvbkdlb21ldHJ5KHJlcGxheUdyb3VwLCBnZW9tZXRyeSwgc3R5bGUsIGZlYXR1cmUpIHtcbiAgdmFyIGZpbGxTdHlsZSA9IHN0eWxlLmdldEZpbGwoKTtcbiAgdmFyIHN0cm9rZVN0eWxlID0gc3R5bGUuZ2V0U3Ryb2tlKCk7XG4gIGlmIChzdHJva2VTdHlsZSB8fCBmaWxsU3R5bGUpIHtcbiAgICB2YXIgcG9seWdvblJlcGxheSA9IHJlcGxheUdyb3VwLmdldFJlcGxheShzdHlsZS5nZXRaSW5kZXgoKSwgUmVwbGF5VHlwZS5QT0xZR09OKTtcbiAgICBwb2x5Z29uUmVwbGF5LnNldEZpbGxTdHJva2VTdHlsZShmaWxsU3R5bGUsIHN0cm9rZVN0eWxlKTtcbiAgICBwb2x5Z29uUmVwbGF5LmRyYXdNdWx0aVBvbHlnb24oZ2VvbWV0cnksIGZlYXR1cmUpO1xuICB9XG4gIHZhciB0ZXh0U3R5bGUgPSBzdHlsZS5nZXRUZXh0KCk7XG4gIGlmICh0ZXh0U3R5bGUpIHtcbiAgICB2YXIgdGV4dFJlcGxheSA9IHJlcGxheUdyb3VwLmdldFJlcGxheShzdHlsZS5nZXRaSW5kZXgoKSwgUmVwbGF5VHlwZS5URVhUKTtcbiAgICB0ZXh0UmVwbGF5LnNldFRleHRTdHlsZSh0ZXh0U3R5bGUsIHJlcGxheUdyb3VwLmFkZERlY2x1dHRlcihmYWxzZSkpO1xuICAgIHRleHRSZXBsYXkuZHJhd1RleHQoZ2VvbWV0cnksIGZlYXR1cmUpO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3JlbmRlci9SZXBsYXlHcm91cC5qc1wiKS5kZWZhdWx0fSByZXBsYXlHcm91cCBSZXBsYXkgZ3JvdXAuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vUG9pbnQuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9yZW5kZXIvRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdH0gc3R5bGUgU3R5bGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUgRmVhdHVyZS5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyUG9pbnRHZW9tZXRyeShyZXBsYXlHcm91cCwgZ2VvbWV0cnksIHN0eWxlLCBmZWF0dXJlKSB7XG4gIHZhciBpbWFnZVN0eWxlID0gc3R5bGUuZ2V0SW1hZ2UoKTtcbiAgaWYgKGltYWdlU3R5bGUpIHtcbiAgICBpZiAoaW1hZ2VTdHlsZS5nZXRJbWFnZVN0YXRlKCkgIT0gSW1hZ2VTdGF0ZS5MT0FERUQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGltYWdlUmVwbGF5ID0gcmVwbGF5R3JvdXAuZ2V0UmVwbGF5KHN0eWxlLmdldFpJbmRleCgpLCBSZXBsYXlUeXBlLklNQUdFKTtcbiAgICBpbWFnZVJlcGxheS5zZXRJbWFnZVN0eWxlKGltYWdlU3R5bGUsIHJlcGxheUdyb3VwLmFkZERlY2x1dHRlcihmYWxzZSkpO1xuICAgIGltYWdlUmVwbGF5LmRyYXdQb2ludChnZW9tZXRyeSwgZmVhdHVyZSk7XG4gIH1cbiAgdmFyIHRleHRTdHlsZSA9IHN0eWxlLmdldFRleHQoKTtcbiAgaWYgKHRleHRTdHlsZSkge1xuICAgIHZhciB0ZXh0UmVwbGF5ID0gcmVwbGF5R3JvdXAuZ2V0UmVwbGF5KHN0eWxlLmdldFpJbmRleCgpLCBSZXBsYXlUeXBlLlRFWFQpO1xuICAgIHRleHRSZXBsYXkuc2V0VGV4dFN0eWxlKHRleHRTdHlsZSwgcmVwbGF5R3JvdXAuYWRkRGVjbHV0dGVyKCEhaW1hZ2VTdHlsZSkpO1xuICAgIHRleHRSZXBsYXkuZHJhd1RleHQoZ2VvbWV0cnksIGZlYXR1cmUpO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3JlbmRlci9SZXBsYXlHcm91cC5qc1wiKS5kZWZhdWx0fSByZXBsYXlHcm91cCBSZXBsYXkgZ3JvdXAuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vTXVsdGlQb2ludC5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL3JlbmRlci9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5kZWZhdWx0fSBzdHlsZSBTdHlsZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZSBGZWF0dXJlLlxuICovXG5mdW5jdGlvbiByZW5kZXJNdWx0aVBvaW50R2VvbWV0cnkocmVwbGF5R3JvdXAsIGdlb21ldHJ5LCBzdHlsZSwgZmVhdHVyZSkge1xuICB2YXIgaW1hZ2VTdHlsZSA9IHN0eWxlLmdldEltYWdlKCk7XG4gIGlmIChpbWFnZVN0eWxlKSB7XG4gICAgaWYgKGltYWdlU3R5bGUuZ2V0SW1hZ2VTdGF0ZSgpICE9IEltYWdlU3RhdGUuTE9BREVEKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpbWFnZVJlcGxheSA9IHJlcGxheUdyb3VwLmdldFJlcGxheShzdHlsZS5nZXRaSW5kZXgoKSwgUmVwbGF5VHlwZS5JTUFHRSk7XG4gICAgaW1hZ2VSZXBsYXkuc2V0SW1hZ2VTdHlsZShpbWFnZVN0eWxlLCByZXBsYXlHcm91cC5hZGREZWNsdXR0ZXIoZmFsc2UpKTtcbiAgICBpbWFnZVJlcGxheS5kcmF3TXVsdGlQb2ludChnZW9tZXRyeSwgZmVhdHVyZSk7XG4gIH1cbiAgdmFyIHRleHRTdHlsZSA9IHN0eWxlLmdldFRleHQoKTtcbiAgaWYgKHRleHRTdHlsZSkge1xuICAgIHZhciB0ZXh0UmVwbGF5ID0gcmVwbGF5R3JvdXAuZ2V0UmVwbGF5KHN0eWxlLmdldFpJbmRleCgpLCBSZXBsYXlUeXBlLlRFWFQpO1xuICAgIHRleHRSZXBsYXkuc2V0VGV4dFN0eWxlKHRleHRTdHlsZSwgcmVwbGF5R3JvdXAuYWRkRGVjbHV0dGVyKCEhaW1hZ2VTdHlsZSkpO1xuICAgIHRleHRSZXBsYXkuZHJhd1RleHQoZ2VvbWV0cnksIGZlYXR1cmUpO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3JlbmRlci9SZXBsYXlHcm91cC5qc1wiKS5kZWZhdWx0fSByZXBsYXlHcm91cCBSZXBsYXkgZ3JvdXAuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vUG9seWdvbi5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL3JlbmRlci9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5kZWZhdWx0fSBzdHlsZSBTdHlsZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZSBGZWF0dXJlLlxuICovXG5mdW5jdGlvbiByZW5kZXJQb2x5Z29uR2VvbWV0cnkocmVwbGF5R3JvdXAsIGdlb21ldHJ5LCBzdHlsZSwgZmVhdHVyZSkge1xuICB2YXIgZmlsbFN0eWxlID0gc3R5bGUuZ2V0RmlsbCgpO1xuICB2YXIgc3Ryb2tlU3R5bGUgPSBzdHlsZS5nZXRTdHJva2UoKTtcbiAgaWYgKGZpbGxTdHlsZSB8fCBzdHJva2VTdHlsZSkge1xuICAgIHZhciBwb2x5Z29uUmVwbGF5ID0gcmVwbGF5R3JvdXAuZ2V0UmVwbGF5KHN0eWxlLmdldFpJbmRleCgpLCBSZXBsYXlUeXBlLlBPTFlHT04pO1xuICAgIHBvbHlnb25SZXBsYXkuc2V0RmlsbFN0cm9rZVN0eWxlKGZpbGxTdHlsZSwgc3Ryb2tlU3R5bGUpO1xuICAgIHBvbHlnb25SZXBsYXkuZHJhd1BvbHlnb24oZ2VvbWV0cnksIGZlYXR1cmUpO1xuICB9XG4gIHZhciB0ZXh0U3R5bGUgPSBzdHlsZS5nZXRUZXh0KCk7XG4gIGlmICh0ZXh0U3R5bGUpIHtcbiAgICB2YXIgdGV4dFJlcGxheSA9IHJlcGxheUdyb3VwLmdldFJlcGxheShzdHlsZS5nZXRaSW5kZXgoKSwgUmVwbGF5VHlwZS5URVhUKTtcbiAgICB0ZXh0UmVwbGF5LnNldFRleHRTdHlsZSh0ZXh0U3R5bGUsIHJlcGxheUdyb3VwLmFkZERlY2x1dHRlcihmYWxzZSkpO1xuICAgIHRleHRSZXBsYXkuZHJhd1RleHQoZ2VvbWV0cnksIGZlYXR1cmUpO1xuICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlY3Rvci5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVwcm9qXG4gKi9cbmltcG9ydCB7Y3JlYXRlQ2FudmFzQ29udGV4dDJEfSBmcm9tICcuL2RvbS5qcyc7XG5pbXBvcnQge2NvbnRhaW5zQ29vcmRpbmF0ZSwgY3JlYXRlRW1wdHksIGV4dGVuZCwgZ2V0SGVpZ2h0LCBnZXRUb3BMZWZ0LCBnZXRXaWR0aH0gZnJvbSAnLi9leHRlbnQuanMnO1xuaW1wb3J0IHtzb2x2ZUxpbmVhclN5c3RlbX0gZnJvbSAnLi9tYXRoLmpzJztcbmltcG9ydCB7Z2V0UG9pbnRSZXNvbHV0aW9uLCB0cmFuc2Zvcm19IGZyb20gJy4vcHJvai5qcyc7XG5cblxuLyoqXG4gKiBDYWxjdWxhdGVzIGlkZWFsIHJlc29sdXRpb24gdG8gdXNlIGZyb20gdGhlIHNvdXJjZSBpbiBvcmRlciB0byBhY2hpZXZlXG4gKiBwaXhlbCBtYXBwaW5nIGFzIGNsb3NlIGFzIHBvc3NpYmxlIHRvIDE6MSBkdXJpbmcgcmVwcm9qZWN0aW9uLlxuICogVGhlIHJlc29sdXRpb24gaXMgY2FsY3VsYXRlZCByZWdhcmRsZXNzIG9mIHdoYXQgcmVzb2x1dGlvbnNcbiAqIGFyZSBhY3R1YWxseSBhdmFpbGFibGUgaW4gdGhlIGRhdGFzZXQgKFRpbGVHcmlkLCBJbWFnZSwgLi4uKS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHNvdXJjZVByb2ogU291cmNlIHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHRhcmdldFByb2ogVGFyZ2V0IHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSB0YXJnZXRDZW50ZXIgVGFyZ2V0IGNlbnRlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0YXJnZXRSZXNvbHV0aW9uIFRhcmdldCByZXNvbHV0aW9uLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYmVzdCByZXNvbHV0aW9uIHRvIHVzZS4gQ2FuIGJlICstSW5maW5pdHksIE5hTiBvciAwLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlU291cmNlUmVzb2x1dGlvbihzb3VyY2VQcm9qLCB0YXJnZXRQcm9qLFxuICB0YXJnZXRDZW50ZXIsIHRhcmdldFJlc29sdXRpb24pIHtcblxuICB2YXIgc291cmNlQ2VudGVyID0gdHJhbnNmb3JtKHRhcmdldENlbnRlciwgdGFyZ2V0UHJvaiwgc291cmNlUHJvaik7XG5cbiAgLy8gY2FsY3VsYXRlIHRoZSBpZGVhbCByZXNvbHV0aW9uIG9mIHRoZSBzb3VyY2UgZGF0YVxuICB2YXIgc291cmNlUmVzb2x1dGlvbiA9IGdldFBvaW50UmVzb2x1dGlvbih0YXJnZXRQcm9qLCB0YXJnZXRSZXNvbHV0aW9uLCB0YXJnZXRDZW50ZXIpO1xuXG4gIHZhciB0YXJnZXRNZXRlcnNQZXJVbml0ID0gdGFyZ2V0UHJvai5nZXRNZXRlcnNQZXJVbml0KCk7XG4gIGlmICh0YXJnZXRNZXRlcnNQZXJVbml0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBzb3VyY2VSZXNvbHV0aW9uICo9IHRhcmdldE1ldGVyc1BlclVuaXQ7XG4gIH1cbiAgdmFyIHNvdXJjZU1ldGVyc1BlclVuaXQgPSBzb3VyY2VQcm9qLmdldE1ldGVyc1BlclVuaXQoKTtcbiAgaWYgKHNvdXJjZU1ldGVyc1BlclVuaXQgIT09IHVuZGVmaW5lZCkge1xuICAgIHNvdXJjZVJlc29sdXRpb24gLz0gc291cmNlTWV0ZXJzUGVyVW5pdDtcbiAgfVxuXG4gIC8vIEJhc2VkIG9uIHRoZSBwcm9qZWN0aW9uIHByb3BlcnRpZXMsIHRoZSBwb2ludCByZXNvbHV0aW9uIGF0IHRoZSBzcGVjaWZpZWRcbiAgLy8gY29vcmRpbmF0ZXMgbWF5IGJlIHNsaWdodGx5IGRpZmZlcmVudC4gV2UgbmVlZCB0byByZXZlcnNlLWNvbXBlbnNhdGUgdGhpc1xuICAvLyBpbiBvcmRlciB0byBhY2hpZXZlIG9wdGltYWwgcmVzdWx0cy5cblxuICB2YXIgc291cmNlRXh0ZW50ID0gc291cmNlUHJvai5nZXRFeHRlbnQoKTtcbiAgaWYgKCFzb3VyY2VFeHRlbnQgfHwgY29udGFpbnNDb29yZGluYXRlKHNvdXJjZUV4dGVudCwgc291cmNlQ2VudGVyKSkge1xuICAgIHZhciBjb21wZW5zYXRpb25GYWN0b3IgPSBnZXRQb2ludFJlc29sdXRpb24oc291cmNlUHJvaiwgc291cmNlUmVzb2x1dGlvbiwgc291cmNlQ2VudGVyKSAvXG4gICAgICAgIHNvdXJjZVJlc29sdXRpb247XG4gICAgaWYgKGlzRmluaXRlKGNvbXBlbnNhdGlvbkZhY3RvcikgJiYgY29tcGVuc2F0aW9uRmFjdG9yID4gMCkge1xuICAgICAgc291cmNlUmVzb2x1dGlvbiAvPSBjb21wZW5zYXRpb25GYWN0b3I7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNvdXJjZVJlc29sdXRpb247XG59XG5cblxuLyoqXG4gKiBFbmxhcmdlIHRoZSBjbGlwcGluZyB0cmlhbmdsZSBwb2ludCBieSAxIHBpeGVsIHRvIGVuc3VyZSB0aGUgZWRnZXMgb3ZlcmxhcFxuICogaW4gb3JkZXIgdG8gbWFzayBnYXBzIGNhdXNlZCBieSBhbnRpYWxpYXNpbmcuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGNlbnRyb2lkWCBDZW50cm9pZCBvZiB0aGUgdHJpYW5nbGUgKHggY29vcmRpbmF0ZSBpbiBwaXhlbHMpLlxuICogQHBhcmFtIHtudW1iZXJ9IGNlbnRyb2lkWSBDZW50cm9pZCBvZiB0aGUgdHJpYW5nbGUgKHkgY29vcmRpbmF0ZSBpbiBwaXhlbHMpLlxuICogQHBhcmFtIHtudW1iZXJ9IHggWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCAoaW4gcGl4ZWxzKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgKGluIHBpeGVscykuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gTmV3IHBvaW50IDEgcHggZmFydGhlciBmcm9tIHRoZSBjZW50cm9pZC5cbiAqL1xuZnVuY3Rpb24gZW5sYXJnZUNsaXBQb2ludChjZW50cm9pZFgsIGNlbnRyb2lkWSwgeCwgeSkge1xuICB2YXIgZFggPSB4IC0gY2VudHJvaWRYO1xuICB2YXIgZFkgPSB5IC0gY2VudHJvaWRZO1xuICB2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZFggKiBkWCArIGRZICogZFkpO1xuICByZXR1cm4gW01hdGgucm91bmQoeCArIGRYIC8gZGlzdGFuY2UpLCBNYXRoLnJvdW5kKHkgKyBkWSAvIGRpc3RhbmNlKV07XG59XG5cblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBzb3VyY2UgZGF0YSBpbnRvIG5ldyBjYW52YXMgYmFzZWQgb24gdGhlIHRyaWFuZ3VsYXRpb24uXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFdpZHRoIG9mIHRoZSBjYW52YXMuXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IEhlaWdodCBvZiB0aGUgY2FudmFzLlxuICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gKiBAcGFyYW0ge251bWJlcn0gc291cmNlUmVzb2x1dGlvbiBTb3VyY2UgcmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBzb3VyY2VFeHRlbnQgRXh0ZW50IG9mIHRoZSBkYXRhIHNvdXJjZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0YXJnZXRSZXNvbHV0aW9uIFRhcmdldCByZXNvbHV0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IHRhcmdldEV4dGVudCBUYXJnZXQgZXh0ZW50LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3JlcHJvai9Ucmlhbmd1bGF0aW9uLmpzXCIpLmRlZmF1bHR9IHRyaWFuZ3VsYXRpb25cbiAqIENhbGN1bGF0ZWQgdHJpYW5ndWxhdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXk8e2V4dGVudDogaW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50LFxuICogICAgICAgICAgICAgICAgIGltYWdlOiAoSFRNTENhbnZhc0VsZW1lbnR8SFRNTEltYWdlRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50KX0+fSBzb3VyY2VzXG4gKiBBcnJheSBvZiBzb3VyY2VzLlxuICogQHBhcmFtIHtudW1iZXJ9IGd1dHRlciBHdXR0ZXIgb2YgdGhlIHNvdXJjZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfcmVuZGVyRWRnZXMgUmVuZGVyIHJlcHJvamVjdGlvbiBlZGdlcy5cbiAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBDYW52YXMgd2l0aCByZXByb2plY3RlZCBkYXRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyKHdpZHRoLCBoZWlnaHQsIHBpeGVsUmF0aW8sXG4gIHNvdXJjZVJlc29sdXRpb24sIHNvdXJjZUV4dGVudCwgdGFyZ2V0UmVzb2x1dGlvbiwgdGFyZ2V0RXh0ZW50LFxuICB0cmlhbmd1bGF0aW9uLCBzb3VyY2VzLCBndXR0ZXIsIG9wdF9yZW5kZXJFZGdlcykge1xuXG4gIHZhciBjb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKE1hdGgucm91bmQocGl4ZWxSYXRpbyAqIHdpZHRoKSxcbiAgICBNYXRoLnJvdW5kKHBpeGVsUmF0aW8gKiBoZWlnaHQpKTtcblxuICBpZiAoc291cmNlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gY29udGV4dC5jYW52YXM7XG4gIH1cblxuICBjb250ZXh0LnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xuXG4gIHZhciBzb3VyY2VEYXRhRXh0ZW50ID0gY3JlYXRlRW1wdHkoKTtcbiAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uKHNyYywgaSwgYXJyKSB7XG4gICAgZXh0ZW5kKHNvdXJjZURhdGFFeHRlbnQsIHNyYy5leHRlbnQpO1xuICB9KTtcblxuICB2YXIgY2FudmFzV2lkdGhJblVuaXRzID0gZ2V0V2lkdGgoc291cmNlRGF0YUV4dGVudCk7XG4gIHZhciBjYW52YXNIZWlnaHRJblVuaXRzID0gZ2V0SGVpZ2h0KHNvdXJjZURhdGFFeHRlbnQpO1xuICB2YXIgc3RpdGNoQ29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQyRChcbiAgICBNYXRoLnJvdW5kKHBpeGVsUmF0aW8gKiBjYW52YXNXaWR0aEluVW5pdHMgLyBzb3VyY2VSZXNvbHV0aW9uKSxcbiAgICBNYXRoLnJvdW5kKHBpeGVsUmF0aW8gKiBjYW52YXNIZWlnaHRJblVuaXRzIC8gc291cmNlUmVzb2x1dGlvbikpO1xuXG4gIHZhciBzdGl0Y2hTY2FsZSA9IHBpeGVsUmF0aW8gLyBzb3VyY2VSZXNvbHV0aW9uO1xuXG4gIHNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbihzcmMsIGksIGFycikge1xuICAgIHZhciB4UG9zID0gc3JjLmV4dGVudFswXSAtIHNvdXJjZURhdGFFeHRlbnRbMF07XG4gICAgdmFyIHlQb3MgPSAtKHNyYy5leHRlbnRbM10gLSBzb3VyY2VEYXRhRXh0ZW50WzNdKTtcbiAgICB2YXIgc3JjV2lkdGggPSBnZXRXaWR0aChzcmMuZXh0ZW50KTtcbiAgICB2YXIgc3JjSGVpZ2h0ID0gZ2V0SGVpZ2h0KHNyYy5leHRlbnQpO1xuXG4gICAgc3RpdGNoQ29udGV4dC5kcmF3SW1hZ2UoXG4gICAgICBzcmMuaW1hZ2UsXG4gICAgICBndXR0ZXIsIGd1dHRlcixcbiAgICAgIHNyYy5pbWFnZS53aWR0aCAtIDIgKiBndXR0ZXIsIHNyYy5pbWFnZS5oZWlnaHQgLSAyICogZ3V0dGVyLFxuICAgICAgeFBvcyAqIHN0aXRjaFNjYWxlLCB5UG9zICogc3RpdGNoU2NhbGUsXG4gICAgICBzcmNXaWR0aCAqIHN0aXRjaFNjYWxlLCBzcmNIZWlnaHQgKiBzdGl0Y2hTY2FsZSk7XG4gIH0pO1xuXG4gIHZhciB0YXJnZXRUb3BMZWZ0ID0gZ2V0VG9wTGVmdCh0YXJnZXRFeHRlbnQpO1xuXG4gIHRyaWFuZ3VsYXRpb24uZ2V0VHJpYW5nbGVzKCkuZm9yRWFjaChmdW5jdGlvbih0cmlhbmdsZSwgaSwgYXJyKSB7XG4gICAgLyogQ2FsY3VsYXRlIGFmZmluZSB0cmFuc2Zvcm0gKHNyYyAtPiBkc3QpXG4gICAgICogUmVzdWx0aW5nIG1hdHJpeCBjYW4gYmUgdXNlZCB0byB0cmFuc2Zvcm0gY29vcmRpbmF0ZVxuICAgICAqIGZyb20gYHNvdXJjZVByb2plY3Rpb25gIHRvIGRlc3RpbmF0aW9uIHBpeGVscy5cbiAgICAgKlxuICAgICAqIFRvIG9wdGltaXplIG51bWJlciBvZiBjb250ZXh0IGNhbGxzIGFuZCBpbmNyZWFzZSBudW1lcmljYWwgc3RhYmlsaXR5LFxuICAgICAqIHdlIGFsc28gZG8gdGhlIGZvbGxvd2luZyBvcGVyYXRpb25zOlxuICAgICAqIHRyYW5zKC10b3BMZWZ0RXh0ZW50Q29ybmVyKSwgc2NhbGUoMSAvIHRhcmdldFJlc29sdXRpb24pLCBzY2FsZSgxLCAtMSlcbiAgICAgKiBoZXJlIGJlZm9yZSBzb2x2aW5nIHRoZSBsaW5lYXIgc3lzdGVtIHNvIFt1aSwgdmldIGFyZSBwaXhlbCBjb29yZGluYXRlcy5cbiAgICAgKlxuICAgICAqIFNyYyBwb2ludHM6IHhpLCB5aVxuICAgICAqIERzdCBwb2ludHM6IHVpLCB2aVxuICAgICAqIEFmZmluZSBjb2VmZmljaWVudHM6IGFpalxuICAgICAqXG4gICAgICogfCB4MCB5MCAxICAwICAwIDAgfCAgIHxhMDB8ICAgfHUwfFxuICAgICAqIHwgeDEgeTEgMSAgMCAgMCAwIHwgICB8YTAxfCAgIHx1MXxcbiAgICAgKiB8IHgyIHkyIDEgIDAgIDAgMCB8IHggfGEwMnwgPSB8dTJ8XG4gICAgICogfCAgMCAgMCAwIHgwIHkwIDEgfCAgIHxhMTB8ICAgfHYwfFxuICAgICAqIHwgIDAgIDAgMCB4MSB5MSAxIHwgICB8YTExfCAgIHx2MXxcbiAgICAgKiB8ICAwICAwIDAgeDIgeTIgMSB8ICAgfGExMnwgICB8djJ8XG4gICAgICovXG4gICAgdmFyIHNvdXJjZSA9IHRyaWFuZ2xlLnNvdXJjZTtcbiAgICB2YXIgdGFyZ2V0ID0gdHJpYW5nbGUudGFyZ2V0O1xuICAgIHZhciB4MCA9IHNvdXJjZVswXVswXSwgeTAgPSBzb3VyY2VbMF1bMV07XG4gICAgdmFyIHgxID0gc291cmNlWzFdWzBdLCB5MSA9IHNvdXJjZVsxXVsxXTtcbiAgICB2YXIgeDIgPSBzb3VyY2VbMl1bMF0sIHkyID0gc291cmNlWzJdWzFdO1xuICAgIHZhciB1MCA9ICh0YXJnZXRbMF1bMF0gLSB0YXJnZXRUb3BMZWZ0WzBdKSAvIHRhcmdldFJlc29sdXRpb247XG4gICAgdmFyIHYwID0gLSh0YXJnZXRbMF1bMV0gLSB0YXJnZXRUb3BMZWZ0WzFdKSAvIHRhcmdldFJlc29sdXRpb247XG4gICAgdmFyIHUxID0gKHRhcmdldFsxXVswXSAtIHRhcmdldFRvcExlZnRbMF0pIC8gdGFyZ2V0UmVzb2x1dGlvbjtcbiAgICB2YXIgdjEgPSAtKHRhcmdldFsxXVsxXSAtIHRhcmdldFRvcExlZnRbMV0pIC8gdGFyZ2V0UmVzb2x1dGlvbjtcbiAgICB2YXIgdTIgPSAodGFyZ2V0WzJdWzBdIC0gdGFyZ2V0VG9wTGVmdFswXSkgLyB0YXJnZXRSZXNvbHV0aW9uO1xuICAgIHZhciB2MiA9IC0odGFyZ2V0WzJdWzFdIC0gdGFyZ2V0VG9wTGVmdFsxXSkgLyB0YXJnZXRSZXNvbHV0aW9uO1xuXG4gICAgLy8gU2hpZnQgYWxsIHRoZSBzb3VyY2UgcG9pbnRzIHRvIGltcHJvdmUgbnVtZXJpY2FsIHN0YWJpbGl0eVxuICAgIC8vIG9mIGFsbCB0aGUgc3Vic2VxdWVudCBjYWxjdWxhdGlvbnMuIFRoZSBbeDAsIHkwXSBpcyB1c2VkIGhlcmUuXG4gICAgLy8gVGhpcyBpcyBhbHNvIHVzZWQgdG8gc2ltcGxpZnkgdGhlIGxpbmVhciBzeXN0ZW0uXG4gICAgdmFyIHNvdXJjZU51bWVyaWNhbFNoaWZ0WCA9IHgwO1xuICAgIHZhciBzb3VyY2VOdW1lcmljYWxTaGlmdFkgPSB5MDtcbiAgICB4MCA9IDA7XG4gICAgeTAgPSAwO1xuICAgIHgxIC09IHNvdXJjZU51bWVyaWNhbFNoaWZ0WDtcbiAgICB5MSAtPSBzb3VyY2VOdW1lcmljYWxTaGlmdFk7XG4gICAgeDIgLT0gc291cmNlTnVtZXJpY2FsU2hpZnRYO1xuICAgIHkyIC09IHNvdXJjZU51bWVyaWNhbFNoaWZ0WTtcblxuICAgIHZhciBhdWdtZW50ZWRNYXRyaXggPSBbXG4gICAgICBbeDEsIHkxLCAwLCAwLCB1MSAtIHUwXSxcbiAgICAgIFt4MiwgeTIsIDAsIDAsIHUyIC0gdTBdLFxuICAgICAgWzAsIDAsIHgxLCB5MSwgdjEgLSB2MF0sXG4gICAgICBbMCwgMCwgeDIsIHkyLCB2MiAtIHYwXVxuICAgIF07XG4gICAgdmFyIGFmZmluZUNvZWZzID0gc29sdmVMaW5lYXJTeXN0ZW0oYXVnbWVudGVkTWF0cml4KTtcbiAgICBpZiAoIWFmZmluZUNvZWZzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29udGV4dC5zYXZlKCk7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICB2YXIgY2VudHJvaWRYID0gKHUwICsgdTEgKyB1MikgLyAzO1xuICAgIHZhciBjZW50cm9pZFkgPSAodjAgKyB2MSArIHYyKSAvIDM7XG4gICAgdmFyIHAwID0gZW5sYXJnZUNsaXBQb2ludChjZW50cm9pZFgsIGNlbnRyb2lkWSwgdTAsIHYwKTtcbiAgICB2YXIgcDEgPSBlbmxhcmdlQ2xpcFBvaW50KGNlbnRyb2lkWCwgY2VudHJvaWRZLCB1MSwgdjEpO1xuICAgIHZhciBwMiA9IGVubGFyZ2VDbGlwUG9pbnQoY2VudHJvaWRYLCBjZW50cm9pZFksIHUyLCB2Mik7XG5cbiAgICBjb250ZXh0Lm1vdmVUbyhwMVswXSwgcDFbMV0pO1xuICAgIGNvbnRleHQubGluZVRvKHAwWzBdLCBwMFsxXSk7XG4gICAgY29udGV4dC5saW5lVG8ocDJbMF0sIHAyWzFdKTtcbiAgICBjb250ZXh0LmNsaXAoKTtcblxuICAgIGNvbnRleHQudHJhbnNmb3JtKFxuICAgICAgYWZmaW5lQ29lZnNbMF0sIGFmZmluZUNvZWZzWzJdLCBhZmZpbmVDb2Vmc1sxXSwgYWZmaW5lQ29lZnNbM10sIHUwLCB2MCk7XG5cbiAgICBjb250ZXh0LnRyYW5zbGF0ZShzb3VyY2VEYXRhRXh0ZW50WzBdIC0gc291cmNlTnVtZXJpY2FsU2hpZnRYLFxuICAgICAgc291cmNlRGF0YUV4dGVudFszXSAtIHNvdXJjZU51bWVyaWNhbFNoaWZ0WSk7XG5cbiAgICBjb250ZXh0LnNjYWxlKHNvdXJjZVJlc29sdXRpb24gLyBwaXhlbFJhdGlvLFxuICAgICAgLXNvdXJjZVJlc29sdXRpb24gLyBwaXhlbFJhdGlvKTtcblxuICAgIGNvbnRleHQuZHJhd0ltYWdlKHN0aXRjaENvbnRleHQuY2FudmFzLCAwLCAwKTtcbiAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgfSk7XG5cbiAgaWYgKG9wdF9yZW5kZXJFZGdlcykge1xuICAgIGNvbnRleHQuc2F2ZSgpO1xuXG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICdibGFjayc7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSAxO1xuXG4gICAgdHJpYW5ndWxhdGlvbi5nZXRUcmlhbmdsZXMoKS5mb3JFYWNoKGZ1bmN0aW9uKHRyaWFuZ2xlLCBpLCBhcnIpIHtcbiAgICAgIHZhciB0YXJnZXQgPSB0cmlhbmdsZS50YXJnZXQ7XG4gICAgICB2YXIgdTAgPSAodGFyZ2V0WzBdWzBdIC0gdGFyZ2V0VG9wTGVmdFswXSkgLyB0YXJnZXRSZXNvbHV0aW9uO1xuICAgICAgdmFyIHYwID0gLSh0YXJnZXRbMF1bMV0gLSB0YXJnZXRUb3BMZWZ0WzFdKSAvIHRhcmdldFJlc29sdXRpb247XG4gICAgICB2YXIgdTEgPSAodGFyZ2V0WzFdWzBdIC0gdGFyZ2V0VG9wTGVmdFswXSkgLyB0YXJnZXRSZXNvbHV0aW9uO1xuICAgICAgdmFyIHYxID0gLSh0YXJnZXRbMV1bMV0gLSB0YXJnZXRUb3BMZWZ0WzFdKSAvIHRhcmdldFJlc29sdXRpb247XG4gICAgICB2YXIgdTIgPSAodGFyZ2V0WzJdWzBdIC0gdGFyZ2V0VG9wTGVmdFswXSkgLyB0YXJnZXRSZXNvbHV0aW9uO1xuICAgICAgdmFyIHYyID0gLSh0YXJnZXRbMl1bMV0gLSB0YXJnZXRUb3BMZWZ0WzFdKSAvIHRhcmdldFJlc29sdXRpb247XG5cbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBjb250ZXh0Lm1vdmVUbyh1MSwgdjEpO1xuICAgICAgY29udGV4dC5saW5lVG8odTAsIHYwKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHUyLCB2Mik7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICB9KTtcblxuICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICB9XG4gIHJldHVybiBjb250ZXh0LmNhbnZhcztcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVwcm9qLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9yZXByb2ovVGlsZVxuICovXG5pbXBvcnQge0VSUk9SX1RIUkVTSE9MRH0gZnJvbSAnLi9jb21tb24uanMnO1xuXG5pbXBvcnQgVGlsZSBmcm9tICcuLi9UaWxlLmpzJztcbmltcG9ydCBUaWxlU3RhdGUgZnJvbSAnLi4vVGlsZVN0YXRlLmpzJztcbmltcG9ydCB7bGlzdGVuLCB1bmxpc3RlbkJ5S2V5fSBmcm9tICcuLi9ldmVudHMuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7Z2V0QXJlYSwgZ2V0Q2VudGVyLCBnZXRJbnRlcnNlY3Rpb259IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge2NsYW1wfSBmcm9tICcuLi9tYXRoLmpzJztcbmltcG9ydCB7Y2FsY3VsYXRlU291cmNlUmVzb2x1dGlvbiwgcmVuZGVyIGFzIHJlbmRlclJlcHJvamVjdGVkfSBmcm9tICcuLi9yZXByb2ouanMnO1xuaW1wb3J0IFRyaWFuZ3VsYXRpb24gZnJvbSAnLi9Ucmlhbmd1bGF0aW9uLmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIpIDogaW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5kZWZhdWx0fSBGdW5jdGlvblR5cGVcbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQ2xhc3MgZW5jYXBzdWxhdGluZyBzaW5nbGUgcmVwcm9qZWN0ZWQgdGlsZS5cbiAqIFNlZSB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9UaWxlSW1hZ2V+VGlsZUltYWdlfS5cbiAqXG4gKi9cbnZhciBSZXByb2pUaWxlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoVGlsZSkge1xuICBmdW5jdGlvbiBSZXByb2pUaWxlKFxuICAgIHNvdXJjZVByb2osXG4gICAgc291cmNlVGlsZUdyaWQsXG4gICAgdGFyZ2V0UHJvaixcbiAgICB0YXJnZXRUaWxlR3JpZCxcbiAgICB0aWxlQ29vcmQsXG4gICAgd3JhcHBlZFRpbGVDb29yZCxcbiAgICBwaXhlbFJhdGlvLFxuICAgIGd1dHRlcixcbiAgICBnZXRUaWxlRnVuY3Rpb24sXG4gICAgb3B0X2Vycm9yVGhyZXNob2xkLFxuICAgIG9wdF9yZW5kZXJFZGdlc1xuICApIHtcbiAgICBUaWxlLmNhbGwodGhpcywgdGlsZUNvb3JkLCBUaWxlU3RhdGUuSURMRSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyRWRnZXNfID0gb3B0X3JlbmRlckVkZ2VzICE9PSB1bmRlZmluZWQgPyBvcHRfcmVuZGVyRWRnZXMgOiBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnBpeGVsUmF0aW9fID0gcGl4ZWxSYXRpbztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmd1dHRlcl8gPSBndXR0ZXI7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmNhbnZhc18gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLnNvdXJjZVRpbGVHcmlkXyA9IHNvdXJjZVRpbGVHcmlkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldFRpbGVHcmlkXyA9IHRhcmdldFRpbGVHcmlkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH1cbiAgICAgKi9cbiAgICB0aGlzLndyYXBwZWRUaWxlQ29vcmRfID0gd3JhcHBlZFRpbGVDb29yZCA/IHdyYXBwZWRUaWxlQ29vcmQgOiB0aWxlQ29vcmQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshQXJyYXk8aW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5kZWZhdWx0Pn1cbiAgICAgKi9cbiAgICB0aGlzLnNvdXJjZVRpbGVzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5zb3VyY2VzTGlzdGVuZXJLZXlzXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zb3VyY2VaXyA9IDA7XG5cbiAgICB2YXIgdGFyZ2V0RXh0ZW50ID0gdGFyZ2V0VGlsZUdyaWQuZ2V0VGlsZUNvb3JkRXh0ZW50KHRoaXMud3JhcHBlZFRpbGVDb29yZF8pO1xuICAgIHZhciBtYXhUYXJnZXRFeHRlbnQgPSB0aGlzLnRhcmdldFRpbGVHcmlkXy5nZXRFeHRlbnQoKTtcbiAgICB2YXIgbWF4U291cmNlRXh0ZW50ID0gdGhpcy5zb3VyY2VUaWxlR3JpZF8uZ2V0RXh0ZW50KCk7XG5cbiAgICB2YXIgbGltaXRlZFRhcmdldEV4dGVudCA9IG1heFRhcmdldEV4dGVudCA/XG4gICAgICBnZXRJbnRlcnNlY3Rpb24odGFyZ2V0RXh0ZW50LCBtYXhUYXJnZXRFeHRlbnQpIDogdGFyZ2V0RXh0ZW50O1xuXG4gICAgaWYgKGdldEFyZWEobGltaXRlZFRhcmdldEV4dGVudCkgPT09IDApIHtcbiAgICAgIC8vIFRpbGUgaXMgY29tcGxldGVseSBvdXRzaWRlIHJhbmdlIC0+IEVNUFRZXG4gICAgICAvLyBUT0RPOiBpcyBpdCBhY3R1YWxseSBjb3JyZWN0IHRoYXQgdGhlIHNvdXJjZSBldmVuIGNyZWF0ZXMgdGhlIHRpbGUgP1xuICAgICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5FTVBUWTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlUHJvakV4dGVudCA9IHNvdXJjZVByb2ouZ2V0RXh0ZW50KCk7XG4gICAgaWYgKHNvdXJjZVByb2pFeHRlbnQpIHtcbiAgICAgIGlmICghbWF4U291cmNlRXh0ZW50KSB7XG4gICAgICAgIG1heFNvdXJjZUV4dGVudCA9IHNvdXJjZVByb2pFeHRlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXhTb3VyY2VFeHRlbnQgPSBnZXRJbnRlcnNlY3Rpb24obWF4U291cmNlRXh0ZW50LCBzb3VyY2VQcm9qRXh0ZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0UmVzb2x1dGlvbiA9IHRhcmdldFRpbGVHcmlkLmdldFJlc29sdXRpb24oXG4gICAgICB0aGlzLndyYXBwZWRUaWxlQ29vcmRfWzBdKTtcblxuICAgIHZhciB0YXJnZXRDZW50ZXIgPSBnZXRDZW50ZXIobGltaXRlZFRhcmdldEV4dGVudCk7XG4gICAgdmFyIHNvdXJjZVJlc29sdXRpb24gPSBjYWxjdWxhdGVTb3VyY2VSZXNvbHV0aW9uKFxuICAgICAgc291cmNlUHJvaiwgdGFyZ2V0UHJvaiwgdGFyZ2V0Q2VudGVyLCB0YXJnZXRSZXNvbHV0aW9uKTtcblxuICAgIGlmICghaXNGaW5pdGUoc291cmNlUmVzb2x1dGlvbikgfHwgc291cmNlUmVzb2x1dGlvbiA8PSAwKSB7XG4gICAgICAvLyBpbnZhbGlkIHNvdXJjZVJlc29sdXRpb24gLT4gRU1QVFlcbiAgICAgIC8vIHByb2JhYmx5IGVkZ2VzIG9mIHRoZSBwcm9qZWN0aW9ucyB3aGVuIG5vIGV4dGVudCBpcyBkZWZpbmVkXG4gICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkVNUFRZO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBlcnJvclRocmVzaG9sZEluUGl4ZWxzID0gb3B0X2Vycm9yVGhyZXNob2xkICE9PSB1bmRlZmluZWQgP1xuICAgICAgb3B0X2Vycm9yVGhyZXNob2xkIDogRVJST1JfVEhSRVNIT0xEO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IWltcG9ydChcIi4vVHJpYW5ndWxhdGlvbi5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMudHJpYW5ndWxhdGlvbl8gPSBuZXcgVHJpYW5ndWxhdGlvbihcbiAgICAgIHNvdXJjZVByb2osIHRhcmdldFByb2osIGxpbWl0ZWRUYXJnZXRFeHRlbnQsIG1heFNvdXJjZUV4dGVudCxcbiAgICAgIHNvdXJjZVJlc29sdXRpb24gKiBlcnJvclRocmVzaG9sZEluUGl4ZWxzKTtcblxuICAgIGlmICh0aGlzLnRyaWFuZ3VsYXRpb25fLmdldFRyaWFuZ2xlcygpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gbm8gdmFsaWQgdHJpYW5nbGVzIC0+IEVNUFRZXG4gICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkVNUFRZO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc291cmNlWl8gPSBzb3VyY2VUaWxlR3JpZC5nZXRaRm9yUmVzb2x1dGlvbihzb3VyY2VSZXNvbHV0aW9uKTtcbiAgICB2YXIgc291cmNlRXh0ZW50ID0gdGhpcy50cmlhbmd1bGF0aW9uXy5jYWxjdWxhdGVTb3VyY2VFeHRlbnQoKTtcblxuICAgIGlmIChtYXhTb3VyY2VFeHRlbnQpIHtcbiAgICAgIGlmIChzb3VyY2VQcm9qLmNhbldyYXBYKCkpIHtcbiAgICAgICAgc291cmNlRXh0ZW50WzFdID0gY2xhbXAoXG4gICAgICAgICAgc291cmNlRXh0ZW50WzFdLCBtYXhTb3VyY2VFeHRlbnRbMV0sIG1heFNvdXJjZUV4dGVudFszXSk7XG4gICAgICAgIHNvdXJjZUV4dGVudFszXSA9IGNsYW1wKFxuICAgICAgICAgIHNvdXJjZUV4dGVudFszXSwgbWF4U291cmNlRXh0ZW50WzFdLCBtYXhTb3VyY2VFeHRlbnRbM10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc291cmNlRXh0ZW50ID0gZ2V0SW50ZXJzZWN0aW9uKHNvdXJjZUV4dGVudCwgbWF4U291cmNlRXh0ZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWdldEFyZWEoc291cmNlRXh0ZW50KSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5FTVBUWTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNvdXJjZVJhbmdlID0gc291cmNlVGlsZUdyaWQuZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWihcbiAgICAgICAgc291cmNlRXh0ZW50LCB0aGlzLnNvdXJjZVpfKTtcblxuICAgICAgZm9yICh2YXIgc3JjWCA9IHNvdXJjZVJhbmdlLm1pblg7IHNyY1ggPD0gc291cmNlUmFuZ2UubWF4WDsgc3JjWCsrKSB7XG4gICAgICAgIGZvciAodmFyIHNyY1kgPSBzb3VyY2VSYW5nZS5taW5ZOyBzcmNZIDw9IHNvdXJjZVJhbmdlLm1heFk7IHNyY1krKykge1xuICAgICAgICAgIHZhciB0aWxlID0gZ2V0VGlsZUZ1bmN0aW9uKHRoaXMuc291cmNlWl8sIHNyY1gsIHNyY1ksIHBpeGVsUmF0aW8pO1xuICAgICAgICAgIGlmICh0aWxlKSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZVRpbGVzXy5wdXNoKHRpbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zb3VyY2VUaWxlc18ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuRU1QVFk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCBUaWxlICkgUmVwcm9qVGlsZS5fX3Byb3RvX18gPSBUaWxlO1xuICBSZXByb2pUaWxlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRpbGUgJiYgVGlsZS5wcm90b3R5cGUgKTtcbiAgUmVwcm9qVGlsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZXByb2pUaWxlO1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgUmVwcm9qVGlsZS5wcm90b3R5cGUuZGlzcG9zZUludGVybmFsID0gZnVuY3Rpb24gZGlzcG9zZUludGVybmFsICgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PSBUaWxlU3RhdGUuTE9BRElORykge1xuICAgICAgdGhpcy51bmxpc3RlblNvdXJjZXNfKCk7XG4gICAgfVxuICAgIFRpbGUucHJvdG90eXBlLmRpc3Bvc2VJbnRlcm5hbC5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIEhUTUwgQ2FudmFzIGVsZW1lbnQgZm9yIHRoaXMgdGlsZS5cbiAgICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR9IENhbnZhcy5cbiAgICovXG4gIFJlcHJvalRpbGUucHJvdG90eXBlLmdldEltYWdlID0gZnVuY3Rpb24gZ2V0SW1hZ2UgKCkge1xuICAgIHJldHVybiB0aGlzLmNhbnZhc187XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBSZXByb2pUaWxlLnByb3RvdHlwZS5yZXByb2plY3RfID0gZnVuY3Rpb24gcmVwcm9qZWN0XyAoKSB7XG4gICAgdmFyIHNvdXJjZXMgPSBbXTtcbiAgICB0aGlzLnNvdXJjZVRpbGVzXy5mb3JFYWNoKGZ1bmN0aW9uKHRpbGUsIGksIGFycikge1xuICAgICAgaWYgKHRpbGUgJiYgdGlsZS5nZXRTdGF0ZSgpID09IFRpbGVTdGF0ZS5MT0FERUQpIHtcbiAgICAgICAgc291cmNlcy5wdXNoKHtcbiAgICAgICAgICBleHRlbnQ6IHRoaXMuc291cmNlVGlsZUdyaWRfLmdldFRpbGVDb29yZEV4dGVudCh0aWxlLnRpbGVDb29yZCksXG4gICAgICAgICAgaW1hZ2U6IHRpbGUuZ2V0SW1hZ2UoKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LmJpbmQodGhpcykpO1xuICAgIHRoaXMuc291cmNlVGlsZXNfLmxlbmd0aCA9IDA7XG5cbiAgICBpZiAoc291cmNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuRVJST1I7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB6ID0gdGhpcy53cmFwcGVkVGlsZUNvb3JkX1swXTtcbiAgICAgIHZhciBzaXplID0gdGhpcy50YXJnZXRUaWxlR3JpZF8uZ2V0VGlsZVNpemUoeik7XG4gICAgICB2YXIgd2lkdGggPSB0eXBlb2Ygc2l6ZSA9PT0gJ251bWJlcicgPyBzaXplIDogc2l6ZVswXTtcbiAgICAgIHZhciBoZWlnaHQgPSB0eXBlb2Ygc2l6ZSA9PT0gJ251bWJlcicgPyBzaXplIDogc2l6ZVsxXTtcbiAgICAgIHZhciB0YXJnZXRSZXNvbHV0aW9uID0gdGhpcy50YXJnZXRUaWxlR3JpZF8uZ2V0UmVzb2x1dGlvbih6KTtcbiAgICAgIHZhciBzb3VyY2VSZXNvbHV0aW9uID0gdGhpcy5zb3VyY2VUaWxlR3JpZF8uZ2V0UmVzb2x1dGlvbih0aGlzLnNvdXJjZVpfKTtcblxuICAgICAgdmFyIHRhcmdldEV4dGVudCA9IHRoaXMudGFyZ2V0VGlsZUdyaWRfLmdldFRpbGVDb29yZEV4dGVudChcbiAgICAgICAgdGhpcy53cmFwcGVkVGlsZUNvb3JkXyk7XG4gICAgICB0aGlzLmNhbnZhc18gPSByZW5kZXJSZXByb2plY3RlZCh3aWR0aCwgaGVpZ2h0LCB0aGlzLnBpeGVsUmF0aW9fLFxuICAgICAgICBzb3VyY2VSZXNvbHV0aW9uLCB0aGlzLnNvdXJjZVRpbGVHcmlkXy5nZXRFeHRlbnQoKSxcbiAgICAgICAgdGFyZ2V0UmVzb2x1dGlvbiwgdGFyZ2V0RXh0ZW50LCB0aGlzLnRyaWFuZ3VsYXRpb25fLCBzb3VyY2VzLFxuICAgICAgICB0aGlzLmd1dHRlcl8sIHRoaXMucmVuZGVyRWRnZXNfKTtcblxuICAgICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5MT0FERUQ7XG4gICAgfVxuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgUmVwcm9qVGlsZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIGxvYWQgKCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09IFRpbGVTdGF0ZS5JRExFKSB7XG4gICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkxPQURJTkc7XG4gICAgICB0aGlzLmNoYW5nZWQoKTtcblxuICAgICAgdmFyIGxlZnRUb0xvYWQgPSAwO1xuXG4gICAgICB0aGlzLnNvdXJjZXNMaXN0ZW5lcktleXNfID0gW107XG4gICAgICB0aGlzLnNvdXJjZVRpbGVzXy5mb3JFYWNoKGZ1bmN0aW9uKHRpbGUsIGksIGFycikge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aWxlLmdldFN0YXRlKCk7XG4gICAgICAgIGlmIChzdGF0ZSA9PSBUaWxlU3RhdGUuSURMRSB8fCBzdGF0ZSA9PSBUaWxlU3RhdGUuTE9BRElORykge1xuICAgICAgICAgIGxlZnRUb0xvYWQrKztcblxuICAgICAgICAgIHZhciBzb3VyY2VMaXN0ZW5LZXkgPSBsaXN0ZW4odGlsZSwgRXZlbnRUeXBlLkNIQU5HRSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgdmFyIHN0YXRlID0gdGlsZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICBpZiAoc3RhdGUgPT0gVGlsZVN0YXRlLkxPQURFRCB8fFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9PSBUaWxlU3RhdGUuRVJST1IgfHxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPT0gVGlsZVN0YXRlLkVNUFRZKSB7XG4gICAgICAgICAgICAgICAgdW5saXN0ZW5CeUtleShzb3VyY2VMaXN0ZW5LZXkpO1xuICAgICAgICAgICAgICAgIGxlZnRUb0xvYWQtLTtcbiAgICAgICAgICAgICAgICBpZiAobGVmdFRvTG9hZCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy51bmxpc3RlblNvdXJjZXNfKCk7XG4gICAgICAgICAgICAgICAgICB0aGlzLnJlcHJvamVjdF8oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgIHRoaXMuc291cmNlc0xpc3RlbmVyS2V5c18ucHVzaChzb3VyY2VMaXN0ZW5LZXkpO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICB0aGlzLnNvdXJjZVRpbGVzXy5mb3JFYWNoKGZ1bmN0aW9uKHRpbGUsIGksIGFycikge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aWxlLmdldFN0YXRlKCk7XG4gICAgICAgIGlmIChzdGF0ZSA9PSBUaWxlU3RhdGUuSURMRSkge1xuICAgICAgICAgIHRpbGUubG9hZCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKGxlZnRUb0xvYWQgPT09IDApIHtcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLnJlcHJvamVjdF8uYmluZCh0aGlzKSwgMCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgUmVwcm9qVGlsZS5wcm90b3R5cGUudW5saXN0ZW5Tb3VyY2VzXyA9IGZ1bmN0aW9uIHVubGlzdGVuU291cmNlc18gKCkge1xuICAgIHRoaXMuc291cmNlc0xpc3RlbmVyS2V5c18uZm9yRWFjaCh1bmxpc3RlbkJ5S2V5KTtcbiAgICB0aGlzLnNvdXJjZXNMaXN0ZW5lcktleXNfID0gbnVsbDtcbiAgfTtcblxuICByZXR1cm4gUmVwcm9qVGlsZTtcbn0oVGlsZSkpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IFJlcHJvalRpbGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpbGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlcHJvai9Ucmlhbmd1bGF0aW9uXG4gKi9cbmltcG9ydCB7Ym91bmRpbmdFeHRlbnQsIGNyZWF0ZUVtcHR5LCBleHRlbmRDb29yZGluYXRlLCBnZXRCb3R0b21MZWZ0LCBnZXRCb3R0b21SaWdodCxcbiAgZ2V0VG9wTGVmdCwgZ2V0VG9wUmlnaHQsIGdldFdpZHRoLCBpbnRlcnNlY3RzfSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IHttb2R1bG99IGZyb20gJy4uL21hdGguanMnO1xuaW1wb3J0IHtnZXRUcmFuc2Zvcm19IGZyb20gJy4uL3Byb2ouanMnO1xuXG5cbi8qKlxuICogU2luZ2xlIHRyaWFuZ2xlOyBjb25zaXN0cyBvZiAzIHNvdXJjZSBwb2ludHMgYW5kIDMgdGFyZ2V0IHBvaW50cy5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRyaWFuZ2xlXG4gKiBAcHJvcGVydHkge0FycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59IHNvdXJjZVxuICogQHByb3BlcnR5IHtBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSB0YXJnZXRcbiAqL1xuXG5cbi8qKlxuICogTWF4aW11bSBudW1iZXIgb2Ygc3ViZGl2aXNpb24gc3RlcHMgZHVyaW5nIHJhc3RlciByZXByb2plY3Rpb24gdHJpYW5ndWxhdGlvbi5cbiAqIFByZXZlbnRzIGhpZ2ggbWVtb3J5IHVzYWdlIGFuZCBsYXJnZSBudW1iZXIgb2YgcHJvajQgY2FsbHMgKGZvciBjZXJ0YWluXG4gKiB0cmFuc2Zvcm1hdGlvbnMgYW5kIGFyZWFzKS4gQXQgbW9zdCBgMiooMl50aGlzKWAgdHJpYW5nbGVzIGFyZSBjcmVhdGVkIGZvclxuICogZWFjaCB0cmlhbmd1bGF0ZWQgZXh0ZW50ICh0aWxlL2ltYWdlKS5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbnZhciBNQVhfU1VCRElWSVNJT04gPSAxMDtcblxuXG4vKipcbiAqIE1heGltdW0gYWxsb3dlZCBzaXplIG9mIHRyaWFuZ2xlIHJlbGF0aXZlIHRvIHdvcmxkIHdpZHRoLiBXaGVuIHRyYW5zZm9ybWluZ1xuICogY29ybmVycyBvZiB3b3JsZCBleHRlbnQgYmV0d2VlbiBjZXJ0YWluIHByb2plY3Rpb25zLCB0aGUgcmVzdWx0aW5nXG4gKiB0cmlhbmd1bGF0aW9uIHNlZW1zIHRvIGhhdmUgemVybyBlcnJvciBhbmQgbm8gc3ViZGl2aXNpb24gaXMgcGVyZm9ybWVkLiBJZlxuICogdGhlIHRyaWFuZ2xlIHdpZHRoIGlzIG1vcmUgdGhhbiB0aGlzIChyZWxhdGl2ZSB0byB3b3JsZCB3aWR0aDsgMC0xKSxcbiAqIHN1YmRpdmlzb24gaXMgZm9yY2VkICh1cCB0byBgTUFYX1NVQkRJVklTSU9OYCkuIERlZmF1bHQgaXMgYDAuMjVgLlxuICogQHR5cGUge251bWJlcn1cbiAqL1xudmFyIE1BWF9UUklBTkdMRV9XSURUSCA9IDAuMjU7XG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBDbGFzcyBjb250YWluaW5nIHRyaWFuZ3VsYXRpb24gb2YgdGhlIGdpdmVuIHRhcmdldCBleHRlbnQuXG4gKiBVc2VkIGZvciBkZXRlcm1pbmluZyBzb3VyY2UgZGF0YSBhbmQgdGhlIHJlcHJvamVjdGlvbiBpdHNlbGYuXG4gKi9cbnZhciBUcmlhbmd1bGF0aW9uID0gZnVuY3Rpb24gVHJpYW5ndWxhdGlvbihzb3VyY2VQcm9qLCB0YXJnZXRQcm9qLCB0YXJnZXRFeHRlbnQsIG1heFNvdXJjZUV4dGVudCwgZXJyb3JUaHJlc2hvbGQpIHtcblxuICAvKipcbiAgICogQHR5cGUge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5zb3VyY2VQcm9qXyA9IHNvdXJjZVByb2o7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMudGFyZ2V0UHJval8gPSB0YXJnZXRQcm9qO1xuXG4gIC8qKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59ICovXG4gIHZhciB0cmFuc2Zvcm1JbnZDYWNoZSA9IHt9O1xuICB2YXIgdHJhbnNmb3JtSW52ID0gZ2V0VHJhbnNmb3JtKHRoaXMudGFyZ2V0UHJval8sIHRoaXMuc291cmNlUHJval8pO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gYyBBIGNvb3JkaW5hdGUuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gVHJhbnNmb3JtZWQgY29vcmRpbmF0ZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMudHJhbnNmb3JtSW52XyA9IGZ1bmN0aW9uKGMpIHtcbiAgICB2YXIga2V5ID0gY1swXSArICcvJyArIGNbMV07XG4gICAgaWYgKCF0cmFuc2Zvcm1JbnZDYWNoZVtrZXldKSB7XG4gICAgICB0cmFuc2Zvcm1JbnZDYWNoZVtrZXldID0gdHJhbnNmb3JtSW52KGMpO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNmb3JtSW52Q2FjaGVba2V5XTtcbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLm1heFNvdXJjZUV4dGVudF8gPSBtYXhTb3VyY2VFeHRlbnQ7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmVycm9yVGhyZXNob2xkU3F1YXJlZF8gPSBlcnJvclRocmVzaG9sZCAqIGVycm9yVGhyZXNob2xkO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXk8VHJpYW5nbGU+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy50cmlhbmdsZXNfID0gW107XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyB0aGF0IHRoZSB0cmlhbmd1bGF0aW9uIGNyb3NzZXMgZWRnZSBvZiB0aGUgc291cmNlIHByb2plY3Rpb24uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy53cmFwc1hJblNvdXJjZV8gPSBmYWxzZTtcblxuICAvKipcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmNhbldyYXBYSW5Tb3VyY2VfID0gdGhpcy5zb3VyY2VQcm9qXy5jYW5XcmFwWCgpICYmXG4gICAgICAhIW1heFNvdXJjZUV4dGVudCAmJlxuICAgICAgISF0aGlzLnNvdXJjZVByb2pfLmdldEV4dGVudCgpICYmXG4gICAgICAoZ2V0V2lkdGgobWF4U291cmNlRXh0ZW50KSA9PSBnZXRXaWR0aCh0aGlzLnNvdXJjZVByb2pfLmdldEV4dGVudCgpKSk7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHs/bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5zb3VyY2VXb3JsZFdpZHRoXyA9IHRoaXMuc291cmNlUHJval8uZ2V0RXh0ZW50KCkgP1xuICAgIGdldFdpZHRoKHRoaXMuc291cmNlUHJval8uZ2V0RXh0ZW50KCkpIDogbnVsbDtcblxuICAvKipcbiAgICogQHR5cGUgez9udW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnRhcmdldFdvcmxkV2lkdGhfID0gdGhpcy50YXJnZXRQcm9qXy5nZXRFeHRlbnQoKSA/XG4gICAgZ2V0V2lkdGgodGhpcy50YXJnZXRQcm9qXy5nZXRFeHRlbnQoKSkgOiBudWxsO1xuXG4gIHZhciBkZXN0aW5hdGlvblRvcExlZnQgPSBnZXRUb3BMZWZ0KHRhcmdldEV4dGVudCk7XG4gIHZhciBkZXN0aW5hdGlvblRvcFJpZ2h0ID0gZ2V0VG9wUmlnaHQodGFyZ2V0RXh0ZW50KTtcbiAgdmFyIGRlc3RpbmF0aW9uQm90dG9tUmlnaHQgPSBnZXRCb3R0b21SaWdodCh0YXJnZXRFeHRlbnQpO1xuICB2YXIgZGVzdGluYXRpb25Cb3R0b21MZWZ0ID0gZ2V0Qm90dG9tTGVmdCh0YXJnZXRFeHRlbnQpO1xuICB2YXIgc291cmNlVG9wTGVmdCA9IHRoaXMudHJhbnNmb3JtSW52XyhkZXN0aW5hdGlvblRvcExlZnQpO1xuICB2YXIgc291cmNlVG9wUmlnaHQgPSB0aGlzLnRyYW5zZm9ybUludl8oZGVzdGluYXRpb25Ub3BSaWdodCk7XG4gIHZhciBzb3VyY2VCb3R0b21SaWdodCA9IHRoaXMudHJhbnNmb3JtSW52XyhkZXN0aW5hdGlvbkJvdHRvbVJpZ2h0KTtcbiAgdmFyIHNvdXJjZUJvdHRvbUxlZnQgPSB0aGlzLnRyYW5zZm9ybUludl8oZGVzdGluYXRpb25Cb3R0b21MZWZ0KTtcblxuICB0aGlzLmFkZFF1YWRfKFxuICAgIGRlc3RpbmF0aW9uVG9wTGVmdCwgZGVzdGluYXRpb25Ub3BSaWdodCxcbiAgICBkZXN0aW5hdGlvbkJvdHRvbVJpZ2h0LCBkZXN0aW5hdGlvbkJvdHRvbUxlZnQsXG4gICAgc291cmNlVG9wTGVmdCwgc291cmNlVG9wUmlnaHQsIHNvdXJjZUJvdHRvbVJpZ2h0LCBzb3VyY2VCb3R0b21MZWZ0LFxuICAgIE1BWF9TVUJESVZJU0lPTik7XG5cbiAgaWYgKHRoaXMud3JhcHNYSW5Tb3VyY2VfKSB7XG4gICAgdmFyIGxlZnRCb3VuZCA9IEluZmluaXR5O1xuICAgIHRoaXMudHJpYW5nbGVzXy5mb3JFYWNoKGZ1bmN0aW9uKHRyaWFuZ2xlLCBpLCBhcnIpIHtcbiAgICAgIGxlZnRCb3VuZCA9IE1hdGgubWluKGxlZnRCb3VuZCxcbiAgICAgICAgdHJpYW5nbGUuc291cmNlWzBdWzBdLCB0cmlhbmdsZS5zb3VyY2VbMV1bMF0sIHRyaWFuZ2xlLnNvdXJjZVsyXVswXSk7XG4gICAgfSk7XG5cbiAgICAvLyBTaGlmdCB0cmlhbmdsZXMgdG8gYmUgYXMgY2xvc2UgdG8gYGxlZnRCb3VuZGAgYXMgcG9zc2libGVcbiAgICAvLyAoaWYgdGhlIGRpc3RhbmNlIGlzIG1vcmUgdGhhbiBgd29ybGRXaWR0aCAvIDJgIGl0IGNhbiBiZSBjbG9zZXIuXG4gICAgdGhpcy50cmlhbmdsZXNfLmZvckVhY2goZnVuY3Rpb24odHJpYW5nbGUpIHtcbiAgICAgIGlmIChNYXRoLm1heCh0cmlhbmdsZS5zb3VyY2VbMF1bMF0sIHRyaWFuZ2xlLnNvdXJjZVsxXVswXSxcbiAgICAgICAgdHJpYW5nbGUuc291cmNlWzJdWzBdKSAtIGxlZnRCb3VuZCA+IHRoaXMuc291cmNlV29ybGRXaWR0aF8gLyAyKSB7XG4gICAgICAgIHZhciBuZXdUcmlhbmdsZSA9IFtbdHJpYW5nbGUuc291cmNlWzBdWzBdLCB0cmlhbmdsZS5zb3VyY2VbMF1bMV1dLFxuICAgICAgICAgIFt0cmlhbmdsZS5zb3VyY2VbMV1bMF0sIHRyaWFuZ2xlLnNvdXJjZVsxXVsxXV0sXG4gICAgICAgICAgW3RyaWFuZ2xlLnNvdXJjZVsyXVswXSwgdHJpYW5nbGUuc291cmNlWzJdWzFdXV07XG4gICAgICAgIGlmICgobmV3VHJpYW5nbGVbMF1bMF0gLSBsZWZ0Qm91bmQpID4gdGhpcy5zb3VyY2VXb3JsZFdpZHRoXyAvIDIpIHtcbiAgICAgICAgICBuZXdUcmlhbmdsZVswXVswXSAtPSB0aGlzLnNvdXJjZVdvcmxkV2lkdGhfO1xuICAgICAgICB9XG4gICAgICAgIGlmICgobmV3VHJpYW5nbGVbMV1bMF0gLSBsZWZ0Qm91bmQpID4gdGhpcy5zb3VyY2VXb3JsZFdpZHRoXyAvIDIpIHtcbiAgICAgICAgICBuZXdUcmlhbmdsZVsxXVswXSAtPSB0aGlzLnNvdXJjZVdvcmxkV2lkdGhfO1xuICAgICAgICB9XG4gICAgICAgIGlmICgobmV3VHJpYW5nbGVbMl1bMF0gLSBsZWZ0Qm91bmQpID4gdGhpcy5zb3VyY2VXb3JsZFdpZHRoXyAvIDIpIHtcbiAgICAgICAgICBuZXdUcmlhbmdsZVsyXVswXSAtPSB0aGlzLnNvdXJjZVdvcmxkV2lkdGhfO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmFyZWx5IChpZiB0aGUgZXh0ZW50IGNvbnRhaW5zIGJvdGggdGhlIGRhdGVsaW5lIGFuZCBwcmltZSBtZXJpZGlhbilcbiAgICAgICAgLy8gdGhlIHNoaWZ0IGNhbiBpbiB0dXJuIGJyZWFrIHNvbWUgdHJpYW5nbGVzLlxuICAgICAgICAvLyBEZXRlY3QgdGhpcyBoZXJlIGFuZCBkb24ndCBzaGlmdCBpbiBzdWNoIGNhc2VzLlxuICAgICAgICB2YXIgbWluWCA9IE1hdGgubWluKFxuICAgICAgICAgIG5ld1RyaWFuZ2xlWzBdWzBdLCBuZXdUcmlhbmdsZVsxXVswXSwgbmV3VHJpYW5nbGVbMl1bMF0pO1xuICAgICAgICB2YXIgbWF4WCA9IE1hdGgubWF4KFxuICAgICAgICAgIG5ld1RyaWFuZ2xlWzBdWzBdLCBuZXdUcmlhbmdsZVsxXVswXSwgbmV3VHJpYW5nbGVbMl1bMF0pO1xuICAgICAgICBpZiAoKG1heFggLSBtaW5YKSA8IHRoaXMuc291cmNlV29ybGRXaWR0aF8gLyAyKSB7XG4gICAgICAgICAgdHJpYW5nbGUuc291cmNlID0gbmV3VHJpYW5nbGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LmJpbmQodGhpcykpO1xuICB9XG5cbiAgdHJhbnNmb3JtSW52Q2FjaGUgPSB7fTtcbn07XG5cbi8qKlxuICogQWRkcyB0cmlhbmdsZSB0byB0aGUgdHJpYW5ndWxhdGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBhIFRoZSB0YXJnZXQgYSBjb29yZGluYXRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGIgVGhlIHRhcmdldCBiIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gYyBUaGUgdGFyZ2V0IGMgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBhU3JjIFRoZSBzb3VyY2UgYSBjb29yZGluYXRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGJTcmMgVGhlIHNvdXJjZSBiIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY1NyYyBUaGUgc291cmNlIGMgY29vcmRpbmF0ZS5cbiAqIEBwcml2YXRlXG4gKi9cblRyaWFuZ3VsYXRpb24ucHJvdG90eXBlLmFkZFRyaWFuZ2xlXyA9IGZ1bmN0aW9uIGFkZFRyaWFuZ2xlXyAoYSwgYiwgYywgYVNyYywgYlNyYywgY1NyYykge1xuICB0aGlzLnRyaWFuZ2xlc18ucHVzaCh7XG4gICAgc291cmNlOiBbYVNyYywgYlNyYywgY1NyY10sXG4gICAgdGFyZ2V0OiBbYSwgYiwgY11cbiAgfSk7XG59O1xuXG4vKipcbiAqIEFkZHMgcXVhZCAocG9pbnRzIGluIGNsb2NrLXdpc2Ugb3JkZXIpIHRvIHRoZSB0cmlhbmd1bGF0aW9uXG4gKiAoYW5kIHJlcHJvamVjdHMgdGhlIHZlcnRpY2VzKSBpZiB2YWxpZC5cbiAqIFBlcmZvcm1zIHF1YWQgc3ViZGl2aXNpb24gaWYgbmVlZGVkIHRvIGluY3JlYXNlIHByZWNpc2lvbi5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gYSBUaGUgdGFyZ2V0IGEgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBiIFRoZSB0YXJnZXQgYiBjb29yZGluYXRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGMgVGhlIHRhcmdldCBjIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gZCBUaGUgdGFyZ2V0IGQgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBhU3JjIFRoZSBzb3VyY2UgYSBjb29yZGluYXRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGJTcmMgVGhlIHNvdXJjZSBiIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY1NyYyBUaGUgc291cmNlIGMgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBkU3JjIFRoZSBzb3VyY2UgZCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heFN1YmRpdmlzaW9uIE1heGltYWwgYWxsb3dlZCBzdWJkaXZpc2lvbiBvZiB0aGUgcXVhZC5cbiAqIEBwcml2YXRlXG4gKi9cblRyaWFuZ3VsYXRpb24ucHJvdG90eXBlLmFkZFF1YWRfID0gZnVuY3Rpb24gYWRkUXVhZF8gKGEsIGIsIGMsIGQsIGFTcmMsIGJTcmMsIGNTcmMsIGRTcmMsIG1heFN1YmRpdmlzaW9uKSB7XG5cbiAgdmFyIHNvdXJjZVF1YWRFeHRlbnQgPSBib3VuZGluZ0V4dGVudChbYVNyYywgYlNyYywgY1NyYywgZFNyY10pO1xuICB2YXIgc291cmNlQ292ZXJhZ2VYID0gdGhpcy5zb3VyY2VXb3JsZFdpZHRoXyA/XG4gICAgZ2V0V2lkdGgoc291cmNlUXVhZEV4dGVudCkgLyB0aGlzLnNvdXJjZVdvcmxkV2lkdGhfIDogbnVsbDtcbiAgdmFyIHNvdXJjZVdvcmxkV2lkdGggPSAvKiogQHR5cGUge251bWJlcn0gKi8gKHRoaXMuc291cmNlV29ybGRXaWR0aF8pO1xuXG4gIC8vIHdoZW4gdGhlIHF1YWQgaXMgd3JhcHBlZCBpbiB0aGUgc291cmNlIHByb2plY3Rpb25cbiAgLy8gaXQgY292ZXJzIG1vc3Qgb2YgdGhlIHByb2plY3Rpb24gZXh0ZW50LCBidXQgbm90IGZ1bGx5XG4gIHZhciB3cmFwc1ggPSB0aGlzLnNvdXJjZVByb2pfLmNhbldyYXBYKCkgJiZcbiAgICAgICAgICAgICAgIHNvdXJjZUNvdmVyYWdlWCA+IDAuNSAmJiBzb3VyY2VDb3ZlcmFnZVggPCAxO1xuXG4gIHZhciBuZWVkc1N1YmRpdmlzaW9uID0gZmFsc2U7XG5cbiAgaWYgKG1heFN1YmRpdmlzaW9uID4gMCkge1xuICAgIGlmICh0aGlzLnRhcmdldFByb2pfLmlzR2xvYmFsKCkgJiYgdGhpcy50YXJnZXRXb3JsZFdpZHRoXykge1xuICAgICAgdmFyIHRhcmdldFF1YWRFeHRlbnQgPSBib3VuZGluZ0V4dGVudChbYSwgYiwgYywgZF0pO1xuICAgICAgdmFyIHRhcmdldENvdmVyYWdlWCA9IGdldFdpZHRoKHRhcmdldFF1YWRFeHRlbnQpIC8gdGhpcy50YXJnZXRXb3JsZFdpZHRoXztcbiAgICAgIG5lZWRzU3ViZGl2aXNpb24gPSB0YXJnZXRDb3ZlcmFnZVggPiBNQVhfVFJJQU5HTEVfV0lEVEggfHxcbiAgICAgICAgbmVlZHNTdWJkaXZpc2lvbjtcbiAgICB9XG4gICAgaWYgKCF3cmFwc1ggJiYgdGhpcy5zb3VyY2VQcm9qXy5pc0dsb2JhbCgpICYmIHNvdXJjZUNvdmVyYWdlWCkge1xuICAgICAgbmVlZHNTdWJkaXZpc2lvbiA9IHNvdXJjZUNvdmVyYWdlWCA+IE1BWF9UUklBTkdMRV9XSURUSCB8fFxuICAgICAgICAgIG5lZWRzU3ViZGl2aXNpb247XG4gICAgfVxuICB9XG5cbiAgaWYgKCFuZWVkc1N1YmRpdmlzaW9uICYmIHRoaXMubWF4U291cmNlRXh0ZW50Xykge1xuICAgIGlmICghaW50ZXJzZWN0cyhzb3VyY2VRdWFkRXh0ZW50LCB0aGlzLm1heFNvdXJjZUV4dGVudF8pKSB7XG4gICAgICAvLyB3aG9sZSBxdWFkIG91dHNpZGUgc291cmNlIHByb2plY3Rpb24gZXh0ZW50IC0+IGlnbm9yZVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmICghbmVlZHNTdWJkaXZpc2lvbikge1xuICAgIGlmICghaXNGaW5pdGUoYVNyY1swXSkgfHwgIWlzRmluaXRlKGFTcmNbMV0pIHx8XG4gICAgICAgICFpc0Zpbml0ZShiU3JjWzBdKSB8fCAhaXNGaW5pdGUoYlNyY1sxXSkgfHxcbiAgICAgICAgIWlzRmluaXRlKGNTcmNbMF0pIHx8ICFpc0Zpbml0ZShjU3JjWzFdKSB8fFxuICAgICAgICAhaXNGaW5pdGUoZFNyY1swXSkgfHwgIWlzRmluaXRlKGRTcmNbMV0pKSB7XG4gICAgICBpZiAobWF4U3ViZGl2aXNpb24gPiAwKSB7XG4gICAgICAgIG5lZWRzU3ViZGl2aXNpb24gPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChtYXhTdWJkaXZpc2lvbiA+IDApIHtcbiAgICBpZiAoIW5lZWRzU3ViZGl2aXNpb24pIHtcbiAgICAgIHZhciBjZW50ZXIgPSBbKGFbMF0gKyBjWzBdKSAvIDIsIChhWzFdICsgY1sxXSkgLyAyXTtcbiAgICAgIHZhciBjZW50ZXJTcmMgPSB0aGlzLnRyYW5zZm9ybUludl8oY2VudGVyKTtcblxuICAgICAgdmFyIGR4O1xuICAgICAgaWYgKHdyYXBzWCkge1xuICAgICAgICB2YXIgY2VudGVyU3JjRXN0aW1YID1cbiAgICAgICAgICAgIChtb2R1bG8oYVNyY1swXSwgc291cmNlV29ybGRXaWR0aCkgK1xuICAgICAgICAgICAgIG1vZHVsbyhjU3JjWzBdLCBzb3VyY2VXb3JsZFdpZHRoKSkgLyAyO1xuICAgICAgICBkeCA9IGNlbnRlclNyY0VzdGltWCAtXG4gICAgICAgICAgICBtb2R1bG8oY2VudGVyU3JjWzBdLCBzb3VyY2VXb3JsZFdpZHRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGR4ID0gKGFTcmNbMF0gKyBjU3JjWzBdKSAvIDIgLSBjZW50ZXJTcmNbMF07XG4gICAgICB9XG4gICAgICB2YXIgZHkgPSAoYVNyY1sxXSArIGNTcmNbMV0pIC8gMiAtIGNlbnRlclNyY1sxXTtcbiAgICAgIHZhciBjZW50ZXJTcmNFcnJvclNxdWFyZWQgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgIG5lZWRzU3ViZGl2aXNpb24gPSBjZW50ZXJTcmNFcnJvclNxdWFyZWQgPiB0aGlzLmVycm9yVGhyZXNob2xkU3F1YXJlZF87XG4gICAgfVxuICAgIGlmIChuZWVkc1N1YmRpdmlzaW9uKSB7XG4gICAgICBpZiAoTWF0aC5hYnMoYVswXSAtIGNbMF0pIDw9IE1hdGguYWJzKGFbMV0gLSBjWzFdKSkge1xuICAgICAgICAvLyBzcGxpdCBob3Jpem9udGFsbHkgKHRvcCAmIGJvdHRvbSlcbiAgICAgICAgdmFyIGJjID0gWyhiWzBdICsgY1swXSkgLyAyLCAoYlsxXSArIGNbMV0pIC8gMl07XG4gICAgICAgIHZhciBiY1NyYyA9IHRoaXMudHJhbnNmb3JtSW52XyhiYyk7XG4gICAgICAgIHZhciBkYSA9IFsoZFswXSArIGFbMF0pIC8gMiwgKGRbMV0gKyBhWzFdKSAvIDJdO1xuICAgICAgICB2YXIgZGFTcmMgPSB0aGlzLnRyYW5zZm9ybUludl8oZGEpO1xuXG4gICAgICAgIHRoaXMuYWRkUXVhZF8oXG4gICAgICAgICAgYSwgYiwgYmMsIGRhLCBhU3JjLCBiU3JjLCBiY1NyYywgZGFTcmMsIG1heFN1YmRpdmlzaW9uIC0gMSk7XG4gICAgICAgIHRoaXMuYWRkUXVhZF8oXG4gICAgICAgICAgZGEsIGJjLCBjLCBkLCBkYVNyYywgYmNTcmMsIGNTcmMsIGRTcmMsIG1heFN1YmRpdmlzaW9uIC0gMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzcGxpdCB2ZXJ0aWNhbGx5IChsZWZ0ICYgcmlnaHQpXG4gICAgICAgIHZhciBhYiA9IFsoYVswXSArIGJbMF0pIC8gMiwgKGFbMV0gKyBiWzFdKSAvIDJdO1xuICAgICAgICB2YXIgYWJTcmMgPSB0aGlzLnRyYW5zZm9ybUludl8oYWIpO1xuICAgICAgICB2YXIgY2QgPSBbKGNbMF0gKyBkWzBdKSAvIDIsIChjWzFdICsgZFsxXSkgLyAyXTtcbiAgICAgICAgdmFyIGNkU3JjID0gdGhpcy50cmFuc2Zvcm1JbnZfKGNkKTtcblxuICAgICAgICB0aGlzLmFkZFF1YWRfKFxuICAgICAgICAgIGEsIGFiLCBjZCwgZCwgYVNyYywgYWJTcmMsIGNkU3JjLCBkU3JjLCBtYXhTdWJkaXZpc2lvbiAtIDEpO1xuICAgICAgICB0aGlzLmFkZFF1YWRfKFxuICAgICAgICAgIGFiLCBiLCBjLCBjZCwgYWJTcmMsIGJTcmMsIGNTcmMsIGNkU3JjLCBtYXhTdWJkaXZpc2lvbiAtIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmICh3cmFwc1gpIHtcbiAgICBpZiAoIXRoaXMuY2FuV3JhcFhJblNvdXJjZV8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy53cmFwc1hJblNvdXJjZV8gPSB0cnVlO1xuICB9XG5cbiAgdGhpcy5hZGRUcmlhbmdsZV8oYSwgYywgZCwgYVNyYywgY1NyYywgZFNyYyk7XG4gIHRoaXMuYWRkVHJpYW5nbGVfKGEsIGIsIGMsIGFTcmMsIGJTcmMsIGNTcmMpO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIGV4dGVudCBvZiB0aGUgJ3NvdXJjZScgY29vcmRpbmF0ZXMgZnJvbSBhbGwgdGhlIHRyaWFuZ2xlcy5cbiAqXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBDYWxjdWxhdGVkIGV4dGVudC5cbiAqL1xuVHJpYW5ndWxhdGlvbi5wcm90b3R5cGUuY2FsY3VsYXRlU291cmNlRXh0ZW50ID0gZnVuY3Rpb24gY2FsY3VsYXRlU291cmNlRXh0ZW50ICgpIHtcbiAgdmFyIGV4dGVudCA9IGNyZWF0ZUVtcHR5KCk7XG5cbiAgdGhpcy50cmlhbmdsZXNfLmZvckVhY2goZnVuY3Rpb24odHJpYW5nbGUsIGksIGFycikge1xuICAgIHZhciBzcmMgPSB0cmlhbmdsZS5zb3VyY2U7XG4gICAgZXh0ZW5kQ29vcmRpbmF0ZShleHRlbnQsIHNyY1swXSk7XG4gICAgZXh0ZW5kQ29vcmRpbmF0ZShleHRlbnQsIHNyY1sxXSk7XG4gICAgZXh0ZW5kQ29vcmRpbmF0ZShleHRlbnQsIHNyY1syXSk7XG4gIH0pO1xuXG4gIHJldHVybiBleHRlbnQ7XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge0FycmF5PFRyaWFuZ2xlPn0gQXJyYXkgb2YgdGhlIGNhbGN1bGF0ZWQgdHJpYW5nbGVzLlxuICovXG5Ucmlhbmd1bGF0aW9uLnByb3RvdHlwZS5nZXRUcmlhbmdsZXMgPSBmdW5jdGlvbiBnZXRUcmlhbmdsZXMgKCkge1xuICByZXR1cm4gdGhpcy50cmlhbmdsZXNfO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgVHJpYW5ndWxhdGlvbjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VHJpYW5ndWxhdGlvbi5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVwcm9qL2NvbW1vblxuICovXG5cbi8qKlxuICogRGVmYXVsdCBtYXhpbXVtIGFsbG93ZWQgdGhyZXNob2xkICAoaW4gcGl4ZWxzKSBmb3IgcmVwcm9qZWN0aW9uXG4gKiB0cmlhbmd1bGF0aW9uLlxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBFUlJPUl9USFJFU0hPTEQgPSAwLjU7XG5cbi8qKlxuICogRW5hYmxlIGF1dG9tYXRpYyByZXByb2plY3Rpb24gb2YgcmFzdGVyIHNvdXJjZXMuIERlZmF1bHQgaXMgYHRydWVgLlxuICogVE9ETzogZGVjaWRlIGlmIHdlIHdhbnQgdG8gZXhwb3NlIHRoaXMgYXMgYSBidWlsZCBmbGFnIG9yIHJlbW92ZSBpdFxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCB2YXIgRU5BQkxFX1JBU1RFUl9SRVBST0pFQ1RJT04gPSB0cnVlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tb24uanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3Jlc29sdXRpb25jb25zdHJhaW50XG4gKi9cbmltcG9ydCB7bGluZWFyRmluZE5lYXJlc3R9IGZyb20gJy4vYXJyYXkuanMnO1xuaW1wb3J0IHtjbGFtcH0gZnJvbSAnLi9tYXRoLmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbigobnVtYmVyfHVuZGVmaW5lZCksIG51bWJlciwgbnVtYmVyKTogKG51bWJlcnx1bmRlZmluZWQpfSBUeXBlXG4gKi9cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gcmVzb2x1dGlvbnMgUmVzb2x1dGlvbnMuXG4gKiBAcmV0dXJuIHtUeXBlfSBab29tIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU25hcFRvUmVzb2x1dGlvbnMocmVzb2x1dGlvbnMpIHtcbiAgcmV0dXJuIChcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGEgRGVsdGEuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpcmVjdGlvbiBEaXJlY3Rpb24uXG4gICAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gUmVzb2x1dGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbihyZXNvbHV0aW9uLCBkZWx0YSwgZGlyZWN0aW9uKSB7XG4gICAgICBpZiAocmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciB6ID0gbGluZWFyRmluZE5lYXJlc3QocmVzb2x1dGlvbnMsIHJlc29sdXRpb24sIGRpcmVjdGlvbik7XG4gICAgICAgIHogPSBjbGFtcCh6ICsgZGVsdGEsIDAsIHJlc29sdXRpb25zLmxlbmd0aCAtIDEpO1xuICAgICAgICB2YXIgaW5kZXggPSBNYXRoLmZsb29yKHopO1xuICAgICAgICBpZiAoeiAhPSBpbmRleCAmJiBpbmRleCA8IHJlc29sdXRpb25zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICB2YXIgcG93ZXIgPSByZXNvbHV0aW9uc1tpbmRleF0gLyByZXNvbHV0aW9uc1tpbmRleCArIDFdO1xuICAgICAgICAgIHJldHVybiByZXNvbHV0aW9uc1tpbmRleF0gLyBNYXRoLnBvdyhwb3dlciwgeiAtIGluZGV4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x1dGlvbnNbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3dlciBQb3dlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhSZXNvbHV0aW9uIE1heGltdW0gcmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X21heExldmVsIE1heGltdW0gbGV2ZWwuXG4gKiBAcmV0dXJuIHtUeXBlfSBab29tIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU25hcFRvUG93ZXIocG93ZXIsIG1heFJlc29sdXRpb24sIG9wdF9tYXhMZXZlbCkge1xuICByZXR1cm4gKFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YSBEZWx0YS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGlyZWN0aW9uIERpcmVjdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBSZXNvbHV0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uKHJlc29sdXRpb24sIGRlbHRhLCBkaXJlY3Rpb24pIHtcbiAgICAgIGlmIChyZXNvbHV0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IC1kaXJlY3Rpb24gLyAyICsgMC41O1xuICAgICAgICB2YXIgb2xkTGV2ZWwgPSBNYXRoLmZsb29yKFxuICAgICAgICAgIE1hdGgubG9nKG1heFJlc29sdXRpb24gLyByZXNvbHV0aW9uKSAvIE1hdGgubG9nKHBvd2VyKSArIG9mZnNldCk7XG4gICAgICAgIHZhciBuZXdMZXZlbCA9IE1hdGgubWF4KG9sZExldmVsICsgZGVsdGEsIDApO1xuICAgICAgICBpZiAob3B0X21heExldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBuZXdMZXZlbCA9IE1hdGgubWluKG5ld0xldmVsLCBvcHRfbWF4TGV2ZWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXhSZXNvbHV0aW9uIC8gTWF0aC5wb3cocG93ZXIsIG5ld0xldmVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdXRpb25jb25zdHJhaW50LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9yb3RhdGlvbmNvbnN0cmFpbnRcbiAqL1xuaW1wb3J0IHt0b1JhZGlhbnN9IGZyb20gJy4vbWF0aC5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oKG51bWJlcnx1bmRlZmluZWQpLCBudW1iZXIpOiAobnVtYmVyfHVuZGVmaW5lZCl9IFR5cGVcbiAqL1xuXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YSBEZWx0YS5cbiAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFJvdGF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlzYWJsZShyb3RhdGlvbiwgZGVsdGEpIHtcbiAgaWYgKHJvdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhIERlbHRhLlxuICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gUm90YXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub25lKHJvdGF0aW9uLCBkZWx0YSkge1xuICBpZiAocm90YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiByb3RhdGlvbiArIGRlbHRhO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIE4uXG4gKiBAcmV0dXJuIHtUeXBlfSBSb3RhdGlvbiBjb25zdHJhaW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU25hcFRvTihuKSB7XG4gIHZhciB0aGV0YSA9IDIgKiBNYXRoLlBJIC8gbjtcbiAgcmV0dXJuIChcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YSBEZWx0YS5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBSb3RhdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbihyb3RhdGlvbiwgZGVsdGEpIHtcbiAgICAgIGlmIChyb3RhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJvdGF0aW9uID0gTWF0aC5mbG9vcigocm90YXRpb24gKyBkZWx0YSkgLyB0aGV0YSArIDAuNSkgKiB0aGV0YTtcbiAgICAgICAgcmV0dXJuIHJvdGF0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9KTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X3RvbGVyYW5jZSBUb2xlcmFuY2UuXG4gKiBAcmV0dXJuIHtUeXBlfSBSb3RhdGlvbiBjb25zdHJhaW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU25hcFRvWmVybyhvcHRfdG9sZXJhbmNlKSB7XG4gIHZhciB0b2xlcmFuY2UgPSBvcHRfdG9sZXJhbmNlIHx8IHRvUmFkaWFucyg1KTtcbiAgcmV0dXJuIChcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YSBEZWx0YS5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBSb3RhdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbihyb3RhdGlvbiwgZGVsdGEpIHtcbiAgICAgIGlmIChyb3RhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChNYXRoLmFicyhyb3RhdGlvbiArIGRlbHRhKSA8PSB0b2xlcmFuY2UpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcm90YXRpb24gKyBkZWx0YTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9KTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm90YXRpb25jb25zdHJhaW50LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9zaXplXG4gKi9cblxuXG4vKipcbiAqIEFuIGFycmF5IG9mIG51bWJlcnMgcmVwcmVzZW50aW5nIGEgc2l6ZTogYFt3aWR0aCwgaGVpZ2h0XWAuXG4gKiBAdHlwZWRlZiB7QXJyYXk8bnVtYmVyPn0gU2l6ZVxuICogQGFwaVxuICovXG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgYnVmZmVyZWQgc2l6ZS5cbiAqIEBwYXJhbSB7U2l6ZX0gc2l6ZSBTaXplLlxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgYW1vdW50IGJ5IHdoaWNoIHRvIGJ1ZmZlci5cbiAqIEBwYXJhbSB7U2l6ZT19IG9wdF9zaXplIE9wdGlvbmFsIHJldXNhYmxlIHNpemUgYXJyYXkuXG4gKiBAcmV0dXJuIHtTaXplfSBUaGUgYnVmZmVyZWQgc2l6ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1ZmZlcihzaXplLCBudW0sIG9wdF9zaXplKSB7XG4gIGlmIChvcHRfc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0X3NpemUgPSBbMCwgMF07XG4gIH1cbiAgb3B0X3NpemVbMF0gPSBzaXplWzBdICsgMiAqIG51bTtcbiAgb3B0X3NpemVbMV0gPSBzaXplWzFdICsgMiAqIG51bTtcbiAgcmV0dXJuIG9wdF9zaXplO1xufVxuXG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIHNpemUgaGFzIGEgcG9zaXRpdmUgYXJlYS5cbiAqIEBwYXJhbSB7U2l6ZX0gc2l6ZSBUaGUgc2l6ZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHNpemUgaGFzIGEgcG9zaXRpdmUgYXJlYS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc0FyZWEoc2l6ZSkge1xuICByZXR1cm4gc2l6ZVswXSA+IDAgJiYgc2l6ZVsxXSA+IDA7XG59XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgc2l6ZSBzY2FsZWQgYnkgYSByYXRpby4gVGhlIHJlc3VsdCB3aWxsIGJlIGFuIGFycmF5IG9mIGludGVnZXJzLlxuICogQHBhcmFtIHtTaXplfSBzaXplIFNpemUuXG4gKiBAcGFyYW0ge251bWJlcn0gcmF0aW8gUmF0aW8uXG4gKiBAcGFyYW0ge1NpemU9fSBvcHRfc2l6ZSBPcHRpb25hbCByZXVzYWJsZSBzaXplIGFycmF5LlxuICogQHJldHVybiB7U2l6ZX0gVGhlIHNjYWxlZCBzaXplLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUoc2l6ZSwgcmF0aW8sIG9wdF9zaXplKSB7XG4gIGlmIChvcHRfc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0X3NpemUgPSBbMCwgMF07XG4gIH1cbiAgb3B0X3NpemVbMF0gPSAoc2l6ZVswXSAqIHJhdGlvICsgMC41KSB8IDA7XG4gIG9wdF9zaXplWzFdID0gKHNpemVbMV0gKiByYXRpbyArIDAuNSkgfCAwO1xuICByZXR1cm4gb3B0X3NpemU7XG59XG5cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGBTaXplYCBhcnJheSBmb3IgdGhlIHBhc3NlZCBpbiBudW1iZXIgKG1lYW5pbmc6IHNxdWFyZSkgb3JcbiAqIGBTaXplYCBhcnJheS5cbiAqIChtZWFuaW5nOiBub24tc3F1YXJlKSxcbiAqIEBwYXJhbSB7bnVtYmVyfFNpemV9IHNpemUgV2lkdGggYW5kIGhlaWdodC5cbiAqIEBwYXJhbSB7U2l6ZT19IG9wdF9zaXplIE9wdGlvbmFsIHJldXNhYmxlIHNpemUgYXJyYXkuXG4gKiBAcmV0dXJuIHtTaXplfSBTaXplLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9TaXplKHNpemUsIG9wdF9zaXplKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHNpemUpKSB7XG4gICAgcmV0dXJuIHNpemU7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG9wdF9zaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdF9zaXplID0gW3NpemUsIHNpemVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRfc2l6ZVswXSA9IG9wdF9zaXplWzFdID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChzaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdF9zaXplO1xuICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpemUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3NvdXJjZS9PU01cbiAqL1xuXG5pbXBvcnQgWFlaIGZyb20gJy4vWFlaLmpzJztcblxuXG4vKipcbiAqIFRoZSBhdHRyaWJ1dGlvbiBjb250YWluaW5nIGEgbGluayB0byB0aGUgT3BlblN0cmVldE1hcCBDb3B5cmlnaHQgYW5kIExpY2Vuc2VcbiAqIHBhZ2UuXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAYXBpXG4gKi9cbmV4cG9ydCB2YXIgQVRUUklCVVRJT04gPSAnJiMxNjk7ICcgK1xuICAgICAgJzxhIGhyZWY9XCJodHRwczovL3d3dy5vcGVuc3RyZWV0bWFwLm9yZy9jb3B5cmlnaHRcIj5PcGVuU3RyZWV0TWFwPC9hPiAnICtcbiAgICAgICdjb250cmlidXRvcnMuJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9Tb3VyY2UuanNcIikuQXR0cmlidXRpb25MaWtlfSBbYXR0cmlidXRpb25zXSBBdHRyaWJ1dGlvbnMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2NhY2hlU2l6ZT0yMDQ4XSBDYWNoZSBzaXplLlxuICogQHByb3BlcnR5IHtudWxsfHN0cmluZ30gW2Nyb3NzT3JpZ2luXSBUaGUgYGNyb3NzT3JpZ2luYCBhdHRyaWJ1dGUgZm9yIGxvYWRlZCBpbWFnZXMuICBOb3RlIHRoYXRcbiAqIHlvdSBtdXN0IHByb3ZpZGUgYSBgY3Jvc3NPcmlnaW5gIHZhbHVlIGlmIHlvdSBhcmUgdXNpbmcgdGhlIFdlYkdMIHJlbmRlcmVyIG9yIGlmIHlvdSB3YW50IHRvXG4gKiBhY2Nlc3MgcGl4ZWwgZGF0YSB3aXRoIHRoZSBDYW52YXMgcmVuZGVyZXIuICBTZWVcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQ09SU19lbmFibGVkX2ltYWdlIGZvciBtb3JlIGRldGFpbC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4Wm9vbT0xOV0gTWF4IHpvb20uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtvcGFxdWU9dHJ1ZV0gV2hldGhlciB0aGUgbGF5ZXIgaXMgb3BhcXVlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyZXByb2plY3Rpb25FcnJvclRocmVzaG9sZD0xLjVdIE1heGltdW0gYWxsb3dlZCByZXByb2plY3Rpb24gZXJyb3IgKGluIHBpeGVscykuXG4gKiBIaWdoZXIgdmFsdWVzIGNhbiBpbmNyZWFzZSByZXByb2plY3Rpb24gcGVyZm9ybWFuY2UsIGJ1dCBkZWNyZWFzZSBwcmVjaXNpb24uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL1RpbGUuanNcIikuTG9hZEZ1bmN0aW9ufSBbdGlsZUxvYWRGdW5jdGlvbl0gT3B0aW9uYWwgZnVuY3Rpb24gdG8gbG9hZCBhIHRpbGUgZ2l2ZW4gYSBVUkwuIFRoZSBkZWZhdWx0IGlzXG4gKiBgYGBqc1xuICogZnVuY3Rpb24oaW1hZ2VUaWxlLCBzcmMpIHtcbiAqICAgaW1hZ2VUaWxlLmdldEltYWdlKCkuc3JjID0gc3JjO1xuICogfTtcbiAqIGBgYFxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt1cmw9J2h0dHBzOi8ve2EtY30udGlsZS5vcGVuc3RyZWV0bWFwLm9yZy97en0ve3h9L3t5fS5wbmcnXSBVUkwgdGVtcGxhdGUuXG4gKiBNdXN0IGluY2x1ZGUgYHt4fWAsIGB7eX1gIG9yIGB7LXl9YCwgYW5kIGB7en1gIHBsYWNlaG9sZGVycy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3dyYXBYPXRydWVdIFdoZXRoZXIgdG8gd3JhcCB0aGUgd29ybGQgaG9yaXpvbnRhbGx5LlxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBMYXllciBzb3VyY2UgZm9yIHRoZSBPcGVuU3RyZWV0TWFwIHRpbGUgc2VydmVyLlxuICogQGFwaVxuICovXG52YXIgT1NNID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoWFlaKSB7XG4gIGZ1bmN0aW9uIE9TTShvcHRfb3B0aW9ucykge1xuXG4gICAgdmFyIG9wdGlvbnMgPSBvcHRfb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciBhdHRyaWJ1dGlvbnM7XG4gICAgaWYgKG9wdGlvbnMuYXR0cmlidXRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGF0dHJpYnV0aW9ucyA9IG9wdGlvbnMuYXR0cmlidXRpb25zO1xuICAgIH0gZWxzZSB7XG4gICAgICBhdHRyaWJ1dGlvbnMgPSBbQVRUUklCVVRJT05dO1xuICAgIH1cblxuICAgIHZhciBjcm9zc09yaWdpbiA9IG9wdGlvbnMuY3Jvc3NPcmlnaW4gIT09IHVuZGVmaW5lZCA/XG4gICAgICBvcHRpb25zLmNyb3NzT3JpZ2luIDogJ2Fub255bW91cyc7XG5cbiAgICB2YXIgdXJsID0gb3B0aW9ucy51cmwgIT09IHVuZGVmaW5lZCA/XG4gICAgICBvcHRpb25zLnVybCA6ICdodHRwczovL3thLWN9LnRpbGUub3BlbnN0cmVldG1hcC5vcmcve3p9L3t4fS97eX0ucG5nJztcblxuICAgIFhZWi5jYWxsKHRoaXMsIHtcbiAgICAgIGF0dHJpYnV0aW9uczogYXR0cmlidXRpb25zLFxuICAgICAgY2FjaGVTaXplOiBvcHRpb25zLmNhY2hlU2l6ZSxcbiAgICAgIGNyb3NzT3JpZ2luOiBjcm9zc09yaWdpbixcbiAgICAgIG9wYXF1ZTogb3B0aW9ucy5vcGFxdWUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMub3BhcXVlIDogdHJ1ZSxcbiAgICAgIG1heFpvb206IG9wdGlvbnMubWF4Wm9vbSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tYXhab29tIDogMTksXG4gICAgICByZXByb2plY3Rpb25FcnJvclRocmVzaG9sZDogb3B0aW9ucy5yZXByb2plY3Rpb25FcnJvclRocmVzaG9sZCxcbiAgICAgIHRpbGVMb2FkRnVuY3Rpb246IG9wdGlvbnMudGlsZUxvYWRGdW5jdGlvbixcbiAgICAgIHVybDogdXJsLFxuICAgICAgd3JhcFg6IG9wdGlvbnMud3JhcFgsXG4gICAgICBhdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZTogZmFsc2VcbiAgICB9KTtcblxuICB9XG5cbiAgaWYgKCBYWVogKSBPU00uX19wcm90b19fID0gWFlaO1xuICBPU00ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggWFlaICYmIFhZWi5wcm90b3R5cGUgKTtcbiAgT1NNLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE9TTTtcblxuICByZXR1cm4gT1NNO1xufShYWVopKTtcblxuZXhwb3J0IGRlZmF1bHQgT1NNO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1PU00uanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3NvdXJjZS9Tb3VyY2VcbiAqL1xuaW1wb3J0IHthYnN0cmFjdH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5pbXBvcnQgQmFzZU9iamVjdCBmcm9tICcuLi9PYmplY3QuanMnO1xuaW1wb3J0IHtnZXQgYXMgZ2V0UHJvamVjdGlvbn0gZnJvbSAnLi4vcHJvai5qcyc7XG5pbXBvcnQgU291cmNlU3RhdGUgZnJvbSAnLi9TdGF0ZS5qcyc7XG5cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHN0cmluZyBvciBhbiBhcnJheSBvZiBzdHJpbmdzIHJlcHJlc2VudGluZyBzb3VyY2VcbiAqIGF0dHJpYnV0aW9ucy5cbiAqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLkZyYW1lU3RhdGUpOiAoc3RyaW5nfEFycmF5PHN0cmluZz4pfSBBdHRyaWJ1dGlvblxuICovXG5cblxuLyoqXG4gKiBBIHR5cGUgdGhhdCBjYW4gYmUgdXNlZCB0byBwcm92aWRlIGF0dHJpYnV0aW9uIGluZm9ybWF0aW9uIGZvciBkYXRhIHNvdXJjZXMuXG4gKlxuICogSXQgcmVwcmVzZW50cyBlaXRoZXJcbiAqICogYSBzaW1wbGUgc3RyaW5nIChlLmcuIGAnwqkgQWNtZSBJbmMuJ2ApXG4gKiAqIGFuIGFycmF5IG9mIHNpbXBsZSBzdHJpbmdzIChlLmcuIGBbJ8KpIEFjbWUgSW5jLicsICfCqSBCYWNtZSBJbmMuJ11gKVxuICogKiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHN0cmluZyBvciBhcnJheSBvZiBzdHJpbmdzIChge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvU291cmNlfkF0dHJpYnV0aW9ufWApXG4gKlxuICogQHR5cGVkZWYge3N0cmluZ3xBcnJheTxzdHJpbmc+fEF0dHJpYnV0aW9ufSBBdHRyaWJ1dGlvbkxpa2VcbiAqL1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtBdHRyaWJ1dGlvbkxpa2V9IFthdHRyaWJ1dGlvbnNdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZT10cnVlXSBBdHRyaWJ1dGlvbnMgYXJlIGNvbGxhcHNpYmxlLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9wcm9qLmpzXCIpLlByb2plY3Rpb25MaWtlfSBwcm9qZWN0aW9uXG4gKiBAcHJvcGVydHkge1NvdXJjZVN0YXRlfSBbc3RhdGU9J3JlYWR5J11cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3dyYXBYPWZhbHNlXVxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzOyBub3JtYWxseSBvbmx5IHVzZWQgZm9yIGNyZWF0aW5nIHN1YmNsYXNzZXMgYW5kIG5vdFxuICogaW5zdGFudGlhdGVkIGluIGFwcHMuXG4gKiBCYXNlIGNsYXNzIGZvciB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL0xheWVyfkxheWVyfSBzb3VyY2VzLlxuICpcbiAqIEEgZ2VuZXJpYyBgY2hhbmdlYCBldmVudCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgc3RhdGUgb2YgdGhlIHNvdXJjZSBjaGFuZ2VzLlxuICogQGFic3RyYWN0XG4gKiBAYXBpXG4gKi9cbnZhciBTb3VyY2UgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChCYXNlT2JqZWN0KSB7XG4gIGZ1bmN0aW9uIFNvdXJjZShvcHRpb25zKSB7XG5cbiAgICBCYXNlT2JqZWN0LmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLnByb2plY3Rpb25fID0gZ2V0UHJvamVjdGlvbihvcHRpb25zLnByb2plY3Rpb24pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P0F0dHJpYnV0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuYXR0cmlidXRpb25zXyA9IGFkYXB0QXR0cmlidXRpb25zKG9wdGlvbnMuYXR0cmlidXRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5hdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZV8gPSBvcHRpb25zLmF0dHJpYnV0aW9uc0NvbGxhcHNpYmxlICE9PSB1bmRlZmluZWQgP1xuICAgICAgb3B0aW9ucy5hdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZSA6IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIHNvdXJjZSBpcyBjdXJyZW50bHkgbG9hZGluZyBkYXRhLiBTb3VyY2VzIHRoYXQgZGVmZXIgbG9hZGluZyB0byB0aGVcbiAgICAgKiBtYXAncyB0aWxlIHF1ZXVlIG5ldmVyIHNldCB0aGlzIHRvIGB0cnVlYC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge1NvdXJjZVN0YXRlfVxuICAgICAqL1xuICAgIHRoaXMuc3RhdGVfID0gb3B0aW9ucy5zdGF0ZSAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdGlvbnMuc3RhdGUgOiBTb3VyY2VTdGF0ZS5SRUFEWTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy53cmFwWF8gPSBvcHRpb25zLndyYXBYICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLndyYXBYIDogZmFsc2U7XG5cbiAgfVxuXG4gIGlmICggQmFzZU9iamVjdCApIFNvdXJjZS5fX3Byb3RvX18gPSBCYXNlT2JqZWN0O1xuICBTb3VyY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQmFzZU9iamVjdCAmJiBCYXNlT2JqZWN0LnByb3RvdHlwZSApO1xuICBTb3VyY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU291cmNlO1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGF0dHJpYnV0aW9uIGZ1bmN0aW9uIGZvciB0aGUgc291cmNlLlxuICAgKiBAcmV0dXJuIHs/QXR0cmlidXRpb259IEF0dHJpYnV0aW9uIGZ1bmN0aW9uLlxuICAgKi9cbiAgU291cmNlLnByb3RvdHlwZS5nZXRBdHRyaWJ1dGlvbnMgPSBmdW5jdGlvbiBnZXRBdHRyaWJ1dGlvbnMgKCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJpYnV0aW9uc187XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IEFhdHRyaWJ1dGlvbnMgYXJlIGNvbGxhcHNpYmxlLlxuICAgKi9cbiAgU291cmNlLnByb3RvdHlwZS5nZXRBdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZSA9IGZ1bmN0aW9uIGdldEF0dHJpYnV0aW9uc0NvbGxhcHNpYmxlICgpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZV87XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcHJvamVjdGlvbiBvZiB0aGUgc291cmNlLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gUHJvamVjdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgU291cmNlLnByb3RvdHlwZS5nZXRQcm9qZWN0aW9uID0gZnVuY3Rpb24gZ2V0UHJvamVjdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvamVjdGlvbl87XG4gIH07XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fHVuZGVmaW5lZH0gUmVzb2x1dGlvbnMuXG4gICAqL1xuICBTb3VyY2UucHJvdG90eXBlLmdldFJlc29sdXRpb25zID0gZnVuY3Rpb24gZ2V0UmVzb2x1dGlvbnMgKCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0YXRlIG9mIHRoZSBzb3VyY2UsIHNlZSB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9TdGF0ZX5TdGF0ZX0gZm9yIHBvc3NpYmxlIHN0YXRlcy5cbiAgICogQHJldHVybiB7U291cmNlU3RhdGV9IFN0YXRlLlxuICAgKiBAYXBpXG4gICAqL1xuICBTb3VyY2UucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24gZ2V0U3RhdGUgKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlXztcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbnx1bmRlZmluZWR9IFdyYXAgWC5cbiAgICovXG4gIFNvdXJjZS5wcm90b3R5cGUuZ2V0V3JhcFggPSBmdW5jdGlvbiBnZXRXcmFwWCAoKSB7XG4gICAgcmV0dXJuIHRoaXMud3JhcFhfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWZyZXNoZXMgdGhlIHNvdXJjZSBhbmQgZmluYWxseSBkaXNwYXRjaGVzIGEgJ2NoYW5nZScgZXZlbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIFNvdXJjZS5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uIHJlZnJlc2ggKCkge1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGF0dHJpYnV0aW9ucyBvZiB0aGUgc291cmNlLlxuICAgKiBAcGFyYW0ge0F0dHJpYnV0aW9uTGlrZXx1bmRlZmluZWR9IGF0dHJpYnV0aW9ucyBBdHRyaWJ1dGlvbnMuXG4gICAqICAgICBDYW4gYmUgcGFzc2VkIGFzIGBzdHJpbmdgLCBgQXJyYXk8c3RyaW5nPmAsIGB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9Tb3VyY2V+QXR0cmlidXRpb259YCxcbiAgICogICAgIG9yIGB1bmRlZmluZWRgLlxuICAgKiBAYXBpXG4gICAqL1xuICBTb3VyY2UucHJvdG90eXBlLnNldEF0dHJpYnV0aW9ucyA9IGZ1bmN0aW9uIHNldEF0dHJpYnV0aW9ucyAoYXR0cmlidXRpb25zKSB7XG4gICAgdGhpcy5hdHRyaWJ1dGlvbnNfID0gYWRhcHRBdHRyaWJ1dGlvbnMoYXR0cmlidXRpb25zKTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBzdGF0ZSBvZiB0aGUgc291cmNlLlxuICAgKiBAcGFyYW0ge1NvdXJjZVN0YXRlfSBzdGF0ZSBTdGF0ZS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgU291cmNlLnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIHNldFN0YXRlIChzdGF0ZSkge1xuICAgIHRoaXMuc3RhdGVfID0gc3RhdGU7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH07XG5cbiAgcmV0dXJuIFNvdXJjZTtcbn0oQmFzZU9iamVjdCkpO1xuXG5cbi8qKlxuICogVHVybnMgdGhlIGF0dHJpYnV0aW9ucyBvcHRpb24gaW50byBhbiBhdHRyaWJ1dGlvbnMgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0F0dHJpYnV0aW9uTGlrZXx1bmRlZmluZWR9IGF0dHJpYnV0aW9uTGlrZSBUaGUgYXR0cmlidXRpb24gb3B0aW9uLlxuICogQHJldHVybiB7P0F0dHJpYnV0aW9ufSBBbiBhdHRyaWJ1dGlvbiBmdW5jdGlvbiAob3IgbnVsbCkuXG4gKi9cbmZ1bmN0aW9uIGFkYXB0QXR0cmlidXRpb25zKGF0dHJpYnV0aW9uTGlrZSkge1xuICBpZiAoIWF0dHJpYnV0aW9uTGlrZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGF0dHJpYnV0aW9uTGlrZSkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZnJhbWVTdGF0ZSkge1xuICAgICAgcmV0dXJuIGF0dHJpYnV0aW9uTGlrZTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhdHRyaWJ1dGlvbkxpa2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gYXR0cmlidXRpb25MaWtlO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGZyYW1lU3RhdGUpIHtcbiAgICByZXR1cm4gW2F0dHJpYnV0aW9uTGlrZV07XG4gIH07XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgU291cmNlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Tb3VyY2UuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3NvdXJjZS9TdGFtZW5cbiAqL1xuXG5pbXBvcnQge0FUVFJJQlVUSU9OIGFzIE9TTV9BVFRSSUJVVElPTn0gZnJvbSAnLi9PU00uanMnO1xuaW1wb3J0IFhZWiBmcm9tICcuL1hZWi5qcyc7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtBcnJheTxzdHJpbmc+fVxuICovXG52YXIgQVRUUklCVVRJT05TID0gW1xuICAnTWFwIHRpbGVzIGJ5IDxhIGhyZWY9XCJodHRwczovL3N0YW1lbi5jb20vXCI+U3RhbWVuIERlc2lnbjwvYT4sICcgK1xuICAgICAgICAndW5kZXIgPGEgaHJlZj1cImh0dHBzOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS8zLjAvXCI+Q0MgQlknICtcbiAgICAgICAgJyAzLjA8L2E+LicsXG4gIE9TTV9BVFRSSUJVVElPTlxuXTtcblxuXG4vKipcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCB7ZXh0ZW5zaW9uOiBzdHJpbmcsIG9wYXF1ZTogYm9vbGVhbn0+fVxuICovXG52YXIgTGF5ZXJDb25maWcgPSB7XG4gICd0ZXJyYWluJzoge1xuICAgIGV4dGVuc2lvbjogJ2pwZycsXG4gICAgb3BhcXVlOiB0cnVlXG4gIH0sXG4gICd0ZXJyYWluLWJhY2tncm91bmQnOiB7XG4gICAgZXh0ZW5zaW9uOiAnanBnJyxcbiAgICBvcGFxdWU6IHRydWVcbiAgfSxcbiAgJ3RlcnJhaW4tbGFiZWxzJzoge1xuICAgIGV4dGVuc2lvbjogJ3BuZycsXG4gICAgb3BhcXVlOiBmYWxzZVxuICB9LFxuICAndGVycmFpbi1saW5lcyc6IHtcbiAgICBleHRlbnNpb246ICdwbmcnLFxuICAgIG9wYXF1ZTogZmFsc2VcbiAgfSxcbiAgJ3RvbmVyLWJhY2tncm91bmQnOiB7XG4gICAgZXh0ZW5zaW9uOiAncG5nJyxcbiAgICBvcGFxdWU6IHRydWVcbiAgfSxcbiAgJ3RvbmVyJzoge1xuICAgIGV4dGVuc2lvbjogJ3BuZycsXG4gICAgb3BhcXVlOiB0cnVlXG4gIH0sXG4gICd0b25lci1oeWJyaWQnOiB7XG4gICAgZXh0ZW5zaW9uOiAncG5nJyxcbiAgICBvcGFxdWU6IGZhbHNlXG4gIH0sXG4gICd0b25lci1sYWJlbHMnOiB7XG4gICAgZXh0ZW5zaW9uOiAncG5nJyxcbiAgICBvcGFxdWU6IGZhbHNlXG4gIH0sXG4gICd0b25lci1saW5lcyc6IHtcbiAgICBleHRlbnNpb246ICdwbmcnLFxuICAgIG9wYXF1ZTogZmFsc2VcbiAgfSxcbiAgJ3RvbmVyLWxpdGUnOiB7XG4gICAgZXh0ZW5zaW9uOiAncG5nJyxcbiAgICBvcGFxdWU6IHRydWVcbiAgfSxcbiAgJ3dhdGVyY29sb3InOiB7XG4gICAgZXh0ZW5zaW9uOiAnanBnJyxcbiAgICBvcGFxdWU6IHRydWVcbiAgfVxufTtcblxuXG4vKipcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCB7bWluWm9vbTogbnVtYmVyLCBtYXhab29tOiBudW1iZXJ9Pn1cbiAqL1xudmFyIFByb3ZpZGVyQ29uZmlnID0ge1xuICAndGVycmFpbic6IHtcbiAgICBtaW5ab29tOiA0LFxuICAgIG1heFpvb206IDE4XG4gIH0sXG4gICd0b25lcic6IHtcbiAgICBtaW5ab29tOiAwLFxuICAgIG1heFpvb206IDIwXG4gIH0sXG4gICd3YXRlcmNvbG9yJzoge1xuICAgIG1pblpvb206IDEsXG4gICAgbWF4Wm9vbTogMTZcbiAgfVxufTtcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY2FjaGVTaXplPTIwNDhdIENhY2hlIHNpemUuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbGF5ZXIgTGF5ZXIgbmFtZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluWm9vbV0gTWluaW11bSB6b29tLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhab29tXSBNYXhpbXVtIHpvb20uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JlcHJvamVjdGlvbkVycm9yVGhyZXNob2xkPTAuNV0gTWF4aW11bSBhbGxvd2VkIHJlcHJvamVjdGlvbiBlcnJvciAoaW4gcGl4ZWxzKS5cbiAqIEhpZ2hlciB2YWx1ZXMgY2FuIGluY3JlYXNlIHJlcHJvamVjdGlvbiBwZXJmb3JtYW5jZSwgYnV0IGRlY3JlYXNlIHByZWNpc2lvbi5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5Mb2FkRnVuY3Rpb259IFt0aWxlTG9hZEZ1bmN0aW9uXVxuICogT3B0aW9uYWwgZnVuY3Rpb24gdG8gbG9hZCBhIHRpbGUgZ2l2ZW4gYSBVUkwuIFRoZSBkZWZhdWx0IGlzXG4gKiBgYGBqc1xuICogZnVuY3Rpb24oaW1hZ2VUaWxlLCBzcmMpIHtcbiAqICAgaW1hZ2VUaWxlLmdldEltYWdlKCkuc3JjID0gc3JjO1xuICogfTtcbiAqIGBgYFxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt1cmxdIFVSTCB0ZW1wbGF0ZS4gTXVzdCBpbmNsdWRlIGB7eH1gLCBge3l9YCBvciBgey15fWAsIGFuZCBge3p9YCBwbGFjZWhvbGRlcnMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt3cmFwWD10cnVlXSBXaGV0aGVyIHRvIHdyYXAgdGhlIHdvcmxkIGhvcml6b250YWxseS5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogTGF5ZXIgc291cmNlIGZvciB0aGUgU3RhbWVuIHRpbGUgc2VydmVyLlxuICogQGFwaVxuICovXG52YXIgU3RhbWVuID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoWFlaKSB7XG4gIGZ1bmN0aW9uIFN0YW1lbihvcHRpb25zKSB7XG4gICAgdmFyIGkgPSBvcHRpb25zLmxheWVyLmluZGV4T2YoJy0nKTtcbiAgICB2YXIgcHJvdmlkZXIgPSBpID09IC0xID8gb3B0aW9ucy5sYXllciA6IG9wdGlvbnMubGF5ZXIuc2xpY2UoMCwgaSk7XG4gICAgdmFyIHByb3ZpZGVyQ29uZmlnID0gUHJvdmlkZXJDb25maWdbcHJvdmlkZXJdO1xuXG4gICAgdmFyIGxheWVyQ29uZmlnID0gTGF5ZXJDb25maWdbb3B0aW9ucy5sYXllcl07XG5cbiAgICB2YXIgdXJsID0gb3B0aW9ucy51cmwgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudXJsIDpcbiAgICAgICdodHRwczovL3N0YW1lbi10aWxlcy17YS1kfS5hLnNzbC5mYXN0bHkubmV0LycgKyBvcHRpb25zLmxheWVyICtcbiAgICAgICAgJy97en0ve3h9L3t5fS4nICsgbGF5ZXJDb25maWcuZXh0ZW5zaW9uO1xuXG4gICAgWFlaLmNhbGwodGhpcywge1xuICAgICAgYXR0cmlidXRpb25zOiBBVFRSSUJVVElPTlMsXG4gICAgICBjYWNoZVNpemU6IG9wdGlvbnMuY2FjaGVTaXplLFxuICAgICAgY3Jvc3NPcmlnaW46ICdhbm9ueW1vdXMnLFxuICAgICAgbWF4Wm9vbTogb3B0aW9ucy5tYXhab29tICE9IHVuZGVmaW5lZCA/IG9wdGlvbnMubWF4Wm9vbSA6IHByb3ZpZGVyQ29uZmlnLm1heFpvb20sXG4gICAgICBtaW5ab29tOiBvcHRpb25zLm1pblpvb20gIT0gdW5kZWZpbmVkID8gb3B0aW9ucy5taW5ab29tIDogcHJvdmlkZXJDb25maWcubWluWm9vbSxcbiAgICAgIG9wYXF1ZTogbGF5ZXJDb25maWcub3BhcXVlLFxuICAgICAgcmVwcm9qZWN0aW9uRXJyb3JUaHJlc2hvbGQ6IG9wdGlvbnMucmVwcm9qZWN0aW9uRXJyb3JUaHJlc2hvbGQsXG4gICAgICB0aWxlTG9hZEZ1bmN0aW9uOiBvcHRpb25zLnRpbGVMb2FkRnVuY3Rpb24sXG4gICAgICB1cmw6IHVybCxcbiAgICAgIHdyYXBYOiBvcHRpb25zLndyYXBYXG4gICAgfSk7XG5cbiAgfVxuXG4gIGlmICggWFlaICkgU3RhbWVuLl9fcHJvdG9fXyA9IFhZWjtcbiAgU3RhbWVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFhZWiAmJiBYWVoucHJvdG90eXBlICk7XG4gIFN0YW1lbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdGFtZW47XG5cbiAgcmV0dXJuIFN0YW1lbjtcbn0oWFlaKSk7XG5cbmV4cG9ydCBkZWZhdWx0IFN0YW1lbjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RhbWVuLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9zb3VyY2UvU3RhdGVcbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKiBTdGF0ZSBvZiB0aGUgc291cmNlLCBvbmUgb2YgJ3VuZGVmaW5lZCcsICdsb2FkaW5nJywgJ3JlYWR5JyBvciAnZXJyb3InLlxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIFVOREVGSU5FRDogJ3VuZGVmaW5lZCcsXG4gIExPQURJTkc6ICdsb2FkaW5nJyxcbiAgUkVBRFk6ICdyZWFkeScsXG4gIEVSUk9SOiAnZXJyb3InXG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdGF0ZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvc291cmNlL1RpbGVcbiAqL1xuaW1wb3J0IHthYnN0cmFjdH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5pbXBvcnQgVGlsZUNhY2hlIGZyb20gJy4uL1RpbGVDYWNoZS5qcyc7XG5pbXBvcnQgVGlsZVN0YXRlIGZyb20gJy4uL1RpbGVTdGF0ZS5qcyc7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzL0V2ZW50LmpzJztcbmltcG9ydCB7ZXF1aXZhbGVudH0gZnJvbSAnLi4vcHJvai5qcyc7XG5pbXBvcnQge3RvU2l6ZSwgc2NhbGUgYXMgc2NhbGVTaXplfSBmcm9tICcuLi9zaXplLmpzJztcbmltcG9ydCBTb3VyY2UgZnJvbSAnLi9Tb3VyY2UuanMnO1xuaW1wb3J0IHtnZXRLZXlaWFksIHdpdGhpbkV4dGVudEFuZFp9IGZyb20gJy4uL3RpbGVjb29yZC5qcyc7XG5pbXBvcnQge3dyYXBYLCBnZXRGb3JQcm9qZWN0aW9uIGFzIGdldFRpbGVHcmlkRm9yUHJvamVjdGlvbn0gZnJvbSAnLi4vdGlsZWdyaWQuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9Tb3VyY2UuanNcIikuQXR0cmlidXRpb25MaWtlfSBbYXR0cmlidXRpb25zXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbYXR0cmlidXRpb25zQ29sbGFwc2libGU9dHJ1ZV0gQXR0cmlidXRpb25zIGFyZSBjb2xsYXBzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY2FjaGVTaXplXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbb3BhcXVlXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0aWxlUGl4ZWxSYXRpb11cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gW3Byb2plY3Rpb25dXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vU3RhdGUuanNcIikuZGVmYXVsdH0gW3N0YXRlXVxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSBbdGlsZUdyaWRdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt3cmFwWD10cnVlXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0cmFuc2l0aW9uXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtrZXldXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3M7IG5vcm1hbGx5IG9ubHkgdXNlZCBmb3IgY3JlYXRpbmcgc3ViY2xhc3NlcyBhbmQgbm90XG4gKiBpbnN0YW50aWF0ZWQgaW4gYXBwcy5cbiAqIEJhc2UgY2xhc3MgZm9yIHNvdXJjZXMgcHJvdmlkaW5nIGltYWdlcyBkaXZpZGVkIGludG8gYSB0aWxlIGdyaWQuXG4gKiBAYWJzdHJhY3RcbiAqIEBhcGlcbiAqL1xudmFyIFRpbGVTb3VyY2UgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChTb3VyY2UpIHtcbiAgZnVuY3Rpb24gVGlsZVNvdXJjZShvcHRpb25zKSB7XG5cbiAgICBTb3VyY2UuY2FsbCh0aGlzLCB7XG4gICAgICBhdHRyaWJ1dGlvbnM6IG9wdGlvbnMuYXR0cmlidXRpb25zLFxuICAgICAgYXR0cmlidXRpb25zQ29sbGFwc2libGU6IG9wdGlvbnMuYXR0cmlidXRpb25zQ29sbGFwc2libGUsXG4gICAgICBwcm9qZWN0aW9uOiBvcHRpb25zLnByb2plY3Rpb24sXG4gICAgICBzdGF0ZTogb3B0aW9ucy5zdGF0ZSxcbiAgICAgIHdyYXBYOiBvcHRpb25zLndyYXBYXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMub3BhcXVlXyA9IG9wdGlvbnMub3BhcXVlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm9wYXF1ZSA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudGlsZVBpeGVsUmF0aW9fID0gb3B0aW9ucy50aWxlUGl4ZWxSYXRpbyAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdGlvbnMudGlsZVBpeGVsUmF0aW8gOiAxO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMudGlsZUdyaWQgPSBvcHRpb25zLnRpbGVHcmlkICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnRpbGVHcmlkIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vVGlsZUNhY2hlLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy50aWxlQ2FjaGUgPSBuZXcgVGlsZUNhY2hlKG9wdGlvbnMuY2FjaGVTaXplKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfVxuICAgICAqL1xuICAgIHRoaXMudG1wU2l6ZSA9IFswLCAwXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmtleV8gPSBvcHRpb25zLmtleSB8fCAnJztcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5PcHRpb25zfVxuICAgICAqL1xuICAgIHRoaXMudGlsZU9wdGlvbnMgPSB7dHJhbnNpdGlvbjogb3B0aW9ucy50cmFuc2l0aW9ufTtcblxuICB9XG5cbiAgaWYgKCBTb3VyY2UgKSBUaWxlU291cmNlLl9fcHJvdG9fXyA9IFNvdXJjZTtcbiAgVGlsZVNvdXJjZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBTb3VyY2UgJiYgU291cmNlLnByb3RvdHlwZSApO1xuICBUaWxlU291cmNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRpbGVTb3VyY2U7XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IENhbiBleHBpcmUgY2FjaGUuXG4gICAqL1xuICBUaWxlU291cmNlLnByb3RvdHlwZS5jYW5FeHBpcmVDYWNoZSA9IGZ1bmN0aW9uIGNhbkV4cGlyZUNhY2hlICgpIHtcbiAgICByZXR1cm4gdGhpcy50aWxlQ2FjaGUuY2FuRXhwaXJlQ2FjaGUoKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgKiBAcGFyYW0geyFPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdD59IHVzZWRUaWxlcyBVc2VkIHRpbGVzLlxuICAgKi9cbiAgVGlsZVNvdXJjZS5wcm90b3R5cGUuZXhwaXJlQ2FjaGUgPSBmdW5jdGlvbiBleHBpcmVDYWNoZSAocHJvamVjdGlvbiwgdXNlZFRpbGVzKSB7XG4gICAgdmFyIHRpbGVDYWNoZSA9IHRoaXMuZ2V0VGlsZUNhY2hlRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgICBpZiAodGlsZUNhY2hlKSB7XG4gICAgICB0aWxlQ2FjaGUuZXhwaXJlQ2FjaGUodXNlZFRpbGVzKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHogWm9vbSBsZXZlbC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdH0gdGlsZVJhbmdlIFRpbGUgcmFuZ2UuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5kZWZhdWx0KTooYm9vbGVhbnx2b2lkKX0gY2FsbGJhY2sgQ2FsbGVkIHdpdGggZWFjaFxuICAgKiAgICAgbG9hZGVkIHRpbGUuICBJZiB0aGUgY2FsbGJhY2sgcmV0dXJucyBgZmFsc2VgLCB0aGUgdGlsZSB3aWxsIG5vdCBiZVxuICAgKiAgICAgY29uc2lkZXJlZCBsb2FkZWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB0aWxlIHJhbmdlIGlzIGZ1bGx5IGNvdmVyZWQgd2l0aCBsb2FkZWQgdGlsZXMuXG4gICAqL1xuICBUaWxlU291cmNlLnByb3RvdHlwZS5mb3JFYWNoTG9hZGVkVGlsZSA9IGZ1bmN0aW9uIGZvckVhY2hMb2FkZWRUaWxlIChwcm9qZWN0aW9uLCB6LCB0aWxlUmFuZ2UsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHRpbGVDYWNoZSA9IHRoaXMuZ2V0VGlsZUNhY2hlRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgICBpZiAoIXRpbGVDYWNoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBjb3ZlcmVkID0gdHJ1ZTtcbiAgICB2YXIgdGlsZSwgdGlsZUNvb3JkS2V5LCBsb2FkZWQ7XG4gICAgZm9yICh2YXIgeCA9IHRpbGVSYW5nZS5taW5YOyB4IDw9IHRpbGVSYW5nZS5tYXhYOyArK3gpIHtcbiAgICAgIGZvciAodmFyIHkgPSB0aWxlUmFuZ2UubWluWTsgeSA8PSB0aWxlUmFuZ2UubWF4WTsgKyt5KSB7XG4gICAgICAgIHRpbGVDb29yZEtleSA9IGdldEtleVpYWSh6LCB4LCB5KTtcbiAgICAgICAgbG9hZGVkID0gZmFsc2U7XG4gICAgICAgIGlmICh0aWxlQ2FjaGUuY29udGFpbnNLZXkodGlsZUNvb3JkS2V5KSkge1xuICAgICAgICAgIHRpbGUgPSAvKiogQHR5cGUgeyFpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLmRlZmF1bHR9ICovICh0aWxlQ2FjaGUuZ2V0KHRpbGVDb29yZEtleSkpO1xuICAgICAgICAgIGxvYWRlZCA9IHRpbGUuZ2V0U3RhdGUoKSA9PT0gVGlsZVN0YXRlLkxPQURFRDtcbiAgICAgICAgICBpZiAobG9hZGVkKSB7XG4gICAgICAgICAgICBsb2FkZWQgPSAoY2FsbGJhY2sodGlsZSkgIT09IGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsb2FkZWQpIHtcbiAgICAgICAgICBjb3ZlcmVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvdmVyZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7bnVtYmVyfSBHdXR0ZXIuXG4gICAqL1xuICBUaWxlU291cmNlLnByb3RvdHlwZS5nZXRHdXR0ZXJGb3JQcm9qZWN0aW9uID0gZnVuY3Rpb24gZ2V0R3V0dGVyRm9yUHJvamVjdGlvbiAocHJvamVjdGlvbikge1xuICAgIHJldHVybiAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGtleSB0byBiZSB1c2VkIGZvciBhbGwgdGlsZXMgaW4gdGhlIHNvdXJjZS5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUga2V5IGZvciBhbGwgdGlsZXMuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIFRpbGVTb3VyY2UucHJvdG90eXBlLmdldEtleSA9IGZ1bmN0aW9uIGdldEtleSAoKSB7XG4gICAgcmV0dXJuIHRoaXMua2V5XztcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSB2YWx1ZSB0byBiZSB1c2VkIGFzIHRoZSBrZXkgZm9yIGFsbCB0aWxlcyBpbiB0aGUgc291cmNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgZm9yIHRpbGVzLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBUaWxlU291cmNlLnByb3RvdHlwZS5zZXRLZXkgPSBmdW5jdGlvbiBzZXRLZXkgKGtleSkge1xuICAgIGlmICh0aGlzLmtleV8gIT09IGtleSkge1xuICAgICAgdGhpcy5rZXlfID0ga2V5O1xuICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IE9wYXF1ZS5cbiAgICovXG4gIFRpbGVTb3VyY2UucHJvdG90eXBlLmdldE9wYXF1ZSA9IGZ1bmN0aW9uIGdldE9wYXF1ZSAocHJvamVjdGlvbikge1xuICAgIHJldHVybiB0aGlzLm9wYXF1ZV87XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBUaWxlU291cmNlLnByb3RvdHlwZS5nZXRSZXNvbHV0aW9ucyA9IGZ1bmN0aW9uIGdldFJlc29sdXRpb25zICgpIHtcbiAgICByZXR1cm4gdGhpcy50aWxlR3JpZC5nZXRSZXNvbHV0aW9ucygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHogVGlsZSBjb29yZGluYXRlIHouXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFRpbGUgY29vcmRpbmF0ZSB4LlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBUaWxlIGNvb3JkaW5hdGUgeS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7IWltcG9ydChcIi4uL1RpbGUuanNcIikuZGVmYXVsdH0gVGlsZS5cbiAgICovXG4gIFRpbGVTb3VyY2UucHJvdG90eXBlLmdldFRpbGUgPSBmdW5jdGlvbiBnZXRUaWxlICh6LCB4LCB5LCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgdGlsZSBncmlkIG9mIHRoZSB0aWxlIHNvdXJjZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH0gVGlsZSBncmlkLlxuICAgKiBAYXBpXG4gICAqL1xuICBUaWxlU291cmNlLnByb3RvdHlwZS5nZXRUaWxlR3JpZCA9IGZ1bmN0aW9uIGdldFRpbGVHcmlkICgpIHtcbiAgICByZXR1cm4gdGhpcy50aWxlR3JpZDtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgKiBAcmV0dXJuIHshaW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH0gVGlsZSBncmlkLlxuICAgKi9cbiAgVGlsZVNvdXJjZS5wcm90b3R5cGUuZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uID0gZnVuY3Rpb24gZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uJDEgKHByb2plY3Rpb24pIHtcbiAgICBpZiAoIXRoaXMudGlsZUdyaWQpIHtcbiAgICAgIHJldHVybiBnZXRUaWxlR3JpZEZvclByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnRpbGVHcmlkO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9UaWxlQ2FjaGUuanNcIikuZGVmYXVsdH0gVGlsZSBjYWNoZS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgVGlsZVNvdXJjZS5wcm90b3R5cGUuZ2V0VGlsZUNhY2hlRm9yUHJvamVjdGlvbiA9IGZ1bmN0aW9uIGdldFRpbGVDYWNoZUZvclByb2plY3Rpb24gKHByb2plY3Rpb24pIHtcbiAgICB2YXIgdGhpc1Byb2ogPSB0aGlzLmdldFByb2plY3Rpb24oKTtcbiAgICBpZiAodGhpc1Byb2ogJiYgIWVxdWl2YWxlbnQodGhpc1Byb2osIHByb2plY3Rpb24pKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMudGlsZUNhY2hlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSB0aWxlIHBpeGVsIHJhdGlvIGZvciB0aGlzIHNvdXJjZS4gU3ViY2xhc3NlcyBtYXkgb3ZlcnJpZGUgdGhpc1xuICAgKiBtZXRob2QsIHdoaWNoIGlzIG1lYW50IHRvIHJldHVybiBhIHN1cHBvcnRlZCBwaXhlbCByYXRpbyB0aGF0IG1hdGNoZXMgdGhlXG4gICAqIHByb3ZpZGVkIGBwaXhlbFJhdGlvYCBhcyBjbG9zZSBhcyBwb3NzaWJsZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGlsZSBwaXhlbCByYXRpby5cbiAgICovXG4gIFRpbGVTb3VyY2UucHJvdG90eXBlLmdldFRpbGVQaXhlbFJhdGlvID0gZnVuY3Rpb24gZ2V0VGlsZVBpeGVsUmF0aW8gKHBpeGVsUmF0aW8pIHtcbiAgICByZXR1cm4gdGhpcy50aWxlUGl4ZWxSYXRpb187XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6IFouXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gVGlsZSBzaXplLlxuICAgKi9cbiAgVGlsZVNvdXJjZS5wcm90b3R5cGUuZ2V0VGlsZVBpeGVsU2l6ZSA9IGZ1bmN0aW9uIGdldFRpbGVQaXhlbFNpemUgKHosIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pIHtcbiAgICB2YXIgdGlsZUdyaWQgPSB0aGlzLmdldFRpbGVHcmlkRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgICB2YXIgdGlsZVBpeGVsUmF0aW8gPSB0aGlzLmdldFRpbGVQaXhlbFJhdGlvKHBpeGVsUmF0aW8pO1xuICAgIHZhciB0aWxlU2l6ZSA9IHRvU2l6ZSh0aWxlR3JpZC5nZXRUaWxlU2l6ZSh6KSwgdGhpcy50bXBTaXplKTtcbiAgICBpZiAodGlsZVBpeGVsUmF0aW8gPT0gMSkge1xuICAgICAgcmV0dXJuIHRpbGVTaXplO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc2NhbGVTaXplKHRpbGVTaXplLCB0aWxlUGl4ZWxSYXRpbywgdGhpcy50bXBTaXplKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB0aWxlIGNvb3JkaW5hdGUgd3JhcHBlZCBhcm91bmQgdGhlIHgtYXhpcy4gV2hlbiB0aGUgdGlsZSBjb29yZGluYXRlXG4gICAqIGlzIG91dHNpZGUgdGhlIHJlc29sdXRpb24gYW5kIGV4dGVudCByYW5nZSBvZiB0aGUgdGlsZSBncmlkLCBgbnVsbGAgd2lsbCBiZVxuICAgKiByZXR1cm5lZC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0PX0gb3B0X3Byb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gVGlsZSBjb29yZGluYXRlIHRvIGJlIHBhc3NlZCB0byB0aGUgdGlsZVVybEZ1bmN0aW9uIG9yXG4gICAqICAgICBudWxsIGlmIG5vIHRpbGUgVVJMIHNob3VsZCBiZSBjcmVhdGVkIGZvciB0aGUgcGFzc2VkIGB0aWxlQ29vcmRgLlxuICAgKi9cbiAgVGlsZVNvdXJjZS5wcm90b3R5cGUuZ2V0VGlsZUNvb3JkRm9yVGlsZVVybEZ1bmN0aW9uID0gZnVuY3Rpb24gZ2V0VGlsZUNvb3JkRm9yVGlsZVVybEZ1bmN0aW9uICh0aWxlQ29vcmQsIG9wdF9wcm9qZWN0aW9uKSB7XG4gICAgdmFyIHByb2plY3Rpb24gPSBvcHRfcHJvamVjdGlvbiAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdF9wcm9qZWN0aW9uIDogdGhpcy5nZXRQcm9qZWN0aW9uKCk7XG4gICAgdmFyIHRpbGVHcmlkID0gdGhpcy5nZXRUaWxlR3JpZEZvclByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gICAgaWYgKHRoaXMuZ2V0V3JhcFgoKSAmJiBwcm9qZWN0aW9uLmlzR2xvYmFsKCkpIHtcbiAgICAgIHRpbGVDb29yZCA9IHdyYXBYKHRpbGVHcmlkLCB0aWxlQ29vcmQsIHByb2plY3Rpb24pO1xuICAgIH1cbiAgICByZXR1cm4gd2l0aGluRXh0ZW50QW5kWih0aWxlQ29vcmQsIHRpbGVHcmlkKSA/IHRpbGVDb29yZCA6IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBUaWxlU291cmNlLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gcmVmcmVzaCAoKSB7XG4gICAgdGhpcy50aWxlQ2FjaGUuY2xlYXIoKTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuICAvKipcbiAgICogTWFya3MgYSB0aWxlIGNvb3JkIGFzIGJlaW5nIHVzZWQsIHdpdGhvdXQgdHJpZ2dlcmluZyBhIGxvYWQuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge251bWJlcn0geiBUaWxlIGNvb3JkaW5hdGUgei5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggVGlsZSBjb29yZGluYXRlIHguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IFRpbGUgY29vcmRpbmF0ZSB5LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqL1xuICBUaWxlU291cmNlLnByb3RvdHlwZS51c2VUaWxlID0gZnVuY3Rpb24gdXNlVGlsZSAoeiwgeCwgeSwgcHJvamVjdGlvbikge307XG5cbiAgcmV0dXJuIFRpbGVTb3VyY2U7XG59KFNvdXJjZSkpO1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogRXZlbnRzIGVtaXR0ZWQgYnkge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVGlsZX5UaWxlU291cmNlfSBpbnN0YW5jZXMgYXJlIGluc3RhbmNlcyBvZiB0aGlzXG4gKiB0eXBlLlxuICovXG5leHBvcnQgdmFyIFRpbGVTb3VyY2VFdmVudCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEV2ZW50KSB7XG4gIGZ1bmN0aW9uIFRpbGVTb3VyY2VFdmVudCh0eXBlLCB0aWxlKSB7XG5cbiAgICBFdmVudC5jYWxsKHRoaXMsIHR5cGUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRpbGUgcmVsYXRlZCB0byB0aGUgZXZlbnQuXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL1RpbGUuanNcIikuZGVmYXVsdH1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy50aWxlID0gdGlsZTtcblxuICB9XG5cbiAgaWYgKCBFdmVudCApIFRpbGVTb3VyY2VFdmVudC5fX3Byb3RvX18gPSBFdmVudDtcbiAgVGlsZVNvdXJjZUV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEV2ZW50ICYmIEV2ZW50LnByb3RvdHlwZSApO1xuICBUaWxlU291cmNlRXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGlsZVNvdXJjZUV2ZW50O1xuXG4gIHJldHVybiBUaWxlU291cmNlRXZlbnQ7XG59KEV2ZW50KSk7XG5cbmV4cG9ydCBkZWZhdWx0IFRpbGVTb3VyY2U7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpbGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3NvdXJjZS9UaWxlRXZlbnRUeXBlXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB3aGVuIGEgdGlsZSBzdGFydHMgbG9hZGluZy5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9zb3VyY2UvVGlsZS5UaWxlU291cmNlRXZlbnQjdGlsZWxvYWRzdGFydFxuICAgKiBAYXBpXG4gICAqL1xuICBUSUxFTE9BRFNUQVJUOiAndGlsZWxvYWRzdGFydCcsXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB3aGVuIGEgdGlsZSBmaW5pc2hlcyBsb2FkaW5nLCBlaXRoZXIgd2hlbiBpdHMgZGF0YSBpcyBsb2FkZWQsXG4gICAqIG9yIHdoZW4gbG9hZGluZyB3YXMgYWJvcnRlZCBiZWNhdXNlIHRoZSB0aWxlIGlzIG5vIGxvbmdlciBuZWVkZWQuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvc291cmNlL1RpbGUuVGlsZVNvdXJjZUV2ZW50I3RpbGVsb2FkZW5kXG4gICAqIEBhcGlcbiAgICovXG4gIFRJTEVMT0FERU5EOiAndGlsZWxvYWRlbmQnLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgaWYgdGlsZSBsb2FkaW5nIHJlc3VsdHMgaW4gYW4gZXJyb3IuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvc291cmNlL1RpbGUuVGlsZVNvdXJjZUV2ZW50I3RpbGVsb2FkZXJyb3JcbiAgICogQGFwaVxuICAgKi9cbiAgVElMRUxPQURFUlJPUjogJ3RpbGVsb2FkZXJyb3InXG5cbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpbGVFdmVudFR5cGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3NvdXJjZS9UaWxlSW1hZ2VcbiAqL1xuaW1wb3J0IHtFTkFCTEVfUkFTVEVSX1JFUFJPSkVDVElPTn0gZnJvbSAnLi4vcmVwcm9qL2NvbW1vbi5qcyc7XG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5pbXBvcnQgSW1hZ2VUaWxlIGZyb20gJy4uL0ltYWdlVGlsZS5qcyc7XG5pbXBvcnQgVGlsZUNhY2hlIGZyb20gJy4uL1RpbGVDYWNoZS5qcyc7XG5pbXBvcnQgVGlsZVN0YXRlIGZyb20gJy4uL1RpbGVTdGF0ZS5qcyc7XG5pbXBvcnQge2xpc3Rlbn0gZnJvbSAnLi4vZXZlbnRzLmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQge2VxdWl2YWxlbnQsIGdldCBhcyBnZXRQcm9qZWN0aW9ufSBmcm9tICcuLi9wcm9qLmpzJztcbmltcG9ydCBSZXByb2pUaWxlIGZyb20gJy4uL3JlcHJvai9UaWxlLmpzJztcbmltcG9ydCBVcmxUaWxlIGZyb20gJy4vVXJsVGlsZS5qcyc7XG5pbXBvcnQge2dldEtleSwgZ2V0S2V5WlhZfSBmcm9tICcuLi90aWxlY29vcmQuanMnO1xuaW1wb3J0IHtnZXRGb3JQcm9qZWN0aW9uIGFzIGdldFRpbGVHcmlkRm9yUHJvamVjdGlvbn0gZnJvbSAnLi4vdGlsZWdyaWQuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9Tb3VyY2UuanNcIikuQXR0cmlidXRpb25MaWtlfSBbYXR0cmlidXRpb25zXSBBdHRyaWJ1dGlvbnMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZT10cnVlXSBBdHRyaWJ1dGlvbnMgYXJlIGNvbGxhcHNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtjYWNoZVNpemU9MjA0OF0gQ2FjaGUgc2l6ZS5cbiAqIEBwcm9wZXJ0eSB7bnVsbHxzdHJpbmd9IFtjcm9zc09yaWdpbl0gVGhlIGBjcm9zc09yaWdpbmAgYXR0cmlidXRlIGZvciBsb2FkZWQgaW1hZ2VzLiAgTm90ZSB0aGF0XG4gKiB5b3UgbXVzdCBwcm92aWRlIGEgYGNyb3NzT3JpZ2luYCB2YWx1ZSBpZiB5b3UgYXJlIHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlciBvciBpZiB5b3Ugd2FudCB0b1xuICogYWNjZXNzIHBpeGVsIGRhdGEgd2l0aCB0aGUgQ2FudmFzIHJlbmRlcmVyLiAgU2VlXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0NPUlNfZW5hYmxlZF9pbWFnZSBmb3IgbW9yZSBkZXRhaWwuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtvcGFxdWU9dHJ1ZV0gV2hldGhlciB0aGUgbGF5ZXIgaXMgb3BhcXVlLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9wcm9qLmpzXCIpLlByb2plY3Rpb25MaWtlfSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JlcHJvamVjdGlvbkVycm9yVGhyZXNob2xkPTAuNV0gTWF4aW11bSBhbGxvd2VkIHJlcHJvamVjdGlvbiBlcnJvciAoaW4gcGl4ZWxzKS5cbiAqIEhpZ2hlciB2YWx1ZXMgY2FuIGluY3JlYXNlIHJlcHJvamVjdGlvbiBwZXJmb3JtYW5jZSwgYnV0IGRlY3JlYXNlIHByZWNpc2lvbi5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9TdGF0ZS5qc1wiKS5kZWZhdWx0fSBbc3RhdGVdIFNvdXJjZSBzdGF0ZS5cbiAqIEBwcm9wZXJ0eSB7dHlwZW9mIGltcG9ydChcIi4uL0ltYWdlVGlsZS5qc1wiKS5kZWZhdWx0fSBbdGlsZUNsYXNzXSBDbGFzcyB1c2VkIHRvIGluc3RhbnRpYXRlIGltYWdlIHRpbGVzLlxuICogRGVmYXVsdCBpcyB7QGxpbmsgbW9kdWxlOm9sL0ltYWdlVGlsZX5JbWFnZVRpbGV9LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSBbdGlsZUdyaWRdIFRpbGUgZ3JpZC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5Mb2FkRnVuY3Rpb259IFt0aWxlTG9hZEZ1bmN0aW9uXSBPcHRpb25hbCBmdW5jdGlvbiB0byBsb2FkIGEgdGlsZSBnaXZlbiBhIFVSTC4gVGhlIGRlZmF1bHQgaXNcbiAqIGBgYGpzXG4gKiBmdW5jdGlvbihpbWFnZVRpbGUsIHNyYykge1xuICogICBpbWFnZVRpbGUuZ2V0SW1hZ2UoKS5zcmMgPSBzcmM7XG4gKiB9O1xuICogYGBgXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RpbGVQaXhlbFJhdGlvPTFdIFRoZSBwaXhlbCByYXRpbyB1c2VkIGJ5IHRoZSB0aWxlIHNlcnZpY2UuIEZvciBleGFtcGxlLCBpZiB0aGUgdGlsZVxuICogc2VydmljZSBhZHZlcnRpemVzIDI1NnB4IGJ5IDI1NnB4IHRpbGVzIGJ1dCBhY3R1YWxseSBzZW5kcyA1MTJweFxuICogYnkgNTEycHggaW1hZ2VzIChmb3IgcmV0aW5hL2hpZHBpIGRldmljZXMpIHRoZW4gYHRpbGVQaXhlbFJhdGlvYFxuICogc2hvdWxkIGJlIHNldCB0byBgMmAuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL1RpbGUuanNcIikuVXJsRnVuY3Rpb259IFt0aWxlVXJsRnVuY3Rpb25dIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGdldCB0aWxlIFVSTCBnaXZlbiBhIHRpbGUgY29vcmRpbmF0ZSBhbmQgdGhlIHByb2plY3Rpb24uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3VybF0gVVJMIHRlbXBsYXRlLiBNdXN0IGluY2x1ZGUgYHt4fWAsIGB7eX1gIG9yIGB7LXl9YCwgYW5kIGB7en1gIHBsYWNlaG9sZGVycy5cbiAqIEEgYHs/LT99YCB0ZW1wbGF0ZSBwYXR0ZXJuLCBmb3IgZXhhbXBsZSBgc3ViZG9tYWlue2EtZn0uZG9tYWluLmNvbWAsIG1heSBiZVxuICogdXNlZCBpbnN0ZWFkIG9mIGRlZmluaW5nIGVhY2ggb25lIHNlcGFyYXRlbHkgaW4gdGhlIGB1cmxzYCBvcHRpb24uXG4gKiBAcHJvcGVydHkge0FycmF5PHN0cmluZz59IFt1cmxzXSBBbiBhcnJheSBvZiBVUkwgdGVtcGxhdGVzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbd3JhcFhdIFdoZXRoZXIgdG8gd3JhcCB0aGUgd29ybGQgaG9yaXpvbnRhbGx5LiBUaGUgZGVmYXVsdCwgaXMgdG9cbiAqIHJlcXVlc3Qgb3V0LW9mLWJvdW5kcyB0aWxlcyBmcm9tIHRoZSBzZXJ2ZXIuIFdoZW4gc2V0IHRvIGBmYWxzZWAsIG9ubHkgb25lXG4gKiB3b3JsZCB3aWxsIGJlIHJlbmRlcmVkLiBXaGVuIHNldCB0byBgdHJ1ZWAsIHRpbGVzIHdpbGwgYmUgcmVxdWVzdGVkIGZvciBvbmVcbiAqIHdvcmxkIG9ubHksIGJ1dCB0aGV5IHdpbGwgYmUgd3JhcHBlZCBob3Jpem9udGFsbHkgdG8gcmVuZGVyIG11bHRpcGxlIHdvcmxkcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdHJhbnNpdGlvbl0gRHVyYXRpb24gb2YgdGhlIG9wYWNpdHkgdHJhbnNpdGlvbiBmb3IgcmVuZGVyaW5nLlxuICogVG8gZGlzYWJsZSB0aGUgb3BhY2l0eSB0cmFuc2l0aW9uLCBwYXNzIGB0cmFuc2l0aW9uOiAwYC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBba2V5XSBPcHRpb25hbCB0aWxlIGtleSBmb3IgcHJvcGVyIGNhY2hlIGZldGNoaW5nXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEJhc2UgY2xhc3MgZm9yIHNvdXJjZXMgcHJvdmlkaW5nIGltYWdlcyBkaXZpZGVkIGludG8gYSB0aWxlIGdyaWQuXG4gKlxuICogQGZpcmVzIGltcG9ydChcIi4vVGlsZS5qc1wiKS5UaWxlU291cmNlRXZlbnRcbiAqIEBhcGlcbiAqL1xudmFyIFRpbGVJbWFnZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFVybFRpbGUpIHtcbiAgZnVuY3Rpb24gVGlsZUltYWdlKG9wdGlvbnMpIHtcblxuICAgIFVybFRpbGUuY2FsbCh0aGlzLCB7XG4gICAgICBhdHRyaWJ1dGlvbnM6IG9wdGlvbnMuYXR0cmlidXRpb25zLFxuICAgICAgY2FjaGVTaXplOiBvcHRpb25zLmNhY2hlU2l6ZSxcbiAgICAgIG9wYXF1ZTogb3B0aW9ucy5vcGFxdWUsXG4gICAgICBwcm9qZWN0aW9uOiBvcHRpb25zLnByb2plY3Rpb24sXG4gICAgICBzdGF0ZTogb3B0aW9ucy5zdGF0ZSxcbiAgICAgIHRpbGVHcmlkOiBvcHRpb25zLnRpbGVHcmlkLFxuICAgICAgdGlsZUxvYWRGdW5jdGlvbjogb3B0aW9ucy50aWxlTG9hZEZ1bmN0aW9uID9cbiAgICAgICAgb3B0aW9ucy50aWxlTG9hZEZ1bmN0aW9uIDogZGVmYXVsdFRpbGVMb2FkRnVuY3Rpb24sXG4gICAgICB0aWxlUGl4ZWxSYXRpbzogb3B0aW9ucy50aWxlUGl4ZWxSYXRpbyxcbiAgICAgIHRpbGVVcmxGdW5jdGlvbjogb3B0aW9ucy50aWxlVXJsRnVuY3Rpb24sXG4gICAgICB1cmw6IG9wdGlvbnMudXJsLFxuICAgICAgdXJsczogb3B0aW9ucy51cmxzLFxuICAgICAgd3JhcFg6IG9wdGlvbnMud3JhcFgsXG4gICAgICB0cmFuc2l0aW9uOiBvcHRpb25zLnRyYW5zaXRpb24sXG4gICAgICBrZXk6IG9wdGlvbnMua2V5LFxuICAgICAgYXR0cmlidXRpb25zQ29sbGFwc2libGU6IG9wdGlvbnMuYXR0cmlidXRpb25zQ29sbGFwc2libGVcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7P3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmNyb3NzT3JpZ2luID1cbiAgICAgICAgb3B0aW9ucy5jcm9zc09yaWdpbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jcm9zc09yaWdpbiA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge3R5cGVvZiBJbWFnZVRpbGV9XG4gICAgICovXG4gICAgdGhpcy50aWxlQ2xhc3MgPSBvcHRpb25zLnRpbGVDbGFzcyAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdGlvbnMudGlsZUNsYXNzIDogSW1hZ2VUaWxlO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgVGlsZUNhY2hlPn1cbiAgICAgKi9cbiAgICB0aGlzLnRpbGVDYWNoZUZvclByb2plY3Rpb24gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHQ+fVxuICAgICAqL1xuICAgIHRoaXMudGlsZUdyaWRGb3JQcm9qZWN0aW9uID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMucmVwcm9qZWN0aW9uRXJyb3JUaHJlc2hvbGRfID0gb3B0aW9ucy5yZXByb2plY3Rpb25FcnJvclRocmVzaG9sZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJSZXByb2plY3Rpb25FZGdlc18gPSBmYWxzZTtcbiAgfVxuXG4gIGlmICggVXJsVGlsZSApIFRpbGVJbWFnZS5fX3Byb3RvX18gPSBVcmxUaWxlO1xuICBUaWxlSW1hZ2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVXJsVGlsZSAmJiBVcmxUaWxlLnByb3RvdHlwZSApO1xuICBUaWxlSW1hZ2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGlsZUltYWdlO1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgVGlsZUltYWdlLnByb3RvdHlwZS5jYW5FeHBpcmVDYWNoZSA9IGZ1bmN0aW9uIGNhbkV4cGlyZUNhY2hlICgpIHtcbiAgICBpZiAoIUVOQUJMRV9SQVNURVJfUkVQUk9KRUNUSU9OKSB7XG4gICAgICByZXR1cm4gVXJsVGlsZS5wcm90b3R5cGUuY2FuRXhwaXJlQ2FjaGUuY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGlsZUNhY2hlLmNhbkV4cGlyZUNhY2hlKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy50aWxlQ2FjaGVGb3JQcm9qZWN0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbGVDYWNoZUZvclByb2plY3Rpb25ba2V5XS5jYW5FeHBpcmVDYWNoZSgpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgVGlsZUltYWdlLnByb3RvdHlwZS5leHBpcmVDYWNoZSA9IGZ1bmN0aW9uIGV4cGlyZUNhY2hlIChwcm9qZWN0aW9uLCB1c2VkVGlsZXMpIHtcbiAgICBpZiAoIUVOQUJMRV9SQVNURVJfUkVQUk9KRUNUSU9OKSB7XG4gICAgICBVcmxUaWxlLnByb3RvdHlwZS5leHBpcmVDYWNoZS5jYWxsKHRoaXMsIHByb2plY3Rpb24sIHVzZWRUaWxlcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB1c2VkVGlsZUNhY2hlID0gdGhpcy5nZXRUaWxlQ2FjaGVGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuXG4gICAgdGhpcy50aWxlQ2FjaGUuZXhwaXJlQ2FjaGUodGhpcy50aWxlQ2FjaGUgPT0gdXNlZFRpbGVDYWNoZSA/IHVzZWRUaWxlcyA6IHt9KTtcbiAgICBmb3IgKHZhciBpZCBpbiB0aGlzLnRpbGVDYWNoZUZvclByb2plY3Rpb24pIHtcbiAgICAgIHZhciB0aWxlQ2FjaGUgPSB0aGlzLnRpbGVDYWNoZUZvclByb2plY3Rpb25baWRdO1xuICAgICAgdGlsZUNhY2hlLmV4cGlyZUNhY2hlKHRpbGVDYWNoZSA9PSB1c2VkVGlsZUNhY2hlID8gdXNlZFRpbGVzIDoge30pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIFRpbGVJbWFnZS5wcm90b3R5cGUuZ2V0R3V0dGVyRm9yUHJvamVjdGlvbiA9IGZ1bmN0aW9uIGdldEd1dHRlckZvclByb2plY3Rpb24gKHByb2plY3Rpb24pIHtcbiAgICBpZiAoRU5BQkxFX1JBU1RFUl9SRVBST0pFQ1RJT04gJiZcbiAgICAgICAgdGhpcy5nZXRQcm9qZWN0aW9uKCkgJiYgcHJvamVjdGlvbiAmJiAhZXF1aXZhbGVudCh0aGlzLmdldFByb2plY3Rpb24oKSwgcHJvamVjdGlvbikpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRHdXR0ZXIoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gR3V0dGVyLlxuICAgKi9cbiAgVGlsZUltYWdlLnByb3RvdHlwZS5nZXRHdXR0ZXIgPSBmdW5jdGlvbiBnZXRHdXR0ZXIgKCkge1xuICAgIHJldHVybiAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgVGlsZUltYWdlLnByb3RvdHlwZS5nZXRPcGFxdWUgPSBmdW5jdGlvbiBnZXRPcGFxdWUgKHByb2plY3Rpb24pIHtcbiAgICBpZiAoRU5BQkxFX1JBU1RFUl9SRVBST0pFQ1RJT04gJiZcbiAgICAgICAgdGhpcy5nZXRQcm9qZWN0aW9uKCkgJiYgcHJvamVjdGlvbiAmJiAhZXF1aXZhbGVudCh0aGlzLmdldFByb2plY3Rpb24oKSwgcHJvamVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFVybFRpbGUucHJvdG90eXBlLmdldE9wYXF1ZS5jYWxsKHRoaXMsIHByb2plY3Rpb24pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIFRpbGVJbWFnZS5wcm90b3R5cGUuZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uID0gZnVuY3Rpb24gZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uJDEgKHByb2plY3Rpb24pIHtcbiAgICBpZiAoIUVOQUJMRV9SQVNURVJfUkVQUk9KRUNUSU9OKSB7XG4gICAgICByZXR1cm4gVXJsVGlsZS5wcm90b3R5cGUuZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uLmNhbGwodGhpcywgcHJvamVjdGlvbik7XG4gICAgfVxuICAgIHZhciB0aGlzUHJvaiA9IHRoaXMuZ2V0UHJvamVjdGlvbigpO1xuICAgIGlmICh0aGlzLnRpbGVHcmlkICYmICghdGhpc1Byb2ogfHwgZXF1aXZhbGVudCh0aGlzUHJvaiwgcHJvamVjdGlvbikpKSB7XG4gICAgICByZXR1cm4gdGhpcy50aWxlR3JpZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHByb2pLZXkgPSBnZXRVaWQocHJvamVjdGlvbik7XG4gICAgICBpZiAoIShwcm9qS2V5IGluIHRoaXMudGlsZUdyaWRGb3JQcm9qZWN0aW9uKSkge1xuICAgICAgICB0aGlzLnRpbGVHcmlkRm9yUHJvamVjdGlvbltwcm9qS2V5XSA9IGdldFRpbGVHcmlkRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoXG4gICAgICAgIC8qKiBAdHlwZSB7IWltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9ICovICh0aGlzLnRpbGVHcmlkRm9yUHJvamVjdGlvbltwcm9qS2V5XSlcbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgVGlsZUltYWdlLnByb3RvdHlwZS5nZXRUaWxlQ2FjaGVGb3JQcm9qZWN0aW9uID0gZnVuY3Rpb24gZ2V0VGlsZUNhY2hlRm9yUHJvamVjdGlvbiAocHJvamVjdGlvbikge1xuICAgIGlmICghRU5BQkxFX1JBU1RFUl9SRVBST0pFQ1RJT04pIHtcbiAgICAgIHJldHVybiBVcmxUaWxlLnByb3RvdHlwZS5nZXRUaWxlQ2FjaGVGb3JQcm9qZWN0aW9uLmNhbGwodGhpcywgcHJvamVjdGlvbik7XG4gICAgfVxuICAgIHZhciB0aGlzUHJvaiA9IHRoaXMuZ2V0UHJvamVjdGlvbigpOyBpZiAoIXRoaXNQcm9qIHx8IGVxdWl2YWxlbnQodGhpc1Byb2osIHByb2plY3Rpb24pKSB7XG4gICAgICByZXR1cm4gdGhpcy50aWxlQ2FjaGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwcm9qS2V5ID0gZ2V0VWlkKHByb2plY3Rpb24pO1xuICAgICAgaWYgKCEocHJvaktleSBpbiB0aGlzLnRpbGVDYWNoZUZvclByb2plY3Rpb24pKSB7XG4gICAgICAgIHRoaXMudGlsZUNhY2hlRm9yUHJvamVjdGlvbltwcm9qS2V5XSA9IG5ldyBUaWxlQ2FjaGUodGhpcy50aWxlQ2FjaGUuaGlnaFdhdGVyTWFyayk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy50aWxlQ2FjaGVGb3JQcm9qZWN0aW9uW3Byb2pLZXldO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHogVGlsZSBjb29yZGluYXRlIHouXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFRpbGUgY29vcmRpbmF0ZSB4LlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBUaWxlIGNvb3JkaW5hdGUgeS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IHNldCBvbiB0aGUgdGlsZS5cbiAgICogQHJldHVybiB7IWltcG9ydChcIi4uL1RpbGUuanNcIikuZGVmYXVsdH0gVGlsZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFRpbGVJbWFnZS5wcm90b3R5cGUuY3JlYXRlVGlsZV8gPSBmdW5jdGlvbiBjcmVhdGVUaWxlXyAoeiwgeCwgeSwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbiwga2V5KSB7XG4gICAgdmFyIHRpbGVDb29yZCA9IFt6LCB4LCB5XTtcbiAgICB2YXIgdXJsVGlsZUNvb3JkID0gdGhpcy5nZXRUaWxlQ29vcmRGb3JUaWxlVXJsRnVuY3Rpb24oXG4gICAgICB0aWxlQ29vcmQsIHByb2plY3Rpb24pO1xuICAgIHZhciB0aWxlVXJsID0gdXJsVGlsZUNvb3JkID9cbiAgICAgIHRoaXMudGlsZVVybEZ1bmN0aW9uKHVybFRpbGVDb29yZCwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbikgOiB1bmRlZmluZWQ7XG4gICAgdmFyIHRpbGUgPSBuZXcgdGhpcy50aWxlQ2xhc3MoXG4gICAgICB0aWxlQ29vcmQsXG4gICAgICB0aWxlVXJsICE9PSB1bmRlZmluZWQgPyBUaWxlU3RhdGUuSURMRSA6IFRpbGVTdGF0ZS5FTVBUWSxcbiAgICAgIHRpbGVVcmwgIT09IHVuZGVmaW5lZCA/IHRpbGVVcmwgOiAnJyxcbiAgICAgIHRoaXMuY3Jvc3NPcmlnaW4sXG4gICAgICB0aGlzLnRpbGVMb2FkRnVuY3Rpb24sXG4gICAgICB0aGlzLnRpbGVPcHRpb25zKTtcbiAgICB0aWxlLmtleSA9IGtleTtcbiAgICBsaXN0ZW4odGlsZSwgRXZlbnRUeXBlLkNIQU5HRSxcbiAgICAgIHRoaXMuaGFuZGxlVGlsZUNoYW5nZSwgdGhpcyk7XG4gICAgcmV0dXJuIHRpbGU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBUaWxlSW1hZ2UucHJvdG90eXBlLmdldFRpbGUgPSBmdW5jdGlvbiBnZXRUaWxlICh6LCB4LCB5LCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKSB7XG4gICAgdmFyIHNvdXJjZVByb2plY3Rpb24gPSAvKiogQHR5cGUgeyFpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gKi8gKHRoaXMuZ2V0UHJvamVjdGlvbigpKTtcbiAgICBpZiAoIUVOQUJMRV9SQVNURVJfUkVQUk9KRUNUSU9OIHx8XG4gICAgICAgICFzb3VyY2VQcm9qZWN0aW9uIHx8ICFwcm9qZWN0aW9uIHx8IGVxdWl2YWxlbnQoc291cmNlUHJvamVjdGlvbiwgcHJvamVjdGlvbikpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFRpbGVJbnRlcm5hbCh6LCB4LCB5LCBwaXhlbFJhdGlvLCBzb3VyY2VQcm9qZWN0aW9uIHx8IHByb2plY3Rpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY2FjaGUgPSB0aGlzLmdldFRpbGVDYWNoZUZvclByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gICAgICB2YXIgdGlsZUNvb3JkID0gW3osIHgsIHldO1xuICAgICAgdmFyIHRpbGU7XG4gICAgICB2YXIgdGlsZUNvb3JkS2V5ID0gZ2V0S2V5KHRpbGVDb29yZCk7XG4gICAgICBpZiAoY2FjaGUuY29udGFpbnNLZXkodGlsZUNvb3JkS2V5KSkge1xuICAgICAgICB0aWxlID0gLyoqIEB0eXBlIHshaW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5kZWZhdWx0fSAqLyAoY2FjaGUuZ2V0KHRpbGVDb29yZEtleSkpO1xuICAgICAgfVxuICAgICAgdmFyIGtleSA9IHRoaXMuZ2V0S2V5KCk7XG4gICAgICBpZiAodGlsZSAmJiB0aWxlLmtleSA9PSBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRpbGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc291cmNlVGlsZUdyaWQgPSB0aGlzLmdldFRpbGVHcmlkRm9yUHJvamVjdGlvbihzb3VyY2VQcm9qZWN0aW9uKTtcbiAgICAgICAgdmFyIHRhcmdldFRpbGVHcmlkID0gdGhpcy5nZXRUaWxlR3JpZEZvclByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gICAgICAgIHZhciB3cmFwcGVkVGlsZUNvb3JkID1cbiAgICAgICAgICAgIHRoaXMuZ2V0VGlsZUNvb3JkRm9yVGlsZVVybEZ1bmN0aW9uKHRpbGVDb29yZCwgcHJvamVjdGlvbik7XG4gICAgICAgIHZhciBuZXdUaWxlID0gbmV3IFJlcHJvalRpbGUoXG4gICAgICAgICAgc291cmNlUHJvamVjdGlvbiwgc291cmNlVGlsZUdyaWQsXG4gICAgICAgICAgcHJvamVjdGlvbiwgdGFyZ2V0VGlsZUdyaWQsXG4gICAgICAgICAgdGlsZUNvb3JkLCB3cmFwcGVkVGlsZUNvb3JkLCB0aGlzLmdldFRpbGVQaXhlbFJhdGlvKHBpeGVsUmF0aW8pLFxuICAgICAgICAgIHRoaXMuZ2V0R3V0dGVyKCksXG4gICAgICAgICAgZnVuY3Rpb24oeiwgeCwgeSwgcGl4ZWxSYXRpbykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGlsZUludGVybmFsKHosIHgsIHksIHBpeGVsUmF0aW8sIHNvdXJjZVByb2plY3Rpb24pO1xuICAgICAgICAgIH0uYmluZCh0aGlzKSwgdGhpcy5yZXByb2plY3Rpb25FcnJvclRocmVzaG9sZF8sXG4gICAgICAgICAgdGhpcy5yZW5kZXJSZXByb2plY3Rpb25FZGdlc18pO1xuICAgICAgICBuZXdUaWxlLmtleSA9IGtleTtcblxuICAgICAgICBpZiAodGlsZSkge1xuICAgICAgICAgIG5ld1RpbGUuaW50ZXJpbVRpbGUgPSB0aWxlO1xuICAgICAgICAgIG5ld1RpbGUucmVmcmVzaEludGVyaW1DaGFpbigpO1xuICAgICAgICAgIGNhY2hlLnJlcGxhY2UodGlsZUNvb3JkS2V5LCBuZXdUaWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWNoZS5zZXQodGlsZUNvb3JkS2V5LCBuZXdUaWxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3VGlsZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6IFRpbGUgY29vcmRpbmF0ZSB6LlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBUaWxlIGNvb3JkaW5hdGUgeC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgVGlsZSBjb29yZGluYXRlIHkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcGFyYW0geyFpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgKiBAcmV0dXJuIHshaW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5kZWZhdWx0fSBUaWxlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBUaWxlSW1hZ2UucHJvdG90eXBlLmdldFRpbGVJbnRlcm5hbCA9IGZ1bmN0aW9uIGdldFRpbGVJbnRlcm5hbCAoeiwgeCwgeSwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbikge1xuICAgIHZhciB0aWxlID0gbnVsbDtcbiAgICB2YXIgdGlsZUNvb3JkS2V5ID0gZ2V0S2V5WlhZKHosIHgsIHkpO1xuICAgIHZhciBrZXkgPSB0aGlzLmdldEtleSgpO1xuICAgIGlmICghdGhpcy50aWxlQ2FjaGUuY29udGFpbnNLZXkodGlsZUNvb3JkS2V5KSkge1xuICAgICAgdGlsZSA9IHRoaXMuY3JlYXRlVGlsZV8oeiwgeCwgeSwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbiwga2V5KTtcbiAgICAgIHRoaXMudGlsZUNhY2hlLnNldCh0aWxlQ29vcmRLZXksIHRpbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aWxlID0gdGhpcy50aWxlQ2FjaGUuZ2V0KHRpbGVDb29yZEtleSk7XG4gICAgICBpZiAodGlsZS5rZXkgIT0ga2V5KSB7XG4gICAgICAgIC8vIFRoZSBzb3VyY2UncyBwYXJhbXMgY2hhbmdlZC4gSWYgdGhlIHRpbGUgaGFzIGFuIGludGVyaW0gdGlsZSBhbmQgaWYgd2VcbiAgICAgICAgLy8gY2FuIHVzZSBpdCB0aGVuIHdlIHVzZSBpdC4gT3RoZXJ3aXNlIHdlIGNyZWF0ZSBhIG5ldyB0aWxlLiAgSW4gYm90aFxuICAgICAgICAvLyBjYXNlcyB3ZSBhdHRlbXB0IHRvIGFzc2lnbiBhbiBpbnRlcmltIHRpbGUgdG8gdGhlIG5ldyB0aWxlLlxuICAgICAgICB2YXIgaW50ZXJpbVRpbGUgPSB0aWxlO1xuICAgICAgICB0aWxlID0gdGhpcy5jcmVhdGVUaWxlXyh6LCB4LCB5LCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uLCBrZXkpO1xuXG4gICAgICAgIC8vbWFrZSB0aGUgbmV3IHRpbGUgdGhlIGhlYWQgb2YgdGhlIGxpc3QsXG4gICAgICAgIGlmIChpbnRlcmltVGlsZS5nZXRTdGF0ZSgpID09IFRpbGVTdGF0ZS5JRExFKSB7XG4gICAgICAgICAgLy90aGUgb2xkIHRpbGUgaGFzbid0IGJlZ3VuIGxvYWRpbmcgeWV0LCBhbmQgaXMgbm93IG91dGRhdGVkLCBzbyB3ZSBjYW4gc2ltcGx5IGRpc2NhcmQgaXRcbiAgICAgICAgICB0aWxlLmludGVyaW1UaWxlID0gaW50ZXJpbVRpbGUuaW50ZXJpbVRpbGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGlsZS5pbnRlcmltVGlsZSA9IGludGVyaW1UaWxlO1xuICAgICAgICB9XG4gICAgICAgIHRpbGUucmVmcmVzaEludGVyaW1DaGFpbigpO1xuICAgICAgICB0aGlzLnRpbGVDYWNoZS5yZXBsYWNlKHRpbGVDb29yZEtleSwgdGlsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aWxlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIHdoZXRoZXIgdG8gcmVuZGVyIHJlcHJvamVjdGlvbiBlZGdlcyBvciBub3QgKHVzdWFsbHkgZm9yIGRlYnVnZ2luZykuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVuZGVyIFJlbmRlciB0aGUgZWRnZXMuXG4gICAqIEBhcGlcbiAgICovXG4gIFRpbGVJbWFnZS5wcm90b3R5cGUuc2V0UmVuZGVyUmVwcm9qZWN0aW9uRWRnZXMgPSBmdW5jdGlvbiBzZXRSZW5kZXJSZXByb2plY3Rpb25FZGdlcyAocmVuZGVyKSB7XG4gICAgaWYgKCFFTkFCTEVfUkFTVEVSX1JFUFJPSkVDVElPTiB8fFxuICAgICAgICB0aGlzLnJlbmRlclJlcHJvamVjdGlvbkVkZ2VzXyA9PSByZW5kZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZW5kZXJSZXByb2plY3Rpb25FZGdlc18gPSByZW5kZXI7XG4gICAgZm9yICh2YXIgaWQgaW4gdGhpcy50aWxlQ2FjaGVGb3JQcm9qZWN0aW9uKSB7XG4gICAgICB0aGlzLnRpbGVDYWNoZUZvclByb2plY3Rpb25baWRdLmNsZWFyKCk7XG4gICAgfVxuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0aWxlIGdyaWQgdG8gdXNlIHdoZW4gcmVwcm9qZWN0aW5nIHRoZSB0aWxlcyB0byB0aGUgZ2l2ZW5cbiAgICogcHJvamVjdGlvbiBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IHRpbGUgZ3JpZCBmb3IgdGhlIHByb2plY3Rpb24uXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuIHRoZSBkZWZhdWx0IHRpbGUgZ3JpZCBjYW5ub3QgYmUgY3JlYXRlZFxuICAgKiAoZS5nLiBwcm9qZWN0aW9uIGhhcyBubyBleHRlbnQgZGVmaW5lZCkgb3JcbiAgICogZm9yIG9wdGltaXphdGlvbiByZWFzb25zIChjdXN0b20gdGlsZSBzaXplLCByZXNvbHV0aW9ucywgLi4uKS5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qLmpzXCIpLlByb2plY3Rpb25MaWtlfSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH0gdGlsZWdyaWQgVGlsZSBncmlkIHRvIHVzZSBmb3IgdGhlIHByb2plY3Rpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIFRpbGVJbWFnZS5wcm90b3R5cGUuc2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uID0gZnVuY3Rpb24gc2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uIChwcm9qZWN0aW9uLCB0aWxlZ3JpZCkge1xuICAgIGlmIChFTkFCTEVfUkFTVEVSX1JFUFJPSkVDVElPTikge1xuICAgICAgdmFyIHByb2ogPSBnZXRQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICAgICAgaWYgKHByb2opIHtcbiAgICAgICAgdmFyIHByb2pLZXkgPSBnZXRVaWQocHJvaik7XG4gICAgICAgIGlmICghKHByb2pLZXkgaW4gdGhpcy50aWxlR3JpZEZvclByb2plY3Rpb24pKSB7XG4gICAgICAgICAgdGhpcy50aWxlR3JpZEZvclByb2plY3Rpb25bcHJvaktleV0gPSB0aWxlZ3JpZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVGlsZUltYWdlO1xufShVcmxUaWxlKSk7XG5cblxuLyoqXG4gKiBAcGFyYW0ge0ltYWdlVGlsZX0gaW1hZ2VUaWxlIEltYWdlIHRpbGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjIFNvdXJjZS5cbiAqL1xuZnVuY3Rpb24gZGVmYXVsdFRpbGVMb2FkRnVuY3Rpb24oaW1hZ2VUaWxlLCBzcmMpIHtcbiAgLyoqIEB0eXBlIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR9ICovIChpbWFnZVRpbGUuZ2V0SW1hZ2UoKSkuc3JjID0gc3JjO1xufVxuXG5leHBvcnQgZGVmYXVsdCBUaWxlSW1hZ2U7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpbGVJbWFnZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvc291cmNlL1VybFRpbGVcbiAqL1xuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4uL3V0aWwuanMnO1xuaW1wb3J0IFRpbGVTdGF0ZSBmcm9tICcuLi9UaWxlU3RhdGUuanMnO1xuaW1wb3J0IHtleHBhbmRVcmwsIGNyZWF0ZUZyb21UZW1wbGF0ZXMsIG51bGxUaWxlVXJsRnVuY3Rpb259IGZyb20gJy4uL3RpbGV1cmxmdW5jdGlvbi5qcyc7XG5pbXBvcnQgVGlsZVNvdXJjZSwge1RpbGVTb3VyY2VFdmVudH0gZnJvbSAnLi9UaWxlLmpzJztcbmltcG9ydCBUaWxlRXZlbnRUeXBlIGZyb20gJy4vVGlsZUV2ZW50VHlwZS5qcyc7XG5pbXBvcnQge2dldEtleVpYWX0gZnJvbSAnLi4vdGlsZWNvb3JkLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vU291cmNlLmpzXCIpLkF0dHJpYnV0aW9uTGlrZX0gW2F0dHJpYnV0aW9uc11cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2F0dHJpYnV0aW9uc0NvbGxhcHNpYmxlPXRydWVdIEF0dHJpYnV0aW9ucyBhcmUgY29sbGFwc2libGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2NhY2hlU2l6ZV1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW29wYXF1ZV1cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gW3Byb2plY3Rpb25dXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vU3RhdGUuanNcIikuZGVmYXVsdH0gW3N0YXRlXVxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSBbdGlsZUdyaWRdXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL1RpbGUuanNcIikuTG9hZEZ1bmN0aW9ufSB0aWxlTG9hZEZ1bmN0aW9uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RpbGVQaXhlbFJhdGlvXVxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLlVybEZ1bmN0aW9ufSBbdGlsZVVybEZ1bmN0aW9uXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt1cmxdXG4gKiBAcHJvcGVydHkge0FycmF5PHN0cmluZz59IFt1cmxzXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbd3JhcFg9dHJ1ZV1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdHJhbnNpdGlvbl1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBba2V5XVxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBCYXNlIGNsYXNzIGZvciBzb3VyY2VzIHByb3ZpZGluZyB0aWxlcyBkaXZpZGVkIGludG8gYSB0aWxlIGdyaWQgb3ZlciBodHRwLlxuICpcbiAqIEBmaXJlcyBpbXBvcnQoXCIuL1RpbGUuanNcIikuVGlsZVNvdXJjZUV2ZW50XG4gKi9cbnZhciBVcmxUaWxlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoVGlsZVNvdXJjZSkge1xuICBmdW5jdGlvbiBVcmxUaWxlKG9wdGlvbnMpIHtcblxuICAgIFRpbGVTb3VyY2UuY2FsbCh0aGlzLCB7XG4gICAgICBhdHRyaWJ1dGlvbnM6IG9wdGlvbnMuYXR0cmlidXRpb25zLFxuICAgICAgY2FjaGVTaXplOiBvcHRpb25zLmNhY2hlU2l6ZSxcbiAgICAgIG9wYXF1ZTogb3B0aW9ucy5vcGFxdWUsXG4gICAgICBwcm9qZWN0aW9uOiBvcHRpb25zLnByb2plY3Rpb24sXG4gICAgICBzdGF0ZTogb3B0aW9ucy5zdGF0ZSxcbiAgICAgIHRpbGVHcmlkOiBvcHRpb25zLnRpbGVHcmlkLFxuICAgICAgdGlsZVBpeGVsUmF0aW86IG9wdGlvbnMudGlsZVBpeGVsUmF0aW8sXG4gICAgICB3cmFwWDogb3B0aW9ucy53cmFwWCxcbiAgICAgIHRyYW5zaXRpb246IG9wdGlvbnMudHJhbnNpdGlvbixcbiAgICAgIGtleTogb3B0aW9ucy5rZXksXG4gICAgICBhdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZTogb3B0aW9ucy5hdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmdlbmVyYXRlVGlsZVVybEZ1bmN0aW9uXyA9ICFvcHRpb25zLnRpbGVVcmxGdW5jdGlvbjtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5Mb2FkRnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy50aWxlTG9hZEZ1bmN0aW9uID0gb3B0aW9ucy50aWxlTG9hZEZ1bmN0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLlVybEZ1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMudGlsZVVybEZ1bmN0aW9uID0gb3B0aW9ucy50aWxlVXJsRnVuY3Rpb24gPyBvcHRpb25zLnRpbGVVcmxGdW5jdGlvbi5iaW5kKHRoaXMpIDogbnVsbFRpbGVVcmxGdW5jdGlvbjtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7IUFycmF5PHN0cmluZz58bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnVybHMgPSBudWxsO1xuXG4gICAgaWYgKG9wdGlvbnMudXJscykge1xuICAgICAgdGhpcy5zZXRVcmxzKG9wdGlvbnMudXJscyk7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnVybCkge1xuICAgICAgdGhpcy5zZXRVcmwob3B0aW9ucy51cmwpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnRpbGVVcmxGdW5jdGlvbikge1xuICAgICAgdGhpcy5zZXRUaWxlVXJsRnVuY3Rpb24ob3B0aW9ucy50aWxlVXJsRnVuY3Rpb24sIHRoaXMua2V5Xyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIGJvb2xlYW4+fVxuICAgICAqL1xuICAgIHRoaXMudGlsZUxvYWRpbmdLZXlzXyA9IHt9O1xuXG4gIH1cblxuICBpZiAoIFRpbGVTb3VyY2UgKSBVcmxUaWxlLl9fcHJvdG9fXyA9IFRpbGVTb3VyY2U7XG4gIFVybFRpbGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVGlsZVNvdXJjZSAmJiBUaWxlU291cmNlLnByb3RvdHlwZSApO1xuICBVcmxUaWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFVybFRpbGU7XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgdGlsZSBsb2FkIGZ1bmN0aW9uIG9mIHRoZSBzb3VyY2UuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL1RpbGUuanNcIikuTG9hZEZ1bmN0aW9ufSBUaWxlTG9hZEZ1bmN0aW9uXG4gICAqIEBhcGlcbiAgICovXG4gIFVybFRpbGUucHJvdG90eXBlLmdldFRpbGVMb2FkRnVuY3Rpb24gPSBmdW5jdGlvbiBnZXRUaWxlTG9hZEZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy50aWxlTG9hZEZ1bmN0aW9uO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHRpbGUgVVJMIGZ1bmN0aW9uIG9mIHRoZSBzb3VyY2UuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL1RpbGUuanNcIikuVXJsRnVuY3Rpb259IFRpbGVVcmxGdW5jdGlvblxuICAgKiBAYXBpXG4gICAqL1xuICBVcmxUaWxlLnByb3RvdHlwZS5nZXRUaWxlVXJsRnVuY3Rpb24gPSBmdW5jdGlvbiBnZXRUaWxlVXJsRnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnRpbGVVcmxGdW5jdGlvbjtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBVUkxzIHVzZWQgZm9yIHRoaXMgc291cmNlLlxuICAgKiBXaGVuIGEgdGlsZVVybEZ1bmN0aW9uIGlzIHVzZWQgaW5zdGVhZCBvZiB1cmwgb3IgdXJscyxcbiAgICogbnVsbCB3aWxsIGJlIHJldHVybmVkLlxuICAgKiBAcmV0dXJuIHshQXJyYXk8c3RyaW5nPnxudWxsfSBVUkxzLlxuICAgKiBAYXBpXG4gICAqL1xuICBVcmxUaWxlLnByb3RvdHlwZS5nZXRVcmxzID0gZnVuY3Rpb24gZ2V0VXJscyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudXJscztcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIHRpbGUgY2hhbmdlIGV2ZW50cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdH0gZXZlbnQgRXZlbnQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIFVybFRpbGUucHJvdG90eXBlLmhhbmRsZVRpbGVDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVUaWxlQ2hhbmdlIChldmVudCkge1xuICAgIHZhciB0aWxlID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLmRlZmF1bHR9ICovIChldmVudC50YXJnZXQpO1xuICAgIHZhciB1aWQgPSBnZXRVaWQodGlsZSk7XG4gICAgdmFyIHRpbGVTdGF0ZSA9IHRpbGUuZ2V0U3RhdGUoKTtcbiAgICB2YXIgdHlwZTtcbiAgICBpZiAodGlsZVN0YXRlID09IFRpbGVTdGF0ZS5MT0FESU5HKSB7XG4gICAgICB0aGlzLnRpbGVMb2FkaW5nS2V5c19bdWlkXSA9IHRydWU7XG4gICAgICB0eXBlID0gVGlsZUV2ZW50VHlwZS5USUxFTE9BRFNUQVJUO1xuICAgIH0gZWxzZSBpZiAodWlkIGluIHRoaXMudGlsZUxvYWRpbmdLZXlzXykge1xuICAgICAgZGVsZXRlIHRoaXMudGlsZUxvYWRpbmdLZXlzX1t1aWRdO1xuICAgICAgdHlwZSA9IHRpbGVTdGF0ZSA9PSBUaWxlU3RhdGUuRVJST1IgPyBUaWxlRXZlbnRUeXBlLlRJTEVMT0FERVJST1IgOlxuICAgICAgICAodGlsZVN0YXRlID09IFRpbGVTdGF0ZS5MT0FERUQgfHwgdGlsZVN0YXRlID09IFRpbGVTdGF0ZS5BQk9SVCkgP1xuICAgICAgICAgIFRpbGVFdmVudFR5cGUuVElMRUxPQURFTkQgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICh0eXBlICE9IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBUaWxlU291cmNlRXZlbnQodHlwZSwgdGlsZSkpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSB0aWxlIGxvYWQgZnVuY3Rpb24gb2YgdGhlIHNvdXJjZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLkxvYWRGdW5jdGlvbn0gdGlsZUxvYWRGdW5jdGlvbiBUaWxlIGxvYWQgZnVuY3Rpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIFVybFRpbGUucHJvdG90eXBlLnNldFRpbGVMb2FkRnVuY3Rpb24gPSBmdW5jdGlvbiBzZXRUaWxlTG9hZEZ1bmN0aW9uICh0aWxlTG9hZEZ1bmN0aW9uKSB7XG4gICAgdGhpcy50aWxlQ2FjaGUuY2xlYXIoKTtcbiAgICB0aGlzLnRpbGVMb2FkRnVuY3Rpb24gPSB0aWxlTG9hZEZ1bmN0aW9uO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRpbGUgVVJMIGZ1bmN0aW9uIG9mIHRoZSBzb3VyY2UuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5VcmxGdW5jdGlvbn0gdGlsZVVybEZ1bmN0aW9uIFRpbGUgVVJMIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IGtleSBPcHRpb25hbCBuZXcgdGlsZSBrZXkgZm9yIHRoZSBzb3VyY2UuXG4gICAqIEBhcGlcbiAgICovXG4gIFVybFRpbGUucHJvdG90eXBlLnNldFRpbGVVcmxGdW5jdGlvbiA9IGZ1bmN0aW9uIHNldFRpbGVVcmxGdW5jdGlvbiAodGlsZVVybEZ1bmN0aW9uLCBrZXkpIHtcbiAgICB0aGlzLnRpbGVVcmxGdW5jdGlvbiA9IHRpbGVVcmxGdW5jdGlvbjtcbiAgICB0aGlzLnRpbGVDYWNoZS5wcnVuZUV4Y2VwdE5ld2VzdFooKTtcbiAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuc2V0S2V5KGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBVUkwgdG8gdXNlIGZvciByZXF1ZXN0cy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBVUkwuXG4gICAqIEBhcGlcbiAgICovXG4gIFVybFRpbGUucHJvdG90eXBlLnNldFVybCA9IGZ1bmN0aW9uIHNldFVybCAodXJsKSB7XG4gICAgdmFyIHVybHMgPSB0aGlzLnVybHMgPSBleHBhbmRVcmwodXJsKTtcbiAgICB0aGlzLnNldFVybHModXJscyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgVVJMcyB0byB1c2UgZm9yIHJlcXVlc3RzLlxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHVybHMgVVJMcy5cbiAgICogQGFwaVxuICAgKi9cbiAgVXJsVGlsZS5wcm90b3R5cGUuc2V0VXJscyA9IGZ1bmN0aW9uIHNldFVybHMgKHVybHMpIHtcbiAgICB0aGlzLnVybHMgPSB1cmxzO1xuICAgIHZhciBrZXkgPSB1cmxzLmpvaW4oJ1xcbicpO1xuICAgIGlmICh0aGlzLmdlbmVyYXRlVGlsZVVybEZ1bmN0aW9uXykge1xuICAgICAgdGhpcy5zZXRUaWxlVXJsRnVuY3Rpb24oY3JlYXRlRnJvbVRlbXBsYXRlcyh1cmxzLCB0aGlzLnRpbGVHcmlkKSwga2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRLZXkoa2V5KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBVcmxUaWxlLnByb3RvdHlwZS51c2VUaWxlID0gZnVuY3Rpb24gdXNlVGlsZSAoeiwgeCwgeSkge1xuICAgIHZhciB0aWxlQ29vcmRLZXkgPSBnZXRLZXlaWFkoeiwgeCwgeSk7XG4gICAgaWYgKHRoaXMudGlsZUNhY2hlLmNvbnRhaW5zS2V5KHRpbGVDb29yZEtleSkpIHtcbiAgICAgIHRoaXMudGlsZUNhY2hlLmdldCh0aWxlQ29vcmRLZXkpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVXJsVGlsZTtcbn0oVGlsZVNvdXJjZSkpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IFVybFRpbGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVVybFRpbGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3NvdXJjZS9WZWN0b3JcbiAqL1xuXG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5pbXBvcnQgQ29sbGVjdGlvbiBmcm9tICcuLi9Db2xsZWN0aW9uLmpzJztcbmltcG9ydCBDb2xsZWN0aW9uRXZlbnRUeXBlIGZyb20gJy4uL0NvbGxlY3Rpb25FdmVudFR5cGUuanMnO1xuaW1wb3J0IE9iamVjdEV2ZW50VHlwZSBmcm9tICcuLi9PYmplY3RFdmVudFR5cGUuanMnO1xuaW1wb3J0IHtleHRlbmR9IGZyb20gJy4uL2FycmF5LmpzJztcbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuLi9hc3NlcnRzLmpzJztcbmltcG9ydCB7bGlzdGVuLCB1bmxpc3RlbkJ5S2V5fSBmcm9tICcuLi9ldmVudHMuanMnO1xuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cy9FdmVudC5qcyc7XG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4uL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IHtjb250YWluc0V4dGVudCwgZXF1YWxzfSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IHt4aHJ9IGZyb20gJy4uL2ZlYXR1cmVsb2FkZXIuanMnO1xuaW1wb3J0IHtUUlVFLCBWT0lEfSBmcm9tICcuLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IHthbGwgYXMgYWxsU3RyYXRlZ3l9IGZyb20gJy4uL2xvYWRpbmdzdHJhdGVneS5qcyc7XG5pbXBvcnQge2lzRW1wdHksIGdldFZhbHVlc30gZnJvbSAnLi4vb2JqLmpzJztcbmltcG9ydCBTb3VyY2UgZnJvbSAnLi9Tb3VyY2UuanMnO1xuaW1wb3J0IFNvdXJjZVN0YXRlIGZyb20gJy4vU3RhdGUuanMnO1xuaW1wb3J0IFZlY3RvckV2ZW50VHlwZSBmcm9tICcuL1ZlY3RvckV2ZW50VHlwZS5qcyc7XG5pbXBvcnQgUkJ1c2ggZnJvbSAnLi4vc3RydWN0cy9SQnVzaC5qcyc7XG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gYW5kIGEgcmVzb2x1dGlvbiBhcyBhcmd1bWVudHMsIGFuZFxuICogcmV0dXJucyBhbiBhcnJheSBvZiB7QGxpbmsgbW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IHdpdGggdGhlIGV4dGVudHMgdG8gbG9hZC4gVXN1YWxseSB0aGlzXG4gKiBpcyBvbmUgb2YgdGhlIHN0YW5kYXJkIHtAbGluayBtb2R1bGU6b2wvbG9hZGluZ3N0cmF0ZWd5fSBzdHJhdGVnaWVzLlxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50LCBudW1iZXIpOiBBcnJheTxpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50Pn0gTG9hZGluZ1N0cmF0ZWd5XG4gKiBAYXBpXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEV2ZW50cyBlbWl0dGVkIGJ5IHtAbGluayBtb2R1bGU6b2wvc291cmNlL1ZlY3Rvcn0gaW5zdGFuY2VzIGFyZSBpbnN0YW5jZXMgb2YgdGhpc1xuICogdHlwZS5cbiAqL1xuZXhwb3J0IHZhciBWZWN0b3JTb3VyY2VFdmVudCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEV2ZW50KSB7XG4gIGZ1bmN0aW9uIFZlY3RvclNvdXJjZUV2ZW50KHR5cGUsIG9wdF9mZWF0dXJlKSB7XG5cbiAgICBFdmVudC5jYWxsKHRoaXMsIHR5cGUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZlYXR1cmUgYmVpbmcgYWRkZWQgb3IgcmVtb3ZlZC5cbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fHVuZGVmaW5lZH1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5mZWF0dXJlID0gb3B0X2ZlYXR1cmU7XG5cbiAgfVxuXG4gIGlmICggRXZlbnQgKSBWZWN0b3JTb3VyY2VFdmVudC5fX3Byb3RvX18gPSBFdmVudDtcbiAgVmVjdG9yU291cmNlRXZlbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXZlbnQgJiYgRXZlbnQucHJvdG90eXBlICk7XG4gIFZlY3RvclNvdXJjZUV2ZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFZlY3RvclNvdXJjZUV2ZW50O1xuXG4gIHJldHVybiBWZWN0b3JTb3VyY2VFdmVudDtcbn0oRXZlbnQpKTtcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9Tb3VyY2UuanNcIikuQXR0cmlidXRpb25MaWtlfSBbYXR0cmlidXRpb25zXSBBdHRyaWJ1dGlvbnMuXG4gKiBAcHJvcGVydHkge0FycmF5PGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD58Q29sbGVjdGlvbjxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fSBbZmVhdHVyZXNdXG4gKiBGZWF0dXJlcy4gSWYgcHJvdmlkZWQgYXMge0BsaW5rIG1vZHVsZTpvbC9Db2xsZWN0aW9ufSwgdGhlIGZlYXR1cmVzIGluIHRoZSBzb3VyY2VcbiAqIGFuZCB0aGUgY29sbGVjdGlvbiB3aWxsIHN0YXkgaW4gc3luYy5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZm9ybWF0L0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gW2Zvcm1hdF0gVGhlIGZlYXR1cmUgZm9ybWF0IHVzZWQgYnkgdGhlIFhIUlxuICogZmVhdHVyZSBsb2FkZXIgd2hlbiBgdXJsYCBpcyBzZXQuIFJlcXVpcmVkIGlmIGB1cmxgIGlzIHNldCwgb3RoZXJ3aXNlIGlnbm9yZWQuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2ZlYXR1cmVsb2FkZXIuanNcIikuRmVhdHVyZUxvYWRlcn0gW2xvYWRlcl1cbiAqIFRoZSBsb2FkZXIgZnVuY3Rpb24gdXNlZCB0byBsb2FkIGZlYXR1cmVzLCBmcm9tIGEgcmVtb3RlIHNvdXJjZSBmb3IgZXhhbXBsZS5cbiAqIElmIHRoaXMgaXMgbm90IHNldCBhbmQgYHVybGAgaXMgc2V0LCB0aGUgc291cmNlIHdpbGwgY3JlYXRlIGFuZCB1c2UgYW4gWEhSXG4gKiBmZWF0dXJlIGxvYWRlci5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiBpbXBvcnQge1ZlY3Rvcn0gZnJvbSAnb2wvc291cmNlJztcbiAqIGltcG9ydCB7R2VvSlNPTn0gZnJvbSAnb2wvZm9ybWF0JztcbiAqIGltcG9ydCB7YmJveH0gZnJvbSAnb2wvbG9hZGluZ3N0cmF0ZWd5JztcbiAqXG4gKiB2YXIgdmVjdG9yU291cmNlID0gbmV3IFZlY3Rvcih7XG4gKiAgIGZvcm1hdDogbmV3IEdlb0pTT04oKSxcbiAqICAgbG9hZGVyOiBmdW5jdGlvbihleHRlbnQsIHJlc29sdXRpb24sIHByb2plY3Rpb24pIHtcbiAqICAgICAgdmFyIHByb2ogPSBwcm9qZWN0aW9uLmdldENvZGUoKTtcbiAqICAgICAgdmFyIHVybCA9ICdodHRwczovL2Fob2NldmFyLmNvbS9nZW9zZXJ2ZXIvd2ZzP3NlcnZpY2U9V0ZTJicgK1xuICogICAgICAgICAgJ3ZlcnNpb249MS4xLjAmcmVxdWVzdD1HZXRGZWF0dXJlJnR5cGVuYW1lPW9zbTp3YXRlcl9hcmVhcyYnICtcbiAqICAgICAgICAgICdvdXRwdXRGb3JtYXQ9YXBwbGljYXRpb24vanNvbiZzcnNuYW1lPScgKyBwcm9qICsgJyYnICtcbiAqICAgICAgICAgICdiYm94PScgKyBleHRlbnQuam9pbignLCcpICsgJywnICsgcHJvajtcbiAqICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICogICAgICB4aHIub3BlbignR0VUJywgdXJsKTtcbiAqICAgICAgdmFyIG9uRXJyb3IgPSBmdW5jdGlvbigpIHtcbiAqICAgICAgICB2ZWN0b3JTb3VyY2UucmVtb3ZlTG9hZGVkRXh0ZW50KGV4dGVudCk7XG4gKiAgICAgIH1cbiAqICAgICAgeGhyLm9uZXJyb3IgPSBvbkVycm9yO1xuICogICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgaWYgKHhoci5zdGF0dXMgPT0gMjAwKSB7XG4gKiAgICAgICAgICB2ZWN0b3JTb3VyY2UuYWRkRmVhdHVyZXMoXG4gKiAgICAgICAgICAgICAgdmVjdG9yU291cmNlLmdldEZvcm1hdCgpLnJlYWRGZWF0dXJlcyh4aHIucmVzcG9uc2VUZXh0KSk7XG4gKiAgICAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgIG9uRXJyb3IoKTtcbiAqICAgICAgICB9XG4gKiAgICAgIH1cbiAqICAgICAgeGhyLnNlbmQoKTtcbiAqICAgIH0sXG4gKiAgICBzdHJhdGVneTogYmJveFxuICogIH0pO1xuICogYGBgXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtvdmVybGFwcz10cnVlXSBUaGlzIHNvdXJjZSBtYXkgaGF2ZSBvdmVybGFwcGluZyBnZW9tZXRyaWVzLlxuICogU2V0dGluZyB0aGlzIHRvIGBmYWxzZWAgKGUuZy4gZm9yIHNvdXJjZXMgd2l0aCBwb2x5Z29ucyB0aGF0IHJlcHJlc2VudCBhZG1pbmlzdHJhdGl2ZVxuICogYm91bmRhcmllcyBvciBUb3BvSlNPTiBzb3VyY2VzKSBhbGxvd3MgdGhlIHJlbmRlcmVyIHRvIG9wdGltaXNlIGZpbGwgYW5kXG4gKiBzdHJva2Ugb3BlcmF0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7TG9hZGluZ1N0cmF0ZWd5fSBbc3RyYXRlZ3ldIFRoZSBsb2FkaW5nIHN0cmF0ZWd5IHRvIHVzZS5cbiAqIEJ5IGRlZmF1bHQgYW4ge0BsaW5rIG1vZHVsZTpvbC9sb2FkaW5nc3RyYXRlZ3l+YWxsfVxuICogc3RyYXRlZ3kgaXMgdXNlZCwgYSBvbmUtb2ZmIHN0cmF0ZWd5IHdoaWNoIGxvYWRzIGFsbCBmZWF0dXJlcyBhdCBvbmNlLlxuICogQHByb3BlcnR5IHtzdHJpbmd8aW1wb3J0KFwiLi4vZmVhdHVyZWxvYWRlci5qc1wiKS5GZWF0dXJlVXJsRnVuY3Rpb259IFt1cmxdXG4gKiBTZXR0aW5nIHRoaXMgb3B0aW9uIGluc3RydWN0cyB0aGUgc291cmNlIHRvIGxvYWQgZmVhdHVyZXMgdXNpbmcgYW4gWEhSIGxvYWRlclxuICogKHNlZSB7QGxpbmsgbW9kdWxlOm9sL2ZlYXR1cmVsb2FkZXJ+eGhyfSkuIFVzZSBhIGBzdHJpbmdgIGFuZCBhblxuICoge0BsaW5rIG1vZHVsZTpvbC9sb2FkaW5nc3RyYXRlZ3l+YWxsfSBmb3IgYSBvbmUtb2ZmIGRvd25sb2FkIG9mIGFsbCBmZWF0dXJlcyBmcm9tXG4gKiB0aGUgZ2l2ZW4gVVJMLiBVc2UgYSB7QGxpbmsgbW9kdWxlOm9sL2ZlYXR1cmVsb2FkZXJ+RmVhdHVyZVVybEZ1bmN0aW9ufSB0byBnZW5lcmF0ZSB0aGUgdXJsIHdpdGhcbiAqIG90aGVyIGxvYWRpbmcgc3RyYXRlZ2llcy5cbiAqIFJlcXVpcmVzIGBmb3JtYXRgIHRvIGJlIHNldCBhcyB3ZWxsLlxuICogV2hlbiBkZWZhdWx0IFhIUiBmZWF0dXJlIGxvYWRlciBpcyBwcm92aWRlZCwgdGhlIGZlYXR1cmVzIHdpbGxcbiAqIGJlIHRyYW5zZm9ybWVkIGZyb20gdGhlIGRhdGEgcHJvamVjdGlvbiB0byB0aGUgdmlldyBwcm9qZWN0aW9uXG4gKiBkdXJpbmcgcGFyc2luZy4gSWYgeW91ciByZW1vdGUgZGF0YSBzb3VyY2UgZG9lcyBub3QgYWR2ZXJ0aXNlIGl0cyBwcm9qZWN0aW9uXG4gKiBwcm9wZXJseSwgdGhpcyB0cmFuc2Zvcm1hdGlvbiB3aWxsIGJlIGluY29ycmVjdC4gRm9yIHNvbWUgZm9ybWF0cywgdGhlXG4gKiBkZWZhdWx0IHByb2plY3Rpb24gKHVzdWFsbHkgRVBTRzo0MzI2KSBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzZXR0aW5nIHRoZVxuICogZGF0YVByb2plY3Rpb24gY29uc3RydWN0b3Igb3B0aW9uIG9uIHRoZSBmb3JtYXQuXG4gKiBOb3RlIHRoYXQgaWYgYSBzb3VyY2UgY29udGFpbnMgbm9uLWZlYXR1cmUgZGF0YSwgc3VjaCBhcyBhIEdlb0pTT04gZ2VvbWV0cnlcbiAqIG9yIGEgS01MIE5ldHdvcmtMaW5rLCB0aGVzZSB3aWxsIGJlIGlnbm9yZWQuIFVzZSBhIGN1c3RvbSBsb2FkZXIgdG8gbG9hZCB0aGVzZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3VzZVNwYXRpYWxJbmRleD10cnVlXVxuICogQnkgZGVmYXVsdCwgYW4gUlRyZWUgaXMgdXNlZCBhcyBzcGF0aWFsIGluZGV4LiBXaGVuIGZlYXR1cmVzIGFyZSByZW1vdmVkIGFuZFxuICogYWRkZWQgZnJlcXVlbnRseSwgYW5kIHRoZSB0b3RhbCBudW1iZXIgb2YgZmVhdHVyZXMgaXMgbG93LCBzZXR0aW5nIHRoaXMgdG9cbiAqIGBmYWxzZWAgbWF5IGltcHJvdmUgcGVyZm9ybWFuY2UuXG4gKlxuICogTm90ZSB0aGF0XG4gKiB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3J+VmVjdG9yU291cmNlI2dldEZlYXR1cmVzSW5FeHRlbnR9LFxuICoge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yflZlY3RvclNvdXJjZSNnZXRDbG9zZXN0RmVhdHVyZVRvQ29vcmRpbmF0ZX0gYW5kXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3J+VmVjdG9yU291cmNlI2dldEV4dGVudH0gY2Fubm90IGJlIHVzZWQgd2hlbiBgdXNlU3BhdGlhbEluZGV4YCBpc1xuICogc2V0IHRvIGBmYWxzZWAsIGFuZCB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3J+VmVjdG9yU291cmNlI2ZvckVhY2hGZWF0dXJlSW5FeHRlbnR9IHdpbGwgbG9vcFxuICogdGhyb3VnaCBhbGwgZmVhdHVyZXMuXG4gKlxuICogV2hlbiBzZXQgdG8gYGZhbHNlYCwgdGhlIGZlYXR1cmVzIHdpbGwgYmUgbWFpbnRhaW5lZCBpbiBhblxuICoge0BsaW5rIG1vZHVsZTpvbC9Db2xsZWN0aW9ufSwgd2hpY2ggY2FuIGJlIHJldHJpZXZlZCB0aHJvdWdoXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3J+VmVjdG9yU291cmNlI2dldEZlYXR1cmVzQ29sbGVjdGlvbn0uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt3cmFwWD10cnVlXSBXcmFwIHRoZSB3b3JsZCBob3Jpem9udGFsbHkuIEZvciB2ZWN0b3IgZWRpdGluZyBhY3Jvc3MgdGhlXG4gKiAtMTgwwrAgYW5kIDE4MMKwIG1lcmlkaWFucyB0byB3b3JrIHByb3Blcmx5LCB0aGlzIHNob3VsZCBiZSBzZXQgdG8gYGZhbHNlYC4gVGhlXG4gKiByZXN1bHRpbmcgZ2VvbWV0cnkgY29vcmRpbmF0ZXMgd2lsbCB0aGVuIGV4Y2VlZCB0aGUgd29ybGQgYm91bmRzLlxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBQcm92aWRlcyBhIHNvdXJjZSBvZiBmZWF0dXJlcyBmb3IgdmVjdG9yIGxheWVycy4gVmVjdG9yIGZlYXR1cmVzIHByb3ZpZGVkXG4gKiBieSB0aGlzIHNvdXJjZSBhcmUgc3VpdGFibGUgZm9yIGVkaXRpbmcuIFNlZSB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3JUaWxlflZlY3RvclRpbGV9IGZvclxuICogdmVjdG9yIGRhdGEgdGhhdCBpcyBvcHRpbWl6ZWQgZm9yIHJlbmRlcmluZy5cbiAqXG4gKiBAZmlyZXMgb2wvc291cmNlL1ZlY3Rvci5WZWN0b3JTb3VyY2VFdmVudFxuICogQGFwaVxuICovXG52YXIgVmVjdG9yU291cmNlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoU291cmNlKSB7XG4gIGZ1bmN0aW9uIFZlY3RvclNvdXJjZShvcHRfb3B0aW9ucykge1xuXG4gICAgdmFyIG9wdGlvbnMgPSBvcHRfb3B0aW9ucyB8fCB7fTtcblxuICAgIFNvdXJjZS5jYWxsKHRoaXMsIHtcbiAgICAgIGF0dHJpYnV0aW9uczogb3B0aW9ucy5hdHRyaWJ1dGlvbnMsXG4gICAgICBwcm9qZWN0aW9uOiB1bmRlZmluZWQsXG4gICAgICBzdGF0ZTogU291cmNlU3RhdGUuUkVBRFksXG4gICAgICB3cmFwWDogb3B0aW9ucy53cmFwWCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy53cmFwWCA6IHRydWVcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2ZlYXR1cmVsb2FkZXIuanNcIikuRmVhdHVyZUxvYWRlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxvYWRlcl8gPSBWT0lEO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZm9ybWF0L0ZlYXR1cmUuanNcIikuZGVmYXVsdHx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5mb3JtYXRfID0gb3B0aW9ucy5mb3JtYXQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMub3ZlcmxhcHNfID0gb3B0aW9ucy5vdmVybGFwcyA9PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0aW9ucy5vdmVybGFwcztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3N0cmluZ3xpbXBvcnQoXCIuLi9mZWF0dXJlbG9hZGVyLmpzXCIpLkZlYXR1cmVVcmxGdW5jdGlvbnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy51cmxfID0gb3B0aW9ucy51cmw7XG5cbiAgICBpZiAob3B0aW9ucy5sb2FkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5sb2FkZXJfID0gb3B0aW9ucy5sb2FkZXI7XG4gICAgfSBlbHNlIGlmICh0aGlzLnVybF8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgYXNzZXJ0KHRoaXMuZm9ybWF0XywgNyk7IC8vIGBmb3JtYXRgIG11c3QgYmUgc2V0IHdoZW4gYHVybGAgaXMgc2V0XG4gICAgICAvLyBjcmVhdGUgYSBYSFIgZmVhdHVyZSBsb2FkZXIgZm9yIFwidXJsXCIgYW5kIFwiZm9ybWF0XCJcbiAgICAgIHRoaXMubG9hZGVyXyA9IHhocih0aGlzLnVybF8sIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vZm9ybWF0L0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gKi8gKHRoaXMuZm9ybWF0XykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0xvYWRpbmdTdHJhdGVneX1cbiAgICAgKi9cbiAgICB0aGlzLnN0cmF0ZWd5XyA9IG9wdGlvbnMuc3RyYXRlZ3kgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc3RyYXRlZ3kgOiBhbGxTdHJhdGVneTtcblxuICAgIHZhciB1c2VTcGF0aWFsSW5kZXggPVxuICAgICAgICBvcHRpb25zLnVzZVNwYXRpYWxJbmRleCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy51c2VTcGF0aWFsSW5kZXggOiB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7UkJ1c2g8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn1cbiAgICAgKi9cbiAgICB0aGlzLmZlYXR1cmVzUnRyZWVfID0gdXNlU3BhdGlhbEluZGV4ID8gbmV3IFJCdXNoKCkgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7UkJ1c2g8e2V4dGVudDogaW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0+fVxuICAgICAqL1xuICAgIHRoaXMubG9hZGVkRXh0ZW50c1J0cmVlXyA9IG5ldyBSQnVzaCgpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59XG4gICAgICovXG4gICAgdGhpcy5udWxsR2VvbWV0cnlGZWF0dXJlc18gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEEgbG9va3VwIG9mIGZlYXR1cmVzIGJ5IGlkICh0aGUgcmV0dXJuIGZyb20gZmVhdHVyZS5nZXRJZCgpKS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn1cbiAgICAgKi9cbiAgICB0aGlzLmlkSW5kZXhfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBBIGxvb2t1cCBvZiBmZWF0dXJlcyB3aXRob3V0IGlkIChrZXllZCBieSBnZXRVaWQoZmVhdHVyZSkpLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fVxuICAgICAqL1xuICAgIHRoaXMudW5kZWZJZEluZGV4XyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgQXJyYXk8aW1wb3J0KFwiLi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleT4+fVxuICAgICAqL1xuICAgIHRoaXMuZmVhdHVyZUNoYW5nZUtleXNfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtDb2xsZWN0aW9uPGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59XG4gICAgICovXG4gICAgdGhpcy5mZWF0dXJlc0NvbGxlY3Rpb25fID0gbnVsbDtcblxuICAgIHZhciBjb2xsZWN0aW9uLCBmZWF0dXJlcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLmZlYXR1cmVzKSkge1xuICAgICAgZmVhdHVyZXMgPSBvcHRpb25zLmZlYXR1cmVzO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5mZWF0dXJlcykge1xuICAgICAgY29sbGVjdGlvbiA9IG9wdGlvbnMuZmVhdHVyZXM7XG4gICAgICBmZWF0dXJlcyA9IGNvbGxlY3Rpb24uZ2V0QXJyYXkoKTtcbiAgICB9XG4gICAgaWYgKCF1c2VTcGF0aWFsSW5kZXggJiYgY29sbGVjdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oZmVhdHVyZXMpO1xuICAgIH1cbiAgICBpZiAoZmVhdHVyZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5hZGRGZWF0dXJlc0ludGVybmFsKGZlYXR1cmVzKTtcbiAgICB9XG4gICAgaWYgKGNvbGxlY3Rpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5iaW5kRmVhdHVyZXNDb2xsZWN0aW9uXyhjb2xsZWN0aW9uKTtcbiAgICB9XG5cbiAgfVxuXG4gIGlmICggU291cmNlICkgVmVjdG9yU291cmNlLl9fcHJvdG9fXyA9IFNvdXJjZTtcbiAgVmVjdG9yU291cmNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFNvdXJjZSAmJiBTb3VyY2UucHJvdG90eXBlICk7XG4gIFZlY3RvclNvdXJjZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBWZWN0b3JTb3VyY2U7XG5cbiAgLyoqXG4gICAqIEFkZCBhIHNpbmdsZSBmZWF0dXJlIHRvIHRoZSBzb3VyY2UuICBJZiB5b3Ugd2FudCB0byBhZGQgYSBiYXRjaCBvZiBmZWF0dXJlc1xuICAgKiBhdCBvbmNlLCBjYWxsIHtAbGluayBtb2R1bGU6b2wvc291cmNlL1ZlY3Rvcn5WZWN0b3JTb3VyY2UjYWRkRmVhdHVyZXMgI2FkZEZlYXR1cmVzKCl9XG4gICAqIGluc3RlYWQuIEEgZmVhdHVyZSB3aWxsIG5vdCBiZSBhZGRlZCB0byB0aGUgc291cmNlIGlmIGZlYXR1cmUgd2l0aFxuICAgKiB0aGUgc2FtZSBpZCBpcyBhbHJlYWR5IHRoZXJlLiBUaGUgcmVhc29uIGZvciB0aGlzIGJlaGF2aW9yIGlzIHRvIGF2b2lkXG4gICAqIGZlYXR1cmUgZHVwbGljYXRpb24gd2hlbiB1c2luZyBiYm94IG9yIHRpbGUgbG9hZGluZyBzdHJhdGVnaWVzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlIHRvIGFkZC5cbiAgICogQGFwaVxuICAgKi9cbiAgVmVjdG9yU291cmNlLnByb3RvdHlwZS5hZGRGZWF0dXJlID0gZnVuY3Rpb24gYWRkRmVhdHVyZSAoZmVhdHVyZSkge1xuICAgIHRoaXMuYWRkRmVhdHVyZUludGVybmFsKGZlYXR1cmUpO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEFkZCBhIGZlYXR1cmUgd2l0aG91dCBmaXJpbmcgYSBgY2hhbmdlYCBldmVudC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgVmVjdG9yU291cmNlLnByb3RvdHlwZS5hZGRGZWF0dXJlSW50ZXJuYWwgPSBmdW5jdGlvbiBhZGRGZWF0dXJlSW50ZXJuYWwgKGZlYXR1cmUpIHtcbiAgICB2YXIgZmVhdHVyZUtleSA9IGdldFVpZChmZWF0dXJlKTtcblxuICAgIGlmICghdGhpcy5hZGRUb0luZGV4XyhmZWF0dXJlS2V5LCBmZWF0dXJlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc2V0dXBDaGFuZ2VFdmVudHNfKGZlYXR1cmVLZXksIGZlYXR1cmUpO1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gZmVhdHVyZS5nZXRHZW9tZXRyeSgpO1xuICAgIGlmIChnZW9tZXRyeSkge1xuICAgICAgdmFyIGV4dGVudCA9IGdlb21ldHJ5LmdldEV4dGVudCgpO1xuICAgICAgaWYgKHRoaXMuZmVhdHVyZXNSdHJlZV8pIHtcbiAgICAgICAgdGhpcy5mZWF0dXJlc1J0cmVlXy5pbnNlcnQoZXh0ZW50LCBmZWF0dXJlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5udWxsR2VvbWV0cnlGZWF0dXJlc19bZmVhdHVyZUtleV0gPSBmZWF0dXJlO1xuICAgIH1cblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgIG5ldyBWZWN0b3JTb3VyY2VFdmVudChWZWN0b3JFdmVudFR5cGUuQURERkVBVFVSRSwgZmVhdHVyZSkpO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlS2V5IFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgZmVhdHVyZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgVGhlIGZlYXR1cmUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBWZWN0b3JTb3VyY2UucHJvdG90eXBlLnNldHVwQ2hhbmdlRXZlbnRzXyA9IGZ1bmN0aW9uIHNldHVwQ2hhbmdlRXZlbnRzXyAoZmVhdHVyZUtleSwgZmVhdHVyZSkge1xuICAgIHRoaXMuZmVhdHVyZUNoYW5nZUtleXNfW2ZlYXR1cmVLZXldID0gW1xuICAgICAgbGlzdGVuKGZlYXR1cmUsIEV2ZW50VHlwZS5DSEFOR0UsXG4gICAgICAgIHRoaXMuaGFuZGxlRmVhdHVyZUNoYW5nZV8sIHRoaXMpLFxuICAgICAgbGlzdGVuKGZlYXR1cmUsIE9iamVjdEV2ZW50VHlwZS5QUk9QRVJUWUNIQU5HRSxcbiAgICAgICAgdGhpcy5oYW5kbGVGZWF0dXJlQ2hhbmdlXywgdGhpcylcbiAgICBdO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlS2V5IFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgZmVhdHVyZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgVGhlIGZlYXR1cmUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBmZWF0dXJlIGlzIFwidmFsaWRcIiwgaW4gdGhlIHNlbnNlIHRoYXQgaXQgaXMgYWxzbyBhXG4gICAqICAgICBjYW5kaWRhdGUgZm9yIGluc2VydGlvbiBpbnRvIHRoZSBSdHJlZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFZlY3RvclNvdXJjZS5wcm90b3R5cGUuYWRkVG9JbmRleF8gPSBmdW5jdGlvbiBhZGRUb0luZGV4XyAoZmVhdHVyZUtleSwgZmVhdHVyZSkge1xuICAgIHZhciB2YWxpZCA9IHRydWU7XG4gICAgdmFyIGlkID0gZmVhdHVyZS5nZXRJZCgpO1xuICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIShpZC50b1N0cmluZygpIGluIHRoaXMuaWRJbmRleF8pKSB7XG4gICAgICAgIHRoaXMuaWRJbmRleF9baWQudG9TdHJpbmcoKV0gPSBmZWF0dXJlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KCEoZmVhdHVyZUtleSBpbiB0aGlzLnVuZGVmSWRJbmRleF8pLFxuICAgICAgICAzMCk7IC8vIFRoZSBwYXNzZWQgYGZlYXR1cmVgIHdhcyBhbHJlYWR5IGFkZGVkIHRvIHRoZSBzb3VyY2VcbiAgICAgIHRoaXMudW5kZWZJZEluZGV4X1tmZWF0dXJlS2V5XSA9IGZlYXR1cmU7XG4gICAgfVxuICAgIHJldHVybiB2YWxpZDtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBBZGQgYSBiYXRjaCBvZiBmZWF0dXJlcyB0byB0aGUgc291cmNlLlxuICAgKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59IGZlYXR1cmVzIEZlYXR1cmVzIHRvIGFkZC5cbiAgICogQGFwaVxuICAgKi9cbiAgVmVjdG9yU291cmNlLnByb3RvdHlwZS5hZGRGZWF0dXJlcyA9IGZ1bmN0aW9uIGFkZEZlYXR1cmVzIChmZWF0dXJlcykge1xuICAgIHRoaXMuYWRkRmVhdHVyZXNJbnRlcm5hbChmZWF0dXJlcyk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH07XG5cblxuICAvKipcbiAgICogQWRkIGZlYXR1cmVzIHdpdGhvdXQgZmlyaW5nIGEgYGNoYW5nZWAgZXZlbnQuXG4gICAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn0gZmVhdHVyZXMgRmVhdHVyZXMuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIFZlY3RvclNvdXJjZS5wcm90b3R5cGUuYWRkRmVhdHVyZXNJbnRlcm5hbCA9IGZ1bmN0aW9uIGFkZEZlYXR1cmVzSW50ZXJuYWwgKGZlYXR1cmVzKSB7XG4gICAgdmFyIGV4dGVudHMgPSBbXTtcbiAgICB2YXIgbmV3RmVhdHVyZXMgPSBbXTtcbiAgICB2YXIgZ2VvbWV0cnlGZWF0dXJlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGZlYXR1cmVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZmVhdHVyZSA9IGZlYXR1cmVzW2ldO1xuICAgICAgdmFyIGZlYXR1cmVLZXkgPSBnZXRVaWQoZmVhdHVyZSk7XG4gICAgICBpZiAodGhpcy5hZGRUb0luZGV4XyhmZWF0dXJlS2V5LCBmZWF0dXJlKSkge1xuICAgICAgICBuZXdGZWF0dXJlcy5wdXNoKGZlYXR1cmUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkkMSA9IDAsIGxlbmd0aCQxID0gbmV3RmVhdHVyZXMubGVuZ3RoOyBpJDEgPCBsZW5ndGgkMTsgaSQxKyspIHtcbiAgICAgIHZhciBmZWF0dXJlJDEgPSBuZXdGZWF0dXJlc1tpJDFdO1xuICAgICAgdmFyIGZlYXR1cmVLZXkkMSA9IGdldFVpZChmZWF0dXJlJDEpO1xuICAgICAgdGhpcy5zZXR1cENoYW5nZUV2ZW50c18oZmVhdHVyZUtleSQxLCBmZWF0dXJlJDEpO1xuXG4gICAgICB2YXIgZ2VvbWV0cnkgPSBmZWF0dXJlJDEuZ2V0R2VvbWV0cnkoKTtcbiAgICAgIGlmIChnZW9tZXRyeSkge1xuICAgICAgICB2YXIgZXh0ZW50ID0gZ2VvbWV0cnkuZ2V0RXh0ZW50KCk7XG4gICAgICAgIGV4dGVudHMucHVzaChleHRlbnQpO1xuICAgICAgICBnZW9tZXRyeUZlYXR1cmVzLnB1c2goZmVhdHVyZSQxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubnVsbEdlb21ldHJ5RmVhdHVyZXNfW2ZlYXR1cmVLZXkkMV0gPSBmZWF0dXJlJDE7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmZlYXR1cmVzUnRyZWVfKSB7XG4gICAgICB0aGlzLmZlYXR1cmVzUnRyZWVfLmxvYWQoZXh0ZW50cywgZ2VvbWV0cnlGZWF0dXJlcyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSQyID0gMCwgbGVuZ3RoJDIgPSBuZXdGZWF0dXJlcy5sZW5ndGg7IGkkMiA8IGxlbmd0aCQyOyBpJDIrKykge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBWZWN0b3JTb3VyY2VFdmVudChWZWN0b3JFdmVudFR5cGUuQURERkVBVFVSRSwgbmV3RmVhdHVyZXNbaSQyXSkpO1xuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFDb2xsZWN0aW9uPGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59IGNvbGxlY3Rpb24gQ29sbGVjdGlvbi5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFZlY3RvclNvdXJjZS5wcm90b3R5cGUuYmluZEZlYXR1cmVzQ29sbGVjdGlvbl8gPSBmdW5jdGlvbiBiaW5kRmVhdHVyZXNDb2xsZWN0aW9uXyAoY29sbGVjdGlvbikge1xuICAgIHZhciBtb2RpZnlpbmdDb2xsZWN0aW9uID0gZmFsc2U7XG4gICAgbGlzdGVuKHRoaXMsIFZlY3RvckV2ZW50VHlwZS5BRERGRUFUVVJFLFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge1ZlY3RvclNvdXJjZUV2ZW50fSBldnQgVGhlIHZlY3RvciBzb3VyY2UgZXZlbnRcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIGlmICghbW9kaWZ5aW5nQ29sbGVjdGlvbikge1xuICAgICAgICAgIG1vZGlmeWluZ0NvbGxlY3Rpb24gPSB0cnVlO1xuICAgICAgICAgIGNvbGxlY3Rpb24ucHVzaChldnQuZmVhdHVyZSk7XG4gICAgICAgICAgbW9kaWZ5aW5nQ29sbGVjdGlvbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICBsaXN0ZW4odGhpcywgVmVjdG9yRXZlbnRUeXBlLlJFTU9WRUZFQVRVUkUsXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7VmVjdG9yU291cmNlRXZlbnR9IGV2dCBUaGUgdmVjdG9yIHNvdXJjZSBldmVudFxuICAgICAgICovXG4gICAgICBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgaWYgKCFtb2RpZnlpbmdDb2xsZWN0aW9uKSB7XG4gICAgICAgICAgbW9kaWZ5aW5nQ29sbGVjdGlvbiA9IHRydWU7XG4gICAgICAgICAgY29sbGVjdGlvbi5yZW1vdmUoZXZ0LmZlYXR1cmUpO1xuICAgICAgICAgIG1vZGlmeWluZ0NvbGxlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgbGlzdGVuKGNvbGxlY3Rpb24sIENvbGxlY3Rpb25FdmVudFR5cGUuQURELFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0NvbGxlY3Rpb24uanNcIikuQ29sbGVjdGlvbkV2ZW50fSBldnQgVGhlIGNvbGxlY3Rpb24gZXZlbnRcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIGlmICghbW9kaWZ5aW5nQ29sbGVjdGlvbikge1xuICAgICAgICAgIG1vZGlmeWluZ0NvbGxlY3Rpb24gPSB0cnVlO1xuICAgICAgICAgIHRoaXMuYWRkRmVhdHVyZSgvKiogQHR5cGUge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gKi8gKGV2dC5lbGVtZW50KSk7XG4gICAgICAgICAgbW9kaWZ5aW5nQ29sbGVjdGlvbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICBsaXN0ZW4oY29sbGVjdGlvbiwgQ29sbGVjdGlvbkV2ZW50VHlwZS5SRU1PVkUsXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vQ29sbGVjdGlvbi5qc1wiKS5Db2xsZWN0aW9uRXZlbnR9IGV2dCBUaGUgY29sbGVjdGlvbiBldmVudFxuICAgICAgICovXG4gICAgICBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgaWYgKCFtb2RpZnlpbmdDb2xsZWN0aW9uKSB7XG4gICAgICAgICAgbW9kaWZ5aW5nQ29sbGVjdGlvbiA9IHRydWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVGZWF0dXJlKC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSAqLyAoZXZ0LmVsZW1lbnQpKTtcbiAgICAgICAgICBtb2RpZnlpbmdDb2xsZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgIHRoaXMuZmVhdHVyZXNDb2xsZWN0aW9uXyA9IGNvbGxlY3Rpb247XG4gIH07XG5cblxuICAvKipcbiAgICogUmVtb3ZlIGFsbCBmZWF0dXJlcyBmcm9tIHRoZSBzb3VyY2UuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9mYXN0IFNraXAgZGlzcGF0Y2hpbmcgb2Yge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yLlZlY3RvclNvdXJjZUV2ZW50I3JlbW92ZWZlYXR1cmV9IGV2ZW50cy5cbiAgICogQGFwaVxuICAgKi9cbiAgVmVjdG9yU291cmNlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyIChvcHRfZmFzdCkge1xuICAgIGlmIChvcHRfZmFzdCkge1xuICAgICAgZm9yICh2YXIgZmVhdHVyZUlkIGluIHRoaXMuZmVhdHVyZUNoYW5nZUtleXNfKSB7XG4gICAgICAgIHZhciBrZXlzID0gdGhpcy5mZWF0dXJlQ2hhbmdlS2V5c19bZmVhdHVyZUlkXTtcbiAgICAgICAga2V5cy5mb3JFYWNoKHVubGlzdGVuQnlLZXkpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmZlYXR1cmVzQ29sbGVjdGlvbl8pIHtcbiAgICAgICAgdGhpcy5mZWF0dXJlQ2hhbmdlS2V5c18gPSB7fTtcbiAgICAgICAgdGhpcy5pZEluZGV4XyA9IHt9O1xuICAgICAgICB0aGlzLnVuZGVmSWRJbmRleF8gPSB7fTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuZmVhdHVyZXNSdHJlZV8pIHtcbiAgICAgICAgdGhpcy5mZWF0dXJlc1J0cmVlXy5mb3JFYWNoKHRoaXMucmVtb3ZlRmVhdHVyZUludGVybmFsLCB0aGlzKTtcbiAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5udWxsR2VvbWV0cnlGZWF0dXJlc18pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUZlYXR1cmVJbnRlcm5hbCh0aGlzLm51bGxHZW9tZXRyeUZlYXR1cmVzX1tpZF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmZlYXR1cmVzQ29sbGVjdGlvbl8pIHtcbiAgICAgIHRoaXMuZmVhdHVyZXNDb2xsZWN0aW9uXy5jbGVhcigpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZlYXR1cmVzUnRyZWVfKSB7XG4gICAgICB0aGlzLmZlYXR1cmVzUnRyZWVfLmNsZWFyKCk7XG4gICAgfVxuICAgIHRoaXMubG9hZGVkRXh0ZW50c1J0cmVlXy5jbGVhcigpO1xuICAgIHRoaXMubnVsbEdlb21ldHJ5RmVhdHVyZXNfID0ge307XG5cbiAgICB2YXIgY2xlYXJFdmVudCA9IG5ldyBWZWN0b3JTb3VyY2VFdmVudChWZWN0b3JFdmVudFR5cGUuQ0xFQVIpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChjbGVhckV2ZW50KTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBJdGVyYXRlIHRocm91Z2ggYWxsIGZlYXR1cmVzIG9uIHRoZSBzb3VyY2UsIGNhbGxpbmcgdGhlIHByb3ZpZGVkIGNhbGxiYWNrXG4gICAqIHdpdGggZWFjaCBvbmUuICBJZiB0aGUgY2FsbGJhY2sgcmV0dXJucyBhbnkgXCJ0cnV0aHlcIiB2YWx1ZSwgaXRlcmF0aW9uIHdpbGxcbiAgICogc3RvcCBhbmQgdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSBzYW1lIHZhbHVlLlxuICAgKiBOb3RlOiB0aGlzIGZ1bmN0aW9uIG9ubHkgaXRlcmF0ZSB0aHJvdWdoIHRoZSBmZWF0dXJlIHRoYXQgaGF2ZSBhIGRlZmluZWQgZ2VvbWV0cnkuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0KTogVH0gY2FsbGJhY2sgQ2FsbGVkIHdpdGggZWFjaCBmZWF0dXJlXG4gICAqICAgICBvbiB0aGUgc291cmNlLiAgUmV0dXJuIGEgdHJ1dGh5IHZhbHVlIHRvIHN0b3AgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJuIHtUfHVuZGVmaW5lZH0gVGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBsYXN0IGNhbGwgdG8gdGhlIGNhbGxiYWNrLlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKiBAYXBpXG4gICAqL1xuICBWZWN0b3JTb3VyY2UucHJvdG90eXBlLmZvckVhY2hGZWF0dXJlID0gZnVuY3Rpb24gZm9yRWFjaEZlYXR1cmUgKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuZmVhdHVyZXNSdHJlZV8pIHtcbiAgICAgIHJldHVybiB0aGlzLmZlYXR1cmVzUnRyZWVfLmZvckVhY2goY2FsbGJhY2spO1xuICAgIH0gZWxzZSBpZiAodGhpcy5mZWF0dXJlc0NvbGxlY3Rpb25fKSB7XG4gICAgICB0aGlzLmZlYXR1cmVzQ29sbGVjdGlvbl8uZm9yRWFjaChjYWxsYmFjayk7XG4gICAgfVxuICB9O1xuXG5cbiAgLyoqXG4gICAqIEl0ZXJhdGUgdGhyb3VnaCBhbGwgZmVhdHVyZXMgd2hvc2UgZ2VvbWV0cmllcyBjb250YWluIHRoZSBwcm92aWRlZFxuICAgKiBjb29yZGluYXRlLCBjYWxsaW5nIHRoZSBjYWxsYmFjayB3aXRoIGVhY2ggZmVhdHVyZS4gIElmIHRoZSBjYWxsYmFjayByZXR1cm5zXG4gICAqIGEgXCJ0cnV0aHlcIiB2YWx1ZSwgaXRlcmF0aW9uIHdpbGwgc3RvcCBhbmQgdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSBzYW1lXG4gICAqIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdCk6IFR9IGNhbGxiYWNrIENhbGxlZCB3aXRoIGVhY2ggZmVhdHVyZVxuICAgKiAgICAgd2hvc2UgZ29lbWV0cnkgY29udGFpbnMgdGhlIHByb3ZpZGVkIGNvb3JkaW5hdGUuXG4gICAqIEByZXR1cm4ge1R8dW5kZWZpbmVkfSBUaGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGxhc3QgY2FsbCB0byB0aGUgY2FsbGJhY2suXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqL1xuICBWZWN0b3JTb3VyY2UucHJvdG90eXBlLmZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlRGlyZWN0ID0gZnVuY3Rpb24gZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGVEaXJlY3QgKGNvb3JkaW5hdGUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGV4dGVudCA9IFtjb29yZGluYXRlWzBdLCBjb29yZGluYXRlWzFdLCBjb29yZGluYXRlWzBdLCBjb29yZGluYXRlWzFdXTtcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoRmVhdHVyZUluRXh0ZW50KGV4dGVudCwgZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgICAgdmFyIGdlb21ldHJ5ID0gZmVhdHVyZS5nZXRHZW9tZXRyeSgpO1xuICAgICAgaWYgKGdlb21ldHJ5LmludGVyc2VjdHNDb29yZGluYXRlKGNvb3JkaW5hdGUpKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhmZWF0dXJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cblxuICAvKipcbiAgICogSXRlcmF0ZSB0aHJvdWdoIGFsbCBmZWF0dXJlcyB3aG9zZSBib3VuZGluZyBib3ggaW50ZXJzZWN0cyB0aGUgcHJvdmlkZWRcbiAgICogZXh0ZW50IChub3RlIHRoYXQgdGhlIGZlYXR1cmUncyBnZW9tZXRyeSBtYXkgbm90IGludGVyc2VjdCB0aGUgZXh0ZW50KSxcbiAgICogY2FsbGluZyB0aGUgY2FsbGJhY2sgd2l0aCBlYWNoIGZlYXR1cmUuICBJZiB0aGUgY2FsbGJhY2sgcmV0dXJucyBhIFwidHJ1dGh5XCJcbiAgICogdmFsdWUsIGl0ZXJhdGlvbiB3aWxsIHN0b3AgYW5kIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgc2FtZSB2YWx1ZS5cbiAgICpcbiAgICogSWYgeW91IGFyZSBpbnRlcmVzdGVkIGluIGZlYXR1cmVzIHdob3NlIGdlb21ldHJ5IGludGVyc2VjdHMgYW4gZXh0ZW50LCBjYWxsXG4gICAqIHRoZSB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3J+VmVjdG9yU291cmNlI2ZvckVhY2hGZWF0dXJlSW50ZXJzZWN0aW5nRXh0ZW50ICNmb3JFYWNoRmVhdHVyZUludGVyc2VjdGluZ0V4dGVudCgpfSBtZXRob2QgaW5zdGVhZC5cbiAgICpcbiAgICogV2hlbiBgdXNlU3BhdGlhbEluZGV4YCBpcyBzZXQgdG8gZmFsc2UsIHRoaXMgbWV0aG9kIHdpbGwgbG9vcCB0aHJvdWdoIGFsbFxuICAgKiBmZWF0dXJlcywgZXF1aXZhbGVudCB0byB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3J+VmVjdG9yU291cmNlI2ZvckVhY2hGZWF0dXJlICNmb3JFYWNoRmVhdHVyZSgpfS5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdCk6IFR9IGNhbGxiYWNrIENhbGxlZCB3aXRoIGVhY2ggZmVhdHVyZVxuICAgKiAgICAgd2hvc2UgYm91bmRpbmcgYm94IGludGVyc2VjdHMgdGhlIHByb3ZpZGVkIGV4dGVudC5cbiAgICogQHJldHVybiB7VHx1bmRlZmluZWR9IFRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgbGFzdCBjYWxsIHRvIHRoZSBjYWxsYmFjay5cbiAgICogQHRlbXBsYXRlIFRcbiAgICogQGFwaVxuICAgKi9cbiAgVmVjdG9yU291cmNlLnByb3RvdHlwZS5mb3JFYWNoRmVhdHVyZUluRXh0ZW50ID0gZnVuY3Rpb24gZm9yRWFjaEZlYXR1cmVJbkV4dGVudCAoZXh0ZW50LCBjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLmZlYXR1cmVzUnRyZWVfKSB7XG4gICAgICByZXR1cm4gdGhpcy5mZWF0dXJlc1J0cmVlXy5mb3JFYWNoSW5FeHRlbnQoZXh0ZW50LCBjYWxsYmFjayk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmZlYXR1cmVzQ29sbGVjdGlvbl8pIHtcbiAgICAgIHRoaXMuZmVhdHVyZXNDb2xsZWN0aW9uXy5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgICB9XG4gIH07XG5cblxuICAvKipcbiAgICogSXRlcmF0ZSB0aHJvdWdoIGFsbCBmZWF0dXJlcyB3aG9zZSBnZW9tZXRyeSBpbnRlcnNlY3RzIHRoZSBwcm92aWRlZCBleHRlbnQsXG4gICAqIGNhbGxpbmcgdGhlIGNhbGxiYWNrIHdpdGggZWFjaCBmZWF0dXJlLiAgSWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYSBcInRydXRoeVwiXG4gICAqIHZhbHVlLCBpdGVyYXRpb24gd2lsbCBzdG9wIGFuZCB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHNhbWUgdmFsdWUuXG4gICAqXG4gICAqIElmIHlvdSBvbmx5IHdhbnQgdG8gdGVzdCBmb3IgYm91bmRpbmcgYm94IGludGVyc2VjdGlvbiwgY2FsbCB0aGVcbiAgICoge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yflZlY3RvclNvdXJjZSNmb3JFYWNoRmVhdHVyZUluRXh0ZW50ICNmb3JFYWNoRmVhdHVyZUluRXh0ZW50KCl9IG1ldGhvZCBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0KTogVH0gY2FsbGJhY2sgQ2FsbGVkIHdpdGggZWFjaCBmZWF0dXJlXG4gICAqICAgICB3aG9zZSBnZW9tZXRyeSBpbnRlcnNlY3RzIHRoZSBwcm92aWRlZCBleHRlbnQuXG4gICAqIEByZXR1cm4ge1R8dW5kZWZpbmVkfSBUaGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGxhc3QgY2FsbCB0byB0aGUgY2FsbGJhY2suXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqIEBhcGlcbiAgICovXG4gIFZlY3RvclNvdXJjZS5wcm90b3R5cGUuZm9yRWFjaEZlYXR1cmVJbnRlcnNlY3RpbmdFeHRlbnQgPSBmdW5jdGlvbiBmb3JFYWNoRmVhdHVyZUludGVyc2VjdGluZ0V4dGVudCAoZXh0ZW50LCBjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLmZvckVhY2hGZWF0dXJlSW5FeHRlbnQoZXh0ZW50LFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICAgICAgICogQHJldHVybiB7VHx1bmRlZmluZWR9IFRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgbGFzdCBjYWxsIHRvIHRoZSBjYWxsYmFjay5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgICAgICB2YXIgZ2VvbWV0cnkgPSBmZWF0dXJlLmdldEdlb21ldHJ5KCk7XG4gICAgICAgIGlmIChnZW9tZXRyeS5pbnRlcnNlY3RzRXh0ZW50KGV4dGVudCkpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gY2FsbGJhY2soZmVhdHVyZSk7XG4gICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZmVhdHVyZXMgY29sbGVjdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhpcyBzb3VyY2UuIFdpbGwgYmUgYG51bGxgXG4gICAqIHVubGVzcyB0aGUgc291cmNlIHdhcyBjb25maWd1cmVkIHdpdGggYHVzZVNwYXRpYWxJbmRleGAgc2V0IHRvIGBmYWxzZWAsIG9yXG4gICAqIHdpdGggYW4ge0BsaW5rIG1vZHVsZTpvbC9Db2xsZWN0aW9ufSBhcyBgZmVhdHVyZXNgLlxuICAgKiBAcmV0dXJuIHtDb2xsZWN0aW9uPGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59IFRoZSBjb2xsZWN0aW9uIG9mIGZlYXR1cmVzLlxuICAgKiBAYXBpXG4gICAqL1xuICBWZWN0b3JTb3VyY2UucHJvdG90eXBlLmdldEZlYXR1cmVzQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIGdldEZlYXR1cmVzQ29sbGVjdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmVhdHVyZXNDb2xsZWN0aW9uXztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIGZlYXR1cmVzIG9uIHRoZSBzb3VyY2UgaW4gcmFuZG9tIG9yZGVyLlxuICAgKiBAcmV0dXJuIHtBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fSBGZWF0dXJlcy5cbiAgICogQGFwaVxuICAgKi9cbiAgVmVjdG9yU291cmNlLnByb3RvdHlwZS5nZXRGZWF0dXJlcyA9IGZ1bmN0aW9uIGdldEZlYXR1cmVzICgpIHtcbiAgICB2YXIgZmVhdHVyZXM7XG4gICAgaWYgKHRoaXMuZmVhdHVyZXNDb2xsZWN0aW9uXykge1xuICAgICAgZmVhdHVyZXMgPSB0aGlzLmZlYXR1cmVzQ29sbGVjdGlvbl8uZ2V0QXJyYXkoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZmVhdHVyZXNSdHJlZV8pIHtcbiAgICAgIGZlYXR1cmVzID0gdGhpcy5mZWF0dXJlc1J0cmVlXy5nZXRBbGwoKTtcbiAgICAgIGlmICghaXNFbXB0eSh0aGlzLm51bGxHZW9tZXRyeUZlYXR1cmVzXykpIHtcbiAgICAgICAgZXh0ZW5kKGZlYXR1cmVzLCBnZXRWYWx1ZXModGhpcy5udWxsR2VvbWV0cnlGZWF0dXJlc18pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn0gKi8gKGZlYXR1cmVzKVxuICAgICk7XG4gIH07XG5cblxuICAvKipcbiAgICogR2V0IGFsbCBmZWF0dXJlcyB3aG9zZSBnZW9tZXRyeSBpbnRlcnNlY3RzIHRoZSBwcm92aWRlZCBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICAgKiBAcmV0dXJuIHtBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fSBGZWF0dXJlcy5cbiAgICogQGFwaVxuICAgKi9cbiAgVmVjdG9yU291cmNlLnByb3RvdHlwZS5nZXRGZWF0dXJlc0F0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldEZlYXR1cmVzQXRDb29yZGluYXRlIChjb29yZGluYXRlKSB7XG4gICAgdmFyIGZlYXR1cmVzID0gW107XG4gICAgdGhpcy5mb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZURpcmVjdChjb29yZGluYXRlLCBmdW5jdGlvbihmZWF0dXJlKSB7XG4gICAgICBmZWF0dXJlcy5wdXNoKGZlYXR1cmUpO1xuICAgIH0pO1xuICAgIHJldHVybiBmZWF0dXJlcztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIGZlYXR1cmVzIGluIHRoZSBwcm92aWRlZCBleHRlbnQuICBOb3RlIHRoYXQgdGhpcyByZXR1cm5zIGFuIGFycmF5IG9mXG4gICAqIGFsbCBmZWF0dXJlcyBpbnRlcnNlY3RpbmcgdGhlIGdpdmVuIGV4dGVudCBpbiByYW5kb20gb3JkZXIgKHNvIGl0IG1heSBpbmNsdWRlXG4gICAqIGZlYXR1cmVzIHdob3NlIGdlb21ldHJpZXMgZG8gbm90IGludGVyc2VjdCB0aGUgZXh0ZW50KS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgbm90IGF2YWlsYWJsZSB3aGVuIHRoZSBzb3VyY2UgaXMgY29uZmlndXJlZCB3aXRoXG4gICAqIGB1c2VTcGF0aWFsSW5kZXhgIHNldCB0byBgZmFsc2VgLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEByZXR1cm4ge0FycmF5PGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59IEZlYXR1cmVzLlxuICAgKiBAYXBpXG4gICAqL1xuICBWZWN0b3JTb3VyY2UucHJvdG90eXBlLmdldEZlYXR1cmVzSW5FeHRlbnQgPSBmdW5jdGlvbiBnZXRGZWF0dXJlc0luRXh0ZW50IChleHRlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5mZWF0dXJlc1J0cmVlXy5nZXRJbkV4dGVudChleHRlbnQpO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY2xvc2VzdCBmZWF0dXJlIHRvIHRoZSBwcm92aWRlZCBjb29yZGluYXRlLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBub3QgYXZhaWxhYmxlIHdoZW4gdGhlIHNvdXJjZSBpcyBjb25maWd1cmVkIHdpdGhcbiAgICogYHVzZVNwYXRpYWxJbmRleGAgc2V0IHRvIGBmYWxzZWAuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0KTpib29sZWFuPX0gb3B0X2ZpbHRlciBGZWF0dXJlIGZpbHRlciBmdW5jdGlvbi5cbiAgICogICAgIFRoZSBmaWx0ZXIgZnVuY3Rpb24gd2lsbCByZWNlaXZlIG9uZSBhcmd1bWVudCwgdGhlIHtAbGluayBtb2R1bGU6b2wvRmVhdHVyZSBmZWF0dXJlfVxuICAgKiAgICAgYW5kIGl0IHNob3VsZCByZXR1cm4gYSBib29sZWFuIHZhbHVlLiBCeSBkZWZhdWx0LCBubyBmaWx0ZXJpbmcgaXMgbWFkZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBDbG9zZXN0IGZlYXR1cmUuXG4gICAqIEBhcGlcbiAgICovXG4gIFZlY3RvclNvdXJjZS5wcm90b3R5cGUuZ2V0Q2xvc2VzdEZlYXR1cmVUb0Nvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRDbG9zZXN0RmVhdHVyZVRvQ29vcmRpbmF0ZSAoY29vcmRpbmF0ZSwgb3B0X2ZpbHRlcikge1xuICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3QgZmVhdHVyZSB1c2luZyBicmFuY2ggYW5kIGJvdW5kLiAgV2Ugc3RhcnQgc2VhcmNoaW5nIGFuXG4gICAgLy8gaW5maW5pdGUgZXh0ZW50LCBhbmQgZmluZCB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgZmlyc3QgZmVhdHVyZSBmb3VuZC4gIFRoaXNcbiAgICAvLyBiZWNvbWVzIHRoZSBjbG9zZXN0IGZlYXR1cmUuICBXZSB0aGVuIGNvbXB1dGUgYSBzbWFsbGVyIGV4dGVudCB3aGljaCBhbnlcbiAgICAvLyBjbG9zZXIgZmVhdHVyZSBtdXN0IGludGVyc2VjdC4gIFdlIGNvbnRpbnVlIHNlYXJjaGluZyB3aXRoIHRoaXMgc21hbGxlclxuICAgIC8vIGV4dGVudCwgdHJ5aW5nIHRvIGZpbmQgYSBjbG9zZXIgZmVhdHVyZS4gIEV2ZXJ5IHRpbWUgd2UgZmluZCBhIGNsb3NlclxuICAgIC8vIGZlYXR1cmUsIHdlIHVwZGF0ZSB0aGUgZXh0ZW50IGJlaW5nIHNlYXJjaGVkIHNvIHRoYXQgYW55IGV2ZW4gY2xvc2VyXG4gICAgLy8gZmVhdHVyZSBtdXN0IGludGVyc2VjdCBpdC4gIFdlIGNvbnRpbnVlIHVudGlsIHdlIHJ1biBvdXQgb2YgZmVhdHVyZXMuXG4gICAgdmFyIHggPSBjb29yZGluYXRlWzBdO1xuICAgIHZhciB5ID0gY29vcmRpbmF0ZVsxXTtcbiAgICB2YXIgY2xvc2VzdEZlYXR1cmUgPSBudWxsO1xuICAgIHZhciBjbG9zZXN0UG9pbnQgPSBbTmFOLCBOYU5dO1xuICAgIHZhciBtaW5TcXVhcmVkRGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICB2YXIgZXh0ZW50ID0gWy1JbmZpbml0eSwgLUluZmluaXR5LCBJbmZpbml0eSwgSW5maW5pdHldO1xuICAgIHZhciBmaWx0ZXIgPSBvcHRfZmlsdGVyID8gb3B0X2ZpbHRlciA6IFRSVUU7XG4gICAgdGhpcy5mZWF0dXJlc1J0cmVlXy5mb3JFYWNoSW5FeHRlbnQoZXh0ZW50LFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbihmZWF0dXJlKSB7XG4gICAgICAgIGlmIChmaWx0ZXIoZmVhdHVyZSkpIHtcbiAgICAgICAgICB2YXIgZ2VvbWV0cnkgPSBmZWF0dXJlLmdldEdlb21ldHJ5KCk7XG4gICAgICAgICAgdmFyIHByZXZpb3VzTWluU3F1YXJlZERpc3RhbmNlID0gbWluU3F1YXJlZERpc3RhbmNlO1xuICAgICAgICAgIG1pblNxdWFyZWREaXN0YW5jZSA9IGdlb21ldHJ5LmNsb3Nlc3RQb2ludFhZKFxuICAgICAgICAgICAgeCwgeSwgY2xvc2VzdFBvaW50LCBtaW5TcXVhcmVkRGlzdGFuY2UpO1xuICAgICAgICAgIGlmIChtaW5TcXVhcmVkRGlzdGFuY2UgPCBwcmV2aW91c01pblNxdWFyZWREaXN0YW5jZSkge1xuICAgICAgICAgICAgY2xvc2VzdEZlYXR1cmUgPSBmZWF0dXJlO1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBzbmVha3kuICBSZWR1Y2UgdGhlIGV4dGVudCB0aGF0IGl0IGlzIGN1cnJlbnRseSBiZWluZ1xuICAgICAgICAgICAgLy8gc2VhcmNoZWQgd2hpbGUgdGhlIFItVHJlZSB0cmF2ZXJzYWwgdXNpbmcgdGhpcyBzYW1lIGV4dGVudCBvYmplY3RcbiAgICAgICAgICAgIC8vIGlzIHN0aWxsIGluIHByb2dyZXNzLiAgVGhpcyBpcyBzYWZlIGJlY2F1c2UgdGhlIG5ldyBleHRlbnQgaXNcbiAgICAgICAgICAgIC8vIHN0cmljdGx5IGNvbnRhaW5lZCBieSB0aGUgb2xkIGV4dGVudC5cbiAgICAgICAgICAgIHZhciBtaW5EaXN0YW5jZSA9IE1hdGguc3FydChtaW5TcXVhcmVkRGlzdGFuY2UpO1xuICAgICAgICAgICAgZXh0ZW50WzBdID0geCAtIG1pbkRpc3RhbmNlO1xuICAgICAgICAgICAgZXh0ZW50WzFdID0geSAtIG1pbkRpc3RhbmNlO1xuICAgICAgICAgICAgZXh0ZW50WzJdID0geCArIG1pbkRpc3RhbmNlO1xuICAgICAgICAgICAgZXh0ZW50WzNdID0geSArIG1pbkRpc3RhbmNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgcmV0dXJuIGNsb3Nlc3RGZWF0dXJlO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZXh0ZW50IG9mIHRoZSBmZWF0dXJlcyBjdXJyZW50bHkgaW4gdGhlIHNvdXJjZS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgbm90IGF2YWlsYWJsZSB3aGVuIHRoZSBzb3VyY2UgaXMgY29uZmlndXJlZCB3aXRoXG4gICAqIGB1c2VTcGF0aWFsSW5kZXhgIHNldCB0byBgZmFsc2VgLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnQ9fSBvcHRfZXh0ZW50IERlc3RpbmF0aW9uIGV4dGVudC4gSWYgcHJvdmlkZWQsIG5vIG5ldyBleHRlbnRcbiAgICogICAgIHdpbGwgYmUgY3JlYXRlZC4gSW5zdGVhZCwgdGhhdCBleHRlbnQncyBjb29yZGluYXRlcyB3aWxsIGJlIG92ZXJ3cml0dGVuLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBFeHRlbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIFZlY3RvclNvdXJjZS5wcm90b3R5cGUuZ2V0RXh0ZW50ID0gZnVuY3Rpb24gZ2V0RXh0ZW50IChvcHRfZXh0ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuZmVhdHVyZXNSdHJlZV8uZ2V0RXh0ZW50KG9wdF9leHRlbnQpO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEdldCBhIGZlYXR1cmUgYnkgaXRzIGlkZW50aWZpZXIgKHRoZSB2YWx1ZSByZXR1cm5lZCBieSBmZWF0dXJlLmdldElkKCkpLlxuICAgKiBOb3RlIHRoYXQgdGhlIGluZGV4IHRyZWF0cyBzdHJpbmcgYW5kIG51bWVyaWMgaWRlbnRpZmllcnMgYXMgdGhlIHNhbWUuICBTb1xuICAgKiBgc291cmNlLmdldEZlYXR1cmVCeUlkKDIpYCB3aWxsIHJldHVybiBhIGZlYXR1cmUgd2l0aCBpZCBgJzInYCBvciBgMmAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gaWQgRmVhdHVyZSBpZGVudGlmaWVyLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IFRoZSBmZWF0dXJlIChvciBgbnVsbGAgaWYgbm90IGZvdW5kKS5cbiAgICogQGFwaVxuICAgKi9cbiAgVmVjdG9yU291cmNlLnByb3RvdHlwZS5nZXRGZWF0dXJlQnlJZCA9IGZ1bmN0aW9uIGdldEZlYXR1cmVCeUlkIChpZCkge1xuICAgIHZhciBmZWF0dXJlID0gdGhpcy5pZEluZGV4X1tpZC50b1N0cmluZygpXTtcbiAgICByZXR1cm4gZmVhdHVyZSAhPT0gdW5kZWZpbmVkID8gZmVhdHVyZSA6IG51bGw7XG4gIH07XG5cblxuICAvKipcbiAgICogR2V0IHRoZSBmb3JtYXQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgc291cmNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9mb3JtYXQvRmVhdHVyZS5qc1wiKS5kZWZhdWx0fHVuZGVmaW5lZH0gVGhlIGZlYXR1cmUgZm9ybWF0LlxuICAgKiBAYXBpXG4gICAqL1xuICBWZWN0b3JTb3VyY2UucHJvdG90eXBlLmdldEZvcm1hdCA9IGZ1bmN0aW9uIGdldEZvcm1hdCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0XztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgc291cmNlIGNhbiBoYXZlIG92ZXJsYXBwaW5nIGdlb21ldHJpZXMuXG4gICAqL1xuICBWZWN0b3JTb3VyY2UucHJvdG90eXBlLmdldE92ZXJsYXBzID0gZnVuY3Rpb24gZ2V0T3ZlcmxhcHMgKCkge1xuICAgIHJldHVybiB0aGlzLm92ZXJsYXBzXztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHVybCBhc3NvY2lhdGVkIHdpdGggdGhpcyBzb3VyY2UuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ3xpbXBvcnQoXCIuLi9mZWF0dXJlbG9hZGVyLmpzXCIpLkZlYXR1cmVVcmxGdW5jdGlvbnx1bmRlZmluZWR9IFRoZSB1cmwuXG4gICAqIEBhcGlcbiAgICovXG4gIFZlY3RvclNvdXJjZS5wcm90b3R5cGUuZ2V0VXJsID0gZnVuY3Rpb24gZ2V0VXJsICgpIHtcbiAgICByZXR1cm4gdGhpcy51cmxfO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IEV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgVmVjdG9yU291cmNlLnByb3RvdHlwZS5oYW5kbGVGZWF0dXJlQ2hhbmdlXyA9IGZ1bmN0aW9uIGhhbmRsZUZlYXR1cmVDaGFuZ2VfIChldmVudCkge1xuICAgIHZhciBmZWF0dXJlID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9ICovIChldmVudC50YXJnZXQpO1xuICAgIHZhciBmZWF0dXJlS2V5ID0gZ2V0VWlkKGZlYXR1cmUpO1xuICAgIHZhciBnZW9tZXRyeSA9IGZlYXR1cmUuZ2V0R2VvbWV0cnkoKTtcbiAgICBpZiAoIWdlb21ldHJ5KSB7XG4gICAgICBpZiAoIShmZWF0dXJlS2V5IGluIHRoaXMubnVsbEdlb21ldHJ5RmVhdHVyZXNfKSkge1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlc1J0cmVlXykge1xuICAgICAgICAgIHRoaXMuZmVhdHVyZXNSdHJlZV8ucmVtb3ZlKGZlYXR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubnVsbEdlb21ldHJ5RmVhdHVyZXNfW2ZlYXR1cmVLZXldID0gZmVhdHVyZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGV4dGVudCA9IGdlb21ldHJ5LmdldEV4dGVudCgpO1xuICAgICAgaWYgKGZlYXR1cmVLZXkgaW4gdGhpcy5udWxsR2VvbWV0cnlGZWF0dXJlc18pIHtcbiAgICAgICAgZGVsZXRlIHRoaXMubnVsbEdlb21ldHJ5RmVhdHVyZXNfW2ZlYXR1cmVLZXldO1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlc1J0cmVlXykge1xuICAgICAgICAgIHRoaXMuZmVhdHVyZXNSdHJlZV8uaW5zZXJ0KGV4dGVudCwgZmVhdHVyZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVzUnRyZWVfKSB7XG4gICAgICAgICAgdGhpcy5mZWF0dXJlc1J0cmVlXy51cGRhdGUoZXh0ZW50LCBmZWF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgaWQgPSBmZWF0dXJlLmdldElkKCk7XG4gICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBzaWQgPSBpZC50b1N0cmluZygpO1xuICAgICAgaWYgKGZlYXR1cmVLZXkgaW4gdGhpcy51bmRlZklkSW5kZXhfKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnVuZGVmSWRJbmRleF9bZmVhdHVyZUtleV07XG4gICAgICAgIHRoaXMuaWRJbmRleF9bc2lkXSA9IGZlYXR1cmU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5pZEluZGV4X1tzaWRdICE9PSBmZWF0dXJlKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVGcm9tSWRJbmRleF8oZmVhdHVyZSk7XG4gICAgICAgICAgdGhpcy5pZEluZGV4X1tzaWRdID0gZmVhdHVyZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIShmZWF0dXJlS2V5IGluIHRoaXMudW5kZWZJZEluZGV4XykpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVGcm9tSWRJbmRleF8oZmVhdHVyZSk7XG4gICAgICAgIHRoaXMudW5kZWZJZEluZGV4X1tmZWF0dXJlS2V5XSA9IGZlYXR1cmU7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgVmVjdG9yU291cmNlRXZlbnQoXG4gICAgICBWZWN0b3JFdmVudFR5cGUuQ0hBTkdFRkVBVFVSRSwgZmVhdHVyZSkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGZlYXR1cmUgaXMgY29udGFpbmVkIHdpdGhpbiB0aGUgc291cmNlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBIYXMgZmVhdHVyZS5cbiAgICogQGFwaVxuICAgKi9cbiAgVmVjdG9yU291cmNlLnByb3RvdHlwZS5oYXNGZWF0dXJlID0gZnVuY3Rpb24gaGFzRmVhdHVyZSAoZmVhdHVyZSkge1xuICAgIHZhciBpZCA9IGZlYXR1cmUuZ2V0SWQoKTtcbiAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGlkIGluIHRoaXMuaWRJbmRleF87XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnZXRVaWQoZmVhdHVyZSkgaW4gdGhpcy51bmRlZklkSW5kZXhfO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSXMgZW1wdHkuXG4gICAqL1xuICBWZWN0b3JTb3VyY2UucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5JDEgKCkge1xuICAgIHJldHVybiB0aGlzLmZlYXR1cmVzUnRyZWVfLmlzRW1wdHkoKSAmJiBpc0VtcHR5KHRoaXMubnVsbEdlb21ldHJ5RmVhdHVyZXNfKTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICovXG4gIFZlY3RvclNvdXJjZS5wcm90b3R5cGUubG9hZEZlYXR1cmVzID0gZnVuY3Rpb24gbG9hZEZlYXR1cmVzIChleHRlbnQsIHJlc29sdXRpb24sIHByb2plY3Rpb24pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBsb2FkZWRFeHRlbnRzUnRyZWUgPSB0aGlzLmxvYWRlZEV4dGVudHNSdHJlZV87XG4gICAgdmFyIGV4dGVudHNUb0xvYWQgPSB0aGlzLnN0cmF0ZWd5XyhleHRlbnQsIHJlc29sdXRpb24pO1xuICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCBpLCBpaSApIHtcbiAgICAgIHZhciBleHRlbnRUb0xvYWQgPSBleHRlbnRzVG9Mb2FkW2ldO1xuICAgICAgdmFyIGFscmVhZHlMb2FkZWQgPSBsb2FkZWRFeHRlbnRzUnRyZWUuZm9yRWFjaEluRXh0ZW50KGV4dGVudFRvTG9hZCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7e2V4dGVudDogaW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH19IG9iamVjdCBPYmplY3QuXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IENvbnRhaW5zLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRhaW5zRXh0ZW50KG9iamVjdC5leHRlbnQsIGV4dGVudFRvTG9hZCk7XG4gICAgICAgIH0pO1xuICAgICAgaWYgKCFhbHJlYWR5TG9hZGVkKSB7XG4gICAgICAgIHRoaXMkMS5sb2FkZXJfLmNhbGwodGhpcyQxLCBleHRlbnRUb0xvYWQsIHJlc29sdXRpb24sIHByb2plY3Rpb24pO1xuICAgICAgICBsb2FkZWRFeHRlbnRzUnRyZWUuaW5zZXJ0KGV4dGVudFRvTG9hZCwge2V4dGVudDogZXh0ZW50VG9Mb2FkLnNsaWNlKCl9KTtcbiAgICAgICAgdGhpcyQxLmxvYWRpbmcgPSB0aGlzJDEubG9hZGVyXyAhPT0gVk9JRDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZXh0ZW50c1RvTG9hZC5sZW5ndGg7IGkgPCBpaTsgKytpKSBsb29wKCBpLCBpaSApO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBleHRlbnQgZnJvbSB0aGUgbGlzdCBvZiBsb2FkZWQgZXh0ZW50cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBWZWN0b3JTb3VyY2UucHJvdG90eXBlLnJlbW92ZUxvYWRlZEV4dGVudCA9IGZ1bmN0aW9uIHJlbW92ZUxvYWRlZEV4dGVudCAoZXh0ZW50KSB7XG4gICAgdmFyIGxvYWRlZEV4dGVudHNSdHJlZSA9IHRoaXMubG9hZGVkRXh0ZW50c1J0cmVlXztcbiAgICB2YXIgb2JqO1xuICAgIGxvYWRlZEV4dGVudHNSdHJlZS5mb3JFYWNoSW5FeHRlbnQoZXh0ZW50LCBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIGlmIChlcXVhbHMob2JqZWN0LmV4dGVudCwgZXh0ZW50KSkge1xuICAgICAgICBvYmogPSBvYmplY3Q7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChvYmopIHtcbiAgICAgIGxvYWRlZEV4dGVudHNSdHJlZS5yZW1vdmUob2JqKTtcbiAgICB9XG4gIH07XG5cblxuICAvKipcbiAgICogUmVtb3ZlIGEgc2luZ2xlIGZlYXR1cmUgZnJvbSB0aGUgc291cmNlLiAgSWYgeW91IHdhbnQgdG8gcmVtb3ZlIGFsbCBmZWF0dXJlc1xuICAgKiBhdCBvbmNlLCB1c2UgdGhlIHtAbGluayBtb2R1bGU6b2wvc291cmNlL1ZlY3Rvcn5WZWN0b3JTb3VyY2UjY2xlYXIgI2NsZWFyKCl9IG1ldGhvZFxuICAgKiBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlIHRvIHJlbW92ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgVmVjdG9yU291cmNlLnByb3RvdHlwZS5yZW1vdmVGZWF0dXJlID0gZnVuY3Rpb24gcmVtb3ZlRmVhdHVyZSAoZmVhdHVyZSkge1xuICAgIHZhciBmZWF0dXJlS2V5ID0gZ2V0VWlkKGZlYXR1cmUpO1xuICAgIGlmIChmZWF0dXJlS2V5IGluIHRoaXMubnVsbEdlb21ldHJ5RmVhdHVyZXNfKSB7XG4gICAgICBkZWxldGUgdGhpcy5udWxsR2VvbWV0cnlGZWF0dXJlc19bZmVhdHVyZUtleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmZlYXR1cmVzUnRyZWVfKSB7XG4gICAgICAgIHRoaXMuZmVhdHVyZXNSdHJlZV8ucmVtb3ZlKGZlYXR1cmUpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJlbW92ZUZlYXR1cmVJbnRlcm5hbChmZWF0dXJlKTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBSZW1vdmUgZmVhdHVyZSB3aXRob3V0IGZpcmluZyBhIGBjaGFuZ2VgIGV2ZW50LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBWZWN0b3JTb3VyY2UucHJvdG90eXBlLnJlbW92ZUZlYXR1cmVJbnRlcm5hbCA9IGZ1bmN0aW9uIHJlbW92ZUZlYXR1cmVJbnRlcm5hbCAoZmVhdHVyZSkge1xuICAgIHZhciBmZWF0dXJlS2V5ID0gZ2V0VWlkKGZlYXR1cmUpO1xuICAgIHRoaXMuZmVhdHVyZUNoYW5nZUtleXNfW2ZlYXR1cmVLZXldLmZvckVhY2godW5saXN0ZW5CeUtleSk7XG4gICAgZGVsZXRlIHRoaXMuZmVhdHVyZUNoYW5nZUtleXNfW2ZlYXR1cmVLZXldO1xuICAgIHZhciBpZCA9IGZlYXR1cmUuZ2V0SWQoKTtcbiAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZGVsZXRlIHRoaXMuaWRJbmRleF9baWQudG9TdHJpbmcoKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnVuZGVmSWRJbmRleF9bZmVhdHVyZUtleV07XG4gICAgfVxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgVmVjdG9yU291cmNlRXZlbnQoXG4gICAgICBWZWN0b3JFdmVudFR5cGUuUkVNT1ZFRkVBVFVSRSwgZmVhdHVyZSkpO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGZlYXR1cmUgZnJvbSB0aGUgaWQgaW5kZXguICBDYWxsZWQgaW50ZXJuYWxseSB3aGVuIHRoZSBmZWF0dXJlIGlkXG4gICAqIG1heSBoYXZlIGNoYW5nZWQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIFRoZSBmZWF0dXJlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBSZW1vdmVkIHRoZSBmZWF0dXJlIGZyb20gdGhlIGluZGV4LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgVmVjdG9yU291cmNlLnByb3RvdHlwZS5yZW1vdmVGcm9tSWRJbmRleF8gPSBmdW5jdGlvbiByZW1vdmVGcm9tSWRJbmRleF8gKGZlYXR1cmUpIHtcbiAgICB2YXIgcmVtb3ZlZCA9IGZhbHNlO1xuICAgIGZvciAodmFyIGlkIGluIHRoaXMuaWRJbmRleF8pIHtcbiAgICAgIGlmICh0aGlzLmlkSW5kZXhfW2lkXSA9PT0gZmVhdHVyZSkge1xuICAgICAgICBkZWxldGUgdGhpcy5pZEluZGV4X1tpZF07XG4gICAgICAgIHJlbW92ZWQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlbW92ZWQ7XG4gIH07XG5cblxuICAvKipcbiAgICogU2V0IHRoZSBuZXcgbG9hZGVyIG9mIHRoZSBzb3VyY2UuIFRoZSBuZXh0IGxvYWRGZWF0dXJlcyBjYWxsIHdpbGwgdXNlIHRoZVxuICAgKiBuZXcgbG9hZGVyLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2ZlYXR1cmVsb2FkZXIuanNcIikuRmVhdHVyZUxvYWRlcn0gbG9hZGVyIFRoZSBsb2FkZXIgdG8gc2V0LlxuICAgKiBAYXBpXG4gICAqL1xuICBWZWN0b3JTb3VyY2UucHJvdG90eXBlLnNldExvYWRlciA9IGZ1bmN0aW9uIHNldExvYWRlciAobG9hZGVyKSB7XG4gICAgdGhpcy5sb2FkZXJfID0gbG9hZGVyO1xuICB9O1xuXG4gIHJldHVybiBWZWN0b3JTb3VyY2U7XG59KFNvdXJjZSkpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IFZlY3RvclNvdXJjZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VmVjdG9yLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9zb3VyY2UvVmVjdG9yRXZlbnRUeXBlXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiBhIGZlYXR1cmUgaXMgYWRkZWQgdG8gdGhlIHNvdXJjZS5cbiAgICogQGV2ZW50IG9sL3NvdXJjZS9WZWN0b3IuVmVjdG9yU291cmNlRXZlbnQjYWRkZmVhdHVyZVxuICAgKiBAYXBpXG4gICAqL1xuICBBRERGRUFUVVJFOiAnYWRkZmVhdHVyZScsXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB3aGVuIGEgZmVhdHVyZSBpcyB1cGRhdGVkLlxuICAgKiBAZXZlbnQgb2wvc291cmNlL1ZlY3Rvci5WZWN0b3JTb3VyY2VFdmVudCNjaGFuZ2VmZWF0dXJlXG4gICAqIEBhcGlcbiAgICovXG4gIENIQU5HRUZFQVRVUkU6ICdjaGFuZ2VmZWF0dXJlJyxcblxuICAvKipcbiAgICogVHJpZ2dlcmVkIHdoZW4gdGhlIGNsZWFyIG1ldGhvZCBpcyBjYWxsZWQgb24gdGhlIHNvdXJjZS5cbiAgICogQGV2ZW50IG9sL3NvdXJjZS9WZWN0b3IuVmVjdG9yU291cmNlRXZlbnQjY2xlYXJcbiAgICogQGFwaVxuICAgKi9cbiAgQ0xFQVI6ICdjbGVhcicsXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB3aGVuIGEgZmVhdHVyZSBpcyByZW1vdmVkIGZyb20gdGhlIHNvdXJjZS5cbiAgICogU2VlIHtAbGluayBtb2R1bGU6b2wvc291cmNlL1ZlY3RvciNjbGVhciBzb3VyY2UuY2xlYXIoKX0gZm9yIGV4Y2VwdGlvbnMuXG4gICAqIEBldmVudCBvbC9zb3VyY2UvVmVjdG9yLlZlY3RvclNvdXJjZUV2ZW50I3JlbW92ZWZlYXR1cmVcbiAgICogQGFwaVxuICAgKi9cbiAgUkVNT1ZFRkVBVFVSRTogJ3JlbW92ZWZlYXR1cmUnXG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1WZWN0b3JFdmVudFR5cGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3NvdXJjZS9YWVpcbiAqL1xuXG5pbXBvcnQgVGlsZUltYWdlIGZyb20gJy4vVGlsZUltYWdlLmpzJztcbmltcG9ydCB7Y3JlYXRlWFlaLCBleHRlbnRGcm9tUHJvamVjdGlvbn0gZnJvbSAnLi4vdGlsZWdyaWQuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9Tb3VyY2UuanNcIikuQXR0cmlidXRpb25MaWtlfSBbYXR0cmlidXRpb25zXSBBdHRyaWJ1dGlvbnMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZT10cnVlXSBBdHRyaWJ1dGlvbnMgYXJlIGNvbGxhcHNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtjYWNoZVNpemU9MjA0OF0gQ2FjaGUgc2l6ZS5cbiAqIEBwcm9wZXJ0eSB7bnVsbHxzdHJpbmd9IFtjcm9zc09yaWdpbl0gVGhlIGBjcm9zc09yaWdpbmAgYXR0cmlidXRlIGZvciBsb2FkZWQgaW1hZ2VzLiAgTm90ZSB0aGF0XG4gKiB5b3UgbXVzdCBwcm92aWRlIGEgYGNyb3NzT3JpZ2luYCB2YWx1ZSBpZiB5b3UgYXJlIHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlciBvciBpZiB5b3Ugd2FudCB0b1xuICogYWNjZXNzIHBpeGVsIGRhdGEgd2l0aCB0aGUgQ2FudmFzIHJlbmRlcmVyLiAgU2VlXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0NPUlNfZW5hYmxlZF9pbWFnZSBmb3IgbW9yZSBkZXRhaWwuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtvcGFxdWU9dHJ1ZV0gV2hldGhlciB0aGUgbGF5ZXIgaXMgb3BhcXVlLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9wcm9qLmpzXCIpLlByb2plY3Rpb25MaWtlfSBbcHJvamVjdGlvbj0nRVBTRzozODU3J10gUHJvamVjdGlvbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmVwcm9qZWN0aW9uRXJyb3JUaHJlc2hvbGQ9MC41XSBNYXhpbXVtIGFsbG93ZWQgcmVwcm9qZWN0aW9uIGVycm9yIChpbiBwaXhlbHMpLlxuICogSGlnaGVyIHZhbHVlcyBjYW4gaW5jcmVhc2UgcmVwcm9qZWN0aW9uIHBlcmZvcm1hbmNlLCBidXQgZGVjcmVhc2UgcHJlY2lzaW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhab29tPTE4XSBPcHRpb25hbCBtYXggem9vbSBsZXZlbC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluWm9vbT0wXSBPcHRpb25hbCBtaW4gem9vbSBsZXZlbC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH0gW3RpbGVHcmlkXSBUaWxlIGdyaWQuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL1RpbGUuanNcIikuTG9hZEZ1bmN0aW9ufSBbdGlsZUxvYWRGdW5jdGlvbl0gT3B0aW9uYWwgZnVuY3Rpb24gdG8gbG9hZCBhIHRpbGUgZ2l2ZW4gYSBVUkwuIFRoZSBkZWZhdWx0IGlzXG4gKiBgYGBqc1xuICogZnVuY3Rpb24oaW1hZ2VUaWxlLCBzcmMpIHtcbiAqICAgaW1hZ2VUaWxlLmdldEltYWdlKCkuc3JjID0gc3JjO1xuICogfTtcbiAqIGBgYFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0aWxlUGl4ZWxSYXRpbz0xXSBUaGUgcGl4ZWwgcmF0aW8gdXNlZCBieSB0aGUgdGlsZSBzZXJ2aWNlLlxuICogRm9yIGV4YW1wbGUsIGlmIHRoZSB0aWxlIHNlcnZpY2UgYWR2ZXJ0aXplcyAyNTZweCBieSAyNTZweCB0aWxlcyBidXQgYWN0dWFsbHkgc2VuZHMgNTEycHhcbiAqIGJ5IDUxMnB4IGltYWdlcyAoZm9yIHJldGluYS9oaWRwaSBkZXZpY2VzKSB0aGVuIGB0aWxlUGl4ZWxSYXRpb2BcbiAqIHNob3VsZCBiZSBzZXQgdG8gYDJgLlxuICogQHByb3BlcnR5IHtudW1iZXJ8aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBbdGlsZVNpemU9WzI1NiwgMjU2XV0gVGhlIHRpbGUgc2l6ZSB1c2VkIGJ5IHRoZSB0aWxlIHNlcnZpY2UuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL1RpbGUuanNcIikuVXJsRnVuY3Rpb259IFt0aWxlVXJsRnVuY3Rpb25dIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGdldFxuICogdGlsZSBVUkwgZ2l2ZW4gYSB0aWxlIGNvb3JkaW5hdGUgYW5kIHRoZSBwcm9qZWN0aW9uLlxuICogUmVxdWlyZWQgaWYgdXJsIG9yIHVybHMgYXJlIG5vdCBwcm92aWRlZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdXJsXSBVUkwgdGVtcGxhdGUuIE11c3QgaW5jbHVkZSBge3h9YCwgYHt5fWAgb3IgYHsteX1gLFxuICogYW5kIGB7en1gIHBsYWNlaG9sZGVycy4gQSBgez8tP31gIHRlbXBsYXRlIHBhdHRlcm4sIGZvciBleGFtcGxlIGBzdWJkb21haW57YS1mfS5kb21haW4uY29tYCxcbiAqIG1heSBiZSB1c2VkIGluc3RlYWQgb2YgZGVmaW5pbmcgZWFjaCBvbmUgc2VwYXJhdGVseSBpbiB0aGUgYHVybHNgIG9wdGlvbi5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8c3RyaW5nPn0gW3VybHNdIEFuIGFycmF5IG9mIFVSTCB0ZW1wbGF0ZXMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt3cmFwWD10cnVlXSBXaGV0aGVyIHRvIHdyYXAgdGhlIHdvcmxkIGhvcml6b250YWxseS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdHJhbnNpdGlvbl0gRHVyYXRpb24gb2YgdGhlIG9wYWNpdHkgdHJhbnNpdGlvbiBmb3IgcmVuZGVyaW5nLlxuICogVG8gZGlzYWJsZSB0aGUgb3BhY2l0eSB0cmFuc2l0aW9uLCBwYXNzIGB0cmFuc2l0aW9uOiAwYC5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogTGF5ZXIgc291cmNlIGZvciB0aWxlIGRhdGEgd2l0aCBVUkxzIGluIGEgc2V0IFhZWiBmb3JtYXQgdGhhdCBhcmVcbiAqIGRlZmluZWQgaW4gYSBVUkwgdGVtcGxhdGUuIEJ5IGRlZmF1bHQsIHRoaXMgZm9sbG93cyB0aGUgd2lkZWx5LXVzZWRcbiAqIEdvb2dsZSBncmlkIHdoZXJlIGB4YCAwIGFuZCBgeWAgMCBhcmUgaW4gdGhlIHRvcCBsZWZ0LiBHcmlkcyBsaWtlXG4gKiBUTVMgd2hlcmUgYHhgIDAgYW5kIGB5YCAwIGFyZSBpbiB0aGUgYm90dG9tIGxlZnQgY2FuIGJlIHVzZWQgYnlcbiAqIHVzaW5nIHRoZSBgey15fWAgcGxhY2Vob2xkZXIgaW4gdGhlIFVSTCB0ZW1wbGF0ZSwgc28gbG9uZyBhcyB0aGVcbiAqIHNvdXJjZSBkb2VzIG5vdCBoYXZlIGEgY3VzdG9tIHRpbGUgZ3JpZC4gSW4gdGhpcyBjYXNlLFxuICoge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVGlsZUltYWdlfSBjYW4gYmUgdXNlZCB3aXRoIGEgYHRpbGVVcmxGdW5jdGlvbmBcbiAqIHN1Y2ggYXM6XG4gKlxuICogIHRpbGVVcmxGdW5jdGlvbjogZnVuY3Rpb24oY29vcmRpbmF0ZSkge1xuICogICAgcmV0dXJuICdodHRwOi8vbWFwc2VydmVyLmNvbS8nICsgY29vcmRpbmF0ZVswXSArICcvJyArXG4gKiAgICAgICAgY29vcmRpbmF0ZVsxXSArICcvJyArIGNvb3JkaW5hdGVbMl0gKyAnLnBuZyc7XG4gKiAgICB9XG4gKlxuICogQGFwaVxuICovXG52YXIgWFlaID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoVGlsZUltYWdlKSB7XG4gIGZ1bmN0aW9uIFhZWihvcHRfb3B0aW9ucykge1xuICAgIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgfHwge307XG4gICAgdmFyIHByb2plY3Rpb24gPSBvcHRpb25zLnByb2plY3Rpb24gIT09IHVuZGVmaW5lZCA/XG4gICAgICBvcHRpb25zLnByb2plY3Rpb24gOiAnRVBTRzozODU3JztcblxuICAgIHZhciB0aWxlR3JpZCA9IG9wdGlvbnMudGlsZUdyaWQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudGlsZUdyaWQgOlxuICAgICAgY3JlYXRlWFlaKHtcbiAgICAgICAgZXh0ZW50OiBleHRlbnRGcm9tUHJvamVjdGlvbihwcm9qZWN0aW9uKSxcbiAgICAgICAgbWF4Wm9vbTogb3B0aW9ucy5tYXhab29tLFxuICAgICAgICBtaW5ab29tOiBvcHRpb25zLm1pblpvb20sXG4gICAgICAgIHRpbGVTaXplOiBvcHRpb25zLnRpbGVTaXplXG4gICAgICB9KTtcblxuICAgIFRpbGVJbWFnZS5jYWxsKHRoaXMsIHtcbiAgICAgIGF0dHJpYnV0aW9uczogb3B0aW9ucy5hdHRyaWJ1dGlvbnMsXG4gICAgICBjYWNoZVNpemU6IG9wdGlvbnMuY2FjaGVTaXplLFxuICAgICAgY3Jvc3NPcmlnaW46IG9wdGlvbnMuY3Jvc3NPcmlnaW4sXG4gICAgICBvcGFxdWU6IG9wdGlvbnMub3BhcXVlLFxuICAgICAgcHJvamVjdGlvbjogcHJvamVjdGlvbixcbiAgICAgIHJlcHJvamVjdGlvbkVycm9yVGhyZXNob2xkOiBvcHRpb25zLnJlcHJvamVjdGlvbkVycm9yVGhyZXNob2xkLFxuICAgICAgdGlsZUdyaWQ6IHRpbGVHcmlkLFxuICAgICAgdGlsZUxvYWRGdW5jdGlvbjogb3B0aW9ucy50aWxlTG9hZEZ1bmN0aW9uLFxuICAgICAgdGlsZVBpeGVsUmF0aW86IG9wdGlvbnMudGlsZVBpeGVsUmF0aW8sXG4gICAgICB0aWxlVXJsRnVuY3Rpb246IG9wdGlvbnMudGlsZVVybEZ1bmN0aW9uLFxuICAgICAgdXJsOiBvcHRpb25zLnVybCxcbiAgICAgIHVybHM6IG9wdGlvbnMudXJscyxcbiAgICAgIHdyYXBYOiBvcHRpb25zLndyYXBYICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLndyYXBYIDogdHJ1ZSxcbiAgICAgIHRyYW5zaXRpb246IG9wdGlvbnMudHJhbnNpdGlvbixcbiAgICAgIGF0dHJpYnV0aW9uc0NvbGxhcHNpYmxlOiBvcHRpb25zLmF0dHJpYnV0aW9uc0NvbGxhcHNpYmxlXG4gICAgfSk7XG5cbiAgfVxuXG4gIGlmICggVGlsZUltYWdlICkgWFlaLl9fcHJvdG9fXyA9IFRpbGVJbWFnZTtcbiAgWFlaLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRpbGVJbWFnZSAmJiBUaWxlSW1hZ2UucHJvdG90eXBlICk7XG4gIFhZWi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBYWVo7XG5cbiAgcmV0dXJuIFhZWjtcbn0oVGlsZUltYWdlKSk7XG5cbmV4cG9ydCBkZWZhdWx0IFhZWjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9WFlaLmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIExhdGl0dWRlL2xvbmdpdHVkZSBzcGhlcmljYWwgZ2VvZGVzeSBmb3JtdWxhZSB0YWtlbiBmcm9tXG4gKiBodHRwOi8vd3d3Lm1vdmFibGUtdHlwZS5jby51ay9zY3JpcHRzL2xhdGxvbmcuaHRtbFxuICogTGljZW5zZWQgdW5kZXIgQ0MtQlktMy4wLlxuICovXG5cbi8qKlxuICogQG1vZHVsZSBvbC9zcGhlcmVcbiAqL1xuaW1wb3J0IHt0b1JhZGlhbnMsIHRvRGVncmVlc30gZnJvbSAnLi9tYXRoLmpzJztcbmltcG9ydCBHZW9tZXRyeVR5cGUgZnJvbSAnLi9nZW9tL0dlb21ldHJ5VHlwZS5qcyc7XG5cblxuLyoqXG4gKiBPYmplY3QgbGl0ZXJhbCB3aXRoIG9wdGlvbnMgZm9yIHRoZSB7QGxpbmsgZ2V0TGVuZ3RofSBvciB7QGxpbmsgZ2V0QXJlYX1cbiAqIGZ1bmN0aW9ucy5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNwaGVyZU1ldHJpY09wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9wcm9qLmpzXCIpLlByb2plY3Rpb25MaWtlfSBbcHJvamVjdGlvbj0nRVBTRzozODU3J11cbiAqIFByb2plY3Rpb24gb2YgdGhlICBnZW9tZXRyeS4gIEJ5IGRlZmF1bHQsIHRoZSBnZW9tZXRyeSBpcyBhc3N1bWVkIHRvIGJlIGluXG4gKiBXZWIgTWVyY2F0b3IuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JhZGl1cz02MzcxMDA4LjhdIFNwaGVyZSByYWRpdXMuICBCeSBkZWZhdWx0LCB0aGUgcmFkaXVzIG9mIHRoZVxuICogZWFydGggaXMgdXNlZCAoQ2xhcmtlIDE4NjYgQXV0aGFsaWMgU3BoZXJlKS5cbiAqL1xuXG5cbi8qKlxuICogVGhlIG1lYW4gRWFydGggcmFkaXVzICgxLzMgKiAoMmEgKyBiKSkgZm9yIHRoZSBXR1M4NCBlbGxpcHNvaWQuXG4gKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FYXJ0aF9yYWRpdXMjTWVhbl9yYWRpdXNcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgREVGQVVMVF9SQURJVVMgPSA2MzcxMDA4Ljg7XG5cblxuLyoqXG4gKiBHZXQgdGhlIGdyZWF0IGNpcmNsZSBkaXN0YW5jZSAoaW4gbWV0ZXJzKSBiZXR3ZWVuIHR3byBnZW9ncmFwaGljIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtBcnJheX0gYzEgU3RhcnRpbmcgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7QXJyYXl9IGMyIEVuZGluZyBjb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfcmFkaXVzIFRoZSBzcGhlcmUgcmFkaXVzIHRvIHVzZS4gIERlZmF1bHRzIHRvIHRoZSBFYXJ0aCdzXG4gKiAgICAgbWVhbiByYWRpdXMgdXNpbmcgdGhlIFdHUzg0IGVsbGlwc29pZC5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGdyZWF0IGNpcmNsZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBwb2ludHMgKGluIG1ldGVycykuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREaXN0YW5jZShjMSwgYzIsIG9wdF9yYWRpdXMpIHtcbiAgdmFyIHJhZGl1cyA9IG9wdF9yYWRpdXMgfHwgREVGQVVMVF9SQURJVVM7XG4gIHZhciBsYXQxID0gdG9SYWRpYW5zKGMxWzFdKTtcbiAgdmFyIGxhdDIgPSB0b1JhZGlhbnMoYzJbMV0pO1xuICB2YXIgZGVsdGFMYXRCeTIgPSAobGF0MiAtIGxhdDEpIC8gMjtcbiAgdmFyIGRlbHRhTG9uQnkyID0gdG9SYWRpYW5zKGMyWzBdIC0gYzFbMF0pIC8gMjtcbiAgdmFyIGEgPSBNYXRoLnNpbihkZWx0YUxhdEJ5MikgKiBNYXRoLnNpbihkZWx0YUxhdEJ5MikgK1xuICAgICAgTWF0aC5zaW4oZGVsdGFMb25CeTIpICogTWF0aC5zaW4oZGVsdGFMb25CeTIpICpcbiAgICAgIE1hdGguY29zKGxhdDEpICogTWF0aC5jb3MobGF0Mik7XG4gIHJldHVybiAyICogcmFkaXVzICogTWF0aC5hdGFuMihNYXRoLnNxcnQoYSksIE1hdGguc3FydCgxIC0gYSkpO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBjdW11bGF0aXZlIGdyZWF0IGNpcmNsZSBsZW5ndGggb2YgbGluZXN0cmluZyBjb29yZGluYXRlcyAoZ2VvZ3JhcGhpYykuXG4gKiBAcGFyYW0ge0FycmF5fSBjb29yZGluYXRlcyBMaW5lc3RyaW5nIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBUaGUgc3BoZXJlIHJhZGl1cyB0byB1c2UuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBsZW5ndGggKGluIG1ldGVycykuXG4gKi9cbmZ1bmN0aW9uIGdldExlbmd0aEludGVybmFsKGNvb3JkaW5hdGVzLCByYWRpdXMpIHtcbiAgdmFyIGxlbmd0aCA9IDA7XG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpIC0gMTsgKytpKSB7XG4gICAgbGVuZ3RoICs9IGdldERpc3RhbmNlKGNvb3JkaW5hdGVzW2ldLCBjb29yZGluYXRlc1tpICsgMV0sIHJhZGl1cyk7XG4gIH1cbiAgcmV0dXJuIGxlbmd0aDtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgc3BoZXJpY2FsIGxlbmd0aCBvZiBhIGdlb21ldHJ5LiAgVGhpcyBsZW5ndGggaXMgdGhlIHN1bSBvZiB0aGVcbiAqIGdyZWF0IGNpcmNsZSBkaXN0YW5jZXMgYmV0d2VlbiBjb29yZGluYXRlcy4gIEZvciBwb2x5Z29ucywgdGhlIGxlbmd0aCBpc1xuICogdGhlIHN1bSBvZiBhbGwgcmluZ3MuICBGb3IgcG9pbnRzLCB0aGUgbGVuZ3RoIGlzIHplcm8uICBGb3IgbXVsdGktcGFydFxuICogZ2VvbWV0cmllcywgdGhlIGxlbmd0aCBpcyB0aGUgc3VtIG9mIHRoZSBsZW5ndGggb2YgZWFjaCBwYXJ0LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgQSBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7U3BoZXJlTWV0cmljT3B0aW9ucz19IG9wdF9vcHRpb25zIE9wdGlvbnMgZm9yIHRoZVxuICogbGVuZ3RoIGNhbGN1bGF0aW9uLiAgQnkgZGVmYXVsdCwgZ2VvbWV0cmllcyBhcmUgYXNzdW1lZCB0byBiZSBpbiAnRVBTRzozODU3Jy5cbiAqIFlvdSBjYW4gY2hhbmdlIHRoaXMgYnkgcHJvdmlkaW5nIGEgYHByb2plY3Rpb25gIG9wdGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHNwaGVyaWNhbCBsZW5ndGggKGluIG1ldGVycykuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMZW5ndGgoZ2VvbWV0cnksIG9wdF9vcHRpb25zKSB7XG4gIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgfHwge307XG4gIHZhciByYWRpdXMgPSBvcHRpb25zLnJhZGl1cyB8fCBERUZBVUxUX1JBRElVUztcbiAgdmFyIHByb2plY3Rpb24gPSBvcHRpb25zLnByb2plY3Rpb24gfHwgJ0VQU0c6Mzg1Nyc7XG4gIHZhciB0eXBlID0gZ2VvbWV0cnkuZ2V0VHlwZSgpO1xuICBpZiAodHlwZSAhPT0gR2VvbWV0cnlUeXBlLkdFT01FVFJZX0NPTExFQ1RJT04pIHtcbiAgICBnZW9tZXRyeSA9IGdlb21ldHJ5LmNsb25lKCkudHJhbnNmb3JtKHByb2plY3Rpb24sICdFUFNHOjQzMjYnKTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gMDtcbiAgdmFyIGNvb3JkaW5hdGVzLCBjb29yZHMsIGksIGlpLCBqLCBqajtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBHZW9tZXRyeVR5cGUuUE9JTlQ6XG4gICAgY2FzZSBHZW9tZXRyeVR5cGUuTVVMVElfUE9JTlQ6IHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIEdlb21ldHJ5VHlwZS5MSU5FX1NUUklORzpcbiAgICBjYXNlIEdlb21ldHJ5VHlwZS5MSU5FQVJfUklORzoge1xuICAgICAgY29vcmRpbmF0ZXMgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSAqLyAoZ2VvbWV0cnkpLmdldENvb3JkaW5hdGVzKCk7XG4gICAgICBsZW5ndGggPSBnZXRMZW5ndGhJbnRlcm5hbChjb29yZGluYXRlcywgcmFkaXVzKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIEdlb21ldHJ5VHlwZS5NVUxUSV9MSU5FX1NUUklORzpcbiAgICBjYXNlIEdlb21ldHJ5VHlwZS5QT0xZR09OOiB7XG4gICAgICBjb29yZGluYXRlcyA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR9ICovIChnZW9tZXRyeSkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIGZvciAoaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBsZW5ndGggKz0gZ2V0TGVuZ3RoSW50ZXJuYWwoY29vcmRpbmF0ZXNbaV0sIHJhZGl1cyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBHZW9tZXRyeVR5cGUuTVVMVElfUE9MWUdPTjoge1xuICAgICAgY29vcmRpbmF0ZXMgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSAqLyAoZ2VvbWV0cnkpLmdldENvb3JkaW5hdGVzKCk7XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgY29vcmRzID0gY29vcmRpbmF0ZXNbaV07XG4gICAgICAgIGZvciAoaiA9IDAsIGpqID0gY29vcmRzLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICAgICAgICBsZW5ndGggKz0gZ2V0TGVuZ3RoSW50ZXJuYWwoY29vcmRzW2pdLCByYWRpdXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBHZW9tZXRyeVR5cGUuR0VPTUVUUllfQ09MTEVDVElPTjoge1xuICAgICAgdmFyIGdlb21ldHJpZXMgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vZ2VvbS9HZW9tZXRyeUNvbGxlY3Rpb24uanNcIikuZGVmYXVsdH0gKi8gKGdlb21ldHJ5KS5nZXRHZW9tZXRyaWVzKCk7XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IGdlb21ldHJpZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBsZW5ndGggKz0gZ2V0TGVuZ3RoKGdlb21ldHJpZXNbaV0sIG9wdF9vcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGdlb21ldHJ5IHR5cGU6ICcgKyB0eXBlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxlbmd0aDtcbn1cblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNwaGVyaWNhbCBhcmVhIGZvciBhIGxpc3Qgb2YgY29vcmRpbmF0ZXMuXG4gKlxuICogW1JlZmVyZW5jZV0oaHR0cHM6Ly90cnMtbmV3LmpwbC5uYXNhLmdvdi9oYW5kbGUvMjAxNC80MDQwOSlcbiAqIFJvYmVydC4gRy4gQ2hhbWJlcmxhaW4gYW5kIFdpbGxpYW0gSC4gRHVxdWV0dGUsIFwiU29tZSBBbGdvcml0aG1zIGZvclxuICogUG9seWdvbnMgb24gYSBTcGhlcmVcIiwgSlBMIFB1YmxpY2F0aW9uIDA3LTAzLCBKZXQgUHJvcHVsc2lvblxuICogTGFib3JhdG9yeSwgUGFzYWRlbmEsIENBLCBKdW5lIDIwMDdcbiAqXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn0gY29vcmRpbmF0ZXMgTGlzdCBvZiBjb29yZGluYXRlcyBvZiBhIGxpbmVhclxuICogcmluZy4gSWYgdGhlIHJpbmcgaXMgb3JpZW50ZWQgY2xvY2t3aXNlLCB0aGUgYXJlYSB3aWxsIGJlIHBvc2l0aXZlLFxuICogb3RoZXJ3aXNlIGl0IHdpbGwgYmUgbmVnYXRpdmUuXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFRoZSBzcGhlcmUgcmFkaXVzLlxuICogQHJldHVybiB7bnVtYmVyfSBBcmVhIChpbiBzcXVhcmUgbWV0ZXJzKS5cbiAqL1xuZnVuY3Rpb24gZ2V0QXJlYUludGVybmFsKGNvb3JkaW5hdGVzLCByYWRpdXMpIHtcbiAgdmFyIGFyZWEgPSAwO1xuICB2YXIgbGVuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICB2YXIgeDEgPSBjb29yZGluYXRlc1tsZW4gLSAxXVswXTtcbiAgdmFyIHkxID0gY29vcmRpbmF0ZXNbbGVuIC0gMV1bMV07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgeDIgPSBjb29yZGluYXRlc1tpXVswXTtcbiAgICB2YXIgeTIgPSBjb29yZGluYXRlc1tpXVsxXTtcbiAgICBhcmVhICs9IHRvUmFkaWFucyh4MiAtIHgxKSAqXG4gICAgICAgICgyICsgTWF0aC5zaW4odG9SYWRpYW5zKHkxKSkgK1xuICAgICAgICBNYXRoLnNpbih0b1JhZGlhbnMoeTIpKSk7XG4gICAgeDEgPSB4MjtcbiAgICB5MSA9IHkyO1xuICB9XG4gIHJldHVybiBhcmVhICogcmFkaXVzICogcmFkaXVzIC8gMi4wO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBzcGhlcmljYWwgYXJlYSBvZiBhIGdlb21ldHJ5LiAgVGhpcyBpcyB0aGUgYXJlYSAoaW4gbWV0ZXJzKSBhc3N1bWluZ1xuICogdGhhdCBwb2x5Z29uIGVkZ2VzIGFyZSBzZWdtZW50cyBvZiBncmVhdCBjaXJjbGVzIG9uIGEgc3BoZXJlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgQSBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7U3BoZXJlTWV0cmljT3B0aW9ucz19IG9wdF9vcHRpb25zIE9wdGlvbnMgZm9yIHRoZSBhcmVhXG4gKiAgICAgY2FsY3VsYXRpb24uICBCeSBkZWZhdWx0LCBnZW9tZXRyaWVzIGFyZSBhc3N1bWVkIHRvIGJlIGluICdFUFNHOjM4NTcnLlxuICogICAgIFlvdSBjYW4gY2hhbmdlIHRoaXMgYnkgcHJvdmlkaW5nIGEgYHByb2plY3Rpb25gIG9wdGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHNwaGVyaWNhbCBhcmVhIChpbiBzcXVhcmUgbWV0ZXJzKS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFyZWEoZ2VvbWV0cnksIG9wdF9vcHRpb25zKSB7XG4gIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgfHwge307XG4gIHZhciByYWRpdXMgPSBvcHRpb25zLnJhZGl1cyB8fCBERUZBVUxUX1JBRElVUztcbiAgdmFyIHByb2plY3Rpb24gPSBvcHRpb25zLnByb2plY3Rpb24gfHwgJ0VQU0c6Mzg1Nyc7XG4gIHZhciB0eXBlID0gZ2VvbWV0cnkuZ2V0VHlwZSgpO1xuICBpZiAodHlwZSAhPT0gR2VvbWV0cnlUeXBlLkdFT01FVFJZX0NPTExFQ1RJT04pIHtcbiAgICBnZW9tZXRyeSA9IGdlb21ldHJ5LmNsb25lKCkudHJhbnNmb3JtKHByb2plY3Rpb24sICdFUFNHOjQzMjYnKTtcbiAgfVxuICB2YXIgYXJlYSA9IDA7XG4gIHZhciBjb29yZGluYXRlcywgY29vcmRzLCBpLCBpaSwgaiwgamo7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgR2VvbWV0cnlUeXBlLlBPSU5UOlxuICAgIGNhc2UgR2VvbWV0cnlUeXBlLk1VTFRJX1BPSU5UOlxuICAgIGNhc2UgR2VvbWV0cnlUeXBlLkxJTkVfU1RSSU5HOlxuICAgIGNhc2UgR2VvbWV0cnlUeXBlLk1VTFRJX0xJTkVfU1RSSU5HOlxuICAgIGNhc2UgR2VvbWV0cnlUeXBlLkxJTkVBUl9SSU5HOiB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBHZW9tZXRyeVR5cGUuUE9MWUdPTjoge1xuICAgICAgY29vcmRpbmF0ZXMgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vZ2VvbS9Qb2x5Z29uLmpzXCIpLmRlZmF1bHR9ICovIChnZW9tZXRyeSkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIGFyZWEgPSBNYXRoLmFicyhnZXRBcmVhSW50ZXJuYWwoY29vcmRpbmF0ZXNbMF0sIHJhZGl1cykpO1xuICAgICAgZm9yIChpID0gMSwgaWkgPSBjb29yZGluYXRlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGFyZWEgLT0gTWF0aC5hYnMoZ2V0QXJlYUludGVybmFsKGNvb3JkaW5hdGVzW2ldLCByYWRpdXMpKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIEdlb21ldHJ5VHlwZS5NVUxUSV9QT0xZR09OOiB7XG4gICAgICBjb29yZGluYXRlcyA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR9ICovIChnZW9tZXRyeSkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIGZvciAoaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBjb29yZHMgPSBjb29yZGluYXRlc1tpXTtcbiAgICAgICAgYXJlYSArPSBNYXRoLmFicyhnZXRBcmVhSW50ZXJuYWwoY29vcmRzWzBdLCByYWRpdXMpKTtcbiAgICAgICAgZm9yIChqID0gMSwgamogPSBjb29yZHMubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgICAgIGFyZWEgLT0gTWF0aC5hYnMoZ2V0QXJlYUludGVybmFsKGNvb3Jkc1tqXSwgcmFkaXVzKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIEdlb21ldHJ5VHlwZS5HRU9NRVRSWV9DT0xMRUNUSU9OOiB7XG4gICAgICB2YXIgZ2VvbWV0cmllcyA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9nZW9tL0dlb21ldHJ5Q29sbGVjdGlvbi5qc1wiKS5kZWZhdWx0fSAqLyAoZ2VvbWV0cnkpLmdldEdlb21ldHJpZXMoKTtcbiAgICAgIGZvciAoaSA9IDAsIGlpID0gZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGFyZWEgKz0gZ2V0QXJlYShnZW9tZXRyaWVzW2ldLCBvcHRfb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBnZW9tZXRyeSB0eXBlOiAnICsgdHlwZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcmVhO1xufVxuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgY29vcmRpbmF0ZSBhdCB0aGUgZ2l2ZW4gZGlzdGFuY2UgYW5kIGJlYXJpbmcgZnJvbSBgYzFgLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGMxIFRoZSBvcmlnaW4gcG9pbnQgKGBbbG9uLCBsYXRdYCBpbiBkZWdyZWVzKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZSBUaGUgZ3JlYXQtY2lyY2xlIGRpc3RhbmNlIGJldHdlZW4gdGhlIG9yaWdpblxuICogICAgIHBvaW50IGFuZCB0aGUgdGFyZ2V0IHBvaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IGJlYXJpbmcgVGhlIGJlYXJpbmcgKGluIHJhZGlhbnMpLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfcmFkaXVzIFRoZSBzcGhlcmUgcmFkaXVzIHRvIHVzZS4gIERlZmF1bHRzIHRvIHRoZSBFYXJ0aCdzXG4gKiAgICAgbWVhbiByYWRpdXMgdXNpbmcgdGhlIFdHUzg0IGVsbGlwc29pZC5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBUaGUgdGFyZ2V0IHBvaW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gb2Zmc2V0KGMxLCBkaXN0YW5jZSwgYmVhcmluZywgb3B0X3JhZGl1cykge1xuICB2YXIgcmFkaXVzID0gb3B0X3JhZGl1cyB8fCBERUZBVUxUX1JBRElVUztcbiAgdmFyIGxhdDEgPSB0b1JhZGlhbnMoYzFbMV0pO1xuICB2YXIgbG9uMSA9IHRvUmFkaWFucyhjMVswXSk7XG4gIHZhciBkQnlSID0gZGlzdGFuY2UgLyByYWRpdXM7XG4gIHZhciBsYXQgPSBNYXRoLmFzaW4oXG4gICAgTWF0aC5zaW4obGF0MSkgKiBNYXRoLmNvcyhkQnlSKSArXG4gICAgICBNYXRoLmNvcyhsYXQxKSAqIE1hdGguc2luKGRCeVIpICogTWF0aC5jb3MoYmVhcmluZykpO1xuICB2YXIgbG9uID0gbG9uMSArIE1hdGguYXRhbjIoXG4gICAgTWF0aC5zaW4oYmVhcmluZykgKiBNYXRoLnNpbihkQnlSKSAqIE1hdGguY29zKGxhdDEpLFxuICAgIE1hdGguY29zKGRCeVIpIC0gTWF0aC5zaW4obGF0MSkgKiBNYXRoLnNpbihsYXQpKTtcbiAgcmV0dXJuIFt0b0RlZ3JlZXMobG9uKSwgdG9EZWdyZWVzKGxhdCldO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zcGhlcmUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3N0cmluZ1xuICovXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBOdW1iZXIgdG8gYmUgZm9ybWF0dGVkXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggVGhlIGRlc2lyZWQgd2lkdGhcbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X3ByZWNpc2lvbiBQcmVjaXNpb24gb2YgdGhlIG91dHB1dCBzdHJpbmcgKGkuZS4gbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzKVxuICogQHJldHVybnMge3N0cmluZ30gRm9ybWF0dGVkIHN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gcGFkTnVtYmVyKG51bWJlciwgd2lkdGgsIG9wdF9wcmVjaXNpb24pIHtcbiAgdmFyIG51bWJlclN0cmluZyA9IG9wdF9wcmVjaXNpb24gIT09IHVuZGVmaW5lZCA/IG51bWJlci50b0ZpeGVkKG9wdF9wcmVjaXNpb24pIDogJycgKyBudW1iZXI7XG4gIHZhciBkZWNpbWFsID0gbnVtYmVyU3RyaW5nLmluZGV4T2YoJy4nKTtcbiAgZGVjaW1hbCA9IGRlY2ltYWwgPT09IC0xID8gbnVtYmVyU3RyaW5nLmxlbmd0aCA6IGRlY2ltYWw7XG4gIHJldHVybiBkZWNpbWFsID4gd2lkdGggPyBudW1iZXJTdHJpbmcgOiBuZXcgQXJyYXkoMSArIHdpZHRoIC0gZGVjaW1hbCkuam9pbignMCcpICsgbnVtYmVyU3RyaW5nO1xufVxuXG5cbi8qKlxuICogQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9vbWljaGVsc2VuL2NvbXBhcmUtdmVyc2lvbnMvYmxvYi9tYXN0ZXIvaW5kZXguanNcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdjEgRmlyc3QgdmVyc2lvblxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2MiBTZWNvbmQgdmVyc2lvblxuICogQHJldHVybnMge251bWJlcn0gVmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVWZXJzaW9ucyh2MSwgdjIpIHtcbiAgdmFyIHMxID0gKCcnICsgdjEpLnNwbGl0KCcuJyk7XG4gIHZhciBzMiA9ICgnJyArIHYyKS5zcGxpdCgnLicpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgTWF0aC5tYXgoczEubGVuZ3RoLCBzMi5sZW5ndGgpOyBpKyspIHtcbiAgICB2YXIgbjEgPSBwYXJzZUludChzMVtpXSB8fCAnMCcsIDEwKTtcbiAgICB2YXIgbjIgPSBwYXJzZUludChzMltpXSB8fCAnMCcsIDEwKTtcblxuICAgIGlmIChuMSA+IG4yKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKG4yID4gbjEpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyaW5nLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9zdHJ1Y3RzL0xSVUNhY2hlXG4gKi9cblxuaW1wb3J0IHthc3NlcnR9IGZyb20gJy4uL2Fzc2VydHMuanMnO1xuaW1wb3J0IEV2ZW50VGFyZ2V0IGZyb20gJy4uL2V2ZW50cy9UYXJnZXQuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEVudHJ5XG4gKiBAcHJvcGVydHkge3N0cmluZ30ga2V5X1xuICogQHByb3BlcnR5IHtPYmplY3R9IG5ld2VyXG4gKiBAcHJvcGVydHkge09iamVjdH0gb2xkZXJcbiAqIEBwcm9wZXJ0eSB7Kn0gdmFsdWVfXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEltcGxlbWVudHMgYSBMZWFzdC1SZWNlbnRseS1Vc2VkIGNhY2hlIHdoZXJlIHRoZSBrZXlzIGRvIG5vdCBjb25mbGljdCB3aXRoXG4gKiBPYmplY3QncyBwcm9wZXJ0aWVzIChlLmcuICdoYXNPd25Qcm9wZXJ0eScgaXMgbm90IGFsbG93ZWQgYXMgYSBrZXkpLiBFeHBpcmluZ1xuICogaXRlbXMgZnJvbSB0aGUgY2FjaGUgaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSB1c2VyLlxuICpcbiAqIEBmaXJlcyBpbXBvcnQoXCIuLi9ldmVudHMvRXZlbnQuanNcIikuRXZlbnRcbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbnZhciBMUlVDYWNoZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEV2ZW50VGFyZ2V0KSB7XG4gIGZ1bmN0aW9uIExSVUNhY2hlKG9wdF9oaWdoV2F0ZXJNYXJrKSB7XG5cbiAgICBFdmVudFRhcmdldC5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBvcHRfaGlnaFdhdGVyTWFyayAhPT0gdW5kZWZpbmVkID8gb3B0X2hpZ2hXYXRlck1hcmsgOiAyMDQ4O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuY291bnRfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBFbnRyeT59XG4gICAgICovXG4gICAgdGhpcy5lbnRyaWVzXyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P0VudHJ5fVxuICAgICAqL1xuICAgIHRoaXMub2xkZXN0XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/RW50cnl9XG4gICAgICovXG4gICAgdGhpcy5uZXdlc3RfID0gbnVsbDtcblxuICB9XG5cbiAgaWYgKCBFdmVudFRhcmdldCApIExSVUNhY2hlLl9fcHJvdG9fXyA9IEV2ZW50VGFyZ2V0O1xuICBMUlVDYWNoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFdmVudFRhcmdldCAmJiBFdmVudFRhcmdldC5wcm90b3R5cGUgKTtcbiAgTFJVQ2FjaGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTFJVQ2FjaGU7XG5cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gQ2FuIGV4cGlyZSBjYWNoZS5cbiAgICovXG4gIExSVUNhY2hlLnByb3RvdHlwZS5jYW5FeHBpcmVDYWNoZSA9IGZ1bmN0aW9uIGNhbkV4cGlyZUNhY2hlICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDb3VudCgpID4gdGhpcy5oaWdoV2F0ZXJNYXJrO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEZJWE1FIGVtcHR5IGRlc2NyaXB0aW9uIGZvciBqc2RvY1xuICAgKi9cbiAgTFJVQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICAgIHRoaXMuY291bnRfID0gMDtcbiAgICB0aGlzLmVudHJpZXNfID0ge307XG4gICAgdGhpcy5vbGRlc3RfID0gbnVsbDtcbiAgICB0aGlzLm5ld2VzdF8gPSBudWxsO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudFR5cGUuQ0xFQVIpO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgS2V5LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBDb250YWlucyBrZXkuXG4gICAqL1xuICBMUlVDYWNoZS5wcm90b3R5cGUuY29udGFpbnNLZXkgPSBmdW5jdGlvbiBjb250YWluc0tleSAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuZW50cmllc18uaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6IFMsIFQsIHN0cmluZywgTFJVQ2FjaGUpOiA/fSBmIFRoZSBmdW5jdGlvblxuICAgKiAgICAgdG8gY2FsbCBmb3IgZXZlcnkgZW50cnkgZnJvbSB0aGUgb2xkZXN0IHRvIHRoZSBuZXdlci4gVGhpcyBmdW5jdGlvbiB0YWtlc1xuICAgKiAgICAgMyBhcmd1bWVudHMgKHRoZSBlbnRyeSB2YWx1ZSwgdGhlIGVudHJ5IGtleSBhbmQgdGhlIExSVUNhY2hlIG9iamVjdCkuXG4gICAqICAgICBUaGUgcmV0dXJuIHZhbHVlIGlzIGlnbm9yZWQuXG4gICAqIEBwYXJhbSB7Uz19IG9wdF90aGlzIFRoZSBvYmplY3QgdG8gdXNlIGFzIGB0aGlzYCBpbiBgZmAuXG4gICAqIEB0ZW1wbGF0ZSBTXG4gICAqL1xuICBMUlVDYWNoZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2ggKGYsIG9wdF90aGlzKSB7XG4gICAgdmFyIGVudHJ5ID0gdGhpcy5vbGRlc3RfO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgZi5jYWxsKG9wdF90aGlzLCBlbnRyeS52YWx1ZV8sIGVudHJ5LmtleV8sIHRoaXMpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXdlcjtcbiAgICB9XG4gIH07XG5cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkuXG4gICAqIEByZXR1cm4ge1R9IFZhbHVlLlxuICAgKi9cbiAgTFJVQ2FjaGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gdGhpcy5lbnRyaWVzX1trZXldO1xuICAgIGFzc2VydChlbnRyeSAhPT0gdW5kZWZpbmVkLFxuICAgICAgMTUpOyAvLyBUcmllZCB0byBnZXQgYSB2YWx1ZSBmb3IgYSBrZXkgdGhhdCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgY2FjaGVcbiAgICBpZiAoZW50cnkgPT09IHRoaXMubmV3ZXN0Xykge1xuICAgICAgcmV0dXJuIGVudHJ5LnZhbHVlXztcbiAgICB9IGVsc2UgaWYgKGVudHJ5ID09PSB0aGlzLm9sZGVzdF8pIHtcbiAgICAgIHRoaXMub2xkZXN0XyA9IC8qKiBAdHlwZSB7RW50cnl9ICovICh0aGlzLm9sZGVzdF8ubmV3ZXIpO1xuICAgICAgdGhpcy5vbGRlc3RfLm9sZGVyID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgZW50cnkubmV3ZXIub2xkZXIgPSBlbnRyeS5vbGRlcjtcbiAgICAgIGVudHJ5Lm9sZGVyLm5ld2VyID0gZW50cnkubmV3ZXI7XG4gICAgfVxuICAgIGVudHJ5Lm5ld2VyID0gbnVsbDtcbiAgICBlbnRyeS5vbGRlciA9IHRoaXMubmV3ZXN0XztcbiAgICB0aGlzLm5ld2VzdF8ubmV3ZXIgPSBlbnRyeTtcbiAgICB0aGlzLm5ld2VzdF8gPSBlbnRyeTtcbiAgICByZXR1cm4gZW50cnkudmFsdWVfO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBlbnRyeSBmcm9tIHRoZSBjYWNoZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgZW50cnkga2V5LlxuICAgKiBAcmV0dXJuIHtUfSBUaGUgcmVtb3ZlZCBlbnRyeS5cbiAgICovXG4gIExSVUNhY2hlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUgKGtleSkge1xuICAgIHZhciBlbnRyeSA9IHRoaXMuZW50cmllc19ba2V5XTtcbiAgICBhc3NlcnQoZW50cnkgIT09IHVuZGVmaW5lZCwgMTUpOyAvLyBUcmllZCB0byBnZXQgYSB2YWx1ZSBmb3IgYSBrZXkgdGhhdCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgY2FjaGVcbiAgICBpZiAoZW50cnkgPT09IHRoaXMubmV3ZXN0Xykge1xuICAgICAgdGhpcy5uZXdlc3RfID0gLyoqIEB0eXBlIHtFbnRyeX0gKi8gKGVudHJ5Lm9sZGVyKTtcbiAgICAgIGlmICh0aGlzLm5ld2VzdF8pIHtcbiAgICAgICAgdGhpcy5uZXdlc3RfLm5ld2VyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVudHJ5ID09PSB0aGlzLm9sZGVzdF8pIHtcbiAgICAgIHRoaXMub2xkZXN0XyA9IC8qKiBAdHlwZSB7RW50cnl9ICovIChlbnRyeS5uZXdlcik7XG4gICAgICBpZiAodGhpcy5vbGRlc3RfKSB7XG4gICAgICAgIHRoaXMub2xkZXN0Xy5vbGRlciA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVudHJ5Lm5ld2VyLm9sZGVyID0gZW50cnkub2xkZXI7XG4gICAgICBlbnRyeS5vbGRlci5uZXdlciA9IGVudHJ5Lm5ld2VyO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5lbnRyaWVzX1trZXldO1xuICAgIC0tdGhpcy5jb3VudF87XG4gICAgcmV0dXJuIGVudHJ5LnZhbHVlXztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IENvdW50LlxuICAgKi9cbiAgTFJVQ2FjaGUucHJvdG90eXBlLmdldENvdW50ID0gZnVuY3Rpb24gZ2V0Q291bnQgKCkge1xuICAgIHJldHVybiB0aGlzLmNvdW50XztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxzdHJpbmc+fSBLZXlzLlxuICAgKi9cbiAgTFJVQ2FjaGUucHJvdG90eXBlLmdldEtleXMgPSBmdW5jdGlvbiBnZXRLZXlzICgpIHtcbiAgICB2YXIga2V5cyA9IG5ldyBBcnJheSh0aGlzLmNvdW50Xyk7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBlbnRyeTtcbiAgICBmb3IgKGVudHJ5ID0gdGhpcy5uZXdlc3RfOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5vbGRlcikge1xuICAgICAga2V5c1tpKytdID0gZW50cnkua2V5XztcbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG5cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8VD59IFZhbHVlcy5cbiAgICovXG4gIExSVUNhY2hlLnByb3RvdHlwZS5nZXRWYWx1ZXMgPSBmdW5jdGlvbiBnZXRWYWx1ZXMgKCkge1xuICAgIHZhciB2YWx1ZXMgPSBuZXcgQXJyYXkodGhpcy5jb3VudF8pO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgZW50cnk7XG4gICAgZm9yIChlbnRyeSA9IHRoaXMubmV3ZXN0XzsgZW50cnk7IGVudHJ5ID0gZW50cnkub2xkZXIpIHtcbiAgICAgIHZhbHVlc1tpKytdID0gZW50cnkudmFsdWVfO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1R9IExhc3QgdmFsdWUuXG4gICAqL1xuICBMUlVDYWNoZS5wcm90b3R5cGUucGVla0xhc3QgPSBmdW5jdGlvbiBwZWVrTGFzdCAoKSB7XG4gICAgcmV0dXJuIHRoaXMub2xkZXN0Xy52YWx1ZV87XG4gIH07XG5cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfSBMYXN0IGtleS5cbiAgICovXG4gIExSVUNhY2hlLnByb3RvdHlwZS5wZWVrTGFzdEtleSA9IGZ1bmN0aW9uIHBlZWtMYXN0S2V5ICgpIHtcbiAgICByZXR1cm4gdGhpcy5vbGRlc3RfLmtleV87XG4gIH07XG5cblxuICAvKipcbiAgICogR2V0IHRoZSBrZXkgb2YgdGhlIG5ld2VzdCBpdGVtIGluIHRoZSBjYWNoZS4gIFRocm93cyBpZiB0aGUgY2FjaGUgaXMgZW1wdHkuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIG5ld2VzdCBrZXkuXG4gICAqL1xuICBMUlVDYWNoZS5wcm90b3R5cGUucGVla0ZpcnN0S2V5ID0gZnVuY3Rpb24gcGVla0ZpcnN0S2V5ICgpIHtcbiAgICByZXR1cm4gdGhpcy5uZXdlc3RfLmtleV87XG4gIH07XG5cblxuICAvKipcbiAgICogQHJldHVybiB7VH0gdmFsdWUgVmFsdWUuXG4gICAqL1xuICBMUlVDYWNoZS5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gcG9wICgpIHtcbiAgICB2YXIgZW50cnkgPSB0aGlzLm9sZGVzdF87XG4gICAgZGVsZXRlIHRoaXMuZW50cmllc19bZW50cnkua2V5X107XG4gICAgaWYgKGVudHJ5Lm5ld2VyKSB7XG4gICAgICBlbnRyeS5uZXdlci5vbGRlciA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMub2xkZXN0XyA9IC8qKiBAdHlwZSB7RW50cnl9ICovIChlbnRyeS5uZXdlcik7XG4gICAgaWYgKCF0aGlzLm9sZGVzdF8pIHtcbiAgICAgIHRoaXMubmV3ZXN0XyA9IG51bGw7XG4gICAgfVxuICAgIC0tdGhpcy5jb3VudF87XG4gICAgcmV0dXJuIGVudHJ5LnZhbHVlXztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleS5cbiAgICogQHBhcmFtIHtUfSB2YWx1ZSBWYWx1ZS5cbiAgICovXG4gIExSVUNhY2hlLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZSAoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuZ2V0KGtleSk7IC8vIHVwZGF0ZSBgbmV3ZXN0X2BcbiAgICB0aGlzLmVudHJpZXNfW2tleV0udmFsdWVfID0gdmFsdWU7XG4gIH07XG5cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkuXG4gICAqIEBwYXJhbSB7VH0gdmFsdWUgVmFsdWUuXG4gICAqL1xuICBMUlVDYWNoZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0IChrZXksIHZhbHVlKSB7XG4gICAgYXNzZXJ0KCEoa2V5IGluIHRoaXMuZW50cmllc18pLFxuICAgICAgMTYpOyAvLyBUcmllZCB0byBzZXQgYSB2YWx1ZSBmb3IgYSBrZXkgdGhhdCBpcyB1c2VkIGFscmVhZHlcbiAgICB2YXIgZW50cnkgPSAvKiogQHR5cGUge0VudHJ5fSAqLyAoe1xuICAgICAga2V5Xzoga2V5LFxuICAgICAgbmV3ZXI6IG51bGwsXG4gICAgICBvbGRlcjogdGhpcy5uZXdlc3RfLFxuICAgICAgdmFsdWVfOiB2YWx1ZVxuICAgIH0pO1xuICAgIGlmICghdGhpcy5uZXdlc3RfKSB7XG4gICAgICB0aGlzLm9sZGVzdF8gPSBlbnRyeTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5uZXdlc3RfLm5ld2VyID0gZW50cnk7XG4gICAgfVxuICAgIHRoaXMubmV3ZXN0XyA9IGVudHJ5O1xuICAgIHRoaXMuZW50cmllc19ba2V5XSA9IGVudHJ5O1xuICAgICsrdGhpcy5jb3VudF87XG4gIH07XG5cblxuICAvKipcbiAgICogU2V0IGEgbWF4aW11bSBudW1iZXIgb2YgZW50cmllcyBmb3IgdGhlIGNhY2hlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBDYWNoZSBzaXplLlxuICAgKiBAYXBpXG4gICAqL1xuICBMUlVDYWNoZS5wcm90b3R5cGUuc2V0U2l6ZSA9IGZ1bmN0aW9uIHNldFNpemUgKHNpemUpIHtcbiAgICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBzaXplO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFBydW5lIHRoZSBjYWNoZS5cbiAgICovXG4gIExSVUNhY2hlLnByb3RvdHlwZS5wcnVuZSA9IGZ1bmN0aW9uIHBydW5lICgpIHtcbiAgICB3aGlsZSAodGhpcy5jYW5FeHBpcmVDYWNoZSgpKSB7XG4gICAgICB0aGlzLnBvcCgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gTFJVQ2FjaGU7XG59KEV2ZW50VGFyZ2V0KSk7XG5cbmV4cG9ydCBkZWZhdWx0IExSVUNhY2hlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1MUlVDYWNoZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvc3RydWN0cy9Qcmlvcml0eVF1ZXVlXG4gKi9cbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuLi9hc3NlcnRzLmpzJztcbmltcG9ydCB7Y2xlYXJ9IGZyb20gJy4uL29iai5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIERST1AgPSBJbmZpbml0eTtcblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFByaW9yaXR5IHF1ZXVlLlxuICpcbiAqIFRoZSBpbXBsZW1lbnRhdGlvbiBpcyBpbnNwaXJlZCBmcm9tIHRoZSBDbG9zdXJlIExpYnJhcnkncyBIZWFwIGNsYXNzIGFuZFxuICogUHl0aG9uJ3MgaGVhcHEgbW9kdWxlLlxuICpcbiAqIFNlZSBodHRwOi8vY2xvc3VyZS1saWJyYXJ5Lmdvb2dsZWNvZGUuY29tL3N2bi9kb2NzL2Nsb3N1cmVfZ29vZ19zdHJ1Y3RzX2hlYXAuanMuc291cmNlLmh0bWxcbiAqIGFuZCBodHRwOi8vaGcucHl0aG9uLm9yZy9jcHl0aG9uL2ZpbGUvMi43L0xpYi9oZWFwcS5weS5cbiAqXG4gKiBAdGVtcGxhdGUgVFxuICovXG52YXIgUHJpb3JpdHlRdWV1ZSA9IGZ1bmN0aW9uIFByaW9yaXR5UXVldWUocHJpb3JpdHlGdW5jdGlvbiwga2V5RnVuY3Rpb24pIHtcblxuICAvKipcbiAgICogQHR5cGUge2Z1bmN0aW9uKFQpOiBudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnByaW9yaXR5RnVuY3Rpb25fID0gcHJpb3JpdHlGdW5jdGlvbjtcblxuICAvKipcbiAgICogQHR5cGUge2Z1bmN0aW9uKFQpOiBzdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmtleUZ1bmN0aW9uXyA9IGtleUZ1bmN0aW9uO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXk8VD59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmVsZW1lbnRzXyA9IFtdO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMucHJpb3JpdGllc18gPSBbXTtcblxuICAvKipcbiAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBib29sZWFuPn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMucXVldWVkRWxlbWVudHNfID0ge307XG5cbn07XG5cbi8qKlxuICogRklYTUUgZW1wdHkgZGVzY3JpcHRpb24gZm9yIGpzZG9jXG4gKi9cblByaW9yaXR5UXVldWUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIkMSAoKSB7XG4gIHRoaXMuZWxlbWVudHNfLmxlbmd0aCA9IDA7XG4gIHRoaXMucHJpb3JpdGllc18ubGVuZ3RoID0gMDtcbiAgY2xlYXIodGhpcy5xdWV1ZWRFbGVtZW50c18pO1xufTtcblxuXG4vKipcbiAqIFJlbW92ZSBhbmQgcmV0dXJuIHRoZSBoaWdoZXN0LXByaW9yaXR5IGVsZW1lbnQuIE8obG9nIE4pLlxuICogQHJldHVybiB7VH0gRWxlbWVudC5cbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuZGVxdWV1ZSA9IGZ1bmN0aW9uIGRlcXVldWUgKCkge1xuICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzXztcbiAgdmFyIHByaW9yaXRpZXMgPSB0aGlzLnByaW9yaXRpZXNfO1xuICB2YXIgZWxlbWVudCA9IGVsZW1lbnRzWzBdO1xuICBpZiAoZWxlbWVudHMubGVuZ3RoID09IDEpIHtcbiAgICBlbGVtZW50cy5sZW5ndGggPSAwO1xuICAgIHByaW9yaXRpZXMubGVuZ3RoID0gMDtcbiAgfSBlbHNlIHtcbiAgICBlbGVtZW50c1swXSA9IGVsZW1lbnRzLnBvcCgpO1xuICAgIHByaW9yaXRpZXNbMF0gPSBwcmlvcml0aWVzLnBvcCgpO1xuICAgIHRoaXMuc2lmdFVwXygwKTtcbiAgfVxuICB2YXIgZWxlbWVudEtleSA9IHRoaXMua2V5RnVuY3Rpb25fKGVsZW1lbnQpO1xuICBkZWxldGUgdGhpcy5xdWV1ZWRFbGVtZW50c19bZWxlbWVudEtleV07XG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuXG4vKipcbiAqIEVucXVldWUgYW4gZWxlbWVudC4gTyhsb2cgTikuXG4gKiBAcGFyYW0ge1R9IGVsZW1lbnQgRWxlbWVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBlbGVtZW50IHdhcyBhZGRlZCB0byB0aGUgcXVldWUuXG4gKi9cblByaW9yaXR5UXVldWUucHJvdG90eXBlLmVucXVldWUgPSBmdW5jdGlvbiBlbnF1ZXVlIChlbGVtZW50KSB7XG4gIGFzc2VydCghKHRoaXMua2V5RnVuY3Rpb25fKGVsZW1lbnQpIGluIHRoaXMucXVldWVkRWxlbWVudHNfKSxcbiAgICAzMSk7IC8vIFRyaWVkIHRvIGVucXVldWUgYW4gYGVsZW1lbnRgIHRoYXQgd2FzIGFscmVhZHkgYWRkZWQgdG8gdGhlIHF1ZXVlXG4gIHZhciBwcmlvcml0eSA9IHRoaXMucHJpb3JpdHlGdW5jdGlvbl8oZWxlbWVudCk7XG4gIGlmIChwcmlvcml0eSAhPSBEUk9QKSB7XG4gICAgdGhpcy5lbGVtZW50c18ucHVzaChlbGVtZW50KTtcbiAgICB0aGlzLnByaW9yaXRpZXNfLnB1c2gocHJpb3JpdHkpO1xuICAgIHRoaXMucXVldWVkRWxlbWVudHNfW3RoaXMua2V5RnVuY3Rpb25fKGVsZW1lbnQpXSA9IHRydWU7XG4gICAgdGhpcy5zaWZ0RG93bl8oMCwgdGhpcy5lbGVtZW50c18ubGVuZ3RoIC0gMSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuXG4vKipcbiAqIEByZXR1cm4ge251bWJlcn0gQ291bnQuXG4gKi9cblByaW9yaXR5UXVldWUucHJvdG90eXBlLmdldENvdW50ID0gZnVuY3Rpb24gZ2V0Q291bnQgKCkge1xuICByZXR1cm4gdGhpcy5lbGVtZW50c18ubGVuZ3RoO1xufTtcblxuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IG9mIHRoZSBsZWZ0IGNoaWxkIG9mIHRoZSBub2RlIGF0IHRoZSBnaXZlbiBpbmRleC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIG5vZGUgdG8gZ2V0IHRoZSBsZWZ0IGNoaWxkIGZvci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGluZGV4IG9mIHRoZSBsZWZ0IGNoaWxkLlxuICogQHByaXZhdGVcbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuZ2V0TGVmdENoaWxkSW5kZXhfID0gZnVuY3Rpb24gZ2V0TGVmdENoaWxkSW5kZXhfIChpbmRleCkge1xuICByZXR1cm4gaW5kZXggKiAyICsgMTtcbn07XG5cblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBvZiB0aGUgcmlnaHQgY2hpbGQgb2YgdGhlIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbm9kZSB0byBnZXQgdGhlIHJpZ2h0IGNoaWxkIGZvci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGluZGV4IG9mIHRoZSByaWdodCBjaGlsZC5cbiAqIEBwcml2YXRlXG4gKi9cblByaW9yaXR5UXVldWUucHJvdG90eXBlLmdldFJpZ2h0Q2hpbGRJbmRleF8gPSBmdW5jdGlvbiBnZXRSaWdodENoaWxkSW5kZXhfIChpbmRleCkge1xuICByZXR1cm4gaW5kZXggKiAyICsgMjtcbn07XG5cblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBvZiB0aGUgcGFyZW50IG9mIHRoZSBub2RlIGF0IHRoZSBnaXZlbiBpbmRleC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIG5vZGUgdG8gZ2V0IHRoZSBwYXJlbnQgZm9yLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgaW5kZXggb2YgdGhlIHBhcmVudC5cbiAqIEBwcml2YXRlXG4gKi9cblByaW9yaXR5UXVldWUucHJvdG90eXBlLmdldFBhcmVudEluZGV4XyA9IGZ1bmN0aW9uIGdldFBhcmVudEluZGV4XyAoaW5kZXgpIHtcbiAgcmV0dXJuIChpbmRleCAtIDEpID4+IDE7XG59O1xuXG5cbi8qKlxuICogTWFrZSB0aGlzIGEgaGVhcC4gTyhOKS5cbiAqIEBwcml2YXRlXG4gKi9cblByaW9yaXR5UXVldWUucHJvdG90eXBlLmhlYXBpZnlfID0gZnVuY3Rpb24gaGVhcGlmeV8gKCkge1xuICB2YXIgaTtcbiAgZm9yIChpID0gKHRoaXMuZWxlbWVudHNfLmxlbmd0aCA+PiAxKSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdGhpcy5zaWZ0VXBfKGkpO1xuICB9XG59O1xuXG5cbi8qKlxuICogQHJldHVybiB7Ym9vbGVhbn0gSXMgZW1wdHkuXG4gKi9cblByaW9yaXR5UXVldWUucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5ICgpIHtcbiAgcmV0dXJuIHRoaXMuZWxlbWVudHNfLmxlbmd0aCA9PT0gMDtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IElzIGtleSBxdWV1ZWQuXG4gKi9cblByaW9yaXR5UXVldWUucHJvdG90eXBlLmlzS2V5UXVldWVkID0gZnVuY3Rpb24gaXNLZXlRdWV1ZWQgKGtleSkge1xuICByZXR1cm4ga2V5IGluIHRoaXMucXVldWVkRWxlbWVudHNfO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7VH0gZWxlbWVudCBFbGVtZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gSXMgcXVldWVkLlxuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5pc1F1ZXVlZCA9IGZ1bmN0aW9uIGlzUXVldWVkIChlbGVtZW50KSB7XG4gIHJldHVybiB0aGlzLmlzS2V5UXVldWVkKHRoaXMua2V5RnVuY3Rpb25fKGVsZW1lbnQpKTtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBub2RlIHRvIG1vdmUgZG93bi5cbiAqIEBwcml2YXRlXG4gKi9cblByaW9yaXR5UXVldWUucHJvdG90eXBlLnNpZnRVcF8gPSBmdW5jdGlvbiBzaWZ0VXBfIChpbmRleCkge1xuICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzXztcbiAgdmFyIHByaW9yaXRpZXMgPSB0aGlzLnByaW9yaXRpZXNfO1xuICB2YXIgY291bnQgPSBlbGVtZW50cy5sZW5ndGg7XG4gIHZhciBlbGVtZW50ID0gZWxlbWVudHNbaW5kZXhdO1xuICB2YXIgcHJpb3JpdHkgPSBwcmlvcml0aWVzW2luZGV4XTtcbiAgdmFyIHN0YXJ0SW5kZXggPSBpbmRleDtcblxuICB3aGlsZSAoaW5kZXggPCAoY291bnQgPj4gMSkpIHtcbiAgICB2YXIgbEluZGV4ID0gdGhpcy5nZXRMZWZ0Q2hpbGRJbmRleF8oaW5kZXgpO1xuICAgIHZhciBySW5kZXggPSB0aGlzLmdldFJpZ2h0Q2hpbGRJbmRleF8oaW5kZXgpO1xuXG4gICAgdmFyIHNtYWxsZXJDaGlsZEluZGV4ID0gckluZGV4IDwgY291bnQgJiZcbiAgICAgICAgcHJpb3JpdGllc1tySW5kZXhdIDwgcHJpb3JpdGllc1tsSW5kZXhdID9cbiAgICAgIHJJbmRleCA6IGxJbmRleDtcblxuICAgIGVsZW1lbnRzW2luZGV4XSA9IGVsZW1lbnRzW3NtYWxsZXJDaGlsZEluZGV4XTtcbiAgICBwcmlvcml0aWVzW2luZGV4XSA9IHByaW9yaXRpZXNbc21hbGxlckNoaWxkSW5kZXhdO1xuICAgIGluZGV4ID0gc21hbGxlckNoaWxkSW5kZXg7XG4gIH1cblxuICBlbGVtZW50c1tpbmRleF0gPSBlbGVtZW50O1xuICBwcmlvcml0aWVzW2luZGV4XSA9IHByaW9yaXR5O1xuICB0aGlzLnNpZnREb3duXyhzdGFydEluZGV4LCBpbmRleCk7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SW5kZXggVGhlIGluZGV4IG9mIHRoZSByb290LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbm9kZSB0byBtb3ZlIHVwLlxuICogQHByaXZhdGVcbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuc2lmdERvd25fID0gZnVuY3Rpb24gc2lmdERvd25fIChzdGFydEluZGV4LCBpbmRleCkge1xuICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzXztcbiAgdmFyIHByaW9yaXRpZXMgPSB0aGlzLnByaW9yaXRpZXNfO1xuICB2YXIgZWxlbWVudCA9IGVsZW1lbnRzW2luZGV4XTtcbiAgdmFyIHByaW9yaXR5ID0gcHJpb3JpdGllc1tpbmRleF07XG5cbiAgd2hpbGUgKGluZGV4ID4gc3RhcnRJbmRleCkge1xuICAgIHZhciBwYXJlbnRJbmRleCA9IHRoaXMuZ2V0UGFyZW50SW5kZXhfKGluZGV4KTtcbiAgICBpZiAocHJpb3JpdGllc1twYXJlbnRJbmRleF0gPiBwcmlvcml0eSkge1xuICAgICAgZWxlbWVudHNbaW5kZXhdID0gZWxlbWVudHNbcGFyZW50SW5kZXhdO1xuICAgICAgcHJpb3JpdGllc1tpbmRleF0gPSBwcmlvcml0aWVzW3BhcmVudEluZGV4XTtcbiAgICAgIGluZGV4ID0gcGFyZW50SW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBlbGVtZW50c1tpbmRleF0gPSBlbGVtZW50O1xuICBwcmlvcml0aWVzW2luZGV4XSA9IHByaW9yaXR5O1xufTtcblxuXG4vKipcbiAqIEZJWE1FIGVtcHR5IGRlc2NyaXB0aW9uIGZvciBqc2RvY1xuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5yZXByaW9yaXRpemUgPSBmdW5jdGlvbiByZXByaW9yaXRpemUgKCkge1xuICB2YXIgcHJpb3JpdHlGdW5jdGlvbiA9IHRoaXMucHJpb3JpdHlGdW5jdGlvbl87XG4gIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHNfO1xuICB2YXIgcHJpb3JpdGllcyA9IHRoaXMucHJpb3JpdGllc187XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBuID0gZWxlbWVudHMubGVuZ3RoO1xuICB2YXIgZWxlbWVudCwgaSwgcHJpb3JpdHk7XG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgcHJpb3JpdHkgPSBwcmlvcml0eUZ1bmN0aW9uKGVsZW1lbnQpO1xuICAgIGlmIChwcmlvcml0eSA9PSBEUk9QKSB7XG4gICAgICBkZWxldGUgdGhpcy5xdWV1ZWRFbGVtZW50c19bdGhpcy5rZXlGdW5jdGlvbl8oZWxlbWVudCldO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmlvcml0aWVzW2luZGV4XSA9IHByaW9yaXR5O1xuICAgICAgZWxlbWVudHNbaW5kZXgrK10gPSBlbGVtZW50O1xuICAgIH1cbiAgfVxuICBlbGVtZW50cy5sZW5ndGggPSBpbmRleDtcbiAgcHJpb3JpdGllcy5sZW5ndGggPSBpbmRleDtcbiAgdGhpcy5oZWFwaWZ5XygpO1xufTtcblxuXG5leHBvcnQgZGVmYXVsdCBQcmlvcml0eVF1ZXVlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qcmlvcml0eVF1ZXVlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9zdHJ1Y3RzL1JCdXNoXG4gKi9cbmltcG9ydCB7Z2V0VWlkfSBmcm9tICcuLi91dGlsLmpzJztcbmltcG9ydCByYnVzaCBmcm9tICdyYnVzaCc7XG5pbXBvcnQge2NyZWF0ZU9yVXBkYXRlLCBlcXVhbHN9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge2lzRW1wdHl9IGZyb20gJy4uL29iai5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRW50cnlcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW5YXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWluWVxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1heFhcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhZXG4gKiBAcHJvcGVydHkge09iamVjdH0gW3ZhbHVlXVxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogV3JhcHBlciBhcm91bmQgdGhlIFJCdXNoIGJ5IFZsYWRpbWlyIEFnYWZvbmtpbi5cbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW91cm5lci9yYnVzaC5cbiAqXG4gKiBAdGVtcGxhdGUgVFxuICovXG52YXIgUkJ1c2ggPSBmdW5jdGlvbiBSQnVzaChvcHRfbWF4RW50cmllcykge1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5yYnVzaF8gPSByYnVzaChvcHRfbWF4RW50cmllcywgdW5kZWZpbmVkKTtcblxuICAvKipcbiAgICogQSBtYXBwaW5nIGJldHdlZW4gdGhlIG9iamVjdHMgYWRkZWQgdG8gdGhpcyByYnVzaCB3cmFwcGVyXG4gICAqIGFuZCB0aGUgb2JqZWN0cyB0aGF0IGFyZSBhY3R1YWxseSBhZGRlZCB0byB0aGUgaW50ZXJuYWwgcmJ1c2guXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBFbnRyeT59XG4gICAqL1xuICB0aGlzLml0ZW1zXyA9IHt9O1xuXG59O1xuXG4vKipcbiAqIEluc2VydCBhIHZhbHVlIGludG8gdGhlIFJCdXNoLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtUfSB2YWx1ZSBWYWx1ZS5cbiAqL1xuUkJ1c2gucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIGluc2VydCAoZXh0ZW50LCB2YWx1ZSkge1xuICAvKiogQHR5cGUge0VudHJ5fSAqL1xuICB2YXIgaXRlbSA9IHtcbiAgICBtaW5YOiBleHRlbnRbMF0sXG4gICAgbWluWTogZXh0ZW50WzFdLFxuICAgIG1heFg6IGV4dGVudFsyXSxcbiAgICBtYXhZOiBleHRlbnRbM10sXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG5cbiAgdGhpcy5yYnVzaF8uaW5zZXJ0KGl0ZW0pO1xuICB0aGlzLml0ZW1zX1tnZXRVaWQodmFsdWUpXSA9IGl0ZW07XG59O1xuXG5cbi8qKlxuICogQnVsay1pbnNlcnQgdmFsdWVzIGludG8gdGhlIFJCdXNoLlxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50Pn0gZXh0ZW50cyBFeHRlbnRzLlxuICogQHBhcmFtIHtBcnJheTxUPn0gdmFsdWVzIFZhbHVlcy5cbiAqL1xuUkJ1c2gucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiBsb2FkIChleHRlbnRzLCB2YWx1ZXMpIHtcbiAgdmFyIGl0ZW1zID0gbmV3IEFycmF5KHZhbHVlcy5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgZXh0ZW50ID0gZXh0ZW50c1tpXTtcbiAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaV07XG5cbiAgICAvKiogQHR5cGUge0VudHJ5fSAqL1xuICAgIHZhciBpdGVtID0ge1xuICAgICAgbWluWDogZXh0ZW50WzBdLFxuICAgICAgbWluWTogZXh0ZW50WzFdLFxuICAgICAgbWF4WDogZXh0ZW50WzJdLFxuICAgICAgbWF4WTogZXh0ZW50WzNdLFxuICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfTtcbiAgICBpdGVtc1tpXSA9IGl0ZW07XG4gICAgdGhpcy5pdGVtc19bZ2V0VWlkKHZhbHVlKV0gPSBpdGVtO1xuICB9XG4gIHRoaXMucmJ1c2hfLmxvYWQoaXRlbXMpO1xufTtcblxuXG4vKipcbiAqIFJlbW92ZSBhIHZhbHVlIGZyb20gdGhlIFJCdXNoLlxuICogQHBhcmFtIHtUfSB2YWx1ZSBWYWx1ZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJlbW92ZWQuXG4gKi9cblJCdXNoLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUgKHZhbHVlKSB7XG4gIHZhciB1aWQgPSBnZXRVaWQodmFsdWUpO1xuXG4gIC8vIGdldCB0aGUgb2JqZWN0IGluIHdoaWNoIHRoZSB2YWx1ZSB3YXMgd3JhcHBlZCB3aGVuIGFkZGluZyB0byB0aGVcbiAgLy8gaW50ZXJuYWwgcmJ1c2guIHRoZW4gdXNlIHRoYXQgb2JqZWN0IHRvIGRvIHRoZSByZW1vdmFsLlxuICB2YXIgaXRlbSA9IHRoaXMuaXRlbXNfW3VpZF07XG4gIGRlbGV0ZSB0aGlzLml0ZW1zX1t1aWRdO1xuICByZXR1cm4gdGhpcy5yYnVzaF8ucmVtb3ZlKGl0ZW0pICE9PSBudWxsO1xufTtcblxuXG4vKipcbiAqIFVwZGF0ZSB0aGUgZXh0ZW50IG9mIGEgdmFsdWUgaW4gdGhlIFJCdXNoLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtUfSB2YWx1ZSBWYWx1ZS5cbiAqL1xuUkJ1c2gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoZXh0ZW50LCB2YWx1ZSkge1xuICB2YXIgaXRlbSA9IHRoaXMuaXRlbXNfW2dldFVpZCh2YWx1ZSldO1xuICB2YXIgYmJveCA9IFtpdGVtLm1pblgsIGl0ZW0ubWluWSwgaXRlbS5tYXhYLCBpdGVtLm1heFldO1xuICBpZiAoIWVxdWFscyhiYm94LCBleHRlbnQpKSB7XG4gICAgdGhpcy5yZW1vdmUodmFsdWUpO1xuICAgIHRoaXMuaW5zZXJ0KGV4dGVudCwgdmFsdWUpO1xuICB9XG59O1xuXG5cbi8qKlxuICogUmV0dXJuIGFsbCB2YWx1ZXMgaW4gdGhlIFJCdXNoLlxuICogQHJldHVybiB7QXJyYXk8VD59IEFsbC5cbiAqL1xuUkJ1c2gucHJvdG90eXBlLmdldEFsbCA9IGZ1bmN0aW9uIGdldEFsbCAoKSB7XG4gIHZhciBpdGVtcyA9IHRoaXMucmJ1c2hfLmFsbCgpO1xuICByZXR1cm4gaXRlbXMubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbS52YWx1ZTtcbiAgfSk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJuIGFsbCB2YWx1ZXMgaW4gdGhlIGdpdmVuIGV4dGVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge0FycmF5PFQ+fSBBbGwgaW4gZXh0ZW50LlxuICovXG5SQnVzaC5wcm90b3R5cGUuZ2V0SW5FeHRlbnQgPSBmdW5jdGlvbiBnZXRJbkV4dGVudCAoZXh0ZW50KSB7XG4gIC8qKiBAdHlwZSB7RW50cnl9ICovXG4gIHZhciBiYm94ID0ge1xuICAgIG1pblg6IGV4dGVudFswXSxcbiAgICBtaW5ZOiBleHRlbnRbMV0sXG4gICAgbWF4WDogZXh0ZW50WzJdLFxuICAgIG1heFk6IGV4dGVudFszXVxuICB9O1xuICB2YXIgaXRlbXMgPSB0aGlzLnJidXNoXy5zZWFyY2goYmJveCk7XG4gIHJldHVybiBpdGVtcy5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgIHJldHVybiBpdGVtLnZhbHVlO1xuICB9KTtcbn07XG5cblxuLyoqXG4gKiBDYWxscyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggZWFjaCB2YWx1ZSBpbiB0aGUgdHJlZS5cbiAqIElmIHRoZSBjYWxsYmFjayByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlLCB0aGlzIHZhbHVlIGlzIHJldHVybmVkIHdpdGhvdXRcbiAqIGNoZWNraW5nIHRoZSByZXN0IG9mIHRoZSB0cmVlLlxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBTLCBUKTogKn0gY2FsbGJhY2sgQ2FsbGJhY2suXG4gKiBAcGFyYW0ge1M9fSBvcHRfdGhpcyBUaGUgb2JqZWN0IHRvIHVzZSBhcyBgdGhpc2AgaW4gYGNhbGxiYWNrYC5cbiAqIEByZXR1cm4geyp9IENhbGxiYWNrIHJldHVybiB2YWx1ZS5cbiAqIEB0ZW1wbGF0ZSBTXG4gKi9cblJCdXNoLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaCAoY2FsbGJhY2ssIG9wdF90aGlzKSB7XG4gIHJldHVybiB0aGlzLmZvckVhY2hfKHRoaXMuZ2V0QWxsKCksIGNhbGxiYWNrLCBvcHRfdGhpcyk7XG59O1xuXG5cbi8qKlxuICogQ2FsbHMgYSBjYWxsYmFjayBmdW5jdGlvbiB3aXRoIGVhY2ggdmFsdWUgaW4gdGhlIHByb3ZpZGVkIGV4dGVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczogUywgVCk6ICp9IGNhbGxiYWNrIENhbGxiYWNrLlxuICogQHBhcmFtIHtTPX0gb3B0X3RoaXMgVGhlIG9iamVjdCB0byB1c2UgYXMgYHRoaXNgIGluIGBjYWxsYmFja2AuXG4gKiBAcmV0dXJuIHsqfSBDYWxsYmFjayByZXR1cm4gdmFsdWUuXG4gKiBAdGVtcGxhdGUgU1xuICovXG5SQnVzaC5wcm90b3R5cGUuZm9yRWFjaEluRXh0ZW50ID0gZnVuY3Rpb24gZm9yRWFjaEluRXh0ZW50IChleHRlbnQsIGNhbGxiYWNrLCBvcHRfdGhpcykge1xuICByZXR1cm4gdGhpcy5mb3JFYWNoXyh0aGlzLmdldEluRXh0ZW50KGV4dGVudCksIGNhbGxiYWNrLCBvcHRfdGhpcyk7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxUPn0gdmFsdWVzIFZhbHVlcy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczogUywgVCk6ICp9IGNhbGxiYWNrIENhbGxiYWNrLlxuICogQHBhcmFtIHtTPX0gb3B0X3RoaXMgVGhlIG9iamVjdCB0byB1c2UgYXMgYHRoaXNgIGluIGBjYWxsYmFja2AuXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybiB7Kn0gQ2FsbGJhY2sgcmV0dXJuIHZhbHVlLlxuICogQHRlbXBsYXRlIFNcbiAqL1xuUkJ1c2gucHJvdG90eXBlLmZvckVhY2hfID0gZnVuY3Rpb24gZm9yRWFjaF8gKHZhbHVlcywgY2FsbGJhY2ssIG9wdF90aGlzKSB7XG4gIHZhciByZXN1bHQ7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHJlc3VsdCA9IGNhbGxiYWNrLmNhbGwob3B0X3RoaXMsIHZhbHVlc1tpXSk7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtib29sZWFufSBJcyBlbXB0eS5cbiAqL1xuUkJ1c2gucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5JDEgKCkge1xuICByZXR1cm4gaXNFbXB0eSh0aGlzLml0ZW1zXyk7XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlIGFsbCB2YWx1ZXMgZnJvbSB0aGUgUkJ1c2guXG4gKi9cblJCdXNoLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgdGhpcy5yYnVzaF8uY2xlYXIoKTtcbiAgdGhpcy5pdGVtc18gPSB7fTtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnQ9fSBvcHRfZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IEV4dGVudC5cbiAqL1xuUkJ1c2gucHJvdG90eXBlLmdldEV4dGVudCA9IGZ1bmN0aW9uIGdldEV4dGVudCAob3B0X2V4dGVudCkge1xuICB2YXIgZGF0YSA9IHRoaXMucmJ1c2hfLnRvSlNPTigpO1xuICByZXR1cm4gY3JlYXRlT3JVcGRhdGUoZGF0YS5taW5YLCBkYXRhLm1pblksIGRhdGEubWF4WCwgZGF0YS5tYXhZLCBvcHRfZXh0ZW50KTtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge1JCdXNofSByYnVzaCBSLVRyZWUuXG4gKi9cblJCdXNoLnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKHJidXNoKSB7XG4gIHRoaXMucmJ1c2hfLmxvYWQocmJ1c2gucmJ1c2hfLmFsbCgpKTtcbiAgZm9yICh2YXIgaSBpbiByYnVzaC5pdGVtc18pIHtcbiAgICB0aGlzLml0ZW1zX1tpXSA9IHJidXNoLml0ZW1zX1tpXTtcbiAgfVxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBSQnVzaDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UkJ1c2guanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3N0eWxlL0NpcmNsZVxuICovXG5cbmltcG9ydCBSZWd1bGFyU2hhcGUgZnJvbSAnLi9SZWd1bGFyU2hhcGUuanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL0ZpbGwuanNcIikuZGVmYXVsdH0gW2ZpbGxdIEZpbGwgc3R5bGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gcmFkaXVzIENpcmNsZSByYWRpdXMuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vU3Ryb2tlLmpzXCIpLmRlZmF1bHR9IFtzdHJva2VdIFN0cm9rZSBzdHlsZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9BdGxhc01hbmFnZXIuanNcIikuZGVmYXVsdH0gW2F0bGFzTWFuYWdlcl0gVGhlIGF0bGFzIG1hbmFnZXIgdG8gdXNlIGZvciB0aGlzIGNpcmNsZS5cbiAqIFdoZW4gdXNpbmcgV2ViR0wgaXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIGFuIGF0bGFzIG1hbmFnZXIgdG8gYXZvaWQgdGV4dHVyZSBzd2l0Y2hpbmcuIElmIGFuIGF0bGFzIG1hbmFnZXIgaXMgZ2l2ZW4sXG4gKiB0aGUgY2lyY2xlIGlzIGFkZGVkIHRvIGFuIGF0bGFzLiBCeSBkZWZhdWx0IG5vIGF0bGFzIG1hbmFnZXIgaXMgdXNlZC5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogU2V0IGNpcmNsZSBzdHlsZSBmb3IgdmVjdG9yIGZlYXR1cmVzLlxuICogQGFwaVxuICovXG52YXIgQ2lyY2xlU3R5bGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChSZWd1bGFyU2hhcGUpIHtcbiAgZnVuY3Rpb24gQ2lyY2xlU3R5bGUob3B0X29wdGlvbnMpIHtcblxuICAgIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgfHwgLyoqIEB0eXBlIHtPcHRpb25zfSAqLyAoe30pO1xuXG4gICAgUmVndWxhclNoYXBlLmNhbGwodGhpcywge1xuICAgICAgcG9pbnRzOiBJbmZpbml0eSxcbiAgICAgIGZpbGw6IG9wdGlvbnMuZmlsbCxcbiAgICAgIHJhZGl1czogb3B0aW9ucy5yYWRpdXMsXG4gICAgICBzdHJva2U6IG9wdGlvbnMuc3Ryb2tlLFxuICAgICAgYXRsYXNNYW5hZ2VyOiBvcHRpb25zLmF0bGFzTWFuYWdlclxuICAgIH0pO1xuXG4gIH1cblxuICBpZiAoIFJlZ3VsYXJTaGFwZSApIENpcmNsZVN0eWxlLl9fcHJvdG9fXyA9IFJlZ3VsYXJTaGFwZTtcbiAgQ2lyY2xlU3R5bGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUmVndWxhclNoYXBlICYmIFJlZ3VsYXJTaGFwZS5wcm90b3R5cGUgKTtcbiAgQ2lyY2xlU3R5bGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2lyY2xlU3R5bGU7XG5cbiAgLyoqXG4gICogQ2xvbmVzIHRoZSBzdHlsZS4gIElmIGFuIGF0bGFzbWFuYWdlciB3YXMgcHJvdmlkZWQgdG8gdGhlIG9yaWdpbmFsIHN0eWxlIGl0IHdpbGwgYmUgdXNlZCBpbiB0aGUgY2xvbmVkIHN0eWxlLCB0b28uXG4gICogQHJldHVybiB7Q2lyY2xlU3R5bGV9IFRoZSBjbG9uZWQgc3R5bGUuXG4gICogQG92ZXJyaWRlXG4gICogQGFwaVxuICAqL1xuICBDaXJjbGVTdHlsZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgdmFyIHN0eWxlID0gbmV3IENpcmNsZVN0eWxlKHtcbiAgICAgIGZpbGw6IHRoaXMuZ2V0RmlsbCgpID8gdGhpcy5nZXRGaWxsKCkuY2xvbmUoKSA6IHVuZGVmaW5lZCxcbiAgICAgIHN0cm9rZTogdGhpcy5nZXRTdHJva2UoKSA/IHRoaXMuZ2V0U3Ryb2tlKCkuY2xvbmUoKSA6IHVuZGVmaW5lZCxcbiAgICAgIHJhZGl1czogdGhpcy5nZXRSYWRpdXMoKSxcbiAgICAgIGF0bGFzTWFuYWdlcjogdGhpcy5hdGxhc01hbmFnZXJfXG4gICAgfSk7XG4gICAgc3R5bGUuc2V0T3BhY2l0eSh0aGlzLmdldE9wYWNpdHkoKSk7XG4gICAgc3R5bGUuc2V0U2NhbGUodGhpcy5nZXRTY2FsZSgpKTtcbiAgICByZXR1cm4gc3R5bGU7XG4gIH07XG5cbiAgLyoqXG4gICogU2V0IHRoZSBjaXJjbGUgcmFkaXVzLlxuICAqXG4gICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBDaXJjbGUgcmFkaXVzLlxuICAqIEBhcGlcbiAgKi9cbiAgQ2lyY2xlU3R5bGUucHJvdG90eXBlLnNldFJhZGl1cyA9IGZ1bmN0aW9uIHNldFJhZGl1cyAocmFkaXVzKSB7XG4gICAgdGhpcy5yYWRpdXNfID0gcmFkaXVzO1xuICAgIHRoaXMucmVuZGVyXyh0aGlzLmF0bGFzTWFuYWdlcl8pO1xuICB9O1xuXG4gIHJldHVybiBDaXJjbGVTdHlsZTtcbn0oUmVndWxhclNoYXBlKSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgQ2lyY2xlU3R5bGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNpcmNsZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvc3R5bGUvRmlsbFxuICovXG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5pbXBvcnQge2FzU3RyaW5nfSBmcm9tICcuLi9jb2xvci5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfGltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9IFtjb2xvcl0gQSBjb2xvciwgZ3JhZGllbnQgb3IgcGF0dGVybi5cbiAqIFNlZSB7QGxpbmsgbW9kdWxlOm9sL2NvbG9yfkNvbG9yfSBhbmQge0BsaW5rIG1vZHVsZTpvbC9jb2xvcmxpa2V+Q29sb3JMaWtlfSBmb3IgcG9zc2libGUgZm9ybWF0cy5cbiAqIERlZmF1bHQgbnVsbDsgaWYgbnVsbCwgdGhlIENhbnZhcy9yZW5kZXJlciBkZWZhdWx0IGJsYWNrIHdpbGwgYmUgdXNlZC5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogU2V0IGZpbGwgc3R5bGUgZm9yIHZlY3RvciBmZWF0dXJlcy5cbiAqIEBhcGlcbiAqL1xudmFyIEZpbGwgPSBmdW5jdGlvbiBGaWxsKG9wdF9vcHRpb25zKSB7XG5cbiAgdmFyIG9wdGlvbnMgPSBvcHRfb3B0aW9ucyB8fCB7fTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfGltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9XG4gICAqL1xuICB0aGlzLmNvbG9yXyA9IG9wdGlvbnMuY29sb3IgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY29sb3IgOiBudWxsO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7c3RyaW5nfHVuZGVmaW5lZH1cbiAgICovXG4gIHRoaXMuY2hlY2tzdW1fID0gdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBDbG9uZXMgdGhlIHN0eWxlLiBUaGUgY29sb3IgaXMgbm90IGNsb25lZCBpZiBpdCBpcyBhbiB7QGxpbmsgbW9kdWxlOm9sL2NvbG9ybGlrZX5Db2xvckxpa2V9LlxuICogQHJldHVybiB7RmlsbH0gVGhlIGNsb25lZCBzdHlsZS5cbiAqIEBhcGlcbiAqL1xuRmlsbC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gIHZhciBjb2xvciA9IHRoaXMuZ2V0Q29sb3IoKTtcbiAgcmV0dXJuIG5ldyBGaWxsKHtcbiAgICBjb2xvcjogQXJyYXkuaXNBcnJheShjb2xvcikgPyBjb2xvci5zbGljZSgpIDogY29sb3IgfHwgdW5kZWZpbmVkXG4gIH0pO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGZpbGwgY29sb3IuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcnxpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfSBDb2xvci5cbiAqIEBhcGlcbiAqL1xuRmlsbC5wcm90b3R5cGUuZ2V0Q29sb3IgPSBmdW5jdGlvbiBnZXRDb2xvciAoKSB7XG4gIHJldHVybiB0aGlzLmNvbG9yXztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb2xvci5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfGltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9IGNvbG9yIENvbG9yLlxuICogQGFwaVxuICovXG5GaWxsLnByb3RvdHlwZS5zZXRDb2xvciA9IGZ1bmN0aW9uIHNldENvbG9yIChjb2xvcikge1xuICB0aGlzLmNvbG9yXyA9IGNvbG9yO1xuICB0aGlzLmNoZWNrc3VtXyA9IHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgY2hlY2tzdW0uXG4gKi9cbkZpbGwucHJvdG90eXBlLmdldENoZWNrc3VtID0gZnVuY3Rpb24gZ2V0Q2hlY2tzdW0gKCkge1xuICBpZiAodGhpcy5jaGVja3N1bV8gPT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBjb2xvciA9IHRoaXMuY29sb3JfO1xuICAgIGlmIChjb2xvcikge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29sb3IpIHx8IHR5cGVvZiBjb2xvciA9PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLmNoZWNrc3VtXyA9ICdmJyArIGFzU3RyaW5nKC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J8c3RyaW5nfSAqLyAoY29sb3IpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2hlY2tzdW1fID0gZ2V0VWlkKHRoaXMuY29sb3JfKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jaGVja3N1bV8gPSAnZi0nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzLmNoZWNrc3VtXztcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEZpbGw7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZpbGwuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3N0eWxlL0ljb25JbWFnZUNhY2hlXG4gKi9cbmltcG9ydCB7YXNTdHJpbmd9IGZyb20gJy4uL2NvbG9yLmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBTaW5nbGV0b24gY2xhc3MuIEF2YWlsYWJsZSB0aHJvdWdoIHtAbGluayBtb2R1bGU6b2wvc3R5bGUvSWNvbkltYWdlQ2FjaGV+c2hhcmVkfS5cbiAqL1xudmFyIEljb25JbWFnZUNhY2hlID0gZnVuY3Rpb24gSWNvbkltYWdlQ2FjaGUoKSB7XG5cbiAgLyoqXG4gICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuL0ljb25JbWFnZS5qc1wiKS5kZWZhdWx0Pn1cbiAgKiBAcHJpdmF0ZVxuICAqL1xuICB0aGlzLmNhY2hlXyA9IHt9O1xuXG4gIC8qKlxuICAqIEB0eXBlIHtudW1iZXJ9XG4gICogQHByaXZhdGVcbiAgKi9cbiAgdGhpcy5jYWNoZVNpemVfID0gMDtcblxuICAvKipcbiAgKiBAdHlwZSB7bnVtYmVyfVxuICAqIEBwcml2YXRlXG4gICovXG4gIHRoaXMubWF4Q2FjaGVTaXplXyA9IDMyO1xufTtcblxuLyoqXG4qIEZJWE1FIGVtcHR5IGRlc2NyaXB0aW9uIGZvciBqc2RvY1xuKi9cbkljb25JbWFnZUNhY2hlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgdGhpcy5jYWNoZV8gPSB7fTtcbiAgdGhpcy5jYWNoZVNpemVfID0gMDtcbn07XG5cbi8qKlxuKiBGSVhNRSBlbXB0eSBkZXNjcmlwdGlvbiBmb3IganNkb2NcbiovXG5JY29uSW1hZ2VDYWNoZS5wcm90b3R5cGUuZXhwaXJlID0gZnVuY3Rpb24gZXhwaXJlICgpIHtcbiAgaWYgKHRoaXMuY2FjaGVTaXplXyA+IHRoaXMubWF4Q2FjaGVTaXplXykge1xuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5jYWNoZV8pIHtcbiAgICAgIHZhciBpY29uSW1hZ2UgPSB0aGlzLmNhY2hlX1trZXldO1xuICAgICAgaWYgKChpKysgJiAzKSA9PT0gMCAmJiAhaWNvbkltYWdlLmhhc0xpc3RlbmVyKCkpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuY2FjaGVfW2tleV07XG4gICAgICAgIC0tdGhpcy5jYWNoZVNpemVfO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4qIEBwYXJhbSB7c3RyaW5nfSBzcmMgU3JjLlxuKiBAcGFyYW0gez9zdHJpbmd9IGNyb3NzT3JpZ2luIENyb3NzIG9yaWdpbi5cbiogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcn0gY29sb3IgQ29sb3IuXG4qIEByZXR1cm4ge2ltcG9ydChcIi4vSWNvbkltYWdlLmpzXCIpLmRlZmF1bHR9IEljb24gaW1hZ2UuXG4qL1xuSWNvbkltYWdlQ2FjaGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoc3JjLCBjcm9zc09yaWdpbiwgY29sb3IpIHtcbiAgdmFyIGtleSA9IGdldEtleShzcmMsIGNyb3NzT3JpZ2luLCBjb2xvcik7XG4gIHJldHVybiBrZXkgaW4gdGhpcy5jYWNoZV8gPyB0aGlzLmNhY2hlX1trZXldIDogbnVsbDtcbn07XG5cbi8qKlxuKiBAcGFyYW0ge3N0cmluZ30gc3JjIFNyYy5cbiogQHBhcmFtIHs/c3RyaW5nfSBjcm9zc09yaWdpbiBDcm9zcyBvcmlnaW4uXG4qIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J9IGNvbG9yIENvbG9yLlxuKiBAcGFyYW0ge2ltcG9ydChcIi4vSWNvbkltYWdlLmpzXCIpLmRlZmF1bHR9IGljb25JbWFnZSBJY29uIGltYWdlLlxuKi9cbkljb25JbWFnZUNhY2hlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQgKHNyYywgY3Jvc3NPcmlnaW4sIGNvbG9yLCBpY29uSW1hZ2UpIHtcbiAgdmFyIGtleSA9IGdldEtleShzcmMsIGNyb3NzT3JpZ2luLCBjb2xvcik7XG4gIHRoaXMuY2FjaGVfW2tleV0gPSBpY29uSW1hZ2U7XG4gICsrdGhpcy5jYWNoZVNpemVfO1xufTtcblxuLyoqXG4qIFNldCB0aGUgY2FjaGUgc2l6ZSBvZiB0aGUgaWNvbiBjYWNoZS4gRGVmYXVsdCBpcyBgMzJgLiBDaGFuZ2UgdGhpcyB2YWx1ZSB3aGVuXG4qIHlvdXIgbWFwIHVzZXMgbW9yZSB0aGFuIDMyIGRpZmZlcmVudCBpY29uIGltYWdlcyBhbmQgeW91IGFyZSBub3QgY2FjaGluZyBpY29uXG4qIHN0eWxlcyBvbiB0aGUgYXBwbGljYXRpb24gbGV2ZWwuXG4qIEBwYXJhbSB7bnVtYmVyfSBtYXhDYWNoZVNpemUgQ2FjaGUgbWF4IHNpemUuXG4qIEBhcGlcbiovXG5JY29uSW1hZ2VDYWNoZS5wcm90b3R5cGUuc2V0U2l6ZSA9IGZ1bmN0aW9uIHNldFNpemUgKG1heENhY2hlU2l6ZSkge1xuICB0aGlzLm1heENhY2hlU2l6ZV8gPSBtYXhDYWNoZVNpemU7XG4gIHRoaXMuZXhwaXJlKCk7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHNyYyBTcmMuXG4gKiBAcGFyYW0gez9zdHJpbmd9IGNyb3NzT3JpZ2luIENyb3NzIG9yaWdpbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J9IGNvbG9yIENvbG9yLlxuICogQHJldHVybiB7c3RyaW5nfSBDYWNoZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIGdldEtleShzcmMsIGNyb3NzT3JpZ2luLCBjb2xvcikge1xuICB2YXIgY29sb3JTdHJpbmcgPSBjb2xvciA/IGFzU3RyaW5nKGNvbG9yKSA6ICdudWxsJztcbiAgcmV0dXJuIGNyb3NzT3JpZ2luICsgJzonICsgc3JjICsgJzonICsgY29sb3JTdHJpbmc7XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgSWNvbkltYWdlQ2FjaGU7XG5cblxuLyoqXG4gKiBUaGUge0BsaW5rIG1vZHVsZTpvbC9zdHlsZS9JY29uSW1hZ2VDYWNoZX5JY29uSW1hZ2VDYWNoZX0gZm9yXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3N0eWxlL0ljb25+SWNvbn0gaW1hZ2VzLlxuICogQGFwaVxuICovXG5leHBvcnQgdmFyIHNoYXJlZCA9IG5ldyBJY29uSW1hZ2VDYWNoZSgpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1JY29uSW1hZ2VDYWNoZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvc3R5bGUvSW1hZ2VcbiAqL1xuaW1wb3J0IHthYnN0cmFjdH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gb3BhY2l0eVxuICogQHByb3BlcnR5IHtib29sZWFufSByb3RhdGVXaXRoVmlld1xuICogQHByb3BlcnR5IHtudW1iZXJ9IHJvdGF0aW9uXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2NhbGVcbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQSBiYXNlIGNsYXNzIHVzZWQgZm9yIGNyZWF0aW5nIHN1YmNsYXNzZXMgYW5kIG5vdCBpbnN0YW50aWF0ZWQgaW5cbiAqIGFwcHMuIEJhc2UgY2xhc3MgZm9yIHtAbGluayBtb2R1bGU6b2wvc3R5bGUvSWNvbn5JY29ufSwge0BsaW5rIG1vZHVsZTpvbC9zdHlsZS9DaXJjbGV+Q2lyY2xlU3R5bGV9IGFuZFxuICoge0BsaW5rIG1vZHVsZTpvbC9zdHlsZS9SZWd1bGFyU2hhcGV+UmVndWxhclNoYXBlfS5cbiAqIEBhYnN0cmFjdFxuICogQGFwaVxuICovXG52YXIgSW1hZ2VTdHlsZSA9IGZ1bmN0aW9uIEltYWdlU3R5bGUob3B0aW9ucykge1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5vcGFjaXR5XyA9IG9wdGlvbnMub3BhY2l0eTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICB0aGlzLnJvdGF0ZVdpdGhWaWV3XyA9IG9wdGlvbnMucm90YXRlV2l0aFZpZXc7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLnJvdGF0aW9uXyA9IG9wdGlvbnMucm90YXRpb247XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLnNjYWxlXyA9IG9wdGlvbnMuc2NhbGU7XG5cbn07XG5cbi8qKlxuICogQ2xvbmVzIHRoZSBzdHlsZS5cbiAqIEByZXR1cm4ge0ltYWdlU3R5bGV9IFRoZSBjbG9uZWQgc3R5bGUuXG4gKiBAYXBpXG4gKi9cbkltYWdlU3R5bGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuICByZXR1cm4gbmV3IEltYWdlU3R5bGUoe1xuICAgIG9wYWNpdHk6IHRoaXMuZ2V0T3BhY2l0eSgpLFxuICAgIHNjYWxlOiB0aGlzLmdldFNjYWxlKCksXG4gICAgcm90YXRpb246IHRoaXMuZ2V0Um90YXRpb24oKSxcbiAgICByb3RhdGVXaXRoVmlldzogdGhpcy5nZXRSb3RhdGVXaXRoVmlldygpXG4gIH0pO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHN5bWJvbGl6ZXIgb3BhY2l0eS5cbiAqIEByZXR1cm4ge251bWJlcn0gT3BhY2l0eS5cbiAqIEBhcGlcbiAqL1xuSW1hZ2VTdHlsZS5wcm90b3R5cGUuZ2V0T3BhY2l0eSA9IGZ1bmN0aW9uIGdldE9wYWNpdHkgKCkge1xuICByZXR1cm4gdGhpcy5vcGFjaXR5Xztcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHN5bWJvbGl6ZXIgcm90YXRlcyB3aXRoIHRoZSBtYXAuXG4gKiBAcmV0dXJuIHtib29sZWFufSBSb3RhdGUgd2l0aCBtYXAuXG4gKiBAYXBpXG4gKi9cbkltYWdlU3R5bGUucHJvdG90eXBlLmdldFJvdGF0ZVdpdGhWaWV3ID0gZnVuY3Rpb24gZ2V0Um90YXRlV2l0aFZpZXcgKCkge1xuICByZXR1cm4gdGhpcy5yb3RhdGVXaXRoVmlld187XG59O1xuXG4vKipcbiAqIEdldCB0aGUgc3ltb2JsaXplciByb3RhdGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn0gUm90YXRpb24uXG4gKiBAYXBpXG4gKi9cbkltYWdlU3R5bGUucHJvdG90eXBlLmdldFJvdGF0aW9uID0gZnVuY3Rpb24gZ2V0Um90YXRpb24gKCkge1xuICByZXR1cm4gdGhpcy5yb3RhdGlvbl87XG59O1xuXG4vKipcbiAqIEdldCB0aGUgc3ltYm9saXplciBzY2FsZS5cbiAqIEByZXR1cm4ge251bWJlcn0gU2NhbGUuXG4gKiBAYXBpXG4gKi9cbkltYWdlU3R5bGUucHJvdG90eXBlLmdldFNjYWxlID0gZnVuY3Rpb24gZ2V0U2NhbGUgKCkge1xuICByZXR1cm4gdGhpcy5zY2FsZV87XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGRlcHJlY2F0ZWQgYW5kIGFsd2F5cyByZXR1cm5zIGZhbHNlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gZmFsc2UuXG4gKiBAZGVwcmVjYXRlZFxuICogQGFwaVxuICovXG5JbWFnZVN0eWxlLnByb3RvdHlwZS5nZXRTbmFwVG9QaXhlbCA9IGZ1bmN0aW9uIGdldFNuYXBUb1BpeGVsICgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGFuY2hvciBwb2ludCBpbiBwaXhlbHMuIFRoZSBhbmNob3IgZGV0ZXJtaW5lcyB0aGUgY2VudGVyIHBvaW50IGZvciB0aGVcbiAqIHN5bWJvbGl6ZXIuXG4gKiBAYWJzdHJhY3RcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEFuY2hvci5cbiAqL1xuSW1hZ2VTdHlsZS5wcm90b3R5cGUuZ2V0QW5jaG9yID0gZnVuY3Rpb24gZ2V0QW5jaG9yICgpIHtcbiAgcmV0dXJuIGFic3RyYWN0KCk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgaW1hZ2UgZWxlbWVudCBmb3IgdGhlIHN5bWJvbGl6ZXIuXG4gKiBAYWJzdHJhY3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR8SFRNTFZpZGVvRWxlbWVudHxIVE1MSW1hZ2VFbGVtZW50fSBJbWFnZSBlbGVtZW50LlxuICovXG5JbWFnZVN0eWxlLnByb3RvdHlwZS5nZXRJbWFnZSA9IGZ1bmN0aW9uIGdldEltYWdlIChwaXhlbFJhdGlvKSB7XG4gIHJldHVybiBhYnN0cmFjdCgpO1xufTtcblxuLyoqXG4gKiBAYWJzdHJhY3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR8SFRNTFZpZGVvRWxlbWVudHxIVE1MSW1hZ2VFbGVtZW50fSBJbWFnZSBlbGVtZW50LlxuICovXG5JbWFnZVN0eWxlLnByb3RvdHlwZS5nZXRIaXREZXRlY3Rpb25JbWFnZSA9IGZ1bmN0aW9uIGdldEhpdERldGVjdGlvbkltYWdlIChwaXhlbFJhdGlvKSB7XG4gIHJldHVybiBhYnN0cmFjdCgpO1xufTtcblxuLyoqXG4gKiBAYWJzdHJhY3RcbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uL0ltYWdlU3RhdGUuanNcIikuZGVmYXVsdH0gSW1hZ2Ugc3RhdGUuXG4gKi9cbkltYWdlU3R5bGUucHJvdG90eXBlLmdldEltYWdlU3RhdGUgPSBmdW5jdGlvbiBnZXRJbWFnZVN0YXRlICgpIHtcbiAgcmV0dXJuIGFic3RyYWN0KCk7XG59O1xuXG4vKipcbiAqIEBhYnN0cmFjdFxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBJbWFnZSBzaXplLlxuICovXG5JbWFnZVN0eWxlLnByb3RvdHlwZS5nZXRJbWFnZVNpemUgPSBmdW5jdGlvbiBnZXRJbWFnZVNpemUgKCkge1xuICByZXR1cm4gYWJzdHJhY3QoKTtcbn07XG5cbi8qKlxuICogQGFic3RyYWN0XG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IFNpemUgb2YgdGhlIGhpdC1kZXRlY3Rpb24gaW1hZ2UuXG4gKi9cbkltYWdlU3R5bGUucHJvdG90eXBlLmdldEhpdERldGVjdGlvbkltYWdlU2l6ZSA9IGZ1bmN0aW9uIGdldEhpdERldGVjdGlvbkltYWdlU2l6ZSAoKSB7XG4gIHJldHVybiBhYnN0cmFjdCgpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIG9yaWdpbiBvZiB0aGUgc3ltYm9saXplci5cbiAqIEBhYnN0cmFjdFxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gT3JpZ2luLlxuICovXG5JbWFnZVN0eWxlLnByb3RvdHlwZS5nZXRPcmlnaW4gPSBmdW5jdGlvbiBnZXRPcmlnaW4gKCkge1xuICByZXR1cm4gYWJzdHJhY3QoKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBzaXplIG9mIHRoZSBzeW1ib2xpemVyIChpbiBwaXhlbHMpLlxuICogQGFic3RyYWN0XG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IFNpemUuXG4gKi9cbkltYWdlU3R5bGUucHJvdG90eXBlLmdldFNpemUgPSBmdW5jdGlvbiBnZXRTaXplICgpIHtcbiAgcmV0dXJuIGFic3RyYWN0KCk7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgb3BhY2l0eS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gb3BhY2l0eSBPcGFjaXR5LlxuICogQGFwaVxuICovXG5JbWFnZVN0eWxlLnByb3RvdHlwZS5zZXRPcGFjaXR5ID0gZnVuY3Rpb24gc2V0T3BhY2l0eSAob3BhY2l0eSkge1xuICB0aGlzLm9wYWNpdHlfID0gb3BhY2l0eTtcbn07XG5cbi8qKlxuICogU2V0IHdoZXRoZXIgdG8gcm90YXRlIHRoZSBzdHlsZSB3aXRoIHRoZSB2aWV3LlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcm90YXRlV2l0aFZpZXcgUm90YXRlIHdpdGggbWFwLlxuICogQGFwaVxuICovXG5JbWFnZVN0eWxlLnByb3RvdHlwZS5zZXRSb3RhdGVXaXRoVmlldyA9IGZ1bmN0aW9uIHNldFJvdGF0ZVdpdGhWaWV3IChyb3RhdGVXaXRoVmlldykge1xuICB0aGlzLnJvdGF0ZVdpdGhWaWV3XyA9IHJvdGF0ZVdpdGhWaWV3O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHJvdGF0aW9uLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAqIEBhcGlcbiAqL1xuSW1hZ2VTdHlsZS5wcm90b3R5cGUuc2V0Um90YXRpb24gPSBmdW5jdGlvbiBzZXRSb3RhdGlvbiAocm90YXRpb24pIHtcbiAgdGhpcy5yb3RhdGlvbl8gPSByb3RhdGlvbjtcbn07XG4vKipcbiAqIFNldCB0aGUgc2NhbGUuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlIFNjYWxlLlxuICogQGFwaVxuICovXG5JbWFnZVN0eWxlLnByb3RvdHlwZS5zZXRTY2FsZSA9IGZ1bmN0aW9uIHNldFNjYWxlIChzY2FsZSkge1xuICB0aGlzLnNjYWxlXyA9IHNjYWxlO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBkZXByZWNhdGVkIGFuZCBkb2VzIG5vdGhpbmcuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNuYXBUb1BpeGVsIFNuYXAgdG8gcGl4ZWw/XG4gKiBAZGVwcmVjYXRlZFxuICogQGFwaVxuICovXG5JbWFnZVN0eWxlLnByb3RvdHlwZS5zZXRTbmFwVG9QaXhlbCA9IGZ1bmN0aW9uIHNldFNuYXBUb1BpeGVsIChzbmFwVG9QaXhlbCkge307XG5cbi8qKlxuICogQGFic3RyYWN0XG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6IFQsIGltcG9ydChcIi4uL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0KX0gbGlzdGVuZXIgTGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge1R9IHRoaXNBcmcgVmFsdWUgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyBgbGlzdGVuZXJgLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleXx1bmRlZmluZWR9IExpc3RlbmVyIGtleS5cbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbkltYWdlU3R5bGUucHJvdG90eXBlLmxpc3RlbkltYWdlQ2hhbmdlID0gZnVuY3Rpb24gbGlzdGVuSW1hZ2VDaGFuZ2UgKGxpc3RlbmVyLCB0aGlzQXJnKSB7XG4gIHJldHVybiBhYnN0cmFjdCgpO1xufTtcblxuLyoqXG4gKiBMb2FkIG5vdCB5ZXQgbG9hZGVkIFVSSS5cbiAqIEBhYnN0cmFjdFxuICovXG5JbWFnZVN0eWxlLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gbG9hZCAoKSB7XG4gIGFic3RyYWN0KCk7XG59O1xuXG4vKipcbiAqIEBhYnN0cmFjdFxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBULCBpbXBvcnQoXCIuLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdCl9IGxpc3RlbmVyIExpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtUfSB0aGlzQXJnIFZhbHVlIHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgYGxpc3RlbmVyYC5cbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbkltYWdlU3R5bGUucHJvdG90eXBlLnVubGlzdGVuSW1hZ2VDaGFuZ2UgPSBmdW5jdGlvbiB1bmxpc3RlbkltYWdlQ2hhbmdlIChsaXN0ZW5lciwgdGhpc0FyZykge1xuICBhYnN0cmFjdCgpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgSW1hZ2VTdHlsZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW1hZ2UuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3N0eWxlL1JlZ3VsYXJTaGFwZVxuICovXG5cbmltcG9ydCB7YXNTdHJpbmd9IGZyb20gJy4uL2NvbG9yLmpzJztcbmltcG9ydCB7YXNDb2xvckxpa2V9IGZyb20gJy4uL2NvbG9ybGlrZS5qcyc7XG5pbXBvcnQge2NyZWF0ZUNhbnZhc0NvbnRleHQyRH0gZnJvbSAnLi4vZG9tLmpzJztcbmltcG9ydCB7Q0FOVkFTX0xJTkVfREFTSH0gZnJvbSAnLi4vaGFzLmpzJztcbmltcG9ydCBJbWFnZVN0YXRlIGZyb20gJy4uL0ltYWdlU3RhdGUuanMnO1xuaW1wb3J0IHtkZWZhdWx0U3Ryb2tlU3R5bGUsIGRlZmF1bHRGaWxsU3R5bGUsIGRlZmF1bHRMaW5lQ2FwLCBkZWZhdWx0TGluZVdpZHRoLCBkZWZhdWx0TGluZUpvaW4sIGRlZmF1bHRNaXRlckxpbWl0fSBmcm9tICcuLi9yZW5kZXIvY2FudmFzLmpzJztcbmltcG9ydCBJbWFnZVN0eWxlIGZyb20gJy4vSW1hZ2UuanMnO1xuXG5cbi8qKlxuICogU3BlY2lmeSByYWRpdXMgZm9yIHJlZ3VsYXIgcG9seWdvbnMsIG9yIHJhZGl1czEgYW5kIHJhZGl1czIgZm9yIHN0YXJzLlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL0ZpbGwuanNcIikuZGVmYXVsdH0gW2ZpbGxdIEZpbGwgc3R5bGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gcG9pbnRzIE51bWJlciBvZiBwb2ludHMgZm9yIHN0YXJzIGFuZCByZWd1bGFyIHBvbHlnb25zLiBJbiBjYXNlIG9mIGEgcG9seWdvbiwgdGhlIG51bWJlciBvZiBwb2ludHNcbiAqIGlzIHRoZSBudW1iZXIgb2Ygc2lkZXMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JhZGl1c10gUmFkaXVzIG9mIGEgcmVndWxhciBwb2x5Z29uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyYWRpdXMxXSBPdXRlciByYWRpdXMgb2YgYSBzdGFyLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyYWRpdXMyXSBJbm5lciByYWRpdXMgb2YgYSBzdGFyLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFthbmdsZT0wXSBTaGFwZSdzIGFuZ2xlIGluIHJhZGlhbnMuIEEgdmFsdWUgb2YgMCB3aWxsIGhhdmUgb25lIG9mIHRoZSBzaGFwZSdzIHBvaW50IGZhY2luZyB1cC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdH0gW3N0cm9rZV0gU3Ryb2tlIHN0eWxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyb3RhdGlvbj0wXSBSb3RhdGlvbiBpbiByYWRpYW5zIChwb3NpdGl2ZSByb3RhdGlvbiBjbG9ja3dpc2UpLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbcm90YXRlV2l0aFZpZXc9ZmFsc2VdIFdoZXRoZXIgdG8gcm90YXRlIHRoZSBzaGFwZSB3aXRoIHRoZSB2aWV3LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL0F0bGFzTWFuYWdlci5qc1wiKS5kZWZhdWx0fSBbYXRsYXNNYW5hZ2VyXSBUaGUgYXRsYXMgbWFuYWdlciB0byB1c2UgZm9yIHRoaXMgc3ltYm9sLiBXaGVuXG4gKiB1c2luZyBXZWJHTCBpdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgYW4gYXRsYXMgbWFuYWdlciB0byBhdm9pZCB0ZXh0dXJlIHN3aXRjaGluZy4gSWYgYW4gYXRsYXMgbWFuYWdlciBpcyBnaXZlbiwgdGhlXG4gKiBzeW1ib2wgaXMgYWRkZWQgdG8gYW4gYXRsYXMuIEJ5IGRlZmF1bHQgbm8gYXRsYXMgbWFuYWdlciBpcyB1c2VkLlxuICovXG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBSZW5kZXJPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9IFtzdHJva2VTdHlsZV1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdHJva2VXaWR0aFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNpemVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBsaW5lQ2FwXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IGxpbmVEYXNoXG4gKiBAcHJvcGVydHkge251bWJlcn0gbGluZURhc2hPZmZzZXRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBsaW5lSm9pblxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1pdGVyTGltaXRcbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogU2V0IHJlZ3VsYXIgc2hhcGUgc3R5bGUgZm9yIHZlY3RvciBmZWF0dXJlcy4gVGhlIHJlc3VsdGluZyBzaGFwZSB3aWxsIGJlXG4gKiBhIHJlZ3VsYXIgcG9seWdvbiB3aGVuIGByYWRpdXNgIGlzIHByb3ZpZGVkLCBvciBhIHN0YXIgd2hlbiBgcmFkaXVzMWAgYW5kXG4gKiBgcmFkaXVzMmAgYXJlIHByb3ZpZGVkLlxuICogQGFwaVxuICovXG52YXIgUmVndWxhclNoYXBlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoSW1hZ2VTdHlsZSkge1xuICBmdW5jdGlvbiBSZWd1bGFyU2hhcGUob3B0aW9ucykge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHZhciByb3RhdGVXaXRoVmlldyA9IG9wdGlvbnMucm90YXRlV2l0aFZpZXcgIT09IHVuZGVmaW5lZCA/XG4gICAgICBvcHRpb25zLnJvdGF0ZVdpdGhWaWV3IDogZmFsc2U7XG5cbiAgICBJbWFnZVN0eWxlLmNhbGwodGhpcywge1xuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIHJvdGF0ZVdpdGhWaWV3OiByb3RhdGVXaXRoVmlldyxcbiAgICAgIHJvdGF0aW9uOiBvcHRpb25zLnJvdGF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnJvdGF0aW9uIDogMCxcbiAgICAgIHNjYWxlOiAxXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxzdHJpbmd8bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLmNoZWNrc3Vtc18gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5jYW52YXNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uQ2FudmFzXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL0ZpbGwuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLmZpbGxfID0gb3B0aW9ucy5maWxsICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmZpbGwgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLm9yaWdpbl8gPSBbMCwgMF07XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5wb2ludHNfID0gb3B0aW9ucy5wb2ludHM7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJhZGl1c18gPSAvKiogQHR5cGUge251bWJlcn0gKi8gKG9wdGlvbnMucmFkaXVzICE9PSB1bmRlZmluZWQgP1xuICAgICAgb3B0aW9ucy5yYWRpdXMgOiBvcHRpb25zLnJhZGl1czEpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnJhZGl1czJfID0gb3B0aW9ucy5yYWRpdXMyO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuYW5nbGVfID0gb3B0aW9ucy5hbmdsZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5hbmdsZSA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL1N0cm9rZS5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMuc3Ryb2tlXyA9IG9wdGlvbnMuc3Ryb2tlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0cm9rZSA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMuYW5jaG9yXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9XG4gICAgICovXG4gICAgdGhpcy5zaXplXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9XG4gICAgICovXG4gICAgdGhpcy5pbWFnZVNpemVfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX1cbiAgICAgKi9cbiAgICB0aGlzLmhpdERldGVjdGlvbkltYWdlU2l6ZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL0F0bGFzTWFuYWdlci5qc1wiKS5kZWZhdWx0fHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmF0bGFzTWFuYWdlcl8gPSBvcHRpb25zLmF0bGFzTWFuYWdlcjtcblxuICAgIHRoaXMucmVuZGVyXyh0aGlzLmF0bGFzTWFuYWdlcl8pO1xuXG4gIH1cblxuICBpZiAoIEltYWdlU3R5bGUgKSBSZWd1bGFyU2hhcGUuX19wcm90b19fID0gSW1hZ2VTdHlsZTtcbiAgUmVndWxhclNoYXBlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEltYWdlU3R5bGUgJiYgSW1hZ2VTdHlsZS5wcm90b3R5cGUgKTtcbiAgUmVndWxhclNoYXBlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlZ3VsYXJTaGFwZTtcblxuICAvKipcbiAgICogQ2xvbmVzIHRoZSBzdHlsZS4gSWYgYW4gYXRsYXNtYW5hZ2VyIHdhcyBwcm92aWRlZCB0byB0aGUgb3JpZ2luYWwgc3R5bGUgaXQgd2lsbCBiZSB1c2VkIGluIHRoZSBjbG9uZWQgc3R5bGUsIHRvby5cbiAgICogQHJldHVybiB7UmVndWxhclNoYXBlfSBUaGUgY2xvbmVkIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBSZWd1bGFyU2hhcGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgIHZhciBzdHlsZSA9IG5ldyBSZWd1bGFyU2hhcGUoe1xuICAgICAgZmlsbDogdGhpcy5nZXRGaWxsKCkgPyB0aGlzLmdldEZpbGwoKS5jbG9uZSgpIDogdW5kZWZpbmVkLFxuICAgICAgcG9pbnRzOiB0aGlzLmdldFBvaW50cygpLFxuICAgICAgcmFkaXVzOiB0aGlzLmdldFJhZGl1cygpLFxuICAgICAgcmFkaXVzMjogdGhpcy5nZXRSYWRpdXMyKCksXG4gICAgICBhbmdsZTogdGhpcy5nZXRBbmdsZSgpLFxuICAgICAgc3Ryb2tlOiB0aGlzLmdldFN0cm9rZSgpID8gdGhpcy5nZXRTdHJva2UoKS5jbG9uZSgpIDogdW5kZWZpbmVkLFxuICAgICAgcm90YXRpb246IHRoaXMuZ2V0Um90YXRpb24oKSxcbiAgICAgIHJvdGF0ZVdpdGhWaWV3OiB0aGlzLmdldFJvdGF0ZVdpdGhWaWV3KCksXG4gICAgICBhdGxhc01hbmFnZXI6IHRoaXMuYXRsYXNNYW5hZ2VyX1xuICAgIH0pO1xuICAgIHN0eWxlLnNldE9wYWNpdHkodGhpcy5nZXRPcGFjaXR5KCkpO1xuICAgIHN0eWxlLnNldFNjYWxlKHRoaXMuZ2V0U2NhbGUoKSk7XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKiBAYXBpXG4gICAqL1xuICBSZWd1bGFyU2hhcGUucHJvdG90eXBlLmdldEFuY2hvciA9IGZ1bmN0aW9uIGdldEFuY2hvciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYW5jaG9yXztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBhbmdsZSB1c2VkIGluIGdlbmVyYXRpbmcgdGhlIHNoYXBlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFNoYXBlJ3Mgcm90YXRpb24gaW4gcmFkaWFucy5cbiAgICogQGFwaVxuICAgKi9cbiAgUmVndWxhclNoYXBlLnByb3RvdHlwZS5nZXRBbmdsZSA9IGZ1bmN0aW9uIGdldEFuZ2xlICgpIHtcbiAgICByZXR1cm4gdGhpcy5hbmdsZV87XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZmlsbCBzdHlsZSBmb3IgdGhlIHNoYXBlLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL0ZpbGwuanNcIikuZGVmYXVsdH0gRmlsbCBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgUmVndWxhclNoYXBlLnByb3RvdHlwZS5nZXRGaWxsID0gZnVuY3Rpb24gZ2V0RmlsbCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsbF87XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBSZWd1bGFyU2hhcGUucHJvdG90eXBlLmdldEhpdERldGVjdGlvbkltYWdlID0gZnVuY3Rpb24gZ2V0SGl0RGV0ZWN0aW9uSW1hZ2UgKHBpeGVsUmF0aW8pIHtcbiAgICByZXR1cm4gdGhpcy5oaXREZXRlY3Rpb25DYW52YXNfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKiBAYXBpXG4gICAqL1xuICBSZWd1bGFyU2hhcGUucHJvdG90eXBlLmdldEltYWdlID0gZnVuY3Rpb24gZ2V0SW1hZ2UgKHBpeGVsUmF0aW8pIHtcbiAgICByZXR1cm4gdGhpcy5jYW52YXNfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgUmVndWxhclNoYXBlLnByb3RvdHlwZS5nZXRJbWFnZVNpemUgPSBmdW5jdGlvbiBnZXRJbWFnZVNpemUgKCkge1xuICAgIHJldHVybiB0aGlzLmltYWdlU2l6ZV87XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBSZWd1bGFyU2hhcGUucHJvdG90eXBlLmdldEhpdERldGVjdGlvbkltYWdlU2l6ZSA9IGZ1bmN0aW9uIGdldEhpdERldGVjdGlvbkltYWdlU2l6ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGl0RGV0ZWN0aW9uSW1hZ2VTaXplXztcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIFJlZ3VsYXJTaGFwZS5wcm90b3R5cGUuZ2V0SW1hZ2VTdGF0ZSA9IGZ1bmN0aW9uIGdldEltYWdlU3RhdGUgKCkge1xuICAgIHJldHVybiBJbWFnZVN0YXRlLkxPQURFRDtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGFwaVxuICAgKi9cbiAgUmVndWxhclNoYXBlLnByb3RvdHlwZS5nZXRPcmlnaW4gPSBmdW5jdGlvbiBnZXRPcmlnaW4gKCkge1xuICAgIHJldHVybiB0aGlzLm9yaWdpbl87XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbnVtYmVyIG9mIHBvaW50cyBmb3IgZ2VuZXJhdGluZyB0aGUgc2hhcGUuXG4gICAqIEByZXR1cm4ge251bWJlcn0gTnVtYmVyIG9mIHBvaW50cyBmb3Igc3RhcnMgYW5kIHJlZ3VsYXIgcG9seWdvbnMuXG4gICAqIEBhcGlcbiAgICovXG4gIFJlZ3VsYXJTaGFwZS5wcm90b3R5cGUuZ2V0UG9pbnRzID0gZnVuY3Rpb24gZ2V0UG9pbnRzICgpIHtcbiAgICByZXR1cm4gdGhpcy5wb2ludHNfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIChwcmltYXJ5KSByYWRpdXMgZm9yIHRoZSBzaGFwZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBSYWRpdXMuXG4gICAqIEBhcGlcbiAgICovXG4gIFJlZ3VsYXJTaGFwZS5wcm90b3R5cGUuZ2V0UmFkaXVzID0gZnVuY3Rpb24gZ2V0UmFkaXVzICgpIHtcbiAgICByZXR1cm4gdGhpcy5yYWRpdXNfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNlY29uZGFyeSByYWRpdXMgZm9yIHRoZSBzaGFwZS5cbiAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gUmFkaXVzMi5cbiAgICogQGFwaVxuICAgKi9cbiAgUmVndWxhclNoYXBlLnByb3RvdHlwZS5nZXRSYWRpdXMyID0gZnVuY3Rpb24gZ2V0UmFkaXVzMiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmFkaXVzMl87XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqIEBhcGlcbiAgICovXG4gIFJlZ3VsYXJTaGFwZS5wcm90b3R5cGUuZ2V0U2l6ZSA9IGZ1bmN0aW9uIGdldFNpemUgKCkge1xuICAgIHJldHVybiB0aGlzLnNpemVfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0cm9rZSBzdHlsZSBmb3IgdGhlIHNoYXBlLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL1N0cm9rZS5qc1wiKS5kZWZhdWx0fSBTdHJva2Ugc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIFJlZ3VsYXJTaGFwZS5wcm90b3R5cGUuZ2V0U3Ryb2tlID0gZnVuY3Rpb24gZ2V0U3Ryb2tlICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJva2VfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgUmVndWxhclNoYXBlLnByb3RvdHlwZS5saXN0ZW5JbWFnZUNoYW5nZSA9IGZ1bmN0aW9uIGxpc3RlbkltYWdlQ2hhbmdlIChsaXN0ZW5lciwgdGhpc0FyZykge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBSZWd1bGFyU2hhcGUucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiBsb2FkICgpIHt9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgUmVndWxhclNoYXBlLnByb3RvdHlwZS51bmxpc3RlbkltYWdlQ2hhbmdlID0gZnVuY3Rpb24gdW5saXN0ZW5JbWFnZUNoYW5nZSAobGlzdGVuZXIsIHRoaXNBcmcpIHt9O1xuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9BdGxhc01hbmFnZXIuanNcIikuZGVmYXVsdHx1bmRlZmluZWR9IGF0bGFzTWFuYWdlciBBbiBhdGxhcyBtYW5hZ2VyLlxuICAgKi9cbiAgUmVndWxhclNoYXBlLnByb3RvdHlwZS5yZW5kZXJfID0gZnVuY3Rpb24gcmVuZGVyXyAoYXRsYXNNYW5hZ2VyKSB7XG4gICAgdmFyIGltYWdlU2l6ZTtcbiAgICB2YXIgbGluZUNhcCA9ICcnO1xuICAgIHZhciBsaW5lSm9pbiA9ICcnO1xuICAgIHZhciBtaXRlckxpbWl0ID0gMDtcbiAgICB2YXIgbGluZURhc2ggPSBudWxsO1xuICAgIHZhciBsaW5lRGFzaE9mZnNldCA9IDA7XG4gICAgdmFyIHN0cm9rZVN0eWxlO1xuICAgIHZhciBzdHJva2VXaWR0aCA9IDA7XG5cbiAgICBpZiAodGhpcy5zdHJva2VfKSB7XG4gICAgICBzdHJva2VTdHlsZSA9IHRoaXMuc3Ryb2tlXy5nZXRDb2xvcigpO1xuICAgICAgaWYgKHN0cm9rZVN0eWxlID09PSBudWxsKSB7XG4gICAgICAgIHN0cm9rZVN0eWxlID0gZGVmYXVsdFN0cm9rZVN0eWxlO1xuICAgICAgfVxuICAgICAgc3Ryb2tlU3R5bGUgPSBhc0NvbG9yTGlrZShzdHJva2VTdHlsZSk7XG4gICAgICBzdHJva2VXaWR0aCA9IHRoaXMuc3Ryb2tlXy5nZXRXaWR0aCgpO1xuICAgICAgaWYgKHN0cm9rZVdpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3Ryb2tlV2lkdGggPSBkZWZhdWx0TGluZVdpZHRoO1xuICAgICAgfVxuICAgICAgbGluZURhc2ggPSB0aGlzLnN0cm9rZV8uZ2V0TGluZURhc2goKTtcbiAgICAgIGxpbmVEYXNoT2Zmc2V0ID0gdGhpcy5zdHJva2VfLmdldExpbmVEYXNoT2Zmc2V0KCk7XG4gICAgICBpZiAoIUNBTlZBU19MSU5FX0RBU0gpIHtcbiAgICAgICAgbGluZURhc2ggPSBudWxsO1xuICAgICAgICBsaW5lRGFzaE9mZnNldCA9IDA7XG4gICAgICB9XG4gICAgICBsaW5lSm9pbiA9IHRoaXMuc3Ryb2tlXy5nZXRMaW5lSm9pbigpO1xuICAgICAgaWYgKGxpbmVKb2luID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGluZUpvaW4gPSBkZWZhdWx0TGluZUpvaW47XG4gICAgICB9XG4gICAgICBsaW5lQ2FwID0gdGhpcy5zdHJva2VfLmdldExpbmVDYXAoKTtcbiAgICAgIGlmIChsaW5lQ2FwID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGluZUNhcCA9IGRlZmF1bHRMaW5lQ2FwO1xuICAgICAgfVxuICAgICAgbWl0ZXJMaW1pdCA9IHRoaXMuc3Ryb2tlXy5nZXRNaXRlckxpbWl0KCk7XG4gICAgICBpZiAobWl0ZXJMaW1pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1pdGVyTGltaXQgPSBkZWZhdWx0TWl0ZXJMaW1pdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2l6ZSA9IDIgKiAodGhpcy5yYWRpdXNfICsgc3Ryb2tlV2lkdGgpICsgMTtcblxuICAgIC8qKiBAdHlwZSB7UmVuZGVyT3B0aW9uc30gKi9cbiAgICB2YXIgcmVuZGVyT3B0aW9ucyA9IHtcbiAgICAgIHN0cm9rZVN0eWxlOiBzdHJva2VTdHlsZSxcbiAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICAgIHNpemU6IHNpemUsXG4gICAgICBsaW5lQ2FwOiBsaW5lQ2FwLFxuICAgICAgbGluZURhc2g6IGxpbmVEYXNoLFxuICAgICAgbGluZURhc2hPZmZzZXQ6IGxpbmVEYXNoT2Zmc2V0LFxuICAgICAgbGluZUpvaW46IGxpbmVKb2luLFxuICAgICAgbWl0ZXJMaW1pdDogbWl0ZXJMaW1pdFxuICAgIH07XG5cbiAgICBpZiAoYXRsYXNNYW5hZ2VyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIG5vIGF0bGFzIG1hbmFnZXIgaXMgdXNlZCwgY3JlYXRlIGEgbmV3IGNhbnZhc1xuICAgICAgdmFyIGNvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0MkQoc2l6ZSwgc2l6ZSk7XG4gICAgICB0aGlzLmNhbnZhc18gPSBjb250ZXh0LmNhbnZhcztcblxuICAgICAgLy8gY2FudmFzLndpZHRoIGFuZCBoZWlnaHQgYXJlIHJvdW5kZWQgdG8gdGhlIGNsb3Nlc3QgaW50ZWdlclxuICAgICAgc2l6ZSA9IHRoaXMuY2FudmFzXy53aWR0aDtcbiAgICAgIGltYWdlU2l6ZSA9IHNpemU7XG5cbiAgICAgIHRoaXMuZHJhd18ocmVuZGVyT3B0aW9ucywgY29udGV4dCwgMCwgMCk7XG5cbiAgICAgIHRoaXMuY3JlYXRlSGl0RGV0ZWN0aW9uQ2FudmFzXyhyZW5kZXJPcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYW4gYXRsYXMgbWFuYWdlciBpcyB1c2VkLCBhZGQgdGhlIHN5bWJvbCB0byBhbiBhdGxhc1xuICAgICAgc2l6ZSA9IE1hdGgucm91bmQoc2l6ZSk7XG5cbiAgICAgIHZhciBoYXNDdXN0b21IaXREZXRlY3Rpb25JbWFnZSA9ICF0aGlzLmZpbGxfO1xuICAgICAgdmFyIHJlbmRlckhpdERldGVjdGlvbkNhbGxiYWNrO1xuICAgICAgaWYgKGhhc0N1c3RvbUhpdERldGVjdGlvbkltYWdlKSB7XG4gICAgICAgIC8vIHJlbmRlciB0aGUgaGl0LWRldGVjdGlvbiBpbWFnZSBpbnRvIGEgc2VwYXJhdGUgYXRsYXMgaW1hZ2VcbiAgICAgICAgcmVuZGVySGl0RGV0ZWN0aW9uQ2FsbGJhY2sgPVxuICAgICAgICAgICAgdGhpcy5kcmF3SGl0RGV0ZWN0aW9uQ2FudmFzXy5iaW5kKHRoaXMsIHJlbmRlck9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWQgPSB0aGlzLmdldENoZWNrc3VtKCk7XG4gICAgICB2YXIgaW5mbyA9IGF0bGFzTWFuYWdlci5hZGQoXG4gICAgICAgIGlkLCBzaXplLCBzaXplLCB0aGlzLmRyYXdfLmJpbmQodGhpcywgcmVuZGVyT3B0aW9ucyksXG4gICAgICAgIHJlbmRlckhpdERldGVjdGlvbkNhbGxiYWNrKTtcblxuICAgICAgdGhpcy5jYW52YXNfID0gaW5mby5pbWFnZTtcbiAgICAgIHRoaXMub3JpZ2luXyA9IFtpbmZvLm9mZnNldFgsIGluZm8ub2Zmc2V0WV07XG4gICAgICBpbWFnZVNpemUgPSBpbmZvLmltYWdlLndpZHRoO1xuXG4gICAgICBpZiAoaGFzQ3VzdG9tSGl0RGV0ZWN0aW9uSW1hZ2UpIHtcbiAgICAgICAgdGhpcy5oaXREZXRlY3Rpb25DYW52YXNfID0gaW5mby5oaXRJbWFnZTtcbiAgICAgICAgdGhpcy5oaXREZXRlY3Rpb25JbWFnZVNpemVfID1cbiAgICAgICAgICAgIFtpbmZvLmhpdEltYWdlLndpZHRoLCBpbmZvLmhpdEltYWdlLmhlaWdodF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhpdERldGVjdGlvbkNhbnZhc18gPSB0aGlzLmNhbnZhc187XG4gICAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW1hZ2VTaXplXyA9IFtpbWFnZVNpemUsIGltYWdlU2l6ZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5hbmNob3JfID0gW3NpemUgLyAyLCBzaXplIC8gMl07XG4gICAgdGhpcy5zaXplXyA9IFtzaXplLCBzaXplXTtcbiAgICB0aGlzLmltYWdlU2l6ZV8gPSBbaW1hZ2VTaXplLCBpbWFnZVNpemVdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1JlbmRlck9wdGlvbnN9IHJlbmRlck9wdGlvbnMgUmVuZGVyIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IFRoZSByZW5kZXJpbmcgY29udGV4dC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIG9yaWdpbiBmb3IgdGhlIHN5bWJvbCAoeCkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IFRoZSBvcmlnaW4gZm9yIHRoZSBzeW1ib2wgKHkpLlxuICAgKi9cbiAgUmVndWxhclNoYXBlLnByb3RvdHlwZS5kcmF3XyA9IGZ1bmN0aW9uIGRyYXdfIChyZW5kZXJPcHRpb25zLCBjb250ZXh0LCB4LCB5KSB7XG4gICAgdmFyIGksIGFuZ2xlMCwgcmFkaXVzQztcbiAgICAvLyByZXNldCB0cmFuc2Zvcm1cbiAgICBjb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcblxuICAgIC8vIHRoZW4gbW92ZSB0byAoeCwgeSlcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSh4LCB5KTtcblxuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG5cbiAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHNfO1xuICAgIGlmIChwb2ludHMgPT09IEluZmluaXR5KSB7XG4gICAgICBjb250ZXh0LmFyYyhcbiAgICAgICAgcmVuZGVyT3B0aW9ucy5zaXplIC8gMiwgcmVuZGVyT3B0aW9ucy5zaXplIC8gMixcbiAgICAgICAgdGhpcy5yYWRpdXNfLCAwLCAyICogTWF0aC5QSSwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByYWRpdXMyID0gKHRoaXMucmFkaXVzMl8gIT09IHVuZGVmaW5lZCkgPyB0aGlzLnJhZGl1czJfXG4gICAgICAgIDogdGhpcy5yYWRpdXNfO1xuICAgICAgaWYgKHJhZGl1czIgIT09IHRoaXMucmFkaXVzXykge1xuICAgICAgICBwb2ludHMgPSAyICogcG9pbnRzO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8PSBwb2ludHM7IGkrKykge1xuICAgICAgICBhbmdsZTAgPSBpICogMiAqIE1hdGguUEkgLyBwb2ludHMgLSBNYXRoLlBJIC8gMiArIHRoaXMuYW5nbGVfO1xuICAgICAgICByYWRpdXNDID0gaSAlIDIgPT09IDAgPyB0aGlzLnJhZGl1c18gOiByYWRpdXMyO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyhyZW5kZXJPcHRpb25zLnNpemUgLyAyICsgcmFkaXVzQyAqIE1hdGguY29zKGFuZ2xlMCksXG4gICAgICAgICAgcmVuZGVyT3B0aW9ucy5zaXplIC8gMiArIHJhZGl1c0MgKiBNYXRoLnNpbihhbmdsZTApKTtcbiAgICAgIH1cbiAgICB9XG5cblxuICAgIGlmICh0aGlzLmZpbGxfKSB7XG4gICAgICB2YXIgY29sb3IgPSB0aGlzLmZpbGxfLmdldENvbG9yKCk7XG4gICAgICBpZiAoY29sb3IgPT09IG51bGwpIHtcbiAgICAgICAgY29sb3IgPSBkZWZhdWx0RmlsbFN0eWxlO1xuICAgICAgfVxuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBhc0NvbG9yTGlrZShjb2xvcik7XG4gICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3Ryb2tlXykge1xuICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHJlbmRlck9wdGlvbnMuc3Ryb2tlU3R5bGU7XG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHJlbmRlck9wdGlvbnMuc3Ryb2tlV2lkdGg7XG4gICAgICBpZiAocmVuZGVyT3B0aW9ucy5saW5lRGFzaCkge1xuICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKHJlbmRlck9wdGlvbnMubGluZURhc2gpO1xuICAgICAgICBjb250ZXh0LmxpbmVEYXNoT2Zmc2V0ID0gcmVuZGVyT3B0aW9ucy5saW5lRGFzaE9mZnNldDtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQubGluZUNhcCA9IC8qKiBAdHlwZSB7Q2FudmFzTGluZUNhcH0gKi8gKHJlbmRlck9wdGlvbnMubGluZUNhcCk7XG4gICAgICBjb250ZXh0LmxpbmVKb2luID0gLyoqIEB0eXBlIHtDYW52YXNMaW5lSm9pbn0gKi8gKHJlbmRlck9wdGlvbnMubGluZUpvaW4pO1xuICAgICAgY29udGV4dC5taXRlckxpbWl0ID0gcmVuZGVyT3B0aW9ucy5taXRlckxpbWl0O1xuICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICB9XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtSZW5kZXJPcHRpb25zfSByZW5kZXJPcHRpb25zIFJlbmRlciBvcHRpb25zLlxuICAgKi9cbiAgUmVndWxhclNoYXBlLnByb3RvdHlwZS5jcmVhdGVIaXREZXRlY3Rpb25DYW52YXNfID0gZnVuY3Rpb24gY3JlYXRlSGl0RGV0ZWN0aW9uQ2FudmFzXyAocmVuZGVyT3B0aW9ucykge1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW1hZ2VTaXplXyA9IFtyZW5kZXJPcHRpb25zLnNpemUsIHJlbmRlck9wdGlvbnMuc2l6ZV07XG4gICAgaWYgKHRoaXMuZmlsbF8pIHtcbiAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uQ2FudmFzXyA9IHRoaXMuY2FudmFzXztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBpZiBubyBmaWxsIHN0eWxlIGlzIHNldCwgY3JlYXRlIGFuIGV4dHJhIGhpdC1kZXRlY3Rpb24gaW1hZ2Ugd2l0aCBhXG4gICAgLy8gZGVmYXVsdCBmaWxsIHN0eWxlXG4gICAgdmFyIGNvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0MkQocmVuZGVyT3B0aW9ucy5zaXplLCByZW5kZXJPcHRpb25zLnNpemUpO1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uQ2FudmFzXyA9IGNvbnRleHQuY2FudmFzO1xuXG4gICAgdGhpcy5kcmF3SGl0RGV0ZWN0aW9uQ2FudmFzXyhyZW5kZXJPcHRpb25zLCBjb250ZXh0LCAwLCAwKTtcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtSZW5kZXJPcHRpb25zfSByZW5kZXJPcHRpb25zIFJlbmRlciBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBUaGUgY29udGV4dC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIG9yaWdpbiBmb3IgdGhlIHN5bWJvbCAoeCkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IFRoZSBvcmlnaW4gZm9yIHRoZSBzeW1ib2wgKHkpLlxuICAgKi9cbiAgUmVndWxhclNoYXBlLnByb3RvdHlwZS5kcmF3SGl0RGV0ZWN0aW9uQ2FudmFzXyA9IGZ1bmN0aW9uIGRyYXdIaXREZXRlY3Rpb25DYW52YXNfIChyZW5kZXJPcHRpb25zLCBjb250ZXh0LCB4LCB5KSB7XG4gICAgLy8gcmVzZXQgdHJhbnNmb3JtXG4gICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cbiAgICAvLyB0aGVuIG1vdmUgdG8gKHgsIHkpXG4gICAgY29udGV4dC50cmFuc2xhdGUoeCwgeSk7XG5cbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuXG4gICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzXztcbiAgICBpZiAocG9pbnRzID09PSBJbmZpbml0eSkge1xuICAgICAgY29udGV4dC5hcmMoXG4gICAgICAgIHJlbmRlck9wdGlvbnMuc2l6ZSAvIDIsIHJlbmRlck9wdGlvbnMuc2l6ZSAvIDIsXG4gICAgICAgIHRoaXMucmFkaXVzXywgMCwgMiAqIE1hdGguUEksIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmFkaXVzMiA9ICh0aGlzLnJhZGl1czJfICE9PSB1bmRlZmluZWQpID8gdGhpcy5yYWRpdXMyX1xuICAgICAgICA6IHRoaXMucmFkaXVzXztcbiAgICAgIGlmIChyYWRpdXMyICE9PSB0aGlzLnJhZGl1c18pIHtcbiAgICAgICAgcG9pbnRzID0gMiAqIHBvaW50cztcbiAgICAgIH1cbiAgICAgIHZhciBpLCByYWRpdXNDLCBhbmdsZTA7XG4gICAgICBmb3IgKGkgPSAwOyBpIDw9IHBvaW50czsgaSsrKSB7XG4gICAgICAgIGFuZ2xlMCA9IGkgKiAyICogTWF0aC5QSSAvIHBvaW50cyAtIE1hdGguUEkgLyAyICsgdGhpcy5hbmdsZV87XG4gICAgICAgIHJhZGl1c0MgPSBpICUgMiA9PT0gMCA/IHRoaXMucmFkaXVzXyA6IHJhZGl1czI7XG4gICAgICAgIGNvbnRleHQubGluZVRvKHJlbmRlck9wdGlvbnMuc2l6ZSAvIDIgKyByYWRpdXNDICogTWF0aC5jb3MoYW5nbGUwKSxcbiAgICAgICAgICByZW5kZXJPcHRpb25zLnNpemUgLyAyICsgcmFkaXVzQyAqIE1hdGguc2luKGFuZ2xlMCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gYXNTdHJpbmcoZGVmYXVsdEZpbGxTdHlsZSk7XG4gICAgY29udGV4dC5maWxsKCk7XG4gICAgaWYgKHRoaXMuc3Ryb2tlXykge1xuICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHJlbmRlck9wdGlvbnMuc3Ryb2tlU3R5bGU7XG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHJlbmRlck9wdGlvbnMuc3Ryb2tlV2lkdGg7XG4gICAgICBpZiAocmVuZGVyT3B0aW9ucy5saW5lRGFzaCkge1xuICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKHJlbmRlck9wdGlvbnMubGluZURhc2gpO1xuICAgICAgICBjb250ZXh0LmxpbmVEYXNoT2Zmc2V0ID0gcmVuZGVyT3B0aW9ucy5saW5lRGFzaE9mZnNldDtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgfVxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGNoZWNrc3VtLlxuICAgKi9cbiAgUmVndWxhclNoYXBlLnByb3RvdHlwZS5nZXRDaGVja3N1bSA9IGZ1bmN0aW9uIGdldENoZWNrc3VtICgpIHtcbiAgICB2YXIgc3Ryb2tlQ2hlY2tzdW0gPSB0aGlzLnN0cm9rZV8gP1xuICAgICAgdGhpcy5zdHJva2VfLmdldENoZWNrc3VtKCkgOiAnLSc7XG4gICAgdmFyIGZpbGxDaGVja3N1bSA9IHRoaXMuZmlsbF8gP1xuICAgICAgdGhpcy5maWxsXy5nZXRDaGVja3N1bSgpIDogJy0nO1xuXG4gICAgdmFyIHJlY2FsY3VsYXRlID0gIXRoaXMuY2hlY2tzdW1zXyB8fFxuICAgICAgICAoc3Ryb2tlQ2hlY2tzdW0gIT0gdGhpcy5jaGVja3N1bXNfWzFdIHx8XG4gICAgICAgIGZpbGxDaGVja3N1bSAhPSB0aGlzLmNoZWNrc3Vtc19bMl0gfHxcbiAgICAgICAgdGhpcy5yYWRpdXNfICE9IHRoaXMuY2hlY2tzdW1zX1szXSB8fFxuICAgICAgICB0aGlzLnJhZGl1czJfICE9IHRoaXMuY2hlY2tzdW1zX1s0XSB8fFxuICAgICAgICB0aGlzLmFuZ2xlXyAhPSB0aGlzLmNoZWNrc3Vtc19bNV0gfHxcbiAgICAgICAgdGhpcy5wb2ludHNfICE9IHRoaXMuY2hlY2tzdW1zX1s2XSk7XG5cbiAgICBpZiAocmVjYWxjdWxhdGUpIHtcbiAgICAgIHZhciBjaGVja3N1bSA9ICdyJyArIHN0cm9rZUNoZWNrc3VtICsgZmlsbENoZWNrc3VtICtcbiAgICAgICAgICAodGhpcy5yYWRpdXNfICE9PSB1bmRlZmluZWQgPyB0aGlzLnJhZGl1c18udG9TdHJpbmcoKSA6ICctJykgK1xuICAgICAgICAgICh0aGlzLnJhZGl1czJfICE9PSB1bmRlZmluZWQgPyB0aGlzLnJhZGl1czJfLnRvU3RyaW5nKCkgOiAnLScpICtcbiAgICAgICAgICAodGhpcy5hbmdsZV8gIT09IHVuZGVmaW5lZCA/IHRoaXMuYW5nbGVfLnRvU3RyaW5nKCkgOiAnLScpICtcbiAgICAgICAgICAodGhpcy5wb2ludHNfICE9PSB1bmRlZmluZWQgPyB0aGlzLnBvaW50c18udG9TdHJpbmcoKSA6ICctJyk7XG4gICAgICB0aGlzLmNoZWNrc3Vtc18gPSBbY2hlY2tzdW0sIHN0cm9rZUNoZWNrc3VtLCBmaWxsQ2hlY2tzdW0sXG4gICAgICAgIHRoaXMucmFkaXVzXywgdGhpcy5yYWRpdXMyXywgdGhpcy5hbmdsZV8sIHRoaXMucG9pbnRzX107XG4gICAgfVxuXG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAodGhpcy5jaGVja3N1bXNfWzBdKTtcbiAgfTtcblxuICByZXR1cm4gUmVndWxhclNoYXBlO1xufShJbWFnZVN0eWxlKSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgUmVndWxhclNoYXBlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWd1bGFyU2hhcGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3N0eWxlL1N0cm9rZVxuICovXG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfGltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9IFtjb2xvcl0gQSBjb2xvciwgZ3JhZGllbnQgb3IgcGF0dGVybi5cbiAqIFNlZSB7QGxpbmsgbW9kdWxlOm9sL2NvbG9yfkNvbG9yfSBhbmQge0BsaW5rIG1vZHVsZTpvbC9jb2xvcmxpa2V+Q29sb3JMaWtlfSBmb3IgcG9zc2libGUgZm9ybWF0cy5cbiAqIERlZmF1bHQgbnVsbDsgaWYgbnVsbCwgdGhlIENhbnZhcy9yZW5kZXJlciBkZWZhdWx0IGJsYWNrIHdpbGwgYmUgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbGluZUNhcD0ncm91bmQnXSBMaW5lIGNhcCBzdHlsZTogYGJ1dHRgLCBgcm91bmRgLCBvciBgc3F1YXJlYC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbGluZUpvaW49J3JvdW5kJ10gTGluZSBqb2luIHN0eWxlOiBgYmV2ZWxgLCBgcm91bmRgLCBvciBgbWl0ZXJgLlxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBbbGluZURhc2hdIExpbmUgZGFzaCBwYXR0ZXJuLiBEZWZhdWx0IGlzIGB1bmRlZmluZWRgIChubyBkYXNoKS5cbiAqIFBsZWFzZSBub3RlIHRoYXQgSW50ZXJuZXQgRXhwbG9yZXIgMTAgYW5kIGxvd2VyIGRvIG5vdCBzdXBwb3J0IHRoZSBgc2V0TGluZURhc2hgIG1ldGhvZCBvblxuICogdGhlIGBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRgIGFuZCB0aGVyZWZvcmUgdGhpcyBvcHRpb24gd2lsbCBoYXZlIG5vIHZpc3VhbCBlZmZlY3QgaW4gdGhlc2UgYnJvd3NlcnMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2xpbmVEYXNoT2Zmc2V0PTBdIExpbmUgZGFzaCBvZmZzZXQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pdGVyTGltaXQ9MTBdIE1pdGVyIGxpbWl0LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt3aWR0aF0gV2lkdGguXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFNldCBzdHJva2Ugc3R5bGUgZm9yIHZlY3RvciBmZWF0dXJlcy5cbiAqIE5vdGUgdGhhdCB0aGUgZGVmYXVsdHMgZ2l2ZW4gYXJlIHRoZSBDYW52YXMgZGVmYXVsdHMsIHdoaWNoIHdpbGwgYmUgdXNlZCBpZlxuICogb3B0aW9uIGlzIG5vdCBkZWZpbmVkLiBUaGUgYGdldGAgZnVuY3Rpb25zIHJldHVybiB3aGF0ZXZlciB3YXMgZW50ZXJlZCBpblxuICogdGhlIG9wdGlvbnM7IHRoZXkgd2lsbCBub3QgcmV0dXJuIHRoZSBkZWZhdWx0LlxuICogQGFwaVxuICovXG52YXIgU3Ryb2tlID0gZnVuY3Rpb24gU3Ryb2tlKG9wdF9vcHRpb25zKSB7XG5cbiAgdmFyIG9wdGlvbnMgPSBvcHRfb3B0aW9ucyB8fCB7fTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfGltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9XG4gICAqL1xuICB0aGlzLmNvbG9yXyA9IG9wdGlvbnMuY29sb3IgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY29sb3IgOiBudWxsO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7c3RyaW5nfHVuZGVmaW5lZH1cbiAgICovXG4gIHRoaXMubGluZUNhcF8gPSBvcHRpb25zLmxpbmVDYXA7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgKi9cbiAgdGhpcy5saW5lRGFzaF8gPSBvcHRpb25zLmxpbmVEYXNoICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmxpbmVEYXNoIDogbnVsbDtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAqL1xuICB0aGlzLmxpbmVEYXNoT2Zmc2V0XyA9IG9wdGlvbnMubGluZURhc2hPZmZzZXQ7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtzdHJpbmd8dW5kZWZpbmVkfVxuICAgKi9cbiAgdGhpcy5saW5lSm9pbl8gPSBvcHRpb25zLmxpbmVKb2luO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICovXG4gIHRoaXMubWl0ZXJMaW1pdF8gPSBvcHRpb25zLm1pdGVyTGltaXQ7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgKi9cbiAgdGhpcy53aWR0aF8gPSBvcHRpb25zLndpZHRoO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7c3RyaW5nfHVuZGVmaW5lZH1cbiAgICovXG4gIHRoaXMuY2hlY2tzdW1fID0gdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBDbG9uZXMgdGhlIHN0eWxlLlxuICogQHJldHVybiB7U3Ryb2tlfSBUaGUgY2xvbmVkIHN0eWxlLlxuICogQGFwaVxuICovXG5TdHJva2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuICB2YXIgY29sb3IgPSB0aGlzLmdldENvbG9yKCk7XG4gIHJldHVybiBuZXcgU3Ryb2tlKHtcbiAgICBjb2xvcjogQXJyYXkuaXNBcnJheShjb2xvcikgPyBjb2xvci5zbGljZSgpIDogY29sb3IgfHwgdW5kZWZpbmVkLFxuICAgIGxpbmVDYXA6IHRoaXMuZ2V0TGluZUNhcCgpLFxuICAgIGxpbmVEYXNoOiB0aGlzLmdldExpbmVEYXNoKCkgPyB0aGlzLmdldExpbmVEYXNoKCkuc2xpY2UoKSA6IHVuZGVmaW5lZCxcbiAgICBsaW5lRGFzaE9mZnNldDogdGhpcy5nZXRMaW5lRGFzaE9mZnNldCgpLFxuICAgIGxpbmVKb2luOiB0aGlzLmdldExpbmVKb2luKCksXG4gICAgbWl0ZXJMaW1pdDogdGhpcy5nZXRNaXRlckxpbWl0KCksXG4gICAgd2lkdGg6IHRoaXMuZ2V0V2lkdGgoKVxuICB9KTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBzdHJva2UgY29sb3IuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcnxpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfSBDb2xvci5cbiAqIEBhcGlcbiAqL1xuU3Ryb2tlLnByb3RvdHlwZS5nZXRDb2xvciA9IGZ1bmN0aW9uIGdldENvbG9yICgpIHtcbiAgcmV0dXJuIHRoaXMuY29sb3JfO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGxpbmUgY2FwIHR5cGUgZm9yIHRoZSBzdHJva2UuXG4gKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfSBMaW5lIGNhcC5cbiAqIEBhcGlcbiAqL1xuU3Ryb2tlLnByb3RvdHlwZS5nZXRMaW5lQ2FwID0gZnVuY3Rpb24gZ2V0TGluZUNhcCAoKSB7XG4gIHJldHVybiB0aGlzLmxpbmVDYXBfO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGxpbmUgZGFzaCBzdHlsZSBmb3IgdGhlIHN0cm9rZS5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IExpbmUgZGFzaC5cbiAqIEBhcGlcbiAqL1xuU3Ryb2tlLnByb3RvdHlwZS5nZXRMaW5lRGFzaCA9IGZ1bmN0aW9uIGdldExpbmVEYXNoICgpIHtcbiAgcmV0dXJuIHRoaXMubGluZURhc2hfO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGxpbmUgZGFzaCBvZmZzZXQgZm9yIHRoZSBzdHJva2UuXG4gKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBMaW5lIGRhc2ggb2Zmc2V0LlxuICogQGFwaVxuICovXG5TdHJva2UucHJvdG90eXBlLmdldExpbmVEYXNoT2Zmc2V0ID0gZnVuY3Rpb24gZ2V0TGluZURhc2hPZmZzZXQgKCkge1xuICByZXR1cm4gdGhpcy5saW5lRGFzaE9mZnNldF87XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbGluZSBqb2luIHR5cGUgZm9yIHRoZSBzdHJva2UuXG4gKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfSBMaW5lIGpvaW4uXG4gKiBAYXBpXG4gKi9cblN0cm9rZS5wcm90b3R5cGUuZ2V0TGluZUpvaW4gPSBmdW5jdGlvbiBnZXRMaW5lSm9pbiAoKSB7XG4gIHJldHVybiB0aGlzLmxpbmVKb2luXztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBtaXRlciBsaW1pdCBmb3IgdGhlIHN0cm9rZS5cbiAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IE1pdGVyIGxpbWl0LlxuICogQGFwaVxuICovXG5TdHJva2UucHJvdG90eXBlLmdldE1pdGVyTGltaXQgPSBmdW5jdGlvbiBnZXRNaXRlckxpbWl0ICgpIHtcbiAgcmV0dXJuIHRoaXMubWl0ZXJMaW1pdF87XG59O1xuXG4vKipcbiAqIEdldCB0aGUgc3Ryb2tlIHdpZHRoLlxuICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gV2lkdGguXG4gKiBAYXBpXG4gKi9cblN0cm9rZS5wcm90b3R5cGUuZ2V0V2lkdGggPSBmdW5jdGlvbiBnZXRXaWR0aCAoKSB7XG4gIHJldHVybiB0aGlzLndpZHRoXztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb2xvci5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfGltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9IGNvbG9yIENvbG9yLlxuICogQGFwaVxuICovXG5TdHJva2UucHJvdG90eXBlLnNldENvbG9yID0gZnVuY3Rpb24gc2V0Q29sb3IgKGNvbG9yKSB7XG4gIHRoaXMuY29sb3JfID0gY29sb3I7XG4gIHRoaXMuY2hlY2tzdW1fID0gdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGxpbmUgY2FwLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gbGluZUNhcCBMaW5lIGNhcC5cbiAqIEBhcGlcbiAqL1xuU3Ryb2tlLnByb3RvdHlwZS5zZXRMaW5lQ2FwID0gZnVuY3Rpb24gc2V0TGluZUNhcCAobGluZUNhcCkge1xuICB0aGlzLmxpbmVDYXBfID0gbGluZUNhcDtcbiAgdGhpcy5jaGVja3N1bV8gPSB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbGluZSBkYXNoLlxuICpcbiAqIFBsZWFzZSBub3RlIHRoYXQgSW50ZXJuZXQgRXhwbG9yZXIgMTAgYW5kIGxvd2VyIFtkbyBub3Qgc3VwcG9ydF1bbWRuXSB0aGVcbiAqIGBzZXRMaW5lRGFzaGAgbWV0aG9kIG9uIHRoZSBgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEYCBhbmQgdGhlcmVmb3JlIHRoaXNcbiAqIHByb3BlcnR5IHdpbGwgaGF2ZSBubyB2aXN1YWwgZWZmZWN0IGluIHRoZXNlIGJyb3dzZXJzLlxuICpcbiAqIFttZG5dOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3NldExpbmVEYXNoI0Jyb3dzZXJfY29tcGF0aWJpbGl0eVxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gbGluZURhc2ggTGluZSBkYXNoLlxuICogQGFwaVxuICovXG5TdHJva2UucHJvdG90eXBlLnNldExpbmVEYXNoID0gZnVuY3Rpb24gc2V0TGluZURhc2ggKGxpbmVEYXNoKSB7XG4gIHRoaXMubGluZURhc2hfID0gbGluZURhc2g7XG4gIHRoaXMuY2hlY2tzdW1fID0gdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGxpbmUgZGFzaCBvZmZzZXQuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSBsaW5lRGFzaE9mZnNldCBMaW5lIGRhc2ggb2Zmc2V0LlxuICogQGFwaVxuICovXG5TdHJva2UucHJvdG90eXBlLnNldExpbmVEYXNoT2Zmc2V0ID0gZnVuY3Rpb24gc2V0TGluZURhc2hPZmZzZXQgKGxpbmVEYXNoT2Zmc2V0KSB7XG4gIHRoaXMubGluZURhc2hPZmZzZXRfID0gbGluZURhc2hPZmZzZXQ7XG4gIHRoaXMuY2hlY2tzdW1fID0gdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGxpbmUgam9pbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IGxpbmVKb2luIExpbmUgam9pbi5cbiAqIEBhcGlcbiAqL1xuU3Ryb2tlLnByb3RvdHlwZS5zZXRMaW5lSm9pbiA9IGZ1bmN0aW9uIHNldExpbmVKb2luIChsaW5lSm9pbikge1xuICB0aGlzLmxpbmVKb2luXyA9IGxpbmVKb2luO1xuICB0aGlzLmNoZWNrc3VtXyA9IHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtaXRlciBsaW1pdC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IG1pdGVyTGltaXQgTWl0ZXIgbGltaXQuXG4gKiBAYXBpXG4gKi9cblN0cm9rZS5wcm90b3R5cGUuc2V0TWl0ZXJMaW1pdCA9IGZ1bmN0aW9uIHNldE1pdGVyTGltaXQgKG1pdGVyTGltaXQpIHtcbiAgdGhpcy5taXRlckxpbWl0XyA9IG1pdGVyTGltaXQ7XG4gIHRoaXMuY2hlY2tzdW1fID0gdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHdpZHRoLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gd2lkdGggV2lkdGguXG4gKiBAYXBpXG4gKi9cblN0cm9rZS5wcm90b3R5cGUuc2V0V2lkdGggPSBmdW5jdGlvbiBzZXRXaWR0aCAod2lkdGgpIHtcbiAgdGhpcy53aWR0aF8gPSB3aWR0aDtcbiAgdGhpcy5jaGVja3N1bV8gPSB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGNoZWNrc3VtLlxuICovXG5TdHJva2UucHJvdG90eXBlLmdldENoZWNrc3VtID0gZnVuY3Rpb24gZ2V0Q2hlY2tzdW0gKCkge1xuICBpZiAodGhpcy5jaGVja3N1bV8gPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuY2hlY2tzdW1fID0gJ3MnO1xuICAgIGlmICh0aGlzLmNvbG9yXykge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLmNvbG9yXyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5jaGVja3N1bV8gKz0gdGhpcy5jb2xvcl87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNoZWNrc3VtXyArPSBnZXRVaWQodGhpcy5jb2xvcl8pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNoZWNrc3VtXyArPSAnLSc7XG4gICAgfVxuICAgIHRoaXMuY2hlY2tzdW1fICs9ICcsJyArXG4gICAgICAgICh0aGlzLmxpbmVDYXBfICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgIHRoaXMubGluZUNhcF8udG9TdHJpbmcoKSA6ICctJykgKyAnLCcgK1xuICAgICAgICAodGhpcy5saW5lRGFzaF8gP1xuICAgICAgICAgIHRoaXMubGluZURhc2hfLnRvU3RyaW5nKCkgOiAnLScpICsgJywnICtcbiAgICAgICAgKHRoaXMubGluZURhc2hPZmZzZXRfICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgIHRoaXMubGluZURhc2hPZmZzZXRfIDogJy0nKSArICcsJyArXG4gICAgICAgICh0aGlzLmxpbmVKb2luXyAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICB0aGlzLmxpbmVKb2luXyA6ICctJykgKyAnLCcgK1xuICAgICAgICAodGhpcy5taXRlckxpbWl0XyAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICB0aGlzLm1pdGVyTGltaXRfLnRvU3RyaW5nKCkgOiAnLScpICsgJywnICtcbiAgICAgICAgKHRoaXMud2lkdGhfICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgIHRoaXMud2lkdGhfLnRvU3RyaW5nKCkgOiAnLScpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuY2hlY2tzdW1fO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgU3Ryb2tlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdHJva2UuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3N0eWxlL1N0eWxlXG4gKi9cblxuLyoqXG4gKiBGZWF0dXJlIHN0eWxlcy5cbiAqXG4gKiBJZiBubyBzdHlsZSBpcyBkZWZpbmVkLCB0aGUgZm9sbG93aW5nIGRlZmF1bHQgc3R5bGUgaXMgdXNlZDpcbiAqIGBgYGpzXG4gKiAgaW1wb3J0IHtGaWxsLCBTdHJva2UsIENpcmNsZSwgU3R5bGV9IGZyb20gJ29sL3N0eWxlJztcbiAqXG4gKiAgdmFyIGZpbGwgPSBuZXcgRmlsbCh7XG4gKiAgICBjb2xvcjogJ3JnYmEoMjU1LDI1NSwyNTUsMC40KSdcbiAqICB9KTtcbiAqICB2YXIgc3Ryb2tlID0gbmV3IFN0cm9rZSh7XG4gKiAgICBjb2xvcjogJyMzMzk5Q0MnLFxuICogICAgd2lkdGg6IDEuMjVcbiAqICB9KTtcbiAqICB2YXIgc3R5bGVzID0gW1xuICogICAgbmV3IFN0eWxlKHtcbiAqICAgICAgaW1hZ2U6IG5ldyBDaXJjbGUoe1xuICogICAgICAgIGZpbGw6IGZpbGwsXG4gKiAgICAgICAgc3Ryb2tlOiBzdHJva2UsXG4gKiAgICAgICAgcmFkaXVzOiA1XG4gKiAgICAgIH0pLFxuICogICAgICBmaWxsOiBmaWxsLFxuICogICAgICBzdHJva2U6IHN0cm9rZVxuICogICAgfSlcbiAqICBdO1xuICogYGBgXG4gKlxuICogQSBzZXBhcmF0ZSBlZGl0aW5nIHN0eWxlIGhhcyB0aGUgZm9sbG93aW5nIGRlZmF1bHRzOlxuICogYGBganNcbiAqICBpbXBvcnQge0ZpbGwsIFN0cm9rZSwgQ2lyY2xlLCBTdHlsZX0gZnJvbSAnb2wvc3R5bGUnO1xuICogIGltcG9ydCBHZW9tZXRyeVR5cGUgZnJvbSAnb2wvZ2VvbS9HZW9tZXRyeVR5cGUnO1xuICpcbiAqICB2YXIgd2hpdGUgPSBbMjU1LCAyNTUsIDI1NSwgMV07XG4gKiAgdmFyIGJsdWUgPSBbMCwgMTUzLCAyNTUsIDFdO1xuICogIHZhciB3aWR0aCA9IDM7XG4gKiAgc3R5bGVzW0dlb21ldHJ5VHlwZS5QT0xZR09OXSA9IFtcbiAqICAgIG5ldyBTdHlsZSh7XG4gKiAgICAgIGZpbGw6IG5ldyBGaWxsKHtcbiAqICAgICAgICBjb2xvcjogWzI1NSwgMjU1LCAyNTUsIDAuNV1cbiAqICAgICAgfSlcbiAqICAgIH0pXG4gKiAgXTtcbiAqICBzdHlsZXNbR2VvbWV0cnlUeXBlLk1VTFRJX1BPTFlHT05dID1cbiAqICAgICAgc3R5bGVzW0dlb21ldHJ5VHlwZS5QT0xZR09OXTtcbiAqICBzdHlsZXNbR2VvbWV0cnlUeXBlLkxJTkVfU1RSSU5HXSA9IFtcbiAqICAgIG5ldyBTdHlsZSh7XG4gKiAgICAgIHN0cm9rZTogbmV3IFN0cm9rZSh7XG4gKiAgICAgICAgY29sb3I6IHdoaXRlLFxuICogICAgICAgIHdpZHRoOiB3aWR0aCArIDJcbiAqICAgICAgfSlcbiAqICAgIH0pLFxuICogICAgbmV3IFN0eWxlKHtcbiAqICAgICAgc3Ryb2tlOiBuZXcgU3Ryb2tlKHtcbiAqICAgICAgICBjb2xvcjogYmx1ZSxcbiAqICAgICAgICB3aWR0aDogd2lkdGhcbiAqICAgICAgfSlcbiAqICAgIH0pXG4gKiAgXTtcbiAqICBzdHlsZXNbR2VvbWV0cnlUeXBlLk1VTFRJX0xJTkVfU1RSSU5HXSA9XG4gKiAgICAgIHN0eWxlc1tHZW9tZXRyeVR5cGUuTElORV9TVFJJTkddO1xuICogIHN0eWxlc1tHZW9tZXRyeVR5cGUuUE9JTlRdID0gW1xuICogICAgbmV3IFN0eWxlKHtcbiAqICAgICAgaW1hZ2U6IG5ldyBDaXJjbGUoe1xuICogICAgICAgIHJhZGl1czogd2lkdGggKiAyLFxuICogICAgICAgIGZpbGw6IG5ldyBGaWxsKHtcbiAqICAgICAgICAgIGNvbG9yOiBibHVlXG4gKiAgICAgICAgfSksXG4gKiAgICAgICAgc3Ryb2tlOiBuZXcgU3Ryb2tlKHtcbiAqICAgICAgICAgIGNvbG9yOiB3aGl0ZSxcbiAqICAgICAgICAgIHdpZHRoOiB3aWR0aCAvIDJcbiAqICAgICAgICB9KVxuICogICAgICB9KSxcbiAqICAgICAgekluZGV4OiBJbmZpbml0eVxuICogICAgfSlcbiAqICBdO1xuICogIHN0eWxlc1tHZW9tZXRyeVR5cGUuTVVMVElfUE9JTlRdID1cbiAqICAgICAgc3R5bGVzW0dlb21ldHJ5VHlwZS5QT0lOVF07XG4gKiAgc3R5bGVzW0dlb21ldHJ5VHlwZS5HRU9NRVRSWV9DT0xMRUNUSU9OXSA9XG4gKiAgICAgIHN0eWxlc1tHZW9tZXRyeVR5cGUuUE9MWUdPTl0uY29uY2F0KFxuICogICAgICAgICAgc3R5bGVzW0dlb21ldHJ5VHlwZS5MSU5FX1NUUklOR10sXG4gKiAgICAgICAgICBzdHlsZXNbR2VvbWV0cnlUeXBlLlBPSU5UXVxuICogICAgICApO1xuICogYGBgXG4gKi9cbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuLi9hc3NlcnRzLmpzJztcbmltcG9ydCBHZW9tZXRyeVR5cGUgZnJvbSAnLi4vZ2VvbS9HZW9tZXRyeVR5cGUuanMnO1xuaW1wb3J0IENpcmNsZVN0eWxlIGZyb20gJy4vQ2lyY2xlLmpzJztcbmltcG9ydCBGaWxsIGZyb20gJy4vRmlsbC5qcyc7XG5pbXBvcnQgU3Ryb2tlIGZyb20gJy4vU3Ryb2tlLmpzJztcblxuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL0ZlYXR1cmV9IGFuZCBhIGB7bnVtYmVyfWBcbiAqIHJlcHJlc2VudGluZyB0aGUgdmlldydzIHJlc29sdXRpb24uIFRoZSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGFcbiAqIHtAbGluayBtb2R1bGU6b2wvc3R5bGUvU3R5bGV9IG9yIGFuIGFycmF5IG9mIHRoZW0uIFRoaXMgd2F5IGUuZy4gYVxuICogdmVjdG9yIGxheWVyIGNhbiBiZSBzdHlsZWQuXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2UsIG51bWJlcik6KFN0eWxlfEFycmF5PFN0eWxlPil9IFN0eWxlRnVuY3Rpb25cbiAqL1xuXG4vKipcbiAqIEEge0BsaW5rIFN0eWxlfSwgYW4gYXJyYXkgb2Yge0BsaW5rIFN0eWxlfSwgb3IgYSB7QGxpbmsgU3R5bGVGdW5jdGlvbn0uXG4gKiBAdHlwZWRlZiB7U3R5bGV8QXJyYXk8U3R5bGU+fFN0eWxlRnVuY3Rpb259IFN0eWxlTGlrZVxuICovXG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvRmVhdHVyZX0gYXMgYXJndW1lbnQgYW5kIHJldHVybnMgYW5cbiAqIHtAbGluayBtb2R1bGU6b2wvZ2VvbS9HZW9tZXRyeX0gdGhhdCB3aWxsIGJlIHJlbmRlcmVkIGFuZCBzdHlsZWQgZm9yIHRoZSBmZWF0dXJlLlxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlKTpcbiAqICAgICAoaW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL3JlbmRlci9GZWF0dXJlLmpzXCIpLmRlZmF1bHR8dW5kZWZpbmVkKX0gR2VvbWV0cnlGdW5jdGlvblxuICovXG5cblxuLyoqXG4gKiBDdXN0b20gcmVuZGVyZXIgZnVuY3Rpb24uIFRha2VzIHR3byBhcmd1bWVudHM6XG4gKlxuICogMS4gVGhlIHBpeGVsIGNvb3JkaW5hdGVzIG9mIHRoZSBnZW9tZXRyeSBpbiBHZW9KU09OIG5vdGF0aW9uLlxuICogMi4gVGhlIHtAbGluayBtb2R1bGU6b2wvcmVuZGVyflN0YXRlfSBvZiB0aGUgbGF5ZXIgcmVuZGVyZXIuXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKChpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPnxBcnJheTxBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+PiksaW1wb3J0KFwiLi4vcmVuZGVyLmpzXCIpLlN0YXRlKX1cbiAqIFJlbmRlckZ1bmN0aW9uXG4gKi9cblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfGltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdHxHZW9tZXRyeUZ1bmN0aW9ufSBbZ2VvbWV0cnldIEZlYXR1cmUgcHJvcGVydHkgb3IgZ2VvbWV0cnlcbiAqIG9yIGZ1bmN0aW9uIHJldHVybmluZyBhIGdlb21ldHJ5IHRvIHJlbmRlciBmb3IgdGhpcyBzdHlsZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9GaWxsLmpzXCIpLmRlZmF1bHR9IFtmaWxsXSBGaWxsIHN0eWxlLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL0ltYWdlLmpzXCIpLmRlZmF1bHR9IFtpbWFnZV0gSW1hZ2Ugc3R5bGUuXG4gKiBAcHJvcGVydHkge1JlbmRlckZ1bmN0aW9ufSBbcmVuZGVyZXJdIEN1c3RvbSByZW5kZXJlci4gV2hlbiBjb25maWd1cmVkLCBgZmlsbGAsIGBzdHJva2VgIGFuZCBgaW1hZ2VgIHdpbGwgYmVcbiAqIGlnbm9yZWQsIGFuZCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2l0aCBlYWNoIHJlbmRlciBmcmFtZSBmb3IgZWFjaCBnZW9tZXRyeS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdH0gW3N0cm9rZV0gU3Ryb2tlIHN0eWxlLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL1RleHQuanNcIikuZGVmYXVsdH0gW3RleHRdIFRleHQgc3R5bGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3pJbmRleF0gWiBpbmRleC5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIENvbnRhaW5lciBmb3IgdmVjdG9yIGZlYXR1cmUgcmVuZGVyaW5nIHN0eWxlcy4gQW55IGNoYW5nZXMgbWFkZSB0byB0aGUgc3R5bGVcbiAqIG9yIGl0cyBjaGlsZHJlbiB0aHJvdWdoIGBzZXQqKClgIG1ldGhvZHMgd2lsbCBub3QgdGFrZSBlZmZlY3QgdW50aWwgdGhlXG4gKiBmZWF0dXJlIG9yIGxheWVyIHRoYXQgdXNlcyB0aGUgc3R5bGUgaXMgcmUtcmVuZGVyZWQuXG4gKiBAYXBpXG4gKi9cbnZhciBTdHlsZSA9IGZ1bmN0aW9uIFN0eWxlKG9wdF9vcHRpb25zKSB7XG5cbiAgdmFyIG9wdGlvbnMgPSBvcHRfb3B0aW9ucyB8fCB7fTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge3N0cmluZ3xpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR8R2VvbWV0cnlGdW5jdGlvbn1cbiAgICovXG4gIHRoaXMuZ2VvbWV0cnlfID0gbnVsbDtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUgeyFHZW9tZXRyeUZ1bmN0aW9ufVxuICAgKi9cbiAgdGhpcy5nZW9tZXRyeUZ1bmN0aW9uXyA9IGRlZmF1bHRHZW9tZXRyeUZ1bmN0aW9uO1xuXG4gIGlmIChvcHRpb25zLmdlb21ldHJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnNldEdlb21ldHJ5KG9wdGlvbnMuZ2VvbWV0cnkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtpbXBvcnQoXCIuL0ZpbGwuanNcIikuZGVmYXVsdH1cbiAgICovXG4gIHRoaXMuZmlsbF8gPSBvcHRpb25zLmZpbGwgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZmlsbCA6IG51bGw7XG5cbiAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9JbWFnZS5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICB0aGlzLmltYWdlXyA9IG9wdGlvbnMuaW1hZ2UgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuaW1hZ2UgOiBudWxsO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7UmVuZGVyRnVuY3Rpb258bnVsbH1cbiAgICovXG4gIHRoaXMucmVuZGVyZXJfID0gb3B0aW9ucy5yZW5kZXJlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5yZW5kZXJlciA6IG51bGw7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtpbXBvcnQoXCIuL1N0cm9rZS5qc1wiKS5kZWZhdWx0fVxuICAgKi9cbiAgdGhpcy5zdHJva2VfID0gb3B0aW9ucy5zdHJva2UgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc3Ryb2tlIDogbnVsbDtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge2ltcG9ydChcIi4vVGV4dC5qc1wiKS5kZWZhdWx0fVxuICAgKi9cbiAgdGhpcy50ZXh0XyA9IG9wdGlvbnMudGV4dCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy50ZXh0IDogbnVsbDtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAqL1xuICB0aGlzLnpJbmRleF8gPSBvcHRpb25zLnpJbmRleDtcblxufTtcblxuLyoqXG4gKiBDbG9uZXMgdGhlIHN0eWxlLlxuICogQHJldHVybiB7U3R5bGV9IFRoZSBjbG9uZWQgc3R5bGUuXG4gKiBAYXBpXG4gKi9cblN0eWxlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgdmFyIGdlb21ldHJ5ID0gdGhpcy5nZXRHZW9tZXRyeSgpO1xuICBpZiAoZ2VvbWV0cnkgJiYgdHlwZW9mIGdlb21ldHJ5ID09PSAnb2JqZWN0Jykge1xuICAgIGdlb21ldHJ5ID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9ICovIChnZW9tZXRyeSkuY2xvbmUoKTtcbiAgfVxuICByZXR1cm4gbmV3IFN0eWxlKHtcbiAgICBnZW9tZXRyeTogZ2VvbWV0cnksXG4gICAgZmlsbDogdGhpcy5nZXRGaWxsKCkgPyB0aGlzLmdldEZpbGwoKS5jbG9uZSgpIDogdW5kZWZpbmVkLFxuICAgIGltYWdlOiB0aGlzLmdldEltYWdlKCkgPyB0aGlzLmdldEltYWdlKCkuY2xvbmUoKSA6IHVuZGVmaW5lZCxcbiAgICBzdHJva2U6IHRoaXMuZ2V0U3Ryb2tlKCkgPyB0aGlzLmdldFN0cm9rZSgpLmNsb25lKCkgOiB1bmRlZmluZWQsXG4gICAgdGV4dDogdGhpcy5nZXRUZXh0KCkgPyB0aGlzLmdldFRleHQoKS5jbG9uZSgpIDogdW5kZWZpbmVkLFxuICAgIHpJbmRleDogdGhpcy5nZXRaSW5kZXgoKVxuICB9KTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjdXN0b20gcmVuZGVyZXIgZnVuY3Rpb24gdGhhdCB3YXMgY29uZmlndXJlZCB3aXRoXG4gKiB7QGxpbmsgI3NldFJlbmRlcmVyfSBvciB0aGUgYHJlbmRlcmVyYCBjb25zdHJ1Y3RvciBvcHRpb24uXG4gKiBAcmV0dXJuIHtSZW5kZXJGdW5jdGlvbnxudWxsfSBDdXN0b20gcmVuZGVyZXIgZnVuY3Rpb24uXG4gKiBAYXBpXG4gKi9cblN0eWxlLnByb3RvdHlwZS5nZXRSZW5kZXJlciA9IGZ1bmN0aW9uIGdldFJlbmRlcmVyICgpIHtcbiAgcmV0dXJuIHRoaXMucmVuZGVyZXJfO1xufTtcblxuLyoqXG4gKiBTZXRzIGEgY3VzdG9tIHJlbmRlcmVyIGZ1bmN0aW9uIGZvciB0aGlzIHN0eWxlLiBXaGVuIHNldCwgYGZpbGxgLCBgc3Ryb2tlYFxuICogYW5kIGBpbWFnZWAgb3B0aW9ucyBvZiB0aGUgc3R5bGUgd2lsbCBiZSBpZ25vcmVkLlxuICogQHBhcmFtIHtSZW5kZXJGdW5jdGlvbnxudWxsfSByZW5kZXJlciBDdXN0b20gcmVuZGVyZXIgZnVuY3Rpb24uXG4gKiBAYXBpXG4gKi9cblN0eWxlLnByb3RvdHlwZS5zZXRSZW5kZXJlciA9IGZ1bmN0aW9uIHNldFJlbmRlcmVyIChyZW5kZXJlcikge1xuICB0aGlzLnJlbmRlcmVyXyA9IHJlbmRlcmVyO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGdlb21ldHJ5IHRvIGJlIHJlbmRlcmVkLlxuICogQHJldHVybiB7c3RyaW5nfGltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdHxHZW9tZXRyeUZ1bmN0aW9ufVxuICogRmVhdHVyZSBwcm9wZXJ0eSBvciBnZW9tZXRyeSBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGdlb21ldHJ5IHRoYXQgd2lsbFxuICogYmUgcmVuZGVyZWQgd2l0aCB0aGlzIHN0eWxlLlxuICogQGFwaVxuICovXG5TdHlsZS5wcm90b3R5cGUuZ2V0R2VvbWV0cnkgPSBmdW5jdGlvbiBnZXRHZW9tZXRyeSAoKSB7XG4gIHJldHVybiB0aGlzLmdlb21ldHJ5Xztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIGEgZ2VvbWV0cnkgZm9yIHJlbmRlcmluZy5cbiAqIEByZXR1cm4geyFHZW9tZXRyeUZ1bmN0aW9ufSBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIGEgZmVhdHVyZVxuICogYW5kIHJldHVybnMgdGhlIGdlb21ldHJ5IHRvIHJlbmRlciBpbnN0ZWFkIG9mIHRoZSBmZWF0dXJlJ3MgZ2VvbWV0cnkuXG4gKiBAYXBpXG4gKi9cblN0eWxlLnByb3RvdHlwZS5nZXRHZW9tZXRyeUZ1bmN0aW9uID0gZnVuY3Rpb24gZ2V0R2VvbWV0cnlGdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdlb21ldHJ5RnVuY3Rpb25fO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGZpbGwgc3R5bGUuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL0ZpbGwuanNcIikuZGVmYXVsdH0gRmlsbCBzdHlsZS5cbiAqIEBhcGlcbiAqL1xuU3R5bGUucHJvdG90eXBlLmdldEZpbGwgPSBmdW5jdGlvbiBnZXRGaWxsICgpIHtcbiAgcmV0dXJuIHRoaXMuZmlsbF87XG59O1xuXG4vKipcbiAqIFNldCB0aGUgZmlsbCBzdHlsZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GaWxsLmpzXCIpLmRlZmF1bHR9IGZpbGwgRmlsbCBzdHlsZS5cbiAqIEBhcGlcbiAqL1xuU3R5bGUucHJvdG90eXBlLnNldEZpbGwgPSBmdW5jdGlvbiBzZXRGaWxsIChmaWxsKSB7XG4gIHRoaXMuZmlsbF8gPSBmaWxsO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGltYWdlIHN0eWxlLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9JbWFnZS5qc1wiKS5kZWZhdWx0fSBJbWFnZSBzdHlsZS5cbiAqIEBhcGlcbiAqL1xuU3R5bGUucHJvdG90eXBlLmdldEltYWdlID0gZnVuY3Rpb24gZ2V0SW1hZ2UgKCkge1xuICByZXR1cm4gdGhpcy5pbWFnZV87XG59O1xuXG4vKipcbiAqIFNldCB0aGUgaW1hZ2Ugc3R5bGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vSW1hZ2UuanNcIikuZGVmYXVsdH0gaW1hZ2UgSW1hZ2Ugc3R5bGUuXG4gKiBAYXBpXG4gKi9cblN0eWxlLnByb3RvdHlwZS5zZXRJbWFnZSA9IGZ1bmN0aW9uIHNldEltYWdlIChpbWFnZSkge1xuICB0aGlzLmltYWdlXyA9IGltYWdlO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHN0cm9rZSBzdHlsZS5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vU3Ryb2tlLmpzXCIpLmRlZmF1bHR9IFN0cm9rZSBzdHlsZS5cbiAqIEBhcGlcbiAqL1xuU3R5bGUucHJvdG90eXBlLmdldFN0cm9rZSA9IGZ1bmN0aW9uIGdldFN0cm9rZSAoKSB7XG4gIHJldHVybiB0aGlzLnN0cm9rZV87XG59O1xuXG4vKipcbiAqIFNldCB0aGUgc3Ryb2tlIHN0eWxlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL1N0cm9rZS5qc1wiKS5kZWZhdWx0fSBzdHJva2UgU3Ryb2tlIHN0eWxlLlxuICogQGFwaVxuICovXG5TdHlsZS5wcm90b3R5cGUuc2V0U3Ryb2tlID0gZnVuY3Rpb24gc2V0U3Ryb2tlIChzdHJva2UpIHtcbiAgdGhpcy5zdHJva2VfID0gc3Ryb2tlO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHRleHQgc3R5bGUuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL1RleHQuanNcIikuZGVmYXVsdH0gVGV4dCBzdHlsZS5cbiAqIEBhcGlcbiAqL1xuU3R5bGUucHJvdG90eXBlLmdldFRleHQgPSBmdW5jdGlvbiBnZXRUZXh0ICgpIHtcbiAgcmV0dXJuIHRoaXMudGV4dF87XG59O1xuXG4vKipcbiAqIFNldCB0aGUgdGV4dCBzdHlsZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9UZXh0LmpzXCIpLmRlZmF1bHR9IHRleHQgVGV4dCBzdHlsZS5cbiAqIEBhcGlcbiAqL1xuU3R5bGUucHJvdG90eXBlLnNldFRleHQgPSBmdW5jdGlvbiBzZXRUZXh0ICh0ZXh0KSB7XG4gIHRoaXMudGV4dF8gPSB0ZXh0O1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHotaW5kZXggZm9yIHRoZSBzdHlsZS5cbiAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFpJbmRleC5cbiAqIEBhcGlcbiAqL1xuU3R5bGUucHJvdG90eXBlLmdldFpJbmRleCA9IGZ1bmN0aW9uIGdldFpJbmRleCAoKSB7XG4gIHJldHVybiB0aGlzLnpJbmRleF87XG59O1xuXG4vKipcbiAqIFNldCBhIGdlb21ldHJ5IHRoYXQgaXMgcmVuZGVyZWQgaW5zdGVhZCBvZiB0aGUgZmVhdHVyZSdzIGdlb21ldHJ5LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfGltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdHxHZW9tZXRyeUZ1bmN0aW9ufSBnZW9tZXRyeVxuICogICBGZWF0dXJlIHByb3BlcnR5IG9yIGdlb21ldHJ5IG9yIGZ1bmN0aW9uIHJldHVybmluZyBhIGdlb21ldHJ5IHRvIHJlbmRlclxuICogICBmb3IgdGhpcyBzdHlsZS5cbiAqIEBhcGlcbiAqL1xuU3R5bGUucHJvdG90eXBlLnNldEdlb21ldHJ5ID0gZnVuY3Rpb24gc2V0R2VvbWV0cnkgKGdlb21ldHJ5KSB7XG4gIGlmICh0eXBlb2YgZ2VvbWV0cnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLmdlb21ldHJ5RnVuY3Rpb25fID0gZ2VvbWV0cnk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGdlb21ldHJ5ID09PSAnc3RyaW5nJykge1xuICAgIHRoaXMuZ2VvbWV0cnlGdW5jdGlvbl8gPSBmdW5jdGlvbihmZWF0dXJlKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gKi8gKGZlYXR1cmUuZ2V0KGdlb21ldHJ5KSlcbiAgICAgICk7XG4gICAgfTtcbiAgfSBlbHNlIGlmICghZ2VvbWV0cnkpIHtcbiAgICB0aGlzLmdlb21ldHJ5RnVuY3Rpb25fID0gZGVmYXVsdEdlb21ldHJ5RnVuY3Rpb247XG4gIH0gZWxzZSBpZiAoZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuZ2VvbWV0cnlGdW5jdGlvbl8gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSAqLyAoZ2VvbWV0cnkpXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgdGhpcy5nZW9tZXRyeV8gPSBnZW9tZXRyeTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSB6LWluZGV4LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gekluZGV4IFpJbmRleC5cbiAqIEBhcGlcbiAqL1xuU3R5bGUucHJvdG90eXBlLnNldFpJbmRleCA9IGZ1bmN0aW9uIHNldFpJbmRleCAoekluZGV4KSB7XG4gIHRoaXMuekluZGV4XyA9IHpJbmRleDtcbn07XG5cblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBwcm92aWRlZCBvYmplY3QgaW50byBhIHN0eWxlIGZ1bmN0aW9uLiAgRnVuY3Rpb25zIHBhc3NlZCB0aHJvdWdoXG4gKiB1bmNoYW5nZWQuICBBcnJheXMgb2YgU3R5bGUgb3Igc2luZ2xlIHN0eWxlIG9iamVjdHMgd3JhcHBlZCBpbiBhXG4gKiBuZXcgc3R5bGUgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge1N0eWxlRnVuY3Rpb258QXJyYXk8U3R5bGU+fFN0eWxlfSBvYmpcbiAqICAgICBBIHN0eWxlIGZ1bmN0aW9uLCBhIHNpbmdsZSBzdHlsZSwgb3IgYW4gYXJyYXkgb2Ygc3R5bGVzLlxuICogQHJldHVybiB7U3R5bGVGdW5jdGlvbn0gQSBzdHlsZSBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvRnVuY3Rpb24ob2JqKSB7XG4gIHZhciBzdHlsZUZ1bmN0aW9uO1xuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc3R5bGVGdW5jdGlvbiA9IG9iajtcbiAgfSBlbHNlIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8U3R5bGU+fVxuICAgICAqL1xuICAgIHZhciBzdHlsZXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgc3R5bGVzID0gb2JqO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQodHlwZW9mIC8qKiBAdHlwZSB7P30gKi8gKG9iaikuZ2V0WkluZGV4ID09PSAnZnVuY3Rpb24nLFxuICAgICAgICA0MSk7IC8vIEV4cGVjdGVkIGFuIGBTdHlsZWAgb3IgYW4gYXJyYXkgb2YgYFN0eWxlYFxuICAgICAgdmFyIHN0eWxlID0gLyoqIEB0eXBlIHtTdHlsZX0gKi8gKG9iaik7XG4gICAgICBzdHlsZXMgPSBbc3R5bGVdO1xuICAgIH1cbiAgICBzdHlsZUZ1bmN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3R5bGVzO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHN0eWxlRnVuY3Rpb247XG59XG5cblxuLyoqXG4gKiBAdHlwZSB7QXJyYXk8U3R5bGU+fVxuICovXG52YXIgZGVmYXVsdFN0eWxlcyA9IG51bGw7XG5cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUgRmVhdHVyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gKiBAcmV0dXJuIHtBcnJheTxTdHlsZT59IFN0eWxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRGVmYXVsdFN0eWxlKGZlYXR1cmUsIHJlc29sdXRpb24pIHtcbiAgLy8gV2UgZG9uJ3QgdXNlIGFuIGltbWVkaWF0ZWx5LWludm9rZWQgZnVuY3Rpb25cbiAgLy8gYW5kIGEgY2xvc3VyZSBzbyB3ZSBkb24ndCBnZXQgYW4gZXJyb3IgYXQgc2NyaXB0IGV2YWx1YXRpb24gdGltZSBpblxuICAvLyBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IENhbnZhcy4gKGltcG9ydChcIi4vQ2lyY2xlLmpzXCIpLkNpcmNsZVN0eWxlIGRvZXNcbiAgLy8gY2FudmFzLmdldENvbnRleHQoJzJkJykgYXQgY29uc3RydWN0aW9uIHRpbWUsIHdoaWNoIHdpbGwgY2F1c2UgYW4uZXJyb3JcbiAgLy8gaW4gc3VjaCBicm93c2Vycy4pXG4gIGlmICghZGVmYXVsdFN0eWxlcykge1xuICAgIHZhciBmaWxsID0gbmV3IEZpbGwoe1xuICAgICAgY29sb3I6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNCknXG4gICAgfSk7XG4gICAgdmFyIHN0cm9rZSA9IG5ldyBTdHJva2Uoe1xuICAgICAgY29sb3I6ICcjMzM5OUNDJyxcbiAgICAgIHdpZHRoOiAxLjI1XG4gICAgfSk7XG4gICAgZGVmYXVsdFN0eWxlcyA9IFtcbiAgICAgIG5ldyBTdHlsZSh7XG4gICAgICAgIGltYWdlOiBuZXcgQ2lyY2xlU3R5bGUoe1xuICAgICAgICAgIGZpbGw6IGZpbGwsXG4gICAgICAgICAgc3Ryb2tlOiBzdHJva2UsXG4gICAgICAgICAgcmFkaXVzOiA1XG4gICAgICAgIH0pLFxuICAgICAgICBmaWxsOiBmaWxsLFxuICAgICAgICBzdHJva2U6IHN0cm9rZVxuICAgICAgfSlcbiAgICBdO1xuICB9XG4gIHJldHVybiBkZWZhdWx0U3R5bGVzO1xufVxuXG5cbi8qKlxuICogRGVmYXVsdCBzdHlsZXMgZm9yIGVkaXRpbmcgZmVhdHVyZXMuXG4gKiBAcmV0dXJuIHtPYmplY3Q8aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeVR5cGUuanNcIikuZGVmYXVsdCwgQXJyYXk8U3R5bGU+Pn0gU3R5bGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFZGl0aW5nU3R5bGUoKSB7XG4gIC8qKiBAdHlwZSB7T2JqZWN0PGltcG9ydChcIi4uL2dlb20vR2VvbWV0cnlUeXBlLmpzXCIpLmRlZmF1bHQsIEFycmF5PFN0eWxlPj59ICovXG4gIHZhciBzdHlsZXMgPSB7fTtcbiAgdmFyIHdoaXRlID0gWzI1NSwgMjU1LCAyNTUsIDFdO1xuICB2YXIgYmx1ZSA9IFswLCAxNTMsIDI1NSwgMV07XG4gIHZhciB3aWR0aCA9IDM7XG4gIHN0eWxlc1tHZW9tZXRyeVR5cGUuUE9MWUdPTl0gPSBbXG4gICAgbmV3IFN0eWxlKHtcbiAgICAgIGZpbGw6IG5ldyBGaWxsKHtcbiAgICAgICAgY29sb3I6IFsyNTUsIDI1NSwgMjU1LCAwLjVdXG4gICAgICB9KVxuICAgIH0pXG4gIF07XG4gIHN0eWxlc1tHZW9tZXRyeVR5cGUuTVVMVElfUE9MWUdPTl0gPVxuICAgICAgc3R5bGVzW0dlb21ldHJ5VHlwZS5QT0xZR09OXTtcblxuICBzdHlsZXNbR2VvbWV0cnlUeXBlLkxJTkVfU1RSSU5HXSA9IFtcbiAgICBuZXcgU3R5bGUoe1xuICAgICAgc3Ryb2tlOiBuZXcgU3Ryb2tlKHtcbiAgICAgICAgY29sb3I6IHdoaXRlLFxuICAgICAgICB3aWR0aDogd2lkdGggKyAyXG4gICAgICB9KVxuICAgIH0pLFxuICAgIG5ldyBTdHlsZSh7XG4gICAgICBzdHJva2U6IG5ldyBTdHJva2Uoe1xuICAgICAgICBjb2xvcjogYmx1ZSxcbiAgICAgICAgd2lkdGg6IHdpZHRoXG4gICAgICB9KVxuICAgIH0pXG4gIF07XG4gIHN0eWxlc1tHZW9tZXRyeVR5cGUuTVVMVElfTElORV9TVFJJTkddID1cbiAgICAgIHN0eWxlc1tHZW9tZXRyeVR5cGUuTElORV9TVFJJTkddO1xuXG4gIHN0eWxlc1tHZW9tZXRyeVR5cGUuQ0lSQ0xFXSA9XG4gICAgICBzdHlsZXNbR2VvbWV0cnlUeXBlLlBPTFlHT05dLmNvbmNhdChcbiAgICAgICAgc3R5bGVzW0dlb21ldHJ5VHlwZS5MSU5FX1NUUklOR11cbiAgICAgICk7XG5cblxuICBzdHlsZXNbR2VvbWV0cnlUeXBlLlBPSU5UXSA9IFtcbiAgICBuZXcgU3R5bGUoe1xuICAgICAgaW1hZ2U6IG5ldyBDaXJjbGVTdHlsZSh7XG4gICAgICAgIHJhZGl1czogd2lkdGggKiAyLFxuICAgICAgICBmaWxsOiBuZXcgRmlsbCh7XG4gICAgICAgICAgY29sb3I6IGJsdWVcbiAgICAgICAgfSksXG4gICAgICAgIHN0cm9rZTogbmV3IFN0cm9rZSh7XG4gICAgICAgICAgY29sb3I6IHdoaXRlLFxuICAgICAgICAgIHdpZHRoOiB3aWR0aCAvIDJcbiAgICAgICAgfSlcbiAgICAgIH0pLFxuICAgICAgekluZGV4OiBJbmZpbml0eVxuICAgIH0pXG4gIF07XG4gIHN0eWxlc1tHZW9tZXRyeVR5cGUuTVVMVElfUE9JTlRdID1cbiAgICAgIHN0eWxlc1tHZW9tZXRyeVR5cGUuUE9JTlRdO1xuXG4gIHN0eWxlc1tHZW9tZXRyeVR5cGUuR0VPTUVUUllfQ09MTEVDVElPTl0gPVxuICAgICAgc3R5bGVzW0dlb21ldHJ5VHlwZS5QT0xZR09OXS5jb25jYXQoXG4gICAgICAgIHN0eWxlc1tHZW9tZXRyeVR5cGUuTElORV9TVFJJTkddLFxuICAgICAgICBzdHlsZXNbR2VvbWV0cnlUeXBlLlBPSU5UXVxuICAgICAgKTtcblxuICByZXR1cm4gc3R5bGVzO1xufVxuXG5cbi8qKlxuICogRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBhIGZlYXR1cmUgYW5kIHJldHVybnMgaXRzIGRlZmF1bHQgZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUgRmVhdHVyZSB0byBnZXQgdGhlIGdlb21ldHJ5IGZvci5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9yZW5kZXIvRmVhdHVyZS5qc1wiKS5kZWZhdWx0fHVuZGVmaW5lZH0gR2VvbWV0cnkgdG8gcmVuZGVyLlxuICovXG5mdW5jdGlvbiBkZWZhdWx0R2VvbWV0cnlGdW5jdGlvbihmZWF0dXJlKSB7XG4gIHJldHVybiBmZWF0dXJlLmdldEdlb21ldHJ5KCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFN0eWxlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdHlsZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvc3R5bGUvVGV4dFBsYWNlbWVudFxuICovXG5cbi8qKlxuICogVGV4dCBwbGFjZW1lbnQuIE9uZSBvZiBgJ3BvaW50J2AsIGAnbGluZSdgLiBEZWZhdWx0IGlzIGAncG9pbnQnYC4gTm90ZSB0aGF0XG4gKiBgJ2xpbmUnYCByZXF1aXJlcyB0aGUgdW5kZXJseWluZyBnZW9tZXRyeSB0byBiZSBhIHtAbGluayBtb2R1bGU6b2wvZ2VvbS9MaW5lU3RyaW5nfkxpbmVTdHJpbmd9LFxuICoge0BsaW5rIG1vZHVsZTpvbC9nZW9tL1BvbHlnb25+UG9seWdvbn0sIHtAbGluayBtb2R1bGU6b2wvZ2VvbS9NdWx0aUxpbmVTdHJpbmd+TXVsdGlMaW5lU3RyaW5nfSBvclxuICoge0BsaW5rIG1vZHVsZTpvbC9nZW9tL011bHRpUG9seWdvbn5NdWx0aVBvbHlnb259LlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBQT0lOVDogJ3BvaW50JyxcbiAgTElORTogJ2xpbmUnXG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1UZXh0UGxhY2VtZW50LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC90aWxlY29vcmRcbiAqL1xuXG5cbi8qKlxuICogQW4gYXJyYXkgb2YgdGhyZWUgbnVtYmVycyByZXByZXNlbnRpbmcgdGhlIGxvY2F0aW9uIG9mIGEgdGlsZSBpbiBhIHRpbGVcbiAqIGdyaWQuIFRoZSBvcmRlciBpcyBgemAsIGB4YCwgYW5kIGB5YC4gYHpgIGlzIHRoZSB6b29tIGxldmVsLlxuICogQHR5cGVkZWYge0FycmF5PG51bWJlcj59IFRpbGVDb29yZFxuICogQGFwaVxuICovXG5cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0geiBaLlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKiBAcGFyYW0ge1RpbGVDb29yZD19IG9wdF90aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICogQHJldHVybiB7VGlsZUNvb3JkfSBUaWxlIGNvb3JkaW5hdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVPclVwZGF0ZSh6LCB4LCB5LCBvcHRfdGlsZUNvb3JkKSB7XG4gIGlmIChvcHRfdGlsZUNvb3JkICE9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRfdGlsZUNvb3JkWzBdID0gejtcbiAgICBvcHRfdGlsZUNvb3JkWzFdID0geDtcbiAgICBvcHRfdGlsZUNvb3JkWzJdID0geTtcbiAgICByZXR1cm4gb3B0X3RpbGVDb29yZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW3osIHgsIHldO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0geiBaLlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEtleVpYWSh6LCB4LCB5KSB7XG4gIHJldHVybiB6ICsgJy8nICsgeCArICcvJyArIHk7XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIGtleSBmb3IgYSB0aWxlIGNvb3JkLlxuICogQHBhcmFtIHtUaWxlQ29vcmR9IHRpbGVDb29yZCBUaGUgdGlsZSBjb29yZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gS2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0S2V5KHRpbGVDb29yZCkge1xuICByZXR1cm4gZ2V0S2V5WlhZKHRpbGVDb29yZFswXSwgdGlsZUNvb3JkWzFdLCB0aWxlQ29vcmRbMl0pO1xufVxuXG5cbi8qKlxuICogR2V0IGEgdGlsZSBjb29yZCBnaXZlbiBhIGtleS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHRpbGUgY29vcmQga2V5LlxuICogQHJldHVybiB7VGlsZUNvb3JkfSBUaGUgdGlsZSBjb29yZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21LZXkoa2V5KSB7XG4gIHJldHVybiBrZXkuc3BsaXQoJy8nKS5tYXAoTnVtYmVyKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7VGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZC5cbiAqIEByZXR1cm4ge251bWJlcn0gSGFzaC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2godGlsZUNvb3JkKSB7XG4gIHJldHVybiAodGlsZUNvb3JkWzFdIDw8IHRpbGVDb29yZFswXSkgKyB0aWxlQ29vcmRbMl07XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge1RpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFF1YWQga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVhZEtleSh0aWxlQ29vcmQpIHtcbiAgdmFyIHogPSB0aWxlQ29vcmRbMF07XG4gIHZhciBkaWdpdHMgPSBuZXcgQXJyYXkoeik7XG4gIHZhciBtYXNrID0gMSA8PCAoeiAtIDEpO1xuICB2YXIgaSwgY2hhckNvZGU7XG4gIGZvciAoaSA9IDA7IGkgPCB6OyArK2kpIHtcbiAgICAvLyA0OCBpcyBjaGFyQ29kZSBmb3IgMCAtICcwJy5jaGFyQ29kZUF0KDApXG4gICAgY2hhckNvZGUgPSA0ODtcbiAgICBpZiAodGlsZUNvb3JkWzFdICYgbWFzaykge1xuICAgICAgY2hhckNvZGUgKz0gMTtcbiAgICB9XG4gICAgaWYgKHRpbGVDb29yZFsyXSAmIG1hc2spIHtcbiAgICAgIGNoYXJDb2RlICs9IDI7XG4gICAgfVxuICAgIGRpZ2l0c1tpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICAgIG1hc2sgPj49IDE7XG4gIH1cbiAgcmV0dXJuIGRpZ2l0cy5qb2luKCcnKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7VGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICogQHBhcmFtIHshaW1wb3J0KFwiLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSB0aWxlR3JpZCBUaWxlIGdyaWQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaWxlIGNvb3JkaW5hdGUgaXMgd2l0aGluIGV4dGVudCBhbmQgem9vbSBsZXZlbCByYW5nZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdpdGhpbkV4dGVudEFuZFoodGlsZUNvb3JkLCB0aWxlR3JpZCkge1xuICB2YXIgeiA9IHRpbGVDb29yZFswXTtcbiAgdmFyIHggPSB0aWxlQ29vcmRbMV07XG4gIHZhciB5ID0gdGlsZUNvb3JkWzJdO1xuXG4gIGlmICh0aWxlR3JpZC5nZXRNaW5ab29tKCkgPiB6IHx8IHogPiB0aWxlR3JpZC5nZXRNYXhab29tKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGV4dGVudCA9IHRpbGVHcmlkLmdldEV4dGVudCgpO1xuICB2YXIgdGlsZVJhbmdlO1xuICBpZiAoIWV4dGVudCkge1xuICAgIHRpbGVSYW5nZSA9IHRpbGVHcmlkLmdldEZ1bGxUaWxlUmFuZ2Uoeik7XG4gIH0gZWxzZSB7XG4gICAgdGlsZVJhbmdlID0gdGlsZUdyaWQuZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWihleHRlbnQsIHopO1xuICB9XG4gIGlmICghdGlsZVJhbmdlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRpbGVSYW5nZS5jb250YWluc1hZKHgsIHkpO1xuICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbGVjb29yZC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvdGlsZWdyaWRcbiAqL1xuaW1wb3J0IHtERUZBVUxUX01BWF9aT09NLCBERUZBVUxUX1RJTEVfU0laRX0gZnJvbSAnLi90aWxlZ3JpZC9jb21tb24uanMnO1xuaW1wb3J0IHt0b1NpemV9IGZyb20gJy4vc2l6ZS5qcyc7XG5pbXBvcnQge2NvbnRhaW5zQ29vcmRpbmF0ZSwgY3JlYXRlT3JVcGRhdGUsIGdldENvcm5lciwgZ2V0SGVpZ2h0LCBnZXRXaWR0aH0gZnJvbSAnLi9leHRlbnQuanMnO1xuaW1wb3J0IENvcm5lciBmcm9tICcuL2V4dGVudC9Db3JuZXIuanMnO1xuaW1wb3J0IHtnZXQgYXMgZ2V0UHJvamVjdGlvbiwgTUVURVJTX1BFUl9VTklUfSBmcm9tICcuL3Byb2ouanMnO1xuaW1wb3J0IFVuaXRzIGZyb20gJy4vcHJvai9Vbml0cy5qcyc7XG5pbXBvcnQgVGlsZUdyaWQgZnJvbSAnLi90aWxlZ3JpZC9UaWxlR3JpZC5qcyc7XG5cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAqIEByZXR1cm4geyFUaWxlR3JpZH0gRGVmYXVsdCB0aWxlIGdyaWQgZm9yIHRoZVxuICogcGFzc2VkIHByb2plY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pIHtcbiAgdmFyIHRpbGVHcmlkID0gcHJvamVjdGlvbi5nZXREZWZhdWx0VGlsZUdyaWQoKTtcbiAgaWYgKCF0aWxlR3JpZCkge1xuICAgIHRpbGVHcmlkID0gY3JlYXRlRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgICBwcm9qZWN0aW9uLnNldERlZmF1bHRUaWxlR3JpZCh0aWxlR3JpZCk7XG4gIH1cbiAgcmV0dXJuIHRpbGVHcmlkO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtUaWxlR3JpZH0gdGlsZUdyaWQgVGlsZSBncmlkLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gVGlsZSBjb29yZGluYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gd3JhcFgodGlsZUdyaWQsIHRpbGVDb29yZCwgcHJvamVjdGlvbikge1xuICB2YXIgeiA9IHRpbGVDb29yZFswXTtcbiAgdmFyIGNlbnRlciA9IHRpbGVHcmlkLmdldFRpbGVDb29yZENlbnRlcih0aWxlQ29vcmQpO1xuICB2YXIgcHJvamVjdGlvbkV4dGVudCA9IGV4dGVudEZyb21Qcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICBpZiAoIWNvbnRhaW5zQ29vcmRpbmF0ZShwcm9qZWN0aW9uRXh0ZW50LCBjZW50ZXIpKSB7XG4gICAgdmFyIHdvcmxkV2lkdGggPSBnZXRXaWR0aChwcm9qZWN0aW9uRXh0ZW50KTtcbiAgICB2YXIgd29ybGRzQXdheSA9IE1hdGguY2VpbCgocHJvamVjdGlvbkV4dGVudFswXSAtIGNlbnRlclswXSkgLyB3b3JsZFdpZHRoKTtcbiAgICBjZW50ZXJbMF0gKz0gd29ybGRXaWR0aCAqIHdvcmxkc0F3YXk7XG4gICAgcmV0dXJuIHRpbGVHcmlkLmdldFRpbGVDb29yZEZvckNvb3JkQW5kWihjZW50ZXIsIHopO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aWxlQ29vcmQ7XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfbWF4Wm9vbSBNYXhpbXVtIHpvb20gbGV2ZWwgKGRlZmF1bHQgaXNcbiAqICAgICBERUZBVUxUX01BWF9aT09NKS5cbiAqIEBwYXJhbSB7bnVtYmVyfGltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplPX0gb3B0X3RpbGVTaXplIFRpbGUgc2l6ZSAoZGVmYXVsdCB1c2VzXG4gKiAgICAgREVGQVVMVF9USUxFX1NJWkUpLlxuICogQHBhcmFtIHtDb3JuZXI9fSBvcHRfY29ybmVyIEV4dGVudCBjb3JuZXIgKGRlZmF1bHQgaXMgYCd0b3AtbGVmdCdgKS5cbiAqIEByZXR1cm4geyFUaWxlR3JpZH0gVGlsZUdyaWQgaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGb3JFeHRlbnQoZXh0ZW50LCBvcHRfbWF4Wm9vbSwgb3B0X3RpbGVTaXplLCBvcHRfY29ybmVyKSB7XG4gIHZhciBjb3JuZXIgPSBvcHRfY29ybmVyICE9PSB1bmRlZmluZWQgPyBvcHRfY29ybmVyIDogQ29ybmVyLlRPUF9MRUZUO1xuXG4gIHZhciByZXNvbHV0aW9ucyA9IHJlc29sdXRpb25zRnJvbUV4dGVudChleHRlbnQsIG9wdF9tYXhab29tLCBvcHRfdGlsZVNpemUpO1xuXG4gIHJldHVybiBuZXcgVGlsZUdyaWQoe1xuICAgIGV4dGVudDogZXh0ZW50LFxuICAgIG9yaWdpbjogZ2V0Q29ybmVyKGV4dGVudCwgY29ybmVyKSxcbiAgICByZXNvbHV0aW9uczogcmVzb2x1dGlvbnMsXG4gICAgdGlsZVNpemU6IG9wdF90aWxlU2l6ZVxuICB9KTtcbn1cblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFhZWk9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBbZXh0ZW50XSBFeHRlbnQgZm9yIHRoZSB0aWxlIGdyaWQuIFRoZSBvcmlnaW4gZm9yIGFuIFhZWiB0aWxlIGdyaWQgaXMgdGhlXG4gKiB0b3AtbGVmdCBjb3JuZXIgb2YgdGhlIGV4dGVudC4gVGhlIHplcm8gbGV2ZWwgb2YgdGhlIGdyaWQgaXMgZGVmaW5lZCBieSB0aGUgcmVzb2x1dGlvbiBhdCB3aGljaCBvbmUgdGlsZSBmaXRzIGluIHRoZVxuICogcHJvdmlkZWQgZXh0ZW50LiBJZiBub3QgcHJvdmlkZWQsIHRoZSBleHRlbnQgb2YgdGhlIEVQU0c6Mzg1NyBwcm9qZWN0aW9uIGlzIHVzZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFpvb21dIE1heGltdW0gem9vbS4gVGhlIGRlZmF1bHQgaXMgYDQyYC4gVGhpcyBkZXRlcm1pbmVzIHRoZSBudW1iZXIgb2YgbGV2ZWxzXG4gKiBpbiB0aGUgZ3JpZCBzZXQuIEZvciBleGFtcGxlLCBhIGBtYXhab29tYCBvZiAyMSBtZWFucyB0aGVyZSBhcmUgMjIgbGV2ZWxzIGluIHRoZSBncmlkIHNldC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluWm9vbT0wXSBNaW5pbXVtIHpvb20uXG4gKiBAcHJvcGVydHkge251bWJlcnxpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gW3RpbGVTaXplPVsyNTYsIDI1Nl1dIFRpbGUgc2l6ZSBpbiBwaXhlbHMuXG4gKi9cblxuXG4vKipcbiAqIENyZWF0ZXMgYSB0aWxlIGdyaWQgd2l0aCBhIHN0YW5kYXJkIFhZWiB0aWxpbmcgc2NoZW1lLlxuICogQHBhcmFtIHtYWVpPcHRpb25zPX0gb3B0X29wdGlvbnMgVGlsZSBncmlkIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHshVGlsZUdyaWR9IFRpbGUgZ3JpZCBpbnN0YW5jZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVhZWihvcHRfb3B0aW9ucykge1xuICAvKiogQHR5cGUge1hZWk9wdGlvbnN9ICovXG4gIHZhciB4eXpPcHRpb25zID0gb3B0X29wdGlvbnMgfHwge307XG5cbiAgdmFyIGV4dGVudCA9IHh5ek9wdGlvbnMuZXh0ZW50IHx8IGdldFByb2plY3Rpb24oJ0VQU0c6Mzg1NycpLmdldEV4dGVudCgpO1xuXG4gIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5PcHRpb25zfSAqL1xuICB2YXIgZ3JpZE9wdGlvbnMgPSB7XG4gICAgZXh0ZW50OiBleHRlbnQsXG4gICAgbWluWm9vbTogeHl6T3B0aW9ucy5taW5ab29tLFxuICAgIHRpbGVTaXplOiB4eXpPcHRpb25zLnRpbGVTaXplLFxuICAgIHJlc29sdXRpb25zOiByZXNvbHV0aW9uc0Zyb21FeHRlbnQoXG4gICAgICBleHRlbnQsXG4gICAgICB4eXpPcHRpb25zLm1heFpvb20sXG4gICAgICB4eXpPcHRpb25zLnRpbGVTaXplXG4gICAgKVxuICB9O1xuICByZXR1cm4gbmV3IFRpbGVHcmlkKGdyaWRPcHRpb25zKTtcbn1cblxuXG4vKipcbiAqIENyZWF0ZSBhIHJlc29sdXRpb25zIGFycmF5IGZyb20gYW4gZXh0ZW50LiAgQSB6b29tIGZhY3RvciBvZiAyIGlzIGFzc3VtZWQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X21heFpvb20gTWF4aW11bSB6b29tIGxldmVsIChkZWZhdWx0IGlzXG4gKiAgICAgREVGQVVMVF9NQVhfWk9PTSkuXG4gKiBAcGFyYW0ge251bWJlcnxpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZT19IG9wdF90aWxlU2l6ZSBUaWxlIHNpemUgKGRlZmF1bHQgdXNlc1xuICogICAgIERFRkFVTFRfVElMRV9TSVpFKS5cbiAqIEByZXR1cm4geyFBcnJheTxudW1iZXI+fSBSZXNvbHV0aW9ucyBhcnJheS5cbiAqL1xuZnVuY3Rpb24gcmVzb2x1dGlvbnNGcm9tRXh0ZW50KGV4dGVudCwgb3B0X21heFpvb20sIG9wdF90aWxlU2l6ZSkge1xuICB2YXIgbWF4Wm9vbSA9IG9wdF9tYXhab29tICE9PSB1bmRlZmluZWQgP1xuICAgIG9wdF9tYXhab29tIDogREVGQVVMVF9NQVhfWk9PTTtcblxuICB2YXIgaGVpZ2h0ID0gZ2V0SGVpZ2h0KGV4dGVudCk7XG4gIHZhciB3aWR0aCA9IGdldFdpZHRoKGV4dGVudCk7XG5cbiAgdmFyIHRpbGVTaXplID0gdG9TaXplKG9wdF90aWxlU2l6ZSAhPT0gdW5kZWZpbmVkID9cbiAgICBvcHRfdGlsZVNpemUgOiBERUZBVUxUX1RJTEVfU0laRSk7XG4gIHZhciBtYXhSZXNvbHV0aW9uID0gTWF0aC5tYXgoXG4gICAgd2lkdGggLyB0aWxlU2l6ZVswXSwgaGVpZ2h0IC8gdGlsZVNpemVbMV0pO1xuXG4gIHZhciBsZW5ndGggPSBtYXhab29tICsgMTtcbiAgdmFyIHJlc29sdXRpb25zID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gIGZvciAodmFyIHogPSAwOyB6IDwgbGVuZ3RoOyArK3opIHtcbiAgICByZXNvbHV0aW9uc1t6XSA9IG1heFJlc29sdXRpb24gLyBNYXRoLnBvdygyLCB6KTtcbiAgfVxuICByZXR1cm4gcmVzb2x1dGlvbnM7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfbWF4Wm9vbSBNYXhpbXVtIHpvb20gbGV2ZWwgKGRlZmF1bHQgaXNcbiAqICAgICBERUZBVUxUX01BWF9aT09NKS5cbiAqIEBwYXJhbSB7bnVtYmVyfGltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplPX0gb3B0X3RpbGVTaXplIFRpbGUgc2l6ZSAoZGVmYXVsdCB1c2VzXG4gKiAgICAgREVGQVVMVF9USUxFX1NJWkUpLlxuICogQHBhcmFtIHtDb3JuZXI9fSBvcHRfY29ybmVyIEV4dGVudCBjb3JuZXIgKGRlZmF1bHQgaXMgYCd0b3AtbGVmdCdgKS5cbiAqIEByZXR1cm4geyFUaWxlR3JpZH0gVGlsZUdyaWQgaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24sIG9wdF9tYXhab29tLCBvcHRfdGlsZVNpemUsIG9wdF9jb3JuZXIpIHtcbiAgdmFyIGV4dGVudCA9IGV4dGVudEZyb21Qcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICByZXR1cm4gY3JlYXRlRm9yRXh0ZW50KGV4dGVudCwgb3B0X21heFpvb20sIG9wdF90aWxlU2l6ZSwgb3B0X2Nvcm5lcik7XG59XG5cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHRpbGUgZ3JpZCBleHRlbnQgZnJvbSBhIHByb2plY3Rpb24uICBJZiB0aGUgcHJvamVjdGlvbiBoYXMgYW5cbiAqIGV4dGVudCwgaXQgaXMgdXNlZC4gIElmIG5vdCwgYSBnbG9iYWwgZXh0ZW50IGlzIGFzc3VtZWQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBFeHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRlbnRGcm9tUHJvamVjdGlvbihwcm9qZWN0aW9uKSB7XG4gIHByb2plY3Rpb24gPSBnZXRQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICB2YXIgZXh0ZW50ID0gcHJvamVjdGlvbi5nZXRFeHRlbnQoKTtcbiAgaWYgKCFleHRlbnQpIHtcbiAgICB2YXIgaGFsZiA9IDE4MCAqIE1FVEVSU19QRVJfVU5JVFtVbml0cy5ERUdSRUVTXSAvIHByb2plY3Rpb24uZ2V0TWV0ZXJzUGVyVW5pdCgpO1xuICAgIGV4dGVudCA9IGNyZWF0ZU9yVXBkYXRlKC1oYWxmLCAtaGFsZiwgaGFsZiwgaGFsZik7XG4gIH1cbiAgcmV0dXJuIGV4dGVudDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGlsZWdyaWQuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3RpbGVncmlkL1RpbGVHcmlkXG4gKi9cbmltcG9ydCB7REVGQVVMVF9USUxFX1NJWkV9IGZyb20gJy4vY29tbW9uLmpzJztcbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuLi9hc3NlcnRzLmpzJztcbmltcG9ydCBUaWxlUmFuZ2UsIHtjcmVhdGVPclVwZGF0ZSBhcyBjcmVhdGVPclVwZGF0ZVRpbGVSYW5nZX0gZnJvbSAnLi4vVGlsZVJhbmdlLmpzJztcbmltcG9ydCB7aXNTb3J0ZWQsIGxpbmVhckZpbmROZWFyZXN0fSBmcm9tICcuLi9hcnJheS5qcyc7XG5pbXBvcnQge2NyZWF0ZU9yVXBkYXRlLCBnZXRUb3BMZWZ0fSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IHtjbGFtcH0gZnJvbSAnLi4vbWF0aC5qcyc7XG5pbXBvcnQge3RvU2l6ZX0gZnJvbSAnLi4vc2l6ZS5qcyc7XG5pbXBvcnQge2NyZWF0ZU9yVXBkYXRlIGFzIGNyZWF0ZU9yVXBkYXRlVGlsZUNvb3JkfSBmcm9tICcuLi90aWxlY29vcmQuanMnO1xuXG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEB0eXBlIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfVxuICovXG52YXIgdG1wVGlsZUNvb3JkID0gWzAsIDAsIDBdO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBbZXh0ZW50XSBFeHRlbnQgZm9yIHRoZSB0aWxlIGdyaWQuIE5vIHRpbGVzIG91dHNpZGUgdGhpc1xuICogZXh0ZW50IHdpbGwgYmUgcmVxdWVzdGVkIGJ5IHtAbGluayBtb2R1bGU6b2wvc291cmNlL1RpbGV9IHNvdXJjZXMuIFdoZW4gbm8gYG9yaWdpbmAgb3JcbiAqIGBvcmlnaW5zYCBhcmUgY29uZmlndXJlZCwgdGhlIGBvcmlnaW5gIHdpbGwgYmUgc2V0IHRvIHRoZSB0b3AtbGVmdCBjb3JuZXIgb2YgdGhlIGV4dGVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluWm9vbT0wXSBNaW5pbXVtIHpvb20uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gW29yaWdpbl0gVGhlIHRpbGUgZ3JpZCBvcmlnaW4sIGkuZS4gd2hlcmUgdGhlIGB4YFxuICogYW5kIGB5YCBheGVzIG1lZXQgKGBbeiwgMCwgMF1gKS4gVGlsZSBjb29yZGluYXRlcyBpbmNyZWFzZSBsZWZ0IHRvIHJpZ2h0IGFuZCB1cHdhcmRzLiBJZiBub3RcbiAqIHNwZWNpZmllZCwgYGV4dGVudGAgb3IgYG9yaWdpbnNgIG11c3QgYmUgcHJvdmlkZWQuXG4gKiBAcHJvcGVydHkge0FycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59IFtvcmlnaW5zXSBUaWxlIGdyaWQgb3JpZ2lucywgaS5lLiB3aGVyZVxuICogdGhlIGB4YCBhbmQgYHlgIGF4ZXMgbWVldCAoYFt6LCAwLCAwXWApLCBmb3IgZWFjaCB6b29tIGxldmVsLiBJZiBnaXZlbiwgdGhlIGFycmF5IGxlbmd0aFxuICogc2hvdWxkIG1hdGNoIHRoZSBsZW5ndGggb2YgdGhlIGByZXNvbHV0aW9uc2AgYXJyYXksIGkuZS4gZWFjaCByZXNvbHV0aW9uIGNhbiBoYXZlIGEgZGlmZmVyZW50XG4gKiBvcmlnaW4uIFRpbGUgY29vcmRpbmF0ZXMgaW5jcmVhc2UgbGVmdCB0byByaWdodCBhbmQgdXB3YXJkcy4gSWYgbm90IHNwZWNpZmllZCwgYGV4dGVudGAgb3JcbiAqIGBvcmlnaW5gIG11c3QgYmUgcHJvdmlkZWQuXG4gKiBAcHJvcGVydHkgeyFBcnJheTxudW1iZXI+fSByZXNvbHV0aW9ucyBSZXNvbHV0aW9ucy4gVGhlIGFycmF5IGluZGV4IG9mIGVhY2ggcmVzb2x1dGlvbiBuZWVkc1xuICogdG8gbWF0Y2ggdGhlIHpvb20gbGV2ZWwuIFRoaXMgbWVhbnMgdGhhdCBldmVuIGlmIGEgYG1pblpvb21gIGlzIGNvbmZpZ3VyZWQsIHRoZSByZXNvbHV0aW9uc1xuICogYXJyYXkgd2lsbCBoYXZlIGEgbGVuZ3RoIG9mIGBtYXhab29tICsgMWAuXG4gKiBAcHJvcGVydHkge0FycmF5PGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZT59IFtzaXplc10gU2l6ZXMuXG4gKiBAcHJvcGVydHkge251bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IFt0aWxlU2l6ZV0gVGlsZSBzaXplLlxuICogRGVmYXVsdCBpcyBgWzI1NiwgMjU2XWAuXG4gKiBAcHJvcGVydHkge0FycmF5PGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZT59IFt0aWxlU2l6ZXNdIFRpbGUgc2l6ZXMuIElmIGdpdmVuLCB0aGUgYXJyYXkgbGVuZ3RoXG4gKiBzaG91bGQgbWF0Y2ggdGhlIGxlbmd0aCBvZiB0aGUgYHJlc29sdXRpb25zYCBhcnJheSwgaS5lLiBlYWNoIHJlc29sdXRpb24gY2FuIGhhdmUgYSBkaWZmZXJlbnRcbiAqIHRpbGUgc2l6ZS5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQmFzZSBjbGFzcyBmb3Igc2V0dGluZyB0aGUgZ3JpZCBwYXR0ZXJuIGZvciBzb3VyY2VzIGFjY2Vzc2luZyB0aWxlZC1pbWFnZVxuICogc2VydmVycy5cbiAqIEBhcGlcbiAqL1xudmFyIFRpbGVHcmlkID0gZnVuY3Rpb24gVGlsZUdyaWQob3B0aW9ucykge1xuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLm1pblpvb20gPSBvcHRpb25zLm1pblpvb20gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubWluWm9vbSA6IDA7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHshQXJyYXk8bnVtYmVyPn1cbiAgICovXG4gIHRoaXMucmVzb2x1dGlvbnNfID0gb3B0aW9ucy5yZXNvbHV0aW9ucztcbiAgYXNzZXJ0KGlzU29ydGVkKHRoaXMucmVzb2x1dGlvbnNfLCBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGIgLSBhO1xuICB9LCB0cnVlKSwgMTcpOyAvLyBgcmVzb2x1dGlvbnNgIG11c3QgYmUgc29ydGVkIGluIGRlc2NlbmRpbmcgb3JkZXJcblxuXG4gIC8vIGNoZWNrIGlmIHdlJ3ZlIGdvdCBhIGNvbnNpc3RlbnQgem9vbSBmYWN0b3IgYW5kIG9yaWdpblxuICB2YXIgem9vbUZhY3RvcjtcbiAgaWYgKCFvcHRpb25zLm9yaWdpbnMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLnJlc29sdXRpb25zXy5sZW5ndGggLSAxOyBpIDwgaWk7ICsraSkge1xuICAgICAgaWYgKCF6b29tRmFjdG9yKSB7XG4gICAgICAgIHpvb21GYWN0b3IgPSB0aGlzLnJlc29sdXRpb25zX1tpXSAvIHRoaXMucmVzb2x1dGlvbnNfW2kgKyAxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLnJlc29sdXRpb25zX1tpXSAvIHRoaXMucmVzb2x1dGlvbnNfW2kgKyAxXSAhPT0gem9vbUZhY3Rvcikge1xuICAgICAgICAgIHpvb21GYWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICovXG4gIHRoaXMuem9vbUZhY3Rvcl8gPSB6b29tRmFjdG9yO1xuXG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMubWF4Wm9vbSA9IHRoaXMucmVzb2x1dGlvbnNfLmxlbmd0aCAtIDE7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9XG4gICAqL1xuICB0aGlzLm9yaWdpbl8gPSBvcHRpb25zLm9yaWdpbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5vcmlnaW4gOiBudWxsO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn1cbiAgICovXG4gIHRoaXMub3JpZ2luc18gPSBudWxsO1xuICBpZiAob3B0aW9ucy5vcmlnaW5zICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLm9yaWdpbnNfID0gb3B0aW9ucy5vcmlnaW5zO1xuICAgIGFzc2VydCh0aGlzLm9yaWdpbnNfLmxlbmd0aCA9PSB0aGlzLnJlc29sdXRpb25zXy5sZW5ndGgsXG4gICAgICAyMCk7IC8vIE51bWJlciBvZiBgb3JpZ2luc2AgYW5kIGByZXNvbHV0aW9uc2AgbXVzdCBiZSBlcXVhbFxuICB9XG5cbiAgdmFyIGV4dGVudCA9IG9wdGlvbnMuZXh0ZW50O1xuXG4gIGlmIChleHRlbnQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgIXRoaXMub3JpZ2luXyAmJiAhdGhpcy5vcmlnaW5zXykge1xuICAgIHRoaXMub3JpZ2luXyA9IGdldFRvcExlZnQoZXh0ZW50KTtcbiAgfVxuXG4gIGFzc2VydChcbiAgICAoIXRoaXMub3JpZ2luXyAmJiB0aGlzLm9yaWdpbnNfKSB8fCAodGhpcy5vcmlnaW5fICYmICF0aGlzLm9yaWdpbnNfKSxcbiAgICAxOCk7IC8vIEVpdGhlciBgb3JpZ2luYCBvciBgb3JpZ2luc2AgbXVzdCBiZSBjb25maWd1cmVkLCBuZXZlciBib3RoXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtBcnJheTxudW1iZXJ8aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplPn1cbiAgICovXG4gIHRoaXMudGlsZVNpemVzXyA9IG51bGw7XG4gIGlmIChvcHRpb25zLnRpbGVTaXplcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy50aWxlU2l6ZXNfID0gb3B0aW9ucy50aWxlU2l6ZXM7XG4gICAgYXNzZXJ0KHRoaXMudGlsZVNpemVzXy5sZW5ndGggPT0gdGhpcy5yZXNvbHV0aW9uc18ubGVuZ3RoLFxuICAgICAgMTkpOyAvLyBOdW1iZXIgb2YgYHRpbGVTaXplc2AgYW5kIGByZXNvbHV0aW9uc2AgbXVzdCBiZSBlcXVhbFxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtudW1iZXJ8aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfVxuICAgKi9cbiAgdGhpcy50aWxlU2l6ZV8gPSBvcHRpb25zLnRpbGVTaXplICE9PSB1bmRlZmluZWQgP1xuICAgIG9wdGlvbnMudGlsZVNpemUgOlxuICAgICF0aGlzLnRpbGVTaXplc18gPyBERUZBVUxUX1RJTEVfU0laRSA6IG51bGw7XG4gIGFzc2VydChcbiAgICAoIXRoaXMudGlsZVNpemVfICYmIHRoaXMudGlsZVNpemVzXykgfHxcbiAgICAgICh0aGlzLnRpbGVTaXplXyAmJiAhdGhpcy50aWxlU2l6ZXNfKSxcbiAgICAyMik7IC8vIEVpdGhlciBgdGlsZVNpemVgIG9yIGB0aWxlU2l6ZXNgIG11c3QgYmUgY29uZmlndXJlZCwgbmV2ZXIgYm90aFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAgICovXG4gIHRoaXMuZXh0ZW50XyA9IGV4dGVudCAhPT0gdW5kZWZpbmVkID8gZXh0ZW50IDogbnVsbDtcblxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHQ+fVxuICAgKi9cbiAgdGhpcy5mdWxsVGlsZVJhbmdlc18gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfVxuICAgKi9cbiAgdGhpcy50bXBTaXplXyA9IFswLCAwXTtcblxuICBpZiAob3B0aW9ucy5zaXplcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5mdWxsVGlsZVJhbmdlc18gPSBvcHRpb25zLnNpemVzLm1hcChmdW5jdGlvbihzaXplLCB6KSB7XG4gICAgICB2YXIgdGlsZVJhbmdlID0gbmV3IFRpbGVSYW5nZShcbiAgICAgICAgTWF0aC5taW4oMCwgc2l6ZVswXSksIE1hdGgubWF4KHNpemVbMF0gLSAxLCAtMSksXG4gICAgICAgIE1hdGgubWluKDAsIHNpemVbMV0pLCBNYXRoLm1heChzaXplWzFdIC0gMSwgLTEpKTtcbiAgICAgIHJldHVybiB0aWxlUmFuZ2U7XG4gICAgfSwgdGhpcyk7XG4gIH0gZWxzZSBpZiAoZXh0ZW50KSB7XG4gICAgdGhpcy5jYWxjdWxhdGVUaWxlUmFuZ2VzXyhleHRlbnQpO1xuICB9XG5cbn07XG5cbi8qKlxuICogQ2FsbCBhIGZ1bmN0aW9uIHdpdGggZWFjaCB0aWxlIGNvb3JkaW5hdGUgZm9yIGEgZ2l2ZW4gZXh0ZW50IGFuZCB6b29tIGxldmVsLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB6b29tIEludGVnZXIgem9vbSBsZXZlbC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZCl9IGNhbGxiYWNrIEZ1bmN0aW9uIGNhbGxlZCB3aXRoIGVhY2ggdGlsZSBjb29yZGluYXRlLlxuICogQGFwaVxuICovXG5UaWxlR3JpZC5wcm90b3R5cGUuZm9yRWFjaFRpbGVDb29yZCA9IGZ1bmN0aW9uIGZvckVhY2hUaWxlQ29vcmQgKGV4dGVudCwgem9vbSwgY2FsbGJhY2spIHtcbiAgdmFyIHRpbGVSYW5nZSA9IHRoaXMuZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWihleHRlbnQsIHpvb20pO1xuICBmb3IgKHZhciBpID0gdGlsZVJhbmdlLm1pblgsIGlpID0gdGlsZVJhbmdlLm1heFg7IGkgPD0gaWk7ICsraSkge1xuICAgIGZvciAodmFyIGogPSB0aWxlUmFuZ2UubWluWSwgamogPSB0aWxlUmFuZ2UubWF4WTsgaiA8PSBqajsgKytqKSB7XG4gICAgICBjYWxsYmFjayhbem9vbSwgaSwgal0pO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6IFQsIG51bWJlciwgaW1wb3J0KFwiLi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHQpOiBib29sZWFufSBjYWxsYmFjayBDYWxsYmFjay5cbiAqIEBwYXJhbSB7VD19IG9wdF90aGlzIFRoZSBvYmplY3QgdG8gdXNlIGFzIGB0aGlzYCBpbiBgY2FsbGJhY2tgLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdD19IG9wdF90aWxlUmFuZ2UgVGVtcG9yYXJ5IGltcG9ydChcIi4uL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0IG9iamVjdC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudD19IG9wdF9leHRlbnQgVGVtcG9yYXJ5IGltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnQgb2JqZWN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gQ2FsbGJhY2sgc3VjY2VlZGVkLlxuICogQHRlbXBsYXRlIFRcbiAqL1xuVGlsZUdyaWQucHJvdG90eXBlLmZvckVhY2hUaWxlQ29vcmRQYXJlbnRUaWxlUmFuZ2UgPSBmdW5jdGlvbiBmb3JFYWNoVGlsZUNvb3JkUGFyZW50VGlsZVJhbmdlICh0aWxlQ29vcmQsIGNhbGxiYWNrLCBvcHRfdGhpcywgb3B0X3RpbGVSYW5nZSwgb3B0X2V4dGVudCkge1xuICB2YXIgdGlsZVJhbmdlLCB4LCB5O1xuICB2YXIgdGlsZUNvb3JkRXh0ZW50ID0gbnVsbDtcbiAgdmFyIHogPSB0aWxlQ29vcmRbMF0gLSAxO1xuICBpZiAodGhpcy56b29tRmFjdG9yXyA9PT0gMikge1xuICAgIHggPSB0aWxlQ29vcmRbMV07XG4gICAgeSA9IHRpbGVDb29yZFsyXTtcbiAgfSBlbHNlIHtcbiAgICB0aWxlQ29vcmRFeHRlbnQgPSB0aGlzLmdldFRpbGVDb29yZEV4dGVudCh0aWxlQ29vcmQsIG9wdF9leHRlbnQpO1xuICB9XG4gIHdoaWxlICh6ID49IHRoaXMubWluWm9vbSkge1xuICAgIGlmICh0aGlzLnpvb21GYWN0b3JfID09PSAyKSB7XG4gICAgICB4ID0gTWF0aC5mbG9vcih4IC8gMik7XG4gICAgICB5ID0gTWF0aC5mbG9vcih5IC8gMik7XG4gICAgICB0aWxlUmFuZ2UgPSBjcmVhdGVPclVwZGF0ZVRpbGVSYW5nZSh4LCB4LCB5LCB5LCBvcHRfdGlsZVJhbmdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGlsZVJhbmdlID0gdGhpcy5nZXRUaWxlUmFuZ2VGb3JFeHRlbnRBbmRaKHRpbGVDb29yZEV4dGVudCwgeiwgb3B0X3RpbGVSYW5nZSk7XG4gICAgfVxuICAgIGlmIChjYWxsYmFjay5jYWxsKG9wdF90aGlzLCB6LCB0aWxlUmFuZ2UpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLS16O1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBleHRlbnQgZm9yIHRoaXMgdGlsZSBncmlkLCBpZiBpdCB3YXMgY29uZmlndXJlZC5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IEV4dGVudC5cbiAqL1xuVGlsZUdyaWQucHJvdG90eXBlLmdldEV4dGVudCA9IGZ1bmN0aW9uIGdldEV4dGVudCAoKSB7XG4gIHJldHVybiB0aGlzLmV4dGVudF87XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbWF4aW11bSB6b29tIGxldmVsIGZvciB0aGUgZ3JpZC5cbiAqIEByZXR1cm4ge251bWJlcn0gTWF4IHpvb20uXG4gKiBAYXBpXG4gKi9cblRpbGVHcmlkLnByb3RvdHlwZS5nZXRNYXhab29tID0gZnVuY3Rpb24gZ2V0TWF4Wm9vbSAoKSB7XG4gIHJldHVybiB0aGlzLm1heFpvb207XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbWluaW11bSB6b29tIGxldmVsIGZvciB0aGUgZ3JpZC5cbiAqIEByZXR1cm4ge251bWJlcn0gTWluIHpvb20uXG4gKiBAYXBpXG4gKi9cblRpbGVHcmlkLnByb3RvdHlwZS5nZXRNaW5ab29tID0gZnVuY3Rpb24gZ2V0TWluWm9vbSAoKSB7XG4gIHJldHVybiB0aGlzLm1pblpvb207XG59O1xuXG4vKipcbiAqIEdldCB0aGUgb3JpZ2luIGZvciB0aGUgZ3JpZCBhdCB0aGUgZ2l2ZW4gem9vbSBsZXZlbC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB6IEludGVnZXIgem9vbSBsZXZlbC5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gT3JpZ2luLlxuICogQGFwaVxuICovXG5UaWxlR3JpZC5wcm90b3R5cGUuZ2V0T3JpZ2luID0gZnVuY3Rpb24gZ2V0T3JpZ2luICh6KSB7XG4gIGlmICh0aGlzLm9yaWdpbl8pIHtcbiAgICByZXR1cm4gdGhpcy5vcmlnaW5fO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLm9yaWdpbnNfW3pdO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgcmVzb2x1dGlvbiBmb3IgdGhlIGdpdmVuIHpvb20gbGV2ZWwuXG4gKiBAcGFyYW0ge251bWJlcn0geiBJbnRlZ2VyIHpvb20gbGV2ZWwuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFJlc29sdXRpb24uXG4gKiBAYXBpXG4gKi9cblRpbGVHcmlkLnByb3RvdHlwZS5nZXRSZXNvbHV0aW9uID0gZnVuY3Rpb24gZ2V0UmVzb2x1dGlvbiAoeikge1xuICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uc19bel07XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbGlzdCBvZiByZXNvbHV0aW9ucyBmb3IgdGhlIHRpbGUgZ3JpZC5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFJlc29sdXRpb25zLlxuICogQGFwaVxuICovXG5UaWxlR3JpZC5wcm90b3R5cGUuZ2V0UmVzb2x1dGlvbnMgPSBmdW5jdGlvbiBnZXRSZXNvbHV0aW9ucyAoKSB7XG4gIHJldHVybiB0aGlzLnJlc29sdXRpb25zXztcbn07XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdD19IG9wdF90aWxlUmFuZ2UgVGVtcG9yYXJ5IGltcG9ydChcIi4uL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0IG9iamVjdC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudD19IG9wdF9leHRlbnQgVGVtcG9yYXJ5IGltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnQgb2JqZWN0LlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHR9IFRpbGUgcmFuZ2UuXG4gKi9cblRpbGVHcmlkLnByb3RvdHlwZS5nZXRUaWxlQ29vcmRDaGlsZFRpbGVSYW5nZSA9IGZ1bmN0aW9uIGdldFRpbGVDb29yZENoaWxkVGlsZVJhbmdlICh0aWxlQ29vcmQsIG9wdF90aWxlUmFuZ2UsIG9wdF9leHRlbnQpIHtcbiAgaWYgKHRpbGVDb29yZFswXSA8IHRoaXMubWF4Wm9vbSkge1xuICAgIGlmICh0aGlzLnpvb21GYWN0b3JfID09PSAyKSB7XG4gICAgICB2YXIgbWluWCA9IHRpbGVDb29yZFsxXSAqIDI7XG4gICAgICB2YXIgbWluWSA9IHRpbGVDb29yZFsyXSAqIDI7XG4gICAgICByZXR1cm4gY3JlYXRlT3JVcGRhdGVUaWxlUmFuZ2UobWluWCwgbWluWCArIDEsIG1pblksIG1pblkgKyAxLCBvcHRfdGlsZVJhbmdlKTtcbiAgICB9XG4gICAgdmFyIHRpbGVDb29yZEV4dGVudCA9IHRoaXMuZ2V0VGlsZUNvb3JkRXh0ZW50KHRpbGVDb29yZCwgb3B0X2V4dGVudCk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWihcbiAgICAgIHRpbGVDb29yZEV4dGVudCwgdGlsZUNvb3JkWzBdICsgMSwgb3B0X3RpbGVSYW5nZSk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgZXh0ZW50IGZvciBhIHRpbGUgcmFuZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0geiBJbnRlZ2VyIHpvb20gbGV2ZWwuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0fSB0aWxlUmFuZ2UgVGlsZSByYW5nZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudD19IG9wdF9leHRlbnQgVGVtcG9yYXJ5IGltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnQgb2JqZWN0LlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gRXh0ZW50LlxuICovXG5UaWxlR3JpZC5wcm90b3R5cGUuZ2V0VGlsZVJhbmdlRXh0ZW50ID0gZnVuY3Rpb24gZ2V0VGlsZVJhbmdlRXh0ZW50ICh6LCB0aWxlUmFuZ2UsIG9wdF9leHRlbnQpIHtcbiAgdmFyIG9yaWdpbiA9IHRoaXMuZ2V0T3JpZ2luKHopO1xuICB2YXIgcmVzb2x1dGlvbiA9IHRoaXMuZ2V0UmVzb2x1dGlvbih6KTtcbiAgdmFyIHRpbGVTaXplID0gdG9TaXplKHRoaXMuZ2V0VGlsZVNpemUoeiksIHRoaXMudG1wU2l6ZV8pO1xuICB2YXIgbWluWCA9IG9yaWdpblswXSArIHRpbGVSYW5nZS5taW5YICogdGlsZVNpemVbMF0gKiByZXNvbHV0aW9uO1xuICB2YXIgbWF4WCA9IG9yaWdpblswXSArICh0aWxlUmFuZ2UubWF4WCArIDEpICogdGlsZVNpemVbMF0gKiByZXNvbHV0aW9uO1xuICB2YXIgbWluWSA9IG9yaWdpblsxXSArIHRpbGVSYW5nZS5taW5ZICogdGlsZVNpemVbMV0gKiByZXNvbHV0aW9uO1xuICB2YXIgbWF4WSA9IG9yaWdpblsxXSArICh0aWxlUmFuZ2UubWF4WSArIDEpICogdGlsZVNpemVbMV0gKiByZXNvbHV0aW9uO1xuICByZXR1cm4gY3JlYXRlT3JVcGRhdGUobWluWCwgbWluWSwgbWF4WCwgbWF4WSwgb3B0X2V4dGVudCk7XG59O1xuXG4vKipcbiAqIEdldCBhIHRpbGUgcmFuZ2UgZm9yIHRoZSBnaXZlbiBleHRlbnQgYW5kIGludGVnZXIgem9vbSBsZXZlbC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB6IEludGVnZXIgem9vbSBsZXZlbC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHQ9fSBvcHRfdGlsZVJhbmdlIFRlbXBvcmFyeSB0aWxlIHJhbmdlIG9iamVjdC5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0fSBUaWxlIHJhbmdlLlxuICovXG5UaWxlR3JpZC5wcm90b3R5cGUuZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWiA9IGZ1bmN0aW9uIGdldFRpbGVSYW5nZUZvckV4dGVudEFuZFogKGV4dGVudCwgeiwgb3B0X3RpbGVSYW5nZSkge1xuICB2YXIgdGlsZUNvb3JkID0gdG1wVGlsZUNvb3JkO1xuICB0aGlzLmdldFRpbGVDb29yZEZvclhZQW5kWl8oZXh0ZW50WzBdLCBleHRlbnRbMV0sIHosIGZhbHNlLCB0aWxlQ29vcmQpO1xuICB2YXIgbWluWCA9IHRpbGVDb29yZFsxXTtcbiAgdmFyIG1pblkgPSB0aWxlQ29vcmRbMl07XG4gIHRoaXMuZ2V0VGlsZUNvb3JkRm9yWFlBbmRaXyhleHRlbnRbMl0sIGV4dGVudFszXSwgeiwgdHJ1ZSwgdGlsZUNvb3JkKTtcbiAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlVGlsZVJhbmdlKG1pblgsIHRpbGVDb29yZFsxXSwgbWluWSwgdGlsZUNvb3JkWzJdLCBvcHRfdGlsZVJhbmdlKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBUaWxlIGNlbnRlci5cbiAqL1xuVGlsZUdyaWQucHJvdG90eXBlLmdldFRpbGVDb29yZENlbnRlciA9IGZ1bmN0aW9uIGdldFRpbGVDb29yZENlbnRlciAodGlsZUNvb3JkKSB7XG4gIHZhciBvcmlnaW4gPSB0aGlzLmdldE9yaWdpbih0aWxlQ29vcmRbMF0pO1xuICB2YXIgcmVzb2x1dGlvbiA9IHRoaXMuZ2V0UmVzb2x1dGlvbih0aWxlQ29vcmRbMF0pO1xuICB2YXIgdGlsZVNpemUgPSB0b1NpemUodGhpcy5nZXRUaWxlU2l6ZSh0aWxlQ29vcmRbMF0pLCB0aGlzLnRtcFNpemVfKTtcbiAgcmV0dXJuIFtcbiAgICBvcmlnaW5bMF0gKyAodGlsZUNvb3JkWzFdICsgMC41KSAqIHRpbGVTaXplWzBdICogcmVzb2x1dGlvbixcbiAgICBvcmlnaW5bMV0gKyAodGlsZUNvb3JkWzJdICsgMC41KSAqIHRpbGVTaXplWzFdICogcmVzb2x1dGlvblxuICBdO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGV4dGVudCBvZiBhIHRpbGUgY29vcmRpbmF0ZS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnQ9fSBvcHRfZXh0ZW50IFRlbXBvcmFyeSBleHRlbnQgb2JqZWN0LlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gRXh0ZW50LlxuICogQGFwaVxuICovXG5UaWxlR3JpZC5wcm90b3R5cGUuZ2V0VGlsZUNvb3JkRXh0ZW50ID0gZnVuY3Rpb24gZ2V0VGlsZUNvb3JkRXh0ZW50ICh0aWxlQ29vcmQsIG9wdF9leHRlbnQpIHtcbiAgdmFyIG9yaWdpbiA9IHRoaXMuZ2V0T3JpZ2luKHRpbGVDb29yZFswXSk7XG4gIHZhciByZXNvbHV0aW9uID0gdGhpcy5nZXRSZXNvbHV0aW9uKHRpbGVDb29yZFswXSk7XG4gIHZhciB0aWxlU2l6ZSA9IHRvU2l6ZSh0aGlzLmdldFRpbGVTaXplKHRpbGVDb29yZFswXSksIHRoaXMudG1wU2l6ZV8pO1xuICB2YXIgbWluWCA9IG9yaWdpblswXSArIHRpbGVDb29yZFsxXSAqIHRpbGVTaXplWzBdICogcmVzb2x1dGlvbjtcbiAgdmFyIG1pblkgPSBvcmlnaW5bMV0gKyB0aWxlQ29vcmRbMl0gKiB0aWxlU2l6ZVsxXSAqIHJlc29sdXRpb247XG4gIHZhciBtYXhYID0gbWluWCArIHRpbGVTaXplWzBdICogcmVzb2x1dGlvbjtcbiAgdmFyIG1heFkgPSBtaW5ZICsgdGlsZVNpemVbMV0gKiByZXNvbHV0aW9uO1xuICByZXR1cm4gY3JlYXRlT3JVcGRhdGUobWluWCwgbWluWSwgbWF4WCwgbWF4WSwgb3B0X2V4dGVudCk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdGlsZSBjb29yZGluYXRlIGZvciB0aGUgZ2l2ZW4gbWFwIGNvb3JkaW5hdGUgYW5kIHJlc29sdXRpb24uVGhpc1xuICogbWV0aG9kIGNvbnNpZGVycyB0aGF0IGNvb3JkaW5hdGVzIHRoYXQgaW50ZXJzZWN0IHRpbGUgYm91bmRhcmllcyBzaG91bGQgYmVcbiAqIGFzc2lnbmVkIHRoZSBoaWdoZXIgdGlsZSBjb29yZGluYXRlLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkPX0gb3B0X3RpbGVDb29yZCBEZXN0aW5hdGlvbiBpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkIG9iamVjdC5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IFRpbGUgY29vcmRpbmF0ZS5cbiAqIEBhcGlcbiAqL1xuVGlsZUdyaWQucHJvdG90eXBlLmdldFRpbGVDb29yZEZvckNvb3JkQW5kUmVzb2x1dGlvbiA9IGZ1bmN0aW9uIGdldFRpbGVDb29yZEZvckNvb3JkQW5kUmVzb2x1dGlvbiAoY29vcmRpbmF0ZSwgcmVzb2x1dGlvbiwgb3B0X3RpbGVDb29yZCkge1xuICByZXR1cm4gdGhpcy5nZXRUaWxlQ29vcmRGb3JYWUFuZFJlc29sdXRpb25fKFxuICAgIGNvb3JkaW5hdGVbMF0sIGNvb3JkaW5hdGVbMV0sIHJlc29sdXRpb24sIGZhbHNlLCBvcHRfdGlsZUNvb3JkKTtcbn07XG5cbi8qKlxuICogTm90ZSB0aGF0IHRoaXMgbWV0aG9kIHNob3VsZCBub3QgYmUgY2FsbGVkIGZvciByZXNvbHV0aW9ucyB0aGF0IGNvcnJlc3BvbmRcbiAqIHRvIGFuIGludGVnZXIgem9vbSBsZXZlbC5JbnN0ZWFkIGNhbGwgdGhlIGBnZXRUaWxlQ29vcmRGb3JYWUFuZFpfYCBtZXRob2QuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24gKGZvciBhIG5vbi1pbnRlZ2VyIHpvb20gbGV2ZWwpLlxuICogQHBhcmFtIHtib29sZWFufSByZXZlcnNlSW50ZXJzZWN0aW9uUG9saWN5IEluc3RlYWQgb2YgbGV0dGluZyBlZGdlXG4gKiAgIGludGVyc2VjdGlvbnMgZ28gdG8gdGhlIGhpZ2hlciB0aWxlIGNvb3JkaW5hdGUsIGxldCBlZGdlIGludGVyc2VjdGlvbnNcbiAqICAgZ28gdG8gdGhlIGxvd2VyIHRpbGUgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZD19IG9wdF90aWxlQ29vcmQgVGVtcG9yYXJ5IGltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmQgb2JqZWN0LlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gVGlsZSBjb29yZGluYXRlLlxuICogQHByaXZhdGVcbiAqL1xuVGlsZUdyaWQucHJvdG90eXBlLmdldFRpbGVDb29yZEZvclhZQW5kUmVzb2x1dGlvbl8gPSBmdW5jdGlvbiBnZXRUaWxlQ29vcmRGb3JYWUFuZFJlc29sdXRpb25fICh4LCB5LCByZXNvbHV0aW9uLCByZXZlcnNlSW50ZXJzZWN0aW9uUG9saWN5LCBvcHRfdGlsZUNvb3JkKSB7XG4gIHZhciB6ID0gdGhpcy5nZXRaRm9yUmVzb2x1dGlvbihyZXNvbHV0aW9uKTtcbiAgdmFyIHNjYWxlID0gcmVzb2x1dGlvbiAvIHRoaXMuZ2V0UmVzb2x1dGlvbih6KTtcbiAgdmFyIG9yaWdpbiA9IHRoaXMuZ2V0T3JpZ2luKHopO1xuICB2YXIgdGlsZVNpemUgPSB0b1NpemUodGhpcy5nZXRUaWxlU2l6ZSh6KSwgdGhpcy50bXBTaXplXyk7XG5cbiAgdmFyIGFkanVzdFggPSByZXZlcnNlSW50ZXJzZWN0aW9uUG9saWN5ID8gMC41IDogMDtcbiAgdmFyIGFkanVzdFkgPSByZXZlcnNlSW50ZXJzZWN0aW9uUG9saWN5ID8gMCA6IDAuNTtcbiAgdmFyIHhGcm9tT3JpZ2luID0gTWF0aC5mbG9vcigoeCAtIG9yaWdpblswXSkgLyByZXNvbHV0aW9uICsgYWRqdXN0WCk7XG4gIHZhciB5RnJvbU9yaWdpbiA9IE1hdGguZmxvb3IoKHkgLSBvcmlnaW5bMV0pIC8gcmVzb2x1dGlvbiArIGFkanVzdFkpO1xuICB2YXIgdGlsZUNvb3JkWCA9IHNjYWxlICogeEZyb21PcmlnaW4gLyB0aWxlU2l6ZVswXTtcbiAgdmFyIHRpbGVDb29yZFkgPSBzY2FsZSAqIHlGcm9tT3JpZ2luIC8gdGlsZVNpemVbMV07XG5cbiAgaWYgKHJldmVyc2VJbnRlcnNlY3Rpb25Qb2xpY3kpIHtcbiAgICB0aWxlQ29vcmRYID0gTWF0aC5jZWlsKHRpbGVDb29yZFgpIC0gMTtcbiAgICB0aWxlQ29vcmRZID0gTWF0aC5jZWlsKHRpbGVDb29yZFkpIC0gMTtcbiAgfSBlbHNlIHtcbiAgICB0aWxlQ29vcmRYID0gTWF0aC5mbG9vcih0aWxlQ29vcmRYKTtcbiAgICB0aWxlQ29vcmRZID0gTWF0aC5mbG9vcih0aWxlQ29vcmRZKTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVPclVwZGF0ZVRpbGVDb29yZCh6LCB0aWxlQ29vcmRYLCB0aWxlQ29vcmRZLCBvcHRfdGlsZUNvb3JkKTtcbn07XG5cbi8qKlxuICogQWx0aG91Z2ggdGhlcmUgaXMgcmVwZXRpdGlvbiBiZXR3ZWVuIHRoaXMgbWV0aG9kIGFuZCBgZ2V0VGlsZUNvb3JkRm9yWFlBbmRSZXNvbHV0aW9uX2AsXG4gKiB0aGV5IHNob3VsZCBoYXZlIHNlcGFyYXRlIGltcGxlbWVudGF0aW9ucy5UaGlzIG1ldGhvZCBpcyBmb3IgaW50ZWdlciB6b29tXG4gKiBsZXZlbHMuVGhlIG90aGVyIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgZm9yIHJlc29sdXRpb25zIGNvcnJlc3BvbmRpbmdcbiAqIHRvIG5vbi1pbnRlZ2VyIHpvb20gbGV2ZWxzLlxuICogQHBhcmFtIHtudW1iZXJ9IHggTWFwIHggY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IE1hcCB5IGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0geiBJbnRlZ2VyIHpvb20gbGV2ZWwuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHJldmVyc2VJbnRlcnNlY3Rpb25Qb2xpY3kgSW5zdGVhZCBvZiBsZXR0aW5nIGVkZ2VcbiAqICAgaW50ZXJzZWN0aW9ucyBnbyB0byB0aGUgaGlnaGVyIHRpbGUgY29vcmRpbmF0ZSwgbGV0IGVkZ2UgaW50ZXJzZWN0aW9uc1xuICogICBnbyB0byB0aGUgbG93ZXIgdGlsZSBjb29yZGluYXRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkPX0gb3B0X3RpbGVDb29yZCBUZW1wb3JhcnkgaW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZCBvYmplY3QuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSBUaWxlIGNvb3JkaW5hdGUuXG4gKiBAcHJpdmF0ZVxuICovXG5UaWxlR3JpZC5wcm90b3R5cGUuZ2V0VGlsZUNvb3JkRm9yWFlBbmRaXyA9IGZ1bmN0aW9uIGdldFRpbGVDb29yZEZvclhZQW5kWl8gKHgsIHksIHosIHJldmVyc2VJbnRlcnNlY3Rpb25Qb2xpY3ksIG9wdF90aWxlQ29vcmQpIHtcbiAgdmFyIG9yaWdpbiA9IHRoaXMuZ2V0T3JpZ2luKHopO1xuICB2YXIgcmVzb2x1dGlvbiA9IHRoaXMuZ2V0UmVzb2x1dGlvbih6KTtcbiAgdmFyIHRpbGVTaXplID0gdG9TaXplKHRoaXMuZ2V0VGlsZVNpemUoeiksIHRoaXMudG1wU2l6ZV8pO1xuXG4gIHZhciBhZGp1c3RYID0gcmV2ZXJzZUludGVyc2VjdGlvblBvbGljeSA/IDAuNSA6IDA7XG4gIHZhciBhZGp1c3RZID0gcmV2ZXJzZUludGVyc2VjdGlvblBvbGljeSA/IDAgOiAwLjU7XG4gIHZhciB4RnJvbU9yaWdpbiA9IE1hdGguZmxvb3IoKHggLSBvcmlnaW5bMF0pIC8gcmVzb2x1dGlvbiArIGFkanVzdFgpO1xuICB2YXIgeUZyb21PcmlnaW4gPSBNYXRoLmZsb29yKCh5IC0gb3JpZ2luWzFdKSAvIHJlc29sdXRpb24gKyBhZGp1c3RZKTtcbiAgdmFyIHRpbGVDb29yZFggPSB4RnJvbU9yaWdpbiAvIHRpbGVTaXplWzBdO1xuICB2YXIgdGlsZUNvb3JkWSA9IHlGcm9tT3JpZ2luIC8gdGlsZVNpemVbMV07XG5cbiAgaWYgKHJldmVyc2VJbnRlcnNlY3Rpb25Qb2xpY3kpIHtcbiAgICB0aWxlQ29vcmRYID0gTWF0aC5jZWlsKHRpbGVDb29yZFgpIC0gMTtcbiAgICB0aWxlQ29vcmRZID0gTWF0aC5jZWlsKHRpbGVDb29yZFkpIC0gMTtcbiAgfSBlbHNlIHtcbiAgICB0aWxlQ29vcmRYID0gTWF0aC5mbG9vcih0aWxlQ29vcmRYKTtcbiAgICB0aWxlQ29vcmRZID0gTWF0aC5mbG9vcih0aWxlQ29vcmRZKTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVPclVwZGF0ZVRpbGVDb29yZCh6LCB0aWxlQ29vcmRYLCB0aWxlQ29vcmRZLCBvcHRfdGlsZUNvb3JkKTtcbn07XG5cbi8qKlxuICogR2V0IGEgdGlsZSBjb29yZGluYXRlIGdpdmVuIGEgbWFwIGNvb3JkaW5hdGUgYW5kIHpvb20gbGV2ZWwuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHogWm9vbSBsZXZlbC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZD19IG9wdF90aWxlQ29vcmQgRGVzdGluYXRpb24gaW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZCBvYmplY3QuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSBUaWxlIGNvb3JkaW5hdGUuXG4gKiBAYXBpXG4gKi9cblRpbGVHcmlkLnByb3RvdHlwZS5nZXRUaWxlQ29vcmRGb3JDb29yZEFuZFogPSBmdW5jdGlvbiBnZXRUaWxlQ29vcmRGb3JDb29yZEFuZFogKGNvb3JkaW5hdGUsIHosIG9wdF90aWxlQ29vcmQpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0VGlsZUNvb3JkRm9yWFlBbmRaXyhcbiAgICBjb29yZGluYXRlWzBdLCBjb29yZGluYXRlWzFdLCB6LCBmYWxzZSwgb3B0X3RpbGVDb29yZCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAqIEByZXR1cm4ge251bWJlcn0gVGlsZSByZXNvbHV0aW9uLlxuICovXG5UaWxlR3JpZC5wcm90b3R5cGUuZ2V0VGlsZUNvb3JkUmVzb2x1dGlvbiA9IGZ1bmN0aW9uIGdldFRpbGVDb29yZFJlc29sdXRpb24gKHRpbGVDb29yZCkge1xuICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uc19bdGlsZUNvb3JkWzBdXTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSB0aWxlIHNpemUgZm9yIGEgem9vbSBsZXZlbC4gVGhlIHR5cGUgb2YgdGhlIHJldHVybiB2YWx1ZSBtYXRjaGVzIHRoZVxuICogYHRpbGVTaXplYCBvciBgdGlsZVNpemVzYCB0aGF0IHRoZSB0aWxlIGdyaWQgd2FzIGNvbmZpZ3VyZWQgd2l0aC4gVG8gYWx3YXlzXG4gKiBnZXQgYW4gYGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZWAsIHJ1biB0aGUgcmVzdWx0IHRocm91Z2ggYGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZS50b1NpemUoKWAuXG4gKiBAcGFyYW0ge251bWJlcn0geiBaLlxuICogQHJldHVybiB7bnVtYmVyfGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gVGlsZSBzaXplLlxuICogQGFwaVxuICovXG5UaWxlR3JpZC5wcm90b3R5cGUuZ2V0VGlsZVNpemUgPSBmdW5jdGlvbiBnZXRUaWxlU2l6ZSAoeikge1xuICBpZiAodGhpcy50aWxlU2l6ZV8pIHtcbiAgICByZXR1cm4gdGhpcy50aWxlU2l6ZV87XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMudGlsZVNpemVzX1t6XTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0geiBab29tIGxldmVsLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHR9IEV4dGVudCB0aWxlIHJhbmdlIGZvciB0aGUgc3BlY2lmaWVkIHpvb20gbGV2ZWwuXG4gKi9cblRpbGVHcmlkLnByb3RvdHlwZS5nZXRGdWxsVGlsZVJhbmdlID0gZnVuY3Rpb24gZ2V0RnVsbFRpbGVSYW5nZSAoeikge1xuICBpZiAoIXRoaXMuZnVsbFRpbGVSYW5nZXNfKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMuZnVsbFRpbGVSYW5nZXNfW3pdO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9kaXJlY3Rpb24gSWYgMCwgdGhlIG5lYXJlc3QgcmVzb2x1dGlvbiB3aWxsIGJlIHVzZWQuXG4gKiAgIElmIDEsIHRoZSBuZWFyZXN0IGxvd2VyIHJlc29sdXRpb24gd2lsbCBiZSB1c2VkLiBJZiAtMSwgdGhlIG5lYXJlc3RcbiAqICAgaGlnaGVyIHJlc29sdXRpb24gd2lsbCBiZSB1c2VkLiBEZWZhdWx0IGlzIDAuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFouXG4gKiBAYXBpXG4gKi9cblRpbGVHcmlkLnByb3RvdHlwZS5nZXRaRm9yUmVzb2x1dGlvbiA9IGZ1bmN0aW9uIGdldFpGb3JSZXNvbHV0aW9uIChyZXNvbHV0aW9uLCBvcHRfZGlyZWN0aW9uKSB7XG4gIHZhciB6ID0gbGluZWFyRmluZE5lYXJlc3QodGhpcy5yZXNvbHV0aW9uc18sIHJlc29sdXRpb24sIG9wdF9kaXJlY3Rpb24gfHwgMCk7XG4gIHJldHVybiBjbGFtcCh6LCB0aGlzLm1pblpvb20sIHRoaXMubWF4Wm9vbSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7IWltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQgZm9yIHRoaXMgdGlsZSBncmlkLlxuICogQHByaXZhdGVcbiAqL1xuVGlsZUdyaWQucHJvdG90eXBlLmNhbGN1bGF0ZVRpbGVSYW5nZXNfID0gZnVuY3Rpb24gY2FsY3VsYXRlVGlsZVJhbmdlc18gKGV4dGVudCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5yZXNvbHV0aW9uc18ubGVuZ3RoO1xuICB2YXIgZnVsbFRpbGVSYW5nZXMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgZm9yICh2YXIgeiA9IHRoaXMubWluWm9vbTsgeiA8IGxlbmd0aDsgKyt6KSB7XG4gICAgZnVsbFRpbGVSYW5nZXNbel0gPSB0aGlzLmdldFRpbGVSYW5nZUZvckV4dGVudEFuZFooZXh0ZW50LCB6KTtcbiAgfVxuICB0aGlzLmZ1bGxUaWxlUmFuZ2VzXyA9IGZ1bGxUaWxlUmFuZ2VzO1xufTtcblxuXG5leHBvcnQgZGVmYXVsdCBUaWxlR3JpZDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGlsZUdyaWQuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3RpbGVncmlkL2NvbW1vblxuICovXG5cbi8qKlxuICogRGVmYXVsdCBtYXhpbXVtIHpvb20gZm9yIGRlZmF1bHQgdGlsZSBncmlkcy5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgREVGQVVMVF9NQVhfWk9PTSA9IDQyO1xuXG4vKipcbiAqIERlZmF1bHQgdGlsZSBzaXplLlxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBERUZBVUxUX1RJTEVfU0laRSA9IDI1NjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tbW9uLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC90aWxldXJsZnVuY3Rpb25cbiAqL1xuaW1wb3J0IHthc3NlcnR9IGZyb20gJy4vYXNzZXJ0cy5qcyc7XG5pbXBvcnQge21vZHVsb30gZnJvbSAnLi9tYXRoLmpzJztcbmltcG9ydCB7aGFzaCBhcyB0aWxlQ29vcmRIYXNofSBmcm9tICcuL3RpbGVjb29yZC5qcyc7XG5cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGVtcGxhdGUgVGVtcGxhdGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH0gdGlsZUdyaWQgVGlsZSBncmlkLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9UaWxlLmpzXCIpLlVybEZ1bmN0aW9ufSBUaWxlIFVSTCBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZyb21UZW1wbGF0ZSh0ZW1wbGF0ZSwgdGlsZUdyaWQpIHtcbiAgdmFyIHpSZWdFeCA9IC9cXHt6XFx9L2c7XG4gIHZhciB4UmVnRXggPSAvXFx7eFxcfS9nO1xuICB2YXIgeVJlZ0V4ID0gL1xce3lcXH0vZztcbiAgdmFyIGRhc2hZUmVnRXggPSAvXFx7LXlcXH0vZztcbiAgcmV0dXJuIChcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgQ29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfSBUaWxlIFVSTC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbih0aWxlQ29vcmQsIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pIHtcbiAgICAgIGlmICghdGlsZUNvb3JkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGVtcGxhdGUucmVwbGFjZSh6UmVnRXgsIHRpbGVDb29yZFswXS50b1N0cmluZygpKVxuICAgICAgICAgIC5yZXBsYWNlKHhSZWdFeCwgdGlsZUNvb3JkWzFdLnRvU3RyaW5nKCkpXG4gICAgICAgICAgLnJlcGxhY2UoeVJlZ0V4LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB5ID0gLXRpbGVDb29yZFsyXSAtIDE7XG4gICAgICAgICAgICByZXR1cm4geS50b1N0cmluZygpO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnJlcGxhY2UoZGFzaFlSZWdFeCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgeiA9IHRpbGVDb29yZFswXTtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IHRpbGVHcmlkLmdldEZ1bGxUaWxlUmFuZ2Uoeik7XG4gICAgICAgICAgICBhc3NlcnQocmFuZ2UsIDU1KTsgLy8gVGhlIHsteX0gcGxhY2Vob2xkZXIgcmVxdWlyZXMgYSB0aWxlIGdyaWQgd2l0aCBleHRlbnRcbiAgICAgICAgICAgIHZhciB5ID0gcmFuZ2UuZ2V0SGVpZ2h0KCkgKyB0aWxlQ29vcmRbMl07XG4gICAgICAgICAgICByZXR1cm4geS50b1N0cmluZygpO1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gdGVtcGxhdGVzIFRlbXBsYXRlcy5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSB0aWxlR3JpZCBUaWxlIGdyaWQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL1RpbGUuanNcIikuVXJsRnVuY3Rpb259IFRpbGUgVVJMIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRnJvbVRlbXBsYXRlcyh0ZW1wbGF0ZXMsIHRpbGVHcmlkKSB7XG4gIHZhciBsZW4gPSB0ZW1wbGF0ZXMubGVuZ3RoO1xuICB2YXIgdGlsZVVybEZ1bmN0aW9ucyA9IG5ldyBBcnJheShsZW4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdGlsZVVybEZ1bmN0aW9uc1tpXSA9IGNyZWF0ZUZyb21UZW1wbGF0ZSh0ZW1wbGF0ZXNbaV0sIHRpbGVHcmlkKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlRnJvbVRpbGVVcmxGdW5jdGlvbnModGlsZVVybEZ1bmN0aW9ucyk7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4vVGlsZS5qc1wiKS5VcmxGdW5jdGlvbj59IHRpbGVVcmxGdW5jdGlvbnMgVGlsZSBVUkwgRnVuY3Rpb25zLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9UaWxlLmpzXCIpLlVybEZ1bmN0aW9ufSBUaWxlIFVSTCBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZyb21UaWxlVXJsRnVuY3Rpb25zKHRpbGVVcmxGdW5jdGlvbnMpIHtcbiAgaWYgKHRpbGVVcmxGdW5jdGlvbnMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHRpbGVVcmxGdW5jdGlvbnNbMF07XG4gIH1cbiAgcmV0dXJuIChcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgQ29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfSBUaWxlIFVSTC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbih0aWxlQ29vcmQsIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pIHtcbiAgICAgIGlmICghdGlsZUNvb3JkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaCA9IHRpbGVDb29yZEhhc2godGlsZUNvb3JkKTtcbiAgICAgICAgdmFyIGluZGV4ID0gbW9kdWxvKGgsIHRpbGVVcmxGdW5jdGlvbnMubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHRpbGVVcmxGdW5jdGlvbnNbaW5kZXhdKHRpbGVDb29yZCwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbik7XG4gICAgICB9XG4gICAgfVxuICApO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0gVGlsZSBVUkwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBudWxsVGlsZVVybEZ1bmN0aW9uKHRpbGVDb29yZCwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbikge1xuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBVUkwuXG4gKiBAcmV0dXJuIHtBcnJheTxzdHJpbmc+fSBBcnJheSBvZiB1cmxzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kVXJsKHVybCkge1xuICB2YXIgdXJscyA9IFtdO1xuICB2YXIgbWF0Y2ggPSAvXFx7KFthLXpdKS0oW2Etel0pXFx9Ly5leGVjKHVybCk7XG4gIGlmIChtYXRjaCkge1xuICAgIC8vIGNoYXIgcmFuZ2VcbiAgICB2YXIgc3RhcnRDaGFyQ29kZSA9IG1hdGNoWzFdLmNoYXJDb2RlQXQoMCk7XG4gICAgdmFyIHN0b3BDaGFyQ29kZSA9IG1hdGNoWzJdLmNoYXJDb2RlQXQoMCk7XG4gICAgdmFyIGNoYXJDb2RlO1xuICAgIGZvciAoY2hhckNvZGUgPSBzdGFydENoYXJDb2RlOyBjaGFyQ29kZSA8PSBzdG9wQ2hhckNvZGU7ICsrY2hhckNvZGUpIHtcbiAgICAgIHVybHMucHVzaCh1cmwucmVwbGFjZShtYXRjaFswXSwgU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHVybHM7XG4gIH1cbiAgbWF0Y2ggPSBtYXRjaCA9IC9cXHsoXFxkKyktKFxcZCspXFx9Ly5leGVjKHVybCk7XG4gIGlmIChtYXRjaCkge1xuICAgIC8vIG51bWJlciByYW5nZVxuICAgIHZhciBzdG9wID0gcGFyc2VJbnQobWF0Y2hbMl0sIDEwKTtcbiAgICBmb3IgKHZhciBpID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTsgaSA8PSBzdG9wOyBpKyspIHtcbiAgICAgIHVybHMucHVzaCh1cmwucmVwbGFjZShtYXRjaFswXSwgaS50b1N0cmluZygpKSk7XG4gICAgfVxuICAgIHJldHVybiB1cmxzO1xuICB9XG4gIHVybHMucHVzaCh1cmwpO1xuICByZXR1cm4gdXJscztcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGlsZXVybGZ1bmN0aW9uLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC90cmFuc2Zvcm1cbiAqL1xuaW1wb3J0IHthc3NlcnR9IGZyb20gJy4vYXNzZXJ0cy5qcyc7XG5cblxuLyoqXG4gKiBBbiBhcnJheSByZXByZXNlbnRpbmcgYW4gYWZmaW5lIDJkIHRyYW5zZm9ybWF0aW9uIGZvciB1c2Ugd2l0aFxuICoge0BsaW5rIG1vZHVsZTpvbC90cmFuc2Zvcm19IGZ1bmN0aW9ucy4gVGhlIGFycmF5IGhhcyA2IGVsZW1lbnRzLlxuICogQHR5cGVkZWYgeyFBcnJheTxudW1iZXI+fSBUcmFuc2Zvcm1cbiAqL1xuXG5cbi8qKlxuICogQ29sbGVjdGlvbiBvZiBhZmZpbmUgMmQgdHJhbnNmb3JtYXRpb24gZnVuY3Rpb25zLiBUaGUgZnVuY3Rpb25zIHdvcmsgb24gYW5cbiAqIGFycmF5IG9mIDYgZWxlbWVudHMuIFRoZSBlbGVtZW50IG9yZGVyIGlzIGNvbXBhdGlibGUgd2l0aCB0aGUgW1NWR01hdHJpeFxuICogaW50ZXJmYWNlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU1ZHTWF0cml4KSBhbmQgaXNcbiAqIGEgc3Vic2V0IChlbGVtZW50cyBhIHRvIGYpIG9mIGEgM8OXMyBtYXRyaXg6XG4gKiBgYGBcbiAqIFsgYSBjIGUgXVxuICogWyBiIGQgZiBdXG4gKiBbIDAgMCAxIF1cbiAqIGBgYFxuICovXG5cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHR5cGUge1RyYW5zZm9ybX1cbiAqL1xudmFyIHRtcF8gPSBuZXcgQXJyYXkoNik7XG5cblxuLyoqXG4gKiBDcmVhdGUgYW4gaWRlbnRpdHkgdHJhbnNmb3JtLlxuICogQHJldHVybiB7IVRyYW5zZm9ybX0gSWRlbnRpdHkgdHJhbnNmb3JtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKCkge1xuICByZXR1cm4gWzEsIDAsIDAsIDEsIDAsIDBdO1xufVxuXG5cbi8qKlxuICogUmVzZXRzIHRoZSBnaXZlbiB0cmFuc2Zvcm0gdG8gYW4gaWRlbnRpdHkgdHJhbnNmb3JtLlxuICogQHBhcmFtIHshVHJhbnNmb3JtfSB0cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICogQHJldHVybiB7IVRyYW5zZm9ybX0gVHJhbnNmb3JtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzZXQodHJhbnNmb3JtKSB7XG4gIHJldHVybiBzZXQodHJhbnNmb3JtLCAxLCAwLCAwLCAxLCAwLCAwKTtcbn1cblxuXG4vKipcbiAqIE11bHRpcGx5IHRoZSB1bmRlcmx5aW5nIG1hdHJpY2VzIG9mIHR3byB0cmFuc2Zvcm1zIGFuZCByZXR1cm4gdGhlIHJlc3VsdCBpblxuICogdGhlIGZpcnN0IHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gdHJhbnNmb3JtMSBUcmFuc2Zvcm0gcGFyYW1ldGVycyBvZiBtYXRyaXggMS5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gdHJhbnNmb3JtMiBUcmFuc2Zvcm0gcGFyYW1ldGVycyBvZiBtYXRyaXggMi5cbiAqIEByZXR1cm4geyFUcmFuc2Zvcm19IHRyYW5zZm9ybTEgbXVsdGlwbGllZCB3aXRoIHRyYW5zZm9ybTIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseSh0cmFuc2Zvcm0xLCB0cmFuc2Zvcm0yKSB7XG4gIHZhciBhMSA9IHRyYW5zZm9ybTFbMF07XG4gIHZhciBiMSA9IHRyYW5zZm9ybTFbMV07XG4gIHZhciBjMSA9IHRyYW5zZm9ybTFbMl07XG4gIHZhciBkMSA9IHRyYW5zZm9ybTFbM107XG4gIHZhciBlMSA9IHRyYW5zZm9ybTFbNF07XG4gIHZhciBmMSA9IHRyYW5zZm9ybTFbNV07XG4gIHZhciBhMiA9IHRyYW5zZm9ybTJbMF07XG4gIHZhciBiMiA9IHRyYW5zZm9ybTJbMV07XG4gIHZhciBjMiA9IHRyYW5zZm9ybTJbMl07XG4gIHZhciBkMiA9IHRyYW5zZm9ybTJbM107XG4gIHZhciBlMiA9IHRyYW5zZm9ybTJbNF07XG4gIHZhciBmMiA9IHRyYW5zZm9ybTJbNV07XG5cbiAgdHJhbnNmb3JtMVswXSA9IGExICogYTIgKyBjMSAqIGIyO1xuICB0cmFuc2Zvcm0xWzFdID0gYjEgKiBhMiArIGQxICogYjI7XG4gIHRyYW5zZm9ybTFbMl0gPSBhMSAqIGMyICsgYzEgKiBkMjtcbiAgdHJhbnNmb3JtMVszXSA9IGIxICogYzIgKyBkMSAqIGQyO1xuICB0cmFuc2Zvcm0xWzRdID0gYTEgKiBlMiArIGMxICogZjIgKyBlMTtcbiAgdHJhbnNmb3JtMVs1XSA9IGIxICogZTIgKyBkMSAqIGYyICsgZjE7XG5cbiAgcmV0dXJuIHRyYW5zZm9ybTE7XG59XG5cbi8qKlxuICogU2V0IHRoZSB0cmFuc2Zvcm0gY29tcG9uZW50cyBhLWYgb24gYSBnaXZlbiB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0geyFUcmFuc2Zvcm19IHRyYW5zZm9ybSBUcmFuc2Zvcm0uXG4gKiBAcGFyYW0ge251bWJlcn0gYSBUaGUgYSBjb21wb25lbnQgb2YgdGhlIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFRoZSBiIGNvbXBvbmVudCBvZiB0aGUgdHJhbnNmb3JtLlxuICogQHBhcmFtIHtudW1iZXJ9IGMgVGhlIGMgY29tcG9uZW50IG9mIHRoZSB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0ge251bWJlcn0gZCBUaGUgZCBjb21wb25lbnQgb2YgdGhlIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlIFRoZSBlIGNvbXBvbmVudCBvZiB0aGUgdHJhbnNmb3JtLlxuICogQHBhcmFtIHtudW1iZXJ9IGYgVGhlIGYgY29tcG9uZW50IG9mIHRoZSB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJuIHshVHJhbnNmb3JtfSBNYXRyaXggd2l0aCB0cmFuc2Zvcm0gYXBwbGllZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldCh0cmFuc2Zvcm0sIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgdHJhbnNmb3JtWzBdID0gYTtcbiAgdHJhbnNmb3JtWzFdID0gYjtcbiAgdHJhbnNmb3JtWzJdID0gYztcbiAgdHJhbnNmb3JtWzNdID0gZDtcbiAgdHJhbnNmb3JtWzRdID0gZTtcbiAgdHJhbnNmb3JtWzVdID0gZjtcbiAgcmV0dXJuIHRyYW5zZm9ybTtcbn1cblxuXG4vKipcbiAqIFNldCB0cmFuc2Zvcm0gb24gb25lIG1hdHJpeCBmcm9tIGFub3RoZXIgbWF0cml4LlxuICogQHBhcmFtIHshVHJhbnNmb3JtfSB0cmFuc2Zvcm0xIE1hdHJpeCB0byBzZXQgdHJhbnNmb3JtIHRvLlxuICogQHBhcmFtIHshVHJhbnNmb3JtfSB0cmFuc2Zvcm0yIE1hdHJpeCB0byBzZXQgdHJhbnNmb3JtIGZyb20uXG4gKiBAcmV0dXJuIHshVHJhbnNmb3JtfSB0cmFuc2Zvcm0xIHdpdGggdHJhbnNmb3JtIGZyb20gdHJhbnNmb3JtMiBhcHBsaWVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0RnJvbUFycmF5KHRyYW5zZm9ybTEsIHRyYW5zZm9ybTIpIHtcbiAgdHJhbnNmb3JtMVswXSA9IHRyYW5zZm9ybTJbMF07XG4gIHRyYW5zZm9ybTFbMV0gPSB0cmFuc2Zvcm0yWzFdO1xuICB0cmFuc2Zvcm0xWzJdID0gdHJhbnNmb3JtMlsyXTtcbiAgdHJhbnNmb3JtMVszXSA9IHRyYW5zZm9ybTJbM107XG4gIHRyYW5zZm9ybTFbNF0gPSB0cmFuc2Zvcm0yWzRdO1xuICB0cmFuc2Zvcm0xWzVdID0gdHJhbnNmb3JtMls1XTtcbiAgcmV0dXJuIHRyYW5zZm9ybTE7XG59XG5cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSBnaXZlbiBjb29yZGluYXRlIHdpdGggdGhlIGdpdmVuIHRyYW5zZm9ybSByZXR1cm5pbmcgdGhlXG4gKiByZXN1bHRpbmcsIHRyYW5zZm9ybWVkIGNvb3JkaW5hdGUuIFRoZSBjb29yZGluYXRlIHdpbGwgYmUgbW9kaWZpZWQgaW4tcGxhY2UuXG4gKlxuICogQHBhcmFtIHtUcmFuc2Zvcm19IHRyYW5zZm9ybSBUaGUgdHJhbnNmb3JtYXRpb24uXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfGltcG9ydChcIi4vcGl4ZWwuanNcIikuUGl4ZWx9IGNvb3JkaW5hdGUgVGhlIGNvb3JkaW5hdGUgdG8gdHJhbnNmb3JtLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8aW1wb3J0KFwiLi9waXhlbC5qc1wiKS5QaXhlbH0gcmV0dXJuIGNvb3JkaW5hdGUgc28gdGhhdCBvcGVyYXRpb25zIGNhbiBiZVxuICogICAgIGNoYWluZWQgdG9nZXRoZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseSh0cmFuc2Zvcm0sIGNvb3JkaW5hdGUpIHtcbiAgdmFyIHggPSBjb29yZGluYXRlWzBdO1xuICB2YXIgeSA9IGNvb3JkaW5hdGVbMV07XG4gIGNvb3JkaW5hdGVbMF0gPSB0cmFuc2Zvcm1bMF0gKiB4ICsgdHJhbnNmb3JtWzJdICogeSArIHRyYW5zZm9ybVs0XTtcbiAgY29vcmRpbmF0ZVsxXSA9IHRyYW5zZm9ybVsxXSAqIHggKyB0cmFuc2Zvcm1bM10gKiB5ICsgdHJhbnNmb3JtWzVdO1xuICByZXR1cm4gY29vcmRpbmF0ZTtcbn1cblxuXG4vKipcbiAqIEFwcGxpZXMgcm90YXRpb24gdG8gdGhlIGdpdmVuIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSBBbmdsZSBpbiByYWRpYW5zLlxuICogQHJldHVybiB7IVRyYW5zZm9ybX0gVGhlIHJvdGF0ZWQgdHJhbnNmb3JtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKHRyYW5zZm9ybSwgYW5nbGUpIHtcbiAgdmFyIGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgdmFyIHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgcmV0dXJuIG11bHRpcGx5KHRyYW5zZm9ybSwgc2V0KHRtcF8sIGNvcywgc2luLCAtc2luLCBjb3MsIDAsIDApKTtcbn1cblxuXG4vKipcbiAqIEFwcGxpZXMgc2NhbGUgdG8gYSBnaXZlbiB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0geyFUcmFuc2Zvcm19IHRyYW5zZm9ybSBUcmFuc2Zvcm0uXG4gKiBAcGFyYW0ge251bWJlcn0geCBTY2FsZSBmYWN0b3IgeC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFNjYWxlIGZhY3RvciB5LlxuICogQHJldHVybiB7IVRyYW5zZm9ybX0gVGhlIHNjYWxlZCB0cmFuc2Zvcm0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZSh0cmFuc2Zvcm0sIHgsIHkpIHtcbiAgcmV0dXJuIG11bHRpcGx5KHRyYW5zZm9ybSwgc2V0KHRtcF8sIHgsIDAsIDAsIHksIDAsIDApKTtcbn1cblxuXG4vKipcbiAqIEFwcGxpZXMgdHJhbnNsYXRpb24gdG8gdGhlIGdpdmVuIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkeCBUcmFuc2xhdGlvbiB4LlxuICogQHBhcmFtIHtudW1iZXJ9IGR5IFRyYW5zbGF0aW9uIHkuXG4gKiBAcmV0dXJuIHshVHJhbnNmb3JtfSBUaGUgdHJhbnNsYXRlZCB0cmFuc2Zvcm0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2xhdGUodHJhbnNmb3JtLCBkeCwgZHkpIHtcbiAgcmV0dXJuIG11bHRpcGx5KHRyYW5zZm9ybSwgc2V0KHRtcF8sIDEsIDAsIDAsIDEsIGR4LCBkeSkpO1xufVxuXG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvbXBvc2l0ZSB0cmFuc2Zvcm0gZ2l2ZW4gYW4gaW5pdGlhbCB0cmFuc2xhdGlvbiwgc2NhbGUsIHJvdGF0aW9uLCBhbmRcbiAqIGZpbmFsIHRyYW5zbGF0aW9uIChpbiB0aGF0IG9yZGVyIG9ubHksIG5vdCBjb21tdXRhdGl2ZSkuXG4gKiBAcGFyYW0geyFUcmFuc2Zvcm19IHRyYW5zZm9ybSBUaGUgdHJhbnNmb3JtICh3aWxsIGJlIG1vZGlmaWVkIGluIHBsYWNlKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkeDEgSW5pdGlhbCB0cmFuc2xhdGlvbiB4LlxuICogQHBhcmFtIHtudW1iZXJ9IGR5MSBJbml0aWFsIHRyYW5zbGF0aW9uIHkuXG4gKiBAcGFyYW0ge251bWJlcn0gc3ggU2NhbGUgZmFjdG9yIHguXG4gKiBAcGFyYW0ge251bWJlcn0gc3kgU2NhbGUgZmFjdG9yIHkuXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGUgUm90YXRpb24gKGluIGNvdW50ZXItY2xvY2t3aXNlIHJhZGlhbnMpLlxuICogQHBhcmFtIHtudW1iZXJ9IGR4MiBGaW5hbCB0cmFuc2xhdGlvbiB4LlxuICogQHBhcmFtIHtudW1iZXJ9IGR5MiBGaW5hbCB0cmFuc2xhdGlvbiB5LlxuICogQHJldHVybiB7IVRyYW5zZm9ybX0gVGhlIGNvbXBvc2l0ZSB0cmFuc2Zvcm0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wb3NlKHRyYW5zZm9ybSwgZHgxLCBkeTEsIHN4LCBzeSwgYW5nbGUsIGR4MiwgZHkyKSB7XG4gIHZhciBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG4gIHZhciBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG4gIHRyYW5zZm9ybVswXSA9IHN4ICogY29zO1xuICB0cmFuc2Zvcm1bMV0gPSBzeSAqIHNpbjtcbiAgdHJhbnNmb3JtWzJdID0gLXN4ICogc2luO1xuICB0cmFuc2Zvcm1bM10gPSBzeSAqIGNvcztcbiAgdHJhbnNmb3JtWzRdID0gZHgyICogc3ggKiBjb3MgLSBkeTIgKiBzeCAqIHNpbiArIGR4MTtcbiAgdHJhbnNmb3JtWzVdID0gZHgyICogc3kgKiBzaW4gKyBkeTIgKiBzeSAqIGNvcyArIGR5MTtcbiAgcmV0dXJuIHRyYW5zZm9ybTtcbn1cblxuXG4vKipcbiAqIEludmVydCB0aGUgZ2l2ZW4gdHJhbnNmb3JtLlxuICogQHBhcmFtIHshVHJhbnNmb3JtfSB0cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICogQHJldHVybiB7IVRyYW5zZm9ybX0gSW52ZXJzZSBvZiB0aGUgdHJhbnNmb3JtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KHRyYW5zZm9ybSkge1xuICB2YXIgZGV0ID0gZGV0ZXJtaW5hbnQodHJhbnNmb3JtKTtcbiAgYXNzZXJ0KGRldCAhPT0gMCwgMzIpOyAvLyBUcmFuc2Zvcm1hdGlvbiBtYXRyaXggY2Fubm90IGJlIGludmVydGVkXG5cbiAgdmFyIGEgPSB0cmFuc2Zvcm1bMF07XG4gIHZhciBiID0gdHJhbnNmb3JtWzFdO1xuICB2YXIgYyA9IHRyYW5zZm9ybVsyXTtcbiAgdmFyIGQgPSB0cmFuc2Zvcm1bM107XG4gIHZhciBlID0gdHJhbnNmb3JtWzRdO1xuICB2YXIgZiA9IHRyYW5zZm9ybVs1XTtcblxuICB0cmFuc2Zvcm1bMF0gPSBkIC8gZGV0O1xuICB0cmFuc2Zvcm1bMV0gPSAtYiAvIGRldDtcbiAgdHJhbnNmb3JtWzJdID0gLWMgLyBkZXQ7XG4gIHRyYW5zZm9ybVszXSA9IGEgLyBkZXQ7XG4gIHRyYW5zZm9ybVs0XSA9IChjICogZiAtIGQgKiBlKSAvIGRldDtcbiAgdHJhbnNmb3JtWzVdID0gLShhICogZiAtIGIgKiBlKSAvIGRldDtcblxuICByZXR1cm4gdHJhbnNmb3JtO1xufVxuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgZGV0ZXJtaW5hbnQgb2YgdGhlIGdpdmVuIG1hdHJpeC5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gbWF0IE1hdHJpeC5cbiAqIEByZXR1cm4ge251bWJlcn0gRGV0ZXJtaW5hbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmFudChtYXQpIHtcbiAgcmV0dXJuIG1hdFswXSAqIG1hdFszXSAtIG1hdFsxXSAqIG1hdFsyXTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNmb3JtLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC91dGlsXG4gKi9cblxuLyoqXG4gKiBAcmV0dXJuIHs/fSBBbnkgcmV0dXJuLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWJzdHJhY3QoKSB7XG4gIHJldHVybiAvKiogQHR5cGUgez99ICovICgoZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmltcGxlbWVudGVkIGFic3RyYWN0IG1ldGhvZC4nKTtcbiAgfSkoKSk7XG59XG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFVzYWdlOlxuICpcbiAqICAgICBmdW5jdGlvbiBQYXJlbnRDbGFzcyhhLCBiKSB7IH1cbiAqICAgICBQYXJlbnRDbGFzcy5wcm90b3R5cGUuZm9vID0gZnVuY3Rpb24oYSkgeyB9XG4gKlxuICogICAgIGZ1bmN0aW9uIENoaWxkQ2xhc3MoYSwgYiwgYykge1xuICogICAgICAgLy8gQ2FsbCBwYXJlbnQgY29uc3RydWN0b3JcbiAqICAgICAgIFBhcmVudENsYXNzLmNhbGwodGhpcywgYSwgYik7XG4gKiAgICAgfVxuICogICAgIGluaGVyaXRzKENoaWxkQ2xhc3MsIFBhcmVudENsYXNzKTtcbiAqXG4gKiAgICAgdmFyIGNoaWxkID0gbmV3IENoaWxkQ2xhc3MoJ2EnLCAnYicsICdzZWUnKTtcbiAqICAgICBjaGlsZC5mb28oKTsgLy8gVGhpcyB3b3Jrcy5cbiAqXG4gKiBAcGFyYW0geyFGdW5jdGlvbn0gY2hpbGRDdG9yIENoaWxkIGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHshRnVuY3Rpb259IHBhcmVudEN0b3IgUGFyZW50IGNvbnN0cnVjdG9yLlxuICogQGZ1bmN0aW9uIG1vZHVsZTpvbC5pbmhlcml0c1xuICogQGRlcHJlY2F0ZWRcbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaGVyaXRzKGNoaWxkQ3RvciwgcGFyZW50Q3Rvcikge1xuICBjaGlsZEN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRDdG9yLnByb3RvdHlwZSk7XG4gIGNoaWxkQ3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjaGlsZEN0b3I7XG59XG5cbi8qKlxuICogQ291bnRlciBmb3IgZ2V0VWlkLlxuICogQHR5cGUge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciB1aWRDb3VudGVyXyA9IDA7XG5cbi8qKlxuICogR2V0cyBhIHVuaXF1ZSBJRCBmb3IgYW4gb2JqZWN0LiBUaGlzIG11dGF0ZXMgdGhlIG9iamVjdCBzbyB0aGF0IGZ1cnRoZXIgY2FsbHNcbiAqIHdpdGggdGhlIHNhbWUgb2JqZWN0IGFzIGEgcGFyYW1ldGVyIHJldHVybnMgdGhlIHNhbWUgdmFsdWUuIFVuaXF1ZSBJRHMgYXJlIGdlbmVyYXRlZFxuICogYXMgYSBzdHJpY3RseSBpbmNyZWFzaW5nIHNlcXVlbmNlLiBBZGFwdGVkIGZyb20gZ29vZy5nZXRVaWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGdldCB0aGUgdW5pcXVlIElEIGZvci5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHVuaXF1ZSBJRCBmb3IgdGhlIG9iamVjdC5cbiAqIEBmdW5jdGlvbiBtb2R1bGU6b2wuZ2V0VWlkXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVaWQob2JqKSB7XG4gIHJldHVybiBvYmoub2xfdWlkIHx8IChvYmoub2xfdWlkID0gU3RyaW5nKCsrdWlkQ291bnRlcl8pKTtcbn1cblxuLyoqXG4gKiBPcGVuTGF5ZXJzIHZlcnNpb24uXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgdmFyIFZFUlNJT04gPSAnNS4zLjMnO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC93ZWJnbFxuICovXG5cblxuLyoqXG4gKiBDb25zdGFudHMgdGFrZW4gZnJvbSBnb29nLndlYmdsXG4gKi9cblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBPTkUgPSAxO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIFNSQ19BTFBIQSA9IDB4MDMwMjtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBDT0xPUl9BVFRBQ0hNRU5UMCA9IDB4OENFMDtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBDT0xPUl9CVUZGRVJfQklUID0gMHgwMDAwNDAwMDtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBUUklBTkdMRVMgPSAweDAwMDQ7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgVFJJQU5HTEVfU1RSSVAgPSAweDAwMDU7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgT05FX01JTlVTX1NSQ19BTFBIQSA9IDB4MDMwMztcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBBUlJBWV9CVUZGRVIgPSAweDg4OTI7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgRUxFTUVOVF9BUlJBWV9CVUZGRVIgPSAweDg4OTM7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgU1RSRUFNX0RSQVcgPSAweDg4RTA7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgU1RBVElDX0RSQVcgPSAweDg4RTQ7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgRFlOQU1JQ19EUkFXID0gMHg4OEU4O1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIENVTExfRkFDRSA9IDB4MEI0NDtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBCTEVORCA9IDB4MEJFMjtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBTVEVOQ0lMX1RFU1QgPSAweDBCOTA7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgREVQVEhfVEVTVCA9IDB4MEI3MTtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBTQ0lTU09SX1RFU1QgPSAweDBDMTE7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgVU5TSUdORURfQllURSA9IDB4MTQwMTtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBVTlNJR05FRF9TSE9SVCA9IDB4MTQwMztcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBVTlNJR05FRF9JTlQgPSAweDE0MDU7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgRkxPQVQgPSAweDE0MDY7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgUkdCQSA9IDB4MTkwODtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBGUkFHTUVOVF9TSEFERVIgPSAweDhCMzA7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgVkVSVEVYX1NIQURFUiA9IDB4OEIzMTtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBMSU5LX1NUQVRVUyA9IDB4OEI4MjtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBMSU5FQVIgPSAweDI2MDE7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgVEVYVFVSRV9NQUdfRklMVEVSID0gMHgyODAwO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIFRFWFRVUkVfTUlOX0ZJTFRFUiA9IDB4MjgwMTtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBURVhUVVJFX1dSQVBfUyA9IDB4MjgwMjtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBURVhUVVJFX1dSQVBfVCA9IDB4MjgwMztcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBURVhUVVJFXzJEID0gMHgwREUxO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIFRFWFRVUkUwID0gMHg4NEMwO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIENMQU1QX1RPX0VER0UgPSAweDgxMkY7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgQ09NUElMRV9TVEFUVVMgPSAweDhCODE7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgRlJBTUVCVUZGRVIgPSAweDhENDA7XG5cblxuLyoqIGVuZCBvZiBnb29nLndlYmdsIGNvbnN0YW50c1xuICovXG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtBcnJheTxzdHJpbmc+fVxuICovXG52YXIgQ09OVEVYVF9JRFMgPSBbXG4gICdleHBlcmltZW50YWwtd2ViZ2wnLFxuICAnd2ViZ2wnLFxuICAnd2Via2l0LTNkJyxcbiAgJ21vei13ZWJnbCdcbl07XG5cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgQ2FudmFzLlxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfYXR0cmlidXRlcyBBdHRyaWJ1dGVzLlxuICogQHJldHVybiB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBXZWJHTCByZW5kZXJpbmcgY29udGV4dC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvbnRleHQoY2FudmFzLCBvcHRfYXR0cmlidXRlcykge1xuICB2YXIgaWkgPSBDT05URVhUX0lEUy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaWk7ICsraSkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KENPTlRFWFRfSURTW2ldLCBvcHRfYXR0cmlidXRlcyk7XG4gICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHshV2ViR0xSZW5kZXJpbmdDb250ZXh0fSAqLyAoY29udGV4dCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gcGFzc1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuXG4vKipcbiAqIEluY2x1ZGUgZGVidWdnYWJsZSBzaGFkZXIgc291cmNlcy4gIERlZmF1bHQgaXMgYHRydWVgLiBUaGlzIHNob3VsZCBiZSBzZXQgdG9cbiAqIGBmYWxzZWAgZm9yIHByb2R1Y3Rpb24gYnVpbGRzLlxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCB2YXIgREVCVUcgPSB0cnVlO1xuXG5cbi8qKlxuICogVGhlIG1heGltdW0gc3VwcG9ydGVkIFdlYkdMIHRleHR1cmUgc2l6ZSBpbiBwaXhlbHMuIElmIFdlYkdMIGlzIG5vdFxuICogc3VwcG9ydGVkLCB0aGUgdmFsdWUgaXMgc2V0IHRvIGB1bmRlZmluZWRgLlxuICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gKi9cbnZhciBNQVhfVEVYVFVSRV9TSVpFOyAvLyB2YWx1ZSBpcyBzZXQgYmVsb3dcblxuXG4vKipcbiAqIExpc3Qgb2Ygc3VwcG9ydGVkIFdlYkdMIGV4dGVuc2lvbnMuXG4gKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn1cbiAqL1xudmFyIEVYVEVOU0lPTlM7IC8vIHZhbHVlIGlzIHNldCBiZWxvd1xuXG5cbi8qKlxuICogVHJ1ZSBpZiBib3RoIE9wZW5MYXllcnMgYW5kIGJyb3dzZXIgc3VwcG9ydCBXZWJHTC5cbiAqIEB0eXBlIHtib29sZWFufVxuICogQGFwaVxuICovXG52YXIgSEFTID0gZmFsc2U7XG5cbi8vVE9ETyBSZW1vdmUgc2lkZSBlZmZlY3RzXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ1dlYkdMUmVuZGVyaW5nQ29udGV4dCcgaW4gd2luZG93KSB7XG4gIHRyeSB7XG4gICAgdmFyIGNhbnZhcyA9IC8qKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnR9ICovIChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSk7XG4gICAgdmFyIGdsID0gZ2V0Q29udGV4dChjYW52YXMsIHtmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0OiB0cnVlfSk7XG4gICAgaWYgKGdsKSB7XG4gICAgICBIQVMgPSB0cnVlO1xuICAgICAgTUFYX1RFWFRVUkVfU0laRSA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX1NJWkUpKTtcbiAgICAgIEVYVEVOU0lPTlMgPSBnbC5nZXRTdXBwb3J0ZWRFeHRlbnNpb25zKCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gcGFzc1xuICB9XG59XG5cbmV4cG9ydCB7SEFTLCBNQVhfVEVYVFVSRV9TSVpFLCBFWFRFTlNJT05TfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViZ2wuanMubWFwIiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuXHQoZ2xvYmFsLnF1aWNrc2VsZWN0ID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBxdWlja3NlbGVjdChhcnIsIGssIGxlZnQsIHJpZ2h0LCBjb21wYXJlKSB7XG4gICAgcXVpY2tzZWxlY3RTdGVwKGFyciwgaywgbGVmdCB8fCAwLCByaWdodCB8fCAoYXJyLmxlbmd0aCAtIDEpLCBjb21wYXJlIHx8IGRlZmF1bHRDb21wYXJlKTtcbn1cblxuZnVuY3Rpb24gcXVpY2tzZWxlY3RTdGVwKGFyciwgaywgbGVmdCwgcmlnaHQsIGNvbXBhcmUpIHtcblxuICAgIHdoaWxlIChyaWdodCA+IGxlZnQpIHtcbiAgICAgICAgaWYgKHJpZ2h0IC0gbGVmdCA+IDYwMCkge1xuICAgICAgICAgICAgdmFyIG4gPSByaWdodCAtIGxlZnQgKyAxO1xuICAgICAgICAgICAgdmFyIG0gPSBrIC0gbGVmdCArIDE7XG4gICAgICAgICAgICB2YXIgeiA9IE1hdGgubG9nKG4pO1xuICAgICAgICAgICAgdmFyIHMgPSAwLjUgKiBNYXRoLmV4cCgyICogeiAvIDMpO1xuICAgICAgICAgICAgdmFyIHNkID0gMC41ICogTWF0aC5zcXJ0KHogKiBzICogKG4gLSBzKSAvIG4pICogKG0gLSBuIC8gMiA8IDAgPyAtMSA6IDEpO1xuICAgICAgICAgICAgdmFyIG5ld0xlZnQgPSBNYXRoLm1heChsZWZ0LCBNYXRoLmZsb29yKGsgLSBtICogcyAvIG4gKyBzZCkpO1xuICAgICAgICAgICAgdmFyIG5ld1JpZ2h0ID0gTWF0aC5taW4ocmlnaHQsIE1hdGguZmxvb3IoayArIChuIC0gbSkgKiBzIC8gbiArIHNkKSk7XG4gICAgICAgICAgICBxdWlja3NlbGVjdFN0ZXAoYXJyLCBrLCBuZXdMZWZ0LCBuZXdSaWdodCwgY29tcGFyZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdCA9IGFycltrXTtcbiAgICAgICAgdmFyIGkgPSBsZWZ0O1xuICAgICAgICB2YXIgaiA9IHJpZ2h0O1xuXG4gICAgICAgIHN3YXAoYXJyLCBsZWZ0LCBrKTtcbiAgICAgICAgaWYgKGNvbXBhcmUoYXJyW3JpZ2h0XSwgdCkgPiAwKSBzd2FwKGFyciwgbGVmdCwgcmlnaHQpO1xuXG4gICAgICAgIHdoaWxlIChpIDwgaikge1xuICAgICAgICAgICAgc3dhcChhcnIsIGksIGopO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUoYXJyW2ldLCB0KSA8IDApIGkrKztcbiAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKGFycltqXSwgdCkgPiAwKSBqLS07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29tcGFyZShhcnJbbGVmdF0sIHQpID09PSAwKSBzd2FwKGFyciwgbGVmdCwgaik7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgc3dhcChhcnIsIGosIHJpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChqIDw9IGspIGxlZnQgPSBqICsgMTtcbiAgICAgICAgaWYgKGsgPD0gaikgcmlnaHQgPSBqIC0gMTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHN3YXAoYXJyLCBpLCBqKSB7XG4gICAgdmFyIHRtcCA9IGFycltpXTtcbiAgICBhcnJbaV0gPSBhcnJbal07XG4gICAgYXJyW2pdID0gdG1wO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0Q29tcGFyZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xufVxuXG5yZXR1cm4gcXVpY2tzZWxlY3Q7XG5cbn0pKSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmJ1c2g7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gcmJ1c2g7XG5cbnZhciBxdWlja3NlbGVjdCA9IHJlcXVpcmUoJ3F1aWNrc2VsZWN0Jyk7XG5cbmZ1bmN0aW9uIHJidXNoKG1heEVudHJpZXMsIGZvcm1hdCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiByYnVzaCkpIHJldHVybiBuZXcgcmJ1c2gobWF4RW50cmllcywgZm9ybWF0KTtcblxuICAgIC8vIG1heCBlbnRyaWVzIGluIGEgbm9kZSBpcyA5IGJ5IGRlZmF1bHQ7IG1pbiBub2RlIGZpbGwgaXMgNDAlIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhpcy5fbWF4RW50cmllcyA9IE1hdGgubWF4KDQsIG1heEVudHJpZXMgfHwgOSk7XG4gICAgdGhpcy5fbWluRW50cmllcyA9IE1hdGgubWF4KDIsIE1hdGguY2VpbCh0aGlzLl9tYXhFbnRyaWVzICogMC40KSk7XG5cbiAgICBpZiAoZm9ybWF0KSB7XG4gICAgICAgIHRoaXMuX2luaXRGb3JtYXQoZm9ybWF0KTtcbiAgICB9XG5cbiAgICB0aGlzLmNsZWFyKCk7XG59XG5cbnJidXNoLnByb3RvdHlwZSA9IHtcblxuICAgIGFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWxsKHRoaXMuZGF0YSwgW10pO1xuICAgIH0sXG5cbiAgICBzZWFyY2g6IGZ1bmN0aW9uIChiYm94KSB7XG5cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmRhdGEsXG4gICAgICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgICAgIHRvQkJveCA9IHRoaXMudG9CQm94O1xuXG4gICAgICAgIGlmICghaW50ZXJzZWN0cyhiYm94LCBub2RlKSkgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICB2YXIgbm9kZXNUb1NlYXJjaCA9IFtdLFxuICAgICAgICAgICAgaSwgbGVuLCBjaGlsZCwgY2hpbGRCQm94O1xuXG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cbiAgICAgICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgY2hpbGRCQm94ID0gbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkO1xuXG4gICAgICAgICAgICAgICAgaWYgKGludGVyc2VjdHMoYmJveCwgY2hpbGRCQm94KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5sZWFmKSByZXN1bHQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbnRhaW5zKGJib3gsIGNoaWxkQkJveCkpIHRoaXMuX2FsbChjaGlsZCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBub2Rlc1RvU2VhcmNoLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBub2Rlc1RvU2VhcmNoLnBvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgY29sbGlkZXM6IGZ1bmN0aW9uIChiYm94KSB7XG5cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmRhdGEsXG4gICAgICAgICAgICB0b0JCb3ggPSB0aGlzLnRvQkJveDtcblxuICAgICAgICBpZiAoIWludGVyc2VjdHMoYmJveCwgbm9kZSkpIHJldHVybiBmYWxzZTtcblxuICAgICAgICB2YXIgbm9kZXNUb1NlYXJjaCA9IFtdLFxuICAgICAgICAgICAgaSwgbGVuLCBjaGlsZCwgY2hpbGRCQm94O1xuXG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cbiAgICAgICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgY2hpbGRCQm94ID0gbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkO1xuXG4gICAgICAgICAgICAgICAgaWYgKGludGVyc2VjdHMoYmJveCwgY2hpbGRCQm94KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5sZWFmIHx8IGNvbnRhaW5zKGJib3gsIGNoaWxkQkJveCkpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBub2Rlc1RvU2VhcmNoLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBub2Rlc1RvU2VhcmNoLnBvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBsb2FkOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoIShkYXRhICYmIGRhdGEubGVuZ3RoKSkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgdGhpcy5fbWluRW50cmllcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluc2VydChkYXRhW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVjdXJzaXZlbHkgYnVpbGQgdGhlIHRyZWUgd2l0aCB0aGUgZ2l2ZW4gZGF0YSBmcm9tIHNjcmF0Y2ggdXNpbmcgT01UIGFsZ29yaXRobVxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX2J1aWxkKGRhdGEuc2xpY2UoKSwgMCwgZGF0YS5sZW5ndGggLSAxLCAwKTtcblxuICAgICAgICBpZiAoIXRoaXMuZGF0YS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHNhdmUgYXMgaXMgaWYgdHJlZSBpcyBlbXB0eVxuICAgICAgICAgICAgdGhpcy5kYXRhID0gbm9kZTtcblxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YS5oZWlnaHQgPT09IG5vZGUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyBzcGxpdCByb290IGlmIHRyZWVzIGhhdmUgdGhlIHNhbWUgaGVpZ2h0XG4gICAgICAgICAgICB0aGlzLl9zcGxpdFJvb3QodGhpcy5kYXRhLCBub2RlKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS5oZWlnaHQgPCBub2RlLmhlaWdodCkge1xuICAgICAgICAgICAgICAgIC8vIHN3YXAgdHJlZXMgaWYgaW5zZXJ0ZWQgb25lIGlzIGJpZ2dlclxuICAgICAgICAgICAgICAgIHZhciB0bXBOb2RlID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHRtcE5vZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGluc2VydCB0aGUgc21hbGwgdHJlZSBpbnRvIHRoZSBsYXJnZSB0cmVlIGF0IGFwcHJvcHJpYXRlIGxldmVsXG4gICAgICAgICAgICB0aGlzLl9pbnNlcnQobm9kZSwgdGhpcy5kYXRhLmhlaWdodCAtIG5vZGUuaGVpZ2h0IC0gMSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgaW5zZXJ0OiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoaXRlbSkgdGhpcy5faW5zZXJ0KGl0ZW0sIHRoaXMuZGF0YS5oZWlnaHQgLSAxKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGNyZWF0ZU5vZGUoW10pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoaXRlbSwgZXF1YWxzRm4pIHtcbiAgICAgICAgaWYgKCFpdGVtKSByZXR1cm4gdGhpcztcblxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIGJib3ggPSB0aGlzLnRvQkJveChpdGVtKSxcbiAgICAgICAgICAgIHBhdGggPSBbXSxcbiAgICAgICAgICAgIGluZGV4ZXMgPSBbXSxcbiAgICAgICAgICAgIGksIHBhcmVudCwgaW5kZXgsIGdvaW5nVXA7XG5cbiAgICAgICAgLy8gZGVwdGgtZmlyc3QgaXRlcmF0aXZlIHRyZWUgdHJhdmVyc2FsXG4gICAgICAgIHdoaWxlIChub2RlIHx8IHBhdGgubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIGlmICghbm9kZSkgeyAvLyBnbyB1cFxuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXRoLnBvcCgpO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpID0gaW5kZXhlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBnb2luZ1VwID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5vZGUubGVhZikgeyAvLyBjaGVjayBjdXJyZW50IG5vZGVcbiAgICAgICAgICAgICAgICBpbmRleCA9IGZpbmRJdGVtKGl0ZW0sIG5vZGUuY2hpbGRyZW4sIGVxdWFsc0ZuKTtcblxuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaXRlbSBmb3VuZCwgcmVtb3ZlIHRoZSBpdGVtIGFuZCBjb25kZW5zZSB0cmVlIHVwd2FyZHNcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbmRlbnNlKHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZ29pbmdVcCAmJiAhbm9kZS5sZWFmICYmIGNvbnRhaW5zKG5vZGUsIGJib3gpKSB7IC8vIGdvIGRvd25cbiAgICAgICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgaW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5bMF07XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyZW50KSB7IC8vIGdvIHJpZ2h0XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgZ29pbmdVcCA9IGZhbHNlO1xuXG4gICAgICAgICAgICB9IGVsc2Ugbm9kZSA9IG51bGw7IC8vIG5vdGhpbmcgZm91bmRcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB0b0JCb3g6IGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtOyB9LFxuXG4gICAgY29tcGFyZU1pblg6IGNvbXBhcmVOb2RlTWluWCxcbiAgICBjb21wYXJlTWluWTogY29tcGFyZU5vZGVNaW5ZLFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmRhdGE7IH0sXG5cbiAgICBmcm9tSlNPTjogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9hbGw6IGZ1bmN0aW9uIChub2RlLCByZXN1bHQpIHtcbiAgICAgICAgdmFyIG5vZGVzVG9TZWFyY2ggPSBbXTtcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmxlYWYpIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgbm9kZS5jaGlsZHJlbik7XG4gICAgICAgICAgICBlbHNlIG5vZGVzVG9TZWFyY2gucHVzaC5hcHBseShub2Rlc1RvU2VhcmNoLCBub2RlLmNoaWxkcmVuKTtcblxuICAgICAgICAgICAgbm9kZSA9IG5vZGVzVG9TZWFyY2gucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgX2J1aWxkOiBmdW5jdGlvbiAoaXRlbXMsIGxlZnQsIHJpZ2h0LCBoZWlnaHQpIHtcblxuICAgICAgICB2YXIgTiA9IHJpZ2h0IC0gbGVmdCArIDEsXG4gICAgICAgICAgICBNID0gdGhpcy5fbWF4RW50cmllcyxcbiAgICAgICAgICAgIG5vZGU7XG5cbiAgICAgICAgaWYgKE4gPD0gTSkge1xuICAgICAgICAgICAgLy8gcmVhY2hlZCBsZWFmIGxldmVsOyByZXR1cm4gbGVhZlxuICAgICAgICAgICAgbm9kZSA9IGNyZWF0ZU5vZGUoaXRlbXMuc2xpY2UobGVmdCwgcmlnaHQgKyAxKSk7XG4gICAgICAgICAgICBjYWxjQkJveChub2RlLCB0aGlzLnRvQkJveCk7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyB0YXJnZXQgaGVpZ2h0IG9mIHRoZSBidWxrLWxvYWRlZCB0cmVlXG4gICAgICAgICAgICBoZWlnaHQgPSBNYXRoLmNlaWwoTWF0aC5sb2coTikgLyBNYXRoLmxvZyhNKSk7XG5cbiAgICAgICAgICAgIC8vIHRhcmdldCBudW1iZXIgb2Ygcm9vdCBlbnRyaWVzIHRvIG1heGltaXplIHN0b3JhZ2UgdXRpbGl6YXRpb25cbiAgICAgICAgICAgIE0gPSBNYXRoLmNlaWwoTiAvIE1hdGgucG93KE0sIGhlaWdodCAtIDEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBjcmVhdGVOb2RlKFtdKTtcbiAgICAgICAgbm9kZS5sZWFmID0gZmFsc2U7XG4gICAgICAgIG5vZGUuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgIC8vIHNwbGl0IHRoZSBpdGVtcyBpbnRvIE0gbW9zdGx5IHNxdWFyZSB0aWxlc1xuXG4gICAgICAgIHZhciBOMiA9IE1hdGguY2VpbChOIC8gTSksXG4gICAgICAgICAgICBOMSA9IE4yICogTWF0aC5jZWlsKE1hdGguc3FydChNKSksXG4gICAgICAgICAgICBpLCBqLCByaWdodDIsIHJpZ2h0MztcblxuICAgICAgICBtdWx0aVNlbGVjdChpdGVtcywgbGVmdCwgcmlnaHQsIE4xLCB0aGlzLmNvbXBhcmVNaW5YKTtcblxuICAgICAgICBmb3IgKGkgPSBsZWZ0OyBpIDw9IHJpZ2h0OyBpICs9IE4xKSB7XG5cbiAgICAgICAgICAgIHJpZ2h0MiA9IE1hdGgubWluKGkgKyBOMSAtIDEsIHJpZ2h0KTtcblxuICAgICAgICAgICAgbXVsdGlTZWxlY3QoaXRlbXMsIGksIHJpZ2h0MiwgTjIsIHRoaXMuY29tcGFyZU1pblkpO1xuXG4gICAgICAgICAgICBmb3IgKGogPSBpOyBqIDw9IHJpZ2h0MjsgaiArPSBOMikge1xuXG4gICAgICAgICAgICAgICAgcmlnaHQzID0gTWF0aC5taW4oaiArIE4yIC0gMSwgcmlnaHQyKTtcblxuICAgICAgICAgICAgICAgIC8vIHBhY2sgZWFjaCBlbnRyeSByZWN1cnNpdmVseVxuICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaCh0aGlzLl9idWlsZChpdGVtcywgaiwgcmlnaHQzLCBoZWlnaHQgLSAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjYWxjQkJveChub2RlLCB0aGlzLnRvQkJveCk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcblxuICAgIF9jaG9vc2VTdWJ0cmVlOiBmdW5jdGlvbiAoYmJveCwgbm9kZSwgbGV2ZWwsIHBhdGgpIHtcblxuICAgICAgICB2YXIgaSwgbGVuLCBjaGlsZCwgdGFyZ2V0Tm9kZSwgYXJlYSwgZW5sYXJnZW1lbnQsIG1pbkFyZWEsIG1pbkVubGFyZ2VtZW50O1xuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG5cbiAgICAgICAgICAgIGlmIChub2RlLmxlYWYgfHwgcGF0aC5sZW5ndGggLSAxID09PSBsZXZlbCkgYnJlYWs7XG5cbiAgICAgICAgICAgIG1pbkFyZWEgPSBtaW5FbmxhcmdlbWVudCA9IEluZmluaXR5O1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGFyZWEgPSBiYm94QXJlYShjaGlsZCk7XG4gICAgICAgICAgICAgICAgZW5sYXJnZW1lbnQgPSBlbmxhcmdlZEFyZWEoYmJveCwgY2hpbGQpIC0gYXJlYTtcblxuICAgICAgICAgICAgICAgIC8vIGNob29zZSBlbnRyeSB3aXRoIHRoZSBsZWFzdCBhcmVhIGVubGFyZ2VtZW50XG4gICAgICAgICAgICAgICAgaWYgKGVubGFyZ2VtZW50IDwgbWluRW5sYXJnZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluRW5sYXJnZW1lbnQgPSBlbmxhcmdlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWEgPCBtaW5BcmVhID8gYXJlYSA6IG1pbkFyZWE7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSBjaGlsZDtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZW5sYXJnZW1lbnQgPT09IG1pbkVubGFyZ2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBjaG9vc2Ugb25lIHdpdGggdGhlIHNtYWxsZXN0IGFyZWFcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZWEgPCBtaW5BcmVhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZSA9IHRhcmdldE5vZGUgfHwgbm9kZS5jaGlsZHJlblswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG5cbiAgICBfaW5zZXJ0OiBmdW5jdGlvbiAoaXRlbSwgbGV2ZWwsIGlzTm9kZSkge1xuXG4gICAgICAgIHZhciB0b0JCb3ggPSB0aGlzLnRvQkJveCxcbiAgICAgICAgICAgIGJib3ggPSBpc05vZGUgPyBpdGVtIDogdG9CQm94KGl0ZW0pLFxuICAgICAgICAgICAgaW5zZXJ0UGF0aCA9IFtdO1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIGJlc3Qgbm9kZSBmb3IgYWNjb21tb2RhdGluZyB0aGUgaXRlbSwgc2F2aW5nIGFsbCBub2RlcyBhbG9uZyB0aGUgcGF0aCB0b29cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9jaG9vc2VTdWJ0cmVlKGJib3gsIHRoaXMuZGF0YSwgbGV2ZWwsIGluc2VydFBhdGgpO1xuXG4gICAgICAgIC8vIHB1dCB0aGUgaXRlbSBpbnRvIHRoZSBub2RlXG4gICAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaChpdGVtKTtcbiAgICAgICAgZXh0ZW5kKG5vZGUsIGJib3gpO1xuXG4gICAgICAgIC8vIHNwbGl0IG9uIG5vZGUgb3ZlcmZsb3c7IHByb3BhZ2F0ZSB1cHdhcmRzIGlmIG5lY2Vzc2FyeVxuICAgICAgICB3aGlsZSAobGV2ZWwgPj0gMCkge1xuICAgICAgICAgICAgaWYgKGluc2VydFBhdGhbbGV2ZWxdLmNoaWxkcmVuLmxlbmd0aCA+IHRoaXMuX21heEVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGxpdChpbnNlcnRQYXRoLCBsZXZlbCk7XG4gICAgICAgICAgICAgICAgbGV2ZWwtLTtcbiAgICAgICAgICAgIH0gZWxzZSBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkanVzdCBiYm94ZXMgYWxvbmcgdGhlIGluc2VydGlvbiBwYXRoXG4gICAgICAgIHRoaXMuX2FkanVzdFBhcmVudEJCb3hlcyhiYm94LCBpbnNlcnRQYXRoLCBsZXZlbCk7XG4gICAgfSxcblxuICAgIC8vIHNwbGl0IG92ZXJmbG93ZWQgbm9kZSBpbnRvIHR3b1xuICAgIF9zcGxpdDogZnVuY3Rpb24gKGluc2VydFBhdGgsIGxldmVsKSB7XG5cbiAgICAgICAgdmFyIG5vZGUgPSBpbnNlcnRQYXRoW2xldmVsXSxcbiAgICAgICAgICAgIE0gPSBub2RlLmNoaWxkcmVuLmxlbmd0aCxcbiAgICAgICAgICAgIG0gPSB0aGlzLl9taW5FbnRyaWVzO1xuXG4gICAgICAgIHRoaXMuX2Nob29zZVNwbGl0QXhpcyhub2RlLCBtLCBNKTtcblxuICAgICAgICB2YXIgc3BsaXRJbmRleCA9IHRoaXMuX2Nob29zZVNwbGl0SW5kZXgobm9kZSwgbSwgTSk7XG5cbiAgICAgICAgdmFyIG5ld05vZGUgPSBjcmVhdGVOb2RlKG5vZGUuY2hpbGRyZW4uc3BsaWNlKHNwbGl0SW5kZXgsIG5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gc3BsaXRJbmRleCkpO1xuICAgICAgICBuZXdOb2RlLmhlaWdodCA9IG5vZGUuaGVpZ2h0O1xuICAgICAgICBuZXdOb2RlLmxlYWYgPSBub2RlLmxlYWY7XG5cbiAgICAgICAgY2FsY0JCb3gobm9kZSwgdGhpcy50b0JCb3gpO1xuICAgICAgICBjYWxjQkJveChuZXdOb2RlLCB0aGlzLnRvQkJveCk7XG5cbiAgICAgICAgaWYgKGxldmVsKSBpbnNlcnRQYXRoW2xldmVsIC0gMV0uY2hpbGRyZW4ucHVzaChuZXdOb2RlKTtcbiAgICAgICAgZWxzZSB0aGlzLl9zcGxpdFJvb3Qobm9kZSwgbmV3Tm9kZSk7XG4gICAgfSxcblxuICAgIF9zcGxpdFJvb3Q6IGZ1bmN0aW9uIChub2RlLCBuZXdOb2RlKSB7XG4gICAgICAgIC8vIHNwbGl0IHJvb3Qgbm9kZVxuICAgICAgICB0aGlzLmRhdGEgPSBjcmVhdGVOb2RlKFtub2RlLCBuZXdOb2RlXSk7XG4gICAgICAgIHRoaXMuZGF0YS5oZWlnaHQgPSBub2RlLmhlaWdodCArIDE7XG4gICAgICAgIHRoaXMuZGF0YS5sZWFmID0gZmFsc2U7XG4gICAgICAgIGNhbGNCQm94KHRoaXMuZGF0YSwgdGhpcy50b0JCb3gpO1xuICAgIH0sXG5cbiAgICBfY2hvb3NlU3BsaXRJbmRleDogZnVuY3Rpb24gKG5vZGUsIG0sIE0pIHtcblxuICAgICAgICB2YXIgaSwgYmJveDEsIGJib3gyLCBvdmVybGFwLCBhcmVhLCBtaW5PdmVybGFwLCBtaW5BcmVhLCBpbmRleDtcblxuICAgICAgICBtaW5PdmVybGFwID0gbWluQXJlYSA9IEluZmluaXR5O1xuXG4gICAgICAgIGZvciAoaSA9IG07IGkgPD0gTSAtIG07IGkrKykge1xuICAgICAgICAgICAgYmJveDEgPSBkaXN0QkJveChub2RlLCAwLCBpLCB0aGlzLnRvQkJveCk7XG4gICAgICAgICAgICBiYm94MiA9IGRpc3RCQm94KG5vZGUsIGksIE0sIHRoaXMudG9CQm94KTtcblxuICAgICAgICAgICAgb3ZlcmxhcCA9IGludGVyc2VjdGlvbkFyZWEoYmJveDEsIGJib3gyKTtcbiAgICAgICAgICAgIGFyZWEgPSBiYm94QXJlYShiYm94MSkgKyBiYm94QXJlYShiYm94Mik7XG5cbiAgICAgICAgICAgIC8vIGNob29zZSBkaXN0cmlidXRpb24gd2l0aCBtaW5pbXVtIG92ZXJsYXBcbiAgICAgICAgICAgIGlmIChvdmVybGFwIDwgbWluT3ZlcmxhcCkge1xuICAgICAgICAgICAgICAgIG1pbk92ZXJsYXAgPSBvdmVybGFwO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcblxuICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhIDwgbWluQXJlYSA/IGFyZWEgOiBtaW5BcmVhO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG92ZXJsYXAgPT09IG1pbk92ZXJsYXApIHtcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgY2hvb3NlIGRpc3RyaWJ1dGlvbiB3aXRoIG1pbmltdW0gYXJlYVxuICAgICAgICAgICAgICAgIGlmIChhcmVhIDwgbWluQXJlYSkge1xuICAgICAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9LFxuXG4gICAgLy8gc29ydHMgbm9kZSBjaGlsZHJlbiBieSB0aGUgYmVzdCBheGlzIGZvciBzcGxpdFxuICAgIF9jaG9vc2VTcGxpdEF4aXM6IGZ1bmN0aW9uIChub2RlLCBtLCBNKSB7XG5cbiAgICAgICAgdmFyIGNvbXBhcmVNaW5YID0gbm9kZS5sZWFmID8gdGhpcy5jb21wYXJlTWluWCA6IGNvbXBhcmVOb2RlTWluWCxcbiAgICAgICAgICAgIGNvbXBhcmVNaW5ZID0gbm9kZS5sZWFmID8gdGhpcy5jb21wYXJlTWluWSA6IGNvbXBhcmVOb2RlTWluWSxcbiAgICAgICAgICAgIHhNYXJnaW4gPSB0aGlzLl9hbGxEaXN0TWFyZ2luKG5vZGUsIG0sIE0sIGNvbXBhcmVNaW5YKSxcbiAgICAgICAgICAgIHlNYXJnaW4gPSB0aGlzLl9hbGxEaXN0TWFyZ2luKG5vZGUsIG0sIE0sIGNvbXBhcmVNaW5ZKTtcblxuICAgICAgICAvLyBpZiB0b3RhbCBkaXN0cmlidXRpb25zIG1hcmdpbiB2YWx1ZSBpcyBtaW5pbWFsIGZvciB4LCBzb3J0IGJ5IG1pblgsXG4gICAgICAgIC8vIG90aGVyd2lzZSBpdCdzIGFscmVhZHkgc29ydGVkIGJ5IG1pbllcbiAgICAgICAgaWYgKHhNYXJnaW4gPCB5TWFyZ2luKSBub2RlLmNoaWxkcmVuLnNvcnQoY29tcGFyZU1pblgpO1xuICAgIH0sXG5cbiAgICAvLyB0b3RhbCBtYXJnaW4gb2YgYWxsIHBvc3NpYmxlIHNwbGl0IGRpc3RyaWJ1dGlvbnMgd2hlcmUgZWFjaCBub2RlIGlzIGF0IGxlYXN0IG0gZnVsbFxuICAgIF9hbGxEaXN0TWFyZ2luOiBmdW5jdGlvbiAobm9kZSwgbSwgTSwgY29tcGFyZSkge1xuXG4gICAgICAgIG5vZGUuY2hpbGRyZW4uc29ydChjb21wYXJlKTtcblxuICAgICAgICB2YXIgdG9CQm94ID0gdGhpcy50b0JCb3gsXG4gICAgICAgICAgICBsZWZ0QkJveCA9IGRpc3RCQm94KG5vZGUsIDAsIG0sIHRvQkJveCksXG4gICAgICAgICAgICByaWdodEJCb3ggPSBkaXN0QkJveChub2RlLCBNIC0gbSwgTSwgdG9CQm94KSxcbiAgICAgICAgICAgIG1hcmdpbiA9IGJib3hNYXJnaW4obGVmdEJCb3gpICsgYmJveE1hcmdpbihyaWdodEJCb3gpLFxuICAgICAgICAgICAgaSwgY2hpbGQ7XG5cbiAgICAgICAgZm9yIChpID0gbTsgaSA8IE0gLSBtOyBpKyspIHtcbiAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGV4dGVuZChsZWZ0QkJveCwgbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkKTtcbiAgICAgICAgICAgIG1hcmdpbiArPSBiYm94TWFyZ2luKGxlZnRCQm94KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IE0gLSBtIC0gMTsgaSA+PSBtOyBpLS0pIHtcbiAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGV4dGVuZChyaWdodEJCb3gsIG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZCk7XG4gICAgICAgICAgICBtYXJnaW4gKz0gYmJveE1hcmdpbihyaWdodEJCb3gpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hcmdpbjtcbiAgICB9LFxuXG4gICAgX2FkanVzdFBhcmVudEJCb3hlczogZnVuY3Rpb24gKGJib3gsIHBhdGgsIGxldmVsKSB7XG4gICAgICAgIC8vIGFkanVzdCBiYm94ZXMgYWxvbmcgdGhlIGdpdmVuIHRyZWUgcGF0aFxuICAgICAgICBmb3IgKHZhciBpID0gbGV2ZWw7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBleHRlbmQocGF0aFtpXSwgYmJveCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2NvbmRlbnNlOiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAvLyBnbyB0aHJvdWdoIHRoZSBwYXRoLCByZW1vdmluZyBlbXB0eSBub2RlcyBhbmQgdXBkYXRpbmcgYmJveGVzXG4gICAgICAgIGZvciAodmFyIGkgPSBwYXRoLmxlbmd0aCAtIDEsIHNpYmxpbmdzOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKHBhdGhbaV0uY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpYmxpbmdzID0gcGF0aFtpIC0gMV0uY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgICAgIHNpYmxpbmdzLnNwbGljZShzaWJsaW5ncy5pbmRleE9mKHBhdGhbaV0pLCAxKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB0aGlzLmNsZWFyKCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBjYWxjQkJveChwYXRoW2ldLCB0aGlzLnRvQkJveCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2luaXRGb3JtYXQ6IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgLy8gZGF0YSBmb3JtYXQgKG1pblgsIG1pblksIG1heFgsIG1heFkgYWNjZXNzb3JzKVxuXG4gICAgICAgIC8vIHVzZXMgZXZhbC10eXBlIGZ1bmN0aW9uIGNvbXBpbGF0aW9uIGluc3RlYWQgb2YganVzdCBhY2NlcHRpbmcgYSB0b0JCb3ggZnVuY3Rpb25cbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgYWxnb3JpdGhtcyBhcmUgdmVyeSBzZW5zaXRpdmUgdG8gc29ydGluZyBmdW5jdGlvbnMgcGVyZm9ybWFuY2UsXG4gICAgICAgIC8vIHNvIHRoZXkgc2hvdWxkIGJlIGRlYWQgc2ltcGxlIGFuZCB3aXRob3V0IGlubmVyIGNhbGxzXG5cbiAgICAgICAgdmFyIGNvbXBhcmVBcnIgPSBbJ3JldHVybiBhJywgJyAtIGInLCAnOyddO1xuXG4gICAgICAgIHRoaXMuY29tcGFyZU1pblggPSBuZXcgRnVuY3Rpb24oJ2EnLCAnYicsIGNvbXBhcmVBcnIuam9pbihmb3JtYXRbMF0pKTtcbiAgICAgICAgdGhpcy5jb21wYXJlTWluWSA9IG5ldyBGdW5jdGlvbignYScsICdiJywgY29tcGFyZUFyci5qb2luKGZvcm1hdFsxXSkpO1xuXG4gICAgICAgIHRoaXMudG9CQm94ID0gbmV3IEZ1bmN0aW9uKCdhJyxcbiAgICAgICAgICAgICdyZXR1cm4ge21pblg6IGEnICsgZm9ybWF0WzBdICtcbiAgICAgICAgICAgICcsIG1pblk6IGEnICsgZm9ybWF0WzFdICtcbiAgICAgICAgICAgICcsIG1heFg6IGEnICsgZm9ybWF0WzJdICtcbiAgICAgICAgICAgICcsIG1heFk6IGEnICsgZm9ybWF0WzNdICsgJ307Jyk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gZmluZEl0ZW0oaXRlbSwgaXRlbXMsIGVxdWFsc0ZuKSB7XG4gICAgaWYgKCFlcXVhbHNGbikgcmV0dXJuIGl0ZW1zLmluZGV4T2YoaXRlbSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChlcXVhbHNGbihpdGVtLCBpdGVtc1tpXSkpIHJldHVybiBpO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5cbi8vIGNhbGN1bGF0ZSBub2RlJ3MgYmJveCBmcm9tIGJib3hlcyBvZiBpdHMgY2hpbGRyZW5cbmZ1bmN0aW9uIGNhbGNCQm94KG5vZGUsIHRvQkJveCkge1xuICAgIGRpc3RCQm94KG5vZGUsIDAsIG5vZGUuY2hpbGRyZW4ubGVuZ3RoLCB0b0JCb3gsIG5vZGUpO1xufVxuXG4vLyBtaW4gYm91bmRpbmcgcmVjdGFuZ2xlIG9mIG5vZGUgY2hpbGRyZW4gZnJvbSBrIHRvIHAtMVxuZnVuY3Rpb24gZGlzdEJCb3gobm9kZSwgaywgcCwgdG9CQm94LCBkZXN0Tm9kZSkge1xuICAgIGlmICghZGVzdE5vZGUpIGRlc3ROb2RlID0gY3JlYXRlTm9kZShudWxsKTtcbiAgICBkZXN0Tm9kZS5taW5YID0gSW5maW5pdHk7XG4gICAgZGVzdE5vZGUubWluWSA9IEluZmluaXR5O1xuICAgIGRlc3ROb2RlLm1heFggPSAtSW5maW5pdHk7XG4gICAgZGVzdE5vZGUubWF4WSA9IC1JbmZpbml0eTtcblxuICAgIGZvciAodmFyIGkgPSBrLCBjaGlsZDsgaSA8IHA7IGkrKykge1xuICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgIGV4dGVuZChkZXN0Tm9kZSwgbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVzdE5vZGU7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZChhLCBiKSB7XG4gICAgYS5taW5YID0gTWF0aC5taW4oYS5taW5YLCBiLm1pblgpO1xuICAgIGEubWluWSA9IE1hdGgubWluKGEubWluWSwgYi5taW5ZKTtcbiAgICBhLm1heFggPSBNYXRoLm1heChhLm1heFgsIGIubWF4WCk7XG4gICAgYS5tYXhZID0gTWF0aC5tYXgoYS5tYXhZLCBiLm1heFkpO1xuICAgIHJldHVybiBhO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlTm9kZU1pblgoYSwgYikgeyByZXR1cm4gYS5taW5YIC0gYi5taW5YOyB9XG5mdW5jdGlvbiBjb21wYXJlTm9kZU1pblkoYSwgYikgeyByZXR1cm4gYS5taW5ZIC0gYi5taW5ZOyB9XG5cbmZ1bmN0aW9uIGJib3hBcmVhKGEpICAgeyByZXR1cm4gKGEubWF4WCAtIGEubWluWCkgKiAoYS5tYXhZIC0gYS5taW5ZKTsgfVxuZnVuY3Rpb24gYmJveE1hcmdpbihhKSB7IHJldHVybiAoYS5tYXhYIC0gYS5taW5YKSArIChhLm1heFkgLSBhLm1pblkpOyB9XG5cbmZ1bmN0aW9uIGVubGFyZ2VkQXJlYShhLCBiKSB7XG4gICAgcmV0dXJuIChNYXRoLm1heChiLm1heFgsIGEubWF4WCkgLSBNYXRoLm1pbihiLm1pblgsIGEubWluWCkpICpcbiAgICAgICAgICAgKE1hdGgubWF4KGIubWF4WSwgYS5tYXhZKSAtIE1hdGgubWluKGIubWluWSwgYS5taW5ZKSk7XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdGlvbkFyZWEoYSwgYikge1xuICAgIHZhciBtaW5YID0gTWF0aC5tYXgoYS5taW5YLCBiLm1pblgpLFxuICAgICAgICBtaW5ZID0gTWF0aC5tYXgoYS5taW5ZLCBiLm1pblkpLFxuICAgICAgICBtYXhYID0gTWF0aC5taW4oYS5tYXhYLCBiLm1heFgpLFxuICAgICAgICBtYXhZID0gTWF0aC5taW4oYS5tYXhZLCBiLm1heFkpO1xuXG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIG1heFggLSBtaW5YKSAqXG4gICAgICAgICAgIE1hdGgubWF4KDAsIG1heFkgLSBtaW5ZKTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnMoYSwgYikge1xuICAgIHJldHVybiBhLm1pblggPD0gYi5taW5YICYmXG4gICAgICAgICAgIGEubWluWSA8PSBiLm1pblkgJiZcbiAgICAgICAgICAgYi5tYXhYIDw9IGEubWF4WCAmJlxuICAgICAgICAgICBiLm1heFkgPD0gYS5tYXhZO1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3RzKGEsIGIpIHtcbiAgICByZXR1cm4gYi5taW5YIDw9IGEubWF4WCAmJlxuICAgICAgICAgICBiLm1pblkgPD0gYS5tYXhZICYmXG4gICAgICAgICAgIGIubWF4WCA+PSBhLm1pblggJiZcbiAgICAgICAgICAgYi5tYXhZID49IGEubWluWTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9kZShjaGlsZHJlbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICBsZWFmOiB0cnVlLFxuICAgICAgICBtaW5YOiBJbmZpbml0eSxcbiAgICAgICAgbWluWTogSW5maW5pdHksXG4gICAgICAgIG1heFg6IC1JbmZpbml0eSxcbiAgICAgICAgbWF4WTogLUluZmluaXR5XG4gICAgfTtcbn1cblxuLy8gc29ydCBhbiBhcnJheSBzbyB0aGF0IGl0ZW1zIGNvbWUgaW4gZ3JvdXBzIG9mIG4gdW5zb3J0ZWQgaXRlbXMsIHdpdGggZ3JvdXBzIHNvcnRlZCBiZXR3ZWVuIGVhY2ggb3RoZXI7XG4vLyBjb21iaW5lcyBzZWxlY3Rpb24gYWxnb3JpdGhtIHdpdGggYmluYXJ5IGRpdmlkZSAmIGNvbnF1ZXIgYXBwcm9hY2hcblxuZnVuY3Rpb24gbXVsdGlTZWxlY3QoYXJyLCBsZWZ0LCByaWdodCwgbiwgY29tcGFyZSkge1xuICAgIHZhciBzdGFjayA9IFtsZWZ0LCByaWdodF0sXG4gICAgICAgIG1pZDtcblxuICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgcmlnaHQgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgbGVmdCA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICAgIGlmIChyaWdodCAtIGxlZnQgPD0gbikgY29udGludWU7XG5cbiAgICAgICAgbWlkID0gbGVmdCArIE1hdGguY2VpbCgocmlnaHQgLSBsZWZ0KSAvIG4gLyAyKSAqIG47XG4gICAgICAgIHF1aWNrc2VsZWN0KGFyciwgbWlkLCBsZWZ0LCByaWdodCwgY29tcGFyZSk7XG5cbiAgICAgICAgc3RhY2sucHVzaChsZWZ0LCBtaWQsIG1pZCwgcmlnaHQpO1xuICAgIH1cbn1cbiIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHt9O1xuXG52YXJcdG1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW87XG5cblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBtZW1vO1xuXHR9O1xufTtcblxudmFyIGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcblx0Ly8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3Ncblx0Ly8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuXHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG5cdC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuXHQvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcblx0cmV0dXJuIHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iO1xufSk7XG5cbnZhciBnZXRUYXJnZXQgPSBmdW5jdGlvbiAodGFyZ2V0LCBwYXJlbnQpIHtcbiAgaWYgKHBhcmVudCl7XG4gICAgcmV0dXJuIHBhcmVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG4gIH1cbiAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcbn07XG5cbnZhciBnZXRFbGVtZW50ID0gKGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbyA9IHt9O1xuXG5cdHJldHVybiBmdW5jdGlvbih0YXJnZXQsIHBhcmVudCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHBhc3NpbmcgZnVuY3Rpb24gaW4gb3B0aW9ucywgdGhlbiB1c2UgaXQgZm9yIHJlc29sdmUgXCJoZWFkXCIgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAvLyBVc2VmdWwgZm9yIFNoYWRvdyBSb290IHN0eWxlIGkuZVxuICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICAgICAgICAvLyAgIGluc2VydEludG86IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZm9vXCIpLnNoYWRvd1Jvb3QgfVxuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0dmFyIHN0eWxlVGFyZ2V0ID0gZ2V0VGFyZ2V0LmNhbGwodGhpcywgdGFyZ2V0LCBwYXJlbnQpO1xuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblx0XHRcdGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHQvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuXHRcdFx0XHRcdC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcblx0XHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcblx0XHR9XG5cdFx0cmV0dXJuIG1lbW9bdGFyZ2V0XVxuXHR9O1xufSkoKTtcblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXJcdHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xudmFyXHRzdHlsZXNJbnNlcnRlZEF0VG9wID0gW107XG5cbnZhclx0Zml4VXJscyA9IHJlcXVpcmUoXCIuL3VybHNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xuXHRpZiAodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XG5cdFx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuXHR9XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0b3B0aW9ucy5hdHRycyA9IHR5cGVvZiBvcHRpb25zLmF0dHJzID09PSBcIm9iamVjdFwiID8gb3B0aW9ucy5hdHRycyA6IHt9O1xuXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cdGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSBcImJvb2xlYW5cIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgPGhlYWQ+IGVsZW1lbnRcbiAgICAgICAgaWYgKCFvcHRpb25zLmluc2VydEludG8pIG9wdGlvbnMuaW5zZXJ0SW50byA9IFwiaGVhZFwiO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdGFyZ2V0XG5cdGlmICghb3B0aW9ucy5pbnNlcnRBdCkgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XG5cblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0LCBvcHRpb25zKTtcblxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuXHRcdH1cblxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCwgb3B0aW9ucyk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykgZG9tU3R5bGUucGFydHNbal0oKTtcblxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMsIG9wdGlvbnMpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdGlmKGRvbVN0eWxlKSB7XG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAobGlzdCwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGVzID0gW107XG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XG5cdFx0dmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XG5cblx0XHRpZighbmV3U3R5bGVzW2lkXSkgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcblx0fVxuXG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudCAob3B0aW9ucywgc3R5bGUpIHtcblx0dmFyIHRhcmdldCA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvKVxuXG5cdGlmICghdGFyZ2V0KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnRJbnRvJyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG5cdH1cblxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZXNJbnNlcnRlZEF0VG9wW3N0eWxlc0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XG5cblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZiAoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCB0YXJnZXQuZmlyc3RDaGlsZCk7XG5cdFx0fSBlbHNlIGlmIChsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHRcdH1cblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGUpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcblx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlKSB7XG5cdFx0dmFyIG5leHRTaWJsaW5nID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEF0LmJlZm9yZSwgdGFyZ2V0KTtcblx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBuZXh0U2libGluZyk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiW1N0eWxlIExvYWRlcl1cXG5cXG4gSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcgKCdvcHRpb25zLmluc2VydEF0JykgZm91bmQuXFxuIE11c3QgYmUgJ3RvcCcsICdib3R0b20nLCBvciBPYmplY3QuXFxuIChodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlciNpbnNlcnRhdClcXG5cIik7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50IChzdHlsZSkge1xuXHRpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXHRzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcblxuXHR2YXIgaWR4ID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlKTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG5cblx0aWYob3B0aW9ucy5hdHRycy50eXBlID09PSB1bmRlZmluZWQpIHtcblx0XHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdH1cblxuXHRpZihvcHRpb25zLmF0dHJzLm5vbmNlID09PSB1bmRlZmluZWQpIHtcblx0XHR2YXIgbm9uY2UgPSBnZXROb25jZSgpO1xuXHRcdGlmIChub25jZSkge1xuXHRcdFx0b3B0aW9ucy5hdHRycy5ub25jZSA9IG5vbmNlO1xuXHRcdH1cblx0fVxuXG5cdGFkZEF0dHJzKHN0eWxlLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlKTtcblxuXHRyZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cblx0aWYob3B0aW9ucy5hdHRycy50eXBlID09PSB1bmRlZmluZWQpIHtcblx0XHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdH1cblx0b3B0aW9ucy5hdHRycy5yZWwgPSBcInN0eWxlc2hlZXRcIjtcblxuXHRhZGRBdHRycyhsaW5rLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIGxpbmspO1xuXG5cdHJldHVybiBsaW5rO1xufVxuXG5mdW5jdGlvbiBhZGRBdHRycyAoZWwsIGF0dHJzKSB7XG5cdE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRlbC5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyc1trZXldKTtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIGdldE5vbmNlKCkge1xuXHRpZiAodHlwZW9mIF9fd2VicGFja19ub25jZV9fID09PSAndW5kZWZpbmVkJykge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0cmV0dXJuIF9fd2VicGFja19ub25jZV9fO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqLCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZSwgdXBkYXRlLCByZW1vdmUsIHJlc3VsdDtcblxuXHQvLyBJZiBhIHRyYW5zZm9ybSBmdW5jdGlvbiB3YXMgZGVmaW5lZCwgcnVuIGl0IG9uIHRoZSBjc3Ncblx0aWYgKG9wdGlvbnMudHJhbnNmb3JtICYmIG9iai5jc3MpIHtcblx0ICAgIHJlc3VsdCA9IHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJ1xuXHRcdCA/IG9wdGlvbnMudHJhbnNmb3JtKG9iai5jc3MpIFxuXHRcdCA6IG9wdGlvbnMudHJhbnNmb3JtLmRlZmF1bHQob2JqLmNzcyk7XG5cblx0ICAgIGlmIChyZXN1bHQpIHtcblx0ICAgIFx0Ly8gSWYgdHJhbnNmb3JtIHJldHVybnMgYSB2YWx1ZSwgdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgY3NzLlxuXHQgICAgXHQvLyBUaGlzIGFsbG93cyBydW5uaW5nIHJ1bnRpbWUgdHJhbnNmb3JtYXRpb25zIG9uIHRoZSBjc3MuXG5cdCAgICBcdG9iai5jc3MgPSByZXN1bHQ7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgXHQvLyBJZiB0aGUgdHJhbnNmb3JtIGZ1bmN0aW9uIHJldHVybnMgYSBmYWxzeSB2YWx1ZSwgZG9uJ3QgYWRkIHRoaXMgY3NzLlxuXHQgICAgXHQvLyBUaGlzIGFsbG93cyBjb25kaXRpb25hbCBsb2FkaW5nIG9mIGNzc1xuXHQgICAgXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICBcdFx0Ly8gbm9vcFxuXHQgICAgXHR9O1xuXHQgICAgfVxuXHR9XG5cblx0aWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG5cblx0XHRzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcblxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgZmFsc2UpO1xuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgdHJ1ZSk7XG5cblx0fSBlbHNlIGlmIChcblx0XHRvYmouc291cmNlTWFwICYmXG5cdFx0dHlwZW9mIFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgQmxvYiA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIlxuXHQpIHtcblx0XHRzdHlsZSA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IHVwZGF0ZUxpbmsuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcblxuXHRcdFx0aWYoc3R5bGUuaHJlZikgVVJMLnJldm9rZU9iamVjdFVSTChzdHlsZS5ocmVmKTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdHN0eWxlID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcblx0XHR9O1xuXHR9XG5cblx0dXBkYXRlKG9iaik7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChuZXdPYmopIHtcblx0XHRpZiAobmV3T2JqKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdG5ld09iai5jc3MgPT09IG9iai5jc3MgJiZcblx0XHRcdFx0bmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiZcblx0XHRcdFx0bmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcFxuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dXBkYXRlKG9iaiA9IG5ld09iaik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlbW92ZSgpO1xuXHRcdH1cblx0fTtcbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuXG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG5cdH07XG59KSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnIChzdHlsZSwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG5cdHZhciBjc3MgPSByZW1vdmUgPyBcIlwiIDogb2JqLmNzcztcblxuXHRpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuXHR9IGVsc2Uge1xuXHRcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG5cblx0XHRpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcblxuXHRcdGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuXHRcdFx0c3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcgKHN0eWxlLCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcblxuXHRpZihtZWRpYSkge1xuXHRcdHN0eWxlLnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKVxuXHR9XG5cblx0aWYoc3R5bGUuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcblx0fSBlbHNlIHtcblx0XHR3aGlsZShzdHlsZS5maXJzdENoaWxkKSB7XG5cdFx0XHRzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcblx0XHR9XG5cblx0XHRzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcblx0fVxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaW5rIChsaW5rLCBvcHRpb25zLCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuXG5cdC8qXG5cdFx0SWYgY29udmVydFRvQWJzb2x1dGVVcmxzIGlzbid0IGRlZmluZWQsIGJ1dCBzb3VyY2VtYXBzIGFyZSBlbmFibGVkXG5cdFx0YW5kIHRoZXJlIGlzIG5vIHB1YmxpY1BhdGggZGVmaW5lZCB0aGVuIGxldHMgdHVybiBjb252ZXJ0VG9BYnNvbHV0ZVVybHNcblx0XHRvbiBieSBkZWZhdWx0LiAgT3RoZXJ3aXNlIGRlZmF1bHQgdG8gdGhlIGNvbnZlcnRUb0Fic29sdXRlVXJscyBvcHRpb25cblx0XHRkaXJlY3RseVxuXHQqL1xuXHR2YXIgYXV0b0ZpeFVybHMgPSBvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyA9PT0gdW5kZWZpbmVkICYmIHNvdXJjZU1hcDtcblxuXHRpZiAob3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgfHwgYXV0b0ZpeFVybHMpIHtcblx0XHRjc3MgPSBmaXhVcmxzKGNzcyk7XG5cdH1cblxuXHRpZiAoc291cmNlTWFwKSB7XG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcblx0XHRjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArIFwiICovXCI7XG5cdH1cblxuXHR2YXIgYmxvYiA9IG5ldyBCbG9iKFtjc3NdLCB7IHR5cGU6IFwidGV4dC9jc3NcIiB9KTtcblxuXHR2YXIgb2xkU3JjID0gbGluay5ocmVmO1xuXG5cdGxpbmsuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG5cblx0aWYob2xkU3JjKSBVUkwucmV2b2tlT2JqZWN0VVJMKG9sZFNyYyk7XG59XG4iLCJcbi8qKlxuICogV2hlbiBzb3VyY2UgbWFwcyBhcmUgZW5hYmxlZCwgYHN0eWxlLWxvYWRlcmAgdXNlcyBhIGxpbmsgZWxlbWVudCB3aXRoIGEgZGF0YS11cmkgdG9cbiAqIGVtYmVkIHRoZSBjc3Mgb24gdGhlIHBhZ2UuIFRoaXMgYnJlYWtzIGFsbCByZWxhdGl2ZSB1cmxzIGJlY2F1c2Ugbm93IHRoZXkgYXJlIHJlbGF0aXZlIHRvIGFcbiAqIGJ1bmRsZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHBhZ2UuXG4gKlxuICogT25lIHNvbHV0aW9uIGlzIHRvIG9ubHkgdXNlIGZ1bGwgdXJscywgYnV0IHRoYXQgbWF5IGJlIGltcG9zc2libGUuXG4gKlxuICogSW5zdGVhZCwgdGhpcyBmdW5jdGlvbiBcImZpeGVzXCIgdGhlIHJlbGF0aXZlIHVybHMgdG8gYmUgYWJzb2x1dGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXG4gKlxuICogQSBydWRpbWVudGFyeSB0ZXN0IHN1aXRlIGlzIGxvY2F0ZWQgYXQgYHRlc3QvZml4VXJscy5qc2AgYW5kIGNhbiBiZSBydW4gdmlhIHRoZSBgbnBtIHRlc3RgIGNvbW1hbmQuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcykge1xuICAvLyBnZXQgY3VycmVudCBsb2NhdGlvblxuICB2YXIgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbjtcblxuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZml4VXJscyByZXF1aXJlcyB3aW5kb3cubG9jYXRpb25cIik7XG4gIH1cblxuXHQvLyBibGFuayBvciBudWxsP1xuXHRpZiAoIWNzcyB8fCB0eXBlb2YgY3NzICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHZhciBiYXNlVXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0O1xuICB2YXIgY3VycmVudERpciA9IGJhc2VVcmwgKyBsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sIFwiL1wiKTtcblxuXHQvLyBjb252ZXJ0IGVhY2ggdXJsKC4uLilcblx0Lypcblx0VGhpcyByZWd1bGFyIGV4cHJlc3Npb24gaXMganVzdCBhIHdheSB0byByZWN1cnNpdmVseSBtYXRjaCBicmFja2V0cyB3aXRoaW5cblx0YSBzdHJpbmcuXG5cblx0IC91cmxcXHMqXFwoICA9IE1hdGNoIG9uIHRoZSB3b3JkIFwidXJsXCIgd2l0aCBhbnkgd2hpdGVzcGFjZSBhZnRlciBpdCBhbmQgdGhlbiBhIHBhcmVuc1xuXHQgICAoICA9IFN0YXJ0IGEgY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgKD86ICA9IFN0YXJ0IGEgbm9uLWNhcHR1cmluZyBncm91cFxuXHQgICAgICAgICBbXikoXSAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKD86ICA9IFN0YXJ0IGFub3RoZXIgbm9uLWNhcHR1cmluZyBncm91cHNcblx0ICAgICAgICAgICAgICAgICBbXikoXSsgID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgICAgIFteKShdKiAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICBcXCkgID0gTWF0Y2ggYSBlbmQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICkgID0gRW5kIEdyb3VwXG4gICAgICAgICAgICAgICpcXCkgPSBNYXRjaCBhbnl0aGluZyBhbmQgdGhlbiBhIGNsb3NlIHBhcmVuc1xuICAgICAgICAgICkgID0gQ2xvc2Ugbm9uLWNhcHR1cmluZyBncm91cFxuICAgICAgICAgICogID0gTWF0Y2ggYW55dGhpbmdcbiAgICAgICApICA9IENsb3NlIGNhcHR1cmluZyBncm91cFxuXHQgXFwpICA9IE1hdGNoIGEgY2xvc2UgcGFyZW5zXG5cblx0IC9naSAgPSBHZXQgYWxsIG1hdGNoZXMsIG5vdCB0aGUgZmlyc3QuICBCZSBjYXNlIGluc2Vuc2l0aXZlLlxuXHQgKi9cblx0dmFyIGZpeGVkQ3NzID0gY3NzLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXG5cdFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcblx0XHRcdC50cmltKClcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXG5cdFx0XHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XG5cblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxuXHRcdGlmICgvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcL3xcXHMqJCkvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcblx0XHR2YXIgbmV3VXJsO1xuXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xuXHRcdFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcblx0XHRcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG5cdFx0XHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXG5cdFx0fVxuXG5cdFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcblx0fSk7XG5cblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3Ncblx0cmV0dXJuIGZpeGVkQ3NzO1xufTtcbiIsIlxuaW1wb3J0IHtMaXptYXBNYXBNYW5hZ2VyLCBNYWluRXZlbnREaXNwYXRjaGVyfSBmcm9tIFwiLi4vbW9kdWxlcy9MaXptYXBHbG9iYWxzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpem1hcEJhc2VMYXllcnNFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIGNvbnN0IHNoYWRvd1Jvb3QgPSB0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KTtcbiAgICAgICAgdGhpcy5fc2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VsZWN0Jyk7XG4gICAgICAgIHNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQodGhpcy5fc2VsZWN0KTtcblxuICAgICAgICB0aGlzLl9zZWxlY3QuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBMaXptYXBNYXBNYW5hZ2VyLmdldE1hcCh0aGlzLm1hcElkKS5iYXNlTGF5ZXJHcm91cC5sYXllclZpc2libGUgPSBldmVudC50YXJnZXQudmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9sYXllcnMgPSBbXTtcbiAgICAgICAgdGhpcy5fbWFwSWQgPSAnJztcbiAgICB9XG5cbiAgICBnZXQgbWFwSWQgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwSWQ7XG4gICAgfVxuXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIHRoaXMuX21hcElkID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ21hcC1pZCcpO1xuICAgICAgICBNYWluRXZlbnREaXNwYXRjaGVyLmFkZExpc3RlbmVyKHRoaXMub25Mb2FkZWRCYXNlTGF5ZXJzLmJpbmQodGhpcyksXG4gICAgICAgICAgICB7IHR5cGU6ICdtYXAtYmFzZS1sYXllcnMtbG9hZGVkJywgbWFwSWQgOiB0aGlzLm1hcElkfSk7XG4gICAgfVxuXG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIE1haW5FdmVudERpc3BhdGNoZXIucmVtb3ZlTGlzdGVuZXIodGhpcy5vbkxvYWRlZEJhc2VMYXllcnMuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHsgdHlwZTogJ21hcC1iYXNlLWxheWVycy1sb2FkZWQnLCBtYXBJZCA6IHRoaXMubWFwSWR9KTtcblxuICAgIH1cblxuICAgIG9uTG9hZGVkQmFzZUxheWVycyhldmVudCkge1xuICAgICAgICB0aGlzLl9sYXllcnMgPSBldmVudC5iYXNlTGF5ZXJHcm91cC5sYXllcnM7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLl9zZWxlY3QudGV4dENvbnRlbnQgPSAnJztcbiAgICAgICAgdGhpcy5fbGF5ZXJzLmZvckVhY2goKGxheWVyKSA9PiB7XG4gICAgICAgICAgICBsZXQgbmV3Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgICAgICAgICAgbmV3Tm9kZS5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgbGF5ZXIubGF5ZXJJZCk7XG4gICAgICAgICAgICBpZiAobGF5ZXIudmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIG5ld05vZGUuc2V0QXR0cmlidXRlKCdzZWxlY3RlZCcsICdzZWxlY3RlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3Tm9kZS5pbm5lclRleHQgPSBsYXllci5sYXllck5hbWU7XG5cbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdC5hcHBlbmRDaGlsZChuZXdOb2RlKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4iLCJpbXBvcnQgJ29sL29sLmNzcyc7XG5cbi8vIE9MTWFwIGFuZCBub3QgTWFwIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIGdsb2JhbCBvYmplY3QgTWFwXG5pbXBvcnQgT0xNYXAgZnJvbSAnb2wvTWFwLmpzJztcbmltcG9ydCBWaWV3IGZyb20gJ29sL1ZpZXcuanMnO1xuaW1wb3J0IExheWVyR3JvdXAgZnJvbSBcIm9sL2xheWVyL0dyb3VwXCI7XG5pbXBvcnQgVGlsZUxheWVyIGZyb20gJ29sL2xheWVyL1RpbGUuanMnO1xuaW1wb3J0IE9TTSBmcm9tICdvbC9zb3VyY2UvT1NNLmpzJztcbmltcG9ydCBTdGFtZW4gZnJvbSBcIm9sL3NvdXJjZS9TdGFtZW5cIjtcblxuaW1wb3J0IHsgTWFpbkV2ZW50RGlzcGF0Y2hlciB9IGZyb20gXCIuLi9tb2R1bGVzL0xpem1hcEdsb2JhbHNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGl6bWFwTWFwRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLl9PTE1hcCA9IG51bGw7XG4gICAgICAgIHRoaXMuX09MbGF5ZXJHcm91cCA9IG51bGw7XG4gICAgICAgIHRoaXMuX21hcElkID0gJyc7XG4gICAgfVxuXG4gICAgZ2V0IG1hcElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwSWQ7XG4gICAgfVxuXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIHRoaXMuX21hcElkID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ21hcC1pZCcpO1xuXG4gICAgICAgIE1haW5FdmVudERpc3BhdGNoZXIuYWRkTGlzdGVuZXIodGhpcy5vbkxvYWRlZE1hcENvbmZpZy5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgeyB0eXBlOiAnbWFwLWNvbmZpZy1sb2FkZWQnLCBtYXBJZDogdGhpcy5tYXBJZCB9KTtcblxuICAgICAgICBNYWluRXZlbnREaXNwYXRjaGVyLmFkZExpc3RlbmVyKHRoaXMub25Mb2FkZWRCYXNlTGF5ZXJzLmJpbmQodGhpcyksXG4gICAgICAgICAgICB7IHR5cGU6ICdtYXAtYmFzZS1sYXllcnMtbG9hZGVkJywgbWFwSWQ6IHRoaXMubWFwSWQgfSk7XG5cbiAgICAgICAgTWFpbkV2ZW50RGlzcGF0Y2hlci5hZGRMaXN0ZW5lcih0aGlzLm9uQmFzZUxheWVyVmlzaWJpbGl0eS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgeyB0eXBlOiAnbWFwLWJhc2UtbGF5ZXJzLXZpc2liaWxpdHknLCBtYXBJZDogdGhpcy5tYXBJZCB9KTtcblxuICAgICAgICBNYWluRXZlbnREaXNwYXRjaGVyLmFkZExpc3RlbmVyKHRoaXMub25ab29tU2V0LmJpbmQodGhpcyksXG4gICAgICAgICAgICB7IHR5cGU6ICdtYXAtem9vbS1zZXQnLCBtYXBJZDogdGhpcy5tYXBJZCB9KTtcbiAgICB9XG5cbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgTWFpbkV2ZW50RGlzcGF0Y2hlci5yZW1vdmVMaXN0ZW5lcih0aGlzLm9uTG9hZGVkTWFwQ29uZmlnLmJpbmQodGhpcyksXG4gICAgICAgICAgICB7IHR5cGU6ICdtYXAtY29uZmlnLWxvYWRlZCcsIG1hcElkOiB0aGlzLm1hcElkIH0pO1xuXG4gICAgICAgIE1haW5FdmVudERpc3BhdGNoZXIucmVtb3ZlTGlzdGVuZXIodGhpcy5vbkxvYWRlZEJhc2VMYXllcnMuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHsgdHlwZTogJ21hcC1iYXNlLWxheWVycy1sb2FkZWQnLCBtYXBJZDogdGhpcy5tYXBJZCB9KTtcblxuICAgICAgICBNYWluRXZlbnREaXNwYXRjaGVyLnJlbW92ZUxpc3RlbmVyKHRoaXMub25CYXNlTGF5ZXJWaXNpYmlsaXR5LmJpbmQodGhpcyksXG4gICAgICAgICAgICB7IHR5cGU6ICdtYXAtYmFzZS1sYXllcnMtdmlzaWJpbGl0eScsIG1hcElkOiB0aGlzLm1hcElkIH0pO1xuXG4gICAgICAgIE1haW5FdmVudERpc3BhdGNoZXIucmVtb3ZlTGlzdGVuZXIodGhpcy5vblpvb21TZXQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHsgdHlwZTogJ21hcC16b29tLXNldCcsIG1hcElkOiB0aGlzLm1hcElkIH0pO1xuXG4gICAgfVxuXG4gICAgb25Mb2FkZWRNYXBDb25maWcoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5fbWFwSWQgPSBldmVudC5tYXBJZDtcblxuICAgICAgICB0aGlzLl9PTE1hcCA9IG5ldyBPTE1hcCh7XG4gICAgICAgICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICAgICAgICB2aWV3OiBuZXcgVmlldyh7XG4gICAgICAgICAgICAgICAgY2VudGVyOiBbMCwgMF0sXG4gICAgICAgICAgICAgICAgem9vbTogdGhpcy5fem9vbVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fT0xNYXAuZ2V0VmlldygpLmZpdChldmVudC5jb25maWcub3B0aW9ucy5pbml0aWFsRXh0ZW50KTtcblxuICAgIH1cblxuICAgIG9uTG9hZGVkQmFzZUxheWVycyhldmVudCkge1xuICAgICAgICBsZXQgT0xMYXllcnMgPSBldmVudC5iYXNlTGF5ZXJHcm91cC5sYXllcnMubWFwKChsYXllcikgPT4ge1xuICAgICAgICAgICAgbGV0IG9sTGF5ZXI7XG4gICAgICAgICAgICBpZiAobGF5ZXIubGF5ZXJJZCA9PT0gJ29zbU1hcG5paycpIHtcbiAgICAgICAgICAgICAgICBvbExheWVyID0gbmV3IFRpbGVMYXllcih7XG4gICAgICAgICAgICAgICAgICAgIGxheWVySWQ6IGxheWVyLmxheWVySWQsXG4gICAgICAgICAgICAgICAgICAgIHZpc2libGU6IGxheWVyLnZpc2libGUsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogbmV3IE9TTSgpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGF5ZXIubGF5ZXJJZCA9PT0gJ29zbVN0YW1lblRvbmVyJykge1xuICAgICAgICAgICAgICAgIG9sTGF5ZXIgPSBuZXcgVGlsZUxheWVyKHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJJZDogbGF5ZXIubGF5ZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZTogbGF5ZXIudmlzaWJsZSxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBuZXcgU3RhbWVuKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyOiAndG9uZXInXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2xMYXllcjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fT0xsYXllckdyb3VwID0gbmV3IExheWVyR3JvdXAoe1xuICAgICAgICAgICAgbGF5ZXJzOiBPTExheWVyc1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9PTE1hcC5hZGRMYXllcih0aGlzLl9PTGxheWVyR3JvdXApO1xuICAgIH1cblxuICAgIG9uQmFzZUxheWVyVmlzaWJpbGl0eShldmVudCkge1xuICAgICAgICBsZXQgb2xMYXllcnMgPSB0aGlzLl9PTGxheWVyR3JvdXAuZ2V0TGF5ZXJzKCk7XG4gICAgICAgIGV2ZW50LmxheWVycy5mb3JFYWNoKChsem1MYXllciwgaWR4KSA9PiB7XG4gICAgICAgICAgICBvbExheWVycy5pdGVtKGlkeCkuc2V0VmlzaWJsZShsem1MYXllci52aXNpYmxlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb25ab29tU2V0KGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX09MTWFwLmdldFZpZXcoKS5zZXRab29tKGV2ZW50Lnpvb20pO1xuICAgIH1cbn1cbiIsImltcG9ydCBMaXptYXBNYXBFbGVtZW50IGZyb20gJy4vY29tcG9uZW50cy9MaXptYXBNYXBFbGVtZW50LmpzJztcbmltcG9ydCBMaXptYXBCYXNlTGF5ZXJzRWxlbWVudCBmcm9tICcuL2NvbXBvbmVudHMvTGl6bWFwQmFzZUxheWVyc0VsZW1lbnQuanMnO1xuaW1wb3J0IHsgTGl6bWFwTWFwTWFuYWdlciwgTWFpbkV2ZW50RGlzcGF0Y2hlciB9IGZyb20gXCIuL21vZHVsZXMvTGl6bWFwR2xvYmFsc1wiO1xuXG5cbndpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2xpem1hcC1tYXAnLCBMaXptYXBNYXBFbGVtZW50KTtcbndpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2xpem1hcC1iYXNlbGF5ZXJzJywgTGl6bWFwQmFzZUxheWVyc0VsZW1lbnQpO1xuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uIChldmVudCkge1xuXG4gICAgTGl6bWFwTWFwTWFuYWdlci5jcmVhdGVNYXAoJ21haW5tYXAnLCBsaXpVcmxzLmNvbmZpZywgbGl6VXJscy5wYXJhbXMucmVwb3NpdG9yeSwgbGl6VXJscy5wYXJhbXMucHJvamVjdCk7XG5cbn0sIGZhbHNlKTtcblxuLyoqXG4gKiBPYmplY3QgdGhhdCBleHBvcnQgQVBJIGZvciBleHRlcm5hbCBzY3JpcHRzLlxuICovXG5jb25zdCBtYWluID0ge1xuICAgIG1hbmFnZXI6IExpem1hcE1hcE1hbmFnZXIsXG4gICAgZGlzcGF0Y2hlcjogTWFpbkV2ZW50RGlzcGF0Y2hlclxufTtcblxuZXhwb3J0IHsgbWFpbiBhcyBkZWZhdWx0IH07XG4iLCIvKipcbiAqIEV4cG9ydCBnbG9iYWwgb2JqZWN0cyBuZWVkZWQgYnkgbGl6bWFwIGNvbXBvbmVudHMgYW5kIGNsYXNzZXNcbiAqIEludGVybmFsIHVzZSBvbmx5XG4gKi9cblxuaW1wb3J0IEV2ZW50RGlzcGF0Y2hlciBmcm9tICcuLi91dGlscy9FdmVudERpc3BhdGNoZXIuanMnO1xuaW1wb3J0IExpem1hcE1hcE1hbmFnZXIgZnJvbSAnLi9MaXptYXBNYXBNYW5hZ2VyJztcblxuY29uc3QgTWFpbkV2ZW50RGlzcGF0Y2hlciA9IG5ldyBFdmVudERpc3BhdGNoZXIoKTtcblxuZXhwb3J0ICB7XG4gICAgTWFpbkV2ZW50RGlzcGF0Y2hlcixcbiAgICBMaXptYXBNYXBNYW5hZ2VyXG59O1xuIiwiXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpem1hcExheWVyIHtcbiAgICBjb25zdHJ1Y3RvcihsYXllcklkLCBuYW1lLCB2aXNpYmxlKSB7XG5cbiAgICAgICAgdGhpcy5fbGF5ZXJJZCA9IGxheWVySWQ7XG4gICAgICAgIHRoaXMuX2xheWVyTmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSB2aXNpYmxlO1xuICAgIH1cblxuICAgIGdldCBsYXllcklkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGF5ZXJJZDtcbiAgICB9XG5cbiAgICBnZXQgbGF5ZXJOYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGF5ZXJOYW1lO1xuICAgIH1cblxuICAgIGdldCB2aXNpYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZTtcbiAgICB9XG5cbiAgICBzZXQgdmlzaWJsZSh2YWwpIHtcbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IHZhbDtcbiAgICB9XG5cblxufSIsImltcG9ydCBMaXptYXBMYXllciBmcm9tICcuL0xpem1hcExheWVyLmpzJztcbmltcG9ydCBMYXllckdyb3VwIGZyb20gJ29sL2xheWVyL0dyb3VwJztcbmltcG9ydCB7TWFpbkV2ZW50RGlzcGF0Y2hlcn0gZnJvbSBcIi4vTGl6bWFwR2xvYmFsc1wiO1xuXG4vLyBhdHRyaWJ1dCBzZWxlY3RlZFxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGl6bWFwTGF5ZXJHcm91cCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1hcElkXG4gICAgICogQHBhcmFtIHtMaXptYXBMYXllcltdfSBsYXllcnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0X29wdGlvbnNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtYXBJZCwgbGF5ZXJzLCBvcHRfb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9tYXBJZCA9IG1hcElkO1xuICAgICAgICB0aGlzLl9tdXR1YWxseUV4Y2x1c2l2ZSA9IG9wdF9vcHRpb25zLm11dHVhbGx5RXhjbHVzaXZlO1xuXG4gICAgICAgIHRoaXMuX2xpem1hcExheWVycyA9IGxheWVycztcbiAgICB9XG5cbiAgICAvLyBNYWtlIGNsYXNzIGl0ZXJhYmxlXG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIGxldCBpbmRleCA9IC0xO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0OiAoKSA9PiAoeyB2YWx1ZTogdGhpcy5fbGl6bWFwTGF5ZXJzWysraW5kZXhdLCBkb25lOiAhKGluZGV4IGluIHRoaXMuX2xpem1hcExheWVycykgfSlcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgZ2V0IGxheWVycyAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saXptYXBMYXllcnM7XG4gICAgfVxuXG4gICAgc2V0IGxheWVyVmlzaWJsZShsYXllcklkKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbGl6bWFwTGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBTZXQgdmlzaWJpbGl0eSB0byBmYWxzZSB3aGVuIG11dHVhbGx5IGV4Y2x1c2l2ZVxuICAgICAgICAgICAgaWYgKHRoaXMuX211dHVhbGx5RXhjbHVzaXZlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGl6bWFwTGF5ZXJzW2ldLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9saXptYXBMYXllcnNbaV0ubGF5ZXJJZCA9PT0gbGF5ZXJJZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpem1hcExheWVyc1tpXS52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBNYWluRXZlbnREaXNwYXRjaGVyLmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdtYXAtYmFzZS1sYXllcnMtdmlzaWJpbGl0eScsXG4gICAgICAgICAgICBtYXBJZCA6IHRoaXMuX21hcElkLFxuICAgICAgICAgICAgbGF5ZXJzIDogdGhpcy5fbGl6bWFwTGF5ZXJzXG4gICAgICAgIH0pXG4gICAgfVxufSIsImltcG9ydCB7TWFpbkV2ZW50RGlzcGF0Y2hlcn0gZnJvbSBcIi4vTGl6bWFwR2xvYmFsc1wiO1xuaW1wb3J0IExpem1hcExheWVyR3JvdXAgZnJvbSBcIi4vTGl6bWFwTGF5ZXJHcm91cFwiO1xuaW1wb3J0IExpem1hcExheWVyIGZyb20gXCIuL0xpem1hcExheWVyXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpem1hcE1hcCB7XG5cbiAgICBjb25zdHJ1Y3RvciAobWFwSWQsIHJlcG9zaXRvcnksIHByb2plY3QpIHtcbiAgICAgICAgdGhpcy5fbWFwSWQgPSBtYXBJZDtcbiAgICAgICAgdGhpcy5fcmVwb3NpdG9yeU5hbWUgPSByZXBvc2l0b3J5O1xuICAgICAgICB0aGlzLl9wcm9qZWN0TmFtZSA9IHByb2plY3Q7XG4gICAgfVxuXG4gICAgc2V0Q29uZmlnKGNvbmZpZykge1xuICAgICAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG4gICAgICAgIE1haW5FdmVudERpc3BhdGNoZXIuZGlzcGF0Y2goe1xuICAgICAgICAgICAgIHR5cGU6IFwibWFwLWNvbmZpZy1sb2FkZWRcIixcbiAgICAgICAgICAgICBtYXBJZDogdGhpcy5fbWFwSWQsXG4gICAgICAgICAgICAgY29uZmlnOiB0aGlzLl9jb25maWdcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGxldCBiYXNlTGF5ZXJzID0gW107XG4gICAgICAgIGZvciAobGV0IG9wdGlvbiBpbiBjb25maWcub3B0aW9ucykge1xuICAgICAgICAgICAgaWYob3B0aW9uID09PSAnb3NtTWFwbmlrJyl7XG4gICAgICAgICAgICAgICAgYmFzZUxheWVycy5wdXNoKG5ldyBMaXptYXBMYXllcihvcHRpb24sICdPU00nLCBjb25maWcub3B0aW9ucy5zdGFydHVwQmFzZWxheWVyID09PSBcIm9zbS1tYXBuaWtcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYob3B0aW9uID09PSAnb3NtU3RhbWVuVG9uZXInKXtcbiAgICAgICAgICAgICAgICBiYXNlTGF5ZXJzLnB1c2gobmV3IExpem1hcExheWVyKG9wdGlvbiwgJ09TTSBUb25lcicsIGNvbmZpZy5vcHRpb25zLnN0YXJ0dXBCYXNlbGF5ZXIgPT09IFwib3NtLXN0YW1lbi10b25lclwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9iYXNlTGF5ZXJHcm91cCA9IG5ldyBMaXptYXBMYXllckdyb3VwKHRoaXMuX21hcElkLCBiYXNlTGF5ZXJzLCB7bXV0dWFsbHlFeGNsdXNpdmU6IHRydWV9KTtcblxuICAgICAgICBNYWluRXZlbnREaXNwYXRjaGVyLmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwibWFwLWJhc2UtbGF5ZXJzLWxvYWRlZFwiLFxuICAgICAgICAgICAgbWFwSWQ6IHRoaXMuX21hcElkLFxuICAgICAgICAgICAgYmFzZUxheWVyR3JvdXA6IHRoaXMuX2Jhc2VMYXllckdyb3VwXG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgZ2V0IHpvb20gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fem9vbTtcbiAgICB9XG5cbiAgICBnZXQgYmFzZUxheWVyR3JvdXAgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmFzZUxheWVyR3JvdXA7XG4gICAgfVxufSIsImltcG9ydCBMaXptYXBNYXAgZnJvbSAnLi9MaXptYXBNYXAnO1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVwb3NpdG9yeVxuICogQHBhcmFtIHtTdHJpbmd9IHByb2plY3RcbiAqIEByZXR1cm5zIHtQcm9taXNlfVxuICovXG5hc3luYyBmdW5jdGlvbiBsb2FkTWFwQ29uZmlnKGNvbmZpZ1VSTCwgcmVwb3NpdG9yeSwgcHJvamVjdCkge1xuICAgIC8vIGh0dHAgcmVxdWVzdCB0byByZXRyaWV2ZSB0aGUgXCJjb25maWdcIlxuICAgIGNvbnN0IGNvbmZpZyA9IGF3YWl0IGZldGNoKGNvbmZpZ1VSTCArICc/cmVwb3NpdG9yeT0nICsgcmVwb3NpdG9yeSArICcmcHJvamVjdD0nICsgcHJvamVjdClcbiAgICAgICAgLnRoZW4oKHJlc3ApID0+IHJlc3AuanNvbigpKTtcblxuICAgIHJldHVybiBjb25maWc7XG59XG5cbmNvbnN0IG1hcHMgPSB7fTtcblxuY29uc3QgTGl6bWFwTWFwTWFuYWdlciA9IHtcblxuICAgIGNyZWF0ZU1hcDogYXN5bmMgZnVuY3Rpb24gKG1hcElkLCBjb25maWdVUkwsIHJlcG9zaXRvcnksIHByb2plY3QpIHtcbiAgICAgICAgaWYgKG1hcElkIGluIG1hcHMpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXBzW21hcElkXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjb25maWcgPSBhd2FpdCBsb2FkTWFwQ29uZmlnKGNvbmZpZ1VSTCwgcmVwb3NpdG9yeSwgcHJvamVjdCk7XG4gICAgICAgIG1hcHNbbWFwSWRdID0gbmV3IExpem1hcE1hcChtYXBJZCwgcmVwb3NpdG9yeSwgcHJvamVjdCk7XG4gICAgICAgIG1hcHNbbWFwSWRdLnNldENvbmZpZyhjb25maWcpO1xuICAgICAgICByZXR1cm4gbWFwc1ttYXBJZF07XG4gICAgfSxcblxuICAgIGdldE1hcDogZnVuY3Rpb24gKG1hcElkKSB7XG4gICAgICAgIGlmIChtYXBJZCBpbiBtYXBzKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFwc1ttYXBJZF07XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5leHBvcnQgeyBMaXptYXBNYXBNYW5hZ2VyIGFzIGRlZmF1bHQgfTtcblxuIiwiLyoqXG4gKiBVSSBjb21wb25lbnRzIG9yIGFueSBvdGhlciBjb21wb25lbnRzIGNhbiBiZSBub3RpZmllZCBieSB0aGlzIG9iamVjdCBvZiBzb21lXG4gKiBhcHBsaWNhdGlvbiBldmVudHMsIGluIG9yZGVyIHRvIHVwZGF0ZSB0aGVpciBzdGF0ZSBvciB0byBkbyBzb21ldGhpbmdcbiAqXG4gKiBAdmVyc2lvbiAwLjFcbiAqIEBhdXRob3IgTGF1cmVudCBKb3Vhbm5lYXVcbiAqIEBsaWNlbmNlIE1JVFxuICogQGNvcHlyaWdodCAzTGl6IDIwMTlcbiAqL1xuXG4vKipcbiAqIERpc3BhdGNoIHNvbWUgYXBwbGljYXRpb24gZXZlbnRzIHRvIGxpc3RlbmVyc1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFdmVudERpc3BhdGNoZXIge1xuXG4gICAgY29uc3RydWN0b3IgKCkge1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBhZGQgYSBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgY2FsbGVkIGZvciBvbmUgb3Igc2V2ZXJhbCBnaXZlbiBldmVudHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd8T2JqZWN0fSBzdXBwb3J0ZWRFdmVudHMgZXZlbnRzIG9uIHdoaWNoIHRoZSBsaXN0ZW5lciB3aWxsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgIGJlIGNhbGxlZC4gaWYgdW5kZWZpbmVkIG9yIFwiKlwiLCBpdCB3aWxsIGJlIGNhbGxlZCBmb3IgYW55IGV2ZW50c1xuICAgICAqL1xuICAgIGFkZExpc3RlbmVyIChsaXN0ZW5lciwgc3VwcG9ydGVkRXZlbnRzICkge1xuXG4gICAgICAgIGlmIChzdXBwb3J0ZWRFdmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3VwcG9ydGVkRXZlbnRzID0gXCIqXCJcbiAgICAgICAgfVxuICAgICAgICBsZXQgYXBwZW5kID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGV2ZW50XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEoZXZlbnQudHlwZSBpbiB0aGlzLl9saXN0ZW5lcnMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW2V2ZW50LnR5cGVdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNbZXZlbnQudHlwZV0ucHVzaChbbGlzdGVuZXIsIGV2ZW50XSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3VwcG9ydGVkRXZlbnRzKSkge1xuICAgICAgICAgICAgc3VwcG9ydGVkRXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50ID09PSBcIipcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFwcGVuZChldmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFwcGVuZChzdXBwb3J0ZWRFdmVudHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIGEgbGlzdGVuZXIgdGhhdCBpcyBhc3NvY2lhdGVkIGZvciBvbmUgb3Igc2V2ZXJhbCBnaXZlbiBldmVudHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IHN1cHBvcnRlZEV2ZW50cyBsaXN0IG9mIGV2ZW50cyBmcm9tIHdoaWNoIHRoZSBsaXN0ZW5lclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICB3aWxsIGJlIHJlbW92ZWQuIGlmIHVuZGVmaW5lZCBvciBcIipcIiwgaXQgd2lsbCBiZSByZW1vdmVkIGZyb20gYW55IGV2ZW50c1xuICAgICAqL1xuICAgIHJlbW92ZUxpc3RlbmVyIChsaXN0ZW5lciwgc3VwcG9ydGVkRXZlbnRzKSB7XG5cbiAgICAgICAgaWYgKHN1cHBvcnRlZEV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdXBwb3J0ZWRFdmVudHMgPSBcIipcIlxuICAgICAgICB9XG4gICAgICAgIGxldCByZW1vdmUgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBldmVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogZXZlbnRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgaW4gdGhpcy5fbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByb3BlcnRpZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhldmVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW2V2ZW50LnR5cGVdID0gdGhpcy5fbGlzdGVuZXJzW2V2ZW50LnR5cGVdLmZpbHRlcigoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgW2xpc3RlbmVyLCBleHBlY3RlZEV2ZW50XSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMuZm9yRWFjaCgocHJvcE5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2ggfHwgcHJvcE5hbWUgPT0gJ3R5cGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEocHJvcE5hbWUgaW4gZXhwZWN0ZWRFdmVudCkgfHwgZXZlbnRbcHJvcE5hbWVdICE9IGV4cGVjdGVkRXZlbnRbcHJvcE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhbWF0Y2g7IC8vIHJlbW92ZSBhbGwgZXZlbnRzIHRoYXQgbWF0Y2ggdGhlIGdpdmVuIGV2ZW50XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3VwcG9ydGVkRXZlbnRzKSkge1xuICAgICAgICAgICAgc3VwcG9ydGVkRXZlbnRzLmZvckVhY2gocmVtb3ZlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdXBwb3J0ZWRFdmVudHMgPT0gXCIqXCIpIHtcbiAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMuX2xpc3RlbmVycykuZm9yRWFjaChyZW1vdmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVtb3ZlKHN1cHBvcnRlZEV2ZW50cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsIGxpc3RlbmVycyBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIGV2ZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGV2ZW50ICBhbiBldmVudCBuYW1lLCBvciBhbiBvYmplY3Qgd2l0aCBhICd0eXBlJ1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5IGhhdmluZyB0aGUgZXZlbnQgbmFtZS4gSW4gdGhpc1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2Ugb3RoZXIgcHJvcGVydGllcyBhcmUgcGFyYW1ldGVycyBmb3JcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuXG4gICAgICovXG4gICAgZGlzcGF0Y2ggKGV2ZW50KSB7XG4gICAgICAgIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgZXZlbnQgKSB7XG4gICAgICAgICAgICBldmVudCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBldmVudFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudC50eXBlID09IFwiKlwiKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIk5vdGlmaWNhdGlvbiBmb3IgYWxsIGV2ZW50cyBpcyBub3QgYWxsb3dlZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudC50eXBlIGluIHRoaXMuX2xpc3RlbmVycykge1xuICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW2V2ZW50LnR5cGVdLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgW2xpc3RlbmVyLCBleHBlY3RlZEV2ZW50XSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgbGV0IG1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhleHBlY3RlZEV2ZW50KS5mb3JFYWNoKChwcm9wTmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoIHx8IHByb3BOYW1lID09ICd0eXBlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHByb3BOYW1lIGluIGV2ZW50KSB8fCBldmVudFtwcm9wTmFtZV0gIT0gZXhwZWN0ZWRFdmVudFtwcm9wTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcIipcIiBpbiB0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVyc1tcIipcIl0uZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKGV2ZW50KSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4iXSwic291cmNlUm9vdCI6IiJ9