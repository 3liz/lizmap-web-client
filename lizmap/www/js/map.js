/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/ol/ol.css":
/*!**********************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/ol/ol.css ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js")(false);
// Module
exports.push([module.i, ".ol-box {\n  box-sizing: border-box;\n  border-radius: 2px;\n  border: 2px solid blue;\n}\n\n.ol-mouse-position {\n  top: 8px;\n  right: 8px;\n  position: absolute;\n}\n\n.ol-scale-line {\n  background: rgba(0,60,136,0.3);\n  border-radius: 4px;\n  bottom: 8px;\n  left: 8px;\n  padding: 2px;\n  position: absolute;\n}\n.ol-scale-line-inner {\n  border: 1px solid #eee;\n  border-top: none;\n  color: #eee;\n  font-size: 10px;\n  text-align: center;\n  margin: 1px;\n  will-change: contents, width;\n}\n.ol-overlay-container {\n  will-change: left,right,top,bottom;\n}\n\n.ol-unsupported {\n  display: none;\n}\n.ol-viewport, .ol-unselectable {\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n.ol-selectable {\n  -webkit-touch-callout: default;\n  -webkit-user-select: text;\n  -moz-user-select: text;\n  -ms-user-select: text;\n  user-select: text;\n}\n.ol-grabbing {\n  cursor: -webkit-grabbing;\n  cursor: -moz-grabbing;\n  cursor: grabbing;\n}\n.ol-grab {\n  cursor: move;\n  cursor: -webkit-grab;\n  cursor: -moz-grab;\n  cursor: grab;\n}\n.ol-control {\n  position: absolute;\n  background-color: rgba(255,255,255,0.4);\n  border-radius: 4px;\n  padding: 2px;\n}\n.ol-control:hover {\n  background-color: rgba(255,255,255,0.6);\n}\n.ol-zoom {\n  top: .5em;\n  left: .5em;\n}\n.ol-rotate {\n  top: .5em;\n  right: .5em;\n  transition: opacity .25s linear, visibility 0s linear;\n}\n.ol-rotate.ol-hidden {\n  opacity: 0;\n  visibility: hidden;\n  transition: opacity .25s linear, visibility 0s linear .25s;\n}\n.ol-zoom-extent {\n  top: 4.643em;\n  left: .5em;\n}\n.ol-full-screen {\n  right: .5em;\n  top: .5em;\n}\n@media print {\n  .ol-control {\n    display: none;\n  }\n}\n\n.ol-control button {\n  display: block;\n  margin: 1px;\n  padding: 0;\n  color: white;\n  font-size: 1.14em;\n  font-weight: bold;\n  text-decoration: none;\n  text-align: center;\n  height: 1.375em;\n  width: 1.375em;\n  line-height: .4em;\n  background-color: rgba(0,60,136,0.5);\n  border: none;\n  border-radius: 2px;\n}\n.ol-control button::-moz-focus-inner {\n  border: none;\n  padding: 0;\n}\n.ol-zoom-extent button {\n  line-height: 1.4em;\n}\n.ol-compass {\n  display: block;\n  font-weight: normal;\n  font-size: 1.2em;\n  will-change: transform;\n}\n.ol-touch .ol-control button {\n  font-size: 1.5em;\n}\n.ol-touch .ol-zoom-extent {\n  top: 5.5em;\n}\n.ol-control button:hover,\n.ol-control button:focus {\n  text-decoration: none;\n  background-color: rgba(0,60,136,0.7);\n}\n.ol-zoom .ol-zoom-in {\n  border-radius: 2px 2px 0 0;\n}\n.ol-zoom .ol-zoom-out {\n  border-radius: 0 0 2px 2px;\n}\n\n\n.ol-attribution {\n  text-align: right;\n  bottom: .5em;\n  right: .5em;\n  max-width: calc(100% - 1.3em);\n}\n\n.ol-attribution ul {\n  margin: 0;\n  padding: 0 .5em;\n  font-size: .7rem;\n  line-height: 1.375em;\n  color: #000;\n  text-shadow: 0 0 2px #fff;\n}\n.ol-attribution li {\n  display: inline;\n  list-style: none;\n  line-height: inherit;\n}\n.ol-attribution li:not(:last-child):after {\n  content: \" \";\n}\n.ol-attribution img {\n  max-height: 2em;\n  max-width: inherit;\n  vertical-align: middle;\n}\n.ol-attribution ul, .ol-attribution button {\n  display: inline-block;\n}\n.ol-attribution.ol-collapsed ul {\n  display: none;\n}\n.ol-attribution:not(.ol-collapsed) {\n  background: rgba(255,255,255,0.8);\n}\n.ol-attribution.ol-uncollapsible {\n  bottom: 0;\n  right: 0;\n  border-radius: 4px 0 0;\n  height: 1.1em;\n  line-height: 1em;\n}\n.ol-attribution.ol-uncollapsible img {\n  margin-top: -.2em;\n  max-height: 1.6em;\n}\n.ol-attribution.ol-uncollapsible button {\n  display: none;\n}\n\n.ol-zoomslider {\n  top: 4.5em;\n  left: .5em;\n  height: 200px;\n}\n.ol-zoomslider button {\n  position: relative;\n  height: 10px;\n}\n\n.ol-touch .ol-zoomslider {\n  top: 5.5em;\n}\n\n.ol-overviewmap {\n  left: 0.5em;\n  bottom: 0.5em;\n}\n.ol-overviewmap.ol-uncollapsible {\n  bottom: 0;\n  left: 0;\n  border-radius: 0 4px 0 0;\n}\n.ol-overviewmap .ol-overviewmap-map,\n.ol-overviewmap button {\n  display: inline-block;\n}\n.ol-overviewmap .ol-overviewmap-map {\n  border: 1px solid #7b98bc;\n  height: 150px;\n  margin: 2px;\n  width: 150px;\n}\n.ol-overviewmap:not(.ol-collapsed) button{\n  bottom: 1px;\n  left: 2px;\n  position: absolute;\n}\n.ol-overviewmap.ol-collapsed .ol-overviewmap-map,\n.ol-overviewmap.ol-uncollapsible button {\n  display: none;\n}\n.ol-overviewmap:not(.ol-collapsed) {\n  background: rgba(255,255,255,0.8);\n}\n.ol-overviewmap-box {\n  border: 2px dotted rgba(0,60,136,0.7);\n}\n\n.ol-overviewmap .ol-overviewmap-box:hover {\n  cursor: move;\n}\n", ""]);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], "{").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    for (var i = 0; i < this.length; i++) {
      // eslint-disable-next-line prefer-destructuring
      var id = this[i][0];

      if (id != null) {
        alreadyImportedModules[id] = true;
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = modules[_i]; // skip already imported module
      // this implementation is not 100% perfect for weird media query combinations
      // when a module is imported multiple times with different media queries.
      // I hope this will never occur (Hey this way we have smaller bundles)

      if (item[0] == null || !alreadyImportedModules[item[0]]) {
        if (mediaQuery && !item[2]) {
          item[2] = mediaQuery;
        } else if (mediaQuery) {
          item[2] = "(".concat(item[2], ") and (").concat(mediaQuery, ")");
        }

        list.push(item);
      }
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot).concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),

/***/ "./node_modules/ol/AssertionError.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/AssertionError.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ "./node_modules/ol/util.js");
/**
 * @module ol/AssertionError
 */


/**
 * Error object thrown when an assertion failed. This is an ECMA-262 Error,
 * extended with a `code` property.
 * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error.
 */
var AssertionError = /*@__PURE__*/(function (Error) {
  function AssertionError(code) {
    var path = _util_js__WEBPACK_IMPORTED_MODULE_0__["VERSION"] === 'latest' ? _util_js__WEBPACK_IMPORTED_MODULE_0__["VERSION"] : 'v' + _util_js__WEBPACK_IMPORTED_MODULE_0__["VERSION"].split('-')[0];
    var message = 'Assertion failed. See https://openlayers.org/en/' + path +
    '/doc/errors/#' + code + ' for details.';

    Error.call(this, message);

    /**
     * Error code. The meaning of the code can be found on
     * https://openlayers.org/en/latest/doc/errors/ (replace `latest` with
     * the version found in the OpenLayers script's header comment if a version
     * other than the latest is used).
     * @type {number}
     * @api
     */
    this.code = code;

    /**
     * @type {string}
     */
    this.name = 'AssertionError';

    // Re-assign message, see https://github.com/Rich-Harris/buble/issues/40
    this.message = message;
  }

  if ( Error ) AssertionError.__proto__ = Error;
  AssertionError.prototype = Object.create( Error && Error.prototype );
  AssertionError.prototype.constructor = AssertionError;

  return AssertionError;
}(Error));

/* harmony default export */ __webpack_exports__["default"] = (AssertionError);

//# sourceMappingURL=AssertionError.js.map

/***/ }),

/***/ "./node_modules/ol/Collection.js":
/*!***************************************!*\
  !*** ./node_modules/ol/Collection.js ***!
  \***************************************/
/*! exports provided: CollectionEvent, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CollectionEvent", function() { return CollectionEvent; });
/* harmony import */ var _AssertionError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AssertionError.js */ "./node_modules/ol/AssertionError.js");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CollectionEventType.js */ "./node_modules/ol/CollectionEventType.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./events/Event.js */ "./node_modules/ol/events/Event.js");
/**
 * @module ol/Collection
 */






/**
 * @enum {string}
 * @private
 */
var Property = {
  LENGTH: 'length'
};


/**
 * @classdesc
 * Events emitted by {@link module:ol/Collection~Collection} instances are instances of this
 * type.
 */
var CollectionEvent = /*@__PURE__*/(function (Event) {
  function CollectionEvent(type, opt_element) {
    Event.call(this, type);

    /**
     * The element that is added to or removed from the collection.
     * @type {*}
     * @api
     */
    this.element = opt_element;

  }

  if ( Event ) CollectionEvent.__proto__ = Event;
  CollectionEvent.prototype = Object.create( Event && Event.prototype );
  CollectionEvent.prototype.constructor = CollectionEvent;

  return CollectionEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_3__["default"]));


/**
 * @typedef {Object} Options
 * @property {boolean} [unique=false] Disallow the same item from being added to
 * the collection twice.
 */

/**
 * @classdesc
 * An expanded version of standard JS Array, adding convenience methods for
 * manipulation. Add and remove changes to the Collection trigger a Collection
 * event. Note that this does not cover changes to the objects _within_ the
 * Collection; they trigger events on the appropriate object, not on the
 * Collection as a whole.
 *
 * @fires CollectionEvent
 *
 * @template T
 * @api
 */
var Collection = /*@__PURE__*/(function (BaseObject) {
  function Collection(opt_array, opt_options) {

    BaseObject.call(this);

    var options = opt_options || {};

    /**
     * @private
     * @type {boolean}
     */
    this.unique_ = !!options.unique;

    /**
     * @private
     * @type {!Array<T>}
     */
    this.array_ = opt_array ? opt_array : [];

    if (this.unique_) {
      for (var i = 0, ii = this.array_.length; i < ii; ++i) {
        this.assertUnique_(this.array_[i], i);
      }
    }

    this.updateLength_();

  }

  if ( BaseObject ) Collection.__proto__ = BaseObject;
  Collection.prototype = Object.create( BaseObject && BaseObject.prototype );
  Collection.prototype.constructor = Collection;

  /**
   * Remove all elements from the collection.
   * @api
   */
  Collection.prototype.clear = function clear () {
    while (this.getLength() > 0) {
      this.pop();
    }
  };

  /**
   * Add elements to the collection.  This pushes each item in the provided array
   * to the end of the collection.
   * @param {!Array<T>} arr Array.
   * @return {Collection<T>} This collection.
   * @api
   */
  Collection.prototype.extend = function extend (arr) {
    for (var i = 0, ii = arr.length; i < ii; ++i) {
      this.push(arr[i]);
    }
    return this;
  };

  /**
   * Iterate over each element, calling the provided callback.
   * @param {function(T, number, Array<T>): *} f The function to call
   *     for every element. This function takes 3 arguments (the element, the
   *     index and the array). The return value is ignored.
   * @api
   */
  Collection.prototype.forEach = function forEach (f) {
    var array = this.array_;
    for (var i = 0, ii = array.length; i < ii; ++i) {
      f(array[i], i, array);
    }
  };

  /**
   * Get a reference to the underlying Array object. Warning: if the array
   * is mutated, no events will be dispatched by the collection, and the
   * collection's "length" property won't be in sync with the actual length
   * of the array.
   * @return {!Array<T>} Array.
   * @api
   */
  Collection.prototype.getArray = function getArray () {
    return this.array_;
  };

  /**
   * Get the element at the provided index.
   * @param {number} index Index.
   * @return {T} Element.
   * @api
   */
  Collection.prototype.item = function item (index) {
    return this.array_[index];
  };

  /**
   * Get the length of this collection.
   * @return {number} The length of the array.
   * @observable
   * @api
   */
  Collection.prototype.getLength = function getLength () {
    return this.get(Property.LENGTH);
  };

  /**
   * Insert an element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  Collection.prototype.insertAt = function insertAt (index, elem) {
    if (this.unique_) {
      this.assertUnique_(elem);
    }
    this.array_.splice(index, 0, elem);
    this.updateLength_();
    this.dispatchEvent(
      new CollectionEvent(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].ADD, elem));
  };

  /**
   * Remove the last element of the collection and return it.
   * Return `undefined` if the collection is empty.
   * @return {T|undefined} Element.
   * @api
   */
  Collection.prototype.pop = function pop () {
    return this.removeAt(this.getLength() - 1);
  };

  /**
   * Insert the provided element at the end of the collection.
   * @param {T} elem Element.
   * @return {number} New length of the collection.
   * @api
   */
  Collection.prototype.push = function push (elem) {
    if (this.unique_) {
      this.assertUnique_(elem);
    }
    var n = this.getLength();
    this.insertAt(n, elem);
    return this.getLength();
  };

  /**
   * Remove the first occurrence of an element from the collection.
   * @param {T} elem Element.
   * @return {T|undefined} The removed element or undefined if none found.
   * @api
   */
  Collection.prototype.remove = function remove (elem) {
    var arr = this.array_;
    for (var i = 0, ii = arr.length; i < ii; ++i) {
      if (arr[i] === elem) {
        return this.removeAt(i);
      }
    }
    return undefined;
  };

  /**
   * Remove the element at the provided index and return it.
   * Return `undefined` if the collection does not contain this index.
   * @param {number} index Index.
   * @return {T|undefined} Value.
   * @api
   */
  Collection.prototype.removeAt = function removeAt (index) {
    var prev = this.array_[index];
    this.array_.splice(index, 1);
    this.updateLength_();
    this.dispatchEvent(new CollectionEvent(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].REMOVE, prev));
    return prev;
  };

  /**
   * Set the element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  Collection.prototype.setAt = function setAt (index, elem) {
    var n = this.getLength();
    if (index < n) {
      if (this.unique_) {
        this.assertUnique_(elem, index);
      }
      var prev = this.array_[index];
      this.array_[index] = elem;
      this.dispatchEvent(
        new CollectionEvent(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].REMOVE, prev));
      this.dispatchEvent(
        new CollectionEvent(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].ADD, elem));
    } else {
      for (var j = n; j < index; ++j) {
        this.insertAt(j, undefined);
      }
      this.insertAt(index, elem);
    }
  };

  /**
   * @private
   */
  Collection.prototype.updateLength_ = function updateLength_ () {
    this.set(Property.LENGTH, this.array_.length);
  };

  /**
   * @private
   * @param {T} elem Element.
   * @param {number=} opt_except Optional index to ignore.
   */
  Collection.prototype.assertUnique_ = function assertUnique_ (elem, opt_except) {
    for (var i = 0, ii = this.array_.length; i < ii; ++i) {
      if (this.array_[i] === elem && i !== opt_except) {
        throw new _AssertionError_js__WEBPACK_IMPORTED_MODULE_0__["default"](58);
      }
    }
  };

  return Collection;
}(_Object_js__WEBPACK_IMPORTED_MODULE_2__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (Collection);

//# sourceMappingURL=Collection.js.map

/***/ }),

/***/ "./node_modules/ol/CollectionEventType.js":
/*!************************************************!*\
  !*** ./node_modules/ol/CollectionEventType.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/CollectionEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  /**
   * Triggered when an item is added to the collection.
   * @event module:ol/Collection.CollectionEvent#add
   * @api
   */
  ADD: 'add',
  /**
   * Triggered when an item is removed from the collection.
   * @event module:ol/Collection.CollectionEvent#remove
   * @api
   */
  REMOVE: 'remove'
});

//# sourceMappingURL=CollectionEventType.js.map

/***/ }),

/***/ "./node_modules/ol/Disposable.js":
/*!***************************************!*\
  !*** ./node_modules/ol/Disposable.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/Disposable
 */

/**
 * @classdesc
 * Objects that need to clean up after themselves.
 */
var Disposable = function Disposable() {
  /**
   * The object has already been disposed.
   * @type {boolean}
   * @private
   */
  this.disposed_ = false;
};

/**
 * Clean up.
 */
Disposable.prototype.dispose = function dispose () {
  if (!this.disposed_) {
    this.disposed_ = true;
    this.disposeInternal();
  }
};

/**
 * Extension point for disposable objects.
 * @protected
 */
Disposable.prototype.disposeInternal = function disposeInternal () {};

/* harmony default export */ __webpack_exports__["default"] = (Disposable);

//# sourceMappingURL=Disposable.js.map

/***/ }),

/***/ "./node_modules/ol/Feature.js":
/*!************************************!*\
  !*** ./node_modules/ol/Feature.js ***!
  \************************************/
/*! exports provided: createStyleFunction, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createStyleFunction", function() { return createStyleFunction; });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Object.js */ "./node_modules/ol/Object.js");
/**
 * @module ol/Feature
 */





/**
 * @typedef {typeof Feature|typeof import("./render/Feature.js").default} FeatureClass
 */

/**
 * @typedef {Feature|import("./render/Feature.js").default} FeatureLike
 */

/**
 * @classdesc
 * A vector object for geographic features with a geometry and other
 * attribute properties, similar to the features in vector file formats like
 * GeoJSON.
 *
 * Features can be styled individually with `setStyle`; otherwise they use the
 * style of their vector layer.
 *
 * Note that attribute properties are set as {@link module:ol/Object} properties on
 * the feature object, so they are observable, and have get/set accessors.
 *
 * Typically, a feature has a single geometry property. You can set the
 * geometry using the `setGeometry` method and get it with `getGeometry`.
 * It is possible to store more than one geometry on a feature using attribute
 * properties. By default, the geometry used for rendering is identified by
 * the property name `geometry`. If you want to use another geometry property
 * for rendering, use the `setGeometryName` method to change the attribute
 * property associated with the geometry for the feature.  For example:
 *
 * ```js
 *
 * import Feature from 'ol/Feature';
 * import Polygon from 'ol/geom/Polygon';
 * import Point from 'ol/geom/Point';
 *
 * var feature = new Feature({
 *   geometry: new Polygon(polyCoords),
 *   labelPoint: new Point(labelCoords),
 *   name: 'My Polygon'
 * });
 *
 * // get the polygon geometry
 * var poly = feature.getGeometry();
 *
 * // Render the feature as a point using the coordinates from labelPoint
 * feature.setGeometryName('labelPoint');
 *
 * // get the point geometry
 * var point = feature.getGeometry();
 * ```
 *
 * @api
 */
var Feature = /*@__PURE__*/(function (BaseObject) {
  function Feature(opt_geometryOrProperties) {

    BaseObject.call(this);

    /**
     * @private
     * @type {number|string|undefined}
     */
    this.id_ = undefined;

    /**
     * @type {string}
     * @private
     */
    this.geometryName_ = 'geometry';

    /**
     * User provided style.
     * @private
     * @type {import("./style/Style.js").StyleLike}
     */
    this.style_ = null;

    /**
     * @private
     * @type {import("./style/Style.js").StyleFunction|undefined}
     */
    this.styleFunction_ = undefined;

    /**
     * @private
     * @type {?import("./events.js").EventsKey}
     */
    this.geometryChangeKey_ = null;

    Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["listen"])(
      this, Object(_Object_js__WEBPACK_IMPORTED_MODULE_3__["getChangeEventType"])(this.geometryName_),
      this.handleGeometryChanged_, this);

    if (opt_geometryOrProperties) {
      if (typeof /** @type {?} */ (opt_geometryOrProperties).getSimplifiedGeometry === 'function') {
        var geometry = /** @type {import("./geom/Geometry.js").default} */ (opt_geometryOrProperties);
        this.setGeometry(geometry);
      } else {
        /** @type {Object<string, *>} */
        var properties = opt_geometryOrProperties;
        this.setProperties(properties);
      }
    }
  }

  if ( BaseObject ) Feature.__proto__ = BaseObject;
  Feature.prototype = Object.create( BaseObject && BaseObject.prototype );
  Feature.prototype.constructor = Feature;

  /**
   * Clone this feature. If the original feature has a geometry it
   * is also cloned. The feature id is not set in the clone.
   * @return {Feature} The clone.
   * @api
   */
  Feature.prototype.clone = function clone () {
    var clone = new Feature(this.getProperties());
    clone.setGeometryName(this.getGeometryName());
    var geometry = this.getGeometry();
    if (geometry) {
      clone.setGeometry(geometry.clone());
    }
    var style = this.getStyle();
    if (style) {
      clone.setStyle(style);
    }
    return clone;
  };

  /**
   * Get the feature's default geometry.  A feature may have any number of named
   * geometries.  The "default" geometry (the one that is rendered by default) is
   * set when calling {@link module:ol/Feature~Feature#setGeometry}.
   * @return {import("./geom/Geometry.js").default|undefined} The default geometry for the feature.
   * @api
   * @observable
   */
  Feature.prototype.getGeometry = function getGeometry () {
    return (
      /** @type {import("./geom/Geometry.js").default|undefined} */ (this.get(this.geometryName_))
    );
  };

  /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is either set when reading data from a remote source or set explicitly by
   * calling {@link module:ol/Feature~Feature#setId}.
   * @return {number|string|undefined} Id.
   * @api
   */
  Feature.prototype.getId = function getId () {
    return this.id_;
  };

  /**
   * Get the name of the feature's default geometry.  By default, the default
   * geometry is named `geometry`.
   * @return {string} Get the property name associated with the default geometry
   *     for this feature.
   * @api
   */
  Feature.prototype.getGeometryName = function getGeometryName () {
    return this.geometryName_;
  };

  /**
   * Get the feature's style. Will return what was provided to the
   * {@link module:ol/Feature~Feature#setStyle} method.
   * @return {import("./style/Style.js").StyleLike} The feature style.
   * @api
   */
  Feature.prototype.getStyle = function getStyle () {
    return this.style_;
  };

  /**
   * Get the feature's style function.
   * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
   * representing the current style of this feature.
   * @api
   */
  Feature.prototype.getStyleFunction = function getStyleFunction () {
    return this.styleFunction_;
  };

  /**
   * @private
   */
  Feature.prototype.handleGeometryChange_ = function handleGeometryChange_ () {
    this.changed();
  };

  /**
   * @private
   */
  Feature.prototype.handleGeometryChanged_ = function handleGeometryChanged_ () {
    if (this.geometryChangeKey_) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["unlistenByKey"])(this.geometryChangeKey_);
      this.geometryChangeKey_ = null;
    }
    var geometry = this.getGeometry();
    if (geometry) {
      this.geometryChangeKey_ = Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["listen"])(geometry,
        _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CHANGE, this.handleGeometryChange_, this);
    }
    this.changed();
  };

  /**
   * Set the default geometry for the feature.  This will update the property
   * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
   * @param {import("./geom/Geometry.js").default|undefined} geometry The new geometry.
   * @api
   * @observable
   */
  Feature.prototype.setGeometry = function setGeometry (geometry) {
    this.set(this.geometryName_, geometry);
  };

  /**
   * Set the style for the feature.  This can be a single style object, an array
   * of styles, or a function that takes a resolution and returns an array of
   * styles. If it is `null` the feature has no style (a `null` style).
   * @param {import("./style/Style.js").StyleLike} style Style for this feature.
   * @api
   * @fires module:ol/events/Event~Event#event:change
   */
  Feature.prototype.setStyle = function setStyle (style) {
    this.style_ = style;
    this.styleFunction_ = !style ? undefined : createStyleFunction(style);
    this.changed();
  };

  /**
   * Set the feature id.  The feature id is considered stable and may be used when
   * requesting features or comparing identifiers returned from a remote source.
   * The feature id can be used with the
   * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
   * @param {number|string|undefined} id The feature id.
   * @api
   * @fires module:ol/events/Event~Event#event:change
   */
  Feature.prototype.setId = function setId (id) {
    this.id_ = id;
    this.changed();
  };

  /**
   * Set the property name to be used when getting the feature's default geometry.
   * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
   * this name will be returned.
   * @param {string} name The property name of the default geometry.
   * @api
   */
  Feature.prototype.setGeometryName = function setGeometryName (name) {
    Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["unlisten"])(
      this, Object(_Object_js__WEBPACK_IMPORTED_MODULE_3__["getChangeEventType"])(this.geometryName_),
      this.handleGeometryChanged_, this);
    this.geometryName_ = name;
    Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["listen"])(
      this, Object(_Object_js__WEBPACK_IMPORTED_MODULE_3__["getChangeEventType"])(this.geometryName_),
      this.handleGeometryChanged_, this);
    this.handleGeometryChanged_();
  };

  return Feature;
}(_Object_js__WEBPACK_IMPORTED_MODULE_3__["default"]));


/**
 * Convert the provided object into a feature style function.  Functions passed
 * through unchanged.  Arrays of Style or single style objects wrapped
 * in a new feature style function.
 * @param {!import("./style/Style.js").StyleFunction|!Array<import("./style/Style.js").default>|!import("./style/Style.js").default} obj
 *     A feature style function, a single style, or an array of styles.
 * @return {import("./style/Style.js").StyleFunction} A style function.
 */
function createStyleFunction(obj) {
  if (typeof obj === 'function') {
    return obj;
  } else {
    /**
     * @type {Array<import("./style/Style.js").default>}
     */
    var styles;
    if (Array.isArray(obj)) {
      styles = obj;
    } else {
      Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(typeof /** @type {?} */ (obj).getZIndex === 'function',
        41); // Expected an `import("./style/Style.js").Style` or an array of `import("./style/Style.js").Style`
      var style = /** @type {import("./style/Style.js").default} */ (obj);
      styles = [style];
    }
    return function() {
      return styles;
    };
  }
}
/* harmony default export */ __webpack_exports__["default"] = (Feature);

//# sourceMappingURL=Feature.js.map

/***/ }),

/***/ "./node_modules/ol/ImageBase.js":
/*!**************************************!*\
  !*** ./node_modules/ol/ImageBase.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events/Target.js */ "./node_modules/ol/events/Target.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/**
 * @module ol/ImageBase
 */




/**
 * @abstract
 */
var ImageBase = /*@__PURE__*/(function (EventTarget) {
  function ImageBase(extent, resolution, pixelRatio, state) {

    EventTarget.call(this);

    /**
     * @protected
     * @type {import("./extent.js").Extent}
     */
    this.extent = extent;

    /**
     * @private
     * @type {number}
     */
    this.pixelRatio_ = pixelRatio;

    /**
     * @protected
     * @type {number|undefined}
     */
    this.resolution = resolution;

    /**
     * @protected
     * @type {import("./ImageState.js").default}
     */
    this.state = state;

  }

  if ( EventTarget ) ImageBase.__proto__ = EventTarget;
  ImageBase.prototype = Object.create( EventTarget && EventTarget.prototype );
  ImageBase.prototype.constructor = ImageBase;

  /**
   * @protected
   */
  ImageBase.prototype.changed = function changed () {
    this.dispatchEvent(_events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CHANGE);
  };

  /**
   * @return {import("./extent.js").Extent} Extent.
   */
  ImageBase.prototype.getExtent = function getExtent () {
    return this.extent;
  };

  /**
   * @abstract
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   */
  ImageBase.prototype.getImage = function getImage () {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * @return {number} PixelRatio.
   */
  ImageBase.prototype.getPixelRatio = function getPixelRatio () {
    return this.pixelRatio_;
  };

  /**
   * @return {number} Resolution.
   */
  ImageBase.prototype.getResolution = function getResolution () {
    return /** @type {number} */ (this.resolution);
  };

  /**
   * @return {import("./ImageState.js").default} State.
   */
  ImageBase.prototype.getState = function getState () {
    return this.state;
  };

  /**
   * Load not yet loaded URI.
   * @abstract
   */
  ImageBase.prototype.load = function load () {
    Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  return ImageBase;
}(_events_Target_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (ImageBase);

//# sourceMappingURL=ImageBase.js.map

/***/ }),

/***/ "./node_modules/ol/ImageCanvas.js":
/*!****************************************!*\
  !*** ./node_modules/ol/ImageCanvas.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ImageBase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ImageBase.js */ "./node_modules/ol/ImageBase.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ImageState.js */ "./node_modules/ol/ImageState.js");
/**
 * @module ol/ImageCanvas
 */




/**
 * A function that is called to trigger asynchronous canvas drawing.  It is
 * called with a "done" callback that should be called when drawing is done.
 * If any error occurs during drawing, the "done" callback should be called with
 * that error.
 *
 * @typedef {function(function(Error=))} Loader
 */


var ImageCanvas = /*@__PURE__*/(function (ImageBase) {
  function ImageCanvas(extent, resolution, pixelRatio, canvas, opt_loader) {

    var state = opt_loader !== undefined ? _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE : _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED;

    ImageBase.call(this, extent, resolution, pixelRatio, state);

    /**
     * Optional canvas loader function.
     * @type {?Loader}
     * @private
     */
    this.loader_ = opt_loader !== undefined ? opt_loader : null;

    /**
     * @private
     * @type {HTMLCanvasElement}
     */
    this.canvas_ = canvas;

    /**
     * @private
     * @type {Error}
     */
    this.error_ = null;

  }

  if ( ImageBase ) ImageCanvas.__proto__ = ImageBase;
  ImageCanvas.prototype = Object.create( ImageBase && ImageBase.prototype );
  ImageCanvas.prototype.constructor = ImageCanvas;

  /**
   * Get any error associated with asynchronous rendering.
   * @return {Error} Any error that occurred during rendering.
   */
  ImageCanvas.prototype.getError = function getError () {
    return this.error_;
  };

  /**
   * Handle async drawing complete.
   * @param {Error=} err Any error during drawing.
   * @private
   */
  ImageCanvas.prototype.handleLoad_ = function handleLoad_ (err) {
    if (err) {
      this.error_ = err;
      this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR;
    } else {
      this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED;
    }
    this.changed();
  };

  /**
   * @inheritDoc
   */
  ImageCanvas.prototype.load = function load () {
    if (this.state == _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE) {
      this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING;
      this.changed();
      this.loader_(this.handleLoad_.bind(this));
    }
  };

  /**
   * @return {HTMLCanvasElement} Canvas element.
   */
  ImageCanvas.prototype.getImage = function getImage () {
    return this.canvas_;
  };

  return ImageCanvas;
}(_ImageBase_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (ImageCanvas);

//# sourceMappingURL=ImageCanvas.js.map

/***/ }),

/***/ "./node_modules/ol/ImageState.js":
/*!***************************************!*\
  !*** ./node_modules/ol/ImageState.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/ImageState
 */

/**
 * @enum {number}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3
});

//# sourceMappingURL=ImageState.js.map

/***/ }),

/***/ "./node_modules/ol/ImageTile.js":
/*!**************************************!*\
  !*** ./node_modules/ol/ImageTile.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Tile.js */ "./node_modules/ol/Tile.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/**
 * @module ol/ImageTile
 */







var ImageTile = /*@__PURE__*/(function (Tile) {
  function ImageTile(tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options) {

    Tile.call(this, tileCoord, state, opt_options);

    /**
     * @private
     * @type {?string}
     */
    this.crossOrigin_ = crossOrigin;

    /**
     * Image URI
     *
     * @private
     * @type {string}
     */
    this.src_ = src;

    /**
     * @private
     * @type {HTMLImageElement|HTMLCanvasElement}
     */
    this.image_ = new Image();
    if (crossOrigin !== null) {
      this.image_.crossOrigin = crossOrigin;
    }

    /**
     * @private
     * @type {Array<import("./events.js").EventsKey>}
     */
    this.imageListenerKeys_ = null;

    /**
     * @private
     * @type {import("./Tile.js").LoadFunction}
     */
    this.tileLoadFunction_ = tileLoadFunction;

  }

  if ( Tile ) ImageTile.__proto__ = Tile;
  ImageTile.prototype = Object.create( Tile && Tile.prototype );
  ImageTile.prototype.constructor = ImageTile;

  /**
   * @inheritDoc
   */
  ImageTile.prototype.disposeInternal = function disposeInternal () {
    if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING) {
      this.unlistenImage_();
      this.image_ = getBlankImage();
    }
    if (this.interimTile) {
      this.interimTile.dispose();
    }
    this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ABORT;
    this.changed();
    Tile.prototype.disposeInternal.call(this);
  };

  /**
   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @api
   */
  ImageTile.prototype.getImage = function getImage () {
    return this.image_;
  };

  /**
   * @inheritDoc
   */
  ImageTile.prototype.getKey = function getKey () {
    return this.src_;
  };

  /**
   * Tracks loading or read errors.
   *
   * @private
   */
  ImageTile.prototype.handleImageError_ = function handleImageError_ () {
    this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR;
    this.unlistenImage_();
    this.image_ = getBlankImage();
    this.changed();
  };

  /**
   * Tracks successful image load.
   *
   * @private
   */
  ImageTile.prototype.handleImageLoad_ = function handleImageLoad_ () {
    var image = /** @type {HTMLImageElement} */ (this.image_);
    if (image.naturalWidth && image.naturalHeight) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED;
    } else {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].EMPTY;
    }
    this.unlistenImage_();
    this.changed();
  };

  /**
   * @inheritDoc
   * @api
   */
  ImageTile.prototype.load = function load () {
    if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE;
      this.image_ = new Image();
      if (this.crossOrigin_ !== null) {
        this.image_.crossOrigin = this.crossOrigin_;
      }
    }
    if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING;
      this.changed();
      this.imageListenerKeys_ = [
        Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listenOnce"])(this.image_, _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].ERROR,
          this.handleImageError_, this),
        Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listenOnce"])(this.image_, _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].LOAD,
          this.handleImageLoad_, this)
      ];
      this.tileLoadFunction_(this, this.src_);
    }
  };

  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */
  ImageTile.prototype.unlistenImage_ = function unlistenImage_ () {
    this.imageListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_3__["unlistenByKey"]);
    this.imageListenerKeys_ = null;
  };

  return ImageTile;
}(_Tile_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/**
 * Get a 1-pixel blank image.
 * @return {HTMLCanvasElement} Blank image.
 */
function getBlankImage() {
  var ctx = Object(_dom_js__WEBPACK_IMPORTED_MODULE_2__["createCanvasContext2D"])(1, 1);
  ctx.fillStyle = 'rgba(0,0,0,0)';
  ctx.fillRect(0, 0, 1, 1);
  return ctx.canvas;
}

/* harmony default export */ __webpack_exports__["default"] = (ImageTile);

//# sourceMappingURL=ImageTile.js.map

/***/ }),

/***/ "./node_modules/ol/Kinetic.js":
/*!************************************!*\
  !*** ./node_modules/ol/Kinetic.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/Kinetic
 */

/**
 * @classdesc
 * Implementation of inertial deceleration for map movement.
 *
 * @api
 */
var Kinetic = function Kinetic(decay, minVelocity, delay) {

  /**
   * @private
   * @type {number}
   */
  this.decay_ = decay;

  /**
   * @private
   * @type {number}
   */
  this.minVelocity_ = minVelocity;

  /**
   * @private
   * @type {number}
   */
  this.delay_ = delay;

  /**
   * @private
   * @type {Array<number>}
   */
  this.points_ = [];

  /**
   * @private
   * @type {number}
   */
  this.angle_ = 0;

  /**
   * @private
   * @type {number}
   */
  this.initialVelocity_ = 0;
};

/**
 * FIXME empty description for jsdoc
 */
Kinetic.prototype.begin = function begin () {
  this.points_.length = 0;
  this.angle_ = 0;
  this.initialVelocity_ = 0;
};

/**
 * @param {number} x X.
 * @param {number} y Y.
 */
Kinetic.prototype.update = function update (x, y) {
  this.points_.push(x, y, Date.now());
};

/**
 * @return {boolean} Whether we should do kinetic animation.
 */
Kinetic.prototype.end = function end () {
  if (this.points_.length < 6) {
    // at least 2 points are required (i.e. there must be at least 6 elements
    // in the array)
    return false;
  }
  var delay = Date.now() - this.delay_;
  var lastIndex = this.points_.length - 3;
  if (this.points_[lastIndex + 2] < delay) {
    // the last tracked point is too old, which means that the user stopped
    // panning before releasing the map
    return false;
  }

  // get the first point which still falls into the delay time
  var firstIndex = lastIndex - 3;
  while (firstIndex > 0 && this.points_[firstIndex + 2] > delay) {
    firstIndex -= 3;
  }

  var duration = this.points_[lastIndex + 2] - this.points_[firstIndex + 2];
  // we don't want a duration of 0 (divide by zero)
  // we also make sure the user panned for a duration of at least one frame
  // (1/60s) to compute sane displacement values
  if (duration < 1000 / 60) {
    return false;
  }

  var dx = this.points_[lastIndex] - this.points_[firstIndex];
  var dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];
  this.angle_ = Math.atan2(dy, dx);
  this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration;
  return this.initialVelocity_ > this.minVelocity_;
};

/**
 * @return {number} Total distance travelled (pixels).
 */
Kinetic.prototype.getDistance = function getDistance () {
  return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
};

/**
 * @return {number} Angle of the kinetic panning animation (radians).
 */
Kinetic.prototype.getAngle = function getAngle () {
  return this.angle_;
};

/* harmony default export */ __webpack_exports__["default"] = (Kinetic);

//# sourceMappingURL=Kinetic.js.map

/***/ }),

/***/ "./node_modules/ol/LayerType.js":
/*!**************************************!*\
  !*** ./node_modules/ol/LayerType.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/LayerType
 */

/**
 * A layer type used when creating layer renderers.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  IMAGE: 'IMAGE',
  TILE: 'TILE',
  VECTOR_TILE: 'VECTOR_TILE',
  VECTOR: 'VECTOR'
});

//# sourceMappingURL=LayerType.js.map

/***/ }),

/***/ "./node_modules/ol/Map.js":
/*!********************************!*\
  !*** ./node_modules/ol/Map.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _PluggableMap_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PluggableMap.js */ "./node_modules/ol/PluggableMap.js");
/* harmony import */ var _control_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./control/util.js */ "./node_modules/ol/control/util.js");
/* harmony import */ var _interaction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interaction.js */ "./node_modules/ol/interaction.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _renderer_canvas_ImageLayer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./renderer/canvas/ImageLayer.js */ "./node_modules/ol/renderer/canvas/ImageLayer.js");
/* harmony import */ var _renderer_canvas_Map_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./renderer/canvas/Map.js */ "./node_modules/ol/renderer/canvas/Map.js");
/* harmony import */ var _renderer_canvas_TileLayer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./renderer/canvas/TileLayer.js */ "./node_modules/ol/renderer/canvas/TileLayer.js");
/* harmony import */ var _renderer_canvas_VectorLayer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./renderer/canvas/VectorLayer.js */ "./node_modules/ol/renderer/canvas/VectorLayer.js");
/* harmony import */ var _renderer_canvas_VectorTileLayer_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./renderer/canvas/VectorTileLayer.js */ "./node_modules/ol/renderer/canvas/VectorTileLayer.js");
/**
 * @module ol/Map
 */










/**
 * @classdesc
 * The map is the core component of OpenLayers. For a map to render, a view,
 * one or more layers, and a target container are needed:
 *
 *     import Map from 'ol/Map';
 *     import View from 'ol/View';
 *     import TileLayer from 'ol/layer/Tile';
 *     import OSM from 'ol/source/OSM';
 *
 *     var map = new Map({
 *       view: new View({
 *         center: [0, 0],
 *         zoom: 1
 *       }),
 *       layers: [
 *         new TileLayer({
 *           source: new OSM()
 *         })
 *       ],
 *       target: 'map'
 *     });
 *
 * The above snippet creates a map using a {@link module:ol/layer/Tile} to
 * display {@link module:ol/source/OSM~OSM} OSM data and render it to a DOM
 * element with the id `map`.
 *
 * The constructor places a viewport container (with CSS class name
 * `ol-viewport`) in the target element (see `getViewport()`), and then two
 * further elements within the viewport: one with CSS class name
 * `ol-overlaycontainer-stopevent` for controls and some overlays, and one with
 * CSS class name `ol-overlaycontainer` for other overlays (see the `stopEvent`
 * option of {@link module:ol/Overlay~Overlay} for the difference). The map
 * itself is placed in a further element within the viewport.
 *
 * Layers are stored as a {@link module:ol/Collection~Collection} in
 * layerGroups. A top-level group is provided by the library. This is what is
 * accessed by `getLayerGroup` and `setLayerGroup`. Layers entered in the
 * options are added to this group, and `addLayer` and `removeLayer` change the
 * layer collection in the group. `getLayers` is a convenience function for
 * `getLayerGroup().getLayers()`. Note that {@link module:ol/layer/Group~Group}
 * is a subclass of {@link module:ol/layer/Base}, so layers entered in the
 * options or added with `addLayer` can be groups, which can contain further
 * groups, and so on.
 *
 * @fires import("./MapBrowserEvent.js").MapBrowserEvent
 * @fires import("./MapEvent.js").MapEvent
 * @fires module:ol/render/Event~RenderEvent#postcompose
 * @fires module:ol/render/Event~RenderEvent#precompose
 * @api
 */
var Map = /*@__PURE__*/(function (PluggableMap) {
  function Map(options) {
    options = Object(_obj_js__WEBPACK_IMPORTED_MODULE_3__["assign"])({}, options);
    if (!options.controls) {
      options.controls = Object(_control_util_js__WEBPACK_IMPORTED_MODULE_1__["defaults"])();
    }
    if (!options.interactions) {
      options.interactions = Object(_interaction_js__WEBPACK_IMPORTED_MODULE_2__["defaults"])();
    }

    PluggableMap.call(this, options);
  }

  if ( PluggableMap ) Map.__proto__ = PluggableMap;
  Map.prototype = Object.create( PluggableMap && PluggableMap.prototype );
  Map.prototype.constructor = Map;

  Map.prototype.createRenderer = function createRenderer () {
    var renderer = new _renderer_canvas_Map_js__WEBPACK_IMPORTED_MODULE_5__["default"](this);
    renderer.registerLayerRenderers([
      _renderer_canvas_ImageLayer_js__WEBPACK_IMPORTED_MODULE_4__["default"],
      _renderer_canvas_TileLayer_js__WEBPACK_IMPORTED_MODULE_6__["default"],
      _renderer_canvas_VectorLayer_js__WEBPACK_IMPORTED_MODULE_7__["default"],
      _renderer_canvas_VectorTileLayer_js__WEBPACK_IMPORTED_MODULE_8__["default"]
    ]);
    return renderer;
  };

  return Map;
}(_PluggableMap_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (Map);

//# sourceMappingURL=Map.js.map

/***/ }),

/***/ "./node_modules/ol/MapBrowserEvent.js":
/*!********************************************!*\
  !*** ./node_modules/ol/MapBrowserEvent.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _MapEvent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MapEvent.js */ "./node_modules/ol/MapEvent.js");
/**
 * @module ol/MapBrowserEvent
 */


/**
 * @classdesc
 * Events emitted as map browser events are instances of this type.
 * See {@link module:ol/PluggableMap~PluggableMap} for which events trigger a map browser event.
 */
var MapBrowserEvent = /*@__PURE__*/(function (MapEvent) {
  function MapBrowserEvent(type, map, browserEvent, opt_dragging, opt_frameState) {

    MapEvent.call(this, type, map, opt_frameState);

    /**
     * The original browser event.
     * @const
     * @type {Event}
     * @api
     */
    this.originalEvent = browserEvent;

    /**
     * The map pixel relative to the viewport corresponding to the original browser event.
     * @type {import("./pixel.js").Pixel}
     * @api
     */
    this.pixel = map.getEventPixel(browserEvent);

    /**
     * The coordinate in view projection corresponding to the original browser event.
     * @type {import("./coordinate.js").Coordinate}
     * @api
     */
    this.coordinate = map.getCoordinateFromPixel(this.pixel);

    /**
     * Indicates if the map is currently being dragged. Only set for
     * `POINTERDRAG` and `POINTERMOVE` events. Default is `false`.
     *
     * @type {boolean}
     * @api
     */
    this.dragging = opt_dragging !== undefined ? opt_dragging : false;

  }

  if ( MapEvent ) MapBrowserEvent.__proto__ = MapEvent;
  MapBrowserEvent.prototype = Object.create( MapEvent && MapEvent.prototype );
  MapBrowserEvent.prototype.constructor = MapBrowserEvent;

  /**
   * Prevents the default browser action.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
   * @override
   * @api
   */
  MapBrowserEvent.prototype.preventDefault = function preventDefault () {
    MapEvent.prototype.preventDefault.call(this);
    this.originalEvent.preventDefault();
  };

  /**
   * Prevents further propagation of the current event.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
   * @override
   * @api
   */
  MapBrowserEvent.prototype.stopPropagation = function stopPropagation () {
    MapEvent.prototype.stopPropagation.call(this);
    this.originalEvent.stopPropagation();
  };

  return MapBrowserEvent;
}(_MapEvent_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (MapBrowserEvent);

//# sourceMappingURL=MapBrowserEvent.js.map

/***/ }),

/***/ "./node_modules/ol/MapBrowserEventHandler.js":
/*!***************************************************!*\
  !*** ./node_modules/ol/MapBrowserEventHandler.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MapBrowserEventType.js */ "./node_modules/ol/MapBrowserEventType.js");
/* harmony import */ var _MapBrowserPointerEvent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MapBrowserPointerEvent.js */ "./node_modules/ol/MapBrowserPointerEvent.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./events/Target.js */ "./node_modules/ol/events/Target.js");
/* harmony import */ var _pointer_EventType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./pointer/EventType.js */ "./node_modules/ol/pointer/EventType.js");
/* harmony import */ var _pointer_PointerEventHandler_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./pointer/PointerEventHandler.js */ "./node_modules/ol/pointer/PointerEventHandler.js");
/**
 * @module ol/MapBrowserEventHandler
 */








var MapBrowserEventHandler = /*@__PURE__*/(function (EventTarget) {
  function MapBrowserEventHandler(map, moveTolerance) {

    EventTarget.call(this);

    /**
     * This is the element that we will listen to the real events on.
     * @type {import("./PluggableMap.js").default}
     * @private
     */
    this.map_ = map;

    /**
     * @type {any}
     * @private
     */
    this.clickTimeoutId_;

    /**
     * @type {boolean}
     * @private
     */
    this.dragging_ = false;

    /**
     * @type {!Array<import("./events.js").EventsKey>}
     * @private
     */
    this.dragListenerKeys_ = [];

    /**
     * @type {number}
     * @private
     */
    this.moveTolerance_ = moveTolerance ?
      moveTolerance * _has_js__WEBPACK_IMPORTED_MODULE_0__["DEVICE_PIXEL_RATIO"] : _has_js__WEBPACK_IMPORTED_MODULE_0__["DEVICE_PIXEL_RATIO"];

    /**
     * The most recent "down" type event (or null if none have occurred).
     * Set on pointerdown.
     * @type {import("./pointer/PointerEvent.js").default}
     * @private
     */
    this.down_ = null;

    var element = this.map_.getViewport();

    /**
     * @type {number}
     * @private
     */
    this.activePointers_ = 0;

    /**
     * @type {!Object<number, boolean>}
     * @private
     */
    this.trackedTouches_ = {};

    /**
     * Event handler which generates pointer events for
     * the viewport element.
     *
     * @type {PointerEventHandler}
     * @private
     */
    this.pointerEventHandler_ = new _pointer_PointerEventHandler_js__WEBPACK_IMPORTED_MODULE_6__["default"](element);

    /**
     * Event handler which generates pointer events for
     * the document (used when dragging).
     *
     * @type {PointerEventHandler}
     * @private
     */
    this.documentPointerEventHandler_ = null;

    /**
     * @type {?import("./events.js").EventsKey}
     * @private
     */
    this.pointerdownListenerKey_ = Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(this.pointerEventHandler_,
      _pointer_EventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POINTERDOWN,
      this.handlePointerDown_, this);

    /**
     * @type {?import("./events.js").EventsKey}
     * @private
     */
    this.relayedListenerKey_ = Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(this.pointerEventHandler_,
      _pointer_EventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POINTERMOVE,
      this.relayEvent_, this);

  }

  if ( EventTarget ) MapBrowserEventHandler.__proto__ = EventTarget;
  MapBrowserEventHandler.prototype = Object.create( EventTarget && EventTarget.prototype );
  MapBrowserEventHandler.prototype.constructor = MapBrowserEventHandler;

  /**
   * @param {import("./pointer/PointerEvent.js").default} pointerEvent Pointer
   * event.
   * @private
   */
  MapBrowserEventHandler.prototype.emulateClick_ = function emulateClick_ (pointerEvent) {
    var newEvent = new _MapBrowserPointerEvent_js__WEBPACK_IMPORTED_MODULE_2__["default"](
      _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CLICK, this.map_, pointerEvent);
    this.dispatchEvent(newEvent);
    if (this.clickTimeoutId_ !== undefined) {
      // double-click
      clearTimeout(this.clickTimeoutId_);
      this.clickTimeoutId_ = undefined;
      newEvent = new _MapBrowserPointerEvent_js__WEBPACK_IMPORTED_MODULE_2__["default"](
        _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].DBLCLICK, this.map_, pointerEvent);
      this.dispatchEvent(newEvent);
    } else {
      // click
      this.clickTimeoutId_ = setTimeout(function() {
        this.clickTimeoutId_ = undefined;
        var newEvent = new _MapBrowserPointerEvent_js__WEBPACK_IMPORTED_MODULE_2__["default"](
          _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].SINGLECLICK, this.map_, pointerEvent);
        this.dispatchEvent(newEvent);
      }.bind(this), 250);
    }
  };

  /**
   * Keeps track on how many pointers are currently active.
   *
   * @param {import("./pointer/PointerEvent.js").default} pointerEvent Pointer
   * event.
   * @private
   */
  MapBrowserEventHandler.prototype.updateActivePointers_ = function updateActivePointers_ (pointerEvent) {
    var event = pointerEvent;

    if (event.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERUP ||
        event.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERCANCEL) {
      delete this.trackedTouches_[event.pointerId];
    } else if (event.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERDOWN) {
      this.trackedTouches_[event.pointerId] = true;
    }
    this.activePointers_ = Object.keys(this.trackedTouches_).length;
  };

  /**
   * @param {import("./pointer/PointerEvent.js").default} pointerEvent Pointer
   * event.
   * @private
   */
  MapBrowserEventHandler.prototype.handlePointerUp_ = function handlePointerUp_ (pointerEvent) {
    this.updateActivePointers_(pointerEvent);
    var newEvent = new _MapBrowserPointerEvent_js__WEBPACK_IMPORTED_MODULE_2__["default"](
      _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERUP, this.map_, pointerEvent);
    this.dispatchEvent(newEvent);

    // We emulate click events on left mouse button click, touch contact, and pen
    // contact. isMouseActionButton returns true in these cases (evt.button is set
    // to 0).
    // See http://www.w3.org/TR/pointerevents/#button-states
    // We only fire click, singleclick, and doubleclick if nobody has called
    // event.stopPropagation() or event.preventDefault().
    if (!newEvent.propagationStopped && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {
      this.emulateClick_(this.down_);
    }

    if (this.activePointers_ === 0) {
      this.dragListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_3__["unlistenByKey"]);
      this.dragListenerKeys_.length = 0;
      this.dragging_ = false;
      this.down_ = null;
      this.documentPointerEventHandler_.dispose();
      this.documentPointerEventHandler_ = null;
    }
  };

  /**
   * @param {import("./pointer/PointerEvent.js").default} pointerEvent Pointer
   * event.
   * @return {boolean} If the left mouse button was pressed.
   * @private
   */
  MapBrowserEventHandler.prototype.isMouseActionButton_ = function isMouseActionButton_ (pointerEvent) {
    return pointerEvent.button === 0;
  };

  /**
   * @param {import("./pointer/PointerEvent.js").default} pointerEvent Pointer
   * event.
   * @private
   */
  MapBrowserEventHandler.prototype.handlePointerDown_ = function handlePointerDown_ (pointerEvent) {
    this.updateActivePointers_(pointerEvent);
    var newEvent = new _MapBrowserPointerEvent_js__WEBPACK_IMPORTED_MODULE_2__["default"](
      _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERDOWN, this.map_, pointerEvent);
    this.dispatchEvent(newEvent);

    this.down_ = pointerEvent;

    if (this.dragListenerKeys_.length === 0) {
      /* Set up a pointer event handler on the `document`,
       * which is required when the pointer is moved outside
       * the viewport when dragging.
       */
      this.documentPointerEventHandler_ =
          new _pointer_PointerEventHandler_js__WEBPACK_IMPORTED_MODULE_6__["default"](document);

      this.dragListenerKeys_.push(
        Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(this.documentPointerEventHandler_,
          _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERMOVE,
          this.handlePointerMove_, this),
        Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(this.documentPointerEventHandler_,
          _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERUP,
          this.handlePointerUp_, this),
        /* Note that the listener for `pointercancel is set up on
         * `pointerEventHandler_` and not `documentPointerEventHandler_` like
         * the `pointerup` and `pointermove` listeners.
         *
         * The reason for this is the following: `TouchSource.vacuumTouches_()`
         * issues `pointercancel` events, when there was no `touchend` for a
         * `touchstart`. Now, let's say a first `touchstart` is registered on
         * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
         * But `documentPointerEventHandler_` doesn't know about the first
         * `touchstart`. If there is no `touchend` for the `touchstart`, we can
         * only receive a `touchcancel` from `pointerEventHandler_`, because it is
         * only registered there.
         */
        Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(this.pointerEventHandler_,
          _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERCANCEL,
          this.handlePointerUp_, this)
      );
    }
  };

  /**
   * @param {import("./pointer/PointerEvent.js").default} pointerEvent Pointer
   * event.
   * @private
   */
  MapBrowserEventHandler.prototype.handlePointerMove_ = function handlePointerMove_ (pointerEvent) {
    // Between pointerdown and pointerup, pointermove events are triggered.
    // To avoid a 'false' touchmove event to be dispatched, we test if the pointer
    // moved a significant distance.
    if (this.isMoving_(pointerEvent)) {
      this.dragging_ = true;
      var newEvent = new _MapBrowserPointerEvent_js__WEBPACK_IMPORTED_MODULE_2__["default"](
        _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERDRAG, this.map_, pointerEvent,
        this.dragging_);
      this.dispatchEvent(newEvent);
    }

    // Some native android browser triggers mousemove events during small period
    // of time. See: https://code.google.com/p/android/issues/detail?id=5491 or
    // https://code.google.com/p/android/issues/detail?id=19827
    // ex: Galaxy Tab P3110 + Android 4.1.1
    pointerEvent.preventDefault();
  };

  /**
   * Wrap and relay a pointer event.  Note that this requires that the type
   * string for the MapBrowserPointerEvent matches the PointerEvent type.
   * @param {import("./pointer/PointerEvent.js").default} pointerEvent Pointer
   * event.
   * @private
   */
  MapBrowserEventHandler.prototype.relayEvent_ = function relayEvent_ (pointerEvent) {
    var dragging = !!(this.down_ && this.isMoving_(pointerEvent));
    this.dispatchEvent(new _MapBrowserPointerEvent_js__WEBPACK_IMPORTED_MODULE_2__["default"](
      pointerEvent.type, this.map_, pointerEvent, dragging));
  };

  /**
   * @param {import("./pointer/PointerEvent.js").default} pointerEvent Pointer
   * event.
   * @return {boolean} Is moving.
   * @private
   */
  MapBrowserEventHandler.prototype.isMoving_ = function isMoving_ (pointerEvent) {
    return this.dragging_ ||
        Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ ||
        Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;
  };

  /**
   * @inheritDoc
   */
  MapBrowserEventHandler.prototype.disposeInternal = function disposeInternal () {
    if (this.relayedListenerKey_) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["unlistenByKey"])(this.relayedListenerKey_);
      this.relayedListenerKey_ = null;
    }
    if (this.pointerdownListenerKey_) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["unlistenByKey"])(this.pointerdownListenerKey_);
      this.pointerdownListenerKey_ = null;
    }

    this.dragListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_3__["unlistenByKey"]);
    this.dragListenerKeys_.length = 0;

    if (this.documentPointerEventHandler_) {
      this.documentPointerEventHandler_.dispose();
      this.documentPointerEventHandler_ = null;
    }
    if (this.pointerEventHandler_) {
      this.pointerEventHandler_.dispose();
      this.pointerEventHandler_ = null;
    }
    EventTarget.prototype.disposeInternal.call(this);
  };

  return MapBrowserEventHandler;
}(_events_Target_js__WEBPACK_IMPORTED_MODULE_4__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (MapBrowserEventHandler);

//# sourceMappingURL=MapBrowserEventHandler.js.map

/***/ }),

/***/ "./node_modules/ol/MapBrowserEventType.js":
/*!************************************************!*\
  !*** ./node_modules/ol/MapBrowserEventType.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/**
 * @module ol/MapBrowserEventType
 */


/**
 * Constants for event names.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({

  /**
   * A true single click with no dragging and no double click. Note that this
   * event is delayed by 250 ms to ensure that it is not a double click.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
   * @api
   */
  SINGLECLICK: 'singleclick',

  /**
   * A click with no dragging. A double click will fire two of this.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
   * @api
   */
  CLICK: _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].CLICK,

  /**
   * A true double click, with no dragging.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
   * @api
   */
  DBLCLICK: _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].DBLCLICK,

  /**
   * Triggered when a pointer is dragged.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
   * @api
   */
  POINTERDRAG: 'pointerdrag',

  /**
   * Triggered when a pointer is moved. Note that on touch devices this is
   * triggered when the map is panned, so is not the same as mousemove.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
   * @api
   */
  POINTERMOVE: 'pointermove',

  POINTERDOWN: 'pointerdown',
  POINTERUP: 'pointerup',
  POINTEROVER: 'pointerover',
  POINTEROUT: 'pointerout',
  POINTERENTER: 'pointerenter',
  POINTERLEAVE: 'pointerleave',
  POINTERCANCEL: 'pointercancel'
});

//# sourceMappingURL=MapBrowserEventType.js.map

/***/ }),

/***/ "./node_modules/ol/MapBrowserPointerEvent.js":
/*!***************************************************!*\
  !*** ./node_modules/ol/MapBrowserPointerEvent.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MapBrowserEvent.js */ "./node_modules/ol/MapBrowserEvent.js");
/**
 * @module ol/MapBrowserPointerEvent
 */


var MapBrowserPointerEvent = /*@__PURE__*/(function (MapBrowserEvent) {
  function MapBrowserPointerEvent(type, map, pointerEvent, opt_dragging, opt_frameState) {

    MapBrowserEvent.call(this, type, map, pointerEvent.originalEvent, opt_dragging, opt_frameState);

    /**
     * @const
     * @type {import("./pointer/PointerEvent.js").default}
     */
    this.pointerEvent = pointerEvent;

  }

  if ( MapBrowserEvent ) MapBrowserPointerEvent.__proto__ = MapBrowserEvent;
  MapBrowserPointerEvent.prototype = Object.create( MapBrowserEvent && MapBrowserEvent.prototype );
  MapBrowserPointerEvent.prototype.constructor = MapBrowserPointerEvent;

  return MapBrowserPointerEvent;
}(_MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_0__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (MapBrowserPointerEvent);

//# sourceMappingURL=MapBrowserPointerEvent.js.map

/***/ }),

/***/ "./node_modules/ol/MapEvent.js":
/*!*************************************!*\
  !*** ./node_modules/ol/MapEvent.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events/Event.js */ "./node_modules/ol/events/Event.js");
/**
 * @module ol/MapEvent
 */


/**
 * @classdesc
 * Events emitted as map events are instances of this type.
 * See {@link module:ol/PluggableMap~PluggableMap} for which events trigger a map event.
 */
var MapEvent = /*@__PURE__*/(function (Event) {
  function MapEvent(type, map, opt_frameState) {

    Event.call(this, type);

    /**
     * The map where the event occurred.
     * @type {import("./PluggableMap.js").default}
     * @api
     */
    this.map = map;

    /**
     * The frame state at the time of the event.
     * @type {?import("./PluggableMap.js").FrameState}
     * @api
     */
    this.frameState = opt_frameState !== undefined ? opt_frameState : null;

  }

  if ( Event ) MapEvent.__proto__ = Event;
  MapEvent.prototype = Object.create( Event && Event.prototype );
  MapEvent.prototype.constructor = MapEvent;

  return MapEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_0__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (MapEvent);

//# sourceMappingURL=MapEvent.js.map

/***/ }),

/***/ "./node_modules/ol/MapEventType.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/MapEventType.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/MapEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({

  /**
   * Triggered after a map frame is rendered.
   * @event module:ol/MapEvent~MapEvent#postrender
   * @api
   */
  POSTRENDER: 'postrender',

  /**
   * Triggered when the map starts moving.
   * @event module:ol/MapEvent~MapEvent#movestart
   * @api
   */
  MOVESTART: 'movestart',

  /**
   * Triggered after the map is moved.
   * @event module:ol/MapEvent~MapEvent#moveend
   * @api
   */
  MOVEEND: 'moveend'

});

//# sourceMappingURL=MapEventType.js.map

/***/ }),

/***/ "./node_modules/ol/MapProperty.js":
/*!****************************************!*\
  !*** ./node_modules/ol/MapProperty.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/MapProperty
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  LAYERGROUP: 'layergroup',
  SIZE: 'size',
  TARGET: 'target',
  VIEW: 'view'
});

//# sourceMappingURL=MapProperty.js.map

/***/ }),

/***/ "./node_modules/ol/Object.js":
/*!***********************************!*\
  !*** ./node_modules/ol/Object.js ***!
  \***********************************/
/*! exports provided: ObjectEvent, getChangeEventType, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObjectEvent", function() { return ObjectEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getChangeEventType", function() { return getChangeEventType; });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ObjectEventType.js */ "./node_modules/ol/ObjectEventType.js");
/* harmony import */ var _Observable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Observable.js */ "./node_modules/ol/Observable.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/Object
 */







/**
 * @classdesc
 * Events emitted by {@link module:ol/Object~BaseObject} instances are instances of this type.
 */
var ObjectEvent = /*@__PURE__*/(function (Event) {
  function ObjectEvent(type, key, oldValue) {
    Event.call(this, type);

    /**
     * The name of the property whose value is changing.
     * @type {string}
     * @api
     */
    this.key = key;

    /**
     * The old value. To get the new value use `e.target.get(e.key)` where
     * `e` is the event object.
     * @type {*}
     * @api
     */
    this.oldValue = oldValue;

  }

  if ( Event ) ObjectEvent.__proto__ = Event;
  ObjectEvent.prototype = Object.create( Event && Event.prototype );
  ObjectEvent.prototype.constructor = ObjectEvent;

  return ObjectEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_3__["default"]));


/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Most non-trivial classes inherit from this.
 *
 * This extends {@link module:ol/Observable} with observable
 * properties, where each property is observable as well as the object as a
 * whole.
 *
 * Classes that inherit from this have pre-defined properties, to which you can
 * add your owns. The pre-defined properties are listed in this documentation as
 * 'Observable Properties', and have their own accessors; for example,
 * {@link module:ol/Map~Map} has a `target` property, accessed with
 * `getTarget()` and changed with `setTarget()`. Not all properties are however
 * settable. There are also general-purpose accessors `get()` and `set()`. For
 * example, `get('target')` is equivalent to `getTarget()`.
 *
 * The `set` accessors trigger a change event, and you can monitor this by
 * registering a listener. For example, {@link module:ol/View~View} has a
 * `center` property, so `view.on('change:center', function(evt) {...});` would
 * call the function whenever the value of the center property changes. Within
 * the function, `evt.target` would be the view, so `evt.target.getCenter()`
 * would return the new center.
 *
 * You can add your own observable properties with
 * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.
 * You can listen for changes on that property value with
 * `object.on('change:prop', listener)`. You can get a list of all
 * properties with {@link module:ol/Object~BaseObject#getProperties}.
 *
 * Note that the observable properties are separate from standard JS properties.
 * You can, for example, give your map object a title with
 * `map.title='New title'` and with `map.set('title', 'Another title')`. The
 * first will be a `hasOwnProperty`; the second will appear in
 * `getProperties()`. Only the second is observable.
 *
 * Properties can be deleted by using the unset method. E.g.
 * object.unset('foo').
 *
 * @fires ObjectEvent
 * @api
 */
var BaseObject = /*@__PURE__*/(function (Observable) {
  function BaseObject(opt_values) {
    Observable.call(this);

    // Call {@link module:ol/util~getUid} to ensure that the order of objects' ids is
    // the same as the order in which they were created.  This also helps to
    // ensure that object properties are always added in the same order, which
    // helps many JavaScript engines generate faster code.
    Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(this);

    /**
     * @private
     * @type {!Object<string, *>}
     */
    this.values_ = {};

    if (opt_values !== undefined) {
      this.setProperties(opt_values);
    }
  }

  if ( Observable ) BaseObject.__proto__ = Observable;
  BaseObject.prototype = Object.create( Observable && Observable.prototype );
  BaseObject.prototype.constructor = BaseObject;

  /**
   * Gets a value.
   * @param {string} key Key name.
   * @return {*} Value.
   * @api
   */
  BaseObject.prototype.get = function get (key) {
    var value;
    if (this.values_.hasOwnProperty(key)) {
      value = this.values_[key];
    }
    return value;
  };

  /**
   * Get a list of object property names.
   * @return {Array<string>} List of property names.
   * @api
   */
  BaseObject.prototype.getKeys = function getKeys () {
    return Object.keys(this.values_);
  };

  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>} Object.
   * @api
   */
  BaseObject.prototype.getProperties = function getProperties () {
    return Object(_obj_js__WEBPACK_IMPORTED_MODULE_4__["assign"])({}, this.values_);
  };

  /**
   * @param {string} key Key name.
   * @param {*} oldValue Old value.
   */
  BaseObject.prototype.notify = function notify (key, oldValue) {
    var eventType;
    eventType = getChangeEventType(key);
    this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
    eventType = _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].PROPERTYCHANGE;
    this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
  };

  /**
   * Sets a value.
   * @param {string} key Key name.
   * @param {*} value Value.
   * @param {boolean=} opt_silent Update without triggering an event.
   * @api
   */
  BaseObject.prototype.set = function set (key, value, opt_silent) {
    if (opt_silent) {
      this.values_[key] = value;
    } else {
      var oldValue = this.values_[key];
      this.values_[key] = value;
      if (oldValue !== value) {
        this.notify(key, oldValue);
      }
    }
  };

  /**
   * Sets a collection of key-value pairs.  Note that this changes any existing
   * properties and adds new ones (it does not remove any existing properties).
   * @param {Object<string, *>} values Values.
   * @param {boolean=} opt_silent Update without triggering an event.
   * @api
   */
  BaseObject.prototype.setProperties = function setProperties (values, opt_silent) {
    for (var key in values) {
      this.set(key, values[key], opt_silent);
    }
  };

  /**
   * Unsets a property.
   * @param {string} key Key name.
   * @param {boolean=} opt_silent Unset without triggering an event.
   * @api
   */
  BaseObject.prototype.unset = function unset (key, opt_silent) {
    if (key in this.values_) {
      var oldValue = this.values_[key];
      delete this.values_[key];
      if (!opt_silent) {
        this.notify(key, oldValue);
      }
    }
  };

  return BaseObject;
}(_Observable_js__WEBPACK_IMPORTED_MODULE_2__["default"]));


/**
 * @type {Object<string, string>}
 */
var changeEventTypeCache = {};


/**
 * @param {string} key Key name.
 * @return {string} Change name.
 */
function getChangeEventType(key) {
  return changeEventTypeCache.hasOwnProperty(key) ?
    changeEventTypeCache[key] :
    (changeEventTypeCache[key] = 'change:' + key);
}


/* harmony default export */ __webpack_exports__["default"] = (BaseObject);

//# sourceMappingURL=Object.js.map

/***/ }),

/***/ "./node_modules/ol/ObjectEventType.js":
/*!********************************************!*\
  !*** ./node_modules/ol/ObjectEventType.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/ObjectEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  /**
   * Triggered when a property is changed.
   * @event module:ol/Object.ObjectEvent#propertychange
   * @api
   */
  PROPERTYCHANGE: 'propertychange'
});

//# sourceMappingURL=ObjectEventType.js.map

/***/ }),

/***/ "./node_modules/ol/Observable.js":
/*!***************************************!*\
  !*** ./node_modules/ol/Observable.js ***!
  \***************************************/
/*! exports provided: unByKey, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unByKey", function() { return unByKey; });
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events/Target.js */ "./node_modules/ol/events/Target.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/**
 * @module ol/Observable
 */




/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * An event target providing convenient methods for listener registration
 * and unregistration. A generic `change` event is always available through
 * {@link module:ol/Observable~Observable#changed}.
 *
 * @fires import("./events/Event.js").Event
 * @api
 */
var Observable = /*@__PURE__*/(function (EventTarget) {
  function Observable() {

    EventTarget.call(this);

    /**
     * @private
     * @type {number}
     */
    this.revision_ = 0;

  }

  if ( EventTarget ) Observable.__proto__ = EventTarget;
  Observable.prototype = Object.create( EventTarget && EventTarget.prototype );
  Observable.prototype.constructor = Observable;

  /**
   * Increases the revision counter and dispatches a 'change' event.
   * @api
   */
  Observable.prototype.changed = function changed () {
    ++this.revision_;
    this.dispatchEvent(_events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CHANGE);
  };

  /**
   * Get the version number for this object.  Each time the object is modified,
   * its version number will be incremented.
   * @return {number} Revision.
   * @api
   */
  Observable.prototype.getRevision = function getRevision () {
    return this.revision_;
  };

  /**
   * Listen for a certain type of event.
   * @param {string|Array<string>} type The event type or array of event types.
   * @param {function(?): ?} listener The listener function.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
   *     called with an array of event types as the first argument, the return
   *     will be an array of keys.
   * @api
   */
  Observable.prototype.on = function on (type, listener) {
    if (Array.isArray(type)) {
      var len = type.length;
      var keys = new Array(len);
      for (var i = 0; i < len; ++i) {
        keys[i] = Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listen"])(this, type[i], listener);
      }
      return keys;
    } else {
      return Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listen"])(this, /** @type {string} */ (type), listener);
    }
  };

  /**
   * Listen once for a certain type of event.
   * @param {string|Array<string>} type The event type or array of event types.
   * @param {function(?): ?} listener The listener function.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
   *     called with an array of event types as the first argument, the return
   *     will be an array of keys.
   * @api
   */
  Observable.prototype.once = function once (type, listener) {
    if (Array.isArray(type)) {
      var len = type.length;
      var keys = new Array(len);
      for (var i = 0; i < len; ++i) {
        keys[i] = Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listenOnce"])(this, type[i], listener);
      }
      return keys;
    } else {
      return Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listenOnce"])(this, /** @type {string} */ (type), listener);
    }
  };

  /**
   * Unlisten for a certain type of event.
   * @param {string|Array<string>} type The event type or array of event types.
   * @param {function(?): ?} listener The listener function.
   * @api
   */
  Observable.prototype.un = function un (type, listener) {
    if (Array.isArray(type)) {
      for (var i = 0, ii = type.length; i < ii; ++i) {
        Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["unlisten"])(this, type[i], listener);
      }
      return;
    } else {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["unlisten"])(this, /** @type {string} */ (type), listener);
    }
  };

  return Observable;
}(_events_Target_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/**
 * Removes an event listener using the key returned by `on()` or `once()`.
 * @param {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} key The key returned by `on()`
 *     or `once()` (or an array of keys).
 * @api
 */
function unByKey(key) {
  if (Array.isArray(key)) {
    for (var i = 0, ii = key.length; i < ii; ++i) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["unlistenByKey"])(key[i]);
    }
  } else {
    Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["unlistenByKey"])(/** @type {import("./events.js").EventsKey} */ (key));
  }
}


/* harmony default export */ __webpack_exports__["default"] = (Observable);

//# sourceMappingURL=Observable.js.map

/***/ }),

/***/ "./node_modules/ol/PluggableMap.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/PluggableMap.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Collection.js */ "./node_modules/ol/Collection.js");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CollectionEventType.js */ "./node_modules/ol/CollectionEventType.js");
/* harmony import */ var _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MapBrowserEvent.js */ "./node_modules/ol/MapBrowserEvent.js");
/* harmony import */ var _MapBrowserEventHandler_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MapBrowserEventHandler.js */ "./node_modules/ol/MapBrowserEventHandler.js");
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./MapBrowserEventType.js */ "./node_modules/ol/MapBrowserEventType.js");
/* harmony import */ var _MapEvent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./MapEvent.js */ "./node_modules/ol/MapEvent.js");
/* harmony import */ var _MapEventType_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./MapEventType.js */ "./node_modules/ol/MapEventType.js");
/* harmony import */ var _MapProperty_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./MapProperty.js */ "./node_modules/ol/MapProperty.js");
/* harmony import */ var _render_EventType_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./render/EventType.js */ "./node_modules/ol/render/EventType.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./ObjectEventType.js */ "./node_modules/ol/ObjectEventType.js");
/* harmony import */ var _TileQueue_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./TileQueue.js */ "./node_modules/ol/TileQueue.js");
/* harmony import */ var _View_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./View.js */ "./node_modules/ol/View.js");
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./ViewHint.js */ "./node_modules/ol/ViewHint.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _layer_Group_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./layer/Group.js */ "./node_modules/ol/layer/Group.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./size.js */ "./node_modules/ol/size.js");
/* harmony import */ var _structs_PriorityQueue_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./structs/PriorityQueue.js */ "./node_modules/ol/structs/PriorityQueue.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/PluggableMap
 */





























/**
 * State of the current frame. Only `pixelRatio`, `time` and `viewState` should
 * be used in applications.
 * @typedef {Object} FrameState
 * @property {number} pixelRatio The pixel ratio of the frame.
 * @property {number} time The time when rendering of the frame was requested.
 * @property {import("./View.js").State} viewState The state of the current view.
 * @property {boolean} animate
 * @property {import("./transform.js").Transform} coordinateToPixelTransform
 * @property {null|import("./extent.js").Extent} extent
 * @property {import("./coordinate.js").Coordinate} focus
 * @property {number} index
 * @property {Object<string, import("./layer/Layer.js").State>} layerStates
 * @property {Array<import("./layer/Layer.js").State>} layerStatesArray
 * @property {import("./transform.js").Transform} pixelToCoordinateTransform
 * @property {Array<PostRenderFunction>} postRenderFunctions
 * @property {import("./size.js").Size} size
 * @property {!Object<string, boolean>} skippedFeatureUids
 * @property {TileQueue} tileQueue
 * @property {Object<string, Object<string, import("./TileRange.js").default>>} usedTiles
 * @property {Array<number>} viewHints
 * @property {!Object<string, Object<string, boolean>>} wantedTiles
 */


/**
 * @typedef {function(PluggableMap, ?FrameState): boolean} PostRenderFunction
 */


/**
 * @typedef {Object} AtPixelOptions
 * @property {undefined|function(import("./layer/Layer.js").default): boolean} layerFilter Layer filter
 * function. The filter function will receive one argument, the
 * {@link module:ol/layer/Layer layer-candidate} and it should return a boolean value.
 * Only layers which are visible and for which this function returns `true`
 * will be tested for features. By default, all visible layers will be tested.
 * @property {number} [hitTolerance=0] Hit-detection tolerance in pixels. Pixels
 * inside the radius around the given position will be checked for features. This only
 * works for the canvas renderer and not for WebGL.
 */


/**
 * @typedef {Object} MapOptionsInternal
 * @property {Collection<import("./control/Control.js").default>} [controls]
 * @property {Collection<import("./interaction/Interaction.js").default>} [interactions]
 * @property {HTMLElement|Document} keyboardEventTarget
 * @property {Collection<import("./Overlay.js").default>} overlays
 * @property {Object<string, *>} values
 */


/**
 * Object literal with config options for the map.
 * @typedef {Object} MapOptions
 * @property {Collection<import("./control/Control.js").default>|Array<import("./control/Control.js").default>} [controls]
 * Controls initially added to the map. If not specified,
 * {@link module:ol/control~defaults} is used.
 * @property {number} [pixelRatio=window.devicePixelRatio] The ratio between
 * physical pixels and device-independent pixels (dips) on the device.
 * @property {Collection<import("./interaction/Interaction.js").default>|Array<import("./interaction/Interaction.js").default>} [interactions]
 * Interactions that are initially added to the map. If not specified,
 * {@link module:ol/interaction~defaults} is used.
 * @property {HTMLElement|Document|string} [keyboardEventTarget] The element to
 * listen to keyboard events on. This determines when the `KeyboardPan` and
 * `KeyboardZoom` interactions trigger. For example, if this option is set to
 * `document` the keyboard interactions will always trigger. If this option is
 * not specified, the element the library listens to keyboard events on is the
 * map target (i.e. the user-provided div for the map). If this is not
 * `document`, the target element needs to be focused for key events to be
 * emitted, requiring that the target element has a `tabindex` attribute.
 * @property {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>|LayerGroup} [layers]
 * Layers. If this is not defined, a map with no layers will be rendered. Note
 * that layers are rendered in the order supplied, so if you want, for example,
 * a vector layer to appear on top of a tile layer, it must come after the tile
 * layer.
 * @property {number} [maxTilesLoading=16] Maximum number tiles to load
 * simultaneously.
 * @property {boolean} [loadTilesWhileAnimating=false] When set to `true`, tiles
 * will be loaded during animations. This may improve the user experience, but
 * can also make animations stutter on devices with slow memory.
 * @property {boolean} [loadTilesWhileInteracting=false] When set to `true`,
 * tiles will be loaded while interacting with the map. This may improve the
 * user experience, but can also make map panning and zooming choppy on devices
 * with slow memory.
 * @property {number} [moveTolerance=1] The minimum distance in pixels the
 * cursor must move to be detected as a map move event instead of a click.
 * Increasing this value can make it easier to click on the map.
 * @property {Collection<import("./Overlay.js").default>|Array<import("./Overlay.js").default>} [overlays]
 * Overlays initially added to the map. By default, no overlays are added.
 * @property {HTMLElement|string} [target] The container for the map, either the
 * element itself or the `id` of the element. If not specified at construction
 * time, {@link module:ol/Map~Map#setTarget} must be called for the map to be
 * rendered.
 * @property {View} [view] The map's view.  No layer sources will be
 * fetched unless this is specified at construction time or through
 * {@link module:ol/Map~Map#setView}.
 */


/**
 * @fires import("./MapBrowserEvent.js").MapBrowserEvent
 * @fires import("./MapEvent.js").MapEvent
 * @fires module:ol/render/Event~RenderEvent#postcompose
 * @fires module:ol/render/Event~RenderEvent#precompose
 * @fires module:ol/render/Event~RenderEvent#rendercomplete
 * @api
 */
var PluggableMap = /*@__PURE__*/(function (BaseObject) {
  function PluggableMap(options) {

    BaseObject.call(this);

    var optionsInternal = createOptionsInternal(options);

    /**
     * @type {number}
     * @private
     */
    this.maxTilesLoading_ = options.maxTilesLoading !== undefined ? options.maxTilesLoading : 16;

    /**
     * @type {boolean}
     * @private
     */
    this.loadTilesWhileAnimating_ =
        options.loadTilesWhileAnimating !== undefined ?
          options.loadTilesWhileAnimating : false;

    /**
     * @type {boolean}
     * @private
     */
    this.loadTilesWhileInteracting_ =
        options.loadTilesWhileInteracting !== undefined ?
          options.loadTilesWhileInteracting : false;

    /**
     * @private
     * @type {number}
     */
    this.pixelRatio_ = options.pixelRatio !== undefined ?
      options.pixelRatio : _has_js__WEBPACK_IMPORTED_MODULE_22__["DEVICE_PIXEL_RATIO"];

    /**
     * @private
     * @type {number|undefined}
     */
    this.animationDelayKey_;

    /**
     * @private
     */
    this.animationDelay_ = function() {
      this.animationDelayKey_ = undefined;
      this.renderFrame_.call(this, Date.now());
    }.bind(this);

    /**
     * @private
     * @type {import("./transform.js").Transform}
     */
    this.coordinateToPixelTransform_ = Object(_transform_js__WEBPACK_IMPORTED_MODULE_26__["create"])();

    /**
     * @private
     * @type {import("./transform.js").Transform}
     */
    this.pixelToCoordinateTransform_ = Object(_transform_js__WEBPACK_IMPORTED_MODULE_26__["create"])();

    /**
     * @private
     * @type {number}
     */
    this.frameIndex_ = 0;

    /**
     * @private
     * @type {?FrameState}
     */
    this.frameState_ = null;

    /**
     * The extent at the previous 'moveend' event.
     * @private
     * @type {import("./extent.js").Extent}
     */
    this.previousExtent_ = null;

    /**
     * @private
     * @type {?import("./events.js").EventsKey}
     */
    this.viewPropertyListenerKey_ = null;

    /**
     * @private
     * @type {?import("./events.js").EventsKey}
     */
    this.viewChangeListenerKey_ = null;

    /**
     * @private
     * @type {Array<import("./events.js").EventsKey>}
     */
    this.layerGroupPropertyListenerKeys_ = null;

    /**
     * @private
     * @type {!HTMLElement}
     */
    this.viewport_ = document.createElement('div');
    this.viewport_.className = 'ol-viewport' + (_has_js__WEBPACK_IMPORTED_MODULE_22__["TOUCH"] ? ' ol-touch' : '');
    this.viewport_.style.position = 'relative';
    this.viewport_.style.overflow = 'hidden';
    this.viewport_.style.width = '100%';
    this.viewport_.style.height = '100%';
    // prevent page zoom on IE >= 10 browsers
    this.viewport_.style.msTouchAction = 'none';
    this.viewport_.style.touchAction = 'none';

    /**
     * @private
     * @type {!HTMLElement}
     */
    this.overlayContainer_ = document.createElement('div');
    this.overlayContainer_.className = 'ol-overlaycontainer';
    this.viewport_.appendChild(this.overlayContainer_);

    /**
     * @private
     * @type {!HTMLElement}
     */
    this.overlayContainerStopEvent_ = document.createElement('div');
    this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent';
    var overlayEvents = [
      _events_EventType_js__WEBPACK_IMPORTED_MODULE_19__["default"].CLICK,
      _events_EventType_js__WEBPACK_IMPORTED_MODULE_19__["default"].DBLCLICK,
      _events_EventType_js__WEBPACK_IMPORTED_MODULE_19__["default"].MOUSEDOWN,
      _events_EventType_js__WEBPACK_IMPORTED_MODULE_19__["default"].TOUCHSTART,
      _events_EventType_js__WEBPACK_IMPORTED_MODULE_19__["default"].MSPOINTERDOWN,
      _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POINTERDOWN,
      _events_EventType_js__WEBPACK_IMPORTED_MODULE_19__["default"].MOUSEWHEEL,
      _events_EventType_js__WEBPACK_IMPORTED_MODULE_19__["default"].WHEEL
    ];
    for (var i = 0, ii = overlayEvents.length; i < ii; ++i) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["listen"])(this.overlayContainerStopEvent_, overlayEvents[i], _events_Event_js__WEBPACK_IMPORTED_MODULE_18__["stopPropagation"]);
    }
    this.viewport_.appendChild(this.overlayContainerStopEvent_);

    /**
     * @private
     * @type {MapBrowserEventHandler}
     */
    this.mapBrowserEventHandler_ = new _MapBrowserEventHandler_js__WEBPACK_IMPORTED_MODULE_4__["default"](this, options.moveTolerance);
    for (var key in _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_5__["default"]) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["listen"])(this.mapBrowserEventHandler_, _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_5__["default"][key],
        this.handleMapBrowserEvent, this);
    }

    /**
     * @private
     * @type {HTMLElement|Document}
     */
    this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;

    /**
     * @private
     * @type {Array<import("./events.js").EventsKey>}
     */
    this.keyHandlerKeys_ = null;

    Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["listen"])(this.viewport_, _events_EventType_js__WEBPACK_IMPORTED_MODULE_19__["default"].CONTEXTMENU, this.handleBrowserEvent, this);
    Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["listen"])(this.viewport_, _events_EventType_js__WEBPACK_IMPORTED_MODULE_19__["default"].WHEEL, this.handleBrowserEvent, this);
    Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["listen"])(this.viewport_, _events_EventType_js__WEBPACK_IMPORTED_MODULE_19__["default"].MOUSEWHEEL, this.handleBrowserEvent, this);

    /**
     * @type {Collection<import("./control/Control.js").default>}
     * @protected
     */
    this.controls = optionsInternal.controls || new _Collection_js__WEBPACK_IMPORTED_MODULE_1__["default"]();

    /**
     * @type {Collection<import("./interaction/Interaction.js").default>}
     * @protected
     */
    this.interactions = optionsInternal.interactions || new _Collection_js__WEBPACK_IMPORTED_MODULE_1__["default"]();

    /**
     * @type {Collection<import("./Overlay.js").default>}
     * @private
     */
    this.overlays_ = optionsInternal.overlays;

    /**
     * A lookup of overlays by id.
     * @private
     * @type {Object<string, import("./Overlay.js").default>}
     */
    this.overlayIdIndex_ = {};

    /**
     * @type {import("./renderer/Map.js").default}
     * @private
     */
    this.renderer_ = this.createRenderer();

    /**
     * @type {function(Event)|undefined}
     * @private
     */
    this.handleResize_;

    /**
     * @private
     * @type {import("./coordinate.js").Coordinate}
     */
    this.focus_ = null;

    /**
     * @private
     * @type {!Array<PostRenderFunction>}
     */
    this.postRenderFunctions_ = [];

    /**
     * @private
     * @type {TileQueue}
     */
    this.tileQueue_ = new _TileQueue_js__WEBPACK_IMPORTED_MODULE_12__["default"](
      this.getTilePriority.bind(this),
      this.handleTileChange_.bind(this));

    /**
     * Uids of features to skip at rendering time.
     * @type {Object<string, boolean>}
     * @private
     */
    this.skippedFeatureUids_ = {};

    Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["listen"])(
      this, Object(_Object_js__WEBPACK_IMPORTED_MODULE_10__["getChangeEventType"])(_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].LAYERGROUP),
      this.handleLayerGroupChanged_, this);
    Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["listen"])(this, Object(_Object_js__WEBPACK_IMPORTED_MODULE_10__["getChangeEventType"])(_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].VIEW),
      this.handleViewChanged_, this);
    Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["listen"])(this, Object(_Object_js__WEBPACK_IMPORTED_MODULE_10__["getChangeEventType"])(_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].SIZE),
      this.handleSizeChanged_, this);
    Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["listen"])(this, Object(_Object_js__WEBPACK_IMPORTED_MODULE_10__["getChangeEventType"])(_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].TARGET),
      this.handleTargetChanged_, this);

    // setProperties will trigger the rendering of the map if the map
    // is "defined" already.
    this.setProperties(optionsInternal.values);

    this.controls.forEach(
      /**
       * @param {import("./control/Control.js").default} control Control.
       * @this {PluggableMap}
       */
      (function(control) {
        control.setMap(this);
      }).bind(this));

    Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["listen"])(this.controls, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
       */
      function(event) {
        event.element.setMap(this);
      }, this);

    Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["listen"])(this.controls, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
       */
      function(event) {
        event.element.setMap(null);
      }, this);

    this.interactions.forEach(
      /**
       * @param {import("./interaction/Interaction.js").default} interaction Interaction.
       * @this {PluggableMap}
       */
      (function(interaction) {
        interaction.setMap(this);
      }).bind(this));

    Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["listen"])(this.interactions, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
       */
      function(event) {
        event.element.setMap(this);
      }, this);

    Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["listen"])(this.interactions, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
       */
      function(event) {
        event.element.setMap(null);
      }, this);

    this.overlays_.forEach(this.addOverlayInternal_.bind(this));

    Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["listen"])(this.overlays_, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
       */
      function(event) {
        this.addOverlayInternal_(/** @type {import("./Overlay.js").default} */ (event.element));
      }, this);

    Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["listen"])(this.overlays_, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
       */
      function(event) {
        var overlay = /** @type {import("./Overlay.js").default} */ (event.element);
        var id = overlay.getId();
        if (id !== undefined) {
          delete this.overlayIdIndex_[id.toString()];
        }
        event.element.setMap(null);
      }, this);

  }

  if ( BaseObject ) PluggableMap.__proto__ = BaseObject;
  PluggableMap.prototype = Object.create( BaseObject && BaseObject.prototype );
  PluggableMap.prototype.constructor = PluggableMap;

  /**
   * @abstract
   * @return {import("./renderer/Map.js").default} The map renderer
   */
  PluggableMap.prototype.createRenderer = function createRenderer () {
    throw new Error('Use a map type that has a createRenderer method');
  };

  /**
   * Add the given control to the map.
   * @param {import("./control/Control.js").default} control Control.
   * @api
   */
  PluggableMap.prototype.addControl = function addControl (control) {
    this.getControls().push(control);
  };

  /**
   * Add the given interaction to the map.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to add.
   * @api
   */
  PluggableMap.prototype.addInteraction = function addInteraction (interaction) {
    this.getInteractions().push(interaction);
  };

  /**
   * Adds the given layer to the top of this map. If you want to add a layer
   * elsewhere in the stack, use `getLayers()` and the methods available on
   * {@link module:ol/Collection~Collection}.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @api
   */
  PluggableMap.prototype.addLayer = function addLayer (layer) {
    var layers = this.getLayerGroup().getLayers();
    layers.push(layer);
  };

  /**
   * Add the given overlay to the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @api
   */
  PluggableMap.prototype.addOverlay = function addOverlay (overlay) {
    this.getOverlays().push(overlay);
  };

  /**
   * This deals with map's overlay collection changes.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @private
   */
  PluggableMap.prototype.addOverlayInternal_ = function addOverlayInternal_ (overlay) {
    var id = overlay.getId();
    if (id !== undefined) {
      this.overlayIdIndex_[id.toString()] = overlay;
    }
    overlay.setMap(this);
  };

  /**
   *
   * @inheritDoc
   */
  PluggableMap.prototype.disposeInternal = function disposeInternal () {
    this.mapBrowserEventHandler_.dispose();
    Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["unlisten"])(this.viewport_, _events_EventType_js__WEBPACK_IMPORTED_MODULE_19__["default"].CONTEXTMENU, this.handleBrowserEvent, this);
    Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["unlisten"])(this.viewport_, _events_EventType_js__WEBPACK_IMPORTED_MODULE_19__["default"].WHEEL, this.handleBrowserEvent, this);
    Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["unlisten"])(this.viewport_, _events_EventType_js__WEBPACK_IMPORTED_MODULE_19__["default"].MOUSEWHEEL, this.handleBrowserEvent, this);
    if (this.handleResize_ !== undefined) {
      removeEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_19__["default"].RESIZE, this.handleResize_, false);
      this.handleResize_ = undefined;
    }
    if (this.animationDelayKey_) {
      cancelAnimationFrame(this.animationDelayKey_);
      this.animationDelayKey_ = undefined;
    }
    this.setTarget(null);
    BaseObject.prototype.disposeInternal.call(this);
  };

  /**
   * Detect features that intersect a pixel on the viewport, and execute a
   * callback with each intersecting feature. Layers included in the detection can
   * be configured through the `layerFilter` option in `opt_options`.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {function(this: S, import("./Feature.js").FeatureLike,
   *     import("./layer/Layer.js").default): T} callback Feature callback. The callback will be
   *     called with two arguments. The first argument is one
   *     {@link module:ol/Feature feature} or
   *     {@link module:ol/render/Feature render feature} at the pixel, the second is
   *     the {@link module:ol/layer/Layer layer} of the feature and will be null for
   *     unmanaged layers. To stop detection, callback functions can return a
   *     truthy value.
   * @param {AtPixelOptions=} opt_options Optional options.
   * @return {T|undefined} Callback result, i.e. the return value of last
   * callback execution, or the first truthy callback return value.
   * @template S,T
   * @api
   */
  PluggableMap.prototype.forEachFeatureAtPixel = function forEachFeatureAtPixel (pixel, callback, opt_options) {
    if (!this.frameState_) {
      return;
    }
    var coordinate = this.getCoordinateFromPixel(pixel);
    opt_options = opt_options !== undefined ? opt_options :
      /** @type {AtPixelOptions} */ ({});
    var hitTolerance = opt_options.hitTolerance !== undefined ?
      opt_options.hitTolerance * this.frameState_.pixelRatio : 0;
    var layerFilter = opt_options.layerFilter !== undefined ?
      opt_options.layerFilter : _functions_js__WEBPACK_IMPORTED_MODULE_21__["TRUE"];
    return this.renderer_.forEachFeatureAtCoordinate(
      coordinate, this.frameState_, hitTolerance, callback, null,
      layerFilter, null);
  };

  /**
   * Get all features that intersect a pixel on the viewport.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions=} opt_options Optional options.
   * @return {Array<import("./Feature.js").FeatureLike>} The detected features or
   * `null` if none were found.
   * @api
   */
  PluggableMap.prototype.getFeaturesAtPixel = function getFeaturesAtPixel (pixel, opt_options) {
    var features = null;
    this.forEachFeatureAtPixel(pixel, function(feature) {
      if (!features) {
        features = [];
      }
      features.push(feature);
    }, opt_options);
    return features;
  };

  /**
   * Detect layers that have a color value at a pixel on the viewport, and
   * execute a callback with each matching layer. Layers included in the
   * detection can be configured through `opt_layerFilter`.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {function(this: S, import("./layer/Layer.js").default, (Uint8ClampedArray|Uint8Array)): T} callback
   *     Layer callback. This callback will receive two arguments: first is the
   *     {@link module:ol/layer/Layer layer}, second argument is an array representing
   *     [R, G, B, A] pixel values (0 - 255) and will be `null` for layer types
   *     that do not currently support this argument. To stop detection, callback
   *     functions can return a truthy value.
   * @param {AtPixelOptions=} opt_options Configuration options.
   * @return {T|undefined} Callback result, i.e. the return value of last
   * callback execution, or the first truthy callback return value.
   * @template S,T
   * @api
   */
  PluggableMap.prototype.forEachLayerAtPixel = function forEachLayerAtPixel (pixel, callback, opt_options) {
    if (!this.frameState_) {
      return;
    }
    var options = opt_options || /** @type {AtPixelOptions} */ ({});
    var hitTolerance = options.hitTolerance !== undefined ?
      opt_options.hitTolerance * this.frameState_.pixelRatio : 0;
    var layerFilter = options.layerFilter || _functions_js__WEBPACK_IMPORTED_MODULE_21__["TRUE"];
    return this.renderer_.forEachLayerAtPixel(
      pixel, this.frameState_, hitTolerance, callback, null, layerFilter, null);
  };

  /**
   * Detect if features intersect a pixel on the viewport. Layers included in the
   * detection can be configured through `opt_layerFilter`.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions=} opt_options Optional options.
   * @return {boolean} Is there a feature at the given pixel?
   * @template U
   * @api
   */
  PluggableMap.prototype.hasFeatureAtPixel = function hasFeatureAtPixel (pixel, opt_options) {
    if (!this.frameState_) {
      return false;
    }
    var coordinate = this.getCoordinateFromPixel(pixel);
    opt_options = opt_options !== undefined ? opt_options :
      /** @type {AtPixelOptions} */ ({});
    var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : _functions_js__WEBPACK_IMPORTED_MODULE_21__["TRUE"];
    var hitTolerance = opt_options.hitTolerance !== undefined ?
      opt_options.hitTolerance * this.frameState_.pixelRatio : 0;
    return this.renderer_.hasFeatureAtCoordinate(
      coordinate, this.frameState_, hitTolerance, layerFilter, null);
  };

  /**
   * Returns the coordinate in view projection for a browser event.
   * @param {Event} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   * @api
   */
  PluggableMap.prototype.getEventCoordinate = function getEventCoordinate (event) {
    return this.getCoordinateFromPixel(this.getEventPixel(event));
  };

  /**
   * Returns the map pixel position for a browser event relative to the viewport.
   * @param {Event|TouchEvent} event Event.
   * @return {import("./pixel.js").Pixel} Pixel.
   * @api
   */
  PluggableMap.prototype.getEventPixel = function getEventPixel (event) {
    var viewportPosition = this.viewport_.getBoundingClientRect();
    var eventPosition = 'changedTouches' in event ?
      /** @type {TouchEvent} */ (event).changedTouches[0] :
      /** @type {MouseEvent} */ (event);

    return [
      eventPosition.clientX - viewportPosition.left,
      eventPosition.clientY - viewportPosition.top
    ];
  };

  /**
   * Get the target in which this map is rendered.
   * Note that this returns what is entered as an option or in setTarget:
   * if that was an element, it returns an element; if a string, it returns that.
   * @return {HTMLElement|string|undefined} The Element or id of the Element that the
   *     map is rendered in.
   * @observable
   * @api
   */
  PluggableMap.prototype.getTarget = function getTarget () {
    return /** @type {HTMLElement|string|undefined} */ (this.get(_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].TARGET));
  };

  /**
   * Get the DOM element into which this map is rendered. In contrast to
   * `getTarget` this method always return an `Element`, or `null` if the
   * map has no target.
   * @return {HTMLElement} The element that the map is rendered in.
   * @api
   */
  PluggableMap.prototype.getTargetElement = function getTargetElement () {
    var target = this.getTarget();
    if (target !== undefined) {
      return typeof target === 'string' ? document.getElementById(target) : target;
    } else {
      return null;
    }
  };

  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * map view projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   * @api
   */
  PluggableMap.prototype.getCoordinateFromPixel = function getCoordinateFromPixel (pixel) {
    var frameState = this.frameState_;
    if (!frameState) {
      return null;
    } else {
      return Object(_transform_js__WEBPACK_IMPORTED_MODULE_26__["apply"])(frameState.pixelToCoordinateTransform, pixel.slice());
    }
  };

  /**
   * Get the map controls. Modifying this collection changes the controls
   * associated with the map.
   * @return {Collection<import("./control/Control.js").default>} Controls.
   * @api
   */
  PluggableMap.prototype.getControls = function getControls () {
    return this.controls;
  };

  /**
   * Get the map overlays. Modifying this collection changes the overlays
   * associated with the map.
   * @return {Collection<import("./Overlay.js").default>} Overlays.
   * @api
   */
  PluggableMap.prototype.getOverlays = function getOverlays () {
    return this.overlays_;
  };

  /**
   * Get an overlay by its identifier (the value returned by overlay.getId()).
   * Note that the index treats string and numeric identifiers as the same. So
   * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
   * @param {string|number} id Overlay identifier.
   * @return {import("./Overlay.js").default} Overlay.
   * @api
   */
  PluggableMap.prototype.getOverlayById = function getOverlayById (id) {
    var overlay = this.overlayIdIndex_[id.toString()];
    return overlay !== undefined ? overlay : null;
  };

  /**
   * Get the map interactions. Modifying this collection changes the interactions
   * associated with the map.
   *
   * Interactions are used for e.g. pan, zoom and rotate.
   * @return {Collection<import("./interaction/Interaction.js").default>} Interactions.
   * @api
   */
  PluggableMap.prototype.getInteractions = function getInteractions () {
    return this.interactions;
  };

  /**
   * Get the layergroup associated with this map.
   * @return {LayerGroup} A layer group containing the layers in this map.
   * @observable
   * @api
   */
  PluggableMap.prototype.getLayerGroup = function getLayerGroup () {
    return (
      /** @type {LayerGroup} */ (this.get(_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].LAYERGROUP))
    );
  };

  /**
   * Get the collection of layers associated with this map.
   * @return {!Collection<import("./layer/Base.js").default>} Layers.
   * @api
   */
  PluggableMap.prototype.getLayers = function getLayers () {
    var layers = this.getLayerGroup().getLayers();
    return layers;
  };

  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the map view
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   * @api
   */
  PluggableMap.prototype.getPixelFromCoordinate = function getPixelFromCoordinate (coordinate) {
    var frameState = this.frameState_;
    if (!frameState) {
      return null;
    } else {
      return Object(_transform_js__WEBPACK_IMPORTED_MODULE_26__["apply"])(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));
    }
  };

  /**
   * Get the map renderer.
   * @return {import("./renderer/Map.js").default} Renderer
   */
  PluggableMap.prototype.getRenderer = function getRenderer () {
    return this.renderer_;
  };

  /**
   * Get the size of this map.
   * @return {import("./size.js").Size|undefined} The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  PluggableMap.prototype.getSize = function getSize () {
    return (
      /** @type {import("./size.js").Size|undefined} */ (this.get(_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].SIZE))
    );
  };

  /**
   * Get the view associated with this map. A view manages properties such as
   * center and resolution.
   * @return {View} The view that controls this map.
   * @observable
   * @api
   */
  PluggableMap.prototype.getView = function getView () {
    return (
      /** @type {View} */ (this.get(_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].VIEW))
    );
  };

  /**
   * Get the element that serves as the map viewport.
   * @return {HTMLElement} Viewport.
   * @api
   */
  PluggableMap.prototype.getViewport = function getViewport () {
    return this.viewport_;
  };

  /**
   * Get the element that serves as the container for overlays.  Elements added to
   * this container will let mousedown and touchstart events through to the map,
   * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}
   * events.
   * @return {!HTMLElement} The map's overlay container.
   */
  PluggableMap.prototype.getOverlayContainer = function getOverlayContainer () {
    return this.overlayContainer_;
  };

  /**
   * Get the element that serves as a container for overlays that don't allow
   * event propagation. Elements added to this container won't let mousedown and
   * touchstart events through to the map, so clicks and gestures on an overlay
   * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   * @return {!HTMLElement} The map's overlay container that stops events.
   */
  PluggableMap.prototype.getOverlayContainerStopEvent = function getOverlayContainerStopEvent () {
    return this.overlayContainerStopEvent_;
  };

  /**
   * @param {import("./Tile.js").default} tile Tile.
   * @param {string} tileSourceKey Tile source key.
   * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
   * @param {number} tileResolution Tile resolution.
   * @return {number} Tile priority.
   */
  PluggableMap.prototype.getTilePriority = function getTilePriority (tile, tileSourceKey, tileCenter, tileResolution) {
    // Filter out tiles at higher zoom levels than the current zoom level, or that
    // are outside the visible extent.
    var frameState = this.frameState_;
    if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {
      return _structs_PriorityQueue_js__WEBPACK_IMPORTED_MODULE_25__["DROP"];
    }
    if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {
      return _structs_PriorityQueue_js__WEBPACK_IMPORTED_MODULE_25__["DROP"];
    }
    // Prioritize the highest zoom level tiles closest to the focus.
    // Tiles at higher zoom levels are prioritized using Math.log(tileResolution).
    // Within a zoom level, tiles are prioritized by the distance in pixels
    // between the center of the tile and the focus.  The factor of 65536 means
    // that the prioritization should behave as desired for tiles up to
    // 65536 * Math.log(2) = 45426 pixels from the focus.
    var deltaX = tileCenter[0] - frameState.focus[0];
    var deltaY = tileCenter[1] - frameState.focus[1];
    return 65536 * Math.log(tileResolution) +
        Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;
  };

  /**
   * @param {Event} browserEvent Browser event.
   * @param {string=} opt_type Type.
   */
  PluggableMap.prototype.handleBrowserEvent = function handleBrowserEvent (browserEvent, opt_type) {
    var type = opt_type || browserEvent.type;
    var mapBrowserEvent = new _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_3__["default"](type, this, browserEvent);
    this.handleMapBrowserEvent(mapBrowserEvent);
  };

  /**
   * @param {MapBrowserEvent} mapBrowserEvent The event to handle.
   */
  PluggableMap.prototype.handleMapBrowserEvent = function handleMapBrowserEvent (mapBrowserEvent) {
    if (!this.frameState_) {
      // With no view defined, we cannot translate pixels into geographical
      // coordinates so interactions cannot be used.
      return;
    }
    this.focus_ = mapBrowserEvent.coordinate;
    mapBrowserEvent.frameState = this.frameState_;
    var interactionsArray = this.getInteractions().getArray();
    if (this.dispatchEvent(mapBrowserEvent) !== false) {
      for (var i = interactionsArray.length - 1; i >= 0; i--) {
        var interaction = interactionsArray[i];
        if (!interaction.getActive()) {
          continue;
        }
        var cont = interaction.handleEvent(mapBrowserEvent);
        if (!cont) {
          break;
        }
      }
    }
  };

  /**
   * @protected
   */
  PluggableMap.prototype.handlePostRender = function handlePostRender () {

    var frameState = this.frameState_;

    // Manage the tile queue
    // Image loads are expensive and a limited resource, so try to use them
    // efficiently:
    // * When the view is static we allow a large number of parallel tile loads
    //   to complete the frame as quickly as possible.
    // * When animating or interacting, image loads can cause janks, so we reduce
    //   the maximum number of loads per frame and limit the number of parallel
    //   tile loads to remain reactive to view changes and to reduce the chance of
    //   loading tiles that will quickly disappear from view.
    var tileQueue = this.tileQueue_;
    if (!tileQueue.isEmpty()) {
      var maxTotalLoading = this.maxTilesLoading_;
      var maxNewLoads = maxTotalLoading;
      if (frameState) {
        var hints = frameState.viewHints;
        if (hints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_14__["default"].ANIMATING]) {
          maxTotalLoading = this.loadTilesWhileAnimating_ ? 8 : 0;
          maxNewLoads = 2;
        }
        if (hints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_14__["default"].INTERACTING]) {
          maxTotalLoading = this.loadTilesWhileInteracting_ ? 8 : 0;
          maxNewLoads = 2;
        }
      }
      if (tileQueue.getTilesLoading() < maxTotalLoading) {
        tileQueue.reprioritize(); // FIXME only call if view has changed
        tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);
      }
    }
    if (frameState && this.hasListener(_render_EventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].RENDERCOMPLETE) && !frameState.animate &&
        !this.tileQueue_.getTilesLoading() && !getLoading(this.getLayers().getArray())) {
      this.renderer_.dispatchRenderEvent(_render_EventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].RENDERCOMPLETE, frameState);
    }

    var postRenderFunctions = this.postRenderFunctions_;
    for (var i = 0, ii = postRenderFunctions.length; i < ii; ++i) {
      postRenderFunctions[i](this, frameState);
    }
    postRenderFunctions.length = 0;
  };

  /**
   * @private
   */
  PluggableMap.prototype.handleSizeChanged_ = function handleSizeChanged_ () {
    this.render();
  };

  /**
   * @private
   */
  PluggableMap.prototype.handleTargetChanged_ = function handleTargetChanged_ () {
    // target may be undefined, null, a string or an Element.
    // If it's a string we convert it to an Element before proceeding.
    // If it's not now an Element we remove the viewport from the DOM.
    // If it's an Element we append the viewport element to it.

    var targetElement;
    if (this.getTarget()) {
      targetElement = this.getTargetElement();
    }

    if (this.keyHandlerKeys_) {
      for (var i = 0, ii = this.keyHandlerKeys_.length; i < ii; ++i) {
        Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["unlistenByKey"])(this.keyHandlerKeys_[i]);
      }
      this.keyHandlerKeys_ = null;
    }

    if (!targetElement) {
      this.renderer_.removeLayerRenderers();
      Object(_dom_js__WEBPACK_IMPORTED_MODULE_16__["removeNode"])(this.viewport_);
      if (this.handleResize_ !== undefined) {
        removeEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_19__["default"].RESIZE, this.handleResize_, false);
        this.handleResize_ = undefined;
      }
    } else {
      targetElement.appendChild(this.viewport_);

      var keyboardEventTarget = !this.keyboardEventTarget_ ?
        targetElement : this.keyboardEventTarget_;
      this.keyHandlerKeys_ = [
        Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["listen"])(keyboardEventTarget, _events_EventType_js__WEBPACK_IMPORTED_MODULE_19__["default"].KEYDOWN, this.handleBrowserEvent, this),
        Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["listen"])(keyboardEventTarget, _events_EventType_js__WEBPACK_IMPORTED_MODULE_19__["default"].KEYPRESS, this.handleBrowserEvent, this)
      ];

      if (!this.handleResize_) {
        this.handleResize_ = this.updateSize.bind(this);
        window.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_19__["default"].RESIZE, this.handleResize_, false);
      }
    }

    this.updateSize();
    // updateSize calls setSize, so no need to call this.render
    // ourselves here.
  };

  /**
   * @private
   */
  PluggableMap.prototype.handleTileChange_ = function handleTileChange_ () {
    this.render();
  };

  /**
   * @private
   */
  PluggableMap.prototype.handleViewPropertyChanged_ = function handleViewPropertyChanged_ () {
    this.render();
  };

  /**
   * @private
   */
  PluggableMap.prototype.handleViewChanged_ = function handleViewChanged_ () {
    if (this.viewPropertyListenerKey_) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["unlistenByKey"])(this.viewPropertyListenerKey_);
      this.viewPropertyListenerKey_ = null;
    }
    if (this.viewChangeListenerKey_) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["unlistenByKey"])(this.viewChangeListenerKey_);
      this.viewChangeListenerKey_ = null;
    }
    var view = this.getView();
    if (view) {
      this.viewport_.setAttribute('data-view', Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(view));
      this.viewPropertyListenerKey_ = Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["listen"])(
        view, _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_11__["default"].PROPERTYCHANGE,
        this.handleViewPropertyChanged_, this);
      this.viewChangeListenerKey_ = Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["listen"])(
        view, _events_EventType_js__WEBPACK_IMPORTED_MODULE_19__["default"].CHANGE,
        this.handleViewPropertyChanged_, this);
    }
    this.render();
  };

  /**
   * @private
   */
  PluggableMap.prototype.handleLayerGroupChanged_ = function handleLayerGroupChanged_ () {
    if (this.layerGroupPropertyListenerKeys_) {
      this.layerGroupPropertyListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_17__["unlistenByKey"]);
      this.layerGroupPropertyListenerKeys_ = null;
    }
    var layerGroup = this.getLayerGroup();
    if (layerGroup) {
      this.layerGroupPropertyListenerKeys_ = [
        Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["listen"])(
          layerGroup, _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_11__["default"].PROPERTYCHANGE,
          this.render, this),
        Object(_events_js__WEBPACK_IMPORTED_MODULE_17__["listen"])(
          layerGroup, _events_EventType_js__WEBPACK_IMPORTED_MODULE_19__["default"].CHANGE,
          this.render, this)
      ];
    }
    this.render();
  };

  /**
   * @return {boolean} Is rendered.
   */
  PluggableMap.prototype.isRendered = function isRendered () {
    return !!this.frameState_;
  };

  /**
   * Requests an immediate render in a synchronous manner.
   * @api
   */
  PluggableMap.prototype.renderSync = function renderSync () {
    if (this.animationDelayKey_) {
      cancelAnimationFrame(this.animationDelayKey_);
    }
    this.animationDelay_();
  };

  /**
   * Request a map rendering (at the next animation frame).
   * @api
   */
  PluggableMap.prototype.render = function render () {
    if (this.animationDelayKey_ === undefined) {
      this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);
    }
  };

  /**
   * Remove the given control from the map.
   * @param {import("./control/Control.js").default} control Control.
   * @return {import("./control/Control.js").default|undefined} The removed control (or undefined
   *     if the control was not found).
   * @api
   */
  PluggableMap.prototype.removeControl = function removeControl (control) {
    return this.getControls().remove(control);
  };

  /**
   * Remove the given interaction from the map.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to remove.
   * @return {import("./interaction/Interaction.js").default|undefined} The removed interaction (or
   *     undefined if the interaction was not found).
   * @api
   */
  PluggableMap.prototype.removeInteraction = function removeInteraction (interaction) {
    return this.getInteractions().remove(interaction);
  };

  /**
   * Removes the given layer from the map.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @return {import("./layer/Base.js").default|undefined} The removed layer (or undefined if the
   *     layer was not found).
   * @api
   */
  PluggableMap.prototype.removeLayer = function removeLayer (layer) {
    var layers = this.getLayerGroup().getLayers();
    return layers.remove(layer);
  };

  /**
   * Remove the given overlay from the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @return {import("./Overlay.js").default|undefined} The removed overlay (or undefined
   *     if the overlay was not found).
   * @api
   */
  PluggableMap.prototype.removeOverlay = function removeOverlay (overlay) {
    return this.getOverlays().remove(overlay);
  };

  /**
   * @param {number} time Time.
   * @private
   */
  PluggableMap.prototype.renderFrame_ = function renderFrame_ (time) {
    var viewState;

    var size = this.getSize();
    var view = this.getView();
    var extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_20__["createEmpty"])();
    var previousFrameState = this.frameState_;
    /** @type {?FrameState} */
    var frameState = null;
    if (size !== undefined && Object(_size_js__WEBPACK_IMPORTED_MODULE_24__["hasArea"])(size) && view && view.isDef()) {
      var viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : undefined);
      var layerStatesArray = this.getLayerGroup().getLayerStatesArray();
      var layerStates = {};
      for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
        layerStates[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(layerStatesArray[i].layer)] = layerStatesArray[i];
      }
      viewState = view.getState(this.pixelRatio_);
      frameState = /** @type {FrameState} */ ({
        animate: false,
        coordinateToPixelTransform: this.coordinateToPixelTransform_,
        extent: extent,
        focus: this.focus_ ? this.focus_ : viewState.center,
        index: this.frameIndex_++,
        layerStates: layerStates,
        layerStatesArray: layerStatesArray,
        pixelRatio: this.pixelRatio_,
        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
        postRenderFunctions: [],
        size: size,
        skippedFeatureUids: this.skippedFeatureUids_,
        tileQueue: this.tileQueue_,
        time: time,
        usedTiles: {},
        viewState: viewState,
        viewHints: viewHints,
        wantedTiles: {}
      });
    }

    if (frameState) {
      frameState.extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_20__["getForViewAndSize"])(viewState.center,
        viewState.resolution, viewState.rotation, frameState.size, extent);
    }

    this.frameState_ = frameState;
    this.renderer_.renderFrame(frameState);

    if (frameState) {
      if (frameState.animate) {
        this.render();
      }
      Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);

      if (previousFrameState) {
        var moveStart = !this.previousExtent_ ||
                    (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_20__["isEmpty"])(this.previousExtent_) &&
                    !Object(_extent_js__WEBPACK_IMPORTED_MODULE_20__["equals"])(frameState.extent, this.previousExtent_));
        if (moveStart) {
          this.dispatchEvent(
            new _MapEvent_js__WEBPACK_IMPORTED_MODULE_6__["default"](_MapEventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].MOVESTART, this, previousFrameState));
          this.previousExtent_ = Object(_extent_js__WEBPACK_IMPORTED_MODULE_20__["createOrUpdateEmpty"])(this.previousExtent_);
        }
      }

      var idle = this.previousExtent_ &&
          !frameState.viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_14__["default"].ANIMATING] &&
          !frameState.viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_14__["default"].INTERACTING] &&
          !Object(_extent_js__WEBPACK_IMPORTED_MODULE_20__["equals"])(frameState.extent, this.previousExtent_);

      if (idle) {
        this.dispatchEvent(new _MapEvent_js__WEBPACK_IMPORTED_MODULE_6__["default"](_MapEventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].MOVEEND, this, frameState));
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_20__["clone"])(frameState.extent, this.previousExtent_);
      }
    }

    this.dispatchEvent(new _MapEvent_js__WEBPACK_IMPORTED_MODULE_6__["default"](_MapEventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].POSTRENDER, this, frameState));

    setTimeout(this.handlePostRender.bind(this), 0);

  };

  /**
   * Sets the layergroup of this map.
   * @param {LayerGroup} layerGroup A layer group containing the layers in this map.
   * @observable
   * @api
   */
  PluggableMap.prototype.setLayerGroup = function setLayerGroup (layerGroup) {
    this.set(_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].LAYERGROUP, layerGroup);
  };

  /**
   * Set the size of this map.
   * @param {import("./size.js").Size|undefined} size The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  PluggableMap.prototype.setSize = function setSize (size) {
    this.set(_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].SIZE, size);
  };

  /**
   * Set the target element to render this map into.
   * @param {HTMLElement|string|undefined} target The Element or id of the Element
   *     that the map is rendered in.
   * @observable
   * @api
   */
  PluggableMap.prototype.setTarget = function setTarget (target) {
    this.set(_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].TARGET, target);
  };

  /**
   * Set the view for this map.
   * @param {View} view The view that controls this map.
   * @observable
   * @api
   */
  PluggableMap.prototype.setView = function setView (view) {
    this.set(_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].VIEW, view);
  };

  /**
   * @param {import("./Feature.js").default} feature Feature.
   */
  PluggableMap.prototype.skipFeature = function skipFeature (feature) {
    this.skippedFeatureUids_[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature)] = true;
    this.render();
  };

  /**
   * Force a recalculation of the map viewport size.  This should be called when
   * third-party code changes the size of the map viewport.
   * @api
   */
  PluggableMap.prototype.updateSize = function updateSize () {
    var targetElement = this.getTargetElement();

    if (!targetElement) {
      this.setSize(undefined);
    } else {
      var computedStyle = getComputedStyle(targetElement);
      this.setSize([
        targetElement.offsetWidth -
            parseFloat(computedStyle['borderLeftWidth']) -
            parseFloat(computedStyle['paddingLeft']) -
            parseFloat(computedStyle['paddingRight']) -
            parseFloat(computedStyle['borderRightWidth']),
        targetElement.offsetHeight -
            parseFloat(computedStyle['borderTopWidth']) -
            parseFloat(computedStyle['paddingTop']) -
            parseFloat(computedStyle['paddingBottom']) -
            parseFloat(computedStyle['borderBottomWidth'])
      ]);
    }
  };

  /**
   * @param {import("./Feature.js").default} feature Feature.
   */
  PluggableMap.prototype.unskipFeature = function unskipFeature (feature) {
    delete this.skippedFeatureUids_[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature)];
    this.render();
  };

  return PluggableMap;
}(_Object_js__WEBPACK_IMPORTED_MODULE_10__["default"]));


/**
 * @param {MapOptions} options Map options.
 * @return {MapOptionsInternal} Internal map options.
 */
function createOptionsInternal(options) {

  /**
   * @type {HTMLElement|Document}
   */
  var keyboardEventTarget = null;
  if (options.keyboardEventTarget !== undefined) {
    keyboardEventTarget = typeof options.keyboardEventTarget === 'string' ?
      document.getElementById(options.keyboardEventTarget) :
      options.keyboardEventTarget;
  }

  /**
   * @type {Object<string, *>}
   */
  var values = {};

  var layerGroup = options.layers && typeof /** @type {?} */ (options.layers).getLayers === 'function' ?
    /** @type {LayerGroup} */ (options.layers) : new _layer_Group_js__WEBPACK_IMPORTED_MODULE_23__["default"]({layers: /** @type {Collection} */ (options.layers)});
  values[_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].LAYERGROUP] = layerGroup;

  values[_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].TARGET] = options.target;

  values[_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].VIEW] = options.view !== undefined ?
    options.view : new _View_js__WEBPACK_IMPORTED_MODULE_13__["default"]();

  var controls;
  if (options.controls !== undefined) {
    if (Array.isArray(options.controls)) {
      controls = new _Collection_js__WEBPACK_IMPORTED_MODULE_1__["default"](options.controls.slice());
    } else {
      Object(_asserts_js__WEBPACK_IMPORTED_MODULE_15__["assert"])(typeof /** @type {?} */ (options.controls).getArray === 'function',
        47); // Expected `controls` to be an array or an `import("./Collection.js").Collection`
      controls = /** @type {Collection} */ (options.controls);
    }
  }

  var interactions;
  if (options.interactions !== undefined) {
    if (Array.isArray(options.interactions)) {
      interactions = new _Collection_js__WEBPACK_IMPORTED_MODULE_1__["default"](options.interactions.slice());
    } else {
      Object(_asserts_js__WEBPACK_IMPORTED_MODULE_15__["assert"])(typeof /** @type {?} */ (options.interactions).getArray === 'function',
        48); // Expected `interactions` to be an array or an `import("./Collection.js").Collection`
      interactions = /** @type {Collection} */ (options.interactions);
    }
  }

  var overlays;
  if (options.overlays !== undefined) {
    if (Array.isArray(options.overlays)) {
      overlays = new _Collection_js__WEBPACK_IMPORTED_MODULE_1__["default"](options.overlays.slice());
    } else {
      Object(_asserts_js__WEBPACK_IMPORTED_MODULE_15__["assert"])(typeof /** @type {?} */ (options.overlays).getArray === 'function',
        49); // Expected `overlays` to be an array or an `import("./Collection.js").Collection`
      overlays = options.overlays;
    }
  } else {
    overlays = new _Collection_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
  }

  return {
    controls: controls,
    interactions: interactions,
    keyboardEventTarget: keyboardEventTarget,
    overlays: overlays,
    values: values
  };

}
/* harmony default export */ __webpack_exports__["default"] = (PluggableMap);

/**
 * @param  {Array<import("./layer/Base.js").default>} layers Layers.
 * @return {boolean} Layers have sources that are still loading.
 */
function getLoading(layers) {
  for (var i = 0, ii = layers.length; i < ii; ++i) {
    var layer = layers[i];
    if (typeof /** @type {?} */ (layer).getLayers === 'function') {
      return getLoading(/** @type {LayerGroup} */ (layer).getLayers().getArray());
    } else {
      var source = /** @type {import("./layer/Layer.js").default} */ (
        layer).getSource();
      if (source && source.loading) {
        return true;
      }
    }
  }
  return false;
}

//# sourceMappingURL=PluggableMap.js.map

/***/ }),

/***/ "./node_modules/ol/Tile.js":
/*!*********************************!*\
  !*** ./node_modules/ol/Tile.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./easing.js */ "./node_modules/ol/easing.js");
/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events/Target.js */ "./node_modules/ol/events/Target.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/**
 * @module ol/Tile
 */






/**
 * A function that takes an {@link module:ol/Tile} for the tile and a
 * `{string}` for the url as arguments. The default is
 * ```js
 * source.setTileLoadFunction(function(tile, src) {
 *   tile.getImage().src = src;
 * });
 * ```
 * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve
 * error handling:
 *
 * ```js
 * import TileState from 'ol/TileState';
 *
 * source.setTileLoadFunction(function(tile, src) {
 *   var xhr = new XMLHttpRequest();
 *   xhr.responseType = 'blob';
 *   xhr.addEventListener('loadend', function (evt) {
 *     var data = this.response;
 *     if (data !== undefined) {
 *       tile.getImage().src = URL.createObjectURL(data);
 *     } else {
 *       tile.setState(TileState.ERROR);
 *     }
 *   });
 *   xhr.addEventListener('error', function () {
 *     tile.setState(TileState.ERROR);
 *   });
 *   xhr.open('GET', src);
 *   xhr.send();
 * });
 * ```
 *
 * @typedef {function(Tile, string)} LoadFunction
 * @api
 */

/**
 * {@link module:ol/source/Tile~Tile} sources use a function of this type to get
 * the url that provides a tile for a given tile coordinate.
 *
 * This function takes an {@link module:ol/tilecoord~TileCoord} for the tile
 * coordinate, a `{number}` representing the pixel ratio and a
 * {@link module:ol/proj/Projection} for the projection  as arguments
 * and returns a `{string}` representing the tile URL, or undefined if no tile
 * should be requested for the passed tile coordinate.
 *
 * @typedef {function(import("./tilecoord.js").TileCoord, number,
 *           import("./proj/Projection.js").default): (string|undefined)} UrlFunction
 * @api
 */


/**
 * @typedef {Object} Options
 * @property {number} [transition=250] A duration for tile opacity
 * transitions in milliseconds. A duration of 0 disables the opacity transition.
 * @api
 */


/**
 * @classdesc
 * Base class for tiles.
 *
 * @abstract
 */
var Tile = /*@__PURE__*/(function (EventTarget) {
  function Tile(tileCoord, state, opt_options) {
    EventTarget.call(this);

    var options = opt_options ? opt_options : {};

    /**
     * @type {import("./tilecoord.js").TileCoord}
     */
    this.tileCoord = tileCoord;

    /**
     * @protected
     * @type {TileState}
     */
    this.state = state;

    /**
     * An "interim" tile for this tile. The interim tile may be used while this
     * one is loading, for "smooth" transitions when changing params/dimensions
     * on the source.
     * @type {Tile}
     */
    this.interimTile = null;

    /**
     * A key assigned to the tile. This is used by the tile source to determine
     * if this tile can effectively be used, or if a new tile should be created
     * and this one be used as an interim tile for this new tile.
     * @type {string}
     */
    this.key = '';

    /**
     * The duration for the opacity transition.
     * @type {number}
     */
    this.transition_ = options.transition === undefined ? 250 : options.transition;

    /**
     * Lookup of start times for rendering transitions.  If the start time is
     * equal to -1, the transition is complete.
     * @type {Object<string, number>}
     */
    this.transitionStarts_ = {};

  }

  if ( EventTarget ) Tile.__proto__ = EventTarget;
  Tile.prototype = Object.create( EventTarget && EventTarget.prototype );
  Tile.prototype.constructor = Tile;

  /**
   * @protected
   */
  Tile.prototype.changed = function changed () {
    this.dispatchEvent(_events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].CHANGE);
  };

  /**
   * @return {string} Key.
   */
  Tile.prototype.getKey = function getKey () {
    return this.key + '/' + this.tileCoord;
  };

  /**
   * Get the interim tile most suitable for rendering using the chain of interim
   * tiles. This corresponds to the  most recent tile that has been loaded, if no
   * such tile exists, the original tile is returned.
   * @return {!Tile} Best tile for rendering.
   */
  Tile.prototype.getInterimTile = function getInterimTile () {
    if (!this.interimTile) {
      //empty chain
      return this;
    }
    var tile = this.interimTile;

    // find the first loaded tile and return it. Since the chain is sorted in
    // decreasing order of creation time, there is no need to search the remainder
    // of the list (all those tiles correspond to older requests and will be
    // cleaned up by refreshInterimChain)
    do {
      if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].LOADED) {
        return tile;
      }
      tile = tile.interimTile;
    } while (tile);

    // we can not find a better tile
    return this;
  };

  /**
   * Goes through the chain of interim tiles and discards sections of the chain
   * that are no longer relevant.
   */
  Tile.prototype.refreshInterimChain = function refreshInterimChain () {
    if (!this.interimTile) {
      return;
    }

    var tile = this.interimTile;
    var prev = /** @type {Tile} */ (this);

    do {
      if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].LOADED) {
        //we have a loaded tile, we can discard the rest of the list
        //we would could abort any LOADING tile request
        //older than this tile (i.e. any LOADING tile following this entry in the chain)
        tile.interimTile = null;
        break;
      } else if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].LOADING) {
        //keep this LOADING tile any loaded tiles later in the chain are
        //older than this tile, so we're still interested in the request
        prev = tile;
      } else if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].IDLE) {
        //the head of the list is the most current tile, we don't need
        //to start any other requests for this chain
        prev.interimTile = tile.interimTile;
      } else {
        prev = tile;
      }
      tile = prev.interimTile;
    } while (tile);
  };

  /**
   * Get the tile coordinate for this tile.
   * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
   * @api
   */
  Tile.prototype.getTileCoord = function getTileCoord () {
    return this.tileCoord;
  };

  /**
   * @return {TileState} State.
   */
  Tile.prototype.getState = function getState () {
    return this.state;
  };

  /**
   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,
   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}
   * when the tile cannot be loaded. Otherwise the tile cannot be removed from
   * the tile queue and will block other requests.
   * @param {TileState} state State.
   * @api
   */
  Tile.prototype.setState = function setState (state) {
    this.state = state;
    this.changed();
  };

  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   * @abstract
   * @api
   */
  Tile.prototype.load = function load () {};

  /**
   * Get the alpha value for rendering.
   * @param {string} id An id for the renderer.
   * @param {number} time The render frame time.
   * @return {number} A number between 0 and 1.
   */
  Tile.prototype.getAlpha = function getAlpha (id, time) {
    if (!this.transition_) {
      return 1;
    }

    var start = this.transitionStarts_[id];
    if (!start) {
      start = time;
      this.transitionStarts_[id] = start;
    } else if (start === -1) {
      return 1;
    }

    var delta = time - start + (1000 / 60); // avoid rendering at 0
    if (delta >= this.transition_) {
      return 1;
    }
    return Object(_easing_js__WEBPACK_IMPORTED_MODULE_1__["easeIn"])(delta / this.transition_);
  };

  /**
   * Determine if a tile is in an alpha transition.  A tile is considered in
   * transition if tile.getAlpha() has not yet been called or has been called
   * and returned 1.
   * @param {string} id An id for the renderer.
   * @return {boolean} The tile is in transition.
   */
  Tile.prototype.inTransition = function inTransition (id) {
    if (!this.transition_) {
      return false;
    }
    return this.transitionStarts_[id] !== -1;
  };

  /**
   * Mark a transition as complete.
   * @param {string} id An id for the renderer.
   */
  Tile.prototype.endTransition = function endTransition (id) {
    if (this.transition_) {
      this.transitionStarts_[id] = -1;
    }
  };

  return Tile;
}(_events_Target_js__WEBPACK_IMPORTED_MODULE_2__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (Tile);

//# sourceMappingURL=Tile.js.map

/***/ }),

/***/ "./node_modules/ol/TileCache.js":
/*!**************************************!*\
  !*** ./node_modules/ol/TileCache.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _structs_LRUCache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./structs/LRUCache.js */ "./node_modules/ol/structs/LRUCache.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tilecoord.js */ "./node_modules/ol/tilecoord.js");
/**
 * @module ol/TileCache
 */



var TileCache = /*@__PURE__*/(function (LRUCache) {
  function TileCache(opt_highWaterMark) {

    LRUCache.call(this, opt_highWaterMark);

  }

  if ( LRUCache ) TileCache.__proto__ = LRUCache;
  TileCache.prototype = Object.create( LRUCache && LRUCache.prototype );
  TileCache.prototype.constructor = TileCache;

  /**
   * @param {!Object<string, import("./TileRange.js").default>} usedTiles Used tiles.
   */
  TileCache.prototype.expireCache = function expireCache (usedTiles) {
    while (this.canExpireCache()) {
      var tile = this.peekLast();
      var zKey = tile.tileCoord[0].toString();
      if (zKey in usedTiles && usedTiles[zKey].contains(tile.tileCoord)) {
        break;
      } else {
        this.pop().dispose();
      }
    }
  };

  /**
   * Prune all tiles from the cache that don't have the same z as the newest tile.
   */
  TileCache.prototype.pruneExceptNewestZ = function pruneExceptNewestZ () {
    if (this.getCount() === 0) {
      return;
    }
    var key = this.peekFirstKey();
    var tileCoord = Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_1__["fromKey"])(key);
    var z = tileCoord[0];
    this.forEach(function(tile) {
      if (tile.tileCoord[0] !== z) {
        this.remove(Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_1__["getKey"])(tile.tileCoord));
        tile.dispose();
      }
    }, this);
  };

  return TileCache;
}(_structs_LRUCache_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (TileCache);

//# sourceMappingURL=TileCache.js.map

/***/ }),

/***/ "./node_modules/ol/TileQueue.js":
/*!**************************************!*\
  !*** ./node_modules/ol/TileQueue.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _structs_PriorityQueue_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./structs/PriorityQueue.js */ "./node_modules/ol/structs/PriorityQueue.js");
/**
 * @module ol/TileQueue
 */






/**
 * @typedef {function(import("./Tile.js").default, string, import("./coordinate.js").Coordinate, number): number} PriorityFunction
 */


var TileQueue = /*@__PURE__*/(function (PriorityQueue) {
  function TileQueue(tilePriorityFunction, tileChangeCallback) {

    PriorityQueue.call(
      /**
       * @param {Array} element Element.
       * @return {number} Priority.
       */
      this, function(element) {
        return tilePriorityFunction.apply(null, element);
      },
      /**
       * @param {Array} element Element.
       * @return {string} Key.
       */
      function(element) {
        return (/** @type {import("./Tile.js").default} */ (element[0]).getKey());
      });

    /**
     * @private
     * @type {function(): ?}
     */
    this.tileChangeCallback_ = tileChangeCallback;

    /**
     * @private
     * @type {number}
     */
    this.tilesLoading_ = 0;

    /**
     * @private
     * @type {!Object<string,boolean>}
     */
    this.tilesLoadingKeys_ = {};

  }

  if ( PriorityQueue ) TileQueue.__proto__ = PriorityQueue;
  TileQueue.prototype = Object.create( PriorityQueue && PriorityQueue.prototype );
  TileQueue.prototype.constructor = TileQueue;

  /**
   * @inheritDoc
   */
  TileQueue.prototype.enqueue = function enqueue (element) {
    var added = PriorityQueue.prototype.enqueue.call(this, element);
    if (added) {
      var tile = element[0];
      Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["listen"])(tile, _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CHANGE, this.handleTileChange, this);
    }
    return added;
  };

  /**
   * @return {number} Number of tiles loading.
   */
  TileQueue.prototype.getTilesLoading = function getTilesLoading () {
    return this.tilesLoading_;
  };

  /**
   * @param {import("./events/Event.js").default} event Event.
   * @protected
   */
  TileQueue.prototype.handleTileChange = function handleTileChange (event) {
    var tile = /** @type {import("./Tile.js").default} */ (event.target);
    var state = tile.getState();
    if (state === _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].LOADED || state === _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].ERROR ||
        state === _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].EMPTY || state === _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].ABORT) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["unlisten"])(tile, _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CHANGE, this.handleTileChange, this);
      var tileKey = tile.getKey();
      if (tileKey in this.tilesLoadingKeys_) {
        delete this.tilesLoadingKeys_[tileKey];
        --this.tilesLoading_;
      }
      this.tileChangeCallback_();
    }
  };

  /**
   * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
   * @param {number} maxNewLoads Maximum number of new tiles to load.
   */
  TileQueue.prototype.loadMoreTiles = function loadMoreTiles (maxTotalLoading, maxNewLoads) {
    var newLoads = 0;
    var abortedTiles = false;
    var state, tile, tileKey;
    while (this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads &&
           this.getCount() > 0) {
      tile = /** @type {import("./Tile.js").default} */ (this.dequeue()[0]);
      tileKey = tile.getKey();
      state = tile.getState();
      if (state === _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].ABORT) {
        abortedTiles = true;
      } else if (state === _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].IDLE && !(tileKey in this.tilesLoadingKeys_)) {
        this.tilesLoadingKeys_[tileKey] = true;
        ++this.tilesLoading_;
        ++newLoads;
        tile.load();
      }
    }
    if (newLoads === 0 && abortedTiles) {
      // Do not stop the render loop when all wanted tiles were aborted due to
      // a small, saturated tile cache.
      this.tileChangeCallback_();
    }
  };

  return TileQueue;
}(_structs_PriorityQueue_js__WEBPACK_IMPORTED_MODULE_3__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (TileQueue);

//# sourceMappingURL=TileQueue.js.map

/***/ }),

/***/ "./node_modules/ol/TileRange.js":
/*!**************************************!*\
  !*** ./node_modules/ol/TileRange.js ***!
  \**************************************/
/*! exports provided: createOrUpdate, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdate", function() { return createOrUpdate; });
/**
 * @module ol/TileRange
 */

/**
 * A representation of a contiguous block of tiles.  A tile range is specified
 * by its min/max tile coordinates and is inclusive of coordinates.
 */
var TileRange = function TileRange(minX, maxX, minY, maxY) {

  /**
   * @type {number}
   */
  this.minX = minX;

  /**
   * @type {number}
   */
  this.maxX = maxX;

  /**
   * @type {number}
   */
  this.minY = minY;

  /**
   * @type {number}
   */
  this.maxY = maxY;

};

/**
 * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @return {boolean} Contains tile coordinate.
 */
TileRange.prototype.contains = function contains (tileCoord) {
  return this.containsXY(tileCoord[1], tileCoord[2]);
};

/**
 * @param {TileRange} tileRange Tile range.
 * @return {boolean} Contains.
 */
TileRange.prototype.containsTileRange = function containsTileRange (tileRange) {
  return this.minX <= tileRange.minX && tileRange.maxX <= this.maxX &&
     this.minY <= tileRange.minY && tileRange.maxY <= this.maxY;
};

/**
 * @param {number} x Tile coordinate x.
 * @param {number} y Tile coordinate y.
 * @return {boolean} Contains coordinate.
 */
TileRange.prototype.containsXY = function containsXY (x, y) {
  return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
};

/**
 * @param {TileRange} tileRange Tile range.
 * @return {boolean} Equals.
 */
TileRange.prototype.equals = function equals (tileRange) {
  return this.minX == tileRange.minX && this.minY == tileRange.minY &&
     this.maxX == tileRange.maxX && this.maxY == tileRange.maxY;
};

/**
 * @param {TileRange} tileRange Tile range.
 */
TileRange.prototype.extend = function extend (tileRange) {
  if (tileRange.minX < this.minX) {
    this.minX = tileRange.minX;
  }
  if (tileRange.maxX > this.maxX) {
    this.maxX = tileRange.maxX;
  }
  if (tileRange.minY < this.minY) {
    this.minY = tileRange.minY;
  }
  if (tileRange.maxY > this.maxY) {
    this.maxY = tileRange.maxY;
  }
};

/**
 * @return {number} Height.
 */
TileRange.prototype.getHeight = function getHeight () {
  return this.maxY - this.minY + 1;
};

/**
 * @return {import("./size.js").Size} Size.
 */
TileRange.prototype.getSize = function getSize () {
  return [this.getWidth(), this.getHeight()];
};

/**
 * @return {number} Width.
 */
TileRange.prototype.getWidth = function getWidth () {
  return this.maxX - this.minX + 1;
};

/**
 * @param {TileRange} tileRange Tile range.
 * @return {boolean} Intersects.
 */
TileRange.prototype.intersects = function intersects (tileRange) {
  return this.minX <= tileRange.maxX &&
     this.maxX >= tileRange.minX &&
     this.minY <= tileRange.maxY &&
     this.maxY >= tileRange.minY;
};


/**
 * @param {number} minX Minimum X.
 * @param {number} maxX Maximum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxY Maximum Y.
 * @param {TileRange=} tileRange TileRange.
 * @return {TileRange} Tile range.
 */
function createOrUpdate(minX, maxX, minY, maxY, tileRange) {
  if (tileRange !== undefined) {
    tileRange.minX = minX;
    tileRange.maxX = maxX;
    tileRange.minY = minY;
    tileRange.maxY = maxY;
    return tileRange;
  } else {
    return new TileRange(minX, maxX, minY, maxY);
  }
}


/* harmony default export */ __webpack_exports__["default"] = (TileRange);

//# sourceMappingURL=TileRange.js.map

/***/ }),

/***/ "./node_modules/ol/TileState.js":
/*!**************************************!*\
  !*** ./node_modules/ol/TileState.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/TileState
 */

/**
 * @enum {number}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  /**
   * Indicates that tile loading failed
   * @type {number}
   */
  ERROR: 3,
  EMPTY: 4,
  ABORT: 5
});

//# sourceMappingURL=TileState.js.map

/***/ }),

/***/ "./node_modules/ol/View.js":
/*!*********************************!*\
  !*** ./node_modules/ol/View.js ***!
  \*********************************/
/*! exports provided: createCenterConstraint, createResolutionConstraint, createRotationConstraint, isNoopAnimation, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createCenterConstraint", function() { return createCenterConstraint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createResolutionConstraint", function() { return createResolutionConstraint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createRotationConstraint", function() { return createRotationConstraint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNoopAnimation", function() { return isNoopAnimation; });
/* harmony import */ var _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tilegrid/common.js */ "./node_modules/ol/tilegrid/common.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _centerconstraint_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./centerconstraint.js */ "./node_modules/ol/centerconstraint.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _resolutionconstraint_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./resolutionconstraint.js */ "./node_modules/ol/resolutionconstraint.js");
/* harmony import */ var _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./rotationconstraint.js */ "./node_modules/ol/rotationconstraint.js");
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ViewHint.js */ "./node_modules/ol/ViewHint.js");
/* harmony import */ var _ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ViewProperty.js */ "./node_modules/ol/ViewProperty.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./coordinate.js */ "./node_modules/ol/coordinate.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./easing.js */ "./node_modules/ol/easing.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./geom/Polygon.js */ "./node_modules/ol/geom/Polygon.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _proj_Units_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./proj/Units.js */ "./node_modules/ol/proj/Units.js");
/**
 * @module ol/View
 */






















/**
 * An animation configuration
 *
 * @typedef {Object} Animation
 * @property {import("./coordinate.js").Coordinate} [sourceCenter]
 * @property {import("./coordinate.js").Coordinate} [targetCenter]
 * @property {number} [sourceResolution]
 * @property {number} [targetResolution]
 * @property {number} [sourceRotation]
 * @property {number} [targetRotation]
 * @property {import("./coordinate.js").Coordinate} [anchor]
 * @property {number} start
 * @property {number} duration
 * @property {boolean} complete
 * @property {function(number):number} easing
 * @property {function(boolean)} callback
 */


/**
 * @typedef {Object} Constraints
 * @property {import("./centerconstraint.js").Type} center
 * @property {import("./resolutionconstraint.js").Type} resolution
 * @property {import("./rotationconstraint.js").Type} rotation
 */


/**
 * @typedef {Object} FitOptions
 * @property {import("./size.js").Size} [size] The size in pixels of the box to fit
 * the extent into. Default is the current size of the first map in the DOM that
 * uses this view, or `[100, 100]` if no such map is found.
 * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in pixels) to be
 * cleared inside the view. Values in the array are top, right, bottom and left
 * padding.
 * @property {boolean} [constrainResolution=true] Constrain the resolution.
 * @property {boolean} [nearest=false] If `constrainResolution` is `true`, get
 * the nearest extent instead of the closest that actually fits the view.
 * @property {number} [minResolution=0] Minimum resolution that we zoom to.
 * @property {number} [maxZoom] Maximum zoom level that we zoom to. If
 * `minResolution` is given, this property is ignored.
 * @property {number} [duration] The duration of the animation in milliseconds.
 * By default, there is no animation to the target extent.
 * @property {function(number):number} [easing] The easing function used during
 * the animation (defaults to {@link module:ol/easing~inAndOut}).
 * The function will be called for each frame with a number representing a
 * fraction of the animation's duration.  The function should return a number
 * between 0 and 1 representing the progress toward the destination state.
 * @property {function(boolean)} [callback] Function called when the view is in
 * its final position. The callback will be called with `true` if the animation
 * series completed on its own or `false` if it was cancelled.
 */


/**
 * @typedef {Object} ViewOptions
 * @property {import("./coordinate.js").Coordinate} [center] The initial center for
 * the view. The coordinate system for the center is specified with the
 * `projection` option. Layer sources will not be fetched if this is not set,
 * but the center can be set later with {@link #setCenter}.
 * @property {boolean|number} [constrainRotation=true] Rotation constraint.
 * `false` means no constraint. `true` means no constraint, but snap to zero
 * near zero. A number constrains the rotation to that number of values. For
 * example, `4` will constrain the rotation to 0, 90, 180, and 270 degrees.
 * @property {boolean} [enableRotation=true] Enable rotation.
 * If `false`, a rotation constraint that always sets the rotation to zero is
 * used. The `constrainRotation` option has no effect if `enableRotation` is
 * `false`.
 * @property {import("./extent.js").Extent} [extent] The extent that constrains the
 * center, in other words, center cannot be set outside this extent.
 * @property {number} [maxResolution] The maximum resolution used to determine
 * the resolution constraint. It is used together with `minResolution` (or
 * `maxZoom`) and `zoomFactor`. If unspecified it is calculated in such a way
 * that the projection's validity extent fits in a 256x256 px tile. If the
 * projection is Spherical Mercator (the default) then `maxResolution` defaults
 * to `40075016.68557849 / 256 = 156543.03392804097`.
 * @property {number} [minResolution] The minimum resolution used to determine
 * the resolution constraint.  It is used together with `maxResolution` (or
 * `minZoom`) and `zoomFactor`.  If unspecified it is calculated assuming 29
 * zoom levels (with a factor of 2). If the projection is Spherical Mercator
 * (the default) then `minResolution` defaults to
 * `40075016.68557849 / 256 / Math.pow(2, 28) = 0.0005831682455839253`.
 * @property {number} [maxZoom=28] The maximum zoom level used to determine the
 * resolution constraint. It is used together with `minZoom` (or
 * `maxResolution`) and `zoomFactor`.  Note that if `minResolution` is also
 * provided, it is given precedence over `maxZoom`.
 * @property {number} [minZoom=0] The minimum zoom level used to determine the
 * resolution constraint. It is used together with `maxZoom` (or
 * `minResolution`) and `zoomFactor`.  Note that if `maxResolution` is also
 * provided, it is given precedence over `minZoom`.
 * @property {import("./proj.js").ProjectionLike} [projection='EPSG:3857'] The
 * projection. The default is Spherical Mercator.
 * @property {number} [resolution] The initial resolution for the view. The
 * units are `projection` units per pixel (e.g. meters per pixel). An
 * alternative to setting this is to set `zoom`. Layer sources will not be
 * fetched if neither this nor `zoom` are defined, but they can be set later
 * with {@link #setZoom} or {@link #setResolution}.
 * @property {Array<number>} [resolutions] Resolutions to determine the
 * resolution constraint. If set the `maxResolution`, `minResolution`,
 * `minZoom`, `maxZoom`, and `zoomFactor` options are ignored.
 * @property {number} [rotation=0] The initial rotation for the view in radians
 * (positive rotation clockwise, 0 means North).
 * @property {number} [zoom] Only used if `resolution` is not defined. Zoom
 * level used to calculate the initial resolution for the view. The initial
 * resolution is determined using the {@link #constrainResolution} method.
 * @property {number} [zoomFactor=2] The zoom factor used to determine the
 * resolution constraint.
 */


/**
 * @typedef {Object} AnimationOptions
 * @property {import("./coordinate.js").Coordinate} [center] The center of the view at the end of
 * the animation.
 * @property {number} [zoom] The zoom level of the view at the end of the
 * animation. This takes precedence over `resolution`.
 * @property {number} [resolution] The resolution of the view at the end
 * of the animation.  If `zoom` is also provided, this option will be ignored.
 * @property {number} [rotation] The rotation of the view at the end of
 * the animation.
 * @property {import("./coordinate.js").Coordinate} [anchor] Optional anchor to remained fixed
 * during a rotation or resolution animation.
 * @property {number} [duration=1000] The duration of the animation in milliseconds.
 * @property {function(number):number} [easing] The easing function used
 * during the animation (defaults to {@link module:ol/easing~inAndOut}).
 * The function will be called for each frame with a number representing a
 * fraction of the animation's duration.  The function should return a number
 * between 0 and 1 representing the progress toward the destination state.
 */


/**
 * @typedef {Object} State
 * @property {import("./coordinate.js").Coordinate} center
 * @property {import("./proj/Projection.js").default} projection
 * @property {number} resolution
 * @property {number} rotation
 * @property {number} zoom
 */


/**
 * Default min zoom level for the map view.
 * @type {number}
 */
var DEFAULT_MIN_ZOOM = 0;


/**
 * @classdesc
 * A View object represents a simple 2D view of the map.
 *
 * This is the object to act upon to change the center, resolution,
 * and rotation of the map.
 *
 * ### The view states
 *
 * An View is determined by three states: `center`, `resolution`,
 * and `rotation`. Each state has a corresponding getter and setter, e.g.
 * `getCenter` and `setCenter` for the `center` state.
 *
 * An View has a `projection`. The projection determines the
 * coordinate system of the center, and its units determine the units of the
 * resolution (projection units per pixel). The default projection is
 * Spherical Mercator (EPSG:3857).
 *
 * ### The constraints
 *
 * `setCenter`, `setResolution` and `setRotation` can be used to change the
 * states of the view. Any value can be passed to the setters. And the value
 * that is passed to a setter will effectively be the value set in the view,
 * and returned by the corresponding getter.
 *
 * But a View object also has a *resolution constraint*, a
 * *rotation constraint* and a *center constraint*.
 *
 * As said above, no constraints are applied when the setters are used to set
 * new states for the view. Applying constraints is done explicitly through
 * the use of the `constrain*` functions (`constrainResolution` and
 * `constrainRotation` and `constrainCenter`).
 *
 * The main users of the constraints are the interactions and the
 * controls. For example, double-clicking on the map changes the view to
 * the "next" resolution. And releasing the fingers after pinch-zooming
 * snaps to the closest resolution (with an animation).
 *
 * The *resolution constraint* snaps to specific resolutions. It is
 * determined by the following options: `resolutions`, `maxResolution`,
 * `maxZoom`, and `zoomFactor`. If `resolutions` is set, the other three
 * options are ignored. See documentation for each option for more
 * information.
 *
 * The *rotation constraint* snaps to specific angles. It is determined
 * by the following options: `enableRotation` and `constrainRotation`.
 * By default the rotation value is snapped to zero when approaching the
 * horizontal.
 *
 * The *center constraint* is determined by the `extent` option. By
 * default the center is not constrained at all.
 *
  * @api
 */
var View = /*@__PURE__*/(function (BaseObject) {
  function View(opt_options) {
    BaseObject.call(this);

    var options = Object(_obj_js__WEBPACK_IMPORTED_MODULE_17__["assign"])({}, opt_options);

    /**
     * @private
     * @type {Array<number>}
     */
    this.hints_ = [0, 0];

    /**
     * @private
     * @type {Array<Array<Animation>>}
     */
    this.animations_ = [];

    /**
     * @private
     * @type {number|undefined}
     */
    this.updateAnimationKey_;

    this.updateAnimations_ = this.updateAnimations_.bind(this);

    /**
     * @private
     * @const
     * @type {import("./proj/Projection.js").default}
     */
    this.projection_ = Object(_proj_js__WEBPACK_IMPORTED_MODULE_18__["createProjection"])(options.projection, 'EPSG:3857');

    this.applyOptions_(options);
  }

  if ( BaseObject ) View.__proto__ = BaseObject;
  View.prototype = Object.create( BaseObject && BaseObject.prototype );
  View.prototype.constructor = View;

  /**
   * Set up the view with the given options.
   * @param {ViewOptions} options View options.
   */
  View.prototype.applyOptions_ = function applyOptions_ (options) {

    /**
     * @type {Object<string, *>}
     */
    var properties = {};
    properties[_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].CENTER] = options.center !== undefined ?
      options.center : null;

    var resolutionConstraintInfo = createResolutionConstraint(options);

    /**
     * @private
     * @type {number}
     */
    this.maxResolution_ = resolutionConstraintInfo.maxResolution;

    /**
     * @private
     * @type {number}
     */
    this.minResolution_ = resolutionConstraintInfo.minResolution;

    /**
     * @private
     * @type {number}
     */
    this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;

    /**
     * @private
     * @type {Array<number>|undefined}
     */
    this.resolutions_ = options.resolutions;

    /**
     * @private
     * @type {number}
     */
    this.minZoom_ = resolutionConstraintInfo.minZoom;

    var centerConstraint = createCenterConstraint(options);
    var resolutionConstraint = resolutionConstraintInfo.constraint;
    var rotationConstraint = createRotationConstraint(options);

    /**
     * @private
     * @type {Constraints}
     */
    this.constraints_ = {
      center: centerConstraint,
      resolution: resolutionConstraint,
      rotation: rotationConstraint
    };

    if (options.resolution !== undefined) {
      properties[_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].RESOLUTION] = options.resolution;
    } else if (options.zoom !== undefined) {
      properties[_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].RESOLUTION] = this.constrainResolution(
        this.maxResolution_, options.zoom - this.minZoom_);

      if (this.resolutions_) { // in case map zoom is out of min/max zoom range
        properties[_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].RESOLUTION] = Object(_math_js__WEBPACK_IMPORTED_MODULE_16__["clamp"])(
          Number(this.getResolution() || properties[_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].RESOLUTION]),
          this.minResolution_, this.maxResolution_);
      }
    }
    properties[_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].ROTATION] = options.rotation !== undefined ? options.rotation : 0;
    this.setProperties(properties);

    /**
     * @private
     * @type {ViewOptions}
     */
    this.options_ = options;

  };

  /**
   * Get an updated version of the view options used to construct the view.  The
   * current resolution (or zoom), center, and rotation are applied to any stored
   * options.  The provided options can be used to apply new min/max zoom or
   * resolution limits.
   * @param {ViewOptions} newOptions New options to be applied.
   * @return {ViewOptions} New options updated with the current view state.
   */
  View.prototype.getUpdatedOptions_ = function getUpdatedOptions_ (newOptions) {
    var options = Object(_obj_js__WEBPACK_IMPORTED_MODULE_17__["assign"])({}, this.options_);

    // preserve resolution (or zoom)
    if (options.resolution !== undefined) {
      options.resolution = this.getResolution();
    } else {
      options.zoom = this.getZoom();
    }

    // preserve center
    options.center = this.getCenter();

    // preserve rotation
    options.rotation = this.getRotation();

    return Object(_obj_js__WEBPACK_IMPORTED_MODULE_17__["assign"])({}, options, newOptions);
  };

  /**
   * Animate the view.  The view's center, zoom (or resolution), and rotation
   * can be animated for smooth transitions between view states.  For example,
   * to animate the view to a new zoom level:
   *
   *     view.animate({zoom: view.getZoom() + 1});
   *
   * By default, the animation lasts one second and uses in-and-out easing.  You
   * can customize this behavior by including `duration` (in milliseconds) and
   * `easing` options (see {@link module:ol/easing}).
   *
   * To chain together multiple animations, call the method with multiple
   * animation objects.  For example, to first zoom and then pan:
   *
   *     view.animate({zoom: 10}, {center: [0, 0]});
   *
   * If you provide a function as the last argument to the animate method, it
   * will get called at the end of an animation series.  The callback will be
   * called with `true` if the animation series completed on its own or `false`
   * if it was cancelled.
   *
   * Animations are cancelled by user interactions (e.g. dragging the map) or by
   * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
   * (or another method that calls one of these).
   *
   * @param {...(AnimationOptions|function(boolean))} var_args Animation
   *     options.  Multiple animations can be run in series by passing multiple
   *     options objects.  To run multiple animations in parallel, call the method
   *     multiple times.  An optional callback can be provided as a final
   *     argument.  The callback will be called with a boolean indicating whether
   *     the animation completed without being cancelled.
   * @api
   */
  View.prototype.animate = function animate (var_args) {
    var arguments$1 = arguments;

    var animationCount = arguments.length;
    var callback;
    if (animationCount > 1 && typeof arguments[animationCount - 1] === 'function') {
      callback = arguments[animationCount - 1];
      --animationCount;
    }
    if (!this.isDef()) {
      // if view properties are not yet set, shortcut to the final state
      var state = arguments[animationCount - 1];
      if (state.center) {
        this.setCenter(state.center);
      }
      if (state.zoom !== undefined) {
        this.setZoom(state.zoom);
      }
      if (state.rotation !== undefined) {
        this.setRotation(state.rotation);
      }
      if (callback) {
        animationCallback(callback, true);
      }
      return;
    }
    var start = Date.now();
    var center = this.getCenter().slice();
    var resolution = this.getResolution();
    var rotation = this.getRotation();
    var series = [];
    for (var i = 0; i < animationCount; ++i) {
      var options = /** @type {AnimationOptions} */ (arguments$1[i]);

      var animation = /** @type {Animation} */ ({
        start: start,
        complete: false,
        anchor: options.anchor,
        duration: options.duration !== undefined ? options.duration : 1000,
        easing: options.easing || _easing_js__WEBPACK_IMPORTED_MODULE_12__["inAndOut"]
      });

      if (options.center) {
        animation.sourceCenter = center;
        animation.targetCenter = options.center;
        center = animation.targetCenter;
      }

      if (options.zoom !== undefined) {
        animation.sourceResolution = resolution;
        animation.targetResolution = this.constrainResolution(
          this.maxResolution_, options.zoom - this.minZoom_, 0);
        resolution = animation.targetResolution;
      } else if (options.resolution) {
        animation.sourceResolution = resolution;
        animation.targetResolution = options.resolution;
        resolution = animation.targetResolution;
      }

      if (options.rotation !== undefined) {
        animation.sourceRotation = rotation;
        var delta = Object(_math_js__WEBPACK_IMPORTED_MODULE_16__["modulo"])(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
        animation.targetRotation = rotation + delta;
        rotation = animation.targetRotation;
      }

      animation.callback = callback;

      // check if animation is a no-op
      if (isNoopAnimation(animation)) {
        animation.complete = true;
        // we still push it onto the series for callback handling
      } else {
        start += animation.duration;
      }
      series.push(animation);
    }
    this.animations_.push(series);
    this.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_7__["default"].ANIMATING, 1);
    this.updateAnimations_();
  };

  /**
   * Determine if the view is being animated.
   * @return {boolean} The view is being animated.
   * @api
   */
  View.prototype.getAnimating = function getAnimating () {
    return this.hints_[_ViewHint_js__WEBPACK_IMPORTED_MODULE_7__["default"].ANIMATING] > 0;
  };

  /**
   * Determine if the user is interacting with the view, such as panning or zooming.
   * @return {boolean} The view is being interacted with.
   * @api
   */
  View.prototype.getInteracting = function getInteracting () {
    return this.hints_[_ViewHint_js__WEBPACK_IMPORTED_MODULE_7__["default"].INTERACTING] > 0;
  };

  /**
   * Cancel any ongoing animations.
   * @api
   */
  View.prototype.cancelAnimations = function cancelAnimations () {
    this.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_7__["default"].ANIMATING, -this.hints_[_ViewHint_js__WEBPACK_IMPORTED_MODULE_7__["default"].ANIMATING]);
    for (var i = 0, ii = this.animations_.length; i < ii; ++i) {
      var series = this.animations_[i];
      if (series[0].callback) {
        animationCallback(series[0].callback, false);
      }
    }
    this.animations_.length = 0;
  };

  /**
   * Update all animations.
   */
  View.prototype.updateAnimations_ = function updateAnimations_ () {
    if (this.updateAnimationKey_ !== undefined) {
      cancelAnimationFrame(this.updateAnimationKey_);
      this.updateAnimationKey_ = undefined;
    }
    if (!this.getAnimating()) {
      return;
    }
    var now = Date.now();
    var more = false;
    for (var i = this.animations_.length - 1; i >= 0; --i) {
      var series = this.animations_[i];
      var seriesComplete = true;
      for (var j = 0, jj = series.length; j < jj; ++j) {
        var animation = series[j];
        if (animation.complete) {
          continue;
        }
        var elapsed = now - animation.start;
        var fraction = animation.duration > 0 ? elapsed / animation.duration : 1;
        if (fraction >= 1) {
          animation.complete = true;
          fraction = 1;
        } else {
          seriesComplete = false;
        }
        var progress = animation.easing(fraction);
        if (animation.sourceCenter) {
          var x0 = animation.sourceCenter[0];
          var y0 = animation.sourceCenter[1];
          var x1 = animation.targetCenter[0];
          var y1 = animation.targetCenter[1];
          var x = x0 + progress * (x1 - x0);
          var y = y0 + progress * (y1 - y0);
          this.set(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].CENTER, [x, y]);
        }
        if (animation.sourceResolution && animation.targetResolution) {
          var resolution = progress === 1 ?
            animation.targetResolution :
            animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);
          if (animation.anchor) {
            this.set(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].CENTER,
              this.calculateCenterZoom(resolution, animation.anchor));
          }
          this.set(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].RESOLUTION, resolution);
        }
        if (animation.sourceRotation !== undefined && animation.targetRotation !== undefined) {
          var rotation = progress === 1 ?
            Object(_math_js__WEBPACK_IMPORTED_MODULE_16__["modulo"])(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI :
            animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);
          if (animation.anchor) {
            this.set(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].CENTER,
              this.calculateCenterRotate(rotation, animation.anchor));
          }
          this.set(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].ROTATION, rotation);
        }
        more = true;
        if (!animation.complete) {
          break;
        }
      }
      if (seriesComplete) {
        this.animations_[i] = null;
        this.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_7__["default"].ANIMATING, -1);
        var callback = series[0].callback;
        if (callback) {
          animationCallback(callback, true);
        }
      }
    }
    // prune completed series
    this.animations_ = this.animations_.filter(Boolean);
    if (more && this.updateAnimationKey_ === undefined) {
      this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_);
    }
  };

  /**
   * @param {number} rotation Target rotation.
   * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
   */
  View.prototype.calculateCenterRotate = function calculateCenterRotate (rotation, anchor) {
    var center;
    var currentCenter = this.getCenter();
    if (currentCenter !== undefined) {
      center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];
      Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_11__["rotate"])(center, rotation - this.getRotation());
      Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_11__["add"])(center, anchor);
    }
    return center;
  };

  /**
   * @param {number} resolution Target resolution.
   * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
   */
  View.prototype.calculateCenterZoom = function calculateCenterZoom (resolution, anchor) {
    var center;
    var currentCenter = this.getCenter();
    var currentResolution = this.getResolution();
    if (currentCenter !== undefined && currentResolution !== undefined) {
      var x = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;
      var y = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;
      center = [x, y];
    }
    return center;
  };

  /**
   * @private
   * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
   */
  View.prototype.getSizeFromViewport_ = function getSizeFromViewport_ () {
    var size = [100, 100];
    var selector = '.ol-viewport[data-view="' + Object(_util_js__WEBPACK_IMPORTED_MODULE_1__["getUid"])(this) + '"]';
    var element = document.querySelector(selector);
    if (element) {
      var metrics = getComputedStyle(element);
      size[0] = parseInt(metrics.width, 10);
      size[1] = parseInt(metrics.height, 10);
    }
    return size;
  };

  /**
   * Get the constrained center of this view.
   * @param {import("./coordinate.js").Coordinate|undefined} center Center.
   * @return {import("./coordinate.js").Coordinate|undefined} Constrained center.
   * @api
   */
  View.prototype.constrainCenter = function constrainCenter (center) {
    return this.constraints_.center(center);
  };

  /**
   * Get the constrained resolution of this view.
   * @param {number|undefined} resolution Resolution.
   * @param {number=} opt_delta Delta. Default is `0`.
   * @param {number=} opt_direction Direction. Default is `0`.
   * @return {number|undefined} Constrained resolution.
   * @api
   */
  View.prototype.constrainResolution = function constrainResolution (resolution, opt_delta, opt_direction) {
    var delta = opt_delta || 0;
    var direction = opt_direction || 0;
    return this.constraints_.resolution(resolution, delta, direction);
  };

  /**
   * Get the constrained rotation of this view.
   * @param {number|undefined} rotation Rotation.
   * @param {number=} opt_delta Delta. Default is `0`.
   * @return {number|undefined} Constrained rotation.
   * @api
   */
  View.prototype.constrainRotation = function constrainRotation (rotation, opt_delta) {
    var delta = opt_delta || 0;
    return this.constraints_.rotation(rotation, delta);
  };

  /**
   * Get the view center.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   * @observable
   * @api
   */
  View.prototype.getCenter = function getCenter () {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */ (this.get(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].CENTER))
    );
  };

  /**
   * @return {Constraints} Constraints.
   */
  View.prototype.getConstraints = function getConstraints () {
    return this.constraints_;
  };

  /**
   * @param {Array<number>=} opt_hints Destination array.
   * @return {Array<number>} Hint.
   */
  View.prototype.getHints = function getHints (opt_hints) {
    if (opt_hints !== undefined) {
      opt_hints[0] = this.hints_[0];
      opt_hints[1] = this.hints_[1];
      return opt_hints;
    } else {
      return this.hints_.slice();
    }
  };

  /**
   * Calculate the extent for the current view state and the passed size.
   * The size is the pixel dimensions of the box into which the calculated extent
   * should fit. In most cases you want to get the extent of the entire map,
   * that is `map.getSize()`.
   * @param {import("./size.js").Size=} opt_size Box pixel size. If not provided, the size of the
   * first map that uses this view will be used.
   * @return {import("./extent.js").Extent} Extent.
   * @api
   */
  View.prototype.calculateExtent = function calculateExtent (opt_size) {
    var size = opt_size || this.getSizeFromViewport_();
    var center = /** @type {!import("./coordinate.js").Coordinate} */ (this.getCenter());
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_10__["assert"])(center, 1); // The view center is not defined
    var resolution = /** @type {!number} */ (this.getResolution());
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_10__["assert"])(resolution !== undefined, 2); // The view resolution is not defined
    var rotation = /** @type {!number} */ (this.getRotation());
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_10__["assert"])(rotation !== undefined, 3); // The view rotation is not defined

    return Object(_extent_js__WEBPACK_IMPORTED_MODULE_13__["getForViewAndSize"])(center, resolution, rotation, size);
  };

  /**
   * Get the maximum resolution of the view.
   * @return {number} The maximum resolution of the view.
   * @api
   */
  View.prototype.getMaxResolution = function getMaxResolution () {
    return this.maxResolution_;
  };

  /**
   * Get the minimum resolution of the view.
   * @return {number} The minimum resolution of the view.
   * @api
   */
  View.prototype.getMinResolution = function getMinResolution () {
    return this.minResolution_;
  };

  /**
   * Get the maximum zoom level for the view.
   * @return {number} The maximum zoom level.
   * @api
   */
  View.prototype.getMaxZoom = function getMaxZoom () {
    return /** @type {number} */ (this.getZoomForResolution(this.minResolution_));
  };

  /**
   * Set a new maximum zoom level for the view.
   * @param {number} zoom The maximum zoom level.
   * @api
   */
  View.prototype.setMaxZoom = function setMaxZoom (zoom) {
    this.applyOptions_(this.getUpdatedOptions_({maxZoom: zoom}));
  };

  /**
   * Get the minimum zoom level for the view.
   * @return {number} The minimum zoom level.
   * @api
   */
  View.prototype.getMinZoom = function getMinZoom () {
    return /** @type {number} */ (this.getZoomForResolution(this.maxResolution_));
  };

  /**
   * Set a new minimum zoom level for the view.
   * @param {number} zoom The minimum zoom level.
   * @api
   */
  View.prototype.setMinZoom = function setMinZoom (zoom) {
    this.applyOptions_(this.getUpdatedOptions_({minZoom: zoom}));
  };

  /**
   * Get the view projection.
   * @return {import("./proj/Projection.js").default} The projection of the view.
   * @api
   */
  View.prototype.getProjection = function getProjection () {
    return this.projection_;
  };

  /**
   * Get the view resolution.
   * @return {number|undefined} The resolution of the view.
   * @observable
   * @api
   */
  View.prototype.getResolution = function getResolution () {
    return /** @type {number|undefined} */ (this.get(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].RESOLUTION));
  };

  /**
   * Get the resolutions for the view. This returns the array of resolutions
   * passed to the constructor of the View, or undefined if none were given.
   * @return {Array<number>|undefined} The resolutions of the view.
   * @api
   */
  View.prototype.getResolutions = function getResolutions () {
    return this.resolutions_;
  };

  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size=} opt_size Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   * @api
   */
  View.prototype.getResolutionForExtent = function getResolutionForExtent (extent, opt_size) {
    var size = opt_size || this.getSizeFromViewport_();
    var xResolution = Object(_extent_js__WEBPACK_IMPORTED_MODULE_13__["getWidth"])(extent) / size[0];
    var yResolution = Object(_extent_js__WEBPACK_IMPORTED_MODULE_13__["getHeight"])(extent) / size[1];
    return Math.max(xResolution, yResolution);
  };

  /**
   * Return a function that returns a value between 0 and 1 for a
   * resolution. Exponential scaling is assumed.
   * @param {number=} opt_power Power.
   * @return {function(number): number} Resolution for value function.
   */
  View.prototype.getResolutionForValueFunction = function getResolutionForValueFunction (opt_power) {
    var power = opt_power || 2;
    var maxResolution = this.maxResolution_;
    var minResolution = this.minResolution_;
    var max = Math.log(maxResolution / minResolution) / Math.log(power);
    return (
      /**
       * @param {number} value Value.
       * @return {number} Resolution.
       */
      function(value) {
        var resolution = maxResolution / Math.pow(power, value * max);
        return resolution;
      });
  };

  /**
   * Get the view rotation.
   * @return {number} The rotation of the view in radians.
   * @observable
   * @api
   */
  View.prototype.getRotation = function getRotation () {
    return /** @type {number} */ (this.get(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].ROTATION));
  };

  /**
   * Return a function that returns a resolution for a value between
   * 0 and 1. Exponential scaling is assumed.
   * @param {number=} opt_power Power.
   * @return {function(number): number} Value for resolution function.
   */
  View.prototype.getValueForResolutionFunction = function getValueForResolutionFunction (opt_power) {
    var power = opt_power || 2;
    var maxResolution = this.maxResolution_;
    var minResolution = this.minResolution_;
    var max = Math.log(maxResolution / minResolution) / Math.log(power);
    return (
      /**
       * @param {number} resolution Resolution.
       * @return {number} Value.
       */
      function(resolution) {
        var value = (Math.log(maxResolution / resolution) / Math.log(power)) / max;
        return value;
      });
  };

  /**
   * @param {number} pixelRatio Pixel ratio for center rounding.
   * @return {State} View state.
   */
  View.prototype.getState = function getState (pixelRatio) {
    var center = /** @type {import("./coordinate.js").Coordinate} */ (this.getCenter());
    var projection = this.getProjection();
    var resolution = /** @type {number} */ (this.getResolution());
    var pixelResolution = resolution / pixelRatio;
    var rotation = this.getRotation();
    return (
      /** @type {State} */ ({
        center: [
          Math.round(center[0] / pixelResolution) * pixelResolution,
          Math.round(center[1] / pixelResolution) * pixelResolution
        ],
        projection: projection !== undefined ? projection : null,
        resolution: resolution,
        rotation: rotation,
        zoom: this.getZoom()
      })
    );
  };

  /**
   * Get the current zoom level.  If you configured your view with a resolutions
   * array (this is rare), this method may return non-integer zoom levels (so
   * the zoom level is not safe to use as an index into a resolutions array).
   * @return {number|undefined} Zoom.
   * @api
   */
  View.prototype.getZoom = function getZoom () {
    var zoom;
    var resolution = this.getResolution();
    if (resolution !== undefined) {
      zoom = this.getZoomForResolution(resolution);
    }
    return zoom;
  };

  /**
   * Get the zoom level for a resolution.
   * @param {number} resolution The resolution.
   * @return {number|undefined} The zoom level for the provided resolution.
   * @api
   */
  View.prototype.getZoomForResolution = function getZoomForResolution (resolution) {
    var offset = this.minZoom_ || 0;
    var max, zoomFactor;
    if (this.resolutions_) {
      var nearest = Object(_array_js__WEBPACK_IMPORTED_MODULE_9__["linearFindNearest"])(this.resolutions_, resolution, 1);
      offset = nearest;
      max = this.resolutions_[nearest];
      if (nearest == this.resolutions_.length - 1) {
        zoomFactor = 2;
      } else {
        zoomFactor = max / this.resolutions_[nearest + 1];
      }
    } else {
      max = this.maxResolution_;
      zoomFactor = this.zoomFactor_;
    }
    return offset + Math.log(max / resolution) / Math.log(zoomFactor);
  };

  /**
   * Get the resolution for a zoom level.
   * @param {number} zoom Zoom level.
   * @return {number} The view resolution for the provided zoom level.
   * @api
   */
  View.prototype.getResolutionForZoom = function getResolutionForZoom (zoom) {
    return /** @type {number} */ (this.constrainResolution(
      this.maxResolution_, zoom - this.minZoom_, 0));
  };

  /**
   * Fit the given geometry or extent based on the given map size and border.
   * The size is pixel dimensions of the box to fit the extent into.
   * In most cases you will want to use the map size, that is `map.getSize()`.
   * Takes care of the map angle.
   * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
   *     extent to fit the view to.
   * @param {FitOptions=} opt_options Options.
   * @api
   */
  View.prototype.fit = function fit (geometryOrExtent, opt_options) {
    var options = opt_options || {};
    var size = options.size;
    if (!size) {
      size = this.getSizeFromViewport_();
    }
    /** @type {import("./geom/SimpleGeometry.js").default} */
    var geometry;
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_10__["assert"])(Array.isArray(geometryOrExtent) || typeof /** @type {?} */ (geometryOrExtent).getSimplifiedGeometry === 'function',
      24); // Invalid extent or geometry provided as `geometry`
    if (Array.isArray(geometryOrExtent)) {
      Object(_asserts_js__WEBPACK_IMPORTED_MODULE_10__["assert"])(!Object(_extent_js__WEBPACK_IMPORTED_MODULE_13__["isEmpty"])(geometryOrExtent),
        25); // Cannot fit empty extent provided as `geometry`
      geometry = Object(_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_15__["fromExtent"])(geometryOrExtent);
    } else if (geometryOrExtent.getType() === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_14__["default"].CIRCLE) {
      geometryOrExtent = geometryOrExtent.getExtent();
      geometry = Object(_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_15__["fromExtent"])(geometryOrExtent);
      geometry.rotate(this.getRotation(), Object(_extent_js__WEBPACK_IMPORTED_MODULE_13__["getCenter"])(geometryOrExtent));
    } else {
      geometry = geometryOrExtent;
    }

    var padding = options.padding !== undefined ? options.padding : [0, 0, 0, 0];
    var constrainResolution = options.constrainResolution !== undefined ?
      options.constrainResolution : true;
    var nearest = options.nearest !== undefined ? options.nearest : false;
    var minResolution;
    if (options.minResolution !== undefined) {
      minResolution = options.minResolution;
    } else if (options.maxZoom !== undefined) {
      minResolution = this.constrainResolution(
        this.maxResolution_, options.maxZoom - this.minZoom_, 0);
    } else {
      minResolution = 0;
    }
    var coords = geometry.getFlatCoordinates();

    // calculate rotated extent
    var rotation = this.getRotation();
    var cosAngle = Math.cos(-rotation);
    var sinAngle = Math.sin(-rotation);
    var minRotX = +Infinity;
    var minRotY = +Infinity;
    var maxRotX = -Infinity;
    var maxRotY = -Infinity;
    var stride = geometry.getStride();
    for (var i = 0, ii = coords.length; i < ii; i += stride) {
      var rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;
      var rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;
      minRotX = Math.min(minRotX, rotX);
      minRotY = Math.min(minRotY, rotY);
      maxRotX = Math.max(maxRotX, rotX);
      maxRotY = Math.max(maxRotY, rotY);
    }

    // calculate resolution
    var resolution = this.getResolutionForExtent(
      [minRotX, minRotY, maxRotX, maxRotY],
      [size[0] - padding[1] - padding[3], size[1] - padding[0] - padding[2]]);
    resolution = isNaN(resolution) ? minResolution :
      Math.max(resolution, minResolution);
    if (constrainResolution) {
      var constrainedResolution = this.constrainResolution(resolution, 0, 0);
      if (!nearest && constrainedResolution < resolution) {
        constrainedResolution = this.constrainResolution(
          constrainedResolution, -1, 0);
      }
      resolution = constrainedResolution;
    }

    // calculate center
    sinAngle = -sinAngle; // go back to original rotation
    var centerRotX = (minRotX + maxRotX) / 2;
    var centerRotY = (minRotY + maxRotY) / 2;
    centerRotX += (padding[1] - padding[3]) / 2 * resolution;
    centerRotY += (padding[0] - padding[2]) / 2 * resolution;
    var centerX = centerRotX * cosAngle - centerRotY * sinAngle;
    var centerY = centerRotY * cosAngle + centerRotX * sinAngle;
    var center = [centerX, centerY];
    var callback = options.callback ? options.callback : _functions_js__WEBPACK_IMPORTED_MODULE_2__["VOID"];

    if (options.duration !== undefined) {
      this.animate({
        resolution: resolution,
        center: center,
        duration: options.duration,
        easing: options.easing
      }, callback);
    } else {
      this.setResolution(resolution);
      this.setCenter(center);
      animationCallback(callback, true);
    }
  };

  /**
   * Center on coordinate and view position.
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   * @api
   */
  View.prototype.centerOn = function centerOn (coordinate, size, position) {
    // calculate rotated position
    var rotation = this.getRotation();
    var cosAngle = Math.cos(-rotation);
    var sinAngle = Math.sin(-rotation);
    var rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
    var rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
    var resolution = this.getResolution();
    rotX += (size[0] / 2 - position[0]) * resolution;
    rotY += (position[1] - size[1] / 2) * resolution;

    // go back to original angle
    sinAngle = -sinAngle; // go back to original rotation
    var centerX = rotX * cosAngle - rotY * sinAngle;
    var centerY = rotY * cosAngle + rotX * sinAngle;

    this.setCenter([centerX, centerY]);
  };

  /**
   * @return {boolean} Is defined.
   */
  View.prototype.isDef = function isDef () {
    return !!this.getCenter() && this.getResolution() !== undefined;
  };

  /**
   * Rotate the view around a given coordinate.
   * @param {number} rotation New rotation value for the view.
   * @param {import("./coordinate.js").Coordinate=} opt_anchor The rotation center.
   * @api
   */
  View.prototype.rotate = function rotate (rotation, opt_anchor) {
    if (opt_anchor !== undefined) {
      var center = this.calculateCenterRotate(rotation, opt_anchor);
      this.setCenter(center);
    }
    this.setRotation(rotation);
  };

  /**
   * Set the center of the current view.
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   * @observable
   * @api
   */
  View.prototype.setCenter = function setCenter (center) {
    this.set(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].CENTER, center);
    if (this.getAnimating()) {
      this.cancelAnimations();
    }
  };

  /**
   * @param {ViewHint} hint Hint.
   * @param {number} delta Delta.
   * @return {number} New value.
   */
  View.prototype.setHint = function setHint (hint, delta) {
    this.hints_[hint] += delta;
    this.changed();
    return this.hints_[hint];
  };

  /**
   * Set the resolution for this view.
   * @param {number|undefined} resolution The resolution of the view.
   * @observable
   * @api
   */
  View.prototype.setResolution = function setResolution (resolution) {
    this.set(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].RESOLUTION, resolution);
    if (this.getAnimating()) {
      this.cancelAnimations();
    }
  };

  /**
   * Set the rotation for this view.
   * @param {number} rotation The rotation of the view in radians.
   * @observable
   * @api
   */
  View.prototype.setRotation = function setRotation (rotation) {
    this.set(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].ROTATION, rotation);
    if (this.getAnimating()) {
      this.cancelAnimations();
    }
  };

  /**
   * Zoom to a specific zoom level.
   * @param {number} zoom Zoom level.
   * @api
   */
  View.prototype.setZoom = function setZoom (zoom) {
    this.setResolution(this.getResolutionForZoom(zoom));
  };

  return View;
}(_Object_js__WEBPACK_IMPORTED_MODULE_4__["default"]));


/**
 * @param {Function} callback Callback.
 * @param {*} returnValue Return value.
 */
function animationCallback(callback, returnValue) {
  setTimeout(function() {
    callback(returnValue);
  }, 0);
}


/**
 * @param {ViewOptions} options View options.
 * @return {import("./centerconstraint.js").Type} The constraint.
 */
function createCenterConstraint(options) {
  if (options.extent !== undefined) {
    return Object(_centerconstraint_js__WEBPACK_IMPORTED_MODULE_3__["createExtent"])(options.extent);
  } else {
    return _centerconstraint_js__WEBPACK_IMPORTED_MODULE_3__["none"];
  }
}


/**
 * @param {ViewOptions} options View options.
 * @return {{constraint: import("./resolutionconstraint.js").Type, maxResolution: number,
 *     minResolution: number, minZoom: number, zoomFactor: number}} The constraint.
 */
function createResolutionConstraint(options) {
  var resolutionConstraint;
  var maxResolution;
  var minResolution;

  // TODO: move these to be ol constants
  // see https://github.com/openlayers/openlayers/issues/2076
  var defaultMaxZoom = 28;
  var defaultZoomFactor = 2;

  var minZoom = options.minZoom !== undefined ?
    options.minZoom : DEFAULT_MIN_ZOOM;

  var maxZoom = options.maxZoom !== undefined ?
    options.maxZoom : defaultMaxZoom;

  var zoomFactor = options.zoomFactor !== undefined ?
    options.zoomFactor : defaultZoomFactor;

  if (options.resolutions !== undefined) {
    var resolutions = options.resolutions;
    maxResolution = resolutions[minZoom];
    minResolution = resolutions[maxZoom] !== undefined ?
      resolutions[maxZoom] : resolutions[resolutions.length - 1];
    resolutionConstraint = Object(_resolutionconstraint_js__WEBPACK_IMPORTED_MODULE_5__["createSnapToResolutions"])(
      resolutions);
  } else {
    // calculate the default min and max resolution
    var projection = Object(_proj_js__WEBPACK_IMPORTED_MODULE_18__["createProjection"])(options.projection, 'EPSG:3857');
    var extent = projection.getExtent();
    var size = !extent ?
      // use an extent that can fit the whole world if need be
      360 * _proj_js__WEBPACK_IMPORTED_MODULE_18__["METERS_PER_UNIT"][_proj_Units_js__WEBPACK_IMPORTED_MODULE_19__["default"].DEGREES] /
            projection.getMetersPerUnit() :
      Math.max(Object(_extent_js__WEBPACK_IMPORTED_MODULE_13__["getWidth"])(extent), Object(_extent_js__WEBPACK_IMPORTED_MODULE_13__["getHeight"])(extent));

    var defaultMaxResolution = size / _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_TILE_SIZE"] / Math.pow(
      defaultZoomFactor, DEFAULT_MIN_ZOOM);

    var defaultMinResolution = defaultMaxResolution / Math.pow(
      defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);

    // user provided maxResolution takes precedence
    maxResolution = options.maxResolution;
    if (maxResolution !== undefined) {
      minZoom = 0;
    } else {
      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
    }

    // user provided minResolution takes precedence
    minResolution = options.minResolution;
    if (minResolution === undefined) {
      if (options.maxZoom !== undefined) {
        if (options.maxResolution !== undefined) {
          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
        } else {
          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
        }
      } else {
        minResolution = defaultMinResolution;
      }
    }

    // given discrete zoom levels, minResolution may be different than provided
    maxZoom = minZoom + Math.floor(
      Math.log(maxResolution / minResolution) / Math.log(zoomFactor));
    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);

    resolutionConstraint = Object(_resolutionconstraint_js__WEBPACK_IMPORTED_MODULE_5__["createSnapToPower"])(
      zoomFactor, maxResolution, maxZoom - minZoom);
  }
  return {constraint: resolutionConstraint, maxResolution: maxResolution,
    minResolution: minResolution, minZoom: minZoom, zoomFactor: zoomFactor};
}


/**
 * @param {ViewOptions} options View options.
 * @return {import("./rotationconstraint.js").Type} Rotation constraint.
 */
function createRotationConstraint(options) {
  var enableRotation = options.enableRotation !== undefined ?
    options.enableRotation : true;
  if (enableRotation) {
    var constrainRotation = options.constrainRotation;
    if (constrainRotation === undefined || constrainRotation === true) {
      return Object(_rotationconstraint_js__WEBPACK_IMPORTED_MODULE_6__["createSnapToZero"])();
    } else if (constrainRotation === false) {
      return _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_6__["none"];
    } else if (typeof constrainRotation === 'number') {
      return Object(_rotationconstraint_js__WEBPACK_IMPORTED_MODULE_6__["createSnapToN"])(constrainRotation);
    } else {
      return _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_6__["none"];
    }
  } else {
    return _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_6__["disable"];
  }
}


/**
 * Determine if an animation involves no view change.
 * @param {Animation} animation The animation.
 * @return {boolean} The animation involves no view change.
 */
function isNoopAnimation(animation) {
  if (animation.sourceCenter && animation.targetCenter) {
    if (!Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_11__["equals"])(animation.sourceCenter, animation.targetCenter)) {
      return false;
    }
  }
  if (animation.sourceResolution !== animation.targetResolution) {
    return false;
  }
  if (animation.sourceRotation !== animation.targetRotation) {
    return false;
  }
  return true;
}

/* harmony default export */ __webpack_exports__["default"] = (View);

//# sourceMappingURL=View.js.map

/***/ }),

/***/ "./node_modules/ol/ViewHint.js":
/*!*************************************!*\
  !*** ./node_modules/ol/ViewHint.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/ViewHint
 */

/**
 * @enum {number}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  ANIMATING: 0,
  INTERACTING: 1
});

//# sourceMappingURL=ViewHint.js.map

/***/ }),

/***/ "./node_modules/ol/ViewProperty.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/ViewProperty.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/ViewProperty
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  CENTER: 'center',
  RESOLUTION: 'resolution',
  ROTATION: 'rotation'
});

//# sourceMappingURL=ViewProperty.js.map

/***/ }),

/***/ "./node_modules/ol/array.js":
/*!**********************************!*\
  !*** ./node_modules/ol/array.js ***!
  \**********************************/
/*! exports provided: binarySearch, numberSafeCompareFunction, includes, linearFindNearest, reverseSubArray, extend, remove, find, equals, stableSort, findIndex, isSorted */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "binarySearch", function() { return binarySearch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "numberSafeCompareFunction", function() { return numberSafeCompareFunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "includes", function() { return includes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearFindNearest", function() { return linearFindNearest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverseSubArray", function() { return reverseSubArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "remove", function() { return remove; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "find", function() { return find; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stableSort", function() { return stableSort; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findIndex", function() { return findIndex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSorted", function() { return isSorted; });
/**
 * @module ol/array
 */


/**
 * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.
 * https://github.com/darkskyapp/binary-search
 *
 * @param {Array<*>} haystack Items to search through.
 * @param {*} needle The item to look for.
 * @param {Function=} opt_comparator Comparator function.
 * @return {number} The index of the item if found, -1 if not.
 */
function binarySearch(haystack, needle, opt_comparator) {
  var mid, cmp;
  var comparator = opt_comparator || numberSafeCompareFunction;
  var low = 0;
  var high = haystack.length;
  var found = false;

  while (low < high) {
    /* Note that "(low + high) >>> 1" may overflow, and results in a typecast
     * to double (which gives the wrong results). */
    mid = low + (high - low >> 1);
    cmp = +comparator(haystack[mid], needle);

    if (cmp < 0.0) { /* Too low. */
      low = mid + 1;

    } else { /* Key found or too high */
      high = mid;
      found = !cmp;
    }
  }

  /* Key not found. */
  return found ? low : ~low;
}


/**
 * Compare function for array sort that is safe for numbers.
 * @param {*} a The first object to be compared.
 * @param {*} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is less than, equal to, or greater than the second.
 */
function numberSafeCompareFunction(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
}


/**
 * Whether the array contains the given object.
 * @param {Array<*>} arr The array to test for the presence of the element.
 * @param {*} obj The object for which to test.
 * @return {boolean} The object is in the array.
 */
function includes(arr, obj) {
  return arr.indexOf(obj) >= 0;
}


/**
 * @param {Array<number>} arr Array.
 * @param {number} target Target.
 * @param {number} direction 0 means return the nearest, > 0
 *    means return the largest nearest, < 0 means return the
 *    smallest nearest.
 * @return {number} Index.
 */
function linearFindNearest(arr, target, direction) {
  var n = arr.length;
  if (arr[0] <= target) {
    return 0;
  } else if (target <= arr[n - 1]) {
    return n - 1;
  } else {
    var i;
    if (direction > 0) {
      for (i = 1; i < n; ++i) {
        if (arr[i] < target) {
          return i - 1;
        }
      }
    } else if (direction < 0) {
      for (i = 1; i < n; ++i) {
        if (arr[i] <= target) {
          return i;
        }
      }
    } else {
      for (i = 1; i < n; ++i) {
        if (arr[i] == target) {
          return i;
        } else if (arr[i] < target) {
          if (arr[i - 1] - target < target - arr[i]) {
            return i - 1;
          } else {
            return i;
          }
        }
      }
    }
    return n - 1;
  }
}


/**
 * @param {Array<*>} arr Array.
 * @param {number} begin Begin index.
 * @param {number} end End index.
 */
function reverseSubArray(arr, begin, end) {
  while (begin < end) {
    var tmp = arr[begin];
    arr[begin] = arr[end];
    arr[end] = tmp;
    ++begin;
    --end;
  }
}


/**
 * @param {Array<VALUE>} arr The array to modify.
 * @param {!Array<VALUE>|VALUE} data The elements or arrays of elements to add to arr.
 * @template VALUE
 */
function extend(arr, data) {
  var extension = Array.isArray(data) ? data : [data];
  var length = extension.length;
  for (var i = 0; i < length; i++) {
    arr[arr.length] = extension[i];
  }
}


/**
 * @param {Array<VALUE>} arr The array to modify.
 * @param {VALUE} obj The element to remove.
 * @template VALUE
 * @return {boolean} If the element was removed.
 */
function remove(arr, obj) {
  var i = arr.indexOf(obj);
  var found = i > -1;
  if (found) {
    arr.splice(i, 1);
  }
  return found;
}


/**
 * @param {Array<VALUE>} arr The array to search in.
 * @param {function(VALUE, number, ?) : boolean} func The function to compare.
 * @template VALUE
 * @return {VALUE|null} The element found or null.
 */
function find(arr, func) {
  var length = arr.length >>> 0;
  var value;

  for (var i = 0; i < length; i++) {
    value = arr[i];
    if (func(value, i, arr)) {
      return value;
    }
  }
  return null;
}


/**
 * @param {Array|Uint8ClampedArray} arr1 The first array to compare.
 * @param {Array|Uint8ClampedArray} arr2 The second array to compare.
 * @return {boolean} Whether the two arrays are equal.
 */
function equals(arr1, arr2) {
  var len1 = arr1.length;
  if (len1 !== arr2.length) {
    return false;
  }
  for (var i = 0; i < len1; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
}


/**
 * Sort the passed array such that the relative order of equal elements is preverved.
 * See https://en.wikipedia.org/wiki/Sorting_algorithm#Stability for details.
 * @param {Array<*>} arr The array to sort (modifies original).
 * @param {!function(*, *): number} compareFnc Comparison function.
 * @api
 */
function stableSort(arr, compareFnc) {
  var length = arr.length;
  var tmp = Array(arr.length);
  var i;
  for (i = 0; i < length; i++) {
    tmp[i] = {index: i, value: arr[i]};
  }
  tmp.sort(function(a, b) {
    return compareFnc(a.value, b.value) || a.index - b.index;
  });
  for (i = 0; i < arr.length; i++) {
    arr[i] = tmp[i].value;
  }
}


/**
 * @param {Array<*>} arr The array to search in.
 * @param {Function} func Comparison function.
 * @return {number} Return index.
 */
function findIndex(arr, func) {
  var index;
  var found = !arr.every(function(el, idx) {
    index = idx;
    return !func(el, idx, arr);
  });
  return found ? index : -1;
}


/**
 * @param {Array<*>} arr The array to test.
 * @param {Function=} opt_func Comparison function.
 * @param {boolean=} opt_strict Strictly sorted (default false).
 * @return {boolean} Return index.
 */
function isSorted(arr, opt_func, opt_strict) {
  var compare = opt_func || numberSafeCompareFunction;
  return arr.every(function(currentVal, index) {
    if (index === 0) {
      return true;
    }
    var res = compare(arr[index - 1], currentVal);
    return !(res > 0 || opt_strict && res === 0);
  });
}

//# sourceMappingURL=array.js.map

/***/ }),

/***/ "./node_modules/ol/asserts.js":
/*!************************************!*\
  !*** ./node_modules/ol/asserts.js ***!
  \************************************/
/*! exports provided: assert */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return assert; });
/* harmony import */ var _AssertionError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AssertionError.js */ "./node_modules/ol/AssertionError.js");
/**
 * @module ol/asserts
 */


/**
 * @param {*} assertion Assertion we expected to be truthy.
 * @param {number} errorCode Error code.
 */
function assert(assertion, errorCode) {
  if (!assertion) {
    throw new _AssertionError_js__WEBPACK_IMPORTED_MODULE_0__["default"](errorCode);
  }
}

//# sourceMappingURL=asserts.js.map

/***/ }),

/***/ "./node_modules/ol/centerconstraint.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/centerconstraint.js ***!
  \*********************************************/
/*! exports provided: createExtent, none */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createExtent", function() { return createExtent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "none", function() { return none; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/centerconstraint
 */



/**
 * @typedef {function((import("./coordinate.js").Coordinate|undefined)): (import("./coordinate.js").Coordinate|undefined)} Type
 */


/**
 * @param {import("./extent.js").Extent} extent Extent.
 * @return {Type} The constraint.
 */
function createExtent(extent) {
  return (
    /**
     * @param {import("./coordinate.js").Coordinate=} center Center.
     * @return {import("./coordinate.js").Coordinate|undefined} Center.
     */
    function(center) {
      if (center) {
        return [
          Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["clamp"])(center[0], extent[0], extent[2]),
          Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["clamp"])(center[1], extent[1], extent[3])
        ];
      } else {
        return undefined;
      }
    }
  );
}


/**
 * @param {import("./coordinate.js").Coordinate=} center Center.
 * @return {import("./coordinate.js").Coordinate|undefined} Center.
 */
function none(center) {
  return center;
}

//# sourceMappingURL=centerconstraint.js.map

/***/ }),

/***/ "./node_modules/ol/color.js":
/*!**********************************!*\
  !*** ./node_modules/ol/color.js ***!
  \**********************************/
/*! exports provided: asString, fromString, asArray, normalize, toString */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asString", function() { return asString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromString", function() { return fromString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asArray", function() { return asArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toString", function() { return toString; });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/color
 */




/**
 * A color represented as a short array [red, green, blue, alpha].
 * red, green, and blue should be integers in the range 0..255 inclusive.
 * alpha should be a float in the range 0..1 inclusive. If no alpha value is
 * given then `1` will be used.
 * @typedef {Array<number>} Color
 * @api
 */


/**
 * This RegExp matches # followed by 3, 4, 6, or 8 hex digits.
 * @const
 * @type {RegExp}
 * @private
 */
var HEX_COLOR_RE_ = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i;


/**
 * Regular expression for matching potential named color style strings.
 * @const
 * @type {RegExp}
 * @private
 */
var NAMED_COLOR_RE_ = /^([a-z]*)$/i;


/**
 * Return the color as an rgba string.
 * @param {Color|string} color Color.
 * @return {string} Rgba string.
 * @api
 */
function asString(color) {
  if (typeof color === 'string') {
    return color;
  } else {
    return toString(color);
  }
}

/**
 * Return named color as an rgba string.
 * @param {string} color Named color.
 * @return {string} Rgb string.
 */
function fromNamed(color) {
  var el = document.createElement('div');
  el.style.color = color;
  if (el.style.color !== '') {
    document.body.appendChild(el);
    var rgb = getComputedStyle(el).color;
    document.body.removeChild(el);
    return rgb;
  } else {
    return '';
  }
}


/**
 * @param {string} s String.
 * @return {Color} Color.
 */
var fromString = (
  function() {

    // We maintain a small cache of parsed strings.  To provide cheap LRU-like
    // semantics, whenever the cache grows too large we simply delete an
    // arbitrary 25% of the entries.

    /**
     * @const
     * @type {number}
     */
    var MAX_CACHE_SIZE = 1024;

    /**
     * @type {Object<string, Color>}
     */
    var cache = {};

    /**
     * @type {number}
     */
    var cacheSize = 0;

    return (
      /**
       * @param {string} s String.
       * @return {Color} Color.
       */
      function(s) {
        var color;
        if (cache.hasOwnProperty(s)) {
          color = cache[s];
        } else {
          if (cacheSize >= MAX_CACHE_SIZE) {
            var i = 0;
            for (var key in cache) {
              if ((i++ & 3) === 0) {
                delete cache[key];
                --cacheSize;
              }
            }
          }
          color = fromStringInternal_(s);
          cache[s] = color;
          ++cacheSize;
        }
        return color;
      }
    );

  })();

/**
 * Return the color as an array. This function maintains a cache of calculated
 * arrays which means the result should not be modified.
 * @param {Color|string} color Color.
 * @return {Color} Color.
 * @api
 */
function asArray(color) {
  if (Array.isArray(color)) {
    return color;
  } else {
    return fromString(color);
  }
}

/**
 * @param {string} s String.
 * @private
 * @return {Color} Color.
 */
function fromStringInternal_(s) {
  var r, g, b, a, color;

  if (NAMED_COLOR_RE_.exec(s)) {
    s = fromNamed(s);
  }

  if (HEX_COLOR_RE_.exec(s)) { // hex
    var n = s.length - 1; // number of hex digits
    var d; // number of digits per channel
    if (n <= 4) {
      d = 1;
    } else {
      d = 2;
    }
    var hasAlpha = n === 4 || n === 8;
    r = parseInt(s.substr(1 + 0 * d, d), 16);
    g = parseInt(s.substr(1 + 1 * d, d), 16);
    b = parseInt(s.substr(1 + 2 * d, d), 16);
    if (hasAlpha) {
      a = parseInt(s.substr(1 + 3 * d, d), 16);
    } else {
      a = 255;
    }
    if (d == 1) {
      r = (r << 4) + r;
      g = (g << 4) + g;
      b = (b << 4) + b;
      if (hasAlpha) {
        a = (a << 4) + a;
      }
    }
    color = [r, g, b, a / 255];
  } else if (s.indexOf('rgba(') == 0) { // rgba()
    color = s.slice(5, -1).split(',').map(Number);
    normalize(color);
  } else if (s.indexOf('rgb(') == 0) { // rgb()
    color = s.slice(4, -1).split(',').map(Number);
    color.push(1);
    normalize(color);
  } else {
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(false, 14); // Invalid color
  }
  return color;
}


/**
 * TODO this function is only used in the test, we probably shouldn't export it
 * @param {Color} color Color.
 * @return {Color} Clamped color.
 */
function normalize(color) {
  color[0] = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["clamp"])((color[0] + 0.5) | 0, 0, 255);
  color[1] = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["clamp"])((color[1] + 0.5) | 0, 0, 255);
  color[2] = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["clamp"])((color[2] + 0.5) | 0, 0, 255);
  color[3] = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["clamp"])(color[3], 0, 1);
  return color;
}


/**
 * @param {Color} color Color.
 * @return {string} String.
 */
function toString(color) {
  var r = color[0];
  if (r != (r | 0)) {
    r = (r + 0.5) | 0;
  }
  var g = color[1];
  if (g != (g | 0)) {
    g = (g + 0.5) | 0;
  }
  var b = color[2];
  if (b != (b | 0)) {
    b = (b + 0.5) | 0;
  }
  var a = color[3] === undefined ? 1 : color[3];
  return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
}

//# sourceMappingURL=color.js.map

/***/ }),

/***/ "./node_modules/ol/colorlike.js":
/*!**************************************!*\
  !*** ./node_modules/ol/colorlike.js ***!
  \**************************************/
/*! exports provided: asColorLike */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asColorLike", function() { return asColorLike; });
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/ol/color.js");
/**
 * @module ol/colorlike
 */



/**
 * A type accepted by CanvasRenderingContext2D.fillStyle
 * or CanvasRenderingContext2D.strokeStyle.
 * Represents a color, pattern, or gradient. The origin for patterns and
 * gradients as fill style is an increment of 512 css pixels from map coordinate
 * `[0, 0]`. For seamless repeat patterns, width and height of the pattern image
 * must be a factor of two (2, 4, 8, ..., 512).
 *
 * @typedef {string|CanvasPattern|CanvasGradient} ColorLike
 * @api
 */


/**
 * @param {import("./color.js").Color|ColorLike} color Color.
 * @return {ColorLike} The color as an {@link ol/colorlike~ColorLike}.
 * @api
 */
function asColorLike(color) {
  if (Array.isArray(color)) {
    return Object(_color_js__WEBPACK_IMPORTED_MODULE_0__["toString"])(color);
  } else {
    return color;
  }
}

//# sourceMappingURL=colorlike.js.map

/***/ }),

/***/ "./node_modules/ol/control/Attribution.js":
/*!************************************************!*\
  !*** ./node_modules/ol/control/Attribution.js ***!
  \************************************************/
/*! exports provided: render, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _Control_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Control.js */ "./node_modules/ol/control/Control.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../css.js */ "./node_modules/ol/css.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _layer_Layer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../layer/Layer.js */ "./node_modules/ol/layer/Layer.js");
/**
 * @module ol/control/Attribution
 */









/**
 * @typedef {Object} Options
 * @property {string} [className='ol-attribution'] CSS class name.
 * @property {HTMLElement|string} [target] Specify a target if you
 * want the control to be rendered outside of the map's
 * viewport.
 * @property {boolean} [collapsible] Specify if attributions can
 * be collapsed. If not specified, sources control this behavior with their
 * `attributionsCollapsible` setting.
 * @property {boolean} [collapsed=true] Specify if attributions should
 * be collapsed at startup.
 * @property {string} [tipLabel='Attributions'] Text label to use for the button tip.
 * @property {string} [label='i'] Text label to use for the
 * collapsed attributions button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string|HTMLElement} [collapseLabel='»'] Text label to use
 * for the expanded attributions button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {function(import("../MapEvent.js").default)} [render] Function called when
 * the control should be re-rendered. This is called in a `requestAnimationFrame`
 * callback.
 */


/**
 * @classdesc
 * Control to show all the attributions associated with the layer sources
 * in the map. This control is one of the default controls included in maps.
 * By default it will show in the bottom right portion of the map, but this can
 * be changed by using a css selector for `.ol-attribution`.
 *
 * @api
 */
var Attribution = /*@__PURE__*/(function (Control) {
  function Attribution(opt_options) {

    var options = opt_options ? opt_options : {};

    Control.call(this, {
      element: document.createElement('div'),
      render: options.render || render,
      target: options.target
    });

    /**
     * @private
     * @type {HTMLElement}
     */
    this.ulElement_ = document.createElement('ul');

    /**
     * @private
     * @type {boolean}
     */
    this.collapsed_ = options.collapsed !== undefined ? options.collapsed : true;

    /**
     * @private
     * @type {boolean}
     */
    this.overrideCollapsible_ = options.collapsible !== undefined;

    /**
     * @private
     * @type {boolean}
     */
    this.collapsible_ = options.collapsible !== undefined ?
      options.collapsible : true;

    if (!this.collapsible_) {
      this.collapsed_ = false;
    }

    var className = options.className !== undefined ? options.className : 'ol-attribution';

    var tipLabel = options.tipLabel !== undefined ? options.tipLabel : 'Attributions';

    var collapseLabel = options.collapseLabel !== undefined ? options.collapseLabel : '\u00BB';

    if (typeof collapseLabel === 'string') {
      /**
       * @private
       * @type {HTMLElement}
       */
      this.collapseLabel_ = document.createElement('span');
      this.collapseLabel_.textContent = collapseLabel;
    } else {
      this.collapseLabel_ = collapseLabel;
    }

    var label = options.label !== undefined ? options.label : 'i';

    if (typeof label === 'string') {
      /**
       * @private
       * @type {HTMLElement}
       */
      this.label_ = document.createElement('span');
      this.label_.textContent = label;
    } else {
      this.label_ = label;
    }


    var activeLabel = (this.collapsible_ && !this.collapsed_) ?
      this.collapseLabel_ : this.label_;
    var button = document.createElement('button');
    button.setAttribute('type', 'button');
    button.title = tipLabel;
    button.appendChild(activeLabel);

    Object(_events_js__WEBPACK_IMPORTED_MODULE_4__["listen"])(button, _events_EventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].CLICK, this.handleClick_, this);

    var cssClasses = className + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_2__["CLASS_UNSELECTABLE"] + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_2__["CLASS_CONTROL"] +
        (this.collapsed_ && this.collapsible_ ? ' ' + _css_js__WEBPACK_IMPORTED_MODULE_2__["CLASS_COLLAPSED"] : '') +
        (this.collapsible_ ? '' : ' ol-uncollapsible');
    var element = this.element;
    element.className = cssClasses;
    element.appendChild(this.ulElement_);
    element.appendChild(button);

    /**
     * A list of currently rendered resolutions.
     * @type {Array<string>}
     * @private
     */
    this.renderedAttributions_ = [];

    /**
     * @private
     * @type {boolean}
     */
    this.renderedVisible_ = true;

  }

  if ( Control ) Attribution.__proto__ = Control;
  Attribution.prototype = Object.create( Control && Control.prototype );
  Attribution.prototype.constructor = Attribution;

  /**
   * Collect a list of visible attributions and set the collapsible state.
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @return {Array<string>} Attributions.
   * @private
   */
  Attribution.prototype.collectSourceAttributions_ = function collectSourceAttributions_ (frameState) {
    /**
     * Used to determine if an attribution already exists.
     * @type {!Object<string, boolean>}
     */
    var lookup = {};

    /**
     * A list of visible attributions.
     * @type {Array<string>}
     */
    var visibleAttributions = [];

    var layerStatesArray = frameState.layerStatesArray;
    var resolution = frameState.viewState.resolution;
    for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      var layerState = layerStatesArray[i];
      if (!Object(_layer_Layer_js__WEBPACK_IMPORTED_MODULE_6__["visibleAtResolution"])(layerState, resolution)) {
        continue;
      }

      var source = /** @type {import("../layer/Layer.js").default} */ (layerState.layer).getSource();
      if (!source) {
        continue;
      }

      var attributionGetter = source.getAttributions();
      if (!attributionGetter) {
        continue;
      }

      var attributions = attributionGetter(frameState);
      if (!attributions) {
        continue;
      }

      if (!this.overrideCollapsible_ && source.getAttributionsCollapsible() === false) {
        this.setCollapsible(false);
      }

      if (Array.isArray(attributions)) {
        for (var j = 0, jj = attributions.length; j < jj; ++j) {
          if (!(attributions[j] in lookup)) {
            visibleAttributions.push(attributions[j]);
            lookup[attributions[j]] = true;
          }
        }
      } else {
        if (!(attributions in lookup)) {
          visibleAttributions.push(attributions);
          lookup[attributions] = true;
        }
      }
    }
    return visibleAttributions;
  };

  /**
   * @private
   * @param {?import("../PluggableMap.js").FrameState} frameState Frame state.
   */
  Attribution.prototype.updateElement_ = function updateElement_ (frameState) {
    if (!frameState) {
      if (this.renderedVisible_) {
        this.element.style.display = 'none';
        this.renderedVisible_ = false;
      }
      return;
    }

    var attributions = this.collectSourceAttributions_(frameState);

    var visible = attributions.length > 0;
    if (this.renderedVisible_ != visible) {
      this.element.style.display = visible ? '' : 'none';
      this.renderedVisible_ = visible;
    }

    if (Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["equals"])(attributions, this.renderedAttributions_)) {
      return;
    }

    Object(_dom_js__WEBPACK_IMPORTED_MODULE_3__["removeChildren"])(this.ulElement_);

    // append the attributions
    for (var i = 0, ii = attributions.length; i < ii; ++i) {
      var element = document.createElement('li');
      element.innerHTML = attributions[i];
      this.ulElement_.appendChild(element);
    }

    this.renderedAttributions_ = attributions;
  };

  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  Attribution.prototype.handleClick_ = function handleClick_ (event) {
    event.preventDefault();
    this.handleToggle_();
  };

  /**
   * @private
   */
  Attribution.prototype.handleToggle_ = function handleToggle_ () {
    this.element.classList.toggle(_css_js__WEBPACK_IMPORTED_MODULE_2__["CLASS_COLLAPSED"]);
    if (this.collapsed_) {
      Object(_dom_js__WEBPACK_IMPORTED_MODULE_3__["replaceNode"])(this.collapseLabel_, this.label_);
    } else {
      Object(_dom_js__WEBPACK_IMPORTED_MODULE_3__["replaceNode"])(this.label_, this.collapseLabel_);
    }
    this.collapsed_ = !this.collapsed_;
  };

  /**
   * Return `true` if the attribution is collapsible, `false` otherwise.
   * @return {boolean} True if the widget is collapsible.
   * @api
   */
  Attribution.prototype.getCollapsible = function getCollapsible () {
    return this.collapsible_;
  };

  /**
   * Set whether the attribution should be collapsible.
   * @param {boolean} collapsible True if the widget is collapsible.
   * @api
   */
  Attribution.prototype.setCollapsible = function setCollapsible (collapsible) {
    if (this.collapsible_ === collapsible) {
      return;
    }
    this.collapsible_ = collapsible;
    this.element.classList.toggle('ol-uncollapsible');
    if (!collapsible && this.collapsed_) {
      this.handleToggle_();
    }
  };

  /**
   * Collapse or expand the attribution according to the passed parameter. Will
   * not do anything if the attribution isn't collapsible or if the current
   * collapsed state is already the one requested.
   * @param {boolean} collapsed True if the widget is collapsed.
   * @api
   */
  Attribution.prototype.setCollapsed = function setCollapsed (collapsed) {
    if (!this.collapsible_ || this.collapsed_ === collapsed) {
      return;
    }
    this.handleToggle_();
  };

  /**
   * Return `true` when the attribution is currently collapsed or `false`
   * otherwise.
   * @return {boolean} True if the widget is collapsed.
   * @api
   */
  Attribution.prototype.getCollapsed = function getCollapsed () {
    return this.collapsed_;
  };

  return Attribution;
}(_Control_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/**
 * Update the attribution element.
 * @param {import("../MapEvent.js").default} mapEvent Map event.
 * @this {Attribution}
 * @api
 */
function render(mapEvent) {
  this.updateElement_(mapEvent.frameState);
}


/* harmony default export */ __webpack_exports__["default"] = (Attribution);

//# sourceMappingURL=Attribution.js.map

/***/ }),

/***/ "./node_modules/ol/control/Control.js":
/*!********************************************!*\
  !*** ./node_modules/ol/control/Control.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _MapEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../MapEventType.js */ "./node_modules/ol/MapEventType.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/**
 * @module ol/control/Control
 */







/**
 * @typedef {Object} Options
 * @property {HTMLElement} [element] The element is the control's
 * container element. This only needs to be specified if you're developing
 * a custom control.
 * @property {function(import("../MapEvent.js").default)} [render] Function called when
 * the control should be re-rendered. This is called in a `requestAnimationFrame`
 * callback.
 * @property {HTMLElement|string} [target] Specify a target if you want
 * the control to be rendered outside of the map's viewport.
 */


/**
 * @classdesc
 * A control is a visible widget with a DOM element in a fixed position on the
 * screen. They can involve user input (buttons), or be informational only;
 * the position is determined using CSS. By default these are placed in the
 * container with CSS class name `ol-overlaycontainer-stopevent`, but can use
 * any outside DOM element.
 *
 * This is the base class for controls. You can use it for simple custom
 * controls by creating the element with listeners, creating an instance:
 * ```js
 * var myControl = new Control({element: myElement});
 * ```
 * and then adding this to the map.
 *
 * The main advantage of having this as a control rather than a simple separate
 * DOM element is that preventing propagation is handled for you. Controls
 * will also be objects in a {@link module:ol/Collection~Collection}, so you can use their methods.
 *
 * You can also extend this base for your own control class. See
 * examples/custom-controls for an example of how to do this.
 *
 * @api
 */
var Control = /*@__PURE__*/(function (BaseObject) {
  function Control(options) {

    BaseObject.call(this);

    /**
     * @protected
     * @type {HTMLElement}
     */
    this.element = options.element ? options.element : null;

    /**
     * @private
     * @type {HTMLElement}
     */
    this.target_ = null;

    /**
     * @private
     * @type {import("../PluggableMap.js").default}
     */
    this.map_ = null;

    /**
     * @protected
     * @type {!Array<import("../events.js").EventsKey>}
     */
    this.listenerKeys = [];

    /**
     * @type {function(import("../MapEvent.js").default)}
     */
    this.render = options.render ? options.render : _functions_js__WEBPACK_IMPORTED_MODULE_0__["VOID"];

    if (options.target) {
      this.setTarget(options.target);
    }

  }

  if ( BaseObject ) Control.__proto__ = BaseObject;
  Control.prototype = Object.create( BaseObject && BaseObject.prototype );
  Control.prototype.constructor = Control;

  /**
   * @inheritDoc
   */
  Control.prototype.disposeInternal = function disposeInternal () {
    Object(_dom_js__WEBPACK_IMPORTED_MODULE_3__["removeNode"])(this.element);
    BaseObject.prototype.disposeInternal.call(this);
  };

  /**
   * Get the map associated with this control.
   * @return {import("../PluggableMap.js").default} Map.
   * @api
   */
  Control.prototype.getMap = function getMap () {
    return this.map_;
  };

  /**
   * Remove the control from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../PluggableMap.js").default} map Map.
   * @api
   */
  Control.prototype.setMap = function setMap (map) {
    if (this.map_) {
      Object(_dom_js__WEBPACK_IMPORTED_MODULE_3__["removeNode"])(this.element);
    }
    for (var i = 0, ii = this.listenerKeys.length; i < ii; ++i) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_4__["unlistenByKey"])(this.listenerKeys[i]);
    }
    this.listenerKeys.length = 0;
    this.map_ = map;
    if (this.map_) {
      var target = this.target_ ?
        this.target_ : map.getOverlayContainerStopEvent();
      target.appendChild(this.element);
      if (this.render !== _functions_js__WEBPACK_IMPORTED_MODULE_0__["VOID"]) {
        this.listenerKeys.push(Object(_events_js__WEBPACK_IMPORTED_MODULE_4__["listen"])(map,
          _MapEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POSTRENDER, this.render, this));
      }
      map.render();
    }
  };

  /**
   * This function is used to set a target element for the control. It has no
   * effect if it is called after the control has been added to the map (i.e.
   * after `setMap` is called on the control). If no `target` is set in the
   * options passed to the control constructor and if `setTarget` is not called
   * then the control is added to the map's overlay container.
   * @param {HTMLElement|string} target Target.
   * @api
   */
  Control.prototype.setTarget = function setTarget (target) {
    this.target_ = typeof target === 'string' ?
      document.getElementById(target) :
      target;
  };

  return Control;
}(_Object_js__WEBPACK_IMPORTED_MODULE_2__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (Control);

//# sourceMappingURL=Control.js.map

/***/ }),

/***/ "./node_modules/ol/control/Rotate.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/control/Rotate.js ***!
  \*******************************************/
/*! exports provided: render, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony import */ var _Control_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Control.js */ "./node_modules/ol/control/Control.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../css.js */ "./node_modules/ol/css.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../easing.js */ "./node_modules/ol/easing.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/**
 * @module ol/control/Rotate
 */







/**
 * @typedef {Object} Options
 * @property {string} [className='ol-rotate'] CSS class name.
 * @property {string|HTMLElement} [label='⇧'] Text label to use for the rotate button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [tipLabel='Reset rotation'] Text label to use for the rotate tip.
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {boolean} [autoHide=true] Hide the control when rotation is 0.
 * @property {function(import("../MapEvent.js").default)} [render] Function called when the control should
 * be re-rendered. This is called in a `requestAnimationFrame` callback.
 * @property {function()} [resetNorth] Function called when the control is clicked.
 * This will override the default `resetNorth`.
 * @property {HTMLElement|string} [target] Specify a target if you want the control to be
 * rendered outside of the map's viewport.
 */


/**
 * @classdesc
 * A button control to reset rotation to 0.
 * To style this control use css selector `.ol-rotate`. A `.ol-hidden` css
 * selector is added to the button when the rotation is 0.
 *
 * @api
 */
var Rotate = /*@__PURE__*/(function (Control) {
  function Rotate(opt_options) {

    var options = opt_options ? opt_options : {};

    Control.call(this, {
      element: document.createElement('div'),
      render: options.render || render,
      target: options.target
    });

    var className = options.className !== undefined ? options.className : 'ol-rotate';

    var label = options.label !== undefined ? options.label : '\u21E7';

    /**
     * @type {HTMLElement}
     * @private
     */
    this.label_ = null;

    if (typeof label === 'string') {
      this.label_ = document.createElement('span');
      this.label_.className = 'ol-compass';
      this.label_.textContent = label;
    } else {
      this.label_ = label;
      this.label_.classList.add('ol-compass');
    }

    var tipLabel = options.tipLabel ? options.tipLabel : 'Reset rotation';

    var button = document.createElement('button');
    button.className = className + '-reset';
    button.setAttribute('type', 'button');
    button.title = tipLabel;
    button.appendChild(this.label_);

    Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(button, _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].CLICK, this.handleClick_, this);

    var cssClasses = className + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_1__["CLASS_UNSELECTABLE"] + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_1__["CLASS_CONTROL"];
    var element = this.element;
    element.className = cssClasses;
    element.appendChild(button);

    this.callResetNorth_ = options.resetNorth ? options.resetNorth : undefined;

    /**
     * @type {number}
     * @private
     */
    this.duration_ = options.duration !== undefined ? options.duration : 250;

    /**
     * @type {boolean}
     * @private
     */
    this.autoHide_ = options.autoHide !== undefined ? options.autoHide : true;

    /**
     * @private
     * @type {number|undefined}
     */
    this.rotation_ = undefined;

    if (this.autoHide_) {
      this.element.classList.add(_css_js__WEBPACK_IMPORTED_MODULE_1__["CLASS_HIDDEN"]);
    }

  }

  if ( Control ) Rotate.__proto__ = Control;
  Rotate.prototype = Object.create( Control && Control.prototype );
  Rotate.prototype.constructor = Rotate;

  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  Rotate.prototype.handleClick_ = function handleClick_ (event) {
    event.preventDefault();
    if (this.callResetNorth_ !== undefined) {
      this.callResetNorth_();
    } else {
      this.resetNorth_();
    }
  };

  /**
   * @private
   */
  Rotate.prototype.resetNorth_ = function resetNorth_ () {
    var map = this.getMap();
    var view = map.getView();
    if (!view) {
      // the map does not have a view, so we can't act
      // upon it
      return;
    }
    if (view.getRotation() !== undefined) {
      if (this.duration_ > 0) {
        view.animate({
          rotation: 0,
          duration: this.duration_,
          easing: _easing_js__WEBPACK_IMPORTED_MODULE_2__["easeOut"]
        });
      } else {
        view.setRotation(0);
      }
    }
  };

  return Rotate;
}(_Control_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/**
 * Update the rotate control element.
 * @param {import("../MapEvent.js").default} mapEvent Map event.
 * @this {Rotate}
 * @api
 */
function render(mapEvent) {
  var frameState = mapEvent.frameState;
  if (!frameState) {
    return;
  }
  var rotation = frameState.viewState.rotation;
  if (rotation != this.rotation_) {
    var transform = 'rotate(' + rotation + 'rad)';
    if (this.autoHide_) {
      var contains = this.element.classList.contains(_css_js__WEBPACK_IMPORTED_MODULE_1__["CLASS_HIDDEN"]);
      if (!contains && rotation === 0) {
        this.element.classList.add(_css_js__WEBPACK_IMPORTED_MODULE_1__["CLASS_HIDDEN"]);
      } else if (contains && rotation !== 0) {
        this.element.classList.remove(_css_js__WEBPACK_IMPORTED_MODULE_1__["CLASS_HIDDEN"]);
      }
    }
    this.label_.style.msTransform = transform;
    this.label_.style.webkitTransform = transform;
    this.label_.style.transform = transform;
  }
  this.rotation_ = rotation;
}

/* harmony default export */ __webpack_exports__["default"] = (Rotate);

//# sourceMappingURL=Rotate.js.map

/***/ }),

/***/ "./node_modules/ol/control/Zoom.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/control/Zoom.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _Control_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Control.js */ "./node_modules/ol/control/Control.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../css.js */ "./node_modules/ol/css.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../easing.js */ "./node_modules/ol/easing.js");
/**
 * @module ol/control/Zoom
 */







/**
 * @typedef {Object} Options
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {string} [className='ol-zoom'] CSS class name.
 * @property {string|HTMLElement} [zoomInLabel='+'] Text label to use for the zoom-in
 * button. Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string|HTMLElement} [zoomOutLabel='-'] Text label to use for the zoom-out button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [zoomInTipLabel='Zoom in'] Text label to use for the button tip.
 * @property {string} [zoomOutTipLabel='Zoom out'] Text label to use for the button tip.
 * @property {number} [delta=1] The zoom delta applied on each click.
 * @property {HTMLElement|string} [target] Specify a target if you want the control to be
 * rendered outside of the map's viewport.
 */


/**
 * @classdesc
 * A control with 2 buttons, one for zoom in and one for zoom out.
 * This control is one of the default controls of a map. To style this control
 * use css selectors `.ol-zoom-in` and `.ol-zoom-out`.
 *
 * @api
 */
var Zoom = /*@__PURE__*/(function (Control) {
  function Zoom(opt_options) {

    var options = opt_options ? opt_options : {};

    Control.call(this, {
      element: document.createElement('div'),
      target: options.target
    });

    var className = options.className !== undefined ? options.className : 'ol-zoom';

    var delta = options.delta !== undefined ? options.delta : 1;

    var zoomInLabel = options.zoomInLabel !== undefined ? options.zoomInLabel : '+';
    var zoomOutLabel = options.zoomOutLabel !== undefined ? options.zoomOutLabel : '\u2212';

    var zoomInTipLabel = options.zoomInTipLabel !== undefined ?
      options.zoomInTipLabel : 'Zoom in';
    var zoomOutTipLabel = options.zoomOutTipLabel !== undefined ?
      options.zoomOutTipLabel : 'Zoom out';

    var inElement = document.createElement('button');
    inElement.className = className + '-in';
    inElement.setAttribute('type', 'button');
    inElement.title = zoomInTipLabel;
    inElement.appendChild(
      typeof zoomInLabel === 'string' ? document.createTextNode(zoomInLabel) : zoomInLabel
    );

    Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listen"])(inElement, _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CLICK, this.handleClick_.bind(this, delta));

    var outElement = document.createElement('button');
    outElement.className = className + '-out';
    outElement.setAttribute('type', 'button');
    outElement.title = zoomOutTipLabel;
    outElement.appendChild(
      typeof zoomOutLabel === 'string' ? document.createTextNode(zoomOutLabel) : zoomOutLabel
    );

    Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listen"])(outElement, _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CLICK, this.handleClick_.bind(this, -delta));

    var cssClasses = className + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_3__["CLASS_UNSELECTABLE"] + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_3__["CLASS_CONTROL"];
    var element = this.element;
    element.className = cssClasses;
    element.appendChild(inElement);
    element.appendChild(outElement);

    /**
     * @type {number}
     * @private
     */
    this.duration_ = options.duration !== undefined ? options.duration : 250;

  }

  if ( Control ) Zoom.__proto__ = Control;
  Zoom.prototype = Object.create( Control && Control.prototype );
  Zoom.prototype.constructor = Zoom;

  /**
   * @param {number} delta Zoom delta.
   * @param {MouseEvent} event The event to handle
   * @private
   */
  Zoom.prototype.handleClick_ = function handleClick_ (delta, event) {
    event.preventDefault();
    this.zoomByDelta_(delta);
  };

  /**
   * @param {number} delta Zoom delta.
   * @private
   */
  Zoom.prototype.zoomByDelta_ = function zoomByDelta_ (delta) {
    var map = this.getMap();
    var view = map.getView();
    if (!view) {
      // the map does not have a view, so we can't act
      // upon it
      return;
    }
    var currentResolution = view.getResolution();
    if (currentResolution) {
      var newResolution = view.constrainResolution(currentResolution, delta);
      if (this.duration_ > 0) {
        if (view.getAnimating()) {
          view.cancelAnimations();
        }
        view.animate({
          resolution: newResolution,
          duration: this.duration_,
          easing: _easing_js__WEBPACK_IMPORTED_MODULE_4__["easeOut"]
        });
      } else {
        view.setResolution(newResolution);
      }
    }
  };

  return Zoom;
}(_Control_js__WEBPACK_IMPORTED_MODULE_2__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (Zoom);

//# sourceMappingURL=Zoom.js.map

/***/ }),

/***/ "./node_modules/ol/control/util.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/control/util.js ***!
  \*****************************************/
/*! exports provided: defaults */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaults", function() { return defaults; });
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Collection.js */ "./node_modules/ol/Collection.js");
/* harmony import */ var _Attribution_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Attribution.js */ "./node_modules/ol/control/Attribution.js");
/* harmony import */ var _Rotate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Rotate.js */ "./node_modules/ol/control/Rotate.js");
/* harmony import */ var _Zoom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Zoom.js */ "./node_modules/ol/control/Zoom.js");
/**
 * @module ol/control/util
 */






/**
 * @typedef {Object} DefaultsOptions
 * @property {boolean} [attribution=true] Include
 * {@link module:ol/control/Attribution~Attribution}.
 * @property {import("./Attribution.js").Options} [attributionOptions]
 * Options for {@link module:ol/control/Attribution~Attribution}.
 * @property {boolean} [rotate=true] Include
 * {@link module:ol/control/Rotate~Rotate}.
 * @property {import("./Rotate.js").Options} [rotateOptions] Options
 * for {@link module:ol/control/Rotate~Rotate}.
 * @property {boolean} [zoom] Include {@link module:ol/control/Zoom~Zoom}.
 * @property {import("./Zoom.js").Options} [zoomOptions] Options for
 * {@link module:ol/control/Zoom~Zoom}.
 * @api
 */


/**
 * Set of controls included in maps by default. Unless configured otherwise,
 * this returns a collection containing an instance of each of the following
 * controls:
 * * {@link module:ol/control/Zoom~Zoom}
 * * {@link module:ol/control/Rotate~Rotate}
 * * {@link module:ol/control/Attribution~Attribution}
 *
 * @param {DefaultsOptions=} opt_options
 * Defaults options.
 * @return {Collection<import("./Control.js").default>}
 * Controls.
 * @function module:ol/control.defaults
 * @api
 */
function defaults(opt_options) {

  var options = opt_options ? opt_options : {};

  var controls = new _Collection_js__WEBPACK_IMPORTED_MODULE_0__["default"]();

  var zoomControl = options.zoom !== undefined ? options.zoom : true;
  if (zoomControl) {
    controls.push(new _Zoom_js__WEBPACK_IMPORTED_MODULE_3__["default"](options.zoomOptions));
  }

  var rotateControl = options.rotate !== undefined ? options.rotate : true;
  if (rotateControl) {
    controls.push(new _Rotate_js__WEBPACK_IMPORTED_MODULE_2__["default"](options.rotateOptions));
  }

  var attributionControl = options.attribution !== undefined ?
    options.attribution : true;
  if (attributionControl) {
    controls.push(new _Attribution_js__WEBPACK_IMPORTED_MODULE_1__["default"](options.attributionOptions));
  }

  return controls;
}

//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/ol/coordinate.js":
/*!***************************************!*\
  !*** ./node_modules/ol/coordinate.js ***!
  \***************************************/
/*! exports provided: add, closestOnCircle, closestOnSegment, createStringXY, degreesToStringHDMS, format, equals, rotate, scale, squaredDistance, distance, squaredDistanceToSegment, toStringHDMS, toStringXY */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "closestOnCircle", function() { return closestOnCircle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "closestOnSegment", function() { return closestOnSegment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createStringXY", function() { return createStringXY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "degreesToStringHDMS", function() { return degreesToStringHDMS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "format", function() { return format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistanceToSegment", function() { return squaredDistanceToSegment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toStringHDMS", function() { return toStringHDMS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toStringXY", function() { return toStringXY; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./string.js */ "./node_modules/ol/string.js");
/**
 * @module ol/coordinate
 */




/**
 * An array of numbers representing an xy coordinate. Example: `[16, 48]`.
 * @typedef {Array<number>} Coordinate
 * @api
 */


/**
 * A function that takes a {@link module:ol/coordinate~Coordinate} and
 * transforms it into a `{string}`.
 *
 * @typedef {function((Coordinate|undefined)): string} CoordinateFormat
 * @api
 */


/**
 * Add `delta` to `coordinate`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     import {add} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     add(coord, [-2, 4]);
 *     // coord is now [5.85, 51.983333]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {Coordinate} delta Delta.
 * @return {Coordinate} The input coordinate adjusted by
 * the given delta.
 * @api
 */
function add(coordinate, delta) {
  coordinate[0] += delta[0];
  coordinate[1] += delta[1];
  return coordinate;
}


/**
 * Calculates the point closest to the passed coordinate on the passed circle.
 *
 * @param {Coordinate} coordinate The coordinate.
 * @param {import("./geom/Circle.js").default} circle The circle.
 * @return {Coordinate} Closest point on the circumference.
 */
function closestOnCircle(coordinate, circle) {
  var r = circle.getRadius();
  var center = circle.getCenter();
  var x0 = center[0];
  var y0 = center[1];
  var x1 = coordinate[0];
  var y1 = coordinate[1];

  var dx = x1 - x0;
  var dy = y1 - y0;
  if (dx === 0 && dy === 0) {
    dx = 1;
  }
  var d = Math.sqrt(dx * dx + dy * dy);

  var x = x0 + r * dx / d;
  var y = y0 + r * dy / d;

  return [x, y];
}


/**
 * Calculates the point closest to the passed coordinate on the passed segment.
 * This is the foot of the perpendicular of the coordinate to the segment when
 * the foot is on the segment, or the closest segment coordinate when the foot
 * is outside the segment.
 *
 * @param {Coordinate} coordinate The coordinate.
 * @param {Array<Coordinate>} segment The two coordinates
 * of the segment.
 * @return {Coordinate} The foot of the perpendicular of
 * the coordinate to the segment.
 */
function closestOnSegment(coordinate, segment) {
  var x0 = coordinate[0];
  var y0 = coordinate[1];
  var start = segment[0];
  var end = segment[1];
  var x1 = start[0];
  var y1 = start[1];
  var x2 = end[0];
  var y2 = end[1];
  var dx = x2 - x1;
  var dy = y2 - y1;
  var along = (dx === 0 && dy === 0) ? 0 :
    ((dx * (x0 - x1)) + (dy * (y0 - y1))) / ((dx * dx + dy * dy) || 0);
  var x, y;
  if (along <= 0) {
    x = x1;
    y = y1;
  } else if (along >= 1) {
    x = x2;
    y = y2;
  } else {
    x = x1 + along * dx;
    y = y1 + along * dy;
  }
  return [x, y];
}


/**
 * Returns a {@link module:ol/coordinate~CoordinateFormat} function that can be
 * used to format
 * a {Coordinate} to a string.
 *
 * Example without specifying the fractional digits:
 *
 *     import {createStringXY} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var stringifyFunc = createStringXY();
 *     var out = stringifyFunc(coord);
 *     // out is now '8, 48'
 *
 * Example with explicitly specifying 2 fractional digits:
 *
 *     import {createStringXY} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var stringifyFunc = createStringXY(2);
 *     var out = stringifyFunc(coord);
 *     // out is now '7.85, 47.98'
 *
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {CoordinateFormat} Coordinate format.
 * @api
 */
function createStringXY(opt_fractionDigits) {
  return (
    /**
     * @param {Coordinate} coordinate Coordinate.
     * @return {string} String XY.
     */
    function(coordinate) {
      return toStringXY(coordinate, opt_fractionDigits);
    }
  );
}


/**
 * @param {string} hemispheres Hemispheres.
 * @param {number} degrees Degrees.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} String.
 */
function degreesToStringHDMS(hemispheres, degrees, opt_fractionDigits) {
  var normalizedDegrees = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["modulo"])(degrees + 180, 360) - 180;
  var x = Math.abs(3600 * normalizedDegrees);
  var dflPrecision = opt_fractionDigits || 0;
  var precision = Math.pow(10, dflPrecision);

  var deg = Math.floor(x / 3600);
  var min = Math.floor((x - deg * 3600) / 60);
  var sec = x - (deg * 3600) - (min * 60);
  sec = Math.ceil(sec * precision) / precision;

  if (sec >= 60) {
    sec = 0;
    min += 1;
  }

  if (min >= 60) {
    min = 0;
    deg += 1;
  }

  return deg + '\u00b0 ' + Object(_string_js__WEBPACK_IMPORTED_MODULE_1__["padNumber"])(min, 2) + '\u2032 ' +
    Object(_string_js__WEBPACK_IMPORTED_MODULE_1__["padNumber"])(sec, 2, dflPrecision) + '\u2033' +
    (normalizedDegrees == 0 ? '' : ' ' + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0));
}


/**
 * Transforms the given {@link module:ol/coordinate~Coordinate} to a string
 * using the given string template. The strings `{x}` and `{y}` in the template
 * will be replaced with the first and second coordinate values respectively.
 *
 * Example without specifying the fractional digits:
 *
 *     import {format} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var template = 'Coordinate is ({x}|{y}).';
 *     var out = format(coord, template);
 *     // out is now 'Coordinate is (8|48).'
 *
 * Example explicitly specifying the fractional digits:
 *
 *     import {format} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var template = 'Coordinate is ({x}|{y}).';
 *     var out = format(coord, template, 2);
 *     // out is now 'Coordinate is (7.85|47.98).'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {string} template A template string with `{x}` and `{y}` placeholders
 *     that will be replaced by first and second coordinate values.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Formatted coordinate.
 * @api
 */
function format(coordinate, template, opt_fractionDigits) {
  if (coordinate) {
    return template
      .replace('{x}', coordinate[0].toFixed(opt_fractionDigits))
      .replace('{y}', coordinate[1].toFixed(opt_fractionDigits));
  } else {
    return '';
  }
}


/**
 * @param {Coordinate} coordinate1 First coordinate.
 * @param {Coordinate} coordinate2 Second coordinate.
 * @return {boolean} The two coordinates are equal.
 */
function equals(coordinate1, coordinate2) {
  var equals = true;
  for (var i = coordinate1.length - 1; i >= 0; --i) {
    if (coordinate1[i] != coordinate2[i]) {
      equals = false;
      break;
    }
  }
  return equals;
}


/**
 * Rotate `coordinate` by `angle`. `coordinate` is modified in place and
 * returned by the function.
 *
 * Example:
 *
 *     import {rotate} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var rotateRadians = Math.PI / 2; // 90 degrees
 *     rotate(coord, rotateRadians);
 *     // coord is now [-47.983333, 7.85]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} angle Angle in radian.
 * @return {Coordinate} Coordinate.
 * @api
 */
function rotate(coordinate, angle) {
  var cosAngle = Math.cos(angle);
  var sinAngle = Math.sin(angle);
  var x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  var y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  coordinate[0] = x;
  coordinate[1] = y;
  return coordinate;
}


/**
 * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     import {scale as scaleCoordinate} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var scale = 1.2;
 *     scaleCoordinate(coord, scale);
 *     // coord is now [9.42, 57.5799996]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} scale Scale factor.
 * @return {Coordinate} Coordinate.
 */
function scale(coordinate, scale) {
  coordinate[0] *= scale;
  coordinate[1] *= scale;
  return coordinate;
}


/**
 * @param {Coordinate} coord1 First coordinate.
 * @param {Coordinate} coord2 Second coordinate.
 * @return {number} Squared distance between coord1 and coord2.
 */
function squaredDistance(coord1, coord2) {
  var dx = coord1[0] - coord2[0];
  var dy = coord1[1] - coord2[1];
  return dx * dx + dy * dy;
}


/**
 * @param {Coordinate} coord1 First coordinate.
 * @param {Coordinate} coord2 Second coordinate.
 * @return {number} Distance between coord1 and coord2.
 */
function distance(coord1, coord2) {
  return Math.sqrt(squaredDistance(coord1, coord2));
}


/**
 * Calculate the squared distance from a coordinate to a line segment.
 *
 * @param {Coordinate} coordinate Coordinate of the point.
 * @param {Array<Coordinate>} segment Line segment (2
 * coordinates).
 * @return {number} Squared distance from the point to the line segment.
 */
function squaredDistanceToSegment(coordinate, segment) {
  return squaredDistance(coordinate,
    closestOnSegment(coordinate, segment));
}


/**
 * Format a geographic coordinate with the hemisphere, degrees, minutes, and
 * seconds.
 *
 * Example without specifying fractional digits:
 *
 *     import {toStringHDMS} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var out = toStringHDMS(coord);
 *     // out is now '47° 58′ 60″ N 7° 50′ 60″ E'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     import {toStringHDMS} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var out = toStringHDMS(coord, 1);
 *     // out is now '47° 58′ 60.0″ N 7° 50′ 60.0″ E'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Hemisphere, degrees, minutes and seconds.
 * @api
 */
function toStringHDMS(coordinate, opt_fractionDigits) {
  if (coordinate) {
    return degreesToStringHDMS('NS', coordinate[1], opt_fractionDigits) + ' ' +
        degreesToStringHDMS('EW', coordinate[0], opt_fractionDigits);
  } else {
    return '';
  }
}


/**
 * Format a coordinate as a comma delimited string.
 *
 * Example without specifying fractional digits:
 *
 *     import {toStringXY} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var out = toStringXY(coord);
 *     // out is now '8, 48'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     import {toStringXY} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var out = toStringXY(coord, 1);
 *     // out is now '7.8, 48.0'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} XY.
 * @api
 */
function toStringXY(coordinate, opt_fractionDigits) {
  return format(coordinate, '{x}, {y}', opt_fractionDigits);
}

//# sourceMappingURL=coordinate.js.map

/***/ }),

/***/ "./node_modules/ol/css.js":
/*!********************************!*\
  !*** ./node_modules/ol/css.js ***!
  \********************************/
/*! exports provided: CLASS_HIDDEN, CLASS_SELECTABLE, CLASS_UNSELECTABLE, CLASS_UNSUPPORTED, CLASS_CONTROL, CLASS_COLLAPSED, getFontFamilies */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLASS_HIDDEN", function() { return CLASS_HIDDEN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLASS_SELECTABLE", function() { return CLASS_SELECTABLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLASS_UNSELECTABLE", function() { return CLASS_UNSELECTABLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLASS_UNSUPPORTED", function() { return CLASS_UNSUPPORTED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLASS_CONTROL", function() { return CLASS_CONTROL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLASS_COLLAPSED", function() { return CLASS_COLLAPSED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFontFamilies", function() { return getFontFamilies; });
/**
 * @module ol/css
 */


/**
 * The CSS class for hidden feature.
 *
 * @const
 * @type {string}
 */
var CLASS_HIDDEN = 'ol-hidden';


/**
 * The CSS class that we'll give the DOM elements to have them selectable.
 *
 * @const
 * @type {string}
 */
var CLASS_SELECTABLE = 'ol-selectable';


/**
 * The CSS class that we'll give the DOM elements to have them unselectable.
 *
 * @const
 * @type {string}
 */
var CLASS_UNSELECTABLE = 'ol-unselectable';


/**
 * The CSS class for unsupported feature.
 *
 * @const
 * @type {string}
 */
var CLASS_UNSUPPORTED = 'ol-unsupported';


/**
 * The CSS class for controls.
 *
 * @const
 * @type {string}
 */
var CLASS_CONTROL = 'ol-control';


/**
 * The CSS class that we'll give the DOM elements that are collapsed, i.e.
 * to those elements which usually can be expanded.
 *
 * @const
 * @type {string}
 */
var CLASS_COLLAPSED = 'ol-collapsed';


/**
 * Get the list of font families from a font spec.  Note that this doesn't work
 * for font families that have commas in them.
 * @param {string} The CSS font property.
 * @return {Object<string>} The font families (or null if the input spec is invalid).
 */
var getFontFamilies = (function() {
  var style;
  var cache = {};
  return function(font) {
    if (!style) {
      style = document.createElement('div').style;
    }
    if (!(font in cache)) {
      style.font = font;
      var family = style.fontFamily;
      style.font = '';
      if (!family) {
        return null;
      }
      cache[font] = family.split(/,\s?/);
    }
    return cache[font];
  };
})();

//# sourceMappingURL=css.js.map

/***/ }),

/***/ "./node_modules/ol/dom.js":
/*!********************************!*\
  !*** ./node_modules/ol/dom.js ***!
  \********************************/
/*! exports provided: createCanvasContext2D, outerWidth, outerHeight, replaceNode, removeNode, removeChildren */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createCanvasContext2D", function() { return createCanvasContext2D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "outerWidth", function() { return outerWidth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "outerHeight", function() { return outerHeight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "replaceNode", function() { return replaceNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeNode", function() { return removeNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeChildren", function() { return removeChildren; });
/**
 * @module ol/dom
 */


/**
 * Create an html canvas element and returns its 2d context.
 * @param {number=} opt_width Canvas width.
 * @param {number=} opt_height Canvas height.
 * @return {CanvasRenderingContext2D} The context.
 */
function createCanvasContext2D(opt_width, opt_height) {
  var canvas = /** @type {HTMLCanvasElement} */ (document.createElement('canvas'));
  if (opt_width) {
    canvas.width = opt_width;
  }
  if (opt_height) {
    canvas.height = opt_height;
  }
  return /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));
}


/**
 * Get the current computed width for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerWidth(true)`.
 * @param {!HTMLElement} element Element.
 * @return {number} The width.
 */
function outerWidth(element) {
  var width = element.offsetWidth;
  var style = getComputedStyle(element);
  width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);

  return width;
}


/**
 * Get the current computed height for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerHeight(true)`.
 * @param {!HTMLElement} element Element.
 * @return {number} The height.
 */
function outerHeight(element) {
  var height = element.offsetHeight;
  var style = getComputedStyle(element);
  height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);

  return height;
}

/**
 * @param {Node} newNode Node to replace old node
 * @param {Node} oldNode The node to be replaced
 */
function replaceNode(newNode, oldNode) {
  var parent = oldNode.parentNode;
  if (parent) {
    parent.replaceChild(newNode, oldNode);
  }
}

/**
 * @param {Node} node The node to remove.
 * @returns {Node} The node that was removed or null.
 */
function removeNode(node) {
  return node && node.parentNode ? node.parentNode.removeChild(node) : null;
}

/**
 * @param {Node} node The node to remove the children from.
 */
function removeChildren(node) {
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
}

//# sourceMappingURL=dom.js.map

/***/ }),

/***/ "./node_modules/ol/easing.js":
/*!***********************************!*\
  !*** ./node_modules/ol/easing.js ***!
  \***********************************/
/*! exports provided: easeIn, easeOut, inAndOut, linear, upAndDown */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "easeIn", function() { return easeIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "easeOut", function() { return easeOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inAndOut", function() { return inAndOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linear", function() { return linear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "upAndDown", function() { return upAndDown; });
/**
 * @module ol/easing
 */


/**
 * Start slow and speed up.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function easeIn(t) {
  return Math.pow(t, 3);
}


/**
 * Start fast and slow down.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function easeOut(t) {
  return 1 - easeIn(1 - t);
}


/**
 * Start slow, speed up, and then slow down again.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function inAndOut(t) {
  return 3 * t * t - 2 * t * t * t;
}


/**
 * Maintain a constant speed over time.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function linear(t) {
  return t;
}


/**
 * Start slow, speed up, and at the very end slow down again.  This has the
 * same general behavior as {@link module:ol/easing~inAndOut}, but the final
 * slowdown is delayed.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function upAndDown(t) {
  if (t < 0.5) {
    return inAndOut(2 * t);
  } else {
    return 1 - inAndOut(2 * (t - 0.5));
  }
}

//# sourceMappingURL=easing.js.map

/***/ }),

/***/ "./node_modules/ol/events.js":
/*!***********************************!*\
  !*** ./node_modules/ol/events.js ***!
  \***********************************/
/*! exports provided: bindListener, findListener, getListeners, listen, listenOnce, unlisten, unlistenByKey, unlistenAll */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bindListener", function() { return bindListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findListener", function() { return findListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getListeners", function() { return getListeners; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "listen", function() { return listen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "listenOnce", function() { return listenOnce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unlisten", function() { return unlisten; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unlistenByKey", function() { return unlistenByKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unlistenAll", function() { return unlistenAll; });
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/events
 */



/**
 * Key to use with {@link module:ol/Observable~Observable#unByKey}.
 * @typedef {Object} EventsKey
 * @property {Object} [bindTo]
 * @property {ListenerFunction} [boundListener]
 * @property {boolean} callOnce
 * @property {number} [deleteIndex]
 * @property {ListenerFunction} listener
 * @property {import("./events/Target.js").EventTargetLike} target
 * @property {string} type
 * @api
 */


/**
 * Listener function. This function is called with an event object as argument.
 * When the function returns `false`, event propagation will stop.
 *
 * @typedef {function((Event|import("./events/Event.js").default)): (void|boolean)} ListenerFunction
 * @api
 */


/**
 * @param {EventsKey} listenerObj Listener object.
 * @return {ListenerFunction} Bound listener.
 */
function bindListener(listenerObj) {
  var boundListener = function(evt) {
    var listener = listenerObj.listener;
    var bindTo = listenerObj.bindTo || listenerObj.target;
    if (listenerObj.callOnce) {
      unlistenByKey(listenerObj);
    }
    return listener.call(bindTo, evt);
  };
  listenerObj.boundListener = boundListener;
  return boundListener;
}


/**
 * Finds the matching {@link module:ol/events~EventsKey} in the given listener
 * array.
 *
 * @param {!Array<!EventsKey>} listeners Array of listeners.
 * @param {!Function} listener The listener function.
 * @param {Object=} opt_this The `this` value inside the listener.
 * @param {boolean=} opt_setDeleteIndex Set the deleteIndex on the matching
 *     listener, for {@link module:ol/events~unlistenByKey}.
 * @return {EventsKey|undefined} The matching listener object.
 */
function findListener(listeners, listener, opt_this, opt_setDeleteIndex) {
  var listenerObj;
  for (var i = 0, ii = listeners.length; i < ii; ++i) {
    listenerObj = listeners[i];
    if (listenerObj.listener === listener &&
        listenerObj.bindTo === opt_this) {
      if (opt_setDeleteIndex) {
        listenerObj.deleteIndex = i;
      }
      return listenerObj;
    }
  }
  return undefined;
}


/**
 * @param {import("./events/Target.js").EventTargetLike} target Target.
 * @param {string} type Type.
 * @return {Array<EventsKey>|undefined} Listeners.
 */
function getListeners(target, type) {
  var listenerMap = getListenerMap(target);
  return listenerMap ? listenerMap[type] : undefined;
}


/**
 * Get the lookup of listeners.
 * @param {Object} target Target.
 * @param {boolean=} opt_create If a map should be created if it doesn't exist.
 * @return {!Object<string, Array<EventsKey>>} Map of
 *     listeners by event type.
 */
function getListenerMap(target, opt_create) {
  var listenerMap = target.ol_lm;
  if (!listenerMap && opt_create) {
    listenerMap = target.ol_lm = {};
  }
  return listenerMap;
}


/**
 * Remove the listener map from a target.
 * @param {Object} target Target.
 */
function removeListenerMap(target) {
  delete target.ol_lm;
}


/**
 * Clean up all listener objects of the given type.  All properties on the
 * listener objects will be removed, and if no listeners remain in the listener
 * map, it will be removed from the target.
 * @param {import("./events/Target.js").EventTargetLike} target Target.
 * @param {string} type Type.
 */
function removeListeners(target, type) {
  var listeners = getListeners(target, type);
  if (listeners) {
    for (var i = 0, ii = listeners.length; i < ii; ++i) {
      /** @type {import("./events/Target.js").default} */ (target).
        removeEventListener(type, listeners[i].boundListener);
      Object(_obj_js__WEBPACK_IMPORTED_MODULE_0__["clear"])(listeners[i]);
    }
    listeners.length = 0;
    var listenerMap = getListenerMap(target);
    if (listenerMap) {
      delete listenerMap[type];
      if (Object.keys(listenerMap).length === 0) {
        removeListenerMap(target);
      }
    }
  }
}


/**
 * Registers an event listener on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * This function efficiently binds a `listener` to a `this` object, and returns
 * a key for use with {@link module:ol/events~unlistenByKey}.
 *
 * @param {import("./events/Target.js").EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ListenerFunction} listener Listener.
 * @param {Object=} opt_this Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @param {boolean=} opt_once If true, add the listener as one-off listener.
 * @return {EventsKey} Unique key for the listener.
 */
function listen(target, type, listener, opt_this, opt_once) {
  var listenerMap = getListenerMap(target, true);
  var listeners = listenerMap[type];
  if (!listeners) {
    listeners = listenerMap[type] = [];
  }
  var listenerObj = findListener(listeners, listener, opt_this, false);
  if (listenerObj) {
    if (!opt_once) {
      // Turn one-off listener into a permanent one.
      listenerObj.callOnce = false;
    }
  } else {
    listenerObj = /** @type {EventsKey} */ ({
      bindTo: opt_this,
      callOnce: !!opt_once,
      listener: listener,
      target: target,
      type: type
    });
    /** @type {import("./events/Target.js").default} */ (target).
      addEventListener(type, bindListener(listenerObj));
    listeners.push(listenerObj);
  }

  return listenerObj;
}


/**
 * Registers a one-off event listener on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * This function efficiently binds a `listener` as self-unregistering listener
 * to a `this` object, and returns a key for use with
 * {@link module:ol/events~unlistenByKey} in case the listener needs to be
 * unregistered before it is called.
 *
 * When {@link module:ol/events~listen} is called with the same arguments after this
 * function, the self-unregistering listener will be turned into a permanent
 * listener.
 *
 * @param {import("./events/Target.js").EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ListenerFunction} listener Listener.
 * @param {Object=} opt_this Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @return {EventsKey} Key for unlistenByKey.
 */
function listenOnce(target, type, listener, opt_this) {
  return listen(target, type, listener, opt_this, true);
}


/**
 * Unregisters an event listener on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * To return a listener, this function needs to be called with the exact same
 * arguments that were used for a previous {@link module:ol/events~listen} call.
 *
 * @param {import("./events/Target.js").EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ListenerFunction} listener Listener.
 * @param {Object=} opt_this Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 */
function unlisten(target, type, listener, opt_this) {
  var listeners = getListeners(target, type);
  if (listeners) {
    var listenerObj = findListener(listeners, listener, opt_this, true);
    if (listenerObj) {
      unlistenByKey(listenerObj);
    }
  }
}


/**
 * Unregisters event listeners on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * The argument passed to this function is the key returned from
 * {@link module:ol/events~listen} or {@link module:ol/events~listenOnce}.
 *
 * @param {EventsKey} key The key.
 */
function unlistenByKey(key) {
  if (key && key.target) {
    /** @type {import("./events/Target.js").default} */ (key.target).
      removeEventListener(key.type, key.boundListener);
    var listeners = getListeners(key.target, key.type);
    if (listeners) {
      var i = 'deleteIndex' in key ? key.deleteIndex : listeners.indexOf(key);
      if (i !== -1) {
        listeners.splice(i, 1);
      }
      if (listeners.length === 0) {
        removeListeners(key.target, key.type);
      }
    }
    Object(_obj_js__WEBPACK_IMPORTED_MODULE_0__["clear"])(key);
  }
}


/**
 * Unregisters all event listeners on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * @param {import("./events/Target.js").EventTargetLike} target Target.
 */
function unlistenAll(target) {
  var listenerMap = getListenerMap(target);
  if (listenerMap) {
    for (var type in listenerMap) {
      removeListeners(target, type);
    }
  }
}

//# sourceMappingURL=events.js.map

/***/ }),

/***/ "./node_modules/ol/events/Event.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/events/Event.js ***!
  \*****************************************/
/*! exports provided: stopPropagation, preventDefault, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stopPropagation", function() { return stopPropagation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "preventDefault", function() { return preventDefault; });
/**
 * @module ol/events/Event
 */

/**
 * @classdesc
 * Stripped down implementation of the W3C DOM Level 2 Event interface.
 * See https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface.
 *
 * This implementation only provides `type` and `target` properties, and
 * `stopPropagation` and `preventDefault` methods. It is meant as base class
 * for higher level events defined in the library, and works with
 * {@link module:ol/events/Target~Target}.
 */
var Event = function Event(type) {

  /**
   * @type {boolean}
   */
  this.propagationStopped;

  /**
   * The event type.
   * @type {string}
   * @api
   */
  this.type = type;

  /**
   * The event target.
   * @type {Object}
   * @api
   */
  this.target = null;
};

/**
 * Stop event propagation.
 * @api
 */
Event.prototype.preventDefault = function preventDefault () {
  this.propagationStopped = true;
};

/**
 * Stop event propagation.
 * @api
 */
Event.prototype.stopPropagation = function stopPropagation () {
  this.propagationStopped = true;
};


/**
 * @param {Event|import("./Event.js").default} evt Event
 */
function stopPropagation(evt) {
  evt.stopPropagation();
}


/**
 * @param {Event|import("./Event.js").default} evt Event
 */
function preventDefault(evt) {
  evt.preventDefault();
}

/* harmony default export */ __webpack_exports__["default"] = (Event);

//# sourceMappingURL=Event.js.map

/***/ }),

/***/ "./node_modules/ol/events/EventType.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/events/EventType.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/events/EventType
 */

/**
 * @enum {string}
 * @const
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event module:ol/events/Event~Event#change
   * @api
   */
  CHANGE: 'change',

  CLEAR: 'clear',
  CONTEXTMENU: 'contextmenu',
  CLICK: 'click',
  DBLCLICK: 'dblclick',
  DRAGENTER: 'dragenter',
  DRAGOVER: 'dragover',
  DROP: 'drop',
  ERROR: 'error',
  KEYDOWN: 'keydown',
  KEYPRESS: 'keypress',
  LOAD: 'load',
  MOUSEDOWN: 'mousedown',
  MOUSEMOVE: 'mousemove',
  MOUSEOUT: 'mouseout',
  MOUSEUP: 'mouseup',
  MOUSEWHEEL: 'mousewheel',
  MSPOINTERDOWN: 'MSPointerDown',
  RESIZE: 'resize',
  TOUCHSTART: 'touchstart',
  TOUCHMOVE: 'touchmove',
  TOUCHEND: 'touchend',
  WHEEL: 'wheel'
});

//# sourceMappingURL=EventType.js.map

/***/ }),

/***/ "./node_modules/ol/events/KeyCode.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/events/KeyCode.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/events/KeyCode
 */

/**
 * @enum {number}
 * @const
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40
});

//# sourceMappingURL=KeyCode.js.map

/***/ }),

/***/ "./node_modules/ol/events/Target.js":
/*!******************************************!*\
  !*** ./node_modules/ol/events/Target.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Disposable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Disposable.js */ "./node_modules/ol/Disposable.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _Event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Event.js */ "./node_modules/ol/events/Event.js");
/**
 * @module ol/events/Target
 */






/**
 * @typedef {EventTarget|Target} EventTargetLike
 */


/**
 * @classdesc
 * A simplified implementation of the W3C DOM Level 2 EventTarget interface.
 * See https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget.
 *
 * There are two important simplifications compared to the specification:
 *
 * 1. The handling of `useCapture` in `addEventListener` and
 *    `removeEventListener`. There is no real capture model.
 * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.
 *    There is no event target hierarchy. When a listener calls
 *    `stopPropagation` or `preventDefault` on an event object, it means that no
 *    more listeners after this one will be called. Same as when the listener
 *    returns false.
 */
var Target = /*@__PURE__*/(function (Disposable) {
  function Target() {

    Disposable.call(this);

    /**
     * @private
     * @type {!Object<string, number>}
     */
    this.pendingRemovals_ = {};

    /**
     * @private
     * @type {!Object<string, number>}
     */
    this.dispatching_ = {};

    /**
     * @private
     * @type {!Object<string, Array<import("../events.js").ListenerFunction>>}
     */
    this.listeners_ = {};

  }

  if ( Disposable ) Target.__proto__ = Disposable;
  Target.prototype = Object.create( Disposable && Disposable.prototype );
  Target.prototype.constructor = Target;

  /**
   * @param {string} type Type.
   * @param {import("../events.js").ListenerFunction} listener Listener.
   */
  Target.prototype.addEventListener = function addEventListener (type, listener) {
    var listeners = this.listeners_[type];
    if (!listeners) {
      listeners = this.listeners_[type] = [];
    }
    if (listeners.indexOf(listener) === -1) {
      listeners.push(listener);
    }
  };

  /**
   * Dispatches an event and calls all listeners listening for events
   * of this type. The event parameter can either be a string or an
   * Object with a `type` property.
   *
   * @param {{type: string,
   *     target: (EventTargetLike|undefined),
   *     propagationStopped: (boolean|undefined)}|
   *     import("./Event.js").default|string} event Event object.
   * @return {boolean|undefined} `false` if anyone called preventDefault on the
   *     event object or if any of the listeners returned false.
   * @api
   */
  Target.prototype.dispatchEvent = function dispatchEvent (event) {
    var evt = typeof event === 'string' ? new _Event_js__WEBPACK_IMPORTED_MODULE_3__["default"](event) : event;
    var type = evt.type;
    evt.target = this;
    var listeners = this.listeners_[type];
    var propagate;
    if (listeners) {
      if (!(type in this.dispatching_)) {
        this.dispatching_[type] = 0;
        this.pendingRemovals_[type] = 0;
      }
      ++this.dispatching_[type];
      for (var i = 0, ii = listeners.length; i < ii; ++i) {
        if (listeners[i].call(this, evt) === false || evt.propagationStopped) {
          propagate = false;
          break;
        }
      }
      --this.dispatching_[type];
      if (this.dispatching_[type] === 0) {
        var pendingRemovals = this.pendingRemovals_[type];
        delete this.pendingRemovals_[type];
        while (pendingRemovals--) {
          this.removeEventListener(type, _functions_js__WEBPACK_IMPORTED_MODULE_2__["VOID"]);
        }
        delete this.dispatching_[type];
      }
      return propagate;
    }
  };

  /**
   * @inheritDoc
   */
  Target.prototype.disposeInternal = function disposeInternal () {
    Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["unlistenAll"])(this);
  };

  /**
   * Get the listeners for a specified event type. Listeners are returned in the
   * order that they will be called in.
   *
   * @param {string} type Type.
   * @return {Array<import("../events.js").ListenerFunction>} Listeners.
   */
  Target.prototype.getListeners = function getListeners (type) {
    return this.listeners_[type];
  };

  /**
   * @param {string=} opt_type Type. If not provided,
   *     `true` will be returned if this event target has any listeners.
   * @return {boolean} Has listeners.
   */
  Target.prototype.hasListener = function hasListener (opt_type) {
    return opt_type ?
      opt_type in this.listeners_ :
      Object.keys(this.listeners_).length > 0;
  };

  /**
   * @param {string} type Type.
   * @param {import("../events.js").ListenerFunction} listener Listener.
   */
  Target.prototype.removeEventListener = function removeEventListener (type, listener) {
    var listeners = this.listeners_[type];
    if (listeners) {
      var index = listeners.indexOf(listener);
      if (type in this.pendingRemovals_) {
        // make listener a no-op, and remove later in #dispatchEvent()
        listeners[index] = _functions_js__WEBPACK_IMPORTED_MODULE_2__["VOID"];
        ++this.pendingRemovals_[type];
      } else {
        listeners.splice(index, 1);
        if (listeners.length === 0) {
          delete this.listeners_[type];
        }
      }
    }
  };

  return Target;
}(_Disposable_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (Target);

//# sourceMappingURL=Target.js.map

/***/ }),

/***/ "./node_modules/ol/events/condition.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/events/condition.js ***!
  \*********************************************/
/*! exports provided: altKeyOnly, altShiftKeysOnly, focus, always, click, mouseActionButton, never, pointerMove, singleClick, doubleClick, noModifierKeys, platformModifierKeyOnly, shiftKeyOnly, targetNotEditable, mouseOnly, primaryAction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "altKeyOnly", function() { return altKeyOnly; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "altShiftKeysOnly", function() { return altShiftKeysOnly; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "focus", function() { return focus; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "always", function() { return always; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "click", function() { return click; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mouseActionButton", function() { return mouseActionButton; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "never", function() { return never; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointerMove", function() { return pointerMove; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "singleClick", function() { return singleClick; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "doubleClick", function() { return doubleClick; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "noModifierKeys", function() { return noModifierKeys; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "platformModifierKeyOnly", function() { return platformModifierKeyOnly; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shiftKeyOnly", function() { return shiftKeyOnly; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "targetNotEditable", function() { return targetNotEditable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mouseOnly", function() { return mouseOnly; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "primaryAction", function() { return primaryAction; });
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MapBrowserEventType.js */ "./node_modules/ol/MapBrowserEventType.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../has.js */ "./node_modules/ol/has.js");
/**
 * @module ol/events/condition
 */






/**
 * A function that takes an {@link module:ol/MapBrowserEvent} and returns a
 * `{boolean}`. If the condition is met, true should be returned.
 *
 * @typedef {function(this: ?, import("../MapBrowserEvent.js").default): boolean} Condition
 */


/**
 * Return `true` if only the alt-key is pressed, `false` otherwise (e.g. when
 * additionally the shift-key is pressed).
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the alt key is pressed.
 * @api
 */
var altKeyOnly = function(mapBrowserEvent) {
  var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (mapBrowserEvent.originalEvent);
  return (
    originalEvent.altKey &&
      !(originalEvent.metaKey || originalEvent.ctrlKey) &&
      !originalEvent.shiftKey);
};


/**
 * Return `true` if only the alt-key and shift-key is pressed, `false` otherwise
 * (e.g. when additionally the platform-modifier-key is pressed).
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the alt and shift keys are pressed.
 * @api
 */
var altShiftKeysOnly = function(mapBrowserEvent) {
  var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (mapBrowserEvent.originalEvent);
  return (
    originalEvent.altKey &&
      !(originalEvent.metaKey || originalEvent.ctrlKey) &&
      originalEvent.shiftKey);
};


/**
 * Return `true` if the map has the focus. This condition requires a map target
 * element with a `tabindex` attribute, e.g. `<div id="map" tabindex="1">`.
 *
 * @param {import("../MapBrowserEvent.js").default} event Map browser event.
 * @return {boolean} The map has the focus.
 * @api
 */
var focus = function(event) {
  return event.target.getTargetElement() === document.activeElement;
};


/**
 * Return always true.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True.
 * @api
 */
var always = _functions_js__WEBPACK_IMPORTED_MODULE_2__["TRUE"];


/**
 * Return `true` if the event is a `click` event, `false` otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `click` event.
 * @api
 */
var click = function(mapBrowserEvent) {
  return mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].CLICK;
};


/**
 * Return `true` if the event has an "action"-producing mouse button.
 *
 * By definition, this includes left-click on windows/linux, and left-click
 * without the ctrl key on Macs.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} The result.
 */
var mouseActionButton = function(mapBrowserEvent) {
  var originalEvent = /** @type {MouseEvent} */ (mapBrowserEvent.originalEvent);
  return originalEvent.button == 0 &&
      !(_has_js__WEBPACK_IMPORTED_MODULE_3__["WEBKIT"] && _has_js__WEBPACK_IMPORTED_MODULE_3__["MAC"] && originalEvent.ctrlKey);
};


/**
 * Return always false.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} False.
 * @api
 */
var never = _functions_js__WEBPACK_IMPORTED_MODULE_2__["FALSE"];


/**
 * Return `true` if the browser event is a `pointermove` event, `false`
 * otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the browser event is a `pointermove` event.
 * @api
 */
var pointerMove = function(mapBrowserEvent) {
  return mapBrowserEvent.type == 'pointermove';
};


/**
 * Return `true` if the event is a map `singleclick` event, `false` otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `singleclick` event.
 * @api
 */
var singleClick = function(mapBrowserEvent) {
  return mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].SINGLECLICK;
};


/**
 * Return `true` if the event is a map `dblclick` event, `false` otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `dblclick` event.
 * @api
 */
var doubleClick = function(mapBrowserEvent) {
  return mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].DBLCLICK;
};


/**
 * Return `true` if no modifier key (alt-, shift- or platform-modifier-key) is
 * pressed.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True only if there no modifier keys are pressed.
 * @api
 */
var noModifierKeys = function(mapBrowserEvent) {
  var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (mapBrowserEvent.originalEvent);
  return (
    !originalEvent.altKey &&
      !(originalEvent.metaKey || originalEvent.ctrlKey) &&
      !originalEvent.shiftKey);
};


/**
 * Return `true` if only the platform-modifier-key (the meta-key on Mac,
 * ctrl-key otherwise) is pressed, `false` otherwise (e.g. when additionally
 * the shift-key is pressed).
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the platform modifier key is pressed.
 * @api
 */
var platformModifierKeyOnly = function(mapBrowserEvent) {
  var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (mapBrowserEvent.originalEvent);
  return !originalEvent.altKey &&
    (_has_js__WEBPACK_IMPORTED_MODULE_3__["MAC"] ? originalEvent.metaKey : originalEvent.ctrlKey) &&
    !originalEvent.shiftKey;
};


/**
 * Return `true` if only the shift-key is pressed, `false` otherwise (e.g. when
 * additionally the alt-key is pressed).
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the shift key is pressed.
 * @api
 */
var shiftKeyOnly = function(mapBrowserEvent) {
  var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (mapBrowserEvent.originalEvent);
  return (
    !originalEvent.altKey &&
      !(originalEvent.metaKey || originalEvent.ctrlKey) &&
      originalEvent.shiftKey);
};


/**
 * Return `true` if the target element is not editable, i.e. not a `<input>`-,
 * `<select>`- or `<textarea>`-element, `false` otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True only if the target element is not editable.
 * @api
 */
var targetNotEditable = function(mapBrowserEvent) {
  var target = mapBrowserEvent.originalEvent.target;
  var tagName = /** @type {Element} */ (target).tagName;
  return (
    tagName !== 'INPUT' &&
      tagName !== 'SELECT' &&
      tagName !== 'TEXTAREA');
};


/**
 * Return `true` if the event originates from a mouse device.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a mouse device.
 * @api
 */
var mouseOnly = function(mapBrowserEvent) {
  var pointerEvent = /** @type {import("../MapBrowserPointerEvent").default} */ (mapBrowserEvent).pointerEvent;
  Object(_asserts_js__WEBPACK_IMPORTED_MODULE_1__["assert"])(pointerEvent !== undefined, 56); // mapBrowserEvent must originate from a pointer event
  // see http://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType
  return pointerEvent.pointerType == 'mouse';
};


/**
 * Return `true` if the event originates from a primary pointer in
 * contact with the surface or if the left mouse button is pressed.
 * See http://www.w3.org/TR/pointerevents/#button-states.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a primary pointer.
 * @api
 */
var primaryAction = function(mapBrowserEvent) {
  var pointerEvent = /** @type {import("../MapBrowserPointerEvent").default} */ (mapBrowserEvent).pointerEvent;
  Object(_asserts_js__WEBPACK_IMPORTED_MODULE_1__["assert"])(pointerEvent !== undefined, 56); // mapBrowserEvent must originate from a pointer event
  return pointerEvent.isPrimary && pointerEvent.button === 0;
};

//# sourceMappingURL=condition.js.map

/***/ }),

/***/ "./node_modules/ol/extent.js":
/*!***********************************!*\
  !*** ./node_modules/ol/extent.js ***!
  \***********************************/
/*! exports provided: boundingExtent, buffer, clone, closestSquaredDistanceXY, containsCoordinate, containsExtent, containsXY, coordinateRelationship, createEmpty, createOrUpdate, createOrUpdateEmpty, createOrUpdateFromCoordinate, createOrUpdateFromCoordinates, createOrUpdateFromFlatCoordinates, createOrUpdateFromRings, equals, extend, extendCoordinate, extendCoordinates, extendFlatCoordinates, extendRings, extendXY, forEachCorner, getArea, getBottomLeft, getBottomRight, getCenter, getCorner, getEnlargedArea, getForViewAndSize, getHeight, getIntersectionArea, getIntersection, getMargin, getSize, getTopLeft, getTopRight, getWidth, intersects, isEmpty, returnOrUpdate, scaleFromCenter, intersectsSegment, applyTransform */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "boundingExtent", function() { return boundingExtent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buffer", function() { return buffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "closestSquaredDistanceXY", function() { return closestSquaredDistanceXY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "containsCoordinate", function() { return containsCoordinate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "containsExtent", function() { return containsExtent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "containsXY", function() { return containsXY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "coordinateRelationship", function() { return coordinateRelationship; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createEmpty", function() { return createEmpty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdate", function() { return createOrUpdate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdateEmpty", function() { return createOrUpdateEmpty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdateFromCoordinate", function() { return createOrUpdateFromCoordinate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdateFromCoordinates", function() { return createOrUpdateFromCoordinates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdateFromFlatCoordinates", function() { return createOrUpdateFromFlatCoordinates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdateFromRings", function() { return createOrUpdateFromRings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendCoordinate", function() { return extendCoordinate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendCoordinates", function() { return extendCoordinates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendFlatCoordinates", function() { return extendFlatCoordinates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendRings", function() { return extendRings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendXY", function() { return extendXY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEachCorner", function() { return forEachCorner; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getArea", function() { return getArea; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBottomLeft", function() { return getBottomLeft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBottomRight", function() { return getBottomRight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCenter", function() { return getCenter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCorner", function() { return getCorner; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getEnlargedArea", function() { return getEnlargedArea; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getForViewAndSize", function() { return getForViewAndSize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getHeight", function() { return getHeight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getIntersectionArea", function() { return getIntersectionArea; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getIntersection", function() { return getIntersection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMargin", function() { return getMargin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSize", function() { return getSize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTopLeft", function() { return getTopLeft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTopRight", function() { return getTopRight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getWidth", function() { return getWidth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersects", function() { return intersects; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEmpty", function() { return isEmpty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "returnOrUpdate", function() { return returnOrUpdate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleFromCenter", function() { return scaleFromCenter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersectsSegment", function() { return intersectsSegment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyTransform", function() { return applyTransform; });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _extent_Corner_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./extent/Corner.js */ "./node_modules/ol/extent/Corner.js");
/* harmony import */ var _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./extent/Relationship.js */ "./node_modules/ol/extent/Relationship.js");
/**
 * @module ol/extent
 */





/**
 * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.
 * @typedef {Array<number>} Extent
 * @api
 */

/**
 * Build an extent that includes all given coordinates.
 *
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @return {Extent} Bounding extent.
 * @api
 */
function boundingExtent(coordinates) {
  var extent = createEmpty();
  for (var i = 0, ii = coordinates.length; i < ii; ++i) {
    extendCoordinate(extent, coordinates[i]);
  }
  return extent;
}


/**
 * @param {Array<number>} xs Xs.
 * @param {Array<number>} ys Ys.
 * @param {Extent=} opt_extent Destination extent.
 * @private
 * @return {Extent} Extent.
 */
function _boundingExtentXYs(xs, ys, opt_extent) {
  var minX = Math.min.apply(null, xs);
  var minY = Math.min.apply(null, ys);
  var maxX = Math.max.apply(null, xs);
  var maxY = Math.max.apply(null, ys);
  return createOrUpdate(minX, minY, maxX, maxY, opt_extent);
}


/**
 * Return extent increased by the provided value.
 * @param {Extent} extent Extent.
 * @param {number} value The amount by which the extent should be buffered.
 * @param {Extent=} opt_extent Extent.
 * @return {Extent} Extent.
 * @api
 */
function buffer(extent, value, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent[0] - value;
    opt_extent[1] = extent[1] - value;
    opt_extent[2] = extent[2] + value;
    opt_extent[3] = extent[3] + value;
    return opt_extent;
  } else {
    return [
      extent[0] - value,
      extent[1] - value,
      extent[2] + value,
      extent[3] + value
    ];
  }
}


/**
 * Creates a clone of an extent.
 *
 * @param {Extent} extent Extent to clone.
 * @param {Extent=} opt_extent Extent.
 * @return {Extent} The clone.
 */
function clone(extent, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent[0];
    opt_extent[1] = extent[1];
    opt_extent[2] = extent[2];
    opt_extent[3] = extent[3];
    return opt_extent;
  } else {
    return extent.slice();
  }
}


/**
 * @param {Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {number} Closest squared distance.
 */
function closestSquaredDistanceXY(extent, x, y) {
  var dx, dy;
  if (x < extent[0]) {
    dx = extent[0] - x;
  } else if (extent[2] < x) {
    dx = x - extent[2];
  } else {
    dx = 0;
  }
  if (y < extent[1]) {
    dy = extent[1] - y;
  } else if (extent[3] < y) {
    dy = y - extent[3];
  } else {
    dy = 0;
  }
  return dx * dx + dy * dy;
}


/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {Extent} extent Extent.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @return {boolean} The coordinate is contained in the extent.
 * @api
 */
function containsCoordinate(extent, coordinate) {
  return containsXY(extent, coordinate[0], coordinate[1]);
}


/**
 * Check if one extent contains another.
 *
 * An extent is deemed contained if it lies completely within the other extent,
 * including if they share one or more edges.
 *
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {boolean} The second extent is contained by or on the edge of the
 *     first.
 * @api
 */
function containsExtent(extent1, extent2) {
  return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] &&
      extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
}


/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {Extent} extent Extent.
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @return {boolean} The x, y values are contained in the extent.
 * @api
 */
function containsXY(extent, x, y) {
  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
}


/**
 * Get the relationship between a coordinate and extent.
 * @param {Extent} extent The extent.
 * @param {import("./coordinate.js").Coordinate} coordinate The coordinate.
 * @return {Relationship} The relationship (bitwise compare with
 *     import("./extent/Relationship.js").Relationship).
 */
function coordinateRelationship(extent, coordinate) {
  var minX = extent[0];
  var minY = extent[1];
  var maxX = extent[2];
  var maxY = extent[3];
  var x = coordinate[0];
  var y = coordinate[1];
  var relationship = _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].UNKNOWN;
  if (x < minX) {
    relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].LEFT;
  } else if (x > maxX) {
    relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].RIGHT;
  }
  if (y < minY) {
    relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].BELOW;
  } else if (y > maxY) {
    relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].ABOVE;
  }
  if (relationship === _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].UNKNOWN) {
    relationship = _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].INTERSECTING;
  }
  return relationship;
}


/**
 * Create an empty extent.
 * @return {Extent} Empty extent.
 * @api
 */
function createEmpty() {
  return [Infinity, Infinity, -Infinity, -Infinity];
}


/**
 * Create a new extent or update the provided extent.
 * @param {number} minX Minimum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxX Maximum X.
 * @param {number} maxY Maximum Y.
 * @param {Extent=} opt_extent Destination extent.
 * @return {Extent} Extent.
 */
function createOrUpdate(minX, minY, maxX, maxY, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = minX;
    opt_extent[1] = minY;
    opt_extent[2] = maxX;
    opt_extent[3] = maxY;
    return opt_extent;
  } else {
    return [minX, minY, maxX, maxY];
  }
}


/**
 * Create a new empty extent or make the provided one empty.
 * @param {Extent=} opt_extent Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateEmpty(opt_extent) {
  return createOrUpdate(
    Infinity, Infinity, -Infinity, -Infinity, opt_extent);
}


/**
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {Extent=} opt_extent Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateFromCoordinate(coordinate, opt_extent) {
  var x = coordinate[0];
  var y = coordinate[1];
  return createOrUpdate(x, y, x, y, opt_extent);
}


/**
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @param {Extent=} opt_extent Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateFromCoordinates(coordinates, opt_extent) {
  var extent = createOrUpdateEmpty(opt_extent);
  return extendCoordinates(extent, coordinates);
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Extent=} opt_extent Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, opt_extent) {
  var extent = createOrUpdateEmpty(opt_extent);
  return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
}

/**
 * @param {Array<Array<import("./coordinate.js").Coordinate>>} rings Rings.
 * @param {Extent=} opt_extent Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateFromRings(rings, opt_extent) {
  var extent = createOrUpdateEmpty(opt_extent);
  return extendRings(extent, rings);
}


/**
 * Determine if two extents are equivalent.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {boolean} The two extents are equivalent.
 * @api
 */
function equals(extent1, extent2) {
  return extent1[0] == extent2[0] && extent1[2] == extent2[2] &&
      extent1[1] == extent2[1] && extent1[3] == extent2[3];
}


/**
 * Modify an extent to include another extent.
 * @param {Extent} extent1 The extent to be modified.
 * @param {Extent} extent2 The extent that will be included in the first.
 * @return {Extent} A reference to the first (extended) extent.
 * @api
 */
function extend(extent1, extent2) {
  if (extent2[0] < extent1[0]) {
    extent1[0] = extent2[0];
  }
  if (extent2[2] > extent1[2]) {
    extent1[2] = extent2[2];
  }
  if (extent2[1] < extent1[1]) {
    extent1[1] = extent2[1];
  }
  if (extent2[3] > extent1[3]) {
    extent1[3] = extent2[3];
  }
  return extent1;
}


/**
 * @param {Extent} extent Extent.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 */
function extendCoordinate(extent, coordinate) {
  if (coordinate[0] < extent[0]) {
    extent[0] = coordinate[0];
  }
  if (coordinate[0] > extent[2]) {
    extent[2] = coordinate[0];
  }
  if (coordinate[1] < extent[1]) {
    extent[1] = coordinate[1];
  }
  if (coordinate[1] > extent[3]) {
    extent[3] = coordinate[1];
  }
}


/**
 * @param {Extent} extent Extent.
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @return {Extent} Extent.
 */
function extendCoordinates(extent, coordinates) {
  for (var i = 0, ii = coordinates.length; i < ii; ++i) {
    extendCoordinate(extent, coordinates[i]);
  }
  return extent;
}


/**
 * @param {Extent} extent Extent.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {Extent} Extent.
 */
function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {
  for (; offset < end; offset += stride) {
    extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
  }
  return extent;
}


/**
 * @param {Extent} extent Extent.
 * @param {Array<Array<import("./coordinate.js").Coordinate>>} rings Rings.
 * @return {Extent} Extent.
 */
function extendRings(extent, rings) {
  for (var i = 0, ii = rings.length; i < ii; ++i) {
    extendCoordinates(extent, rings[i]);
  }
  return extent;
}


/**
 * @param {Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 */
function extendXY(extent, x, y) {
  extent[0] = Math.min(extent[0], x);
  extent[1] = Math.min(extent[1], y);
  extent[2] = Math.max(extent[2], x);
  extent[3] = Math.max(extent[3], y);
}


/**
 * This function calls `callback` for each corner of the extent. If the
 * callback returns a truthy value the function returns that value
 * immediately. Otherwise the function returns `false`.
 * @param {Extent} extent Extent.
 * @param {function(this:T, import("./coordinate.js").Coordinate): S} callback Callback.
 * @param {T=} opt_this Value to use as `this` when executing `callback`.
 * @return {S|boolean} Value.
 * @template S, T
 */
function forEachCorner(extent, callback, opt_this) {
  var val;
  val = callback.call(opt_this, getBottomLeft(extent));
  if (val) {
    return val;
  }
  val = callback.call(opt_this, getBottomRight(extent));
  if (val) {
    return val;
  }
  val = callback.call(opt_this, getTopRight(extent));
  if (val) {
    return val;
  }
  val = callback.call(opt_this, getTopLeft(extent));
  if (val) {
    return val;
  }
  return false;
}


/**
 * Get the size of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Area.
 * @api
 */
function getArea(extent) {
  var area = 0;
  if (!isEmpty(extent)) {
    area = getWidth(extent) * getHeight(extent);
  }
  return area;
}


/**
 * Get the bottom left coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Bottom left coordinate.
 * @api
 */
function getBottomLeft(extent) {
  return [extent[0], extent[1]];
}


/**
 * Get the bottom right coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Bottom right coordinate.
 * @api
 */
function getBottomRight(extent) {
  return [extent[2], extent[1]];
}


/**
 * Get the center coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Center.
 * @api
 */
function getCenter(extent) {
  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
}


/**
 * Get a corner coordinate of an extent.
 * @param {Extent} extent Extent.
 * @param {Corner} corner Corner.
 * @return {import("./coordinate.js").Coordinate} Corner coordinate.
 */
function getCorner(extent, corner) {
  var coordinate;
  if (corner === _extent_Corner_js__WEBPACK_IMPORTED_MODULE_1__["default"].BOTTOM_LEFT) {
    coordinate = getBottomLeft(extent);
  } else if (corner === _extent_Corner_js__WEBPACK_IMPORTED_MODULE_1__["default"].BOTTOM_RIGHT) {
    coordinate = getBottomRight(extent);
  } else if (corner === _extent_Corner_js__WEBPACK_IMPORTED_MODULE_1__["default"].TOP_LEFT) {
    coordinate = getTopLeft(extent);
  } else if (corner === _extent_Corner_js__WEBPACK_IMPORTED_MODULE_1__["default"].TOP_RIGHT) {
    coordinate = getTopRight(extent);
  } else {
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(false, 13); // Invalid corner
  }
  return coordinate;
}


/**
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {number} Enlarged area.
 */
function getEnlargedArea(extent1, extent2) {
  var minX = Math.min(extent1[0], extent2[0]);
  var minY = Math.min(extent1[1], extent2[1]);
  var maxX = Math.max(extent1[2], extent2[2]);
  var maxY = Math.max(extent1[3], extent2[3]);
  return (maxX - minX) * (maxY - minY);
}


/**
 * @param {import("./coordinate.js").Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {import("./size.js").Size} size Size.
 * @param {Extent=} opt_extent Destination extent.
 * @return {Extent} Extent.
 */
function getForViewAndSize(center, resolution, rotation, size, opt_extent) {
  var dx = resolution * size[0] / 2;
  var dy = resolution * size[1] / 2;
  var cosRotation = Math.cos(rotation);
  var sinRotation = Math.sin(rotation);
  var xCos = dx * cosRotation;
  var xSin = dx * sinRotation;
  var yCos = dy * cosRotation;
  var ySin = dy * sinRotation;
  var x = center[0];
  var y = center[1];
  var x0 = x - xCos + ySin;
  var x1 = x - xCos - ySin;
  var x2 = x + xCos - ySin;
  var x3 = x + xCos + ySin;
  var y0 = y - xSin - yCos;
  var y1 = y - xSin + yCos;
  var y2 = y + xSin + yCos;
  var y3 = y + xSin - yCos;
  return createOrUpdate(
    Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3),
    Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3),
    opt_extent);
}


/**
 * Get the height of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Height.
 * @api
 */
function getHeight(extent) {
  return extent[3] - extent[1];
}


/**
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {number} Intersection area.
 */
function getIntersectionArea(extent1, extent2) {
  var intersection = getIntersection(extent1, extent2);
  return getArea(intersection);
}


/**
 * Get the intersection of two extents.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @param {Extent=} opt_extent Optional extent to populate with intersection.
 * @return {Extent} Intersecting extent.
 * @api
 */
function getIntersection(extent1, extent2, opt_extent) {
  var intersection = opt_extent ? opt_extent : createEmpty();
  if (intersects(extent1, extent2)) {
    if (extent1[0] > extent2[0]) {
      intersection[0] = extent1[0];
    } else {
      intersection[0] = extent2[0];
    }
    if (extent1[1] > extent2[1]) {
      intersection[1] = extent1[1];
    } else {
      intersection[1] = extent2[1];
    }
    if (extent1[2] < extent2[2]) {
      intersection[2] = extent1[2];
    } else {
      intersection[2] = extent2[2];
    }
    if (extent1[3] < extent2[3]) {
      intersection[3] = extent1[3];
    } else {
      intersection[3] = extent2[3];
    }
  } else {
    createOrUpdateEmpty(intersection);
  }
  return intersection;
}


/**
 * @param {Extent} extent Extent.
 * @return {number} Margin.
 */
function getMargin(extent) {
  return getWidth(extent) + getHeight(extent);
}


/**
 * Get the size (width, height) of an extent.
 * @param {Extent} extent The extent.
 * @return {import("./size.js").Size} The extent size.
 * @api
 */
function getSize(extent) {
  return [extent[2] - extent[0], extent[3] - extent[1]];
}


/**
 * Get the top left coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Top left coordinate.
 * @api
 */
function getTopLeft(extent) {
  return [extent[0], extent[3]];
}


/**
 * Get the top right coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Top right coordinate.
 * @api
 */
function getTopRight(extent) {
  return [extent[2], extent[3]];
}


/**
 * Get the width of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Width.
 * @api
 */
function getWidth(extent) {
  return extent[2] - extent[0];
}


/**
 * Determine if one extent intersects another.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent.
 * @return {boolean} The two extents intersect.
 * @api
 */
function intersects(extent1, extent2) {
  return extent1[0] <= extent2[2] &&
      extent1[2] >= extent2[0] &&
      extent1[1] <= extent2[3] &&
      extent1[3] >= extent2[1];
}


/**
 * Determine if an extent is empty.
 * @param {Extent} extent Extent.
 * @return {boolean} Is empty.
 * @api
 */
function isEmpty(extent) {
  return extent[2] < extent[0] || extent[3] < extent[1];
}


/**
 * @param {Extent} extent Extent.
 * @param {Extent=} opt_extent Extent.
 * @return {Extent} Extent.
 */
function returnOrUpdate(extent, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent[0];
    opt_extent[1] = extent[1];
    opt_extent[2] = extent[2];
    opt_extent[3] = extent[3];
    return opt_extent;
  } else {
    return extent;
  }
}


/**
 * @param {Extent} extent Extent.
 * @param {number} value Value.
 */
function scaleFromCenter(extent, value) {
  var deltaX = ((extent[2] - extent[0]) / 2) * (value - 1);
  var deltaY = ((extent[3] - extent[1]) / 2) * (value - 1);
  extent[0] -= deltaX;
  extent[2] += deltaX;
  extent[1] -= deltaY;
  extent[3] += deltaY;
}


/**
 * Determine if the segment between two coordinates intersects (crosses,
 * touches, or is contained by) the provided extent.
 * @param {Extent} extent The extent.
 * @param {import("./coordinate.js").Coordinate} start Segment start coordinate.
 * @param {import("./coordinate.js").Coordinate} end Segment end coordinate.
 * @return {boolean} The segment intersects the extent.
 */
function intersectsSegment(extent, start, end) {
  var intersects = false;
  var startRel = coordinateRelationship(extent, start);
  var endRel = coordinateRelationship(extent, end);
  if (startRel === _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].INTERSECTING ||
      endRel === _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].INTERSECTING) {
    intersects = true;
  } else {
    var minX = extent[0];
    var minY = extent[1];
    var maxX = extent[2];
    var maxY = extent[3];
    var startX = start[0];
    var startY = start[1];
    var endX = end[0];
    var endY = end[1];
    var slope = (endY - startY) / (endX - startX);
    var x, y;
    if (!!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].ABOVE) &&
        !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].ABOVE)) {
      // potentially intersects top
      x = endX - ((endY - maxY) / slope);
      intersects = x >= minX && x <= maxX;
    }
    if (!intersects && !!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].RIGHT) &&
        !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].RIGHT)) {
      // potentially intersects right
      y = endY - ((endX - maxX) * slope);
      intersects = y >= minY && y <= maxY;
    }
    if (!intersects && !!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].BELOW) &&
        !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].BELOW)) {
      // potentially intersects bottom
      x = endX - ((endY - minY) / slope);
      intersects = x >= minX && x <= maxX;
    }
    if (!intersects && !!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].LEFT) &&
        !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].LEFT)) {
      // potentially intersects left
      y = endY - ((endX - minX) * slope);
      intersects = y >= minY && y <= maxY;
    }

  }
  return intersects;
}


/**
 * Apply a transform function to the extent.
 * @param {Extent} extent Extent.
 * @param {import("./proj.js").TransformFunction} transformFn Transform function.
 * Called with `[minX, minY, maxX, maxY]` extent coordinates.
 * @param {Extent=} opt_extent Destination extent.
 * @return {Extent} Extent.
 * @api
 */
function applyTransform(extent, transformFn, opt_extent) {
  var coordinates = [
    extent[0], extent[1],
    extent[0], extent[3],
    extent[2], extent[1],
    extent[2], extent[3]
  ];
  transformFn(coordinates, coordinates, 2);
  var xs = [coordinates[0], coordinates[2], coordinates[4], coordinates[6]];
  var ys = [coordinates[1], coordinates[3], coordinates[5], coordinates[7]];
  return _boundingExtentXYs(xs, ys, opt_extent);
}

//# sourceMappingURL=extent.js.map

/***/ }),

/***/ "./node_modules/ol/extent/Corner.js":
/*!******************************************!*\
  !*** ./node_modules/ol/extent/Corner.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/extent/Corner
 */

/**
 * Extent corner.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  BOTTOM_LEFT: 'bottom-left',
  BOTTOM_RIGHT: 'bottom-right',
  TOP_LEFT: 'top-left',
  TOP_RIGHT: 'top-right'
});

//# sourceMappingURL=Corner.js.map

/***/ }),

/***/ "./node_modules/ol/extent/Relationship.js":
/*!************************************************!*\
  !*** ./node_modules/ol/extent/Relationship.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/extent/Relationship
 */

/**
 * Relationship to an extent.
 * @enum {number}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  UNKNOWN: 0,
  INTERSECTING: 1,
  ABOVE: 2,
  RIGHT: 4,
  BELOW: 8,
  LEFT: 16
});

//# sourceMappingURL=Relationship.js.map

/***/ }),

/***/ "./node_modules/ol/featureloader.js":
/*!******************************************!*\
  !*** ./node_modules/ol/featureloader.js ***!
  \******************************************/
/*! exports provided: loadFeaturesXhr, xhr */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadFeaturesXhr", function() { return loadFeaturesXhr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xhr", function() { return xhr; });
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _format_FormatType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./format/FormatType.js */ "./node_modules/ol/format/FormatType.js");
/**
 * @module ol/featureloader
 */



/**
 * {@link module:ol/source/Vector} sources use a function of this type to
 * load features.
 *
 * This function takes an {@link module:ol/extent~Extent} representing the area to be loaded,
 * a `{number}` representing the resolution (map units per pixel) and an
 * {@link module:ol/proj/Projection} for the projection  as
 * arguments. `this` within the function is bound to the
 * {@link module:ol/source/Vector} it's called from.
 *
 * The function is responsible for loading the features and adding them to the
 * source.
 * @typedef {function(this:(import("./source/Vector").default|import("./VectorTile.js").default), import("./extent.js").Extent, number,
 *                    import("./proj/Projection.js").default)} FeatureLoader
 * @api
 */


/**
 * {@link module:ol/source/Vector} sources use a function of this type to
 * get the url to load features from.
 *
 * This function takes an {@link module:ol/extent~Extent} representing the area
 * to be loaded, a `{number}` representing the resolution (map units per pixel)
 * and an {@link module:ol/proj/Projection} for the projection  as
 * arguments and returns a `{string}` representing the URL.
 * @typedef {function(import("./extent.js").Extent, number, import("./proj/Projection.js").default): string} FeatureUrlFunction
 * @api
 */


/**
 * @param {string|FeatureUrlFunction} url Feature URL service.
 * @param {import("./format/Feature.js").default} format Feature format.
 * @param {function(this:import("./VectorTile.js").default, Array<import("./Feature.js").default>, import("./proj/Projection.js").default, import("./extent.js").Extent)|function(this:import("./source/Vector").default, Array<import("./Feature.js").default>)} success
 *     Function called with the loaded features and optionally with the data
 *     projection. Called with the vector tile or source as `this`.
 * @param {function(this:import("./VectorTile.js").default)|function(this:import("./source/Vector").default)} failure
 *     Function called when loading failed. Called with the vector tile or
 *     source as `this`.
 * @return {FeatureLoader} The feature loader.
 */
function loadFeaturesXhr(url, format, success, failure) {
  return (
    /**
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @this {import("./source/Vector").default|import("./VectorTile.js").default}
     */
    function(extent, resolution, projection) {
      var xhr = new XMLHttpRequest();
      xhr.open('GET',
        typeof url === 'function' ? url(extent, resolution, projection) : url,
        true);
      if (format.getType() == _format_FormatType_js__WEBPACK_IMPORTED_MODULE_1__["default"].ARRAY_BUFFER) {
        xhr.responseType = 'arraybuffer';
      }
      /**
       * @param {Event} event Event.
       * @private
       */
      xhr.onload = function(event) {
        // status will be 0 for file:// urls
        if (!xhr.status || xhr.status >= 200 && xhr.status < 300) {
          var type = format.getType();
          /** @type {Document|Node|Object|string|undefined} */
          var source;
          if (type == _format_FormatType_js__WEBPACK_IMPORTED_MODULE_1__["default"].JSON || type == _format_FormatType_js__WEBPACK_IMPORTED_MODULE_1__["default"].TEXT) {
            source = xhr.responseText;
          } else if (type == _format_FormatType_js__WEBPACK_IMPORTED_MODULE_1__["default"].XML) {
            source = xhr.responseXML;
            if (!source) {
              source = new DOMParser().parseFromString(xhr.responseText, 'application/xml');
            }
          } else if (type == _format_FormatType_js__WEBPACK_IMPORTED_MODULE_1__["default"].ARRAY_BUFFER) {
            source = /** @type {ArrayBuffer} */ (xhr.response);
          }
          if (source) {
            success.call(this, format.readFeatures(source,
              {featureProjection: projection}),
            format.readProjection(source), format.getLastExtent());
          } else {
            failure.call(this);
          }
        } else {
          failure.call(this);
        }
      }.bind(this);
      /**
       * @private
       */
      xhr.onerror = function() {
        failure.call(this);
      }.bind(this);
      xhr.send();
    }
  );
}


/**
 * Create an XHR feature loader for a `url` and `format`. The feature loader
 * loads features (with XHR), parses the features, and adds them to the
 * vector source.
 * @param {string|FeatureUrlFunction} url Feature URL service.
 * @param {import("./format/Feature.js").default} format Feature format.
 * @return {FeatureLoader} The feature loader.
 * @api
 */
function xhr(url, format) {
  return loadFeaturesXhr(url, format,
    /**
     * @param {Array<import("./Feature.js").default>} features The loaded features.
     * @param {import("./proj/Projection.js").default} dataProjection Data
     * projection.
     * @this {import("./source/Vector").default|import("./VectorTile.js").default}
     */
    function(features, dataProjection) {
      var sourceOrTile = /** @type {?} */ (this);
      if (typeof sourceOrTile.addFeatures === 'function') {
        /** @type {import("./source/Vector").default} */ (sourceOrTile).addFeatures(features);
      }
    }, /* FIXME handle error */ _functions_js__WEBPACK_IMPORTED_MODULE_0__["VOID"]);
}

//# sourceMappingURL=featureloader.js.map

/***/ }),

/***/ "./node_modules/ol/format/FormatType.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/format/FormatType.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/format/FormatType
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  ARRAY_BUFFER: 'arraybuffer',
  JSON: 'json',
  TEXT: 'text',
  XML: 'xml'
});

//# sourceMappingURL=FormatType.js.map

/***/ }),

/***/ "./node_modules/ol/functions.js":
/*!**************************************!*\
  !*** ./node_modules/ol/functions.js ***!
  \**************************************/
/*! exports provided: TRUE, FALSE, VOID */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TRUE", function() { return TRUE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FALSE", function() { return FALSE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VOID", function() { return VOID; });
/**
 * @module ol/functions
 */

/**
 * Always returns true.
 * @returns {boolean} true.
 */
function TRUE() {
  return true;
}

/**
 * Always returns false.
 * @returns {boolean} false.
 */
function FALSE() {
  return false;
}

/**
 * A reusable function, used e.g. as a default for callbacks.
 *
 * @return {void} Nothing.
 */
function VOID() {}

//# sourceMappingURL=functions.js.map

/***/ }),

/***/ "./node_modules/ol/geom/Circle.js":
/*!****************************************!*\
  !*** ./node_modules/ol/geom/Circle.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _GeometryType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/**
 * @module ol/geom/Circle
 */





/**
 * @classdesc
 * Circle geometry.
 *
 * @api
 */
var Circle = /*@__PURE__*/(function (SimpleGeometry) {
  function Circle(center, opt_radius, opt_layout) {
    SimpleGeometry.call(this);
    if (opt_layout !== undefined && opt_radius === undefined) {
      this.setFlatCoordinates(opt_layout, center);
    } else {
      var radius = opt_radius ? opt_radius : 0;
      this.setCenterAndRadius(center, radius, opt_layout);
    }
  }

  if ( SimpleGeometry ) Circle.__proto__ = SimpleGeometry;
  Circle.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );
  Circle.prototype.constructor = Circle;

  /**
   * Make a complete copy of the geometry.
   * @return {!Circle} Clone.
   * @override
   * @api
   */
  Circle.prototype.clone = function clone () {
    return new Circle(this.flatCoordinates.slice(), undefined, this.layout);
  };

  /**
   * @inheritDoc
   */
  Circle.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {
    var flatCoordinates = this.flatCoordinates;
    var dx = x - flatCoordinates[0];
    var dy = y - flatCoordinates[1];
    var squaredDistance = dx * dx + dy * dy;
    if (squaredDistance < minSquaredDistance) {
      if (squaredDistance === 0) {
        for (var i = 0; i < this.stride; ++i) {
          closestPoint[i] = flatCoordinates[i];
        }
      } else {
        var delta = this.getRadius() / Math.sqrt(squaredDistance);
        closestPoint[0] = flatCoordinates[0] + delta * dx;
        closestPoint[1] = flatCoordinates[1] + delta * dy;
        for (var i$1 = 2; i$1 < this.stride; ++i$1) {
          closestPoint[i$1] = flatCoordinates[i$1];
        }
      }
      closestPoint.length = this.stride;
      return squaredDistance;
    } else {
      return minSquaredDistance;
    }
  };

  /**
   * @inheritDoc
   */
  Circle.prototype.containsXY = function containsXY (x, y) {
    var flatCoordinates = this.flatCoordinates;
    var dx = x - flatCoordinates[0];
    var dy = y - flatCoordinates[1];
    return dx * dx + dy * dy <= this.getRadiusSquared_();
  };

  /**
   * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
   * @return {import("../coordinate.js").Coordinate} Center.
   * @api
   */
  Circle.prototype.getCenter = function getCenter () {
    return this.flatCoordinates.slice(0, this.stride);
  };

  /**
   * @inheritDoc
   */
  Circle.prototype.computeExtent = function computeExtent (extent) {
    var flatCoordinates = this.flatCoordinates;
    var radius = flatCoordinates[this.stride] - flatCoordinates[0];
    return Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["createOrUpdate"])(
      flatCoordinates[0] - radius, flatCoordinates[1] - radius,
      flatCoordinates[0] + radius, flatCoordinates[1] + radius,
      extent);
  };

  /**
   * Return the radius of the circle.
   * @return {number} Radius.
   * @api
   */
  Circle.prototype.getRadius = function getRadius () {
    return Math.sqrt(this.getRadiusSquared_());
  };

  /**
   * @private
   * @return {number} Radius squared.
   */
  Circle.prototype.getRadiusSquared_ = function getRadiusSquared_ () {
    var dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];
    var dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
    return dx * dx + dy * dy;
  };

  /**
   * @inheritDoc
   * @api
   */
  Circle.prototype.getType = function getType () {
    return _GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CIRCLE;
  };

  /**
   * @inheritDoc
   * @api
   */
  Circle.prototype.intersectsExtent = function intersectsExtent (extent) {
    var circleExtent = this.getExtent();
    if (Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["intersects"])(extent, circleExtent)) {
      var center = this.getCenter();

      if (extent[0] <= center[0] && extent[2] >= center[0]) {
        return true;
      }
      if (extent[1] <= center[1] && extent[3] >= center[1]) {
        return true;
      }

      return Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["forEachCorner"])(extent, this.intersectsCoordinate, this);
    }
    return false;

  };

  /**
   * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} center Center.
   * @api
   */
  Circle.prototype.setCenter = function setCenter (center) {
    var stride = this.stride;
    var radius = this.flatCoordinates[stride] - this.flatCoordinates[0];
    var flatCoordinates = center.slice();
    flatCoordinates[stride] = flatCoordinates[0] + radius;
    for (var i = 1; i < stride; ++i) {
      flatCoordinates[stride + i] = center[i];
    }
    this.setFlatCoordinates(this.layout, flatCoordinates);
    this.changed();
  };

  /**
   * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as
   * number) of the circle.
   * @param {!import("../coordinate.js").Coordinate} center Center.
   * @param {number} radius Radius.
   * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
   * @api
   */
  Circle.prototype.setCenterAndRadius = function setCenterAndRadius (center, radius, opt_layout) {
    this.setLayout(opt_layout, center, 0);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    /** @type {Array<number>} */
    var flatCoordinates = this.flatCoordinates;
    var offset = Object(_flat_deflate_js__WEBPACK_IMPORTED_MODULE_3__["deflateCoordinate"])(
      flatCoordinates, 0, center, this.stride);
    flatCoordinates[offset++] = flatCoordinates[0] + radius;
    for (var i = 1, ii = this.stride; i < ii; ++i) {
      flatCoordinates[offset++] = flatCoordinates[i];
    }
    flatCoordinates.length = offset;
    this.changed();
  };

  /**
   * @inheritDoc
   */
  Circle.prototype.getCoordinates = function getCoordinates () {
    return null;
  };

  /**
   * @inheritDoc
   */
  Circle.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {};

  /**
   * Set the radius of the circle. The radius is in the units of the projection.
   * @param {number} radius Radius.
   * @api
   */
  Circle.prototype.setRadius = function setRadius (radius) {
    this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;
    this.changed();
  };

  return Circle;
}(_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_2__["default"]));


/**
 * Transform each coordinate of the circle from one coordinate reference system
 * to another. The geometry is modified in place.
 * If you do not want the geometry modified in place, first clone() it and
 * then use this function on the clone.
 *
 * Internally a circle is currently represented by two points: the center of
 * the circle `[cx, cy]`, and the point to the right of the circle
 * `[cx + r, cy]`. This `transform` function just transforms these two points.
 * So the resulting geometry is also a circle, and that circle does not
 * correspond to the shape that would be obtained by transforming every point
 * of the original circle.
 *
 * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
 *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
 * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
 *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
 * @return {Circle} This geometry.  Note that original geometry is
 *     modified in place.
 * @function
 * @api
 */
Circle.prototype.transform;
/* harmony default export */ __webpack_exports__["default"] = (Circle);

//# sourceMappingURL=Circle.js.map

/***/ }),

/***/ "./node_modules/ol/geom/Geometry.js":
/*!******************************************!*\
  !*** ./node_modules/ol/geom/Geometry.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _flat_transform_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./flat/transform.js */ "./node_modules/ol/geom/flat/transform.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _proj_Units_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../proj/Units.js */ "./node_modules/ol/proj/Units.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/geom/Geometry
 */









/**
 * @type {import("../transform.js").Transform}
 */
var tmpTransform = Object(_transform_js__WEBPACK_IMPORTED_MODULE_6__["create"])();


/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for vector geometries.
 *
 * To get notified of changes to the geometry, register a listener for the
 * generic `change` event on your geometry instance.
 *
 * @abstract
 * @api
 */
var Geometry = /*@__PURE__*/(function (BaseObject) {
  function Geometry() {

    BaseObject.call(this);

    /**
     * @private
     * @type {import("../extent.js").Extent}
     */
    this.extent_ = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["createEmpty"])();

    /**
     * @private
     * @type {number}
     */
    this.extentRevision_ = -1;

    /**
     * @protected
     * @type {Object<string, Geometry>}
     */
    this.simplifiedGeometryCache = {};

    /**
     * @protected
     * @type {number}
     */
    this.simplifiedGeometryMaxMinSquaredTolerance = 0;

    /**
     * @protected
     * @type {number}
     */
    this.simplifiedGeometryRevision = 0;

  }

  if ( BaseObject ) Geometry.__proto__ = BaseObject;
  Geometry.prototype = Object.create( BaseObject && BaseObject.prototype );
  Geometry.prototype.constructor = Geometry;

  /**
   * Make a complete copy of the geometry.
   * @abstract
   * @return {!Geometry} Clone.
   */
  Geometry.prototype.clone = function clone () {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * @abstract
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  Geometry.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  Geometry.prototype.containsXY = function containsXY (x, y) {
    return false;
  };

  /**
   * Return the closest point of the geometry to the passed point as
   * {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} point Point.
   * @param {import("../coordinate.js").Coordinate=} opt_closestPoint Closest point.
   * @return {import("../coordinate.js").Coordinate} Closest point.
   * @api
   */
  Geometry.prototype.getClosestPoint = function getClosestPoint (point, opt_closestPoint) {
    var closestPoint = opt_closestPoint ? opt_closestPoint : [NaN, NaN];
    this.closestPointXY(point[0], point[1], closestPoint, Infinity);
    return closestPoint;
  };

  /**
   * Returns true if this geometry includes the specified coordinate. If the
   * coordinate is on the boundary of the geometry, returns false.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {boolean} Contains coordinate.
   * @api
   */
  Geometry.prototype.intersectsCoordinate = function intersectsCoordinate (coordinate) {
    return this.containsXY(coordinate[0], coordinate[1]);
  };

  /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  Geometry.prototype.computeExtent = function computeExtent (extent) {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Get the extent of the geometry.
   * @param {import("../extent.js").Extent=} opt_extent Extent.
   * @return {import("../extent.js").Extent} extent Extent.
   * @api
   */
  Geometry.prototype.getExtent = function getExtent (opt_extent) {
    if (this.extentRevision_ != this.getRevision()) {
      this.extent_ = this.computeExtent(this.extent_);
      this.extentRevision_ = this.getRevision();
    }
    return Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["returnOrUpdate"])(this.extent_, opt_extent);
  };

  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  Geometry.prototype.rotate = function rotate (angle, anchor) {
    Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number=} opt_sy The scaling factor in the y-direction (defaults to
   *     sx).
   * @param {import("../coordinate.js").Coordinate=} opt_anchor The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  Geometry.prototype.scale = function scale (sx, opt_sy, opt_anchor) {
    Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Create a simplified version of this geometry.  For linestrings, this uses
   * the the {@link
   * https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm
   * Douglas Peucker} algorithm.  For polygons, a quantization-based
   * simplification is used to preserve topology.
   * @param {number} tolerance The tolerance distance for simplification.
   * @return {Geometry} A new, simplified version of the original geometry.
   * @api
   */
  Geometry.prototype.simplify = function simplify (tolerance) {
    return this.getSimplifiedGeometry(tolerance * tolerance);
  };

  /**
   * Create a simplified version of this geometry using the Douglas Peucker
   * algorithm.
   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Geometry} Simplified geometry.
   */
  Geometry.prototype.getSimplifiedGeometry = function getSimplifiedGeometry (squaredTolerance) {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Get the type of this geometry.
   * @abstract
   * @return {import("./GeometryType.js").default} Geometry type.
   */
  Geometry.prototype.getType = function getType () {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Apply a transform function to each coordinate of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @abstract
   * @param {import("../proj.js").TransformFunction} transformFn Transform.
   */
  Geometry.prototype.applyTransform = function applyTransform (transformFn) {
    Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Test if the geometry and the passed extent intersect.
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   */
  Geometry.prototype.intersectsExtent = function intersectsExtent (extent) {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @abstract
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  Geometry.prototype.translate = function translate (deltaX, deltaY) {
    Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Transform each coordinate of the geometry from one coordinate reference
   * system to another. The geometry is modified in place.
   * For example, a line will be transformed to a line and a circle to a circle.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   *
   * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @return {Geometry} This geometry.  Note that original geometry is
   *     modified in place.
   * @api
   */
  Geometry.prototype.transform = function transform (source, destination) {
    /** @type {import("../proj/Projection.js").default} */
    var sourceProj = Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__["get"])(source);
    var transformFn = sourceProj.getUnits() == _proj_Units_js__WEBPACK_IMPORTED_MODULE_5__["default"].TILE_PIXELS ?
      function(inCoordinates, outCoordinates, stride) {
        var pixelExtent = sourceProj.getExtent();
        var projectedExtent = sourceProj.getWorldExtent();
        var scale = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["getHeight"])(projectedExtent) / Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["getHeight"])(pixelExtent);
        Object(_transform_js__WEBPACK_IMPORTED_MODULE_6__["compose"])(tmpTransform,
          projectedExtent[0], projectedExtent[3],
          scale, -scale, 0,
          0, 0);
        Object(_flat_transform_js__WEBPACK_IMPORTED_MODULE_3__["transform2D"])(inCoordinates, 0, inCoordinates.length, stride,
          tmpTransform, outCoordinates);
        return Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__["getTransform"])(sourceProj, destination)(inCoordinates, outCoordinates, stride);
      } :
      Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__["getTransform"])(sourceProj, destination);
    this.applyTransform(transformFn);
    return this;
  };

  return Geometry;
}(_Object_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (Geometry);

//# sourceMappingURL=Geometry.js.map

/***/ }),

/***/ "./node_modules/ol/geom/GeometryLayout.js":
/*!************************************************!*\
  !*** ./node_modules/ol/geom/GeometryLayout.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/geom/GeometryLayout
 */

/**
 * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')
 * or measure ('M') coordinate is available. Supported values are `'XY'`,
 * `'XYZ'`, `'XYM'`, `'XYZM'`.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  XY: 'XY',
  XYZ: 'XYZ',
  XYM: 'XYM',
  XYZM: 'XYZM'
});

//# sourceMappingURL=GeometryLayout.js.map

/***/ }),

/***/ "./node_modules/ol/geom/GeometryType.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/geom/GeometryType.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/geom/GeometryType
 */

/**
 * The geometry type. One of `'Point'`, `'LineString'`, `'LinearRing'`,
 * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,
 * `'GeometryCollection'`, `'Circle'`.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  POINT: 'Point',
  LINE_STRING: 'LineString',
  LINEAR_RING: 'LinearRing',
  POLYGON: 'Polygon',
  MULTI_POINT: 'MultiPoint',
  MULTI_LINE_STRING: 'MultiLineString',
  MULTI_POLYGON: 'MultiPolygon',
  GEOMETRY_COLLECTION: 'GeometryCollection',
  CIRCLE: 'Circle'
});

//# sourceMappingURL=GeometryType.js.map

/***/ }),

/***/ "./node_modules/ol/geom/LineString.js":
/*!********************************************!*\
  !*** ./node_modules/ol/geom/LineString.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GeometryLayout.js */ "./node_modules/ol/geom/GeometryLayout.js");
/* harmony import */ var _GeometryType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _flat_closest_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./flat/closest.js */ "./node_modules/ol/geom/flat/closest.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _flat_inflate_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _flat_interpolate_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./flat/interpolate.js */ "./node_modules/ol/geom/flat/interpolate.js");
/* harmony import */ var _flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./flat/intersectsextent.js */ "./node_modules/ol/geom/flat/intersectsextent.js");
/* harmony import */ var _flat_length_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./flat/length.js */ "./node_modules/ol/geom/flat/length.js");
/* harmony import */ var _flat_segments_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./flat/segments.js */ "./node_modules/ol/geom/flat/segments.js");
/* harmony import */ var _flat_simplify_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./flat/simplify.js */ "./node_modules/ol/geom/flat/simplify.js");
/**
 * @module ol/geom/LineString
 */














/**
 * @classdesc
 * Linestring geometry.
 *
 * @api
 */
var LineString = /*@__PURE__*/(function (SimpleGeometry) {
  function LineString(coordinates, opt_layout) {

    SimpleGeometry.call(this);

    /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */
    this.flatMidpoint_ = null;

    /**
     * @private
     * @type {number}
     */
    this.flatMidpointRevision_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.maxDelta_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.maxDeltaRevision_ = -1;

    if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {
      this.setFlatCoordinates(opt_layout, /** @type {Array<number>} */ (coordinates));
    } else {
      this.setCoordinates(/** @type {Array<import("../coordinate.js").Coordinate>} */ (coordinates), opt_layout);
    }

  }

  if ( SimpleGeometry ) LineString.__proto__ = SimpleGeometry;
  LineString.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );
  LineString.prototype.constructor = LineString;

  /**
   * Append the passed coordinate to the coordinates of the linestring.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @api
   */
  LineString.prototype.appendCoordinate = function appendCoordinate (coordinate) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = coordinate.slice();
    } else {
      Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(this.flatCoordinates, coordinate);
    }
    this.changed();
  };

  /**
   * Make a complete copy of the geometry.
   * @return {!LineString} Clone.
   * @override
   * @api
   */
  LineString.prototype.clone = function clone () {
    return new LineString(this.flatCoordinates.slice(), this.layout);
  };

  /**
   * @inheritDoc
   */
  LineString.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["closestSquaredDistanceXY"])(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(Object(_flat_closest_js__WEBPACK_IMPORTED_MODULE_5__["maxSquaredDelta"])(
        this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
      this.maxDeltaRevision_ = this.getRevision();
    }
    return Object(_flat_closest_js__WEBPACK_IMPORTED_MODULE_5__["assignClosestPoint"])(
      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,
      this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
  };

  /**
   * Iterate over each segment, calling the provided callback.
   * If the callback returns a truthy value the function returns that
   * value immediately. Otherwise the function returns `false`.
   *
   * @param {function(this: S, import("../coordinate.js").Coordinate, import("../coordinate.js").Coordinate): T} callback Function
   *     called for each segment.
   * @return {T|boolean} Value.
   * @template T,S
   * @api
   */
  LineString.prototype.forEachSegment = function forEachSegment$1 (callback) {
    return Object(_flat_segments_js__WEBPACK_IMPORTED_MODULE_11__["forEach"])(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, callback);
  };

  /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `opt_extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * @param {number} m M.
   * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate} Coordinate.
   * @api
   */
  LineString.prototype.getCoordinateAtM = function getCoordinateAtM (m, opt_extrapolate) {
    if (this.layout != _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__["default"].XYM &&
        this.layout != _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__["default"].XYZM) {
      return null;
    }
    var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;
    return Object(_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_8__["lineStringCoordinateAtM"])(this.flatCoordinates, 0,
      this.flatCoordinates.length, this.stride, m, extrapolate);
  };

  /**
   * Return the coordinates of the linestring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @override
   * @api
   */
  LineString.prototype.getCoordinates = function getCoordinates () {
    return Object(_flat_inflate_js__WEBPACK_IMPORTED_MODULE_7__["inflateCoordinates"])(
      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
  };

  /**
   * Return the coordinate at the provided fraction along the linestring.
   * The `fraction` is a number between 0 and 1, where 0 is the start of the
   * linestring and 1 is the end.
   * @param {number} fraction Fraction.
   * @param {import("../coordinate.js").Coordinate=} opt_dest Optional coordinate whose values will
   *     be modified. If not provided, a new coordinate will be returned.
   * @return {import("../coordinate.js").Coordinate} Coordinate of the interpolated point.
   * @api
   */
  LineString.prototype.getCoordinateAt = function getCoordinateAt (fraction, opt_dest) {
    return Object(_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_8__["interpolatePoint"])(
      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,
      fraction, opt_dest);
  };

  /**
   * Return the length of the linestring on projected plane.
   * @return {number} Length (on projected plane).
   * @api
   */
  LineString.prototype.getLength = function getLength () {
    return Object(_flat_length_js__WEBPACK_IMPORTED_MODULE_10__["lineStringLength"])(
      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
  };

  /**
   * @return {Array<number>} Flat midpoint.
   */
  LineString.prototype.getFlatMidpoint = function getFlatMidpoint () {
    if (this.flatMidpointRevision_ != this.getRevision()) {
      this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);
      this.flatMidpointRevision_ = this.getRevision();
    }
    return this.flatMidpoint_;
  };

  /**
   * @inheritDoc
   */
  LineString.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {
    var simplifiedFlatCoordinates = [];
    simplifiedFlatCoordinates.length = Object(_flat_simplify_js__WEBPACK_IMPORTED_MODULE_12__["douglasPeucker"])(
      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,
      squaredTolerance, simplifiedFlatCoordinates, 0);
    return new LineString(simplifiedFlatCoordinates, _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__["default"].XY);
  };

  /**
   * @inheritDoc
   * @api
   */
  LineString.prototype.getType = function getType () {
    return _GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].LINE_STRING;
  };

  /**
   * @inheritDoc
   * @api
   */
  LineString.prototype.intersectsExtent = function intersectsExtent (extent) {
    return Object(_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_9__["intersectsLineString"])(
      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,
      extent);
  };

  /**
   * Set the coordinates of the linestring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {GeometryLayout=} opt_layout Layout.
   * @override
   * @api
   */
  LineString.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 1);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = Object(_flat_deflate_js__WEBPACK_IMPORTED_MODULE_6__["deflateCoordinates"])(
      this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  };

  return LineString;
}(_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_4__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (LineString);

//# sourceMappingURL=LineString.js.map

/***/ }),

/***/ "./node_modules/ol/geom/LinearRing.js":
/*!********************************************!*\
  !*** ./node_modules/ol/geom/LinearRing.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GeometryLayout.js */ "./node_modules/ol/geom/GeometryLayout.js");
/* harmony import */ var _GeometryType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _flat_area_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./flat/area.js */ "./node_modules/ol/geom/flat/area.js");
/* harmony import */ var _flat_closest_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./flat/closest.js */ "./node_modules/ol/geom/flat/closest.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _flat_inflate_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _flat_simplify_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./flat/simplify.js */ "./node_modules/ol/geom/flat/simplify.js");
/**
 * @module ol/geom/LinearRing
 */










/**
 * @classdesc
 * Linear ring geometry. Only used as part of polygon; cannot be rendered
 * on its own.
 *
 * @api
 */
var LinearRing = /*@__PURE__*/(function (SimpleGeometry) {
  function LinearRing(coordinates, opt_layout) {

    SimpleGeometry.call(this);

    /**
     * @private
     * @type {number}
     */
    this.maxDelta_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.maxDeltaRevision_ = -1;

    if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {
      this.setFlatCoordinates(opt_layout, /** @type {Array<number>} */ (coordinates));
    } else {
      this.setCoordinates(/** @type {Array<import("../coordinate.js").Coordinate>} */ (coordinates), opt_layout);
    }

  }

  if ( SimpleGeometry ) LinearRing.__proto__ = SimpleGeometry;
  LinearRing.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );
  LinearRing.prototype.constructor = LinearRing;

  /**
   * Make a complete copy of the geometry.
   * @return {!LinearRing} Clone.
   * @override
   * @api
   */
  LinearRing.prototype.clone = function clone () {
    return new LinearRing(this.flatCoordinates.slice(), this.layout);
  };

  /**
   * @inheritDoc
   */
  LinearRing.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["closestSquaredDistanceXY"])(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(Object(_flat_closest_js__WEBPACK_IMPORTED_MODULE_5__["maxSquaredDelta"])(
        this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
      this.maxDeltaRevision_ = this.getRevision();
    }
    return Object(_flat_closest_js__WEBPACK_IMPORTED_MODULE_5__["assignClosestPoint"])(
      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,
      this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
  };

  /**
   * Return the area of the linear ring on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  LinearRing.prototype.getArea = function getArea () {
    return Object(_flat_area_js__WEBPACK_IMPORTED_MODULE_4__["linearRing"])(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
  };

  /**
   * Return the coordinates of the linear ring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @override
   * @api
   */
  LinearRing.prototype.getCoordinates = function getCoordinates () {
    return Object(_flat_inflate_js__WEBPACK_IMPORTED_MODULE_7__["inflateCoordinates"])(
      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
  };

  /**
   * @inheritDoc
   */
  LinearRing.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {
    var simplifiedFlatCoordinates = [];
    simplifiedFlatCoordinates.length = Object(_flat_simplify_js__WEBPACK_IMPORTED_MODULE_8__["douglasPeucker"])(
      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,
      squaredTolerance, simplifiedFlatCoordinates, 0);
    return new LinearRing(simplifiedFlatCoordinates, _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_1__["default"].XY);
  };

  /**
   * @inheritDoc
   * @api
   */
  LinearRing.prototype.getType = function getType () {
    return _GeometryType_js__WEBPACK_IMPORTED_MODULE_2__["default"].LINEAR_RING;
  };

  /**
   * @inheritDoc
   */
  LinearRing.prototype.intersectsExtent = function intersectsExtent (extent) {
    return false;
  };

  /**
   * Set the coordinates of the linear ring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {GeometryLayout=} opt_layout Layout.
   * @override
   * @api
   */
  LinearRing.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 1);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = Object(_flat_deflate_js__WEBPACK_IMPORTED_MODULE_6__["deflateCoordinates"])(
      this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  };

  return LinearRing;
}(_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_3__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (LinearRing);

//# sourceMappingURL=LinearRing.js.map

/***/ }),

/***/ "./node_modules/ol/geom/MultiLineString.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/geom/MultiLineString.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GeometryLayout.js */ "./node_modules/ol/geom/GeometryLayout.js");
/* harmony import */ var _GeometryType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _LineString_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./LineString.js */ "./node_modules/ol/geom/LineString.js");
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _flat_closest_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./flat/closest.js */ "./node_modules/ol/geom/flat/closest.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _flat_inflate_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _flat_interpolate_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./flat/interpolate.js */ "./node_modules/ol/geom/flat/interpolate.js");
/* harmony import */ var _flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./flat/intersectsextent.js */ "./node_modules/ol/geom/flat/intersectsextent.js");
/* harmony import */ var _flat_simplify_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./flat/simplify.js */ "./node_modules/ol/geom/flat/simplify.js");
/**
 * @module ol/geom/MultiLineString
 */













/**
 * @classdesc
 * Multi-linestring geometry.
 *
 * @api
 */
var MultiLineString = /*@__PURE__*/(function (SimpleGeometry) {
  function MultiLineString(coordinates, opt_layout, opt_ends) {

    SimpleGeometry.call(this);

    /**
     * @type {Array<number>}
     * @private
     */
    this.ends_ = [];

    /**
     * @private
     * @type {number}
     */
    this.maxDelta_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.maxDeltaRevision_ = -1;

    if (Array.isArray(coordinates[0])) {
      this.setCoordinates(/** @type {Array<Array<import("../coordinate.js").Coordinate>>} */ (coordinates), opt_layout);
    } else if (opt_layout !== undefined && opt_ends) {
      this.setFlatCoordinates(opt_layout, /** @type {Array<number>} */ (coordinates));
      this.ends_ = opt_ends;
    } else {
      var layout = this.getLayout();
      var lineStrings = /** @type {Array<LineString>} */ (coordinates);
      var flatCoordinates = [];
      var ends = [];
      for (var i = 0, ii = lineStrings.length; i < ii; ++i) {
        var lineString = lineStrings[i];
        if (i === 0) {
          layout = lineString.getLayout();
        }
        Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(flatCoordinates, lineString.getFlatCoordinates());
        ends.push(flatCoordinates.length);
      }
      this.setFlatCoordinates(layout, flatCoordinates);
      this.ends_ = ends;
    }

  }

  if ( SimpleGeometry ) MultiLineString.__proto__ = SimpleGeometry;
  MultiLineString.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );
  MultiLineString.prototype.constructor = MultiLineString;

  /**
   * Append the passed linestring to the multilinestring.
   * @param {LineString} lineString LineString.
   * @api
   */
  MultiLineString.prototype.appendLineString = function appendLineString (lineString) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = lineString.getFlatCoordinates().slice();
    } else {
      Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(this.flatCoordinates, lineString.getFlatCoordinates().slice());
    }
    this.ends_.push(this.flatCoordinates.length);
    this.changed();
  };

  /**
   * Make a complete copy of the geometry.
   * @return {!MultiLineString} Clone.
   * @override
   * @api
   */
  MultiLineString.prototype.clone = function clone () {
    return new MultiLineString(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
  };

  /**
   * @inheritDoc
   */
  MultiLineString.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["closestSquaredDistanceXY"])(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(Object(_flat_closest_js__WEBPACK_IMPORTED_MODULE_6__["arrayMaxSquaredDelta"])(
        this.flatCoordinates, 0, this.ends_, this.stride, 0));
      this.maxDeltaRevision_ = this.getRevision();
    }
    return Object(_flat_closest_js__WEBPACK_IMPORTED_MODULE_6__["assignClosestArrayPoint"])(
      this.flatCoordinates, 0, this.ends_, this.stride,
      this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
  };

  /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `opt_extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * `opt_interpolate` controls interpolation between consecutive LineStrings
   * within the MultiLineString. If `opt_interpolate` is `true` the coordinates
   * will be linearly interpolated between the last coordinate of one LineString
   * and the first coordinate of the next LineString.  If `opt_interpolate` is
   * `false` then the function will return `null` for Ms falling between
   * LineStrings.
   *
   * @param {number} m M.
   * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.
   * @param {boolean=} opt_interpolate Interpolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate} Coordinate.
   * @api
   */
  MultiLineString.prototype.getCoordinateAtM = function getCoordinateAtM (m, opt_extrapolate, opt_interpolate) {
    if ((this.layout != _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__["default"].XYM &&
         this.layout != _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__["default"].XYZM) ||
        this.flatCoordinates.length === 0) {
      return null;
    }
    var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;
    var interpolate = opt_interpolate !== undefined ? opt_interpolate : false;
    return Object(_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_9__["lineStringsCoordinateAtM"])(this.flatCoordinates, 0,
      this.ends_, this.stride, m, extrapolate, interpolate);
  };

  /**
   * Return the coordinates of the multilinestring.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @override
   * @api
   */
  MultiLineString.prototype.getCoordinates = function getCoordinates () {
    return Object(_flat_inflate_js__WEBPACK_IMPORTED_MODULE_8__["inflateCoordinatesArray"])(
      this.flatCoordinates, 0, this.ends_, this.stride);
  };

  /**
   * @return {Array<number>} Ends.
   */
  MultiLineString.prototype.getEnds = function getEnds () {
    return this.ends_;
  };

  /**
   * Return the linestring at the specified index.
   * @param {number} index Index.
   * @return {LineString} LineString.
   * @api
   */
  MultiLineString.prototype.getLineString = function getLineString (index) {
    if (index < 0 || this.ends_.length <= index) {
      return null;
    }
    return new _LineString_js__WEBPACK_IMPORTED_MODULE_4__["default"](this.flatCoordinates.slice(
      index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
  };

  /**
   * Return the linestrings of this multilinestring.
   * @return {Array<LineString>} LineStrings.
   * @api
   */
  MultiLineString.prototype.getLineStrings = function getLineStrings () {
    var flatCoordinates = this.flatCoordinates;
    var ends = this.ends_;
    var layout = this.layout;
    /** @type {Array<LineString>} */
    var lineStrings = [];
    var offset = 0;
    for (var i = 0, ii = ends.length; i < ii; ++i) {
      var end = ends[i];
      var lineString = new _LineString_js__WEBPACK_IMPORTED_MODULE_4__["default"](flatCoordinates.slice(offset, end), layout);
      lineStrings.push(lineString);
      offset = end;
    }
    return lineStrings;
  };

  /**
   * @return {Array<number>} Flat midpoints.
   */
  MultiLineString.prototype.getFlatMidpoints = function getFlatMidpoints () {
    var midpoints = [];
    var flatCoordinates = this.flatCoordinates;
    var offset = 0;
    var ends = this.ends_;
    var stride = this.stride;
    for (var i = 0, ii = ends.length; i < ii; ++i) {
      var end = ends[i];
      var midpoint = Object(_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_9__["interpolatePoint"])(
        flatCoordinates, offset, end, stride, 0.5);
      Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(midpoints, midpoint);
      offset = end;
    }
    return midpoints;
  };

  /**
   * @inheritDoc
   */
  MultiLineString.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {
    var simplifiedFlatCoordinates = [];
    var simplifiedEnds = [];
    simplifiedFlatCoordinates.length = Object(_flat_simplify_js__WEBPACK_IMPORTED_MODULE_11__["douglasPeuckerArray"])(
      this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance,
      simplifiedFlatCoordinates, 0, simplifiedEnds);
    return new MultiLineString(simplifiedFlatCoordinates, _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__["default"].XY, simplifiedEnds);
  };

  /**
   * @inheritDoc
   * @api
   */
  MultiLineString.prototype.getType = function getType () {
    return _GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].MULTI_LINE_STRING;
  };

  /**
   * @inheritDoc
   * @api
   */
  MultiLineString.prototype.intersectsExtent = function intersectsExtent (extent) {
    return Object(_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_10__["intersectsLineStringArray"])(
      this.flatCoordinates, 0, this.ends_, this.stride, extent);
  };

  /**
   * Set the coordinates of the multilinestring.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {GeometryLayout=} opt_layout Layout.
   * @override
   * @api
   */
  MultiLineString.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 2);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    var ends = Object(_flat_deflate_js__WEBPACK_IMPORTED_MODULE_7__["deflateCoordinatesArray"])(
      this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
    this.changed();
  };

  return MultiLineString;
}(_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_5__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (MultiLineString);

//# sourceMappingURL=MultiLineString.js.map

/***/ }),

/***/ "./node_modules/ol/geom/MultiPoint.js":
/*!********************************************!*\
  !*** ./node_modules/ol/geom/MultiPoint.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _GeometryType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _Point_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Point.js */ "./node_modules/ol/geom/Point.js");
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _flat_inflate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/geom/MultiPoint
 */









/**
 * @classdesc
 * Multi-point geometry.
 *
 * @api
 */
var MultiPoint = /*@__PURE__*/(function (SimpleGeometry) {
  function MultiPoint(coordinates, opt_layout) {
    SimpleGeometry.call(this);
    if (opt_layout && !Array.isArray(coordinates[0])) {
      this.setFlatCoordinates(opt_layout, /** @type {Array<number>} */ (coordinates));
    } else {
      this.setCoordinates(/** @type {Array<import("../coordinate.js").Coordinate>} */ (coordinates), opt_layout);
    }
  }

  if ( SimpleGeometry ) MultiPoint.__proto__ = SimpleGeometry;
  MultiPoint.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );
  MultiPoint.prototype.constructor = MultiPoint;

  /**
   * Append the passed point to this multipoint.
   * @param {Point} point Point.
   * @api
   */
  MultiPoint.prototype.appendPoint = function appendPoint (point) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = point.getFlatCoordinates().slice();
    } else {
      Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(this.flatCoordinates, point.getFlatCoordinates());
    }
    this.changed();
  };

  /**
   * Make a complete copy of the geometry.
   * @return {!MultiPoint} Clone.
   * @override
   * @api
   */
  MultiPoint.prototype.clone = function clone () {
    var multiPoint = new MultiPoint(this.flatCoordinates.slice(), this.layout);
    return multiPoint;
  };

  /**
   * @inheritDoc
   */
  MultiPoint.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["closestSquaredDistanceXY"])(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    var flatCoordinates = this.flatCoordinates;
    var stride = this.stride;
    for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
      var squaredDistance = Object(_math_js__WEBPACK_IMPORTED_MODULE_7__["squaredDistance"])(
        x, y, flatCoordinates[i], flatCoordinates[i + 1]);
      if (squaredDistance < minSquaredDistance) {
        minSquaredDistance = squaredDistance;
        for (var j = 0; j < stride; ++j) {
          closestPoint[j] = flatCoordinates[i + j];
        }
        closestPoint.length = stride;
      }
    }
    return minSquaredDistance;
  };

  /**
   * Return the coordinates of the multipoint.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @override
   * @api
   */
  MultiPoint.prototype.getCoordinates = function getCoordinates () {
    return Object(_flat_inflate_js__WEBPACK_IMPORTED_MODULE_6__["inflateCoordinates"])(
      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
  };

  /**
   * Return the point at the specified index.
   * @param {number} index Index.
   * @return {Point} Point.
   * @api
   */
  MultiPoint.prototype.getPoint = function getPoint (index) {
    var n = !this.flatCoordinates ? 0 : this.flatCoordinates.length / this.stride;
    if (index < 0 || n <= index) {
      return null;
    }
    return new _Point_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.flatCoordinates.slice(
      index * this.stride, (index + 1) * this.stride), this.layout);
  };

  /**
   * Return the points of this multipoint.
   * @return {Array<Point>} Points.
   * @api
   */
  MultiPoint.prototype.getPoints = function getPoints () {
    var flatCoordinates = this.flatCoordinates;
    var layout = this.layout;
    var stride = this.stride;
    /** @type {Array<Point>} */
    var points = [];
    for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
      var point = new _Point_js__WEBPACK_IMPORTED_MODULE_3__["default"](flatCoordinates.slice(i, i + stride), layout);
      points.push(point);
    }
    return points;
  };

  /**
   * @inheritDoc
   * @api
   */
  MultiPoint.prototype.getType = function getType () {
    return _GeometryType_js__WEBPACK_IMPORTED_MODULE_2__["default"].MULTI_POINT;
  };

  /**
   * @inheritDoc
   * @api
   */
  MultiPoint.prototype.intersectsExtent = function intersectsExtent (extent) {
    var flatCoordinates = this.flatCoordinates;
    var stride = this.stride;
    for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
      var x = flatCoordinates[i];
      var y = flatCoordinates[i + 1];
      if (Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["containsXY"])(extent, x, y)) {
        return true;
      }
    }
    return false;
  };

  /**
   * Set the coordinates of the multipoint.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
   * @override
   * @api
   */
  MultiPoint.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 1);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = Object(_flat_deflate_js__WEBPACK_IMPORTED_MODULE_5__["deflateCoordinates"])(
      this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  };

  return MultiPoint;
}(_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_4__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (MultiPoint);

//# sourceMappingURL=MultiPoint.js.map

/***/ }),

/***/ "./node_modules/ol/geom/MultiPolygon.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/geom/MultiPolygon.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GeometryLayout.js */ "./node_modules/ol/geom/GeometryLayout.js");
/* harmony import */ var _GeometryType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _MultiPoint_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MultiPoint.js */ "./node_modules/ol/geom/MultiPoint.js");
/* harmony import */ var _Polygon_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Polygon.js */ "./node_modules/ol/geom/Polygon.js");
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _flat_area_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./flat/area.js */ "./node_modules/ol/geom/flat/area.js");
/* harmony import */ var _flat_center_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./flat/center.js */ "./node_modules/ol/geom/flat/center.js");
/* harmony import */ var _flat_closest_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./flat/closest.js */ "./node_modules/ol/geom/flat/closest.js");
/* harmony import */ var _flat_contains_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./flat/contains.js */ "./node_modules/ol/geom/flat/contains.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _flat_inflate_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _flat_interiorpoint_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./flat/interiorpoint.js */ "./node_modules/ol/geom/flat/interiorpoint.js");
/* harmony import */ var _flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./flat/intersectsextent.js */ "./node_modules/ol/geom/flat/intersectsextent.js");
/* harmony import */ var _flat_orient_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./flat/orient.js */ "./node_modules/ol/geom/flat/orient.js");
/* harmony import */ var _flat_simplify_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./flat/simplify.js */ "./node_modules/ol/geom/flat/simplify.js");
/**
 * @module ol/geom/MultiPolygon
 */


















/**
 * @classdesc
 * Multi-polygon geometry.
 *
 * @api
 */
var MultiPolygon = /*@__PURE__*/(function (SimpleGeometry) {
  function MultiPolygon(coordinates, opt_layout, opt_endss) {

    SimpleGeometry.call(this);

    /**
     * @type {Array<Array<number>>}
     * @private
     */
    this.endss_ = [];

    /**
     * @private
     * @type {number}
     */
    this.flatInteriorPointsRevision_ = -1;

    /**
     * @private
     * @type {Array<number>}
     */
    this.flatInteriorPoints_ = null;

    /**
     * @private
     * @type {number}
     */
    this.maxDelta_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.maxDeltaRevision_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.orientedRevision_ = -1;

    /**
     * @private
     * @type {Array<number>}
     */
    this.orientedFlatCoordinates_ = null;

    if (!opt_endss && !Array.isArray(coordinates[0])) {
      var layout = this.getLayout();
      var polygons = /** @type {Array<Polygon>} */ (coordinates);
      var flatCoordinates = [];
      var endss = [];
      for (var i = 0, ii = polygons.length; i < ii; ++i) {
        var polygon = polygons[i];
        if (i === 0) {
          layout = polygon.getLayout();
        }
        var offset = flatCoordinates.length;
        var ends = polygon.getEnds();
        for (var j = 0, jj = ends.length; j < jj; ++j) {
          ends[j] += offset;
        }
        Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(flatCoordinates, polygon.getFlatCoordinates());
        endss.push(ends);
      }
      opt_layout = layout;
      coordinates = flatCoordinates;
      opt_endss = endss;
    }
    if (opt_layout !== undefined && opt_endss) {
      this.setFlatCoordinates(opt_layout, /** @type {Array<number>} */ (coordinates));
      this.endss_ = opt_endss;
    } else {
      this.setCoordinates(/** @type {Array<Array<Array<import("../coordinate.js").Coordinate>>>} */ (coordinates),
        opt_layout);
    }

  }

  if ( SimpleGeometry ) MultiPolygon.__proto__ = SimpleGeometry;
  MultiPolygon.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );
  MultiPolygon.prototype.constructor = MultiPolygon;

  /**
   * Append the passed polygon to this multipolygon.
   * @param {Polygon} polygon Polygon.
   * @api
   */
  MultiPolygon.prototype.appendPolygon = function appendPolygon (polygon) {
    /** @type {Array<number>} */
    var ends;
    if (!this.flatCoordinates) {
      this.flatCoordinates = polygon.getFlatCoordinates().slice();
      ends = polygon.getEnds().slice();
      this.endss_.push();
    } else {
      var offset = this.flatCoordinates.length;
      Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(this.flatCoordinates, polygon.getFlatCoordinates());
      ends = polygon.getEnds().slice();
      for (var i = 0, ii = ends.length; i < ii; ++i) {
        ends[i] += offset;
      }
    }
    this.endss_.push(ends);
    this.changed();
  };

  /**
   * Make a complete copy of the geometry.
   * @return {!MultiPolygon} Clone.
   * @override
   * @api
   */
  MultiPolygon.prototype.clone = function clone () {
    var len = this.endss_.length;
    var newEndss = new Array(len);
    for (var i = 0; i < len; ++i) {
      newEndss[i] = this.endss_[i].slice();
    }

    return new MultiPolygon(
      this.flatCoordinates.slice(), this.layout, newEndss);
  };

  /**
   * @inheritDoc
   */
  MultiPolygon.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["closestSquaredDistanceXY"])(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(Object(_flat_closest_js__WEBPACK_IMPORTED_MODULE_9__["multiArrayMaxSquaredDelta"])(
        this.flatCoordinates, 0, this.endss_, this.stride, 0));
      this.maxDeltaRevision_ = this.getRevision();
    }
    return Object(_flat_closest_js__WEBPACK_IMPORTED_MODULE_9__["assignClosestMultiArrayPoint"])(
      this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride,
      this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
  };

  /**
   * @inheritDoc
   */
  MultiPolygon.prototype.containsXY = function containsXY (x, y) {
    return Object(_flat_contains_js__WEBPACK_IMPORTED_MODULE_10__["linearRingssContainsXY"])(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);
  };

  /**
   * Return the area of the multipolygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  MultiPolygon.prototype.getArea = function getArea () {
    return Object(_flat_area_js__WEBPACK_IMPORTED_MODULE_7__["linearRingss"])(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);
  };

  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for multi-polygons.
   *
   * @param {boolean=} opt_right Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<Array<import("../coordinate.js").Coordinate>>>} Coordinates.
   * @override
   * @api
   */
  MultiPolygon.prototype.getCoordinates = function getCoordinates (opt_right) {
    var flatCoordinates;
    if (opt_right !== undefined) {
      flatCoordinates = this.getOrientedFlatCoordinates().slice();
      Object(_flat_orient_js__WEBPACK_IMPORTED_MODULE_15__["orientLinearRingsArray"])(
        flatCoordinates, 0, this.endss_, this.stride, opt_right);
    } else {
      flatCoordinates = this.flatCoordinates;
    }

    return Object(_flat_inflate_js__WEBPACK_IMPORTED_MODULE_12__["inflateMultiCoordinatesArray"])(
      flatCoordinates, 0, this.endss_, this.stride);
  };

  /**
   * @return {Array<Array<number>>} Endss.
   */
  MultiPolygon.prototype.getEndss = function getEndss () {
    return this.endss_;
  };

  /**
   * @return {Array<number>} Flat interior points.
   */
  MultiPolygon.prototype.getFlatInteriorPoints = function getFlatInteriorPoints () {
    if (this.flatInteriorPointsRevision_ != this.getRevision()) {
      var flatCenters = Object(_flat_center_js__WEBPACK_IMPORTED_MODULE_8__["linearRingss"])(
        this.flatCoordinates, 0, this.endss_, this.stride);
      this.flatInteriorPoints_ = Object(_flat_interiorpoint_js__WEBPACK_IMPORTED_MODULE_13__["getInteriorPointsOfMultiArray"])(
        this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride,
        flatCenters);
      this.flatInteriorPointsRevision_ = this.getRevision();
    }
    return this.flatInteriorPoints_;
  };

  /**
   * Return the interior points as {@link module:ol/geom/MultiPoint multipoint}.
   * @return {MultiPoint} Interior points as XYM coordinates, where M is
   * the length of the horizontal intersection that the point belongs to.
   * @api
   */
  MultiPolygon.prototype.getInteriorPoints = function getInteriorPoints () {
    return new _MultiPoint_js__WEBPACK_IMPORTED_MODULE_4__["default"](this.getFlatInteriorPoints().slice(), _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__["default"].XYM);
  };

  /**
   * @return {Array<number>} Oriented flat coordinates.
   */
  MultiPolygon.prototype.getOrientedFlatCoordinates = function getOrientedFlatCoordinates () {
    if (this.orientedRevision_ != this.getRevision()) {
      var flatCoordinates = this.flatCoordinates;
      if (Object(_flat_orient_js__WEBPACK_IMPORTED_MODULE_15__["linearRingsAreOriented"])(
        flatCoordinates, 0, this.endss_, this.stride)) {
        this.orientedFlatCoordinates_ = flatCoordinates;
      } else {
        this.orientedFlatCoordinates_ = flatCoordinates.slice();
        this.orientedFlatCoordinates_.length =
            Object(_flat_orient_js__WEBPACK_IMPORTED_MODULE_15__["orientLinearRingsArray"])(
              this.orientedFlatCoordinates_, 0, this.endss_, this.stride);
      }
      this.orientedRevision_ = this.getRevision();
    }
    return this.orientedFlatCoordinates_;
  };

  /**
   * @inheritDoc
   */
  MultiPolygon.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {
    var simplifiedFlatCoordinates = [];
    var simplifiedEndss = [];
    simplifiedFlatCoordinates.length = Object(_flat_simplify_js__WEBPACK_IMPORTED_MODULE_16__["quantizeMultiArray"])(
      this.flatCoordinates, 0, this.endss_, this.stride,
      Math.sqrt(squaredTolerance),
      simplifiedFlatCoordinates, 0, simplifiedEndss);
    return new MultiPolygon(simplifiedFlatCoordinates, _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__["default"].XY, simplifiedEndss);
  };

  /**
   * Return the polygon at the specified index.
   * @param {number} index Index.
   * @return {Polygon} Polygon.
   * @api
   */
  MultiPolygon.prototype.getPolygon = function getPolygon (index) {
    if (index < 0 || this.endss_.length <= index) {
      return null;
    }
    var offset;
    if (index === 0) {
      offset = 0;
    } else {
      var prevEnds = this.endss_[index - 1];
      offset = prevEnds[prevEnds.length - 1];
    }
    var ends = this.endss_[index].slice();
    var end = ends[ends.length - 1];
    if (offset !== 0) {
      for (var i = 0, ii = ends.length; i < ii; ++i) {
        ends[i] -= offset;
      }
    }
    return new _Polygon_js__WEBPACK_IMPORTED_MODULE_5__["default"](this.flatCoordinates.slice(offset, end), this.layout, ends);
  };

  /**
   * Return the polygons of this multipolygon.
   * @return {Array<Polygon>} Polygons.
   * @api
   */
  MultiPolygon.prototype.getPolygons = function getPolygons () {
    var layout = this.layout;
    var flatCoordinates = this.flatCoordinates;
    var endss = this.endss_;
    var polygons = [];
    var offset = 0;
    for (var i = 0, ii = endss.length; i < ii; ++i) {
      var ends = endss[i].slice();
      var end = ends[ends.length - 1];
      if (offset !== 0) {
        for (var j = 0, jj = ends.length; j < jj; ++j) {
          ends[j] -= offset;
        }
      }
      var polygon = new _Polygon_js__WEBPACK_IMPORTED_MODULE_5__["default"](flatCoordinates.slice(offset, end), layout, ends);
      polygons.push(polygon);
      offset = end;
    }
    return polygons;
  };

  /**
   * @inheritDoc
   * @api
   */
  MultiPolygon.prototype.getType = function getType () {
    return _GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].MULTI_POLYGON;
  };

  /**
   * @inheritDoc
   * @api
   */
  MultiPolygon.prototype.intersectsExtent = function intersectsExtent (extent) {
    return Object(_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_14__["intersectsLinearRingMultiArray"])(
      this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);
  };

  /**
   * Set the coordinates of the multipolygon.
   * @param {!Array<Array<Array<import("../coordinate.js").Coordinate>>>} coordinates Coordinates.
   * @param {GeometryLayout=} opt_layout Layout.
   * @override
   * @api
   */
  MultiPolygon.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 3);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    var endss = Object(_flat_deflate_js__WEBPACK_IMPORTED_MODULE_11__["deflateMultiCoordinatesArray"])(
      this.flatCoordinates, 0, coordinates, this.stride, this.endss_);
    if (endss.length === 0) {
      this.flatCoordinates.length = 0;
    } else {
      var lastEnds = endss[endss.length - 1];
      this.flatCoordinates.length = lastEnds.length === 0 ?
        0 : lastEnds[lastEnds.length - 1];
    }
    this.changed();
  };

  return MultiPolygon;
}(_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_6__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (MultiPolygon);

//# sourceMappingURL=MultiPolygon.js.map

/***/ }),

/***/ "./node_modules/ol/geom/Point.js":
/*!***************************************!*\
  !*** ./node_modules/ol/geom/Point.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _GeometryType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/geom/Point
 */






/**
 * @classdesc
 * Point geometry.
 *
 * @api
 */
var Point = /*@__PURE__*/(function (SimpleGeometry) {
  function Point(coordinates, opt_layout) {
    SimpleGeometry.call(this);
    this.setCoordinates(coordinates, opt_layout);
  }

  if ( SimpleGeometry ) Point.__proto__ = SimpleGeometry;
  Point.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );
  Point.prototype.constructor = Point;

  /**
   * Make a complete copy of the geometry.
   * @return {!Point} Clone.
   * @override
   * @api
   */
  Point.prototype.clone = function clone () {
    var point = new Point(this.flatCoordinates.slice(), this.layout);
    return point;
  };

  /**
   * @inheritDoc
   */
  Point.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {
    var flatCoordinates = this.flatCoordinates;
    var squaredDistance = Object(_math_js__WEBPACK_IMPORTED_MODULE_4__["squaredDistance"])(x, y, flatCoordinates[0], flatCoordinates[1]);
    if (squaredDistance < minSquaredDistance) {
      var stride = this.stride;
      for (var i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[i];
      }
      closestPoint.length = stride;
      return squaredDistance;
    } else {
      return minSquaredDistance;
    }
  };

  /**
   * Return the coordinate of the point.
   * @return {import("../coordinate.js").Coordinate} Coordinates.
   * @override
   * @api
   */
  Point.prototype.getCoordinates = function getCoordinates () {
    return !this.flatCoordinates ? [] : this.flatCoordinates.slice();
  };

  /**
   * @inheritDoc
   */
  Point.prototype.computeExtent = function computeExtent (extent) {
    return Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["createOrUpdateFromCoordinate"])(this.flatCoordinates, extent);
  };

  /**
   * @inheritDoc
   * @api
   */
  Point.prototype.getType = function getType () {
    return _GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINT;
  };

  /**
   * @inheritDoc
   * @api
   */
  Point.prototype.intersectsExtent = function intersectsExtent (extent) {
    return Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["containsXY"])(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
  };

  /**
   * @inheritDoc
   * @api
   */
  Point.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 0);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = Object(_flat_deflate_js__WEBPACK_IMPORTED_MODULE_3__["deflateCoordinate"])(
      this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  };

  return Point;
}(_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_2__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (Point);

//# sourceMappingURL=Point.js.map

/***/ }),

/***/ "./node_modules/ol/geom/Polygon.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/geom/Polygon.js ***!
  \*****************************************/
/*! exports provided: default, circular, fromExtent, fromCircle, makeRegular */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circular", function() { return circular; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromExtent", function() { return fromExtent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromCircle", function() { return fromCircle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeRegular", function() { return makeRegular; });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GeometryLayout.js */ "./node_modules/ol/geom/GeometryLayout.js");
/* harmony import */ var _GeometryType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _LinearRing_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./LinearRing.js */ "./node_modules/ol/geom/LinearRing.js");
/* harmony import */ var _Point_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Point.js */ "./node_modules/ol/geom/Point.js");
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _sphere_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../sphere.js */ "./node_modules/ol/sphere.js");
/* harmony import */ var _flat_area_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./flat/area.js */ "./node_modules/ol/geom/flat/area.js");
/* harmony import */ var _flat_closest_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./flat/closest.js */ "./node_modules/ol/geom/flat/closest.js");
/* harmony import */ var _flat_contains_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./flat/contains.js */ "./node_modules/ol/geom/flat/contains.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _flat_inflate_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _flat_interiorpoint_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./flat/interiorpoint.js */ "./node_modules/ol/geom/flat/interiorpoint.js");
/* harmony import */ var _flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./flat/intersectsextent.js */ "./node_modules/ol/geom/flat/intersectsextent.js");
/* harmony import */ var _flat_orient_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./flat/orient.js */ "./node_modules/ol/geom/flat/orient.js");
/* harmony import */ var _flat_simplify_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./flat/simplify.js */ "./node_modules/ol/geom/flat/simplify.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/geom/Polygon
 */



















/**
 * @classdesc
 * Polygon geometry.
 *
 * @api
 */
var Polygon = /*@__PURE__*/(function (SimpleGeometry) {
  function Polygon(coordinates, opt_layout, opt_ends) {

    SimpleGeometry.call(this);

    /**
     * @type {Array<number>}
     * @private
     */
    this.ends_ = [];

    /**
     * @private
     * @type {number}
     */
    this.flatInteriorPointRevision_ = -1;

    /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */
    this.flatInteriorPoint_ = null;

    /**
     * @private
     * @type {number}
     */
    this.maxDelta_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.maxDeltaRevision_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.orientedRevision_ = -1;

    /**
     * @private
     * @type {Array<number>}
     */
    this.orientedFlatCoordinates_ = null;

    if (opt_layout !== undefined && opt_ends) {
      this.setFlatCoordinates(opt_layout, /** @type {Array<number>} */ (coordinates));
      this.ends_ = opt_ends;
    } else {
      this.setCoordinates(/** @type {Array<Array<import("../coordinate.js").Coordinate>>} */ (coordinates), opt_layout);
    }

  }

  if ( SimpleGeometry ) Polygon.__proto__ = SimpleGeometry;
  Polygon.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );
  Polygon.prototype.constructor = Polygon;

  /**
   * Append the passed linear ring to this polygon.
   * @param {LinearRing} linearRing Linear ring.
   * @api
   */
  Polygon.prototype.appendLinearRing = function appendLinearRing (linearRing) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = linearRing.getFlatCoordinates().slice();
    } else {
      Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(this.flatCoordinates, linearRing.getFlatCoordinates());
    }
    this.ends_.push(this.flatCoordinates.length);
    this.changed();
  };

  /**
   * Make a complete copy of the geometry.
   * @return {!Polygon} Clone.
   * @override
   * @api
   */
  Polygon.prototype.clone = function clone () {
    return new Polygon(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
  };

  /**
   * @inheritDoc
   */
  Polygon.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["closestSquaredDistanceXY"])(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(Object(_flat_closest_js__WEBPACK_IMPORTED_MODULE_9__["arrayMaxSquaredDelta"])(
        this.flatCoordinates, 0, this.ends_, this.stride, 0));
      this.maxDeltaRevision_ = this.getRevision();
    }
    return Object(_flat_closest_js__WEBPACK_IMPORTED_MODULE_9__["assignClosestArrayPoint"])(
      this.flatCoordinates, 0, this.ends_, this.stride,
      this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
  };

  /**
   * @inheritDoc
   */
  Polygon.prototype.containsXY = function containsXY (x, y) {
    return Object(_flat_contains_js__WEBPACK_IMPORTED_MODULE_10__["linearRingsContainsXY"])(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);
  };

  /**
   * Return the area of the polygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  Polygon.prototype.getArea = function getArea () {
    return Object(_flat_area_js__WEBPACK_IMPORTED_MODULE_8__["linearRings"])(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);
  };

  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for polygons.
   *
   * @param {boolean=} opt_right Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @override
   * @api
   */
  Polygon.prototype.getCoordinates = function getCoordinates (opt_right) {
    var flatCoordinates;
    if (opt_right !== undefined) {
      flatCoordinates = this.getOrientedFlatCoordinates().slice();
      Object(_flat_orient_js__WEBPACK_IMPORTED_MODULE_15__["orientLinearRings"])(
        flatCoordinates, 0, this.ends_, this.stride, opt_right);
    } else {
      flatCoordinates = this.flatCoordinates;
    }

    return Object(_flat_inflate_js__WEBPACK_IMPORTED_MODULE_12__["inflateCoordinatesArray"])(
      flatCoordinates, 0, this.ends_, this.stride);
  };

  /**
   * @return {Array<number>} Ends.
   */
  Polygon.prototype.getEnds = function getEnds () {
    return this.ends_;
  };

  /**
   * @return {Array<number>} Interior point.
   */
  Polygon.prototype.getFlatInteriorPoint = function getFlatInteriorPoint () {
    if (this.flatInteriorPointRevision_ != this.getRevision()) {
      var flatCenter = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getCenter"])(this.getExtent());
      this.flatInteriorPoint_ = Object(_flat_interiorpoint_js__WEBPACK_IMPORTED_MODULE_13__["getInteriorPointOfArray"])(
        this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride,
        flatCenter, 0);
      this.flatInteriorPointRevision_ = this.getRevision();
    }
    return this.flatInteriorPoint_;
  };

  /**
   * Return an interior point of the polygon.
   * @return {Point} Interior point as XYM coordinate, where M is the
   * length of the horizontal intersection that the point belongs to.
   * @api
   */
  Polygon.prototype.getInteriorPoint = function getInteriorPoint () {
    return new _Point_js__WEBPACK_IMPORTED_MODULE_5__["default"](this.getFlatInteriorPoint(), _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__["default"].XYM);
  };

  /**
   * Return the number of rings of the polygon,  this includes the exterior
   * ring and any interior rings.
   *
   * @return {number} Number of rings.
   * @api
   */
  Polygon.prototype.getLinearRingCount = function getLinearRingCount () {
    return this.ends_.length;
  };

  /**
   * Return the Nth linear ring of the polygon geometry. Return `null` if the
   * given index is out of range.
   * The exterior linear ring is available at index `0` and the interior rings
   * at index `1` and beyond.
   *
   * @param {number} index Index.
   * @return {LinearRing} Linear ring.
   * @api
   */
  Polygon.prototype.getLinearRing = function getLinearRing (index) {
    if (index < 0 || this.ends_.length <= index) {
      return null;
    }
    return new _LinearRing_js__WEBPACK_IMPORTED_MODULE_4__["default"](this.flatCoordinates.slice(
      index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
  };

  /**
   * Return the linear rings of the polygon.
   * @return {Array<LinearRing>} Linear rings.
   * @api
   */
  Polygon.prototype.getLinearRings = function getLinearRings () {
    var layout = this.layout;
    var flatCoordinates = this.flatCoordinates;
    var ends = this.ends_;
    var linearRings = [];
    var offset = 0;
    for (var i = 0, ii = ends.length; i < ii; ++i) {
      var end = ends[i];
      var linearRing = new _LinearRing_js__WEBPACK_IMPORTED_MODULE_4__["default"](flatCoordinates.slice(offset, end), layout);
      linearRings.push(linearRing);
      offset = end;
    }
    return linearRings;
  };

  /**
   * @return {Array<number>} Oriented flat coordinates.
   */
  Polygon.prototype.getOrientedFlatCoordinates = function getOrientedFlatCoordinates () {
    if (this.orientedRevision_ != this.getRevision()) {
      var flatCoordinates = this.flatCoordinates;
      if (Object(_flat_orient_js__WEBPACK_IMPORTED_MODULE_15__["linearRingIsOriented"])(
        flatCoordinates, 0, this.ends_, this.stride)) {
        this.orientedFlatCoordinates_ = flatCoordinates;
      } else {
        this.orientedFlatCoordinates_ = flatCoordinates.slice();
        this.orientedFlatCoordinates_.length =
            Object(_flat_orient_js__WEBPACK_IMPORTED_MODULE_15__["orientLinearRings"])(
              this.orientedFlatCoordinates_, 0, this.ends_, this.stride);
      }
      this.orientedRevision_ = this.getRevision();
    }
    return this.orientedFlatCoordinates_;
  };

  /**
   * @inheritDoc
   */
  Polygon.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {
    var simplifiedFlatCoordinates = [];
    var simplifiedEnds = [];
    simplifiedFlatCoordinates.length = Object(_flat_simplify_js__WEBPACK_IMPORTED_MODULE_16__["quantizeArray"])(
      this.flatCoordinates, 0, this.ends_, this.stride,
      Math.sqrt(squaredTolerance),
      simplifiedFlatCoordinates, 0, simplifiedEnds);
    return new Polygon(simplifiedFlatCoordinates, _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__["default"].XY, simplifiedEnds);
  };

  /**
   * @inheritDoc
   * @api
   */
  Polygon.prototype.getType = function getType () {
    return _GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POLYGON;
  };

  /**
   * @inheritDoc
   * @api
   */
  Polygon.prototype.intersectsExtent = function intersectsExtent (extent) {
    return Object(_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_14__["intersectsLinearRingArray"])(
      this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);
  };

  /**
   * Set the coordinates of the polygon.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {GeometryLayout=} opt_layout Layout.
   * @override
   * @api
   */
  Polygon.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 2);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    var ends = Object(_flat_deflate_js__WEBPACK_IMPORTED_MODULE_11__["deflateCoordinatesArray"])(
      this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
    this.changed();
  };

  return Polygon;
}(_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_6__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (Polygon);


/**
 * Create an approximation of a circle on the surface of a sphere.
 * @param {import("../coordinate.js").Coordinate} center Center (`[lon, lat]` in degrees).
 * @param {number} radius The great-circle distance from the center to
 *     the polygon vertices.
 * @param {number=} opt_n Optional number of vertices for the resulting
 *     polygon. Default is `32`.
 * @param {number=} opt_sphereRadius Optional radius for the sphere (defaults to
 *     the Earth's mean radius using the WGS84 ellipsoid).
 * @return {Polygon} The "circular" polygon.
 * @api
 */
function circular(center, radius, opt_n, opt_sphereRadius) {
  var n = opt_n ? opt_n : 32;
  /** @type {Array<number>} */
  var flatCoordinates = [];
  for (var i = 0; i < n; ++i) {
    Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(flatCoordinates, Object(_sphere_js__WEBPACK_IMPORTED_MODULE_7__["offset"])(center, radius, 2 * Math.PI * i / n, opt_sphereRadius));
  }
  flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);
  return new Polygon(flatCoordinates, _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__["default"].XY, [flatCoordinates.length]);
}


/**
 * Create a polygon from an extent. The layout used is `XY`.
 * @param {import("../extent.js").Extent} extent The extent.
 * @return {Polygon} The polygon.
 * @api
 */
function fromExtent(extent) {
  var minX = extent[0];
  var minY = extent[1];
  var maxX = extent[2];
  var maxY = extent[3];
  var flatCoordinates =
      [minX, minY, minX, maxY, maxX, maxY, maxX, minY, minX, minY];
  return new Polygon(flatCoordinates, _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__["default"].XY, [flatCoordinates.length]);
}


/**
 * Create a regular polygon from a circle.
 * @param {import("./Circle.js").default} circle Circle geometry.
 * @param {number=} opt_sides Number of sides of the polygon. Default is 32.
 * @param {number=} opt_angle Start angle for the first vertex of the polygon in
 *     radians. Default is 0.
 * @return {Polygon} Polygon geometry.
 * @api
 */
function fromCircle(circle, opt_sides, opt_angle) {
  var sides = opt_sides ? opt_sides : 32;
  var stride = circle.getStride();
  var layout = circle.getLayout();
  var center = circle.getCenter();
  var arrayLength = stride * (sides + 1);
  var flatCoordinates = new Array(arrayLength);
  for (var i = 0; i < arrayLength; i += stride) {
    flatCoordinates[i] = 0;
    flatCoordinates[i + 1] = 0;
    for (var j = 2; j < stride; j++) {
      flatCoordinates[i + j] = center[j];
    }
  }
  var ends = [flatCoordinates.length];
  var polygon = new Polygon(flatCoordinates, layout, ends);
  makeRegular(polygon, center, circle.getRadius(), opt_angle);
  return polygon;
}


/**
 * Modify the coordinates of a polygon to make it a regular polygon.
 * @param {Polygon} polygon Polygon geometry.
 * @param {import("../coordinate.js").Coordinate} center Center of the regular polygon.
 * @param {number} radius Radius of the regular polygon.
 * @param {number=} opt_angle Start angle for the first vertex of the polygon in
 *     radians. Default is 0.
 */
function makeRegular(polygon, center, radius, opt_angle) {
  var flatCoordinates = polygon.getFlatCoordinates();
  var stride = polygon.getStride();
  var sides = flatCoordinates.length / stride - 1;
  var startAngle = opt_angle ? opt_angle : 0;
  for (var i = 0; i <= sides; ++i) {
    var offset = i * stride;
    var angle = startAngle + (Object(_math_js__WEBPACK_IMPORTED_MODULE_17__["modulo"])(i, sides) * 2 * Math.PI / sides);
    flatCoordinates[offset] = center[0] + (radius * Math.cos(angle));
    flatCoordinates[offset + 1] = center[1] + (radius * Math.sin(angle));
  }
  polygon.changed();
}

//# sourceMappingURL=Polygon.js.map

/***/ }),

/***/ "./node_modules/ol/geom/SimpleGeometry.js":
/*!************************************************!*\
  !*** ./node_modules/ol/geom/SimpleGeometry.js ***!
  \************************************************/
/*! exports provided: getStrideForLayout, transformGeom2D, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getStrideForLayout", function() { return getStrideForLayout; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformGeom2D", function() { return transformGeom2D; });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _Geometry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Geometry.js */ "./node_modules/ol/geom/Geometry.js");
/* harmony import */ var _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GeometryLayout.js */ "./node_modules/ol/geom/GeometryLayout.js");
/* harmony import */ var _flat_transform_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./flat/transform.js */ "./node_modules/ol/geom/flat/transform.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/geom/SimpleGeometry
 */







/**
 * @classdesc
 * Abstract base class; only used for creating subclasses; do not instantiate
 * in apps, as cannot be rendered.
 *
 * @abstract
 * @api
 */
var SimpleGeometry = /*@__PURE__*/(function (Geometry) {
  function SimpleGeometry() {

    Geometry.call(this);

    /**
     * @protected
     * @type {GeometryLayout}
     */
    this.layout = _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XY;

    /**
     * @protected
     * @type {number}
     */
    this.stride = 2;

    /**
     * @protected
     * @type {Array<number>}
     */
    this.flatCoordinates = null;

  }

  if ( Geometry ) SimpleGeometry.__proto__ = Geometry;
  SimpleGeometry.prototype = Object.create( Geometry && Geometry.prototype );
  SimpleGeometry.prototype.constructor = SimpleGeometry;

  /**
   * @inheritDoc
   */
  SimpleGeometry.prototype.computeExtent = function computeExtent (extent) {
    return Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["createOrUpdateFromFlatCoordinates"])(this.flatCoordinates,
      0, this.flatCoordinates.length, this.stride, extent);
  };

  /**
   * @abstract
   * @return {Array} Coordinates.
   */
  SimpleGeometry.prototype.getCoordinates = function getCoordinates () {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Return the first coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} First coordinate.
   * @api
   */
  SimpleGeometry.prototype.getFirstCoordinate = function getFirstCoordinate () {
    return this.flatCoordinates.slice(0, this.stride);
  };

  /**
   * @return {Array<number>} Flat coordinates.
   */
  SimpleGeometry.prototype.getFlatCoordinates = function getFlatCoordinates () {
    return this.flatCoordinates;
  };

  /**
   * Return the last coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} Last point.
   * @api
   */
  SimpleGeometry.prototype.getLastCoordinate = function getLastCoordinate () {
    return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);
  };

  /**
   * Return the {@link module:ol/geom/GeometryLayout layout} of the geometry.
   * @return {GeometryLayout} Layout.
   * @api
   */
  SimpleGeometry.prototype.getLayout = function getLayout () {
    return this.layout;
  };

  /**
   * @inheritDoc
   */
  SimpleGeometry.prototype.getSimplifiedGeometry = function getSimplifiedGeometry (squaredTolerance) {
    if (this.simplifiedGeometryRevision != this.getRevision()) {
      Object(_obj_js__WEBPACK_IMPORTED_MODULE_5__["clear"])(this.simplifiedGeometryCache);
      this.simplifiedGeometryMaxMinSquaredTolerance = 0;
      this.simplifiedGeometryRevision = this.getRevision();
    }
    // If squaredTolerance is negative or if we know that simplification will not
    // have any effect then just return this.
    if (squaredTolerance < 0 ||
        (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&
         squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance)) {
      return this;
    }
    var key = squaredTolerance.toString();
    if (this.simplifiedGeometryCache.hasOwnProperty(key)) {
      return this.simplifiedGeometryCache[key];
    } else {
      var simplifiedGeometry =
          this.getSimplifiedGeometryInternal(squaredTolerance);
      var simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();
      if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {
        this.simplifiedGeometryCache[key] = simplifiedGeometry;
        return simplifiedGeometry;
      } else {
        // Simplification did not actually remove any coordinates.  We now know
        // that any calls to getSimplifiedGeometry with a squaredTolerance less
        // than or equal to the current squaredTolerance will also not have any
        // effect.  This allows us to short circuit simplification (saving CPU
        // cycles) and prevents the cache of simplified geometries from filling
        // up with useless identical copies of this geometry (saving memory).
        this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
        return this;
      }
    }
  };

  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   * @protected
   */
  SimpleGeometry.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {
    return this;
  };

  /**
   * @return {number} Stride.
   */
  SimpleGeometry.prototype.getStride = function getStride () {
    return this.stride;
  };

  /**
   * @param {GeometryLayout} layout Layout.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   */
  SimpleGeometry.prototype.setFlatCoordinates = function setFlatCoordinates (layout, flatCoordinates) {
    this.stride = getStrideForLayout(layout);
    this.layout = layout;
    this.flatCoordinates = flatCoordinates;
  };

  /**
   * @abstract
   * @param {!Array} coordinates Coordinates.
   * @param {GeometryLayout=} opt_layout Layout.
   */
  SimpleGeometry.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {
    Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * @param {GeometryLayout|undefined} layout Layout.
   * @param {Array} coordinates Coordinates.
   * @param {number} nesting Nesting.
   * @protected
   */
  SimpleGeometry.prototype.setLayout = function setLayout (layout, coordinates, nesting) {
    /** @type {number} */
    var stride;
    if (layout) {
      stride = getStrideForLayout(layout);
    } else {
      for (var i = 0; i < nesting; ++i) {
        if (coordinates.length === 0) {
          this.layout = _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XY;
          this.stride = 2;
          return;
        } else {
          coordinates = /** @type {Array} */ (coordinates[0]);
        }
      }
      stride = coordinates.length;
      layout = getLayoutForStride(stride);
    }
    this.layout = layout;
    this.stride = stride;
  };

  /**
   * @inheritDoc
   * @api
   */
  SimpleGeometry.prototype.applyTransform = function applyTransform (transformFn) {
    if (this.flatCoordinates) {
      transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);
      this.changed();
    }
  };

  /**
   * @inheritDoc
   * @api
   */
  SimpleGeometry.prototype.rotate = function rotate$1 (angle, anchor) {
    var flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      var stride = this.getStride();
      Object(_flat_transform_js__WEBPACK_IMPORTED_MODULE_4__["rotate"])(
        flatCoordinates, 0, flatCoordinates.length,
        stride, angle, anchor, flatCoordinates);
      this.changed();
    }
  };

  /**
   * @inheritDoc
   * @api
   */
  SimpleGeometry.prototype.scale = function scale$1 (sx, opt_sy, opt_anchor) {
    var sy = opt_sy;
    if (sy === undefined) {
      sy = sx;
    }
    var anchor = opt_anchor;
    if (!anchor) {
      anchor = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getCenter"])(this.getExtent());
    }
    var flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      var stride = this.getStride();
      Object(_flat_transform_js__WEBPACK_IMPORTED_MODULE_4__["scale"])(
        flatCoordinates, 0, flatCoordinates.length,
        stride, sx, sy, anchor, flatCoordinates);
      this.changed();
    }
  };

  /**
   * @inheritDoc
   * @api
   */
  SimpleGeometry.prototype.translate = function translate$1 (deltaX, deltaY) {
    var flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      var stride = this.getStride();
      Object(_flat_transform_js__WEBPACK_IMPORTED_MODULE_4__["translate"])(
        flatCoordinates, 0, flatCoordinates.length, stride,
        deltaX, deltaY, flatCoordinates);
      this.changed();
    }
  };

  return SimpleGeometry;
}(_Geometry_js__WEBPACK_IMPORTED_MODULE_2__["default"]));


/**
 * @param {number} stride Stride.
 * @return {GeometryLayout} layout Layout.
 */
function getLayoutForStride(stride) {
  var layout;
  if (stride == 2) {
    layout = _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XY;
  } else if (stride == 3) {
    layout = _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XYZ;
  } else if (stride == 4) {
    layout = _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XYZM;
  }
  return (
    /** @type {GeometryLayout} */ (layout)
  );
}


/**
 * @param {GeometryLayout} layout Layout.
 * @return {number} Stride.
 */
function getStrideForLayout(layout) {
  var stride;
  if (layout == _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XY) {
    stride = 2;
  } else if (layout == _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XYZ || layout == _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XYM) {
    stride = 3;
  } else if (layout == _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XYZM) {
    stride = 4;
  }
  return /** @type {number} */ (stride);
}


/**
 * @param {SimpleGeometry} simpleGeometry Simple geometry.
 * @param {import("../transform.js").Transform} transform Transform.
 * @param {Array<number>=} opt_dest Destination.
 * @return {Array<number>} Transformed flat coordinates.
 */
function transformGeom2D(simpleGeometry, transform, opt_dest) {
  var flatCoordinates = simpleGeometry.getFlatCoordinates();
  if (!flatCoordinates) {
    return null;
  } else {
    var stride = simpleGeometry.getStride();
    return Object(_flat_transform_js__WEBPACK_IMPORTED_MODULE_4__["transform2D"])(
      flatCoordinates, 0, flatCoordinates.length, stride,
      transform, opt_dest);
  }
}

/* harmony default export */ __webpack_exports__["default"] = (SimpleGeometry);

//# sourceMappingURL=SimpleGeometry.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/area.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/geom/flat/area.js ***!
  \*******************************************/
/*! exports provided: linearRing, linearRings, linearRingss */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearRing", function() { return linearRing; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearRings", function() { return linearRings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearRingss", function() { return linearRingss; });
/**
 * @module ol/geom/flat/area
 */


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Area.
 */
function linearRing(flatCoordinates, offset, end, stride) {
  var twiceArea = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    twiceArea += y1 * x2 - x1 * y2;
    x1 = x2;
    y1 = y2;
  }
  return twiceArea / 2;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @return {number} Area.
 */
function linearRings(flatCoordinates, offset, ends, stride) {
  var area = 0;
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    area += linearRing(flatCoordinates, offset, end, stride);
    offset = end;
  }
  return area;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @return {number} Area.
 */
function linearRingss(flatCoordinates, offset, endss, stride) {
  var area = 0;
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    area += linearRings(flatCoordinates, offset, ends, stride);
    offset = ends[ends.length - 1];
  }
  return area;
}

//# sourceMappingURL=area.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/center.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/geom/flat/center.js ***!
  \*********************************************/
/*! exports provided: linearRingss */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearRingss", function() { return linearRingss; });
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/**
 * @module ol/geom/flat/center
 */



/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @return {Array<number>} Flat centers.
 */
function linearRingss(flatCoordinates, offset, endss, stride) {
  var flatCenters = [];
  var extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["createEmpty"])();
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["createOrUpdateFromFlatCoordinates"])(flatCoordinates, offset, ends[0], stride);
    flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);
    offset = ends[ends.length - 1];
  }
  return flatCenters;
}

//# sourceMappingURL=center.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/closest.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/geom/flat/closest.js ***!
  \**********************************************/
/*! exports provided: maxSquaredDelta, arrayMaxSquaredDelta, multiArrayMaxSquaredDelta, assignClosestPoint, assignClosestArrayPoint, assignClosestMultiArrayPoint */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "maxSquaredDelta", function() { return maxSquaredDelta; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arrayMaxSquaredDelta", function() { return arrayMaxSquaredDelta; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiArrayMaxSquaredDelta", function() { return multiArrayMaxSquaredDelta; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assignClosestPoint", function() { return assignClosestPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assignClosestArrayPoint", function() { return assignClosestArrayPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assignClosestMultiArrayPoint", function() { return assignClosestMultiArrayPoint; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/geom/flat/closest
 */



/**
 * Returns the point on the 2D line segment flatCoordinates[offset1] to
 * flatCoordinates[offset2] that is closest to the point (x, y).  Extra
 * dimensions are linearly interpolated.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset1 Offset 1.
 * @param {number} offset2 Offset 2.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 */
function assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {
  var x1 = flatCoordinates[offset1];
  var y1 = flatCoordinates[offset1 + 1];
  var dx = flatCoordinates[offset2] - x1;
  var dy = flatCoordinates[offset2 + 1] - y1;
  var offset;
  if (dx === 0 && dy === 0) {
    offset = offset1;
  } else {
    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      offset = offset2;
    } else if (t > 0) {
      for (var i = 0; i < stride; ++i) {
        closestPoint[i] = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["lerp"])(flatCoordinates[offset1 + i],
          flatCoordinates[offset2 + i], t);
      }
      closestPoint.length = stride;
      return;
    } else {
      offset = offset1;
    }
  }
  for (var i$1 = 0; i$1 < stride; ++i$1) {
    closestPoint[i$1] = flatCoordinates[offset + i$1];
  }
  closestPoint.length = stride;
}


/**
 * Return the squared of the largest distance between any pair of consecutive
 * coordinates.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */
function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {
  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1];
  for (offset += stride; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    var squaredDelta = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["squaredDistance"])(x1, y1, x2, y2);
    if (squaredDelta > max) {
      max = squaredDelta;
    }
    x1 = x2;
    y1 = y2;
  }
  return max;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */
function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    max = maxSquaredDelta(
      flatCoordinates, offset, end, stride, max);
    offset = end;
  }
  return max;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */
function multiArrayMaxSquaredDelta(flatCoordinates, offset, endss, stride, max) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    max = arrayMaxSquaredDelta(
      flatCoordinates, offset, ends, stride, max);
    offset = ends[ends.length - 1];
  }
  return max;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>=} opt_tmpPoint Temporary point object.
 * @return {number} Minimum squared distance.
 */
function assignClosestPoint(flatCoordinates, offset, end,
  stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance,
  opt_tmpPoint) {
  if (offset == end) {
    return minSquaredDistance;
  }
  var i, squaredDistance;
  if (maxDelta === 0) {
    // All points are identical, so just test the first point.
    squaredDistance = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["squaredDistance"])(
      x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);
    if (squaredDistance < minSquaredDistance) {
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[offset + i];
      }
      closestPoint.length = stride;
      return squaredDistance;
    } else {
      return minSquaredDistance;
    }
  }
  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
  var index = offset + stride;
  while (index < end) {
    assignClosest(
      flatCoordinates, index - stride, index, stride, x, y, tmpPoint);
    squaredDistance = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["squaredDistance"])(x, y, tmpPoint[0], tmpPoint[1]);
    if (squaredDistance < minSquaredDistance) {
      minSquaredDistance = squaredDistance;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }
      closestPoint.length = stride;
      index += stride;
    } else {
      // Skip ahead multiple points, because we know that all the skipped
      // points cannot be any closer than the closest point we have found so
      // far.  We know this because we know how close the current point is, how
      // close the closest point we have found so far is, and the maximum
      // distance between consecutive points.  For example, if we're currently
      // at distance 10, the best we've found so far is 3, and that the maximum
      // distance between consecutive points is 2, then we'll need to skip at
      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of
      // finding a closer point.  We use Math.max(..., 1) to ensure that we
      // always advance at least one point, to avoid an infinite loop.
      index += stride * Math.max(
        ((Math.sqrt(squaredDistance) -
            Math.sqrt(minSquaredDistance)) / maxDelta) | 0, 1);
    }
  }
  if (isRing) {
    // Check the closing segment.
    assignClosest(
      flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);
    squaredDistance = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["squaredDistance"])(x, y, tmpPoint[0], tmpPoint[1]);
    if (squaredDistance < minSquaredDistance) {
      minSquaredDistance = squaredDistance;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }
      closestPoint.length = stride;
    }
  }
  return minSquaredDistance;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>=} opt_tmpPoint Temporary point object.
 * @return {number} Minimum squared distance.
 */
function assignClosestArrayPoint(flatCoordinates, offset, ends,
  stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance,
  opt_tmpPoint) {
  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    minSquaredDistance = assignClosestPoint(
      flatCoordinates, offset, end, stride,
      maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
    offset = end;
  }
  return minSquaredDistance;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>=} opt_tmpPoint Temporary point object.
 * @return {number} Minimum squared distance.
 */
function assignClosestMultiArrayPoint(flatCoordinates, offset,
  endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance,
  opt_tmpPoint) {
  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    minSquaredDistance = assignClosestArrayPoint(
      flatCoordinates, offset, ends, stride,
      maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
    offset = ends[ends.length - 1];
  }
  return minSquaredDistance;
}

//# sourceMappingURL=closest.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/contains.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/geom/flat/contains.js ***!
  \***********************************************/
/*! exports provided: linearRingContainsExtent, linearRingContainsXY, linearRingsContainsXY, linearRingssContainsXY */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearRingContainsExtent", function() { return linearRingContainsExtent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearRingContainsXY", function() { return linearRingContainsXY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearRingsContainsXY", function() { return linearRingsContainsXY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearRingssContainsXY", function() { return linearRingssContainsXY; });
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/**
 * @module ol/geom/flat/contains
 */



/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} Contains extent.
 */
function linearRingContainsExtent(flatCoordinates, offset, end, stride, extent) {
  var outside = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["forEachCorner"])(extent,
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains (x, y).
     */
    function(coordinate) {
      return !linearRingContainsXY(flatCoordinates, offset, end, stride, coordinate[0], coordinate[1]);
    });
  return !outside;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */
function linearRingContainsXY(flatCoordinates, offset, end, stride, x, y) {
  // http://geomalgorithms.com/a03-_inclusion.html
  // Copyright 2000 softSurfer, 2012 Dan Sunday
  // This code may be freely used and modified for any purpose
  // providing that this copyright notice is included with it.
  // SoftSurfer makes no warranty for this code, and cannot be held
  // liable for any real or imagined damage resulting from its use.
  // Users of this code must verify correctness for their application.
  var wn = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    if (y1 <= y) {
      if (y2 > y && ((x2 - x1) * (y - y1)) - ((x - x1) * (y2 - y1)) > 0) {
        wn++;
      }
    } else if (y2 <= y && ((x2 - x1) * (y - y1)) - ((x - x1) * (y2 - y1)) < 0) {
      wn--;
    }
    x1 = x2;
    y1 = y2;
  }
  return wn !== 0;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */
function linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y) {
  if (ends.length === 0) {
    return false;
  }
  if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {
    return false;
  }
  for (var i = 1, ii = ends.length; i < ii; ++i) {
    if (linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {
      return false;
    }
  }
  return true;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */
function linearRingssContainsXY(flatCoordinates, offset, endss, stride, x, y) {
  if (endss.length === 0) {
    return false;
  }
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
      return true;
    }
    offset = ends[ends.length - 1];
  }
  return false;
}

//# sourceMappingURL=contains.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/deflate.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/geom/flat/deflate.js ***!
  \**********************************************/
/*! exports provided: deflateCoordinate, deflateCoordinates, deflateCoordinatesArray, deflateMultiCoordinatesArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deflateCoordinate", function() { return deflateCoordinate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deflateCoordinates", function() { return deflateCoordinates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deflateCoordinatesArray", function() { return deflateCoordinatesArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deflateMultiCoordinatesArray", function() { return deflateMultiCoordinatesArray; });
/**
 * @module ol/geom/flat/deflate
 */


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */
function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {
  for (var i = 0, ii = coordinate.length; i < ii; ++i) {
    flatCoordinates[offset++] = coordinate[i];
  }
  return offset;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<import("../../coordinate.js").Coordinate>} coordinates Coordinates.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */
function deflateCoordinates(flatCoordinates, offset, coordinates, stride) {
  for (var i = 0, ii = coordinates.length; i < ii; ++i) {
    var coordinate = coordinates[i];
    for (var j = 0; j < stride; ++j) {
      flatCoordinates[offset++] = coordinate[j];
    }
  }
  return offset;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<import("../../coordinate.js").Coordinate>>} coordinatess Coordinatess.
 * @param {number} stride Stride.
 * @param {Array<number>=} opt_ends Ends.
 * @return {Array<number>} Ends.
 */
function deflateCoordinatesArray(flatCoordinates, offset, coordinatess, stride, opt_ends) {
  var ends = opt_ends ? opt_ends : [];
  var i = 0;
  for (var j = 0, jj = coordinatess.length; j < jj; ++j) {
    var end = deflateCoordinates(
      flatCoordinates, offset, coordinatess[j], stride);
    ends[i++] = end;
    offset = end;
  }
  ends.length = i;
  return ends;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} coordinatesss Coordinatesss.
 * @param {number} stride Stride.
 * @param {Array<Array<number>>=} opt_endss Endss.
 * @return {Array<Array<number>>} Endss.
 */
function deflateMultiCoordinatesArray(flatCoordinates, offset, coordinatesss, stride, opt_endss) {
  var endss = opt_endss ? opt_endss : [];
  var i = 0;
  for (var j = 0, jj = coordinatesss.length; j < jj; ++j) {
    var ends = deflateCoordinatesArray(
      flatCoordinates, offset, coordinatesss[j], stride, endss[i]);
    endss[i++] = ends;
    offset = ends[ends.length - 1];
  }
  endss.length = i;
  return endss;
}

//# sourceMappingURL=deflate.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/inflate.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/geom/flat/inflate.js ***!
  \**********************************************/
/*! exports provided: inflateCoordinates, inflateCoordinatesArray, inflateMultiCoordinatesArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inflateCoordinates", function() { return inflateCoordinates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inflateCoordinatesArray", function() { return inflateCoordinatesArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inflateMultiCoordinatesArray", function() { return inflateMultiCoordinatesArray; });
/**
 * @module ol/geom/flat/inflate
 */


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Array<import("../../coordinate.js").Coordinate>=} opt_coordinates Coordinates.
 * @return {Array<import("../../coordinate.js").Coordinate>} Coordinates.
 */
function inflateCoordinates(flatCoordinates, offset, end, stride, opt_coordinates) {
  var coordinates = opt_coordinates !== undefined ? opt_coordinates : [];
  var i = 0;
  for (var j = offset; j < end; j += stride) {
    coordinates[i++] = flatCoordinates.slice(j, j + stride);
  }
  coordinates.length = i;
  return coordinates;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array<Array<import("../../coordinate.js").Coordinate>>=} opt_coordinatess Coordinatess.
 * @return {Array<Array<import("../../coordinate.js").Coordinate>>} Coordinatess.
 */
function inflateCoordinatesArray(flatCoordinates, offset, ends, stride, opt_coordinatess) {
  var coordinatess = opt_coordinatess !== undefined ? opt_coordinatess : [];
  var i = 0;
  for (var j = 0, jj = ends.length; j < jj; ++j) {
    var end = ends[j];
    coordinatess[i++] = inflateCoordinates(
      flatCoordinates, offset, end, stride, coordinatess[i]);
    offset = end;
  }
  coordinatess.length = i;
  return coordinatess;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>=} opt_coordinatesss
 *     Coordinatesss.
 * @return {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} Coordinatesss.
 */
function inflateMultiCoordinatesArray(flatCoordinates, offset, endss, stride, opt_coordinatesss) {
  var coordinatesss = opt_coordinatesss !== undefined ? opt_coordinatesss : [];
  var i = 0;
  for (var j = 0, jj = endss.length; j < jj; ++j) {
    var ends = endss[j];
    coordinatesss[i++] = inflateCoordinatesArray(
      flatCoordinates, offset, ends, stride, coordinatesss[i]);
    offset = ends[ends.length - 1];
  }
  coordinatesss.length = i;
  return coordinatesss;
}

//# sourceMappingURL=inflate.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/interiorpoint.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/geom/flat/interiorpoint.js ***!
  \****************************************************/
/*! exports provided: getInteriorPointOfArray, getInteriorPointsOfMultiArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getInteriorPointOfArray", function() { return getInteriorPointOfArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getInteriorPointsOfMultiArray", function() { return getInteriorPointsOfMultiArray; });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./contains.js */ "./node_modules/ol/geom/flat/contains.js");
/**
 * @module ol/geom/flat/interiorpoint
 */




/**
 * Calculates a point that is likely to lie in the interior of the linear rings.
 * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array<number>} flatCenters Flat centers.
 * @param {number} flatCentersOffset Flat center offset.
 * @param {Array<number>=} opt_dest Destination.
 * @return {Array<number>} Destination point as XYM coordinate, where M is the
 * length of the horizontal intersection that the point belongs to.
 */
function getInteriorPointOfArray(flatCoordinates, offset,
  ends, stride, flatCenters, flatCentersOffset, opt_dest) {
  var i, ii, x, x1, x2, y1, y2;
  var y = flatCenters[flatCentersOffset + 1];
  /** @type {Array<number>} */
  var intersections = [];
  // Calculate intersections with the horizontal line
  for (var r = 0, rr = ends.length; r < rr; ++r) {
    var end = ends[r];
    x1 = flatCoordinates[end - stride];
    y1 = flatCoordinates[end - stride + 1];
    for (i = offset; i < end; i += stride) {
      x2 = flatCoordinates[i];
      y2 = flatCoordinates[i + 1];
      if ((y <= y1 && y2 <= y) || (y1 <= y && y <= y2)) {
        x = (y - y1) / (y2 - y1) * (x2 - x1) + x1;
        intersections.push(x);
      }
      x1 = x2;
      y1 = y2;
    }
  }
  // Find the longest segment of the horizontal line that has its center point
  // inside the linear ring.
  var pointX = NaN;
  var maxSegmentLength = -Infinity;
  intersections.sort(_array_js__WEBPACK_IMPORTED_MODULE_0__["numberSafeCompareFunction"]);
  x1 = intersections[0];
  for (i = 1, ii = intersections.length; i < ii; ++i) {
    x2 = intersections[i];
    var segmentLength = Math.abs(x2 - x1);
    if (segmentLength > maxSegmentLength) {
      x = (x1 + x2) / 2;
      if (Object(_contains_js__WEBPACK_IMPORTED_MODULE_1__["linearRingsContainsXY"])(flatCoordinates, offset, ends, stride, x, y)) {
        pointX = x;
        maxSegmentLength = segmentLength;
      }
    }
    x1 = x2;
  }
  if (isNaN(pointX)) {
    // There is no horizontal line that has its center point inside the linear
    // ring.  Use the center of the the linear ring's extent.
    pointX = flatCenters[flatCentersOffset];
  }
  if (opt_dest) {
    opt_dest.push(pointX, y, maxSegmentLength);
    return opt_dest;
  } else {
    return [pointX, y, maxSegmentLength];
  }
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array<number>} flatCenters Flat centers.
 * @return {Array<number>} Interior points as XYM coordinates, where M is the
 * length of the horizontal intersection that the point belongs to.
 */
function getInteriorPointsOfMultiArray(flatCoordinates, offset, endss, stride, flatCenters) {
  var interiorPoints = [];
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    interiorPoints = getInteriorPointOfArray(flatCoordinates,
      offset, ends, stride, flatCenters, 2 * i, interiorPoints);
    offset = ends[ends.length - 1];
  }
  return interiorPoints;
}

//# sourceMappingURL=interiorpoint.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/interpolate.js":
/*!**************************************************!*\
  !*** ./node_modules/ol/geom/flat/interpolate.js ***!
  \**************************************************/
/*! exports provided: interpolatePoint, lineStringCoordinateAtM, lineStringsCoordinateAtM */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interpolatePoint", function() { return interpolatePoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineStringCoordinateAtM", function() { return lineStringCoordinateAtM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineStringsCoordinateAtM", function() { return lineStringsCoordinateAtM; });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/geom/flat/interpolate
 */




/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} fraction Fraction.
 * @param {Array<number>=} opt_dest Destination.
 * @return {Array<number>} Destination.
 */
function interpolatePoint(flatCoordinates, offset, end, stride, fraction, opt_dest) {
  var pointX = NaN;
  var pointY = NaN;
  var n = (end - offset) / stride;
  if (n === 1) {
    pointX = flatCoordinates[offset];
    pointY = flatCoordinates[offset + 1];
  } else if (n == 2) {
    pointX = (1 - fraction) * flatCoordinates[offset] +
        fraction * flatCoordinates[offset + stride];
    pointY = (1 - fraction) * flatCoordinates[offset + 1] +
        fraction * flatCoordinates[offset + stride + 1];
  } else if (n !== 0) {
    var x1 = flatCoordinates[offset];
    var y1 = flatCoordinates[offset + 1];
    var length = 0;
    var cumulativeLengths = [0];
    for (var i = offset + stride; i < end; i += stride) {
      var x2 = flatCoordinates[i];
      var y2 = flatCoordinates[i + 1];
      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
      cumulativeLengths.push(length);
      x1 = x2;
      y1 = y2;
    }
    var target = fraction * length;
    var index = Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["binarySearch"])(cumulativeLengths, target);
    if (index < 0) {
      var t = (target - cumulativeLengths[-index - 2]) /
          (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);
      var o = offset + (-index - 2) * stride;
      pointX = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["lerp"])(
        flatCoordinates[o], flatCoordinates[o + stride], t);
      pointY = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["lerp"])(
        flatCoordinates[o + 1], flatCoordinates[o + stride + 1], t);
    } else {
      pointX = flatCoordinates[offset + index * stride];
      pointY = flatCoordinates[offset + index * stride + 1];
    }
  }
  if (opt_dest) {
    opt_dest[0] = pointX;
    opt_dest[1] = pointY;
    return opt_dest;
  } else {
    return [pointX, pointY];
  }
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} m M.
 * @param {boolean} extrapolate Extrapolate.
 * @return {import("../../coordinate.js").Coordinate} Coordinate.
 */
function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {
  if (end == offset) {
    return null;
  }
  var coordinate;
  if (m < flatCoordinates[offset + stride - 1]) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(offset, offset + stride);
      coordinate[stride - 1] = m;
      return coordinate;
    } else {
      return null;
    }
  } else if (flatCoordinates[end - 1] < m) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(end - stride, end);
      coordinate[stride - 1] = m;
      return coordinate;
    } else {
      return null;
    }
  }
  // FIXME use O(1) search
  if (m == flatCoordinates[offset + stride - 1]) {
    return flatCoordinates.slice(offset, offset + stride);
  }
  var lo = offset / stride;
  var hi = end / stride;
  while (lo < hi) {
    var mid = (lo + hi) >> 1;
    if (m < flatCoordinates[(mid + 1) * stride - 1]) {
      hi = mid;
    } else {
      lo = mid + 1;
    }
  }
  var m0 = flatCoordinates[lo * stride - 1];
  if (m == m0) {
    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);
  }
  var m1 = flatCoordinates[(lo + 1) * stride - 1];
  var t = (m - m0) / (m1 - m0);
  coordinate = [];
  for (var i = 0; i < stride - 1; ++i) {
    coordinate.push(Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["lerp"])(flatCoordinates[(lo - 1) * stride + i],
      flatCoordinates[lo * stride + i], t));
  }
  coordinate.push(m);
  return coordinate;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} m M.
 * @param {boolean} extrapolate Extrapolate.
 * @param {boolean} interpolate Interpolate.
 * @return {import("../../coordinate.js").Coordinate} Coordinate.
 */
function lineStringsCoordinateAtM(
  flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {
  if (interpolate) {
    return lineStringCoordinateAtM(
      flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);
  }
  var coordinate;
  if (m < flatCoordinates[stride - 1]) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(0, stride);
      coordinate[stride - 1] = m;
      return coordinate;
    } else {
      return null;
    }
  }
  if (flatCoordinates[flatCoordinates.length - 1] < m) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);
      coordinate[stride - 1] = m;
      return coordinate;
    } else {
      return null;
    }
  }
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    if (offset == end) {
      continue;
    }
    if (m < flatCoordinates[offset + stride - 1]) {
      return null;
    } else if (m <= flatCoordinates[end - 1]) {
      return lineStringCoordinateAtM(
        flatCoordinates, offset, end, stride, m, false);
    }
    offset = end;
  }
  return null;
}

//# sourceMappingURL=interpolate.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/intersectsextent.js":
/*!*******************************************************!*\
  !*** ./node_modules/ol/geom/flat/intersectsextent.js ***!
  \*******************************************************/
/*! exports provided: intersectsLineString, intersectsLineStringArray, intersectsLinearRing, intersectsLinearRingArray, intersectsLinearRingMultiArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersectsLineString", function() { return intersectsLineString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersectsLineStringArray", function() { return intersectsLineStringArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersectsLinearRing", function() { return intersectsLinearRing; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersectsLinearRingArray", function() { return intersectsLinearRingArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersectsLinearRingMultiArray", function() { return intersectsLinearRingMultiArray; });
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./contains.js */ "./node_modules/ol/geom/flat/contains.js");
/* harmony import */ var _segments_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./segments.js */ "./node_modules/ol/geom/flat/segments.js");
/**
 * @module ol/geom/flat/intersectsextent
 */





/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
function intersectsLineString(flatCoordinates, offset, end, stride, extent) {
  var coordinatesExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["extendFlatCoordinates"])(
    Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["createEmpty"])(), flatCoordinates, offset, end, stride);
  if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["intersects"])(extent, coordinatesExtent)) {
    return false;
  }
  if (Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["containsExtent"])(extent, coordinatesExtent)) {
    return true;
  }
  if (coordinatesExtent[0] >= extent[0] &&
      coordinatesExtent[2] <= extent[2]) {
    return true;
  }
  if (coordinatesExtent[1] >= extent[1] &&
      coordinatesExtent[3] <= extent[3]) {
    return true;
  }
  return Object(_segments_js__WEBPACK_IMPORTED_MODULE_2__["forEach"])(flatCoordinates, offset, end, stride,
    /**
     * @param {import("../../coordinate.js").Coordinate} point1 Start point.
     * @param {import("../../coordinate.js").Coordinate} point2 End point.
     * @return {boolean} `true` if the segment and the extent intersect,
     *     `false` otherwise.
     */
    function(point1, point2) {
      return Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["intersectsSegment"])(extent, point1, point2);
    });
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
function intersectsLineStringArray(flatCoordinates, offset, ends, stride, extent) {
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    if (intersectsLineString(
      flatCoordinates, offset, ends[i], stride, extent)) {
      return true;
    }
    offset = ends[i];
  }
  return false;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
function intersectsLinearRing(flatCoordinates, offset, end, stride, extent) {
  if (intersectsLineString(
    flatCoordinates, offset, end, stride, extent)) {
    return true;
  }
  if (Object(_contains_js__WEBPACK_IMPORTED_MODULE_1__["linearRingContainsXY"])(flatCoordinates, offset, end, stride, extent[0], extent[1])) {
    return true;
  }
  if (Object(_contains_js__WEBPACK_IMPORTED_MODULE_1__["linearRingContainsXY"])(flatCoordinates, offset, end, stride, extent[0], extent[3])) {
    return true;
  }
  if (Object(_contains_js__WEBPACK_IMPORTED_MODULE_1__["linearRingContainsXY"])(flatCoordinates, offset, end, stride, extent[2], extent[1])) {
    return true;
  }
  if (Object(_contains_js__WEBPACK_IMPORTED_MODULE_1__["linearRingContainsXY"])(flatCoordinates, offset, end, stride, extent[2], extent[3])) {
    return true;
  }
  return false;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
function intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent) {
  if (!intersectsLinearRing(
    flatCoordinates, offset, ends[0], stride, extent)) {
    return false;
  }
  if (ends.length === 1) {
    return true;
  }
  for (var i = 1, ii = ends.length; i < ii; ++i) {
    if (Object(_contains_js__WEBPACK_IMPORTED_MODULE_1__["linearRingContainsExtent"])(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
      if (!intersectsLineString(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
        return false;
      }
    }
  }
  return true;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
function intersectsLinearRingMultiArray(flatCoordinates, offset, endss, stride, extent) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    if (intersectsLinearRingArray(
      flatCoordinates, offset, ends, stride, extent)) {
      return true;
    }
    offset = ends[ends.length - 1];
  }
  return false;
}

//# sourceMappingURL=intersectsextent.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/length.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/geom/flat/length.js ***!
  \*********************************************/
/*! exports provided: lineStringLength, linearRingLength */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineStringLength", function() { return lineStringLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearRingLength", function() { return linearRingLength; });
/**
 * @module ol/geom/flat/length
 */


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Length.
 */
function lineStringLength(flatCoordinates, offset, end, stride) {
  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1];
  var length = 0;
  for (var i = offset + stride; i < end; i += stride) {
    var x2 = flatCoordinates[i];
    var y2 = flatCoordinates[i + 1];
    length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    x1 = x2;
    y1 = y2;
  }
  return length;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Perimeter.
 */
function linearRingLength(flatCoordinates, offset, end, stride) {
  var perimeter = lineStringLength(flatCoordinates, offset, end, stride);
  var dx = flatCoordinates[end - stride] - flatCoordinates[offset];
  var dy = flatCoordinates[end - stride + 1] - flatCoordinates[offset + 1];
  perimeter += Math.sqrt(dx * dx + dy * dy);
  return perimeter;
}

//# sourceMappingURL=length.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/orient.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/geom/flat/orient.js ***!
  \*********************************************/
/*! exports provided: linearRingIsClockwise, linearRingIsOriented, linearRingsAreOriented, orientLinearRings, orientLinearRingsArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearRingIsClockwise", function() { return linearRingIsClockwise; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearRingIsOriented", function() { return linearRingIsOriented; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearRingsAreOriented", function() { return linearRingsAreOriented; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "orientLinearRings", function() { return orientLinearRings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "orientLinearRingsArray", function() { return orientLinearRingsArray; });
/* harmony import */ var _reverse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reverse.js */ "./node_modules/ol/geom/flat/reverse.js");
/**
 * @module ol/geom/flat/orient
 */



/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {boolean} Is clockwise.
 */
function linearRingIsClockwise(flatCoordinates, offset, end, stride) {
  // http://tinyurl.com/clockwise-method
  // https://github.com/OSGeo/gdal/blob/trunk/gdal/ogr/ogrlinearring.cpp
  var edge = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    edge += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }
  return edge > 0;
}


/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `opt_right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean=} opt_right Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */
function linearRingIsOriented(flatCoordinates, offset, ends, stride, opt_right) {
  var right = opt_right !== undefined ? opt_right : false;
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    var isClockwise = linearRingIsClockwise(
      flatCoordinates, offset, end, stride);
    if (i === 0) {
      if ((right && isClockwise) || (!right && !isClockwise)) {
        return false;
      }
    } else {
      if ((right && !isClockwise) || (!right && isClockwise)) {
        return false;
      }
    }
    offset = end;
  }
  return true;
}


/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `opt_right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean=} opt_right Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */
function linearRingsAreOriented(flatCoordinates, offset, endss, stride, opt_right) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    if (!linearRingIsOriented(
      flatCoordinates, offset, endss[i], stride, opt_right)) {
      return false;
    }
  }
  return true;
}


/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `opt_right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {boolean=} opt_right Follow the right-hand rule for orientation.
 * @return {number} End.
 */
function orientLinearRings(flatCoordinates, offset, ends, stride, opt_right) {
  var right = opt_right !== undefined ? opt_right : false;
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    var isClockwise = linearRingIsClockwise(
      flatCoordinates, offset, end, stride);
    var reverse = i === 0 ?
      (right && isClockwise) || (!right && !isClockwise) :
      (right && !isClockwise) || (!right && isClockwise);
    if (reverse) {
      Object(_reverse_js__WEBPACK_IMPORTED_MODULE_0__["coordinates"])(flatCoordinates, offset, end, stride);
    }
    offset = end;
  }
  return offset;
}


/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `opt_right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean=} opt_right Follow the right-hand rule for orientation.
 * @return {number} End.
 */
function orientLinearRingsArray(flatCoordinates, offset, endss, stride, opt_right) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    offset = orientLinearRings(
      flatCoordinates, offset, endss[i], stride, opt_right);
  }
  return offset;
}

//# sourceMappingURL=orient.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/reverse.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/geom/flat/reverse.js ***!
  \**********************************************/
/*! exports provided: coordinates */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "coordinates", function() { return coordinates; });
/**
 * @module ol/geom/flat/reverse
 */


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 */
function coordinates(flatCoordinates, offset, end, stride) {
  while (offset < end - stride) {
    for (var i = 0; i < stride; ++i) {
      var tmp = flatCoordinates[offset + i];
      flatCoordinates[offset + i] = flatCoordinates[end - stride + i];
      flatCoordinates[end - stride + i] = tmp;
    }
    offset += stride;
    end -= stride;
  }
}

//# sourceMappingURL=reverse.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/segments.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/geom/flat/segments.js ***!
  \***********************************************/
/*! exports provided: forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/**
 * @module ol/geom/flat/segments
 */


/**
 * This function calls `callback` for each segment of the flat coordinates
 * array. If the callback returns a truthy value the function returns that
 * value immediately. Otherwise the function returns `false`.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {function(this: S, import("../../coordinate.js").Coordinate, import("../../coordinate.js").Coordinate): T} callback Function
 *     called for each segment.
 * @param {S=} opt_this The object to be used as the value of 'this'
 *     within callback.
 * @return {T|boolean} Value.
 * @template T,S
 */
function forEach(flatCoordinates, offset, end, stride, callback, opt_this) {
  var point1 = [flatCoordinates[offset], flatCoordinates[offset + 1]];
  var point2 = [];
  var ret;
  for (; (offset + stride) < end; offset += stride) {
    point2[0] = flatCoordinates[offset + stride];
    point2[1] = flatCoordinates[offset + stride + 1];
    ret = callback.call(opt_this, point1, point2);
    if (ret) {
      return ret;
    }
    point1[0] = point2[0];
    point1[1] = point2[1];
  }
  return false;
}

//# sourceMappingURL=segments.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/simplify.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/geom/flat/simplify.js ***!
  \***********************************************/
/*! exports provided: simplifyLineString, douglasPeucker, douglasPeuckerArray, douglasPeuckerMultiArray, radialDistance, snap, quantize, quantizeArray, quantizeMultiArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "simplifyLineString", function() { return simplifyLineString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "douglasPeucker", function() { return douglasPeucker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "douglasPeuckerArray", function() { return douglasPeuckerArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "douglasPeuckerMultiArray", function() { return douglasPeuckerMultiArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "radialDistance", function() { return radialDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "snap", function() { return snap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quantize", function() { return quantize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quantizeArray", function() { return quantizeArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quantizeMultiArray", function() { return quantizeMultiArray; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/geom/flat/simplify
 */
// Based on simplify-js https://github.com/mourner/simplify-js
// Copyright (c) 2012, Vladimir Agafonkin
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.




/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {boolean} highQuality Highest quality.
 * @param {Array<number>=} opt_simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @return {Array<number>} Simplified line string.
 */
function simplifyLineString(flatCoordinates, offset, end,
  stride, squaredTolerance, highQuality, opt_simplifiedFlatCoordinates) {
  var simplifiedFlatCoordinates = opt_simplifiedFlatCoordinates !== undefined ?
    opt_simplifiedFlatCoordinates : [];
  if (!highQuality) {
    end = radialDistance(flatCoordinates, offset, end,
      stride, squaredTolerance,
      simplifiedFlatCoordinates, 0);
    flatCoordinates = simplifiedFlatCoordinates;
    offset = 0;
    stride = 2;
  }
  simplifiedFlatCoordinates.length = douglasPeucker(
    flatCoordinates, offset, end, stride, squaredTolerance,
    simplifiedFlatCoordinates, 0);
  return simplifiedFlatCoordinates;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */
function douglasPeucker(flatCoordinates, offset, end,
  stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  var n = (end - offset) / stride;
  if (n < 3) {
    for (; offset < end; offset += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] =
          flatCoordinates[offset];
      simplifiedFlatCoordinates[simplifiedOffset++] =
          flatCoordinates[offset + 1];
    }
    return simplifiedOffset;
  }
  /** @type {Array<number>} */
  var markers = new Array(n);
  markers[0] = 1;
  markers[n - 1] = 1;
  /** @type {Array<number>} */
  var stack = [offset, end - stride];
  var index = 0;
  while (stack.length > 0) {
    var last = stack.pop();
    var first = stack.pop();
    var maxSquaredDistance = 0;
    var x1 = flatCoordinates[first];
    var y1 = flatCoordinates[first + 1];
    var x2 = flatCoordinates[last];
    var y2 = flatCoordinates[last + 1];
    for (var i = first + stride; i < last; i += stride) {
      var x = flatCoordinates[i];
      var y = flatCoordinates[i + 1];
      var squaredDistance = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["squaredSegmentDistance"])(
        x, y, x1, y1, x2, y2);
      if (squaredDistance > maxSquaredDistance) {
        index = i;
        maxSquaredDistance = squaredDistance;
      }
    }
    if (maxSquaredDistance > squaredTolerance) {
      markers[(index - offset) / stride] = 1;
      if (first + stride < index) {
        stack.push(first, index);
      }
      if (index + stride < last) {
        stack.push(index, last);
      }
    }
  }
  for (var i$1 = 0; i$1 < n; ++i$1) {
    if (markers[i$1]) {
      simplifiedFlatCoordinates[simplifiedOffset++] =
          flatCoordinates[offset + i$1 * stride];
      simplifiedFlatCoordinates[simplifiedOffset++] =
          flatCoordinates[offset + i$1 * stride + 1];
    }
  }
  return simplifiedOffset;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */
function douglasPeuckerArray(flatCoordinates, offset,
  ends, stride, squaredTolerance, simplifiedFlatCoordinates,
  simplifiedOffset, simplifiedEnds) {
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    simplifiedOffset = douglasPeucker(
      flatCoordinates, offset, end, stride, squaredTolerance,
      simplifiedFlatCoordinates, simplifiedOffset);
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }
  return simplifiedOffset;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<Array<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */
function douglasPeuckerMultiArray(
  flatCoordinates, offset, endss, stride, squaredTolerance,
  simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    var simplifiedEnds = [];
    simplifiedOffset = douglasPeuckerArray(
      flatCoordinates, offset, ends, stride, squaredTolerance,
      simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
    simplifiedEndss.push(simplifiedEnds);
    offset = ends[ends.length - 1];
  }
  return simplifiedOffset;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */
function radialDistance(flatCoordinates, offset, end,
  stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  if (end <= offset + stride) {
    // zero or one point, no simplification possible, so copy and return
    for (; offset < end; offset += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
      simplifiedFlatCoordinates[simplifiedOffset++] =
          flatCoordinates[offset + 1];
    }
    return simplifiedOffset;
  }
  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1];
  // copy first point
  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1;
  var x2 = x1;
  var y2 = y1;
  for (offset += stride; offset < end; offset += stride) {
    x2 = flatCoordinates[offset];
    y2 = flatCoordinates[offset + 1];
    if (Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["squaredDistance"])(x1, y1, x2, y2) > squaredTolerance) {
      // copy point at offset
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      x1 = x2;
      y1 = y2;
    }
  }
  if (x2 != x1 || y2 != y1) {
    // copy last point
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  }
  return simplifiedOffset;
}


/**
 * @param {number} value Value.
 * @param {number} tolerance Tolerance.
 * @return {number} Rounded value.
 */
function snap(value, tolerance) {
  return tolerance * Math.round(value / tolerance);
}


/**
 * Simplifies a line string using an algorithm designed by Tim Schaub.
 * Coordinates are snapped to the nearest value in a virtual grid and
 * consecutive duplicate coordinates are discarded.  This effectively preserves
 * topology as the simplification of any subsection of a line string is
 * independent of the rest of the line string.  This means that, for examples,
 * the common edge between two polygons will be simplified to the same line
 * string independently in both polygons.  This implementation uses a single
 * pass over the coordinates and eliminates intermediate collinear points.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */
function quantize(flatCoordinates, offset, end, stride,
  tolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  // do nothing if the line is empty
  if (offset == end) {
    return simplifiedOffset;
  }
  // snap the first coordinate (P1)
  var x1 = snap(flatCoordinates[offset], tolerance);
  var y1 = snap(flatCoordinates[offset + 1], tolerance);
  offset += stride;
  // add the first coordinate to the output
  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1;
  // find the next coordinate that does not snap to the same value as the first
  // coordinate (P2)
  var x2, y2;
  do {
    x2 = snap(flatCoordinates[offset], tolerance);
    y2 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;
    if (offset == end) {
      // all coordinates snap to the same value, the line collapses to a point
      // push the last snapped value anyway to ensure that the output contains
      // at least two points
      // FIXME should we really return at least two points anyway?
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      return simplifiedOffset;
    }
  } while (x2 == x1 && y2 == y1);
  while (offset < end) {
    // snap the next coordinate (P3)
    var x3 = snap(flatCoordinates[offset], tolerance);
    var y3 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;
    // skip P3 if it is equal to P2
    if (x3 == x2 && y3 == y2) {
      continue;
    }
    // calculate the delta between P1 and P2
    var dx1 = x2 - x1;
    var dy1 = y2 - y1;
    // calculate the delta between P3 and P1
    var dx2 = x3 - x1;
    var dy2 = y3 - y1;
    // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from
    // P1 in the same direction then P2 is on the straight line between P1 and
    // P3
    if ((dx1 * dy2 == dy1 * dx2) &&
        ((dx1 < 0 && dx2 < dx1) || dx1 == dx2 || (dx1 > 0 && dx2 > dx1)) &&
        ((dy1 < 0 && dy2 < dy1) || dy1 == dy2 || (dy1 > 0 && dy2 > dy1))) {
      // discard P2 and set P2 = P3
      x2 = x3;
      y2 = y3;
      continue;
    }
    // either P1, P2, and P3 are not colinear, or they are colinear but P3 is
    // between P3 and P1 or on the opposite half of the line to P2.  add P2,
    // and continue with P1 = P2 and P2 = P3
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
    x1 = x2;
    y1 = y2;
    x2 = x3;
    y2 = y3;
  }
  // add the last point (P2)
  simplifiedFlatCoordinates[simplifiedOffset++] = x2;
  simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  return simplifiedOffset;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */
function quantizeArray(
  flatCoordinates, offset, ends, stride,
  tolerance,
  simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    simplifiedOffset = quantize(
      flatCoordinates, offset, end, stride,
      tolerance,
      simplifiedFlatCoordinates, simplifiedOffset);
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }
  return simplifiedOffset;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<Array<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */
function quantizeMultiArray(
  flatCoordinates, offset, endss, stride,
  tolerance,
  simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    var simplifiedEnds = [];
    simplifiedOffset = quantizeArray(
      flatCoordinates, offset, ends, stride,
      tolerance,
      simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
    simplifiedEndss.push(simplifiedEnds);
    offset = ends[ends.length - 1];
  }
  return simplifiedOffset;
}

//# sourceMappingURL=simplify.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/straightchunk.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/geom/flat/straightchunk.js ***!
  \****************************************************/
/*! exports provided: matchingChunk */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matchingChunk", function() { return matchingChunk; });
/**
 * @module ol/geom/flat/straightchunk
 */


/**
 * @param {number} maxAngle Maximum acceptable angle delta between segments.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {Array<number>} Start and end of the first suitable chunk of the
 * given `flatCoordinates`.
 */
function matchingChunk(maxAngle, flatCoordinates, offset, end, stride) {
  var chunkStart = offset;
  var chunkEnd = offset;
  var chunkM = 0;
  var m = 0;
  var start = offset;
  var acos, i, m12, m23, x1, y1, x12, y12, x23, y23;
  for (i = offset; i < end; i += stride) {
    var x2 = flatCoordinates[i];
    var y2 = flatCoordinates[i + 1];
    if (x1 !== undefined) {
      x23 = x2 - x1;
      y23 = y2 - y1;
      m23 = Math.sqrt(x23 * x23 + y23 * y23);
      if (x12 !== undefined) {
        m += m12;
        acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));
        if (acos > maxAngle) {
          if (m > chunkM) {
            chunkM = m;
            chunkStart = start;
            chunkEnd = i;
          }
          m = 0;
          start = i - stride;
        }
      }
      m12 = m23;
      x12 = x23;
      y12 = y23;
    }
    x1 = x2;
    y1 = y2;
  }
  m += m23;
  return m > chunkM ? [start, i] : [chunkStart, chunkEnd];
}

//# sourceMappingURL=straightchunk.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/textpath.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/geom/flat/textpath.js ***!
  \***********************************************/
/*! exports provided: drawTextOnPath */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawTextOnPath", function() { return drawTextOnPath; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/geom/flat/textpath
 */



/**
 * @param {Array<number>} flatCoordinates Path to put text on.
 * @param {number} offset Start offset of the `flatCoordinates`.
 * @param {number} end End offset of the `flatCoordinates`.
 * @param {number} stride Stride.
 * @param {string} text Text to place on the path.
 * @param {function(string):number} measure Measure function returning the
 * width of the character passed as 1st argument.
 * @param {number} startM m along the path where the text starts.
 * @param {number} maxAngle Max angle between adjacent chars in radians.
 * @return {Array<Array<*>>} The result array of null if `maxAngle` was
 * exceeded. Entries of the array are x, y, anchorX, angle, chunk.
 */
function drawTextOnPath(
  flatCoordinates, offset, end, stride, text, measure, startM, maxAngle) {
  var result = [];

  // Keep text upright
  var reverse = flatCoordinates[offset] > flatCoordinates[end - stride];

  var numChars = text.length;

  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1];
  offset += stride;
  var x2 = flatCoordinates[offset];
  var y2 = flatCoordinates[offset + 1];
  var segmentM = 0;
  var segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));

  var chunk = '';
  var chunkLength = 0;
  var data, index, previousAngle;
  for (var i = 0; i < numChars; ++i) {
    index = reverse ? numChars - i - 1 : i;
    var char = text.charAt(index);
    chunk = reverse ? char + chunk : chunk + char;
    var charLength = measure(chunk) - chunkLength;
    chunkLength += charLength;
    var charM = startM + charLength / 2;
    while (offset < end - stride && segmentM + segmentLength < charM) {
      x1 = x2;
      y1 = y2;
      offset += stride;
      x2 = flatCoordinates[offset];
      y2 = flatCoordinates[offset + 1];
      segmentM += segmentLength;
      segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    }
    var segmentPos = charM - segmentM;
    var angle = Math.atan2(y2 - y1, x2 - x1);
    if (reverse) {
      angle += angle > 0 ? -Math.PI : Math.PI;
    }
    if (previousAngle !== undefined) {
      var delta = angle - previousAngle;
      delta += (delta > Math.PI) ? -2 * Math.PI : (delta < -Math.PI) ? 2 * Math.PI : 0;
      if (Math.abs(delta) > maxAngle) {
        return null;
      }
    }
    var interpolate = segmentPos / segmentLength;
    var x = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["lerp"])(x1, x2, interpolate);
    var y = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["lerp"])(y1, y2, interpolate);
    if (previousAngle == angle) {
      if (reverse) {
        data[0] = x;
        data[1] = y;
        data[2] = charLength / 2;
      }
      data[4] = chunk;
    } else {
      chunk = char;
      chunkLength = charLength;
      data = [x, y, charLength / 2, angle, chunk];
      if (reverse) {
        result.unshift(data);
      } else {
        result.push(data);
      }
      previousAngle = angle;
    }
    startM += charLength;
  }
  return result;
}

//# sourceMappingURL=textpath.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/transform.js":
/*!************************************************!*\
  !*** ./node_modules/ol/geom/flat/transform.js ***!
  \************************************************/
/*! exports provided: transform2D, rotate, scale, translate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transform2D", function() { return transform2D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/**
 * @module ol/geom/flat/transform
 */


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../transform.js").Transform} transform Transform.
 * @param {Array<number>=} opt_dest Destination.
 * @return {Array<number>} Transformed coordinates.
 */
function transform2D(flatCoordinates, offset, end, stride, transform, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var i = 0;
  for (var j = offset; j < end; j += stride) {
    var x = flatCoordinates[j];
    var y = flatCoordinates[j + 1];
    dest[i++] = transform[0] * x + transform[2] * y + transform[4];
    dest[i++] = transform[1] * x + transform[3] * y + transform[5];
  }
  if (opt_dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} angle Angle.
 * @param {Array<number>} anchor Rotation anchor point.
 * @param {Array<number>=} opt_dest Destination.
 * @return {Array<number>} Transformed coordinates.
 */
function rotate(flatCoordinates, offset, end, stride, angle, anchor, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var cos = Math.cos(angle);
  var sin = Math.sin(angle);
  var anchorX = anchor[0];
  var anchorY = anchor[1];
  var i = 0;
  for (var j = offset; j < end; j += stride) {
    var deltaX = flatCoordinates[j] - anchorX;
    var deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + deltaX * cos - deltaY * sin;
    dest[i++] = anchorY + deltaX * sin + deltaY * cos;
    for (var k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (opt_dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}


/**
 * Scale the coordinates.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} sx Scale factor in the x-direction.
 * @param {number} sy Scale factor in the y-direction.
 * @param {Array<number>} anchor Scale anchor point.
 * @param {Array<number>=} opt_dest Destination.
 * @return {Array<number>} Transformed coordinates.
 */
function scale(flatCoordinates, offset, end, stride, sx, sy, anchor, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var anchorX = anchor[0];
  var anchorY = anchor[1];
  var i = 0;
  for (var j = offset; j < end; j += stride) {
    var deltaX = flatCoordinates[j] - anchorX;
    var deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + sx * deltaX;
    dest[i++] = anchorY + sy * deltaY;
    for (var k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (opt_dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} deltaX Delta X.
 * @param {number} deltaY Delta Y.
 * @param {Array<number>=} opt_dest Destination.
 * @return {Array<number>} Transformed coordinates.
 */
function translate(flatCoordinates, offset, end, stride, deltaX, deltaY, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var i = 0;
  for (var j = offset; j < end; j += stride) {
    dest[i++] = flatCoordinates[j] + deltaX;
    dest[i++] = flatCoordinates[j + 1] + deltaY;
    for (var k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (opt_dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}

//# sourceMappingURL=transform.js.map

/***/ }),

/***/ "./node_modules/ol/has.js":
/*!********************************!*\
  !*** ./node_modules/ol/has.js ***!
  \********************************/
/*! exports provided: FIREFOX, SAFARI, WEBKIT, MAC, DEVICE_PIXEL_RATIO, CANVAS_LINE_DASH, GEOLOCATION, TOUCH, POINTER, MSPOINTER, WEBGL */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FIREFOX", function() { return FIREFOX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SAFARI", function() { return SAFARI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WEBKIT", function() { return WEBKIT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAC", function() { return MAC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEVICE_PIXEL_RATIO", function() { return DEVICE_PIXEL_RATIO; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CANVAS_LINE_DASH", function() { return CANVAS_LINE_DASH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GEOLOCATION", function() { return GEOLOCATION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOUCH", function() { return TOUCH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POINTER", function() { return POINTER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MSPOINTER", function() { return MSPOINTER; });
/* harmony import */ var _webgl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webgl.js */ "./node_modules/ol/webgl.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WEBGL", function() { return _webgl_js__WEBPACK_IMPORTED_MODULE_0__["HAS"]; });

/**
 * @module ol/has
 */

var ua = typeof navigator !== 'undefined' ?
  navigator.userAgent.toLowerCase() : '';

/**
 * User agent string says we are dealing with Firefox as browser.
 * @type {boolean}
 */
var FIREFOX = ua.indexOf('firefox') !== -1;

/**
 * User agent string says we are dealing with Safari as browser.
 * @type {boolean}
 */
var SAFARI = ua.indexOf('safari') !== -1 && ua.indexOf('chrom') == -1;

/**
 * User agent string says we are dealing with a WebKit engine.
 * @type {boolean}
 */
var WEBKIT = ua.indexOf('webkit') !== -1 && ua.indexOf('edge') == -1;

/**
 * User agent string says we are dealing with a Mac as platform.
 * @type {boolean}
 */
var MAC = ua.indexOf('macintosh') !== -1;


/**
 * The ratio between physical pixels and device-independent pixels
 * (dips) on the device (`window.devicePixelRatio`).
 * @const
 * @type {number}
 * @api
 */
var DEVICE_PIXEL_RATIO = window.devicePixelRatio || 1;


/**
 * True if the browser's Canvas implementation implements {get,set}LineDash.
 * @type {boolean}
 */
var CANVAS_LINE_DASH = function() {
  var has = false;
  try {
    has = !!document.createElement('canvas').getContext('2d').setLineDash;
  } catch (e) {
    // pass
  }
  return has;
}();


/**
 * Is HTML5 geolocation supported in the current browser?
 * @const
 * @type {boolean}
 * @api
 */
var GEOLOCATION = 'geolocation' in navigator;


/**
 * True if browser supports touch events.
 * @const
 * @type {boolean}
 * @api
 */
var TOUCH = 'ontouchstart' in window;


/**
 * True if browser supports pointer events.
 * @const
 * @type {boolean}
 */
var POINTER = 'PointerEvent' in window;


/**
 * True if browser supports ms pointer events (IE 10).
 * @const
 * @type {boolean}
 */
var MSPOINTER = !!(navigator.msPointerEnabled);




//# sourceMappingURL=has.js.map

/***/ }),

/***/ "./node_modules/ol/interaction.js":
/*!****************************************!*\
  !*** ./node_modules/ol/interaction.js ***!
  \****************************************/
/*! exports provided: DoubleClickZoom, DragAndDrop, DragBox, DragPan, DragRotate, DragRotateAndZoom, DragZoom, Draw, Extent, Interaction, KeyboardPan, KeyboardZoom, Modify, MouseWheelZoom, PinchRotate, PinchZoom, Pointer, Select, Snap, Translate, defaults */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaults", function() { return defaults; });
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Collection.js */ "./node_modules/ol/Collection.js");
/* harmony import */ var _Kinetic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Kinetic.js */ "./node_modules/ol/Kinetic.js");
/* harmony import */ var _interaction_DoubleClickZoom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interaction/DoubleClickZoom.js */ "./node_modules/ol/interaction/DoubleClickZoom.js");
/* harmony import */ var _interaction_DragPan_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interaction/DragPan.js */ "./node_modules/ol/interaction/DragPan.js");
/* harmony import */ var _interaction_DragRotate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./interaction/DragRotate.js */ "./node_modules/ol/interaction/DragRotate.js");
/* harmony import */ var _interaction_DragZoom_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./interaction/DragZoom.js */ "./node_modules/ol/interaction/DragZoom.js");
/* harmony import */ var _interaction_KeyboardPan_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./interaction/KeyboardPan.js */ "./node_modules/ol/interaction/KeyboardPan.js");
/* harmony import */ var _interaction_KeyboardZoom_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./interaction/KeyboardZoom.js */ "./node_modules/ol/interaction/KeyboardZoom.js");
/* harmony import */ var _interaction_MouseWheelZoom_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./interaction/MouseWheelZoom.js */ "./node_modules/ol/interaction/MouseWheelZoom.js");
/* harmony import */ var _interaction_PinchRotate_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./interaction/PinchRotate.js */ "./node_modules/ol/interaction/PinchRotate.js");
/* harmony import */ var _interaction_PinchZoom_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./interaction/PinchZoom.js */ "./node_modules/ol/interaction/PinchZoom.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DoubleClickZoom", function() { return _interaction_DoubleClickZoom_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _interaction_DragAndDrop_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./interaction/DragAndDrop.js */ "./node_modules/ol/interaction/DragAndDrop.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DragAndDrop", function() { return _interaction_DragAndDrop_js__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _interaction_DragBox_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./interaction/DragBox.js */ "./node_modules/ol/interaction/DragBox.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DragBox", function() { return _interaction_DragBox_js__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DragPan", function() { return _interaction_DragPan_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DragRotate", function() { return _interaction_DragRotate_js__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _interaction_DragRotateAndZoom_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./interaction/DragRotateAndZoom.js */ "./node_modules/ol/interaction/DragRotateAndZoom.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DragRotateAndZoom", function() { return _interaction_DragRotateAndZoom_js__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DragZoom", function() { return _interaction_DragZoom_js__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _interaction_Draw_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./interaction/Draw.js */ "./node_modules/ol/interaction/Draw.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Draw", function() { return _interaction_Draw_js__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony import */ var _interaction_Extent_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./interaction/Extent.js */ "./node_modules/ol/interaction/Extent.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Extent", function() { return _interaction_Extent_js__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony import */ var _interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./interaction/Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Interaction", function() { return _interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "KeyboardPan", function() { return _interaction_KeyboardPan_js__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "KeyboardZoom", function() { return _interaction_KeyboardZoom_js__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _interaction_Modify_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./interaction/Modify.js */ "./node_modules/ol/interaction/Modify.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Modify", function() { return _interaction_Modify_js__WEBPACK_IMPORTED_MODULE_18__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MouseWheelZoom", function() { return _interaction_MouseWheelZoom_js__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PinchRotate", function() { return _interaction_PinchRotate_js__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PinchZoom", function() { return _interaction_PinchZoom_js__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _interaction_Pointer_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./interaction/Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Pointer", function() { return _interaction_Pointer_js__WEBPACK_IMPORTED_MODULE_19__["default"]; });

/* harmony import */ var _interaction_Select_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./interaction/Select.js */ "./node_modules/ol/interaction/Select.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Select", function() { return _interaction_Select_js__WEBPACK_IMPORTED_MODULE_20__["default"]; });

/* harmony import */ var _interaction_Snap_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./interaction/Snap.js */ "./node_modules/ol/interaction/Snap.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Snap", function() { return _interaction_Snap_js__WEBPACK_IMPORTED_MODULE_21__["default"]; });

/* harmony import */ var _interaction_Translate_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./interaction/Translate.js */ "./node_modules/ol/interaction/Translate.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Translate", function() { return _interaction_Translate_js__WEBPACK_IMPORTED_MODULE_22__["default"]; });

/**
 * @module ol/interaction
 */



































/**
 * @typedef {Object} DefaultsOptions
 * @property {boolean} [altShiftDragRotate=true] Whether Alt-Shift-drag rotate is
 * desired.
 * @property {boolean} [onFocusOnly=false] Interact only when the map has the
 * focus. This affects the `MouseWheelZoom` and `DragPan` interactions and is
 * useful when page scroll is desired for maps that do not have the browser's
 * focus.
 * @property {boolean} [constrainResolution=false] Zoom to the closest integer
 * zoom level after the wheel/trackpad or pinch gesture ends.
 * @property {boolean} [doubleClickZoom=true] Whether double click zoom is
 * desired.
 * @property {boolean} [keyboard=true] Whether keyboard interaction is desired.
 * @property {boolean} [mouseWheelZoom=true] Whether mousewheel zoom is desired.
 * @property {boolean} [shiftDragZoom=true] Whether Shift-drag zoom is desired.
 * @property {boolean} [dragPan=true] Whether drag pan is desired.
 * @property {boolean} [pinchRotate=true] Whether pinch rotate is desired.
 * @property {boolean} [pinchZoom=true] Whether pinch zoom is desired.
 * @property {number} [zoomDelta] Zoom level delta when using keyboard or
 * mousewheel zoom.
 * @property {number} [zoomDuration] Duration of the zoom animation in
 * milliseconds.
 */


/**
 * Set of interactions included in maps by default. Specific interactions can be
 * excluded by setting the appropriate option to false in the constructor
 * options, but the order of the interactions is fixed.  If you want to specify
 * a different order for interactions, you will need to create your own
 * {@link module:ol/interaction/Interaction} instances and insert
 * them into a {@link module:ol/Collection} in the order you want
 * before creating your {@link module:ol/Map~Map} instance. The default set of
 * interactions, in sequence, is:
 * * {@link module:ol/interaction/DragRotate~DragRotate}
 * * {@link module:ol/interaction/DoubleClickZoom~DoubleClickZoom}
 * * {@link module:ol/interaction/DragPan~DragPan}
 * * {@link module:ol/interaction/PinchRotate~PinchRotate}
 * * {@link module:ol/interaction/PinchZoom~PinchZoom}
 * * {@link module:ol/interaction/KeyboardPan~KeyboardPan}
 * * {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}
 * * {@link module:ol/interaction/MouseWheelZoom~MouseWheelZoom}
 * * {@link module:ol/interaction/DragZoom~DragZoom}
 *
 * @param {DefaultsOptions=} opt_options Defaults options.
 * @return {import("./Collection.js").default<import("./interaction/Interaction.js").default>}
 * A collection of interactions to be used with the {@link module:ol/Map~Map}
 * constructor's `interactions` option.
 * @api
 */
function defaults(opt_options) {

  var options = opt_options ? opt_options : {};

  var interactions = new _Collection_js__WEBPACK_IMPORTED_MODULE_0__["default"]();

  var kinetic = new _Kinetic_js__WEBPACK_IMPORTED_MODULE_1__["default"](-0.005, 0.05, 100);

  var altShiftDragRotate = options.altShiftDragRotate !== undefined ?
    options.altShiftDragRotate : true;
  if (altShiftDragRotate) {
    interactions.push(new _interaction_DragRotate_js__WEBPACK_IMPORTED_MODULE_4__["default"]());
  }

  var doubleClickZoom = options.doubleClickZoom !== undefined ?
    options.doubleClickZoom : true;
  if (doubleClickZoom) {
    interactions.push(new _interaction_DoubleClickZoom_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
      delta: options.zoomDelta,
      duration: options.zoomDuration
    }));
  }

  var dragPan = options.dragPan !== undefined ? options.dragPan : true;
  if (dragPan) {
    interactions.push(new _interaction_DragPan_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
      condition: options.onFocusOnly ? _events_condition_js__WEBPACK_IMPORTED_MODULE_11__["focus"] : undefined,
      kinetic: kinetic
    }));
  }

  var pinchRotate = options.pinchRotate !== undefined ? options.pinchRotate :
    true;
  if (pinchRotate) {
    interactions.push(new _interaction_PinchRotate_js__WEBPACK_IMPORTED_MODULE_9__["default"]());
  }

  var pinchZoom = options.pinchZoom !== undefined ? options.pinchZoom : true;
  if (pinchZoom) {
    interactions.push(new _interaction_PinchZoom_js__WEBPACK_IMPORTED_MODULE_10__["default"]({
      constrainResolution: options.constrainResolution,
      duration: options.zoomDuration
    }));
  }

  var keyboard = options.keyboard !== undefined ? options.keyboard : true;
  if (keyboard) {
    interactions.push(new _interaction_KeyboardPan_js__WEBPACK_IMPORTED_MODULE_6__["default"]());
    interactions.push(new _interaction_KeyboardZoom_js__WEBPACK_IMPORTED_MODULE_7__["default"]({
      delta: options.zoomDelta,
      duration: options.zoomDuration
    }));
  }

  var mouseWheelZoom = options.mouseWheelZoom !== undefined ?
    options.mouseWheelZoom : true;
  if (mouseWheelZoom) {
    interactions.push(new _interaction_MouseWheelZoom_js__WEBPACK_IMPORTED_MODULE_8__["default"]({
      condition: options.onFocusOnly ? _events_condition_js__WEBPACK_IMPORTED_MODULE_11__["focus"] : undefined,
      constrainResolution: options.constrainResolution,
      duration: options.zoomDuration
    }));
  }

  var shiftDragZoom = options.shiftDragZoom !== undefined ?
    options.shiftDragZoom : true;
  if (shiftDragZoom) {
    interactions.push(new _interaction_DragZoom_js__WEBPACK_IMPORTED_MODULE_5__["default"]({
      duration: options.zoomDuration
    }));
  }

  return interactions;

}

//# sourceMappingURL=interaction.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/DoubleClickZoom.js":
/*!********************************************************!*\
  !*** ./node_modules/ol/interaction/DoubleClickZoom.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MapBrowserEventType.js */ "./node_modules/ol/MapBrowserEventType.js");
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/**
 * @module ol/interaction/DoubleClickZoom
 */




/**
 * @typedef {Object} Options
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {number} [delta=1] The zoom delta applied on each double click.
 */


/**
 * @classdesc
 * Allows the user to zoom by double-clicking on the map.
 * @api
 */
var DoubleClickZoom = /*@__PURE__*/(function (Interaction) {
  function DoubleClickZoom(opt_options) {
    Interaction.call(this, {
      handleEvent: handleEvent
    });

    var options = opt_options ? opt_options : {};

    /**
     * @private
     * @type {number}
     */
    this.delta_ = options.delta ? options.delta : 1;

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 250;

  }

  if ( Interaction ) DoubleClickZoom.__proto__ = Interaction;
  DoubleClickZoom.prototype = Object.create( Interaction && Interaction.prototype );
  DoubleClickZoom.prototype.constructor = DoubleClickZoom;

  return DoubleClickZoom;
}(_Interaction_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/**
 * Handles the {@link module:ol/MapBrowserEvent map browser event} (if it was a
 * doubleclick) and eventually zooms the map.
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} `false` to stop event propagation.
 * @this {DoubleClickZoom}
 */
function handleEvent(mapBrowserEvent) {
  var stopEvent = false;
  if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].DBLCLICK) {
    var browserEvent = /** @type {MouseEvent} */ (mapBrowserEvent.originalEvent);
    var map = mapBrowserEvent.map;
    var anchor = mapBrowserEvent.coordinate;
    var delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;
    var view = map.getView();
    Object(_Interaction_js__WEBPACK_IMPORTED_MODULE_1__["zoomByDelta"])(view, delta, anchor, this.duration_);
    mapBrowserEvent.preventDefault();
    stopEvent = true;
  }
  return !stopEvent;
}

/* harmony default export */ __webpack_exports__["default"] = (DoubleClickZoom);

//# sourceMappingURL=DoubleClickZoom.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/DragAndDrop.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/interaction/DragAndDrop.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/**
 * @module ol/interaction/DragAndDrop
 */
// FIXME should handle all geo-referenced data, not just vector data









/**
 * @typedef {Object} Options
 * @property {Array<typeof import("../format/Feature.js").default>} [formatConstructors] Format constructors.
 * @property {import("../source/Vector.js").default} [source] Optional vector source where features will be added.  If a source is provided
 * all existing features will be removed and new features will be added when
 * they are dropped on the target.  If you want to add features to a vector
 * source without removing the existing features (append only), instead of
 * providing the source option listen for the "addfeatures" event.
 * @property {import("../proj.js").ProjectionLike} [projection] Target projection. By default, the map's view's projection is used.
 * @property {HTMLElement} [target] The element that is used as the drop target, default is the viewport element.
 */


/**
 * @enum {string}
 */
var DragAndDropEventType = {
  /**
   * Triggered when features are added
   * @event DragAndDropEvent#addfeatures
   * @api
   */
  ADD_FEATURES: 'addfeatures'
};


/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/DragAndDrop~DragAndDrop} instances are instances
 * of this type.
 */
var DragAndDropEvent = /*@__PURE__*/(function (Event) {
  function DragAndDropEvent(type, file, opt_features, opt_projection) {

    Event.call(this, type);

    /**
     * The features parsed from dropped data.
     * @type {Array<import("../Feature.js").FeatureLike>|undefined}
     * @api
     */
    this.features = opt_features;

    /**
     * The dropped file.
     * @type {File}
     * @api
     */
    this.file = file;

    /**
     * The feature projection.
     * @type {import("../proj/Projection.js").default|undefined}
     * @api
     */
    this.projection = opt_projection;

  }

  if ( Event ) DragAndDropEvent.__proto__ = Event;
  DragAndDropEvent.prototype = Object.create( Event && Event.prototype );
  DragAndDropEvent.prototype.constructor = DragAndDropEvent;

  return DragAndDropEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_2__["default"]));


/**
 * @classdesc
 * Handles input of vector data by drag and drop.
 * @api
 *
 * @fires DragAndDropEvent
 */
var DragAndDrop = /*@__PURE__*/(function (Interaction) {
  function DragAndDrop(opt_options) {

    var options = opt_options ? opt_options : {};

    Interaction.call(this, {
      handleEvent: _functions_js__WEBPACK_IMPORTED_MODULE_0__["TRUE"]
    });

    /**
     * @private
     * @type {Array<typeof import("../format/Feature.js").default>}
     */
    this.formatConstructors_ = options.formatConstructors ?
      options.formatConstructors : [];

    /**
     * @private
     * @type {import("../proj/Projection.js").default}
     */
    this.projection_ = options.projection ?
      Object(_proj_js__WEBPACK_IMPORTED_MODULE_5__["get"])(options.projection) : null;

    /**
     * @private
     * @type {Array<import("../events.js").EventsKey>}
     */
    this.dropListenKeys_ = null;

    /**
     * @private
     * @type {import("../source/Vector.js").default}
     */
    this.source_ = options.source || null;

    /**
     * @private
     * @type {HTMLElement}
     */
    this.target = options.target ? options.target : null;

  }

  if ( Interaction ) DragAndDrop.__proto__ = Interaction;
  DragAndDrop.prototype = Object.create( Interaction && Interaction.prototype );
  DragAndDrop.prototype.constructor = DragAndDrop;

  /**
   * @param {File} file File.
   * @param {Event} event Load event.
   * @private
   */
  DragAndDrop.prototype.handleResult_ = function handleResult_ (file, event) {
    var result = event.target.result;
    var map = this.getMap();
    var projection = this.projection_;
    if (!projection) {
      var view = map.getView();
      projection = view.getProjection();
    }

    var formatConstructors = this.formatConstructors_;
    var features = [];
    for (var i = 0, ii = formatConstructors.length; i < ii; ++i) {
      var format = new formatConstructors[i]();
      features = this.tryReadFeatures_(format, result, {
        featureProjection: projection
      });
      if (features && features.length > 0) {
        break;
      }
    }
    if (this.source_) {
      this.source_.clear();
      this.source_.addFeatures(features);
    }
    this.dispatchEvent(
      new DragAndDropEvent(
        DragAndDropEventType.ADD_FEATURES, file,
        features, projection));
  };

  /**
   * @private
   */
  DragAndDrop.prototype.registerListeners_ = function registerListeners_ () {
    var map = this.getMap();
    if (map) {
      var dropArea = this.target ? this.target : map.getViewport();
      this.dropListenKeys_ = [
        Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["listen"])(dropArea, _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].DROP, handleDrop, this),
        Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["listen"])(dropArea, _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].DRAGENTER, handleStop, this),
        Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["listen"])(dropArea, _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].DRAGOVER, handleStop, this),
        Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["listen"])(dropArea, _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].DROP, handleStop, this)
      ];
    }
  };

  /**
   * @inheritDoc
   */
  DragAndDrop.prototype.setActive = function setActive (active) {
    Interaction.prototype.setActive.call(this, active);
    if (active) {
      this.registerListeners_();
    } else {
      this.unregisterListeners_();
    }
  };

  /**
   * @inheritDoc
   */
  DragAndDrop.prototype.setMap = function setMap (map) {
    this.unregisterListeners_();
    Interaction.prototype.setMap.call(this, map);
    if (this.getActive()) {
      this.registerListeners_();
    }
  };

  /**
   * @param {import("../format/Feature.js").default} format Format.
   * @param {string} text Text.
   * @param {import("../format/Feature.js").ReadOptions} options Read options.
   * @private
   * @return {Array<import("../Feature.js").FeatureLike>} Features.
   */
  DragAndDrop.prototype.tryReadFeatures_ = function tryReadFeatures_ (format, text, options) {
    try {
      return format.readFeatures(text, options);
    } catch (e) {
      return null;
    }
  };

  /**
   * @private
   */
  DragAndDrop.prototype.unregisterListeners_ = function unregisterListeners_ () {
    if (this.dropListenKeys_) {
      this.dropListenKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_1__["unlistenByKey"]);
      this.dropListenKeys_ = null;
    }
  };

  return DragAndDrop;
}(_Interaction_js__WEBPACK_IMPORTED_MODULE_4__["default"]));


/**
 * @param {DragEvent} event Event.
 * @this {DragAndDrop}
 */
function handleDrop(event) {
  var files = event.dataTransfer.files;
  for (var i = 0, ii = files.length; i < ii; ++i) {
    var file = files.item(i);
    var reader = new FileReader();
    reader.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].LOAD, this.handleResult_.bind(this, file));
    reader.readAsText(file);
  }
}


/**
 * @param {DragEvent} event Event.
 */
function handleStop(event) {
  event.stopPropagation();
  event.preventDefault();
  event.dataTransfer.dropEffect = 'copy';
}


/* harmony default export */ __webpack_exports__["default"] = (DragAndDrop);

//# sourceMappingURL=DragAndDrop.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/DragBox.js":
/*!************************************************!*\
  !*** ./node_modules/ol/interaction/DragBox.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/* harmony import */ var _render_Box_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../render/Box.js */ "./node_modules/ol/render/Box.js");
/**
 * @module ol/interaction/DragBox
 */
// FIXME draw drag box







/**
 * A function that takes a {@link module:ol/MapBrowserEvent} and two
 * {@link module:ol/pixel~Pixel}s and returns a `{boolean}`. If the condition is met,
 * true should be returned.
 * @typedef {function(this: ?, import("../MapBrowserEvent.js").default, import("../pixel.js").Pixel, import("../pixel.js").Pixel):boolean} EndCondition
 */


/**
 * @typedef {Object} Options
 * @property {string} [className='ol-dragbox'] CSS class name for styling the box.
 * @property {import("../events/condition.js").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link ol/events/condition~always}.
 * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the default
 * `boxEndCondition` function.
 * @property {EndCondition} [boxEndCondition] A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two
 * {@link module:ol/pixel~Pixel}s to indicate whether a `boxend` event should be fired.
 * Default is `true` if the area of the box is bigger than the `minArea` option.
 * @property {function(this:DragBox, import("../MapBrowserEvent.js").default)} onBoxEnd Code to execute just
 * before `boxend` is fired.
 */


/**
 * @enum {string}
 */
var DragBoxEventType = {
  /**
   * Triggered upon drag box start.
   * @event DragBoxEvent#boxstart
   * @api
   */
  BOXSTART: 'boxstart',

  /**
   * Triggered on drag when box is active.
   * @event DragBoxEvent#boxdrag
   * @api
   */
  BOXDRAG: 'boxdrag',

  /**
   * Triggered upon drag box end.
   * @event DragBoxEvent#boxend
   * @api
   */
  BOXEND: 'boxend'
};


/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/DragBox~DragBox} instances are instances of
 * this type.
 */
var DragBoxEvent = /*@__PURE__*/(function (Event) {
  function DragBoxEvent(type, coordinate, mapBrowserEvent) {
    Event.call(this, type);

    /**
     * The coordinate of the drag event.
     * @const
     * @type {import("../coordinate.js").Coordinate}
     * @api
     */
    this.coordinate = coordinate;

    /**
     * @const
     * @type {import("../MapBrowserEvent.js").default}
     * @api
     */
    this.mapBrowserEvent = mapBrowserEvent;

  }

  if ( Event ) DragBoxEvent.__proto__ = Event;
  DragBoxEvent.prototype = Object.create( Event && Event.prototype );
  DragBoxEvent.prototype.constructor = DragBoxEvent;

  return DragBoxEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/**
 * @classdesc
 * Allows the user to draw a vector box by clicking and dragging on the map,
 * normally combined with an {@link module:ol/events/condition} that limits
 * it to when the shift or other key is held down. This is used, for example,
 * for zooming to a specific area of the map
 * (see {@link module:ol/interaction/DragZoom~DragZoom} and
 * {@link module:ol/interaction/DragRotateAndZoom}).
 *
 * This interaction is only supported for mouse devices.
 *
 * @fires DragBoxEvent
 * @api
 */
var DragBox = /*@__PURE__*/(function (PointerInteraction) {
  function DragBox(opt_options) {

    PointerInteraction.call(this);

    var options = opt_options ? opt_options : {};

    /**
    * @type {import("../render/Box.js").default}
    * @private
    */
    this.box_ = new _render_Box_js__WEBPACK_IMPORTED_MODULE_4__["default"](options.className || 'ol-dragbox');

    /**
    * @type {number}
    * @private
    */
    this.minArea_ = options.minArea !== undefined ? options.minArea : 64;

    /**
     * Function to execute just before `onboxend` is fired
     * @type {function(this:DragBox, import("../MapBrowserEvent.js").default)}
     * @private
     */
    this.onBoxEnd_ = options.onBoxEnd ? options.onBoxEnd : _functions_js__WEBPACK_IMPORTED_MODULE_2__["VOID"];

    /**
    * @type {import("../pixel.js").Pixel}
    * @private
    */
    this.startPixel_ = null;

    /**
    * @private
    * @type {import("../events/condition.js").Condition}
    */
    this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_1__["always"];

    /**
    * @private
    * @type {EndCondition}
    */
    this.boxEndCondition_ = options.boxEndCondition ?
      options.boxEndCondition : this.defaultBoxEndCondition;
  }

  if ( PointerInteraction ) DragBox.__proto__ = PointerInteraction;
  DragBox.prototype = Object.create( PointerInteraction && PointerInteraction.prototype );
  DragBox.prototype.constructor = DragBox;

  /**
   * The default condition for determining whether the boxend event
   * should fire.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent The originating MapBrowserEvent
   *     leading to the box end.
   * @param {import("../pixel.js").Pixel} startPixel The starting pixel of the box.
   * @param {import("../pixel.js").Pixel} endPixel The end pixel of the box.
   * @return {boolean} Whether or not the boxend condition should be fired.
   */
  DragBox.prototype.defaultBoxEndCondition = function defaultBoxEndCondition (mapBrowserEvent, startPixel, endPixel) {
    var width = endPixel[0] - startPixel[0];
    var height = endPixel[1] - startPixel[1];
    return width * width + height * height >= this.minArea_;
  };

  /**
  * Returns geometry of last drawn box.
  * @return {import("../geom/Polygon.js").default} Geometry.
  * @api
  */
  DragBox.prototype.getGeometry = function getGeometry () {
    return this.box_.getGeometry();
  };

  /**
   * @inheritDoc
   */
  DragBox.prototype.handleDragEvent = function handleDragEvent (mapBrowserEvent) {
    if (!Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_1__["mouseOnly"])(mapBrowserEvent)) {
      return;
    }

    this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);

    this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXDRAG,
      mapBrowserEvent.coordinate, mapBrowserEvent));
  };

  /**
   * @inheritDoc
   */
  DragBox.prototype.handleUpEvent = function handleUpEvent (mapBrowserEvent) {
    if (!Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_1__["mouseOnly"])(mapBrowserEvent)) {
      return true;
    }

    this.box_.setMap(null);

    if (this.boxEndCondition_(mapBrowserEvent, this.startPixel_, mapBrowserEvent.pixel)) {
      this.onBoxEnd_(mapBrowserEvent);
      this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXEND,
        mapBrowserEvent.coordinate, mapBrowserEvent));
    }
    return false;
  };

  /**
   * @inheritDoc
   */
  DragBox.prototype.handleDownEvent = function handleDownEvent (mapBrowserEvent) {
    if (!Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_1__["mouseOnly"])(mapBrowserEvent)) {
      return false;
    }

    if (Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_1__["mouseActionButton"])(mapBrowserEvent) &&
        this.condition_(mapBrowserEvent)) {
      this.startPixel_ = mapBrowserEvent.pixel;
      this.box_.setMap(mapBrowserEvent.map);
      this.box_.setPixels(this.startPixel_, this.startPixel_);
      this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXSTART,
        mapBrowserEvent.coordinate, mapBrowserEvent));
      return true;
    } else {
      return false;
    }
  };

  return DragBox;
}(_Pointer_js__WEBPACK_IMPORTED_MODULE_3__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (DragBox);

//# sourceMappingURL=DragBox.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/DragPan.js":
/*!************************************************!*\
  !*** ./node_modules/ol/interaction/DragPan.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ViewHint.js */ "./node_modules/ol/ViewHint.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../coordinate.js */ "./node_modules/ol/coordinate.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../easing.js */ "./node_modules/ol/easing.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/**
 * @module ol/interaction/DragPan
 */








/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition~noModifierKeys}.
 * @property {import("../Kinetic.js").default} [kinetic] Kinetic inertia to apply to the pan.
 */


/**
 * @classdesc
 * Allows the user to pan the map by dragging the map.
 * @api
 */
var DragPan = /*@__PURE__*/(function (PointerInteraction) {
  function DragPan(opt_options) {

    PointerInteraction.call(this, {
      stopDown: _functions_js__WEBPACK_IMPORTED_MODULE_4__["FALSE"]
    });

    var options = opt_options ? opt_options : {};

    /**
     * @private
     * @type {import("../Kinetic.js").default|undefined}
     */
    this.kinetic_ = options.kinetic;

    /**
     * @type {import("../pixel.js").Pixel}
     */
    this.lastCentroid = null;

    /**
     * @type {number}
     */
    this.lastPointersCount_;

    /**
     * @type {boolean}
     */
    this.panning_ = false;

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_3__["noModifierKeys"];

    /**
     * @private
     * @type {boolean}
     */
    this.noKinetic_ = false;

  }

  if ( PointerInteraction ) DragPan.__proto__ = PointerInteraction;
  DragPan.prototype = Object.create( PointerInteraction && PointerInteraction.prototype );
  DragPan.prototype.constructor = DragPan;

  /**
   * @inheritDoc
   */
  DragPan.prototype.handleDragEvent = function handleDragEvent (mapBrowserEvent) {
    if (!this.panning_) {
      this.panning_ = true;
      this.getMap().getView().setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_0__["default"].INTERACTING, 1);
    }
    var targetPointers = this.targetPointers;
    var centroid = Object(_Pointer_js__WEBPACK_IMPORTED_MODULE_5__["centroid"])(targetPointers);
    if (targetPointers.length == this.lastPointersCount_) {
      if (this.kinetic_) {
        this.kinetic_.update(centroid[0], centroid[1]);
      }
      if (this.lastCentroid) {
        var deltaX = this.lastCentroid[0] - centroid[0];
        var deltaY = centroid[1] - this.lastCentroid[1];
        var map = mapBrowserEvent.map;
        var view = map.getView();
        var center = [deltaX, deltaY];
        Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_1__["scale"])(center, view.getResolution());
        Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_1__["rotate"])(center, view.getRotation());
        Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_1__["add"])(center, view.getCenter());
        center = view.constrainCenter(center);
        view.setCenter(center);
      }
    } else if (this.kinetic_) {
      // reset so we don't overestimate the kinetic energy after
      // after one finger down, tiny drag, second finger down
      this.kinetic_.begin();
    }
    this.lastCentroid = centroid;
    this.lastPointersCount_ = targetPointers.length;
  };

  /**
   * @inheritDoc
   */
  DragPan.prototype.handleUpEvent = function handleUpEvent (mapBrowserEvent) {
    var map = mapBrowserEvent.map;
    var view = map.getView();
    if (this.targetPointers.length === 0) {
      if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
        var distance = this.kinetic_.getDistance();
        var angle = this.kinetic_.getAngle();
        var center = /** @type {!import("../coordinate.js").Coordinate} */ (view.getCenter());
        var centerpx = map.getPixelFromCoordinate(center);
        var dest = map.getCoordinateFromPixel([
          centerpx[0] - distance * Math.cos(angle),
          centerpx[1] - distance * Math.sin(angle)
        ]);
        view.animate({
          center: view.constrainCenter(dest),
          duration: 500,
          easing: _easing_js__WEBPACK_IMPORTED_MODULE_2__["easeOut"]
        });
      }
      if (this.panning_) {
        this.panning_ = false;
        view.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_0__["default"].INTERACTING, -1);
      }
      return false;
    } else {
      if (this.kinetic_) {
        // reset so we don't overestimate the kinetic energy after
        // after one finger up, tiny drag, second finger up
        this.kinetic_.begin();
      }
      this.lastCentroid = null;
      return true;
    }
  };

  /**
   * @inheritDoc
   */
  DragPan.prototype.handleDownEvent = function handleDownEvent (mapBrowserEvent) {
    if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {
      var map = mapBrowserEvent.map;
      var view = map.getView();
      this.lastCentroid = null;
      // stop any current animation
      if (view.getAnimating()) {
        view.setCenter(mapBrowserEvent.frameState.viewState.center);
      }
      if (this.kinetic_) {
        this.kinetic_.begin();
      }
      // No kinetic as soon as more than one pointer on the screen is
      // detected. This is to prevent nasty pans after pinch.
      this.noKinetic_ = this.targetPointers.length > 1;
      return true;
    } else {
      return false;
    }
  };

  return DragPan;
}(_Pointer_js__WEBPACK_IMPORTED_MODULE_5__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (DragPan);

//# sourceMappingURL=DragPan.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/DragRotate.js":
/*!***************************************************!*\
  !*** ./node_modules/ol/interaction/DragRotate.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../rotationconstraint.js */ "./node_modules/ol/rotationconstraint.js");
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ViewHint.js */ "./node_modules/ol/ViewHint.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/**
 * @module ol/interaction/DragRotate
 */








/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that takes an
 * {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition~altShiftKeysOnly}.
 * @property {number} [duration=250] Animation duration in milliseconds.
 */


/**
 * @classdesc
 * Allows the user to rotate the map by clicking and dragging on the map,
 * normally combined with an {@link module:ol/events/condition} that limits
 * it to when the alt and shift keys are held down.
 *
 * This interaction is only supported for mouse devices.
 * @api
 */
var DragRotate = /*@__PURE__*/(function (PointerInteraction) {
  function DragRotate(opt_options) {

    var options = opt_options ? opt_options : {};

    PointerInteraction.call(this, {
      stopDown: _functions_js__WEBPACK_IMPORTED_MODULE_3__["FALSE"]
    });

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_2__["altShiftKeysOnly"];

    /**
     * @private
     * @type {number|undefined}
     */
    this.lastAngle_ = undefined;

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 250;

  }

  if ( PointerInteraction ) DragRotate.__proto__ = PointerInteraction;
  DragRotate.prototype = Object.create( PointerInteraction && PointerInteraction.prototype );
  DragRotate.prototype.constructor = DragRotate;

  /**
   * @inheritDoc
   */
  DragRotate.prototype.handleDragEvent = function handleDragEvent (mapBrowserEvent) {
    if (!Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_2__["mouseOnly"])(mapBrowserEvent)) {
      return;
    }

    var map = mapBrowserEvent.map;
    var view = map.getView();
    if (view.getConstraints().rotation === _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_0__["disable"]) {
      return;
    }
    var size = map.getSize();
    var offset = mapBrowserEvent.pixel;
    var theta =
        Math.atan2(size[1] / 2 - offset[1], offset[0] - size[0] / 2);
    if (this.lastAngle_ !== undefined) {
      var delta = theta - this.lastAngle_;
      var rotation = view.getRotation();
      Object(_Interaction_js__WEBPACK_IMPORTED_MODULE_4__["rotateWithoutConstraints"])(view, rotation - delta);
    }
    this.lastAngle_ = theta;
  };


  /**
   * @inheritDoc
   */
  DragRotate.prototype.handleUpEvent = function handleUpEvent (mapBrowserEvent) {
    if (!Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_2__["mouseOnly"])(mapBrowserEvent)) {
      return true;
    }

    var map = mapBrowserEvent.map;
    var view = map.getView();
    view.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_1__["default"].INTERACTING, -1);
    var rotation = view.getRotation();
    Object(_Interaction_js__WEBPACK_IMPORTED_MODULE_4__["rotate"])(view, rotation, undefined, this.duration_);
    return false;
  };


  /**
   * @inheritDoc
   */
  DragRotate.prototype.handleDownEvent = function handleDownEvent (mapBrowserEvent) {
    if (!Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_2__["mouseOnly"])(mapBrowserEvent)) {
      return false;
    }

    if (Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_2__["mouseActionButton"])(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {
      var map = mapBrowserEvent.map;
      map.getView().setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_1__["default"].INTERACTING, 1);
      this.lastAngle_ = undefined;
      return true;
    } else {
      return false;
    }
  };

  return DragRotate;
}(_Pointer_js__WEBPACK_IMPORTED_MODULE_5__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (DragRotate);

//# sourceMappingURL=DragRotate.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/DragRotateAndZoom.js":
/*!**********************************************************!*\
  !*** ./node_modules/ol/interaction/DragRotateAndZoom.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../rotationconstraint.js */ "./node_modules/ol/rotationconstraint.js");
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ViewHint.js */ "./node_modules/ol/ViewHint.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/**
 * @module ol/interaction/DragRotateAndZoom
 */







/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition~shiftKeyOnly}.
 * @property {number} [duration=400] Animation duration in milliseconds.
 */


/**
 * @classdesc
 * Allows the user to zoom and rotate the map by clicking and dragging
 * on the map.  By default, this interaction is limited to when the shift
 * key is held down.
 *
 * This interaction is only supported for mouse devices.
 *
 * And this interaction is not included in the default interactions.
 * @api
 */
var DragRotateAndZoom = /*@__PURE__*/(function (PointerInteraction) {
  function DragRotateAndZoom(opt_options) {

    var options = opt_options ? opt_options : {};

    PointerInteraction.call(/** @type {import("./Pointer.js").Options} */ this, (options));

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_2__["shiftKeyOnly"];

    /**
     * @private
     * @type {number|undefined}
     */
    this.lastAngle_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.lastMagnitude_ = undefined;

    /**
     * @private
     * @type {number}
     */
    this.lastScaleDelta_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 400;

  }

  if ( PointerInteraction ) DragRotateAndZoom.__proto__ = PointerInteraction;
  DragRotateAndZoom.prototype = Object.create( PointerInteraction && PointerInteraction.prototype );
  DragRotateAndZoom.prototype.constructor = DragRotateAndZoom;

  /**
   * @inheritDoc
   */
  DragRotateAndZoom.prototype.handleDragEvent = function handleDragEvent (mapBrowserEvent) {
    if (!Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_2__["mouseOnly"])(mapBrowserEvent)) {
      return;
    }

    var map = mapBrowserEvent.map;
    var size = map.getSize();
    var offset = mapBrowserEvent.pixel;
    var deltaX = offset[0] - size[0] / 2;
    var deltaY = size[1] / 2 - offset[1];
    var theta = Math.atan2(deltaY, deltaX);
    var magnitude = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    var view = map.getView();
    if (view.getConstraints().rotation !== _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_0__["disable"] && this.lastAngle_ !== undefined) {
      var angleDelta = theta - this.lastAngle_;
      Object(_Interaction_js__WEBPACK_IMPORTED_MODULE_3__["rotateWithoutConstraints"])(view, view.getRotation() - angleDelta);
    }
    this.lastAngle_ = theta;
    if (this.lastMagnitude_ !== undefined) {
      var resolution = this.lastMagnitude_ * (view.getResolution() / magnitude);
      Object(_Interaction_js__WEBPACK_IMPORTED_MODULE_3__["zoomWithoutConstraints"])(view, resolution);
    }
    if (this.lastMagnitude_ !== undefined) {
      this.lastScaleDelta_ = this.lastMagnitude_ / magnitude;
    }
    this.lastMagnitude_ = magnitude;
  };

  /**
   * @inheritDoc
   */
  DragRotateAndZoom.prototype.handleUpEvent = function handleUpEvent (mapBrowserEvent) {
    if (!Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_2__["mouseOnly"])(mapBrowserEvent)) {
      return true;
    }

    var map = mapBrowserEvent.map;
    var view = map.getView();
    view.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_1__["default"].INTERACTING, -1);
    var direction = this.lastScaleDelta_ - 1;
    Object(_Interaction_js__WEBPACK_IMPORTED_MODULE_3__["rotate"])(view, view.getRotation());
    Object(_Interaction_js__WEBPACK_IMPORTED_MODULE_3__["zoom"])(view, view.getResolution(), undefined, this.duration_, direction);
    this.lastScaleDelta_ = 0;
    return false;
  };

  /**
   * @inheritDoc
   */
  DragRotateAndZoom.prototype.handleDownEvent = function handleDownEvent (mapBrowserEvent) {
    if (!Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_2__["mouseOnly"])(mapBrowserEvent)) {
      return false;
    }

    if (this.condition_(mapBrowserEvent)) {
      mapBrowserEvent.map.getView().setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_1__["default"].INTERACTING, 1);
      this.lastAngle_ = undefined;
      this.lastMagnitude_ = undefined;
      return true;
    } else {
      return false;
    }
  };

  return DragRotateAndZoom;
}(_Pointer_js__WEBPACK_IMPORTED_MODULE_4__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (DragRotateAndZoom);

//# sourceMappingURL=DragRotateAndZoom.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/DragZoom.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/interaction/DragZoom.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../easing.js */ "./node_modules/ol/easing.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _DragBox_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DragBox.js */ "./node_modules/ol/interaction/DragBox.js");
/**
 * @module ol/interaction/DragZoom
 */






/**
 * @typedef {Object} Options
 * @property {string} [className='ol-dragzoom'] CSS class name for styling the
 * box.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition~shiftKeyOnly}.
 * @property {number} [duration=200] Animation duration in milliseconds.
 * @property {boolean} [out=false] Use interaction for zooming out.
 */


/**
 * @classdesc
 * Allows the user to zoom the map by clicking and dragging on the map,
 * normally combined with an {@link module:ol/events/condition} that limits
 * it to when a key, shift by default, is held down.
 *
 * To change the style of the box, use CSS and the `.ol-dragzoom` selector, or
 * your custom one configured with `className`.
 * @api
 */
var DragZoom = /*@__PURE__*/(function (DragBox) {
  function DragZoom(opt_options) {
    var options = opt_options ? opt_options : {};

    var condition = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_1__["shiftKeyOnly"];

    DragBox.call(this, {
      condition: condition,
      className: options.className || 'ol-dragzoom',
      onBoxEnd: onBoxEnd
    });

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 200;

    /**
     * @private
     * @type {boolean}
     */
    this.out_ = options.out !== undefined ? options.out : false;
  }

  if ( DragBox ) DragZoom.__proto__ = DragBox;
  DragZoom.prototype = Object.create( DragBox && DragBox.prototype );
  DragZoom.prototype.constructor = DragZoom;

  return DragZoom;
}(_DragBox_js__WEBPACK_IMPORTED_MODULE_3__["default"]));


/**
 * @this {DragZoom}
 */
function onBoxEnd() {
  var map = this.getMap();
  var view = /** @type {!import("../View.js").default} */ (map.getView());
  var size = /** @type {!import("../size.js").Size} */ (map.getSize());
  var extent = this.getGeometry().getExtent();

  if (this.out_) {
    var mapExtent = view.calculateExtent(size);
    var boxPixelExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["createOrUpdateFromCoordinates"])([
      map.getPixelFromCoordinate(Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["getBottomLeft"])(extent)),
      map.getPixelFromCoordinate(Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["getTopRight"])(extent))]);
    var factor = view.getResolutionForExtent(boxPixelExtent, size);

    Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["scaleFromCenter"])(mapExtent, 1 / factor);
    extent = mapExtent;
  }

  var resolution = view.constrainResolution(
    view.getResolutionForExtent(extent, size));

  var center = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["getCenter"])(extent);
  center = view.constrainCenter(center);

  view.animate({
    resolution: resolution,
    center: center,
    duration: this.duration_,
    easing: _easing_js__WEBPACK_IMPORTED_MODULE_0__["easeOut"]
  });
}


/* harmony default export */ __webpack_exports__["default"] = (DragZoom);

//# sourceMappingURL=DragZoom.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/Draw.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/interaction/Draw.js ***!
  \*********************************************/
/*! exports provided: createRegularPolygon, createBox, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createRegularPolygon", function() { return createRegularPolygon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createBox", function() { return createBox; });
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Feature.js */ "./node_modules/ol/Feature.js");
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../MapBrowserEventType.js */ "./node_modules/ol/MapBrowserEventType.js");
/* harmony import */ var _MapBrowserPointerEvent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../MapBrowserPointerEvent.js */ "./node_modules/ol/MapBrowserPointerEvent.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../coordinate.js */ "./node_modules/ol/coordinate.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _geom_Circle_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../geom/Circle.js */ "./node_modules/ol/geom/Circle.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _geom_LineString_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../geom/LineString.js */ "./node_modules/ol/geom/LineString.js");
/* harmony import */ var _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../geom/MultiLineString.js */ "./node_modules/ol/geom/MultiLineString.js");
/* harmony import */ var _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../geom/MultiPoint.js */ "./node_modules/ol/geom/MultiPoint.js");
/* harmony import */ var _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../geom/MultiPolygon.js */ "./node_modules/ol/geom/MultiPolygon.js");
/* harmony import */ var _pointer_MouseSource_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../pointer/MouseSource.js */ "./node_modules/ol/pointer/MouseSource.js");
/* harmony import */ var _geom_Point_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../geom/Point.js */ "./node_modules/ol/geom/Point.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../geom/Polygon.js */ "./node_modules/ol/geom/Polygon.js");
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/* harmony import */ var _Property_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./Property.js */ "./node_modules/ol/interaction/Property.js");
/* harmony import */ var _layer_Vector_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../layer/Vector.js */ "./node_modules/ol/layer/Vector.js");
/* harmony import */ var _source_Vector_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../source/Vector.js */ "./node_modules/ol/source/Vector.js");
/* harmony import */ var _style_Style_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../style/Style.js */ "./node_modules/ol/style/Style.js");
/**
 * @module ol/interaction/Draw
 */



























/**
 * @typedef {Object} Options
 * @property {GeometryType} type Geometry type of
 * the geometries being drawn with this instance.
 * @property {number} [clickTolerance=6] The maximum distance in pixels between
 * "down" and "up" for a "up" event to be considered a "click" event and
 * actually add a point/vertex to the geometry being drawn.  The default of `6`
 * was chosen for the draw interaction to behave correctly on mouse as well as
 * on touch devices.
 * @property {import("../Collection.js").default<Feature>} [features]
 * Destination collection for the drawn features.
 * @property {VectorSource} [source] Destination source for
 * the drawn features.
 * @property {number} [dragVertexDelay=500] Delay in milliseconds after pointerdown
 * before the current vertex can be dragged to its exact position.
 * @property {number} [snapTolerance=12] Pixel distance for snapping to the
 * drawing finish.
 * @property {boolean} [stopClick=false] Stop click, singleclick, and
 * doubleclick events from firing during drawing.
 * @property {number} [maxPoints] The number of points that can be drawn before
 * a polygon ring or line string is finished. By default there is no
 * restriction.
 * @property {number} [minPoints] The number of points that must be drawn
 * before a polygon ring or line string can be finished. Default is `3` for
 * polygon rings and `2` for line strings.
 * @property {import("../events/condition.js").Condition} [finishCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether the drawing can be finished.
 * @property {import("../style/Style.js").StyleLike} [style]
 * Style for sketch features.
 * @property {GeometryFunction} [geometryFunction]
 * Function that is called when a geometry's coordinates are updated.
 * @property {string} [geometryName] Geometry name to use for features created
 * by the draw interaction.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * By default {@link module:ol/events/condition~noModifierKeys}, i.e. a click,
 * adds a vertex or deactivates freehand drawing.
 * @property {boolean} [freehand=false] Operate in freehand mode for lines,
 * polygons, and circles.  This makes the interaction always operate in freehand
 * mode and takes precedence over any `freehandCondition` option.
 * @property {import("../events/condition.js").Condition} [freehandCondition]
 * Condition that activates freehand drawing for lines and polygons. This
 * function takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and
 * returns a boolean to indicate whether that event should be handled. The
 * default is {@link module:ol/events/condition~shiftKeyOnly}, meaning that the
 * Shift key activates freehand drawing.
 * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch
 * overlay.
 */


/**
 * Coordinate type when drawing points.
 * @typedef {import("../coordinate.js").Coordinate} PointCoordType
 */


/**
 * Coordinate type when drawing lines.
 * @typedef {Array<import("../coordinate.js").Coordinate>} LineCoordType
 */


/**
 * Coordinate type when drawing polygons.
 * @typedef {Array<Array<import("../coordinate.js").Coordinate>>} PolyCoordType
 */


/**
 * Types used for drawing coordinates.
 * @typedef {PointCoordType|LineCoordType|PolyCoordType} SketchCoordType
 */


/**
 * Function that takes an array of coordinates and an optional existing geometry as
 * arguments, and returns a geometry. The optional existing geometry is the
 * geometry that is returned when the function is called without a second
 * argument.
 * @typedef {function(!SketchCoordType, import("../geom/SimpleGeometry.js").default=):
 *     import("../geom/SimpleGeometry.js").default} GeometryFunction
 */


/**
 * Draw mode.  This collapses multi-part geometry types with their single-part
 * cousins.
 * @enum {string}
 */
var Mode = {
  POINT: 'Point',
  LINE_STRING: 'LineString',
  POLYGON: 'Polygon',
  CIRCLE: 'Circle'
};


/**
 * @enum {string}
 */
var DrawEventType = {
  /**
   * Triggered upon feature draw start
   * @event DrawEvent#drawstart
   * @api
   */
  DRAWSTART: 'drawstart',
  /**
   * Triggered upon feature draw end
   * @event DrawEvent#drawend
   * @api
   */
  DRAWEND: 'drawend'
};


/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Draw~Draw} instances are
 * instances of this type.
 */
var DrawEvent = /*@__PURE__*/(function (Event) {
  function DrawEvent(type, feature) {

    Event.call(this, type);

    /**
     * The feature being drawn.
     * @type {Feature}
     * @api
     */
    this.feature = feature;

  }

  if ( Event ) DrawEvent.__proto__ = Event;
  DrawEvent.prototype = Object.create( Event && Event.prototype );
  DrawEvent.prototype.constructor = DrawEvent;

  return DrawEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_7__["default"]));


/**
 * @classdesc
 * Interaction for drawing feature geometries.
 *
 * @fires DrawEvent
 * @api
 */
var Draw = /*@__PURE__*/(function (PointerInteraction) {
  function Draw(options) {

    var pointerOptions = /** @type {import("./Pointer.js").Options} */ (options);
    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = _functions_js__WEBPACK_IMPORTED_MODULE_10__["FALSE"];
    }

    PointerInteraction.call(this, pointerOptions);

    /**
     * @type {boolean}
     * @private
     */
    this.shouldHandle_ = false;

    /**
     * @type {import("../pixel.js").Pixel}
     * @private
     */
    this.downPx_ = null;

    /**
     * @type {?}
     * @private
     */
    this.downTimeout_;

    /**
     * @type {number|undefined}
     * @private
     */
    this.lastDragTime_;

    /**
     * @type {boolean}
     * @private
     */
    this.freehand_ = false;

    /**
     * Target source for drawn features.
     * @type {VectorSource}
     * @private
     */
    this.source_ = options.source ? options.source : null;

    /**
     * Target collection for drawn features.
     * @type {import("../Collection.js").default<Feature>}
     * @private
     */
    this.features_ = options.features ? options.features : null;

    /**
     * Pixel distance for snapping.
     * @type {number}
     * @private
     */
    this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;

    /**
     * Geometry type.
     * @type {GeometryType}
     * @private
     */
    this.type_ = /** @type {GeometryType} */ (options.type);

    /**
     * Drawing mode (derived from geometry type.
     * @type {Mode}
     * @private
     */
    this.mode_ = getMode(this.type_);

    /**
     * Stop click, singleclick, and doubleclick events from firing during drawing.
     * Default is `false`.
     * @type {boolean}
     * @private
     */
    this.stopClick_ = !!options.stopClick;

    /**
     * The number of points that must be drawn before a polygon ring or line
     * string can be finished.  The default is 3 for polygon rings and 2 for
     * line strings.
     * @type {number}
     * @private
     */
    this.minPoints_ = options.minPoints ?
      options.minPoints :
      (this.mode_ === Mode.POLYGON ? 3 : 2);

    /**
     * The number of points that can be drawn before a polygon ring or line string
     * is finished. The default is no restriction.
     * @type {number}
     * @private
     */
    this.maxPoints_ = options.maxPoints ? options.maxPoints : Infinity;

    /**
     * A function to decide if a potential finish coordinate is permissible
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.finishCondition_ = options.finishCondition ? options.finishCondition : _functions_js__WEBPACK_IMPORTED_MODULE_10__["TRUE"];

    var geometryFunction = options.geometryFunction;
    if (!geometryFunction) {
      if (this.type_ === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].CIRCLE) {
        /**
         * @param {!LineCoordType} coordinates The coordinates.
         * @param {import("../geom/SimpleGeometry.js").default=} opt_geometry Optional geometry.
         * @return {import("../geom/SimpleGeometry.js").default} A geometry.
         */
        geometryFunction = function(coordinates, opt_geometry) {
          var circle = opt_geometry ? /** @type {Circle} */ (opt_geometry) :
            new _geom_Circle_js__WEBPACK_IMPORTED_MODULE_11__["default"]([NaN, NaN]);
          var squaredLength = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_5__["squaredDistance"])(
            coordinates[0], coordinates[1]);
          circle.setCenterAndRadius(coordinates[0], Math.sqrt(squaredLength));
          return circle;
        };
      } else {
        var Constructor;
        var mode = this.mode_;
        if (mode === Mode.POINT) {
          Constructor = _geom_Point_js__WEBPACK_IMPORTED_MODULE_18__["default"];
        } else if (mode === Mode.LINE_STRING) {
          Constructor = _geom_LineString_js__WEBPACK_IMPORTED_MODULE_13__["default"];
        } else if (mode === Mode.POLYGON) {
          Constructor = _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_19__["default"];
        }
        /**
         * @param {!LineCoordType} coordinates The coordinates.
         * @param {import("../geom/SimpleGeometry.js").default=} opt_geometry Optional geometry.
         * @return {import("../geom/SimpleGeometry.js").default} A geometry.
         */
        geometryFunction = function(coordinates, opt_geometry) {
          var geometry = opt_geometry;
          if (geometry) {
            if (mode === Mode.POLYGON) {
              if (coordinates[0].length) {
                // Add a closing coordinate to match the first
                geometry.setCoordinates([coordinates[0].concat([coordinates[0][0]])]);
              } else {
                geometry.setCoordinates([]);
              }
            } else {
              geometry.setCoordinates(coordinates);
            }
          } else {
            geometry = new Constructor(coordinates);
          }
          return geometry;
        };
      }
    }

    /**
     * @type {GeometryFunction}
     * @private
     */
    this.geometryFunction_ = geometryFunction;

    /**
     * @type {number}
     * @private
     */
    this.dragVertexDelay_ = options.dragVertexDelay !== undefined ? options.dragVertexDelay : 500;

    /**
     * Finish coordinate for the feature (first point for polygons, last point for
     * linestrings).
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */
    this.finishCoordinate_ = null;

    /**
     * Sketch feature.
     * @type {Feature}
     * @private
     */
    this.sketchFeature_ = null;

    /**
     * Sketch point.
     * @type {Feature}
     * @private
     */
    this.sketchPoint_ = null;

    /**
     * Sketch coordinates. Used when drawing a line or polygon.
     * @type {SketchCoordType}
     * @private
     */
    this.sketchCoords_ = null;

    /**
     * Sketch line. Used when drawing polygon.
     * @type {Feature}
     * @private
     */
    this.sketchLine_ = null;

    /**
     * Sketch line coordinates. Used when drawing a polygon or circle.
     * @type {LineCoordType}
     * @private
     */
    this.sketchLineCoords_ = null;

    /**
     * Squared tolerance for handling up events.  If the squared distance
     * between a down and up event is greater than this tolerance, up events
     * will not be handled.
     * @type {number}
     * @private
     */
    this.squaredClickTolerance_ = options.clickTolerance ?
      options.clickTolerance * options.clickTolerance : 36;

    /**
     * Draw overlay where our sketch features are drawn.
     * @type {VectorLayer}
     * @private
     */
    this.overlay_ = new _layer_Vector_js__WEBPACK_IMPORTED_MODULE_22__["default"]({
      source: new _source_Vector_js__WEBPACK_IMPORTED_MODULE_23__["default"]({
        useSpatialIndex: false,
        wrapX: options.wrapX ? options.wrapX : false
      }),
      style: options.style ? options.style :
        getDefaultStyleFunction(),
      updateWhileInteracting: true
    });

    /**
     * Name of the geometry attribute for newly created features.
     * @type {string|undefined}
     * @private
     */
    this.geometryName_ = options.geometryName;

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_8__["noModifierKeys"];

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.freehandCondition_;
    if (options.freehand) {
      this.freehandCondition_ = _events_condition_js__WEBPACK_IMPORTED_MODULE_8__["always"];
    } else {
      this.freehandCondition_ = options.freehandCondition ?
        options.freehandCondition : _events_condition_js__WEBPACK_IMPORTED_MODULE_8__["shiftKeyOnly"];
    }

    Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(this,
      Object(_Object_js__WEBPACK_IMPORTED_MODULE_4__["getChangeEventType"])(_Property_js__WEBPACK_IMPORTED_MODULE_21__["default"].ACTIVE),
      this.updateState_, this);

  }

  if ( PointerInteraction ) Draw.__proto__ = PointerInteraction;
  Draw.prototype = Object.create( PointerInteraction && PointerInteraction.prototype );
  Draw.prototype.constructor = Draw;

  /**
   * @inheritDoc
   */
  Draw.prototype.setMap = function setMap (map) {
    PointerInteraction.prototype.setMap.call(this, map);
    this.updateState_();
  };

  /**
   * Get the overlay layer that this interaction renders sketch features to.
   * @return {VectorLayer} Overlay layer.
   * @api
   */
  Draw.prototype.getOverlay = function getOverlay () {
    return this.overlay_;
  };

  /**
   * Handles the {@link module:ol/MapBrowserEvent map browser event} and may actually draw or finish the drawing.
   * @override
   * @api
   */
  Draw.prototype.handleEvent = function handleEvent (event) {
    if (event.originalEvent.type === _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].CONTEXTMENU) {
      // Avoid context menu for long taps when drawing on mobile
      event.preventDefault();
    }
    this.freehand_ = this.mode_ !== Mode.POINT && this.freehandCondition_(event);
    var move = event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERMOVE;
    var pass = true;
    if (!this.freehand_ && this.lastDragTime_ && event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERDRAG) {
      var now = Date.now();
      if (now - this.lastDragTime_ >= this.dragVertexDelay_) {
        this.downPx_ = event.pixel;
        this.shouldHandle_ = !this.freehand_;
        move = true;
      } else {
        this.lastDragTime_ = undefined;
      }
      if (this.shouldHandle_ && this.downTimeout_ !== undefined) {
        clearTimeout(this.downTimeout_);
        this.downTimeout_ = undefined;
      }
    }
    if (this.freehand_ &&
        event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERDRAG &&
        this.sketchFeature_ !== null) {
      this.addToDrawing_(event);
      pass = false;
    } else if (this.freehand_ &&
        event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERDOWN) {
      pass = false;
    } else if (move) {
      pass = event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERMOVE;
      if (pass && this.freehand_) {
        pass = this.handlePointerMove_(event);
      } else if (/** @type {MapBrowserPointerEvent} */ (event).pointerEvent.pointerType == _pointer_MouseSource_js__WEBPACK_IMPORTED_MODULE_17__["POINTER_TYPE"] ||
          (event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERDRAG && this.downTimeout_ === undefined)) {
        this.handlePointerMove_(event);
      }
    } else if (event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].DBLCLICK) {
      pass = false;
    }

    return PointerInteraction.prototype.handleEvent.call(this, event) && pass;
  };

  /**
   * @inheritDoc
   */
  Draw.prototype.handleDownEvent = function handleDownEvent (event) {
    this.shouldHandle_ = !this.freehand_;

    if (this.freehand_) {
      this.downPx_ = event.pixel;
      if (!this.finishCoordinate_) {
        this.startDrawing_(event);
      }
      return true;
    } else if (this.condition_(event)) {
      this.lastDragTime_ = Date.now();
      this.downTimeout_ = setTimeout(function() {
        this.handlePointerMove_(new _MapBrowserPointerEvent_js__WEBPACK_IMPORTED_MODULE_3__["default"](
          _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERMOVE, event.map, event.pointerEvent, false, event.frameState));
      }.bind(this), this.dragVertexDelay_);
      this.downPx_ = event.pixel;
      return true;
    } else {
      return false;
    }
  };


  /**
   * @inheritDoc
   */
  Draw.prototype.handleUpEvent = function handleUpEvent (event) {
    var pass = true;

    if (this.downTimeout_) {
      clearTimeout(this.downTimeout_);
      this.downTimeout_ = undefined;
    }

    this.handlePointerMove_(event);

    var circleMode = this.mode_ === Mode.CIRCLE;

    if (this.shouldHandle_) {
      if (!this.finishCoordinate_) {
        this.startDrawing_(event);
        if (this.mode_ === Mode.POINT) {
          this.finishDrawing();
        }
      } else if (this.freehand_ || circleMode) {
        this.finishDrawing();
      } else if (this.atFinish_(event)) {
        if (this.finishCondition_(event)) {
          this.finishDrawing();
        }
      } else {
        this.addToDrawing_(event);
      }
      pass = false;
    } else if (this.freehand_) {
      this.finishCoordinate_ = null;
      this.abortDrawing_();
    }
    if (!pass && this.stopClick_) {
      event.stopPropagation();
    }
    return pass;
  };

  /**
   * Handle move events.
   * @param {import("../MapBrowserEvent.js").default} event A move event.
   * @return {boolean} Pass the event to other interactions.
   * @private
   */
  Draw.prototype.handlePointerMove_ = function handlePointerMove_ (event) {
    if (this.downPx_ &&
        ((!this.freehand_ && this.shouldHandle_) ||
        (this.freehand_ && !this.shouldHandle_))) {
      var downPx = this.downPx_;
      var clickPx = event.pixel;
      var dx = downPx[0] - clickPx[0];
      var dy = downPx[1] - clickPx[1];
      var squaredDistance = dx * dx + dy * dy;
      this.shouldHandle_ = this.freehand_ ?
        squaredDistance > this.squaredClickTolerance_ :
        squaredDistance <= this.squaredClickTolerance_;
      if (!this.shouldHandle_) {
        return true;
      }
    }

    if (this.finishCoordinate_) {
      this.modifyDrawing_(event);
    } else {
      this.createOrUpdateSketchPoint_(event);
    }
    return true;
  };

  /**
   * Determine if an event is within the snapping tolerance of the start coord.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} The event is within the snapping tolerance of the start.
   * @private
   */
  Draw.prototype.atFinish_ = function atFinish_ (event) {
    var at = false;
    if (this.sketchFeature_) {
      var potentiallyDone = false;
      var potentiallyFinishCoordinates = [this.finishCoordinate_];
      if (this.mode_ === Mode.LINE_STRING) {
        potentiallyDone = this.sketchCoords_.length > this.minPoints_;
      } else if (this.mode_ === Mode.POLYGON) {
        var sketchCoords = /** @type {PolyCoordType} */ (this.sketchCoords_);
        potentiallyDone = sketchCoords[0].length > this.minPoints_;
        potentiallyFinishCoordinates = [sketchCoords[0][0], sketchCoords[0][sketchCoords[0].length - 2]];
      }
      if (potentiallyDone) {
        var map = event.map;
        for (var i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++) {
          var finishCoordinate = potentiallyFinishCoordinates[i];
          var finishPixel = map.getPixelFromCoordinate(finishCoordinate);
          var pixel = event.pixel;
          var dx = pixel[0] - finishPixel[0];
          var dy = pixel[1] - finishPixel[1];
          var snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;
          at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;
          if (at) {
            this.finishCoordinate_ = finishCoordinate;
            break;
          }
        }
      }
    }
    return at;
  };

  /**
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @private
   */
  Draw.prototype.createOrUpdateSketchPoint_ = function createOrUpdateSketchPoint_ (event) {
    var coordinates = event.coordinate.slice();
    if (!this.sketchPoint_) {
      this.sketchPoint_ = new _Feature_js__WEBPACK_IMPORTED_MODULE_1__["default"](new _geom_Point_js__WEBPACK_IMPORTED_MODULE_18__["default"](coordinates));
      this.updateSketchFeatures_();
    } else {
      var sketchPointGeom = /** @type {Point} */ (this.sketchPoint_.getGeometry());
      sketchPointGeom.setCoordinates(coordinates);
    }
  };

  /**
   * Start the drawing.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @private
   */
  Draw.prototype.startDrawing_ = function startDrawing_ (event) {
    var start = event.coordinate;
    this.finishCoordinate_ = start;
    if (this.mode_ === Mode.POINT) {
      this.sketchCoords_ = start.slice();
    } else if (this.mode_ === Mode.POLYGON) {
      this.sketchCoords_ = [[start.slice(), start.slice()]];
      this.sketchLineCoords_ = this.sketchCoords_[0];
    } else {
      this.sketchCoords_ = [start.slice(), start.slice()];
    }
    if (this.sketchLineCoords_) {
      this.sketchLine_ = new _Feature_js__WEBPACK_IMPORTED_MODULE_1__["default"](
        new _geom_LineString_js__WEBPACK_IMPORTED_MODULE_13__["default"](this.sketchLineCoords_));
    }
    var geometry = this.geometryFunction_(this.sketchCoords_);
    this.sketchFeature_ = new _Feature_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
    if (this.geometryName_) {
      this.sketchFeature_.setGeometryName(this.geometryName_);
    }
    this.sketchFeature_.setGeometry(geometry);
    this.updateSketchFeatures_();
    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));
  };

  /**
   * Modify the drawing.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @private
   */
  Draw.prototype.modifyDrawing_ = function modifyDrawing_ (event) {
    var coordinate = event.coordinate;
    var geometry = /** @type {import("../geom/SimpleGeometry.js").default} */ (this.sketchFeature_.getGeometry());
    var coordinates, last;
    if (this.mode_ === Mode.POINT) {
      last = this.sketchCoords_;
    } else if (this.mode_ === Mode.POLYGON) {
      coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];
      last = coordinates[coordinates.length - 1];
      if (this.atFinish_(event)) {
        // snap to finish
        coordinate = this.finishCoordinate_.slice();
      }
    } else {
      coordinates = this.sketchCoords_;
      last = coordinates[coordinates.length - 1];
    }
    last[0] = coordinate[0];
    last[1] = coordinate[1];
    this.geometryFunction_(/** @type {!LineCoordType} */ (this.sketchCoords_), geometry);
    if (this.sketchPoint_) {
      var sketchPointGeom = /** @type {Point} */ (this.sketchPoint_.getGeometry());
      sketchPointGeom.setCoordinates(coordinate);
    }
    /** @type {LineString} */
    var sketchLineGeom;
    if (geometry.getType() == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].POLYGON &&
        this.mode_ !== Mode.POLYGON) {
      if (!this.sketchLine_) {
        this.sketchLine_ = new _Feature_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
      }
      var ring = /** @type {Polygon} */ (geometry).getLinearRing(0);
      sketchLineGeom = /** @type {LineString} */ (this.sketchLine_.getGeometry());
      if (!sketchLineGeom) {
        sketchLineGeom = new _geom_LineString_js__WEBPACK_IMPORTED_MODULE_13__["default"](ring.getFlatCoordinates(), ring.getLayout());
        this.sketchLine_.setGeometry(sketchLineGeom);
      } else {
        sketchLineGeom.setFlatCoordinates(
          ring.getLayout(), ring.getFlatCoordinates());
        sketchLineGeom.changed();
      }
    } else if (this.sketchLineCoords_) {
      sketchLineGeom = /** @type {LineString} */ (this.sketchLine_.getGeometry());
      sketchLineGeom.setCoordinates(this.sketchLineCoords_);
    }
    this.updateSketchFeatures_();
  };

  /**
   * Add a new coordinate to the drawing.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @private
   */
  Draw.prototype.addToDrawing_ = function addToDrawing_ (event) {
    var coordinate = event.coordinate;
    var geometry = /** @type {import("../geom/SimpleGeometry.js").default} */ (this.sketchFeature_.getGeometry());
    var done;
    var coordinates;
    if (this.mode_ === Mode.LINE_STRING) {
      this.finishCoordinate_ = coordinate.slice();
      coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);
      if (coordinates.length >= this.maxPoints_) {
        if (this.freehand_) {
          coordinates.pop();
        } else {
          done = true;
        }
      }
      coordinates.push(coordinate.slice());
      this.geometryFunction_(coordinates, geometry);
    } else if (this.mode_ === Mode.POLYGON) {
      coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];
      if (coordinates.length >= this.maxPoints_) {
        if (this.freehand_) {
          coordinates.pop();
        } else {
          done = true;
        }
      }
      coordinates.push(coordinate.slice());
      if (done) {
        this.finishCoordinate_ = coordinates[0];
      }
      this.geometryFunction_(this.sketchCoords_, geometry);
    }
    this.updateSketchFeatures_();
    if (done) {
      this.finishDrawing();
    }
  };

  /**
   * Remove last point of the feature currently being drawn.
   * @api
   */
  Draw.prototype.removeLastPoint = function removeLastPoint () {
    if (!this.sketchFeature_) {
      return;
    }
    var geometry = /** @type {import("../geom/SimpleGeometry.js").default} */ (this.sketchFeature_.getGeometry());
    var coordinates;
    /** @type {LineString} */
    var sketchLineGeom;
    if (this.mode_ === Mode.LINE_STRING) {
      coordinates = /** @type {LineCoordType} */ (this.sketchCoords_);
      coordinates.splice(-2, 1);
      this.geometryFunction_(coordinates, geometry);
      if (coordinates.length >= 2) {
        this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();
      }
    } else if (this.mode_ === Mode.POLYGON) {
      coordinates = /** @type {PolyCoordType} */ (this.sketchCoords_)[0];
      coordinates.splice(-2, 1);
      sketchLineGeom = /** @type {LineString} */ (this.sketchLine_.getGeometry());
      sketchLineGeom.setCoordinates(coordinates);
      this.geometryFunction_(this.sketchCoords_, geometry);
    }

    if (coordinates.length === 0) {
      this.finishCoordinate_ = null;
    }

    this.updateSketchFeatures_();
  };

  /**
   * Stop drawing and add the sketch feature to the target layer.
   * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is
   * dispatched before inserting the feature.
   * @api
   */
  Draw.prototype.finishDrawing = function finishDrawing () {
    var sketchFeature = this.abortDrawing_();
    if (!sketchFeature) {
      return;
    }
    var coordinates = this.sketchCoords_;
    var geometry = /** @type {import("../geom/SimpleGeometry.js").default} */ (sketchFeature.getGeometry());
    if (this.mode_ === Mode.LINE_STRING) {
      // remove the redundant last point
      coordinates.pop();
      this.geometryFunction_(coordinates, geometry);
    } else if (this.mode_ === Mode.POLYGON) {
      // remove the redundant last point in ring
      /** @type {PolyCoordType} */ (coordinates)[0].pop();
      this.geometryFunction_(coordinates, geometry);
      coordinates = geometry.getCoordinates();
    }

    // cast multi-part geometries
    if (this.type_ === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].MULTI_POINT) {
      sketchFeature.setGeometry(new _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_15__["default"]([/** @type {PointCoordType} */(coordinates)]));
    } else if (this.type_ === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].MULTI_LINE_STRING) {
      sketchFeature.setGeometry(new _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_14__["default"]([/** @type {LineCoordType} */(coordinates)]));
    } else if (this.type_ === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].MULTI_POLYGON) {
      sketchFeature.setGeometry(new _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_16__["default"]([/** @type {PolyCoordType} */(coordinates)]));
    }

    // First dispatch event to allow full set up of feature
    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature));

    // Then insert feature
    if (this.features_) {
      this.features_.push(sketchFeature);
    }
    if (this.source_) {
      this.source_.addFeature(sketchFeature);
    }
  };

  /**
   * Stop drawing without adding the sketch feature to the target layer.
   * @return {Feature} The sketch feature (or null if none).
   * @private
   */
  Draw.prototype.abortDrawing_ = function abortDrawing_ () {
    this.finishCoordinate_ = null;
    var sketchFeature = this.sketchFeature_;
    if (sketchFeature) {
      this.sketchFeature_ = null;
      this.sketchPoint_ = null;
      this.sketchLine_ = null;
      /** @type {VectorSource} */ (this.overlay_.getSource()).clear(true);
    }
    return sketchFeature;
  };

  /**
   * Extend an existing geometry by adding additional points. This only works
   * on features with `LineString` geometries, where the interaction will
   * extend lines by adding points to the end of the coordinates array.
   * @param {!Feature} feature Feature to be extended.
   * @api
   */
  Draw.prototype.extend = function extend (feature) {
    var geometry = feature.getGeometry();
    var lineString = /** @type {LineString} */ (geometry);
    this.sketchFeature_ = feature;
    this.sketchCoords_ = lineString.getCoordinates();
    var last = this.sketchCoords_[this.sketchCoords_.length - 1];
    this.finishCoordinate_ = last.slice();
    this.sketchCoords_.push(last.slice());
    this.updateSketchFeatures_();
    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));
  };

  /**
   * Redraw the sketch features.
   * @private
   */
  Draw.prototype.updateSketchFeatures_ = function updateSketchFeatures_ () {
    var sketchFeatures = [];
    if (this.sketchFeature_) {
      sketchFeatures.push(this.sketchFeature_);
    }
    if (this.sketchLine_) {
      sketchFeatures.push(this.sketchLine_);
    }
    if (this.sketchPoint_) {
      sketchFeatures.push(this.sketchPoint_);
    }
    var overlaySource = /** @type {VectorSource} */ (this.overlay_.getSource());
    overlaySource.clear(true);
    overlaySource.addFeatures(sketchFeatures);
  };

  /**
   * @private
   */
  Draw.prototype.updateState_ = function updateState_ () {
    var map = this.getMap();
    var active = this.getActive();
    if (!map || !active) {
      this.abortDrawing_();
    }
    this.overlay_.setMap(active ? map : null);
  };

  return Draw;
}(_Pointer_js__WEBPACK_IMPORTED_MODULE_20__["default"]));


/**
 * @return {import("../style/Style.js").StyleFunction} Styles.
 */
function getDefaultStyleFunction() {
  var styles = Object(_style_Style_js__WEBPACK_IMPORTED_MODULE_24__["createEditingStyle"])();
  return function(feature, resolution) {
    return styles[feature.getGeometry().getType()];
  };
}


/**
 * Create a `geometryFunction` for `type: 'Circle'` that will create a regular
 * polygon with a user specified number of sides and start angle instead of an
 * `import("../geom/Circle.js").Circle` geometry.
 * @param {number=} opt_sides Number of sides of the regular polygon. Default is
 *     32.
 * @param {number=} opt_angle Angle of the first point in radians. 0 means East.
 *     Default is the angle defined by the heading from the center of the
 *     regular polygon to the current pointer position.
 * @return {GeometryFunction} Function that draws a
 *     polygon.
 * @api
 */
function createRegularPolygon(opt_sides, opt_angle) {
  return function(coordinates, opt_geometry) {
    var center = /** @type {LineCoordType} */ (coordinates)[0];
    var end = /** @type {LineCoordType} */ (coordinates)[1];
    var radius = Math.sqrt(
      Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_5__["squaredDistance"])(center, end));
    var geometry = opt_geometry ? /** @type {Polygon} */ (opt_geometry) :
      Object(_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_19__["fromCircle"])(new _geom_Circle_js__WEBPACK_IMPORTED_MODULE_11__["default"](center), opt_sides);
    var angle = opt_angle;
    if (!opt_angle) {
      var x = end[0] - center[0];
      var y = end[1] - center[1];
      angle = Math.atan(y / x) - (x < 0 ? Math.PI : 0);
    }
    Object(_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_19__["makeRegular"])(geometry, center, radius, angle);
    return geometry;
  };
}


/**
 * Create a `geometryFunction` that will create a box-shaped polygon (aligned
 * with the coordinate system axes).  Use this with the draw interaction and
 * `type: 'Circle'` to return a box instead of a circle geometry.
 * @return {GeometryFunction} Function that draws a box-shaped polygon.
 * @api
 */
function createBox() {
  return (
    function(coordinates, opt_geometry) {
      var extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_9__["boundingExtent"])(/** @type {LineCoordType} */ (coordinates));
      var boxCoordinates = [[
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_9__["getBottomLeft"])(extent),
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_9__["getBottomRight"])(extent),
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_9__["getTopRight"])(extent),
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_9__["getTopLeft"])(extent),
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_9__["getBottomLeft"])(extent)
      ]];
      var geometry = opt_geometry;
      if (geometry) {
        geometry.setCoordinates(boxCoordinates);
      } else {
        geometry = new _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_19__["default"](boxCoordinates);
      }
      return geometry;
    }
  );
}


/**
 * Get the drawing mode.  The mode for mult-part geometries is the same as for
 * their single-part cousins.
 * @param {GeometryType} type Geometry type.
 * @return {Mode} Drawing mode.
 */
function getMode(type) {
  var mode;
  if (type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].POINT ||
      type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].MULTI_POINT) {
    mode = Mode.POINT;
  } else if (type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].LINE_STRING ||
      type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].MULTI_LINE_STRING) {
    mode = Mode.LINE_STRING;
  } else if (type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].POLYGON ||
      type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].MULTI_POLYGON) {
    mode = Mode.POLYGON;
  } else if (type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].CIRCLE) {
    mode = Mode.CIRCLE;
  }
  return (
    /** @type {!Mode} */ (mode)
  );
}


/* harmony default export */ __webpack_exports__["default"] = (Draw);

//# sourceMappingURL=Draw.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/Extent.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/interaction/Extent.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Feature.js */ "./node_modules/ol/Feature.js");
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../MapBrowserEventType.js */ "./node_modules/ol/MapBrowserEventType.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../coordinate.js */ "./node_modules/ol/coordinate.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _geom_Point_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geom/Point.js */ "./node_modules/ol/geom/Point.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../geom/Polygon.js */ "./node_modules/ol/geom/Polygon.js");
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/* harmony import */ var _layer_Vector_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../layer/Vector.js */ "./node_modules/ol/layer/Vector.js");
/* harmony import */ var _source_Vector_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../source/Vector.js */ "./node_modules/ol/source/Vector.js");
/* harmony import */ var _style_Style_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../style/Style.js */ "./node_modules/ol/style/Style.js");
/**
 * @module ol/interaction/Extent
 */














/**
 * @typedef {Object} Options
 * @property {import("../extent.js").Extent} [extent] Initial extent. Defaults to no
 * initial extent.
 * @property {import("../style/Style.js").StyleLike} [boxStyle]
 * Style for the drawn extent box. Defaults to
 * {@link module:ol/style/Style~createEditing()['Polygon']}
 * @property {number} [pixelTolerance=10] Pixel tolerance for considering the
 * pointer close enough to a segment or vertex for editing.
 * @property {import("../style/Style.js").StyleLike} [pointerStyle]
 * Style for the cursor used to draw the extent. Defaults to
 * {@link module:ol/style/Style~createEditing()['Point']}
 * @property {boolean} [wrapX=false] Wrap the drawn extent across multiple maps
 * in the X direction? Only affects visuals, not functionality.
 */


/**
 * @enum {string}
 */
var ExtentEventType = {
  /**
   * Triggered after the extent is changed
   * @event ExtentEventType#extentchanged
   * @api
   */
  EXTENTCHANGED: 'extentchanged'
};


/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Extent~ExtentInteraction} instances are
 * instances of this type.
 */
var ExtentInteractionEvent = /*@__PURE__*/(function (Event) {
  function ExtentInteractionEvent(extent) {
    Event.call(this, ExtentEventType.EXTENTCHANGED);

    /**
     * The current extent.
     * @type {import("../extent.js").Extent}
     * @api
     */
    this.extent = extent;
  }

  if ( Event ) ExtentInteractionEvent.__proto__ = Event;
  ExtentInteractionEvent.prototype = Object.create( Event && Event.prototype );
  ExtentInteractionEvent.prototype.constructor = ExtentInteractionEvent;

  return ExtentInteractionEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_3__["default"]));


/**
 * @classdesc
 * Allows the user to draw a vector box by clicking and dragging on the map.
 * Once drawn, the vector box can be modified by dragging its vertices or edges.
 * This interaction is only supported for mouse devices.
 *
 * @fires Event
 * @api
 */
var ExtentInteraction = /*@__PURE__*/(function (PointerInteraction) {
  function ExtentInteraction(opt_options) {

    var options = opt_options || {};

    PointerInteraction.call(/** @type {import("./Pointer.js").Options} */ this, (options));

    /**
     * Extent of the drawn box
     * @type {import("../extent.js").Extent}
     * @private
     */
    this.extent_ = null;

    /**
     * Handler for pointer move events
     * @type {function (import("../coordinate.js").Coordinate): import("../extent.js").Extent|null}
     * @private
     */
    this.pointerHandler_ = null;

    /**
     * Pixel threshold to snap to extent
     * @type {number}
     * @private
     */
    this.pixelTolerance_ = options.pixelTolerance !== undefined ?
      options.pixelTolerance : 10;

    /**
     * Is the pointer snapped to an extent vertex
     * @type {boolean}
     * @private
     */
    this.snappedToVertex_ = false;

    /**
     * Feature for displaying the visible extent
     * @type {Feature}
     * @private
     */
    this.extentFeature_ = null;

    /**
     * Feature for displaying the visible pointer
     * @type {Feature}
     * @private
     */
    this.vertexFeature_ = null;

    if (!opt_options) {
      opt_options = {};
    }

    /**
     * Layer for the extentFeature
     * @type {VectorLayer}
     * @private
     */
    this.extentOverlay_ = new _layer_Vector_js__WEBPACK_IMPORTED_MODULE_9__["default"]({
      source: new _source_Vector_js__WEBPACK_IMPORTED_MODULE_10__["default"]({
        useSpatialIndex: false,
        wrapX: !!opt_options.wrapX
      }),
      style: opt_options.boxStyle ? opt_options.boxStyle : getDefaultExtentStyleFunction(),
      updateWhileAnimating: true,
      updateWhileInteracting: true
    });

    /**
     * Layer for the vertexFeature
     * @type {VectorLayer}
     * @private
     */
    this.vertexOverlay_ = new _layer_Vector_js__WEBPACK_IMPORTED_MODULE_9__["default"]({
      source: new _source_Vector_js__WEBPACK_IMPORTED_MODULE_10__["default"]({
        useSpatialIndex: false,
        wrapX: !!opt_options.wrapX
      }),
      style: opt_options.pointerStyle ? opt_options.pointerStyle : getDefaultPointerStyleFunction(),
      updateWhileAnimating: true,
      updateWhileInteracting: true
    });

    if (opt_options.extent) {
      this.setExtent(opt_options.extent);
    }
  }

  if ( PointerInteraction ) ExtentInteraction.__proto__ = PointerInteraction;
  ExtentInteraction.prototype = Object.create( PointerInteraction && PointerInteraction.prototype );
  ExtentInteraction.prototype.constructor = ExtentInteraction;

  /**
   * @param {import("../pixel.js").Pixel} pixel cursor location
   * @param {import("../PluggableMap.js").default} map map
   * @returns {import("../coordinate.js").Coordinate|null} snapped vertex on extent
   * @private
   */
  ExtentInteraction.prototype.snapToVertex_ = function snapToVertex_ (pixel, map) {
    var pixelCoordinate = map.getCoordinateFromPixel(pixel);
    var sortByDistance = function(a, b) {
      return Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_2__["squaredDistanceToSegment"])(pixelCoordinate, a) -
          Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_2__["squaredDistanceToSegment"])(pixelCoordinate, b);
    };
    var extent = this.getExtent();
    if (extent) {
      //convert extents to line segments and find the segment closest to pixelCoordinate
      var segments = getSegments(extent);
      segments.sort(sortByDistance);
      var closestSegment = segments[0];

      var vertex = (Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_2__["closestOnSegment"])(pixelCoordinate,
        closestSegment));
      var vertexPixel = map.getPixelFromCoordinate(vertex);

      //if the distance is within tolerance, snap to the segment
      if (Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_2__["distance"])(pixel, vertexPixel) <= this.pixelTolerance_) {
        //test if we should further snap to a vertex
        var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
        var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
        var squaredDist1 = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_2__["squaredDistance"])(vertexPixel, pixel1);
        var squaredDist2 = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_2__["squaredDistance"])(vertexPixel, pixel2);
        var dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
        this.snappedToVertex_ = dist <= this.pixelTolerance_;
        if (this.snappedToVertex_) {
          vertex = squaredDist1 > squaredDist2 ?
            closestSegment[1] : closestSegment[0];
        }
        return vertex;
      }
    }
    return null;
  };

  /**
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent pointer move event
   * @private
   */
  ExtentInteraction.prototype.handlePointerMove_ = function handlePointerMove_ (mapBrowserEvent) {
    var pixel = mapBrowserEvent.pixel;
    var map = mapBrowserEvent.map;

    var vertex = this.snapToVertex_(pixel, map);
    if (!vertex) {
      vertex = map.getCoordinateFromPixel(pixel);
    }
    this.createOrUpdatePointerFeature_(vertex);
  };

  /**
   * @param {import("../extent.js").Extent} extent extent
   * @returns {Feature} extent as featrue
   * @private
   */
  ExtentInteraction.prototype.createOrUpdateExtentFeature_ = function createOrUpdateExtentFeature_ (extent) {
    var extentFeature = this.extentFeature_;

    if (!extentFeature) {
      if (!extent) {
        extentFeature = new _Feature_js__WEBPACK_IMPORTED_MODULE_0__["default"]({});
      } else {
        extentFeature = new _Feature_js__WEBPACK_IMPORTED_MODULE_0__["default"](Object(_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_7__["fromExtent"])(extent));
      }
      this.extentFeature_ = extentFeature;
      /** @type {VectorSource} */ (this.extentOverlay_.getSource()).addFeature(extentFeature);
    } else {
      if (!extent) {
        extentFeature.setGeometry(undefined);
      } else {
        extentFeature.setGeometry(Object(_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_7__["fromExtent"])(extent));
      }
    }
    return extentFeature;
  };

  /**
   * @param {import("../coordinate.js").Coordinate} vertex location of feature
   * @returns {Feature} vertex as feature
   * @private
   */
  ExtentInteraction.prototype.createOrUpdatePointerFeature_ = function createOrUpdatePointerFeature_ (vertex) {
    var vertexFeature = this.vertexFeature_;
    if (!vertexFeature) {
      vertexFeature = new _Feature_js__WEBPACK_IMPORTED_MODULE_0__["default"](new _geom_Point_js__WEBPACK_IMPORTED_MODULE_6__["default"](vertex));
      this.vertexFeature_ = vertexFeature;
      /** @type {VectorSource} */ (this.vertexOverlay_.getSource()).addFeature(vertexFeature);
    } else {
      var geometry = /** @type {Point} */ (vertexFeature.getGeometry());
      geometry.setCoordinates(vertex);
    }
    return vertexFeature;
  };

  /**
   * @inheritDoc
   */
  ExtentInteraction.prototype.handleEvent = function handleEvent (mapBrowserEvent) {
    if (!(/** @type {import("../MapBrowserPointerEvent.js").default} */ (mapBrowserEvent).pointerEvent)) {
      return true;
    }
    //display pointer (if not dragging)
    if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERMOVE && !this.handlingDownUpSequence) {
      this.handlePointerMove_(mapBrowserEvent);
    }
    //call pointer to determine up/down/drag
    PointerInteraction.prototype.handleEvent.call(this, mapBrowserEvent);
    //return false to stop propagation
    return false;
  };

  /**
   * @inheritDoc
   */
  ExtentInteraction.prototype.handleDownEvent = function handleDownEvent (mapBrowserEvent) {
    var pixel = mapBrowserEvent.pixel;
    var map = mapBrowserEvent.map;

    var extent = this.getExtent();
    var vertex = this.snapToVertex_(pixel, map);

    //find the extent corner opposite the passed corner
    var getOpposingPoint = function(point) {
      var x_ = null;
      var y_ = null;
      if (point[0] == extent[0]) {
        x_ = extent[2];
      } else if (point[0] == extent[2]) {
        x_ = extent[0];
      }
      if (point[1] == extent[1]) {
        y_ = extent[3];
      } else if (point[1] == extent[3]) {
        y_ = extent[1];
      }
      if (x_ !== null && y_ !== null) {
        return [x_, y_];
      }
      return null;
    };
    if (vertex && extent) {
      var x = (vertex[0] == extent[0] || vertex[0] == extent[2]) ? vertex[0] : null;
      var y = (vertex[1] == extent[1] || vertex[1] == extent[3]) ? vertex[1] : null;

      //snap to point
      if (x !== null && y !== null) {
        this.pointerHandler_ = getPointHandler(getOpposingPoint(vertex));
      //snap to edge
      } else if (x !== null) {
        this.pointerHandler_ = getEdgeHandler(
          getOpposingPoint([x, extent[1]]),
          getOpposingPoint([x, extent[3]])
        );
      } else if (y !== null) {
        this.pointerHandler_ = getEdgeHandler(
          getOpposingPoint([extent[0], y]),
          getOpposingPoint([extent[2], y])
        );
      }
    //no snap - new bbox
    } else {
      vertex = map.getCoordinateFromPixel(pixel);
      this.setExtent([vertex[0], vertex[1], vertex[0], vertex[1]]);
      this.pointerHandler_ = getPointHandler(vertex);
    }
    return true; //event handled; start downup sequence
  };

  /**
   * @inheritDoc
   */
  ExtentInteraction.prototype.handleDragEvent = function handleDragEvent (mapBrowserEvent) {
    if (this.pointerHandler_) {
      var pixelCoordinate = mapBrowserEvent.coordinate;
      this.setExtent(this.pointerHandler_(pixelCoordinate));
      this.createOrUpdatePointerFeature_(pixelCoordinate);
    }
    return true;
  };

  /**
   * @inheritDoc
   */
  ExtentInteraction.prototype.handleUpEvent = function handleUpEvent (mapBrowserEvent) {
    this.pointerHandler_ = null;
    //If bbox is zero area, set to null;
    var extent = this.getExtent();
    if (!extent || Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["getArea"])(extent) === 0) {
      this.setExtent(null);
    }
    return false; //Stop handling downup sequence
  };

  /**
   * @inheritDoc
   */
  ExtentInteraction.prototype.setMap = function setMap (map) {
    this.extentOverlay_.setMap(map);
    this.vertexOverlay_.setMap(map);
    PointerInteraction.prototype.setMap.call(this, map);
  };

  /**
   * Returns the current drawn extent in the view projection
   *
   * @return {import("../extent.js").Extent} Drawn extent in the view projection.
   * @api
   */
  ExtentInteraction.prototype.getExtent = function getExtent () {
    return this.extent_;
  };

  /**
   * Manually sets the drawn extent, using the view projection.
   *
   * @param {import("../extent.js").Extent} extent Extent
   * @api
   */
  ExtentInteraction.prototype.setExtent = function setExtent (extent) {
    //Null extent means no bbox
    this.extent_ = extent ? extent : null;
    this.createOrUpdateExtentFeature_(extent);
    this.dispatchEvent(new ExtentInteractionEvent(this.extent_));
  };

  return ExtentInteraction;
}(_Pointer_js__WEBPACK_IMPORTED_MODULE_8__["default"]));

/**
 * Returns the default style for the drawn bbox
 *
 * @return {import("../style/Style.js").StyleFunction} Default Extent style
 */
function getDefaultExtentStyleFunction() {
  var style = Object(_style_Style_js__WEBPACK_IMPORTED_MODULE_11__["createEditingStyle"])();
  return function(feature, resolution) {
    return style[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POLYGON];
  };
}

/**
 * Returns the default style for the pointer
 *
 * @return {import("../style/Style.js").StyleFunction} Default pointer style
 */
function getDefaultPointerStyleFunction() {
  var style = Object(_style_Style_js__WEBPACK_IMPORTED_MODULE_11__["createEditingStyle"])();
  return function(feature, resolution) {
    return style[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POINT];
  };
}

/**
 * @param {import("../coordinate.js").Coordinate} fixedPoint corner that will be unchanged in the new extent
 * @returns {function (import("../coordinate.js").Coordinate): import("../extent.js").Extent} event handler
 */
function getPointHandler(fixedPoint) {
  return function(point) {
    return Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["boundingExtent"])([fixedPoint, point]);
  };
}

/**
 * @param {import("../coordinate.js").Coordinate} fixedP1 first corner that will be unchanged in the new extent
 * @param {import("../coordinate.js").Coordinate} fixedP2 second corner that will be unchanged in the new extent
 * @returns {function (import("../coordinate.js").Coordinate): import("../extent.js").Extent|null} event handler
 */
function getEdgeHandler(fixedP1, fixedP2) {
  if (fixedP1[0] == fixedP2[0]) {
    return function(point) {
      return Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["boundingExtent"])([fixedP1, [point[0], fixedP2[1]]]);
    };
  } else if (fixedP1[1] == fixedP2[1]) {
    return function(point) {
      return Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["boundingExtent"])([fixedP1, [fixedP2[0], point[1]]]);
    };
  } else {
    return null;
  }
}

/**
 * @param {import("../extent.js").Extent} extent extent
 * @returns {Array<Array<import("../coordinate.js").Coordinate>>} extent line segments
 */
function getSegments(extent) {
  return [
    [[extent[0], extent[1]], [extent[0], extent[3]]],
    [[extent[0], extent[3]], [extent[2], extent[3]]],
    [[extent[2], extent[3]], [extent[2], extent[1]]],
    [[extent[2], extent[1]], [extent[0], extent[1]]]
  ];
}


/* harmony default export */ __webpack_exports__["default"] = (ExtentInteraction);

//# sourceMappingURL=Extent.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/Interaction.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/interaction/Interaction.js ***!
  \****************************************************/
/*! exports provided: pan, rotate, rotateWithoutConstraints, zoom, zoomByDelta, zoomWithoutConstraints, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pan", function() { return pan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateWithoutConstraints", function() { return rotateWithoutConstraints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zoom", function() { return zoom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zoomByDelta", function() { return zoomByDelta; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zoomWithoutConstraints", function() { return zoomWithoutConstraints; });
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../easing.js */ "./node_modules/ol/easing.js");
/* harmony import */ var _Property_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Property.js */ "./node_modules/ol/interaction/Property.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/interaction/Interaction
 */






/**
 * Object literal with config options for interactions.
 * @typedef {Object} InteractionOptions
 * @property {function(import("../MapBrowserEvent.js").default):boolean} handleEvent
 * Method called by the map to notify the interaction that a browser event was
 * dispatched to the map. If the function returns a falsy value, propagation of
 * the event to other interactions in the map's interactions chain will be
 * prevented (this includes functions with no explicit return).
 */


/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * User actions that change the state of the map. Some are similar to controls,
 * but are not associated with a DOM element.
 * For example, {@link module:ol/interaction/KeyboardZoom~KeyboardZoom} is
 * functionally the same as {@link module:ol/control/Zoom~Zoom}, but triggered
 * by a keyboard event not a button element event.
 * Although interactions do not have a DOM element, some of them do render
 * vectors and so are visible on the screen.
 * @api
 */
var Interaction = /*@__PURE__*/(function (BaseObject) {
  function Interaction(options) {
    BaseObject.call(this);

    if (options.handleEvent) {
      this.handleEvent = options.handleEvent;
    }

    /**
     * @private
     * @type {import("../PluggableMap.js").default}
     */
    this.map_ = null;

    this.setActive(true);
  }

  if ( BaseObject ) Interaction.__proto__ = BaseObject;
  Interaction.prototype = Object.create( BaseObject && BaseObject.prototype );
  Interaction.prototype.constructor = Interaction;

  /**
   * Return whether the interaction is currently active.
   * @return {boolean} `true` if the interaction is active, `false` otherwise.
   * @observable
   * @api
   */
  Interaction.prototype.getActive = function getActive () {
    return /** @type {boolean} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].ACTIVE));
  };

  /**
   * Get the map associated with this interaction.
   * @return {import("../PluggableMap.js").default} Map.
   * @api
   */
  Interaction.prototype.getMap = function getMap () {
    return this.map_;
  };

  /**
   * Handles the {@link module:ol/MapBrowserEvent map browser event}.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  Interaction.prototype.handleEvent = function handleEvent (mapBrowserEvent) {
    return true;
  };

  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */
  Interaction.prototype.setActive = function setActive (active) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].ACTIVE, active);
  };

  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../PluggableMap.js").default} map Map.
   */
  Interaction.prototype.setMap = function setMap (map) {
    this.map_ = map;
  };

  return Interaction;
}(_Object_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/**
 * @param {import("../View.js").default} view View.
 * @param {import("../coordinate.js").Coordinate} delta Delta.
 * @param {number=} opt_duration Duration.
 */
function pan(view, delta, opt_duration) {
  var currentCenter = view.getCenter();
  if (currentCenter) {
    var center = view.constrainCenter(
      [currentCenter[0] + delta[0], currentCenter[1] + delta[1]]);
    if (opt_duration) {
      view.animate({
        duration: opt_duration,
        easing: _easing_js__WEBPACK_IMPORTED_MODULE_1__["linear"],
        center: center
      });
    } else {
      view.setCenter(center);
    }
  }
}


/**
 * @param {import("../View.js").default} view View.
 * @param {number|undefined} rotation Rotation.
 * @param {import("../coordinate.js").Coordinate=} opt_anchor Anchor coordinate.
 * @param {number=} opt_duration Duration.
 */
function rotate(view, rotation, opt_anchor, opt_duration) {
  rotation = view.constrainRotation(rotation, 0);
  rotateWithoutConstraints(view, rotation, opt_anchor, opt_duration);
}


/**
 * @param {import("../View.js").default} view View.
 * @param {number|undefined} rotation Rotation.
 * @param {import("../coordinate.js").Coordinate=} opt_anchor Anchor coordinate.
 * @param {number=} opt_duration Duration.
 */
function rotateWithoutConstraints(view, rotation, opt_anchor, opt_duration) {
  if (rotation !== undefined) {
    var currentRotation = view.getRotation();
    var currentCenter = view.getCenter();
    if (currentRotation !== undefined && currentCenter && opt_duration > 0) {
      view.animate({
        rotation: rotation,
        anchor: opt_anchor,
        duration: opt_duration,
        easing: _easing_js__WEBPACK_IMPORTED_MODULE_1__["easeOut"]
      });
    } else {
      view.rotate(rotation, opt_anchor);
    }
  }
}


/**
 * @param {import("../View.js").default} view View.
 * @param {number|undefined} resolution Resolution to go to.
 * @param {import("../coordinate.js").Coordinate=} opt_anchor Anchor coordinate.
 * @param {number=} opt_duration Duration.
 * @param {number=} opt_direction Zooming direction; > 0 indicates
 *     zooming out, in which case the constraints system will select
 *     the largest nearest resolution; < 0 indicates zooming in, in
 *     which case the constraints system will select the smallest
 *     nearest resolution; == 0 indicates that the zooming direction
 *     is unknown/not relevant, in which case the constraints system
 *     will select the nearest resolution. If not defined 0 is
 *     assumed.
 */
function zoom(view, resolution, opt_anchor, opt_duration, opt_direction) {
  resolution = view.constrainResolution(resolution, 0, opt_direction);
  zoomWithoutConstraints(view, resolution, opt_anchor, opt_duration);
}


/**
 * @param {import("../View.js").default} view View.
 * @param {number} delta Delta from previous zoom level.
 * @param {import("../coordinate.js").Coordinate=} opt_anchor Anchor coordinate.
 * @param {number=} opt_duration Duration.
 */
function zoomByDelta(view, delta, opt_anchor, opt_duration) {
  var currentResolution = view.getResolution();
  var resolution = view.constrainResolution(currentResolution, delta, 0);

  if (resolution !== undefined) {
    var resolutions = view.getResolutions();
    resolution = Object(_math_js__WEBPACK_IMPORTED_MODULE_3__["clamp"])(
      resolution,
      view.getMinResolution() || resolutions[resolutions.length - 1],
      view.getMaxResolution() || resolutions[0]);
  }

  // If we have a constraint on center, we need to change the anchor so that the
  // new center is within the extent. We first calculate the new center, apply
  // the constraint to it, and then calculate back the anchor
  if (opt_anchor && resolution !== undefined && resolution !== currentResolution) {
    var currentCenter = view.getCenter();
    var center = view.calculateCenterZoom(resolution, opt_anchor);
    center = view.constrainCenter(center);

    opt_anchor = [
      (resolution * currentCenter[0] - currentResolution * center[0]) /
          (resolution - currentResolution),
      (resolution * currentCenter[1] - currentResolution * center[1]) /
          (resolution - currentResolution)
    ];
  }

  zoomWithoutConstraints(view, resolution, opt_anchor, opt_duration);
}


/**
 * @param {import("../View.js").default} view View.
 * @param {number|undefined} resolution Resolution to go to.
 * @param {import("../coordinate.js").Coordinate=} opt_anchor Anchor coordinate.
 * @param {number=} opt_duration Duration.
 */
function zoomWithoutConstraints(view, resolution, opt_anchor, opt_duration) {
  if (resolution) {
    var currentResolution = view.getResolution();
    var currentCenter = view.getCenter();
    if (currentResolution !== undefined && currentCenter &&
        resolution !== currentResolution && opt_duration) {
      view.animate({
        resolution: resolution,
        anchor: opt_anchor,
        duration: opt_duration,
        easing: _easing_js__WEBPACK_IMPORTED_MODULE_1__["easeOut"]
      });
    } else {
      if (opt_anchor) {
        var center = view.calculateCenterZoom(resolution, opt_anchor);
        view.setCenter(center);
      }
      view.setResolution(resolution);
    }
  }
}

/* harmony default export */ __webpack_exports__["default"] = (Interaction);

//# sourceMappingURL=Interaction.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/KeyboardPan.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/interaction/KeyboardPan.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../coordinate.js */ "./node_modules/ol/coordinate.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _events_KeyCode_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/KeyCode.js */ "./node_modules/ol/events/KeyCode.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/**
 * @module ol/interaction/KeyboardPan
 */







/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. Default is
 * {@link module:ol/events/condition~noModifierKeys} and
 * {@link module:ol/events/condition~targetNotEditable}.
 * @property {number} [duration=100] Animation duration in milliseconds.
 * @property {number} [pixelDelta=128] The amount of pixels to pan on each key
 * press.
 */


/**
 * @classdesc
 * Allows the user to pan the map using keyboard arrows.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {@link module:ol/Map~Map}. `document` never loses focus but, for any other
 * element, focus will have to be on, and returned to, this element if the keys
 * are to function.
 * See also {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}.
 * @api
 */
var KeyboardPan = /*@__PURE__*/(function (Interaction) {
  function KeyboardPan(opt_options) {

    Interaction.call(this, {
      handleEvent: handleEvent
    });

    var options = opt_options || {};

    /**
     * @private
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Browser event.
     * @return {boolean} Combined condition result.
     */
    this.defaultCondition_ = function(mapBrowserEvent) {
      return Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_3__["noModifierKeys"])(mapBrowserEvent) &&
        Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_3__["targetNotEditable"])(mapBrowserEvent);
    };

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.condition_ = options.condition !== undefined ?
      options.condition : this.defaultCondition_;

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 100;

    /**
     * @private
     * @type {number}
     */
    this.pixelDelta_ = options.pixelDelta !== undefined ?
      options.pixelDelta : 128;

  }

  if ( Interaction ) KeyboardPan.__proto__ = Interaction;
  KeyboardPan.prototype = Object.create( Interaction && Interaction.prototype );
  KeyboardPan.prototype.constructor = KeyboardPan;

  return KeyboardPan;
}(_Interaction_js__WEBPACK_IMPORTED_MODULE_4__["default"]));


/**
 * Handles the {@link module:ol/MapBrowserEvent map browser event} if it was a
 * `KeyEvent`, and decides the direction to pan to (if an arrow key was
 * pressed).
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} `false` to stop event propagation.
 * @this {KeyboardPan}
 */
function handleEvent(mapBrowserEvent) {
  var stopEvent = false;
  if (mapBrowserEvent.type == _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].KEYDOWN) {
    var keyEvent = /** @type {KeyboardEvent} */ (mapBrowserEvent.originalEvent);
    var keyCode = keyEvent.keyCode;
    if (this.condition_(mapBrowserEvent) &&
        (keyCode == _events_KeyCode_js__WEBPACK_IMPORTED_MODULE_2__["default"].DOWN ||
        keyCode == _events_KeyCode_js__WEBPACK_IMPORTED_MODULE_2__["default"].LEFT ||
        keyCode == _events_KeyCode_js__WEBPACK_IMPORTED_MODULE_2__["default"].RIGHT ||
        keyCode == _events_KeyCode_js__WEBPACK_IMPORTED_MODULE_2__["default"].UP)) {
      var map = mapBrowserEvent.map;
      var view = map.getView();
      var mapUnitsDelta = view.getResolution() * this.pixelDelta_;
      var deltaX = 0, deltaY = 0;
      if (keyCode == _events_KeyCode_js__WEBPACK_IMPORTED_MODULE_2__["default"].DOWN) {
        deltaY = -mapUnitsDelta;
      } else if (keyCode == _events_KeyCode_js__WEBPACK_IMPORTED_MODULE_2__["default"].LEFT) {
        deltaX = -mapUnitsDelta;
      } else if (keyCode == _events_KeyCode_js__WEBPACK_IMPORTED_MODULE_2__["default"].RIGHT) {
        deltaX = mapUnitsDelta;
      } else {
        deltaY = mapUnitsDelta;
      }
      var delta = [deltaX, deltaY];
      Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_0__["rotate"])(delta, view.getRotation());
      Object(_Interaction_js__WEBPACK_IMPORTED_MODULE_4__["pan"])(view, delta, this.duration_);
      mapBrowserEvent.preventDefault();
      stopEvent = true;
    }
  }
  return !stopEvent;
}

/* harmony default export */ __webpack_exports__["default"] = (KeyboardPan);

//# sourceMappingURL=KeyboardPan.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/KeyboardZoom.js":
/*!*****************************************************!*\
  !*** ./node_modules/ol/interaction/KeyboardZoom.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/**
 * @module ol/interaction/KeyboardZoom
 */





/**
 * @typedef {Object} Options
 * @property {number} [duration=100] Animation duration in milliseconds.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. Default is
 * {@link module:ol/events/condition~targetNotEditable}.
 * @property {number} [delta=1] The zoom level delta on each key press.
 */


/**
 * @classdesc
 * Allows the user to zoom the map using keyboard + and -.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {@link module:ol/Map~Map}. `document` never loses focus but, for any other
 * element, focus will have to be on, and returned to, this element if the keys
 * are to function.
 * See also {@link module:ol/interaction/KeyboardPan~KeyboardPan}.
 * @api
 */
var KeyboardZoom = /*@__PURE__*/(function (Interaction) {
  function KeyboardZoom(opt_options) {

    Interaction.call(this, {
      handleEvent: handleEvent
    });

    var options = opt_options ? opt_options : {};

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_1__["targetNotEditable"];

    /**
     * @private
     * @type {number}
     */
    this.delta_ = options.delta ? options.delta : 1;

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 100;

  }

  if ( Interaction ) KeyboardZoom.__proto__ = Interaction;
  KeyboardZoom.prototype = Object.create( Interaction && Interaction.prototype );
  KeyboardZoom.prototype.constructor = KeyboardZoom;

  return KeyboardZoom;
}(_Interaction_js__WEBPACK_IMPORTED_MODULE_2__["default"]));


/**
 * Handles the {@link module:ol/MapBrowserEvent map browser event} if it was a
 * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
 * key pressed was '+' or '-').
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} `false` to stop event propagation.
 * @this {KeyboardZoom}
 */
function handleEvent(mapBrowserEvent) {
  var stopEvent = false;
  if (mapBrowserEvent.type == _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].KEYDOWN ||
      mapBrowserEvent.type == _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].KEYPRESS) {
    var keyEvent = /** @type {KeyboardEvent} */ (mapBrowserEvent.originalEvent);
    var charCode = keyEvent.charCode;
    if (this.condition_(mapBrowserEvent) &&
        (charCode == '+'.charCodeAt(0) || charCode == '-'.charCodeAt(0))) {
      var map = mapBrowserEvent.map;
      var delta = (charCode == '+'.charCodeAt(0)) ? this.delta_ : -this.delta_;
      var view = map.getView();
      Object(_Interaction_js__WEBPACK_IMPORTED_MODULE_2__["zoomByDelta"])(view, delta, undefined, this.duration_);
      mapBrowserEvent.preventDefault();
      stopEvent = true;
    }
  }
  return !stopEvent;
}

/* harmony default export */ __webpack_exports__["default"] = (KeyboardZoom);

//# sourceMappingURL=KeyboardZoom.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/Modify.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/interaction/Modify.js ***!
  \***********************************************/
/*! exports provided: ModifyEvent, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ModifyEvent", function() { return ModifyEvent; });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Collection.js */ "./node_modules/ol/Collection.js");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../CollectionEventType.js */ "./node_modules/ol/CollectionEventType.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Feature.js */ "./node_modules/ol/Feature.js");
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../MapBrowserEventType.js */ "./node_modules/ol/MapBrowserEventType.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../coordinate.js */ "./node_modules/ol/coordinate.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _geom_Point_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../geom/Point.js */ "./node_modules/ol/geom/Point.js");
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/* harmony import */ var _layer_Vector_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../layer/Vector.js */ "./node_modules/ol/layer/Vector.js");
/* harmony import */ var _source_Vector_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../source/Vector.js */ "./node_modules/ol/source/Vector.js");
/* harmony import */ var _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../source/VectorEventType.js */ "./node_modules/ol/source/VectorEventType.js");
/* harmony import */ var _structs_RBush_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../structs/RBush.js */ "./node_modules/ol/structs/RBush.js");
/* harmony import */ var _style_Style_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../style/Style.js */ "./node_modules/ol/style/Style.js");
/**
 * @module ol/interaction/Modify
 */






















/**
 * The segment index assigned to a circle's center when
 * breaking up a circle into ModifySegmentDataType segments.
 * @type {number}
 */
var CIRCLE_CENTER_INDEX = 0;

/**
 * The segment index assigned to a circle's circumference when
 * breaking up a circle into ModifySegmentDataType segments.
 * @type {number}
 */
var CIRCLE_CIRCUMFERENCE_INDEX = 1;


/**
 * @enum {string}
 */
var ModifyEventType = {
  /**
   * Triggered upon feature modification start
   * @event ModifyEvent#modifystart
   * @api
   */
  MODIFYSTART: 'modifystart',
  /**
   * Triggered upon feature modification end
   * @event ModifyEvent#modifyend
   * @api
   */
  MODIFYEND: 'modifyend'
};


/**
 * @typedef {Object} SegmentData
 * @property {Array<number>} [depth]
 * @property {Feature} feature
 * @property {import("../geom/SimpleGeometry.js").default} geometry
 * @property {number} [index]
 * @property {Array<import("../extent.js").Extent>} segment
 * @property {Array<SegmentData>} [featureSegments]
 */


/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event will be considered to add or move a
 * vertex to the sketch. Default is
 * {@link module:ol/events/condition~primaryAction}.
 * @property {import("../events/condition.js").Condition} [deleteCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. By default,
 * {@link module:ol/events/condition~singleClick} with
 * {@link module:ol/events/condition~altKeyOnly} results in a vertex deletion.
 * @property {import("../events/condition.js").Condition} [insertVertexCondition] A
 * function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and
 * returns a boolean to indicate whether a new vertex can be added to the sketch
 * features. Default is {@link module:ol/events/condition~always}.
 * @property {number} [pixelTolerance=10] Pixel tolerance for considering the
 * pointer close enough to a segment or vertex for editing.
 * @property {import("../style/Style.js").StyleLike} [style]
 * Style used for the features being modified. By default the default edit
 * style is used (see {@link module:ol/style}).
 * @property {VectorSource} [source] The vector source with
 * features to modify.  If a vector source is not provided, a feature collection
 * must be provided with the features option.
 * @property {Collection<Feature>} [features]
 * The features the interaction works on.  If a feature collection is not
 * provided, a vector source must be provided with the source option.
 * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch
 * overlay.
 */


/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Modify~Modify} instances are
 * instances of this type.
 */
var ModifyEvent = /*@__PURE__*/(function (Event) {
  function ModifyEvent(type, features, mapBrowserPointerEvent) {
    Event.call(this, type);

    /**
     * The features being modified.
     * @type {Collection<Feature>}
     * @api
     */
    this.features = features;

    /**
     * Associated {@link module:ol/MapBrowserEvent}.
     * @type {import("../MapBrowserEvent.js").default}
     * @api
     */
    this.mapBrowserEvent = mapBrowserPointerEvent;

  }

  if ( Event ) ModifyEvent.__proto__ = Event;
  ModifyEvent.prototype = Object.create( Event && Event.prototype );
  ModifyEvent.prototype.constructor = ModifyEvent;

  return ModifyEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_8__["default"]));


/**
 * @classdesc
 * Interaction for modifying feature geometries.  To modify features that have
 * been added to an existing source, construct the modify interaction with the
 * `source` option.  If you want to modify features in a collection (for example,
 * the collection used by a select interaction), construct the interaction with
 * the `features` option.  The interaction must be constructed with either a
 * `source` or `features` option.
 *
 * By default, the interaction will allow deletion of vertices when the `alt`
 * key is pressed.  To configure the interaction with a different condition
 * for deletion, use the `deleteCondition` option.
 * @fires ModifyEvent
 * @api
 */
var Modify = /*@__PURE__*/(function (PointerInteraction) {
  function Modify(options) {

    PointerInteraction.call(/** @type {import("./Pointer.js").Options} */ this, (options));

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_10__["primaryAction"];

    /**
     * @private
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Browser event.
     * @return {boolean} Combined condition result.
     */
    this.defaultDeleteCondition_ = function(mapBrowserEvent) {
      return Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_10__["altKeyOnly"])(mapBrowserEvent) && Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_10__["singleClick"])(mapBrowserEvent);
    };

    /**
     * @type {import("../events/condition.js").Condition}
     * @private
     */
    this.deleteCondition_ = options.deleteCondition ?
      options.deleteCondition : this.defaultDeleteCondition_;

    /**
     * @type {import("../events/condition.js").Condition}
     * @private
     */
    this.insertVertexCondition_ = options.insertVertexCondition ?
      options.insertVertexCondition : _events_condition_js__WEBPACK_IMPORTED_MODULE_10__["always"];

    /**
     * Editing vertex.
     * @type {Feature}
     * @private
     */
    this.vertexFeature_ = null;

    /**
     * Segments intersecting {@link this.vertexFeature_} by segment uid.
     * @type {Object<string, boolean>}
     * @private
     */
    this.vertexSegments_ = null;

    /**
     * @type {import("../pixel.js").Pixel}
     * @private
     */
    this.lastPixel_ = [0, 0];

    /**
     * Tracks if the next `singleclick` event should be ignored to prevent
     * accidental deletion right after vertex creation.
     * @type {boolean}
     * @private
     */
    this.ignoreNextSingleClick_ = false;

    /**
     * @type {boolean}
     * @private
     */
    this.modified_ = false;

    /**
     * Segment RTree for each layer
     * @type {RBush<SegmentData>}
     * @private
     */
    this.rBush_ = new _structs_RBush_js__WEBPACK_IMPORTED_MODULE_18__["default"]();

    /**
     * @type {number}
     * @private
     */
    this.pixelTolerance_ = options.pixelTolerance !== undefined ?
      options.pixelTolerance : 10;

    /**
     * @type {boolean}
     * @private
     */
    this.snappedToVertex_ = false;

    /**
     * Indicate whether the interaction is currently changing a feature's
     * coordinates.
     * @type {boolean}
     * @private
     */
    this.changingFeature_ = false;

    /**
     * @type {Array}
     * @private
     */
    this.dragSegments_ = [];

    /**
     * Draw overlay where sketch features are drawn.
     * @type {VectorLayer}
     * @private
     */
    this.overlay_ = new _layer_Vector_js__WEBPACK_IMPORTED_MODULE_15__["default"]({
      source: new _source_Vector_js__WEBPACK_IMPORTED_MODULE_16__["default"]({
        useSpatialIndex: false,
        wrapX: !!options.wrapX
      }),
      style: options.style ? options.style :
        getDefaultStyleFunction(),
      updateWhileAnimating: true,
      updateWhileInteracting: true
    });

    /**
     * @const
     * @private
     * @type {!Object<string, function(Feature, import("../geom/Geometry.js").default)>}
     */
    this.SEGMENT_WRITERS_ = {
      'Point': this.writePointGeometry_,
      'LineString': this.writeLineStringGeometry_,
      'LinearRing': this.writeLineStringGeometry_,
      'Polygon': this.writePolygonGeometry_,
      'MultiPoint': this.writeMultiPointGeometry_,
      'MultiLineString': this.writeMultiLineStringGeometry_,
      'MultiPolygon': this.writeMultiPolygonGeometry_,
      'Circle': this.writeCircleGeometry_,
      'GeometryCollection': this.writeGeometryCollectionGeometry_
    };


    /**
     * @type {VectorSource}
     * @private
     */
    this.source_ = null;

    var features;
    if (options.source) {
      this.source_ = options.source;
      features = new _Collection_js__WEBPACK_IMPORTED_MODULE_1__["default"](this.source_.getFeatures());
      Object(_events_js__WEBPACK_IMPORTED_MODULE_7__["listen"])(this.source_, _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_17__["default"].ADDFEATURE,
        this.handleSourceAdd_, this);
      Object(_events_js__WEBPACK_IMPORTED_MODULE_7__["listen"])(this.source_, _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_17__["default"].REMOVEFEATURE,
        this.handleSourceRemove_, this);
    } else {
      features = options.features;
    }
    if (!features) {
      throw new Error('The modify interaction requires features or a source');
    }

    /**
     * @type {Collection<Feature>}
     * @private
     */
    this.features_ = features;

    this.features_.forEach(this.addFeature_.bind(this));
    Object(_events_js__WEBPACK_IMPORTED_MODULE_7__["listen"])(this.features_, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].ADD,
      this.handleFeatureAdd_, this);
    Object(_events_js__WEBPACK_IMPORTED_MODULE_7__["listen"])(this.features_, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].REMOVE,
      this.handleFeatureRemove_, this);

    /**
     * @type {import("../MapBrowserPointerEvent.js").default}
     * @private
     */
    this.lastPointerEvent_ = null;

  }

  if ( PointerInteraction ) Modify.__proto__ = PointerInteraction;
  Modify.prototype = Object.create( PointerInteraction && PointerInteraction.prototype );
  Modify.prototype.constructor = Modify;

  /**
   * @param {Feature} feature Feature.
   * @private
   */
  Modify.prototype.addFeature_ = function addFeature_ (feature) {
    var geometry = feature.getGeometry();
    if (geometry && geometry.getType() in this.SEGMENT_WRITERS_) {
      this.SEGMENT_WRITERS_[geometry.getType()].call(this, feature, geometry);
    }
    var map = this.getMap();
    if (map && map.isRendered() && this.getActive()) {
      this.handlePointerAtPixel_(this.lastPixel_, map);
    }
    Object(_events_js__WEBPACK_IMPORTED_MODULE_7__["listen"])(feature, _events_EventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].CHANGE,
      this.handleFeatureChange_, this);
  };

  /**
   * @param {import("../MapBrowserPointerEvent.js").default} evt Map browser event
   * @private
   */
  Modify.prototype.willModifyFeatures_ = function willModifyFeatures_ (evt) {
    if (!this.modified_) {
      this.modified_ = true;
      this.dispatchEvent(new ModifyEvent(
        ModifyEventType.MODIFYSTART, this.features_, evt));
    }
  };

  /**
   * @param {Feature} feature Feature.
   * @private
   */
  Modify.prototype.removeFeature_ = function removeFeature_ (feature) {
    this.removeFeatureSegmentData_(feature);
    // Remove the vertex feature if the collection of canditate features
    // is empty.
    if (this.vertexFeature_ && this.features_.getLength() === 0) {
      /** @type {VectorSource} */ (this.overlay_.getSource()).removeFeature(this.vertexFeature_);
      this.vertexFeature_ = null;
    }
    Object(_events_js__WEBPACK_IMPORTED_MODULE_7__["unlisten"])(feature, _events_EventType_js__WEBPACK_IMPORTED_MODULE_9__["default"].CHANGE,
      this.handleFeatureChange_, this);
  };

  /**
   * @param {Feature} feature Feature.
   * @private
   */
  Modify.prototype.removeFeatureSegmentData_ = function removeFeatureSegmentData_ (feature) {
    var rBush = this.rBush_;
    var /** @type {Array<SegmentData>} */ nodesToRemove = [];
    rBush.forEach(
      /**
       * @param {SegmentData} node RTree node.
       */
      function(node) {
        if (feature === node.feature) {
          nodesToRemove.push(node);
        }
      });
    for (var i = nodesToRemove.length - 1; i >= 0; --i) {
      rBush.remove(nodesToRemove[i]);
    }
  };

  /**
   * @inheritDoc
   */
  Modify.prototype.setActive = function setActive (active) {
    if (this.vertexFeature_ && !active) {
      /** @type {VectorSource} */ (this.overlay_.getSource()).removeFeature(this.vertexFeature_);
      this.vertexFeature_ = null;
    }
    PointerInteraction.prototype.setActive.call(this, active);
  };

  /**
   * @inheritDoc
   */
  Modify.prototype.setMap = function setMap (map) {
    this.overlay_.setMap(map);
    PointerInteraction.prototype.setMap.call(this, map);
  };

  /**
   * Get the overlay layer that this interaction renders sketch features to.
   * @return {VectorLayer} Overlay layer.
   * @api
   */
  Modify.prototype.getOverlay = function getOverlay () {
    return this.overlay_;
  };

  /**
   * @param {import("../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  Modify.prototype.handleSourceAdd_ = function handleSourceAdd_ (event) {
    if (event.feature) {
      this.features_.push(event.feature);
    }
  };

  /**
   * @param {import("../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  Modify.prototype.handleSourceRemove_ = function handleSourceRemove_ (event) {
    if (event.feature) {
      this.features_.remove(event.feature);
    }
  };

  /**
   * @param {import("../Collection.js").CollectionEvent} evt Event.
   * @private
   */
  Modify.prototype.handleFeatureAdd_ = function handleFeatureAdd_ (evt) {
    this.addFeature_(/** @type {Feature} */ (evt.element));
  };

  /**
   * @param {import("../events/Event.js").default} evt Event.
   * @private
   */
  Modify.prototype.handleFeatureChange_ = function handleFeatureChange_ (evt) {
    if (!this.changingFeature_) {
      var feature = /** @type {Feature} */ (evt.target);
      this.removeFeature_(feature);
      this.addFeature_(feature);
    }
  };

  /**
   * @param {import("../Collection.js").CollectionEvent} evt Event.
   * @private
   */
  Modify.prototype.handleFeatureRemove_ = function handleFeatureRemove_ (evt) {
    var feature = /** @type {Feature} */ (evt.element);
    this.removeFeature_(feature);
  };

  /**
   * @param {Feature} feature Feature
   * @param {Point} geometry Geometry.
   * @private
   */
  Modify.prototype.writePointGeometry_ = function writePointGeometry_ (feature, geometry) {
    var coordinates = geometry.getCoordinates();
    var segmentData = /** @type {SegmentData} */ ({
      feature: feature,
      geometry: geometry,
      segment: [coordinates, coordinates]
    });
    this.rBush_.insert(geometry.getExtent(), segmentData);
  };

  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiPoint.js").default} geometry Geometry.
   * @private
   */
  Modify.prototype.writeMultiPointGeometry_ = function writeMultiPointGeometry_ (feature, geometry) {
    var points = geometry.getCoordinates();
    for (var i = 0, ii = points.length; i < ii; ++i) {
      var coordinates = points[i];
      var segmentData = /** @type {SegmentData} */ ({
        feature: feature,
        geometry: geometry,
        depth: [i],
        index: i,
        segment: [coordinates, coordinates]
      });
      this.rBush_.insert(geometry.getExtent(), segmentData);
    }
  };

  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/LineString.js").default} geometry Geometry.
   * @private
   */
  Modify.prototype.writeLineStringGeometry_ = function writeLineStringGeometry_ (feature, geometry) {
    var coordinates = geometry.getCoordinates();
    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
      var segment = coordinates.slice(i, i + 2);
      var segmentData = /** @type {SegmentData} */ ({
        feature: feature,
        geometry: geometry,
        index: i,
        segment: segment
      });
      this.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_11__["boundingExtent"])(segment), segmentData);
    }
  };

  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiLineString.js").default} geometry Geometry.
   * @private
   */
  Modify.prototype.writeMultiLineStringGeometry_ = function writeMultiLineStringGeometry_ (feature, geometry) {
    var lines = geometry.getCoordinates();
    for (var j = 0, jj = lines.length; j < jj; ++j) {
      var coordinates = lines[j];
      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
        var segment = coordinates.slice(i, i + 2);
        var segmentData = /** @type {SegmentData} */ ({
          feature: feature,
          geometry: geometry,
          depth: [j],
          index: i,
          segment: segment
        });
        this.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_11__["boundingExtent"])(segment), segmentData);
      }
    }
  };

  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/Polygon.js").default} geometry Geometry.
   * @private
   */
  Modify.prototype.writePolygonGeometry_ = function writePolygonGeometry_ (feature, geometry) {
    var rings = geometry.getCoordinates();
    for (var j = 0, jj = rings.length; j < jj; ++j) {
      var coordinates = rings[j];
      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
        var segment = coordinates.slice(i, i + 2);
        var segmentData = /** @type {SegmentData} */ ({
          feature: feature,
          geometry: geometry,
          depth: [j],
          index: i,
          segment: segment
        });
        this.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_11__["boundingExtent"])(segment), segmentData);
      }
    }
  };

  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
   * @private
   */
  Modify.prototype.writeMultiPolygonGeometry_ = function writeMultiPolygonGeometry_ (feature, geometry) {
    var polygons = geometry.getCoordinates();
    for (var k = 0, kk = polygons.length; k < kk; ++k) {
      var rings = polygons[k];
      for (var j = 0, jj = rings.length; j < jj; ++j) {
        var coordinates = rings[j];
        for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
          var segment = coordinates.slice(i, i + 2);
          var segmentData = /** @type {SegmentData} */ ({
            feature: feature,
            geometry: geometry,
            depth: [j, k],
            index: i,
            segment: segment
          });
          this.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_11__["boundingExtent"])(segment), segmentData);
        }
      }
    }
  };

  /**
   * We convert a circle into two segments.  The segment at index
   * {@link CIRCLE_CENTER_INDEX} is the
   * circle's center (a point).  The segment at index
   * {@link CIRCLE_CIRCUMFERENCE_INDEX} is
   * the circumference, and is not a line segment.
   *
   * @param {Feature} feature Feature.
   * @param {import("../geom/Circle.js").default} geometry Geometry.
   * @private
   */
  Modify.prototype.writeCircleGeometry_ = function writeCircleGeometry_ (feature, geometry) {
    var coordinates = geometry.getCenter();
    var centerSegmentData = /** @type {SegmentData} */ ({
      feature: feature,
      geometry: geometry,
      index: CIRCLE_CENTER_INDEX,
      segment: [coordinates, coordinates]
    });
    var circumferenceSegmentData = /** @type {SegmentData} */ ({
      feature: feature,
      geometry: geometry,
      index: CIRCLE_CIRCUMFERENCE_INDEX,
      segment: [coordinates, coordinates]
    });
    var featureSegments = [centerSegmentData, circumferenceSegmentData];
    centerSegmentData.featureSegments = circumferenceSegmentData.featureSegments = featureSegments;
    this.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_11__["createOrUpdateFromCoordinate"])(coordinates), centerSegmentData);
    this.rBush_.insert(geometry.getExtent(), circumferenceSegmentData);
  };

  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
   * @private
   */
  Modify.prototype.writeGeometryCollectionGeometry_ = function writeGeometryCollectionGeometry_ (feature, geometry) {
    var geometries = geometry.getGeometriesArray();
    for (var i = 0; i < geometries.length; ++i) {
      this.SEGMENT_WRITERS_[geometries[i].getType()].call(this, feature, geometries[i]);
    }
  };

  /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @return {Feature} Vertex feature.
   * @private
   */
  Modify.prototype.createOrUpdateVertexFeature_ = function createOrUpdateVertexFeature_ (coordinates) {
    var vertexFeature = this.vertexFeature_;
    if (!vertexFeature) {
      vertexFeature = new _Feature_js__WEBPACK_IMPORTED_MODULE_3__["default"](new _geom_Point_js__WEBPACK_IMPORTED_MODULE_13__["default"](coordinates));
      this.vertexFeature_ = vertexFeature;
      /** @type {VectorSource} */ (this.overlay_.getSource()).addFeature(vertexFeature);
    } else {
      var geometry = /** @type {Point} */ (vertexFeature.getGeometry());
      geometry.setCoordinates(coordinates);
    }
    return vertexFeature;
  };

  /**
   * Handles the {@link module:ol/MapBrowserEvent map browser event} and may modify the geometry.
   * @override
   */
  Modify.prototype.handleEvent = function handleEvent (mapBrowserEvent) {
    if (!(/** @type {import("../MapBrowserPointerEvent.js").default} */ (mapBrowserEvent).pointerEvent)) {
      return true;
    }
    this.lastPointerEvent_ = mapBrowserEvent;

    var handled;
    if (!mapBrowserEvent.map.getView().getInteracting() &&
        mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].POINTERMOVE &&
        !this.handlingDownUpSequence) {
      this.handlePointerMove_(mapBrowserEvent);
    }
    if (this.vertexFeature_ && this.deleteCondition_(mapBrowserEvent)) {
      if (mapBrowserEvent.type != _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].SINGLECLICK || !this.ignoreNextSingleClick_) {
        handled = this.removePoint();
      } else {
        handled = true;
      }
    }

    if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].SINGLECLICK) {
      this.ignoreNextSingleClick_ = false;
    }

    return PointerInteraction.prototype.handleEvent.call(this, mapBrowserEvent) && !handled;
  };

  /**
   * @inheritDoc
   */
  Modify.prototype.handleDragEvent = function handleDragEvent (evt) {
    this.ignoreNextSingleClick_ = false;
    this.willModifyFeatures_(evt);

    var vertex = evt.coordinate;
    for (var i = 0, ii = this.dragSegments_.length; i < ii; ++i) {
      var dragSegment = this.dragSegments_[i];
      var segmentData = dragSegment[0];
      var depth = segmentData.depth;
      var geometry = segmentData.geometry;
      var coordinates = (void 0);
      var segment = segmentData.segment;
      var index = dragSegment[1];

      while (vertex.length < geometry.getStride()) {
        vertex.push(segment[index][vertex.length]);
      }

      switch (geometry.getType()) {
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].POINT:
          coordinates = vertex;
          segment[0] = segment[1] = vertex;
          break;
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].MULTI_POINT:
          coordinates = geometry.getCoordinates();
          coordinates[segmentData.index] = vertex;
          segment[0] = segment[1] = vertex;
          break;
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].LINE_STRING:
          coordinates = geometry.getCoordinates();
          coordinates[segmentData.index + index] = vertex;
          segment[index] = vertex;
          break;
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].MULTI_LINE_STRING:
          coordinates = geometry.getCoordinates();
          coordinates[depth[0]][segmentData.index + index] = vertex;
          segment[index] = vertex;
          break;
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].POLYGON:
          coordinates = geometry.getCoordinates();
          coordinates[depth[0]][segmentData.index + index] = vertex;
          segment[index] = vertex;
          break;
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].MULTI_POLYGON:
          coordinates = geometry.getCoordinates();
          coordinates[depth[1]][depth[0]][segmentData.index + index] = vertex;
          segment[index] = vertex;
          break;
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].CIRCLE:
          segment[0] = segment[1] = vertex;
          if (segmentData.index === CIRCLE_CENTER_INDEX) {
            this.changingFeature_ = true;
            geometry.setCenter(vertex);
            this.changingFeature_ = false;
          } else { // We're dragging the circle's circumference:
            this.changingFeature_ = true;
            geometry.setRadius(Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_6__["distance"])(geometry.getCenter(), vertex));
            this.changingFeature_ = false;
          }
          break;
        default:
          // pass
      }

      if (coordinates) {
        this.setGeometryCoordinates_(geometry, coordinates);
      }
    }
    this.createOrUpdateVertexFeature_(vertex);
  };

  /**
   * @inheritDoc
   */
  Modify.prototype.handleDownEvent = function handleDownEvent (evt) {
    if (!this.condition_(evt)) {
      return false;
    }
    this.handlePointerAtPixel_(evt.pixel, evt.map);
    var pixelCoordinate = evt.map.getCoordinateFromPixel(evt.pixel);
    this.dragSegments_.length = 0;
    this.modified_ = false;
    var vertexFeature = this.vertexFeature_;
    if (vertexFeature) {
      var insertVertices = [];
      var geometry = /** @type {Point} */ (vertexFeature.getGeometry());
      var vertex = geometry.getCoordinates();
      var vertexExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_11__["boundingExtent"])([vertex]);
      var segmentDataMatches = this.rBush_.getInExtent(vertexExtent);
      var componentSegments = {};
      segmentDataMatches.sort(compareIndexes);
      for (var i = 0, ii = segmentDataMatches.length; i < ii; ++i) {
        var segmentDataMatch = segmentDataMatches[i];
        var segment = segmentDataMatch.segment;
        var uid = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(segmentDataMatch.feature);
        var depth = segmentDataMatch.depth;
        if (depth) {
          uid += '-' + depth.join('-'); // separate feature components
        }
        if (!componentSegments[uid]) {
          componentSegments[uid] = new Array(2);
        }
        if (segmentDataMatch.geometry.getType() === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].CIRCLE &&
        segmentDataMatch.index === CIRCLE_CIRCUMFERENCE_INDEX) {

          var closestVertex = closestOnSegmentData(pixelCoordinate, segmentDataMatch);
          if (Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_6__["equals"])(closestVertex, vertex) && !componentSegments[uid][0]) {
            this.dragSegments_.push([segmentDataMatch, 0]);
            componentSegments[uid][0] = segmentDataMatch;
          }
        } else if (Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_6__["equals"])(segment[0], vertex) &&
            !componentSegments[uid][0]) {
          this.dragSegments_.push([segmentDataMatch, 0]);
          componentSegments[uid][0] = segmentDataMatch;
        } else if (Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_6__["equals"])(segment[1], vertex) &&
            !componentSegments[uid][1]) {

          // prevent dragging closed linestrings by the connecting node
          if ((segmentDataMatch.geometry.getType() ===
              _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].LINE_STRING ||
              segmentDataMatch.geometry.getType() ===
              _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].MULTI_LINE_STRING) &&
              componentSegments[uid][0] &&
              componentSegments[uid][0].index === 0) {
            continue;
          }

          this.dragSegments_.push([segmentDataMatch, 1]);
          componentSegments[uid][1] = segmentDataMatch;
        } else if (this.insertVertexCondition_(evt) && Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(segment) in this.vertexSegments_ &&
            (!componentSegments[uid][0] && !componentSegments[uid][1])) {
          insertVertices.push([segmentDataMatch, vertex]);
        }
      }
      if (insertVertices.length) {
        this.willModifyFeatures_(evt);
      }
      for (var j = insertVertices.length - 1; j >= 0; --j) {
        this.insertVertex_.apply(this, insertVertices[j]);
      }
    }
    return !!this.vertexFeature_;
  };

  /**
   * @inheritDoc
   */
  Modify.prototype.handleUpEvent = function handleUpEvent (evt) {
    for (var i = this.dragSegments_.length - 1; i >= 0; --i) {
      var segmentData = this.dragSegments_[i][0];
      var geometry = segmentData.geometry;
      if (geometry.getType() === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].CIRCLE) {
        // Update a circle object in the R* bush:
        var coordinates = geometry.getCenter();
        var centerSegmentData = segmentData.featureSegments[0];
        var circumferenceSegmentData = segmentData.featureSegments[1];
        centerSegmentData.segment[0] = centerSegmentData.segment[1] = coordinates;
        circumferenceSegmentData.segment[0] = circumferenceSegmentData.segment[1] = coordinates;
        this.rBush_.update(Object(_extent_js__WEBPACK_IMPORTED_MODULE_11__["createOrUpdateFromCoordinate"])(coordinates), centerSegmentData);
        this.rBush_.update(geometry.getExtent(), circumferenceSegmentData);
      } else {
        this.rBush_.update(Object(_extent_js__WEBPACK_IMPORTED_MODULE_11__["boundingExtent"])(segmentData.segment), segmentData);
      }
    }
    if (this.modified_) {
      this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND, this.features_, evt));
      this.modified_ = false;
    }
    return false;
  };

  /**
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @private
   */
  Modify.prototype.handlePointerMove_ = function handlePointerMove_ (evt) {
    this.lastPixel_ = evt.pixel;
    this.handlePointerAtPixel_(evt.pixel, evt.map);
  };

  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel
   * @param {import("../PluggableMap.js").default} map Map.
   * @private
   */
  Modify.prototype.handlePointerAtPixel_ = function handlePointerAtPixel_ (pixel, map) {
    var pixelCoordinate = map.getCoordinateFromPixel(pixel);
    var sortByDistance = function(a, b) {
      return pointDistanceToSegmentDataSquared(pixelCoordinate, a) -
          pointDistanceToSegmentDataSquared(pixelCoordinate, b);
    };

    var box = Object(_extent_js__WEBPACK_IMPORTED_MODULE_11__["buffer"])(Object(_extent_js__WEBPACK_IMPORTED_MODULE_11__["createOrUpdateFromCoordinate"])(pixelCoordinate),
      map.getView().getResolution() * this.pixelTolerance_);

    var rBush = this.rBush_;
    var nodes = rBush.getInExtent(box);
    if (nodes.length > 0) {
      nodes.sort(sortByDistance);
      var node = nodes[0];
      var closestSegment = node.segment;
      var vertex = closestOnSegmentData(pixelCoordinate, node);
      var vertexPixel = map.getPixelFromCoordinate(vertex);
      var dist = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_6__["distance"])(pixel, vertexPixel);
      if (dist <= this.pixelTolerance_) {
        /** @type {Object<string, boolean>} */
        var vertexSegments = {};

        if (node.geometry.getType() === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].CIRCLE &&
        node.index === CIRCLE_CIRCUMFERENCE_INDEX) {

          this.snappedToVertex_ = true;
          this.createOrUpdateVertexFeature_(vertex);
        } else {
          var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
          var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
          var squaredDist1 = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_6__["squaredDistance"])(vertexPixel, pixel1);
          var squaredDist2 = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_6__["squaredDistance"])(vertexPixel, pixel2);
          dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
          this.snappedToVertex_ = dist <= this.pixelTolerance_;
          if (this.snappedToVertex_) {
            vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
          }
          this.createOrUpdateVertexFeature_(vertex);
          for (var i = 1, ii = nodes.length; i < ii; ++i) {
            var segment = nodes[i].segment;
            if ((Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_6__["equals"])(closestSegment[0], segment[0]) &&
                Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_6__["equals"])(closestSegment[1], segment[1]) ||
                (Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_6__["equals"])(closestSegment[0], segment[1]) &&
                Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_6__["equals"])(closestSegment[1], segment[0])))) {
              vertexSegments[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(segment)] = true;
            } else {
              break;
            }
          }
        }

        vertexSegments[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(closestSegment)] = true;
        this.vertexSegments_ = vertexSegments;
        return;
      }
    }
    if (this.vertexFeature_) {
      /** @type {VectorSource} */ (this.overlay_.getSource()).removeFeature(this.vertexFeature_);
      this.vertexFeature_ = null;
    }
  };

  /**
   * @param {SegmentData} segmentData Segment data.
   * @param {import("../coordinate.js").Coordinate} vertex Vertex.
   * @private
   */
  Modify.prototype.insertVertex_ = function insertVertex_ (segmentData, vertex) {
    var segment = segmentData.segment;
    var feature = segmentData.feature;
    var geometry = segmentData.geometry;
    var depth = segmentData.depth;
    var index = /** @type {number} */ (segmentData.index);
    var coordinates;

    while (vertex.length < geometry.getStride()) {
      vertex.push(0);
    }

    switch (geometry.getType()) {
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].MULTI_LINE_STRING:
        coordinates = geometry.getCoordinates();
        coordinates[depth[0]].splice(index + 1, 0, vertex);
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].POLYGON:
        coordinates = geometry.getCoordinates();
        coordinates[depth[0]].splice(index + 1, 0, vertex);
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].MULTI_POLYGON:
        coordinates = geometry.getCoordinates();
        coordinates[depth[1]][depth[0]].splice(index + 1, 0, vertex);
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].LINE_STRING:
        coordinates = geometry.getCoordinates();
        coordinates.splice(index + 1, 0, vertex);
        break;
      default:
        return;
    }

    this.setGeometryCoordinates_(geometry, coordinates);
    var rTree = this.rBush_;
    rTree.remove(segmentData);
    this.updateSegmentIndices_(geometry, index, depth, 1);
    var newSegmentData = /** @type {SegmentData} */ ({
      segment: [segment[0], vertex],
      feature: feature,
      geometry: geometry,
      depth: depth,
      index: index
    });
    rTree.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_11__["boundingExtent"])(newSegmentData.segment),
      newSegmentData);
    this.dragSegments_.push([newSegmentData, 1]);

    var newSegmentData2 = /** @type {SegmentData} */ ({
      segment: [vertex, segment[1]],
      feature: feature,
      geometry: geometry,
      depth: depth,
      index: index + 1
    });
    rTree.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_11__["boundingExtent"])(newSegmentData2.segment), newSegmentData2);
    this.dragSegments_.push([newSegmentData2, 0]);
    this.ignoreNextSingleClick_ = true;
  };

  /**
   * Removes the vertex currently being pointed.
   * @return {boolean} True when a vertex was removed.
   * @api
   */
  Modify.prototype.removePoint = function removePoint () {
    if (this.lastPointerEvent_ && this.lastPointerEvent_.type != _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].POINTERDRAG) {
      var evt = this.lastPointerEvent_;
      this.willModifyFeatures_(evt);
      this.removeVertex_();
      this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND, this.features_, evt));
      this.modified_ = false;
      return true;
    }
    return false;
  };

  /**
   * Removes a vertex from all matching features.
   * @return {boolean} True when a vertex was removed.
   * @private
   */
  Modify.prototype.removeVertex_ = function removeVertex_ () {
    var dragSegments = this.dragSegments_;
    var segmentsByFeature = {};
    var deleted = false;
    var component, coordinates, dragSegment, geometry, i, index, left;
    var newIndex, right, segmentData, uid;
    for (i = dragSegments.length - 1; i >= 0; --i) {
      dragSegment = dragSegments[i];
      segmentData = dragSegment[0];
      uid = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(segmentData.feature);
      if (segmentData.depth) {
        // separate feature components
        uid += '-' + segmentData.depth.join('-');
      }
      if (!(uid in segmentsByFeature)) {
        segmentsByFeature[uid] = {};
      }
      if (dragSegment[1] === 0) {
        segmentsByFeature[uid].right = segmentData;
        segmentsByFeature[uid].index = segmentData.index;
      } else if (dragSegment[1] == 1) {
        segmentsByFeature[uid].left = segmentData;
        segmentsByFeature[uid].index = segmentData.index + 1;
      }

    }
    for (uid in segmentsByFeature) {
      right = segmentsByFeature[uid].right;
      left = segmentsByFeature[uid].left;
      index = segmentsByFeature[uid].index;
      newIndex = index - 1;
      if (left !== undefined) {
        segmentData = left;
      } else {
        segmentData = right;
      }
      if (newIndex < 0) {
        newIndex = 0;
      }
      geometry = segmentData.geometry;
      coordinates = geometry.getCoordinates();
      component = coordinates;
      deleted = false;
      switch (geometry.getType()) {
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].MULTI_LINE_STRING:
          if (coordinates[segmentData.depth[0]].length > 2) {
            coordinates[segmentData.depth[0]].splice(index, 1);
            deleted = true;
          }
          break;
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].LINE_STRING:
          if (coordinates.length > 2) {
            coordinates.splice(index, 1);
            deleted = true;
          }
          break;
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].MULTI_POLYGON:
          component = component[segmentData.depth[1]];
          /* falls through */
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].POLYGON:
          component = component[segmentData.depth[0]];
          if (component.length > 4) {
            if (index == component.length - 1) {
              index = 0;
            }
            component.splice(index, 1);
            deleted = true;
            if (index === 0) {
              // close the ring again
              component.pop();
              component.push(component[0]);
              newIndex = component.length - 1;
            }
          }
          break;
        default:
          // pass
      }

      if (deleted) {
        this.setGeometryCoordinates_(geometry, coordinates);
        var segments = [];
        if (left !== undefined) {
          this.rBush_.remove(left);
          segments.push(left.segment[0]);
        }
        if (right !== undefined) {
          this.rBush_.remove(right);
          segments.push(right.segment[1]);
        }
        if (left !== undefined && right !== undefined) {
          var newSegmentData = /** @type {SegmentData} */ ({
            depth: segmentData.depth,
            feature: segmentData.feature,
            geometry: segmentData.geometry,
            index: newIndex,
            segment: segments
          });
          this.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_11__["boundingExtent"])(newSegmentData.segment),
            newSegmentData);
        }
        this.updateSegmentIndices_(geometry, index, segmentData.depth, -1);
        if (this.vertexFeature_) {
          /** @type {VectorSource} */ (this.overlay_.getSource()).removeFeature(this.vertexFeature_);
          this.vertexFeature_ = null;
        }
        dragSegments.length = 0;
      }

    }
    return deleted;
  };

  /**
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {Array} coordinates Coordinates.
   * @private
   */
  Modify.prototype.setGeometryCoordinates_ = function setGeometryCoordinates_ (geometry, coordinates) {
    this.changingFeature_ = true;
    geometry.setCoordinates(coordinates);
    this.changingFeature_ = false;
  };

  /**
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {number} index Index.
   * @param {Array<number>|undefined} depth Depth.
   * @param {number} delta Delta (1 or -1).
   * @private
   */
  Modify.prototype.updateSegmentIndices_ = function updateSegmentIndices_ (geometry, index, depth, delta) {
    this.rBush_.forEachInExtent(geometry.getExtent(), function(segmentDataMatch) {
      if (segmentDataMatch.geometry === geometry &&
          (depth === undefined || segmentDataMatch.depth === undefined ||
          Object(_array_js__WEBPACK_IMPORTED_MODULE_5__["equals"])(segmentDataMatch.depth, depth)) &&
          segmentDataMatch.index > index) {
        segmentDataMatch.index += delta;
      }
    });
  };

  return Modify;
}(_Pointer_js__WEBPACK_IMPORTED_MODULE_14__["default"]));


/**
 * @param {SegmentData} a The first segment data.
 * @param {SegmentData} b The second segment data.
 * @return {number} The difference in indexes.
 */
function compareIndexes(a, b) {
  return a.index - b.index;
}


/**
 * Returns the distance from a point to a line segment.
 *
 * @param {import("../coordinate.js").Coordinate} pointCoordinates The coordinates of the point from
 *        which to calculate the distance.
 * @param {SegmentData} segmentData The object describing the line
 *        segment we are calculating the distance to.
 * @return {number} The square of the distance between a point and a line segment.
 */
function pointDistanceToSegmentDataSquared(pointCoordinates, segmentData) {
  var geometry = segmentData.geometry;

  if (geometry.getType() === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].CIRCLE) {
    var circleGeometry = /** @type {import("../geom/Circle.js").default} */ (geometry);

    if (segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {
      var distanceToCenterSquared =
            Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_6__["squaredDistance"])(circleGeometry.getCenter(), pointCoordinates);
      var distanceToCircumference =
            Math.sqrt(distanceToCenterSquared) - circleGeometry.getRadius();
      return distanceToCircumference * distanceToCircumference;
    }
  }
  return Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_6__["squaredDistanceToSegment"])(pointCoordinates, segmentData.segment);
}

/**
 * Returns the point closest to a given line segment.
 *
 * @param {import("../coordinate.js").Coordinate} pointCoordinates The point to which a closest point
 *        should be found.
 * @param {SegmentData} segmentData The object describing the line
 *        segment which should contain the closest point.
 * @return {import("../coordinate.js").Coordinate} The point closest to the specified line segment.
 */
function closestOnSegmentData(pointCoordinates, segmentData) {
  var geometry = segmentData.geometry;

  if (geometry.getType() === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].CIRCLE &&
  segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {
    return geometry.getClosestPoint(pointCoordinates);
  }
  return Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_6__["closestOnSegment"])(pointCoordinates, segmentData.segment);
}


/**
 * @return {import("../style/Style.js").StyleFunction} Styles.
 */
function getDefaultStyleFunction() {
  var style = Object(_style_Style_js__WEBPACK_IMPORTED_MODULE_19__["createEditingStyle"])();
  return function(feature, resolution) {
    return style[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].POINT];
  };
}


/* harmony default export */ __webpack_exports__["default"] = (Modify);

//# sourceMappingURL=Modify.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/MouseWheelZoom.js":
/*!*******************************************************!*\
  !*** ./node_modules/ol/interaction/MouseWheelZoom.js ***!
  \*******************************************************/
/*! exports provided: Mode, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Mode", function() { return Mode; });
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ViewHint.js */ "./node_modules/ol/ViewHint.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../easing.js */ "./node_modules/ol/easing.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/interaction/MouseWheelZoom
 */









/**
 * Maximum mouse wheel delta.
 * @type {number}
 */
var MAX_DELTA = 1;


/**
 * @enum {string}
 */
var Mode = {
  TRACKPAD: 'trackpad',
  WHEEL: 'wheel'
};


/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. Default is
 * {@link module:ol/events/condition~always}.
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {number} [timeout=80] Mouse wheel timeout duration in milliseconds.
 * @property {boolean} [constrainResolution=false] When using a trackpad or
 * magic mouse, zoom to the closest integer zoom level after the scroll gesture
 * ends.
 * @property {boolean} [useAnchor=true] Enable zooming using the mouse's
 * location as the anchor. When set to `false`, zooming in and out will zoom to
 * the center of the screen instead of zooming on the mouse's location.
 */


/**
 * @classdesc
 * Allows the user to zoom the map by scrolling the mouse wheel.
 * @api
 */
var MouseWheelZoom = /*@__PURE__*/(function (Interaction) {
  function MouseWheelZoom(opt_options) {

    var options = opt_options ? opt_options : {};

    Interaction.call(/** @type {import("./Interaction.js").InteractionOptions} */ this, (options));

    /**
     * @private
     * @type {number}
     */
    this.delta_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 250;

    /**
     * @private
     * @type {number}
     */
    this.timeout_ = options.timeout !== undefined ? options.timeout : 80;

    /**
     * @private
     * @type {boolean}
     */
    this.useAnchor_ = options.useAnchor !== undefined ? options.useAnchor : true;

    /**
     * @private
     * @type {boolean}
     */
    this.constrainResolution_ = options.constrainResolution || false;

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_1__["always"];

    /**
     * @private
     * @type {?import("../coordinate.js").Coordinate}
     */
    this.lastAnchor_ = null;

    /**
     * @private
     * @type {number|undefined}
     */
    this.startTime_ = undefined;

    /**
     * @private
     * @type {?}
     */
    this.timeoutId_;

    /**
     * @private
     * @type {Mode|undefined}
     */
    this.mode_ = undefined;

    /**
     * Trackpad events separated by this delay will be considered separate
     * interactions.
     * @type {number}
     */
    this.trackpadEventGap_ = 400;

    /**
     * @type {?}
     */
    this.trackpadTimeoutId_;

    /**
     * The number of delta values per zoom level
     * @private
     * @type {number}
     */
    this.trackpadDeltaPerZoom_ = 300;

    /**
     * The zoom factor by which scroll zooming is allowed to exceed the limits.
     * @private
     * @type {number}
     */
    this.trackpadZoomBuffer_ = 1.5;

  }

  if ( Interaction ) MouseWheelZoom.__proto__ = Interaction;
  MouseWheelZoom.prototype = Object.create( Interaction && Interaction.prototype );
  MouseWheelZoom.prototype.constructor = MouseWheelZoom;

  /**
   * @private
   */
  MouseWheelZoom.prototype.decrementInteractingHint_ = function decrementInteractingHint_ () {
    this.trackpadTimeoutId_ = undefined;
    var view = this.getMap().getView();
    view.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_0__["default"].INTERACTING, -1);
  };

  /**
   * Handles the {@link module:ol/MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually
   * zooms the map.
   * @override
   */
  MouseWheelZoom.prototype.handleEvent = function handleEvent (mapBrowserEvent) {
    if (!this.condition_(mapBrowserEvent)) {
      return true;
    }
    var type = mapBrowserEvent.type;
    if (type !== _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].WHEEL && type !== _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].MOUSEWHEEL) {
      return true;
    }

    mapBrowserEvent.preventDefault();

    var map = mapBrowserEvent.map;
    var wheelEvent = /** @type {WheelEvent} */ (mapBrowserEvent.originalEvent);

    if (this.useAnchor_) {
      this.lastAnchor_ = mapBrowserEvent.coordinate;
    }

    // Delta normalisation inspired by
    // https://github.com/mapbox/mapbox-gl-js/blob/001c7b9/js/ui/handler/scroll_zoom.js
    var delta;
    if (mapBrowserEvent.type == _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].WHEEL) {
      delta = wheelEvent.deltaY;
      if (_has_js__WEBPACK_IMPORTED_MODULE_4__["FIREFOX"] &&
          wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {
        delta /= _has_js__WEBPACK_IMPORTED_MODULE_4__["DEVICE_PIXEL_RATIO"];
      }
      if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {
        delta *= 40;
      }
    } else if (mapBrowserEvent.type == _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].MOUSEWHEEL) {
      delta = -wheelEvent.wheelDeltaY;
      if (_has_js__WEBPACK_IMPORTED_MODULE_4__["SAFARI"]) {
        delta /= 3;
      }
    }

    if (delta === 0) {
      return false;
    }

    var now = Date.now();

    if (this.startTime_ === undefined) {
      this.startTime_ = now;
    }

    if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {
      this.mode_ = Math.abs(delta) < 4 ?
        Mode.TRACKPAD :
        Mode.WHEEL;
    }

    if (this.mode_ === Mode.TRACKPAD) {
      var view = map.getView();
      if (this.trackpadTimeoutId_) {
        clearTimeout(this.trackpadTimeoutId_);
      } else {
        view.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_0__["default"].INTERACTING, 1);
      }
      this.trackpadTimeoutId_ = setTimeout(this.decrementInteractingHint_.bind(this), this.trackpadEventGap_);
      var resolution = view.getResolution() * Math.pow(2, delta / this.trackpadDeltaPerZoom_);
      var minResolution = view.getMinResolution();
      var maxResolution = view.getMaxResolution();
      var rebound = 0;
      if (resolution < minResolution) {
        resolution = Math.max(resolution, minResolution / this.trackpadZoomBuffer_);
        rebound = 1;
      } else if (resolution > maxResolution) {
        resolution = Math.min(resolution, maxResolution * this.trackpadZoomBuffer_);
        rebound = -1;
      }
      if (this.lastAnchor_) {
        var center = view.calculateCenterZoom(resolution, this.lastAnchor_);
        view.setCenter(view.constrainCenter(center));
      }
      view.setResolution(resolution);

      if (rebound === 0 && this.constrainResolution_) {
        view.animate({
          resolution: view.constrainResolution(resolution, delta > 0 ? -1 : 1),
          easing: _easing_js__WEBPACK_IMPORTED_MODULE_2__["easeOut"],
          anchor: this.lastAnchor_,
          duration: this.duration_
        });
      }

      if (rebound > 0) {
        view.animate({
          resolution: minResolution,
          easing: _easing_js__WEBPACK_IMPORTED_MODULE_2__["easeOut"],
          anchor: this.lastAnchor_,
          duration: 500
        });
      } else if (rebound < 0) {
        view.animate({
          resolution: maxResolution,
          easing: _easing_js__WEBPACK_IMPORTED_MODULE_2__["easeOut"],
          anchor: this.lastAnchor_,
          duration: 500
        });
      }
      this.startTime_ = now;
      return false;
    }

    this.delta_ += delta;

    var timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);

    clearTimeout(this.timeoutId_);
    this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, map), timeLeft);

    return false;
  };

  /**
   * @private
   * @param {import("../PluggableMap.js").default} map Map.
   */
  MouseWheelZoom.prototype.handleWheelZoom_ = function handleWheelZoom_ (map) {
    var view = map.getView();
    if (view.getAnimating()) {
      view.cancelAnimations();
    }
    var maxDelta = MAX_DELTA;
    var delta = Object(_math_js__WEBPACK_IMPORTED_MODULE_6__["clamp"])(this.delta_, -maxDelta, maxDelta);
    Object(_Interaction_js__WEBPACK_IMPORTED_MODULE_5__["zoomByDelta"])(view, -delta, this.lastAnchor_, this.duration_);
    this.mode_ = undefined;
    this.delta_ = 0;
    this.lastAnchor_ = null;
    this.startTime_ = undefined;
    this.timeoutId_ = undefined;
  };

  /**
   * Enable or disable using the mouse's location as an anchor when zooming
   * @param {boolean} useAnchor true to zoom to the mouse's location, false
   * to zoom to the center of the map
   * @api
   */
  MouseWheelZoom.prototype.setMouseAnchor = function setMouseAnchor (useAnchor) {
    this.useAnchor_ = useAnchor;
    if (!useAnchor) {
      this.lastAnchor_ = null;
    }
  };

  return MouseWheelZoom;
}(_Interaction_js__WEBPACK_IMPORTED_MODULE_5__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (MouseWheelZoom);

//# sourceMappingURL=MouseWheelZoom.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/PinchRotate.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/interaction/PinchRotate.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ViewHint.js */ "./node_modules/ol/ViewHint.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/* harmony import */ var _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../rotationconstraint.js */ "./node_modules/ol/rotationconstraint.js");
/**
 * @module ol/interaction/PinchRotate
 */







/**
 * @typedef {Object} Options
 * @property {number} [duration=250] The duration of the animation in
 * milliseconds.
 * @property {number} [threshold=0.3] Minimal angle in radians to start a rotation.
 */


/**
 * @classdesc
 * Allows the user to rotate the map by twisting with two fingers
 * on a touch screen.
 * @api
 */
var PinchRotate = /*@__PURE__*/(function (PointerInteraction) {
  function PinchRotate(opt_options) {

    var options = opt_options ? opt_options : {};

    var pointerOptions = /** @type {import("./Pointer.js").Options} */ (options);

    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = _functions_js__WEBPACK_IMPORTED_MODULE_1__["FALSE"];
    }

    PointerInteraction.call(this, pointerOptions);

    /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */
    this.anchor_ = null;

    /**
     * @private
     * @type {number|undefined}
     */
    this.lastAngle_ = undefined;

    /**
     * @private
     * @type {boolean}
     */
    this.rotating_ = false;

    /**
     * @private
     * @type {number}
     */
    this.rotationDelta_ = 0.0;

    /**
     * @private
     * @type {number}
     */
    this.threshold_ = options.threshold !== undefined ? options.threshold : 0.3;

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 250;

  }

  if ( PointerInteraction ) PinchRotate.__proto__ = PointerInteraction;
  PinchRotate.prototype = Object.create( PointerInteraction && PointerInteraction.prototype );
  PinchRotate.prototype.constructor = PinchRotate;

  /**
   * @inheritDoc
   */
  PinchRotate.prototype.handleDragEvent = function handleDragEvent (mapBrowserEvent) {
    var rotationDelta = 0.0;

    var touch0 = this.targetPointers[0];
    var touch1 = this.targetPointers[1];

    // angle between touches
    var angle = Math.atan2(
      touch1.clientY - touch0.clientY,
      touch1.clientX - touch0.clientX);

    if (this.lastAngle_ !== undefined) {
      var delta = angle - this.lastAngle_;
      this.rotationDelta_ += delta;
      if (!this.rotating_ &&
          Math.abs(this.rotationDelta_) > this.threshold_) {
        this.rotating_ = true;
      }
      rotationDelta = delta;
    }
    this.lastAngle_ = angle;

    var map = mapBrowserEvent.map;
    var view = map.getView();
    if (view.getConstraints().rotation === _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_4__["disable"]) {
      return;
    }

    // rotate anchor point.
    // FIXME: should be the intersection point between the lines:
    //     touch0,touch1 and previousTouch0,previousTouch1
    var viewportPosition = map.getViewport().getBoundingClientRect();
    var centroid = Object(_Pointer_js__WEBPACK_IMPORTED_MODULE_3__["centroid"])(this.targetPointers);
    centroid[0] -= viewportPosition.left;
    centroid[1] -= viewportPosition.top;
    this.anchor_ = map.getCoordinateFromPixel(centroid);

    // rotate
    if (this.rotating_) {
      var rotation = view.getRotation();
      map.render();
      Object(_Interaction_js__WEBPACK_IMPORTED_MODULE_2__["rotateWithoutConstraints"])(view, rotation + rotationDelta, this.anchor_);
    }
  };

  /**
   * @inheritDoc
   */
  PinchRotate.prototype.handleUpEvent = function handleUpEvent (mapBrowserEvent) {
    if (this.targetPointers.length < 2) {
      var map = mapBrowserEvent.map;
      var view = map.getView();
      view.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_0__["default"].INTERACTING, -1);
      if (this.rotating_) {
        var rotation = view.getRotation();
        Object(_Interaction_js__WEBPACK_IMPORTED_MODULE_2__["rotate"])(view, rotation, this.anchor_, this.duration_);
      }
      return false;
    } else {
      return true;
    }
  };

  /**
   * @inheritDoc
   */
  PinchRotate.prototype.handleDownEvent = function handleDownEvent (mapBrowserEvent) {
    if (this.targetPointers.length >= 2) {
      var map = mapBrowserEvent.map;
      this.anchor_ = null;
      this.lastAngle_ = undefined;
      this.rotating_ = false;
      this.rotationDelta_ = 0.0;
      if (!this.handlingDownUpSequence) {
        map.getView().setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_0__["default"].INTERACTING, 1);
      }
      return true;
    } else {
      return false;
    }
  };

  return PinchRotate;
}(_Pointer_js__WEBPACK_IMPORTED_MODULE_3__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (PinchRotate);

//# sourceMappingURL=PinchRotate.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/PinchZoom.js":
/*!**************************************************!*\
  !*** ./node_modules/ol/interaction/PinchZoom.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ViewHint.js */ "./node_modules/ol/ViewHint.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/**
 * @module ol/interaction/PinchZoom
 */






/**
 * @typedef {Object} Options
 * @property {number} [duration=400] Animation duration in milliseconds.
 * @property {boolean} [constrainResolution=false] Zoom to the closest integer
 * zoom level after the pinch gesture ends.
 */


/**
 * @classdesc
 * Allows the user to zoom the map by pinching with two fingers
 * on a touch screen.
 * @api
 */
var PinchZoom = /*@__PURE__*/(function (PointerInteraction) {
  function PinchZoom(opt_options) {

    var options = opt_options ? opt_options : {};

    var pointerOptions = /** @type {import("./Pointer.js").Options} */ (options);

    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = _functions_js__WEBPACK_IMPORTED_MODULE_1__["FALSE"];
    }

    PointerInteraction.call(this, pointerOptions);

    /**
     * @private
     * @type {boolean}
     */
    this.constrainResolution_ = options.constrainResolution || false;

    /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */
    this.anchor_ = null;

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 400;

    /**
     * @private
     * @type {number|undefined}
     */
    this.lastDistance_ = undefined;

    /**
     * @private
     * @type {number}
     */
    this.lastScaleDelta_ = 1;

  }

  if ( PointerInteraction ) PinchZoom.__proto__ = PointerInteraction;
  PinchZoom.prototype = Object.create( PointerInteraction && PointerInteraction.prototype );
  PinchZoom.prototype.constructor = PinchZoom;

  /**
   * @inheritDoc
   */
  PinchZoom.prototype.handleDragEvent = function handleDragEvent (mapBrowserEvent) {
    var scaleDelta = 1.0;

    var touch0 = this.targetPointers[0];
    var touch1 = this.targetPointers[1];
    var dx = touch0.clientX - touch1.clientX;
    var dy = touch0.clientY - touch1.clientY;

    // distance between touches
    var distance = Math.sqrt(dx * dx + dy * dy);

    if (this.lastDistance_ !== undefined) {
      scaleDelta = this.lastDistance_ / distance;
    }
    this.lastDistance_ = distance;


    var map = mapBrowserEvent.map;
    var view = map.getView();
    var resolution = view.getResolution();
    var maxResolution = view.getMaxResolution();
    var minResolution = view.getMinResolution();
    var newResolution = resolution * scaleDelta;
    if (newResolution > maxResolution) {
      scaleDelta = maxResolution / resolution;
      newResolution = maxResolution;
    } else if (newResolution < minResolution) {
      scaleDelta = minResolution / resolution;
      newResolution = minResolution;
    }

    if (scaleDelta != 1.0) {
      this.lastScaleDelta_ = scaleDelta;
    }

    // scale anchor point.
    var viewportPosition = map.getViewport().getBoundingClientRect();
    var centroid = Object(_Pointer_js__WEBPACK_IMPORTED_MODULE_3__["centroid"])(this.targetPointers);
    centroid[0] -= viewportPosition.left;
    centroid[1] -= viewportPosition.top;
    this.anchor_ = map.getCoordinateFromPixel(centroid);

    // scale, bypass the resolution constraint
    map.render();
    Object(_Interaction_js__WEBPACK_IMPORTED_MODULE_2__["zoomWithoutConstraints"])(view, newResolution, this.anchor_);
  };

  /**
   * @inheritDoc
   */
  PinchZoom.prototype.handleUpEvent = function handleUpEvent (mapBrowserEvent) {
    if (this.targetPointers.length < 2) {
      var map = mapBrowserEvent.map;
      var view = map.getView();
      view.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_0__["default"].INTERACTING, -1);
      var resolution = view.getResolution();
      if (this.constrainResolution_ ||
          resolution < view.getMinResolution() ||
          resolution > view.getMaxResolution()) {
        // Zoom to final resolution, with an animation, and provide a
        // direction not to zoom out/in if user was pinching in/out.
        // Direction is > 0 if pinching out, and < 0 if pinching in.
        var direction = this.lastScaleDelta_ - 1;
        Object(_Interaction_js__WEBPACK_IMPORTED_MODULE_2__["zoom"])(view, resolution, this.anchor_, this.duration_, direction);
      }
      return false;
    } else {
      return true;
    }
  };

  /**
   * @inheritDoc
   */
  PinchZoom.prototype.handleDownEvent = function handleDownEvent (mapBrowserEvent) {
    if (this.targetPointers.length >= 2) {
      var map = mapBrowserEvent.map;
      this.anchor_ = null;
      this.lastDistance_ = undefined;
      this.lastScaleDelta_ = 1;
      if (!this.handlingDownUpSequence) {
        map.getView().setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_0__["default"].INTERACTING, 1);
      }
      return true;
    } else {
      return false;
    }
  };

  return PinchZoom;
}(_Pointer_js__WEBPACK_IMPORTED_MODULE_3__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (PinchZoom);

//# sourceMappingURL=PinchZoom.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/Pointer.js":
/*!************************************************!*\
  !*** ./node_modules/ol/interaction/Pointer.js ***!
  \************************************************/
/*! exports provided: centroid, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "centroid", function() { return centroid; });
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MapBrowserEventType.js */ "./node_modules/ol/MapBrowserEventType.js");
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/interaction/Pointer
 */





/**
 * @typedef {Object} Options
 * @property {function(import("../MapBrowserPointerEvent.js").default):boolean} [handleDownEvent]
 * Function handling "down" events. If the function returns `true` then a drag
 * sequence is started.
 * @property {function(import("../MapBrowserPointerEvent.js").default)} [handleDragEvent]
 * Function handling "drag" events. This function is called on "move" events
 * during a drag sequence.
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleEvent]
 * Method called by the map to notify the interaction that a browser event was
 * dispatched to the map. The function may return `false` to prevent the
 * propagation of the event to other interactions in the map's interactions
 * chain.
 * @property {function(import("../MapBrowserPointerEvent.js").default)} [handleMoveEvent]
 * Function handling "move" events. This function is called on "move" events,
 * also during a drag sequence (so during a drag sequence both the
 * `handleDragEvent` function and this function are called).
 * @property {function(import("../MapBrowserPointerEvent.js").default):boolean} [handleUpEvent]
 *  Function handling "up" events. If the function returns `false` then the
 * current drag sequence is stopped.
 * @property {function(boolean):boolean} [stopDown]
 * Should the down event be propagated to other interactions, or should be
 * stopped?
 */


/**
 * @classdesc
 * Base class that calls user-defined functions on `down`, `move` and `up`
 * events. This class also manages "drag sequences".
 *
 * When the `handleDownEvent` user function returns `true` a drag sequence is
 * started. During a drag sequence the `handleDragEvent` user function is
 * called on `move` events. The drag sequence ends when the `handleUpEvent`
 * user function is called and returns `false`.
 * @api
 */
var PointerInteraction = /*@__PURE__*/(function (Interaction) {
  function PointerInteraction(opt_options) {

    var options = opt_options ? opt_options : {};

    Interaction.call(/** @type {import("./Interaction.js").InteractionOptions} */ this, (options));

    if (options.handleDownEvent) {
      this.handleDownEvent = options.handleDownEvent;
    }

    if (options.handleDragEvent) {
      this.handleDragEvent = options.handleDragEvent;
    }

    if (options.handleMoveEvent) {
      this.handleMoveEvent = options.handleMoveEvent;
    }

    if (options.handleUpEvent) {
      this.handleUpEvent = options.handleUpEvent;
    }

    if (options.stopDown) {
      this.stopDown = options.stopDown;
    }

    /**
     * @type {boolean}
     * @protected
     */
    this.handlingDownUpSequence = false;

    /**
     * @type {!Object<string, import("../pointer/PointerEvent.js").default>}
     * @private
     */
    this.trackedPointers_ = {};

    /**
     * @type {Array<import("../pointer/PointerEvent.js").default>}
     * @protected
     */
    this.targetPointers = [];

  }

  if ( Interaction ) PointerInteraction.__proto__ = Interaction;
  PointerInteraction.prototype = Object.create( Interaction && Interaction.prototype );
  PointerInteraction.prototype.constructor = PointerInteraction;

  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserPointerEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */
  PointerInteraction.prototype.handleDownEvent = function handleDownEvent (mapBrowserEvent) {
    return false;
  };

  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserPointerEvent.js").default} mapBrowserEvent Event.
   * @protected
   */
  PointerInteraction.prototype.handleDragEvent = function handleDragEvent (mapBrowserEvent) {};

  /**
   * Handles the {@link module:ol/MapBrowserEvent map browser event} and may call into
   * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
   * detected.
   * @override
   * @api
   */
  PointerInteraction.prototype.handleEvent = function handleEvent (mapBrowserEvent) {
    if (!(/** @type {import("../MapBrowserPointerEvent.js").default} */ (mapBrowserEvent).pointerEvent)) {
      return true;
    }

    var stopEvent = false;
    this.updateTrackedPointers_(mapBrowserEvent);
    if (this.handlingDownUpSequence) {
      if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].POINTERDRAG) {
        this.handleDragEvent(mapBrowserEvent);
      } else if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].POINTERUP) {
        var handledUp = this.handleUpEvent(mapBrowserEvent);
        this.handlingDownUpSequence = handledUp && this.targetPointers.length > 0;
      }
    } else {
      if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].POINTERDOWN) {
        var handled = this.handleDownEvent(mapBrowserEvent);
        if (handled) {
          mapBrowserEvent.preventDefault();
        }
        this.handlingDownUpSequence = handled;
        stopEvent = this.stopDown(handled);
      } else if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].POINTERMOVE) {
        this.handleMoveEvent(mapBrowserEvent);
      }
    }
    return !stopEvent;
  };

  /**
   * Handle pointer move events.
   * @param {import("../MapBrowserPointerEvent.js").default} mapBrowserEvent Event.
   * @protected
   */
  PointerInteraction.prototype.handleMoveEvent = function handleMoveEvent (mapBrowserEvent) {};

  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserPointerEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */
  PointerInteraction.prototype.handleUpEvent = function handleUpEvent (mapBrowserEvent) {
    return false;
  };

  /**
   * This function is used to determine if "down" events should be propagated
   * to other interactions or should be stopped.
   * @param {boolean} handled Was the event handled by the interaction?
   * @return {boolean} Should the `down` event be stopped?
   */
  PointerInteraction.prototype.stopDown = function stopDown (handled) {
    return handled;
  };

  /**
   * @param {import("../MapBrowserPointerEvent.js").default} mapBrowserEvent Event.
   * @private
   */
  PointerInteraction.prototype.updateTrackedPointers_ = function updateTrackedPointers_ (mapBrowserEvent) {
    if (isPointerDraggingEvent(mapBrowserEvent)) {
      var event = mapBrowserEvent.pointerEvent;

      var id = event.pointerId.toString();
      if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].POINTERUP) {
        delete this.trackedPointers_[id];
      } else if (mapBrowserEvent.type ==
          _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].POINTERDOWN) {
        this.trackedPointers_[id] = event;
      } else if (id in this.trackedPointers_) {
        // update only when there was a pointerdown event for this pointer
        this.trackedPointers_[id] = event;
      }
      this.targetPointers = Object(_obj_js__WEBPACK_IMPORTED_MODULE_2__["getValues"])(this.trackedPointers_);
    }
  };

  return PointerInteraction;
}(_Interaction_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/**
 * @param {Array<import("../pointer/PointerEvent.js").default>} pointerEvents List of events.
 * @return {import("../pixel.js").Pixel} Centroid pixel.
 */
function centroid(pointerEvents) {
  var length = pointerEvents.length;
  var clientX = 0;
  var clientY = 0;
  for (var i = 0; i < length; i++) {
    clientX += pointerEvents[i].clientX;
    clientY += pointerEvents[i].clientY;
  }
  return [clientX / length, clientY / length];
}


/**
 * @param {import("../MapBrowserPointerEvent.js").default} mapBrowserEvent Event.
 * @return {boolean} Whether the event is a pointerdown, pointerdrag
 *     or pointerup event.
 */
function isPointerDraggingEvent(mapBrowserEvent) {
  var type = mapBrowserEvent.type;
  return type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].POINTERDOWN ||
    type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].POINTERDRAG ||
    type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].POINTERUP;
}


/* harmony default export */ __webpack_exports__["default"] = (PointerInteraction);

//# sourceMappingURL=Pointer.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/Property.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/interaction/Property.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/interaction/Property
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  ACTIVE: 'active'
});

//# sourceMappingURL=Property.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/Select.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/interaction/Select.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../CollectionEventType.js */ "./node_modules/ol/CollectionEventType.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/* harmony import */ var _layer_Vector_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../layer/Vector.js */ "./node_modules/ol/layer/Vector.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _source_Vector_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../source/Vector.js */ "./node_modules/ol/source/Vector.js");
/* harmony import */ var _style_Style_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../style/Style.js */ "./node_modules/ol/style/Style.js");
/**
 * @module ol/interaction/Select
 */















/**
 * @enum {string}
 */
var SelectEventType = {
  /**
   * Triggered when feature(s) has been (de)selected.
   * @event SelectEvent#select
   * @api
   */
  SELECT: 'select'
};


/**
 * A function that takes an {@link module:ol/Feature} or
 * {@link module:ol/render/Feature} and an
 * {@link module:ol/layer/Layer} and returns `true` if the feature may be
 * selected or `false` otherwise.
 * @typedef {function(import("../Feature.js").FeatureLike, import("../layer/Layer.js").default):boolean} FilterFunction
 */


/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [addCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * By default, this is {@link module:ol/events/condition~never}. Use this if you
 * want to use different events for add and remove instead of `toggle`.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. This is the event
 * for the selected features as a whole. By default, this is
 * {@link module:ol/events/condition~singleClick}. Clicking on a feature selects that
 * feature and removes any that were in the selection. Clicking outside any
 * feature removes all from the selection.
 * See `toggle`, `add`, `remove` options for adding/removing extra features to/
 * from the selection.
 * @property {Array<import("../layer/Layer.js").default>|function(import("../layer/Layer.js").default): boolean} [layers]
 * A list of layers from which features should be selected. Alternatively, a
 * filter function can be provided. The function will be called for each layer
 * in the map and should return `true` for layers that you want to be
 * selectable. If the option is absent, all visible layers will be considered
 * selectable.
 * @property {import("../style/Style.js").StyleLike} [style]
 * Style for the selected features. By default the default edit style is used
 * (see {@link module:ol/style}).
 * @property {import("../events/condition.js").Condition} [removeCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * By default, this is {@link module:ol/events/condition~never}. Use this if you
 * want to use different events for add and remove instead of `toggle`.
 * @property {import("../events/condition.js").Condition} [toggleCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. This is in addition
 * to the `condition` event. By default,
 * {@link module:ol/events/condition~shiftKeyOnly}, i.e. pressing `shift` as
 * well as the `condition` event, adds that feature to the current selection if
 * it is not currently selected, and removes it if it is. See `add` and `remove`
 * if you want to use different events instead of a toggle.
 * @property {boolean} [multi=false] A boolean that determines if the default
 * behaviour should select only single features or all (overlapping) features at
 * the clicked map position. The default of `false` means single select.
 * @property {import("../Collection.js").default<import("../Feature.js").default>} [features]
 * Collection where the interaction will place selected features. Optional. If
 * not set the interaction will create a collection. In any case the collection
 * used by the interaction is returned by
 * {@link module:ol/interaction/Select~Select#getFeatures}.
 * @property {FilterFunction} [filter] A function
 * that takes an {@link module:ol/Feature} and an
 * {@link module:ol/layer/Layer} and returns `true` if the feature may be
 * selected or `false` otherwise.
 * @property {boolean} [wrapX=true] Wrap the world horizontally on the selection
 * overlay.
 * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside
 * the radius around the given position will be checked for features. This only
 * works for the canvas renderer and not for WebGL.
 */


/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Select~Select} instances are instances of
 * this type.
 */
var SelectEvent = /*@__PURE__*/(function (Event) {
  function SelectEvent(type, selected, deselected, mapBrowserEvent) {
    Event.call(this, type);

    /**
     * Selected features array.
     * @type {Array<import("../Feature.js").default>}
     * @api
     */
    this.selected = selected;

    /**
     * Deselected features array.
     * @type {Array<import("../Feature.js").default>}
     * @api
     */
    this.deselected = deselected;

    /**
     * Associated {@link module:ol/MapBrowserEvent}.
     * @type {import("../MapBrowserEvent.js").default}
     * @api
     */
    this.mapBrowserEvent = mapBrowserEvent;

  }

  if ( Event ) SelectEvent.__proto__ = Event;
  SelectEvent.prototype = Object.create( Event && Event.prototype );
  SelectEvent.prototype.constructor = SelectEvent;

  return SelectEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_4__["default"]));


/**
 * @classdesc
 * Interaction for selecting vector features. By default, selected features are
 * styled differently, so this interaction can be used for visual highlighting,
 * as well as selecting features for other actions, such as modification or
 * output. There are three ways of controlling which features are selected:
 * using the browser event as defined by the `condition` and optionally the
 * `toggle`, `add`/`remove`, and `multi` options; a `layers` filter; and a
 * further feature filter using the `filter` option.
 *
 * Selected features are added to an internal unmanaged layer.
 *
 * @fires SelectEvent
 * @api
 */
var Select = /*@__PURE__*/(function (Interaction) {
  function Select(opt_options) {

    Interaction.call(this, {
      handleEvent: handleEvent
    });

    var options = opt_options ? opt_options : {};

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_5__["singleClick"];

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.addCondition_ = options.addCondition ? options.addCondition : _events_condition_js__WEBPACK_IMPORTED_MODULE_5__["never"];

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.removeCondition_ = options.removeCondition ? options.removeCondition : _events_condition_js__WEBPACK_IMPORTED_MODULE_5__["never"];

    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */
    this.toggleCondition_ = options.toggleCondition ? options.toggleCondition : _events_condition_js__WEBPACK_IMPORTED_MODULE_5__["shiftKeyOnly"];

    /**
     * @private
     * @type {boolean}
     */
    this.multi_ = options.multi ? options.multi : false;

    /**
     * @private
     * @type {FilterFunction}
     */
    this.filter_ = options.filter ? options.filter : _functions_js__WEBPACK_IMPORTED_MODULE_6__["TRUE"];

    /**
     * @private
     * @type {number}
     */
    this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;

    var featureOverlay = new _layer_Vector_js__WEBPACK_IMPORTED_MODULE_9__["default"]({
      source: new _source_Vector_js__WEBPACK_IMPORTED_MODULE_11__["default"]({
        useSpatialIndex: false,
        features: options.features,
        wrapX: options.wrapX
      }),
      style: options.style ? options.style :
        getDefaultStyleFunction(),
      updateWhileAnimating: true,
      updateWhileInteracting: true
    });

    /**
     * @private
     * @type {VectorLayer}
     */
    this.featureOverlay_ = featureOverlay;

    /** @type {function(import("../layer/Layer.js").default): boolean} */
    var layerFilter;
    if (options.layers) {
      if (typeof options.layers === 'function') {
        layerFilter = options.layers;
      } else {
        var layers = options.layers;
        layerFilter = function(layer) {
          return Object(_array_js__WEBPACK_IMPORTED_MODULE_2__["includes"])(layers, layer);
        };
      }
    } else {
      layerFilter = _functions_js__WEBPACK_IMPORTED_MODULE_6__["TRUE"];
    }

    /**
     * @private
     * @type {function(import("../layer/Layer.js").default): boolean}
     */
    this.layerFilter_ = layerFilter;

    /**
     * An association between selected feature (key)
     * and layer (value)
     * @private
     * @type {Object<string, import("../layer/Layer.js").default>}
     */
    this.featureLayerAssociation_ = {};

    var features = this.getFeatures();
    Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(features, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].ADD,
      this.addFeature_, this);
    Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(features, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].REMOVE,
      this.removeFeature_, this);
  }

  if ( Interaction ) Select.__proto__ = Interaction;
  Select.prototype = Object.create( Interaction && Interaction.prototype );
  Select.prototype.constructor = Select;

  /**
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {import("../layer/Layer.js").default} layer Layer.
   * @private
   */
  Select.prototype.addFeatureLayerAssociation_ = function addFeatureLayerAssociation_ (feature, layer) {
    this.featureLayerAssociation_[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature)] = layer;
  };

  /**
   * Get the selected features.
   * @return {import("../Collection.js").default<import("../Feature.js").default>} Features collection.
   * @api
   */
  Select.prototype.getFeatures = function getFeatures () {
    return /** @type {VectorSource} */ (this.featureOverlay_.getSource()).getFeaturesCollection();
  };

  /**
   * Returns the Hit-detection tolerance.
   * @returns {number} Hit tolerance in pixels.
   * @api
   */
  Select.prototype.getHitTolerance = function getHitTolerance () {
    return this.hitTolerance_;
  };

  /**
   * Returns the associated {@link module:ol/layer/Vector~Vector vectorlayer} of
   * the (last) selected feature. Note that this will not work with any
   * programmatic method like pushing features to
   * {@link module:ol/interaction/Select~Select#getFeatures collection}.
   * @param {import("../Feature.js").FeatureLike} feature Feature
   * @return {VectorLayer} Layer.
   * @api
   */
  Select.prototype.getLayer = function getLayer (feature) {
    return (
      /** @type {VectorLayer} */ (this.featureLayerAssociation_[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature)])
    );
  };

  /**
   * Get the overlay layer that this interaction renders selected features to.
   * @return {VectorLayer} Overlay layer.
   * @api
   */
  Select.prototype.getOverlay = function getOverlay () {
    return this.featureOverlay_;
  };

  /**
   * Hit-detection tolerance. Pixels inside the radius around the given position
   * will be checked for features. This only works for the canvas renderer and
   * not for WebGL.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @api
   */
  Select.prototype.setHitTolerance = function setHitTolerance (hitTolerance) {
    this.hitTolerance_ = hitTolerance;
  };

  /**
   * Remove the interaction from its current map, if any,  and attach it to a new
   * map, if any. Pass `null` to just remove the interaction from the current map.
   * @param {import("../PluggableMap.js").default} map Map.
   * @override
   * @api
   */
  Select.prototype.setMap = function setMap (map) {
    var currentMap = this.getMap();
    var selectedFeatures = this.getFeatures();
    if (currentMap) {
      selectedFeatures.forEach(currentMap.unskipFeature.bind(currentMap));
    }
    Interaction.prototype.setMap.call(this, map);
    this.featureOverlay_.setMap(map);
    if (map) {
      selectedFeatures.forEach(map.skipFeature.bind(map));
    }
  };

  /**
   * @param {import("../Collection.js").CollectionEvent} evt Event.
   * @private
   */
  Select.prototype.addFeature_ = function addFeature_ (evt) {
    var map = this.getMap();
    if (map) {
      map.skipFeature(/** @type {import("../Feature.js").default} */ (evt.element));
    }
  };

  /**
   * @param {import("../Collection.js").CollectionEvent} evt Event.
   * @private
   */
  Select.prototype.removeFeature_ = function removeFeature_ (evt) {
    var map = this.getMap();
    if (map) {
      map.unskipFeature(/** @type {import("../Feature.js").default} */ (evt.element));
    }
  };

  /**
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @private
   */
  Select.prototype.removeFeatureLayerAssociation_ = function removeFeatureLayerAssociation_ (feature) {
    delete this.featureLayerAssociation_[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature)];
  };

  return Select;
}(_Interaction_js__WEBPACK_IMPORTED_MODULE_8__["default"]));


/**
 * Handles the {@link module:ol/MapBrowserEvent map browser event} and may change the
 * selected state of features.
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} `false` to stop event propagation.
 * @this {Select}
 */
function handleEvent(mapBrowserEvent) {
  if (!this.condition_(mapBrowserEvent)) {
    return true;
  }
  var add = this.addCondition_(mapBrowserEvent);
  var remove = this.removeCondition_(mapBrowserEvent);
  var toggle = this.toggleCondition_(mapBrowserEvent);
  var set = !add && !remove && !toggle;
  var map = mapBrowserEvent.map;
  var features = this.getFeatures();
  var deselected = [];
  var selected = [];
  if (set) {
    // Replace the currently selected feature(s) with the feature(s) at the
    // pixel, or clear the selected feature(s) if there is no feature at
    // the pixel.
    Object(_obj_js__WEBPACK_IMPORTED_MODULE_10__["clear"])(this.featureLayerAssociation_);
    map.forEachFeatureAtPixel(mapBrowserEvent.pixel,
      (
        /**
         * @param {import("../Feature.js").FeatureLike} feature Feature.
         * @param {import("../layer/Layer.js").default} layer Layer.
         * @return {boolean|undefined} Continue to iterate over the features.
         */
        function(feature, layer) {
          if (this.filter_(feature, layer)) {
            selected.push(feature);
            this.addFeatureLayerAssociation_(feature, layer);
            return !this.multi_;
          }
        }).bind(this), {
        layerFilter: this.layerFilter_,
        hitTolerance: this.hitTolerance_
      });
    for (var i = features.getLength() - 1; i >= 0; --i) {
      var feature = features.item(i);
      var index = selected.indexOf(feature);
      if (index > -1) {
        // feature is already selected
        selected.splice(index, 1);
      } else {
        features.remove(feature);
        deselected.push(feature);
      }
    }
    if (selected.length !== 0) {
      features.extend(selected);
    }
  } else {
    // Modify the currently selected feature(s).
    map.forEachFeatureAtPixel(mapBrowserEvent.pixel,
      (
        /**
         * @param {import("../Feature.js").FeatureLike} feature Feature.
         * @param {import("../layer/Layer.js").default} layer Layer.
         * @return {boolean|undefined} Continue to iterate over the features.
         */
        function(feature, layer) {
          if (this.filter_(feature, layer)) {
            if ((add || toggle) && !Object(_array_js__WEBPACK_IMPORTED_MODULE_2__["includes"])(features.getArray(), feature)) {
              selected.push(feature);
              this.addFeatureLayerAssociation_(feature, layer);
            } else if ((remove || toggle) && Object(_array_js__WEBPACK_IMPORTED_MODULE_2__["includes"])(features.getArray(), feature)) {
              deselected.push(feature);
              this.removeFeatureLayerAssociation_(feature);
            }
            return !this.multi_;
          }
        }).bind(this), {
        layerFilter: this.layerFilter_,
        hitTolerance: this.hitTolerance_
      });
    for (var j = deselected.length - 1; j >= 0; --j) {
      features.remove(deselected[j]);
    }
    features.extend(selected);
  }
  if (selected.length > 0 || deselected.length > 0) {
    this.dispatchEvent(
      new SelectEvent(SelectEventType.SELECT,
        selected, deselected, mapBrowserEvent));
  }
  return Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_5__["pointerMove"])(mapBrowserEvent);
}


/**
 * @return {import("../style/Style.js").StyleFunction} Styles.
 */
function getDefaultStyleFunction() {
  var styles = Object(_style_Style_js__WEBPACK_IMPORTED_MODULE_12__["createEditingStyle"])();
  Object(_array_js__WEBPACK_IMPORTED_MODULE_2__["extend"])(styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_7__["default"].POLYGON], styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_7__["default"].LINE_STRING]);
  Object(_array_js__WEBPACK_IMPORTED_MODULE_2__["extend"])(styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_7__["default"].GEOMETRY_COLLECTION], styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_7__["default"].LINE_STRING]);

  return function(feature, resolution) {
    if (!feature.getGeometry()) {
      return null;
    }
    return styles[feature.getGeometry().getType()];
  };
}


/* harmony default export */ __webpack_exports__["default"] = (Select);

//# sourceMappingURL=Select.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/Snap.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/interaction/Snap.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../CollectionEventType.js */ "./node_modules/ol/CollectionEventType.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../coordinate.js */ "./node_modules/ol/coordinate.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../geom/Polygon.js */ "./node_modules/ol/geom/Polygon.js");
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../source/VectorEventType.js */ "./node_modules/ol/source/VectorEventType.js");
/* harmony import */ var _structs_RBush_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../structs/RBush.js */ "./node_modules/ol/structs/RBush.js");
/**
 * @module ol/interaction/Snap
 */















/**
 * @typedef {Object} Result
 * @property {boolean} snapped
 * @property {import("../coordinate.js").Coordinate|null} vertex
 * @property {import("../pixel.js").Pixel|null} vertexPixel
 */


/**
 * @typedef {Object} SegmentData
 * @property {import("../Feature.js").default} feature
 * @property {Array<import("../coordinate.js").Coordinate>} segment
 */


/**
 * @typedef {Object} Options
 * @property {import("../Collection.js").default<import("../Feature.js").default>} [features] Snap to these features. Either this option or source should be provided.
 * @property {boolean} [edge=true] Snap to edges.
 * @property {boolean} [vertex=true] Snap to vertices.
 * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or
 * vertex for snapping.
 * @property {import("../source/Vector.js").default} [source] Snap to features from this source. Either this option or features should be provided
 */


/**
 * @param  {import("../source/Vector.js").VectorSourceEvent|import("../Collection.js").CollectionEvent} evt Event.
 * @return {import("../Feature.js").default} Feature.
 */
function getFeatureFromEvent(evt) {
  if (/** @type {import("../source/Vector.js").VectorSourceEvent} */ (evt).feature) {
    return /** @type {import("../source/Vector.js").VectorSourceEvent} */ (evt).feature;
  } else if (/** @type {import("../Collection.js").CollectionEvent} */ (evt).element) {
    return /** @type {import("../Feature.js").default} */ (/** @type {import("../Collection.js").CollectionEvent} */ (evt).element);
  }

}

/**
 * @classdesc
 * Handles snapping of vector features while modifying or drawing them.  The
 * features can come from a {@link module:ol/source/Vector} or {@link module:ol/Collection~Collection}
 * Any interaction object that allows the user to interact
 * with the features using the mouse can benefit from the snapping, as long
 * as it is added before.
 *
 * The snap interaction modifies map browser event `coordinate` and `pixel`
 * properties to force the snap to occur to any interaction that them.
 *
 * Example:
 *
 *     import Snap from 'ol/interaction/Snap';
 *
 *     var snap = new Snap({
 *       source: source
 *     });
 *
 * @api
 */
var Snap = /*@__PURE__*/(function (PointerInteraction) {
  function Snap(opt_options) {

    var options = opt_options ? opt_options : {};

    var pointerOptions = /** @type {import("./Pointer.js").Options} */ (options);

    if (!pointerOptions.handleDownEvent) {
      pointerOptions.handleDownEvent = _functions_js__WEBPACK_IMPORTED_MODULE_6__["TRUE"];
    }

    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = _functions_js__WEBPACK_IMPORTED_MODULE_6__["FALSE"];
    }

    PointerInteraction.call(this, pointerOptions);

    /**
     * @type {import("../source/Vector.js").default}
     * @private
     */
    this.source_ = options.source ? options.source : null;

    /**
     * @private
     * @type {boolean}
     */
    this.vertex_ = options.vertex !== undefined ? options.vertex : true;

    /**
     * @private
     * @type {boolean}
     */
    this.edge_ = options.edge !== undefined ? options.edge : true;

    /**
     * @type {import("../Collection.js").default<import("../Feature.js").default>}
     * @private
     */
    this.features_ = options.features ? options.features : null;

    /**
     * @type {Array<import("../events.js").EventsKey>}
     * @private
     */
    this.featuresListenerKeys_ = [];

    /**
     * @type {Object<string, import("../events.js").EventsKey>}
     * @private
     */
    this.featureChangeListenerKeys_ = {};

    /**
     * Extents are preserved so indexed segment can be quickly removed
     * when its feature geometry changes
     * @type {Object<string, import("../extent.js").Extent>}
     * @private
     */
    this.indexedFeaturesExtents_ = {};

    /**
     * If a feature geometry changes while a pointer drag|move event occurs, the
     * feature doesn't get updated right away.  It will be at the next 'pointerup'
     * event fired.
     * @type {!Object<string, import("../Feature.js").default>}
     * @private
     */
    this.pendingFeatures_ = {};

    /**
     * Used for distance sorting in sortByDistance_
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */
    this.pixelCoordinate_ = null;

    /**
     * @type {number}
     * @private
     */
    this.pixelTolerance_ = options.pixelTolerance !== undefined ?
      options.pixelTolerance : 10;

    /**
     * @type {function(SegmentData, SegmentData): number}
     * @private
     */
    this.sortByDistance_ = sortByDistance.bind(this);


    /**
    * Segment RTree for each layer
    * @type {import("../structs/RBush.js").default<SegmentData>}
    * @private
    */
    this.rBush_ = new _structs_RBush_js__WEBPACK_IMPORTED_MODULE_12__["default"]();


    /**
    * @const
    * @private
    * @type {Object<string, function(import("../Feature.js").default, import("../geom/Geometry.js").default)>}
    */
    this.SEGMENT_WRITERS_ = {
      'Point': this.writePointGeometry_,
      'LineString': this.writeLineStringGeometry_,
      'LinearRing': this.writeLineStringGeometry_,
      'Polygon': this.writePolygonGeometry_,
      'MultiPoint': this.writeMultiPointGeometry_,
      'MultiLineString': this.writeMultiLineStringGeometry_,
      'MultiPolygon': this.writeMultiPolygonGeometry_,
      'GeometryCollection': this.writeGeometryCollectionGeometry_,
      'Circle': this.writeCircleGeometry_
    };
  }

  if ( PointerInteraction ) Snap.__proto__ = PointerInteraction;
  Snap.prototype = Object.create( PointerInteraction && PointerInteraction.prototype );
  Snap.prototype.constructor = Snap;

  /**
   * Add a feature to the collection of features that we may snap to.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {boolean=} opt_listen Whether to listen to the feature change or not
   *     Defaults to `true`.
   * @api
   */
  Snap.prototype.addFeature = function addFeature (feature, opt_listen) {
    var register = opt_listen !== undefined ? opt_listen : true;
    var feature_uid = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature);
    var geometry = feature.getGeometry();
    if (geometry) {
      var segmentWriter = this.SEGMENT_WRITERS_[geometry.getType()];
      if (segmentWriter) {
        this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["createEmpty"])());
        segmentWriter.call(this, feature, geometry);
      }
    }

    if (register) {
      this.featureChangeListenerKeys_[feature_uid] = Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(
        feature,
        _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].CHANGE,
        this.handleFeatureChange_, this);
    }
  };

  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @private
   */
  Snap.prototype.forEachFeatureAdd_ = function forEachFeatureAdd_ (feature) {
    this.addFeature(feature);
  };

  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @private
   */
  Snap.prototype.forEachFeatureRemove_ = function forEachFeatureRemove_ (feature) {
    this.removeFeature(feature);
  };

  /**
   * @return {import("../Collection.js").default<import("../Feature.js").default>|Array<import("../Feature.js").default>} Features.
   * @private
   */
  Snap.prototype.getFeatures_ = function getFeatures_ () {
    var features;
    if (this.features_) {
      features = this.features_;
    } else if (this.source_) {
      features = this.source_.getFeatures();
    }
    return features;
  };

  /**
   * @inheritDoc
   */
  Snap.prototype.handleEvent = function handleEvent (evt) {
    var result = this.snapTo(evt.pixel, evt.coordinate, evt.map);
    if (result.snapped) {
      evt.coordinate = result.vertex.slice(0, 2);
      evt.pixel = result.vertexPixel;
    }
    return PointerInteraction.prototype.handleEvent.call(this, evt);
  };

  /**
   * @param {import("../source/Vector.js").VectorSourceEvent|import("../Collection.js").CollectionEvent} evt Event.
   * @private
   */
  Snap.prototype.handleFeatureAdd_ = function handleFeatureAdd_ (evt) {
    var feature = getFeatureFromEvent(evt);
    this.addFeature(feature);
  };

  /**
   * @param {import("../source/Vector.js").VectorSourceEvent|import("../Collection.js").CollectionEvent} evt Event.
   * @private
   */
  Snap.prototype.handleFeatureRemove_ = function handleFeatureRemove_ (evt) {
    var feature = getFeatureFromEvent(evt);
    this.removeFeature(feature);
  };

  /**
   * @param {import("../events/Event.js").default} evt Event.
   * @private
   */
  Snap.prototype.handleFeatureChange_ = function handleFeatureChange_ (evt) {
    var feature = /** @type {import("../Feature.js").default} */ (evt.target);
    if (this.handlingDownUpSequence) {
      var uid = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature);
      if (!(uid in this.pendingFeatures_)) {
        this.pendingFeatures_[uid] = feature;
      }
    } else {
      this.updateFeature_(feature);
    }
  };

  /**
   * @inheritDoc
   */
  Snap.prototype.handleUpEvent = function handleUpEvent (evt) {
    var featuresToUpdate = Object(_obj_js__WEBPACK_IMPORTED_MODULE_10__["getValues"])(this.pendingFeatures_);
    if (featuresToUpdate.length) {
      featuresToUpdate.forEach(this.updateFeature_.bind(this));
      this.pendingFeatures_ = {};
    }
    return false;
  };

  /**
   * Remove a feature from the collection of features that we may snap to.
   * @param {import("../Feature.js").default} feature Feature
   * @param {boolean=} opt_unlisten Whether to unlisten to the feature change
   *     or not. Defaults to `true`.
   * @api
   */
  Snap.prototype.removeFeature = function removeFeature (feature, opt_unlisten) {
    var unregister = opt_unlisten !== undefined ? opt_unlisten : true;
    var feature_uid = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature);
    var extent = this.indexedFeaturesExtents_[feature_uid];
    if (extent) {
      var rBush = this.rBush_;
      var nodesToRemove = [];
      rBush.forEachInExtent(extent, function(node) {
        if (feature === node.feature) {
          nodesToRemove.push(node);
        }
      });
      for (var i = nodesToRemove.length - 1; i >= 0; --i) {
        rBush.remove(nodesToRemove[i]);
      }
    }

    if (unregister) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["unlistenByKey"])(this.featureChangeListenerKeys_[feature_uid]);
      delete this.featureChangeListenerKeys_[feature_uid];
    }
  };

  /**
   * @inheritDoc
   */
  Snap.prototype.setMap = function setMap (map) {
    var currentMap = this.getMap();
    var keys = this.featuresListenerKeys_;
    var features = /** @type {Array<import("../Feature.js").default>} */ (this.getFeatures_());

    if (currentMap) {
      keys.forEach(_events_js__WEBPACK_IMPORTED_MODULE_3__["unlistenByKey"]);
      keys.length = 0;
      features.forEach(this.forEachFeatureRemove_.bind(this));
    }
    PointerInteraction.prototype.setMap.call(this, map);

    if (map) {
      if (this.features_) {
        keys.push(
          Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(this.features_, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].ADD,
            this.handleFeatureAdd_, this),
          Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(this.features_, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].REMOVE,
            this.handleFeatureRemove_, this)
        );
      } else if (this.source_) {
        keys.push(
          Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(this.source_, _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_11__["default"].ADDFEATURE,
            this.handleFeatureAdd_, this),
          Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(this.source_, _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_11__["default"].REMOVEFEATURE,
            this.handleFeatureRemove_, this)
        );
      }
      features.forEach(this.forEachFeatureAdd_.bind(this));
    }
  };

  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel
   * @param {import("../coordinate.js").Coordinate} pixelCoordinate Coordinate
   * @param {import("../PluggableMap.js").default} map Map.
   * @return {Result} Snap result
   */
  Snap.prototype.snapTo = function snapTo (pixel, pixelCoordinate, map) {

    var lowerLeft = map.getCoordinateFromPixel(
      [pixel[0] - this.pixelTolerance_, pixel[1] + this.pixelTolerance_]);
    var upperRight = map.getCoordinateFromPixel(
      [pixel[0] + this.pixelTolerance_, pixel[1] - this.pixelTolerance_]);
    var box = Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["boundingExtent"])([lowerLeft, upperRight]);

    var segments = this.rBush_.getInExtent(box);

    // If snapping on vertices only, don't consider circles
    if (this.vertex_ && !this.edge_) {
      segments = segments.filter(function(segment) {
        return segment.feature.getGeometry().getType() !==
            _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_7__["default"].CIRCLE;
      });
    }

    var snappedToVertex = false;
    var snapped = false;
    var vertex = null;
    var vertexPixel = null;
    var dist, pixel1, pixel2, squaredDist1, squaredDist2;
    if (segments.length > 0) {
      this.pixelCoordinate_ = pixelCoordinate;
      segments.sort(this.sortByDistance_);
      var closestSegment = segments[0].segment;
      var isCircle = segments[0].feature.getGeometry().getType() ===
          _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_7__["default"].CIRCLE;
      if (this.vertex_ && !this.edge_) {
        pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
        pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
        squaredDist1 = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_2__["squaredDistance"])(pixel, pixel1);
        squaredDist2 = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_2__["squaredDistance"])(pixel, pixel2);
        dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
        snappedToVertex = dist <= this.pixelTolerance_;
        if (snappedToVertex) {
          snapped = true;
          vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
          vertexPixel = map.getPixelFromCoordinate(vertex);
        }
      } else if (this.edge_) {
        if (isCircle) {
          vertex = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_2__["closestOnCircle"])(pixelCoordinate,
            /** @type {import("../geom/Circle.js").default} */ (segments[0].feature.getGeometry()));
        } else {
          vertex = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_2__["closestOnSegment"])(pixelCoordinate, closestSegment);
        }
        vertexPixel = map.getPixelFromCoordinate(vertex);
        if (Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_2__["distance"])(pixel, vertexPixel) <= this.pixelTolerance_) {
          snapped = true;
          if (this.vertex_ && !isCircle) {
            pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
            pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
            squaredDist1 = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_2__["squaredDistance"])(vertexPixel, pixel1);
            squaredDist2 = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_2__["squaredDistance"])(vertexPixel, pixel2);
            dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
            snappedToVertex = dist <= this.pixelTolerance_;
            if (snappedToVertex) {
              vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
              vertexPixel = map.getPixelFromCoordinate(vertex);
            }
          }
        }
      }
      if (snapped) {
        vertexPixel = [Math.round(vertexPixel[0]), Math.round(vertexPixel[1])];
      }
    }
    return (
      /** @type {Result} */ ({
        snapped: snapped,
        vertex: vertex,
        vertexPixel: vertexPixel
      })
    );
  };

  /**
   * @param {import("../Feature.js").default} feature Feature
   * @private
   */
  Snap.prototype.updateFeature_ = function updateFeature_ (feature) {
    this.removeFeature(feature, false);
    this.addFeature(feature, false);
  };

  /**
   * @param {import("../Feature.js").default} feature Feature
   * @param {import("../geom/Circle.js").default} geometry Geometry.
   * @private
   */
  Snap.prototype.writeCircleGeometry_ = function writeCircleGeometry_ (feature, geometry) {
    var polygon = Object(_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_8__["fromCircle"])(geometry);
    var coordinates = polygon.getCoordinates()[0];
    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
      var segment = coordinates.slice(i, i + 2);
      var segmentData = /** @type {SegmentData} */ ({
        feature: feature,
        segment: segment
      });
      this.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["boundingExtent"])(segment), segmentData);
    }
  };

  /**
   * @param {import("../Feature.js").default} feature Feature
   * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
   * @private
   */
  Snap.prototype.writeGeometryCollectionGeometry_ = function writeGeometryCollectionGeometry_ (feature, geometry) {
    var geometries = geometry.getGeometriesArray();
    for (var i = 0; i < geometries.length; ++i) {
      var segmentWriter = this.SEGMENT_WRITERS_[geometries[i].getType()];
      if (segmentWriter) {
        segmentWriter.call(this, feature, geometries[i]);
      }
    }
  };

  /**
   * @param {import("../Feature.js").default} feature Feature
   * @param {import("../geom/LineString.js").default} geometry Geometry.
   * @private
   */
  Snap.prototype.writeLineStringGeometry_ = function writeLineStringGeometry_ (feature, geometry) {
    var coordinates = geometry.getCoordinates();
    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
      var segment = coordinates.slice(i, i + 2);
      var segmentData = /** @type {SegmentData} */ ({
        feature: feature,
        segment: segment
      });
      this.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["boundingExtent"])(segment), segmentData);
    }
  };

  /**
   * @param {import("../Feature.js").default} feature Feature
   * @param {import("../geom/MultiLineString.js").default} geometry Geometry.
   * @private
   */
  Snap.prototype.writeMultiLineStringGeometry_ = function writeMultiLineStringGeometry_ (feature, geometry) {
    var lines = geometry.getCoordinates();
    for (var j = 0, jj = lines.length; j < jj; ++j) {
      var coordinates = lines[j];
      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
        var segment = coordinates.slice(i, i + 2);
        var segmentData = /** @type {SegmentData} */ ({
          feature: feature,
          segment: segment
        });
        this.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["boundingExtent"])(segment), segmentData);
      }
    }
  };

  /**
   * @param {import("../Feature.js").default} feature Feature
   * @param {import("../geom/MultiPoint.js").default} geometry Geometry.
   * @private
   */
  Snap.prototype.writeMultiPointGeometry_ = function writeMultiPointGeometry_ (feature, geometry) {
    var points = geometry.getCoordinates();
    for (var i = 0, ii = points.length; i < ii; ++i) {
      var coordinates = points[i];
      var segmentData = /** @type {SegmentData} */ ({
        feature: feature,
        segment: [coordinates, coordinates]
      });
      this.rBush_.insert(geometry.getExtent(), segmentData);
    }
  };

  /**
   * @param {import("../Feature.js").default} feature Feature
   * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
   * @private
   */
  Snap.prototype.writeMultiPolygonGeometry_ = function writeMultiPolygonGeometry_ (feature, geometry) {
    var polygons = geometry.getCoordinates();
    for (var k = 0, kk = polygons.length; k < kk; ++k) {
      var rings = polygons[k];
      for (var j = 0, jj = rings.length; j < jj; ++j) {
        var coordinates = rings[j];
        for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
          var segment = coordinates.slice(i, i + 2);
          var segmentData = /** @type {SegmentData} */ ({
            feature: feature,
            segment: segment
          });
          this.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["boundingExtent"])(segment), segmentData);
        }
      }
    }
  };

  /**
   * @param {import("../Feature.js").default} feature Feature
   * @param {import("../geom/Point.js").default} geometry Geometry.
   * @private
   */
  Snap.prototype.writePointGeometry_ = function writePointGeometry_ (feature, geometry) {
    var coordinates = geometry.getCoordinates();
    var segmentData = /** @type {SegmentData} */ ({
      feature: feature,
      segment: [coordinates, coordinates]
    });
    this.rBush_.insert(geometry.getExtent(), segmentData);
  };

  /**
   * @param {import("../Feature.js").default} feature Feature
   * @param {import("../geom/Polygon.js").default} geometry Geometry.
   * @private
   */
  Snap.prototype.writePolygonGeometry_ = function writePolygonGeometry_ (feature, geometry) {
    var rings = geometry.getCoordinates();
    for (var j = 0, jj = rings.length; j < jj; ++j) {
      var coordinates = rings[j];
      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
        var segment = coordinates.slice(i, i + 2);
        var segmentData = /** @type {SegmentData} */ ({
          feature: feature,
          segment: segment
        });
        this.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["boundingExtent"])(segment), segmentData);
      }
    }
  };

  return Snap;
}(_Pointer_js__WEBPACK_IMPORTED_MODULE_9__["default"]));


/**
 * Sort segments by distance, helper function
 * @param {SegmentData} a The first segment data.
 * @param {SegmentData} b The second segment data.
 * @return {number} The difference in distance.
 * @this {Snap}
 */
function sortByDistance(a, b) {
  var deltaA = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_2__["squaredDistanceToSegment"])(this.pixelCoordinate_, a.segment);
  var deltaB = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_2__["squaredDistanceToSegment"])(this.pixelCoordinate_, b.segment);
  return deltaA - deltaB;
}

/* harmony default export */ __webpack_exports__["default"] = (Snap);

//# sourceMappingURL=Snap.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/Translate.js":
/*!**************************************************!*\
  !*** ./node_modules/ol/interaction/Translate.js ***!
  \**************************************************/
/*! exports provided: TranslateEvent, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TranslateEvent", function() { return TranslateEvent; });
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Collection.js */ "./node_modules/ol/Collection.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/* harmony import */ var _Property_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Property.js */ "./node_modules/ol/interaction/Property.js");
/**
 * @module ol/interaction/Translate
 */










/**
 * @enum {string}
 */
var TranslateEventType = {
  /**
   * Triggered upon feature translation start.
   * @event TranslateEvent#translatestart
   * @api
   */
  TRANSLATESTART: 'translatestart',
  /**
   * Triggered upon feature translation.
   * @event TranslateEvent#translating
   * @api
   */
  TRANSLATING: 'translating',
  /**
   * Triggered upon feature translation end.
   * @event TranslateEvent#translateend
   * @api
   */
  TRANSLATEEND: 'translateend'
};


/**
 * @typedef {Object} Options
 * @property {Collection<import("../Feature.js").default>} [features] Only features contained in this collection will be able to be translated. If
 * not specified, all features on the map will be able to be translated.
 * @property {Array<import("../layer/Layer.js").default>|function(import("../layer/Layer.js").default): boolean} [layers] A list of layers from which features should be
 * translated. Alternatively, a filter function can be provided. The
 * function will be called for each layer in the map and should return
 * `true` for layers that you want to be translatable. If the option is
 * absent, all visible layers will be considered translatable.
 * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside the radius around the given position
 * will be checked for features. This only works for the canvas renderer and
 * not for WebGL.
 */


/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Translate~Translate} instances
 * are instances of this type.
 */
var TranslateEvent = /*@__PURE__*/(function (Event) {
  function TranslateEvent(type, features, coordinate) {

    Event.call(this, type);

    /**
     * The features being translated.
     * @type {Collection<import("../Feature.js").default>}
     * @api
     */
    this.features = features;

    /**
     * The coordinate of the drag event.
     * @const
     * @type {import("../coordinate.js").Coordinate}
     * @api
     */
    this.coordinate = coordinate;

  }

  if ( Event ) TranslateEvent.__proto__ = Event;
  TranslateEvent.prototype = Object.create( Event && Event.prototype );
  TranslateEvent.prototype.constructor = TranslateEvent;

  return TranslateEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_3__["default"]));


/**
 * @classdesc
 * Interaction for translating (moving) features.
 *
 * @fires TranslateEvent
 * @api
 */
var Translate = /*@__PURE__*/(function (PointerInteraction) {
  function Translate(opt_options) {
    var options = opt_options ? opt_options : {};

    PointerInteraction.call(/** @type {import("./Pointer.js").Options} */ this, (options));

    /**
     * The last position we translated to.
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */
    this.lastCoordinate_ = null;


    /**
     * @type {Collection<import("../Feature.js").default>}
     * @private
     */
    this.features_ = options.features !== undefined ? options.features : null;

    /** @type {function(import("../layer/Layer.js").default): boolean} */
    var layerFilter;
    if (options.layers) {
      if (typeof options.layers === 'function') {
        layerFilter = options.layers;
      } else {
        var layers = options.layers;
        layerFilter = function(layer) {
          return Object(_array_js__WEBPACK_IMPORTED_MODULE_5__["includes"])(layers, layer);
        };
      }
    } else {
      layerFilter = _functions_js__WEBPACK_IMPORTED_MODULE_4__["TRUE"];
    }

    /**
     * @private
     * @type {function(import("../layer/Layer.js").default): boolean}
     */
    this.layerFilter_ = layerFilter;

    /**
     * @private
     * @type {number}
     */
    this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;

    /**
     * @type {import("../Feature.js").default}
     * @private
     */
    this.lastFeature_ = null;

    Object(_events_js__WEBPACK_IMPORTED_MODULE_2__["listen"])(this,
      Object(_Object_js__WEBPACK_IMPORTED_MODULE_1__["getChangeEventType"])(_Property_js__WEBPACK_IMPORTED_MODULE_7__["default"].ACTIVE),
      this.handleActiveChanged_, this);

  }

  if ( PointerInteraction ) Translate.__proto__ = PointerInteraction;
  Translate.prototype = Object.create( PointerInteraction && PointerInteraction.prototype );
  Translate.prototype.constructor = Translate;

  /**
   * @inheritDoc
   */
  Translate.prototype.handleDownEvent = function handleDownEvent (event) {
    this.lastFeature_ = this.featuresAtPixel_(event.pixel, event.map);
    if (!this.lastCoordinate_ && this.lastFeature_) {
      this.lastCoordinate_ = event.coordinate;
      this.handleMoveEvent(event);

      var features = this.features_ || new _Collection_js__WEBPACK_IMPORTED_MODULE_0__["default"]([this.lastFeature_]);

      this.dispatchEvent(
        new TranslateEvent(
          TranslateEventType.TRANSLATESTART, features,
          event.coordinate));
      return true;
    }
    return false;
  };

  /**
   * @inheritDoc
   */
  Translate.prototype.handleUpEvent = function handleUpEvent (event) {
    if (this.lastCoordinate_) {
      this.lastCoordinate_ = null;
      this.handleMoveEvent(event);

      var features = this.features_ || new _Collection_js__WEBPACK_IMPORTED_MODULE_0__["default"]([this.lastFeature_]);

      this.dispatchEvent(
        new TranslateEvent(
          TranslateEventType.TRANSLATEEND, features,
          event.coordinate));
      return true;
    }
    return false;
  };

  /**
   * @inheritDoc
   */
  Translate.prototype.handleDragEvent = function handleDragEvent (event) {
    if (this.lastCoordinate_) {
      var newCoordinate = event.coordinate;
      var deltaX = newCoordinate[0] - this.lastCoordinate_[0];
      var deltaY = newCoordinate[1] - this.lastCoordinate_[1];

      var features = this.features_ || new _Collection_js__WEBPACK_IMPORTED_MODULE_0__["default"]([this.lastFeature_]);

      features.forEach(function(feature) {
        var geom = feature.getGeometry();
        geom.translate(deltaX, deltaY);
        feature.setGeometry(geom);
      });

      this.lastCoordinate_ = newCoordinate;
      this.dispatchEvent(
        new TranslateEvent(
          TranslateEventType.TRANSLATING, features,
          newCoordinate));
    }
  };

  /**
   * @inheritDoc
   */
  Translate.prototype.handleMoveEvent = function handleMoveEvent (event) {
    var elem = event.map.getViewport();

    // Change the cursor to grab/grabbing if hovering any of the features managed
    // by the interaction
    if (this.featuresAtPixel_(event.pixel, event.map)) {
      elem.classList.remove(this.lastCoordinate_ ? 'ol-grab' : 'ol-grabbing');
      elem.classList.add(this.lastCoordinate_ ? 'ol-grabbing' : 'ol-grab');
    } else {
      elem.classList.remove('ol-grab', 'ol-grabbing');
    }
  };

  /**
   * Tests to see if the given coordinates intersects any of our selected
   * features.
   * @param {import("../pixel.js").Pixel} pixel Pixel coordinate to test for intersection.
   * @param {import("../PluggableMap.js").default} map Map to test the intersection on.
   * @return {import("../Feature.js").default} Returns the feature found at the specified pixel
   * coordinates.
   * @private
   */
  Translate.prototype.featuresAtPixel_ = function featuresAtPixel_ (pixel, map) {
    return map.forEachFeatureAtPixel(pixel,
      function(feature) {
        if (!this.features_ || Object(_array_js__WEBPACK_IMPORTED_MODULE_5__["includes"])(this.features_.getArray(), feature)) {
          return feature;
        }
      }.bind(this), {
        layerFilter: this.layerFilter_,
        hitTolerance: this.hitTolerance_
      });
  };

  /**
   * Returns the Hit-detection tolerance.
   * @returns {number} Hit tolerance in pixels.
   * @api
   */
  Translate.prototype.getHitTolerance = function getHitTolerance () {
    return this.hitTolerance_;
  };

  /**
   * Hit-detection tolerance. Pixels inside the radius around the given position
   * will be checked for features. This only works for the canvas renderer and
   * not for WebGL.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @api
   */
  Translate.prototype.setHitTolerance = function setHitTolerance (hitTolerance) {
    this.hitTolerance_ = hitTolerance;
  };

  /**
   * @inheritDoc
   */
  Translate.prototype.setMap = function setMap (map) {
    var oldMap = this.getMap();
    PointerInteraction.prototype.setMap.call(this, map);
    this.updateState_(oldMap);
  };

  /**
   * @private
   */
  Translate.prototype.handleActiveChanged_ = function handleActiveChanged_ () {
    this.updateState_(null);
  };

  /**
   * @param {import("../PluggableMap.js").default} oldMap Old map.
   * @private
   */
  Translate.prototype.updateState_ = function updateState_ (oldMap) {
    var map = this.getMap();
    var active = this.getActive();
    if (!map || !active) {
      map = map || oldMap;
      if (map) {
        var elem = map.getViewport();
        elem.classList.remove('ol-grab', 'ol-grabbing');
      }
    }
  };

  return Translate;
}(_Pointer_js__WEBPACK_IMPORTED_MODULE_6__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (Translate);

//# sourceMappingURL=Translate.js.map

/***/ }),

/***/ "./node_modules/ol/layer/Base.js":
/*!***************************************!*\
  !*** ./node_modules/ol/layer/Base.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _Property_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Property.js */ "./node_modules/ol/layer/Property.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/layer/Base
 */







/**
 * @typedef {Object} Options
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 */


/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Note that with {@link module:ol/layer/Base} and all its subclasses, any property set in
 * the options is set as a {@link module:ol/Object} property on the layer object, so
 * is observable, and has get/set accessors.
 *
 * @api
 */
var BaseLayer = /*@__PURE__*/(function (BaseObject) {
  function BaseLayer(options) {

    BaseObject.call(this);

    /**
     * @type {Object<string, *>}
     */
    var properties = Object(_obj_js__WEBPACK_IMPORTED_MODULE_4__["assign"])({}, options);
    properties[_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].OPACITY] =
       options.opacity !== undefined ? options.opacity : 1;
    properties[_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].VISIBLE] =
       options.visible !== undefined ? options.visible : true;
    properties[_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].Z_INDEX] = options.zIndex;
    properties[_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].MAX_RESOLUTION] =
       options.maxResolution !== undefined ? options.maxResolution : Infinity;
    properties[_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].MIN_RESOLUTION] =
       options.minResolution !== undefined ? options.minResolution : 0;

    this.setProperties(properties);

    /**
     * @type {import("./Layer.js").State}
     * @private
     */
    this.state_ = null;

    /**
     * The layer type.
     * @type {import("../LayerType.js").default}
     * @protected;
     */
    this.type;

  }

  if ( BaseObject ) BaseLayer.__proto__ = BaseObject;
  BaseLayer.prototype = Object.create( BaseObject && BaseObject.prototype );
  BaseLayer.prototype.constructor = BaseLayer;

  /**
   * Get the layer type (used when creating a layer renderer).
   * @return {import("../LayerType.js").default} The layer type.
   */
  BaseLayer.prototype.getType = function getType () {
    return this.type;
  };

  /**
   * @return {import("./Layer.js").State} Layer state.
   */
  BaseLayer.prototype.getLayerState = function getLayerState () {
    /** @type {import("./Layer.js").State} */
    var state = this.state_ || /** @type {?} */ ({
      layer: this,
      managed: true
    });
    state.opacity = Object(_math_js__WEBPACK_IMPORTED_MODULE_3__["clamp"])(this.getOpacity(), 0, 1);
    state.sourceState = this.getSourceState();
    state.visible = this.getVisible();
    state.extent = this.getExtent();
    state.zIndex = this.getZIndex() || 0;
    state.maxResolution = this.getMaxResolution();
    state.minResolution = Math.max(this.getMinResolution(), 0);
    this.state_ = state;

    return state;
  };

  /**
   * @abstract
   * @param {Array<import("./Layer.js").default>=} opt_array Array of layers (to be
   *     modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  BaseLayer.prototype.getLayersArray = function getLayersArray (opt_array) {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * @abstract
   * @param {Array<import("./Layer.js").State>=} opt_states Optional list of layer
   *     states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  BaseLayer.prototype.getLayerStatesArray = function getLayerStatesArray (opt_states) {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
   * will be visible regardless of extent.
   * @return {import("../extent.js").Extent|undefined} The layer extent.
   * @observable
   * @api
   */
  BaseLayer.prototype.getExtent = function getExtent () {
    return (
      /** @type {import("../extent.js").Extent|undefined} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].EXTENT))
    );
  };

  /**
   * Return the maximum resolution of the layer.
   * @return {number} The maximum resolution of the layer.
   * @observable
   * @api
   */
  BaseLayer.prototype.getMaxResolution = function getMaxResolution () {
    return /** @type {number} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].MAX_RESOLUTION));
  };

  /**
   * Return the minimum resolution of the layer.
   * @return {number} The minimum resolution of the layer.
   * @observable
   * @api
   */
  BaseLayer.prototype.getMinResolution = function getMinResolution () {
    return /** @type {number} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].MIN_RESOLUTION));
  };

  /**
   * Return the opacity of the layer (between 0 and 1).
   * @return {number} The opacity of the layer.
   * @observable
   * @api
   */
  BaseLayer.prototype.getOpacity = function getOpacity () {
    return /** @type {number} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].OPACITY));
  };

  /**
   * @abstract
   * @return {import("../source/State.js").default} Source state.
   */
  BaseLayer.prototype.getSourceState = function getSourceState () {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Return the visibility of the layer (`true` or `false`).
   * @return {boolean} The visibility of the layer.
   * @observable
   * @api
   */
  BaseLayer.prototype.getVisible = function getVisible () {
    return /** @type {boolean} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].VISIBLE));
  };

  /**
   * Return the Z-index of the layer, which is used to order layers before
   * rendering. The default Z-index is 0.
   * @return {number} The Z-index of the layer.
   * @observable
   * @api
   */
  BaseLayer.prototype.getZIndex = function getZIndex () {
    return /** @type {number} */ (this.get(_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].Z_INDEX));
  };

  /**
   * Set the extent at which the layer is visible.  If `undefined`, the layer
   * will be visible at all extents.
   * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
   * @observable
   * @api
   */
  BaseLayer.prototype.setExtent = function setExtent (extent) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].EXTENT, extent);
  };

  /**
   * Set the maximum resolution at which the layer is visible.
   * @param {number} maxResolution The maximum resolution of the layer.
   * @observable
   * @api
   */
  BaseLayer.prototype.setMaxResolution = function setMaxResolution (maxResolution) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].MAX_RESOLUTION, maxResolution);
  };

  /**
   * Set the minimum resolution at which the layer is visible.
   * @param {number} minResolution The minimum resolution of the layer.
   * @observable
   * @api
   */
  BaseLayer.prototype.setMinResolution = function setMinResolution (minResolution) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].MIN_RESOLUTION, minResolution);
  };

  /**
   * Set the opacity of the layer, allowed values range from 0 to 1.
   * @param {number} opacity The opacity of the layer.
   * @observable
   * @api
   */
  BaseLayer.prototype.setOpacity = function setOpacity (opacity) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].OPACITY, opacity);
  };

  /**
   * Set the visibility of the layer (`true` or `false`).
   * @param {boolean} visible The visibility of the layer.
   * @observable
   * @api
   */
  BaseLayer.prototype.setVisible = function setVisible (visible) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].VISIBLE, visible);
  };

  /**
   * Set Z-index of the layer, which is used to order layers before rendering.
   * The default Z-index is 0.
   * @param {number} zindex The z-index of the layer.
   * @observable
   * @api
   */
  BaseLayer.prototype.setZIndex = function setZIndex (zindex) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].Z_INDEX, zindex);
  };

  return BaseLayer;
}(_Object_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (BaseLayer);

//# sourceMappingURL=Base.js.map

/***/ }),

/***/ "./node_modules/ol/layer/Group.js":
/*!****************************************!*\
  !*** ./node_modules/ol/layer/Group.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Collection.js */ "./node_modules/ol/Collection.js");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../CollectionEventType.js */ "./node_modules/ol/CollectionEventType.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ObjectEventType.js */ "./node_modules/ol/ObjectEventType.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _Base_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Base.js */ "./node_modules/ol/layer/Base.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _source_State_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../source/State.js */ "./node_modules/ol/source/State.js");
/**
 * @module ol/layer/Group
 */














/**
 * @typedef {Object} Options
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {Array<import("./Base.js").default>|import("../Collection.js").default<import("./Base.js").default>} [layers] Child layers.
 */


/**
 * @enum {string}
 * @private
 */
var Property = {
  LAYERS: 'layers'
};


/**
 * @classdesc
 * A {@link module:ol/Collection~Collection} of layers that are handled together.
 *
 * A generic `change` event is triggered when the group/Collection changes.
 *
 * @api
 */
var LayerGroup = /*@__PURE__*/(function (BaseLayer) {
  function LayerGroup(opt_options) {

    var options = opt_options || {};
    var baseOptions = /** @type {Options} */ (Object(_obj_js__WEBPACK_IMPORTED_MODULE_10__["assign"])({}, options));
    delete baseOptions.layers;

    var layers = options.layers;

    BaseLayer.call(this, baseOptions);

    /**
     * @private
     * @type {Array<import("../events.js").EventsKey>}
     */
    this.layersListenerKeys_ = [];

    /**
     * @private
     * @type {Object<string, Array<import("../events.js").EventsKey>>}
     */
    this.listenerKeys_ = {};

    Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(this,
      Object(_Object_js__WEBPACK_IMPORTED_MODULE_3__["getChangeEventType"])(Property.LAYERS),
      this.handleLayersChanged_, this);

    if (layers) {
      if (Array.isArray(layers)) {
        layers = new _Collection_js__WEBPACK_IMPORTED_MODULE_1__["default"](layers.slice(), {unique: true});
      } else {
        Object(_asserts_js__WEBPACK_IMPORTED_MODULE_5__["assert"])(typeof /** @type {?} */ (layers).getArray === 'function',
          43); // Expected `layers` to be an array or a `Collection`
      }
    } else {
      layers = new _Collection_js__WEBPACK_IMPORTED_MODULE_1__["default"](undefined, {unique: true});
    }

    this.setLayers(layers);

  }

  if ( BaseLayer ) LayerGroup.__proto__ = BaseLayer;
  LayerGroup.prototype = Object.create( BaseLayer && BaseLayer.prototype );
  LayerGroup.prototype.constructor = LayerGroup;

  /**
   * @private
   */
  LayerGroup.prototype.handleLayerChange_ = function handleLayerChange_ () {
    this.changed();
  };

  /**
   * @private
   */
  LayerGroup.prototype.handleLayersChanged_ = function handleLayersChanged_ () {
    this.layersListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_6__["unlistenByKey"]);
    this.layersListenerKeys_.length = 0;

    var layers = this.getLayers();
    this.layersListenerKeys_.push(
      Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(layers, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].ADD, this.handleLayersAdd_, this),
      Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(layers, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].REMOVE, this.handleLayersRemove_, this)
    );

    for (var id in this.listenerKeys_) {
      this.listenerKeys_[id].forEach(_events_js__WEBPACK_IMPORTED_MODULE_6__["unlistenByKey"]);
    }
    Object(_obj_js__WEBPACK_IMPORTED_MODULE_10__["clear"])(this.listenerKeys_);

    var layersArray = layers.getArray();
    for (var i = 0, ii = layersArray.length; i < ii; i++) {
      var layer = layersArray[i];
      this.listenerKeys_[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(layer)] = [
        Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(layer, _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].PROPERTYCHANGE, this.handleLayerChange_, this),
        Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(layer, _events_EventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].CHANGE, this.handleLayerChange_, this)
      ];
    }

    this.changed();
  };

  /**
   * @param {import("../Collection.js").CollectionEvent} collectionEvent CollectionEvent.
   * @private
   */
  LayerGroup.prototype.handleLayersAdd_ = function handleLayersAdd_ (collectionEvent) {
    var layer = /** @type {import("./Base.js").default} */ (collectionEvent.element);
    this.listenerKeys_[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(layer)] = [
      Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(layer, _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].PROPERTYCHANGE, this.handleLayerChange_, this),
      Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(layer, _events_EventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].CHANGE, this.handleLayerChange_, this)
    ];
    this.changed();
  };

  /**
   * @param {import("../Collection.js").CollectionEvent} collectionEvent CollectionEvent.
   * @private
   */
  LayerGroup.prototype.handleLayersRemove_ = function handleLayersRemove_ (collectionEvent) {
    var layer = /** @type {import("./Base.js").default} */ (collectionEvent.element);
    var key = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(layer);
    this.listenerKeys_[key].forEach(_events_js__WEBPACK_IMPORTED_MODULE_6__["unlistenByKey"]);
    delete this.listenerKeys_[key];
    this.changed();
  };

  /**
   * Returns the {@link module:ol/Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @return {!import("../Collection.js").default<import("./Base.js").default>} Collection of
   *   {@link module:ol/layer/Base layers} that are part of this group.
   * @observable
   * @api
   */
  LayerGroup.prototype.getLayers = function getLayers () {
    return (
      /** @type {!import("../Collection.js").default<import("./Base.js").default>} */ (this.get(Property.LAYERS))
    );
  };

  /**
   * Set the {@link module:ol/Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @param {!import("../Collection.js").default<import("./Base.js").default>} layers Collection of
   *   {@link module:ol/layer/Base layers} that are part of this group.
   * @observable
   * @api
   */
  LayerGroup.prototype.setLayers = function setLayers (layers) {
    this.set(Property.LAYERS, layers);
  };

  /**
   * @inheritDoc
   */
  LayerGroup.prototype.getLayersArray = function getLayersArray (opt_array) {
    var array = opt_array !== undefined ? opt_array : [];
    this.getLayers().forEach(function(layer) {
      layer.getLayersArray(array);
    });
    return array;
  };

  /**
   * @inheritDoc
   */
  LayerGroup.prototype.getLayerStatesArray = function getLayerStatesArray (opt_states) {
    var states = opt_states !== undefined ? opt_states : [];

    var pos = states.length;

    this.getLayers().forEach(function(layer) {
      layer.getLayerStatesArray(states);
    });

    var ownLayerState = this.getLayerState();
    for (var i = pos, ii = states.length; i < ii; i++) {
      var layerState = states[i];
      layerState.opacity *= ownLayerState.opacity;
      layerState.visible = layerState.visible && ownLayerState.visible;
      layerState.maxResolution = Math.min(
        layerState.maxResolution, ownLayerState.maxResolution);
      layerState.minResolution = Math.max(
        layerState.minResolution, ownLayerState.minResolution);
      if (ownLayerState.extent !== undefined) {
        if (layerState.extent !== undefined) {
          layerState.extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_8__["getIntersection"])(layerState.extent, ownLayerState.extent);
        } else {
          layerState.extent = ownLayerState.extent;
        }
      }
    }

    return states;
  };

  /**
   * @inheritDoc
   */
  LayerGroup.prototype.getSourceState = function getSourceState () {
    return _source_State_js__WEBPACK_IMPORTED_MODULE_11__["default"].READY;
  };

  return LayerGroup;
}(_Base_js__WEBPACK_IMPORTED_MODULE_9__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (LayerGroup);

//# sourceMappingURL=Group.js.map

/***/ }),

/***/ "./node_modules/ol/layer/Layer.js":
/*!****************************************!*\
  !*** ./node_modules/ol/layer/Layer.js ***!
  \****************************************/
/*! exports provided: visibleAtResolution, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "visibleAtResolution", function() { return visibleAtResolution; });
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _Base_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Base.js */ "./node_modules/ol/layer/Base.js");
/* harmony import */ var _Property_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Property.js */ "./node_modules/ol/layer/Property.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _render_EventType_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../render/EventType.js */ "./node_modules/ol/render/EventType.js");
/* harmony import */ var _source_State_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../source/State.js */ "./node_modules/ol/source/State.js");
/**
 * @module ol/layer/Layer
 */











/**
 * @typedef {Object} Options
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {import("../source/Source.js").default} [source] Source for this layer.  If not provided to the constructor,
 * the source can be set by calling {@link module:ol/layer/Layer#setSource layer.setSource(source)} after
 * construction.
 * @property {import("../PluggableMap.js").default} [map] Map.
 */


/**
 * @typedef {Object} State
 * @property {import("./Base.js").default} layer
 * @property {number} opacity
 * @property {SourceState} sourceState
 * @property {boolean} visible
 * @property {boolean} managed
 * @property {import("../extent.js").Extent} [extent]
 * @property {number} zIndex
 * @property {number} maxResolution
 * @property {number} minResolution
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * A visual representation of raster or vector map data.
 * Layers group together those properties that pertain to how the data is to be
 * displayed, irrespective of the source of that data.
 *
 * Layers are usually added to a map with {@link module:ol/Map#addLayer}. Components
 * like {@link module:ol/interaction/Select~Select} use unmanaged layers
 * internally. These unmanaged layers are associated with the map using
 * {@link module:ol/layer/Layer~Layer#setMap} instead.
 *
 * A generic `change` event is fired when the state of the source changes.
 *
 * @fires import("../render/Event.js").RenderEvent
 */
var Layer = /*@__PURE__*/(function (BaseLayer) {
  function Layer(options) {

    var baseOptions = Object(_obj_js__WEBPACK_IMPORTED_MODULE_6__["assign"])({}, options);
    delete baseOptions.source;

    BaseLayer.call(this, baseOptions);

    /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */
    this.mapPrecomposeKey_ = null;

    /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */
    this.mapRenderKey_ = null;

    /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */
    this.sourceChangeKey_ = null;

    if (options.map) {
      this.setMap(options.map);
    }

    Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listen"])(this,
      Object(_Object_js__WEBPACK_IMPORTED_MODULE_3__["getChangeEventType"])(_Property_js__WEBPACK_IMPORTED_MODULE_5__["default"].SOURCE),
      this.handleSourcePropertyChange_, this);

    var source = options.source ? options.source : null;
    this.setSource(source);
  }

  if ( BaseLayer ) Layer.__proto__ = BaseLayer;
  Layer.prototype = Object.create( BaseLayer && BaseLayer.prototype );
  Layer.prototype.constructor = Layer;

  /**
   * @inheritDoc
   */
  Layer.prototype.getLayersArray = function getLayersArray (opt_array) {
    var array = opt_array ? opt_array : [];
    array.push(this);
    return array;
  };

  /**
   * @inheritDoc
   */
  Layer.prototype.getLayerStatesArray = function getLayerStatesArray (opt_states) {
    var states = opt_states ? opt_states : [];
    states.push(this.getLayerState());
    return states;
  };

  /**
   * Get the layer source.
   * @return {import("../source/Source.js").default} The layer source (or `null` if not yet set).
   * @observable
   * @api
   */
  Layer.prototype.getSource = function getSource () {
    var source = this.get(_Property_js__WEBPACK_IMPORTED_MODULE_5__["default"].SOURCE);
    return (
      /** @type {import("../source/Source.js").default} */ (source) || null
    );
  };

  /**
    * @inheritDoc
    */
  Layer.prototype.getSourceState = function getSourceState () {
    var source = this.getSource();
    return !source ? _source_State_js__WEBPACK_IMPORTED_MODULE_8__["default"].UNDEFINED : source.getState();
  };

  /**
   * @private
   */
  Layer.prototype.handleSourceChange_ = function handleSourceChange_ () {
    this.changed();
  };

  /**
   * @private
   */
  Layer.prototype.handleSourcePropertyChange_ = function handleSourcePropertyChange_ () {
    if (this.sourceChangeKey_) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["unlistenByKey"])(this.sourceChangeKey_);
      this.sourceChangeKey_ = null;
    }
    var source = this.getSource();
    if (source) {
      this.sourceChangeKey_ = Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listen"])(source,
        _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CHANGE, this.handleSourceChange_, this);
    }
    this.changed();
  };

  /**
   * Sets the layer to be rendered on top of other layers on a map. The map will
   * not manage this layer in its layers collection, and the callback in
   * {@link module:ol/Map#forEachLayerAtPixel} will receive `null` as layer. This
   * is useful for temporary layers. To remove an unmanaged layer from the map,
   * use `#setMap(null)`.
   *
   * To add the layer to a map and have it managed by the map, use
   * {@link module:ol/Map#addLayer} instead.
   * @param {import("../PluggableMap.js").default} map Map.
   * @api
   */
  Layer.prototype.setMap = function setMap (map) {
    if (this.mapPrecomposeKey_) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["unlistenByKey"])(this.mapPrecomposeKey_);
      this.mapPrecomposeKey_ = null;
    }
    if (!map) {
      this.changed();
    }
    if (this.mapRenderKey_) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["unlistenByKey"])(this.mapRenderKey_);
      this.mapRenderKey_ = null;
    }
    if (map) {
      this.mapPrecomposeKey_ = Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listen"])(map, _render_EventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].PRECOMPOSE, function(evt) {
        var renderEvent = /** @type {import("../render/Event.js").default} */ (evt);
        var layerState = this.getLayerState();
        layerState.managed = false;
        if (this.getZIndex() === undefined) {
          layerState.zIndex = Infinity;
        }
        renderEvent.frameState.layerStatesArray.push(layerState);
        renderEvent.frameState.layerStates[Object(_util_js__WEBPACK_IMPORTED_MODULE_2__["getUid"])(this)] = layerState;
      }, this);
      this.mapRenderKey_ = Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listen"])(this, _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CHANGE, map.render, map);
      this.changed();
    }
  };

  /**
   * Set the layer source.
   * @param {import("../source/Source.js").default} source The layer source.
   * @observable
   * @api
   */
  Layer.prototype.setSource = function setSource (source) {
    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_5__["default"].SOURCE, source);
  };

  return Layer;
}(_Base_js__WEBPACK_IMPORTED_MODULE_4__["default"]));


/**
 * Return `true` if the layer is visible, and if the passed resolution is
 * between the layer's minResolution and maxResolution. The comparison is
 * inclusive for `minResolution` and exclusive for `maxResolution`.
 * @param {State} layerState Layer state.
 * @param {number} resolution Resolution.
 * @return {boolean} The layer is visible at the given resolution.
 */
function visibleAtResolution(layerState, resolution) {
  return layerState.visible && resolution >= layerState.minResolution &&
      resolution < layerState.maxResolution;
}


/* harmony default export */ __webpack_exports__["default"] = (Layer);

//# sourceMappingURL=Layer.js.map

/***/ }),

/***/ "./node_modules/ol/layer/Property.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/layer/Property.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/layer/Property
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  OPACITY: 'opacity',
  VISIBLE: 'visible',
  EXTENT: 'extent',
  Z_INDEX: 'zIndex',
  MAX_RESOLUTION: 'maxResolution',
  MIN_RESOLUTION: 'minResolution',
  SOURCE: 'source'
});

//# sourceMappingURL=Property.js.map

/***/ }),

/***/ "./node_modules/ol/layer/Tile.js":
/*!***************************************!*\
  !*** ./node_modules/ol/layer/Tile.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _LayerType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../LayerType.js */ "./node_modules/ol/LayerType.js");
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Layer.js */ "./node_modules/ol/layer/Layer.js");
/* harmony import */ var _TileProperty_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TileProperty.js */ "./node_modules/ol/layer/TileProperty.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/layer/Tile
 */






/**
 * @typedef {Object} Options
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`
 * means no preloading.
 * @property {import("../source/Tile.js").default} [source] Source for this layer.
 * @property {import("../PluggableMap.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link module:ol/Map#addLayer}.
 * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.
 */

/**
 * @classdesc
 * For layer sources that provide pre-rendered, tiled images in grids that are
 * organized by zoom levels for specific resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @api
 */
var TileLayer = /*@__PURE__*/(function (Layer) {
  function TileLayer(opt_options) {
    var options = opt_options ? opt_options : {};

    var baseOptions = Object(_obj_js__WEBPACK_IMPORTED_MODULE_3__["assign"])({}, options);

    delete baseOptions.preload;
    delete baseOptions.useInterimTilesOnError;
    Layer.call(this, baseOptions);

    this.setPreload(options.preload !== undefined ? options.preload : 0);
    this.setUseInterimTilesOnError(options.useInterimTilesOnError !== undefined ?
      options.useInterimTilesOnError : true);

    /**
    * The layer type.
    * @protected
    * @type {import("../LayerType.js").default}
    */
    this.type = _LayerType_js__WEBPACK_IMPORTED_MODULE_0__["default"].TILE;

  }

  if ( Layer ) TileLayer.__proto__ = Layer;
  TileLayer.prototype = Object.create( Layer && Layer.prototype );
  TileLayer.prototype.constructor = TileLayer;

  /**
  * Return the level as number to which we will preload tiles up to.
  * @return {number} The level to preload tiles up to.
  * @observable
  * @api
  */
  TileLayer.prototype.getPreload = function getPreload () {
    return /** @type {number} */ (this.get(_TileProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].PRELOAD));
  };

  /**
  * Set the level as number to which we will preload tiles up to.
  * @param {number} preload The level to preload tiles up to.
  * @observable
  * @api
  */
  TileLayer.prototype.setPreload = function setPreload (preload) {
    this.set(_TileProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].PRELOAD, preload);
  };

  /**
  * Whether we use interim tiles on error.
  * @return {boolean} Use interim tiles on error.
  * @observable
  * @api
  */
  TileLayer.prototype.getUseInterimTilesOnError = function getUseInterimTilesOnError () {
    return /** @type {boolean} */ (this.get(_TileProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].USE_INTERIM_TILES_ON_ERROR));
  };

  /**
  * Set whether we use interim tiles on error.
  * @param {boolean} useInterimTilesOnError Use interim tiles on error.
  * @observable
  * @api
  */
  TileLayer.prototype.setUseInterimTilesOnError = function setUseInterimTilesOnError (useInterimTilesOnError) {
    this.set(_TileProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
  };

  return TileLayer;
}(_Layer_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/**
 * Return the associated {@link module:ol/source/Tile tilesource} of the layer.
 * @function
 * @return {import("../source/Tile.js").default} Source.
 * @api
 */
TileLayer.prototype.getSource;


/* harmony default export */ __webpack_exports__["default"] = (TileLayer);

//# sourceMappingURL=Tile.js.map

/***/ }),

/***/ "./node_modules/ol/layer/TileProperty.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/layer/TileProperty.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/layer/TileProperty
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  PRELOAD: 'preload',
  USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError'
});

//# sourceMappingURL=TileProperty.js.map

/***/ }),

/***/ "./node_modules/ol/layer/Vector.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/layer/Vector.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _LayerType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../LayerType.js */ "./node_modules/ol/LayerType.js");
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Layer.js */ "./node_modules/ol/layer/Layer.js");
/* harmony import */ var _VectorRenderType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VectorRenderType.js */ "./node_modules/ol/layer/VectorRenderType.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _style_Style_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../style/Style.js */ "./node_modules/ol/style/Style.js");
/**
 * @module ol/layer/Vector
 */







/**
 * @typedef {Object} Options
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {import("../render.js").OrderFunction} [renderOrder] Render order. Function to be used when sorting
 * features before rendering. By default features are drawn in the order that they are created. Use
 * `null` to avoid the sort, but get an undefined draw order.
 * @property {number} [renderBuffer=100] The buffer in pixels around the viewport extent used by the
 * renderer when getting features from the vector source for the rendering or hit-detection.
 * Recommended value: the size of the largest symbol, line width or label.
 * @property {import("./VectorRenderType.js").default|string} [renderMode='vector'] Render mode for vector layers:
 *  * `'image'`: Vector layers are rendered as images. Great performance, but point symbols and
 *    texts are always rotated with the view and pixels are scaled during zoom animations.
 *  * `'vector'`: Vector layers are rendered as vectors. Most accurate rendering even during
 *    animations, but slower performance.
 * @property {import("../source/Vector.js").default} [source] Source.
 * @property {import("../PluggableMap.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link module:ol/Map#addLayer}.
 * @property {boolean} [declutter=false] Declutter images and text. Decluttering is applied to all
 * image and text styles, and the priority is defined by the z-index of the style. Lower z-index
 * means higher priority.
 * @property {import("../style/Style.js").StyleLike} [style] Layer style. See
 * {@link module:ol/style} for default style which will be used if this is not defined.
 * @property {boolean} [updateWhileAnimating=false] When set to `true` and `renderMode`
 * is `vector`, feature batches will be recreated during animations. This means that no
 * vectors will be shown clipped, but the setting will have a performance impact for large
 * amounts of vector data. When set to `false`, batches will be recreated when no animation
 * is active.
 * @property {boolean} [updateWhileInteracting=false] When set to `true` and `renderMode`
 * is `vector`, feature batches will be recreated during interactions. See also
 * `updateWhileAnimating`.
 */


/**
 * @enum {string}
 * @private
 */
var Property = {
  RENDER_ORDER: 'renderOrder'
};


/**
 * @classdesc
 * Vector data that is rendered client-side.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @api
 */
var VectorLayer = /*@__PURE__*/(function (Layer) {
  function VectorLayer(opt_options) {
    var options = opt_options ?
      opt_options : /** @type {Options} */ ({});

    var baseOptions = Object(_obj_js__WEBPACK_IMPORTED_MODULE_3__["assign"])({}, options);

    delete baseOptions.style;
    delete baseOptions.renderBuffer;
    delete baseOptions.updateWhileAnimating;
    delete baseOptions.updateWhileInteracting;
    Layer.call(this, baseOptions);

    /**
    * @private
    * @type {boolean}
    */
    this.declutter_ = options.declutter !== undefined ? options.declutter : false;

    /**
    * @type {number}
    * @private
    */
    this.renderBuffer_ = options.renderBuffer !== undefined ?
      options.renderBuffer : 100;

    /**
    * User provided style.
    * @type {import("../style/Style.js").StyleLike}
    * @private
    */
    this.style_ = null;

    /**
    * Style function for use within the library.
    * @type {import("../style/Style.js").StyleFunction|undefined}
    * @private
    */
    this.styleFunction_ = undefined;

    this.setStyle(options.style);

    /**
    * @type {boolean}
    * @private
    */
    this.updateWhileAnimating_ = options.updateWhileAnimating !== undefined ?
      options.updateWhileAnimating : false;

    /**
    * @type {boolean}
    * @private
    */
    this.updateWhileInteracting_ = options.updateWhileInteracting !== undefined ?
      options.updateWhileInteracting : false;

    /**
    * @private
    * @type {import("./VectorTileRenderType.js").default|string}
    */
    this.renderMode_ = options.renderMode || _VectorRenderType_js__WEBPACK_IMPORTED_MODULE_2__["default"].VECTOR;

    /**
    * The layer type.
    * @protected
    * @type {import("../LayerType.js").default}
    */
    this.type = _LayerType_js__WEBPACK_IMPORTED_MODULE_0__["default"].VECTOR;

  }

  if ( Layer ) VectorLayer.__proto__ = Layer;
  VectorLayer.prototype = Object.create( Layer && Layer.prototype );
  VectorLayer.prototype.constructor = VectorLayer;

  /**
  * @return {boolean} Declutter.
  */
  VectorLayer.prototype.getDeclutter = function getDeclutter () {
    return this.declutter_;
  };

  /**
  * @param {boolean} declutter Declutter.
  */
  VectorLayer.prototype.setDeclutter = function setDeclutter (declutter) {
    this.declutter_ = declutter;
  };

  /**
  * @return {number|undefined} Render buffer.
  */
  VectorLayer.prototype.getRenderBuffer = function getRenderBuffer () {
    return this.renderBuffer_;
  };

  /**
  * @return {function(import("../Feature.js").default, import("../Feature.js").default): number|null|undefined} Render
  *     order.
  */
  VectorLayer.prototype.getRenderOrder = function getRenderOrder () {
    return (
    /** @type {import("../render.js").OrderFunction|null|undefined} */ (this.get(Property.RENDER_ORDER))
    );
  };

  /**
  * Get the style for features.  This returns whatever was passed to the `style`
  * option at construction or to the `setStyle` method.
  * @return {import("../style/Style.js").StyleLike}
  *     Layer style.
  * @api
  */
  VectorLayer.prototype.getStyle = function getStyle () {
    return this.style_;
  };

  /**
  * Get the style function.
  * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
  * @api
  */
  VectorLayer.prototype.getStyleFunction = function getStyleFunction () {
    return this.styleFunction_;
  };

  /**
  * @return {boolean} Whether the rendered layer should be updated while
  *     animating.
  */
  VectorLayer.prototype.getUpdateWhileAnimating = function getUpdateWhileAnimating () {
    return this.updateWhileAnimating_;
  };

  /**
  * @return {boolean} Whether the rendered layer should be updated while
  *     interacting.
  */
  VectorLayer.prototype.getUpdateWhileInteracting = function getUpdateWhileInteracting () {
    return this.updateWhileInteracting_;
  };

  /**
  * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
  *     Render order.
  */
  VectorLayer.prototype.setRenderOrder = function setRenderOrder (renderOrder) {
    this.set(Property.RENDER_ORDER, renderOrder);
  };

  /**
  * Set the style for features.  This can be a single style object, an array
  * of styles, or a function that takes a feature and resolution and returns
  * an array of styles. If it is `undefined` the default style is used. If
  * it is `null` the layer has no style (a `null` style), so only features
  * that have their own styles will be rendered in the layer. See
  * {@link module:ol/style} for information on the default style.
  * @param {import("../style/Style.js").default|Array<import("../style/Style.js").default>|import("../style/Style.js").StyleFunction|null|undefined} style Layer style.
  * @api
  */
  VectorLayer.prototype.setStyle = function setStyle (style) {
    this.style_ = style !== undefined ? style : _style_Style_js__WEBPACK_IMPORTED_MODULE_4__["createDefaultStyle"];
    this.styleFunction_ = style === null ?
      undefined : Object(_style_Style_js__WEBPACK_IMPORTED_MODULE_4__["toFunction"])(this.style_);
    this.changed();
  };

  /**
  * @return {import("./VectorRenderType.js").default|string} The render mode.
  */
  VectorLayer.prototype.getRenderMode = function getRenderMode () {
    return this.renderMode_;
  };

  return VectorLayer;
}(_Layer_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/**
 * Return the associated {@link module:ol/source/Vector vectorsource} of the layer.
 * @function
 * @return {import("../source/Vector.js").default} Source.
 * @api
 */
VectorLayer.prototype.getSource;


/* harmony default export */ __webpack_exports__["default"] = (VectorLayer);

//# sourceMappingURL=Vector.js.map

/***/ }),

/***/ "./node_modules/ol/layer/VectorRenderType.js":
/*!***************************************************!*\
  !*** ./node_modules/ol/layer/VectorRenderType.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/layer/VectorRenderType
 */

/**
 * @enum {string}
 * Render mode for vector layers:
 *  * `'image'`: Vector layers are rendered as images. Great performance, but
 *    point symbols and texts are always rotated with the view and pixels are
 *    scaled during zoom animations.
 *  * `'vector'`: Vector layers are rendered as vectors. Most accurate rendering
 *    even during animations, but slower performance.
 * @api
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  IMAGE: 'image',
  VECTOR: 'vector'
});

//# sourceMappingURL=VectorRenderType.js.map

/***/ }),

/***/ "./node_modules/ol/layer/VectorTileRenderType.js":
/*!*******************************************************!*\
  !*** ./node_modules/ol/layer/VectorTileRenderType.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/layer/VectorTileRenderType
 */

/**
 * @enum {string}
 * Render mode for vector tiles:
 *  * `'image'`: Vector tiles are rendered as images. Great performance, but
 *    point symbols and texts are always rotated with the view and pixels are
 *    scaled during zoom animations.
 *  * `'hybrid'`: Polygon and line elements are rendered as images, so pixels
 *    are scaled during zoom animations. Point symbols and texts are accurately
 *    rendered as vectors and can stay upright on rotated views.
 *  * `'vector'`: Vector tiles are rendered as vectors. Most accurate rendering
 *    even during animations, but slower performance than the other options.
 * @api
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  IMAGE: 'image',
  HYBRID: 'hybrid',
  VECTOR: 'vector'
});

//# sourceMappingURL=VectorTileRenderType.js.map

/***/ }),

/***/ "./node_modules/ol/loadingstrategy.js":
/*!********************************************!*\
  !*** ./node_modules/ol/loadingstrategy.js ***!
  \********************************************/
/*! exports provided: all, bbox, tile */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "all", function() { return all; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bbox", function() { return bbox; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tile", function() { return tile; });
/**
 * @module ol/loadingstrategy
 */


/**
 * Strategy function for loading all features with a single request.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array<import("./extent.js").Extent>} Extents.
 * @api
 */
function all(extent, resolution) {
  return [[-Infinity, -Infinity, Infinity, Infinity]];
}


/**
 * Strategy function for loading features based on the view's extent and
 * resolution.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array<import("./extent.js").Extent>} Extents.
 * @api
 */
function bbox(extent, resolution) {
  return [extent];
}


/**
 * Creates a strategy function for loading features based on a tile grid.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {function(import("./extent.js").Extent, number): Array<import("./extent.js").Extent>} Loading strategy.
 * @api
 */
function tile(tileGrid) {
  return (
    /**
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @return {Array<import("./extent.js").Extent>} Extents.
     */
    function(extent, resolution) {
      var z = tileGrid.getZForResolution(resolution);
      var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
      /** @type {Array<import("./extent.js").Extent>} */
      var extents = [];
      /** @type {import("./tilecoord.js").TileCoord} */
      var tileCoord = [z, 0, 0];
      for (tileCoord[1] = tileRange.minX; tileCoord[1] <= tileRange.maxX; ++tileCoord[1]) {
        for (tileCoord[2] = tileRange.minY; tileCoord[2] <= tileRange.maxY; ++tileCoord[2]) {
          extents.push(tileGrid.getTileCoordExtent(tileCoord));
        }
      }
      return extents;
    }
  );
}

//# sourceMappingURL=loadingstrategy.js.map

/***/ }),

/***/ "./node_modules/ol/math.js":
/*!*********************************!*\
  !*** ./node_modules/ol/math.js ***!
  \*********************************/
/*! exports provided: clamp, cosh, roundUpToPowerOfTwo, squaredSegmentDistance, squaredDistance, solveLinearSystem, toDegrees, toRadians, modulo, lerp */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clamp", function() { return clamp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cosh", function() { return cosh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "roundUpToPowerOfTwo", function() { return roundUpToPowerOfTwo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredSegmentDistance", function() { return squaredSegmentDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "solveLinearSystem", function() { return solveLinearSystem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toDegrees", function() { return toDegrees; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toRadians", function() { return toRadians; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "modulo", function() { return modulo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/**
 * @module ol/math
 */


/**
 * Takes a number and clamps it to within the provided bounds.
 * @param {number} value The input number.
 * @param {number} min The minimum value to return.
 * @param {number} max The maximum value to return.
 * @return {number} The input number if it is within bounds, or the nearest
 *     number within the bounds.
 */
function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}


/**
 * Return the hyperbolic cosine of a given number. The method will use the
 * native `Math.cosh` function if it is available, otherwise the hyperbolic
 * cosine will be calculated via the reference implementation of the Mozilla
 * developer network.
 *
 * @param {number} x X.
 * @return {number} Hyperbolic cosine of x.
 */
var cosh = (function() {
  // Wrapped in a iife, to save the overhead of checking for the native
  // implementation on every invocation.
  var cosh;
  if ('cosh' in Math) {
    // The environment supports the native Math.cosh function, use it…
    cosh = Math.cosh;
  } else {
    // … else, use the reference implementation of MDN:
    cosh = function(x) {
      var y = /** @type {Math} */ (Math).exp(x);
      return (y + 1 / y) / 2;
    };
  }
  return cosh;
}());


/**
 * @param {number} x X.
 * @return {number} The smallest power of two greater than or equal to x.
 */
function roundUpToPowerOfTwo(x) {
  Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(0 < x, 29); // `x` must be greater than `0`
  return Math.pow(2, Math.ceil(Math.log(x) / Math.LN2));
}


/**
 * Returns the square of the closest distance between the point (x, y) and the
 * line segment (x1, y1) to (x2, y2).
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */
function squaredSegmentDistance(x, y, x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;
  if (dx !== 0 || dy !== 0) {
    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      x1 = x2;
      y1 = y2;
    } else if (t > 0) {
      x1 += dx * t;
      y1 += dy * t;
    }
  }
  return squaredDistance(x, y, x1, y1);
}


/**
 * Returns the square of the distance between the points (x1, y1) and (x2, y2).
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */
function squaredDistance(x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;
  return dx * dx + dy * dy;
}


/**
 * Solves system of linear equations using Gaussian elimination method.
 *
 * @param {Array<Array<number>>} mat Augmented matrix (n x n + 1 column)
 *                                     in row-major order.
 * @return {Array<number>} The resulting vector.
 */
function solveLinearSystem(mat) {
  var n = mat.length;

  for (var i = 0; i < n; i++) {
    // Find max in the i-th column (ignoring i - 1 first rows)
    var maxRow = i;
    var maxEl = Math.abs(mat[i][i]);
    for (var r = i + 1; r < n; r++) {
      var absValue = Math.abs(mat[r][i]);
      if (absValue > maxEl) {
        maxEl = absValue;
        maxRow = r;
      }
    }

    if (maxEl === 0) {
      return null; // matrix is singular
    }

    // Swap max row with i-th (current) row
    var tmp = mat[maxRow];
    mat[maxRow] = mat[i];
    mat[i] = tmp;

    // Subtract the i-th row to make all the remaining rows 0 in the i-th column
    for (var j = i + 1; j < n; j++) {
      var coef = -mat[j][i] / mat[i][i];
      for (var k = i; k < n + 1; k++) {
        if (i == k) {
          mat[j][k] = 0;
        } else {
          mat[j][k] += coef * mat[i][k];
        }
      }
    }
  }

  // Solve Ax=b for upper triangular matrix A (mat)
  var x = new Array(n);
  for (var l = n - 1; l >= 0; l--) {
    x[l] = mat[l][n] / mat[l][l];
    for (var m = l - 1; m >= 0; m--) {
      mat[m][n] -= mat[m][l] * x[l];
    }
  }
  return x;
}


/**
 * Converts radians to to degrees.
 *
 * @param {number} angleInRadians Angle in radians.
 * @return {number} Angle in degrees.
 */
function toDegrees(angleInRadians) {
  return angleInRadians * 180 / Math.PI;
}


/**
 * Converts degrees to radians.
 *
 * @param {number} angleInDegrees Angle in degrees.
 * @return {number} Angle in radians.
 */
function toRadians(angleInDegrees) {
  return angleInDegrees * Math.PI / 180;
}

/**
 * Returns the modulo of a / b, depending on the sign of b.
 *
 * @param {number} a Dividend.
 * @param {number} b Divisor.
 * @return {number} Modulo.
 */
function modulo(a, b) {
  var r = a % b;
  return r * b < 0 ? r + b : r;
}

/**
 * Calculates the linearly interpolated value of x between a and b.
 *
 * @param {number} a Number
 * @param {number} b Number
 * @param {number} x Value to be interpolated.
 * @return {number} Interpolated value.
 */
function lerp(a, b, x) {
  return a + x * (b - a);
}

//# sourceMappingURL=math.js.map

/***/ }),

/***/ "./node_modules/ol/obj.js":
/*!********************************!*\
  !*** ./node_modules/ol/obj.js ***!
  \********************************/
/*! exports provided: assign, clear, getValues, isEmpty */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assign", function() { return assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clear", function() { return clear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getValues", function() { return getValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEmpty", function() { return isEmpty; });
/**
 * @module ol/obj
 */


/**
 * Polyfill for Object.assign().  Assigns enumerable and own properties from
 * one or more source objects to a target object.
 * See https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign.
 *
 * @param {!Object} target The target object.
 * @param {...Object} var_sources The source object(s).
 * @return {!Object} The modified target object.
 */
var assign = (typeof Object.assign === 'function') ? Object.assign : function(target, var_sources) {
  var arguments$1 = arguments;

  if (target === undefined || target === null) {
    throw new TypeError('Cannot convert undefined or null to object');
  }

  var output = Object(target);
  for (var i = 1, ii = arguments.length; i < ii; ++i) {
    var source = arguments$1[i];
    if (source !== undefined && source !== null) {
      for (var key in source) {
        if (source.hasOwnProperty(key)) {
          output[key] = source[key];
        }
      }
    }
  }
  return output;
};


/**
 * Removes all properties from an object.
 * @param {Object} object The object to clear.
 */
function clear(object) {
  for (var property in object) {
    delete object[property];
  }
}


/**
 * Get an array of property values from an object.
 * @param {Object<K,V>} object The object from which to get the values.
 * @return {!Array<V>} The property values.
 * @template K,V
 */
function getValues(object) {
  var values = [];
  for (var property in object) {
    values.push(object[property]);
  }
  return values;
}


/**
 * Determine if an object has any properties.
 * @param {Object} object The object to check.
 * @return {boolean} The object is empty.
 */
function isEmpty(object) {
  var property;
  for (property in object) {
    return false;
  }
  return !property;
}

//# sourceMappingURL=obj.js.map

/***/ }),

/***/ "./node_modules/ol/ol.css":
/*!********************************!*\
  !*** ./node_modules/ol/ol.css ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../css-loader/dist/cjs.js!./ol.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/ol/ol.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./node_modules/ol/pointer/EventSource.js":
/*!************************************************!*\
  !*** ./node_modules/ol/pointer/EventSource.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/pointer/EventSource
 */

var EventSource = function EventSource(dispatcher, mapping) {

  /**
   * @type {import("./PointerEventHandler.js").default}
   */
  this.dispatcher = dispatcher;

  /**
   * @private
   * @const
   * @type {!Object<string, function(Event)>}
   */
  this.mapping_ = mapping;
};

/**
 * List of events supported by this source.
 * @return {Array<string>} Event names
 */
EventSource.prototype.getEvents = function getEvents () {
  return Object.keys(this.mapping_);
};

/**
 * Returns the handler that should handle a given event type.
 * @param {string} eventType The event type.
 * @return {function(Event)} Handler
 */
EventSource.prototype.getHandlerForEvent = function getHandlerForEvent (eventType) {
  return this.mapping_[eventType];
};

/* harmony default export */ __webpack_exports__["default"] = (EventSource);

//# sourceMappingURL=EventSource.js.map

/***/ }),

/***/ "./node_modules/ol/pointer/EventType.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/pointer/EventType.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/pointer/EventType
 */

/**
 * Constants for event names.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  POINTERMOVE: 'pointermove',
  POINTERDOWN: 'pointerdown',
  POINTERUP: 'pointerup',
  POINTEROVER: 'pointerover',
  POINTEROUT: 'pointerout',
  POINTERENTER: 'pointerenter',
  POINTERLEAVE: 'pointerleave',
  POINTERCANCEL: 'pointercancel'
});

//# sourceMappingURL=EventType.js.map

/***/ }),

/***/ "./node_modules/ol/pointer/MouseSource.js":
/*!************************************************!*\
  !*** ./node_modules/ol/pointer/MouseSource.js ***!
  \************************************************/
/*! exports provided: POINTER_ID, POINTER_TYPE, prepareEvent, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POINTER_ID", function() { return POINTER_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POINTER_TYPE", function() { return POINTER_TYPE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prepareEvent", function() { return prepareEvent; });
/* harmony import */ var _EventSource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EventSource.js */ "./node_modules/ol/pointer/EventSource.js");
/**
 * @module ol/pointer/MouseSource
 */

// Based on https://github.com/Polymer/PointerEvents

// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.




/**
 * @type {number}
 */
var POINTER_ID = 1;


/**
 * @type {string}
 */
var POINTER_TYPE = 'mouse';


/**
 * Radius around touchend that swallows mouse events.
 *
 * @type {number}
 */
var DEDUP_DIST = 25;

/**
 * Handler for `mousedown`.
 *
 * @this {MouseSource}
 * @param {MouseEvent} inEvent The in event.
 */
function mousedown(inEvent) {
  if (!this.isEventSimulatedFromTouch_(inEvent)) {
    // TODO(dfreedman) workaround for some elements not sending mouseup
    // http://crbug/149091
    if (POINTER_ID.toString() in this.pointerMap) {
      this.cancel(inEvent);
    }
    var e = prepareEvent(inEvent, this.dispatcher);
    this.pointerMap[POINTER_ID.toString()] = inEvent;
    this.dispatcher.down(e, inEvent);
  }
}

/**
 * Handler for `mousemove`.
 *
 * @this {MouseSource}
 * @param {MouseEvent} inEvent The in event.
 */
function mousemove(inEvent) {
  if (!this.isEventSimulatedFromTouch_(inEvent)) {
    var e = prepareEvent(inEvent, this.dispatcher);
    this.dispatcher.move(e, inEvent);
  }
}

/**
 * Handler for `mouseup`.
 *
 * @this {MouseSource}
 * @param {MouseEvent} inEvent The in event.
 */
function mouseup(inEvent) {
  if (!this.isEventSimulatedFromTouch_(inEvent)) {
    var p = this.pointerMap[POINTER_ID.toString()];

    if (p && p.button === inEvent.button) {
      var e = prepareEvent(inEvent, this.dispatcher);
      this.dispatcher.up(e, inEvent);
      this.cleanupMouse();
    }
  }
}

/**
 * Handler for `mouseover`.
 *
 * @this {MouseSource}
 * @param {MouseEvent} inEvent The in event.
 */
function mouseover(inEvent) {
  if (!this.isEventSimulatedFromTouch_(inEvent)) {
    var e = prepareEvent(inEvent, this.dispatcher);
    this.dispatcher.enterOver(e, inEvent);
  }
}

/**
 * Handler for `mouseout`.
 *
 * @this {MouseSource}
 * @param {MouseEvent} inEvent The in event.
 */
function mouseout(inEvent) {
  if (!this.isEventSimulatedFromTouch_(inEvent)) {
    var e = prepareEvent(inEvent, this.dispatcher);
    this.dispatcher.leaveOut(e, inEvent);
  }
}


var MouseSource = /*@__PURE__*/(function (EventSource) {
  function MouseSource(dispatcher) {
    var mapping = {
      'mousedown': mousedown,
      'mousemove': mousemove,
      'mouseup': mouseup,
      'mouseover': mouseover,
      'mouseout': mouseout
    };
    EventSource.call(this, dispatcher, mapping);

    /**
     * @const
     * @type {!Object<string, Event|Object>}
     */
    this.pointerMap = dispatcher.pointerMap;

    /**
     * @const
     * @type {Array<import("../pixel.js").Pixel>}
     */
    this.lastTouches = [];
  }

  if ( EventSource ) MouseSource.__proto__ = EventSource;
  MouseSource.prototype = Object.create( EventSource && EventSource.prototype );
  MouseSource.prototype.constructor = MouseSource;

  /**
   * Detect if a mouse event was simulated from a touch by
   * checking if previously there was a touch event at the
   * same position.
   *
   * FIXME - Known problem with the native Android browser on
   * Samsung GT-I9100 (Android 4.1.2):
   * In case the page is scrolled, this function does not work
   * correctly when a canvas is used (WebGL or canvas renderer).
   * Mouse listeners on canvas elements (for this browser), create
   * two mouse events: One 'good' and one 'bad' one (on other browsers or
   * when a div is used, there is only one event). For the 'bad' one,
   * clientX/clientY and also pageX/pageY are wrong when the page
   * is scrolled. Because of that, this function can not detect if
   * the events were simulated from a touch event. As result, a
   * pointer event at a wrong position is dispatched, which confuses
   * the map interactions.
   * It is unclear, how one can get the correct position for the event
   * or detect that the positions are invalid.
   *
   * @private
   * @param {MouseEvent} inEvent The in event.
   * @return {boolean} True, if the event was generated by a touch.
   */
  MouseSource.prototype.isEventSimulatedFromTouch_ = function isEventSimulatedFromTouch_ (inEvent) {
    var lts = this.lastTouches;
    var x = inEvent.clientX;
    var y = inEvent.clientY;
    for (var i = 0, l = lts.length, t = (void 0); i < l && (t = lts[i]); i++) {
      // simulated mouse events will be swallowed near a primary touchend
      var dx = Math.abs(x - t[0]);
      var dy = Math.abs(y - t[1]);
      if (dx <= DEDUP_DIST && dy <= DEDUP_DIST) {
        return true;
      }
    }
    return false;
  };

  /**
   * Dispatches a `pointercancel` event.
   *
   * @param {Event} inEvent The in event.
   */
  MouseSource.prototype.cancel = function cancel (inEvent) {
    var e = prepareEvent(inEvent, this.dispatcher);
    this.dispatcher.cancel(e, inEvent);
    this.cleanupMouse();
  };

  /**
   * Remove the mouse from the list of active pointers.
   */
  MouseSource.prototype.cleanupMouse = function cleanupMouse () {
    delete this.pointerMap[POINTER_ID.toString()];
  };

  return MouseSource;
}(_EventSource_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/**
 * Creates a copy of the original event that will be used
 * for the fake pointer event.
 *
 * @param {Event} inEvent The in event.
 * @param {import("./PointerEventHandler.js").default} dispatcher Event handler.
 * @return {Object} The copied event.
 */
function prepareEvent(inEvent, dispatcher) {
  var e = dispatcher.cloneEvent(inEvent, inEvent);

  // forward mouse preventDefault
  var pd = e.preventDefault;
  e.preventDefault = function() {
    inEvent.preventDefault();
    pd();
  };

  e.pointerId = POINTER_ID;
  e.isPrimary = true;
  e.pointerType = POINTER_TYPE;

  return e;
}


/* harmony default export */ __webpack_exports__["default"] = (MouseSource);

//# sourceMappingURL=MouseSource.js.map

/***/ }),

/***/ "./node_modules/ol/pointer/MsSource.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/pointer/MsSource.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _EventSource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EventSource.js */ "./node_modules/ol/pointer/EventSource.js");
/**
 * @module ol/pointer/MsSource
 */
// Based on https://github.com/Polymer/PointerEvents

// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.




/**
 * @const
 * @type {Array<string>}
 */
var POINTER_TYPES = [
  '',
  'unavailable',
  'touch',
  'pen',
  'mouse'
];

/**
 * Handler for `msPointerDown`.
 *
 * @this {MsSource}
 * @param {MSPointerEvent} inEvent The in event.
 */
function msPointerDown(inEvent) {
  this.pointerMap[inEvent.pointerId.toString()] = inEvent;
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.down(e, inEvent);
}

/**
 * Handler for `msPointerMove`.
 *
 * @this {MsSource}
 * @param {MSPointerEvent} inEvent The in event.
 */
function msPointerMove(inEvent) {
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.move(e, inEvent);
}

/**
 * Handler for `msPointerUp`.
 *
 * @this {MsSource}
 * @param {MSPointerEvent} inEvent The in event.
 */
function msPointerUp(inEvent) {
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.up(e, inEvent);
  this.cleanup(inEvent.pointerId);
}

/**
 * Handler for `msPointerOut`.
 *
 * @this {MsSource}
 * @param {MSPointerEvent} inEvent The in event.
 */
function msPointerOut(inEvent) {
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.leaveOut(e, inEvent);
}

/**
 * Handler for `msPointerOver`.
 *
 * @this {MsSource}
 * @param {MSPointerEvent} inEvent The in event.
 */
function msPointerOver(inEvent) {
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.enterOver(e, inEvent);
}

/**
 * Handler for `msPointerCancel`.
 *
 * @this {MsSource}
 * @param {MSPointerEvent} inEvent The in event.
 */
function msPointerCancel(inEvent) {
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.cancel(e, inEvent);
  this.cleanup(inEvent.pointerId);
}

/**
 * Handler for `msLostPointerCapture`.
 *
 * @this {MsSource}
 * @param {MSPointerEvent} inEvent The in event.
 */
function msLostPointerCapture(inEvent) {
  var e = this.dispatcher.makeEvent('lostpointercapture', inEvent, inEvent);
  this.dispatcher.dispatchEvent(e);
}

/**
 * Handler for `msGotPointerCapture`.
 *
 * @this {MsSource}
 * @param {MSPointerEvent} inEvent The in event.
 */
function msGotPointerCapture(inEvent) {
  var e = this.dispatcher.makeEvent('gotpointercapture', inEvent, inEvent);
  this.dispatcher.dispatchEvent(e);
}

var MsSource = /*@__PURE__*/(function (EventSource) {
  function MsSource(dispatcher) {
    var mapping = {
      'MSPointerDown': msPointerDown,
      'MSPointerMove': msPointerMove,
      'MSPointerUp': msPointerUp,
      'MSPointerOut': msPointerOut,
      'MSPointerOver': msPointerOver,
      'MSPointerCancel': msPointerCancel,
      'MSGotPointerCapture': msGotPointerCapture,
      'MSLostPointerCapture': msLostPointerCapture
    };
    EventSource.call(this, dispatcher, mapping);

    /**
     * @const
     * @type {!Object<string, MSPointerEvent|Object>}
     */
    this.pointerMap = dispatcher.pointerMap;
  }

  if ( EventSource ) MsSource.__proto__ = EventSource;
  MsSource.prototype = Object.create( EventSource && EventSource.prototype );
  MsSource.prototype.constructor = MsSource;

  /**
   * Creates a copy of the original event that will be used
   * for the fake pointer event.
   *
   * @private
   * @param {MSPointerEvent} inEvent The in event.
   * @return {Object} The copied event.
   */
  MsSource.prototype.prepareEvent_ = function prepareEvent_ (inEvent) {
    /** @type {MSPointerEvent|Object} */
    var e = inEvent;
    if (typeof inEvent.pointerType === 'number') {
      e = this.dispatcher.cloneEvent(inEvent, inEvent);
      e.pointerType = POINTER_TYPES[inEvent.pointerType];
    }

    return e;
  };

  /**
   * Remove this pointer from the list of active pointers.
   * @param {number} pointerId Pointer identifier.
   */
  MsSource.prototype.cleanup = function cleanup (pointerId) {
    delete this.pointerMap[pointerId.toString()];
  };

  return MsSource;
}(_EventSource_js__WEBPACK_IMPORTED_MODULE_0__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (MsSource);

//# sourceMappingURL=MsSource.js.map

/***/ }),

/***/ "./node_modules/ol/pointer/NativeSource.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/pointer/NativeSource.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _EventSource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EventSource.js */ "./node_modules/ol/pointer/EventSource.js");
/**
 * @module ol/pointer/NativeSource
 */

// Based on https://github.com/Polymer/PointerEvents

// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.



/**
 * Handler for `pointerdown`.
 *
 * @this {NativeSource}
 * @param {Event} inEvent The in event.
 */
function pointerDown(inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
}

/**
 * Handler for `pointermove`.
 *
 * @this {NativeSource}
 * @param {Event} inEvent The in event.
 */
function pointerMove(inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
}

/**
 * Handler for `pointerup`.
 *
 * @this {NativeSource}
 * @param {Event} inEvent The in event.
 */
function pointerUp(inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
}

/**
 * Handler for `pointerout`.
 *
 * @this {NativeSource}
 * @param {Event} inEvent The in event.
 */
function pointerOut(inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
}

/**
 * Handler for `pointerover`.
 *
 * @this {NativeSource}
 * @param {Event} inEvent The in event.
 */
function pointerOver(inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
}

/**
 * Handler for `pointercancel`.
 *
 * @this {NativeSource}
 * @param {Event} inEvent The in event.
 */
function pointerCancel(inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
}

/**
 * Handler for `lostpointercapture`.
 *
 * @this {NativeSource}
 * @param {Event} inEvent The in event.
 */
function lostPointerCapture(inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
}

/**
 * Handler for `gotpointercapture`.
 *
 * @this {NativeSource}
 * @param {Event} inEvent The in event.
 */
function gotPointerCapture(inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
}

var NativeSource = /*@__PURE__*/(function (EventSource) {
  function NativeSource(dispatcher) {
    var mapping = {
      'pointerdown': pointerDown,
      'pointermove': pointerMove,
      'pointerup': pointerUp,
      'pointerout': pointerOut,
      'pointerover': pointerOver,
      'pointercancel': pointerCancel,
      'gotpointercapture': gotPointerCapture,
      'lostpointercapture': lostPointerCapture
    };
    EventSource.call(this, dispatcher, mapping);
  }

  if ( EventSource ) NativeSource.__proto__ = EventSource;
  NativeSource.prototype = Object.create( EventSource && EventSource.prototype );
  NativeSource.prototype.constructor = NativeSource;

  return NativeSource;
}(_EventSource_js__WEBPACK_IMPORTED_MODULE_0__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (NativeSource);

//# sourceMappingURL=NativeSource.js.map

/***/ }),

/***/ "./node_modules/ol/pointer/PointerEvent.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/pointer/PointerEvent.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/**
 * @module ol/pointer/PointerEvent
 */

// Based on https://github.com/Polymer/PointerEvents

// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.




/**
 * Is the `buttons` property supported?
 * @type {boolean}
 */
var HAS_BUTTONS = false;


var PointerEvent = /*@__PURE__*/(function (_Event) {
  function PointerEvent(type, originalEvent, opt_eventDict) {
    _Event.call(this, type);

    /**
     * @const
     * @type {Event}
     */
    this.originalEvent = originalEvent;

    var eventDict = opt_eventDict ? opt_eventDict : {};

    /**
     * @type {number}
     */
    this.buttons = getButtons(eventDict);

    /**
     * @type {number}
     */
    this.pressure = getPressure(eventDict, this.buttons);

    // MouseEvent related properties

    /**
     * @type {boolean}
     */
    this.bubbles = 'bubbles' in eventDict ? eventDict['bubbles'] : false;

    /**
     * @type {boolean}
     */
    this.cancelable = 'cancelable' in eventDict ? eventDict['cancelable'] : false;

    /**
     * @type {Object}
     */
    this.view = 'view' in eventDict ? eventDict['view'] : null;

    /**
     * @type {number}
     */
    this.detail = 'detail' in eventDict ? eventDict['detail'] : null;

    /**
     * @type {number}
     */
    this.screenX = 'screenX' in eventDict ? eventDict['screenX'] : 0;

    /**
     * @type {number}
     */
    this.screenY = 'screenY' in eventDict ? eventDict['screenY'] : 0;

    /**
     * @type {number}
     */
    this.clientX = 'clientX' in eventDict ? eventDict['clientX'] : 0;

    /**
     * @type {number}
     */
    this.clientY = 'clientY' in eventDict ? eventDict['clientY'] : 0;

    /**
     * @type {boolean}
     */
    this.ctrlKey = 'ctrlKey' in eventDict ? eventDict['ctrlKey'] : false;

    /**
     * @type {boolean}
     */
    this.altKey = 'altKey' in eventDict ? eventDict['altKey'] : false;

    /**
     * @type {boolean}
     */
    this.shiftKey = 'shiftKey' in eventDict ? eventDict['shiftKey'] : false;

    /**
     * @type {boolean}
     */
    this.metaKey = 'metaKey' in eventDict ? eventDict['metaKey'] : false;

    /**
     * @type {number}
     */
    this.button = 'button' in eventDict ? eventDict['button'] : 0;

    /**
     * @type {Node}
     */
    this.relatedTarget = 'relatedTarget' in eventDict ?
      eventDict['relatedTarget'] : null;

    // PointerEvent related properties

    /**
     * @const
     * @type {number}
     */
    this.pointerId = 'pointerId' in eventDict ? eventDict['pointerId'] : 0;

    /**
     * @type {number}
     */
    this.width = 'width' in eventDict ? eventDict['width'] : 0;

    /**
     * @type {number}
     */
    this.height = 'height' in eventDict ? eventDict['height'] : 0;

    /**
     * @type {number}
     */
    this.tiltX = 'tiltX' in eventDict ? eventDict['tiltX'] : 0;

    /**
     * @type {number}
     */
    this.tiltY = 'tiltY' in eventDict ? eventDict['tiltY'] : 0;

    /**
     * @type {string}
     */
    this.pointerType = 'pointerType' in eventDict ? eventDict['pointerType'] : '';

    /**
     * @type {number}
     */
    this.hwTimestamp = 'hwTimestamp' in eventDict ? eventDict['hwTimestamp'] : 0;

    /**
     * @type {boolean}
     */
    this.isPrimary = 'isPrimary' in eventDict ? eventDict['isPrimary'] : false;

    // keep the semantics of preventDefault
    if (originalEvent.preventDefault) {
      this.preventDefault = function() {
        originalEvent.preventDefault();
      };
    }
  }

  if ( _Event ) PointerEvent.__proto__ = _Event;
  PointerEvent.prototype = Object.create( _Event && _Event.prototype );
  PointerEvent.prototype.constructor = PointerEvent;

  return PointerEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/**
 * @param {Object<string, ?>} eventDict The event dictionary.
 * @return {number} Button indicator.
 */
function getButtons(eventDict) {
  // According to the w3c spec,
  // http://www.w3.org/TR/DOM-Level-3-Events/#events-MouseEvent-button
  // MouseEvent.button == 0 can mean either no mouse button depressed, or the
  // left mouse button depressed.
  //
  // As of now, the only way to distinguish between the two states of
  // MouseEvent.button is by using the deprecated MouseEvent.which property, as
  // this maps mouse buttons to positive integers > 0, and uses 0 to mean that
  // no mouse button is held.
  //
  // MouseEvent.which is derived from MouseEvent.button at MouseEvent creation,
  // but initMouseEvent does not expose an argument with which to set
  // MouseEvent.which. Calling initMouseEvent with a buttonArg of 0 will set
  // MouseEvent.button == 0 and MouseEvent.which == 1, breaking the expectations
  // of app developers.
  //
  // The only way to propagate the correct state of MouseEvent.which and
  // MouseEvent.button to a new MouseEvent.button == 0 and MouseEvent.which == 0
  // is to call initMouseEvent with a buttonArg value of -1.
  //
  // This is fixed with DOM Level 4's use of buttons
  var buttons;
  if (eventDict.buttons || HAS_BUTTONS) {
    buttons = eventDict.buttons;
  } else {
    switch (eventDict.which) {
      case 1: buttons = 1; break;
      case 2: buttons = 4; break;
      case 3: buttons = 2; break;
      default: buttons = 0;
    }
  }
  return buttons;
}


/**
 * @param {Object<string, ?>} eventDict The event dictionary.
 * @param {number} buttons Button indicator.
 * @return {number} The pressure.
 */
function getPressure(eventDict, buttons) {
  // Spec requires that pointers without pressure specified use 0.5 for down
  // state and 0 for up state.
  var pressure = 0;
  if (eventDict.pressure) {
    pressure = eventDict.pressure;
  } else {
    pressure = buttons ? 0.5 : 0;
  }
  return pressure;
}


/**
 * Checks if the `buttons` property is supported.
 */
(function() {
  try {
    var ev = new MouseEvent('click', {buttons: 1});
    HAS_BUTTONS = ev.buttons === 1;
  } catch (e) {
    // pass
  }
})();

/* harmony default export */ __webpack_exports__["default"] = (PointerEvent);

//# sourceMappingURL=PointerEvent.js.map

/***/ }),

/***/ "./node_modules/ol/pointer/PointerEventHandler.js":
/*!********************************************************!*\
  !*** ./node_modules/ol/pointer/PointerEventHandler.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/Target.js */ "./node_modules/ol/events/Target.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EventType.js */ "./node_modules/ol/pointer/EventType.js");
/* harmony import */ var _MouseSource_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MouseSource.js */ "./node_modules/ol/pointer/MouseSource.js");
/* harmony import */ var _MsSource_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./MsSource.js */ "./node_modules/ol/pointer/MsSource.js");
/* harmony import */ var _NativeSource_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./NativeSource.js */ "./node_modules/ol/pointer/NativeSource.js");
/* harmony import */ var _PointerEvent_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./PointerEvent.js */ "./node_modules/ol/pointer/PointerEvent.js");
/* harmony import */ var _TouchSource_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./TouchSource.js */ "./node_modules/ol/pointer/TouchSource.js");
/**
 * @module ol/pointer/PointerEventHandler
 */

// Based on https://github.com/Polymer/PointerEvents

// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.












/**
 * Properties to copy when cloning an event, with default values.
 * @type {Array<Array>}
 */
var CLONE_PROPS = [
  // MouseEvent
  ['bubbles', false],
  ['cancelable', false],
  ['view', null],
  ['detail', null],
  ['screenX', 0],
  ['screenY', 0],
  ['clientX', 0],
  ['clientY', 0],
  ['ctrlKey', false],
  ['altKey', false],
  ['shiftKey', false],
  ['metaKey', false],
  ['button', 0],
  ['relatedTarget', null],
  // DOM Level 3
  ['buttons', 0],
  // PointerEvent
  ['pointerId', 0],
  ['width', 0],
  ['height', 0],
  ['pressure', 0],
  ['tiltX', 0],
  ['tiltY', 0],
  ['pointerType', ''],
  ['hwTimestamp', 0],
  ['isPrimary', false],
  // event instance
  ['type', ''],
  ['target', null],
  ['currentTarget', null],
  ['which', 0]
];


var PointerEventHandler = /*@__PURE__*/(function (EventTarget) {
  function PointerEventHandler(element) {
    EventTarget.call(this);

    /**
     * @const
     * @private
     * @type {Element|HTMLDocument}
     */
    this.element_ = element;

    /**
     * @const
     * @type {!Object<string, Event|Object>}
     */
    this.pointerMap = {};

    /**
     * @type {Object<string, function(Event)>}
     * @private
     */
    this.eventMap_ = {};

    /**
     * @type {Array<import("./EventSource.js").default>}
     * @private
     */
    this.eventSourceList_ = [];

    this.registerSources();
  }

  if ( EventTarget ) PointerEventHandler.__proto__ = EventTarget;
  PointerEventHandler.prototype = Object.create( EventTarget && EventTarget.prototype );
  PointerEventHandler.prototype.constructor = PointerEventHandler;

  /**
   * Set up the event sources (mouse, touch and native pointers)
   * that generate pointer events.
   */
  PointerEventHandler.prototype.registerSources = function registerSources () {
    if (_has_js__WEBPACK_IMPORTED_MODULE_2__["POINTER"]) {
      this.registerSource('native', new _NativeSource_js__WEBPACK_IMPORTED_MODULE_6__["default"](this));
    } else if (_has_js__WEBPACK_IMPORTED_MODULE_2__["MSPOINTER"]) {
      this.registerSource('ms', new _MsSource_js__WEBPACK_IMPORTED_MODULE_5__["default"](this));
    } else {
      var mouseSource = new _MouseSource_js__WEBPACK_IMPORTED_MODULE_4__["default"](this);
      this.registerSource('mouse', mouseSource);

      if (_has_js__WEBPACK_IMPORTED_MODULE_2__["TOUCH"]) {
        this.registerSource('touch', new _TouchSource_js__WEBPACK_IMPORTED_MODULE_8__["default"](this, mouseSource));
      }
    }

    // register events on the viewport element
    this.register_();
  };

  /**
   * Add a new event source that will generate pointer events.
   *
   * @param {string} name A name for the event source
   * @param {import("./EventSource.js").default} source The source event.
   */
  PointerEventHandler.prototype.registerSource = function registerSource (name, source) {
    var s = source;
    var newEvents = s.getEvents();

    if (newEvents) {
      newEvents.forEach(function(e) {
        var handler = s.getHandlerForEvent(e);

        if (handler) {
          this.eventMap_[e] = handler.bind(s);
        }
      }.bind(this));
      this.eventSourceList_.push(s);
    }
  };

  /**
   * Set up the events for all registered event sources.
   * @private
   */
  PointerEventHandler.prototype.register_ = function register_ () {
    var l = this.eventSourceList_.length;
    for (var i = 0; i < l; i++) {
      var eventSource = this.eventSourceList_[i];
      this.addEvents_(eventSource.getEvents());
    }
  };

  /**
   * Remove all registered events.
   * @private
   */
  PointerEventHandler.prototype.unregister_ = function unregister_ () {
    var l = this.eventSourceList_.length;
    for (var i = 0; i < l; i++) {
      var eventSource = this.eventSourceList_[i];
      this.removeEvents_(eventSource.getEvents());
    }
  };

  /**
   * Calls the right handler for a new event.
   * @private
   * @param {Event} inEvent Browser event.
   */
  PointerEventHandler.prototype.eventHandler_ = function eventHandler_ (inEvent) {
    var type = inEvent.type;
    var handler = this.eventMap_[type];
    if (handler) {
      handler(inEvent);
    }
  };

  /**
   * Setup listeners for the given events.
   * @private
   * @param {Array<string>} events List of events.
   */
  PointerEventHandler.prototype.addEvents_ = function addEvents_ (events) {
    events.forEach(function(eventName) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listen"])(this.element_, eventName, this.eventHandler_, this);
    }.bind(this));
  };

  /**
   * Unregister listeners for the given events.
   * @private
   * @param {Array<string>} events List of events.
   */
  PointerEventHandler.prototype.removeEvents_ = function removeEvents_ (events) {
    events.forEach(function(e) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["unlisten"])(this.element_, e, this.eventHandler_, this);
    }.bind(this));
  };

  /**
   * Returns a snapshot of inEvent, with writable properties.
   *
   * @param {Event} event Browser event.
   * @param {Event|Touch} inEvent An event that contains
   *    properties to copy.
   * @return {Object} An object containing shallow copies of
   *    `inEvent`'s properties.
   */
  PointerEventHandler.prototype.cloneEvent = function cloneEvent (event, inEvent) {
    var eventCopy = {};
    for (var i = 0, ii = CLONE_PROPS.length; i < ii; i++) {
      var p = CLONE_PROPS[i][0];
      eventCopy[p] = event[p] || inEvent[p] || CLONE_PROPS[i][1];
    }

    return eventCopy;
  };

  // EVENTS


  /**
   * Triggers a 'pointerdown' event.
   * @param {Object} data Pointer event data.
   * @param {Event} event The event.
   */
  PointerEventHandler.prototype.down = function down (data, event) {
    this.fireEvent(_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POINTERDOWN, data, event);
  };

  /**
   * Triggers a 'pointermove' event.
   * @param {Object} data Pointer event data.
   * @param {Event} event The event.
   */
  PointerEventHandler.prototype.move = function move (data, event) {
    this.fireEvent(_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POINTERMOVE, data, event);
  };

  /**
   * Triggers a 'pointerup' event.
   * @param {Object} data Pointer event data.
   * @param {Event} event The event.
   */
  PointerEventHandler.prototype.up = function up (data, event) {
    this.fireEvent(_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POINTERUP, data, event);
  };

  /**
   * Triggers a 'pointerenter' event.
   * @param {Object} data Pointer event data.
   * @param {Event} event The event.
   */
  PointerEventHandler.prototype.enter = function enter (data, event) {
    data.bubbles = false;
    this.fireEvent(_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POINTERENTER, data, event);
  };

  /**
   * Triggers a 'pointerleave' event.
   * @param {Object} data Pointer event data.
   * @param {Event} event The event.
   */
  PointerEventHandler.prototype.leave = function leave (data, event) {
    data.bubbles = false;
    this.fireEvent(_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POINTERLEAVE, data, event);
  };

  /**
   * Triggers a 'pointerover' event.
   * @param {Object} data Pointer event data.
   * @param {Event} event The event.
   */
  PointerEventHandler.prototype.over = function over (data, event) {
    data.bubbles = true;
    this.fireEvent(_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POINTEROVER, data, event);
  };

  /**
   * Triggers a 'pointerout' event.
   * @param {Object} data Pointer event data.
   * @param {Event} event The event.
   */
  PointerEventHandler.prototype.out = function out (data, event) {
    data.bubbles = true;
    this.fireEvent(_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POINTEROUT, data, event);
  };

  /**
   * Triggers a 'pointercancel' event.
   * @param {Object} data Pointer event data.
   * @param {Event} event The event.
   */
  PointerEventHandler.prototype.cancel = function cancel (data, event) {
    this.fireEvent(_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POINTERCANCEL, data, event);
  };

  /**
   * Triggers a combination of 'pointerout' and 'pointerleave' events.
   * @param {Object} data Pointer event data.
   * @param {Event} event The event.
   */
  PointerEventHandler.prototype.leaveOut = function leaveOut (data, event) {
    this.out(data, event);
    if (!this.contains_(data.target, data.relatedTarget)) {
      this.leave(data, event);
    }
  };

  /**
   * Triggers a combination of 'pointerover' and 'pointerevents' events.
   * @param {Object} data Pointer event data.
   * @param {Event} event The event.
   */
  PointerEventHandler.prototype.enterOver = function enterOver (data, event) {
    this.over(data, event);
    if (!this.contains_(data.target, data.relatedTarget)) {
      this.enter(data, event);
    }
  };

  /**
   * @private
   * @param {Element} container The container element.
   * @param {Element} contained The contained element.
   * @return {boolean} Returns true if the container element
   *   contains the other element.
   */
  PointerEventHandler.prototype.contains_ = function contains_ (container, contained) {
    if (!container || !contained) {
      return false;
    }
    return container.contains(contained);
  };

  // EVENT CREATION AND TRACKING
  /**
   * Creates a new Event of type `inType`, based on the information in
   * `data`.
   *
   * @param {string} inType A string representing the type of event to create.
   * @param {Object} data Pointer event data.
   * @param {Event} event The event.
   * @return {PointerEvent} A PointerEvent of type `inType`.
   */
  PointerEventHandler.prototype.makeEvent = function makeEvent (inType, data, event) {
    return new _PointerEvent_js__WEBPACK_IMPORTED_MODULE_7__["default"](inType, event, data);
  };

  /**
   * Make and dispatch an event in one call.
   * @param {string} inType A string representing the type of event.
   * @param {Object} data Pointer event data.
   * @param {Event} event The event.
   */
  PointerEventHandler.prototype.fireEvent = function fireEvent (inType, data, event) {
    var e = this.makeEvent(inType, data, event);
    this.dispatchEvent(e);
  };

  /**
   * Creates a pointer event from a native pointer event
   * and dispatches this event.
   * @param {Event} event A platform event with a target.
   */
  PointerEventHandler.prototype.fireNativeEvent = function fireNativeEvent (event) {
    var e = this.makeEvent(event.type, event, event);
    this.dispatchEvent(e);
  };

  /**
   * Wrap a native mouse event into a pointer event.
   * This proxy method is required for the legacy IE support.
   * @param {string} eventType The pointer event type.
   * @param {Event} event The event.
   * @return {PointerEvent} The wrapped event.
   */
  PointerEventHandler.prototype.wrapMouseEvent = function wrapMouseEvent (eventType, event) {
    var pointerEvent = this.makeEvent(
      eventType, Object(_MouseSource_js__WEBPACK_IMPORTED_MODULE_4__["prepareEvent"])(event, this), event);
    return pointerEvent;
  };

  /**
   * @inheritDoc
   */
  PointerEventHandler.prototype.disposeInternal = function disposeInternal () {
    this.unregister_();
    EventTarget.prototype.disposeInternal.call(this);
  };

  return PointerEventHandler;
}(_events_Target_js__WEBPACK_IMPORTED_MODULE_1__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (PointerEventHandler);

//# sourceMappingURL=PointerEventHandler.js.map

/***/ }),

/***/ "./node_modules/ol/pointer/TouchSource.js":
/*!************************************************!*\
  !*** ./node_modules/ol/pointer/TouchSource.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _EventSource_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EventSource.js */ "./node_modules/ol/pointer/EventSource.js");
/* harmony import */ var _MouseSource_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MouseSource.js */ "./node_modules/ol/pointer/MouseSource.js");
/**
 * @module ol/pointer/TouchSource
 */

// Based on https://github.com/Polymer/PointerEvents

// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.






/**
 * @type {number}
 */
var CLICK_COUNT_TIMEOUT = 200;

/**
 * @type {string}
 */
var POINTER_TYPE = 'touch';

/**
 * Handler for `touchstart`, triggers `pointerover`,
 * `pointerenter` and `pointerdown` events.
 *
 * @this {TouchSource}
 * @param {TouchEvent} inEvent The in event.
 */
function touchstart(inEvent) {
  this.vacuumTouches_(inEvent);
  this.setPrimaryTouch_(inEvent.changedTouches[0]);
  this.dedupSynthMouse_(inEvent);
  this.clickCount_++;
  this.processTouches_(inEvent, this.overDown_);
}

/**
 * Handler for `touchmove`.
 *
 * @this {TouchSource}
 * @param {TouchEvent} inEvent The in event.
 */
function touchmove(inEvent) {
  this.processTouches_(inEvent, this.moveOverOut_);
}

/**
 * Handler for `touchend`, triggers `pointerup`,
 * `pointerout` and `pointerleave` events.
 *
 * @this {TouchSource}
 * @param {TouchEvent} inEvent The event.
 */
function touchend(inEvent) {
  this.dedupSynthMouse_(inEvent);
  this.processTouches_(inEvent, this.upOut_);
}

/**
 * Handler for `touchcancel`, triggers `pointercancel`,
 * `pointerout` and `pointerleave` events.
 *
 * @this {TouchSource}
 * @param {TouchEvent} inEvent The in event.
 */
function touchcancel(inEvent) {
  this.processTouches_(inEvent, this.cancelOut_);
}


var TouchSource = /*@__PURE__*/(function (EventSource) {
  function TouchSource(dispatcher, mouseSource) {
    var mapping = {
      'touchstart': touchstart,
      'touchmove': touchmove,
      'touchend': touchend,
      'touchcancel': touchcancel
    };
    EventSource.call(this, dispatcher, mapping);

    /**
     * @const
     * @type {!Object<string, Event|Object>}
     */
    this.pointerMap = dispatcher.pointerMap;

    /**
     * @const
     * @type {import("./MouseSource.js").default}
     */
    this.mouseSource = mouseSource;

    /**
     * @private
     * @type {number|undefined}
     */
    this.firstTouchId_ = undefined;

    /**
     * @private
     * @type {number}
     */
    this.clickCount_ = 0;

    /**
     * @private
     * @type {?}
     */
    this.resetId_;

    /**
     * Mouse event timeout: This should be long enough to
     * ignore compat mouse events made by touch.
     * @private
     * @type {number}
     */
    this.dedupTimeout_ = 2500;
  }

  if ( EventSource ) TouchSource.__proto__ = EventSource;
  TouchSource.prototype = Object.create( EventSource && EventSource.prototype );
  TouchSource.prototype.constructor = TouchSource;

  /**
   * @private
   * @param {Touch} inTouch The in touch.
   * @return {boolean} True, if this is the primary touch.
   */
  TouchSource.prototype.isPrimaryTouch_ = function isPrimaryTouch_ (inTouch) {
    return this.firstTouchId_ === inTouch.identifier;
  };

  /**
   * Set primary touch if there are no pointers, or the only pointer is the mouse.
   * @param {Touch} inTouch The in touch.
   * @private
   */
  TouchSource.prototype.setPrimaryTouch_ = function setPrimaryTouch_ (inTouch) {
    var count = Object.keys(this.pointerMap).length;
    if (count === 0 || (count === 1 && _MouseSource_js__WEBPACK_IMPORTED_MODULE_2__["POINTER_ID"].toString() in this.pointerMap)) {
      this.firstTouchId_ = inTouch.identifier;
      this.cancelResetClickCount_();
    }
  };

  /**
   * @private
   * @param {PointerEvent} inPointer The in pointer object.
   */
  TouchSource.prototype.removePrimaryPointer_ = function removePrimaryPointer_ (inPointer) {
    if (inPointer.isPrimary) {
      this.firstTouchId_ = undefined;
      this.resetClickCount_();
    }
  };

  /**
   * @private
   */
  TouchSource.prototype.resetClickCount_ = function resetClickCount_ () {
    this.resetId_ = setTimeout(
      this.resetClickCountHandler_.bind(this),
      CLICK_COUNT_TIMEOUT);
  };

  /**
   * @private
   */
  TouchSource.prototype.resetClickCountHandler_ = function resetClickCountHandler_ () {
    this.clickCount_ = 0;
    this.resetId_ = undefined;
  };

  /**
   * @private
   */
  TouchSource.prototype.cancelResetClickCount_ = function cancelResetClickCount_ () {
    if (this.resetId_ !== undefined) {
      clearTimeout(this.resetId_);
    }
  };

  /**
   * @private
   * @param {TouchEvent} browserEvent Browser event
   * @param {Touch} inTouch Touch event
   * @return {PointerEvent} A pointer object.
   */
  TouchSource.prototype.touchToPointer_ = function touchToPointer_ (browserEvent, inTouch) {
    var e = this.dispatcher.cloneEvent(browserEvent, inTouch);
    // Spec specifies that pointerId 1 is reserved for Mouse.
    // Touch identifiers can start at 0.
    // Add 2 to the touch identifier for compatibility.
    e.pointerId = inTouch.identifier + 2;
    // TODO: check if this is necessary?
    //e.target = findTarget(e);
    e.bubbles = true;
    e.cancelable = true;
    e.detail = this.clickCount_;
    e.button = 0;
    e.buttons = 1;
    e.width = inTouch.radiusX || 0;
    e.height = inTouch.radiusY || 0;
    e.pressure = inTouch.force || 0.5;
    e.isPrimary = this.isPrimaryTouch_(inTouch);
    e.pointerType = POINTER_TYPE;

    // make sure that the properties that are different for
    // each `Touch` object are not copied from the BrowserEvent object
    e.clientX = inTouch.clientX;
    e.clientY = inTouch.clientY;
    e.screenX = inTouch.screenX;
    e.screenY = inTouch.screenY;

    return e;
  };

  /**
   * @private
   * @param {TouchEvent} inEvent Touch event
   * @param {function(TouchEvent, PointerEvent)} inFunction In function.
   */
  TouchSource.prototype.processTouches_ = function processTouches_ (inEvent, inFunction) {
    var touches = Array.prototype.slice.call(inEvent.changedTouches);
    var count = touches.length;
    function preventDefault() {
      inEvent.preventDefault();
    }
    for (var i = 0; i < count; ++i) {
      var pointer = this.touchToPointer_(inEvent, touches[i]);
      // forward touch preventDefaults
      pointer.preventDefault = preventDefault;
      inFunction.call(this, inEvent, pointer);
    }
  };

  /**
   * @private
   * @param {TouchList} touchList The touch list.
   * @param {number} searchId Search identifier.
   * @return {boolean} True, if the `Touch` with the given id is in the list.
   */
  TouchSource.prototype.findTouch_ = function findTouch_ (touchList, searchId) {
    var l = touchList.length;
    for (var i = 0; i < l; i++) {
      var touch = touchList[i];
      if (touch.identifier === searchId) {
        return true;
      }
    }
    return false;
  };

  /**
   * In some instances, a touchstart can happen without a touchend. This
   * leaves the pointermap in a broken state.
   * Therefore, on every touchstart, we remove the touches that did not fire a
   * touchend event.
   * To keep state globally consistent, we fire a pointercancel for
   * this "abandoned" touch
   *
   * @private
   * @param {TouchEvent} inEvent The in event.
   */
  TouchSource.prototype.vacuumTouches_ = function vacuumTouches_ (inEvent) {
    var touchList = inEvent.touches;
    // pointerMap.getCount() should be < touchList.length here,
    // as the touchstart has not been processed yet.
    var keys = Object.keys(this.pointerMap);
    var count = keys.length;
    if (count >= touchList.length) {
      var d = [];
      for (var i = 0; i < count; ++i) {
        var key = Number(keys[i]);
        var value = this.pointerMap[key];
        // Never remove pointerId == 1, which is mouse.
        // Touch identifiers are 2 smaller than their pointerId, which is the
        // index in pointermap.
        if (key != _MouseSource_js__WEBPACK_IMPORTED_MODULE_2__["POINTER_ID"] && !this.findTouch_(touchList, key - 2)) {
          d.push(value.out);
        }
      }
      for (var i$1 = 0; i$1 < d.length; ++i$1) {
        this.cancelOut_(inEvent, d[i$1]);
      }
    }
  };

  /**
   * @private
   * @param {TouchEvent} browserEvent The event.
   * @param {PointerEvent} inPointer The in pointer object.
   */
  TouchSource.prototype.overDown_ = function overDown_ (browserEvent, inPointer) {
    this.pointerMap[inPointer.pointerId] = {
      target: inPointer.target,
      out: inPointer,
      outTarget: inPointer.target
    };
    this.dispatcher.over(inPointer, browserEvent);
    this.dispatcher.enter(inPointer, browserEvent);
    this.dispatcher.down(inPointer, browserEvent);
  };

  /**
   * @private
   * @param {TouchEvent} browserEvent The event.
   * @param {PointerEvent} inPointer The in pointer.
   */
  TouchSource.prototype.moveOverOut_ = function moveOverOut_ (browserEvent, inPointer) {
    var event = inPointer;
    var pointer = this.pointerMap[event.pointerId];
    // a finger drifted off the screen, ignore it
    if (!pointer) {
      return;
    }
    var outEvent = pointer.out;
    var outTarget = pointer.outTarget;
    this.dispatcher.move(event, browserEvent);
    if (outEvent && outTarget !== event.target) {
      outEvent.relatedTarget = event.target;
      /** @type {Object} */ (event).relatedTarget = outTarget;
      // recover from retargeting by shadow
      outEvent.target = outTarget;
      if (event.target) {
        this.dispatcher.leaveOut(outEvent, browserEvent);
        this.dispatcher.enterOver(event, browserEvent);
      } else {
        // clean up case when finger leaves the screen
        /** @type {Object} */ (event).target = outTarget;
        /** @type {Object} */ (event).relatedTarget = null;
        this.cancelOut_(browserEvent, event);
      }
    }
    pointer.out = event;
    pointer.outTarget = event.target;
  };

  /**
   * @private
   * @param {TouchEvent} browserEvent An event.
   * @param {PointerEvent} inPointer The inPointer object.
   */
  TouchSource.prototype.upOut_ = function upOut_ (browserEvent, inPointer) {
    this.dispatcher.up(inPointer, browserEvent);
    this.dispatcher.out(inPointer, browserEvent);
    this.dispatcher.leave(inPointer, browserEvent);
    this.cleanUpPointer_(inPointer);
  };

  /**
   * @private
   * @param {TouchEvent} browserEvent The event.
   * @param {PointerEvent} inPointer The in pointer.
   */
  TouchSource.prototype.cancelOut_ = function cancelOut_ (browserEvent, inPointer) {
    this.dispatcher.cancel(inPointer, browserEvent);
    this.dispatcher.out(inPointer, browserEvent);
    this.dispatcher.leave(inPointer, browserEvent);
    this.cleanUpPointer_(inPointer);
  };

  /**
   * @private
   * @param {PointerEvent} inPointer The inPointer object.
   */
  TouchSource.prototype.cleanUpPointer_ = function cleanUpPointer_ (inPointer) {
    delete this.pointerMap[inPointer.pointerId];
    this.removePrimaryPointer_(inPointer);
  };

  /**
   * Prevent synth mouse events from creating pointer events.
   *
   * @private
   * @param {TouchEvent} inEvent The in event.
   */
  TouchSource.prototype.dedupSynthMouse_ = function dedupSynthMouse_ (inEvent) {
    var lts = this.mouseSource.lastTouches;
    var t = inEvent.changedTouches[0];
    // only the primary finger will synth mouse events
    if (this.isPrimaryTouch_(t)) {
      // remember x/y of last touch
      var lt = [t.clientX, t.clientY];
      lts.push(lt);

      setTimeout(function() {
        // remove touch after timeout
        Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["remove"])(lts, lt);
      }, this.dedupTimeout_);
    }
  };

  return TouchSource;
}(_EventSource_js__WEBPACK_IMPORTED_MODULE_1__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (TouchSource);

//# sourceMappingURL=TouchSource.js.map

/***/ }),

/***/ "./node_modules/ol/proj.js":
/*!*********************************!*\
  !*** ./node_modules/ol/proj.js ***!
  \*********************************/
/*! exports provided: METERS_PER_UNIT, Projection, cloneTransform, identityTransform, addProjection, addProjections, get, getPointResolution, addEquivalentProjections, addEquivalentTransforms, clearAllProjections, createProjection, createTransformFromCoordinateTransform, addCoordinateTransforms, fromLonLat, toLonLat, equivalent, getTransformFromProjections, getTransform, transform, transformExtent, transformWithProjections, addCommon */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cloneTransform", function() { return cloneTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identityTransform", function() { return identityTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addProjection", function() { return addProjection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addProjections", function() { return addProjections; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return get; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPointResolution", function() { return getPointResolution; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addEquivalentProjections", function() { return addEquivalentProjections; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addEquivalentTransforms", function() { return addEquivalentTransforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clearAllProjections", function() { return clearAllProjections; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createProjection", function() { return createProjection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createTransformFromCoordinateTransform", function() { return createTransformFromCoordinateTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addCoordinateTransforms", function() { return addCoordinateTransforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromLonLat", function() { return fromLonLat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toLonLat", function() { return toLonLat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equivalent", function() { return equivalent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTransformFromProjections", function() { return getTransformFromProjections; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTransform", function() { return getTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transform", function() { return transform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformExtent", function() { return transformExtent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformWithProjections", function() { return transformWithProjections; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addCommon", function() { return addCommon; });
/* harmony import */ var _sphere_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sphere.js */ "./node_modules/ol/sphere.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./proj/epsg3857.js */ "./node_modules/ol/proj/epsg3857.js");
/* harmony import */ var _proj_epsg4326_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./proj/epsg4326.js */ "./node_modules/ol/proj/epsg4326.js");
/* harmony import */ var _proj_Projection_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./proj/Projection.js */ "./node_modules/ol/proj/Projection.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Projection", function() { return _proj_Projection_js__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _proj_Units_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./proj/Units.js */ "./node_modules/ol/proj/Units.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "METERS_PER_UNIT", function() { return _proj_Units_js__WEBPACK_IMPORTED_MODULE_6__["METERS_PER_UNIT"]; });

/* harmony import */ var _proj_projections_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./proj/projections.js */ "./node_modules/ol/proj/projections.js");
/* harmony import */ var _proj_transforms_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./proj/transforms.js */ "./node_modules/ol/proj/transforms.js");
/**
 * @module ol/proj
 */

/**
 * The ol/proj module stores:
 * * a list of {@link module:ol/proj/Projection}
 * objects, one for each projection supported by the application
 * * a list of transform functions needed to convert coordinates in one projection
 * into another.
 *
 * The static functions are the methods used to maintain these.
 * Each transform function can handle not only simple coordinate pairs, but also
 * large arrays of coordinates such as vector geometries.
 *
 * When loaded, the library adds projection objects for EPSG:4326 (WGS84
 * geographic coordinates) and EPSG:3857 (Web or Spherical Mercator, as used
 * for example by Bing Maps or OpenStreetMap), together with the relevant
 * transform functions.
 *
 * Additional transforms may be added by using the http://proj4js.org/
 * library (version 2.2 or later). You can use the full build supplied by
 * Proj4js, or create a custom build to support those projections you need; see
 * the Proj4js website for how to do this. You also need the Proj4js definitions
 * for the required projections. These definitions can be obtained from
 * https://epsg.io/, and are a JS function, so can be loaded in a script
 * tag (as in the examples) or pasted into your application.
 *
 * After all required projection definitions are added to proj4's registry (by
 * using `proj4.defs()`), simply call `register(proj4)` from the `ol/proj/proj4`
 * package. Existing transforms are not changed by this function. See
 * examples/wms-image-custom-proj for an example of this.
 *
 * Additional projection definitions can be registered with `proj4.defs()` any
 * time. Just make sure to call `register(proj4)` again; for example, with user-supplied data where you don't
 * know in advance what projections are needed, you can initially load minimal
 * support and then load whichever are requested.
 *
 * Note that Proj4js does not support projection extents. If you want to add
 * one for creating default tile grids, you can add it after the Projection
 * object has been created with `setExtent`, for example,
 * `get('EPSG:1234').setExtent(extent)`.
 *
 * In addition to Proj4js support, any transform functions can be added with
 * {@link module:ol/proj~addCoordinateTransforms}. To use this, you must first create
 * a {@link module:ol/proj/Projection} object for the new projection and add it with
 * {@link module:ol/proj~addProjection}. You can then add the forward and inverse
 * functions with {@link module:ol/proj~addCoordinateTransforms}. See
 * examples/wms-custom-proj for an example of this.
 *
 * Note that if no transforms are needed and you only need to define the
 * projection, just add a {@link module:ol/proj/Projection} with
 * {@link module:ol/proj~addProjection}. See examples/wms-no-proj for an example of
 * this.
 */











/**
 * A projection as {@link module:ol/proj/Projection}, SRS identifier
 * string or undefined.
 * @typedef {Projection|string|undefined} ProjectionLike
 * @api
 */


/**
 * A transform function accepts an array of input coordinate values, an optional
 * output array, and an optional dimension (default should be 2).  The function
 * transforms the input coordinate values, populates the output array, and
 * returns the output array.
 *
 * @typedef {function(Array<number>, Array<number>=, number=): Array<number>} TransformFunction
 * @api
 */






/**
 * @param {Array<number>} input Input coordinate array.
 * @param {Array<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension.
 * @return {Array<number>} Output coordinate array (new array, same coordinate
 *     values).
 */
function cloneTransform(input, opt_output, opt_dimension) {
  var output;
  if (opt_output !== undefined) {
    for (var i = 0, ii = input.length; i < ii; ++i) {
      opt_output[i] = input[i];
    }
    output = opt_output;
  } else {
    output = input.slice();
  }
  return output;
}


/**
 * @param {Array<number>} input Input coordinate array.
 * @param {Array<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension.
 * @return {Array<number>} Input coordinate array (same array as input).
 */
function identityTransform(input, opt_output, opt_dimension) {
  if (opt_output !== undefined && input !== opt_output) {
    for (var i = 0, ii = input.length; i < ii; ++i) {
      opt_output[i] = input[i];
    }
    input = opt_output;
  }
  return input;
}


/**
 * Add a Projection object to the list of supported projections that can be
 * looked up by their code.
 *
 * @param {Projection} projection Projection instance.
 * @api
 */
function addProjection(projection) {
  _proj_projections_js__WEBPACK_IMPORTED_MODULE_7__["add"](projection.getCode(), projection);
  Object(_proj_transforms_js__WEBPACK_IMPORTED_MODULE_8__["add"])(projection, projection, cloneTransform);
}


/**
 * @param {Array<Projection>} projections Projections.
 */
function addProjections(projections) {
  projections.forEach(addProjection);
}


/**
 * Fetches a Projection object for the code specified.
 *
 * @param {ProjectionLike} projectionLike Either a code string which is
 *     a combination of authority and identifier such as "EPSG:4326", or an
 *     existing projection object, or undefined.
 * @return {Projection} Projection object, or null if not in list.
 * @api
 */
function get(projectionLike) {
  return typeof projectionLike === 'string' ?
    _proj_projections_js__WEBPACK_IMPORTED_MODULE_7__["get"](/** @type {string} */ (projectionLike)) :
    (/** @type {Projection} */ (projectionLike) || null);
}


/**
 * Get the resolution of the point in degrees or distance units.
 * For projections with degrees as the unit this will simply return the
 * provided resolution. For other projections the point resolution is
 * by default estimated by transforming the 'point' pixel to EPSG:4326,
 * measuring its width and height on the normal sphere,
 * and taking the average of the width and height.
 * A custom function can be provided for a specific projection, either
 * by setting the `getPointResolution` option in the
 * {@link module:ol/proj/Projection~Projection} constructor or by using
 * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing
 * projection object.
 * @param {ProjectionLike} projection The projection.
 * @param {number} resolution Nominal resolution in projection units.
 * @param {import("./coordinate.js").Coordinate} point Point to find adjusted resolution at.
 * @param {Units=} opt_units Units to get the point resolution in.
 * Default is the projection's units.
 * @return {number} Point resolution.
 * @api
 */
function getPointResolution(projection, resolution, point, opt_units) {
  projection = get(projection);
  var pointResolution;
  var getter = projection.getPointResolutionFunc();
  if (getter) {
    pointResolution = getter(resolution, point);
  } else {
    var units = projection.getUnits();
    if (units == _proj_Units_js__WEBPACK_IMPORTED_MODULE_6__["default"].DEGREES && !opt_units || opt_units == _proj_Units_js__WEBPACK_IMPORTED_MODULE_6__["default"].DEGREES) {
      pointResolution = resolution;
    } else {
      // Estimate point resolution by transforming the center pixel to EPSG:4326,
      // measuring its width and height on the normal sphere, and taking the
      // average of the width and height.
      var toEPSG4326 = getTransformFromProjections(projection, get('EPSG:4326'));
      var vertices = [
        point[0] - resolution / 2, point[1],
        point[0] + resolution / 2, point[1],
        point[0], point[1] - resolution / 2,
        point[0], point[1] + resolution / 2
      ];
      vertices = toEPSG4326(vertices, vertices, 2);
      var width = Object(_sphere_js__WEBPACK_IMPORTED_MODULE_0__["getDistance"])(vertices.slice(0, 2), vertices.slice(2, 4));
      var height = Object(_sphere_js__WEBPACK_IMPORTED_MODULE_0__["getDistance"])(vertices.slice(4, 6), vertices.slice(6, 8));
      pointResolution = (width + height) / 2;
      var metersPerUnit = opt_units ?
        _proj_Units_js__WEBPACK_IMPORTED_MODULE_6__["METERS_PER_UNIT"][opt_units] :
        projection.getMetersPerUnit();
      if (metersPerUnit !== undefined) {
        pointResolution /= metersPerUnit;
      }
    }
  }
  return pointResolution;
}


/**
 * Registers transformation functions that don't alter coordinates. Those allow
 * to transform between projections with equal meaning.
 *
 * @param {Array<Projection>} projections Projections.
 * @api
 */
function addEquivalentProjections(projections) {
  addProjections(projections);
  projections.forEach(function(source) {
    projections.forEach(function(destination) {
      if (source !== destination) {
        Object(_proj_transforms_js__WEBPACK_IMPORTED_MODULE_8__["add"])(source, destination, cloneTransform);
      }
    });
  });
}


/**
 * Registers transformation functions to convert coordinates in any projection
 * in projection1 to any projection in projection2.
 *
 * @param {Array<Projection>} projections1 Projections with equal
 *     meaning.
 * @param {Array<Projection>} projections2 Projections with equal
 *     meaning.
 * @param {TransformFunction} forwardTransform Transformation from any
 *   projection in projection1 to any projection in projection2.
 * @param {TransformFunction} inverseTransform Transform from any projection
 *   in projection2 to any projection in projection1..
 */
function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
  projections1.forEach(function(projection1) {
    projections2.forEach(function(projection2) {
      Object(_proj_transforms_js__WEBPACK_IMPORTED_MODULE_8__["add"])(projection1, projection2, forwardTransform);
      Object(_proj_transforms_js__WEBPACK_IMPORTED_MODULE_8__["add"])(projection2, projection1, inverseTransform);
    });
  });
}


/**
 * Clear all cached projections and transforms.
 */
function clearAllProjections() {
  _proj_projections_js__WEBPACK_IMPORTED_MODULE_7__["clear"]();
  Object(_proj_transforms_js__WEBPACK_IMPORTED_MODULE_8__["clear"])();
}


/**
 * @param {Projection|string|undefined} projection Projection.
 * @param {string} defaultCode Default code.
 * @return {Projection} Projection.
 */
function createProjection(projection, defaultCode) {
  if (!projection) {
    return get(defaultCode);
  } else if (typeof projection === 'string') {
    return get(projection);
  } else {
    return (
      /** @type {Projection} */ (projection)
    );
  }
}


/**
 * Creates a {@link module:ol/proj~TransformFunction} from a simple 2D coordinate transform
 * function.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} coordTransform Coordinate
 *     transform.
 * @return {TransformFunction} Transform function.
 */
function createTransformFromCoordinateTransform(coordTransform) {
  return (
    /**
     * @param {Array<number>} input Input.
     * @param {Array<number>=} opt_output Output.
     * @param {number=} opt_dimension Dimension.
     * @return {Array<number>} Output.
     */
    function(input, opt_output, opt_dimension) {
      var length = input.length;
      var dimension = opt_dimension !== undefined ? opt_dimension : 2;
      var output = opt_output !== undefined ? opt_output : new Array(length);
      for (var i = 0; i < length; i += dimension) {
        var point = coordTransform([input[i], input[i + 1]]);
        output[i] = point[0];
        output[i + 1] = point[1];
        for (var j = dimension - 1; j >= 2; --j) {
          output[i + j] = input[i + j];
        }
      }
      return output;
    });
}


/**
 * Registers coordinate transform functions to convert coordinates between the
 * source projection and the destination projection.
 * The forward and inverse functions convert coordinate pairs; this function
 * converts these into the functions used internally which also handle
 * extents and coordinate arrays.
 *
 * @param {ProjectionLike} source Source projection.
 * @param {ProjectionLike} destination Destination projection.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} forward The forward transform
 *     function (that is, from the source projection to the destination
 *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
 *     the transformed {@link module:ol/coordinate~Coordinate}.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} inverse The inverse transform
 *     function (that is, from the destination projection to the source
 *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
 *     the transformed {@link module:ol/coordinate~Coordinate}.
 * @api
 */
function addCoordinateTransforms(source, destination, forward, inverse) {
  var sourceProj = get(source);
  var destProj = get(destination);
  Object(_proj_transforms_js__WEBPACK_IMPORTED_MODULE_8__["add"])(sourceProj, destProj, createTransformFromCoordinateTransform(forward));
  Object(_proj_transforms_js__WEBPACK_IMPORTED_MODULE_8__["add"])(destProj, sourceProj, createTransformFromCoordinateTransform(inverse));
}


/**
 * Transforms a coordinate from longitude/latitude to a different projection.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate as longitude and latitude, i.e.
 *     an array with longitude as 1st and latitude as 2nd element.
 * @param {ProjectionLike=} opt_projection Target projection. The
 *     default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {import("./coordinate.js").Coordinate} Coordinate projected to the target projection.
 * @api
 */
function fromLonLat(coordinate, opt_projection) {
  return transform(coordinate, 'EPSG:4326',
    opt_projection !== undefined ? opt_projection : 'EPSG:3857');
}


/**
 * Transforms a coordinate to longitude/latitude.
 * @param {import("./coordinate.js").Coordinate} coordinate Projected coordinate.
 * @param {ProjectionLike=} opt_projection Projection of the coordinate.
 *     The default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {import("./coordinate.js").Coordinate} Coordinate as longitude and latitude, i.e. an array
 *     with longitude as 1st and latitude as 2nd element.
 * @api
 */
function toLonLat(coordinate, opt_projection) {
  var lonLat = transform(coordinate,
    opt_projection !== undefined ? opt_projection : 'EPSG:3857', 'EPSG:4326');
  var lon = lonLat[0];
  if (lon < -180 || lon > 180) {
    lonLat[0] = Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["modulo"])(lon + 180, 360) - 180;
  }
  return lonLat;
}


/**
 * Checks if two projections are the same, that is every coordinate in one
 * projection does represent the same geographic point as the same coordinate in
 * the other projection.
 *
 * @param {Projection} projection1 Projection 1.
 * @param {Projection} projection2 Projection 2.
 * @return {boolean} Equivalent.
 * @api
 */
function equivalent(projection1, projection2) {
  if (projection1 === projection2) {
    return true;
  }
  var equalUnits = projection1.getUnits() === projection2.getUnits();
  if (projection1.getCode() === projection2.getCode()) {
    return equalUnits;
  } else {
    var transformFunc = getTransformFromProjections(projection1, projection2);
    return transformFunc === cloneTransform && equalUnits;
  }
}


/**
 * Searches in the list of transform functions for the function for converting
 * coordinates from the source projection to the destination projection.
 *
 * @param {Projection} sourceProjection Source Projection object.
 * @param {Projection} destinationProjection Destination Projection
 *     object.
 * @return {TransformFunction} Transform function.
 */
function getTransformFromProjections(sourceProjection, destinationProjection) {
  var sourceCode = sourceProjection.getCode();
  var destinationCode = destinationProjection.getCode();
  var transformFunc = Object(_proj_transforms_js__WEBPACK_IMPORTED_MODULE_8__["get"])(sourceCode, destinationCode);
  if (!transformFunc) {
    transformFunc = identityTransform;
  }
  return transformFunc;
}


/**
 * Given the projection-like objects, searches for a transformation
 * function to convert a coordinates array from the source projection to the
 * destination projection.
 *
 * @param {ProjectionLike} source Source.
 * @param {ProjectionLike} destination Destination.
 * @return {TransformFunction} Transform function.
 * @api
 */
function getTransform(source, destination) {
  var sourceProjection = get(source);
  var destinationProjection = get(destination);
  return getTransformFromProjections(sourceProjection, destinationProjection);
}


/**
 * Transforms a coordinate from source projection to destination projection.
 * This returns a new coordinate (and does not modify the original).
 *
 * See {@link module:ol/proj~transformExtent} for extent transformation.
 * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its
 * subclasses for geometry transforms.
 *
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {ProjectionLike} source Source projection-like.
 * @param {ProjectionLike} destination Destination projection-like.
 * @return {import("./coordinate.js").Coordinate} Coordinate.
 * @api
 */
function transform(coordinate, source, destination) {
  var transformFunc = getTransform(source, destination);
  return transformFunc(coordinate, undefined, coordinate.length);
}


/**
 * Transforms an extent from source projection to destination projection.  This
 * returns a new extent (and does not modify the original).
 *
 * @param {import("./extent.js").Extent} extent The extent to transform.
 * @param {ProjectionLike} source Source projection-like.
 * @param {ProjectionLike} destination Destination projection-like.
 * @return {import("./extent.js").Extent} The transformed extent.
 * @api
 */
function transformExtent(extent, source, destination) {
  var transformFunc = getTransform(source, destination);
  return Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["applyTransform"])(extent, transformFunc);
}


/**
 * Transforms the given point to the destination projection.
 *
 * @param {import("./coordinate.js").Coordinate} point Point.
 * @param {Projection} sourceProjection Source projection.
 * @param {Projection} destinationProjection Destination projection.
 * @return {import("./coordinate.js").Coordinate} Point.
 */
function transformWithProjections(point, sourceProjection, destinationProjection) {
  var transformFunc = getTransformFromProjections(sourceProjection, destinationProjection);
  return transformFunc(point);
}

/**
 * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called
 * by when this module is executed and should only need to be called again after
 * `clearAllProjections()` is called (e.g. in tests).
 */
function addCommon() {
  // Add transformations that don't alter coordinates to convert within set of
  // projections with equal meaning.
  addEquivalentProjections(_proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_3__["PROJECTIONS"]);
  addEquivalentProjections(_proj_epsg4326_js__WEBPACK_IMPORTED_MODULE_4__["PROJECTIONS"]);
  // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like
  // coordinates and back.
  addEquivalentTransforms(_proj_epsg4326_js__WEBPACK_IMPORTED_MODULE_4__["PROJECTIONS"], _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_3__["PROJECTIONS"], _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_3__["fromEPSG4326"], _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_3__["toEPSG4326"]);
}

addCommon();

//# sourceMappingURL=proj.js.map

/***/ }),

/***/ "./node_modules/ol/proj/Projection.js":
/*!********************************************!*\
  !*** ./node_modules/ol/proj/Projection.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Units_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Units.js */ "./node_modules/ol/proj/Units.js");
/**
 * @module ol/proj/Projection
 */



/**
 * @typedef {Object} Options
 * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.
 * @property {import("./Units.js").default|string} [units] Units. Required unless a
 * proj4 projection is defined for `code`.
 * @property {import("../extent.js").Extent} [extent] The validity extent for the SRS.
 * @property {string} [axisOrientation='enu'] The axis orientation as specified in Proj4.
 * @property {boolean} [global=false] Whether the projection is valid for the whole globe.
 * @property {number} [metersPerUnit] The meters per unit for the SRS.
 * If not provided, the `units` are used to get the meters per unit from the {@link module:ol/proj/Units~METERS_PER_UNIT}
 * lookup table.
 * @property {import("../extent.js").Extent} [worldExtent] The world extent for the SRS.
 * @property {function(number, import("../coordinate.js").Coordinate):number} [getPointResolution]
 * Function to determine resolution at a point. The function is called with a
 * `{number}` view resolution and an `{import("../coordinate.js").Coordinate}` as arguments, and returns
 * the `{number}` resolution at the passed coordinate. If this is `undefined`,
 * the default {@link module:ol/proj#getPointResolution} function will be used.
 */


/**
 * @classdesc
 * Projection definition class. One of these is created for each projection
 * supported in the application and stored in the {@link module:ol/proj} namespace.
 * You can use these in applications, but this is not required, as API params
 * and options use {@link module:ol/proj~ProjectionLike} which means the simple string
 * code will suffice.
 *
 * You can use {@link module:ol/proj~get} to retrieve the object for a particular
 * projection.
 *
 * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together
 * with the following aliases:
 * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,
 *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,
 *     http://www.opengis.net/gml/srs/epsg.xml#4326,
 *     urn:x-ogc:def:crs:EPSG:4326
 * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,
 *     urn:ogc:def:crs:EPSG:6.18:3:3857,
 *     http://www.opengis.net/gml/srs/epsg.xml#3857
 *
 * If you use [proj4js](https://github.com/proj4js/proj4js), aliases can
 * be added using `proj4.defs()`. After all required projection definitions are
 * added, call the {@link module:ol/proj/proj4~register} function.
 *
 * @api
 */
var Projection = function Projection(options) {
  /**
   * @private
   * @type {string}
   */
  this.code_ = options.code;

  /**
   * Units of projected coordinates. When set to `TILE_PIXELS`, a
   * `this.extent_` and `this.worldExtent_` must be configured properly for each
   * tile.
   * @private
   * @type {import("./Units.js").default}
   */
  this.units_ = /** @type {import("./Units.js").default} */ (options.units);

  /**
   * Validity extent of the projection in projected coordinates. For projections
   * with `TILE_PIXELS` units, this is the extent of the tile in
   * tile pixel space.
   * @private
   * @type {import("../extent.js").Extent}
   */
  this.extent_ = options.extent !== undefined ? options.extent : null;

  /**
   * Extent of the world in EPSG:4326. For projections with
   * `TILE_PIXELS` units, this is the extent of the tile in
   * projected coordinate space.
   * @private
   * @type {import("../extent.js").Extent}
   */
  this.worldExtent_ = options.worldExtent !== undefined ?
    options.worldExtent : null;

  /**
   * @private
   * @type {string}
   */
  this.axisOrientation_ = options.axisOrientation !== undefined ?
    options.axisOrientation : 'enu';

  /**
   * @private
   * @type {boolean}
   */
  this.global_ = options.global !== undefined ? options.global : false;

  /**
   * @private
   * @type {boolean}
   */
  this.canWrapX_ = !!(this.global_ && this.extent_);

  /**
   * @private
   * @type {function(number, import("../coordinate.js").Coordinate):number|undefined}
   */
  this.getPointResolutionFunc_ = options.getPointResolution;

  /**
   * @private
   * @type {import("../tilegrid/TileGrid.js").default}
   */
  this.defaultTileGrid_ = null;

  /**
   * @private
   * @type {number|undefined}
   */
  this.metersPerUnit_ = options.metersPerUnit;
};

/**
 * @return {boolean} The projection is suitable for wrapping the x-axis
 */
Projection.prototype.canWrapX = function canWrapX () {
  return this.canWrapX_;
};

/**
 * Get the code for this projection, e.g. 'EPSG:4326'.
 * @return {string} Code.
 * @api
 */
Projection.prototype.getCode = function getCode () {
  return this.code_;
};

/**
 * Get the validity extent for this projection.
 * @return {import("../extent.js").Extent} Extent.
 * @api
 */
Projection.prototype.getExtent = function getExtent () {
  return this.extent_;
};

/**
 * Get the units of this projection.
 * @return {import("./Units.js").default} Units.
 * @api
 */
Projection.prototype.getUnits = function getUnits () {
  return this.units_;
};

/**
 * Get the amount of meters per unit of this projection.If the projection is
 * not configured with `metersPerUnit` or a units identifier, the return is
 * `undefined`.
 * @return {number|undefined} Meters.
 * @api
 */
Projection.prototype.getMetersPerUnit = function getMetersPerUnit () {
  return this.metersPerUnit_ || _Units_js__WEBPACK_IMPORTED_MODULE_0__["METERS_PER_UNIT"][this.units_];
};

/**
 * Get the world extent for this projection.
 * @return {import("../extent.js").Extent} Extent.
 * @api
 */
Projection.prototype.getWorldExtent = function getWorldExtent () {
  return this.worldExtent_;
};

/**
 * Get the axis orientation of this projection.
 * Example values are:
 * enu - the default easting, northing, elevation.
 * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
 *   or south orientated transverse mercator.
 * wnu - westing, northing, up - some planetary coordinate systems have
 *   "west positive" coordinate systems
 * @return {string} Axis orientation.
 * @api
 */
Projection.prototype.getAxisOrientation = function getAxisOrientation () {
  return this.axisOrientation_;
};

/**
 * Is this projection a global projection which spans the whole world?
 * @return {boolean} Whether the projection is global.
 * @api
 */
Projection.prototype.isGlobal = function isGlobal () {
  return this.global_;
};

/**
 * Set if the projection is a global projection which spans the whole world
 * @param {boolean} global Whether the projection is global.
 * @api
 */
Projection.prototype.setGlobal = function setGlobal (global) {
  this.global_ = global;
  this.canWrapX_ = !!(global && this.extent_);
};

/**
 * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
 */
Projection.prototype.getDefaultTileGrid = function getDefaultTileGrid () {
  return this.defaultTileGrid_;
};

/**
 * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
 */
Projection.prototype.setDefaultTileGrid = function setDefaultTileGrid (tileGrid) {
  this.defaultTileGrid_ = tileGrid;
};

/**
 * Set the validity extent for this projection.
 * @param {import("../extent.js").Extent} extent Extent.
 * @api
 */
Projection.prototype.setExtent = function setExtent (extent) {
  this.extent_ = extent;
  this.canWrapX_ = !!(this.global_ && extent);
};

/**
 * Set the world extent for this projection.
 * @param {import("../extent.js").Extent} worldExtent World extent
 *   [minlon, minlat, maxlon, maxlat].
 * @api
 */
Projection.prototype.setWorldExtent = function setWorldExtent (worldExtent) {
  this.worldExtent_ = worldExtent;
};

/**
 * Set the getPointResolution function (see {@link module:ol/proj~getPointResolution}
 * for this projection.
 * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
 * @api
 */
Projection.prototype.setGetPointResolution = function setGetPointResolution (func) {
  this.getPointResolutionFunc_ = func;
};

/**
 * Get the custom point resolution function for this projection (if set).
 * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
 * resolution function (if set).
 */
Projection.prototype.getPointResolutionFunc = function getPointResolutionFunc () {
  return this.getPointResolutionFunc_;
};

/* harmony default export */ __webpack_exports__["default"] = (Projection);

//# sourceMappingURL=Projection.js.map

/***/ }),

/***/ "./node_modules/ol/proj/Units.js":
/*!***************************************!*\
  !*** ./node_modules/ol/proj/Units.js ***!
  \***************************************/
/*! exports provided: METERS_PER_UNIT, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "METERS_PER_UNIT", function() { return METERS_PER_UNIT; });
/**
 * @module ol/proj/Units
 */

/**
 * Projection units: `'degrees'`, `'ft'`, `'m'`, `'pixels'`, `'tile-pixels'` or
 * `'us-ft'`.
 * @enum {string}
 */
var Units = {
  DEGREES: 'degrees',
  FEET: 'ft',
  METERS: 'm',
  PIXELS: 'pixels',
  TILE_PIXELS: 'tile-pixels',
  USFEET: 'us-ft'
};


/**
 * Meters per unit lookup table.
 * @const
 * @type {Object<Units, number>}
 * @api
 */
var METERS_PER_UNIT = {};
// use the radius of the Normal sphere
METERS_PER_UNIT[Units.DEGREES] = 2 * Math.PI * 6370997 / 360;
METERS_PER_UNIT[Units.FEET] = 0.3048;
METERS_PER_UNIT[Units.METERS] = 1;
METERS_PER_UNIT[Units.USFEET] = 1200 / 3937;

/* harmony default export */ __webpack_exports__["default"] = (Units);

//# sourceMappingURL=Units.js.map

/***/ }),

/***/ "./node_modules/ol/proj/epsg3857.js":
/*!******************************************!*\
  !*** ./node_modules/ol/proj/epsg3857.js ***!
  \******************************************/
/*! exports provided: RADIUS, HALF_SIZE, EXTENT, WORLD_EXTENT, PROJECTIONS, fromEPSG4326, toEPSG4326 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RADIUS", function() { return RADIUS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HALF_SIZE", function() { return HALF_SIZE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EXTENT", function() { return EXTENT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WORLD_EXTENT", function() { return WORLD_EXTENT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PROJECTIONS", function() { return PROJECTIONS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromEPSG4326", function() { return fromEPSG4326; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toEPSG4326", function() { return toEPSG4326; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _Projection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Projection.js */ "./node_modules/ol/proj/Projection.js");
/* harmony import */ var _Units_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Units.js */ "./node_modules/ol/proj/Units.js");
/**
 * @module ol/proj/epsg3857
 */





/**
 * Radius of WGS84 sphere
 *
 * @const
 * @type {number}
 */
var RADIUS = 6378137;


/**
 * @const
 * @type {number}
 */
var HALF_SIZE = Math.PI * RADIUS;


/**
 * @const
 * @type {import("../extent.js").Extent}
 */
var EXTENT = [
  -HALF_SIZE, -HALF_SIZE,
  HALF_SIZE, HALF_SIZE
];


/**
 * @const
 * @type {import("../extent.js").Extent}
 */
var WORLD_EXTENT = [-180, -85, 180, 85];


/**
 * @classdesc
 * Projection object for web/spherical Mercator (EPSG:3857).
 */
var EPSG3857Projection = /*@__PURE__*/(function (Projection) {
  function EPSG3857Projection(code) {
    Projection.call(this, {
      code: code,
      units: _Units_js__WEBPACK_IMPORTED_MODULE_2__["default"].METERS,
      extent: EXTENT,
      global: true,
      worldExtent: WORLD_EXTENT,
      getPointResolution: function(resolution, point) {
        return resolution / Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["cosh"])(point[1] / RADIUS);
      }
    });

  }

  if ( Projection ) EPSG3857Projection.__proto__ = Projection;
  EPSG3857Projection.prototype = Object.create( Projection && Projection.prototype );
  EPSG3857Projection.prototype.constructor = EPSG3857Projection;

  return EPSG3857Projection;
}(_Projection_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/**
 * Projections equal to EPSG:3857.
 *
 * @const
 * @type {Array<import("./Projection.js").default>}
 */
var PROJECTIONS = [
  new EPSG3857Projection('EPSG:3857'),
  new EPSG3857Projection('EPSG:102100'),
  new EPSG3857Projection('EPSG:102113'),
  new EPSG3857Projection('EPSG:900913'),
  new EPSG3857Projection('urn:ogc:def:crs:EPSG:6.18:3:3857'),
  new EPSG3857Projection('urn:ogc:def:crs:EPSG::3857'),
  new EPSG3857Projection('http://www.opengis.net/gml/srs/epsg.xml#3857')
];


/**
 * Transformation from EPSG:4326 to EPSG:3857.
 *
 * @param {Array<number>} input Input array of coordinate values.
 * @param {Array<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension (default is `2`).
 * @return {Array<number>} Output array of coordinate values.
 */
function fromEPSG4326(input, opt_output, opt_dimension) {
  var length = input.length;
  var dimension = opt_dimension > 1 ? opt_dimension : 2;
  var output = opt_output;
  if (output === undefined) {
    if (dimension > 2) {
      // preserve values beyond second dimension
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  var halfSize = HALF_SIZE;
  for (var i = 0; i < length; i += dimension) {
    output[i] = halfSize * input[i] / 180;
    var y = RADIUS *
        Math.log(Math.tan(Math.PI * (input[i + 1] + 90) / 360));
    if (y > halfSize) {
      y = halfSize;
    } else if (y < -halfSize) {
      y = -halfSize;
    }
    output[i + 1] = y;
  }
  return output;
}


/**
 * Transformation from EPSG:3857 to EPSG:4326.
 *
 * @param {Array<number>} input Input array of coordinate values.
 * @param {Array<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension (default is `2`).
 * @return {Array<number>} Output array of coordinate values.
 */
function toEPSG4326(input, opt_output, opt_dimension) {
  var length = input.length;
  var dimension = opt_dimension > 1 ? opt_dimension : 2;
  var output = opt_output;
  if (output === undefined) {
    if (dimension > 2) {
      // preserve values beyond second dimension
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (var i = 0; i < length; i += dimension) {
    output[i] = 180 * input[i] / HALF_SIZE;
    output[i + 1] = 360 * Math.atan(
      Math.exp(input[i + 1] / RADIUS)) / Math.PI - 90;
  }
  return output;
}

//# sourceMappingURL=epsg3857.js.map

/***/ }),

/***/ "./node_modules/ol/proj/epsg4326.js":
/*!******************************************!*\
  !*** ./node_modules/ol/proj/epsg4326.js ***!
  \******************************************/
/*! exports provided: RADIUS, EXTENT, METERS_PER_UNIT, PROJECTIONS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RADIUS", function() { return RADIUS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EXTENT", function() { return EXTENT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "METERS_PER_UNIT", function() { return METERS_PER_UNIT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PROJECTIONS", function() { return PROJECTIONS; });
/* harmony import */ var _Projection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Projection.js */ "./node_modules/ol/proj/Projection.js");
/* harmony import */ var _Units_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Units.js */ "./node_modules/ol/proj/Units.js");
/**
 * @module ol/proj/epsg4326
 */




/**
 * Semi-major radius of the WGS84 ellipsoid.
 *
 * @const
 * @type {number}
 */
var RADIUS = 6378137;


/**
 * Extent of the EPSG:4326 projection which is the whole world.
 *
 * @const
 * @type {import("../extent.js").Extent}
 */
var EXTENT = [-180, -90, 180, 90];


/**
 * @const
 * @type {number}
 */
var METERS_PER_UNIT = Math.PI * RADIUS / 180;


/**
 * @classdesc
 * Projection object for WGS84 geographic coordinates (EPSG:4326).
 *
 * Note that OpenLayers does not strictly comply with the EPSG definition.
 * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).
 * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.
 */
var EPSG4326Projection = /*@__PURE__*/(function (Projection) {
  function EPSG4326Projection(code, opt_axisOrientation) {
    Projection.call(this, {
      code: code,
      units: _Units_js__WEBPACK_IMPORTED_MODULE_1__["default"].DEGREES,
      extent: EXTENT,
      axisOrientation: opt_axisOrientation,
      global: true,
      metersPerUnit: METERS_PER_UNIT,
      worldExtent: EXTENT
    });

  }

  if ( Projection ) EPSG4326Projection.__proto__ = Projection;
  EPSG4326Projection.prototype = Object.create( Projection && Projection.prototype );
  EPSG4326Projection.prototype.constructor = EPSG4326Projection;

  return EPSG4326Projection;
}(_Projection_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/**
 * Projections equal to EPSG:4326.
 *
 * @const
 * @type {Array<import("./Projection.js").default>}
 */
var PROJECTIONS = [
  new EPSG4326Projection('CRS:84'),
  new EPSG4326Projection('EPSG:4326', 'neu'),
  new EPSG4326Projection('urn:ogc:def:crs:EPSG::4326', 'neu'),
  new EPSG4326Projection('urn:ogc:def:crs:EPSG:6.6:4326', 'neu'),
  new EPSG4326Projection('urn:ogc:def:crs:OGC:1.3:CRS84'),
  new EPSG4326Projection('urn:ogc:def:crs:OGC:2:84'),
  new EPSG4326Projection('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'),
  new EPSG4326Projection('urn:x-ogc:def:crs:EPSG:4326', 'neu')
];

//# sourceMappingURL=epsg4326.js.map

/***/ }),

/***/ "./node_modules/ol/proj/projections.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/proj/projections.js ***!
  \*********************************************/
/*! exports provided: clear, get, add */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clear", function() { return clear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return get; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/**
 * @module ol/proj/projections
 */


/**
 * @type {Object<string, import("./Projection.js").default>}
 */
var cache = {};


/**
 * Clear the projections cache.
 */
function clear() {
  cache = {};
}


/**
 * Get a cached projection by code.
 * @param {string} code The code for the projection.
 * @return {import("./Projection.js").default} The projection (if cached).
 */
function get(code) {
  return cache[code] || null;
}


/**
 * Add a projection to the cache.
 * @param {string} code The projection code.
 * @param {import("./Projection.js").default} projection The projection to cache.
 */
function add(code, projection) {
  cache[code] = projection;
}

//# sourceMappingURL=projections.js.map

/***/ }),

/***/ "./node_modules/ol/proj/transforms.js":
/*!********************************************!*\
  !*** ./node_modules/ol/proj/transforms.js ***!
  \********************************************/
/*! exports provided: clear, add, remove, get */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clear", function() { return clear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "remove", function() { return remove; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return get; });
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/proj/transforms
 */



/**
 * @private
 * @type {!Object<string, Object<string, import("../proj.js").TransformFunction>>}
 */
var transforms = {};


/**
 * Clear the transform cache.
 */
function clear() {
  transforms = {};
}


/**
 * Registers a conversion function to convert coordinates from the source
 * projection to the destination projection.
 *
 * @param {import("./Projection.js").default} source Source.
 * @param {import("./Projection.js").default} destination Destination.
 * @param {import("../proj.js").TransformFunction} transformFn Transform.
 */
function add(source, destination, transformFn) {
  var sourceCode = source.getCode();
  var destinationCode = destination.getCode();
  if (!(sourceCode in transforms)) {
    transforms[sourceCode] = {};
  }
  transforms[sourceCode][destinationCode] = transformFn;
}


/**
 * Unregisters the conversion function to convert coordinates from the source
 * projection to the destination projection.  This method is used to clean up
 * cached transforms during testing.
 *
 * @param {import("./Projection.js").default} source Source projection.
 * @param {import("./Projection.js").default} destination Destination projection.
 * @return {import("../proj.js").TransformFunction} transformFn The unregistered transform.
 */
function remove(source, destination) {
  var sourceCode = source.getCode();
  var destinationCode = destination.getCode();
  var transform = transforms[sourceCode][destinationCode];
  delete transforms[sourceCode][destinationCode];
  if (Object(_obj_js__WEBPACK_IMPORTED_MODULE_0__["isEmpty"])(transforms[sourceCode])) {
    delete transforms[sourceCode];
  }
  return transform;
}


/**
 * Get a transform given a source code and a destination code.
 * @param {string} sourceCode The code for the source projection.
 * @param {string} destinationCode The code for the destination projection.
 * @return {import("../proj.js").TransformFunction|undefined} The transform function (if found).
 */
function get(sourceCode, destinationCode) {
  var transform;
  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
    transform = transforms[sourceCode][destinationCode];
  }
  return transform;
}

//# sourceMappingURL=transforms.js.map

/***/ }),

/***/ "./node_modules/ol/render/Box.js":
/*!***************************************!*\
  !*** ./node_modules/ol/render/Box.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Disposable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Disposable.js */ "./node_modules/ol/Disposable.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geom/Polygon.js */ "./node_modules/ol/geom/Polygon.js");
/**
 * @module ol/render/Box
 */




var RenderBox = /*@__PURE__*/(function (Disposable) {
  function RenderBox(className) {
    Disposable.call(this);

    /**
     * @type {import("../geom/Polygon.js").default}
     * @private
     */
    this.geometry_ = null;

    /**
     * @type {HTMLDivElement}
     * @private
     */
    this.element_ = /** @type {HTMLDivElement} */ (document.createElement('div'));
    this.element_.style.position = 'absolute';
    this.element_.className = 'ol-box ' + className;

    /**
     * @private
     * @type {import("../PluggableMap.js").default}
     */
    this.map_ = null;

    /**
     * @private
     * @type {import("../pixel.js").Pixel}
     */
    this.startPixel_ = null;

    /**
     * @private
     * @type {import("../pixel.js").Pixel}
     */
    this.endPixel_ = null;

  }

  if ( Disposable ) RenderBox.__proto__ = Disposable;
  RenderBox.prototype = Object.create( Disposable && Disposable.prototype );
  RenderBox.prototype.constructor = RenderBox;

  /**
   * @inheritDoc
   */
  RenderBox.prototype.disposeInternal = function disposeInternal () {
    this.setMap(null);
  };

  /**
   * @private
   */
  RenderBox.prototype.render_ = function render_ () {
    var startPixel = this.startPixel_;
    var endPixel = this.endPixel_;
    var px = 'px';
    var style = this.element_.style;
    style.left = Math.min(startPixel[0], endPixel[0]) + px;
    style.top = Math.min(startPixel[1], endPixel[1]) + px;
    style.width = Math.abs(endPixel[0] - startPixel[0]) + px;
    style.height = Math.abs(endPixel[1] - startPixel[1]) + px;
  };

  /**
   * @param {import("../PluggableMap.js").default} map Map.
   */
  RenderBox.prototype.setMap = function setMap (map) {
    if (this.map_) {
      this.map_.getOverlayContainer().removeChild(this.element_);
      var style = this.element_.style;
      style.left = style.top = style.width = style.height = 'inherit';
    }
    this.map_ = map;
    if (this.map_) {
      this.map_.getOverlayContainer().appendChild(this.element_);
    }
  };

  /**
   * @param {import("../pixel.js").Pixel} startPixel Start pixel.
   * @param {import("../pixel.js").Pixel} endPixel End pixel.
   */
  RenderBox.prototype.setPixels = function setPixels (startPixel, endPixel) {
    this.startPixel_ = startPixel;
    this.endPixel_ = endPixel;
    this.createOrUpdateGeometry();
    this.render_();
  };

  /**
   * Creates or updates the cached geometry.
   */
  RenderBox.prototype.createOrUpdateGeometry = function createOrUpdateGeometry () {
    var startPixel = this.startPixel_;
    var endPixel = this.endPixel_;
    var pixels = [
      startPixel,
      [startPixel[0], endPixel[1]],
      endPixel,
      [endPixel[0], startPixel[1]]
    ];
    var coordinates = pixels.map(this.map_.getCoordinateFromPixel, this.map_);
    // close the polygon
    coordinates[4] = coordinates[0].slice();
    if (!this.geometry_) {
      this.geometry_ = new _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_1__["default"]([coordinates]);
    } else {
      this.geometry_.setCoordinates([coordinates]);
    }
  };

  /**
   * @return {import("../geom/Polygon.js").default} Geometry.
   */
  RenderBox.prototype.getGeometry = function getGeometry () {
    return this.geometry_;
  };

  return RenderBox;
}(_Disposable_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (RenderBox);

//# sourceMappingURL=Box.js.map

/***/ }),

/***/ "./node_modules/ol/render/Event.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/render/Event.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/**
 * @module ol/render/Event
 */



var RenderEvent = /*@__PURE__*/(function (Event) {
  function RenderEvent(type, opt_vectorContext, opt_frameState, opt_context, opt_glContext) {

    Event.call(this, type);

    /**
     * For canvas, this is an instance of {@link module:ol/render/canvas/Immediate}.
     * @type {import("./VectorContext.js").default|undefined}
     * @api
     */
    this.vectorContext = opt_vectorContext;

    /**
     * An object representing the current render frame state.
     * @type {import("../PluggableMap.js").FrameState|undefined}
     * @api
     */
    this.frameState = opt_frameState;

    /**
     * Canvas context. Only available when a Canvas renderer is used, null
     * otherwise.
     * @type {CanvasRenderingContext2D|null|undefined}
     * @api
     */
    this.context = opt_context;

    /**
     * WebGL context. Only available when a WebGL renderer is used, null
     * otherwise.
     * @type {import("../webgl/Context.js").default|null|undefined}
     * @api
     */
    this.glContext = opt_glContext;

  }

  if ( Event ) RenderEvent.__proto__ = Event;
  RenderEvent.prototype = Object.create( Event && Event.prototype );
  RenderEvent.prototype.constructor = RenderEvent;

  return RenderEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_0__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (RenderEvent);

//# sourceMappingURL=Event.js.map

/***/ }),

/***/ "./node_modules/ol/render/EventType.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/render/EventType.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/render/EventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  /**
   * @event module:ol/render/Event~RenderEvent#postcompose
   * @api
   */
  POSTCOMPOSE: 'postcompose',
  /**
   * @event module:ol/render/Event~RenderEvent#precompose
   * @api
   */
  PRECOMPOSE: 'precompose',
  /**
   * @event module:ol/render/Event~RenderEvent#render
   * @api
   */
  RENDER: 'render',
  /**
   * Triggered when rendering is complete, i.e. all sources and tiles have
   * finished loading for the current viewport, and all tiles are faded in.
   * @event module:ol/render/Event~RenderEvent#rendercomplete
   * @api
   */
  RENDERCOMPLETE: 'rendercomplete'
});

//# sourceMappingURL=EventType.js.map

/***/ }),

/***/ "./node_modules/ol/render/ReplayGroup.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/render/ReplayGroup.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/**
 * @module ol/render/ReplayGroup
 */


/**
 * Base class for replay groups.
 */
var ReplayGroup = function ReplayGroup () {};

ReplayGroup.prototype.getReplay = function getReplay (zIndex, replayType) {
  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
};

/**
 * @abstract
 * @return {boolean} Is empty.
 */
ReplayGroup.prototype.isEmpty = function isEmpty () {
  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
};

/**
 * @abstract
 * @param {boolean} group Group with previous replay
 * @return {Array<*>} The resulting instruction group
 */
ReplayGroup.prototype.addDeclutter = function addDeclutter (group) {
  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
};

/* harmony default export */ __webpack_exports__["default"] = (ReplayGroup);

//# sourceMappingURL=ReplayGroup.js.map

/***/ }),

/***/ "./node_modules/ol/render/ReplayType.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/render/ReplayType.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/render/ReplayType
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  CIRCLE: 'Circle',
  DEFAULT: 'Default',
  IMAGE: 'Image',
  LINE_STRING: 'LineString',
  POLYGON: 'Polygon',
  TEXT: 'Text'
});

//# sourceMappingURL=ReplayType.js.map

/***/ }),

/***/ "./node_modules/ol/render/VectorContext.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/render/VectorContext.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/render/VectorContext
 */

/**
 * @classdesc
 * Context for drawing geometries.  A vector context is available on render
 * events and does not need to be constructed directly.
 * @api
 */
var VectorContext = function VectorContext () {};

VectorContext.prototype.drawCustom = function drawCustom (geometry, feature, renderer) {};

/**
 * Render a geometry.
 *
 * @param {import("../geom/Geometry.js").default} geometry The geometry to render.
 */
VectorContext.prototype.drawGeometry = function drawGeometry (geometry) {};

/**
 * Set the rendering style.
 *
 * @param {import("../style/Style.js").default} style The rendering style.
 */
VectorContext.prototype.setStyle = function setStyle (style) {};

/**
 * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.
 * @param {import("../Feature.js").default} feature Feature.
 */
VectorContext.prototype.drawCircle = function drawCircle (circleGeometry, feature) {};

/**
 * @param {import("../Feature.js").default} feature Feature.
 * @param {import("../style/Style.js").default} style Style.
 */
VectorContext.prototype.drawFeature = function drawFeature (feature, style) {};

/**
 * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.
 * @param {import("../Feature.js").default} feature Feature.
 */
VectorContext.prototype.drawGeometryCollection = function drawGeometryCollection (geometryCollectionGeometry, feature) {};

/**
 * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.
 * @param {import("../Feature.js").default|import("./Feature.js").default} feature Feature.
 */
VectorContext.prototype.drawLineString = function drawLineString (lineStringGeometry, feature) {};

/**
 * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.
 * @param {import("../Feature.js").default|import("./Feature.js").default} feature Feature.
 */
VectorContext.prototype.drawMultiLineString = function drawMultiLineString (multiLineStringGeometry, feature) {};

/**
 * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.
 * @param {import("../Feature.js").default|import("./Feature.js").default} feature Feature.
 */
VectorContext.prototype.drawMultiPoint = function drawMultiPoint (multiPointGeometry, feature) {};

/**
 * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
 * @param {import("../Feature.js").default|import("./Feature.js").default} feature Feature.
 */
VectorContext.prototype.drawMultiPolygon = function drawMultiPolygon (multiPolygonGeometry, feature) {};

/**
 * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.
 * @param {import("../Feature.js").default|import("./Feature.js").default} feature Feature.
 */
VectorContext.prototype.drawPoint = function drawPoint (pointGeometry, feature) {};

/**
 * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.
 * @param {import("../Feature.js").default|import("./Feature.js").default} feature Feature.
 */
VectorContext.prototype.drawPolygon = function drawPolygon (polygonGeometry, feature) {};

/**
 * @param {import("../geom/Geometry.js").default|import("./Feature.js").default} geometry Geometry.
 * @param {import("../Feature.js").default|import("./Feature.js").default} feature Feature.
 */
VectorContext.prototype.drawText = function drawText (geometry, feature) {};

/**
 * @param {import("../style/Fill.js").default} fillStyle Fill style.
 * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.
 */
VectorContext.prototype.setFillStrokeStyle = function setFillStrokeStyle (fillStyle, strokeStyle) {};

/**
 * @param {import("../style/Image.js").default} imageStyle Image style.
 * @param {import("./canvas.js").DeclutterGroup=} opt_declutterGroup Declutter.
 */
VectorContext.prototype.setImageStyle = function setImageStyle (imageStyle, opt_declutterGroup) {};

/**
 * @param {import("../style/Text.js").default} textStyle Text style.
 * @param {import("./canvas.js").DeclutterGroup=} opt_declutterGroup Declutter.
 */
VectorContext.prototype.setTextStyle = function setTextStyle (textStyle, opt_declutterGroup) {};

/* harmony default export */ __webpack_exports__["default"] = (VectorContext);

//# sourceMappingURL=VectorContext.js.map

/***/ }),

/***/ "./node_modules/ol/render/canvas.js":
/*!******************************************!*\
  !*** ./node_modules/ol/render/canvas.js ***!
  \******************************************/
/*! exports provided: defaultFont, defaultFillStyle, defaultLineCap, defaultLineDash, defaultLineDashOffset, defaultLineJoin, defaultMiterLimit, defaultStrokeStyle, defaultTextAlign, defaultTextBaseline, defaultPadding, defaultLineWidth, labelCache, checkedFonts, textHeights, checkFont, measureTextHeight, measureTextWidth, rotateAtOffset, resetTransform, drawImage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultFont", function() { return defaultFont; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultFillStyle", function() { return defaultFillStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultLineCap", function() { return defaultLineCap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultLineDash", function() { return defaultLineDash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultLineDashOffset", function() { return defaultLineDashOffset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultLineJoin", function() { return defaultLineJoin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultMiterLimit", function() { return defaultMiterLimit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultStrokeStyle", function() { return defaultStrokeStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultTextAlign", function() { return defaultTextAlign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultTextBaseline", function() { return defaultTextBaseline; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultPadding", function() { return defaultPadding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultLineWidth", function() { return defaultLineWidth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "labelCache", function() { return labelCache; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkedFonts", function() { return checkedFonts; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "textHeights", function() { return textHeights; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkFont", function() { return checkFont; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "measureTextHeight", function() { return measureTextHeight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "measureTextWidth", function() { return measureTextWidth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateAtOffset", function() { return rotateAtOffset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resetTransform", function() { return resetTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawImage", function() { return drawImage; });
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../css.js */ "./node_modules/ol/css.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _structs_LRUCache_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../structs/LRUCache.js */ "./node_modules/ol/structs/LRUCache.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/render/canvas
 */







/**
 * @typedef {Object} FillState
 * @property {import("../colorlike.js").ColorLike} fillStyle
 */


/**
 * @typedef {Object} FillStrokeState
 * @property {import("../colorlike.js").ColorLike} [currentFillStyle]
 * @property {import("../colorlike.js").ColorLike} [currentStrokeStyle]
 * @property {string} [currentLineCap]
 * @property {Array<number>} currentLineDash
 * @property {number} [currentLineDashOffset]
 * @property {string} [currentLineJoin]
 * @property {number} [currentLineWidth]
 * @property {number} [currentMiterLimit]
 * @property {number} [lastStroke]
 * @property {import("../colorlike.js").ColorLike} [fillStyle]
 * @property {import("../colorlike.js").ColorLike} [strokeStyle]
 * @property {string} [lineCap]
 * @property {Array<number>} lineDash
 * @property {number} [lineDashOffset]
 * @property {string} [lineJoin]
 * @property {number} [lineWidth]
 * @property {number} [miterLimit]
 */


/**
 * @typedef {Object} StrokeState
 * @property {string} lineCap
 * @property {Array<number>} lineDash
 * @property {number} lineDashOffset
 * @property {string} lineJoin
 * @property {number} lineWidth
 * @property {number} miterLimit
 * @property {import("../colorlike.js").ColorLike} strokeStyle
 */


/**
 * @typedef {Object} TextState
 * @property {string} font
 * @property {string} [textAlign]
 * @property {string} textBaseline
 * @property {string} [placement]
 * @property {number} [maxAngle]
 * @property {boolean} [overflow]
 * @property {import("../style/Fill.js").default} [backgroundFill]
 * @property {import("../style/Stroke.js").default} [backgroundStroke]
 * @property {number} [scale]
 * @property {Array<number>} [padding]
 */


/**
 * Container for decluttered replay instructions that need to be rendered or
 * omitted together, i.e. when styles render both an image and text, or for the
 * characters that form text along lines. The basic elements of this array are
 * `[minX, minY, maxX, maxY, count]`, where the first four entries are the
 * rendered extent of the group in pixel space. `count` is the number of styles
 * in the group, i.e. 2 when an image and a text are grouped, or 1 otherwise.
 * In addition to these four elements, declutter instruction arrays (i.e. the
 * arguments to {@link module:ol/render/canvas~drawImage} are appended to the array.
 * @typedef {Array<*>} DeclutterGroup
 */


/**
 * @const
 * @type {string}
 */
var defaultFont = '10px sans-serif';


/**
 * @const
 * @type {import("../color.js").Color}
 */
var defaultFillStyle = [0, 0, 0, 1];


/**
 * @const
 * @type {string}
 */
var defaultLineCap = 'round';


/**
 * @const
 * @type {Array<number>}
 */
var defaultLineDash = [];


/**
 * @const
 * @type {number}
 */
var defaultLineDashOffset = 0;


/**
 * @const
 * @type {string}
 */
var defaultLineJoin = 'round';


/**
 * @const
 * @type {number}
 */
var defaultMiterLimit = 10;


/**
 * @const
 * @type {import("../color.js").Color}
 */
var defaultStrokeStyle = [0, 0, 0, 1];


/**
 * @const
 * @type {string}
 */
var defaultTextAlign = 'center';


/**
 * @const
 * @type {string}
 */
var defaultTextBaseline = 'middle';


/**
 * @const
 * @type {Array<number>}
 */
var defaultPadding = [0, 0, 0, 0];


/**
 * @const
 * @type {number}
 */
var defaultLineWidth = 1;


/**
 * The label cache for text rendering. To change the default cache size of 2048
 * entries, use {@link module:ol/structs/LRUCache#setSize}.
 * @type {LRUCache<HTMLCanvasElement>}
 * @api
 */
var labelCache = new _structs_LRUCache_js__WEBPACK_IMPORTED_MODULE_3__["default"]();


/**
 * @type {!Object<string, number>}
 */
var checkedFonts = {};


/**
 * @type {CanvasRenderingContext2D}
 */
var measureContext = null;


/**
 * @type {!Object<string, number>}
 */
var textHeights = {};


/**
 * Clears the label cache when a font becomes available.
 * @param {string} fontSpec CSS font spec.
 */
var checkFont = (function() {
  var retries = 60;
  var checked = checkedFonts;
  var size = '32px ';
  var referenceFonts = ['monospace', 'serif'];
  var len = referenceFonts.length;
  var text = 'wmytzilWMYTZIL@#/&?$%10\uF013';
  var interval, referenceWidth;

  function isAvailable(font) {
    var context = getMeasureContext();
    // Check weight ranges according to
    // https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight#Fallback_weights
    for (var weight = 100; weight <= 700; weight += 300) {
      var fontWeight = weight + ' ';
      var available = true;
      for (var i = 0; i < len; ++i) {
        var referenceFont = referenceFonts[i];
        context.font = fontWeight + size + referenceFont;
        referenceWidth = context.measureText(text).width;
        if (font != referenceFont) {
          context.font = fontWeight + size + font + ',' + referenceFont;
          var width = context.measureText(text).width;
          // If width and referenceWidth are the same, then the fallback was used
          // instead of the font we wanted, so the font is not available.
          available = available && width != referenceWidth;
        }
      }
      if (available) {
        // Consider font available when it is available in one weight range.
        //FIXME With this we miss rare corner cases, so we should consider
        //FIXME checking availability for each requested weight range.
        return true;
      }
    }
    return false;
  }

  function check() {
    var done = true;
    for (var font in checked) {
      if (checked[font] < retries) {
        if (isAvailable(font)) {
          checked[font] = retries;
          Object(_obj_js__WEBPACK_IMPORTED_MODULE_2__["clear"])(textHeights);
          // Make sure that loaded fonts are picked up by Safari
          measureContext = null;
          labelCache.clear();
        } else {
          ++checked[font];
          done = false;
        }
      }
    }
    if (done) {
      clearInterval(interval);
      interval = undefined;
    }
  }

  return function(fontSpec) {
    var fontFamilies = Object(_css_js__WEBPACK_IMPORTED_MODULE_0__["getFontFamilies"])(fontSpec);
    if (!fontFamilies) {
      return;
    }
    for (var i = 0, ii = fontFamilies.length; i < ii; ++i) {
      var fontFamily = fontFamilies[i];
      if (!(fontFamily in checked)) {
        checked[fontFamily] = retries;
        if (!isAvailable(fontFamily)) {
          checked[fontFamily] = 0;
          if (interval === undefined) {
            interval = setInterval(check, 32);
          }
        }
      }
    }
  };
})();


/**
 * @return {CanvasRenderingContext2D} Measure context.
 */
function getMeasureContext() {
  if (!measureContext) {
    measureContext = Object(_dom_js__WEBPACK_IMPORTED_MODULE_1__["createCanvasContext2D"])(1, 1);
  }
  return measureContext;
}


/**
 * @param {string} font Font to use for measuring.
 * @return {import("../size.js").Size} Measurement.
 */
var measureTextHeight = (function() {
  var span;
  var heights = textHeights;
  return function(font) {
    var height = heights[font];
    if (height == undefined) {
      if (!span) {
        span = document.createElement('span');
        span.textContent = 'M';
        span.style.margin = span.style.padding = '0 !important';
        span.style.position = 'absolute !important';
        span.style.left = '-99999px !important';
      }
      span.style.font = font;
      document.body.appendChild(span);
      height = heights[font] = span.offsetHeight;
      document.body.removeChild(span);
    }
    return height;
  };
})();


/**
 * @param {string} font Font.
 * @param {string} text Text.
 * @return {number} Width.
 */
function measureTextWidth(font, text) {
  var measureContext = getMeasureContext();
  if (font != measureContext.font) {
    measureContext.font = font;
  }
  return measureContext.measureText(text).width;
}


/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} rotation Rotation.
 * @param {number} offsetX X offset.
 * @param {number} offsetY Y offset.
 */
function rotateAtOffset(context, rotation, offsetX, offsetY) {
  if (rotation !== 0) {
    context.translate(offsetX, offsetY);
    context.rotate(rotation);
    context.translate(-offsetX, -offsetY);
  }
}


var resetTransform = Object(_transform_js__WEBPACK_IMPORTED_MODULE_4__["create"])();


/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {import("../transform.js").Transform|null} transform Transform.
 * @param {number} opacity Opacity.
 * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} image Image.
 * @param {number} originX Origin X.
 * @param {number} originY Origin Y.
 * @param {number} w Width.
 * @param {number} h Height.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} scale Scale.
 */
function drawImage(context,
  transform, opacity, image, originX, originY, w, h, x, y, scale) {
  var alpha;
  if (opacity != 1) {
    alpha = context.globalAlpha;
    context.globalAlpha = alpha * opacity;
  }
  if (transform) {
    context.setTransform.apply(context, transform);
  }

  context.drawImage(image, originX, originY, w, h, x, y, w * scale, h * scale);

  if (alpha) {
    context.globalAlpha = alpha;
  }
  if (transform) {
    context.setTransform.apply(context, resetTransform);
  }
}

//# sourceMappingURL=canvas.js.map

/***/ }),

/***/ "./node_modules/ol/render/canvas/ImageReplay.js":
/*!******************************************************!*\
  !*** ./node_modules/ol/render/canvas/ImageReplay.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Instruction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Instruction.js */ "./node_modules/ol/render/canvas/Instruction.js");
/* harmony import */ var _Replay_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Replay.js */ "./node_modules/ol/render/canvas/Replay.js");
/**
 * @module ol/render/canvas/ImageReplay
 */



var CanvasImageReplay = /*@__PURE__*/(function (CanvasReplay) {
  function CanvasImageReplay(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {
    CanvasReplay.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);

    /**
     * @private
     * @type {import("../canvas.js").DeclutterGroup}
     */
    this.declutterGroup_ = null;

    /**
     * @private
     * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
     */
    this.hitDetectionImage_ = null;

    /**
     * @private
     * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
     */
    this.image_ = null;

    /**
     * @private
     * @type {number|undefined}
     */
    this.anchorX_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.anchorY_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.height_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.opacity_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.originX_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.originY_ = undefined;

    /**
     * @private
     * @type {boolean|undefined}
     */
    this.rotateWithView_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.rotation_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.scale_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.width_ = undefined;

  }

  if ( CanvasReplay ) CanvasImageReplay.__proto__ = CanvasReplay;
  CanvasImageReplay.prototype = Object.create( CanvasReplay && CanvasReplay.prototype );
  CanvasImageReplay.prototype.constructor = CanvasImageReplay;

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   * @return {number} My end.
   */
  CanvasImageReplay.prototype.drawCoordinates_ = function drawCoordinates_ (flatCoordinates, offset, end, stride) {
    return this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);
  };

  /**
   * @inheritDoc
   */
  CanvasImageReplay.prototype.drawPoint = function drawPoint (pointGeometry, feature) {
    if (!this.image_) {
      return;
    }
    this.beginGeometry(pointGeometry, feature);
    var flatCoordinates = pointGeometry.getFlatCoordinates();
    var stride = pointGeometry.getStride();
    var myBegin = this.coordinates.length;
    var myEnd = this.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
    this.instructions.push([
      _Instruction_js__WEBPACK_IMPORTED_MODULE_0__["default"].DRAW_IMAGE, myBegin, myEnd, this.image_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_,
      this.originX_, this.originY_, this.rotateWithView_, this.rotation_,
      this.scale_ * this.pixelRatio, this.width_
    ]);
    this.hitDetectionInstructions.push([
      _Instruction_js__WEBPACK_IMPORTED_MODULE_0__["default"].DRAW_IMAGE, myBegin, myEnd, this.hitDetectionImage_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_,
      this.originX_, this.originY_, this.rotateWithView_, this.rotation_,
      this.scale_, this.width_
    ]);
    this.endGeometry(pointGeometry, feature);
  };

  /**
   * @inheritDoc
   */
  CanvasImageReplay.prototype.drawMultiPoint = function drawMultiPoint (multiPointGeometry, feature) {
    if (!this.image_) {
      return;
    }
    this.beginGeometry(multiPointGeometry, feature);
    var flatCoordinates = multiPointGeometry.getFlatCoordinates();
    var stride = multiPointGeometry.getStride();
    var myBegin = this.coordinates.length;
    var myEnd = this.drawCoordinates_(
      flatCoordinates, 0, flatCoordinates.length, stride);
    this.instructions.push([
      _Instruction_js__WEBPACK_IMPORTED_MODULE_0__["default"].DRAW_IMAGE, myBegin, myEnd, this.image_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_,
      this.originX_, this.originY_, this.rotateWithView_, this.rotation_,
      this.scale_ * this.pixelRatio, this.width_
    ]);
    this.hitDetectionInstructions.push([
      _Instruction_js__WEBPACK_IMPORTED_MODULE_0__["default"].DRAW_IMAGE, myBegin, myEnd, this.hitDetectionImage_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_,
      this.originX_, this.originY_, this.rotateWithView_, this.rotation_,
      this.scale_, this.width_
    ]);
    this.endGeometry(multiPointGeometry, feature);
  };

  /**
   * @inheritDoc
   */
  CanvasImageReplay.prototype.finish = function finish () {
    this.reverseHitDetectionInstructions();
    // FIXME this doesn't really protect us against further calls to draw*Geometry
    this.anchorX_ = undefined;
    this.anchorY_ = undefined;
    this.hitDetectionImage_ = null;
    this.image_ = null;
    this.height_ = undefined;
    this.scale_ = undefined;
    this.opacity_ = undefined;
    this.originX_ = undefined;
    this.originY_ = undefined;
    this.rotateWithView_ = undefined;
    this.rotation_ = undefined;
    this.width_ = undefined;
  };

  /**
   * @inheritDoc
   */
  CanvasImageReplay.prototype.setImageStyle = function setImageStyle (imageStyle, declutterGroup) {
    var anchor = imageStyle.getAnchor();
    var size = imageStyle.getSize();
    var hitDetectionImage = imageStyle.getHitDetectionImage(1);
    var image = imageStyle.getImage(1);
    var origin = imageStyle.getOrigin();
    this.anchorX_ = anchor[0];
    this.anchorY_ = anchor[1];
    this.declutterGroup_ = /** @type {import("../canvas.js").DeclutterGroup} */ (declutterGroup);
    this.hitDetectionImage_ = hitDetectionImage;
    this.image_ = image;
    this.height_ = size[1];
    this.opacity_ = imageStyle.getOpacity();
    this.originX_ = origin[0];
    this.originY_ = origin[1];
    this.rotateWithView_ = imageStyle.getRotateWithView();
    this.rotation_ = imageStyle.getRotation();
    this.scale_ = imageStyle.getScale();
    this.width_ = size[0];
  };

  return CanvasImageReplay;
}(_Replay_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (CanvasImageReplay);

//# sourceMappingURL=ImageReplay.js.map

/***/ }),

/***/ "./node_modules/ol/render/canvas/Immediate.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/render/canvas/Immediate.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _colorlike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../colorlike.js */ "./node_modules/ol/colorlike.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../geom/SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../geom/flat/transform.js */ "./node_modules/ol/geom/flat/transform.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _VectorContext_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../VectorContext.js */ "./node_modules/ol/render/VectorContext.js");
/* harmony import */ var _canvas_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/render/canvas/Immediate
 */
// FIXME test, especially polygons with holes and multipolygons
// FIXME need to handle large thick features (where pixel size matters)
// FIXME add offset and end to ol/geom/flat/transform~transform2D?












/**
 * @classdesc
 * A concrete subclass of {@link module:ol/render/VectorContext} that implements
 * direct rendering of features and geometries to an HTML5 Canvas context.
 * Instances of this class are created internally by the library and
 * provided to application code as vectorContext member of the
 * {@link module:ol/render/Event~RenderEvent} object associated with postcompose, precompose and
 * render events emitted by layers and maps.
 */
var CanvasImmediateRenderer = /*@__PURE__*/(function (VectorContext) {
  function CanvasImmediateRenderer(context, pixelRatio, extent, transform, viewRotation) {
    VectorContext.call(this);

    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */
    this.context_ = context;

    /**
     * @private
     * @type {number}
     */
    this.pixelRatio_ = pixelRatio;

    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */
    this.extent_ = extent;

    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */
    this.transform_ = transform;

    /**
     * @private
     * @type {number}
     */
    this.viewRotation_ = viewRotation;

    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */
    this.contextFillState_ = null;

    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */
    this.contextStrokeState_ = null;

    /**
     * @private
     * @type {?import("../canvas.js").TextState}
     */
    this.contextTextState_ = null;

    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */
    this.fillState_ = null;

    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */
    this.strokeState_ = null;

    /**
     * @private
     * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
     */
    this.image_ = null;

    /**
     * @private
     * @type {number}
     */
    this.imageAnchorX_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.imageAnchorY_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.imageHeight_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.imageOpacity_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.imageOriginX_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.imageOriginY_ = 0;

    /**
     * @private
     * @type {boolean}
     */
    this.imageRotateWithView_ = false;

    /**
     * @private
     * @type {number}
     */
    this.imageRotation_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.imageScale_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.imageWidth_ = 0;

    /**
     * @private
     * @type {string}
     */
    this.text_ = '';

    /**
     * @private
     * @type {number}
     */
    this.textOffsetX_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.textOffsetY_ = 0;

    /**
     * @private
     * @type {boolean}
     */
    this.textRotateWithView_ = false;

    /**
     * @private
     * @type {number}
     */
    this.textRotation_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.textScale_ = 0;

    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */
    this.textFillState_ = null;

    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */
    this.textStrokeState_ = null;

    /**
     * @private
     * @type {?import("../canvas.js").TextState}
     */
    this.textState_ = null;

    /**
     * @private
     * @type {Array<number>}
     */
    this.pixelCoordinates_ = [];

    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */
    this.tmpLocalTransform_ = Object(_transform_js__WEBPACK_IMPORTED_MODULE_9__["create"])();

  }

  if ( VectorContext ) CanvasImmediateRenderer.__proto__ = VectorContext;
  CanvasImmediateRenderer.prototype = Object.create( VectorContext && VectorContext.prototype );
  CanvasImmediateRenderer.prototype.constructor = CanvasImmediateRenderer;

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */
  CanvasImmediateRenderer.prototype.drawImages_ = function drawImages_ (flatCoordinates, offset, end, stride) {
    if (!this.image_) {
      return;
    }
    var pixelCoordinates = Object(_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_5__["transform2D"])(
      flatCoordinates, offset, end, 2, this.transform_,
      this.pixelCoordinates_);
    var context = this.context_;
    var localTransform = this.tmpLocalTransform_;
    var alpha = context.globalAlpha;
    if (this.imageOpacity_ != 1) {
      context.globalAlpha = alpha * this.imageOpacity_;
    }
    var rotation = this.imageRotation_;
    if (this.imageRotateWithView_) {
      rotation += this.viewRotation_;
    }
    for (var i = 0, ii = pixelCoordinates.length; i < ii; i += 2) {
      var x = pixelCoordinates[i] - this.imageAnchorX_;
      var y = pixelCoordinates[i + 1] - this.imageAnchorY_;
      if (rotation !== 0 || this.imageScale_ != 1) {
        var centerX = x + this.imageAnchorX_;
        var centerY = y + this.imageAnchorY_;
        Object(_transform_js__WEBPACK_IMPORTED_MODULE_9__["compose"])(localTransform,
          centerX, centerY,
          this.imageScale_, this.imageScale_,
          rotation,
          -centerX, -centerY);
        context.setTransform.apply(context, localTransform);
      }
      context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_,
        this.imageWidth_, this.imageHeight_, x, y,
        this.imageWidth_, this.imageHeight_);
    }
    if (rotation !== 0 || this.imageScale_ != 1) {
      context.setTransform(1, 0, 0, 1, 0, 0);
    }
    if (this.imageOpacity_ != 1) {
      context.globalAlpha = alpha;
    }
  };

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */
  CanvasImmediateRenderer.prototype.drawText_ = function drawText_ (flatCoordinates, offset, end, stride) {
    if (!this.textState_ || this.text_ === '') {
      return;
    }
    if (this.textFillState_) {
      this.setContextFillState_(this.textFillState_);
    }
    if (this.textStrokeState_) {
      this.setContextStrokeState_(this.textStrokeState_);
    }
    this.setContextTextState_(this.textState_);
    var pixelCoordinates = Object(_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_5__["transform2D"])(
      flatCoordinates, offset, end, stride, this.transform_,
      this.pixelCoordinates_);
    var context = this.context_;
    var rotation = this.textRotation_;
    if (this.textRotateWithView_) {
      rotation += this.viewRotation_;
    }
    for (; offset < end; offset += stride) {
      var x = pixelCoordinates[offset] + this.textOffsetX_;
      var y = pixelCoordinates[offset + 1] + this.textOffsetY_;
      if (rotation !== 0 || this.textScale_ != 1) {
        var localTransform = Object(_transform_js__WEBPACK_IMPORTED_MODULE_9__["compose"])(this.tmpLocalTransform_,
          x, y,
          this.textScale_, this.textScale_,
          rotation,
          -x, -y);
        context.setTransform.apply(context, localTransform);
      }
      if (this.textStrokeState_) {
        context.strokeText(this.text_, x, y);
      }
      if (this.textFillState_) {
        context.fillText(this.text_, x, y);
      }
    }
    if (rotation !== 0 || this.textScale_ != 1) {
      context.setTransform(1, 0, 0, 1, 0, 0);
    }
  };

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} close Close.
   * @private
   * @return {number} end End.
   */
  CanvasImmediateRenderer.prototype.moveToLineTo_ = function moveToLineTo_ (flatCoordinates, offset, end, stride, close) {
    var context = this.context_;
    var pixelCoordinates = Object(_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_5__["transform2D"])(
      flatCoordinates, offset, end, stride, this.transform_,
      this.pixelCoordinates_);
    context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);
    var length = pixelCoordinates.length;
    if (close) {
      length -= 2;
    }
    for (var i = 2; i < length; i += 2) {
      context.lineTo(pixelCoordinates[i], pixelCoordinates[i + 1]);
    }
    if (close) {
      context.closePath();
    }
    return end;
  };

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */
  CanvasImmediateRenderer.prototype.drawRings_ = function drawRings_ (flatCoordinates, offset, ends, stride) {
    for (var i = 0, ii = ends.length; i < ii; ++i) {
      offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, true);
    }
    return offset;
  };

  /**
   * Render a circle geometry into the canvas.  Rendering is immediate and uses
   * the current fill and stroke styles.
   *
   * @param {import("../../geom/Circle.js").default} geometry Circle geometry.
   * @override
   * @api
   */
  CanvasImmediateRenderer.prototype.drawCircle = function drawCircle (geometry) {
    if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["intersects"])(this.extent_, geometry.getExtent())) {
      return;
    }
    if (this.fillState_ || this.strokeState_) {
      if (this.fillState_) {
        this.setContextFillState_(this.fillState_);
      }
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
      }
      var pixelCoordinates = Object(_geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_4__["transformGeom2D"])(
        geometry, this.transform_, this.pixelCoordinates_);
      var dx = pixelCoordinates[2] - pixelCoordinates[0];
      var dy = pixelCoordinates[3] - pixelCoordinates[1];
      var radius = Math.sqrt(dx * dx + dy * dy);
      var context = this.context_;
      context.beginPath();
      context.arc(
        pixelCoordinates[0], pixelCoordinates[1], radius, 0, 2 * Math.PI);
      if (this.fillState_) {
        context.fill();
      }
      if (this.strokeState_) {
        context.stroke();
      }
    }
    if (this.text_ !== '') {
      this.drawText_(geometry.getCenter(), 0, 2, 2);
    }
  };

  /**
   * Set the rendering style.  Note that since this is an immediate rendering API,
   * any `zIndex` on the provided style will be ignored.
   *
   * @param {import("../../style/Style.js").default} style The rendering style.
   * @override
   * @api
   */
  CanvasImmediateRenderer.prototype.setStyle = function setStyle (style) {
    this.setFillStrokeStyle(style.getFill(), style.getStroke());
    this.setImageStyle(style.getImage());
    this.setTextStyle(style.getText());
  };

  /**
   * Render a geometry into the canvas.  Call
   * {@link module:ol/render/canvas/Immediate#setStyle} first to set the rendering style.
   *
   * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.
   * @override
   * @api
   */
  CanvasImmediateRenderer.prototype.drawGeometry = function drawGeometry (geometry) {
    var type = geometry.getType();
    switch (type) {
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POINT:
        this.drawPoint(/** @type {import("../../geom/Point.js").default} */ (geometry));
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].LINE_STRING:
        this.drawLineString(/** @type {import("../../geom/LineString.js").default} */ (geometry));
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POLYGON:
        this.drawPolygon(/** @type {import("../../geom/Polygon.js").default} */ (geometry));
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].MULTI_POINT:
        this.drawMultiPoint(/** @type {import("../../geom/MultiPoint.js").default} */ (geometry));
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].MULTI_LINE_STRING:
        this.drawMultiLineString(/** @type {import("../../geom/MultiLineString.js").default} */ (geometry));
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].MULTI_POLYGON:
        this.drawMultiPolygon(/** @type {import("../../geom/MultiPolygon.js").default} */ (geometry));
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].GEOMETRY_COLLECTION:
        this.drawGeometryCollection(/** @type {import("../../geom/GeometryCollection.js").default} */ (geometry));
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].CIRCLE:
        this.drawCircle(/** @type {import("../../geom/Circle.js").default} */ (geometry));
        break;
      default:
    }
  };

  /**
   * Render a feature into the canvas.  Note that any `zIndex` on the provided
   * style will be ignored - features are rendered immediately in the order that
   * this method is called.  If you need `zIndex` support, you should be using an
   * {@link module:ol/layer/Vector~VectorLayer} instead.
   *
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {import("../../style/Style.js").default} style Style.
   * @override
   * @api
   */
  CanvasImmediateRenderer.prototype.drawFeature = function drawFeature (feature, style) {
    var geometry = style.getGeometryFunction()(feature);
    if (!geometry || !Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["intersects"])(this.extent_, geometry.getExtent())) {
      return;
    }
    this.setStyle(style);
    this.drawGeometry(geometry);
  };

  /**
   * Render a GeometryCollection to the canvas.  Rendering is immediate and
   * uses the current styles appropriate for each geometry in the collection.
   *
   * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.
   * @override
   */
  CanvasImmediateRenderer.prototype.drawGeometryCollection = function drawGeometryCollection (geometry) {
    var geometries = geometry.getGeometriesArray();
    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      this.drawGeometry(geometries[i]);
    }
  };

  /**
   * Render a Point geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.
   * @override
   */
  CanvasImmediateRenderer.prototype.drawPoint = function drawPoint (geometry) {
    var flatCoordinates = geometry.getFlatCoordinates();
    var stride = geometry.getStride();
    if (this.image_) {
      this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
    if (this.text_ !== '') {
      this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
  };

  /**
   * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
   * uses the current style.
   *
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.
   * @override
   */
  CanvasImmediateRenderer.prototype.drawMultiPoint = function drawMultiPoint (geometry) {
    var flatCoordinates = geometry.getFlatCoordinates();
    var stride = geometry.getStride();
    if (this.image_) {
      this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
    if (this.text_ !== '') {
      this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
  };

  /**
   * Render a LineString into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.
   * @override
   */
  CanvasImmediateRenderer.prototype.drawLineString = function drawLineString (geometry) {
    if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["intersects"])(this.extent_, geometry.getExtent())) {
      return;
    }
    if (this.strokeState_) {
      this.setContextStrokeState_(this.strokeState_);
      var context = this.context_;
      var flatCoordinates = geometry.getFlatCoordinates();
      context.beginPath();
      this.moveToLineTo_(flatCoordinates, 0, flatCoordinates.length,
        geometry.getStride(), false);
      context.stroke();
    }
    if (this.text_ !== '') {
      var flatMidpoint = geometry.getFlatMidpoint();
      this.drawText_(flatMidpoint, 0, 2, 2);
    }
  };

  /**
   * Render a MultiLineString geometry into the canvas.  Rendering is immediate
   * and uses the current style.
   *
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.
   * @override
   */
  CanvasImmediateRenderer.prototype.drawMultiLineString = function drawMultiLineString (geometry) {
    var geometryExtent = geometry.getExtent();
    if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["intersects"])(this.extent_, geometryExtent)) {
      return;
    }
    if (this.strokeState_) {
      this.setContextStrokeState_(this.strokeState_);
      var context = this.context_;
      var flatCoordinates = geometry.getFlatCoordinates();
      var offset = 0;
      var ends = /** @type {Array<number>} */ (geometry.getEnds());
      var stride = geometry.getStride();
      context.beginPath();
      for (var i = 0, ii = ends.length; i < ii; ++i) {
        offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, false);
      }
      context.stroke();
    }
    if (this.text_ !== '') {
      var flatMidpoints = geometry.getFlatMidpoints();
      this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);
    }
  };

  /**
   * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.
   * @override
   */
  CanvasImmediateRenderer.prototype.drawPolygon = function drawPolygon (geometry) {
    if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["intersects"])(this.extent_, geometry.getExtent())) {
      return;
    }
    if (this.strokeState_ || this.fillState_) {
      if (this.fillState_) {
        this.setContextFillState_(this.fillState_);
      }
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
      }
      var context = this.context_;
      context.beginPath();
      this.drawRings_(geometry.getOrientedFlatCoordinates(),
        0, /** @type {Array<number>} */ (geometry.getEnds()), geometry.getStride());
      if (this.fillState_) {
        context.fill();
      }
      if (this.strokeState_) {
        context.stroke();
      }
    }
    if (this.text_ !== '') {
      var flatInteriorPoint = geometry.getFlatInteriorPoint();
      this.drawText_(flatInteriorPoint, 0, 2, 2);
    }
  };

  /**
   * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
   * uses the current style.
   * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
   * @override
   */
  CanvasImmediateRenderer.prototype.drawMultiPolygon = function drawMultiPolygon (geometry) {
    if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["intersects"])(this.extent_, geometry.getExtent())) {
      return;
    }
    if (this.strokeState_ || this.fillState_) {
      if (this.fillState_) {
        this.setContextFillState_(this.fillState_);
      }
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
      }
      var context = this.context_;
      var flatCoordinates = geometry.getOrientedFlatCoordinates();
      var offset = 0;
      var endss = geometry.getEndss();
      var stride = geometry.getStride();
      context.beginPath();
      for (var i = 0, ii = endss.length; i < ii; ++i) {
        var ends = endss[i];
        offset = this.drawRings_(flatCoordinates, offset, ends, stride);
      }
      if (this.fillState_) {
        context.fill();
      }
      if (this.strokeState_) {
        context.stroke();
      }
    }
    if (this.text_ !== '') {
      var flatInteriorPoints = geometry.getFlatInteriorPoints();
      this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);
    }
  };

  /**
   * @param {import("../canvas.js").FillState} fillState Fill state.
   * @private
   */
  CanvasImmediateRenderer.prototype.setContextFillState_ = function setContextFillState_ (fillState) {
    var context = this.context_;
    var contextFillState = this.contextFillState_;
    if (!contextFillState) {
      context.fillStyle = fillState.fillStyle;
      this.contextFillState_ = {
        fillStyle: fillState.fillStyle
      };
    } else {
      if (contextFillState.fillStyle != fillState.fillStyle) {
        contextFillState.fillStyle = context.fillStyle = fillState.fillStyle;
      }
    }
  };

  /**
   * @param {import("../canvas.js").StrokeState} strokeState Stroke state.
   * @private
   */
  CanvasImmediateRenderer.prototype.setContextStrokeState_ = function setContextStrokeState_ (strokeState) {
    var context = this.context_;
    var contextStrokeState = this.contextStrokeState_;
    if (!contextStrokeState) {
      context.lineCap = /** @type {CanvasLineCap} */ (strokeState.lineCap);
      if (_has_js__WEBPACK_IMPORTED_MODULE_6__["CANVAS_LINE_DASH"]) {
        context.setLineDash(strokeState.lineDash);
        context.lineDashOffset = strokeState.lineDashOffset;
      }
      context.lineJoin = /** @type {CanvasLineJoin} */ (strokeState.lineJoin);
      context.lineWidth = strokeState.lineWidth;
      context.miterLimit = strokeState.miterLimit;
      context.strokeStyle = strokeState.strokeStyle;
      this.contextStrokeState_ = {
        lineCap: strokeState.lineCap,
        lineDash: strokeState.lineDash,
        lineDashOffset: strokeState.lineDashOffset,
        lineJoin: strokeState.lineJoin,
        lineWidth: strokeState.lineWidth,
        miterLimit: strokeState.miterLimit,
        strokeStyle: strokeState.strokeStyle
      };
    } else {
      if (contextStrokeState.lineCap != strokeState.lineCap) {
        contextStrokeState.lineCap = context.lineCap = /** @type {CanvasLineCap} */ (strokeState.lineCap);
      }
      if (_has_js__WEBPACK_IMPORTED_MODULE_6__["CANVAS_LINE_DASH"]) {
        if (!Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["equals"])(contextStrokeState.lineDash, strokeState.lineDash)) {
          context.setLineDash(contextStrokeState.lineDash = strokeState.lineDash);
        }
        if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {
          contextStrokeState.lineDashOffset = context.lineDashOffset =
              strokeState.lineDashOffset;
        }
      }
      if (contextStrokeState.lineJoin != strokeState.lineJoin) {
        contextStrokeState.lineJoin = context.lineJoin = /** @type {CanvasLineJoin} */ (strokeState.lineJoin);
      }
      if (contextStrokeState.lineWidth != strokeState.lineWidth) {
        contextStrokeState.lineWidth = context.lineWidth = strokeState.lineWidth;
      }
      if (contextStrokeState.miterLimit != strokeState.miterLimit) {
        contextStrokeState.miterLimit = context.miterLimit =
            strokeState.miterLimit;
      }
      if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {
        contextStrokeState.strokeStyle = context.strokeStyle =
            strokeState.strokeStyle;
      }
    }
  };

  /**
   * @param {import("../canvas.js").TextState} textState Text state.
   * @private
   */
  CanvasImmediateRenderer.prototype.setContextTextState_ = function setContextTextState_ (textState) {
    var context = this.context_;
    var contextTextState = this.contextTextState_;
    var textAlign = textState.textAlign ?
      textState.textAlign : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultTextAlign"];
    if (!contextTextState) {
      context.font = textState.font;
      context.textAlign = /** @type {CanvasTextAlign} */ (textAlign);
      context.textBaseline = /** @type {CanvasTextBaseline} */ (textState.textBaseline);
      this.contextTextState_ = {
        font: textState.font,
        textAlign: textAlign,
        textBaseline: textState.textBaseline
      };
    } else {
      if (contextTextState.font != textState.font) {
        contextTextState.font = context.font = textState.font;
      }
      if (contextTextState.textAlign != textAlign) {
        contextTextState.textAlign = context.textAlign = /** @type {CanvasTextAlign} */ (textAlign);
      }
      if (contextTextState.textBaseline != textState.textBaseline) {
        contextTextState.textBaseline = context.textBaseline =
          /** @type {CanvasTextBaseline} */ (textState.textBaseline);
      }
    }
  };

  /**
   * Set the fill and stroke style for subsequent draw operations.  To clear
   * either fill or stroke styles, pass null for the appropriate parameter.
   *
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   * @override
   */
  CanvasImmediateRenderer.prototype.setFillStrokeStyle = function setFillStrokeStyle (fillStyle, strokeStyle) {
    if (!fillStyle) {
      this.fillState_ = null;
    } else {
      var fillStyleColor = fillStyle.getColor();
      this.fillState_ = {
        fillStyle: Object(_colorlike_js__WEBPACK_IMPORTED_MODULE_1__["asColorLike"])(fillStyleColor ?
          fillStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultFillStyle"])
      };
    }
    if (!strokeStyle) {
      this.strokeState_ = null;
    } else {
      var strokeStyleColor = strokeStyle.getColor();
      var strokeStyleLineCap = strokeStyle.getLineCap();
      var strokeStyleLineDash = strokeStyle.getLineDash();
      var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
      var strokeStyleLineJoin = strokeStyle.getLineJoin();
      var strokeStyleWidth = strokeStyle.getWidth();
      var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
      this.strokeState_ = {
        lineCap: strokeStyleLineCap !== undefined ?
          strokeStyleLineCap : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultLineCap"],
        lineDash: strokeStyleLineDash ?
          strokeStyleLineDash : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultLineDash"],
        lineDashOffset: strokeStyleLineDashOffset ?
          strokeStyleLineDashOffset : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultLineDashOffset"],
        lineJoin: strokeStyleLineJoin !== undefined ?
          strokeStyleLineJoin : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultLineJoin"],
        lineWidth: this.pixelRatio_ * (strokeStyleWidth !== undefined ?
          strokeStyleWidth : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultLineWidth"]),
        miterLimit: strokeStyleMiterLimit !== undefined ?
          strokeStyleMiterLimit : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultMiterLimit"],
        strokeStyle: Object(_colorlike_js__WEBPACK_IMPORTED_MODULE_1__["asColorLike"])(strokeStyleColor ?
          strokeStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultStrokeStyle"])
      };
    }
  };

  /**
   * Set the image style for subsequent draw operations.  Pass null to remove
   * the image style.
   *
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   * @override
   */
  CanvasImmediateRenderer.prototype.setImageStyle = function setImageStyle (imageStyle) {
    if (!imageStyle) {
      this.image_ = null;
    } else {
      var imageAnchor = imageStyle.getAnchor();
      // FIXME pixel ratio
      var imageImage = imageStyle.getImage(1);
      var imageOrigin = imageStyle.getOrigin();
      var imageSize = imageStyle.getSize();
      this.imageAnchorX_ = imageAnchor[0];
      this.imageAnchorY_ = imageAnchor[1];
      this.imageHeight_ = imageSize[1];
      this.image_ = imageImage;
      this.imageOpacity_ = imageStyle.getOpacity();
      this.imageOriginX_ = imageOrigin[0];
      this.imageOriginY_ = imageOrigin[1];
      this.imageRotateWithView_ = imageStyle.getRotateWithView();
      this.imageRotation_ = imageStyle.getRotation();
      this.imageScale_ = imageStyle.getScale() * this.pixelRatio_;
      this.imageWidth_ = imageSize[0];
    }
  };

  /**
   * Set the text style for subsequent draw operations.  Pass null to
   * remove the text style.
   *
   * @param {import("../../style/Text.js").default} textStyle Text style.
   * @override
   */
  CanvasImmediateRenderer.prototype.setTextStyle = function setTextStyle (textStyle) {
    if (!textStyle) {
      this.text_ = '';
    } else {
      var textFillStyle = textStyle.getFill();
      if (!textFillStyle) {
        this.textFillState_ = null;
      } else {
        var textFillStyleColor = textFillStyle.getColor();
        this.textFillState_ = {
          fillStyle: Object(_colorlike_js__WEBPACK_IMPORTED_MODULE_1__["asColorLike"])(textFillStyleColor ?
            textFillStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultFillStyle"])
        };
      }
      var textStrokeStyle = textStyle.getStroke();
      if (!textStrokeStyle) {
        this.textStrokeState_ = null;
      } else {
        var textStrokeStyleColor = textStrokeStyle.getColor();
        var textStrokeStyleLineCap = textStrokeStyle.getLineCap();
        var textStrokeStyleLineDash = textStrokeStyle.getLineDash();
        var textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();
        var textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();
        var textStrokeStyleWidth = textStrokeStyle.getWidth();
        var textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();
        this.textStrokeState_ = {
          lineCap: textStrokeStyleLineCap !== undefined ?
            textStrokeStyleLineCap : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultLineCap"],
          lineDash: textStrokeStyleLineDash ?
            textStrokeStyleLineDash : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultLineDash"],
          lineDashOffset: textStrokeStyleLineDashOffset ?
            textStrokeStyleLineDashOffset : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultLineDashOffset"],
          lineJoin: textStrokeStyleLineJoin !== undefined ?
            textStrokeStyleLineJoin : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultLineJoin"],
          lineWidth: textStrokeStyleWidth !== undefined ?
            textStrokeStyleWidth : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultLineWidth"],
          miterLimit: textStrokeStyleMiterLimit !== undefined ?
            textStrokeStyleMiterLimit : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultMiterLimit"],
          strokeStyle: Object(_colorlike_js__WEBPACK_IMPORTED_MODULE_1__["asColorLike"])(textStrokeStyleColor ?
            textStrokeStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultStrokeStyle"])
        };
      }
      var textFont = textStyle.getFont();
      var textOffsetX = textStyle.getOffsetX();
      var textOffsetY = textStyle.getOffsetY();
      var textRotateWithView = textStyle.getRotateWithView();
      var textRotation = textStyle.getRotation();
      var textScale = textStyle.getScale();
      var textText = textStyle.getText();
      var textTextAlign = textStyle.getTextAlign();
      var textTextBaseline = textStyle.getTextBaseline();
      this.textState_ = {
        font: textFont !== undefined ?
          textFont : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultFont"],
        textAlign: textTextAlign !== undefined ?
          textTextAlign : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultTextAlign"],
        textBaseline: textTextBaseline !== undefined ?
          textTextBaseline : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultTextBaseline"]
      };
      this.text_ = textText !== undefined ? textText : '';
      this.textOffsetX_ =
          textOffsetX !== undefined ? (this.pixelRatio_ * textOffsetX) : 0;
      this.textOffsetY_ =
          textOffsetY !== undefined ? (this.pixelRatio_ * textOffsetY) : 0;
      this.textRotateWithView_ = textRotateWithView !== undefined ? textRotateWithView : false;
      this.textRotation_ = textRotation !== undefined ? textRotation : 0;
      this.textScale_ = this.pixelRatio_ * (textScale !== undefined ?
        textScale : 1);
    }
  };

  return CanvasImmediateRenderer;
}(_VectorContext_js__WEBPACK_IMPORTED_MODULE_7__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (CanvasImmediateRenderer);

//# sourceMappingURL=Immediate.js.map

/***/ }),

/***/ "./node_modules/ol/render/canvas/Instruction.js":
/*!******************************************************!*\
  !*** ./node_modules/ol/render/canvas/Instruction.js ***!
  \******************************************************/
/*! exports provided: fillInstruction, strokeInstruction, beginPathInstruction, closePathInstruction, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fillInstruction", function() { return fillInstruction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "strokeInstruction", function() { return strokeInstruction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "beginPathInstruction", function() { return beginPathInstruction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "closePathInstruction", function() { return closePathInstruction; });
/**
 * @module ol/render/canvas/Instruction
 */

/**
 * @enum {number}
 */
var Instruction = {
  BEGIN_GEOMETRY: 0,
  BEGIN_PATH: 1,
  CIRCLE: 2,
  CLOSE_PATH: 3,
  CUSTOM: 4,
  DRAW_CHARS: 5,
  DRAW_IMAGE: 6,
  END_GEOMETRY: 7,
  FILL: 8,
  MOVE_TO_LINE_TO: 9,
  SET_FILL_STYLE: 10,
  SET_STROKE_STYLE: 11,
  STROKE: 12
};


/**
 * @type {Array<Instruction>}
 */
var fillInstruction = [Instruction.FILL];


/**
 * @type {Array<Instruction>}
 */
var strokeInstruction = [Instruction.STROKE];


/**
 * @type {Array<Instruction>}
 */
var beginPathInstruction = [Instruction.BEGIN_PATH];


/**
 * @type {Array<Instruction>}
 */
var closePathInstruction = [Instruction.CLOSE_PATH];


/* harmony default export */ __webpack_exports__["default"] = (Instruction);

//# sourceMappingURL=Instruction.js.map

/***/ }),

/***/ "./node_modules/ol/render/canvas/LineStringReplay.js":
/*!***********************************************************!*\
  !*** ./node_modules/ol/render/canvas/LineStringReplay.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Instruction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Instruction.js */ "./node_modules/ol/render/canvas/Instruction.js");
/* harmony import */ var _Replay_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Replay.js */ "./node_modules/ol/render/canvas/Replay.js");
/**
 * @module ol/render/canvas/LineStringReplay
 */



var CanvasLineStringReplay = /*@__PURE__*/(function (CanvasReplay) {
  function CanvasLineStringReplay(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {
    CanvasReplay.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);
  }

  if ( CanvasReplay ) CanvasLineStringReplay.__proto__ = CanvasReplay;
  CanvasLineStringReplay.prototype = Object.create( CanvasReplay && CanvasReplay.prototype );
  CanvasLineStringReplay.prototype.constructor = CanvasLineStringReplay;

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   * @return {number} end.
   */
  CanvasLineStringReplay.prototype.drawFlatCoordinates_ = function drawFlatCoordinates_ (flatCoordinates, offset, end, stride) {
    var myBegin = this.coordinates.length;
    var myEnd = this.appendFlatCoordinates(
      flatCoordinates, offset, end, stride, false, false);
    var moveToLineToInstruction = [_Instruction_js__WEBPACK_IMPORTED_MODULE_0__["default"].MOVE_TO_LINE_TO, myBegin, myEnd];
    this.instructions.push(moveToLineToInstruction);
    this.hitDetectionInstructions.push(moveToLineToInstruction);
    return end;
  };

  /**
   * @inheritDoc
   */
  CanvasLineStringReplay.prototype.drawLineString = function drawLineString (lineStringGeometry, feature) {
    var state = this.state;
    var strokeStyle = state.strokeStyle;
    var lineWidth = state.lineWidth;
    if (strokeStyle === undefined || lineWidth === undefined) {
      return;
    }
    this.updateStrokeStyle(state, this.applyStroke);
    this.beginGeometry(lineStringGeometry, feature);
    this.hitDetectionInstructions.push([
      _Instruction_js__WEBPACK_IMPORTED_MODULE_0__["default"].SET_STROKE_STYLE,
      state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,
      state.miterLimit, state.lineDash, state.lineDashOffset
    ], _Instruction_js__WEBPACK_IMPORTED_MODULE_0__["beginPathInstruction"]);
    var flatCoordinates = lineStringGeometry.getFlatCoordinates();
    var stride = lineStringGeometry.getStride();
    this.drawFlatCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
    this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_0__["strokeInstruction"]);
    this.endGeometry(lineStringGeometry, feature);
  };

  /**
   * @inheritDoc
   */
  CanvasLineStringReplay.prototype.drawMultiLineString = function drawMultiLineString (multiLineStringGeometry, feature) {
    var state = this.state;
    var strokeStyle = state.strokeStyle;
    var lineWidth = state.lineWidth;
    if (strokeStyle === undefined || lineWidth === undefined) {
      return;
    }
    this.updateStrokeStyle(state, this.applyStroke);
    this.beginGeometry(multiLineStringGeometry, feature);
    this.hitDetectionInstructions.push([
      _Instruction_js__WEBPACK_IMPORTED_MODULE_0__["default"].SET_STROKE_STYLE,
      state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,
      state.miterLimit, state.lineDash, state.lineDashOffset
    ], _Instruction_js__WEBPACK_IMPORTED_MODULE_0__["beginPathInstruction"]);
    var ends = multiLineStringGeometry.getEnds();
    var flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
    var stride = multiLineStringGeometry.getStride();
    var offset = 0;
    for (var i = 0, ii = ends.length; i < ii; ++i) {
      offset = this.drawFlatCoordinates_(flatCoordinates, offset, ends[i], stride);
    }
    this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_0__["strokeInstruction"]);
    this.endGeometry(multiLineStringGeometry, feature);
  };

  /**
   * @inheritDoc
   */
  CanvasLineStringReplay.prototype.finish = function finish () {
    var state = this.state;
    if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {
      this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_0__["strokeInstruction"]);
    }
    this.reverseHitDetectionInstructions();
    this.state = null;
  };

  /**
   * @inheritDoc.
   */
  CanvasLineStringReplay.prototype.applyStroke = function applyStroke (state) {
    if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {
      this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_0__["strokeInstruction"]);
      state.lastStroke = this.coordinates.length;
    }
    state.lastStroke = 0;
    CanvasReplay.prototype.applyStroke.call(this, state);
    this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_0__["beginPathInstruction"]);
  };

  return CanvasLineStringReplay;
}(_Replay_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (CanvasLineStringReplay);

//# sourceMappingURL=LineStringReplay.js.map

/***/ }),

/***/ "./node_modules/ol/render/canvas/PolygonReplay.js":
/*!********************************************************!*\
  !*** ./node_modules/ol/render/canvas/PolygonReplay.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../color.js */ "./node_modules/ol/color.js");
/* harmony import */ var _geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../geom/flat/simplify.js */ "./node_modules/ol/geom/flat/simplify.js");
/* harmony import */ var _canvas_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _Instruction_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Instruction.js */ "./node_modules/ol/render/canvas/Instruction.js");
/* harmony import */ var _Replay_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Replay.js */ "./node_modules/ol/render/canvas/Replay.js");
/**
 * @module ol/render/canvas/PolygonReplay
 */







var CanvasPolygonReplay = /*@__PURE__*/(function (CanvasReplay) {
  function CanvasPolygonReplay(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {
    CanvasReplay.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);
  }

  if ( CanvasReplay ) CanvasPolygonReplay.__proto__ = CanvasReplay;
  CanvasPolygonReplay.prototype = Object.create( CanvasReplay && CanvasReplay.prototype );
  CanvasPolygonReplay.prototype.constructor = CanvasPolygonReplay;

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */
  CanvasPolygonReplay.prototype.drawFlatCoordinatess_ = function drawFlatCoordinatess_ (flatCoordinates, offset, ends, stride) {
    var state = this.state;
    var fill = state.fillStyle !== undefined;
    var stroke = state.strokeStyle != undefined;
    var numEnds = ends.length;
    this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["beginPathInstruction"]);
    this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["beginPathInstruction"]);
    for (var i = 0; i < numEnds; ++i) {
      var end = ends[i];
      var myBegin = this.coordinates.length;
      var myEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, true, !stroke);
      var moveToLineToInstruction = [_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].MOVE_TO_LINE_TO, myBegin, myEnd];
      this.instructions.push(moveToLineToInstruction);
      this.hitDetectionInstructions.push(moveToLineToInstruction);
      if (stroke) {
        // Performance optimization: only call closePath() when we have a stroke.
        // Otherwise the ring is closed already (see appendFlatCoordinates above).
        this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["closePathInstruction"]);
        this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["closePathInstruction"]);
      }
      offset = end;
    }
    if (fill) {
      this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["fillInstruction"]);
      this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["fillInstruction"]);
    }
    if (stroke) {
      this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["strokeInstruction"]);
      this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["strokeInstruction"]);
    }
    return offset;
  };

  /**
   * @inheritDoc
   */
  CanvasPolygonReplay.prototype.drawCircle = function drawCircle (circleGeometry, feature) {
    var state = this.state;
    var fillStyle = state.fillStyle;
    var strokeStyle = state.strokeStyle;
    if (fillStyle === undefined && strokeStyle === undefined) {
      return;
    }
    this.setFillStrokeStyles_(circleGeometry);
    this.beginGeometry(circleGeometry, feature);
    if (state.fillStyle !== undefined) {
      this.hitDetectionInstructions.push([
        _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].SET_FILL_STYLE,
        Object(_color_js__WEBPACK_IMPORTED_MODULE_0__["asString"])(_canvas_js__WEBPACK_IMPORTED_MODULE_2__["defaultFillStyle"])
      ]);
    }
    if (state.strokeStyle !== undefined) {
      this.hitDetectionInstructions.push([
        _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].SET_STROKE_STYLE,
        state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,
        state.miterLimit, state.lineDash, state.lineDashOffset
      ]);
    }
    var flatCoordinates = circleGeometry.getFlatCoordinates();
    var stride = circleGeometry.getStride();
    var myBegin = this.coordinates.length;
    this.appendFlatCoordinates(
      flatCoordinates, 0, flatCoordinates.length, stride, false, false);
    var circleInstruction = [_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].CIRCLE, myBegin];
    this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["beginPathInstruction"], circleInstruction);
    this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["beginPathInstruction"], circleInstruction);
    this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["fillInstruction"]);
    if (state.fillStyle !== undefined) {
      this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["fillInstruction"]);
    }
    if (state.strokeStyle !== undefined) {
      this.instructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["strokeInstruction"]);
      this.hitDetectionInstructions.push(_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["strokeInstruction"]);
    }
    this.endGeometry(circleGeometry, feature);
  };

  /**
   * @inheritDoc
   */
  CanvasPolygonReplay.prototype.drawPolygon = function drawPolygon (polygonGeometry, feature) {
    var state = this.state;
    var fillStyle = state.fillStyle;
    var strokeStyle = state.strokeStyle;
    if (fillStyle === undefined && strokeStyle === undefined) {
      return;
    }
    this.setFillStrokeStyles_(polygonGeometry);
    this.beginGeometry(polygonGeometry, feature);
    if (state.fillStyle !== undefined) {
      this.hitDetectionInstructions.push([
        _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].SET_FILL_STYLE,
        Object(_color_js__WEBPACK_IMPORTED_MODULE_0__["asString"])(_canvas_js__WEBPACK_IMPORTED_MODULE_2__["defaultFillStyle"])
      ]);
    }
    if (state.strokeStyle !== undefined) {
      this.hitDetectionInstructions.push([
        _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].SET_STROKE_STYLE,
        state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,
        state.miterLimit, state.lineDash, state.lineDashOffset
      ]);
    }
    var ends = polygonGeometry.getEnds();
    var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();
    var stride = polygonGeometry.getStride();
    this.drawFlatCoordinatess_(flatCoordinates, 0, ends, stride);
    this.endGeometry(polygonGeometry, feature);
  };

  /**
   * @inheritDoc
   */
  CanvasPolygonReplay.prototype.drawMultiPolygon = function drawMultiPolygon (multiPolygonGeometry, feature) {
    var state = this.state;
    var fillStyle = state.fillStyle;
    var strokeStyle = state.strokeStyle;
    if (fillStyle === undefined && strokeStyle === undefined) {
      return;
    }
    this.setFillStrokeStyles_(multiPolygonGeometry);
    this.beginGeometry(multiPolygonGeometry, feature);
    if (state.fillStyle !== undefined) {
      this.hitDetectionInstructions.push([
        _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].SET_FILL_STYLE,
        Object(_color_js__WEBPACK_IMPORTED_MODULE_0__["asString"])(_canvas_js__WEBPACK_IMPORTED_MODULE_2__["defaultFillStyle"])
      ]);
    }
    if (state.strokeStyle !== undefined) {
      this.hitDetectionInstructions.push([
        _Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].SET_STROKE_STYLE,
        state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,
        state.miterLimit, state.lineDash, state.lineDashOffset
      ]);
    }
    var endss = multiPolygonGeometry.getEndss();
    var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();
    var stride = multiPolygonGeometry.getStride();
    var offset = 0;
    for (var i = 0, ii = endss.length; i < ii; ++i) {
      offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);
    }
    this.endGeometry(multiPolygonGeometry, feature);
  };

  /**
   * @inheritDoc
   */
  CanvasPolygonReplay.prototype.finish = function finish () {
    this.reverseHitDetectionInstructions();
    this.state = null;
    // We want to preserve topology when drawing polygons.  Polygons are
    // simplified using quantization and point elimination. However, we might
    // have received a mix of quantized and non-quantized geometries, so ensure
    // that all are quantized by quantizing all coordinates in the batch.
    var tolerance = this.tolerance;
    if (tolerance !== 0) {
      var coordinates = this.coordinates;
      for (var i = 0, ii = coordinates.length; i < ii; ++i) {
        coordinates[i] = Object(_geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_1__["snap"])(coordinates[i], tolerance);
      }
    }
  };

  /**
   * @private
   * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry Geometry.
   */
  CanvasPolygonReplay.prototype.setFillStrokeStyles_ = function setFillStrokeStyles_ (geometry) {
    var state = this.state;
    var fillStyle = state.fillStyle;
    if (fillStyle !== undefined) {
      this.updateFillStyle(state, this.createFill, geometry);
    }
    if (state.strokeStyle !== undefined) {
      this.updateStrokeStyle(state, this.applyStroke);
    }
  };

  return CanvasPolygonReplay;
}(_Replay_js__WEBPACK_IMPORTED_MODULE_4__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (CanvasPolygonReplay);

//# sourceMappingURL=PolygonReplay.js.map

/***/ }),

/***/ "./node_modules/ol/render/canvas/Replay.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/render/canvas/Replay.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _colorlike_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../colorlike.js */ "./node_modules/ol/colorlike.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../extent/Relationship.js */ "./node_modules/ol/extent/Relationship.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../geom/flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _geom_flat_length_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../geom/flat/length.js */ "./node_modules/ol/geom/flat/length.js");
/* harmony import */ var _geom_flat_textpath_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../geom/flat/textpath.js */ "./node_modules/ol/geom/flat/textpath.js");
/* harmony import */ var _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../geom/flat/transform.js */ "./node_modules/ol/geom/flat/transform.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _VectorContext_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../VectorContext.js */ "./node_modules/ol/render/VectorContext.js");
/* harmony import */ var _canvas_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _Instruction_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Instruction.js */ "./node_modules/ol/render/canvas/Instruction.js");
/* harmony import */ var _replay_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../replay.js */ "./node_modules/ol/render/replay.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/render/canvas/Replay
 */



















/**
 * @type {import("../../extent.js").Extent}
 */
var tmpExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__["createEmpty"])();


/**
 * @type {!import("../../transform.js").Transform}
 */
var tmpTransform = Object(_transform_js__WEBPACK_IMPORTED_MODULE_16__["create"])();


var CanvasReplay = /*@__PURE__*/(function (VectorContext) {
  function CanvasReplay(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {
    VectorContext.call(this);

    /**
     * @type {?}
     */
    this.declutterTree = declutterTree;

    /**
     * @protected
     * @type {number}
     */
    this.tolerance = tolerance;

    /**
     * @protected
     * @const
     * @type {import("../../extent.js").Extent}
     */
    this.maxExtent = maxExtent;

    /**
     * @protected
     * @type {boolean}
     */
    this.overlaps = overlaps;

    /**
     * @protected
     * @type {number}
     */
    this.pixelRatio = pixelRatio;

    /**
     * @protected
     * @type {number}
     */
    this.maxLineWidth = 0;

    /**
     * @protected
     * @const
     * @type {number}
     */
    this.resolution = resolution;

    /**
     * @private
     * @type {boolean}
     */
    this.alignFill_;

    /**
     * @private
     * @type {Array<*>}
     */
    this.beginGeometryInstruction1_ = null;

    /**
     * @private
     * @type {Array<*>}
     */
    this.beginGeometryInstruction2_ = null;

    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */
    this.bufferedMaxExtent_ = null;

    /**
     * @protected
     * @type {Array<*>}
     */
    this.instructions = [];

    /**
     * @protected
     * @type {Array<number>}
     */
    this.coordinates = [];

    /**
     * @private
     * @type {!Object<number,import("../../coordinate.js").Coordinate|Array<import("../../coordinate.js").Coordinate>|Array<Array<import("../../coordinate.js").Coordinate>>>}
     */
    this.coordinateCache_ = {};

    /**
     * @private
     * @type {!import("../../transform.js").Transform}
     */
    this.renderedTransform_ = Object(_transform_js__WEBPACK_IMPORTED_MODULE_16__["create"])();

    /**
     * @protected
     * @type {Array<*>}
     */
    this.hitDetectionInstructions = [];

    /**
     * @private
     * @type {Array<number>}
     */
    this.pixelCoordinates_ = null;

    /**
     * @protected
     * @type {import("../canvas.js").FillStrokeState}
     */
    this.state = /** @type {import("../canvas.js").FillStrokeState} */ ({});

    /**
     * @private
     * @type {number}
     */
    this.viewRotation_ = 0;

  }

  if ( VectorContext ) CanvasReplay.__proto__ = VectorContext;
  CanvasReplay.prototype = Object.create( VectorContext && VectorContext.prototype );
  CanvasReplay.prototype.constructor = CanvasReplay;

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../coordinate.js").Coordinate} p1 1st point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p2 2nd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p3 3rd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p4 4th point of the background box.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   */
  CanvasReplay.prototype.replayTextBackground_ = function replayTextBackground_ (context, p1, p2, p3, p4, fillInstruction, strokeInstruction) {
    context.beginPath();
    context.moveTo.apply(context, p1);
    context.lineTo.apply(context, p2);
    context.lineTo.apply(context, p3);
    context.lineTo.apply(context, p4);
    context.lineTo.apply(context, p1);
    if (fillInstruction) {
      this.alignFill_ = /** @type {boolean} */ (fillInstruction[2]);
      this.fill_(context);
    }
    if (strokeInstruction) {
      this.setStrokeStyle_(context, /** @type {Array<*>} */ (strokeInstruction));
      context.stroke();
    }
  };

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} image Image.
   * @param {number} anchorX Anchor X.
   * @param {number} anchorY Anchor Y.
   * @param {import("../canvas.js").DeclutterGroup} declutterGroup Declutter group.
   * @param {number} height Height.
   * @param {number} opacity Opacity.
   * @param {number} originX Origin X.
   * @param {number} originY Origin Y.
   * @param {number} rotation Rotation.
   * @param {number} scale Scale.
   * @param {boolean} snapToPixel Snap to pixel.
   * @param {number} width Width.
   * @param {Array<number>} padding Padding.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   */
  CanvasReplay.prototype.replayImage_ = function replayImage_ (
    context,
    x,
    y,
    image,
    anchorX,
    anchorY,
    declutterGroup,
    height,
    opacity,
    originX,
    originY,
    rotation,
    scale,
    snapToPixel,
    width,
    padding,
    fillInstruction,
    strokeInstruction
  ) {
    var fillStroke = fillInstruction || strokeInstruction;
    anchorX *= scale;
    anchorY *= scale;
    x -= anchorX;
    y -= anchorY;

    var w = (width + originX > image.width) ? image.width - originX : width;
    var h = (height + originY > image.height) ? image.height - originY : height;
    var boxW = padding[3] + w * scale + padding[1];
    var boxH = padding[0] + h * scale + padding[2];
    var boxX = x - padding[3];
    var boxY = y - padding[0];

    /** @type {import("../../coordinate.js").Coordinate} */
    var p1;
    /** @type {import("../../coordinate.js").Coordinate} */
    var p2;
    /** @type {import("../../coordinate.js").Coordinate} */
    var p3;
    /** @type {import("../../coordinate.js").Coordinate} */
    var p4;
    if (fillStroke || rotation !== 0) {
      p1 = [boxX, boxY];
      p2 = [boxX + boxW, boxY];
      p3 = [boxX + boxW, boxY + boxH];
      p4 = [boxX, boxY + boxH];
    }

    var transform = null;
    if (rotation !== 0) {
      var centerX = x + anchorX;
      var centerY = y + anchorY;
      transform = Object(_transform_js__WEBPACK_IMPORTED_MODULE_16__["compose"])(tmpTransform, centerX, centerY, 1, 1, rotation, -centerX, -centerY);

      Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__["createOrUpdateEmpty"])(tmpExtent);
      Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__["extendCoordinate"])(tmpExtent, Object(_transform_js__WEBPACK_IMPORTED_MODULE_16__["apply"])(tmpTransform, p1));
      Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__["extendCoordinate"])(tmpExtent, Object(_transform_js__WEBPACK_IMPORTED_MODULE_16__["apply"])(tmpTransform, p2));
      Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__["extendCoordinate"])(tmpExtent, Object(_transform_js__WEBPACK_IMPORTED_MODULE_16__["apply"])(tmpTransform, p3));
      Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__["extendCoordinate"])(tmpExtent, Object(_transform_js__WEBPACK_IMPORTED_MODULE_16__["apply"])(tmpTransform, p4));
    } else {
      Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__["createOrUpdate"])(boxX, boxY, boxX + boxW, boxY + boxH, tmpExtent);
    }
    var canvas = context.canvas;
    var strokePadding = strokeInstruction ? (strokeInstruction[2] * scale / 2) : 0;
    var intersects =
        tmpExtent[0] - strokePadding <= canvas.width && tmpExtent[2] + strokePadding >= 0 &&
        tmpExtent[1] - strokePadding <= canvas.height && tmpExtent[3] + strokePadding >= 0;

    if (snapToPixel) {
      x = Math.round(x);
      y = Math.round(y);
    }

    if (declutterGroup) {
      if (!intersects && declutterGroup[4] == 1) {
        return;
      }
      Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__["extend"])(declutterGroup, tmpExtent);
      var declutterArgs = intersects ?
        [context, transform ? transform.slice(0) : null, opacity, image, originX, originY, w, h, x, y, scale] :
        null;
      if (declutterArgs && fillStroke) {
        declutterArgs.push(fillInstruction, strokeInstruction, p1, p2, p3, p4);
      }
      declutterGroup.push(declutterArgs);
    } else if (intersects) {
      if (fillStroke) {
        this.replayTextBackground_(context, p1, p2, p3, p4,
          /** @type {Array<*>} */ (fillInstruction),
          /** @type {Array<*>} */ (strokeInstruction));
      }
      Object(_canvas_js__WEBPACK_IMPORTED_MODULE_13__["drawImage"])(context, transform, opacity, image, originX, originY, w, h, x, y, scale);
    }
  };

  /**
   * @protected
   * @param {Array<number>} dashArray Dash array.
   * @return {Array<number>} Dash array with pixel ratio applied
   */
  CanvasReplay.prototype.applyPixelRatio = function applyPixelRatio (dashArray) {
    var pixelRatio = this.pixelRatio;
    return pixelRatio == 1 ? dashArray : dashArray.map(function(dash) {
      return dash * pixelRatio;
    });
  };

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} closed Last input coordinate equals first.
   * @param {boolean} skipFirst Skip first coordinate.
   * @protected
   * @return {number} My end.
   */
  CanvasReplay.prototype.appendFlatCoordinates = function appendFlatCoordinates (flatCoordinates, offset, end, stride, closed, skipFirst) {

    var myEnd = this.coordinates.length;
    var extent = this.getBufferedMaxExtent();
    if (skipFirst) {
      offset += stride;
    }
    var lastCoord = [flatCoordinates[offset], flatCoordinates[offset + 1]];
    var nextCoord = [NaN, NaN];
    var skipped = true;

    var i, lastRel, nextRel;
    for (i = offset + stride; i < end; i += stride) {
      nextCoord[0] = flatCoordinates[i];
      nextCoord[1] = flatCoordinates[i + 1];
      nextRel = Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__["coordinateRelationship"])(extent, nextCoord);
      if (nextRel !== lastRel) {
        if (skipped) {
          this.coordinates[myEnd++] = lastCoord[0];
          this.coordinates[myEnd++] = lastCoord[1];
        }
        this.coordinates[myEnd++] = nextCoord[0];
        this.coordinates[myEnd++] = nextCoord[1];
        skipped = false;
      } else if (nextRel === _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_4__["default"].INTERSECTING) {
        this.coordinates[myEnd++] = nextCoord[0];
        this.coordinates[myEnd++] = nextCoord[1];
        skipped = false;
      } else {
        skipped = true;
      }
      lastCoord[0] = nextCoord[0];
      lastCoord[1] = nextCoord[1];
      lastRel = nextRel;
    }

    // Last coordinate equals first or only one point to append:
    if ((closed && skipped) || i === offset + stride) {
      this.coordinates[myEnd++] = lastCoord[0];
      this.coordinates[myEnd++] = lastCoord[1];
    }
    return myEnd;
  };

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Array<number>} replayEnds Replay ends.
   * @return {number} Offset.
   */
  CanvasReplay.prototype.drawCustomCoordinates_ = function drawCustomCoordinates_ (flatCoordinates, offset, ends, stride, replayEnds) {
    for (var i = 0, ii = ends.length; i < ii; ++i) {
      var end = ends[i];
      var replayEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);
      replayEnds.push(replayEnd);
      offset = end;
    }
    return offset;
  };

  /**
   * @inheritDoc.
   */
  CanvasReplay.prototype.drawCustom = function drawCustom (geometry, feature, renderer) {
    this.beginGeometry(geometry, feature);
    var type = geometry.getType();
    var stride = geometry.getStride();
    var replayBegin = this.coordinates.length;
    var flatCoordinates, replayEnd, replayEnds, replayEndss;
    var offset;
    if (type == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].MULTI_POLYGON) {
      geometry = /** @type {import("../../geom/MultiPolygon.js").default} */ (geometry);
      flatCoordinates = geometry.getOrientedFlatCoordinates();
      replayEndss = [];
      var endss = geometry.getEndss();
      offset = 0;
      for (var i = 0, ii = endss.length; i < ii; ++i) {
        var myEnds = [];
        offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);
        replayEndss.push(myEnds);
      }
      this.instructions.push([_Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].CUSTOM,
        replayBegin, replayEndss, geometry, renderer, _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_6__["inflateMultiCoordinatesArray"]]);
    } else if (type == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POLYGON || type == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].MULTI_LINE_STRING) {
      replayEnds = [];
      flatCoordinates = (type == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POLYGON) ?
        /** @type {import("../../geom/Polygon.js").default} */ (geometry).getOrientedFlatCoordinates() :
        geometry.getFlatCoordinates();
      offset = this.drawCustomCoordinates_(flatCoordinates, 0,
        /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */ (geometry).getEnds(),
        stride, replayEnds);
      this.instructions.push([_Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].CUSTOM,
        replayBegin, replayEnds, geometry, renderer, _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_6__["inflateCoordinatesArray"]]);
    } else if (type == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].LINE_STRING || type == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].MULTI_POINT) {
      flatCoordinates = geometry.getFlatCoordinates();
      replayEnd = this.appendFlatCoordinates(
        flatCoordinates, 0, flatCoordinates.length, stride, false, false);
      this.instructions.push([_Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].CUSTOM,
        replayBegin, replayEnd, geometry, renderer, _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_6__["inflateCoordinates"]]);
    } else if (type == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POINT) {
      flatCoordinates = geometry.getFlatCoordinates();
      this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);
      replayEnd = this.coordinates.length;
      this.instructions.push([_Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].CUSTOM,
        replayBegin, replayEnd, geometry, renderer]);
    }
    this.endGeometry(geometry, feature);
  };

  /**
   * @protected
   * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry Geometry.
   * @param {import("../../Feature.js").default|import("../Feature.js").default} feature Feature.
   */
  CanvasReplay.prototype.beginGeometry = function beginGeometry (geometry, feature) {
    this.beginGeometryInstruction1_ = [_Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].BEGIN_GEOMETRY, feature, 0];
    this.instructions.push(this.beginGeometryInstruction1_);
    this.beginGeometryInstruction2_ = [_Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].BEGIN_GEOMETRY, feature, 0];
    this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
  };

  /**
   * FIXME empty description for jsdoc
   */
  CanvasReplay.prototype.finish = function finish () {};

  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   */
  CanvasReplay.prototype.fill_ = function fill_ (context) {
    if (this.alignFill_) {
      var origin = Object(_transform_js__WEBPACK_IMPORTED_MODULE_16__["apply"])(this.renderedTransform_, [0, 0]);
      var repeatSize = 512 * this.pixelRatio;
      context.translate(origin[0] % repeatSize, origin[1] % repeatSize);
      context.rotate(this.viewRotation_);
    }
    context.fill();
    if (this.alignFill_) {
      context.setTransform.apply(context, _canvas_js__WEBPACK_IMPORTED_MODULE_13__["resetTransform"]);
    }
  };

  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {Array<*>} instruction Instruction.
   */
  CanvasReplay.prototype.setStrokeStyle_ = function setStrokeStyle_ (context, instruction) {
    context.strokeStyle = /** @type {import("../../colorlike.js").ColorLike} */ (instruction[1]);
    context.lineWidth = /** @type {number} */ (instruction[2]);
    context.lineCap = /** @type {CanvasLineCap} */ (instruction[3]);
    context.lineJoin = /** @type {CanvasLineJoin} */ (instruction[4]);
    context.miterLimit = /** @type {number} */ (instruction[5]);
    if (_has_js__WEBPACK_IMPORTED_MODULE_10__["CANVAS_LINE_DASH"]) {
      context.lineDashOffset = /** @type {number} */ (instruction[7]);
      context.setLineDash(/** @type {Array<number>} */ (instruction[6]));
    }
  };

  /**
   * @param {import("../canvas.js").DeclutterGroup} declutterGroup Declutter group.
   * @param {import("../../Feature.js").default|import("../Feature.js").default} feature Feature.
   */
  CanvasReplay.prototype.renderDeclutter_ = function renderDeclutter_ (declutterGroup, feature) {
    if (declutterGroup && declutterGroup.length > 5) {
      var groupCount = declutterGroup[4];
      if (groupCount == 1 || groupCount == declutterGroup.length - 5) {
        /** @type {import("../../structs/RBush.js").Entry} */
        var box = {
          minX: /** @type {number} */ (declutterGroup[0]),
          minY: /** @type {number} */ (declutterGroup[1]),
          maxX: /** @type {number} */ (declutterGroup[2]),
          maxY: /** @type {number} */ (declutterGroup[3]),
          value: feature
        };
        if (!this.declutterTree.collides(box)) {
          this.declutterTree.insert(box);
          for (var j = 5, jj = declutterGroup.length; j < jj; ++j) {
            var declutterData = /** @type {Array} */ (declutterGroup[j]);
            if (declutterData) {
              if (declutterData.length > 11) {
                this.replayTextBackground_(declutterData[0],
                  declutterData[13], declutterData[14], declutterData[15], declutterData[16],
                  declutterData[11], declutterData[12]);
              }
              _canvas_js__WEBPACK_IMPORTED_MODULE_13__["drawImage"].apply(undefined, declutterData);
            }
          }
        }
        declutterGroup.length = 5;
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__["createOrUpdateEmpty"])(declutterGroup);
      }
    }
  };

  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {Object<string, boolean>} skippedFeaturesHash Ids of features
   *     to skip.
   * @param {Array<*>} instructions Instructions array.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {function((import("../../Feature.js").default|import("../Feature.js").default)): T|undefined} featureCallback Feature callback.
   * @param {import("../../extent.js").Extent=} opt_hitExtent Only check features that intersect this
   *     extent.
   * @return {T|undefined} Callback result.
   * @template T
   */
  CanvasReplay.prototype.replay_ = function replay_ (
    context,
    transform,
    skippedFeaturesHash,
    instructions,
    snapToPixel,
    featureCallback,
    opt_hitExtent
  ) {
    /** @type {Array<number>} */
    var pixelCoordinates;
    if (this.pixelCoordinates_ && Object(_array_js__WEBPACK_IMPORTED_MODULE_1__["equals"])(transform, this.renderedTransform_)) {
      pixelCoordinates = this.pixelCoordinates_;
    } else {
      if (!this.pixelCoordinates_) {
        this.pixelCoordinates_ = [];
      }
      pixelCoordinates = Object(_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_9__["transform2D"])(
        this.coordinates, 0, this.coordinates.length, 2,
        transform, this.pixelCoordinates_);
      Object(_transform_js__WEBPACK_IMPORTED_MODULE_16__["setFromArray"])(this.renderedTransform_, transform);
    }
    var skipFeatures = !Object(_obj_js__WEBPACK_IMPORTED_MODULE_11__["isEmpty"])(skippedFeaturesHash);
    var i = 0; // instruction index
    var ii = instructions.length; // end of instructions
    var d = 0; // data index
    var dd; // end of per-instruction data
    var anchorX, anchorY, prevX, prevY, roundX, roundY, declutterGroup, image;
    var pendingFill = 0;
    var pendingStroke = 0;
    var lastFillInstruction = null;
    var lastStrokeInstruction = null;
    var coordinateCache = this.coordinateCache_;
    var viewRotation = this.viewRotation_;

    var state = /** @type {import("../../render.js").State} */ ({
      context: context,
      pixelRatio: this.pixelRatio,
      resolution: this.resolution,
      rotation: viewRotation
    });

    // When the batch size gets too big, performance decreases. 200 is a good
    // balance between batch size and number of fill/stroke instructions.
    var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;
    var /** @type {import("../../Feature.js").default|import("../Feature.js").default} */ feature;
    var x, y;
    while (i < ii) {
      var instruction = instructions[i];
      var type = /** @type {CanvasInstruction} */ (instruction[0]);
      switch (type) {
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].BEGIN_GEOMETRY:
          feature = /** @type {import("../../Feature.js").default|import("../Feature.js").default} */ (instruction[1]);
          if ((skipFeatures && skippedFeaturesHash[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature)]) || !feature.getGeometry()) {
            i = /** @type {number} */ (instruction[2]);
          } else if (opt_hitExtent !== undefined && !Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__["intersects"])(
            opt_hitExtent, feature.getGeometry().getExtent())) {
            i = /** @type {number} */ (instruction[2]) + 1;
          } else {
            ++i;
          }
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].BEGIN_PATH:
          if (pendingFill > batchSize) {
            this.fill_(context);
            pendingFill = 0;
          }
          if (pendingStroke > batchSize) {
            context.stroke();
            pendingStroke = 0;
          }
          if (!pendingFill && !pendingStroke) {
            context.beginPath();
            prevX = prevY = NaN;
          }
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].CIRCLE:
          d = /** @type {number} */ (instruction[1]);
          var x1 = pixelCoordinates[d];
          var y1 = pixelCoordinates[d + 1];
          var x2 = pixelCoordinates[d + 2];
          var y2 = pixelCoordinates[d + 3];
          var dx = x2 - x1;
          var dy = y2 - y1;
          var r = Math.sqrt(dx * dx + dy * dy);
          context.moveTo(x1 + r, y1);
          context.arc(x1, y1, r, 0, 2 * Math.PI, true);
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].CLOSE_PATH:
          context.closePath();
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].CUSTOM:
          d = /** @type {number} */ (instruction[1]);
          dd = instruction[2];
          var geometry = /** @type {import("../../geom/SimpleGeometry.js").default} */ (instruction[3]);
          var renderer = instruction[4];
          var fn = instruction.length == 6 ? instruction[5] : undefined;
          state.geometry = geometry;
          state.feature = feature;
          if (!(i in coordinateCache)) {
            coordinateCache[i] = [];
          }
          var coords = coordinateCache[i];
          if (fn) {
            fn(pixelCoordinates, d, dd, 2, coords);
          } else {
            coords[0] = pixelCoordinates[d];
            coords[1] = pixelCoordinates[d + 1];
            coords.length = 2;
          }
          renderer(coords, state);
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].DRAW_IMAGE:
          d = /** @type {number} */ (instruction[1]);
          dd = /** @type {number} */ (instruction[2]);
          image = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */
              (instruction[3]);
          // Remaining arguments in DRAW_IMAGE are in alphabetical order
          anchorX = /** @type {number} */ (instruction[4]);
          anchorY = /** @type {number} */ (instruction[5]);
          declutterGroup = featureCallback ? null : /** @type {import("../canvas.js").DeclutterGroup} */ (instruction[6]);
          var height = /** @type {number} */ (instruction[7]);
          var opacity = /** @type {number} */ (instruction[8]);
          var originX = /** @type {number} */ (instruction[9]);
          var originY = /** @type {number} */ (instruction[10]);
          var rotateWithView = /** @type {boolean} */ (instruction[11]);
          var rotation = /** @type {number} */ (instruction[12]);
          var scale = /** @type {number} */ (instruction[13]);
          var width = /** @type {number} */ (instruction[14]);

          var padding = (void 0), backgroundFill = (void 0), backgroundStroke = (void 0);
          if (instruction.length > 16) {
            padding = /** @type {Array<number>} */ (instruction[15]);
            backgroundFill = /** @type {boolean} */ (instruction[16]);
            backgroundStroke = /** @type {boolean} */ (instruction[17]);
          } else {
            padding = _canvas_js__WEBPACK_IMPORTED_MODULE_13__["defaultPadding"];
            backgroundFill = backgroundStroke = false;
          }

          if (rotateWithView) {
            rotation += viewRotation;
          }
          for (; d < dd; d += 2) {
            this.replayImage_(context,
              pixelCoordinates[d], pixelCoordinates[d + 1], image, anchorX, anchorY,
              declutterGroup, height, opacity, originX, originY, rotation, scale,
              snapToPixel, width, padding,
              backgroundFill ? /** @type {Array<*>} */ (lastFillInstruction) : null,
              backgroundStroke ? /** @type {Array<*>} */ (lastStrokeInstruction) : null);
          }
          this.renderDeclutter_(declutterGroup, feature);
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].DRAW_CHARS:
          var begin = /** @type {number} */ (instruction[1]);
          var end = /** @type {number} */ (instruction[2]);
          var baseline = /** @type {number} */ (instruction[3]);
          declutterGroup = featureCallback ? null : /** @type {import("../canvas.js").DeclutterGroup} */ (instruction[4]);
          var overflow = /** @type {number} */ (instruction[5]);
          var fillKey = /** @type {string} */ (instruction[6]);
          var maxAngle = /** @type {number} */ (instruction[7]);
          var measure = /** @type {function(string):number} */ (instruction[8]);
          var offsetY = /** @type {number} */ (instruction[9]);
          var strokeKey = /** @type {string} */ (instruction[10]);
          var strokeWidth = /** @type {number} */ (instruction[11]);
          var text = /** @type {string} */ (instruction[12]);
          var textKey = /** @type {string} */ (instruction[13]);
          var textScale = /** @type {number} */ (instruction[14]);

          var pathLength = Object(_geom_flat_length_js__WEBPACK_IMPORTED_MODULE_7__["lineStringLength"])(pixelCoordinates, begin, end, 2);
          var textLength = measure(text);
          if (overflow || textLength <= pathLength) {
            /** @type {import("./TextReplay.js").default} */
            var textReplay = /** @type {?} */ (this);
            var textAlign = textReplay.textStates[textKey].textAlign;
            var startM = (pathLength - textLength) * _replay_js__WEBPACK_IMPORTED_MODULE_15__["TEXT_ALIGN"][textAlign];
            var parts = Object(_geom_flat_textpath_js__WEBPACK_IMPORTED_MODULE_8__["drawTextOnPath"])(
              pixelCoordinates, begin, end, 2, text, measure, startM, maxAngle);
            if (parts) {
              var c = (void 0), cc = (void 0), chars = (void 0), label = (void 0), part = (void 0);
              if (strokeKey) {
                for (c = 0, cc = parts.length; c < cc; ++c) {
                  part = parts[c]; // x, y, anchorX, rotation, chunk
                  chars = /** @type {string} */ (part[4]);
                  label = textReplay.getImage(chars, textKey, '', strokeKey);
                  anchorX = /** @type {number} */ (part[2]) + strokeWidth;
                  anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth - offsetY;
                  this.replayImage_(context,
                    /** @type {number} */ (part[0]), /** @type {number} */ (part[1]), label,
                    anchorX, anchorY, declutterGroup, label.height, 1, 0, 0,
                    /** @type {number} */ (part[3]), textScale, false, label.width,
                    _canvas_js__WEBPACK_IMPORTED_MODULE_13__["defaultPadding"], null, null);
                }
              }
              if (fillKey) {
                for (c = 0, cc = parts.length; c < cc; ++c) {
                  part = parts[c]; // x, y, anchorX, rotation, chunk
                  chars = /** @type {string} */ (part[4]);
                  label = textReplay.getImage(chars, textKey, fillKey, '');
                  anchorX = /** @type {number} */ (part[2]);
                  anchorY = baseline * label.height - offsetY;
                  this.replayImage_(context,
                    /** @type {number} */ (part[0]), /** @type {number} */ (part[1]), label,
                    anchorX, anchorY, declutterGroup, label.height, 1, 0, 0,
                    /** @type {number} */ (part[3]), textScale, false, label.width,
                    _canvas_js__WEBPACK_IMPORTED_MODULE_13__["defaultPadding"], null, null);
                }
              }
            }
          }
          this.renderDeclutter_(declutterGroup, feature);
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].END_GEOMETRY:
          if (featureCallback !== undefined) {
            feature = /** @type {import("../../Feature.js").default|import("../Feature.js").default} */ (instruction[1]);
            var result = featureCallback(feature);
            if (result) {
              return result;
            }
          }
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].FILL:
          if (batchSize) {
            pendingFill++;
          } else {
            this.fill_(context);
          }
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].MOVE_TO_LINE_TO:
          d = /** @type {number} */ (instruction[1]);
          dd = /** @type {number} */ (instruction[2]);
          x = pixelCoordinates[d];
          y = pixelCoordinates[d + 1];
          roundX = (x + 0.5) | 0;
          roundY = (y + 0.5) | 0;
          if (roundX !== prevX || roundY !== prevY) {
            context.moveTo(x, y);
            prevX = roundX;
            prevY = roundY;
          }
          for (d += 2; d < dd; d += 2) {
            x = pixelCoordinates[d];
            y = pixelCoordinates[d + 1];
            roundX = (x + 0.5) | 0;
            roundY = (y + 0.5) | 0;
            if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {
              context.lineTo(x, y);
              prevX = roundX;
              prevY = roundY;
            }
          }
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].SET_FILL_STYLE:
          lastFillInstruction = instruction;
          this.alignFill_ = instruction[2];

          if (pendingFill) {
            this.fill_(context);
            pendingFill = 0;
            if (pendingStroke) {
              context.stroke();
              pendingStroke = 0;
            }
          }

          context.fillStyle = /** @type {import("../../colorlike.js").ColorLike} */ (instruction[1]);
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].SET_STROKE_STYLE:
          lastStrokeInstruction = instruction;
          if (pendingStroke) {
            context.stroke();
            pendingStroke = 0;
          }
          this.setStrokeStyle_(context, /** @type {Array<*>} */ (instruction));
          ++i;
          break;
        case _Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].STROKE:
          if (batchSize) {
            pendingStroke++;
          } else {
            context.stroke();
          }
          ++i;
          break;
        default:
          ++i; // consume the instruction anyway, to avoid an infinite loop
          break;
      }
    }
    if (pendingFill) {
      this.fill_(context);
    }
    if (pendingStroke) {
      context.stroke();
    }
    return undefined;
  };

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {Object<string, boolean>} skippedFeaturesHash Ids of features
   *     to skip.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   */
  CanvasReplay.prototype.replay = function replay (context, transform, viewRotation, skippedFeaturesHash, snapToPixel) {
    this.viewRotation_ = viewRotation;
    this.replay_(context, transform,
      skippedFeaturesHash, this.instructions, snapToPixel, undefined, undefined);
  };

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {Object<string, boolean>} skippedFeaturesHash Ids of features
   *     to skip.
   * @param {function((import("../../Feature.js").default|import("../Feature.js").default)): T=} opt_featureCallback
   *     Feature callback.
   * @param {import("../../extent.js").Extent=} opt_hitExtent Only check features that intersect this
   *     extent.
   * @return {T|undefined} Callback result.
   * @template T
   */
  CanvasReplay.prototype.replayHitDetection = function replayHitDetection (
    context,
    transform,
    viewRotation,
    skippedFeaturesHash,
    opt_featureCallback,
    opt_hitExtent
  ) {
    this.viewRotation_ = viewRotation;
    return this.replay_(context, transform, skippedFeaturesHash,
      this.hitDetectionInstructions, true, opt_featureCallback, opt_hitExtent);
  };

  /**
   * Reverse the hit detection instructions.
   */
  CanvasReplay.prototype.reverseHitDetectionInstructions = function reverseHitDetectionInstructions () {
    var hitDetectionInstructions = this.hitDetectionInstructions;
    // step 1 - reverse array
    hitDetectionInstructions.reverse();
    // step 2 - reverse instructions within geometry blocks
    var i;
    var n = hitDetectionInstructions.length;
    var instruction;
    var type;
    var begin = -1;
    for (i = 0; i < n; ++i) {
      instruction = hitDetectionInstructions[i];
      type = /** @type {CanvasInstruction} */ (instruction[0]);
      if (type == _Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].END_GEOMETRY) {
        begin = i;
      } else if (type == _Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].BEGIN_GEOMETRY) {
        instruction[2] = i;
        Object(_array_js__WEBPACK_IMPORTED_MODULE_1__["reverseSubArray"])(this.hitDetectionInstructions, begin, i);
        begin = -1;
      }
    }
  };

  /**
   * @inheritDoc
   */
  CanvasReplay.prototype.setFillStrokeStyle = function setFillStrokeStyle (fillStyle, strokeStyle) {
    var state = this.state;
    if (fillStyle) {
      var fillStyleColor = fillStyle.getColor();
      state.fillStyle = Object(_colorlike_js__WEBPACK_IMPORTED_MODULE_2__["asColorLike"])(fillStyleColor ?
        fillStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_13__["defaultFillStyle"]);
    } else {
      state.fillStyle = undefined;
    }
    if (strokeStyle) {
      var strokeStyleColor = strokeStyle.getColor();
      state.strokeStyle = Object(_colorlike_js__WEBPACK_IMPORTED_MODULE_2__["asColorLike"])(strokeStyleColor ?
        strokeStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_13__["defaultStrokeStyle"]);
      var strokeStyleLineCap = strokeStyle.getLineCap();
      state.lineCap = strokeStyleLineCap !== undefined ?
        strokeStyleLineCap : _canvas_js__WEBPACK_IMPORTED_MODULE_13__["defaultLineCap"];
      var strokeStyleLineDash = strokeStyle.getLineDash();
      state.lineDash = strokeStyleLineDash ?
        strokeStyleLineDash.slice() : _canvas_js__WEBPACK_IMPORTED_MODULE_13__["defaultLineDash"];
      var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
      state.lineDashOffset = strokeStyleLineDashOffset ?
        strokeStyleLineDashOffset : _canvas_js__WEBPACK_IMPORTED_MODULE_13__["defaultLineDashOffset"];
      var strokeStyleLineJoin = strokeStyle.getLineJoin();
      state.lineJoin = strokeStyleLineJoin !== undefined ?
        strokeStyleLineJoin : _canvas_js__WEBPACK_IMPORTED_MODULE_13__["defaultLineJoin"];
      var strokeStyleWidth = strokeStyle.getWidth();
      state.lineWidth = strokeStyleWidth !== undefined ?
        strokeStyleWidth : _canvas_js__WEBPACK_IMPORTED_MODULE_13__["defaultLineWidth"];
      var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
      state.miterLimit = strokeStyleMiterLimit !== undefined ?
        strokeStyleMiterLimit : _canvas_js__WEBPACK_IMPORTED_MODULE_13__["defaultMiterLimit"];

      if (state.lineWidth > this.maxLineWidth) {
        this.maxLineWidth = state.lineWidth;
        // invalidate the buffered max extent cache
        this.bufferedMaxExtent_ = null;
      }
    } else {
      state.strokeStyle = undefined;
      state.lineCap = undefined;
      state.lineDash = null;
      state.lineDashOffset = undefined;
      state.lineJoin = undefined;
      state.lineWidth = undefined;
      state.miterLimit = undefined;
    }
  };

  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry Geometry.
   * @return {Array<*>} Fill instruction.
   */
  CanvasReplay.prototype.createFill = function createFill (state, geometry) {
    var fillStyle = state.fillStyle;
    /** @type {Array<*>} */
    var fillInstruction = [_Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].SET_FILL_STYLE, fillStyle];
    if (typeof fillStyle !== 'string') {
      // Fill is a pattern or gradient - align it!
      fillInstruction.push(true);
    }
    return fillInstruction;
  };

  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   */
  CanvasReplay.prototype.applyStroke = function applyStroke (state) {
    this.instructions.push(this.createStroke(state));
  };

  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Stroke instruction.
   */
  CanvasReplay.prototype.createStroke = function createStroke (state) {
    return [
      _Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].SET_STROKE_STYLE,
      state.strokeStyle, state.lineWidth * this.pixelRatio, state.lineCap,
      state.lineJoin, state.miterLimit,
      this.applyPixelRatio(state.lineDash), state.lineDashOffset * this.pixelRatio
    ];
  };

  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasReplay, import("../canvas.js").FillStrokeState, (import("../../geom/Geometry.js").default|import("../Feature.js").default)):Array<*>} createFill Create fill.
   * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry Geometry.
   */
  CanvasReplay.prototype.updateFillStyle = function updateFillStyle (state, createFill, geometry) {
    var fillStyle = state.fillStyle;
    if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {
      if (fillStyle !== undefined) {
        this.instructions.push(createFill.call(this, state, geometry));
      }
      state.currentFillStyle = fillStyle;
    }
  };

  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasReplay, import("../canvas.js").FillStrokeState)} applyStroke Apply stroke.
   */
  CanvasReplay.prototype.updateStrokeStyle = function updateStrokeStyle (state, applyStroke) {
    var strokeStyle = state.strokeStyle;
    var lineCap = state.lineCap;
    var lineDash = state.lineDash;
    var lineDashOffset = state.lineDashOffset;
    var lineJoin = state.lineJoin;
    var lineWidth = state.lineWidth;
    var miterLimit = state.miterLimit;
    if (state.currentStrokeStyle != strokeStyle ||
        state.currentLineCap != lineCap ||
        (lineDash != state.currentLineDash && !Object(_array_js__WEBPACK_IMPORTED_MODULE_1__["equals"])(state.currentLineDash, lineDash)) ||
        state.currentLineDashOffset != lineDashOffset ||
        state.currentLineJoin != lineJoin ||
        state.currentLineWidth != lineWidth ||
        state.currentMiterLimit != miterLimit) {
      if (strokeStyle !== undefined) {
        applyStroke.call(this, state);
      }
      state.currentStrokeStyle = strokeStyle;
      state.currentLineCap = lineCap;
      state.currentLineDash = lineDash;
      state.currentLineDashOffset = lineDashOffset;
      state.currentLineJoin = lineJoin;
      state.currentLineWidth = lineWidth;
      state.currentMiterLimit = miterLimit;
    }
  };

  /**
   * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry Geometry.
   * @param {import("../../Feature.js").default|import("../Feature.js").default} feature Feature.
   */
  CanvasReplay.prototype.endGeometry = function endGeometry (geometry, feature) {
    this.beginGeometryInstruction1_[2] = this.instructions.length;
    this.beginGeometryInstruction1_ = null;
    this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;
    this.beginGeometryInstruction2_ = null;
    var endGeometryInstruction = [_Instruction_js__WEBPACK_IMPORTED_MODULE_14__["default"].END_GEOMETRY, feature];
    this.instructions.push(endGeometryInstruction);
    this.hitDetectionInstructions.push(endGeometryInstruction);
  };

  /**
   * Get the buffered rendering extent.  Rendering will be clipped to the extent
   * provided to the constructor.  To account for symbolizers that may intersect
   * this extent, we calculate a buffered extent (e.g. based on stroke width).
   * @return {import("../../extent.js").Extent} The buffered rendering extent.
   * @protected
   */
  CanvasReplay.prototype.getBufferedMaxExtent = function getBufferedMaxExtent () {
    if (!this.bufferedMaxExtent_) {
      this.bufferedMaxExtent_ = Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__["clone"])(this.maxExtent);
      if (this.maxLineWidth > 0) {
        var width = this.resolution * (this.maxLineWidth + 1) / 2;
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__["buffer"])(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
      }
    }
    return this.bufferedMaxExtent_;
  };

  return CanvasReplay;
}(_VectorContext_js__WEBPACK_IMPORTED_MODULE_12__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (CanvasReplay);

//# sourceMappingURL=Replay.js.map

/***/ }),

/***/ "./node_modules/ol/render/canvas/ReplayGroup.js":
/*!******************************************************!*\
  !*** ./node_modules/ol/render/canvas/ReplayGroup.js ***!
  \******************************************************/
/*! exports provided: getCircleArray, replayDeclutter, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCircleArray", function() { return getCircleArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "replayDeclutter", function() { return replayDeclutter; });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../geom/flat/transform.js */ "./node_modules/ol/geom/flat/transform.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _ReplayGroup_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../ReplayGroup.js */ "./node_modules/ol/render/ReplayGroup.js");
/* harmony import */ var _ReplayType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../ReplayType.js */ "./node_modules/ol/render/ReplayType.js");
/* harmony import */ var _Replay_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Replay.js */ "./node_modules/ol/render/canvas/Replay.js");
/* harmony import */ var _ImageReplay_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ImageReplay.js */ "./node_modules/ol/render/canvas/ImageReplay.js");
/* harmony import */ var _LineStringReplay_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./LineStringReplay.js */ "./node_modules/ol/render/canvas/LineStringReplay.js");
/* harmony import */ var _PolygonReplay_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./PolygonReplay.js */ "./node_modules/ol/render/canvas/PolygonReplay.js");
/* harmony import */ var _TextReplay_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./TextReplay.js */ "./node_modules/ol/render/canvas/TextReplay.js");
/* harmony import */ var _replay_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../replay.js */ "./node_modules/ol/render/replay.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/render/canvas/ReplayGroup
 */

















/**
 * @type {Object<ReplayType, typeof CanvasReplay>}
 */
var BATCH_CONSTRUCTORS = {
  'Circle': _PolygonReplay_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  'Default': _Replay_js__WEBPACK_IMPORTED_MODULE_7__["default"],
  'Image': _ImageReplay_js__WEBPACK_IMPORTED_MODULE_8__["default"],
  'LineString': _LineStringReplay_js__WEBPACK_IMPORTED_MODULE_9__["default"],
  'Polygon': _PolygonReplay_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  'Text': _TextReplay_js__WEBPACK_IMPORTED_MODULE_11__["default"]
};


var CanvasReplayGroup = /*@__PURE__*/(function (ReplayGroup) {
  function CanvasReplayGroup(
    tolerance,
    maxExtent,
    resolution,
    pixelRatio,
    overlaps,
    declutterTree,
    opt_renderBuffer
  ) {
    ReplayGroup.call(this);

    /**
     * Declutter tree.
     * @private
     */
    this.declutterTree_ = declutterTree;

    /**
     * @type {import("../canvas.js").DeclutterGroup}
     * @private
     */
    this.declutterGroup_ = null;

    /**
     * @private
     * @type {number}
     */
    this.tolerance_ = tolerance;

    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */
    this.maxExtent_ = maxExtent;

    /**
     * @private
     * @type {boolean}
     */
    this.overlaps_ = overlaps;

    /**
     * @private
     * @type {number}
     */
    this.pixelRatio_ = pixelRatio;

    /**
     * @private
     * @type {number}
     */
    this.resolution_ = resolution;

    /**
     * @private
     * @type {number|undefined}
     */
    this.renderBuffer_ = opt_renderBuffer;

    /**
     * @private
     * @type {!Object<string, !Object<ReplayType, CanvasReplay>>}
     */
    this.replaysByZIndex_ = {};

    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */
    this.hitDetectionContext_ = Object(_dom_js__WEBPACK_IMPORTED_MODULE_1__["createCanvasContext2D"])(1, 1);

    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */
    this.hitDetectionTransform_ = Object(_transform_js__WEBPACK_IMPORTED_MODULE_13__["create"])();
  }

  if ( ReplayGroup ) CanvasReplayGroup.__proto__ = ReplayGroup;
  CanvasReplayGroup.prototype = Object.create( ReplayGroup && ReplayGroup.prototype );
  CanvasReplayGroup.prototype.constructor = CanvasReplayGroup;

  /**
   * @inheritDoc
   */
  CanvasReplayGroup.prototype.addDeclutter = function addDeclutter (group) {
    var declutter = null;
    if (this.declutterTree_) {
      if (group) {
        declutter = this.declutterGroup_;
        /** @type {number} */ (declutter[4])++;
      } else {
        declutter = this.declutterGroup_ = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["createEmpty"])();
        declutter.push(1);
      }
    }
    return declutter;
  };

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   */
  CanvasReplayGroup.prototype.clip = function clip (context, transform) {
    var flatClipCoords = this.getClipCoords(transform);
    context.beginPath();
    context.moveTo(flatClipCoords[0], flatClipCoords[1]);
    context.lineTo(flatClipCoords[2], flatClipCoords[3]);
    context.lineTo(flatClipCoords[4], flatClipCoords[5]);
    context.lineTo(flatClipCoords[6], flatClipCoords[7]);
    context.clip();
  };

  /**
   * @param {Array<ReplayType>} replays Replays.
   * @return {boolean} Has replays of the provided types.
   */
  CanvasReplayGroup.prototype.hasReplays = function hasReplays (replays) {
    for (var zIndex in this.replaysByZIndex_) {
      var candidates = this.replaysByZIndex_[zIndex];
      for (var i = 0, ii = replays.length; i < ii; ++i) {
        if (replays[i] in candidates) {
          return true;
        }
      }
    }
    return false;
  };

  /**
   * FIXME empty description for jsdoc
   */
  CanvasReplayGroup.prototype.finish = function finish () {
    for (var zKey in this.replaysByZIndex_) {
      var replays = this.replaysByZIndex_[zKey];
      for (var replayKey in replays) {
        replays[replayKey].finish();
      }
    }
  };

  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {Object<string, boolean>} skippedFeaturesHash Ids of features to skip.
   * @param {function((import("../../Feature.js").default|import("../Feature.js").default)): T} callback Feature callback.
   * @param {Object<string, import("../canvas.js").DeclutterGroup>} declutterReplays Declutter replays.
   * @return {T|undefined} Callback result.
   * @template T
   */
  CanvasReplayGroup.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate (
    coordinate,
    resolution,
    rotation,
    hitTolerance,
    skippedFeaturesHash,
    callback,
    declutterReplays
  ) {

    hitTolerance = Math.round(hitTolerance);
    var contextSize = hitTolerance * 2 + 1;
    var transform = Object(_transform_js__WEBPACK_IMPORTED_MODULE_13__["compose"])(this.hitDetectionTransform_,
      hitTolerance + 0.5, hitTolerance + 0.5,
      1 / resolution, -1 / resolution,
      -rotation,
      -coordinate[0], -coordinate[1]);
    var context = this.hitDetectionContext_;

    if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {
      context.canvas.width = contextSize;
      context.canvas.height = contextSize;
    } else {
      context.clearRect(0, 0, contextSize, contextSize);
    }

    /**
     * @type {import("../../extent.js").Extent}
     */
    var hitExtent;
    if (this.renderBuffer_ !== undefined) {
      hitExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["createEmpty"])();
      Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["extendCoordinate"])(hitExtent, coordinate);
      Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["buffer"])(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);
    }

    var mask = getCircleArray(hitTolerance);
    var declutteredFeatures;
    if (this.declutterTree_) {
      declutteredFeatures = this.declutterTree_.all().map(function(entry) {
        return entry.value;
      });
    }

    var replayType;

    /**
     * @param {import("../../Feature.js").default|import("../Feature.js").default} feature Feature.
     * @return {?} Callback result.
     */
    function featureCallback(feature) {
      var imageData = context.getImageData(0, 0, contextSize, contextSize).data;
      for (var i = 0; i < contextSize; i++) {
        for (var j = 0; j < contextSize; j++) {
          if (mask[i][j]) {
            if (imageData[(j * contextSize + i) * 4 + 3] > 0) {
              var result = (void 0);
              if (!(declutteredFeatures && (replayType == _ReplayType_js__WEBPACK_IMPORTED_MODULE_6__["default"].IMAGE || replayType == _ReplayType_js__WEBPACK_IMPORTED_MODULE_6__["default"].TEXT)) ||
                  declutteredFeatures.indexOf(feature) !== -1) {
                result = callback(feature);
              }
              if (result) {
                return result;
              } else {
                context.clearRect(0, 0, contextSize, contextSize);
                return undefined;
              }
            }
          }
        }
      }
    }

    /** @type {Array<number>} */
    var zs = Object.keys(this.replaysByZIndex_).map(Number);
    zs.sort(_array_js__WEBPACK_IMPORTED_MODULE_0__["numberSafeCompareFunction"]);

    var i, j, replays, replay, result;
    for (i = zs.length - 1; i >= 0; --i) {
      var zIndexKey = zs[i].toString();
      replays = this.replaysByZIndex_[zIndexKey];
      for (j = _replay_js__WEBPACK_IMPORTED_MODULE_12__["ORDER"].length - 1; j >= 0; --j) {
        replayType = _replay_js__WEBPACK_IMPORTED_MODULE_12__["ORDER"][j];
        replay = replays[replayType];
        if (replay !== undefined) {
          if (declutterReplays &&
              (replayType == _ReplayType_js__WEBPACK_IMPORTED_MODULE_6__["default"].IMAGE || replayType == _ReplayType_js__WEBPACK_IMPORTED_MODULE_6__["default"].TEXT)) {
            var declutter = declutterReplays[zIndexKey];
            if (!declutter) {
              declutterReplays[zIndexKey] = [replay, transform.slice(0)];
            } else {
              declutter.push(replay, transform.slice(0));
            }
          } else {
            result = replay.replayHitDetection(context, transform, rotation,
              skippedFeaturesHash, featureCallback, hitExtent);
            if (result) {
              return result;
            }
          }
        }
      }
    }
    return undefined;
  };

  /**
   * @param {import("../../transform.js").Transform} transform Transform.
   * @return {Array<number>} Clip coordinates.
   */
  CanvasReplayGroup.prototype.getClipCoords = function getClipCoords (transform) {
    var maxExtent = this.maxExtent_;
    var minX = maxExtent[0];
    var minY = maxExtent[1];
    var maxX = maxExtent[2];
    var maxY = maxExtent[3];
    var flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];
    Object(_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_3__["transform2D"])(
      flatClipCoords, 0, 8, 2, transform, flatClipCoords);
    return flatClipCoords;
  };

  /**
   * @inheritDoc
   */
  CanvasReplayGroup.prototype.getReplay = function getReplay (zIndex, replayType) {
    var zIndexKey = zIndex !== undefined ? zIndex.toString() : '0';
    var replays = this.replaysByZIndex_[zIndexKey];
    if (replays === undefined) {
      replays = {};
      this.replaysByZIndex_[zIndexKey] = replays;
    }
    var replay = replays[replayType];
    if (replay === undefined) {
      var Constructor = BATCH_CONSTRUCTORS[replayType];
      replay = new Constructor(this.tolerance_, this.maxExtent_,
        this.resolution_, this.pixelRatio_, this.overlaps_, this.declutterTree_);
      replays[replayType] = replay;
    }
    return replay;
  };

  /**
   * @return {Object<string, Object<ReplayType, CanvasReplay>>} Replays.
   */
  CanvasReplayGroup.prototype.getReplays = function getReplays () {
    return this.replaysByZIndex_;
  };

  /**
   * @inheritDoc
   */
  CanvasReplayGroup.prototype.isEmpty = function isEmpty$1 () {
    return Object(_obj_js__WEBPACK_IMPORTED_MODULE_4__["isEmpty"])(this.replaysByZIndex_);
  };

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {Object<string, boolean>} skippedFeaturesHash Ids of features to skip.
   * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.
   * @param {Array<ReplayType>=} opt_replayTypes Ordered replay types to replay.
   *     Default is {@link module:ol/render/replay~ORDER}
   * @param {Object<string, import("../canvas.js").DeclutterGroup>=} opt_declutterReplays Declutter replays.
   */
  CanvasReplayGroup.prototype.replay = function replay (
    context,
    transform,
    viewRotation,
    skippedFeaturesHash,
    snapToPixel,
    opt_replayTypes,
    opt_declutterReplays
  ) {

    /** @type {Array<number>} */
    var zs = Object.keys(this.replaysByZIndex_).map(Number);
    zs.sort(_array_js__WEBPACK_IMPORTED_MODULE_0__["numberSafeCompareFunction"]);

    // setup clipping so that the parts of over-simplified geometries are not
    // visible outside the current extent when panning
    context.save();
    this.clip(context, transform);

    var replayTypes = opt_replayTypes ? opt_replayTypes : _replay_js__WEBPACK_IMPORTED_MODULE_12__["ORDER"];
    var i, ii, j, jj, replays, replay;
    for (i = 0, ii = zs.length; i < ii; ++i) {
      var zIndexKey = zs[i].toString();
      replays = this.replaysByZIndex_[zIndexKey];
      for (j = 0, jj = replayTypes.length; j < jj; ++j) {
        var replayType = replayTypes[j];
        replay = replays[replayType];
        if (replay !== undefined) {
          if (opt_declutterReplays &&
              (replayType == _ReplayType_js__WEBPACK_IMPORTED_MODULE_6__["default"].IMAGE || replayType == _ReplayType_js__WEBPACK_IMPORTED_MODULE_6__["default"].TEXT)) {
            var declutter = opt_declutterReplays[zIndexKey];
            if (!declutter) {
              opt_declutterReplays[zIndexKey] = [replay, transform.slice(0)];
            } else {
              declutter.push(replay, transform.slice(0));
            }
          } else {
            replay.replay(context, transform, viewRotation, skippedFeaturesHash, snapToPixel);
          }
        }
      }
    }

    context.restore();
  };

  return CanvasReplayGroup;
}(_ReplayGroup_js__WEBPACK_IMPORTED_MODULE_5__["default"]));


/**
 * This cache is used for storing calculated pixel circles for increasing performance.
 * It is a static property to allow each Replaygroup to access it.
 * @type {Object<number, Array<Array<(boolean|undefined)>>>}
 */
var circleArrayCache = {
  0: [[true]]
};


/**
 * This method fills a row in the array from the given coordinate to the
 * middle with `true`.
 * @param {Array<Array<(boolean|undefined)>>} array The array that will be altered.
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 */
function fillCircleArrayRowToMiddle(array, x, y) {
  var i;
  var radius = Math.floor(array.length / 2);
  if (x >= radius) {
    for (i = radius; i < x; i++) {
      array[i][y] = true;
    }
  } else if (x < radius) {
    for (i = x + 1; i < radius; i++) {
      array[i][y] = true;
    }
  }
}


/**
 * This methods creates a circle inside a fitting array. Points inside the
 * circle are marked by true, points on the outside are undefined.
 * It uses the midpoint circle algorithm.
 * A cache is used to increase performance.
 * @param {number} radius Radius.
 * @returns {Array<Array<(boolean|undefined)>>} An array with marked circle points.
 */
function getCircleArray(radius) {
  if (circleArrayCache[radius] !== undefined) {
    return circleArrayCache[radius];
  }

  var arraySize = radius * 2 + 1;
  var arr = new Array(arraySize);
  for (var i = 0; i < arraySize; i++) {
    arr[i] = new Array(arraySize);
  }

  var x = radius;
  var y = 0;
  var error = 0;

  while (x >= y) {
    fillCircleArrayRowToMiddle(arr, radius + x, radius + y);
    fillCircleArrayRowToMiddle(arr, radius + y, radius + x);
    fillCircleArrayRowToMiddle(arr, radius - y, radius + x);
    fillCircleArrayRowToMiddle(arr, radius - x, radius + y);
    fillCircleArrayRowToMiddle(arr, radius - x, radius - y);
    fillCircleArrayRowToMiddle(arr, radius - y, radius - x);
    fillCircleArrayRowToMiddle(arr, radius + y, radius - x);
    fillCircleArrayRowToMiddle(arr, radius + x, radius - y);

    y++;
    error += 1 + 2 * y;
    if (2 * (error - x) + 1 > 0) {
      x -= 1;
      error += 1 - 2 * x;
    }
  }

  circleArrayCache[radius] = arr;
  return arr;
}


/**
 * @param {!Object<string, Array<*>>} declutterReplays Declutter replays.
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} rotation Rotation.
 * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
 */
function replayDeclutter(declutterReplays, context, rotation, snapToPixel) {
  var zs = Object.keys(declutterReplays).map(Number).sort(_array_js__WEBPACK_IMPORTED_MODULE_0__["numberSafeCompareFunction"]);
  var skippedFeatureUids = {};
  for (var z = 0, zz = zs.length; z < zz; ++z) {
    var replayData = declutterReplays[zs[z].toString()];
    for (var i = 0, ii = replayData.length; i < ii;) {
      var replay = replayData[i++];
      var transform = replayData[i++];
      replay.replay(context, transform, rotation, skippedFeatureUids, snapToPixel);
    }
  }
}


/* harmony default export */ __webpack_exports__["default"] = (CanvasReplayGroup);

//# sourceMappingURL=ReplayGroup.js.map

/***/ }),

/***/ "./node_modules/ol/render/canvas/TextReplay.js":
/*!*****************************************************!*\
  !*** ./node_modules/ol/render/canvas/TextReplay.js ***!
  \*****************************************************/
/*! exports provided: measureTextWidths, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "measureTextWidths", function() { return measureTextWidths; });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _colorlike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../colorlike.js */ "./node_modules/ol/colorlike.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_flat_straightchunk_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../geom/flat/straightchunk.js */ "./node_modules/ol/geom/flat/straightchunk.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _canvas_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _Instruction_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Instruction.js */ "./node_modules/ol/render/canvas/Instruction.js");
/* harmony import */ var _Replay_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Replay.js */ "./node_modules/ol/render/canvas/Replay.js");
/* harmony import */ var _replay_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../replay.js */ "./node_modules/ol/render/replay.js");
/* harmony import */ var _style_TextPlacement_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../style/TextPlacement.js */ "./node_modules/ol/style/TextPlacement.js");
/**
 * @module ol/render/canvas/TextReplay
 */













var CanvasTextReplay = /*@__PURE__*/(function (CanvasReplay) {
  function CanvasTextReplay(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {
    CanvasReplay.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);

    /**
     * @private
     * @type {import("../canvas.js").DeclutterGroup}
     */
    this.declutterGroup_;

    /**
     * @private
     * @type {Array<HTMLCanvasElement>}
     */
    this.labels_ = null;

    /**
     * @private
     * @type {string}
     */
    this.text_ = '';

    /**
     * @private
     * @type {number}
     */
    this.textOffsetX_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.textOffsetY_ = 0;

    /**
     * @private
     * @type {boolean|undefined}
     */
    this.textRotateWithView_ = undefined;

    /**
     * @private
     * @type {number}
     */
    this.textRotation_ = 0;

    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */
    this.textFillState_ = null;

    /**
     * @type {!Object<string, import("../canvas.js").FillState>}
     */
    this.fillStates = {};

    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */
    this.textStrokeState_ = null;

    /**
     * @type {!Object<string, import("../canvas.js").StrokeState>}
     */
    this.strokeStates = {};

    /**
     * @private
     * @type {import("../canvas.js").TextState}
     */
    this.textState_ = /** @type {import("../canvas.js").TextState} */ ({});

    /**
     * @type {!Object<string, import("../canvas.js").TextState>}
     */
    this.textStates = {};

    /**
     * @private
     * @type {string}
     */
    this.textKey_ = '';

    /**
     * @private
     * @type {string}
     */
    this.fillKey_ = '';

    /**
     * @private
     * @type {string}
     */
    this.strokeKey_ = '';

    /**
     * @private
     * @type {Object<string, Object<string, number>>}
     */
    this.widths_ = {};

    _canvas_js__WEBPACK_IMPORTED_MODULE_7__["labelCache"].prune();

  }

  if ( CanvasReplay ) CanvasTextReplay.__proto__ = CanvasReplay;
  CanvasTextReplay.prototype = Object.create( CanvasReplay && CanvasReplay.prototype );
  CanvasTextReplay.prototype.constructor = CanvasTextReplay;

  /**
   * @inheritDoc
   */
  CanvasTextReplay.prototype.drawText = function drawText (geometry, feature) {
    var fillState = this.textFillState_;
    var strokeState = this.textStrokeState_;
    var textState = this.textState_;
    if (this.text_ === '' || !textState || (!fillState && !strokeState)) {
      return;
    }

    var begin = this.coordinates.length;

    var geometryType = geometry.getType();
    var flatCoordinates = null;
    var end = 2;
    var stride = 2;
    var i, ii;

    if (textState.placement === _style_TextPlacement_js__WEBPACK_IMPORTED_MODULE_11__["default"].LINE) {
      if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__["intersects"])(this.getBufferedMaxExtent(), geometry.getExtent())) {
        return;
      }
      var ends;
      flatCoordinates = geometry.getFlatCoordinates();
      stride = geometry.getStride();
      if (geometryType == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].LINE_STRING) {
        ends = [flatCoordinates.length];
      } else if (geometryType == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].MULTI_LINE_STRING) {
        ends = geometry.getEnds();
      } else if (geometryType == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POLYGON) {
        ends = geometry.getEnds().slice(0, 1);
      } else if (geometryType == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].MULTI_POLYGON) {
        var endss = geometry.getEndss();
        ends = [];
        for (i = 0, ii = endss.length; i < ii; ++i) {
          ends.push(endss[i][0]);
        }
      }
      this.beginGeometry(geometry, feature);
      var textAlign = textState.textAlign;
      var flatOffset = 0;
      var flatEnd;
      for (var o = 0, oo = ends.length; o < oo; ++o) {
        if (textAlign == undefined) {
          var range = Object(_geom_flat_straightchunk_js__WEBPACK_IMPORTED_MODULE_4__["matchingChunk"])(textState.maxAngle, flatCoordinates, flatOffset, ends[o], stride);
          flatOffset = range[0];
          flatEnd = range[1];
        } else {
          flatEnd = ends[o];
        }
        for (i = flatOffset; i < flatEnd; i += stride) {
          this.coordinates.push(flatCoordinates[i], flatCoordinates[i + 1]);
        }
        end = this.coordinates.length;
        flatOffset = ends[o];
        this.drawChars_(begin, end, this.declutterGroup_);
        begin = end;
      }
      this.endGeometry(geometry, feature);

    } else {
      var label = this.getImage(this.text_, this.textKey_, this.fillKey_, this.strokeKey_);
      var width = label.width / this.pixelRatio;
      switch (geometryType) {
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POINT:
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].MULTI_POINT:
          flatCoordinates = geometry.getFlatCoordinates();
          end = flatCoordinates.length;
          break;
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].LINE_STRING:
          flatCoordinates = /** @type {import("../../geom/LineString.js").default} */ (geometry).getFlatMidpoint();
          break;
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].CIRCLE:
          flatCoordinates = /** @type {import("../../geom/Circle.js").default} */ (geometry).getCenter();
          break;
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].MULTI_LINE_STRING:
          flatCoordinates = /** @type {import("../../geom/MultiLineString.js").default} */ (geometry).getFlatMidpoints();
          end = flatCoordinates.length;
          break;
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POLYGON:
          flatCoordinates = /** @type {import("../../geom/Polygon.js").default} */ (geometry).getFlatInteriorPoint();
          if (!textState.overflow && flatCoordinates[2] / this.resolution < width) {
            return;
          }
          stride = 3;
          break;
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].MULTI_POLYGON:
          var interiorPoints = /** @type {import("../../geom/MultiPolygon.js").default} */ (geometry).getFlatInteriorPoints();
          flatCoordinates = [];
          for (i = 0, ii = interiorPoints.length; i < ii; i += 3) {
            if (textState.overflow || interiorPoints[i + 2] / this.resolution >= width) {
              flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);
            }
          }
          end = flatCoordinates.length;
          if (end == 0) {
            return;
          }
          break;
        default:
      }
      end = this.appendFlatCoordinates(flatCoordinates, 0, end, stride, false, false);
      if (textState.backgroundFill || textState.backgroundStroke) {
        this.setFillStrokeStyle(textState.backgroundFill, textState.backgroundStroke);
        if (textState.backgroundFill) {
          this.updateFillStyle(this.state, this.createFill, geometry);
          this.hitDetectionInstructions.push(this.createFill(this.state, geometry));
        }
        if (textState.backgroundStroke) {
          this.updateStrokeStyle(this.state, this.applyStroke);
          this.hitDetectionInstructions.push(this.createStroke(this.state));
        }
      }
      this.beginGeometry(geometry, feature);
      this.drawTextImage_(label, begin, end);
      this.endGeometry(geometry, feature);
    }
  };

  /**
   * @param {string} text Text.
   * @param {string} textKey Text style key.
   * @param {string} fillKey Fill style key.
   * @param {string} strokeKey Stroke style key.
   * @return {HTMLCanvasElement} Image.
   */
  CanvasTextReplay.prototype.getImage = function getImage (text, textKey, fillKey, strokeKey) {
    var label;
    var key = strokeKey + textKey + text + fillKey + this.pixelRatio;

    if (!_canvas_js__WEBPACK_IMPORTED_MODULE_7__["labelCache"].containsKey(key)) {
      var strokeState = strokeKey ? this.strokeStates[strokeKey] || this.textStrokeState_ : null;
      var fillState = fillKey ? this.fillStates[fillKey] || this.textFillState_ : null;
      var textState = this.textStates[textKey] || this.textState_;
      var pixelRatio = this.pixelRatio;
      var scale = textState.scale * pixelRatio;
      var align = _replay_js__WEBPACK_IMPORTED_MODULE_10__["TEXT_ALIGN"][textState.textAlign || _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultTextAlign"]];
      var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;

      var lines = text.split('\n');
      var numLines = lines.length;
      var widths = [];
      var width = measureTextWidths(textState.font, lines, widths);
      var lineHeight = Object(_canvas_js__WEBPACK_IMPORTED_MODULE_7__["measureTextHeight"])(textState.font);
      var height = lineHeight * numLines;
      var renderWidth = (width + strokeWidth);
      var context = Object(_dom_js__WEBPACK_IMPORTED_MODULE_2__["createCanvasContext2D"])(
        Math.ceil(renderWidth * scale),
        Math.ceil((height + strokeWidth) * scale));
      label = context.canvas;
      _canvas_js__WEBPACK_IMPORTED_MODULE_7__["labelCache"].set(key, label);
      if (scale != 1) {
        context.scale(scale, scale);
      }
      context.font = textState.font;
      if (strokeKey) {
        context.strokeStyle = strokeState.strokeStyle;
        context.lineWidth = strokeWidth;
        context.lineCap = /** @type {CanvasLineCap} */ (strokeState.lineCap);
        context.lineJoin = /** @type {CanvasLineJoin} */ (strokeState.lineJoin);
        context.miterLimit = strokeState.miterLimit;
        if (_has_js__WEBPACK_IMPORTED_MODULE_6__["CANVAS_LINE_DASH"] && strokeState.lineDash.length) {
          context.setLineDash(strokeState.lineDash);
          context.lineDashOffset = strokeState.lineDashOffset;
        }
      }
      if (fillKey) {
        context.fillStyle = fillState.fillStyle;
      }
      context.textBaseline = 'middle';
      context.textAlign = 'center';
      var leftRight = (0.5 - align);
      var x = align * label.width / scale + leftRight * strokeWidth;
      var i;
      if (strokeKey) {
        for (i = 0; i < numLines; ++i) {
          context.strokeText(lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight);
        }
      }
      if (fillKey) {
        for (i = 0; i < numLines; ++i) {
          context.fillText(lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight);
        }
      }
    }
    return _canvas_js__WEBPACK_IMPORTED_MODULE_7__["labelCache"].get(key);
  };

  /**
   * @private
   * @param {HTMLCanvasElement} label Label.
   * @param {number} begin Begin.
   * @param {number} end End.
   */
  CanvasTextReplay.prototype.drawTextImage_ = function drawTextImage_ (label, begin, end) {
    var textState = this.textState_;
    var strokeState = this.textStrokeState_;
    var pixelRatio = this.pixelRatio;
    var align = _replay_js__WEBPACK_IMPORTED_MODULE_10__["TEXT_ALIGN"][textState.textAlign || _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultTextAlign"]];
    var baseline = _replay_js__WEBPACK_IMPORTED_MODULE_10__["TEXT_ALIGN"][textState.textBaseline];
    var strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;

    var anchorX = align * label.width / pixelRatio + 2 * (0.5 - align) * strokeWidth;
    var anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;
    this.instructions.push([_Instruction_js__WEBPACK_IMPORTED_MODULE_8__["default"].DRAW_IMAGE, begin, end,
      label, (anchorX - this.textOffsetX_) * pixelRatio, (anchorY - this.textOffsetY_) * pixelRatio,
      this.declutterGroup_, label.height, 1, 0, 0, this.textRotateWithView_, this.textRotation_,
      1, label.width,
      textState.padding == _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultPadding"] ?
        _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultPadding"] : textState.padding.map(function(p) {
          return p * pixelRatio;
        }),
      !!textState.backgroundFill, !!textState.backgroundStroke
    ]);
    this.hitDetectionInstructions.push([_Instruction_js__WEBPACK_IMPORTED_MODULE_8__["default"].DRAW_IMAGE, begin, end,
      label, (anchorX - this.textOffsetX_) * pixelRatio, (anchorY - this.textOffsetY_) * pixelRatio,
      this.declutterGroup_, label.height, 1, 0, 0, this.textRotateWithView_, this.textRotation_,
      1 / pixelRatio, label.width, textState.padding,
      !!textState.backgroundFill, !!textState.backgroundStroke
    ]);
  };

  /**
   * @private
   * @param {number} begin Begin.
   * @param {number} end End.
   * @param {import("../canvas.js").DeclutterGroup} declutterGroup Declutter group.
   */
  CanvasTextReplay.prototype.drawChars_ = function drawChars_ (begin, end, declutterGroup) {
    var strokeState = this.textStrokeState_;
    var textState = this.textState_;
    var fillState = this.textFillState_;

    var strokeKey = this.strokeKey_;
    if (strokeState) {
      if (!(strokeKey in this.strokeStates)) {
        this.strokeStates[strokeKey] = /** @type {import("../canvas.js").StrokeState} */ ({
          strokeStyle: strokeState.strokeStyle,
          lineCap: strokeState.lineCap,
          lineDashOffset: strokeState.lineDashOffset,
          lineWidth: strokeState.lineWidth,
          lineJoin: strokeState.lineJoin,
          miterLimit: strokeState.miterLimit,
          lineDash: strokeState.lineDash
        });
      }
    }
    var textKey = this.textKey_;
    if (!(this.textKey_ in this.textStates)) {
      this.textStates[this.textKey_] = /** @type {import("../canvas.js").TextState} */ ({
        font: textState.font,
        textAlign: textState.textAlign || _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultTextAlign"],
        scale: textState.scale
      });
    }
    var fillKey = this.fillKey_;
    if (fillState) {
      if (!(fillKey in this.fillStates)) {
        this.fillStates[fillKey] = /** @type {import("../canvas.js").FillState} */ ({
          fillStyle: fillState.fillStyle
        });
      }
    }

    var pixelRatio = this.pixelRatio;
    var baseline = _replay_js__WEBPACK_IMPORTED_MODULE_10__["TEXT_ALIGN"][textState.textBaseline];

    var offsetY = this.textOffsetY_ * pixelRatio;
    var text = this.text_;
    var font = textState.font;
    var textScale = textState.scale;
    var strokeWidth = strokeState ? strokeState.lineWidth * textScale / 2 : 0;
    var widths = this.widths_[font];
    if (!widths) {
      this.widths_[font] = widths = {};
    }
    this.instructions.push([_Instruction_js__WEBPACK_IMPORTED_MODULE_8__["default"].DRAW_CHARS,
      begin, end, baseline, declutterGroup,
      textState.overflow, fillKey, textState.maxAngle,
      function(text) {
        var width = widths[text];
        if (!width) {
          width = widths[text] = Object(_canvas_js__WEBPACK_IMPORTED_MODULE_7__["measureTextWidth"])(font, text);
        }
        return width * textScale * pixelRatio;
      },
      offsetY, strokeKey, strokeWidth * pixelRatio, text, textKey, 1
    ]);
    this.hitDetectionInstructions.push([_Instruction_js__WEBPACK_IMPORTED_MODULE_8__["default"].DRAW_CHARS,
      begin, end, baseline, declutterGroup,
      textState.overflow, fillKey, textState.maxAngle,
      function(text) {
        var width = widths[text];
        if (!width) {
          width = widths[text] = Object(_canvas_js__WEBPACK_IMPORTED_MODULE_7__["measureTextWidth"])(font, text);
        }
        return width * textScale;
      },
      offsetY, strokeKey, strokeWidth, text, textKey, 1 / pixelRatio
    ]);
  };

  /**
   * @inheritDoc
   */
  CanvasTextReplay.prototype.setTextStyle = function setTextStyle (textStyle, declutterGroup) {
    var textState, fillState, strokeState;
    if (!textStyle) {
      this.text_ = '';
    } else {
      this.declutterGroup_ = /** @type {import("../canvas.js").DeclutterGroup} */ (declutterGroup);

      var textFillStyle = textStyle.getFill();
      if (!textFillStyle) {
        fillState = this.textFillState_ = null;
      } else {
        fillState = this.textFillState_;
        if (!fillState) {
          fillState = this.textFillState_ = /** @type {import("../canvas.js").FillState} */ ({});
        }
        fillState.fillStyle = Object(_colorlike_js__WEBPACK_IMPORTED_MODULE_1__["asColorLike"])(
          textFillStyle.getColor() || _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultFillStyle"]);
      }

      var textStrokeStyle = textStyle.getStroke();
      if (!textStrokeStyle) {
        strokeState = this.textStrokeState_ = null;
      } else {
        strokeState = this.textStrokeState_;
        if (!strokeState) {
          strokeState = this.textStrokeState_ = /** @type {import("../canvas.js").StrokeState} */ ({});
        }
        var lineDash = textStrokeStyle.getLineDash();
        var lineDashOffset = textStrokeStyle.getLineDashOffset();
        var lineWidth = textStrokeStyle.getWidth();
        var miterLimit = textStrokeStyle.getMiterLimit();
        strokeState.lineCap = textStrokeStyle.getLineCap() || _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultLineCap"];
        strokeState.lineDash = lineDash ? lineDash.slice() : _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultLineDash"];
        strokeState.lineDashOffset =
            lineDashOffset === undefined ? _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultLineDashOffset"] : lineDashOffset;
        strokeState.lineJoin = textStrokeStyle.getLineJoin() || _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultLineJoin"];
        strokeState.lineWidth =
            lineWidth === undefined ? _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultLineWidth"] : lineWidth;
        strokeState.miterLimit =
            miterLimit === undefined ? _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultMiterLimit"] : miterLimit;
        strokeState.strokeStyle = Object(_colorlike_js__WEBPACK_IMPORTED_MODULE_1__["asColorLike"])(
          textStrokeStyle.getColor() || _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultStrokeStyle"]);
      }

      textState = this.textState_;
      var font = textStyle.getFont() || _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultFont"];
      Object(_canvas_js__WEBPACK_IMPORTED_MODULE_7__["checkFont"])(font);
      var textScale = textStyle.getScale();
      textState.overflow = textStyle.getOverflow();
      textState.font = font;
      textState.maxAngle = textStyle.getMaxAngle();
      textState.placement = textStyle.getPlacement();
      textState.textAlign = textStyle.getTextAlign();
      textState.textBaseline = textStyle.getTextBaseline() || _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultTextBaseline"];
      textState.backgroundFill = textStyle.getBackgroundFill();
      textState.backgroundStroke = textStyle.getBackgroundStroke();
      textState.padding = textStyle.getPadding() || _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultPadding"];
      textState.scale = textScale === undefined ? 1 : textScale;

      var textOffsetX = textStyle.getOffsetX();
      var textOffsetY = textStyle.getOffsetY();
      var textRotateWithView = textStyle.getRotateWithView();
      var textRotation = textStyle.getRotation();
      this.text_ = textStyle.getText() || '';
      this.textOffsetX_ = textOffsetX === undefined ? 0 : textOffsetX;
      this.textOffsetY_ = textOffsetY === undefined ? 0 : textOffsetY;
      this.textRotateWithView_ = textRotateWithView === undefined ? false : textRotateWithView;
      this.textRotation_ = textRotation === undefined ? 0 : textRotation;

      this.strokeKey_ = strokeState ?
        (typeof strokeState.strokeStyle == 'string' ? strokeState.strokeStyle : Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(strokeState.strokeStyle)) +
        strokeState.lineCap + strokeState.lineDashOffset + '|' + strokeState.lineWidth +
        strokeState.lineJoin + strokeState.miterLimit + '[' + strokeState.lineDash.join() + ']' :
        '';
      this.textKey_ = textState.font + textState.scale + (textState.textAlign || '?');
      this.fillKey_ = fillState ?
        (typeof fillState.fillStyle == 'string' ? fillState.fillStyle : ('|' + Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(fillState.fillStyle))) :
        '';
    }
  };

  return CanvasTextReplay;
}(_Replay_js__WEBPACK_IMPORTED_MODULE_9__["default"]));


/**
 * @param {string} font Font to use for measuring.
 * @param {Array<string>} lines Lines to measure.
 * @param {Array<number>} widths Array will be populated with the widths of
 * each line.
 * @return {number} Width of the whole text.
 */
function measureTextWidths(font, lines, widths) {
  var numLines = lines.length;
  var width = 0;
  for (var i = 0; i < numLines; ++i) {
    var currentWidth = Object(_canvas_js__WEBPACK_IMPORTED_MODULE_7__["measureTextWidth"])(font, lines[i]);
    width = Math.max(width, currentWidth);
    widths.push(currentWidth);
  }
  return width;
}


/* harmony default export */ __webpack_exports__["default"] = (CanvasTextReplay);

//# sourceMappingURL=TextReplay.js.map

/***/ }),

/***/ "./node_modules/ol/render/replay.js":
/*!******************************************!*\
  !*** ./node_modules/ol/render/replay.js ***!
  \******************************************/
/*! exports provided: ORDER, TEXT_ALIGN */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ORDER", function() { return ORDER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXT_ALIGN", function() { return TEXT_ALIGN; });
/* harmony import */ var _ReplayType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ReplayType.js */ "./node_modules/ol/render/ReplayType.js");
/**
 * @module ol/render/replay
 */



/**
 * @const
 * @type {Array<ReplayType>}
 */
var ORDER = [
  _ReplayType_js__WEBPACK_IMPORTED_MODULE_0__["default"].POLYGON,
  _ReplayType_js__WEBPACK_IMPORTED_MODULE_0__["default"].CIRCLE,
  _ReplayType_js__WEBPACK_IMPORTED_MODULE_0__["default"].LINE_STRING,
  _ReplayType_js__WEBPACK_IMPORTED_MODULE_0__["default"].IMAGE,
  _ReplayType_js__WEBPACK_IMPORTED_MODULE_0__["default"].TEXT,
  _ReplayType_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEFAULT
];

/**
 * @const
 * @enum {number}
 */
var TEXT_ALIGN = {};
TEXT_ALIGN['left'] = 0;
TEXT_ALIGN['end'] = 0;
TEXT_ALIGN['center'] = 0.5;
TEXT_ALIGN['right'] = 1;
TEXT_ALIGN['start'] = 1;
TEXT_ALIGN['top'] = 0;
TEXT_ALIGN['middle'] = 0.5;
TEXT_ALIGN['hanging'] = 0.2;
TEXT_ALIGN['alphabetic'] = 0.8;
TEXT_ALIGN['ideographic'] = 0.8;
TEXT_ALIGN['bottom'] = 1;

//# sourceMappingURL=replay.js.map

/***/ }),

/***/ "./node_modules/ol/renderer/Layer.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/renderer/Layer.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ImageState.js */ "./node_modules/ol/ImageState.js");
/* harmony import */ var _Observable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Observable.js */ "./node_modules/ol/Observable.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _source_State_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../source/State.js */ "./node_modules/ol/source/State.js");
/**
 * @module ol/renderer/Layer
 */








var LayerRenderer = /*@__PURE__*/(function (Observable) {
  function LayerRenderer(layer) {

    Observable.call(this);

    /**
     * @private
     * @type {import("../layer/Layer.js").default}
     */
    this.layer_ = layer;

  }

  if ( Observable ) LayerRenderer.__proto__ = Observable;
  LayerRenderer.prototype = Object.create( Observable && Observable.prototype );
  LayerRenderer.prototype.constructor = LayerRenderer;

  /**
   * Create a function that adds loaded tiles to the tile lookup.
   * @param {import("../source/Tile.js").default} source Tile source.
   * @param {import("../proj/Projection.js").default} projection Projection of the tiles.
   * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @return {function(number, import("../TileRange.js").default):boolean} A function that can be
   *     called with a zoom level and a tile range to add loaded tiles to the lookup.
   * @protected
   */
  LayerRenderer.prototype.createLoadedTileFinder = function createLoadedTileFinder (source, projection, tiles) {
    return (
      /**
       * @param {number} zoom Zoom level.
       * @param {import("../TileRange.js").default} tileRange Tile range.
       * @return {boolean} The tile range is fully loaded.
       */
      function(zoom, tileRange) {
        /**
         * @param {import("../Tile.js").default} tile Tile.
         */
        function callback(tile) {
          if (!tiles[zoom]) {
            tiles[zoom] = {};
          }
          tiles[zoom][tile.tileCoord.toString()] = tile;
        }
        return source.forEachLoadedTile(projection, zoom, tileRange, callback);
      }
    );
  };

  /**
   * @abstract
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(import("../Feature.js").FeatureLike, import("../layer/Layer.js").default): T} callback Feature callback.
   * @return {T|void} Callback result.
   * @template T
   */
  LayerRenderer.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate (coordinate, frameState, hitTolerance, callback) {};

  /**
   * @return {import("../layer/Layer.js").default} Layer.
   */
  LayerRenderer.prototype.getLayer = function getLayer () {
    return this.layer_;
  };

  /**
   * Handle changes in image state.
   * @param {import("../events/Event.js").default} event Image change event.
   * @private
   */
  LayerRenderer.prototype.handleImageChange_ = function handleImageChange_ (event) {
    var image = /** @type {import("../Image.js").default} */ (event.target);
    if (image.getState() === _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED) {
      this.renderIfReadyAndVisible();
    }
  };

  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @return {boolean} Is there a feature at the given coordinate?
   */
  LayerRenderer.prototype.hasFeatureAtCoordinate = function hasFeatureAtCoordinate (coordinate, frameState) {
    return false;
  };

  /**
   * Load the image if not already loaded, and register the image change
   * listener if needed.
   * @param {import("../ImageBase.js").default} image Image.
   * @return {boolean} `true` if the image is already loaded, `false` otherwise.
   * @protected
   */
  LayerRenderer.prototype.loadImage = function loadImage (image) {
    var imageState = image.getState();
    if (imageState != _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED && imageState != _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_4__["listen"])(image, _events_EventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].CHANGE, this.handleImageChange_, this);
    }
    if (imageState == _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE) {
      image.load();
      imageState = image.getState();
    }
    return imageState == _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED;
  };

  /**
   * @protected
   */
  LayerRenderer.prototype.renderIfReadyAndVisible = function renderIfReadyAndVisible () {
    var layer = this.getLayer();
    if (layer.getVisible() && layer.getSourceState() == _source_State_js__WEBPACK_IMPORTED_MODULE_6__["default"].READY) {
      this.changed();
    }
  };

  /**
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../source/Tile.js").default} tileSource Tile source.
   * @protected
   */
  LayerRenderer.prototype.scheduleExpireCache = function scheduleExpireCache (frameState, tileSource) {
    if (tileSource.canExpireCache()) {
      /**
       * @param {import("../source/Tile.js").default} tileSource Tile source.
       * @param {import("../PluggableMap.js").default} map Map.
       * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
       */
      var postRenderFunction = function(tileSource, map, frameState) {
        var tileSourceKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(tileSource);
        if (tileSourceKey in frameState.usedTiles) {
          tileSource.expireCache(frameState.viewState.projection,
            frameState.usedTiles[tileSourceKey]);
        }
      }.bind(null, tileSource);

      frameState.postRenderFunctions.push(
        /** @type {import("../PluggableMap.js").PostRenderFunction} */ (postRenderFunction)
      );
    }
  };

  /**
   * @param {!Object<string, !Object<string, import("../TileRange.js").default>>} usedTiles Used tiles.
   * @param {import("../source/Tile.js").default} tileSource Tile source.
   * @param {number} z Z.
   * @param {import("../TileRange.js").default} tileRange Tile range.
   * @protected
   */
  LayerRenderer.prototype.updateUsedTiles = function updateUsedTiles (usedTiles, tileSource, z, tileRange) {
    // FIXME should we use tilesToDrawByZ instead?
    var tileSourceKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(tileSource);
    var zKey = z.toString();
    if (tileSourceKey in usedTiles) {
      if (zKey in usedTiles[tileSourceKey]) {
        usedTiles[tileSourceKey][zKey].extend(tileRange);
      } else {
        usedTiles[tileSourceKey][zKey] = tileRange;
      }
    } else {
      usedTiles[tileSourceKey] = {};
      usedTiles[tileSourceKey][zKey] = tileRange;
    }
  };

  /**
   * Manage tile pyramid.
   * This function performs a number of functions related to the tiles at the
   * current zoom and lower zoom levels:
   * - registers idle tiles in frameState.wantedTiles so that they are not
   *   discarded by the tile queue
   * - enqueues missing tiles
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../source/Tile.js").default} tileSource Tile source.
   * @param {import("../tilegrid/TileGrid.js").default} tileGrid Tile grid.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} currentZ Current Z.
   * @param {number} preload Load low resolution tiles up to 'preload' levels.
   * @param {function(this: T, import("../Tile.js").default)=} opt_tileCallback Tile callback.
   * @param {T=} opt_this Object to use as `this` in `opt_tileCallback`.
   * @protected
   * @template T
   */
  LayerRenderer.prototype.manageTilePyramid = function manageTilePyramid (
    frameState,
    tileSource,
    tileGrid,
    pixelRatio,
    projection,
    extent,
    currentZ,
    preload,
    opt_tileCallback,
    opt_this
  ) {
    var tileSourceKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(tileSource);
    if (!(tileSourceKey in frameState.wantedTiles)) {
      frameState.wantedTiles[tileSourceKey] = {};
    }
    var wantedTiles = frameState.wantedTiles[tileSourceKey];
    var tileQueue = frameState.tileQueue;
    var minZoom = tileGrid.getMinZoom();
    var tile, tileRange, tileResolution, x, y, z;
    for (z = minZoom; z <= currentZ; ++z) {
      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);
      tileResolution = tileGrid.getResolution(z);
      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {
          if (currentZ - z <= preload) {
            tile = tileSource.getTile(z, x, y, pixelRatio, projection);
            if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_3__["default"].IDLE) {
              wantedTiles[tile.getKey()] = true;
              if (!tileQueue.isKeyQueued(tile.getKey())) {
                tileQueue.enqueue([tile, tileSourceKey,
                  tileGrid.getTileCoordCenter(tile.tileCoord), tileResolution]);
              }
            }
            if (opt_tileCallback !== undefined) {
              opt_tileCallback.call(opt_this, tile);
            }
          } else {
            tileSource.useTile(z, x, y, projection);
          }
        }
      }
    }
  };

  return LayerRenderer;
}(_Observable_js__WEBPACK_IMPORTED_MODULE_2__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (LayerRenderer);

//# sourceMappingURL=Layer.js.map

/***/ }),

/***/ "./node_modules/ol/renderer/Map.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/renderer/Map.js ***!
  \*****************************************/
/*! exports provided: sortByZIndex, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sortByZIndex", function() { return sortByZIndex; });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _Disposable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Disposable.js */ "./node_modules/ol/Disposable.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _layer_Layer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../layer/Layer.js */ "./node_modules/ol/layer/Layer.js");
/* harmony import */ var _style_IconImageCache_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../style/IconImageCache.js */ "./node_modules/ol/style/IconImageCache.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/renderer/Map
 */










/**
 * @abstract
 */
var MapRenderer = /*@__PURE__*/(function (Disposable) {
  function MapRenderer(map) {
    Disposable.call(this);

    /**
     * @private
     * @type {import("../PluggableMap.js").default}
     */
    this.map_ = map;

    /**
     * @private
     * @type {!Object<string, import("./Layer.js").default>}
     */
    this.layerRenderers_ = {};

    /**
     * @private
     * @type {Object<string, import("../events.js").EventsKey>}
     */
    this.layerRendererListeners_ = {};

    /**
     * @private
     * @type {Array<typeof import("./Layer.js").default>}
     */
    this.layerRendererConstructors_ = [];

  }

  if ( Disposable ) MapRenderer.__proto__ = Disposable;
  MapRenderer.prototype = Object.create( Disposable && Disposable.prototype );
  MapRenderer.prototype.constructor = MapRenderer;

  /**
   * @abstract
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   */
  MapRenderer.prototype.dispatchRenderEvent = function dispatchRenderEvent (type, frameState) {
    Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Register layer renderer constructors.
   * @param {Array<typeof import("./Layer.js").default>} constructors Layer renderers.
   */
  MapRenderer.prototype.registerLayerRenderers = function registerLayerRenderers (constructors) {
    this.layerRendererConstructors_.push.apply(this.layerRendererConstructors_, constructors);
  };

  /**
   * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
   * @protected
   */
  MapRenderer.prototype.calculateMatrices2D = function calculateMatrices2D (frameState) {
    var viewState = frameState.viewState;
    var coordinateToPixelTransform = frameState.coordinateToPixelTransform;
    var pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;

    Object(_transform_js__WEBPACK_IMPORTED_MODULE_8__["compose"])(coordinateToPixelTransform,
      frameState.size[0] / 2, frameState.size[1] / 2,
      1 / viewState.resolution, -1 / viewState.resolution,
      -viewState.rotation,
      -viewState.center[0], -viewState.center[1]);

    Object(_transform_js__WEBPACK_IMPORTED_MODULE_8__["invert"])(
      Object(_transform_js__WEBPACK_IMPORTED_MODULE_8__["setFromArray"])(pixelToCoordinateTransform, coordinateToPixelTransform));
  };

  /**
   * Removes all layer renderers.
   */
  MapRenderer.prototype.removeLayerRenderers = function removeLayerRenderers () {
    for (var key in this.layerRenderers_) {
      this.removeLayerRendererByKey_(key).dispose();
    }
  };

  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(this: S, import("../Feature.js").FeatureLike,
   *     import("../layer/Layer.js").default): T} callback Feature callback.
   * @param {S} thisArg Value to use as `this` when executing `callback`.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
   * @return {T|undefined} Callback result.
   * @template S,T,U
   */
  MapRenderer.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate (
    coordinate,
    frameState,
    hitTolerance,
    callback,
    thisArg,
    layerFilter,
    thisArg2
  ) {
    var result;
    var viewState = frameState.viewState;
    var viewResolution = viewState.resolution;

    /**
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {import("../layer/Layer.js").default} layer Layer.
     * @return {?} Callback result.
     */
    function forEachFeatureAtCoordinate(feature, layer) {
      var managed = frameState.layerStates[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(layer)].managed;
      if (!(Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature) in frameState.skippedFeatureUids && !managed)) {
        return callback.call(thisArg, feature, managed ? layer : null);
      }
    }

    var projection = viewState.projection;

    var translatedCoordinate = coordinate;
    if (projection.canWrapX()) {
      var projectionExtent = projection.getExtent();
      var worldWidth = Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["getWidth"])(projectionExtent);
      var x = coordinate[0];
      if (x < projectionExtent[0] || x > projectionExtent[2]) {
        var worldsAway = Math.ceil((projectionExtent[0] - x) / worldWidth);
        translatedCoordinate = [x + worldWidth * worldsAway, coordinate[1]];
      }
    }

    var layerStates = frameState.layerStatesArray;
    var numLayers = layerStates.length;
    var i;
    for (i = numLayers - 1; i >= 0; --i) {
      var layerState = layerStates[i];
      var layer = layerState.layer;
      if (Object(_layer_Layer_js__WEBPACK_IMPORTED_MODULE_6__["visibleAtResolution"])(layerState, viewResolution) && layerFilter.call(thisArg2, layer)) {
        var layerRenderer = this.getLayerRenderer(layer);
        var source = /** @type {import("../layer/Layer.js").default} */ (layer).getSource();
        if (source) {
          result = layerRenderer.forEachFeatureAtCoordinate(
            source.getWrapX() ? translatedCoordinate : coordinate,
            frameState, hitTolerance, forEachFeatureAtCoordinate);
        }
        if (result) {
          return result;
        }
      }
    }
    return undefined;
  };

  /**
   * @abstract
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(this: S, import("../layer/Layer.js").default, (Uint8ClampedArray|Uint8Array)): T} callback Layer
   *     callback.
   * @param {S} thisArg Value to use as `this` when executing `callback`.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
   * @return {T|undefined} Callback result.
   * @template S,T,U
   */
  MapRenderer.prototype.forEachLayerAtPixel = function forEachLayerAtPixel (pixel, frameState, hitTolerance, callback, thisArg, layerFilter, thisArg2) {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
   * @return {boolean} Is there a feature at the given coordinate?
   * @template U
   */
  MapRenderer.prototype.hasFeatureAtCoordinate = function hasFeatureAtCoordinate (coordinate, frameState, hitTolerance, layerFilter, thisArg) {
    var hasFeature = this.forEachFeatureAtCoordinate(
      coordinate, frameState, hitTolerance, _functions_js__WEBPACK_IMPORTED_MODULE_5__["TRUE"], this, layerFilter, thisArg);

    return hasFeature !== undefined;
  };

  /**
   * @param {import("../layer/Base.js").default} layer Layer.
   * @protected
   * @return {import("./Layer.js").default} Layer renderer.
   */
  MapRenderer.prototype.getLayerRenderer = function getLayerRenderer (layer) {
    var layerKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(layer);
    if (layerKey in this.layerRenderers_) {
      return this.layerRenderers_[layerKey];
    } else {
      var renderer;
      for (var i = 0, ii = this.layerRendererConstructors_.length; i < ii; ++i) {
        var candidate = this.layerRendererConstructors_[i];
        if (candidate['handles'](layer)) {
          renderer = candidate['create'](this, layer);
          break;
        }
      }
      if (renderer) {
        this.layerRenderers_[layerKey] = renderer;
        this.layerRendererListeners_[layerKey] = Object(_events_js__WEBPACK_IMPORTED_MODULE_2__["listen"])(renderer,
          _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].CHANGE, this.handleLayerRendererChange_, this);
      } else {
        throw new Error('Unable to create renderer for layer: ' + layer.getType());
      }
      return renderer;
    }
  };

  /**
   * @param {string} layerKey Layer key.
   * @protected
   * @return {import("./Layer.js").default} Layer renderer.
   */
  MapRenderer.prototype.getLayerRendererByKey = function getLayerRendererByKey (layerKey) {
    return this.layerRenderers_[layerKey];
  };

  /**
   * @protected
   * @return {Object<string, import("./Layer.js").default>} Layer renderers.
   */
  MapRenderer.prototype.getLayerRenderers = function getLayerRenderers () {
    return this.layerRenderers_;
  };

  /**
   * @return {import("../PluggableMap.js").default} Map.
   */
  MapRenderer.prototype.getMap = function getMap () {
    return this.map_;
  };

  /**
   * Handle changes in a layer renderer.
   * @private
   */
  MapRenderer.prototype.handleLayerRendererChange_ = function handleLayerRendererChange_ () {
    this.map_.render();
  };

  /**
   * @param {string} layerKey Layer key.
   * @return {import("./Layer.js").default} Layer renderer.
   * @private
   */
  MapRenderer.prototype.removeLayerRendererByKey_ = function removeLayerRendererByKey_ (layerKey) {
    var layerRenderer = this.layerRenderers_[layerKey];
    delete this.layerRenderers_[layerKey];

    Object(_events_js__WEBPACK_IMPORTED_MODULE_2__["unlistenByKey"])(this.layerRendererListeners_[layerKey]);
    delete this.layerRendererListeners_[layerKey];

    return layerRenderer;
  };

  /**
   * @param {import("../PluggableMap.js").default} map Map.
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @private
   */
  MapRenderer.prototype.removeUnusedLayerRenderers_ = function removeUnusedLayerRenderers_ (map, frameState) {
    for (var layerKey in this.layerRenderers_) {
      if (!frameState || !(layerKey in frameState.layerStates)) {
        this.removeLayerRendererByKey_(layerKey).dispose();
      }
    }
  };

  /**
   * Render.
   * @abstract
   * @param {?import("../PluggableMap.js").FrameState} frameState Frame state.
   */
  MapRenderer.prototype.renderFrame = function renderFrame (frameState) {
    Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @protected
   */
  MapRenderer.prototype.scheduleExpireIconCache = function scheduleExpireIconCache (frameState) {
    frameState.postRenderFunctions.push(/** @type {import("../PluggableMap.js").PostRenderFunction} */ (expireIconCache));
  };

  /**
   * @param {!import("../PluggableMap.js").FrameState} frameState Frame state.
   * @protected
   */
  MapRenderer.prototype.scheduleRemoveUnusedLayerRenderers = function scheduleRemoveUnusedLayerRenderers (frameState) {
    for (var layerKey in this.layerRenderers_) {
      if (!(layerKey in frameState.layerStates)) {
        frameState.postRenderFunctions.push(
          /** @type {import("../PluggableMap.js").PostRenderFunction} */ (this.removeUnusedLayerRenderers_.bind(this))
        );
        return;
      }
    }
  };

  return MapRenderer;
}(_Disposable_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/**
 * @param {import("../PluggableMap.js").default} map Map.
 * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
 */
function expireIconCache(map, frameState) {
  _style_IconImageCache_js__WEBPACK_IMPORTED_MODULE_7__["shared"].expire();
}


/**
 * @param {import("../layer/Layer.js").State} state1 First layer state.
 * @param {import("../layer/Layer.js").State} state2 Second layer state.
 * @return {number} The zIndex difference.
 */
function sortByZIndex(state1, state2) {
  return state1.zIndex - state2.zIndex;
}
/* harmony default export */ __webpack_exports__["default"] = (MapRenderer);

//# sourceMappingURL=Map.js.map

/***/ }),

/***/ "./node_modules/ol/renderer/canvas/ImageLayer.js":
/*!*******************************************************!*\
  !*** ./node_modules/ol/renderer/canvas/ImageLayer.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _reproj_common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../reproj/common.js */ "./node_modules/ol/reproj/common.js");
/* harmony import */ var _ImageCanvas_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../ImageCanvas.js */ "./node_modules/ol/ImageCanvas.js");
/* harmony import */ var _LayerType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../LayerType.js */ "./node_modules/ol/LayerType.js");
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../ViewHint.js */ "./node_modules/ol/ViewHint.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _layer_VectorRenderType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../layer/VectorRenderType.js */ "./node_modules/ol/layer/VectorRenderType.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _Map_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Map.js */ "./node_modules/ol/renderer/canvas/Map.js");
/* harmony import */ var _IntermediateCanvas_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./IntermediateCanvas.js */ "./node_modules/ol/renderer/canvas/IntermediateCanvas.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/renderer/canvas/ImageLayer
 */












/**
 * @classdesc
 * Canvas renderer for image layers.
 * @api
 */
var CanvasImageLayerRenderer = /*@__PURE__*/(function (IntermediateCanvasRenderer) {
  function CanvasImageLayerRenderer(imageLayer) {

    IntermediateCanvasRenderer.call(this, imageLayer);

    /**
     * @private
     * @type {?import("../../ImageBase.js").default}
     */
    this.image_ = null;

    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */
    this.imageTransform_ = Object(_transform_js__WEBPACK_IMPORTED_MODULE_10__["create"])();

    /**
     * @type {!Array<string>}
     */
    this.skippedFeatures_ = [];

    /**
     * @private
     * @type {import("./VectorLayer.js").default}
     */
    this.vectorRenderer_ = null;

    if (imageLayer.getType() === _LayerType_js__WEBPACK_IMPORTED_MODULE_2__["default"].VECTOR) {
      for (var i = 0, ii = _Map_js__WEBPACK_IMPORTED_MODULE_8__["layerRendererConstructors"].length; i < ii; ++i) {
        var ctor = _Map_js__WEBPACK_IMPORTED_MODULE_8__["layerRendererConstructors"][i];
        if (ctor !== CanvasImageLayerRenderer && ctor['handles'](imageLayer)) {
          this.vectorRenderer_ = /** @type {import("./VectorLayer.js").default} */ (new ctor(imageLayer));
          break;
        }
      }
    }

  }

  if ( IntermediateCanvasRenderer ) CanvasImageLayerRenderer.__proto__ = IntermediateCanvasRenderer;
  CanvasImageLayerRenderer.prototype = Object.create( IntermediateCanvasRenderer && IntermediateCanvasRenderer.prototype );
  CanvasImageLayerRenderer.prototype.constructor = CanvasImageLayerRenderer;

  /**
   * @inheritDoc
   */
  CanvasImageLayerRenderer.prototype.disposeInternal = function disposeInternal () {
    if (this.vectorRenderer_) {
      this.vectorRenderer_.dispose();
    }
    IntermediateCanvasRenderer.prototype.disposeInternal.call(this);
  };

  /**
   * @inheritDoc
   */
  CanvasImageLayerRenderer.prototype.getImage = function getImage () {
    return !this.image_ ? null : this.image_.getImage();
  };

  /**
   * @inheritDoc
   */
  CanvasImageLayerRenderer.prototype.getImageTransform = function getImageTransform () {
    return this.imageTransform_;
  };

  /**
   * @inheritDoc
   */
  CanvasImageLayerRenderer.prototype.prepareFrame = function prepareFrame (frameState, layerState) {

    var pixelRatio = frameState.pixelRatio;
    var size = frameState.size;
    var viewState = frameState.viewState;
    var viewCenter = viewState.center;
    var viewResolution = viewState.resolution;

    var image;
    var imageLayer = /** @type {import("../../layer/Image.js").default} */ (this.getLayer());
    var imageSource = /** @type {import("../../source/Image.js").default} */ (imageLayer.getSource());

    var hints = frameState.viewHints;

    var vectorRenderer = this.vectorRenderer_;
    var renderedExtent = frameState.extent;
    if (!vectorRenderer && layerState.extent !== undefined) {
      renderedExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getIntersection"])(renderedExtent, layerState.extent);
    }

    if (!hints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_3__["default"].ANIMATING] && !hints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_3__["default"].INTERACTING] &&
        !Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["isEmpty"])(renderedExtent)) {
      var projection = viewState.projection;
      if (!_reproj_common_js__WEBPACK_IMPORTED_MODULE_0__["ENABLE_RASTER_REPROJECTION"]) {
        var sourceProjection = imageSource.getProjection();
        if (sourceProjection) {
          projection = sourceProjection;
        }
      }
      var skippedFeatures = this.skippedFeatures_;
      if (vectorRenderer) {
        var context = vectorRenderer.context;
        var imageFrameState = /** @type {import("../../PluggableMap.js").FrameState} */ (Object(_obj_js__WEBPACK_IMPORTED_MODULE_7__["assign"])({}, frameState, {
          size: [
            Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getWidth"])(renderedExtent) / viewResolution,
            Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getHeight"])(renderedExtent) / viewResolution
          ],
          viewState: /** @type {import("../../View.js").State} */ (Object(_obj_js__WEBPACK_IMPORTED_MODULE_7__["assign"])({}, frameState.viewState, {
            rotation: 0
          }))
        }));
        var newSkippedFeatures = Object.keys(imageFrameState.skippedFeatureUids).sort();
        image = new _ImageCanvas_js__WEBPACK_IMPORTED_MODULE_1__["default"](renderedExtent, viewResolution, pixelRatio, context.canvas, function(callback) {
          if (vectorRenderer.prepareFrame(imageFrameState, layerState) &&
              (vectorRenderer.replayGroupChanged ||
              !Object(_array_js__WEBPACK_IMPORTED_MODULE_4__["equals"])(skippedFeatures, newSkippedFeatures))) {
            context.canvas.width = imageFrameState.size[0] * pixelRatio;
            context.canvas.height = imageFrameState.size[1] * pixelRatio;
            vectorRenderer.compose(context, imageFrameState, layerState);
            skippedFeatures = newSkippedFeatures;
            callback();
          }
        });
      } else {
        image = imageSource.getImage(
          renderedExtent, viewResolution, pixelRatio, projection);
      }
      if (image && this.loadImage(image)) {
        this.image_ = image;
        this.skippedFeatures_ = skippedFeatures;
      }
    }

    if (this.image_) {
      image = this.image_;
      var imageExtent = image.getExtent();
      var imageResolution = image.getResolution();
      var imagePixelRatio = image.getPixelRatio();
      var scale = pixelRatio * imageResolution /
          (viewResolution * imagePixelRatio);
      var transform = Object(_transform_js__WEBPACK_IMPORTED_MODULE_10__["compose"])(this.imageTransform_,
        pixelRatio * size[0] / 2, pixelRatio * size[1] / 2,
        scale, scale,
        0,
        imagePixelRatio * (imageExtent[0] - viewCenter[0]) / imageResolution,
        imagePixelRatio * (viewCenter[1] - imageExtent[3]) / imageResolution);
      Object(_transform_js__WEBPACK_IMPORTED_MODULE_10__["compose"])(this.coordinateToCanvasPixelTransform,
        pixelRatio * size[0] / 2 - transform[4], pixelRatio * size[1] / 2 - transform[5],
        pixelRatio / viewResolution, -pixelRatio / viewResolution,
        0,
        -viewCenter[0], -viewCenter[1]);

      this.renderedResolution = imageResolution * pixelRatio / imagePixelRatio;
    }

    return !!this.image_;
  };

  /**
   * @inheritDoc
   */
  CanvasImageLayerRenderer.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate (coordinate, frameState, hitTolerance, callback) {
    if (this.vectorRenderer_) {
      return this.vectorRenderer_.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback);
    } else {
      return IntermediateCanvasRenderer.prototype.forEachFeatureAtCoordinate.call(this, coordinate, frameState, hitTolerance, callback);
    }
  };

  return CanvasImageLayerRenderer;
}(_IntermediateCanvas_js__WEBPACK_IMPORTED_MODULE_9__["default"]));


/**
 * Determine if this renderer handles the provided layer.
 * @param {import("../../layer/Layer.js").default} layer The candidate layer.
 * @return {boolean} The renderer can render the layer.
 */
CanvasImageLayerRenderer['handles'] = function(layer) {
  return layer.getType() === _LayerType_js__WEBPACK_IMPORTED_MODULE_2__["default"].IMAGE ||
    layer.getType() === _LayerType_js__WEBPACK_IMPORTED_MODULE_2__["default"].VECTOR &&
    /** @type {import("../../layer/Vector.js").default} */ (layer).getRenderMode() === _layer_VectorRenderType_js__WEBPACK_IMPORTED_MODULE_6__["default"].IMAGE;
};


/**
 * Create a layer renderer.
 * @param {import("../Map.js").default} mapRenderer The map renderer.
 * @param {import("../../layer/Layer.js").default} layer The layer to be rendererd.
 * @return {CanvasImageLayerRenderer} The layer renderer.
 */
CanvasImageLayerRenderer['create'] = function(mapRenderer, layer) {
  return new CanvasImageLayerRenderer(/** @type {import("../../layer/Image.js").default} */ (layer));
};


/* harmony default export */ __webpack_exports__["default"] = (CanvasImageLayerRenderer);

//# sourceMappingURL=ImageLayer.js.map

/***/ }),

/***/ "./node_modules/ol/renderer/canvas/IntermediateCanvas.js":
/*!***************************************************************!*\
  !*** ./node_modules/ol/renderer/canvas/IntermediateCanvas.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../coordinate.js */ "./node_modules/ol/coordinate.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Layer.js */ "./node_modules/ol/renderer/canvas/Layer.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/renderer/canvas/IntermediateCanvas
 */







/**
 * @abstract
 */
var IntermediateCanvasRenderer = /*@__PURE__*/(function (CanvasLayerRenderer) {
  function IntermediateCanvasRenderer(layer) {

    CanvasLayerRenderer.call(this, layer);

    /**
     * @protected
     * @type {import("../../transform.js").Transform}
     */
    this.coordinateToCanvasPixelTransform = Object(_transform_js__WEBPACK_IMPORTED_MODULE_5__["create"])();

    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */
    this.hitCanvasContext_ = null;

  }

  if ( CanvasLayerRenderer ) IntermediateCanvasRenderer.__proto__ = CanvasLayerRenderer;
  IntermediateCanvasRenderer.prototype = Object.create( CanvasLayerRenderer && CanvasLayerRenderer.prototype );
  IntermediateCanvasRenderer.prototype.constructor = IntermediateCanvasRenderer;

  /**
   * @inheritDoc
   */
  IntermediateCanvasRenderer.prototype.composeFrame = function composeFrame (frameState, layerState, context) {

    this.preCompose(context, frameState);

    var image = this.getImage();
    if (image) {

      // clipped rendering if layer extent is set
      var extent = layerState.extent;
      var clipped = extent !== undefined &&
          !Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__["containsExtent"])(extent, frameState.extent) &&
          Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__["intersects"])(extent, frameState.extent);
      if (clipped) {
        this.clip(context, frameState, /** @type {import("../../extent.js").Extent} */ (extent));
      }

      var imageTransform = this.getImageTransform();
      // for performance reasons, context.save / context.restore is not used
      // to save and restore the transformation matrix and the opacity.
      // see http://jsperf.com/context-save-restore-versus-variable
      var alpha = context.globalAlpha;
      context.globalAlpha = layerState.opacity;

      // for performance reasons, context.setTransform is only used
      // when the view is rotated. see http://jsperf.com/canvas-transform
      var dx = imageTransform[4];
      var dy = imageTransform[5];
      var dw = image.width * imageTransform[0];
      var dh = image.height * imageTransform[3];
      if (dw >= 0.5 && dh >= 0.5) {
        context.drawImage(image, 0, 0, +image.width, +image.height,
          Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));
      }
      context.globalAlpha = alpha;

      if (clipped) {
        context.restore();
      }
    }

    this.postCompose(context, frameState, layerState);
  };

  /**
   * @abstract
   * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Canvas.
   */
  IntermediateCanvasRenderer.prototype.getImage = function getImage () {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * @abstract
   * @return {!import("../../transform.js").Transform} Image transform.
   */
  IntermediateCanvasRenderer.prototype.getImageTransform = function getImageTransform () {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * @inheritDoc
   */
  IntermediateCanvasRenderer.prototype.forEachLayerAtCoordinate = function forEachLayerAtCoordinate (coordinate, frameState, hitTolerance, callback, thisArg) {
    if (!this.getImage()) {
      return undefined;
    }

    var pixel = Object(_transform_js__WEBPACK_IMPORTED_MODULE_5__["apply"])(this.coordinateToCanvasPixelTransform, coordinate.slice());
    Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_1__["scale"])(pixel, frameState.viewState.resolution / this.renderedResolution);

    if (!this.hitCanvasContext_) {
      this.hitCanvasContext_ = Object(_dom_js__WEBPACK_IMPORTED_MODULE_2__["createCanvasContext2D"])(1, 1);
    }

    this.hitCanvasContext_.clearRect(0, 0, 1, 1);
    this.hitCanvasContext_.drawImage(this.getImage(), pixel[0], pixel[1], 1, 1, 0, 0, 1, 1);

    var imageData = this.hitCanvasContext_.getImageData(0, 0, 1, 1).data;
    if (imageData[3] > 0) {
      return callback.call(thisArg, this.getLayer(), imageData);
    } else {
      return undefined;
    }
  };

  return IntermediateCanvasRenderer;
}(_Layer_js__WEBPACK_IMPORTED_MODULE_4__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (IntermediateCanvasRenderer);

//# sourceMappingURL=IntermediateCanvas.js.map

/***/ }),

/***/ "./node_modules/ol/renderer/canvas/Layer.js":
/*!**************************************************!*\
  !*** ./node_modules/ol/renderer/canvas/Layer.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _render_Event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../render/Event.js */ "./node_modules/ol/render/Event.js");
/* harmony import */ var _render_EventType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../render/EventType.js */ "./node_modules/ol/render/EventType.js");
/* harmony import */ var _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../render/canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _render_canvas_Immediate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../render/canvas/Immediate.js */ "./node_modules/ol/render/canvas/Immediate.js");
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Layer.js */ "./node_modules/ol/renderer/Layer.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/renderer/canvas/Layer
 */










/**
 * @abstract
 */
var CanvasLayerRenderer = /*@__PURE__*/(function (LayerRenderer) {
  function CanvasLayerRenderer(layer) {

    LayerRenderer.call(this, layer);

    /**
     * @protected
     * @type {number}
     */
    this.renderedResolution;

    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */
    this.transform_ = Object(_transform_js__WEBPACK_IMPORTED_MODULE_8__["create"])();

  }

  if ( LayerRenderer ) CanvasLayerRenderer.__proto__ = LayerRenderer;
  CanvasLayerRenderer.prototype = Object.create( LayerRenderer && LayerRenderer.prototype );
  CanvasLayerRenderer.prototype.constructor = CanvasLayerRenderer;

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent Clip extent.
   * @protected
   */
  CanvasLayerRenderer.prototype.clip = function clip (context, frameState, extent) {
    var pixelRatio = frameState.pixelRatio;
    var width = frameState.size[0] * pixelRatio;
    var height = frameState.size[1] * pixelRatio;
    var rotation = frameState.viewState.rotation;
    var topLeft = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getTopLeft"])(extent);
    var topRight = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getTopRight"])(extent);
    var bottomRight = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getBottomRight"])(extent);
    var bottomLeft = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getBottomLeft"])(extent);

    Object(_transform_js__WEBPACK_IMPORTED_MODULE_8__["apply"])(frameState.coordinateToPixelTransform, topLeft);
    Object(_transform_js__WEBPACK_IMPORTED_MODULE_8__["apply"])(frameState.coordinateToPixelTransform, topRight);
    Object(_transform_js__WEBPACK_IMPORTED_MODULE_8__["apply"])(frameState.coordinateToPixelTransform, bottomRight);
    Object(_transform_js__WEBPACK_IMPORTED_MODULE_8__["apply"])(frameState.coordinateToPixelTransform, bottomLeft);

    context.save();
    Object(_render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["rotateAtOffset"])(context, -rotation, width / 2, height / 2);
    context.beginPath();
    context.moveTo(topLeft[0] * pixelRatio, topLeft[1] * pixelRatio);
    context.lineTo(topRight[0] * pixelRatio, topRight[1] * pixelRatio);
    context.lineTo(bottomRight[0] * pixelRatio, bottomRight[1] * pixelRatio);
    context.lineTo(bottomLeft[0] * pixelRatio, bottomLeft[1] * pixelRatio);
    context.clip();
    Object(_render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["rotateAtOffset"])(context, rotation, width / 2, height / 2);
  };

  /**
   * @param {import("../../render/EventType.js").default} type Event type.
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../../transform.js").Transform=} opt_transform Transform.
   * @private
   */
  CanvasLayerRenderer.prototype.dispatchComposeEvent_ = function dispatchComposeEvent_ (type, context, frameState, opt_transform) {
    var layer = this.getLayer();
    if (layer.hasListener(type)) {
      var width = frameState.size[0] * frameState.pixelRatio;
      var height = frameState.size[1] * frameState.pixelRatio;
      var rotation = frameState.viewState.rotation;
      Object(_render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["rotateAtOffset"])(context, -rotation, width / 2, height / 2);
      var transform = opt_transform !== undefined ?
        opt_transform : this.getTransform(frameState, 0);
      var render = new _render_canvas_Immediate_js__WEBPACK_IMPORTED_MODULE_6__["default"](
        context, frameState.pixelRatio, frameState.extent, transform,
        frameState.viewState.rotation);
      var composeEvent = new _render_Event_js__WEBPACK_IMPORTED_MODULE_3__["default"](type, render, frameState,
        context, null);
      layer.dispatchEvent(composeEvent);
      Object(_render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["rotateAtOffset"])(context, rotation, width / 2, height / 2);
    }
  };

  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../PluggableMap.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(this: S, import("../../layer/Layer.js").default, (Uint8ClampedArray|Uint8Array)): T} callback Layer
   *     callback.
   * @param {S} thisArg Value to use as `this` when executing `callback`.
   * @return {T|undefined} Callback result.
   * @template S,T,U
   */
  CanvasLayerRenderer.prototype.forEachLayerAtCoordinate = function forEachLayerAtCoordinate (coordinate, frameState, hitTolerance, callback, thisArg) {
    var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, _functions_js__WEBPACK_IMPORTED_MODULE_2__["TRUE"]);

    if (hasFeature) {
      return callback.call(thisArg, this.getLayer(), null);
    } else {
      return undefined;
    }
  };

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../../layer/Layer.js").State} layerState Layer state.
   * @param {import("../../transform.js").Transform=} opt_transform Transform.
   * @protected
   */
  CanvasLayerRenderer.prototype.postCompose = function postCompose (context, frameState, layerState, opt_transform) {
    this.dispatchComposeEvent_(_render_EventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].POSTCOMPOSE, context, frameState, opt_transform);
  };

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../../transform.js").Transform=} opt_transform Transform.
   * @protected
   */
  CanvasLayerRenderer.prototype.preCompose = function preCompose (context, frameState, opt_transform) {
    this.dispatchComposeEvent_(_render_EventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].PRECOMPOSE, context, frameState, opt_transform);
  };

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../../transform.js").Transform=} opt_transform Transform.
   * @protected
   */
  CanvasLayerRenderer.prototype.dispatchRenderEvent = function dispatchRenderEvent (context, frameState, opt_transform) {
    this.dispatchComposeEvent_(_render_EventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].RENDER, context, frameState, opt_transform);
  };

  /**
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {number} offsetX Offset on the x-axis in view coordinates.
   * @protected
   * @return {!import("../../transform.js").Transform} Transform.
   */
  CanvasLayerRenderer.prototype.getTransform = function getTransform (frameState, offsetX) {
    var viewState = frameState.viewState;
    var pixelRatio = frameState.pixelRatio;
    var dx1 = pixelRatio * frameState.size[0] / 2;
    var dy1 = pixelRatio * frameState.size[1] / 2;
    var sx = pixelRatio / viewState.resolution;
    var sy = -sx;
    var angle = -viewState.rotation;
    var dx2 = -viewState.center[0] + offsetX;
    var dy2 = -viewState.center[1];
    return Object(_transform_js__WEBPACK_IMPORTED_MODULE_8__["compose"])(this.transform_, dx1, dy1, sx, sy, angle, dx2, dy2);
  };

  /**
   * @abstract
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../../layer/Layer.js").State} layerState Layer state.
   * @param {CanvasRenderingContext2D} context Context.
   */
  CanvasLayerRenderer.prototype.composeFrame = function composeFrame (frameState, layerState, context) {
    Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * @abstract
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../../layer/Layer.js").State} layerState Layer state.
   * @return {boolean} whether composeFrame should be called.
   */
  CanvasLayerRenderer.prototype.prepareFrame = function prepareFrame (frameState, layerState) {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  return CanvasLayerRenderer;
}(_Layer_js__WEBPACK_IMPORTED_MODULE_7__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (CanvasLayerRenderer);

//# sourceMappingURL=Layer.js.map

/***/ }),

/***/ "./node_modules/ol/renderer/canvas/Map.js":
/*!************************************************!*\
  !*** ./node_modules/ol/renderer/canvas/Map.js ***!
  \************************************************/
/*! exports provided: layerRendererConstructors, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "layerRendererConstructors", function() { return layerRendererConstructors; });
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../css.js */ "./node_modules/ol/css.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _layer_Layer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../layer/Layer.js */ "./node_modules/ol/layer/Layer.js");
/* harmony import */ var _render_Event_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../render/Event.js */ "./node_modules/ol/render/Event.js");
/* harmony import */ var _render_EventType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../render/EventType.js */ "./node_modules/ol/render/EventType.js");
/* harmony import */ var _render_canvas_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../render/canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _render_canvas_Immediate_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../render/canvas/Immediate.js */ "./node_modules/ol/render/canvas/Immediate.js");
/* harmony import */ var _Map_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../Map.js */ "./node_modules/ol/renderer/Map.js");
/* harmony import */ var _source_State_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../source/State.js */ "./node_modules/ol/source/State.js");
/**
 * @module ol/renderer/canvas/Map
 */













/**
 * @type {Array<typeof import("../Layer.js").default>}
 */
var layerRendererConstructors = [];

/**
 * @classdesc
 * Canvas map renderer.
 * @api
 */
var CanvasMapRenderer = /*@__PURE__*/(function (MapRenderer) {
  function CanvasMapRenderer(map) {
    MapRenderer.call(this, map);

    var container = map.getViewport();

    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */
    this.context_ = Object(_dom_js__WEBPACK_IMPORTED_MODULE_3__["createCanvasContext2D"])();

    /**
     * @private
     * @type {HTMLCanvasElement}
     */
    this.canvas_ = this.context_.canvas;

    this.canvas_.style.width = '100%';
    this.canvas_.style.height = '100%';
    this.canvas_.style.display = 'block';
    this.canvas_.className = _css_js__WEBPACK_IMPORTED_MODULE_2__["CLASS_UNSELECTABLE"];
    container.insertBefore(this.canvas_, container.childNodes[0] || null);

    /**
     * @private
     * @type {boolean}
     */
    this.renderedVisible_ = true;

    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */
    this.transform_ = Object(_transform_js__WEBPACK_IMPORTED_MODULE_0__["create"])();

  }

  if ( MapRenderer ) CanvasMapRenderer.__proto__ = MapRenderer;
  CanvasMapRenderer.prototype = Object.create( MapRenderer && MapRenderer.prototype );
  CanvasMapRenderer.prototype.constructor = CanvasMapRenderer;

  /**
   * @param {import("../../render/EventType.js").default} type Event type.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   */
  CanvasMapRenderer.prototype.dispatchRenderEvent = function dispatchRenderEvent (type, frameState) {
    var map = this.getMap();
    var context = this.context_;
    if (map.hasListener(type)) {
      var extent = frameState.extent;
      var pixelRatio = frameState.pixelRatio;
      var viewState = frameState.viewState;
      var rotation = viewState.rotation;

      var transform = this.getTransform(frameState);

      var vectorContext = new _render_canvas_Immediate_js__WEBPACK_IMPORTED_MODULE_8__["default"](context, pixelRatio,
        extent, transform, rotation);
      var composeEvent = new _render_Event_js__WEBPACK_IMPORTED_MODULE_5__["default"](type, vectorContext,
        frameState, context, null);
      map.dispatchEvent(composeEvent);
    }
  };

  /**
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @protected
   * @return {!import("../../transform.js").Transform} Transform.
   */
  CanvasMapRenderer.prototype.getTransform = function getTransform (frameState) {
    var viewState = frameState.viewState;
    var dx1 = this.canvas_.width / 2;
    var dy1 = this.canvas_.height / 2;
    var sx = frameState.pixelRatio / viewState.resolution;
    var sy = -sx;
    var angle = -viewState.rotation;
    var dx2 = -viewState.center[0];
    var dy2 = -viewState.center[1];
    return Object(_transform_js__WEBPACK_IMPORTED_MODULE_0__["compose"])(this.transform_, dx1, dy1, sx, sy, angle, dx2, dy2);
  };

  /**
   * @inheritDoc
   */
  CanvasMapRenderer.prototype.renderFrame = function renderFrame (frameState) {

    if (!frameState) {
      if (this.renderedVisible_) {
        this.canvas_.style.display = 'none';
        this.renderedVisible_ = false;
      }
      return;
    }

    var context = this.context_;
    var pixelRatio = frameState.pixelRatio;
    var width = Math.round(frameState.size[0] * pixelRatio);
    var height = Math.round(frameState.size[1] * pixelRatio);
    if (this.canvas_.width != width || this.canvas_.height != height) {
      this.canvas_.width = width;
      this.canvas_.height = height;
    } else {
      context.clearRect(0, 0, width, height);
    }

    var rotation = frameState.viewState.rotation;

    this.calculateMatrices2D(frameState);

    this.dispatchRenderEvent(_render_EventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].PRECOMPOSE, frameState);

    var layerStatesArray = frameState.layerStatesArray;
    Object(_array_js__WEBPACK_IMPORTED_MODULE_1__["stableSort"])(layerStatesArray, _Map_js__WEBPACK_IMPORTED_MODULE_9__["sortByZIndex"]);

    if (rotation) {
      context.save();
      Object(_render_canvas_js__WEBPACK_IMPORTED_MODULE_7__["rotateAtOffset"])(context, rotation, width / 2, height / 2);
    }

    var viewResolution = frameState.viewState.resolution;
    var i, ii;
    for (i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      var layerState = layerStatesArray[i];
      var layer = layerState.layer;
      var layerRenderer = /** @type {import("./Layer.js").default} */ (this.getLayerRenderer(layer));
      if (!Object(_layer_Layer_js__WEBPACK_IMPORTED_MODULE_4__["visibleAtResolution"])(layerState, viewResolution) ||
          layerState.sourceState != _source_State_js__WEBPACK_IMPORTED_MODULE_10__["default"].READY) {
        continue;
      }
      if (layerRenderer.prepareFrame(frameState, layerState)) {
        layerRenderer.composeFrame(frameState, layerState, context);
      }
    }

    if (rotation) {
      context.restore();
    }

    this.dispatchRenderEvent(_render_EventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].POSTCOMPOSE, frameState);

    if (!this.renderedVisible_) {
      this.canvas_.style.display = '';
      this.renderedVisible_ = true;
    }

    this.scheduleRemoveUnusedLayerRenderers(frameState);
    this.scheduleExpireIconCache(frameState);
  };

  /**
   * @inheritDoc
   */
  CanvasMapRenderer.prototype.forEachLayerAtPixel = function forEachLayerAtPixel (pixel, frameState, hitTolerance, callback, thisArg, layerFilter, thisArg2) {
    var result;
    var viewState = frameState.viewState;
    var viewResolution = viewState.resolution;

    var layerStates = frameState.layerStatesArray;
    var numLayers = layerStates.length;

    var coordinate = Object(_transform_js__WEBPACK_IMPORTED_MODULE_0__["apply"])(
      frameState.pixelToCoordinateTransform, pixel.slice());

    var i;
    for (i = numLayers - 1; i >= 0; --i) {
      var layerState = layerStates[i];
      var layer = layerState.layer;
      if (Object(_layer_Layer_js__WEBPACK_IMPORTED_MODULE_4__["visibleAtResolution"])(layerState, viewResolution) && layerFilter.call(thisArg2, layer)) {
        var layerRenderer = /** @type {import("./Layer.js").default} */ (this.getLayerRenderer(layer));
        result = layerRenderer.forEachLayerAtCoordinate(
          coordinate, frameState, hitTolerance, callback, thisArg);
        if (result) {
          return result;
        }
      }
    }
    return undefined;
  };

  /**
   * @inheritDoc
   */
  CanvasMapRenderer.prototype.registerLayerRenderers = function registerLayerRenderers (constructors) {
    MapRenderer.prototype.registerLayerRenderers.call(this, constructors);
    for (var i = 0, ii = constructors.length; i < ii; ++i) {
      var ctor = constructors[i];
      if (!Object(_array_js__WEBPACK_IMPORTED_MODULE_1__["includes"])(layerRendererConstructors, ctor)) {
        layerRendererConstructors.push(ctor);
      }
    }
  };

  return CanvasMapRenderer;
}(_Map_js__WEBPACK_IMPORTED_MODULE_9__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (CanvasMapRenderer);

//# sourceMappingURL=Map.js.map

/***/ }),

/***/ "./node_modules/ol/renderer/canvas/TileLayer.js":
/*!******************************************************!*\
  !*** ./node_modules/ol/renderer/canvas/TileLayer.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _LayerType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../LayerType.js */ "./node_modules/ol/LayerType.js");
/* harmony import */ var _TileRange_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../TileRange.js */ "./node_modules/ol/TileRange.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../ViewHint.js */ "./node_modules/ol/ViewHint.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _IntermediateCanvas_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./IntermediateCanvas.js */ "./node_modules/ol/renderer/canvas/IntermediateCanvas.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/renderer/canvas/TileLayer
 */










/**
 * @classdesc
 * Canvas renderer for tile layers.
 * @api
 */
var CanvasTileLayerRenderer = /*@__PURE__*/(function (IntermediateCanvasRenderer) {
  function CanvasTileLayerRenderer(tileLayer, opt_noContext) {

    IntermediateCanvasRenderer.call(this, tileLayer);

    /**
     * @protected
     * @type {CanvasRenderingContext2D}
     */
    this.context = opt_noContext ? null : Object(_dom_js__WEBPACK_IMPORTED_MODULE_5__["createCanvasContext2D"])();

    /**
     * @private
     * @type {number}
     */
    this.oversampling_;

    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */
    this.renderedExtent_ = null;

    /**
     * @protected
     * @type {number}
     */
    this.renderedRevision;

    /**
     * @protected
     * @type {!Array<import("../../Tile.js").default>}
     */
    this.renderedTiles = [];

    /**
     * @private
     * @type {boolean}
     */
    this.newTiles_ = false;

    /**
     * @protected
     * @type {import("../../extent.js").Extent}
     */
    this.tmpExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_6__["createEmpty"])();

    /**
     * @private
     * @type {import("../../TileRange.js").default}
     */
    this.tmpTileRange_ = new _TileRange_js__WEBPACK_IMPORTED_MODULE_2__["default"](0, 0, 0, 0);

    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */
    this.imageTransform_ = Object(_transform_js__WEBPACK_IMPORTED_MODULE_8__["create"])();

    /**
     * @protected
     * @type {number}
     */
    this.zDirection = 0;

  }

  if ( IntermediateCanvasRenderer ) CanvasTileLayerRenderer.__proto__ = IntermediateCanvasRenderer;
  CanvasTileLayerRenderer.prototype = Object.create( IntermediateCanvasRenderer && IntermediateCanvasRenderer.prototype );
  CanvasTileLayerRenderer.prototype.constructor = CanvasTileLayerRenderer;

  /**
   * @private
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {boolean} Tile is drawable.
   */
  CanvasTileLayerRenderer.prototype.isDrawableTile_ = function isDrawableTile_ (tile) {
    var tileLayer = /** @type {import("../../layer/Tile.js").default} */ (this.getLayer());
    var tileState = tile.getState();
    var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();
    return tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_3__["default"].LOADED ||
        tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_3__["default"].EMPTY ||
        tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_3__["default"].ERROR && !useInterimTilesOnError;
  };

  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection.js").default} projection Projection.
   * @return {!import("../../Tile.js").default} Tile.
   */
  CanvasTileLayerRenderer.prototype.getTile = function getTile (z, x, y, pixelRatio, projection) {
    var tileLayer = /** @type {import("../../layer/Tile.js").default} */ (this.getLayer());
    var tileSource = /** @type {import("../../source/Tile.js").default} */ (tileLayer.getSource());
    var tile = tileSource.getTile(z, x, y, pixelRatio, projection);
    if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_3__["default"].ERROR) {
      if (!tileLayer.getUseInterimTilesOnError()) {
        // When useInterimTilesOnError is false, we consider the error tile as loaded.
        tile.setState(_TileState_js__WEBPACK_IMPORTED_MODULE_3__["default"].LOADED);
      } else if (tileLayer.getPreload() > 0) {
        // Preloaded tiles for lower resolutions might have finished loading.
        this.newTiles_ = true;
      }
    }
    if (!this.isDrawableTile_(tile)) {
      tile = tile.getInterimTile();
    }
    return tile;
  };

  /**
   * @inheritDoc
   */
  CanvasTileLayerRenderer.prototype.prepareFrame = function prepareFrame (frameState, layerState) {

    var pixelRatio = frameState.pixelRatio;
    var size = frameState.size;
    var viewState = frameState.viewState;
    var projection = viewState.projection;
    var viewResolution = viewState.resolution;
    var viewCenter = viewState.center;

    var tileLayer = /** @type {import("../../layer/Tile.js").default} */ (this.getLayer());
    var tileSource = /** @type {import("../../source/Tile.js").default} */ (tileLayer.getSource());
    var sourceRevision = tileSource.getRevision();
    var tileGrid = tileSource.getTileGridForProjection(projection);
    var z = tileGrid.getZForResolution(viewResolution, this.zDirection);
    var tileResolution = tileGrid.getResolution(z);
    var oversampling = Math.round(viewResolution / tileResolution) || 1;
    var extent = frameState.extent;

    if (layerState.extent !== undefined) {
      extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_6__["getIntersection"])(extent, layerState.extent);
    }
    if (Object(_extent_js__WEBPACK_IMPORTED_MODULE_6__["isEmpty"])(extent)) {
      // Return false to prevent the rendering of the layer.
      return false;
    }

    var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
    var imageExtent = tileGrid.getTileRangeExtent(z, tileRange);

    var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);

    /**
     * @type {Object<number, Object<string, import("../../Tile.js").default>>}
     */
    var tilesToDrawByZ = {};
    tilesToDrawByZ[z] = {};

    var findLoadedTiles = this.createLoadedTileFinder(
      tileSource, projection, tilesToDrawByZ);

    var hints = frameState.viewHints;
    var animatingOrInteracting = hints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_4__["default"].ANIMATING] || hints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_4__["default"].INTERACTING];

    var tmpExtent = this.tmpExtent;
    var tmpTileRange = this.tmpTileRange_;
    this.newTiles_ = false;
    var tile, x, y;
    for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (y = tileRange.minY; y <= tileRange.maxY; ++y) {
        if (Date.now() - frameState.time > 16 && animatingOrInteracting) {
          continue;
        }
        tile = this.getTile(z, x, y, pixelRatio, projection);
        if (this.isDrawableTile_(tile)) {
          var uid = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(this);
          if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_3__["default"].LOADED) {
            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;
            var inTransition = tile.inTransition(uid);
            if (!this.newTiles_ && (inTransition || this.renderedTiles.indexOf(tile) === -1)) {
              this.newTiles_ = true;
            }
          }
          if (tile.getAlpha(uid, frameState.time) === 1) {
            // don't look for alt tiles if alpha is 1
            continue;
          }
        }

        var childTileRange = tileGrid.getTileCoordChildTileRange(
          tile.tileCoord, tmpTileRange, tmpExtent);
        var covered = false;
        if (childTileRange) {
          covered = findLoadedTiles(z + 1, childTileRange);
        }
        if (!covered) {
          tileGrid.forEachTileCoordParentTileRange(
            tile.tileCoord, findLoadedTiles, null, tmpTileRange, tmpExtent);
        }

      }
    }

    var renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;
    if (!(this.renderedResolution && Date.now() - frameState.time > 16 && animatingOrInteracting) && (
      this.newTiles_ ||
          !(this.renderedExtent_ && Object(_extent_js__WEBPACK_IMPORTED_MODULE_6__["containsExtent"])(this.renderedExtent_, extent)) ||
          this.renderedRevision != sourceRevision ||
          oversampling != this.oversampling_ ||
          !animatingOrInteracting && renderedResolution != this.renderedResolution
    )) {

      var context = this.context;
      if (context) {
        var tilePixelSize = tileSource.getTilePixelSize(z, pixelRatio, projection);
        var width = Math.round(tileRange.getWidth() * tilePixelSize[0] / oversampling);
        var height = Math.round(tileRange.getHeight() * tilePixelSize[1] / oversampling);
        var canvas = context.canvas;
        if (canvas.width != width || canvas.height != height) {
          this.oversampling_ = oversampling;
          canvas.width = width;
          canvas.height = height;
        } else {
          if ((this.renderedExtent_ && !Object(_extent_js__WEBPACK_IMPORTED_MODULE_6__["equals"])(imageExtent, this.renderedExtent_)) ||
              this.renderedRevision != sourceRevision) {
            context.clearRect(0, 0, width, height);
          }
          oversampling = this.oversampling_;
        }
      }

      this.renderedTiles.length = 0;
      /** @type {Array<number>} */
      var zs = Object.keys(tilesToDrawByZ).map(Number);
      zs.sort(function(a, b) {
        if (a === z) {
          return 1;
        } else if (b === z) {
          return -1;
        } else {
          return a > b ? 1 : a < b ? -1 : 0;
        }
      });
      var currentResolution, currentScale, currentTilePixelSize, currentZ, i, ii;
      var tileExtent, tileGutter, tilesToDraw, w, h;
      for (i = 0, ii = zs.length; i < ii; ++i) {
        currentZ = zs[i];
        currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);
        currentResolution = tileGrid.getResolution(currentZ);
        currentScale = currentResolution / tileResolution;
        tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);
        tilesToDraw = tilesToDrawByZ[currentZ];
        for (var tileCoordKey in tilesToDraw) {
          tile = tilesToDraw[tileCoordKey];
          tileExtent = tileGrid.getTileCoordExtent(tile.getTileCoord(), tmpExtent);
          x = (tileExtent[0] - imageExtent[0]) / tileResolution * tilePixelRatio / oversampling;
          y = (imageExtent[3] - tileExtent[3]) / tileResolution * tilePixelRatio / oversampling;
          w = currentTilePixelSize[0] * currentScale / oversampling;
          h = currentTilePixelSize[1] * currentScale / oversampling;
          this.drawTileImage(tile, frameState, layerState, x, y, w, h, tileGutter, z === currentZ);
          this.renderedTiles.push(tile);
        }
      }

      this.renderedRevision = sourceRevision;
      this.renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;
      this.renderedExtent_ = imageExtent;
    }

    var scale = this.renderedResolution / viewResolution;
    var transform = Object(_transform_js__WEBPACK_IMPORTED_MODULE_8__["compose"])(this.imageTransform_,
      pixelRatio * size[0] / 2, pixelRatio * size[1] / 2,
      scale, scale,
      0,
      (this.renderedExtent_[0] - viewCenter[0]) / this.renderedResolution * pixelRatio,
      (viewCenter[1] - this.renderedExtent_[3]) / this.renderedResolution * pixelRatio);
    Object(_transform_js__WEBPACK_IMPORTED_MODULE_8__["compose"])(this.coordinateToCanvasPixelTransform,
      pixelRatio * size[0] / 2 - transform[4], pixelRatio * size[1] / 2 - transform[5],
      pixelRatio / viewResolution, -pixelRatio / viewResolution,
      0,
      -viewCenter[0], -viewCenter[1]);


    this.updateUsedTiles(frameState.usedTiles, tileSource, z, tileRange);
    this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio,
      projection, extent, z, tileLayer.getPreload());
    this.scheduleExpireCache(frameState, tileSource);

    return this.renderedTiles.length > 0;
  };

  /**
   * @param {import("../../Tile.js").default} tile Tile.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../../layer/Layer.js").State} layerState Layer state.
   * @param {number} x Left of the tile.
   * @param {number} y Top of the tile.
   * @param {number} w Width of the tile.
   * @param {number} h Height of the tile.
   * @param {number} gutter Tile gutter.
   * @param {boolean} transition Apply an alpha transition.
   */
  CanvasTileLayerRenderer.prototype.drawTileImage = function drawTileImage (tile, frameState, layerState, x, y, w, h, gutter, transition) {
    var image = this.getTileImage(tile);
    if (!image) {
      return;
    }
    var uid = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(this);
    var alpha = transition ? tile.getAlpha(uid, frameState.time) : 1;
    var tileLayer = /** @type {import("../../layer/Tile.js").default} */ (this.getLayer());
    var tileSource = /** @type {import("../../source/Tile.js").default} */ (tileLayer.getSource());
    if (alpha === 1 && !tileSource.getOpaque(frameState.viewState.projection)) {
      this.context.clearRect(x, y, w, h);
    }
    var alphaChanged = alpha !== this.context.globalAlpha;
    if (alphaChanged) {
      this.context.save();
      this.context.globalAlpha = alpha;
    }
    this.context.drawImage(image, gutter, gutter,
      image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);

    if (alphaChanged) {
      this.context.restore();
    }
    if (alpha !== 1) {
      frameState.animate = true;
    } else if (transition) {
      tile.endTransition(uid);
    }
  };

  /**
   * @inheritDoc
   */
  CanvasTileLayerRenderer.prototype.getImage = function getImage () {
    var context = this.context;
    return context ? context.canvas : null;
  };

  /**
   * @inheritDoc
   */
  CanvasTileLayerRenderer.prototype.getImageTransform = function getImageTransform () {
    return this.imageTransform_;
  };

  /**
   * Get the image from a tile.
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @protected
   */
  CanvasTileLayerRenderer.prototype.getTileImage = function getTileImage (tile) {
    return /** @type {import("../../ImageTile.js").default} */ (tile).getImage();
  };

  return CanvasTileLayerRenderer;
}(_IntermediateCanvas_js__WEBPACK_IMPORTED_MODULE_7__["default"]));


/**
 * Determine if this renderer handles the provided layer.
 * @param {import("../../layer/Layer.js").default} layer The candidate layer.
 * @return {boolean} The renderer can render the layer.
 */
CanvasTileLayerRenderer['handles'] = function(layer) {
  return layer.getType() === _LayerType_js__WEBPACK_IMPORTED_MODULE_1__["default"].TILE;
};


/**
 * Create a layer renderer.
 * @param {import("../Map.js").default} mapRenderer The map renderer.
 * @param {import("../../layer/Layer.js").default} layer The layer to be rendererd.
 * @return {CanvasTileLayerRenderer} The layer renderer.
 */
CanvasTileLayerRenderer['create'] = function(mapRenderer, layer) {
  return new CanvasTileLayerRenderer(/** @type {import("../../layer/Tile.js").default} */ (layer));
};


/**
 * @function
 * @return {import("../../layer/Tile.js").default|import("../../layer/VectorTile.js").default}
 */
CanvasTileLayerRenderer.prototype.getLayer;


/* harmony default export */ __webpack_exports__["default"] = (CanvasTileLayerRenderer);

//# sourceMappingURL=TileLayer.js.map

/***/ }),

/***/ "./node_modules/ol/renderer/canvas/VectorLayer.js":
/*!********************************************************!*\
  !*** ./node_modules/ol/renderer/canvas/VectorLayer.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _LayerType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../LayerType.js */ "./node_modules/ol/LayerType.js");
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../ViewHint.js */ "./node_modules/ol/ViewHint.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rbush */ "./node_modules/rbush/index.js");
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(rbush__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _render_EventType_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../render/EventType.js */ "./node_modules/ol/render/EventType.js");
/* harmony import */ var _render_canvas_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../render/canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _render_canvas_ReplayGroup_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../render/canvas/ReplayGroup.js */ "./node_modules/ol/render/canvas/ReplayGroup.js");
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Layer.js */ "./node_modules/ol/renderer/canvas/Layer.js");
/* harmony import */ var _vector_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../vector.js */ "./node_modules/ol/renderer/vector.js");
/**
 * @module ol/renderer/canvas/VectorLayer
 */














/**
 * @classdesc
 * Canvas renderer for vector layers.
 * @api
 */
var CanvasVectorLayerRenderer = /*@__PURE__*/(function (CanvasLayerRenderer) {
  function CanvasVectorLayerRenderer(vectorLayer) {

    CanvasLayerRenderer.call(this, vectorLayer);

    /**
     * Declutter tree.
     * @private
     */
    this.declutterTree_ = vectorLayer.getDeclutter() ? rbush__WEBPACK_IMPORTED_MODULE_6___default()(9, undefined) : null;

    /**
     * @private
     * @type {boolean}
     */
    this.dirty_ = false;

    /**
     * @private
     * @type {number}
     */
    this.renderedRevision_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.renderedResolution_ = NaN;

    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */
    this.renderedExtent_ = Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["createEmpty"])();

    /**
     * @private
     * @type {function(import("../../Feature.js").default, import("../../Feature.js").default): number|null}
     */
    this.renderedRenderOrder_ = null;

    /**
     * @private
     * @type {import("../../render/canvas/ReplayGroup.js").default}
     */
    this.replayGroup_ = null;

    /**
     * A new replay group had to be created by `prepareFrame()`
     * @type {boolean}
     */
    this.replayGroupChanged = true;

    /**
     * @type {CanvasRenderingContext2D}
     */
    this.context = Object(_dom_js__WEBPACK_IMPORTED_MODULE_3__["createCanvasContext2D"])();

    Object(_events_js__WEBPACK_IMPORTED_MODULE_4__["listen"])(_render_canvas_js__WEBPACK_IMPORTED_MODULE_9__["labelCache"], _events_EventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].CLEAR, this.handleFontsChanged_, this);

  }

  if ( CanvasLayerRenderer ) CanvasVectorLayerRenderer.__proto__ = CanvasLayerRenderer;
  CanvasVectorLayerRenderer.prototype = Object.create( CanvasLayerRenderer && CanvasLayerRenderer.prototype );
  CanvasVectorLayerRenderer.prototype.constructor = CanvasVectorLayerRenderer;

  /**
   * @inheritDoc
   */
  CanvasVectorLayerRenderer.prototype.disposeInternal = function disposeInternal () {
    Object(_events_js__WEBPACK_IMPORTED_MODULE_4__["unlisten"])(_render_canvas_js__WEBPACK_IMPORTED_MODULE_9__["labelCache"], _events_EventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].CLEAR, this.handleFontsChanged_, this);
    CanvasLayerRenderer.prototype.disposeInternal.call(this);
  };

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../../layer/Layer.js").State} layerState Layer state.
   */
  CanvasVectorLayerRenderer.prototype.compose = function compose (context, frameState, layerState) {
    var extent = frameState.extent;
    var pixelRatio = frameState.pixelRatio;
    var skippedFeatureUids = layerState.managed ?
      frameState.skippedFeatureUids : {};
    var viewState = frameState.viewState;
    var projection = viewState.projection;
    var rotation = viewState.rotation;
    var projectionExtent = projection.getExtent();
    var vectorSource = /** @type {import("../../source/Vector.js").default} */ (this.getLayer().getSource());

    var transform = this.getTransform(frameState, 0);

    // clipped rendering if layer extent is set
    var clipExtent = layerState.extent;
    var clipped = clipExtent !== undefined;
    if (clipped) {
      this.clip(context, frameState, /** @type {import("../../extent.js").Extent} */ (clipExtent));
    }
    var replayGroup = this.replayGroup_;
    if (replayGroup && !replayGroup.isEmpty()) {
      if (this.declutterTree_) {
        this.declutterTree_.clear();
      }
      var layer = /** @type {import("../../layer/Vector.js").default} */ (this.getLayer());
      var drawOffsetX = 0;
      var drawOffsetY = 0;
      var replayContext;
      var transparentLayer = layerState.opacity !== 1;
      var hasRenderListeners = layer.hasListener(_render_EventType_js__WEBPACK_IMPORTED_MODULE_8__["default"].RENDER);
      if (transparentLayer || hasRenderListeners) {
        var drawWidth = context.canvas.width;
        var drawHeight = context.canvas.height;
        if (rotation) {
          var drawSize = Math.round(Math.sqrt(drawWidth * drawWidth + drawHeight * drawHeight));
          drawOffsetX = (drawSize - drawWidth) / 2;
          drawOffsetY = (drawSize - drawHeight) / 2;
          drawWidth = drawHeight = drawSize;
        }
        // resize and clear
        this.context.canvas.width = drawWidth;
        this.context.canvas.height = drawHeight;
        replayContext = this.context;
      } else {
        replayContext = context;
      }

      var alpha = replayContext.globalAlpha;
      if (!transparentLayer) {
        // for performance reasons, context.save / context.restore is not used
        // to save and restore the transformation matrix and the opacity.
        // see http://jsperf.com/context-save-restore-versus-variable
        replayContext.globalAlpha = layerState.opacity;
      }

      if (replayContext != context) {
        replayContext.translate(drawOffsetX, drawOffsetY);
      }

      var viewHints = frameState.viewHints;
      var snapToPixel = !(viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_2__["default"].ANIMATING] || viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_2__["default"].INTERACTING]);
      var width = frameState.size[0] * pixelRatio;
      var height = frameState.size[1] * pixelRatio;
      Object(_render_canvas_js__WEBPACK_IMPORTED_MODULE_9__["rotateAtOffset"])(replayContext, -rotation,
        width / 2, height / 2);
      replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids, snapToPixel);
      if (vectorSource.getWrapX() && projection.canWrapX() &&
          !Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["containsExtent"])(projectionExtent, extent)) {
        var startX = extent[0];
        var worldWidth = Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["getWidth"])(projectionExtent);
        var world = 0;
        var offsetX;
        while (startX < projectionExtent[0]) {
          --world;
          offsetX = worldWidth * world;
          transform = this.getTransform(frameState, offsetX);
          replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids, snapToPixel);
          startX += worldWidth;
        }
        world = 0;
        startX = extent[2];
        while (startX > projectionExtent[2]) {
          ++world;
          offsetX = worldWidth * world;
          transform = this.getTransform(frameState, offsetX);
          replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids, snapToPixel);
          startX -= worldWidth;
        }
      }
      Object(_render_canvas_js__WEBPACK_IMPORTED_MODULE_9__["rotateAtOffset"])(replayContext, rotation,
        width / 2, height / 2);

      if (hasRenderListeners) {
        this.dispatchRenderEvent(replayContext, frameState, transform);
      }
      if (replayContext != context) {
        if (transparentLayer) {
          var mainContextAlpha = context.globalAlpha;
          context.globalAlpha = layerState.opacity;
          context.drawImage(replayContext.canvas, -drawOffsetX, -drawOffsetY);
          context.globalAlpha = mainContextAlpha;
        } else {
          context.drawImage(replayContext.canvas, -drawOffsetX, -drawOffsetY);
        }
        replayContext.translate(-drawOffsetX, -drawOffsetY);
      }

      if (!transparentLayer) {
        replayContext.globalAlpha = alpha;
      }
    }

    if (clipped) {
      context.restore();
    }
  };

  /**
   * @inheritDoc
   */
  CanvasVectorLayerRenderer.prototype.composeFrame = function composeFrame (frameState, layerState, context) {
    var transform = this.getTransform(frameState, 0);
    this.preCompose(context, frameState, transform);
    this.compose(context, frameState, layerState);
    this.postCompose(context, frameState, layerState, transform);
  };

  /**
   * @inheritDoc
   */
  CanvasVectorLayerRenderer.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate (coordinate, frameState, hitTolerance, callback, thisArg) {
    if (!this.replayGroup_) {
      return undefined;
    } else {
      var resolution = frameState.viewState.resolution;
      var rotation = frameState.viewState.rotation;
      var layer = /** @type {import("../../layer/Vector.js").default} */ (this.getLayer());
      /** @type {!Object<string, boolean>} */
      var features = {};
      var result = this.replayGroup_.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, {},
        /**
         * @param {import("../../Feature.js").FeatureLike} feature Feature.
         * @return {?} Callback result.
         */
        function(feature) {
          var key = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature);
          if (!(key in features)) {
            features[key] = true;
            return callback.call(thisArg, feature, layer);
          }
        }, null);
      return result;
    }
  };

  /**
   * @param {import("../../events/Event.js").default} event Event.
   */
  CanvasVectorLayerRenderer.prototype.handleFontsChanged_ = function handleFontsChanged_ (event) {
    var layer = this.getLayer();
    if (layer.getVisible() && this.replayGroup_) {
      layer.changed();
    }
  };

  /**
   * Handle changes in image style state.
   * @param {import("../../events/Event.js").default} event Image style change event.
   * @private
   */
  CanvasVectorLayerRenderer.prototype.handleStyleImageChange_ = function handleStyleImageChange_ (event) {
    this.renderIfReadyAndVisible();
  };

  /**
   * @inheritDoc
   */
  CanvasVectorLayerRenderer.prototype.prepareFrame = function prepareFrame (frameState, layerState) {
    var vectorLayer = /** @type {import("../../layer/Vector.js").default} */ (this.getLayer());
    var vectorSource = /** @type {import("../../source/Vector.js").default} */ (vectorLayer.getSource());

    var animating = frameState.viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_2__["default"].ANIMATING];
    var interacting = frameState.viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_2__["default"].INTERACTING];
    var updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();
    var updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();

    if (!this.dirty_ && (!updateWhileAnimating && animating) ||
        (!updateWhileInteracting && interacting)) {
      return true;
    }

    var frameStateExtent = frameState.extent;
    var viewState = frameState.viewState;
    var projection = viewState.projection;
    var resolution = viewState.resolution;
    var pixelRatio = frameState.pixelRatio;
    var vectorLayerRevision = vectorLayer.getRevision();
    var vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
    var vectorLayerRenderOrder = vectorLayer.getRenderOrder();

    if (vectorLayerRenderOrder === undefined) {
      vectorLayerRenderOrder = _vector_js__WEBPACK_IMPORTED_MODULE_12__["defaultOrder"];
    }

    var extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["buffer"])(frameStateExtent,
      vectorLayerRenderBuffer * resolution);
    var projectionExtent = viewState.projection.getExtent();

    if (vectorSource.getWrapX() && viewState.projection.canWrapX() &&
        !Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["containsExtent"])(projectionExtent, frameState.extent)) {
      // For the replay group, we need an extent that intersects the real world
      // (-180° to +180°). To support geometries in a coordinate range from -540°
      // to +540°, we add at least 1 world width on each side of the projection
      // extent. If the viewport is wider than the world, we need to add half of
      // the viewport width to make sure we cover the whole viewport.
      var worldWidth = Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["getWidth"])(projectionExtent);
      var gutter = Math.max(Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["getWidth"])(extent) / 2, worldWidth);
      extent[0] = projectionExtent[0] - gutter;
      extent[2] = projectionExtent[2] + gutter;
    }

    if (!this.dirty_ &&
        this.renderedResolution_ == resolution &&
        this.renderedRevision_ == vectorLayerRevision &&
        this.renderedRenderOrder_ == vectorLayerRenderOrder &&
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["containsExtent"])(this.renderedExtent_, extent)) {
      this.replayGroupChanged = false;
      return true;
    }

    this.replayGroup_ = null;

    this.dirty_ = false;

    var replayGroup = new _render_canvas_ReplayGroup_js__WEBPACK_IMPORTED_MODULE_10__["default"](
      Object(_vector_js__WEBPACK_IMPORTED_MODULE_12__["getTolerance"])(resolution, pixelRatio), extent, resolution,
      pixelRatio, vectorSource.getOverlaps(), this.declutterTree_, vectorLayer.getRenderBuffer());
    vectorSource.loadFeatures(extent, resolution, projection);
    /**
     * @param {import("../../Feature.js").default} feature Feature.
     * @this {CanvasVectorLayerRenderer}
     */
    var render = function(feature) {
      var styles;
      var styleFunction = feature.getStyleFunction() || vectorLayer.getStyleFunction();
      if (styleFunction) {
        styles = styleFunction(feature, resolution);
      }
      if (styles) {
        var dirty = this.renderFeature(
          feature, resolution, pixelRatio, styles, replayGroup);
        this.dirty_ = this.dirty_ || dirty;
      }
    }.bind(this);
    if (vectorLayerRenderOrder) {
      /** @type {Array<import("../../Feature.js").default>} */
      var features = [];
      vectorSource.forEachFeatureInExtent(extent,
        /**
         * @param {import("../../Feature.js").default} feature Feature.
         */
        function(feature) {
          features.push(feature);
        });
      features.sort(vectorLayerRenderOrder);
      for (var i = 0, ii = features.length; i < ii; ++i) {
        render(features[i]);
      }
    } else {
      vectorSource.forEachFeatureInExtent(extent, render);
    }
    replayGroup.finish();

    this.renderedResolution_ = resolution;
    this.renderedRevision_ = vectorLayerRevision;
    this.renderedRenderOrder_ = vectorLayerRenderOrder;
    this.renderedExtent_ = extent;
    this.replayGroup_ = replayGroup;

    this.replayGroupChanged = true;
    return true;
  };

  /**
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
   * @param {import("../../render/canvas/ReplayGroup.js").default} replayGroup Replay group.
   * @return {boolean} `true` if an image is loading.
   */
  CanvasVectorLayerRenderer.prototype.renderFeature = function renderFeature$1 (feature, resolution, pixelRatio, styles, replayGroup) {
    if (!styles) {
      return false;
    }
    var loading = false;
    if (Array.isArray(styles)) {
      for (var i = 0, ii = styles.length; i < ii; ++i) {
        loading = Object(_vector_js__WEBPACK_IMPORTED_MODULE_12__["renderFeature"])(
          replayGroup, feature, styles[i],
          Object(_vector_js__WEBPACK_IMPORTED_MODULE_12__["getSquaredTolerance"])(resolution, pixelRatio),
          this.handleStyleImageChange_, this) || loading;
      }
    } else {
      loading = Object(_vector_js__WEBPACK_IMPORTED_MODULE_12__["renderFeature"])(
        replayGroup, feature, styles,
        Object(_vector_js__WEBPACK_IMPORTED_MODULE_12__["getSquaredTolerance"])(resolution, pixelRatio),
        this.handleStyleImageChange_, this);
    }
    return loading;
  };

  return CanvasVectorLayerRenderer;
}(_Layer_js__WEBPACK_IMPORTED_MODULE_11__["default"]));


/**
 * Determine if this renderer handles the provided layer.
 * @param {import("../../layer/Layer.js").default} layer The candidate layer.
 * @return {boolean} The renderer can render the layer.
 */
CanvasVectorLayerRenderer['handles'] = function(layer) {
  return layer.getType() === _LayerType_js__WEBPACK_IMPORTED_MODULE_1__["default"].VECTOR;
};


/**
 * Create a layer renderer.
 * @param {import("../Map.js").default} mapRenderer The map renderer.
 * @param {import("../../layer/Layer.js").default} layer The layer to be rendererd.
 * @return {CanvasVectorLayerRenderer} The layer renderer.
 */
CanvasVectorLayerRenderer['create'] = function(mapRenderer, layer) {
  return new CanvasVectorLayerRenderer(/** @type {import("../../layer/Vector.js").default} */ (layer));
};


/* harmony default export */ __webpack_exports__["default"] = (CanvasVectorLayerRenderer);

//# sourceMappingURL=VectorLayer.js.map

/***/ }),

/***/ "./node_modules/ol/renderer/canvas/VectorTileLayer.js":
/*!************************************************************!*\
  !*** ./node_modules/ol/renderer/canvas/VectorTileLayer.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _LayerType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../LayerType.js */ "./node_modules/ol/LayerType.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../ViewHint.js */ "./node_modules/ol/ViewHint.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! rbush */ "./node_modules/rbush/index.js");
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(rbush__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _layer_VectorTileRenderType_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../layer/VectorTileRenderType.js */ "./node_modules/ol/layer/VectorTileRenderType.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _proj_Units_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../proj/Units.js */ "./node_modules/ol/proj/Units.js");
/* harmony import */ var _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../render/ReplayType.js */ "./node_modules/ol/render/ReplayType.js");
/* harmony import */ var _render_canvas_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../render/canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _render_canvas_ReplayGroup_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../render/canvas/ReplayGroup.js */ "./node_modules/ol/render/canvas/ReplayGroup.js");
/* harmony import */ var _render_replay_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../render/replay.js */ "./node_modules/ol/render/replay.js");
/* harmony import */ var _TileLayer_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./TileLayer.js */ "./node_modules/ol/renderer/canvas/TileLayer.js");
/* harmony import */ var _vector_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../vector.js */ "./node_modules/ol/renderer/vector.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/renderer/canvas/VectorTileLayer
 */





















/**
 * @type {!Object<string, Array<import("../../render/ReplayType.js").default>>}
 */
var IMAGE_REPLAYS = {
  'image': [_render_ReplayType_js__WEBPACK_IMPORTED_MODULE_12__["default"].POLYGON, _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_12__["default"].CIRCLE,
    _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_12__["default"].LINE_STRING, _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_12__["default"].IMAGE, _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_12__["default"].TEXT],
  'hybrid': [_render_ReplayType_js__WEBPACK_IMPORTED_MODULE_12__["default"].POLYGON, _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_12__["default"].LINE_STRING]
};


/**
 * @type {!Object<string, Array<import("../../render/ReplayType.js").default>>}
 */
var VECTOR_REPLAYS = {
  'image': [_render_ReplayType_js__WEBPACK_IMPORTED_MODULE_12__["default"].DEFAULT],
  'hybrid': [_render_ReplayType_js__WEBPACK_IMPORTED_MODULE_12__["default"].IMAGE, _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_12__["default"].TEXT, _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_12__["default"].DEFAULT],
  'vector': _render_replay_js__WEBPACK_IMPORTED_MODULE_15__["ORDER"]
};


/**
 * @classdesc
 * Canvas renderer for vector tile layers.
 * @api
 */
var CanvasVectorTileLayerRenderer = /*@__PURE__*/(function (CanvasTileLayerRenderer) {
  function CanvasVectorTileLayerRenderer(layer) {

    CanvasTileLayerRenderer.call(this, layer, true);

    /**
     * Declutter tree.
     * @private
     */
    this.declutterTree_ = layer.getDeclutter() ? rbush__WEBPACK_IMPORTED_MODULE_7___default()(9, undefined) : null;

    /**
     * @private
     * @type {boolean}
     */
    this.dirty_ = false;

    /**
     * @private
     * @type {number}
     */
    this.renderedLayerRevision_;

    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */
    this.tmpTransform_ = Object(_transform_js__WEBPACK_IMPORTED_MODULE_18__["create"])();

    var renderMode = layer.getRenderMode();

    // Use lower resolution for pure vector rendering. Closest resolution otherwise.
    this.zDirection = renderMode === _layer_VectorTileRenderType_js__WEBPACK_IMPORTED_MODULE_9__["default"].VECTOR ? 1 : 0;

    if (renderMode !== _layer_VectorTileRenderType_js__WEBPACK_IMPORTED_MODULE_9__["default"].VECTOR) {
      this.context = Object(_dom_js__WEBPACK_IMPORTED_MODULE_4__["createCanvasContext2D"])();
    }


    Object(_events_js__WEBPACK_IMPORTED_MODULE_5__["listen"])(_render_canvas_js__WEBPACK_IMPORTED_MODULE_13__["labelCache"], _events_EventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].CLEAR, this.handleFontsChanged_, this);

  }

  if ( CanvasTileLayerRenderer ) CanvasVectorTileLayerRenderer.__proto__ = CanvasTileLayerRenderer;
  CanvasVectorTileLayerRenderer.prototype = Object.create( CanvasTileLayerRenderer && CanvasTileLayerRenderer.prototype );
  CanvasVectorTileLayerRenderer.prototype.constructor = CanvasVectorTileLayerRenderer;

  /**
   * @inheritDoc
   */
  CanvasVectorTileLayerRenderer.prototype.disposeInternal = function disposeInternal () {
    Object(_events_js__WEBPACK_IMPORTED_MODULE_5__["unlisten"])(_render_canvas_js__WEBPACK_IMPORTED_MODULE_13__["labelCache"], _events_EventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].CLEAR, this.handleFontsChanged_, this);
    CanvasTileLayerRenderer.prototype.disposeInternal.call(this);
  };

  /**
   * @inheritDoc
   */
  CanvasVectorTileLayerRenderer.prototype.getTile = function getTile (z, x, y, pixelRatio, projection) {
    var tile = CanvasTileLayerRenderer.prototype.getTile.call(this, z, x, y, pixelRatio, projection);
    if (tile.getState() === _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED) {
      this.createReplayGroup_(/** @type {import("../../VectorImageTile.js").default} */ (tile), pixelRatio, projection);
      if (this.context) {
        this.renderTileImage_(/** @type {import("../../VectorImageTile.js").default} */ (tile), pixelRatio, projection);
      }
    }
    return tile;
  };

  /**
   * @inheritDoc
   */
  CanvasVectorTileLayerRenderer.prototype.getTileImage = function getTileImage (tile) {
    var tileLayer = /** @type {import("../../layer/Tile.js").default} */ (this.getLayer());
    return /** @type {import("../../VectorImageTile.js").default} */ (tile).getImage(tileLayer);
  };

  /**
   * @inheritDoc
   */
  CanvasVectorTileLayerRenderer.prototype.prepareFrame = function prepareFrame (frameState, layerState) {
    var layer = /** @type {import("../../layer/Vector.js").default} */ (this.getLayer());
    var layerRevision = layer.getRevision();
    if (this.renderedLayerRevision_ != layerRevision) {
      this.renderedTiles.length = 0;
    }
    this.renderedLayerRevision_ = layerRevision;
    return CanvasTileLayerRenderer.prototype.prepareFrame.call(this, frameState, layerState);
  };

  /**
   * @param {import("../../VectorImageTile.js").default} tile Tile.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection.js").default} projection Projection.
   * @private
   */
  CanvasVectorTileLayerRenderer.prototype.createReplayGroup_ = function createReplayGroup_ (tile, pixelRatio, projection) {
    var this$1 = this;

    var layer = /** @type {import("../../layer/Vector.js").default} */ (this.getLayer());
    var revision = layer.getRevision();
    var renderOrder = /** @type {import("../../render.js").OrderFunction} */ (layer.getRenderOrder()) || null;

    var replayState = tile.getReplayState(layer);
    if (!replayState.dirty && replayState.renderedRevision == revision &&
        replayState.renderedRenderOrder == renderOrder) {
      return;
    }

    var source = /** @type {import("../../source/VectorTile.js").default} */ (layer.getSource());
    var sourceTileGrid = source.getTileGrid();
    var tileGrid = source.getTileGridForProjection(projection);
    var resolution = tileGrid.getResolution(tile.tileCoord[0]);
    var tileExtent = tile.extent;

    var loop = function ( t, tt ) {
      var sourceTile = tile.getTile(tile.tileKeys[t]);
      if (sourceTile.getState() != _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED) {
        return;
      }

      var sourceTileCoord = sourceTile.tileCoord;
      var sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);
      var sharedExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_8__["getIntersection"])(tileExtent, sourceTileExtent);
      var bufferedExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_8__["equals"])(sourceTileExtent, sharedExtent) ? null :
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_8__["buffer"])(sharedExtent, layer.getRenderBuffer() * resolution, this$1.tmpExtent);
      var tileProjection = sourceTile.getProjection();
      var reproject = false;
      if (!Object(_proj_js__WEBPACK_IMPORTED_MODULE_10__["equivalent"])(projection, tileProjection)) {
        reproject = true;
        sourceTile.setProjection(projection);
      }
      replayState.dirty = false;
      var replayGroup = new _render_canvas_ReplayGroup_js__WEBPACK_IMPORTED_MODULE_14__["default"](0, sharedExtent, resolution,
        pixelRatio, source.getOverlaps(), this$1.declutterTree_, layer.getRenderBuffer());
      var squaredTolerance = Object(_vector_js__WEBPACK_IMPORTED_MODULE_17__["getSquaredTolerance"])(resolution, pixelRatio);

      /**
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       * @this {CanvasVectorTileLayerRenderer}
       */
      var render = function(feature) {
        var styles;
        var styleFunction = feature.getStyleFunction() || layer.getStyleFunction();
        if (styleFunction) {
          styles = styleFunction(feature, resolution);
        }
        if (styles) {
          var dirty = this.renderFeature(feature, squaredTolerance, styles, replayGroup);
          this.dirty_ = this.dirty_ || dirty;
          replayState.dirty = replayState.dirty || dirty;
        }
      };

      var features = sourceTile.getFeatures();
      if (renderOrder && renderOrder !== replayState.renderedRenderOrder) {
        features.sort(renderOrder);
      }
      for (var i = 0, ii = features.length; i < ii; ++i) {
        var feature = features[i];
        if (reproject) {
          if (tileProjection.getUnits() == _proj_Units_js__WEBPACK_IMPORTED_MODULE_11__["default"].TILE_PIXELS) {
            // projected tile extent
            tileProjection.setWorldExtent(sourceTileExtent);
            // tile extent in tile pixel space
            tileProjection.setExtent(sourceTile.getExtent());
          }
          feature.getGeometry().transform(tileProjection, projection);
        }
        if (!bufferedExtent || Object(_extent_js__WEBPACK_IMPORTED_MODULE_8__["intersects"])(bufferedExtent, feature.getGeometry().getExtent())) {
          render.call(this$1, feature);
        }
      }
      replayGroup.finish();
      sourceTile.setReplayGroup(layer, tile.tileCoord.toString(), replayGroup);
    };

    for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) loop( t, tt );
    replayState.renderedRevision = revision;
    replayState.renderedRenderOrder = renderOrder;
  };

  /**
   * @inheritDoc
   */
  CanvasVectorTileLayerRenderer.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate (coordinate, frameState, hitTolerance, callback, thisArg) {
    var resolution = frameState.viewState.resolution;
    var rotation = frameState.viewState.rotation;
    hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;
    var layer = this.getLayer();
    /** @type {!Object<string, boolean>} */
    var features = {};

    var renderedTiles = /** @type {Array<import("../../VectorImageTile.js").default>} */ (this.renderedTiles);

    var bufferedExtent, found;
    var i, ii;
    for (i = 0, ii = renderedTiles.length; i < ii; ++i) {
      var tile = renderedTiles[i];
      bufferedExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_8__["buffer"])(tile.extent, hitTolerance * resolution, bufferedExtent);
      if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_8__["containsCoordinate"])(bufferedExtent, coordinate)) {
        continue;
      }
      for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) {
        var sourceTile = tile.getTile(tile.tileKeys[t]);
        if (sourceTile.getState() != _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED) {
          continue;
        }
        var replayGroup = /** @type {CanvasReplayGroup} */ (sourceTile.getReplayGroup(layer,
          tile.tileCoord.toString()));
        found = found || replayGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, {},
          /**
           * @param {import("../../Feature.js").FeatureLike} feature Feature.
           * @return {?} Callback result.
           */
          function(feature) {
            var key = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature);
            if (!(key in features)) {
              features[key] = true;
              return callback.call(thisArg, feature, layer);
            }
          }, null);
      }
    }
    return found;
  };

  /**
   * @param {import("../../VectorTile.js").default} tile Tile.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @return {import("../../transform.js").Transform} transform Transform.
   * @private
   */
  CanvasVectorTileLayerRenderer.prototype.getReplayTransform_ = function getReplayTransform_ (tile, frameState) {
    var layer = this.getLayer();
    var source = /** @type {import("../../source/VectorTile.js").default} */ (layer.getSource());
    var tileGrid = source.getTileGrid();
    var tileCoord = tile.tileCoord;
    var tileResolution = tileGrid.getResolution(tileCoord[0]);
    var viewState = frameState.viewState;
    var pixelRatio = frameState.pixelRatio;
    var renderResolution = viewState.resolution / pixelRatio;
    var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);
    var center = viewState.center;
    var origin = Object(_extent_js__WEBPACK_IMPORTED_MODULE_8__["getTopLeft"])(tileExtent);
    var size = frameState.size;
    var offsetX = Math.round(pixelRatio * size[0] / 2);
    var offsetY = Math.round(pixelRatio * size[1] / 2);
    return Object(_transform_js__WEBPACK_IMPORTED_MODULE_18__["compose"])(this.tmpTransform_,
      offsetX, offsetY,
      tileResolution / renderResolution, tileResolution / renderResolution,
      viewState.rotation,
      (origin[0] - center[0]) / tileResolution,
      (center[1] - origin[1]) / tileResolution);
  };

  /**
   * @param {import("../../events/Event.js").default} event Event.
   */
  CanvasVectorTileLayerRenderer.prototype.handleFontsChanged_ = function handleFontsChanged_ (event) {
    var layer = this.getLayer();
    if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {
      layer.changed();
    }
  };

  /**
   * Handle changes in image style state.
   * @param {import("../../events/Event.js").default} event Image style change event.
   * @private
   */
  CanvasVectorTileLayerRenderer.prototype.handleStyleImageChange_ = function handleStyleImageChange_ (event) {
    this.renderIfReadyAndVisible();
  };

  /**
   * @inheritDoc
   */
  CanvasVectorTileLayerRenderer.prototype.postCompose = function postCompose (context, frameState, layerState) {
    var layer = /** @type {import("../../layer/Vector.js").default} */ (this.getLayer());
    var renderMode = layer.getRenderMode();
    if (renderMode != _layer_VectorTileRenderType_js__WEBPACK_IMPORTED_MODULE_9__["default"].IMAGE) {
      var declutterReplays = layer.getDeclutter() ? {} : null;
      var source = /** @type {import("../../source/VectorTile.js").default} */ (layer.getSource());
      var replayTypes = VECTOR_REPLAYS[renderMode];
      var pixelRatio = frameState.pixelRatio;
      var rotation = frameState.viewState.rotation;
      var size = frameState.size;
      var offsetX, offsetY;
      if (rotation) {
        offsetX = Math.round(pixelRatio * size[0] / 2);
        offsetY = Math.round(pixelRatio * size[1] / 2);
        Object(_render_canvas_js__WEBPACK_IMPORTED_MODULE_13__["rotateAtOffset"])(context, -rotation, offsetX, offsetY);
      }
      if (declutterReplays) {
        this.declutterTree_.clear();
      }
      var viewHints = frameState.viewHints;
      var snapToPixel = !(viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_3__["default"].ANIMATING] || viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_3__["default"].INTERACTING]);
      var tiles = this.renderedTiles;
      var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);
      var clips = [];
      var zs = [];
      for (var i = tiles.length - 1; i >= 0; --i) {
        var tile = /** @type {import("../../VectorImageTile.js").default} */ (tiles[i]);
        if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ABORT) {
          continue;
        }
        var tileCoord = tile.tileCoord;
        var worldOffset = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent)[0] - tile.extent[0];
        var transform = undefined;
        for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) {
          var sourceTile = tile.getTile(tile.tileKeys[t]);
          if (sourceTile.getState() != _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED) {
            continue;
          }
          var replayGroup = /** @type {CanvasReplayGroup} */ (sourceTile.getReplayGroup(layer, tileCoord.toString()));
          if (!replayGroup || !replayGroup.hasReplays(replayTypes)) {
            // sourceTile was not yet loaded when this.createReplayGroup_() was
            // called, or it has no replays of the types we want to render
            continue;
          }
          if (!transform) {
            transform = this.getTransform(frameState, worldOffset);
          }
          var currentZ = sourceTile.tileCoord[0];
          var currentClip = replayGroup.getClipCoords(transform);
          context.save();
          context.globalAlpha = layerState.opacity;
          // Create a clip mask for regions in this low resolution tile that are
          // already filled by a higher resolution tile
          for (var j = 0, jj = clips.length; j < jj; ++j) {
            var clip = clips[j];
            if (currentZ < zs[j]) {
              context.beginPath();
              // counter-clockwise (outer ring) for current tile
              context.moveTo(currentClip[0], currentClip[1]);
              context.lineTo(currentClip[2], currentClip[3]);
              context.lineTo(currentClip[4], currentClip[5]);
              context.lineTo(currentClip[6], currentClip[7]);
              // clockwise (inner ring) for higher resolution tile
              context.moveTo(clip[6], clip[7]);
              context.lineTo(clip[4], clip[5]);
              context.lineTo(clip[2], clip[3]);
              context.lineTo(clip[0], clip[1]);
              context.clip();
            }
          }
          replayGroup.replay(context, transform, rotation, {}, snapToPixel, replayTypes, declutterReplays);
          context.restore();
          clips.push(currentClip);
          zs.push(currentZ);
        }
      }
      if (declutterReplays) {
        Object(_render_canvas_ReplayGroup_js__WEBPACK_IMPORTED_MODULE_14__["replayDeclutter"])(declutterReplays, context, rotation, snapToPixel);
      }
      if (rotation) {
        Object(_render_canvas_js__WEBPACK_IMPORTED_MODULE_13__["rotateAtOffset"])(context, rotation,
          /** @type {number} */ (offsetX), /** @type {number} */ (offsetY));
      }
    }
    CanvasTileLayerRenderer.prototype.postCompose.call(this, context, frameState, layerState);
  };

  /**
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
   * @param {import("../../render/canvas/ReplayGroup.js").default} replayGroup Replay group.
   * @return {boolean} `true` if an image is loading.
   */
  CanvasVectorTileLayerRenderer.prototype.renderFeature = function renderFeature$1 (feature, squaredTolerance, styles, replayGroup) {
    if (!styles) {
      return false;
    }
    var loading = false;
    if (Array.isArray(styles)) {
      for (var i = 0, ii = styles.length; i < ii; ++i) {
        loading = Object(_vector_js__WEBPACK_IMPORTED_MODULE_17__["renderFeature"])(
          replayGroup, feature, styles[i], squaredTolerance,
          this.handleStyleImageChange_, this) || loading;
      }
    } else {
      loading = Object(_vector_js__WEBPACK_IMPORTED_MODULE_17__["renderFeature"])(
        replayGroup, feature, styles, squaredTolerance,
        this.handleStyleImageChange_, this);
    }
    return loading;
  };

  /**
   * @param {import("../../VectorImageTile.js").default} tile Tile.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection.js").default} projection Projection.
   * @private
   */
  CanvasVectorTileLayerRenderer.prototype.renderTileImage_ = function renderTileImage_ (tile, pixelRatio, projection) {
    var layer = /** @type {import("../../layer/Vector.js").default} */ (this.getLayer());
    var replayState = tile.getReplayState(layer);
    var revision = layer.getRevision();
    var replays = IMAGE_REPLAYS[layer.getRenderMode()];
    if (replays && replayState.renderedTileRevision !== revision) {
      replayState.renderedTileRevision = revision;
      var tileCoord = tile.wrappedTileCoord;
      var z = tileCoord[0];
      var source = /** @type {import("../../source/VectorTile.js").default} */ (layer.getSource());
      var tileGrid = source.getTileGridForProjection(projection);
      var resolution = tileGrid.getResolution(z);
      var context = tile.getContext(layer);
      var size = source.getTilePixelSize(z, pixelRatio, projection);
      context.canvas.width = size[0];
      context.canvas.height = size[1];
      var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);
      for (var i = 0, ii = tile.tileKeys.length; i < ii; ++i) {
        var sourceTile = tile.getTile(tile.tileKeys[i]);
        if (sourceTile.getState() != _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED) {
          continue;
        }
        var pixelScale = pixelRatio / resolution;
        var transform = Object(_transform_js__WEBPACK_IMPORTED_MODULE_18__["reset"])(this.tmpTransform_);
        Object(_transform_js__WEBPACK_IMPORTED_MODULE_18__["scale"])(transform, pixelScale, -pixelScale);
        Object(_transform_js__WEBPACK_IMPORTED_MODULE_18__["translate"])(transform, -tileExtent[0], -tileExtent[3]);
        var replayGroup = /** @type {CanvasReplayGroup} */ (sourceTile.getReplayGroup(layer,
          tile.tileCoord.toString()));
        replayGroup.replay(context, transform, 0, {}, true, replays);
      }
    }
  };

  return CanvasVectorTileLayerRenderer;
}(_TileLayer_js__WEBPACK_IMPORTED_MODULE_16__["default"]));


/**
 * Determine if this renderer handles the provided layer.
 * @param {import("../../layer/Layer.js").default} layer The candidate layer.
 * @return {boolean} The renderer can render the layer.
 */
CanvasVectorTileLayerRenderer['handles'] = function(layer) {
  return layer.getType() === _LayerType_js__WEBPACK_IMPORTED_MODULE_1__["default"].VECTOR_TILE;
};


/**
 * Create a layer renderer.
 * @param {import("../Map.js").default} mapRenderer The map renderer.
 * @param {import("../../layer/Layer.js").default} layer The layer to be rendererd.
 * @return {CanvasVectorTileLayerRenderer} The layer renderer.
 */
CanvasVectorTileLayerRenderer['create'] = function(mapRenderer, layer) {
  return new CanvasVectorTileLayerRenderer(/** @type {import("../../layer/VectorTile.js").default} */ (layer));
};


/* harmony default export */ __webpack_exports__["default"] = (CanvasVectorTileLayerRenderer);

//# sourceMappingURL=VectorTileLayer.js.map

/***/ }),

/***/ "./node_modules/ol/renderer/vector.js":
/*!********************************************!*\
  !*** ./node_modules/ol/renderer/vector.js ***!
  \********************************************/
/*! exports provided: defaultOrder, getSquaredTolerance, getTolerance, renderFeature */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultOrder", function() { return defaultOrder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSquaredTolerance", function() { return getSquaredTolerance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTolerance", function() { return getTolerance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderFeature", function() { return renderFeature; });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ImageState.js */ "./node_modules/ol/ImageState.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../render/ReplayType.js */ "./node_modules/ol/render/ReplayType.js");
/**
 * @module ol/renderer/vector
 */






/**
 * Tolerance for geometry simplification in device pixels.
 * @type {number}
 */
var SIMPLIFY_TOLERANCE = 0.5;


/**
 * @const
 * @type {Object<import("../geom/GeometryType.js").default,
 *                function(import("../render/ReplayGroup.js").default, import("../geom/Geometry.js").default,
 *                         import("../style/Style.js").default, Object)>}
 */
var GEOMETRY_RENDERERS = {
  'Point': renderPointGeometry,
  'LineString': renderLineStringGeometry,
  'Polygon': renderPolygonGeometry,
  'MultiPoint': renderMultiPointGeometry,
  'MultiLineString': renderMultiLineStringGeometry,
  'MultiPolygon': renderMultiPolygonGeometry,
  'GeometryCollection': renderGeometryCollectionGeometry,
  'Circle': renderCircleGeometry
};


/**
 * @param {import("../Feature.js").FeatureLike} feature1 Feature 1.
 * @param {import("../Feature.js").FeatureLike} feature2 Feature 2.
 * @return {number} Order.
 */
function defaultOrder(feature1, feature2) {
  return parseInt(Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature1), 10) - parseInt(Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature2), 10);
}


/**
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Squared pixel tolerance.
 */
function getSquaredTolerance(resolution, pixelRatio) {
  var tolerance = getTolerance(resolution, pixelRatio);
  return tolerance * tolerance;
}


/**
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Pixel tolerance.
 */
function getTolerance(resolution, pixelRatio) {
  return SIMPLIFY_TOLERANCE * resolution / pixelRatio;
}


/**
 * @param {import("../render/ReplayGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/Circle.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 */
function renderCircleGeometry(replayGroup, geometry, style, feature) {
  var fillStyle = style.getFill();
  var strokeStyle = style.getStroke();
  if (fillStyle || strokeStyle) {
    var circleReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].CIRCLE);
    circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    circleReplay.drawCircle(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));
    textReplay.drawText(geometry, feature);
  }
}


/**
 * @param {import("../render/ReplayGroup.js").default} replayGroup Replay group.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../style/Style.js").default} style Style.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {function(this: T, import("../events/Event.js").default)} listener Listener function.
 * @param {T} thisArg Value to use as `this` when executing `listener`.
 * @return {boolean} `true` if style is loading.
 * @template T
 */
function renderFeature(replayGroup, feature, style, squaredTolerance, listener, thisArg) {
  var loading = false;
  var imageStyle = style.getImage();
  if (imageStyle) {
    var imageState = imageStyle.getImageState();
    if (imageState == _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED || imageState == _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR) {
      imageStyle.unlistenImageChange(listener, thisArg);
    } else {
      if (imageState == _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE) {
        imageStyle.load();
      }
      imageState = imageStyle.getImageState();
      imageStyle.listenImageChange(listener, thisArg);
      loading = true;
    }
  }
  renderFeatureInternal(replayGroup, feature, style, squaredTolerance);

  return loading;
}


/**
 * @param {import("../render/ReplayGroup.js").default} replayGroup Replay group.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../style/Style.js").default} style Style.
 * @param {number} squaredTolerance Squared tolerance.
 */
function renderFeatureInternal(replayGroup, feature, style, squaredTolerance) {
  var geometry = style.getGeometryFunction()(feature);
  if (!geometry) {
    return;
  }
  var simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);
  var renderer = style.getRenderer();
  if (renderer) {
    renderGeometry(replayGroup, simplifiedGeometry, style, feature);
  } else {
    var geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];
    geometryRenderer(replayGroup, simplifiedGeometry, style, feature);
  }
}


/**
 * @param {import("../render/ReplayGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/Geometry.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 */
function renderGeometry(replayGroup, geometry, style, feature) {
  if (geometry.getType() == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__["default"].GEOMETRY_COLLECTION) {
    var geometries = /** @type {import("../geom/GeometryCollection.js").default} */ (geometry).getGeometries();
    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      renderGeometry(replayGroup, geometries[i], style, feature);
    }
    return;
  }
  var replay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].DEFAULT);
  replay.drawCustom(/** @type {import("../geom/SimpleGeometry.js").default} */ (geometry), feature, style.getRenderer());
}


/**
 * @param {import("../render/ReplayGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 */
function renderGeometryCollectionGeometry(replayGroup, geometry, style, feature) {
  var geometries = geometry.getGeometriesArray();
  var i, ii;
  for (i = 0, ii = geometries.length; i < ii; ++i) {
    var geometryRenderer =
        GEOMETRY_RENDERERS[geometries[i].getType()];
    geometryRenderer(replayGroup, geometries[i], style, feature);
  }
}


/**
 * @param {import("../render/ReplayGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/LineString.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 */
function renderLineStringGeometry(replayGroup, geometry, style, feature) {
  var strokeStyle = style.getStroke();
  if (strokeStyle) {
    var lineStringReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].LINE_STRING);
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawLineString(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));
    textReplay.drawText(geometry, feature);
  }
}


/**
 * @param {import("../render/ReplayGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/MultiLineString.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 */
function renderMultiLineStringGeometry(replayGroup, geometry, style, feature) {
  var strokeStyle = style.getStroke();
  if (strokeStyle) {
    var lineStringReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].LINE_STRING);
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawMultiLineString(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));
    textReplay.drawText(geometry, feature);
  }
}


/**
 * @param {import("../render/ReplayGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 */
function renderMultiPolygonGeometry(replayGroup, geometry, style, feature) {
  var fillStyle = style.getFill();
  var strokeStyle = style.getStroke();
  if (strokeStyle || fillStyle) {
    var polygonReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POLYGON);
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawMultiPolygon(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));
    textReplay.drawText(geometry, feature);
  }
}


/**
 * @param {import("../render/ReplayGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/Point.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 */
function renderPointGeometry(replayGroup, geometry, style, feature) {
  var imageStyle = style.getImage();
  if (imageStyle) {
    if (imageStyle.getImageState() != _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED) {
      return;
    }
    var imageReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].IMAGE);
    imageReplay.setImageStyle(imageStyle, replayGroup.addDeclutter(false));
    imageReplay.drawPoint(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(!!imageStyle));
    textReplay.drawText(geometry, feature);
  }
}


/**
 * @param {import("../render/ReplayGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/MultiPoint.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 */
function renderMultiPointGeometry(replayGroup, geometry, style, feature) {
  var imageStyle = style.getImage();
  if (imageStyle) {
    if (imageStyle.getImageState() != _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED) {
      return;
    }
    var imageReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].IMAGE);
    imageReplay.setImageStyle(imageStyle, replayGroup.addDeclutter(false));
    imageReplay.drawMultiPoint(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(!!imageStyle));
    textReplay.drawText(geometry, feature);
  }
}


/**
 * @param {import("../render/ReplayGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/Polygon.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 */
function renderPolygonGeometry(replayGroup, geometry, style, feature) {
  var fillStyle = style.getFill();
  var strokeStyle = style.getStroke();
  if (fillStyle || strokeStyle) {
    var polygonReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POLYGON);
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawPolygon(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));
    textReplay.drawText(geometry, feature);
  }
}

//# sourceMappingURL=vector.js.map

/***/ }),

/***/ "./node_modules/ol/reproj.js":
/*!***********************************!*\
  !*** ./node_modules/ol/reproj.js ***!
  \***********************************/
/*! exports provided: calculateSourceResolution, render */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calculateSourceResolution", function() { return calculateSourceResolution; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./proj.js */ "./node_modules/ol/proj.js");
/**
 * @module ol/reproj
 */






/**
 * Calculates ideal resolution to use from the source in order to achieve
 * pixel mapping as close as possible to 1:1 during reprojection.
 * The resolution is calculated regardless of what resolutions
 * are actually available in the dataset (TileGrid, Image, ...).
 *
 * @param {import("./proj/Projection.js").default} sourceProj Source projection.
 * @param {import("./proj/Projection.js").default} targetProj Target projection.
 * @param {import("./coordinate.js").Coordinate} targetCenter Target center.
 * @param {number} targetResolution Target resolution.
 * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
 */
function calculateSourceResolution(sourceProj, targetProj,
  targetCenter, targetResolution) {

  var sourceCenter = Object(_proj_js__WEBPACK_IMPORTED_MODULE_3__["transform"])(targetCenter, targetProj, sourceProj);

  // calculate the ideal resolution of the source data
  var sourceResolution = Object(_proj_js__WEBPACK_IMPORTED_MODULE_3__["getPointResolution"])(targetProj, targetResolution, targetCenter);

  var targetMetersPerUnit = targetProj.getMetersPerUnit();
  if (targetMetersPerUnit !== undefined) {
    sourceResolution *= targetMetersPerUnit;
  }
  var sourceMetersPerUnit = sourceProj.getMetersPerUnit();
  if (sourceMetersPerUnit !== undefined) {
    sourceResolution /= sourceMetersPerUnit;
  }

  // Based on the projection properties, the point resolution at the specified
  // coordinates may be slightly different. We need to reverse-compensate this
  // in order to achieve optimal results.

  var sourceExtent = sourceProj.getExtent();
  if (!sourceExtent || Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["containsCoordinate"])(sourceExtent, sourceCenter)) {
    var compensationFactor = Object(_proj_js__WEBPACK_IMPORTED_MODULE_3__["getPointResolution"])(sourceProj, sourceResolution, sourceCenter) /
        sourceResolution;
    if (isFinite(compensationFactor) && compensationFactor > 0) {
      sourceResolution /= compensationFactor;
    }
  }

  return sourceResolution;
}


/**
 * Enlarge the clipping triangle point by 1 pixel to ensure the edges overlap
 * in order to mask gaps caused by antialiasing.
 *
 * @param {number} centroidX Centroid of the triangle (x coordinate in pixels).
 * @param {number} centroidY Centroid of the triangle (y coordinate in pixels).
 * @param {number} x X coordinate of the point (in pixels).
 * @param {number} y Y coordinate of the point (in pixels).
 * @return {import("./coordinate.js").Coordinate} New point 1 px farther from the centroid.
 */
function enlargeClipPoint(centroidX, centroidY, x, y) {
  var dX = x - centroidX;
  var dY = y - centroidY;
  var distance = Math.sqrt(dX * dX + dY * dY);
  return [Math.round(x + dX / distance), Math.round(y + dY / distance)];
}


/**
 * Renders the source data into new canvas based on the triangulation.
 *
 * @param {number} width Width of the canvas.
 * @param {number} height Height of the canvas.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} sourceResolution Source resolution.
 * @param {import("./extent.js").Extent} sourceExtent Extent of the data source.
 * @param {number} targetResolution Target resolution.
 * @param {import("./extent.js").Extent} targetExtent Target extent.
 * @param {import("./reproj/Triangulation.js").default} triangulation
 * Calculated triangulation.
 * @param {Array<{extent: import("./extent.js").Extent,
 *                 image: (HTMLCanvasElement|HTMLImageElement|HTMLVideoElement)}>} sources
 * Array of sources.
 * @param {number} gutter Gutter of the sources.
 * @param {boolean=} opt_renderEdges Render reprojection edges.
 * @return {HTMLCanvasElement} Canvas with reprojected data.
 */
function render(width, height, pixelRatio,
  sourceResolution, sourceExtent, targetResolution, targetExtent,
  triangulation, sources, gutter, opt_renderEdges) {

  var context = Object(_dom_js__WEBPACK_IMPORTED_MODULE_0__["createCanvasContext2D"])(Math.round(pixelRatio * width),
    Math.round(pixelRatio * height));

  if (sources.length === 0) {
    return context.canvas;
  }

  context.scale(pixelRatio, pixelRatio);

  var sourceDataExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["createEmpty"])();
  sources.forEach(function(src, i, arr) {
    Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["extend"])(sourceDataExtent, src.extent);
  });

  var canvasWidthInUnits = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getWidth"])(sourceDataExtent);
  var canvasHeightInUnits = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getHeight"])(sourceDataExtent);
  var stitchContext = Object(_dom_js__WEBPACK_IMPORTED_MODULE_0__["createCanvasContext2D"])(
    Math.round(pixelRatio * canvasWidthInUnits / sourceResolution),
    Math.round(pixelRatio * canvasHeightInUnits / sourceResolution));

  var stitchScale = pixelRatio / sourceResolution;

  sources.forEach(function(src, i, arr) {
    var xPos = src.extent[0] - sourceDataExtent[0];
    var yPos = -(src.extent[3] - sourceDataExtent[3]);
    var srcWidth = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getWidth"])(src.extent);
    var srcHeight = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getHeight"])(src.extent);

    stitchContext.drawImage(
      src.image,
      gutter, gutter,
      src.image.width - 2 * gutter, src.image.height - 2 * gutter,
      xPos * stitchScale, yPos * stitchScale,
      srcWidth * stitchScale, srcHeight * stitchScale);
  });

  var targetTopLeft = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getTopLeft"])(targetExtent);

  triangulation.getTriangles().forEach(function(triangle, i, arr) {
    /* Calculate affine transform (src -> dst)
     * Resulting matrix can be used to transform coordinate
     * from `sourceProjection` to destination pixels.
     *
     * To optimize number of context calls and increase numerical stability,
     * we also do the following operations:
     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)
     * here before solving the linear system so [ui, vi] are pixel coordinates.
     *
     * Src points: xi, yi
     * Dst points: ui, vi
     * Affine coefficients: aij
     *
     * | x0 y0 1  0  0 0 |   |a00|   |u0|
     * | x1 y1 1  0  0 0 |   |a01|   |u1|
     * | x2 y2 1  0  0 0 | x |a02| = |u2|
     * |  0  0 0 x0 y0 1 |   |a10|   |v0|
     * |  0  0 0 x1 y1 1 |   |a11|   |v1|
     * |  0  0 0 x2 y2 1 |   |a12|   |v2|
     */
    var source = triangle.source;
    var target = triangle.target;
    var x0 = source[0][0], y0 = source[0][1];
    var x1 = source[1][0], y1 = source[1][1];
    var x2 = source[2][0], y2 = source[2][1];
    var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
    var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
    var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
    var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
    var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
    var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;

    // Shift all the source points to improve numerical stability
    // of all the subsequent calculations. The [x0, y0] is used here.
    // This is also used to simplify the linear system.
    var sourceNumericalShiftX = x0;
    var sourceNumericalShiftY = y0;
    x0 = 0;
    y0 = 0;
    x1 -= sourceNumericalShiftX;
    y1 -= sourceNumericalShiftY;
    x2 -= sourceNumericalShiftX;
    y2 -= sourceNumericalShiftY;

    var augmentedMatrix = [
      [x1, y1, 0, 0, u1 - u0],
      [x2, y2, 0, 0, u2 - u0],
      [0, 0, x1, y1, v1 - v0],
      [0, 0, x2, y2, v2 - v0]
    ];
    var affineCoefs = Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["solveLinearSystem"])(augmentedMatrix);
    if (!affineCoefs) {
      return;
    }

    context.save();
    context.beginPath();
    var centroidX = (u0 + u1 + u2) / 3;
    var centroidY = (v0 + v1 + v2) / 3;
    var p0 = enlargeClipPoint(centroidX, centroidY, u0, v0);
    var p1 = enlargeClipPoint(centroidX, centroidY, u1, v1);
    var p2 = enlargeClipPoint(centroidX, centroidY, u2, v2);

    context.moveTo(p1[0], p1[1]);
    context.lineTo(p0[0], p0[1]);
    context.lineTo(p2[0], p2[1]);
    context.clip();

    context.transform(
      affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);

    context.translate(sourceDataExtent[0] - sourceNumericalShiftX,
      sourceDataExtent[3] - sourceNumericalShiftY);

    context.scale(sourceResolution / pixelRatio,
      -sourceResolution / pixelRatio);

    context.drawImage(stitchContext.canvas, 0, 0);
    context.restore();
  });

  if (opt_renderEdges) {
    context.save();

    context.strokeStyle = 'black';
    context.lineWidth = 1;

    triangulation.getTriangles().forEach(function(triangle, i, arr) {
      var target = triangle.target;
      var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
      var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
      var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
      var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
      var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
      var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;

      context.beginPath();
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
      context.closePath();
      context.stroke();
    });

    context.restore();
  }
  return context.canvas;
}

//# sourceMappingURL=reproj.js.map

/***/ }),

/***/ "./node_modules/ol/reproj/Tile.js":
/*!****************************************!*\
  !*** ./node_modules/ol/reproj/Tile.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/ol/reproj/common.js");
/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Tile.js */ "./node_modules/ol/Tile.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _reproj_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../reproj.js */ "./node_modules/ol/reproj.js");
/* harmony import */ var _Triangulation_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Triangulation.js */ "./node_modules/ol/reproj/Triangulation.js");
/**
 * @module ol/reproj/Tile
 */












/**
 * @typedef {function(number, number, number, number) : import("../Tile.js").default} FunctionType
 */


/**
 * @classdesc
 * Class encapsulating single reprojected tile.
 * See {@link module:ol/source/TileImage~TileImage}.
 *
 */
var ReprojTile = /*@__PURE__*/(function (Tile) {
  function ReprojTile(
    sourceProj,
    sourceTileGrid,
    targetProj,
    targetTileGrid,
    tileCoord,
    wrappedTileCoord,
    pixelRatio,
    gutter,
    getTileFunction,
    opt_errorThreshold,
    opt_renderEdges
  ) {
    Tile.call(this, tileCoord, _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE);

    /**
     * @private
     * @type {boolean}
     */
    this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;

    /**
     * @private
     * @type {number}
     */
    this.pixelRatio_ = pixelRatio;

    /**
     * @private
     * @type {number}
     */
    this.gutter_ = gutter;

    /**
     * @private
     * @type {HTMLCanvasElement}
     */
    this.canvas_ = null;

    /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */
    this.sourceTileGrid_ = sourceTileGrid;

    /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */
    this.targetTileGrid_ = targetTileGrid;

    /**
     * @private
     * @type {import("../tilecoord.js").TileCoord}
     */
    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;

    /**
     * @private
     * @type {!Array<import("../Tile.js").default>}
     */
    this.sourceTiles_ = [];

    /**
     * @private
     * @type {Array<import("../events.js").EventsKey>}
     */
    this.sourcesListenerKeys_ = null;

    /**
     * @private
     * @type {number}
     */
    this.sourceZ_ = 0;

    var targetExtent = targetTileGrid.getTileCoordExtent(this.wrappedTileCoord_);
    var maxTargetExtent = this.targetTileGrid_.getExtent();
    var maxSourceExtent = this.sourceTileGrid_.getExtent();

    var limitedTargetExtent = maxTargetExtent ?
      Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getIntersection"])(targetExtent, maxTargetExtent) : targetExtent;

    if (Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getArea"])(limitedTargetExtent) === 0) {
      // Tile is completely outside range -> EMPTY
      // TODO: is it actually correct that the source even creates the tile ?
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY;
      return;
    }

    var sourceProjExtent = sourceProj.getExtent();
    if (sourceProjExtent) {
      if (!maxSourceExtent) {
        maxSourceExtent = sourceProjExtent;
      } else {
        maxSourceExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getIntersection"])(maxSourceExtent, sourceProjExtent);
      }
    }

    var targetResolution = targetTileGrid.getResolution(
      this.wrappedTileCoord_[0]);

    var targetCenter = Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getCenter"])(limitedTargetExtent);
    var sourceResolution = Object(_reproj_js__WEBPACK_IMPORTED_MODULE_7__["calculateSourceResolution"])(
      sourceProj, targetProj, targetCenter, targetResolution);

    if (!isFinite(sourceResolution) || sourceResolution <= 0) {
      // invalid sourceResolution -> EMPTY
      // probably edges of the projections when no extent is defined
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY;
      return;
    }

    var errorThresholdInPixels = opt_errorThreshold !== undefined ?
      opt_errorThreshold : _common_js__WEBPACK_IMPORTED_MODULE_0__["ERROR_THRESHOLD"];

    /**
     * @private
     * @type {!import("./Triangulation.js").default}
     */
    this.triangulation_ = new _Triangulation_js__WEBPACK_IMPORTED_MODULE_8__["default"](
      sourceProj, targetProj, limitedTargetExtent, maxSourceExtent,
      sourceResolution * errorThresholdInPixels);

    if (this.triangulation_.getTriangles().length === 0) {
      // no valid triangles -> EMPTY
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY;
      return;
    }

    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);
    var sourceExtent = this.triangulation_.calculateSourceExtent();

    if (maxSourceExtent) {
      if (sourceProj.canWrapX()) {
        sourceExtent[1] = Object(_math_js__WEBPACK_IMPORTED_MODULE_6__["clamp"])(
          sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);
        sourceExtent[3] = Object(_math_js__WEBPACK_IMPORTED_MODULE_6__["clamp"])(
          sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);
      } else {
        sourceExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getIntersection"])(sourceExtent, maxSourceExtent);
      }
    }

    if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getArea"])(sourceExtent)) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY;
    } else {
      var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(
        sourceExtent, this.sourceZ_);

      for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
        for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
          var tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);
          if (tile) {
            this.sourceTiles_.push(tile);
          }
        }
      }

      if (this.sourceTiles_.length === 0) {
        this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY;
      }
    }
  }

  if ( Tile ) ReprojTile.__proto__ = Tile;
  ReprojTile.prototype = Object.create( Tile && Tile.prototype );
  ReprojTile.prototype.constructor = ReprojTile;

  /**
   * @inheritDoc
   */
  ReprojTile.prototype.disposeInternal = function disposeInternal () {
    if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING) {
      this.unlistenSources_();
    }
    Tile.prototype.disposeInternal.call(this);
  };

  /**
   * Get the HTML Canvas element for this tile.
   * @return {HTMLCanvasElement} Canvas.
   */
  ReprojTile.prototype.getImage = function getImage () {
    return this.canvas_;
  };

  /**
   * @private
   */
  ReprojTile.prototype.reproject_ = function reproject_ () {
    var sources = [];
    this.sourceTiles_.forEach(function(tile, i, arr) {
      if (tile && tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED) {
        sources.push({
          extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),
          image: tile.getImage()
        });
      }
    }.bind(this));
    this.sourceTiles_.length = 0;

    if (sources.length === 0) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR;
    } else {
      var z = this.wrappedTileCoord_[0];
      var size = this.targetTileGrid_.getTileSize(z);
      var width = typeof size === 'number' ? size : size[0];
      var height = typeof size === 'number' ? size : size[1];
      var targetResolution = this.targetTileGrid_.getResolution(z);
      var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);

      var targetExtent = this.targetTileGrid_.getTileCoordExtent(
        this.wrappedTileCoord_);
      this.canvas_ = Object(_reproj_js__WEBPACK_IMPORTED_MODULE_7__["render"])(width, height, this.pixelRatio_,
        sourceResolution, this.sourceTileGrid_.getExtent(),
        targetResolution, targetExtent, this.triangulation_, sources,
        this.gutter_, this.renderEdges_);

      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED;
    }
    this.changed();
  };

  /**
   * @inheritDoc
   */
  ReprojTile.prototype.load = function load () {
    if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING;
      this.changed();

      var leftToLoad = 0;

      this.sourcesListenerKeys_ = [];
      this.sourceTiles_.forEach(function(tile, i, arr) {
        var state = tile.getState();
        if (state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE || state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING) {
          leftToLoad++;

          var sourceListenKey = Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(tile, _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].CHANGE,
            function(e) {
              var state = tile.getState();
              if (state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED ||
                    state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR ||
                    state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY) {
                Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["unlistenByKey"])(sourceListenKey);
                leftToLoad--;
                if (leftToLoad === 0) {
                  this.unlistenSources_();
                  this.reproject_();
                }
              }
            }, this);
          this.sourcesListenerKeys_.push(sourceListenKey);
        }
      }.bind(this));

      this.sourceTiles_.forEach(function(tile, i, arr) {
        var state = tile.getState();
        if (state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE) {
          tile.load();
        }
      });

      if (leftToLoad === 0) {
        setTimeout(this.reproject_.bind(this), 0);
      }
    }
  };

  /**
   * @private
   */
  ReprojTile.prototype.unlistenSources_ = function unlistenSources_ () {
    this.sourcesListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_3__["unlistenByKey"]);
    this.sourcesListenerKeys_ = null;
  };

  return ReprojTile;
}(_Tile_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (ReprojTile);

//# sourceMappingURL=Tile.js.map

/***/ }),

/***/ "./node_modules/ol/reproj/Triangulation.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/reproj/Triangulation.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/**
 * @module ol/reproj/Triangulation
 */





/**
 * Single triangle; consists of 3 source points and 3 target points.
 * @typedef {Object} Triangle
 * @property {Array<import("../coordinate.js").Coordinate>} source
 * @property {Array<import("../coordinate.js").Coordinate>} target
 */


/**
 * Maximum number of subdivision steps during raster reprojection triangulation.
 * Prevents high memory usage and large number of proj4 calls (for certain
 * transformations and areas). At most `2*(2^this)` triangles are created for
 * each triangulated extent (tile/image).
 * @type {number}
 */
var MAX_SUBDIVISION = 10;


/**
 * Maximum allowed size of triangle relative to world width. When transforming
 * corners of world extent between certain projections, the resulting
 * triangulation seems to have zero error and no subdivision is performed. If
 * the triangle width is more than this (relative to world width; 0-1),
 * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.
 * @type {number}
 */
var MAX_TRIANGLE_WIDTH = 0.25;


/**
 * @classdesc
 * Class containing triangulation of the given target extent.
 * Used for determining source data and the reprojection itself.
 */
var Triangulation = function Triangulation(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold) {

  /**
   * @type {import("../proj/Projection.js").default}
   * @private
   */
  this.sourceProj_ = sourceProj;

  /**
   * @type {import("../proj/Projection.js").default}
   * @private
   */
  this.targetProj_ = targetProj;

  /** @type {!Object<string, import("../coordinate.js").Coordinate>} */
  var transformInvCache = {};
  var transformInv = Object(_proj_js__WEBPACK_IMPORTED_MODULE_2__["getTransform"])(this.targetProj_, this.sourceProj_);

  /**
   * @param {import("../coordinate.js").Coordinate} c A coordinate.
   * @return {import("../coordinate.js").Coordinate} Transformed coordinate.
   * @private
   */
  this.transformInv_ = function(c) {
    var key = c[0] + '/' + c[1];
    if (!transformInvCache[key]) {
      transformInvCache[key] = transformInv(c);
    }
    return transformInvCache[key];
  };

  /**
   * @type {import("../extent.js").Extent}
   * @private
   */
  this.maxSourceExtent_ = maxSourceExtent;

  /**
   * @type {number}
   * @private
   */
  this.errorThresholdSquared_ = errorThreshold * errorThreshold;

  /**
   * @type {Array<Triangle>}
   * @private
   */
  this.triangles_ = [];

  /**
   * Indicates that the triangulation crosses edge of the source projection.
   * @type {boolean}
   * @private
   */
  this.wrapsXInSource_ = false;

  /**
   * @type {boolean}
   * @private
   */
  this.canWrapXInSource_ = this.sourceProj_.canWrapX() &&
      !!maxSourceExtent &&
      !!this.sourceProj_.getExtent() &&
      (Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getWidth"])(maxSourceExtent) == Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getWidth"])(this.sourceProj_.getExtent()));

  /**
   * @type {?number}
   * @private
   */
  this.sourceWorldWidth_ = this.sourceProj_.getExtent() ?
    Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getWidth"])(this.sourceProj_.getExtent()) : null;

  /**
   * @type {?number}
   * @private
   */
  this.targetWorldWidth_ = this.targetProj_.getExtent() ?
    Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getWidth"])(this.targetProj_.getExtent()) : null;

  var destinationTopLeft = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getTopLeft"])(targetExtent);
  var destinationTopRight = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getTopRight"])(targetExtent);
  var destinationBottomRight = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getBottomRight"])(targetExtent);
  var destinationBottomLeft = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getBottomLeft"])(targetExtent);
  var sourceTopLeft = this.transformInv_(destinationTopLeft);
  var sourceTopRight = this.transformInv_(destinationTopRight);
  var sourceBottomRight = this.transformInv_(destinationBottomRight);
  var sourceBottomLeft = this.transformInv_(destinationBottomLeft);

  this.addQuad_(
    destinationTopLeft, destinationTopRight,
    destinationBottomRight, destinationBottomLeft,
    sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft,
    MAX_SUBDIVISION);

  if (this.wrapsXInSource_) {
    var leftBound = Infinity;
    this.triangles_.forEach(function(triangle, i, arr) {
      leftBound = Math.min(leftBound,
        triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);
    });

    // Shift triangles to be as close to `leftBound` as possible
    // (if the distance is more than `worldWidth / 2` it can be closer.
    this.triangles_.forEach(function(triangle) {
      if (Math.max(triangle.source[0][0], triangle.source[1][0],
        triangle.source[2][0]) - leftBound > this.sourceWorldWidth_ / 2) {
        var newTriangle = [[triangle.source[0][0], triangle.source[0][1]],
          [triangle.source[1][0], triangle.source[1][1]],
          [triangle.source[2][0], triangle.source[2][1]]];
        if ((newTriangle[0][0] - leftBound) > this.sourceWorldWidth_ / 2) {
          newTriangle[0][0] -= this.sourceWorldWidth_;
        }
        if ((newTriangle[1][0] - leftBound) > this.sourceWorldWidth_ / 2) {
          newTriangle[1][0] -= this.sourceWorldWidth_;
        }
        if ((newTriangle[2][0] - leftBound) > this.sourceWorldWidth_ / 2) {
          newTriangle[2][0] -= this.sourceWorldWidth_;
        }

        // Rarely (if the extent contains both the dateline and prime meridian)
        // the shift can in turn break some triangles.
        // Detect this here and don't shift in such cases.
        var minX = Math.min(
          newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
        var maxX = Math.max(
          newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
        if ((maxX - minX) < this.sourceWorldWidth_ / 2) {
          triangle.source = newTriangle;
        }
      }
    }.bind(this));
  }

  transformInvCache = {};
};

/**
 * Adds triangle to the triangulation.
 * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
 * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
 * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
 * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
 * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
 * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
 * @private
 */
Triangulation.prototype.addTriangle_ = function addTriangle_ (a, b, c, aSrc, bSrc, cSrc) {
  this.triangles_.push({
    source: [aSrc, bSrc, cSrc],
    target: [a, b, c]
  });
};

/**
 * Adds quad (points in clock-wise order) to the triangulation
 * (and reprojects the vertices) if valid.
 * Performs quad subdivision if needed to increase precision.
 *
 * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
 * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
 * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
 * @param {import("../coordinate.js").Coordinate} d The target d coordinate.
 * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
 * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
 * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
 * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.
 * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
 * @private
 */
Triangulation.prototype.addQuad_ = function addQuad_ (a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {

  var sourceQuadExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["boundingExtent"])([aSrc, bSrc, cSrc, dSrc]);
  var sourceCoverageX = this.sourceWorldWidth_ ?
    Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getWidth"])(sourceQuadExtent) / this.sourceWorldWidth_ : null;
  var sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);

  // when the quad is wrapped in the source projection
  // it covers most of the projection extent, but not fully
  var wrapsX = this.sourceProj_.canWrapX() &&
               sourceCoverageX > 0.5 && sourceCoverageX < 1;

  var needsSubdivision = false;

  if (maxSubdivision > 0) {
    if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
      var targetQuadExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["boundingExtent"])([a, b, c, d]);
      var targetCoverageX = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getWidth"])(targetQuadExtent) / this.targetWorldWidth_;
      needsSubdivision = targetCoverageX > MAX_TRIANGLE_WIDTH ||
        needsSubdivision;
    }
    if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {
      needsSubdivision = sourceCoverageX > MAX_TRIANGLE_WIDTH ||
          needsSubdivision;
    }
  }

  if (!needsSubdivision && this.maxSourceExtent_) {
    if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["intersects"])(sourceQuadExtent, this.maxSourceExtent_)) {
      // whole quad outside source projection extent -> ignore
      return;
    }
  }

  if (!needsSubdivision) {
    if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ||
        !isFinite(bSrc[0]) || !isFinite(bSrc[1]) ||
        !isFinite(cSrc[0]) || !isFinite(cSrc[1]) ||
        !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {
      if (maxSubdivision > 0) {
        needsSubdivision = true;
      } else {
        return;
      }
    }
  }

  if (maxSubdivision > 0) {
    if (!needsSubdivision) {
      var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];
      var centerSrc = this.transformInv_(center);

      var dx;
      if (wrapsX) {
        var centerSrcEstimX =
            (Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["modulo"])(aSrc[0], sourceWorldWidth) +
             Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["modulo"])(cSrc[0], sourceWorldWidth)) / 2;
        dx = centerSrcEstimX -
            Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["modulo"])(centerSrc[0], sourceWorldWidth);
      } else {
        dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];
      }
      var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];
      var centerSrcErrorSquared = dx * dx + dy * dy;
      needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;
    }
    if (needsSubdivision) {
      if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {
        // split horizontally (top & bottom)
        var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];
        var bcSrc = this.transformInv_(bc);
        var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];
        var daSrc = this.transformInv_(da);

        this.addQuad_(
          a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);
        this.addQuad_(
          da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);
      } else {
        // split vertically (left & right)
        var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];
        var abSrc = this.transformInv_(ab);
        var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];
        var cdSrc = this.transformInv_(cd);

        this.addQuad_(
          a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);
        this.addQuad_(
          ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);
      }
      return;
    }
  }

  if (wrapsX) {
    if (!this.canWrapXInSource_) {
      return;
    }
    this.wrapsXInSource_ = true;
  }

  this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);
  this.addTriangle_(a, b, c, aSrc, bSrc, cSrc);
};

/**
 * Calculates extent of the 'source' coordinates from all the triangles.
 *
 * @return {import("../extent.js").Extent} Calculated extent.
 */
Triangulation.prototype.calculateSourceExtent = function calculateSourceExtent () {
  var extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["createEmpty"])();

  this.triangles_.forEach(function(triangle, i, arr) {
    var src = triangle.source;
    Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["extendCoordinate"])(extent, src[0]);
    Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["extendCoordinate"])(extent, src[1]);
    Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["extendCoordinate"])(extent, src[2]);
  });

  return extent;
};

/**
 * @return {Array<Triangle>} Array of the calculated triangles.
 */
Triangulation.prototype.getTriangles = function getTriangles () {
  return this.triangles_;
};

/* harmony default export */ __webpack_exports__["default"] = (Triangulation);

//# sourceMappingURL=Triangulation.js.map

/***/ }),

/***/ "./node_modules/ol/reproj/common.js":
/*!******************************************!*\
  !*** ./node_modules/ol/reproj/common.js ***!
  \******************************************/
/*! exports provided: ERROR_THRESHOLD, ENABLE_RASTER_REPROJECTION */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ERROR_THRESHOLD", function() { return ERROR_THRESHOLD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENABLE_RASTER_REPROJECTION", function() { return ENABLE_RASTER_REPROJECTION; });
/**
 * @module ol/reproj/common
 */

/**
 * Default maximum allowed threshold  (in pixels) for reprojection
 * triangulation.
 * @type {number}
 */
var ERROR_THRESHOLD = 0.5;

/**
 * Enable automatic reprojection of raster sources. Default is `true`.
 * TODO: decide if we want to expose this as a build flag or remove it
 * @type {boolean}
 */
var ENABLE_RASTER_REPROJECTION = true;

//# sourceMappingURL=common.js.map

/***/ }),

/***/ "./node_modules/ol/resolutionconstraint.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/resolutionconstraint.js ***!
  \*************************************************/
/*! exports provided: createSnapToResolutions, createSnapToPower */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSnapToResolutions", function() { return createSnapToResolutions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSnapToPower", function() { return createSnapToPower; });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/resolutionconstraint
 */




/**
 * @typedef {function((number|undefined), number, number): (number|undefined)} Type
 */


/**
 * @param {Array<number>} resolutions Resolutions.
 * @return {Type} Zoom function.
 */
function createSnapToResolutions(resolutions) {
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} delta Delta.
     * @param {number} direction Direction.
     * @return {number|undefined} Resolution.
     */
    function(resolution, delta, direction) {
      if (resolution !== undefined) {
        var z = Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["linearFindNearest"])(resolutions, resolution, direction);
        z = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["clamp"])(z + delta, 0, resolutions.length - 1);
        var index = Math.floor(z);
        if (z != index && index < resolutions.length - 1) {
          var power = resolutions[index] / resolutions[index + 1];
          return resolutions[index] / Math.pow(power, z - index);
        } else {
          return resolutions[index];
        }
      } else {
        return undefined;
      }
    }
  );
}


/**
 * @param {number} power Power.
 * @param {number} maxResolution Maximum resolution.
 * @param {number=} opt_maxLevel Maximum level.
 * @return {Type} Zoom function.
 */
function createSnapToPower(power, maxResolution, opt_maxLevel) {
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} delta Delta.
     * @param {number} direction Direction.
     * @return {number|undefined} Resolution.
     */
    function(resolution, delta, direction) {
      if (resolution !== undefined) {
        var offset = -direction / 2 + 0.5;
        var oldLevel = Math.floor(
          Math.log(maxResolution / resolution) / Math.log(power) + offset);
        var newLevel = Math.max(oldLevel + delta, 0);
        if (opt_maxLevel !== undefined) {
          newLevel = Math.min(newLevel, opt_maxLevel);
        }
        return maxResolution / Math.pow(power, newLevel);
      } else {
        return undefined;
      }
    });
}

//# sourceMappingURL=resolutionconstraint.js.map

/***/ }),

/***/ "./node_modules/ol/rotationconstraint.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/rotationconstraint.js ***!
  \***********************************************/
/*! exports provided: disable, none, createSnapToN, createSnapToZero */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "disable", function() { return disable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "none", function() { return none; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSnapToN", function() { return createSnapToN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSnapToZero", function() { return createSnapToZero; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/rotationconstraint
 */



/**
 * @typedef {function((number|undefined), number): (number|undefined)} Type
 */


/**
 * @param {number|undefined} rotation Rotation.
 * @param {number} delta Delta.
 * @return {number|undefined} Rotation.
 */
function disable(rotation, delta) {
  if (rotation !== undefined) {
    return 0;
  } else {
    return undefined;
  }
}


/**
 * @param {number|undefined} rotation Rotation.
 * @param {number} delta Delta.
 * @return {number|undefined} Rotation.
 */
function none(rotation, delta) {
  if (rotation !== undefined) {
    return rotation + delta;
  } else {
    return undefined;
  }
}


/**
 * @param {number} n N.
 * @return {Type} Rotation constraint.
 */
function createSnapToN(n) {
  var theta = 2 * Math.PI / n;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {number} delta Delta.
     * @return {number|undefined} Rotation.
     */
    function(rotation, delta) {
      if (rotation !== undefined) {
        rotation = Math.floor((rotation + delta) / theta + 0.5) * theta;
        return rotation;
      } else {
        return undefined;
      }
    });
}


/**
 * @param {number=} opt_tolerance Tolerance.
 * @return {Type} Rotation constraint.
 */
function createSnapToZero(opt_tolerance) {
  var tolerance = opt_tolerance || Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toRadians"])(5);
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {number} delta Delta.
     * @return {number|undefined} Rotation.
     */
    function(rotation, delta) {
      if (rotation !== undefined) {
        if (Math.abs(rotation + delta) <= tolerance) {
          return 0;
        } else {
          return rotation + delta;
        }
      } else {
        return undefined;
      }
    });
}

//# sourceMappingURL=rotationconstraint.js.map

/***/ }),

/***/ "./node_modules/ol/size.js":
/*!*********************************!*\
  !*** ./node_modules/ol/size.js ***!
  \*********************************/
/*! exports provided: buffer, hasArea, scale, toSize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buffer", function() { return buffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasArea", function() { return hasArea; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toSize", function() { return toSize; });
/**
 * @module ol/size
 */


/**
 * An array of numbers representing a size: `[width, height]`.
 * @typedef {Array<number>} Size
 * @api
 */


/**
 * Returns a buffered size.
 * @param {Size} size Size.
 * @param {number} num The amount by which to buffer.
 * @param {Size=} opt_size Optional reusable size array.
 * @return {Size} The buffered size.
 */
function buffer(size, num, opt_size) {
  if (opt_size === undefined) {
    opt_size = [0, 0];
  }
  opt_size[0] = size[0] + 2 * num;
  opt_size[1] = size[1] + 2 * num;
  return opt_size;
}


/**
 * Determines if a size has a positive area.
 * @param {Size} size The size to test.
 * @return {boolean} The size has a positive area.
 */
function hasArea(size) {
  return size[0] > 0 && size[1] > 0;
}


/**
 * Returns a size scaled by a ratio. The result will be an array of integers.
 * @param {Size} size Size.
 * @param {number} ratio Ratio.
 * @param {Size=} opt_size Optional reusable size array.
 * @return {Size} The scaled size.
 */
function scale(size, ratio, opt_size) {
  if (opt_size === undefined) {
    opt_size = [0, 0];
  }
  opt_size[0] = (size[0] * ratio + 0.5) | 0;
  opt_size[1] = (size[1] * ratio + 0.5) | 0;
  return opt_size;
}


/**
 * Returns an `Size` array for the passed in number (meaning: square) or
 * `Size` array.
 * (meaning: non-square),
 * @param {number|Size} size Width and height.
 * @param {Size=} opt_size Optional reusable size array.
 * @return {Size} Size.
 * @api
 */
function toSize(size, opt_size) {
  if (Array.isArray(size)) {
    return size;
  } else {
    if (opt_size === undefined) {
      opt_size = [size, size];
    } else {
      opt_size[0] = opt_size[1] = /** @type {number} */ (size);
    }
    return opt_size;
  }
}

//# sourceMappingURL=size.js.map

/***/ }),

/***/ "./node_modules/ol/source/OSM.js":
/*!***************************************!*\
  !*** ./node_modules/ol/source/OSM.js ***!
  \***************************************/
/*! exports provided: ATTRIBUTION, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ATTRIBUTION", function() { return ATTRIBUTION; });
/* harmony import */ var _XYZ_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./XYZ.js */ "./node_modules/ol/source/XYZ.js");
/**
 * @module ol/source/OSM
 */




/**
 * The attribution containing a link to the OpenStreetMap Copyright and License
 * page.
 * @const
 * @type {string}
 * @api
 */
var ATTRIBUTION = '&#169; ' +
      '<a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> ' +
      'contributors.';


/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize=2048] Cache size.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you are using the WebGL renderer or if you want to
 * access pixel data with the Canvas renderer.  See
 * https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {number} [maxZoom=19] Max zoom.
 * @property {boolean} [opaque=true] Whether the layer is opaque.
 * @property {number} [reprojectionErrorThreshold=1.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {string} [url='https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png'] URL template.
 * Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 */


/**
 * @classdesc
 * Layer source for the OpenStreetMap tile server.
 * @api
 */
var OSM = /*@__PURE__*/(function (XYZ) {
  function OSM(opt_options) {

    var options = opt_options || {};

    var attributions;
    if (options.attributions !== undefined) {
      attributions = options.attributions;
    } else {
      attributions = [ATTRIBUTION];
    }

    var crossOrigin = options.crossOrigin !== undefined ?
      options.crossOrigin : 'anonymous';

    var url = options.url !== undefined ?
      options.url : 'https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png';

    XYZ.call(this, {
      attributions: attributions,
      cacheSize: options.cacheSize,
      crossOrigin: crossOrigin,
      opaque: options.opaque !== undefined ? options.opaque : true,
      maxZoom: options.maxZoom !== undefined ? options.maxZoom : 19,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileLoadFunction: options.tileLoadFunction,
      url: url,
      wrapX: options.wrapX,
      attributionsCollapsible: false
    });

  }

  if ( XYZ ) OSM.__proto__ = XYZ;
  OSM.prototype = Object.create( XYZ && XYZ.prototype );
  OSM.prototype.constructor = OSM;

  return OSM;
}(_XYZ_js__WEBPACK_IMPORTED_MODULE_0__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (OSM);

//# sourceMappingURL=OSM.js.map

/***/ }),

/***/ "./node_modules/ol/source/Source.js":
/*!******************************************!*\
  !*** ./node_modules/ol/source/Source.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _State_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./State.js */ "./node_modules/ol/source/State.js");
/**
 * @module ol/source/Source
 */






/**
 * A function that returns a string or an array of strings representing source
 * attributions.
 *
 * @typedef {function(import("../PluggableMap.js").FrameState): (string|Array<string>)} Attribution
 */


/**
 * A type that can be used to provide attribution information for data sources.
 *
 * It represents either
 * * a simple string (e.g. `'© Acme Inc.'`)
 * * an array of simple strings (e.g. `['© Acme Inc.', '© Bacme Inc.']`)
 * * a function that returns a string or array of strings (`{@link module:ol/source/Source~Attribution}`)
 *
 * @typedef {string|Array<string>|Attribution} AttributionLike
 */


/**
 * @typedef {Object} Options
 * @property {AttributionLike} [attributions]
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {import("../proj.js").ProjectionLike} projection
 * @property {SourceState} [state='ready']
 * @property {boolean} [wrapX=false]
 */


/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for {@link module:ol/layer/Layer~Layer} sources.
 *
 * A generic `change` event is triggered when the state of the source changes.
 * @abstract
 * @api
 */
var Source = /*@__PURE__*/(function (BaseObject) {
  function Source(options) {

    BaseObject.call(this);

    /**
     * @private
     * @type {import("../proj/Projection.js").default}
     */
    this.projection_ = Object(_proj_js__WEBPACK_IMPORTED_MODULE_2__["get"])(options.projection);

    /**
     * @private
     * @type {?Attribution}
     */
    this.attributions_ = adaptAttributions(options.attributions);

    /**
     * @private
     * @type {boolean}
     */
    this.attributionsCollapsible_ = options.attributionsCollapsible !== undefined ?
      options.attributionsCollapsible : true;

    /**
     * This source is currently loading data. Sources that defer loading to the
     * map's tile queue never set this to `true`.
     * @type {boolean}
     */
    this.loading = false;

    /**
     * @private
     * @type {SourceState}
     */
    this.state_ = options.state !== undefined ?
      options.state : _State_js__WEBPACK_IMPORTED_MODULE_3__["default"].READY;

    /**
     * @private
     * @type {boolean}
     */
    this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;

  }

  if ( BaseObject ) Source.__proto__ = BaseObject;
  Source.prototype = Object.create( BaseObject && BaseObject.prototype );
  Source.prototype.constructor = Source;

  /**
   * Get the attribution function for the source.
   * @return {?Attribution} Attribution function.
   */
  Source.prototype.getAttributions = function getAttributions () {
    return this.attributions_;
  };

  /**
   * @return {boolean} Aattributions are collapsible.
   */
  Source.prototype.getAttributionsCollapsible = function getAttributionsCollapsible () {
    return this.attributionsCollapsible_;
  };

  /**
   * Get the projection of the source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   */
  Source.prototype.getProjection = function getProjection () {
    return this.projection_;
  };

  /**
   * @abstract
   * @return {Array<number>|undefined} Resolutions.
   */
  Source.prototype.getResolutions = function getResolutions () {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Get the state of the source, see {@link module:ol/source/State~State} for possible states.
   * @return {SourceState} State.
   * @api
   */
  Source.prototype.getState = function getState () {
    return this.state_;
  };

  /**
   * @return {boolean|undefined} Wrap X.
   */
  Source.prototype.getWrapX = function getWrapX () {
    return this.wrapX_;
  };

  /**
   * Refreshes the source and finally dispatches a 'change' event.
   * @api
   */
  Source.prototype.refresh = function refresh () {
    this.changed();
  };

  /**
   * Set the attributions of the source.
   * @param {AttributionLike|undefined} attributions Attributions.
   *     Can be passed as `string`, `Array<string>`, `{@link module:ol/source/Source~Attribution}`,
   *     or `undefined`.
   * @api
   */
  Source.prototype.setAttributions = function setAttributions (attributions) {
    this.attributions_ = adaptAttributions(attributions);
    this.changed();
  };

  /**
   * Set the state of the source.
   * @param {SourceState} state State.
   * @protected
   */
  Source.prototype.setState = function setState (state) {
    this.state_ = state;
    this.changed();
  };

  return Source;
}(_Object_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/**
 * Turns the attributions option into an attributions function.
 * @param {AttributionLike|undefined} attributionLike The attribution option.
 * @return {?Attribution} An attribution function (or null).
 */
function adaptAttributions(attributionLike) {
  if (!attributionLike) {
    return null;
  }
  if (Array.isArray(attributionLike)) {
    return function(frameState) {
      return attributionLike;
    };
  }

  if (typeof attributionLike === 'function') {
    return attributionLike;
  }

  return function(frameState) {
    return [attributionLike];
  };
}


/* harmony default export */ __webpack_exports__["default"] = (Source);

//# sourceMappingURL=Source.js.map

/***/ }),

/***/ "./node_modules/ol/source/Stamen.js":
/*!******************************************!*\
  !*** ./node_modules/ol/source/Stamen.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _OSM_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./OSM.js */ "./node_modules/ol/source/OSM.js");
/* harmony import */ var _XYZ_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./XYZ.js */ "./node_modules/ol/source/XYZ.js");
/**
 * @module ol/source/Stamen
 */





/**
 * @const
 * @type {Array<string>}
 */
var ATTRIBUTIONS = [
  'Map tiles by <a href="https://stamen.com/">Stamen Design</a>, ' +
        'under <a href="https://creativecommons.org/licenses/by/3.0/">CC BY' +
        ' 3.0</a>.',
  _OSM_js__WEBPACK_IMPORTED_MODULE_0__["ATTRIBUTION"]
];


/**
 * @type {Object<string, {extension: string, opaque: boolean}>}
 */
var LayerConfig = {
  'terrain': {
    extension: 'jpg',
    opaque: true
  },
  'terrain-background': {
    extension: 'jpg',
    opaque: true
  },
  'terrain-labels': {
    extension: 'png',
    opaque: false
  },
  'terrain-lines': {
    extension: 'png',
    opaque: false
  },
  'toner-background': {
    extension: 'png',
    opaque: true
  },
  'toner': {
    extension: 'png',
    opaque: true
  },
  'toner-hybrid': {
    extension: 'png',
    opaque: false
  },
  'toner-labels': {
    extension: 'png',
    opaque: false
  },
  'toner-lines': {
    extension: 'png',
    opaque: false
  },
  'toner-lite': {
    extension: 'png',
    opaque: true
  },
  'watercolor': {
    extension: 'jpg',
    opaque: true
  }
};


/**
 * @type {Object<string, {minZoom: number, maxZoom: number}>}
 */
var ProviderConfig = {
  'terrain': {
    minZoom: 4,
    maxZoom: 18
  },
  'toner': {
    minZoom: 0,
    maxZoom: 20
  },
  'watercolor': {
    minZoom: 1,
    maxZoom: 16
  }
};


/**
 * @typedef {Object} Options
 * @property {number} [cacheSize=2048] Cache size.
 * @property {string} layer Layer name.
 * @property {number} [minZoom] Minimum zoom.
 * @property {number} [maxZoom] Maximum zoom.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction]
 * Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 */


/**
 * @classdesc
 * Layer source for the Stamen tile server.
 * @api
 */
var Stamen = /*@__PURE__*/(function (XYZ) {
  function Stamen(options) {
    var i = options.layer.indexOf('-');
    var provider = i == -1 ? options.layer : options.layer.slice(0, i);
    var providerConfig = ProviderConfig[provider];

    var layerConfig = LayerConfig[options.layer];

    var url = options.url !== undefined ? options.url :
      'https://stamen-tiles-{a-d}.a.ssl.fastly.net/' + options.layer +
        '/{z}/{x}/{y}.' + layerConfig.extension;

    XYZ.call(this, {
      attributions: ATTRIBUTIONS,
      cacheSize: options.cacheSize,
      crossOrigin: 'anonymous',
      maxZoom: options.maxZoom != undefined ? options.maxZoom : providerConfig.maxZoom,
      minZoom: options.minZoom != undefined ? options.minZoom : providerConfig.minZoom,
      opaque: layerConfig.opaque,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileLoadFunction: options.tileLoadFunction,
      url: url,
      wrapX: options.wrapX
    });

  }

  if ( XYZ ) Stamen.__proto__ = XYZ;
  Stamen.prototype = Object.create( XYZ && XYZ.prototype );
  Stamen.prototype.constructor = Stamen;

  return Stamen;
}(_XYZ_js__WEBPACK_IMPORTED_MODULE_1__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (Stamen);

//# sourceMappingURL=Stamen.js.map

/***/ }),

/***/ "./node_modules/ol/source/State.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/source/State.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/source/State
 */

/**
 * @enum {string}
 * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  UNDEFINED: 'undefined',
  LOADING: 'loading',
  READY: 'ready',
  ERROR: 'error'
});

//# sourceMappingURL=State.js.map

/***/ }),

/***/ "./node_modules/ol/source/Tile.js":
/*!****************************************!*\
  !*** ./node_modules/ol/source/Tile.js ***!
  \****************************************/
/*! exports provided: TileSourceEvent, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TileSourceEvent", function() { return TileSourceEvent; });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _TileCache_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../TileCache.js */ "./node_modules/ol/TileCache.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../size.js */ "./node_modules/ol/size.js");
/* harmony import */ var _Source_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Source.js */ "./node_modules/ol/source/Source.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");
/* harmony import */ var _tilegrid_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../tilegrid.js */ "./node_modules/ol/tilegrid.js");
/**
 * @module ol/source/Tile
 */










/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions]
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize]
 * @property {boolean} [opaque]
 * @property {number} [tilePixelRatio]
 * @property {import("../proj.js").ProjectionLike} [projection]
 * @property {import("./State.js").default} [state]
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid]
 * @property {boolean} [wrapX=true]
 * @property {number} [transition]
 * @property {string} [key]
 */


/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for sources providing images divided into a tile grid.
 * @abstract
 * @api
 */
var TileSource = /*@__PURE__*/(function (Source) {
  function TileSource(options) {

    Source.call(this, {
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      projection: options.projection,
      state: options.state,
      wrapX: options.wrapX
    });

    /**
     * @private
     * @type {boolean}
     */
    this.opaque_ = options.opaque !== undefined ? options.opaque : false;

    /**
     * @private
     * @type {number}
     */
    this.tilePixelRatio_ = options.tilePixelRatio !== undefined ?
      options.tilePixelRatio : 1;

    /**
     * @protected
     * @type {import("../tilegrid/TileGrid.js").default}
     */
    this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;

    /**
     * @protected
     * @type {import("../TileCache.js").default}
     */
    this.tileCache = new _TileCache_js__WEBPACK_IMPORTED_MODULE_1__["default"](options.cacheSize);

    /**
     * @protected
     * @type {import("../size.js").Size}
     */
    this.tmpSize = [0, 0];

    /**
     * @private
     * @type {string}
     */
    this.key_ = options.key || '';

    /**
     * @protected
     * @type {import("../Tile.js").Options}
     */
    this.tileOptions = {transition: options.transition};

  }

  if ( Source ) TileSource.__proto__ = Source;
  TileSource.prototype = Object.create( Source && Source.prototype );
  TileSource.prototype.constructor = TileSource;

  /**
   * @return {boolean} Can expire cache.
   */
  TileSource.prototype.canExpireCache = function canExpireCache () {
    return this.tileCache.canExpireCache();
  };

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, import("../TileRange.js").default>} usedTiles Used tiles.
   */
  TileSource.prototype.expireCache = function expireCache (projection, usedTiles) {
    var tileCache = this.getTileCacheForProjection(projection);
    if (tileCache) {
      tileCache.expireCache(usedTiles);
    }
  };

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {number} z Zoom level.
   * @param {import("../TileRange.js").default} tileRange Tile range.
   * @param {function(import("../Tile.js").default):(boolean|void)} callback Called with each
   *     loaded tile.  If the callback returns `false`, the tile will not be
   *     considered loaded.
   * @return {boolean} The tile range is fully covered with loaded tiles.
   */
  TileSource.prototype.forEachLoadedTile = function forEachLoadedTile (projection, z, tileRange, callback) {
    var tileCache = this.getTileCacheForProjection(projection);
    if (!tileCache) {
      return false;
    }

    var covered = true;
    var tile, tileCoordKey, loaded;
    for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
        tileCoordKey = Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_7__["getKeyZXY"])(z, x, y);
        loaded = false;
        if (tileCache.containsKey(tileCoordKey)) {
          tile = /** @type {!import("../Tile.js").default} */ (tileCache.get(tileCoordKey));
          loaded = tile.getState() === _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED;
          if (loaded) {
            loaded = (callback(tile) !== false);
          }
        }
        if (!loaded) {
          covered = false;
        }
      }
    }
    return covered;
  };

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */
  TileSource.prototype.getGutterForProjection = function getGutterForProjection (projection) {
    return 0;
  };

  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   * @protected
   */
  TileSource.prototype.getKey = function getKey () {
    return this.key_;
  };

  /**
   * Set the value to be used as the key for all tiles in the source.
   * @param {string} key The key for tiles.
   * @protected
   */
  TileSource.prototype.setKey = function setKey (key) {
    if (this.key_ !== key) {
      this.key_ = key;
      this.changed();
    }
  };

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {boolean} Opaque.
   */
  TileSource.prototype.getOpaque = function getOpaque (projection) {
    return this.opaque_;
  };

  /**
   * @inheritDoc
   */
  TileSource.prototype.getResolutions = function getResolutions () {
    return this.tileGrid.getResolutions();
  };

  /**
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../Tile.js").default} Tile.
   */
  TileSource.prototype.getTile = function getTile (z, x, y, pixelRatio, projection) {
    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
  };

  /**
   * Return the tile grid of the tile source.
   * @return {import("../tilegrid/TileGrid.js").default} Tile grid.
   * @api
   */
  TileSource.prototype.getTileGrid = function getTileGrid () {
    return this.tileGrid;
  };

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */
  TileSource.prototype.getTileGridForProjection = function getTileGridForProjection$1 (projection) {
    if (!this.tileGrid) {
      return Object(_tilegrid_js__WEBPACK_IMPORTED_MODULE_8__["getForProjection"])(projection);
    } else {
      return this.tileGrid;
    }
  };

  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../TileCache.js").default} Tile cache.
   * @protected
   */
  TileSource.prototype.getTileCacheForProjection = function getTileCacheForProjection (projection) {
    var thisProj = this.getProjection();
    if (thisProj && !Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__["equivalent"])(thisProj, projection)) {
      return null;
    } else {
      return this.tileCache;
    }
  };

  /**
   * Get the tile pixel ratio for this source. Subclasses may override this
   * method, which is meant to return a supported pixel ratio that matches the
   * provided `pixelRatio` as close as possible.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */
  TileSource.prototype.getTilePixelRatio = function getTilePixelRatio (pixelRatio) {
    return this.tilePixelRatio_;
  };

  /**
   * @param {number} z Z.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../size.js").Size} Tile size.
   */
  TileSource.prototype.getTilePixelSize = function getTilePixelSize (z, pixelRatio, projection) {
    var tileGrid = this.getTileGridForProjection(projection);
    var tilePixelRatio = this.getTilePixelRatio(pixelRatio);
    var tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_5__["toSize"])(tileGrid.getTileSize(z), this.tmpSize);
    if (tilePixelRatio == 1) {
      return tileSize;
    } else {
      return Object(_size_js__WEBPACK_IMPORTED_MODULE_5__["scale"])(tileSize, tilePixelRatio, this.tmpSize);
    }
  };

  /**
   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
   * is outside the resolution and extent range of the tile grid, `null` will be
   * returned.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../proj/Projection.js").default=} opt_projection Projection.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or
   *     null if no tile URL should be created for the passed `tileCoord`.
   */
  TileSource.prototype.getTileCoordForTileUrlFunction = function getTileCoordForTileUrlFunction (tileCoord, opt_projection) {
    var projection = opt_projection !== undefined ?
      opt_projection : this.getProjection();
    var tileGrid = this.getTileGridForProjection(projection);
    if (this.getWrapX() && projection.isGlobal()) {
      tileCoord = Object(_tilegrid_js__WEBPACK_IMPORTED_MODULE_8__["wrapX"])(tileGrid, tileCoord, projection);
    }
    return Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_7__["withinExtentAndZ"])(tileCoord, tileGrid) ? tileCoord : null;
  };

  /**
   * @inheritDoc
   */
  TileSource.prototype.refresh = function refresh () {
    this.tileCache.clear();
    this.changed();
  };

  /**
   * Marks a tile coord as being used, without triggering a load.
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  TileSource.prototype.useTile = function useTile (z, x, y, projection) {};

  return TileSource;
}(_Source_js__WEBPACK_IMPORTED_MODULE_6__["default"]));


/**
 * @classdesc
 * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this
 * type.
 */
var TileSourceEvent = /*@__PURE__*/(function (Event) {
  function TileSourceEvent(type, tile) {

    Event.call(this, type);

    /**
     * The tile related to the event.
     * @type {import("../Tile.js").default}
     * @api
     */
    this.tile = tile;

  }

  if ( Event ) TileSourceEvent.__proto__ = Event;
  TileSourceEvent.prototype = Object.create( Event && Event.prototype );
  TileSourceEvent.prototype.constructor = TileSourceEvent;

  return TileSourceEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_3__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (TileSource);

//# sourceMappingURL=Tile.js.map

/***/ }),

/***/ "./node_modules/ol/source/TileEventType.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/source/TileEventType.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/source/TileEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({

  /**
   * Triggered when a tile starts loading.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
   * @api
   */
  TILELOADSTART: 'tileloadstart',

  /**
   * Triggered when a tile finishes loading, either when its data is loaded,
   * or when loading was aborted because the tile is no longer needed.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadend
   * @api
   */
  TILELOADEND: 'tileloadend',

  /**
   * Triggered if tile loading results in an error.
   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
   * @api
   */
  TILELOADERROR: 'tileloaderror'

});

//# sourceMappingURL=TileEventType.js.map

/***/ }),

/***/ "./node_modules/ol/source/TileImage.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/source/TileImage.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _reproj_common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../reproj/common.js */ "./node_modules/ol/reproj/common.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _ImageTile_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ImageTile.js */ "./node_modules/ol/ImageTile.js");
/* harmony import */ var _TileCache_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../TileCache.js */ "./node_modules/ol/TileCache.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _reproj_Tile_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../reproj/Tile.js */ "./node_modules/ol/reproj/Tile.js");
/* harmony import */ var _UrlTile_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./UrlTile.js */ "./node_modules/ol/source/UrlTile.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");
/* harmony import */ var _tilegrid_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../tilegrid.js */ "./node_modules/ol/tilegrid.js");
/**
 * @module ol/source/TileImage
 */













/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize=2048] Cache size.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you are using the WebGL renderer or if you want to
 * access pixel data with the Canvas renderer.  See
 * https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [opaque=true] Whether the layer is opaque.
 * @property {import("../proj.js").ProjectionLike} projection Projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("./State.js").default} [state] Source state.
 * @property {typeof import("../ImageTile.js").default} [tileClass] Class used to instantiate image tiles.
 * Default is {@link module:ol/ImageTile~ImageTile}.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service. For example, if the tile
 * service advertizes 256px by 256px tiles but actually sends 512px
 * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
 * should be set to `2`.
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be
 * used instead of defining each one separately in the `urls` option.
 * @property {Array<string>} [urls] An array of URL templates.
 * @property {boolean} [wrapX] Whether to wrap the world horizontally. The default, is to
 * request out-of-bounds tiles from the server. When set to `false`, only one
 * world will be rendered. When set to `true`, tiles will be requested for one
 * world only, but they will be wrapped horizontally to render multiple worlds.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {string} [key] Optional tile key for proper cache fetching
 */


/**
 * @classdesc
 * Base class for sources providing images divided into a tile grid.
 *
 * @fires import("./Tile.js").TileSourceEvent
 * @api
 */
var TileImage = /*@__PURE__*/(function (UrlTile) {
  function TileImage(options) {

    UrlTile.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      opaque: options.opaque,
      projection: options.projection,
      state: options.state,
      tileGrid: options.tileGrid,
      tileLoadFunction: options.tileLoadFunction ?
        options.tileLoadFunction : defaultTileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX,
      transition: options.transition,
      key: options.key,
      attributionsCollapsible: options.attributionsCollapsible
    });

    /**
     * @protected
     * @type {?string}
     */
    this.crossOrigin =
        options.crossOrigin !== undefined ? options.crossOrigin : null;

    /**
     * @protected
     * @type {typeof ImageTile}
     */
    this.tileClass = options.tileClass !== undefined ?
      options.tileClass : _ImageTile_js__WEBPACK_IMPORTED_MODULE_2__["default"];

    /**
     * @protected
     * @type {!Object<string, TileCache>}
     */
    this.tileCacheForProjection = {};

    /**
     * @protected
     * @type {!Object<string, import("../tilegrid/TileGrid.js").default>}
     */
    this.tileGridForProjection = {};

    /**
     * @private
     * @type {number|undefined}
     */
    this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;

    /**
     * @private
     * @type {boolean}
     */
    this.renderReprojectionEdges_ = false;
  }

  if ( UrlTile ) TileImage.__proto__ = UrlTile;
  TileImage.prototype = Object.create( UrlTile && UrlTile.prototype );
  TileImage.prototype.constructor = TileImage;

  /**
   * @inheritDoc
   */
  TileImage.prototype.canExpireCache = function canExpireCache () {
    if (!_reproj_common_js__WEBPACK_IMPORTED_MODULE_0__["ENABLE_RASTER_REPROJECTION"]) {
      return UrlTile.prototype.canExpireCache.call(this);
    }
    if (this.tileCache.canExpireCache()) {
      return true;
    } else {
      for (var key in this.tileCacheForProjection) {
        if (this.tileCacheForProjection[key].canExpireCache()) {
          return true;
        }
      }
    }
    return false;
  };

  /**
   * @inheritDoc
   */
  TileImage.prototype.expireCache = function expireCache (projection, usedTiles) {
    if (!_reproj_common_js__WEBPACK_IMPORTED_MODULE_0__["ENABLE_RASTER_REPROJECTION"]) {
      UrlTile.prototype.expireCache.call(this, projection, usedTiles);
      return;
    }
    var usedTileCache = this.getTileCacheForProjection(projection);

    this.tileCache.expireCache(this.tileCache == usedTileCache ? usedTiles : {});
    for (var id in this.tileCacheForProjection) {
      var tileCache = this.tileCacheForProjection[id];
      tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});
    }
  };

  /**
   * @inheritDoc
   */
  TileImage.prototype.getGutterForProjection = function getGutterForProjection (projection) {
    if (_reproj_common_js__WEBPACK_IMPORTED_MODULE_0__["ENABLE_RASTER_REPROJECTION"] &&
        this.getProjection() && projection && !Object(_proj_js__WEBPACK_IMPORTED_MODULE_7__["equivalent"])(this.getProjection(), projection)) {
      return 0;
    } else {
      return this.getGutter();
    }
  };

  /**
   * @return {number} Gutter.
   */
  TileImage.prototype.getGutter = function getGutter () {
    return 0;
  };

  /**
   * @inheritDoc
   */
  TileImage.prototype.getOpaque = function getOpaque (projection) {
    if (_reproj_common_js__WEBPACK_IMPORTED_MODULE_0__["ENABLE_RASTER_REPROJECTION"] &&
        this.getProjection() && projection && !Object(_proj_js__WEBPACK_IMPORTED_MODULE_7__["equivalent"])(this.getProjection(), projection)) {
      return false;
    } else {
      return UrlTile.prototype.getOpaque.call(this, projection);
    }
  };

  /**
   * @inheritDoc
   */
  TileImage.prototype.getTileGridForProjection = function getTileGridForProjection$1 (projection) {
    if (!_reproj_common_js__WEBPACK_IMPORTED_MODULE_0__["ENABLE_RASTER_REPROJECTION"]) {
      return UrlTile.prototype.getTileGridForProjection.call(this, projection);
    }
    var thisProj = this.getProjection();
    if (this.tileGrid && (!thisProj || Object(_proj_js__WEBPACK_IMPORTED_MODULE_7__["equivalent"])(thisProj, projection))) {
      return this.tileGrid;
    } else {
      var projKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_1__["getUid"])(projection);
      if (!(projKey in this.tileGridForProjection)) {
        this.tileGridForProjection[projKey] = Object(_tilegrid_js__WEBPACK_IMPORTED_MODULE_11__["getForProjection"])(projection);
      }
      return (
        /** @type {!import("../tilegrid/TileGrid.js").default} */ (this.tileGridForProjection[projKey])
      );
    }
  };

  /**
   * @inheritDoc
   */
  TileImage.prototype.getTileCacheForProjection = function getTileCacheForProjection (projection) {
    if (!_reproj_common_js__WEBPACK_IMPORTED_MODULE_0__["ENABLE_RASTER_REPROJECTION"]) {
      return UrlTile.prototype.getTileCacheForProjection.call(this, projection);
    }
    var thisProj = this.getProjection(); if (!thisProj || Object(_proj_js__WEBPACK_IMPORTED_MODULE_7__["equivalent"])(thisProj, projection)) {
      return this.tileCache;
    } else {
      var projKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_1__["getUid"])(projection);
      if (!(projKey in this.tileCacheForProjection)) {
        this.tileCacheForProjection[projKey] = new _TileCache_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.tileCache.highWaterMark);
      }
      return this.tileCacheForProjection[projKey];
    }
  };

  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {string} key The key set on the tile.
   * @return {!import("../Tile.js").default} Tile.
   * @private
   */
  TileImage.prototype.createTile_ = function createTile_ (z, x, y, pixelRatio, projection, key) {
    var tileCoord = [z, x, y];
    var urlTileCoord = this.getTileCoordForTileUrlFunction(
      tileCoord, projection);
    var tileUrl = urlTileCoord ?
      this.tileUrlFunction(urlTileCoord, pixelRatio, projection) : undefined;
    var tile = new this.tileClass(
      tileCoord,
      tileUrl !== undefined ? _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].IDLE : _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].EMPTY,
      tileUrl !== undefined ? tileUrl : '',
      this.crossOrigin,
      this.tileLoadFunction,
      this.tileOptions);
    tile.key = key;
    Object(_events_js__WEBPACK_IMPORTED_MODULE_5__["listen"])(tile, _events_EventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].CHANGE,
      this.handleTileChange, this);
    return tile;
  };

  /**
   * @inheritDoc
   */
  TileImage.prototype.getTile = function getTile (z, x, y, pixelRatio, projection) {
    var sourceProjection = /** @type {!import("../proj/Projection.js").default} */ (this.getProjection());
    if (!_reproj_common_js__WEBPACK_IMPORTED_MODULE_0__["ENABLE_RASTER_REPROJECTION"] ||
        !sourceProjection || !projection || Object(_proj_js__WEBPACK_IMPORTED_MODULE_7__["equivalent"])(sourceProjection, projection)) {
      return this.getTileInternal(z, x, y, pixelRatio, sourceProjection || projection);
    } else {
      var cache = this.getTileCacheForProjection(projection);
      var tileCoord = [z, x, y];
      var tile;
      var tileCoordKey = Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_10__["getKey"])(tileCoord);
      if (cache.containsKey(tileCoordKey)) {
        tile = /** @type {!import("../Tile.js").default} */ (cache.get(tileCoordKey));
      }
      var key = this.getKey();
      if (tile && tile.key == key) {
        return tile;
      } else {
        var sourceTileGrid = this.getTileGridForProjection(sourceProjection);
        var targetTileGrid = this.getTileGridForProjection(projection);
        var wrappedTileCoord =
            this.getTileCoordForTileUrlFunction(tileCoord, projection);
        var newTile = new _reproj_Tile_js__WEBPACK_IMPORTED_MODULE_8__["default"](
          sourceProjection, sourceTileGrid,
          projection, targetTileGrid,
          tileCoord, wrappedTileCoord, this.getTilePixelRatio(pixelRatio),
          this.getGutter(),
          function(z, x, y, pixelRatio) {
            return this.getTileInternal(z, x, y, pixelRatio, sourceProjection);
          }.bind(this), this.reprojectionErrorThreshold_,
          this.renderReprojectionEdges_);
        newTile.key = key;

        if (tile) {
          newTile.interimTile = tile;
          newTile.refreshInterimChain();
          cache.replace(tileCoordKey, newTile);
        } else {
          cache.set(tileCoordKey, newTile);
        }
        return newTile;
      }
    }
  };

  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {!import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../Tile.js").default} Tile.
   * @protected
   */
  TileImage.prototype.getTileInternal = function getTileInternal (z, x, y, pixelRatio, projection) {
    var tile = null;
    var tileCoordKey = Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_10__["getKeyZXY"])(z, x, y);
    var key = this.getKey();
    if (!this.tileCache.containsKey(tileCoordKey)) {
      tile = this.createTile_(z, x, y, pixelRatio, projection, key);
      this.tileCache.set(tileCoordKey, tile);
    } else {
      tile = this.tileCache.get(tileCoordKey);
      if (tile.key != key) {
        // The source's params changed. If the tile has an interim tile and if we
        // can use it then we use it. Otherwise we create a new tile.  In both
        // cases we attempt to assign an interim tile to the new tile.
        var interimTile = tile;
        tile = this.createTile_(z, x, y, pixelRatio, projection, key);

        //make the new tile the head of the list,
        if (interimTile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].IDLE) {
          //the old tile hasn't begun loading yet, and is now outdated, so we can simply discard it
          tile.interimTile = interimTile.interimTile;
        } else {
          tile.interimTile = interimTile;
        }
        tile.refreshInterimChain();
        this.tileCache.replace(tileCoordKey, tile);
      }
    }
    return tile;
  };

  /**
   * Sets whether to render reprojection edges or not (usually for debugging).
   * @param {boolean} render Render the edges.
   * @api
   */
  TileImage.prototype.setRenderReprojectionEdges = function setRenderReprojectionEdges (render) {
    if (!_reproj_common_js__WEBPACK_IMPORTED_MODULE_0__["ENABLE_RASTER_REPROJECTION"] ||
        this.renderReprojectionEdges_ == render) {
      return;
    }
    this.renderReprojectionEdges_ = render;
    for (var id in this.tileCacheForProjection) {
      this.tileCacheForProjection[id].clear();
    }
    this.changed();
  };

  /**
   * Sets the tile grid to use when reprojecting the tiles to the given
   * projection instead of the default tile grid for the projection.
   *
   * This can be useful when the default tile grid cannot be created
   * (e.g. projection has no extent defined) or
   * for optimization reasons (custom tile size, resolutions, ...).
   *
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
   * @api
   */
  TileImage.prototype.setTileGridForProjection = function setTileGridForProjection (projection, tilegrid) {
    if (_reproj_common_js__WEBPACK_IMPORTED_MODULE_0__["ENABLE_RASTER_REPROJECTION"]) {
      var proj = Object(_proj_js__WEBPACK_IMPORTED_MODULE_7__["get"])(projection);
      if (proj) {
        var projKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_1__["getUid"])(proj);
        if (!(projKey in this.tileGridForProjection)) {
          this.tileGridForProjection[projKey] = tilegrid;
        }
      }
    }
  };

  return TileImage;
}(_UrlTile_js__WEBPACK_IMPORTED_MODULE_9__["default"]));


/**
 * @param {ImageTile} imageTile Image tile.
 * @param {string} src Source.
 */
function defaultTileLoadFunction(imageTile, src) {
  /** @type {HTMLImageElement|HTMLVideoElement} */ (imageTile.getImage()).src = src;
}

/* harmony default export */ __webpack_exports__["default"] = (TileImage);

//# sourceMappingURL=TileImage.js.map

/***/ }),

/***/ "./node_modules/ol/source/UrlTile.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/source/UrlTile.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tileurlfunction.js */ "./node_modules/ol/tileurlfunction.js");
/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Tile.js */ "./node_modules/ol/source/Tile.js");
/* harmony import */ var _TileEventType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./TileEventType.js */ "./node_modules/ol/source/TileEventType.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");
/**
 * @module ol/source/UrlTile
 */







/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions]
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize]
 * @property {boolean} [opaque]
 * @property {import("../proj.js").ProjectionLike} [projection]
 * @property {import("./State.js").default} [state]
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid]
 * @property {import("../Tile.js").LoadFunction} tileLoadFunction
 * @property {number} [tilePixelRatio]
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction]
 * @property {string} [url]
 * @property {Array<string>} [urls]
 * @property {boolean} [wrapX=true]
 * @property {number} [transition]
 * @property {string} [key]
 */


/**
 * @classdesc
 * Base class for sources providing tiles divided into a tile grid over http.
 *
 * @fires import("./Tile.js").TileSourceEvent
 */
var UrlTile = /*@__PURE__*/(function (TileSource) {
  function UrlTile(options) {

    TileSource.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      opaque: options.opaque,
      projection: options.projection,
      state: options.state,
      tileGrid: options.tileGrid,
      tilePixelRatio: options.tilePixelRatio,
      wrapX: options.wrapX,
      transition: options.transition,
      key: options.key,
      attributionsCollapsible: options.attributionsCollapsible
    });

    /**
     * @private
     * @type {boolean}
     */
    this.generateTileUrlFunction_ = !options.tileUrlFunction;

    /**
     * @protected
     * @type {import("../Tile.js").LoadFunction}
     */
    this.tileLoadFunction = options.tileLoadFunction;

    /**
     * @protected
     * @type {import("../Tile.js").UrlFunction}
     */
    this.tileUrlFunction = options.tileUrlFunction ? options.tileUrlFunction.bind(this) : _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_2__["nullTileUrlFunction"];

    /**
     * @protected
     * @type {!Array<string>|null}
     */
    this.urls = null;

    if (options.urls) {
      this.setUrls(options.urls);
    } else if (options.url) {
      this.setUrl(options.url);
    }

    if (options.tileUrlFunction) {
      this.setTileUrlFunction(options.tileUrlFunction, this.key_);
    }

    /**
     * @private
     * @type {!Object<string, boolean>}
     */
    this.tileLoadingKeys_ = {};

  }

  if ( TileSource ) UrlTile.__proto__ = TileSource;
  UrlTile.prototype = Object.create( TileSource && TileSource.prototype );
  UrlTile.prototype.constructor = UrlTile;

  /**
   * Return the tile load function of the source.
   * @return {import("../Tile.js").LoadFunction} TileLoadFunction
   * @api
   */
  UrlTile.prototype.getTileLoadFunction = function getTileLoadFunction () {
    return this.tileLoadFunction;
  };

  /**
   * Return the tile URL function of the source.
   * @return {import("../Tile.js").UrlFunction} TileUrlFunction
   * @api
   */
  UrlTile.prototype.getTileUrlFunction = function getTileUrlFunction () {
    return this.tileUrlFunction;
  };

  /**
   * Return the URLs used for this source.
   * When a tileUrlFunction is used instead of url or urls,
   * null will be returned.
   * @return {!Array<string>|null} URLs.
   * @api
   */
  UrlTile.prototype.getUrls = function getUrls () {
    return this.urls;
  };

  /**
   * Handle tile change events.
   * @param {import("../events/Event.js").default} event Event.
   * @protected
   */
  UrlTile.prototype.handleTileChange = function handleTileChange (event) {
    var tile = /** @type {import("../Tile.js").default} */ (event.target);
    var uid = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(tile);
    var tileState = tile.getState();
    var type;
    if (tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING) {
      this.tileLoadingKeys_[uid] = true;
      type = _TileEventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].TILELOADSTART;
    } else if (uid in this.tileLoadingKeys_) {
      delete this.tileLoadingKeys_[uid];
      type = tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR ? _TileEventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].TILELOADERROR :
        (tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED || tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ABORT) ?
          _TileEventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].TILELOADEND : undefined;
    }
    if (type != undefined) {
      this.dispatchEvent(new _Tile_js__WEBPACK_IMPORTED_MODULE_3__["TileSourceEvent"](type, tile));
    }
  };

  /**
   * Set the tile load function of the source.
   * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @api
   */
  UrlTile.prototype.setTileLoadFunction = function setTileLoadFunction (tileLoadFunction) {
    this.tileCache.clear();
    this.tileLoadFunction = tileLoadFunction;
    this.changed();
  };

  /**
   * Set the tile URL function of the source.
   * @param {import("../Tile.js").UrlFunction} tileUrlFunction Tile URL function.
   * @param {string=} key Optional new tile key for the source.
   * @api
   */
  UrlTile.prototype.setTileUrlFunction = function setTileUrlFunction (tileUrlFunction, key) {
    this.tileUrlFunction = tileUrlFunction;
    this.tileCache.pruneExceptNewestZ();
    if (typeof key !== 'undefined') {
      this.setKey(key);
    } else {
      this.changed();
    }
  };

  /**
   * Set the URL to use for requests.
   * @param {string} url URL.
   * @api
   */
  UrlTile.prototype.setUrl = function setUrl (url) {
    var urls = this.urls = Object(_tileurlfunction_js__WEBPACK_IMPORTED_MODULE_2__["expandUrl"])(url);
    this.setUrls(urls);
  };

  /**
   * Set the URLs to use for requests.
   * @param {Array<string>} urls URLs.
   * @api
   */
  UrlTile.prototype.setUrls = function setUrls (urls) {
    this.urls = urls;
    var key = urls.join('\n');
    if (this.generateTileUrlFunction_) {
      this.setTileUrlFunction(Object(_tileurlfunction_js__WEBPACK_IMPORTED_MODULE_2__["createFromTemplates"])(urls, this.tileGrid), key);
    } else {
      this.setKey(key);
    }
  };

  /**
   * @inheritDoc
   */
  UrlTile.prototype.useTile = function useTile (z, x, y) {
    var tileCoordKey = Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_5__["getKeyZXY"])(z, x, y);
    if (this.tileCache.containsKey(tileCoordKey)) {
      this.tileCache.get(tileCoordKey);
    }
  };

  return UrlTile;
}(_Tile_js__WEBPACK_IMPORTED_MODULE_3__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (UrlTile);

//# sourceMappingURL=UrlTile.js.map

/***/ }),

/***/ "./node_modules/ol/source/Vector.js":
/*!******************************************!*\
  !*** ./node_modules/ol/source/Vector.js ***!
  \******************************************/
/*! exports provided: VectorSourceEvent, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VectorSourceEvent", function() { return VectorSourceEvent; });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Collection.js */ "./node_modules/ol/Collection.js");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../CollectionEventType.js */ "./node_modules/ol/CollectionEventType.js");
/* harmony import */ var _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ObjectEventType.js */ "./node_modules/ol/ObjectEventType.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _featureloader_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../featureloader.js */ "./node_modules/ol/featureloader.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _loadingstrategy_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../loadingstrategy.js */ "./node_modules/ol/loadingstrategy.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _Source_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Source.js */ "./node_modules/ol/source/Source.js");
/* harmony import */ var _State_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./State.js */ "./node_modules/ol/source/State.js");
/* harmony import */ var _VectorEventType_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./VectorEventType.js */ "./node_modules/ol/source/VectorEventType.js");
/* harmony import */ var _structs_RBush_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../structs/RBush.js */ "./node_modules/ol/structs/RBush.js");
/**
 * @module ol/source/Vector
 */




















/**
 * A function that takes an {@link module:ol/extent~Extent} and a resolution as arguments, and
 * returns an array of {@link module:ol/extent~Extent} with the extents to load. Usually this
 * is one of the standard {@link module:ol/loadingstrategy} strategies.
 *
 * @typedef {function(import("../extent.js").Extent, number): Array<import("../extent.js").Extent>} LoadingStrategy
 * @api
 */


/**
 * @classdesc
 * Events emitted by {@link module:ol/source/Vector} instances are instances of this
 * type.
 */
var VectorSourceEvent = /*@__PURE__*/(function (Event) {
  function VectorSourceEvent(type, opt_feature) {

    Event.call(this, type);

    /**
     * The feature being added or removed.
     * @type {import("../Feature.js").default|undefined}
     * @api
     */
    this.feature = opt_feature;

  }

  if ( Event ) VectorSourceEvent.__proto__ = Event;
  VectorSourceEvent.prototype = Object.create( Event && Event.prototype );
  VectorSourceEvent.prototype.constructor = VectorSourceEvent;

  return VectorSourceEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_7__["default"]));


/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {Array<import("../Feature.js").default>|Collection<import("../Feature.js").default>} [features]
 * Features. If provided as {@link module:ol/Collection}, the features in the source
 * and the collection will stay in sync.
 * @property {import("../format/Feature.js").default} [format] The feature format used by the XHR
 * feature loader when `url` is set. Required if `url` is set, otherwise ignored.
 * @property {import("../featureloader.js").FeatureLoader} [loader]
 * The loader function used to load features, from a remote source for example.
 * If this is not set and `url` is set, the source will create and use an XHR
 * feature loader.
 *
 * Example:
 *
 * ```js
 * import {Vector} from 'ol/source';
 * import {GeoJSON} from 'ol/format';
 * import {bbox} from 'ol/loadingstrategy';
 *
 * var vectorSource = new Vector({
 *   format: new GeoJSON(),
 *   loader: function(extent, resolution, projection) {
 *      var proj = projection.getCode();
 *      var url = 'https://ahocevar.com/geoserver/wfs?service=WFS&' +
 *          'version=1.1.0&request=GetFeature&typename=osm:water_areas&' +
 *          'outputFormat=application/json&srsname=' + proj + '&' +
 *          'bbox=' + extent.join(',') + ',' + proj;
 *      var xhr = new XMLHttpRequest();
 *      xhr.open('GET', url);
 *      var onError = function() {
 *        vectorSource.removeLoadedExtent(extent);
 *      }
 *      xhr.onerror = onError;
 *      xhr.onload = function() {
 *        if (xhr.status == 200) {
 *          vectorSource.addFeatures(
 *              vectorSource.getFormat().readFeatures(xhr.responseText));
 *        } else {
 *          onError();
 *        }
 *      }
 *      xhr.send();
 *    },
 *    strategy: bbox
 *  });
 * ```
 * @property {boolean} [overlaps=true] This source may have overlapping geometries.
 * Setting this to `false` (e.g. for sources with polygons that represent administrative
 * boundaries or TopoJSON sources) allows the renderer to optimise fill and
 * stroke operations.
 * @property {LoadingStrategy} [strategy] The loading strategy to use.
 * By default an {@link module:ol/loadingstrategy~all}
 * strategy is used, a one-off strategy which loads all features at once.
 * @property {string|import("../featureloader.js").FeatureUrlFunction} [url]
 * Setting this option instructs the source to load features using an XHR loader
 * (see {@link module:ol/featureloader~xhr}). Use a `string` and an
 * {@link module:ol/loadingstrategy~all} for a one-off download of all features from
 * the given URL. Use a {@link module:ol/featureloader~FeatureUrlFunction} to generate the url with
 * other loading strategies.
 * Requires `format` to be set as well.
 * When default XHR feature loader is provided, the features will
 * be transformed from the data projection to the view projection
 * during parsing. If your remote data source does not advertise its projection
 * properly, this transformation will be incorrect. For some formats, the
 * default projection (usually EPSG:4326) can be overridden by setting the
 * dataProjection constructor option on the format.
 * Note that if a source contains non-feature data, such as a GeoJSON geometry
 * or a KML NetworkLink, these will be ignored. Use a custom loader to load these.
 * @property {boolean} [useSpatialIndex=true]
 * By default, an RTree is used as spatial index. When features are removed and
 * added frequently, and the total number of features is low, setting this to
 * `false` may improve performance.
 *
 * Note that
 * {@link module:ol/source/Vector~VectorSource#getFeaturesInExtent},
 * {@link module:ol/source/Vector~VectorSource#getClosestFeatureToCoordinate} and
 * {@link module:ol/source/Vector~VectorSource#getExtent} cannot be used when `useSpatialIndex` is
 * set to `false`, and {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent} will loop
 * through all features.
 *
 * When set to `false`, the features will be maintained in an
 * {@link module:ol/Collection}, which can be retrieved through
 * {@link module:ol/source/Vector~VectorSource#getFeaturesCollection}.
 * @property {boolean} [wrapX=true] Wrap the world horizontally. For vector editing across the
 * -180° and 180° meridians to work properly, this should be set to `false`. The
 * resulting geometry coordinates will then exceed the world bounds.
 */


/**
 * @classdesc
 * Provides a source of features for vector layers. Vector features provided
 * by this source are suitable for editing. See {@link module:ol/source/VectorTile~VectorTile} for
 * vector data that is optimized for rendering.
 *
 * @fires ol/source/Vector.VectorSourceEvent
 * @api
 */
var VectorSource = /*@__PURE__*/(function (Source) {
  function VectorSource(opt_options) {

    var options = opt_options || {};

    Source.call(this, {
      attributions: options.attributions,
      projection: undefined,
      state: _State_js__WEBPACK_IMPORTED_MODULE_15__["default"].READY,
      wrapX: options.wrapX !== undefined ? options.wrapX : true
    });

    /**
     * @private
     * @type {import("../featureloader.js").FeatureLoader}
     */
    this.loader_ = _functions_js__WEBPACK_IMPORTED_MODULE_11__["VOID"];

    /**
     * @private
     * @type {import("../format/Feature.js").default|undefined}
     */
    this.format_ = options.format;

    /**
     * @private
     * @type {boolean}
     */
    this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;

    /**
     * @private
     * @type {string|import("../featureloader.js").FeatureUrlFunction|undefined}
     */
    this.url_ = options.url;

    if (options.loader !== undefined) {
      this.loader_ = options.loader;
    } else if (this.url_ !== undefined) {
      Object(_asserts_js__WEBPACK_IMPORTED_MODULE_5__["assert"])(this.format_, 7); // `format` must be set when `url` is set
      // create a XHR feature loader for "url" and "format"
      this.loader_ = Object(_featureloader_js__WEBPACK_IMPORTED_MODULE_10__["xhr"])(this.url_, /** @type {import("../format/Feature.js").default} */ (this.format_));
    }

    /**
     * @private
     * @type {LoadingStrategy}
     */
    this.strategy_ = options.strategy !== undefined ? options.strategy : _loadingstrategy_js__WEBPACK_IMPORTED_MODULE_12__["all"];

    var useSpatialIndex =
        options.useSpatialIndex !== undefined ? options.useSpatialIndex : true;

    /**
     * @private
     * @type {RBush<import("../Feature.js").default>}
     */
    this.featuresRtree_ = useSpatialIndex ? new _structs_RBush_js__WEBPACK_IMPORTED_MODULE_17__["default"]() : null;

    /**
     * @private
     * @type {RBush<{extent: import("../extent.js").Extent}>}
     */
    this.loadedExtentsRtree_ = new _structs_RBush_js__WEBPACK_IMPORTED_MODULE_17__["default"]();

    /**
     * @private
     * @type {!Object<string, import("../Feature.js").default>}
     */
    this.nullGeometryFeatures_ = {};

    /**
     * A lookup of features by id (the return from feature.getId()).
     * @private
     * @type {!Object<string, import("../Feature.js").default>}
     */
    this.idIndex_ = {};

    /**
     * A lookup of features without id (keyed by getUid(feature)).
     * @private
     * @type {!Object<string, import("../Feature.js").default>}
     */
    this.undefIdIndex_ = {};

    /**
     * @private
     * @type {Object<string, Array<import("../events.js").EventsKey>>}
     */
    this.featureChangeKeys_ = {};

    /**
     * @private
     * @type {Collection<import("../Feature.js").default>}
     */
    this.featuresCollection_ = null;

    var collection, features;
    if (Array.isArray(options.features)) {
      features = options.features;
    } else if (options.features) {
      collection = options.features;
      features = collection.getArray();
    }
    if (!useSpatialIndex && collection === undefined) {
      collection = new _Collection_js__WEBPACK_IMPORTED_MODULE_1__["default"](features);
    }
    if (features !== undefined) {
      this.addFeaturesInternal(features);
    }
    if (collection !== undefined) {
      this.bindFeaturesCollection_(collection);
    }

  }

  if ( Source ) VectorSource.__proto__ = Source;
  VectorSource.prototype = Object.create( Source && Source.prototype );
  VectorSource.prototype.constructor = VectorSource;

  /**
   * Add a single feature to the source.  If you want to add a batch of features
   * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
   * instead. A feature will not be added to the source if feature with
   * the same id is already there. The reason for this behavior is to avoid
   * feature duplication when using bbox or tile loading strategies.
   * @param {import("../Feature.js").default} feature Feature to add.
   * @api
   */
  VectorSource.prototype.addFeature = function addFeature (feature) {
    this.addFeatureInternal(feature);
    this.changed();
  };


  /**
   * Add a feature without firing a `change` event.
   * @param {import("../Feature.js").default} feature Feature.
   * @protected
   */
  VectorSource.prototype.addFeatureInternal = function addFeatureInternal (feature) {
    var featureKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature);

    if (!this.addToIndex_(featureKey, feature)) {
      return;
    }

    this.setupChangeEvents_(featureKey, feature);

    var geometry = feature.getGeometry();
    if (geometry) {
      var extent = geometry.getExtent();
      if (this.featuresRtree_) {
        this.featuresRtree_.insert(extent, feature);
      }
    } else {
      this.nullGeometryFeatures_[featureKey] = feature;
    }

    this.dispatchEvent(
      new VectorSourceEvent(_VectorEventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].ADDFEATURE, feature));
  };


  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {import("../Feature.js").default} feature The feature.
   * @private
   */
  VectorSource.prototype.setupChangeEvents_ = function setupChangeEvents_ (featureKey, feature) {
    this.featureChangeKeys_[featureKey] = [
      Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(feature, _events_EventType_js__WEBPACK_IMPORTED_MODULE_8__["default"].CHANGE,
        this.handleFeatureChange_, this),
      Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(feature, _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].PROPERTYCHANGE,
        this.handleFeatureChange_, this)
    ];
  };


  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {import("../Feature.js").default} feature The feature.
   * @return {boolean} The feature is "valid", in the sense that it is also a
   *     candidate for insertion into the Rtree.
   * @private
   */
  VectorSource.prototype.addToIndex_ = function addToIndex_ (featureKey, feature) {
    var valid = true;
    var id = feature.getId();
    if (id !== undefined) {
      if (!(id.toString() in this.idIndex_)) {
        this.idIndex_[id.toString()] = feature;
      } else {
        valid = false;
      }
    } else {
      Object(_asserts_js__WEBPACK_IMPORTED_MODULE_5__["assert"])(!(featureKey in this.undefIdIndex_),
        30); // The passed `feature` was already added to the source
      this.undefIdIndex_[featureKey] = feature;
    }
    return valid;
  };


  /**
   * Add a batch of features to the source.
   * @param {Array<import("../Feature.js").default>} features Features to add.
   * @api
   */
  VectorSource.prototype.addFeatures = function addFeatures (features) {
    this.addFeaturesInternal(features);
    this.changed();
  };


  /**
   * Add features without firing a `change` event.
   * @param {Array<import("../Feature.js").default>} features Features.
   * @protected
   */
  VectorSource.prototype.addFeaturesInternal = function addFeaturesInternal (features) {
    var extents = [];
    var newFeatures = [];
    var geometryFeatures = [];

    for (var i = 0, length = features.length; i < length; i++) {
      var feature = features[i];
      var featureKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature);
      if (this.addToIndex_(featureKey, feature)) {
        newFeatures.push(feature);
      }
    }

    for (var i$1 = 0, length$1 = newFeatures.length; i$1 < length$1; i$1++) {
      var feature$1 = newFeatures[i$1];
      var featureKey$1 = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature$1);
      this.setupChangeEvents_(featureKey$1, feature$1);

      var geometry = feature$1.getGeometry();
      if (geometry) {
        var extent = geometry.getExtent();
        extents.push(extent);
        geometryFeatures.push(feature$1);
      } else {
        this.nullGeometryFeatures_[featureKey$1] = feature$1;
      }
    }
    if (this.featuresRtree_) {
      this.featuresRtree_.load(extents, geometryFeatures);
    }

    for (var i$2 = 0, length$2 = newFeatures.length; i$2 < length$2; i$2++) {
      this.dispatchEvent(new VectorSourceEvent(_VectorEventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].ADDFEATURE, newFeatures[i$2]));
    }
  };


  /**
   * @param {!Collection<import("../Feature.js").default>} collection Collection.
   * @private
   */
  VectorSource.prototype.bindFeaturesCollection_ = function bindFeaturesCollection_ (collection) {
    var modifyingCollection = false;
    Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(this, _VectorEventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].ADDFEATURE,
      /**
       * @param {VectorSourceEvent} evt The vector source event
       */
      function(evt) {
        if (!modifyingCollection) {
          modifyingCollection = true;
          collection.push(evt.feature);
          modifyingCollection = false;
        }
      });
    Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(this, _VectorEventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].REMOVEFEATURE,
      /**
       * @param {VectorSourceEvent} evt The vector source event
       */
      function(evt) {
        if (!modifyingCollection) {
          modifyingCollection = true;
          collection.remove(evt.feature);
          modifyingCollection = false;
        }
      });
    Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(collection, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].ADD,
      /**
       * @param {import("../Collection.js").CollectionEvent} evt The collection event
       */
      function(evt) {
        if (!modifyingCollection) {
          modifyingCollection = true;
          this.addFeature(/** @type {import("../Feature.js").default} */ (evt.element));
          modifyingCollection = false;
        }
      }, this);
    Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(collection, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].REMOVE,
      /**
       * @param {import("../Collection.js").CollectionEvent} evt The collection event
       */
      function(evt) {
        if (!modifyingCollection) {
          modifyingCollection = true;
          this.removeFeature(/** @type {import("../Feature.js").default} */ (evt.element));
          modifyingCollection = false;
        }
      }, this);
    this.featuresCollection_ = collection;
  };


  /**
   * Remove all features from the source.
   * @param {boolean=} opt_fast Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#removefeature} events.
   * @api
   */
  VectorSource.prototype.clear = function clear (opt_fast) {
    if (opt_fast) {
      for (var featureId in this.featureChangeKeys_) {
        var keys = this.featureChangeKeys_[featureId];
        keys.forEach(_events_js__WEBPACK_IMPORTED_MODULE_6__["unlistenByKey"]);
      }
      if (!this.featuresCollection_) {
        this.featureChangeKeys_ = {};
        this.idIndex_ = {};
        this.undefIdIndex_ = {};
      }
    } else {
      if (this.featuresRtree_) {
        this.featuresRtree_.forEach(this.removeFeatureInternal, this);
        for (var id in this.nullGeometryFeatures_) {
          this.removeFeatureInternal(this.nullGeometryFeatures_[id]);
        }
      }
    }
    if (this.featuresCollection_) {
      this.featuresCollection_.clear();
    }

    if (this.featuresRtree_) {
      this.featuresRtree_.clear();
    }
    this.loadedExtentsRtree_.clear();
    this.nullGeometryFeatures_ = {};

    var clearEvent = new VectorSourceEvent(_VectorEventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].CLEAR);
    this.dispatchEvent(clearEvent);
    this.changed();
  };


  /**
   * Iterate through all features on the source, calling the provided callback
   * with each one.  If the callback returns any "truthy" value, iteration will
   * stop and the function will return the same value.
   * Note: this function only iterate through the feature that have a defined geometry.
   *
   * @param {function(import("../Feature.js").default): T} callback Called with each feature
   *     on the source.  Return a truthy value to stop iteration.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  VectorSource.prototype.forEachFeature = function forEachFeature (callback) {
    if (this.featuresRtree_) {
      return this.featuresRtree_.forEach(callback);
    } else if (this.featuresCollection_) {
      this.featuresCollection_.forEach(callback);
    }
  };


  /**
   * Iterate through all features whose geometries contain the provided
   * coordinate, calling the callback with each feature.  If the callback returns
   * a "truthy" value, iteration will stop and the function will return the same
   * value.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(import("../Feature.js").default): T} callback Called with each feature
   *     whose goemetry contains the provided coordinate.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   */
  VectorSource.prototype.forEachFeatureAtCoordinateDirect = function forEachFeatureAtCoordinateDirect (coordinate, callback) {
    var extent = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];
    return this.forEachFeatureInExtent(extent, function(feature) {
      var geometry = feature.getGeometry();
      if (geometry.intersectsCoordinate(coordinate)) {
        return callback(feature);
      } else {
        return undefined;
      }
    });
  };


  /**
   * Iterate through all features whose bounding box intersects the provided
   * extent (note that the feature's geometry may not intersect the extent),
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you are interested in features whose geometry intersects an extent, call
   * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
   *
   * When `useSpatialIndex` is set to false, this method will loop through all
   * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(import("../Feature.js").default): T} callback Called with each feature
   *     whose bounding box intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  VectorSource.prototype.forEachFeatureInExtent = function forEachFeatureInExtent (extent, callback) {
    if (this.featuresRtree_) {
      return this.featuresRtree_.forEachInExtent(extent, callback);
    } else if (this.featuresCollection_) {
      this.featuresCollection_.forEach(callback);
    }
  };


  /**
   * Iterate through all features whose geometry intersects the provided extent,
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you only want to test for bounding box intersection, call the
   * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(import("../Feature.js").default): T} callback Called with each feature
   *     whose geometry intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  VectorSource.prototype.forEachFeatureIntersectingExtent = function forEachFeatureIntersectingExtent (extent, callback) {
    return this.forEachFeatureInExtent(extent,
      /**
       * @param {import("../Feature.js").default} feature Feature.
       * @return {T|undefined} The return value from the last call to the callback.
       */
      function(feature) {
        var geometry = feature.getGeometry();
        if (geometry.intersectsExtent(extent)) {
          var result = callback(feature);
          if (result) {
            return result;
          }
        }
      });
  };


  /**
   * Get the features collection associated with this source. Will be `null`
   * unless the source was configured with `useSpatialIndex` set to `false`, or
   * with an {@link module:ol/Collection} as `features`.
   * @return {Collection<import("../Feature.js").default>} The collection of features.
   * @api
   */
  VectorSource.prototype.getFeaturesCollection = function getFeaturesCollection () {
    return this.featuresCollection_;
  };


  /**
   * Get all features on the source in random order.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */
  VectorSource.prototype.getFeatures = function getFeatures () {
    var features;
    if (this.featuresCollection_) {
      features = this.featuresCollection_.getArray();
    } else if (this.featuresRtree_) {
      features = this.featuresRtree_.getAll();
      if (!Object(_obj_js__WEBPACK_IMPORTED_MODULE_13__["isEmpty"])(this.nullGeometryFeatures_)) {
        Object(_array_js__WEBPACK_IMPORTED_MODULE_4__["extend"])(features, Object(_obj_js__WEBPACK_IMPORTED_MODULE_13__["getValues"])(this.nullGeometryFeatures_));
      }
    }
    return (
      /** @type {Array<import("../Feature.js").default>} */ (features)
    );
  };


  /**
   * Get all features whose geometry intersects the provided coordinate.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */
  VectorSource.prototype.getFeaturesAtCoordinate = function getFeaturesAtCoordinate (coordinate) {
    var features = [];
    this.forEachFeatureAtCoordinateDirect(coordinate, function(feature) {
      features.push(feature);
    });
    return features;
  };


  /**
   * Get all features in the provided extent.  Note that this returns an array of
   * all features intersecting the given extent in random order (so it may include
   * features whose geometries do not intersect the extent).
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false`.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */
  VectorSource.prototype.getFeaturesInExtent = function getFeaturesInExtent (extent) {
    return this.featuresRtree_.getInExtent(extent);
  };


  /**
   * Get the closest feature to the provided coordinate.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false`.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(import("../Feature.js").default):boolean=} opt_filter Feature filter function.
   *     The filter function will receive one argument, the {@link module:ol/Feature feature}
   *     and it should return a boolean value. By default, no filtering is made.
   * @return {import("../Feature.js").default} Closest feature.
   * @api
   */
  VectorSource.prototype.getClosestFeatureToCoordinate = function getClosestFeatureToCoordinate (coordinate, opt_filter) {
    // Find the closest feature using branch and bound.  We start searching an
    // infinite extent, and find the distance from the first feature found.  This
    // becomes the closest feature.  We then compute a smaller extent which any
    // closer feature must intersect.  We continue searching with this smaller
    // extent, trying to find a closer feature.  Every time we find a closer
    // feature, we update the extent being searched so that any even closer
    // feature must intersect it.  We continue until we run out of features.
    var x = coordinate[0];
    var y = coordinate[1];
    var closestFeature = null;
    var closestPoint = [NaN, NaN];
    var minSquaredDistance = Infinity;
    var extent = [-Infinity, -Infinity, Infinity, Infinity];
    var filter = opt_filter ? opt_filter : _functions_js__WEBPACK_IMPORTED_MODULE_11__["TRUE"];
    this.featuresRtree_.forEachInExtent(extent,
      /**
       * @param {import("../Feature.js").default} feature Feature.
       */
      function(feature) {
        if (filter(feature)) {
          var geometry = feature.getGeometry();
          var previousMinSquaredDistance = minSquaredDistance;
          minSquaredDistance = geometry.closestPointXY(
            x, y, closestPoint, minSquaredDistance);
          if (minSquaredDistance < previousMinSquaredDistance) {
            closestFeature = feature;
            // This is sneaky.  Reduce the extent that it is currently being
            // searched while the R-Tree traversal using this same extent object
            // is still in progress.  This is safe because the new extent is
            // strictly contained by the old extent.
            var minDistance = Math.sqrt(minSquaredDistance);
            extent[0] = x - minDistance;
            extent[1] = y - minDistance;
            extent[2] = x + minDistance;
            extent[3] = y + minDistance;
          }
        }
      });
    return closestFeature;
  };


  /**
   * Get the extent of the features currently in the source.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false`.
   * @param {import("../extent.js").Extent=} opt_extent Destination extent. If provided, no new extent
   *     will be created. Instead, that extent's coordinates will be overwritten.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  VectorSource.prototype.getExtent = function getExtent (opt_extent) {
    return this.featuresRtree_.getExtent(opt_extent);
  };


  /**
   * Get a feature by its identifier (the value returned by feature.getId()).
   * Note that the index treats string and numeric identifiers as the same.  So
   * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
   *
   * @param {string|number} id Feature identifier.
   * @return {import("../Feature.js").default} The feature (or `null` if not found).
   * @api
   */
  VectorSource.prototype.getFeatureById = function getFeatureById (id) {
    var feature = this.idIndex_[id.toString()];
    return feature !== undefined ? feature : null;
  };


  /**
   * Get the format associated with this source.
   *
   * @return {import("../format/Feature.js").default|undefined} The feature format.
   * @api
   */
  VectorSource.prototype.getFormat = function getFormat () {
    return this.format_;
  };


  /**
   * @return {boolean} The source can have overlapping geometries.
   */
  VectorSource.prototype.getOverlaps = function getOverlaps () {
    return this.overlaps_;
  };


  /**
   * Get the url associated with this source.
   *
   * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.
   * @api
   */
  VectorSource.prototype.getUrl = function getUrl () {
    return this.url_;
  };


  /**
   * @param {Event} event Event.
   * @private
   */
  VectorSource.prototype.handleFeatureChange_ = function handleFeatureChange_ (event) {
    var feature = /** @type {import("../Feature.js").default} */ (event.target);
    var featureKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature);
    var geometry = feature.getGeometry();
    if (!geometry) {
      if (!(featureKey in this.nullGeometryFeatures_)) {
        if (this.featuresRtree_) {
          this.featuresRtree_.remove(feature);
        }
        this.nullGeometryFeatures_[featureKey] = feature;
      }
    } else {
      var extent = geometry.getExtent();
      if (featureKey in this.nullGeometryFeatures_) {
        delete this.nullGeometryFeatures_[featureKey];
        if (this.featuresRtree_) {
          this.featuresRtree_.insert(extent, feature);
        }
      } else {
        if (this.featuresRtree_) {
          this.featuresRtree_.update(extent, feature);
        }
      }
    }
    var id = feature.getId();
    if (id !== undefined) {
      var sid = id.toString();
      if (featureKey in this.undefIdIndex_) {
        delete this.undefIdIndex_[featureKey];
        this.idIndex_[sid] = feature;
      } else {
        if (this.idIndex_[sid] !== feature) {
          this.removeFromIdIndex_(feature);
          this.idIndex_[sid] = feature;
        }
      }
    } else {
      if (!(featureKey in this.undefIdIndex_)) {
        this.removeFromIdIndex_(feature);
        this.undefIdIndex_[featureKey] = feature;
      }
    }
    this.changed();
    this.dispatchEvent(new VectorSourceEvent(
      _VectorEventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].CHANGEFEATURE, feature));
  };

  /**
   * Returns true if the feature is contained within the source.
   * @param {import("../Feature.js").default} feature Feature.
   * @return {boolean} Has feature.
   * @api
   */
  VectorSource.prototype.hasFeature = function hasFeature (feature) {
    var id = feature.getId();
    if (id !== undefined) {
      return id in this.idIndex_;
    } else {
      return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature) in this.undefIdIndex_;
    }
  };

  /**
   * @return {boolean} Is empty.
   */
  VectorSource.prototype.isEmpty = function isEmpty$1 () {
    return this.featuresRtree_.isEmpty() && Object(_obj_js__WEBPACK_IMPORTED_MODULE_13__["isEmpty"])(this.nullGeometryFeatures_);
  };


  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  VectorSource.prototype.loadFeatures = function loadFeatures (extent, resolution, projection) {
    var this$1 = this;

    var loadedExtentsRtree = this.loadedExtentsRtree_;
    var extentsToLoad = this.strategy_(extent, resolution);
    this.loading = false;
    var loop = function ( i, ii ) {
      var extentToLoad = extentsToLoad[i];
      var alreadyLoaded = loadedExtentsRtree.forEachInExtent(extentToLoad,
        /**
         * @param {{extent: import("../extent.js").Extent}} object Object.
         * @return {boolean} Contains.
         */
        function(object) {
          return Object(_extent_js__WEBPACK_IMPORTED_MODULE_9__["containsExtent"])(object.extent, extentToLoad);
        });
      if (!alreadyLoaded) {
        this$1.loader_.call(this$1, extentToLoad, resolution, projection);
        loadedExtentsRtree.insert(extentToLoad, {extent: extentToLoad.slice()});
        this$1.loading = this$1.loader_ !== _functions_js__WEBPACK_IMPORTED_MODULE_11__["VOID"];
      }
    };

    for (var i = 0, ii = extentsToLoad.length; i < ii; ++i) loop( i, ii );
  };


  /**
   * Remove an extent from the list of loaded extents.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */
  VectorSource.prototype.removeLoadedExtent = function removeLoadedExtent (extent) {
    var loadedExtentsRtree = this.loadedExtentsRtree_;
    var obj;
    loadedExtentsRtree.forEachInExtent(extent, function(object) {
      if (Object(_extent_js__WEBPACK_IMPORTED_MODULE_9__["equals"])(object.extent, extent)) {
        obj = object;
        return true;
      }
    });
    if (obj) {
      loadedExtentsRtree.remove(obj);
    }
  };


  /**
   * Remove a single feature from the source.  If you want to remove all features
   * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
   * instead.
   * @param {import("../Feature.js").default} feature Feature to remove.
   * @api
   */
  VectorSource.prototype.removeFeature = function removeFeature (feature) {
    var featureKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature);
    if (featureKey in this.nullGeometryFeatures_) {
      delete this.nullGeometryFeatures_[featureKey];
    } else {
      if (this.featuresRtree_) {
        this.featuresRtree_.remove(feature);
      }
    }
    this.removeFeatureInternal(feature);
    this.changed();
  };


  /**
   * Remove feature without firing a `change` event.
   * @param {import("../Feature.js").default} feature Feature.
   * @protected
   */
  VectorSource.prototype.removeFeatureInternal = function removeFeatureInternal (feature) {
    var featureKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature);
    this.featureChangeKeys_[featureKey].forEach(_events_js__WEBPACK_IMPORTED_MODULE_6__["unlistenByKey"]);
    delete this.featureChangeKeys_[featureKey];
    var id = feature.getId();
    if (id !== undefined) {
      delete this.idIndex_[id.toString()];
    } else {
      delete this.undefIdIndex_[featureKey];
    }
    this.dispatchEvent(new VectorSourceEvent(
      _VectorEventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].REMOVEFEATURE, feature));
  };


  /**
   * Remove a feature from the id index.  Called internally when the feature id
   * may have changed.
   * @param {import("../Feature.js").default} feature The feature.
   * @return {boolean} Removed the feature from the index.
   * @private
   */
  VectorSource.prototype.removeFromIdIndex_ = function removeFromIdIndex_ (feature) {
    var removed = false;
    for (var id in this.idIndex_) {
      if (this.idIndex_[id] === feature) {
        delete this.idIndex_[id];
        removed = true;
        break;
      }
    }
    return removed;
  };


  /**
   * Set the new loader of the source. The next loadFeatures call will use the
   * new loader.
   * @param {import("../featureloader.js").FeatureLoader} loader The loader to set.
   * @api
   */
  VectorSource.prototype.setLoader = function setLoader (loader) {
    this.loader_ = loader;
  };

  return VectorSource;
}(_Source_js__WEBPACK_IMPORTED_MODULE_14__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (VectorSource);

//# sourceMappingURL=Vector.js.map

/***/ }),

/***/ "./node_modules/ol/source/VectorEventType.js":
/*!***************************************************!*\
  !*** ./node_modules/ol/source/VectorEventType.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/source/VectorEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  /**
   * Triggered when a feature is added to the source.
   * @event ol/source/Vector.VectorSourceEvent#addfeature
   * @api
   */
  ADDFEATURE: 'addfeature',

  /**
   * Triggered when a feature is updated.
   * @event ol/source/Vector.VectorSourceEvent#changefeature
   * @api
   */
  CHANGEFEATURE: 'changefeature',

  /**
   * Triggered when the clear method is called on the source.
   * @event ol/source/Vector.VectorSourceEvent#clear
   * @api
   */
  CLEAR: 'clear',

  /**
   * Triggered when a feature is removed from the source.
   * See {@link module:ol/source/Vector#clear source.clear()} for exceptions.
   * @event ol/source/Vector.VectorSourceEvent#removefeature
   * @api
   */
  REMOVEFEATURE: 'removefeature'
});

//# sourceMappingURL=VectorEventType.js.map

/***/ }),

/***/ "./node_modules/ol/source/XYZ.js":
/*!***************************************!*\
  !*** ./node_modules/ol/source/XYZ.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _TileImage_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TileImage.js */ "./node_modules/ol/source/TileImage.js");
/* harmony import */ var _tilegrid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tilegrid.js */ "./node_modules/ol/tilegrid.js");
/**
 * @module ol/source/XYZ
 */




/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize=2048] Cache size.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you are using the WebGL renderer or if you want to
 * access pixel data with the Canvas renderer.  See
 * https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [opaque=true] Whether the layer is opaque.
 * @property {import("../proj.js").ProjectionLike} [projection='EPSG:3857'] Projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {number} [maxZoom=18] Optional max zoom level.
 * @property {number} [minZoom=0] Optional min zoom level.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service.
 * For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px
 * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
 * should be set to `2`.
 * @property {number|import("../size.js").Size} [tileSize=[256, 256]] The tile size used by the tile service.
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Optional function to get
 * tile URL given a tile coordinate and the projection.
 * Required if url or urls are not provided.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`,
 * and `{z}` placeholders. A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`,
 * may be used instead of defining each one separately in the `urls` option.
 * @property {Array<string>} [urls] An array of URL templates.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 */


/**
 * @classdesc
 * Layer source for tile data with URLs in a set XYZ format that are
 * defined in a URL template. By default, this follows the widely-used
 * Google grid where `x` 0 and `y` 0 are in the top left. Grids like
 * TMS where `x` 0 and `y` 0 are in the bottom left can be used by
 * using the `{-y}` placeholder in the URL template, so long as the
 * source does not have a custom tile grid. In this case,
 * {@link module:ol/source/TileImage} can be used with a `tileUrlFunction`
 * such as:
 *
 *  tileUrlFunction: function(coordinate) {
 *    return 'http://mapserver.com/' + coordinate[0] + '/' +
 *        coordinate[1] + '/' + coordinate[2] + '.png';
 *    }
 *
 * @api
 */
var XYZ = /*@__PURE__*/(function (TileImage) {
  function XYZ(opt_options) {
    var options = opt_options || {};
    var projection = options.projection !== undefined ?
      options.projection : 'EPSG:3857';

    var tileGrid = options.tileGrid !== undefined ? options.tileGrid :
      Object(_tilegrid_js__WEBPACK_IMPORTED_MODULE_1__["createXYZ"])({
        extent: Object(_tilegrid_js__WEBPACK_IMPORTED_MODULE_1__["extentFromProjection"])(projection),
        maxZoom: options.maxZoom,
        minZoom: options.minZoom,
        tileSize: options.tileSize
      });

    TileImage.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      opaque: options.opaque,
      projection: projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileGrid: tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX !== undefined ? options.wrapX : true,
      transition: options.transition,
      attributionsCollapsible: options.attributionsCollapsible
    });

  }

  if ( TileImage ) XYZ.__proto__ = TileImage;
  XYZ.prototype = Object.create( TileImage && TileImage.prototype );
  XYZ.prototype.constructor = XYZ;

  return XYZ;
}(_TileImage_js__WEBPACK_IMPORTED_MODULE_0__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (XYZ);

//# sourceMappingURL=XYZ.js.map

/***/ }),

/***/ "./node_modules/ol/sphere.js":
/*!***********************************!*\
  !*** ./node_modules/ol/sphere.js ***!
  \***********************************/
/*! exports provided: DEFAULT_RADIUS, getDistance, getLength, getArea, offset */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_RADIUS", function() { return DEFAULT_RADIUS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDistance", function() { return getDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLength", function() { return getLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getArea", function() { return getArea; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "offset", function() { return offset; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/**
 * @license
 * Latitude/longitude spherical geodesy formulae taken from
 * http://www.movable-type.co.uk/scripts/latlong.html
 * Licensed under CC-BY-3.0.
 */

/**
 * @module ol/sphere
 */




/**
 * Object literal with options for the {@link getLength} or {@link getArea}
 * functions.
 * @typedef {Object} SphereMetricOptions
 * @property {import("./proj.js").ProjectionLike} [projection='EPSG:3857']
 * Projection of the  geometry.  By default, the geometry is assumed to be in
 * Web Mercator.
 * @property {number} [radius=6371008.8] Sphere radius.  By default, the radius of the
 * earth is used (Clarke 1866 Authalic Sphere).
 */


/**
 * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.
 * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius
 * @type {number}
 */
var DEFAULT_RADIUS = 6371008.8;


/**
 * Get the great circle distance (in meters) between two geographic coordinates.
 * @param {Array} c1 Starting coordinate.
 * @param {Array} c2 Ending coordinate.
 * @param {number=} opt_radius The sphere radius to use.  Defaults to the Earth's
 *     mean radius using the WGS84 ellipsoid.
 * @return {number} The great circle distance between the points (in meters).
 * @api
 */
function getDistance(c1, c2, opt_radius) {
  var radius = opt_radius || DEFAULT_RADIUS;
  var lat1 = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toRadians"])(c1[1]);
  var lat2 = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toRadians"])(c2[1]);
  var deltaLatBy2 = (lat2 - lat1) / 2;
  var deltaLonBy2 = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toRadians"])(c2[0] - c1[0]) / 2;
  var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) +
      Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) *
      Math.cos(lat1) * Math.cos(lat2);
  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}


/**
 * Get the cumulative great circle length of linestring coordinates (geographic).
 * @param {Array} coordinates Linestring coordinates.
 * @param {number} radius The sphere radius to use.
 * @return {number} The length (in meters).
 */
function getLengthInternal(coordinates, radius) {
  var length = 0;
  for (var i = 0, ii = coordinates.length; i < ii - 1; ++i) {
    length += getDistance(coordinates[i], coordinates[i + 1], radius);
  }
  return length;
}


/**
 * Get the spherical length of a geometry.  This length is the sum of the
 * great circle distances between coordinates.  For polygons, the length is
 * the sum of all rings.  For points, the length is zero.  For multi-part
 * geometries, the length is the sum of the length of each part.
 * @param {import("./geom/Geometry.js").default} geometry A geometry.
 * @param {SphereMetricOptions=} opt_options Options for the
 * length calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 * You can change this by providing a `projection` option.
 * @return {number} The spherical length (in meters).
 * @api
 */
function getLength(geometry, opt_options) {
  var options = opt_options || {};
  var radius = options.radius || DEFAULT_RADIUS;
  var projection = options.projection || 'EPSG:3857';
  var type = geometry.getType();
  if (type !== _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].GEOMETRY_COLLECTION) {
    geometry = geometry.clone().transform(projection, 'EPSG:4326');
  }
  var length = 0;
  var coordinates, coords, i, ii, j, jj;
  switch (type) {
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINT:
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POINT: {
      break;
    }
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINE_STRING:
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINEAR_RING: {
      coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ (geometry).getCoordinates();
      length = getLengthInternal(coordinates, radius);
      break;
    }
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_LINE_STRING:
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POLYGON: {
      coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ (geometry).getCoordinates();
      for (i = 0, ii = coordinates.length; i < ii; ++i) {
        length += getLengthInternal(coordinates[i], radius);
      }
      break;
    }
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POLYGON: {
      coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ (geometry).getCoordinates();
      for (i = 0, ii = coordinates.length; i < ii; ++i) {
        coords = coordinates[i];
        for (j = 0, jj = coords.length; j < jj; ++j) {
          length += getLengthInternal(coords[j], radius);
        }
      }
      break;
    }
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].GEOMETRY_COLLECTION: {
      var geometries = /** @type {import("./geom/GeometryCollection.js").default} */ (geometry).getGeometries();
      for (i = 0, ii = geometries.length; i < ii; ++i) {
        length += getLength(geometries[i], opt_options);
      }
      break;
    }
    default: {
      throw new Error('Unsupported geometry type: ' + type);
    }
  }
  return length;
}


/**
 * Returns the spherical area for a list of coordinates.
 *
 * [Reference](https://trs-new.jpl.nasa.gov/handle/2014/40409)
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 * Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 * Laboratory, Pasadena, CA, June 2007
 *
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates List of coordinates of a linear
 * ring. If the ring is oriented clockwise, the area will be positive,
 * otherwise it will be negative.
 * @param {number} radius The sphere radius.
 * @return {number} Area (in square meters).
 */
function getAreaInternal(coordinates, radius) {
  var area = 0;
  var len = coordinates.length;
  var x1 = coordinates[len - 1][0];
  var y1 = coordinates[len - 1][1];
  for (var i = 0; i < len; i++) {
    var x2 = coordinates[i][0];
    var y2 = coordinates[i][1];
    area += Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toRadians"])(x2 - x1) *
        (2 + Math.sin(Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toRadians"])(y1)) +
        Math.sin(Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toRadians"])(y2)));
    x1 = x2;
    y1 = y2;
  }
  return area * radius * radius / 2.0;
}


/**
 * Get the spherical area of a geometry.  This is the area (in meters) assuming
 * that polygon edges are segments of great circles on a sphere.
 * @param {import("./geom/Geometry.js").default} geometry A geometry.
 * @param {SphereMetricOptions=} opt_options Options for the area
 *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 *     You can change this by providing a `projection` option.
 * @return {number} The spherical area (in square meters).
 * @api
 */
function getArea(geometry, opt_options) {
  var options = opt_options || {};
  var radius = options.radius || DEFAULT_RADIUS;
  var projection = options.projection || 'EPSG:3857';
  var type = geometry.getType();
  if (type !== _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].GEOMETRY_COLLECTION) {
    geometry = geometry.clone().transform(projection, 'EPSG:4326');
  }
  var area = 0;
  var coordinates, coords, i, ii, j, jj;
  switch (type) {
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINT:
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POINT:
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINE_STRING:
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_LINE_STRING:
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINEAR_RING: {
      break;
    }
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POLYGON: {
      coordinates = /** @type {import("./geom/Polygon.js").default} */ (geometry).getCoordinates();
      area = Math.abs(getAreaInternal(coordinates[0], radius));
      for (i = 1, ii = coordinates.length; i < ii; ++i) {
        area -= Math.abs(getAreaInternal(coordinates[i], radius));
      }
      break;
    }
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POLYGON: {
      coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ (geometry).getCoordinates();
      for (i = 0, ii = coordinates.length; i < ii; ++i) {
        coords = coordinates[i];
        area += Math.abs(getAreaInternal(coords[0], radius));
        for (j = 1, jj = coords.length; j < jj; ++j) {
          area -= Math.abs(getAreaInternal(coords[j], radius));
        }
      }
      break;
    }
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].GEOMETRY_COLLECTION: {
      var geometries = /** @type {import("./geom/GeometryCollection.js").default} */ (geometry).getGeometries();
      for (i = 0, ii = geometries.length; i < ii; ++i) {
        area += getArea(geometries[i], opt_options);
      }
      break;
    }
    default: {
      throw new Error('Unsupported geometry type: ' + type);
    }
  }
  return area;
}


/**
 * Returns the coordinate at the given distance and bearing from `c1`.
 *
 * @param {import("./coordinate.js").Coordinate} c1 The origin point (`[lon, lat]` in degrees).
 * @param {number} distance The great-circle distance between the origin
 *     point and the target point.
 * @param {number} bearing The bearing (in radians).
 * @param {number=} opt_radius The sphere radius to use.  Defaults to the Earth's
 *     mean radius using the WGS84 ellipsoid.
 * @return {import("./coordinate.js").Coordinate} The target point.
 */
function offset(c1, distance, bearing, opt_radius) {
  var radius = opt_radius || DEFAULT_RADIUS;
  var lat1 = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toRadians"])(c1[1]);
  var lon1 = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toRadians"])(c1[0]);
  var dByR = distance / radius;
  var lat = Math.asin(
    Math.sin(lat1) * Math.cos(dByR) +
      Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));
  var lon = lon1 + Math.atan2(
    Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1),
    Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));
  return [Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toDegrees"])(lon), Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toDegrees"])(lat)];
}

//# sourceMappingURL=sphere.js.map

/***/ }),

/***/ "./node_modules/ol/string.js":
/*!***********************************!*\
  !*** ./node_modules/ol/string.js ***!
  \***********************************/
/*! exports provided: padNumber, compareVersions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "padNumber", function() { return padNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compareVersions", function() { return compareVersions; });
/**
 * @module ol/string
 */

/**
 * @param {number} number Number to be formatted
 * @param {number} width The desired width
 * @param {number=} opt_precision Precision of the output string (i.e. number of decimal places)
 * @returns {string} Formatted string
 */
function padNumber(number, width, opt_precision) {
  var numberString = opt_precision !== undefined ? number.toFixed(opt_precision) : '' + number;
  var decimal = numberString.indexOf('.');
  decimal = decimal === -1 ? numberString.length : decimal;
  return decimal > width ? numberString : new Array(1 + width - decimal).join('0') + numberString;
}


/**
 * Adapted from https://github.com/omichelsen/compare-versions/blob/master/index.js
 * @param {string|number} v1 First version
 * @param {string|number} v2 Second version
 * @returns {number} Value
 */
function compareVersions(v1, v2) {
  var s1 = ('' + v1).split('.');
  var s2 = ('' + v2).split('.');

  for (var i = 0; i < Math.max(s1.length, s2.length); i++) {
    var n1 = parseInt(s1[i] || '0', 10);
    var n2 = parseInt(s2[i] || '0', 10);

    if (n1 > n2) {
      return 1;
    }
    if (n2 > n1) {
      return -1;
    }
  }

  return 0;
}

//# sourceMappingURL=string.js.map

/***/ }),

/***/ "./node_modules/ol/structs/LRUCache.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/structs/LRUCache.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/Target.js */ "./node_modules/ol/events/Target.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/**
 * @module ol/structs/LRUCache
 */






/**
 * @typedef {Object} Entry
 * @property {string} key_
 * @property {Object} newer
 * @property {Object} older
 * @property {*} value_
 */


/**
 * @classdesc
 * Implements a Least-Recently-Used cache where the keys do not conflict with
 * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring
 * items from the cache is the responsibility of the user.
 *
 * @fires import("../events/Event.js").Event
 * @template T
 */
var LRUCache = /*@__PURE__*/(function (EventTarget) {
  function LRUCache(opt_highWaterMark) {

    EventTarget.call(this);

    /**
     * @type {number}
     */
    this.highWaterMark = opt_highWaterMark !== undefined ? opt_highWaterMark : 2048;

    /**
     * @private
     * @type {number}
     */
    this.count_ = 0;

    /**
     * @private
     * @type {!Object<string, Entry>}
     */
    this.entries_ = {};

    /**
     * @private
     * @type {?Entry}
     */
    this.oldest_ = null;

    /**
     * @private
     * @type {?Entry}
     */
    this.newest_ = null;

  }

  if ( EventTarget ) LRUCache.__proto__ = EventTarget;
  LRUCache.prototype = Object.create( EventTarget && EventTarget.prototype );
  LRUCache.prototype.constructor = LRUCache;


  /**
   * @return {boolean} Can expire cache.
   */
  LRUCache.prototype.canExpireCache = function canExpireCache () {
    return this.getCount() > this.highWaterMark;
  };


  /**
   * FIXME empty description for jsdoc
   */
  LRUCache.prototype.clear = function clear () {
    this.count_ = 0;
    this.entries_ = {};
    this.oldest_ = null;
    this.newest_ = null;
    this.dispatchEvent(_events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CLEAR);
  };


  /**
   * @param {string} key Key.
   * @return {boolean} Contains key.
   */
  LRUCache.prototype.containsKey = function containsKey (key) {
    return this.entries_.hasOwnProperty(key);
  };


  /**
   * @param {function(this: S, T, string, LRUCache): ?} f The function
   *     to call for every entry from the oldest to the newer. This function takes
   *     3 arguments (the entry value, the entry key and the LRUCache object).
   *     The return value is ignored.
   * @param {S=} opt_this The object to use as `this` in `f`.
   * @template S
   */
  LRUCache.prototype.forEach = function forEach (f, opt_this) {
    var entry = this.oldest_;
    while (entry) {
      f.call(opt_this, entry.value_, entry.key_, this);
      entry = entry.newer;
    }
  };


  /**
   * @param {string} key Key.
   * @return {T} Value.
   */
  LRUCache.prototype.get = function get (key) {
    var entry = this.entries_[key];
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(entry !== undefined,
      15); // Tried to get a value for a key that does not exist in the cache
    if (entry === this.newest_) {
      return entry.value_;
    } else if (entry === this.oldest_) {
      this.oldest_ = /** @type {Entry} */ (this.oldest_.newer);
      this.oldest_.older = null;
    } else {
      entry.newer.older = entry.older;
      entry.older.newer = entry.newer;
    }
    entry.newer = null;
    entry.older = this.newest_;
    this.newest_.newer = entry;
    this.newest_ = entry;
    return entry.value_;
  };


  /**
   * Remove an entry from the cache.
   * @param {string} key The entry key.
   * @return {T} The removed entry.
   */
  LRUCache.prototype.remove = function remove (key) {
    var entry = this.entries_[key];
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache
    if (entry === this.newest_) {
      this.newest_ = /** @type {Entry} */ (entry.older);
      if (this.newest_) {
        this.newest_.newer = null;
      }
    } else if (entry === this.oldest_) {
      this.oldest_ = /** @type {Entry} */ (entry.newer);
      if (this.oldest_) {
        this.oldest_.older = null;
      }
    } else {
      entry.newer.older = entry.older;
      entry.older.newer = entry.newer;
    }
    delete this.entries_[key];
    --this.count_;
    return entry.value_;
  };


  /**
   * @return {number} Count.
   */
  LRUCache.prototype.getCount = function getCount () {
    return this.count_;
  };


  /**
   * @return {Array<string>} Keys.
   */
  LRUCache.prototype.getKeys = function getKeys () {
    var keys = new Array(this.count_);
    var i = 0;
    var entry;
    for (entry = this.newest_; entry; entry = entry.older) {
      keys[i++] = entry.key_;
    }
    return keys;
  };


  /**
   * @return {Array<T>} Values.
   */
  LRUCache.prototype.getValues = function getValues () {
    var values = new Array(this.count_);
    var i = 0;
    var entry;
    for (entry = this.newest_; entry; entry = entry.older) {
      values[i++] = entry.value_;
    }
    return values;
  };


  /**
   * @return {T} Last value.
   */
  LRUCache.prototype.peekLast = function peekLast () {
    return this.oldest_.value_;
  };


  /**
   * @return {string} Last key.
   */
  LRUCache.prototype.peekLastKey = function peekLastKey () {
    return this.oldest_.key_;
  };


  /**
   * Get the key of the newest item in the cache.  Throws if the cache is empty.
   * @return {string} The newest key.
   */
  LRUCache.prototype.peekFirstKey = function peekFirstKey () {
    return this.newest_.key_;
  };


  /**
   * @return {T} value Value.
   */
  LRUCache.prototype.pop = function pop () {
    var entry = this.oldest_;
    delete this.entries_[entry.key_];
    if (entry.newer) {
      entry.newer.older = null;
    }
    this.oldest_ = /** @type {Entry} */ (entry.newer);
    if (!this.oldest_) {
      this.newest_ = null;
    }
    --this.count_;
    return entry.value_;
  };


  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  LRUCache.prototype.replace = function replace (key, value) {
    this.get(key); // update `newest_`
    this.entries_[key].value_ = value;
  };


  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  LRUCache.prototype.set = function set (key, value) {
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(!(key in this.entries_),
      16); // Tried to set a value for a key that is used already
    var entry = /** @type {Entry} */ ({
      key_: key,
      newer: null,
      older: this.newest_,
      value_: value
    });
    if (!this.newest_) {
      this.oldest_ = entry;
    } else {
      this.newest_.newer = entry;
    }
    this.newest_ = entry;
    this.entries_[key] = entry;
    ++this.count_;
  };


  /**
   * Set a maximum number of entries for the cache.
   * @param {number} size Cache size.
   * @api
   */
  LRUCache.prototype.setSize = function setSize (size) {
    this.highWaterMark = size;
  };


  /**
   * Prune the cache.
   */
  LRUCache.prototype.prune = function prune () {
    while (this.canExpireCache()) {
      this.pop();
    }
  };

  return LRUCache;
}(_events_Target_js__WEBPACK_IMPORTED_MODULE_1__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (LRUCache);

//# sourceMappingURL=LRUCache.js.map

/***/ }),

/***/ "./node_modules/ol/structs/PriorityQueue.js":
/*!**************************************************!*\
  !*** ./node_modules/ol/structs/PriorityQueue.js ***!
  \**************************************************/
/*! exports provided: DROP, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DROP", function() { return DROP; });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/structs/PriorityQueue
 */




/**
 * @type {number}
 */
var DROP = Infinity;


/**
 * @classdesc
 * Priority queue.
 *
 * The implementation is inspired from the Closure Library's Heap class and
 * Python's heapq module.
 *
 * See http://closure-library.googlecode.com/svn/docs/closure_goog_structs_heap.js.source.html
 * and http://hg.python.org/cpython/file/2.7/Lib/heapq.py.
 *
 * @template T
 */
var PriorityQueue = function PriorityQueue(priorityFunction, keyFunction) {

  /**
   * @type {function(T): number}
   * @private
   */
  this.priorityFunction_ = priorityFunction;

  /**
   * @type {function(T): string}
   * @private
   */
  this.keyFunction_ = keyFunction;

  /**
   * @type {Array<T>}
   * @private
   */
  this.elements_ = [];

  /**
   * @type {Array<number>}
   * @private
   */
  this.priorities_ = [];

  /**
   * @type {!Object<string, boolean>}
   * @private
   */
  this.queuedElements_ = {};

};

/**
 * FIXME empty description for jsdoc
 */
PriorityQueue.prototype.clear = function clear$1 () {
  this.elements_.length = 0;
  this.priorities_.length = 0;
  Object(_obj_js__WEBPACK_IMPORTED_MODULE_1__["clear"])(this.queuedElements_);
};


/**
 * Remove and return the highest-priority element. O(log N).
 * @return {T} Element.
 */
PriorityQueue.prototype.dequeue = function dequeue () {
  var elements = this.elements_;
  var priorities = this.priorities_;
  var element = elements[0];
  if (elements.length == 1) {
    elements.length = 0;
    priorities.length = 0;
  } else {
    elements[0] = elements.pop();
    priorities[0] = priorities.pop();
    this.siftUp_(0);
  }
  var elementKey = this.keyFunction_(element);
  delete this.queuedElements_[elementKey];
  return element;
};


/**
 * Enqueue an element. O(log N).
 * @param {T} element Element.
 * @return {boolean} The element was added to the queue.
 */
PriorityQueue.prototype.enqueue = function enqueue (element) {
  Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(!(this.keyFunction_(element) in this.queuedElements_),
    31); // Tried to enqueue an `element` that was already added to the queue
  var priority = this.priorityFunction_(element);
  if (priority != DROP) {
    this.elements_.push(element);
    this.priorities_.push(priority);
    this.queuedElements_[this.keyFunction_(element)] = true;
    this.siftDown_(0, this.elements_.length - 1);
    return true;
  }
  return false;
};


/**
 * @return {number} Count.
 */
PriorityQueue.prototype.getCount = function getCount () {
  return this.elements_.length;
};


/**
 * Gets the index of the left child of the node at the given index.
 * @param {number} index The index of the node to get the left child for.
 * @return {number} The index of the left child.
 * @private
 */
PriorityQueue.prototype.getLeftChildIndex_ = function getLeftChildIndex_ (index) {
  return index * 2 + 1;
};


/**
 * Gets the index of the right child of the node at the given index.
 * @param {number} index The index of the node to get the right child for.
 * @return {number} The index of the right child.
 * @private
 */
PriorityQueue.prototype.getRightChildIndex_ = function getRightChildIndex_ (index) {
  return index * 2 + 2;
};


/**
 * Gets the index of the parent of the node at the given index.
 * @param {number} index The index of the node to get the parent for.
 * @return {number} The index of the parent.
 * @private
 */
PriorityQueue.prototype.getParentIndex_ = function getParentIndex_ (index) {
  return (index - 1) >> 1;
};


/**
 * Make this a heap. O(N).
 * @private
 */
PriorityQueue.prototype.heapify_ = function heapify_ () {
  var i;
  for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {
    this.siftUp_(i);
  }
};


/**
 * @return {boolean} Is empty.
 */
PriorityQueue.prototype.isEmpty = function isEmpty () {
  return this.elements_.length === 0;
};


/**
 * @param {string} key Key.
 * @return {boolean} Is key queued.
 */
PriorityQueue.prototype.isKeyQueued = function isKeyQueued (key) {
  return key in this.queuedElements_;
};


/**
 * @param {T} element Element.
 * @return {boolean} Is queued.
 */
PriorityQueue.prototype.isQueued = function isQueued (element) {
  return this.isKeyQueued(this.keyFunction_(element));
};


/**
 * @param {number} index The index of the node to move down.
 * @private
 */
PriorityQueue.prototype.siftUp_ = function siftUp_ (index) {
  var elements = this.elements_;
  var priorities = this.priorities_;
  var count = elements.length;
  var element = elements[index];
  var priority = priorities[index];
  var startIndex = index;

  while (index < (count >> 1)) {
    var lIndex = this.getLeftChildIndex_(index);
    var rIndex = this.getRightChildIndex_(index);

    var smallerChildIndex = rIndex < count &&
        priorities[rIndex] < priorities[lIndex] ?
      rIndex : lIndex;

    elements[index] = elements[smallerChildIndex];
    priorities[index] = priorities[smallerChildIndex];
    index = smallerChildIndex;
  }

  elements[index] = element;
  priorities[index] = priority;
  this.siftDown_(startIndex, index);
};


/**
 * @param {number} startIndex The index of the root.
 * @param {number} index The index of the node to move up.
 * @private
 */
PriorityQueue.prototype.siftDown_ = function siftDown_ (startIndex, index) {
  var elements = this.elements_;
  var priorities = this.priorities_;
  var element = elements[index];
  var priority = priorities[index];

  while (index > startIndex) {
    var parentIndex = this.getParentIndex_(index);
    if (priorities[parentIndex] > priority) {
      elements[index] = elements[parentIndex];
      priorities[index] = priorities[parentIndex];
      index = parentIndex;
    } else {
      break;
    }
  }
  elements[index] = element;
  priorities[index] = priority;
};


/**
 * FIXME empty description for jsdoc
 */
PriorityQueue.prototype.reprioritize = function reprioritize () {
  var priorityFunction = this.priorityFunction_;
  var elements = this.elements_;
  var priorities = this.priorities_;
  var index = 0;
  var n = elements.length;
  var element, i, priority;
  for (i = 0; i < n; ++i) {
    element = elements[i];
    priority = priorityFunction(element);
    if (priority == DROP) {
      delete this.queuedElements_[this.keyFunction_(element)];
    } else {
      priorities[index] = priority;
      elements[index++] = element;
    }
  }
  elements.length = index;
  priorities.length = index;
  this.heapify_();
};


/* harmony default export */ __webpack_exports__["default"] = (PriorityQueue);

//# sourceMappingURL=PriorityQueue.js.map

/***/ }),

/***/ "./node_modules/ol/structs/RBush.js":
/*!******************************************!*\
  !*** ./node_modules/ol/structs/RBush.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rbush */ "./node_modules/rbush/index.js");
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(rbush__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/structs/RBush
 */





/**
 * @typedef {Object} Entry
 * @property {number} minX
 * @property {number} minY
 * @property {number} maxX
 * @property {number} maxY
 * @property {Object} [value]
 */

/**
 * @classdesc
 * Wrapper around the RBush by Vladimir Agafonkin.
 * See https://github.com/mourner/rbush.
 *
 * @template T
 */
var RBush = function RBush(opt_maxEntries) {

  /**
   * @private
   */
  this.rbush_ = rbush__WEBPACK_IMPORTED_MODULE_1___default()(opt_maxEntries, undefined);

  /**
   * A mapping between the objects added to this rbush wrapper
   * and the objects that are actually added to the internal rbush.
   * @private
   * @type {Object<string, Entry>}
   */
  this.items_ = {};

};

/**
 * Insert a value into the RBush.
 * @param {import("../extent.js").Extent} extent Extent.
 * @param {T} value Value.
 */
RBush.prototype.insert = function insert (extent, value) {
  /** @type {Entry} */
  var item = {
    minX: extent[0],
    minY: extent[1],
    maxX: extent[2],
    maxY: extent[3],
    value: value
  };

  this.rbush_.insert(item);
  this.items_[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(value)] = item;
};


/**
 * Bulk-insert values into the RBush.
 * @param {Array<import("../extent.js").Extent>} extents Extents.
 * @param {Array<T>} values Values.
 */
RBush.prototype.load = function load (extents, values) {
  var items = new Array(values.length);
  for (var i = 0, l = values.length; i < l; i++) {
    var extent = extents[i];
    var value = values[i];

    /** @type {Entry} */
    var item = {
      minX: extent[0],
      minY: extent[1],
      maxX: extent[2],
      maxY: extent[3],
      value: value
    };
    items[i] = item;
    this.items_[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(value)] = item;
  }
  this.rbush_.load(items);
};


/**
 * Remove a value from the RBush.
 * @param {T} value Value.
 * @return {boolean} Removed.
 */
RBush.prototype.remove = function remove (value) {
  var uid = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(value);

  // get the object in which the value was wrapped when adding to the
  // internal rbush. then use that object to do the removal.
  var item = this.items_[uid];
  delete this.items_[uid];
  return this.rbush_.remove(item) !== null;
};


/**
 * Update the extent of a value in the RBush.
 * @param {import("../extent.js").Extent} extent Extent.
 * @param {T} value Value.
 */
RBush.prototype.update = function update (extent, value) {
  var item = this.items_[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(value)];
  var bbox = [item.minX, item.minY, item.maxX, item.maxY];
  if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["equals"])(bbox, extent)) {
    this.remove(value);
    this.insert(extent, value);
  }
};


/**
 * Return all values in the RBush.
 * @return {Array<T>} All.
 */
RBush.prototype.getAll = function getAll () {
  var items = this.rbush_.all();
  return items.map(function(item) {
    return item.value;
  });
};


/**
 * Return all values in the given extent.
 * @param {import("../extent.js").Extent} extent Extent.
 * @return {Array<T>} All in extent.
 */
RBush.prototype.getInExtent = function getInExtent (extent) {
  /** @type {Entry} */
  var bbox = {
    minX: extent[0],
    minY: extent[1],
    maxX: extent[2],
    maxY: extent[3]
  };
  var items = this.rbush_.search(bbox);
  return items.map(function(item) {
    return item.value;
  });
};


/**
 * Calls a callback function with each value in the tree.
 * If the callback returns a truthy value, this value is returned without
 * checking the rest of the tree.
 * @param {function(this: S, T): *} callback Callback.
 * @param {S=} opt_this The object to use as `this` in `callback`.
 * @return {*} Callback return value.
 * @template S
 */
RBush.prototype.forEach = function forEach (callback, opt_this) {
  return this.forEach_(this.getAll(), callback, opt_this);
};


/**
 * Calls a callback function with each value in the provided extent.
 * @param {import("../extent.js").Extent} extent Extent.
 * @param {function(this: S, T): *} callback Callback.
 * @param {S=} opt_this The object to use as `this` in `callback`.
 * @return {*} Callback return value.
 * @template S
 */
RBush.prototype.forEachInExtent = function forEachInExtent (extent, callback, opt_this) {
  return this.forEach_(this.getInExtent(extent), callback, opt_this);
};


/**
 * @param {Array<T>} values Values.
 * @param {function(this: S, T): *} callback Callback.
 * @param {S=} opt_this The object to use as `this` in `callback`.
 * @private
 * @return {*} Callback return value.
 * @template S
 */
RBush.prototype.forEach_ = function forEach_ (values, callback, opt_this) {
  var result;
  for (var i = 0, l = values.length; i < l; i++) {
    result = callback.call(opt_this, values[i]);
    if (result) {
      return result;
    }
  }
  return result;
};


/**
 * @return {boolean} Is empty.
 */
RBush.prototype.isEmpty = function isEmpty$1 () {
  return Object(_obj_js__WEBPACK_IMPORTED_MODULE_3__["isEmpty"])(this.items_);
};


/**
 * Remove all values from the RBush.
 */
RBush.prototype.clear = function clear () {
  this.rbush_.clear();
  this.items_ = {};
};


/**
 * @param {import("../extent.js").Extent=} opt_extent Extent.
 * @return {import("../extent.js").Extent} Extent.
 */
RBush.prototype.getExtent = function getExtent (opt_extent) {
  var data = this.rbush_.toJSON();
  return Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["createOrUpdate"])(data.minX, data.minY, data.maxX, data.maxY, opt_extent);
};


/**
 * @param {RBush} rbush R-Tree.
 */
RBush.prototype.concat = function concat (rbush) {
  this.rbush_.load(rbush.rbush_.all());
  for (var i in rbush.items_) {
    this.items_[i] = rbush.items_[i];
  }
};


/* harmony default export */ __webpack_exports__["default"] = (RBush);

//# sourceMappingURL=RBush.js.map

/***/ }),

/***/ "./node_modules/ol/style/Circle.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/style/Circle.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _RegularShape_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RegularShape.js */ "./node_modules/ol/style/RegularShape.js");
/**
 * @module ol/style/Circle
 */




/**
 * @typedef {Object} Options
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {number} radius Circle radius.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {import("./AtlasManager.js").default} [atlasManager] The atlas manager to use for this circle.
 * When using WebGL it is recommended to use an atlas manager to avoid texture switching. If an atlas manager is given,
 * the circle is added to an atlas. By default no atlas manager is used.
 */


/**
 * @classdesc
 * Set circle style for vector features.
 * @api
 */
var CircleStyle = /*@__PURE__*/(function (RegularShape) {
  function CircleStyle(opt_options) {

    var options = opt_options || /** @type {Options} */ ({});

    RegularShape.call(this, {
      points: Infinity,
      fill: options.fill,
      radius: options.radius,
      stroke: options.stroke,
      atlasManager: options.atlasManager
    });

  }

  if ( RegularShape ) CircleStyle.__proto__ = RegularShape;
  CircleStyle.prototype = Object.create( RegularShape && RegularShape.prototype );
  CircleStyle.prototype.constructor = CircleStyle;

  /**
  * Clones the style.  If an atlasmanager was provided to the original style it will be used in the cloned style, too.
  * @return {CircleStyle} The cloned style.
  * @override
  * @api
  */
  CircleStyle.prototype.clone = function clone () {
    var style = new CircleStyle({
      fill: this.getFill() ? this.getFill().clone() : undefined,
      stroke: this.getStroke() ? this.getStroke().clone() : undefined,
      radius: this.getRadius(),
      atlasManager: this.atlasManager_
    });
    style.setOpacity(this.getOpacity());
    style.setScale(this.getScale());
    return style;
  };

  /**
  * Set the circle radius.
  *
  * @param {number} radius Circle radius.
  * @api
  */
  CircleStyle.prototype.setRadius = function setRadius (radius) {
    this.radius_ = radius;
    this.render_(this.atlasManager_);
  };

  return CircleStyle;
}(_RegularShape_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (CircleStyle);

//# sourceMappingURL=Circle.js.map

/***/ }),

/***/ "./node_modules/ol/style/Fill.js":
/*!***************************************!*\
  !*** ./node_modules/ol/style/Fill.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../color.js */ "./node_modules/ol/color.js");
/**
 * @module ol/style/Fill
 */




/**
 * @typedef {Object} Options
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [color] A color, gradient or pattern.
 * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
 * Default null; if null, the Canvas/renderer default black will be used.
 */


/**
 * @classdesc
 * Set fill style for vector features.
 * @api
 */
var Fill = function Fill(opt_options) {

  var options = opt_options || {};

  /**
   * @private
   * @type {import("../color.js").Color|import("../colorlike.js").ColorLike}
   */
  this.color_ = options.color !== undefined ? options.color : null;

  /**
   * @private
   * @type {string|undefined}
   */
  this.checksum_ = undefined;
};

/**
 * Clones the style. The color is not cloned if it is an {@link module:ol/colorlike~ColorLike}.
 * @return {Fill} The cloned style.
 * @api
 */
Fill.prototype.clone = function clone () {
  var color = this.getColor();
  return new Fill({
    color: Array.isArray(color) ? color.slice() : color || undefined
  });
};

/**
 * Get the fill color.
 * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
 * @api
 */
Fill.prototype.getColor = function getColor () {
  return this.color_;
};

/**
 * Set the color.
 *
 * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
 * @api
 */
Fill.prototype.setColor = function setColor (color) {
  this.color_ = color;
  this.checksum_ = undefined;
};

/**
 * @return {string} The checksum.
 */
Fill.prototype.getChecksum = function getChecksum () {
  if (this.checksum_ === undefined) {
    var color = this.color_;
    if (color) {
      if (Array.isArray(color) || typeof color == 'string') {
        this.checksum_ = 'f' + Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["asString"])(/** @type {import("../color.js").Color|string} */ (color));
      } else {
        this.checksum_ = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(this.color_);
      }
    } else {
      this.checksum_ = 'f-';
    }
  }

  return this.checksum_;
};

/* harmony default export */ __webpack_exports__["default"] = (Fill);

//# sourceMappingURL=Fill.js.map

/***/ }),

/***/ "./node_modules/ol/style/IconImageCache.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/style/IconImageCache.js ***!
  \*************************************************/
/*! exports provided: default, shared */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shared", function() { return shared; });
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../color.js */ "./node_modules/ol/color.js");
/**
 * @module ol/style/IconImageCache
 */


/**
 * @classdesc
 * Singleton class. Available through {@link module:ol/style/IconImageCache~shared}.
 */
var IconImageCache = function IconImageCache() {

  /**
  * @type {!Object<string, import("./IconImage.js").default>}
  * @private
  */
  this.cache_ = {};

  /**
  * @type {number}
  * @private
  */
  this.cacheSize_ = 0;

  /**
  * @type {number}
  * @private
  */
  this.maxCacheSize_ = 32;
};

/**
* FIXME empty description for jsdoc
*/
IconImageCache.prototype.clear = function clear () {
  this.cache_ = {};
  this.cacheSize_ = 0;
};

/**
* FIXME empty description for jsdoc
*/
IconImageCache.prototype.expire = function expire () {
  if (this.cacheSize_ > this.maxCacheSize_) {
    var i = 0;
    for (var key in this.cache_) {
      var iconImage = this.cache_[key];
      if ((i++ & 3) === 0 && !iconImage.hasListener()) {
        delete this.cache_[key];
        --this.cacheSize_;
      }
    }
  }
};

/**
* @param {string} src Src.
* @param {?string} crossOrigin Cross origin.
* @param {import("../color.js").Color} color Color.
* @return {import("./IconImage.js").default} Icon image.
*/
IconImageCache.prototype.get = function get (src, crossOrigin, color) {
  var key = getKey(src, crossOrigin, color);
  return key in this.cache_ ? this.cache_[key] : null;
};

/**
* @param {string} src Src.
* @param {?string} crossOrigin Cross origin.
* @param {import("../color.js").Color} color Color.
* @param {import("./IconImage.js").default} iconImage Icon image.
*/
IconImageCache.prototype.set = function set (src, crossOrigin, color, iconImage) {
  var key = getKey(src, crossOrigin, color);
  this.cache_[key] = iconImage;
  ++this.cacheSize_;
};

/**
* Set the cache size of the icon cache. Default is `32`. Change this value when
* your map uses more than 32 different icon images and you are not caching icon
* styles on the application level.
* @param {number} maxCacheSize Cache max size.
* @api
*/
IconImageCache.prototype.setSize = function setSize (maxCacheSize) {
  this.maxCacheSize_ = maxCacheSize;
  this.expire();
};


/**
 * @param {string} src Src.
 * @param {?string} crossOrigin Cross origin.
 * @param {import("../color.js").Color} color Color.
 * @return {string} Cache key.
 */
function getKey(src, crossOrigin, color) {
  var colorString = color ? Object(_color_js__WEBPACK_IMPORTED_MODULE_0__["asString"])(color) : 'null';
  return crossOrigin + ':' + src + ':' + colorString;
}


/* harmony default export */ __webpack_exports__["default"] = (IconImageCache);


/**
 * The {@link module:ol/style/IconImageCache~IconImageCache} for
 * {@link module:ol/style/Icon~Icon} images.
 * @api
 */
var shared = new IconImageCache();

//# sourceMappingURL=IconImageCache.js.map

/***/ }),

/***/ "./node_modules/ol/style/Image.js":
/*!****************************************!*\
  !*** ./node_modules/ol/style/Image.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/**
 * @module ol/style/Image
 */



/**
 * @typedef {Object} Options
 * @property {number} opacity
 * @property {boolean} rotateWithView
 * @property {number} rotation
 * @property {number} scale
 */


/**
 * @classdesc
 * A base class used for creating subclasses and not instantiated in
 * apps. Base class for {@link module:ol/style/Icon~Icon}, {@link module:ol/style/Circle~CircleStyle} and
 * {@link module:ol/style/RegularShape~RegularShape}.
 * @abstract
 * @api
 */
var ImageStyle = function ImageStyle(options) {

  /**
   * @private
   * @type {number}
   */
  this.opacity_ = options.opacity;

  /**
   * @private
   * @type {boolean}
   */
  this.rotateWithView_ = options.rotateWithView;

  /**
   * @private
   * @type {number}
   */
  this.rotation_ = options.rotation;

  /**
   * @private
   * @type {number}
   */
  this.scale_ = options.scale;

};

/**
 * Clones the style.
 * @return {ImageStyle} The cloned style.
 * @api
 */
ImageStyle.prototype.clone = function clone () {
  return new ImageStyle({
    opacity: this.getOpacity(),
    scale: this.getScale(),
    rotation: this.getRotation(),
    rotateWithView: this.getRotateWithView()
  });
};

/**
 * Get the symbolizer opacity.
 * @return {number} Opacity.
 * @api
 */
ImageStyle.prototype.getOpacity = function getOpacity () {
  return this.opacity_;
};

/**
 * Determine whether the symbolizer rotates with the map.
 * @return {boolean} Rotate with map.
 * @api
 */
ImageStyle.prototype.getRotateWithView = function getRotateWithView () {
  return this.rotateWithView_;
};

/**
 * Get the symoblizer rotation.
 * @return {number} Rotation.
 * @api
 */
ImageStyle.prototype.getRotation = function getRotation () {
  return this.rotation_;
};

/**
 * Get the symbolizer scale.
 * @return {number} Scale.
 * @api
 */
ImageStyle.prototype.getScale = function getScale () {
  return this.scale_;
};

/**
 * This method is deprecated and always returns false.
 * @return {boolean} false.
 * @deprecated
 * @api
 */
ImageStyle.prototype.getSnapToPixel = function getSnapToPixel () {
  return false;
};

/**
 * Get the anchor point in pixels. The anchor determines the center point for the
 * symbolizer.
 * @abstract
 * @return {Array<number>} Anchor.
 */
ImageStyle.prototype.getAnchor = function getAnchor () {
  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
};

/**
 * Get the image element for the symbolizer.
 * @abstract
 * @param {number} pixelRatio Pixel ratio.
 * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.
 */
ImageStyle.prototype.getImage = function getImage (pixelRatio) {
  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
};

/**
 * @abstract
 * @param {number} pixelRatio Pixel ratio.
 * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.
 */
ImageStyle.prototype.getHitDetectionImage = function getHitDetectionImage (pixelRatio) {
  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
};

/**
 * @abstract
 * @return {import("../ImageState.js").default} Image state.
 */
ImageStyle.prototype.getImageState = function getImageState () {
  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
};

/**
 * @abstract
 * @return {import("../size.js").Size} Image size.
 */
ImageStyle.prototype.getImageSize = function getImageSize () {
  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
};

/**
 * @abstract
 * @return {import("../size.js").Size} Size of the hit-detection image.
 */
ImageStyle.prototype.getHitDetectionImageSize = function getHitDetectionImageSize () {
  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
};

/**
 * Get the origin of the symbolizer.
 * @abstract
 * @return {Array<number>} Origin.
 */
ImageStyle.prototype.getOrigin = function getOrigin () {
  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
};

/**
 * Get the size of the symbolizer (in pixels).
 * @abstract
 * @return {import("../size.js").Size} Size.
 */
ImageStyle.prototype.getSize = function getSize () {
  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
};

/**
 * Set the opacity.
 *
 * @param {number} opacity Opacity.
 * @api
 */
ImageStyle.prototype.setOpacity = function setOpacity (opacity) {
  this.opacity_ = opacity;
};

/**
 * Set whether to rotate the style with the view.
 *
 * @param {boolean} rotateWithView Rotate with map.
 * @api
 */
ImageStyle.prototype.setRotateWithView = function setRotateWithView (rotateWithView) {
  this.rotateWithView_ = rotateWithView;
};

/**
 * Set the rotation.
 *
 * @param {number} rotation Rotation.
 * @api
 */
ImageStyle.prototype.setRotation = function setRotation (rotation) {
  this.rotation_ = rotation;
};
/**
 * Set the scale.
 *
 * @param {number} scale Scale.
 * @api
 */
ImageStyle.prototype.setScale = function setScale (scale) {
  this.scale_ = scale;
};

/**
 * This method is deprecated and does nothing.
 * @param {boolean} snapToPixel Snap to pixel?
 * @deprecated
 * @api
 */
ImageStyle.prototype.setSnapToPixel = function setSnapToPixel (snapToPixel) {};

/**
 * @abstract
 * @param {function(this: T, import("../events/Event.js").default)} listener Listener function.
 * @param {T} thisArg Value to use as `this` when executing `listener`.
 * @return {import("../events.js").EventsKey|undefined} Listener key.
 * @template T
 */
ImageStyle.prototype.listenImageChange = function listenImageChange (listener, thisArg) {
  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
};

/**
 * Load not yet loaded URI.
 * @abstract
 */
ImageStyle.prototype.load = function load () {
  Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
};

/**
 * @abstract
 * @param {function(this: T, import("../events/Event.js").default)} listener Listener function.
 * @param {T} thisArg Value to use as `this` when executing `listener`.
 * @template T
 */
ImageStyle.prototype.unlistenImageChange = function unlistenImageChange (listener, thisArg) {
  Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["abstract"])();
};

/* harmony default export */ __webpack_exports__["default"] = (ImageStyle);

//# sourceMappingURL=Image.js.map

/***/ }),

/***/ "./node_modules/ol/style/RegularShape.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/style/RegularShape.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../color.js */ "./node_modules/ol/color.js");
/* harmony import */ var _colorlike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../colorlike.js */ "./node_modules/ol/colorlike.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ImageState.js */ "./node_modules/ol/ImageState.js");
/* harmony import */ var _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../render/canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _Image_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Image.js */ "./node_modules/ol/style/Image.js");
/**
 * @module ol/style/RegularShape
 */










/**
 * Specify radius for regular polygons, or radius1 and radius2 for stars.
 * @typedef {Object} Options
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {number} points Number of points for stars and regular polygons. In case of a polygon, the number of points
 * is the number of sides.
 * @property {number} [radius] Radius of a regular polygon.
 * @property {number} [radius1] Outer radius of a star.
 * @property {number} [radius2] Inner radius of a star.
 * @property {number} [angle=0] Shape's angle in radians. A value of 0 will have one of the shape's point facing up.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view.
 * @property {import("./AtlasManager.js").default} [atlasManager] The atlas manager to use for this symbol. When
 * using WebGL it is recommended to use an atlas manager to avoid texture switching. If an atlas manager is given, the
 * symbol is added to an atlas. By default no atlas manager is used.
 */


/**
 * @typedef {Object} RenderOptions
 * @property {import("../colorlike.js").ColorLike} [strokeStyle]
 * @property {number} strokeWidth
 * @property {number} size
 * @property {string} lineCap
 * @property {Array<number>} lineDash
 * @property {number} lineDashOffset
 * @property {string} lineJoin
 * @property {number} miterLimit
 */


/**
 * @classdesc
 * Set regular shape style for vector features. The resulting shape will be
 * a regular polygon when `radius` is provided, or a star when `radius1` and
 * `radius2` are provided.
 * @api
 */
var RegularShape = /*@__PURE__*/(function (ImageStyle) {
  function RegularShape(options) {
    /**
     * @type {boolean}
     */
    var rotateWithView = options.rotateWithView !== undefined ?
      options.rotateWithView : false;

    ImageStyle.call(this, {
      opacity: 1,
      rotateWithView: rotateWithView,
      rotation: options.rotation !== undefined ? options.rotation : 0,
      scale: 1
    });

    /**
     * @private
     * @type {Array<string|number>}
     */
    this.checksums_ = null;

    /**
     * @private
     * @type {HTMLCanvasElement}
     */
    this.canvas_ = null;

    /**
     * @private
     * @type {HTMLCanvasElement}
     */
    this.hitDetectionCanvas_ = null;

    /**
     * @private
     * @type {import("./Fill.js").default}
     */
    this.fill_ = options.fill !== undefined ? options.fill : null;

    /**
     * @private
     * @type {Array<number>}
     */
    this.origin_ = [0, 0];

    /**
     * @private
     * @type {number}
     */
    this.points_ = options.points;

    /**
     * @protected
     * @type {number}
     */
    this.radius_ = /** @type {number} */ (options.radius !== undefined ?
      options.radius : options.radius1);

    /**
     * @private
     * @type {number|undefined}
     */
    this.radius2_ = options.radius2;

    /**
     * @private
     * @type {number}
     */
    this.angle_ = options.angle !== undefined ? options.angle : 0;

    /**
     * @private
     * @type {import("./Stroke.js").default}
     */
    this.stroke_ = options.stroke !== undefined ? options.stroke : null;

    /**
     * @private
     * @type {Array<number>}
     */
    this.anchor_ = null;

    /**
     * @private
     * @type {import("../size.js").Size}
     */
    this.size_ = null;

    /**
     * @private
     * @type {import("../size.js").Size}
     */
    this.imageSize_ = null;

    /**
     * @private
     * @type {import("../size.js").Size}
     */
    this.hitDetectionImageSize_ = null;

    /**
     * @protected
     * @type {import("./AtlasManager.js").default|undefined}
     */
    this.atlasManager_ = options.atlasManager;

    this.render_(this.atlasManager_);

  }

  if ( ImageStyle ) RegularShape.__proto__ = ImageStyle;
  RegularShape.prototype = Object.create( ImageStyle && ImageStyle.prototype );
  RegularShape.prototype.constructor = RegularShape;

  /**
   * Clones the style. If an atlasmanager was provided to the original style it will be used in the cloned style, too.
   * @return {RegularShape} The cloned style.
   * @api
   */
  RegularShape.prototype.clone = function clone () {
    var style = new RegularShape({
      fill: this.getFill() ? this.getFill().clone() : undefined,
      points: this.getPoints(),
      radius: this.getRadius(),
      radius2: this.getRadius2(),
      angle: this.getAngle(),
      stroke: this.getStroke() ? this.getStroke().clone() : undefined,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      atlasManager: this.atlasManager_
    });
    style.setOpacity(this.getOpacity());
    style.setScale(this.getScale());
    return style;
  };

  /**
   * @inheritDoc
   * @api
   */
  RegularShape.prototype.getAnchor = function getAnchor () {
    return this.anchor_;
  };

  /**
   * Get the angle used in generating the shape.
   * @return {number} Shape's rotation in radians.
   * @api
   */
  RegularShape.prototype.getAngle = function getAngle () {
    return this.angle_;
  };

  /**
   * Get the fill style for the shape.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */
  RegularShape.prototype.getFill = function getFill () {
    return this.fill_;
  };

  /**
   * @inheritDoc
   */
  RegularShape.prototype.getHitDetectionImage = function getHitDetectionImage (pixelRatio) {
    return this.hitDetectionCanvas_;
  };

  /**
   * @inheritDoc
   * @api
   */
  RegularShape.prototype.getImage = function getImage (pixelRatio) {
    return this.canvas_;
  };

  /**
   * @inheritDoc
   */
  RegularShape.prototype.getImageSize = function getImageSize () {
    return this.imageSize_;
  };

  /**
   * @inheritDoc
   */
  RegularShape.prototype.getHitDetectionImageSize = function getHitDetectionImageSize () {
    return this.hitDetectionImageSize_;
  };

  /**
   * @inheritDoc
   */
  RegularShape.prototype.getImageState = function getImageState () {
    return _ImageState_js__WEBPACK_IMPORTED_MODULE_4__["default"].LOADED;
  };

  /**
   * @inheritDoc
   * @api
   */
  RegularShape.prototype.getOrigin = function getOrigin () {
    return this.origin_;
  };

  /**
   * Get the number of points for generating the shape.
   * @return {number} Number of points for stars and regular polygons.
   * @api
   */
  RegularShape.prototype.getPoints = function getPoints () {
    return this.points_;
  };

  /**
   * Get the (primary) radius for the shape.
   * @return {number} Radius.
   * @api
   */
  RegularShape.prototype.getRadius = function getRadius () {
    return this.radius_;
  };

  /**
   * Get the secondary radius for the shape.
   * @return {number|undefined} Radius2.
   * @api
   */
  RegularShape.prototype.getRadius2 = function getRadius2 () {
    return this.radius2_;
  };

  /**
   * @inheritDoc
   * @api
   */
  RegularShape.prototype.getSize = function getSize () {
    return this.size_;
  };

  /**
   * Get the stroke style for the shape.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */
  RegularShape.prototype.getStroke = function getStroke () {
    return this.stroke_;
  };

  /**
   * @inheritDoc
   */
  RegularShape.prototype.listenImageChange = function listenImageChange (listener, thisArg) {
    return undefined;
  };

  /**
   * @inheritDoc
   */
  RegularShape.prototype.load = function load () {};

  /**
   * @inheritDoc
   */
  RegularShape.prototype.unlistenImageChange = function unlistenImageChange (listener, thisArg) {};

  /**
   * @protected
   * @param {import("./AtlasManager.js").default|undefined} atlasManager An atlas manager.
   */
  RegularShape.prototype.render_ = function render_ (atlasManager) {
    var imageSize;
    var lineCap = '';
    var lineJoin = '';
    var miterLimit = 0;
    var lineDash = null;
    var lineDashOffset = 0;
    var strokeStyle;
    var strokeWidth = 0;

    if (this.stroke_) {
      strokeStyle = this.stroke_.getColor();
      if (strokeStyle === null) {
        strokeStyle = _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["defaultStrokeStyle"];
      }
      strokeStyle = Object(_colorlike_js__WEBPACK_IMPORTED_MODULE_1__["asColorLike"])(strokeStyle);
      strokeWidth = this.stroke_.getWidth();
      if (strokeWidth === undefined) {
        strokeWidth = _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["defaultLineWidth"];
      }
      lineDash = this.stroke_.getLineDash();
      lineDashOffset = this.stroke_.getLineDashOffset();
      if (!_has_js__WEBPACK_IMPORTED_MODULE_3__["CANVAS_LINE_DASH"]) {
        lineDash = null;
        lineDashOffset = 0;
      }
      lineJoin = this.stroke_.getLineJoin();
      if (lineJoin === undefined) {
        lineJoin = _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["defaultLineJoin"];
      }
      lineCap = this.stroke_.getLineCap();
      if (lineCap === undefined) {
        lineCap = _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["defaultLineCap"];
      }
      miterLimit = this.stroke_.getMiterLimit();
      if (miterLimit === undefined) {
        miterLimit = _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["defaultMiterLimit"];
      }
    }

    var size = 2 * (this.radius_ + strokeWidth) + 1;

    /** @type {RenderOptions} */
    var renderOptions = {
      strokeStyle: strokeStyle,
      strokeWidth: strokeWidth,
      size: size,
      lineCap: lineCap,
      lineDash: lineDash,
      lineDashOffset: lineDashOffset,
      lineJoin: lineJoin,
      miterLimit: miterLimit
    };

    if (atlasManager === undefined) {
      // no atlas manager is used, create a new canvas
      var context = Object(_dom_js__WEBPACK_IMPORTED_MODULE_2__["createCanvasContext2D"])(size, size);
      this.canvas_ = context.canvas;

      // canvas.width and height are rounded to the closest integer
      size = this.canvas_.width;
      imageSize = size;

      this.draw_(renderOptions, context, 0, 0);

      this.createHitDetectionCanvas_(renderOptions);
    } else {
      // an atlas manager is used, add the symbol to an atlas
      size = Math.round(size);

      var hasCustomHitDetectionImage = !this.fill_;
      var renderHitDetectionCallback;
      if (hasCustomHitDetectionImage) {
        // render the hit-detection image into a separate atlas image
        renderHitDetectionCallback =
            this.drawHitDetectionCanvas_.bind(this, renderOptions);
      }

      var id = this.getChecksum();
      var info = atlasManager.add(
        id, size, size, this.draw_.bind(this, renderOptions),
        renderHitDetectionCallback);

      this.canvas_ = info.image;
      this.origin_ = [info.offsetX, info.offsetY];
      imageSize = info.image.width;

      if (hasCustomHitDetectionImage) {
        this.hitDetectionCanvas_ = info.hitImage;
        this.hitDetectionImageSize_ =
            [info.hitImage.width, info.hitImage.height];
      } else {
        this.hitDetectionCanvas_ = this.canvas_;
        this.hitDetectionImageSize_ = [imageSize, imageSize];
      }
    }

    this.anchor_ = [size / 2, size / 2];
    this.size_ = [size, size];
    this.imageSize_ = [imageSize, imageSize];
  };

  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The rendering context.
   * @param {number} x The origin for the symbol (x).
   * @param {number} y The origin for the symbol (y).
   */
  RegularShape.prototype.draw_ = function draw_ (renderOptions, context, x, y) {
    var i, angle0, radiusC;
    // reset transform
    context.setTransform(1, 0, 0, 1, 0, 0);

    // then move to (x, y)
    context.translate(x, y);

    context.beginPath();

    var points = this.points_;
    if (points === Infinity) {
      context.arc(
        renderOptions.size / 2, renderOptions.size / 2,
        this.radius_, 0, 2 * Math.PI, true);
    } else {
      var radius2 = (this.radius2_ !== undefined) ? this.radius2_
        : this.radius_;
      if (radius2 !== this.radius_) {
        points = 2 * points;
      }
      for (i = 0; i <= points; i++) {
        angle0 = i * 2 * Math.PI / points - Math.PI / 2 + this.angle_;
        radiusC = i % 2 === 0 ? this.radius_ : radius2;
        context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0),
          renderOptions.size / 2 + radiusC * Math.sin(angle0));
      }
    }


    if (this.fill_) {
      var color = this.fill_.getColor();
      if (color === null) {
        color = _render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["defaultFillStyle"];
      }
      context.fillStyle = Object(_colorlike_js__WEBPACK_IMPORTED_MODULE_1__["asColorLike"])(color);
      context.fill();
    }
    if (this.stroke_) {
      context.strokeStyle = renderOptions.strokeStyle;
      context.lineWidth = renderOptions.strokeWidth;
      if (renderOptions.lineDash) {
        context.setLineDash(renderOptions.lineDash);
        context.lineDashOffset = renderOptions.lineDashOffset;
      }
      context.lineCap = /** @type {CanvasLineCap} */ (renderOptions.lineCap);
      context.lineJoin = /** @type {CanvasLineJoin} */ (renderOptions.lineJoin);
      context.miterLimit = renderOptions.miterLimit;
      context.stroke();
    }
    context.closePath();
  };

  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   */
  RegularShape.prototype.createHitDetectionCanvas_ = function createHitDetectionCanvas_ (renderOptions) {
    this.hitDetectionImageSize_ = [renderOptions.size, renderOptions.size];
    if (this.fill_) {
      this.hitDetectionCanvas_ = this.canvas_;
      return;
    }

    // if no fill style is set, create an extra hit-detection image with a
    // default fill style
    var context = Object(_dom_js__WEBPACK_IMPORTED_MODULE_2__["createCanvasContext2D"])(renderOptions.size, renderOptions.size);
    this.hitDetectionCanvas_ = context.canvas;

    this.drawHitDetectionCanvas_(renderOptions, context, 0, 0);
  };

  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The context.
   * @param {number} x The origin for the symbol (x).
   * @param {number} y The origin for the symbol (y).
   */
  RegularShape.prototype.drawHitDetectionCanvas_ = function drawHitDetectionCanvas_ (renderOptions, context, x, y) {
    // reset transform
    context.setTransform(1, 0, 0, 1, 0, 0);

    // then move to (x, y)
    context.translate(x, y);

    context.beginPath();

    var points = this.points_;
    if (points === Infinity) {
      context.arc(
        renderOptions.size / 2, renderOptions.size / 2,
        this.radius_, 0, 2 * Math.PI, true);
    } else {
      var radius2 = (this.radius2_ !== undefined) ? this.radius2_
        : this.radius_;
      if (radius2 !== this.radius_) {
        points = 2 * points;
      }
      var i, radiusC, angle0;
      for (i = 0; i <= points; i++) {
        angle0 = i * 2 * Math.PI / points - Math.PI / 2 + this.angle_;
        radiusC = i % 2 === 0 ? this.radius_ : radius2;
        context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0),
          renderOptions.size / 2 + radiusC * Math.sin(angle0));
      }
    }

    context.fillStyle = Object(_color_js__WEBPACK_IMPORTED_MODULE_0__["asString"])(_render_canvas_js__WEBPACK_IMPORTED_MODULE_5__["defaultFillStyle"]);
    context.fill();
    if (this.stroke_) {
      context.strokeStyle = renderOptions.strokeStyle;
      context.lineWidth = renderOptions.strokeWidth;
      if (renderOptions.lineDash) {
        context.setLineDash(renderOptions.lineDash);
        context.lineDashOffset = renderOptions.lineDashOffset;
      }
      context.stroke();
    }
    context.closePath();
  };

  /**
   * @return {string} The checksum.
   */
  RegularShape.prototype.getChecksum = function getChecksum () {
    var strokeChecksum = this.stroke_ ?
      this.stroke_.getChecksum() : '-';
    var fillChecksum = this.fill_ ?
      this.fill_.getChecksum() : '-';

    var recalculate = !this.checksums_ ||
        (strokeChecksum != this.checksums_[1] ||
        fillChecksum != this.checksums_[2] ||
        this.radius_ != this.checksums_[3] ||
        this.radius2_ != this.checksums_[4] ||
        this.angle_ != this.checksums_[5] ||
        this.points_ != this.checksums_[6]);

    if (recalculate) {
      var checksum = 'r' + strokeChecksum + fillChecksum +
          (this.radius_ !== undefined ? this.radius_.toString() : '-') +
          (this.radius2_ !== undefined ? this.radius2_.toString() : '-') +
          (this.angle_ !== undefined ? this.angle_.toString() : '-') +
          (this.points_ !== undefined ? this.points_.toString() : '-');
      this.checksums_ = [checksum, strokeChecksum, fillChecksum,
        this.radius_, this.radius2_, this.angle_, this.points_];
    }

    return /** @type {string} */ (this.checksums_[0]);
  };

  return RegularShape;
}(_Image_js__WEBPACK_IMPORTED_MODULE_6__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (RegularShape);

//# sourceMappingURL=RegularShape.js.map

/***/ }),

/***/ "./node_modules/ol/style/Stroke.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/style/Stroke.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/**
 * @module ol/style/Stroke
 */



/**
 * @typedef {Object} Options
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [color] A color, gradient or pattern.
 * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
 * Default null; if null, the Canvas/renderer default black will be used.
 * @property {string} [lineCap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {string} [lineJoin='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {Array<number>} [lineDash] Line dash pattern. Default is `undefined` (no dash).
 * Please note that Internet Explorer 10 and lower do not support the `setLineDash` method on
 * the `CanvasRenderingContext2D` and therefore this option will have no visual effect in these browsers.
 * @property {number} [lineDashOffset=0] Line dash offset.
 * @property {number} [miterLimit=10] Miter limit.
 * @property {number} [width] Width.
 */


/**
 * @classdesc
 * Set stroke style for vector features.
 * Note that the defaults given are the Canvas defaults, which will be used if
 * option is not defined. The `get` functions return whatever was entered in
 * the options; they will not return the default.
 * @api
 */
var Stroke = function Stroke(opt_options) {

  var options = opt_options || {};

  /**
   * @private
   * @type {import("../color.js").Color|import("../colorlike.js").ColorLike}
   */
  this.color_ = options.color !== undefined ? options.color : null;

  /**
   * @private
   * @type {string|undefined}
   */
  this.lineCap_ = options.lineCap;

  /**
   * @private
   * @type {Array<number>}
   */
  this.lineDash_ = options.lineDash !== undefined ? options.lineDash : null;

  /**
   * @private
   * @type {number|undefined}
   */
  this.lineDashOffset_ = options.lineDashOffset;

  /**
   * @private
   * @type {string|undefined}
   */
  this.lineJoin_ = options.lineJoin;

  /**
   * @private
   * @type {number|undefined}
   */
  this.miterLimit_ = options.miterLimit;

  /**
   * @private
   * @type {number|undefined}
   */
  this.width_ = options.width;

  /**
   * @private
   * @type {string|undefined}
   */
  this.checksum_ = undefined;
};

/**
 * Clones the style.
 * @return {Stroke} The cloned style.
 * @api
 */
Stroke.prototype.clone = function clone () {
  var color = this.getColor();
  return new Stroke({
    color: Array.isArray(color) ? color.slice() : color || undefined,
    lineCap: this.getLineCap(),
    lineDash: this.getLineDash() ? this.getLineDash().slice() : undefined,
    lineDashOffset: this.getLineDashOffset(),
    lineJoin: this.getLineJoin(),
    miterLimit: this.getMiterLimit(),
    width: this.getWidth()
  });
};

/**
 * Get the stroke color.
 * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
 * @api
 */
Stroke.prototype.getColor = function getColor () {
  return this.color_;
};

/**
 * Get the line cap type for the stroke.
 * @return {string|undefined} Line cap.
 * @api
 */
Stroke.prototype.getLineCap = function getLineCap () {
  return this.lineCap_;
};

/**
 * Get the line dash style for the stroke.
 * @return {Array<number>} Line dash.
 * @api
 */
Stroke.prototype.getLineDash = function getLineDash () {
  return this.lineDash_;
};

/**
 * Get the line dash offset for the stroke.
 * @return {number|undefined} Line dash offset.
 * @api
 */
Stroke.prototype.getLineDashOffset = function getLineDashOffset () {
  return this.lineDashOffset_;
};

/**
 * Get the line join type for the stroke.
 * @return {string|undefined} Line join.
 * @api
 */
Stroke.prototype.getLineJoin = function getLineJoin () {
  return this.lineJoin_;
};

/**
 * Get the miter limit for the stroke.
 * @return {number|undefined} Miter limit.
 * @api
 */
Stroke.prototype.getMiterLimit = function getMiterLimit () {
  return this.miterLimit_;
};

/**
 * Get the stroke width.
 * @return {number|undefined} Width.
 * @api
 */
Stroke.prototype.getWidth = function getWidth () {
  return this.width_;
};

/**
 * Set the color.
 *
 * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
 * @api
 */
Stroke.prototype.setColor = function setColor (color) {
  this.color_ = color;
  this.checksum_ = undefined;
};

/**
 * Set the line cap.
 *
 * @param {string|undefined} lineCap Line cap.
 * @api
 */
Stroke.prototype.setLineCap = function setLineCap (lineCap) {
  this.lineCap_ = lineCap;
  this.checksum_ = undefined;
};

/**
 * Set the line dash.
 *
 * Please note that Internet Explorer 10 and lower [do not support][mdn] the
 * `setLineDash` method on the `CanvasRenderingContext2D` and therefore this
 * property will have no visual effect in these browsers.
 *
 * [mdn]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility
 *
 * @param {Array<number>} lineDash Line dash.
 * @api
 */
Stroke.prototype.setLineDash = function setLineDash (lineDash) {
  this.lineDash_ = lineDash;
  this.checksum_ = undefined;
};

/**
 * Set the line dash offset.
 *
 * @param {number|undefined} lineDashOffset Line dash offset.
 * @api
 */
Stroke.prototype.setLineDashOffset = function setLineDashOffset (lineDashOffset) {
  this.lineDashOffset_ = lineDashOffset;
  this.checksum_ = undefined;
};

/**
 * Set the line join.
 *
 * @param {string|undefined} lineJoin Line join.
 * @api
 */
Stroke.prototype.setLineJoin = function setLineJoin (lineJoin) {
  this.lineJoin_ = lineJoin;
  this.checksum_ = undefined;
};

/**
 * Set the miter limit.
 *
 * @param {number|undefined} miterLimit Miter limit.
 * @api
 */
Stroke.prototype.setMiterLimit = function setMiterLimit (miterLimit) {
  this.miterLimit_ = miterLimit;
  this.checksum_ = undefined;
};

/**
 * Set the width.
 *
 * @param {number|undefined} width Width.
 * @api
 */
Stroke.prototype.setWidth = function setWidth (width) {
  this.width_ = width;
  this.checksum_ = undefined;
};

/**
 * @return {string} The checksum.
 */
Stroke.prototype.getChecksum = function getChecksum () {
  if (this.checksum_ === undefined) {
    this.checksum_ = 's';
    if (this.color_) {
      if (typeof this.color_ === 'string') {
        this.checksum_ += this.color_;
      } else {
        this.checksum_ += Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(this.color_);
      }
    } else {
      this.checksum_ += '-';
    }
    this.checksum_ += ',' +
        (this.lineCap_ !== undefined ?
          this.lineCap_.toString() : '-') + ',' +
        (this.lineDash_ ?
          this.lineDash_.toString() : '-') + ',' +
        (this.lineDashOffset_ !== undefined ?
          this.lineDashOffset_ : '-') + ',' +
        (this.lineJoin_ !== undefined ?
          this.lineJoin_ : '-') + ',' +
        (this.miterLimit_ !== undefined ?
          this.miterLimit_.toString() : '-') + ',' +
        (this.width_ !== undefined ?
          this.width_.toString() : '-');
  }

  return this.checksum_;
};

/* harmony default export */ __webpack_exports__["default"] = (Stroke);

//# sourceMappingURL=Stroke.js.map

/***/ }),

/***/ "./node_modules/ol/style/Style.js":
/*!****************************************!*\
  !*** ./node_modules/ol/style/Style.js ***!
  \****************************************/
/*! exports provided: toFunction, createDefaultStyle, createEditingStyle, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toFunction", function() { return toFunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createDefaultStyle", function() { return createDefaultStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createEditingStyle", function() { return createEditingStyle; });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _Circle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Circle.js */ "./node_modules/ol/style/Circle.js");
/* harmony import */ var _Fill_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Fill.js */ "./node_modules/ol/style/Fill.js");
/* harmony import */ var _Stroke_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Stroke.js */ "./node_modules/ol/style/Stroke.js");
/**
 * @module ol/style/Style
 */

/**
 * Feature styles.
 *
 * If no style is defined, the following default style is used:
 * ```js
 *  import {Fill, Stroke, Circle, Style} from 'ol/style';
 *
 *  var fill = new Fill({
 *    color: 'rgba(255,255,255,0.4)'
 *  });
 *  var stroke = new Stroke({
 *    color: '#3399CC',
 *    width: 1.25
 *  });
 *  var styles = [
 *    new Style({
 *      image: new Circle({
 *        fill: fill,
 *        stroke: stroke,
 *        radius: 5
 *      }),
 *      fill: fill,
 *      stroke: stroke
 *    })
 *  ];
 * ```
 *
 * A separate editing style has the following defaults:
 * ```js
 *  import {Fill, Stroke, Circle, Style} from 'ol/style';
 *  import GeometryType from 'ol/geom/GeometryType';
 *
 *  var white = [255, 255, 255, 1];
 *  var blue = [0, 153, 255, 1];
 *  var width = 3;
 *  styles[GeometryType.POLYGON] = [
 *    new Style({
 *      fill: new Fill({
 *        color: [255, 255, 255, 0.5]
 *      })
 *    })
 *  ];
 *  styles[GeometryType.MULTI_POLYGON] =
 *      styles[GeometryType.POLYGON];
 *  styles[GeometryType.LINE_STRING] = [
 *    new Style({
 *      stroke: new Stroke({
 *        color: white,
 *        width: width + 2
 *      })
 *    }),
 *    new Style({
 *      stroke: new Stroke({
 *        color: blue,
 *        width: width
 *      })
 *    })
 *  ];
 *  styles[GeometryType.MULTI_LINE_STRING] =
 *      styles[GeometryType.LINE_STRING];
 *  styles[GeometryType.POINT] = [
 *    new Style({
 *      image: new Circle({
 *        radius: width * 2,
 *        fill: new Fill({
 *          color: blue
 *        }),
 *        stroke: new Stroke({
 *          color: white,
 *          width: width / 2
 *        })
 *      }),
 *      zIndex: Infinity
 *    })
 *  ];
 *  styles[GeometryType.MULTI_POINT] =
 *      styles[GeometryType.POINT];
 *  styles[GeometryType.GEOMETRY_COLLECTION] =
 *      styles[GeometryType.POLYGON].concat(
 *          styles[GeometryType.LINE_STRING],
 *          styles[GeometryType.POINT]
 *      );
 * ```
 */







/**
 * A function that takes an {@link module:ol/Feature} and a `{number}`
 * representing the view's resolution. The function should return a
 * {@link module:ol/style/Style} or an array of them. This way e.g. a
 * vector layer can be styled.
 *
 * @typedef {function(import("../Feature.js").FeatureLike, number):(Style|Array<Style>)} StyleFunction
 */

/**
 * A {@link Style}, an array of {@link Style}, or a {@link StyleFunction}.
 * @typedef {Style|Array<Style>|StyleFunction} StyleLike
 */

/**
 * A function that takes an {@link module:ol/Feature} as argument and returns an
 * {@link module:ol/geom/Geometry} that will be rendered and styled for the feature.
 *
 * @typedef {function(import("../Feature.js").FeatureLike):
 *     (import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined)} GeometryFunction
 */


/**
 * Custom renderer function. Takes two arguments:
 *
 * 1. The pixel coordinates of the geometry in GeoJSON notation.
 * 2. The {@link module:ol/render~State} of the layer renderer.
 *
 * @typedef {function((import("../coordinate.js").Coordinate|Array<import("../coordinate.js").Coordinate>|Array<Array<import("../coordinate.js").Coordinate>>),import("../render.js").State)}
 * RenderFunction
 */


/**
 * @typedef {Object} Options
 * @property {string|import("../geom/Geometry.js").default|GeometryFunction} [geometry] Feature property or geometry
 * or function returning a geometry to render for this style.
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {import("./Image.js").default} [image] Image style.
 * @property {RenderFunction} [renderer] Custom renderer. When configured, `fill`, `stroke` and `image` will be
 * ignored, and the provided function will be called with each render frame for each geometry.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {import("./Text.js").default} [text] Text style.
 * @property {number} [zIndex] Z index.
 */

/**
 * @classdesc
 * Container for vector feature rendering styles. Any changes made to the style
 * or its children through `set*()` methods will not take effect until the
 * feature or layer that uses the style is re-rendered.
 * @api
 */
var Style = function Style(opt_options) {

  var options = opt_options || {};

  /**
   * @private
   * @type {string|import("../geom/Geometry.js").default|GeometryFunction}
   */
  this.geometry_ = null;

  /**
   * @private
   * @type {!GeometryFunction}
   */
  this.geometryFunction_ = defaultGeometryFunction;

  if (options.geometry !== undefined) {
    this.setGeometry(options.geometry);
  }

  /**
   * @private
   * @type {import("./Fill.js").default}
   */
  this.fill_ = options.fill !== undefined ? options.fill : null;

  /**
     * @private
     * @type {import("./Image.js").default}
     */
  this.image_ = options.image !== undefined ? options.image : null;

  /**
   * @private
   * @type {RenderFunction|null}
   */
  this.renderer_ = options.renderer !== undefined ? options.renderer : null;

  /**
   * @private
   * @type {import("./Stroke.js").default}
   */
  this.stroke_ = options.stroke !== undefined ? options.stroke : null;

  /**
   * @private
   * @type {import("./Text.js").default}
   */
  this.text_ = options.text !== undefined ? options.text : null;

  /**
   * @private
   * @type {number|undefined}
   */
  this.zIndex_ = options.zIndex;

};

/**
 * Clones the style.
 * @return {Style} The cloned style.
 * @api
 */
Style.prototype.clone = function clone () {
  var geometry = this.getGeometry();
  if (geometry && typeof geometry === 'object') {
    geometry = /** @type {import("../geom/Geometry.js").default} */ (geometry).clone();
  }
  return new Style({
    geometry: geometry,
    fill: this.getFill() ? this.getFill().clone() : undefined,
    image: this.getImage() ? this.getImage().clone() : undefined,
    stroke: this.getStroke() ? this.getStroke().clone() : undefined,
    text: this.getText() ? this.getText().clone() : undefined,
    zIndex: this.getZIndex()
  });
};

/**
 * Get the custom renderer function that was configured with
 * {@link #setRenderer} or the `renderer` constructor option.
 * @return {RenderFunction|null} Custom renderer function.
 * @api
 */
Style.prototype.getRenderer = function getRenderer () {
  return this.renderer_;
};

/**
 * Sets a custom renderer function for this style. When set, `fill`, `stroke`
 * and `image` options of the style will be ignored.
 * @param {RenderFunction|null} renderer Custom renderer function.
 * @api
 */
Style.prototype.setRenderer = function setRenderer (renderer) {
  this.renderer_ = renderer;
};

/**
 * Get the geometry to be rendered.
 * @return {string|import("../geom/Geometry.js").default|GeometryFunction}
 * Feature property or geometry or function that returns the geometry that will
 * be rendered with this style.
 * @api
 */
Style.prototype.getGeometry = function getGeometry () {
  return this.geometry_;
};

/**
 * Get the function used to generate a geometry for rendering.
 * @return {!GeometryFunction} Function that is called with a feature
 * and returns the geometry to render instead of the feature's geometry.
 * @api
 */
Style.prototype.getGeometryFunction = function getGeometryFunction () {
  return this.geometryFunction_;
};

/**
 * Get the fill style.
 * @return {import("./Fill.js").default} Fill style.
 * @api
 */
Style.prototype.getFill = function getFill () {
  return this.fill_;
};

/**
 * Set the fill style.
 * @param {import("./Fill.js").default} fill Fill style.
 * @api
 */
Style.prototype.setFill = function setFill (fill) {
  this.fill_ = fill;
};

/**
 * Get the image style.
 * @return {import("./Image.js").default} Image style.
 * @api
 */
Style.prototype.getImage = function getImage () {
  return this.image_;
};

/**
 * Set the image style.
 * @param {import("./Image.js").default} image Image style.
 * @api
 */
Style.prototype.setImage = function setImage (image) {
  this.image_ = image;
};

/**
 * Get the stroke style.
 * @return {import("./Stroke.js").default} Stroke style.
 * @api
 */
Style.prototype.getStroke = function getStroke () {
  return this.stroke_;
};

/**
 * Set the stroke style.
 * @param {import("./Stroke.js").default} stroke Stroke style.
 * @api
 */
Style.prototype.setStroke = function setStroke (stroke) {
  this.stroke_ = stroke;
};

/**
 * Get the text style.
 * @return {import("./Text.js").default} Text style.
 * @api
 */
Style.prototype.getText = function getText () {
  return this.text_;
};

/**
 * Set the text style.
 * @param {import("./Text.js").default} text Text style.
 * @api
 */
Style.prototype.setText = function setText (text) {
  this.text_ = text;
};

/**
 * Get the z-index for the style.
 * @return {number|undefined} ZIndex.
 * @api
 */
Style.prototype.getZIndex = function getZIndex () {
  return this.zIndex_;
};

/**
 * Set a geometry that is rendered instead of the feature's geometry.
 *
 * @param {string|import("../geom/Geometry.js").default|GeometryFunction} geometry
 *   Feature property or geometry or function returning a geometry to render
 *   for this style.
 * @api
 */
Style.prototype.setGeometry = function setGeometry (geometry) {
  if (typeof geometry === 'function') {
    this.geometryFunction_ = geometry;
  } else if (typeof geometry === 'string') {
    this.geometryFunction_ = function(feature) {
      return (
        /** @type {import("../geom/Geometry.js").default} */ (feature.get(geometry))
      );
    };
  } else if (!geometry) {
    this.geometryFunction_ = defaultGeometryFunction;
  } else if (geometry !== undefined) {
    this.geometryFunction_ = function() {
      return (
        /** @type {import("../geom/Geometry.js").default} */ (geometry)
      );
    };
  }
  this.geometry_ = geometry;
};

/**
 * Set the z-index.
 *
 * @param {number|undefined} zIndex ZIndex.
 * @api
 */
Style.prototype.setZIndex = function setZIndex (zIndex) {
  this.zIndex_ = zIndex;
};


/**
 * Convert the provided object into a style function.  Functions passed through
 * unchanged.  Arrays of Style or single style objects wrapped in a
 * new style function.
 * @param {StyleFunction|Array<Style>|Style} obj
 *     A style function, a single style, or an array of styles.
 * @return {StyleFunction} A style function.
 */
function toFunction(obj) {
  var styleFunction;

  if (typeof obj === 'function') {
    styleFunction = obj;
  } else {
    /**
     * @type {Array<Style>}
     */
    var styles;
    if (Array.isArray(obj)) {
      styles = obj;
    } else {
      Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(typeof /** @type {?} */ (obj).getZIndex === 'function',
        41); // Expected an `Style` or an array of `Style`
      var style = /** @type {Style} */ (obj);
      styles = [style];
    }
    styleFunction = function() {
      return styles;
    };
  }
  return styleFunction;
}


/**
 * @type {Array<Style>}
 */
var defaultStyles = null;


/**
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {number} resolution Resolution.
 * @return {Array<Style>} Style.
 */
function createDefaultStyle(feature, resolution) {
  // We don't use an immediately-invoked function
  // and a closure so we don't get an error at script evaluation time in
  // browsers that do not support Canvas. (import("./Circle.js").CircleStyle does
  // canvas.getContext('2d') at construction time, which will cause an.error
  // in such browsers.)
  if (!defaultStyles) {
    var fill = new _Fill_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
      color: 'rgba(255,255,255,0.4)'
    });
    var stroke = new _Stroke_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
      color: '#3399CC',
      width: 1.25
    });
    defaultStyles = [
      new Style({
        image: new _Circle_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
          fill: fill,
          stroke: stroke,
          radius: 5
        }),
        fill: fill,
        stroke: stroke
      })
    ];
  }
  return defaultStyles;
}


/**
 * Default styles for editing features.
 * @return {Object<import("../geom/GeometryType.js").default, Array<Style>>} Styles
 */
function createEditingStyle() {
  /** @type {Object<import("../geom/GeometryType.js").default, Array<Style>>} */
  var styles = {};
  var white = [255, 255, 255, 1];
  var blue = [0, 153, 255, 1];
  var width = 3;
  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POLYGON] = [
    new Style({
      fill: new _Fill_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
        color: [255, 255, 255, 0.5]
      })
    })
  ];
  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POLYGON] =
      styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POLYGON];

  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINE_STRING] = [
    new Style({
      stroke: new _Stroke_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
        color: white,
        width: width + 2
      })
    }),
    new Style({
      stroke: new _Stroke_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
        color: blue,
        width: width
      })
    })
  ];
  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_LINE_STRING] =
      styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINE_STRING];

  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CIRCLE] =
      styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POLYGON].concat(
        styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINE_STRING]
      );


  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINT] = [
    new Style({
      image: new _Circle_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
        radius: width * 2,
        fill: new _Fill_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
          color: blue
        }),
        stroke: new _Stroke_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
          color: white,
          width: width / 2
        })
      }),
      zIndex: Infinity
    })
  ];
  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POINT] =
      styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINT];

  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].GEOMETRY_COLLECTION] =
      styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POLYGON].concat(
        styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINE_STRING],
        styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINT]
      );

  return styles;
}


/**
 * Function that is called with a feature and returns its default geometry.
 * @param {import("../Feature.js").FeatureLike} feature Feature to get the geometry for.
 * @return {import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined} Geometry to render.
 */
function defaultGeometryFunction(feature) {
  return feature.getGeometry();
}

/* harmony default export */ __webpack_exports__["default"] = (Style);

//# sourceMappingURL=Style.js.map

/***/ }),

/***/ "./node_modules/ol/style/TextPlacement.js":
/*!************************************************!*\
  !*** ./node_modules/ol/style/TextPlacement.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/style/TextPlacement
 */

/**
 * Text placement. One of `'point'`, `'line'`. Default is `'point'`. Note that
 * `'line'` requires the underlying geometry to be a {@link module:ol/geom/LineString~LineString},
 * {@link module:ol/geom/Polygon~Polygon}, {@link module:ol/geom/MultiLineString~MultiLineString} or
 * {@link module:ol/geom/MultiPolygon~MultiPolygon}.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  POINT: 'point',
  LINE: 'line'
});

//# sourceMappingURL=TextPlacement.js.map

/***/ }),

/***/ "./node_modules/ol/tilecoord.js":
/*!**************************************!*\
  !*** ./node_modules/ol/tilecoord.js ***!
  \**************************************/
/*! exports provided: createOrUpdate, getKeyZXY, getKey, fromKey, hash, quadKey, withinExtentAndZ */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdate", function() { return createOrUpdate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getKeyZXY", function() { return getKeyZXY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getKey", function() { return getKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromKey", function() { return fromKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hash", function() { return hash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quadKey", function() { return quadKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "withinExtentAndZ", function() { return withinExtentAndZ; });
/**
 * @module ol/tilecoord
 */


/**
 * An array of three numbers representing the location of a tile in a tile
 * grid. The order is `z`, `x`, and `y`. `z` is the zoom level.
 * @typedef {Array<number>} TileCoord
 * @api
 */


/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {TileCoord=} opt_tileCoord Tile coordinate.
 * @return {TileCoord} Tile coordinate.
 */
function createOrUpdate(z, x, y, opt_tileCoord) {
  if (opt_tileCoord !== undefined) {
    opt_tileCoord[0] = z;
    opt_tileCoord[1] = x;
    opt_tileCoord[2] = y;
    return opt_tileCoord;
  } else {
    return [z, x, y];
  }
}


/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {string} Key.
 */
function getKeyZXY(z, x, y) {
  return z + '/' + x + '/' + y;
}


/**
 * Get the key for a tile coord.
 * @param {TileCoord} tileCoord The tile coord.
 * @return {string} Key.
 */
function getKey(tileCoord) {
  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);
}


/**
 * Get a tile coord given a key.
 * @param {string} key The tile coord key.
 * @return {TileCoord} The tile coord.
 */
function fromKey(key) {
  return key.split('/').map(Number);
}


/**
 * @param {TileCoord} tileCoord Tile coord.
 * @return {number} Hash.
 */
function hash(tileCoord) {
  return (tileCoord[1] << tileCoord[0]) + tileCoord[2];
}


/**
 * @param {TileCoord} tileCoord Tile coord.
 * @return {string} Quad key.
 */
function quadKey(tileCoord) {
  var z = tileCoord[0];
  var digits = new Array(z);
  var mask = 1 << (z - 1);
  var i, charCode;
  for (i = 0; i < z; ++i) {
    // 48 is charCode for 0 - '0'.charCodeAt(0)
    charCode = 48;
    if (tileCoord[1] & mask) {
      charCode += 1;
    }
    if (tileCoord[2] & mask) {
      charCode += 2;
    }
    digits[i] = String.fromCharCode(charCode);
    mask >>= 1;
  }
  return digits.join('');
}


/**
 * @param {TileCoord} tileCoord Tile coordinate.
 * @param {!import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {boolean} Tile coordinate is within extent and zoom level range.
 */
function withinExtentAndZ(tileCoord, tileGrid) {
  var z = tileCoord[0];
  var x = tileCoord[1];
  var y = tileCoord[2];

  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {
    return false;
  }
  var extent = tileGrid.getExtent();
  var tileRange;
  if (!extent) {
    tileRange = tileGrid.getFullTileRange(z);
  } else {
    tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
  }
  if (!tileRange) {
    return true;
  } else {
    return tileRange.containsXY(x, y);
  }
}

//# sourceMappingURL=tilecoord.js.map

/***/ }),

/***/ "./node_modules/ol/tilegrid.js":
/*!*************************************!*\
  !*** ./node_modules/ol/tilegrid.js ***!
  \*************************************/
/*! exports provided: getForProjection, wrapX, createForExtent, createXYZ, createForProjection, extentFromProjection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getForProjection", function() { return getForProjection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wrapX", function() { return wrapX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createForExtent", function() { return createForExtent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createXYZ", function() { return createXYZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createForProjection", function() { return createForProjection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extentFromProjection", function() { return extentFromProjection; });
/* harmony import */ var _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tilegrid/common.js */ "./node_modules/ol/tilegrid/common.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./size.js */ "./node_modules/ol/size.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _extent_Corner_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./extent/Corner.js */ "./node_modules/ol/extent/Corner.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _proj_Units_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./proj/Units.js */ "./node_modules/ol/proj/Units.js");
/* harmony import */ var _tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./tilegrid/TileGrid.js */ "./node_modules/ol/tilegrid/TileGrid.js");
/**
 * @module ol/tilegrid
 */









/**
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {!TileGrid} Default tile grid for the
 * passed projection.
 */
function getForProjection(projection) {
  var tileGrid = projection.getDefaultTileGrid();
  if (!tileGrid) {
    tileGrid = createForProjection(projection);
    projection.setDefaultTileGrid(tileGrid);
  }
  return tileGrid;
}


/**
 * @param {TileGrid} tileGrid Tile grid.
 * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {import("./tilecoord.js").TileCoord} Tile coordinate.
 */
function wrapX(tileGrid, tileCoord, projection) {
  var z = tileCoord[0];
  var center = tileGrid.getTileCoordCenter(tileCoord);
  var projectionExtent = extentFromProjection(projection);
  if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["containsCoordinate"])(projectionExtent, center)) {
    var worldWidth = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["getWidth"])(projectionExtent);
    var worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);
    center[0] += worldWidth * worldsAway;
    return tileGrid.getTileCoordForCoordAndZ(center, z);
  } else {
    return tileCoord;
  }
}


/**
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number=} opt_maxZoom Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size=} opt_tileSize Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {Corner=} opt_corner Extent corner (default is `'top-left'`).
 * @return {!TileGrid} TileGrid instance.
 */
function createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner) {
  var corner = opt_corner !== undefined ? opt_corner : _extent_Corner_js__WEBPACK_IMPORTED_MODULE_3__["default"].TOP_LEFT;

  var resolutions = resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize);

  return new _tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_6__["default"]({
    extent: extent,
    origin: Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["getCorner"])(extent, corner),
    resolutions: resolutions,
    tileSize: opt_tileSize
  });
}


/**
 * @typedef {Object} XYZOptions
 * @property {import("./extent.js").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the
 * top-left corner of the extent. The zero level of the grid is defined by the resolution at which one tile fits in the
 * provided extent. If not provided, the extent of the EPSG:3857 projection is used.
 * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels
 * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.
 * @property {number} [minZoom=0] Minimum zoom.
 * @property {number|import("./size.js").Size} [tileSize=[256, 256]] Tile size in pixels.
 */


/**
 * Creates a tile grid with a standard XYZ tiling scheme.
 * @param {XYZOptions=} opt_options Tile grid options.
 * @return {!TileGrid} Tile grid instance.
 * @api
 */
function createXYZ(opt_options) {
  /** @type {XYZOptions} */
  var xyzOptions = opt_options || {};

  var extent = xyzOptions.extent || Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__["get"])('EPSG:3857').getExtent();

  /** @type {import("./tilegrid/TileGrid.js").Options} */
  var gridOptions = {
    extent: extent,
    minZoom: xyzOptions.minZoom,
    tileSize: xyzOptions.tileSize,
    resolutions: resolutionsFromExtent(
      extent,
      xyzOptions.maxZoom,
      xyzOptions.tileSize
    )
  };
  return new _tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_6__["default"](gridOptions);
}


/**
 * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number=} opt_maxZoom Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size=} opt_tileSize Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @return {!Array<number>} Resolutions array.
 */
function resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize) {
  var maxZoom = opt_maxZoom !== undefined ?
    opt_maxZoom : _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_MAX_ZOOM"];

  var height = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["getHeight"])(extent);
  var width = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["getWidth"])(extent);

  var tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_1__["toSize"])(opt_tileSize !== undefined ?
    opt_tileSize : _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_TILE_SIZE"]);
  var maxResolution = Math.max(
    width / tileSize[0], height / tileSize[1]);

  var length = maxZoom + 1;
  var resolutions = new Array(length);
  for (var z = 0; z < length; ++z) {
    resolutions[z] = maxResolution / Math.pow(2, z);
  }
  return resolutions;
}


/**
 * @param {import("./proj.js").ProjectionLike} projection Projection.
 * @param {number=} opt_maxZoom Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size=} opt_tileSize Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {Corner=} opt_corner Extent corner (default is `'top-left'`).
 * @return {!TileGrid} TileGrid instance.
 */
function createForProjection(projection, opt_maxZoom, opt_tileSize, opt_corner) {
  var extent = extentFromProjection(projection);
  return createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner);
}


/**
 * Generate a tile grid extent from a projection.  If the projection has an
 * extent, it is used.  If not, a global extent is assumed.
 * @param {import("./proj.js").ProjectionLike} projection Projection.
 * @return {import("./extent.js").Extent} Extent.
 */
function extentFromProjection(projection) {
  projection = Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__["get"])(projection);
  var extent = projection.getExtent();
  if (!extent) {
    var half = 180 * _proj_js__WEBPACK_IMPORTED_MODULE_4__["METERS_PER_UNIT"][_proj_Units_js__WEBPACK_IMPORTED_MODULE_5__["default"].DEGREES] / projection.getMetersPerUnit();
    extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["createOrUpdate"])(-half, -half, half, half);
  }
  return extent;
}

//# sourceMappingURL=tilegrid.js.map

/***/ }),

/***/ "./node_modules/ol/tilegrid/TileGrid.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/tilegrid/TileGrid.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/ol/tilegrid/common.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _TileRange_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../TileRange.js */ "./node_modules/ol/TileRange.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../size.js */ "./node_modules/ol/size.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");
/**
 * @module ol/tilegrid/TileGrid
 */










/**
 * @private
 * @type {import("../tilecoord.js").TileCoord}
 */
var tmpTileCoord = [0, 0, 0];


/**
 * @typedef {Object} Options
 * @property {import("../extent.js").Extent} [extent] Extent for the tile grid. No tiles outside this
 * extent will be requested by {@link module:ol/source/Tile} sources. When no `origin` or
 * `origins` are configured, the `origin` will be set to the top-left corner of the extent.
 * @property {number} [minZoom=0] Minimum zoom.
 * @property {import("../coordinate.js").Coordinate} [origin] The tile grid origin, i.e. where the `x`
 * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and upwards. If not
 * specified, `extent` or `origins` must be provided.
 * @property {Array<import("../coordinate.js").Coordinate>} [origins] Tile grid origins, i.e. where
 * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length
 * should match the length of the `resolutions` array, i.e. each resolution can have a different
 * origin. Tile coordinates increase left to right and upwards. If not specified, `extent` or
 * `origin` must be provided.
 * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs
 * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions
 * array will have a length of `maxZoom + 1`.
 * @property {Array<import("../size.js").Size>} [sizes] Sizes.
 * @property {number|import("../size.js").Size} [tileSize] Tile size.
 * Default is `[256, 256]`.
 * @property {Array<import("../size.js").Size>} [tileSizes] Tile sizes. If given, the array length
 * should match the length of the `resolutions` array, i.e. each resolution can have a different
 * tile size.
 */


/**
 * @classdesc
 * Base class for setting the grid pattern for sources accessing tiled-image
 * servers.
 * @api
 */
var TileGrid = function TileGrid(options) {

  /**
   * @protected
   * @type {number}
   */
  this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;

  /**
   * @private
   * @type {!Array<number>}
   */
  this.resolutions_ = options.resolutions;
  Object(_asserts_js__WEBPACK_IMPORTED_MODULE_1__["assert"])(Object(_array_js__WEBPACK_IMPORTED_MODULE_3__["isSorted"])(this.resolutions_, function(a, b) {
    return b - a;
  }, true), 17); // `resolutions` must be sorted in descending order


  // check if we've got a consistent zoom factor and origin
  var zoomFactor;
  if (!options.origins) {
    for (var i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {
      if (!zoomFactor) {
        zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];
      } else {
        if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {
          zoomFactor = undefined;
          break;
        }
      }
    }
  }


  /**
   * @private
   * @type {number|undefined}
   */
  this.zoomFactor_ = zoomFactor;


  /**
   * @protected
   * @type {number}
   */
  this.maxZoom = this.resolutions_.length - 1;

  /**
   * @private
   * @type {import("../coordinate.js").Coordinate}
   */
  this.origin_ = options.origin !== undefined ? options.origin : null;

  /**
   * @private
   * @type {Array<import("../coordinate.js").Coordinate>}
   */
  this.origins_ = null;
  if (options.origins !== undefined) {
    this.origins_ = options.origins;
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_1__["assert"])(this.origins_.length == this.resolutions_.length,
      20); // Number of `origins` and `resolutions` must be equal
  }

  var extent = options.extent;

  if (extent !== undefined &&
      !this.origin_ && !this.origins_) {
    this.origin_ = Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["getTopLeft"])(extent);
  }

  Object(_asserts_js__WEBPACK_IMPORTED_MODULE_1__["assert"])(
    (!this.origin_ && this.origins_) || (this.origin_ && !this.origins_),
    18); // Either `origin` or `origins` must be configured, never both

  /**
   * @private
   * @type {Array<number|import("../size.js").Size>}
   */
  this.tileSizes_ = null;
  if (options.tileSizes !== undefined) {
    this.tileSizes_ = options.tileSizes;
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_1__["assert"])(this.tileSizes_.length == this.resolutions_.length,
      19); // Number of `tileSizes` and `resolutions` must be equal
  }

  /**
   * @private
   * @type {number|import("../size.js").Size}
   */
  this.tileSize_ = options.tileSize !== undefined ?
    options.tileSize :
    !this.tileSizes_ ? _common_js__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_TILE_SIZE"] : null;
  Object(_asserts_js__WEBPACK_IMPORTED_MODULE_1__["assert"])(
    (!this.tileSize_ && this.tileSizes_) ||
      (this.tileSize_ && !this.tileSizes_),
    22); // Either `tileSize` or `tileSizes` must be configured, never both

  /**
   * @private
   * @type {import("../extent.js").Extent}
   */
  this.extent_ = extent !== undefined ? extent : null;


  /**
   * @private
   * @type {Array<import("../TileRange.js").default>}
   */
  this.fullTileRanges_ = null;

  /**
   * @private
   * @type {import("../size.js").Size}
   */
  this.tmpSize_ = [0, 0];

  if (options.sizes !== undefined) {
    this.fullTileRanges_ = options.sizes.map(function(size, z) {
      var tileRange = new _TileRange_js__WEBPACK_IMPORTED_MODULE_2__["default"](
        Math.min(0, size[0]), Math.max(size[0] - 1, -1),
        Math.min(0, size[1]), Math.max(size[1] - 1, -1));
      return tileRange;
    }, this);
  } else if (extent) {
    this.calculateTileRanges_(extent);
  }

};

/**
 * Call a function with each tile coordinate for a given extent and zoom level.
 *
 * @param {import("../extent.js").Extent} extent Extent.
 * @param {number} zoom Integer zoom level.
 * @param {function(import("../tilecoord.js").TileCoord)} callback Function called with each tile coordinate.
 * @api
 */
TileGrid.prototype.forEachTileCoord = function forEachTileCoord (extent, zoom, callback) {
  var tileRange = this.getTileRangeForExtentAndZ(extent, zoom);
  for (var i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {
    for (var j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {
      callback([zoom, i, j]);
    }
  }
};

/**
 * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @param {function(this: T, number, import("../TileRange.js").default): boolean} callback Callback.
 * @param {T=} opt_this The object to use as `this` in `callback`.
 * @param {import("../TileRange.js").default=} opt_tileRange Temporary import("../TileRange.js").default object.
 * @param {import("../extent.js").Extent=} opt_extent Temporary import("../extent.js").Extent object.
 * @return {boolean} Callback succeeded.
 * @template T
 */
TileGrid.prototype.forEachTileCoordParentTileRange = function forEachTileCoordParentTileRange (tileCoord, callback, opt_this, opt_tileRange, opt_extent) {
  var tileRange, x, y;
  var tileCoordExtent = null;
  var z = tileCoord[0] - 1;
  if (this.zoomFactor_ === 2) {
    x = tileCoord[1];
    y = tileCoord[2];
  } else {
    tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);
  }
  while (z >= this.minZoom) {
    if (this.zoomFactor_ === 2) {
      x = Math.floor(x / 2);
      y = Math.floor(y / 2);
      tileRange = Object(_TileRange_js__WEBPACK_IMPORTED_MODULE_2__["createOrUpdate"])(x, x, y, y, opt_tileRange);
    } else {
      tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);
    }
    if (callback.call(opt_this, z, tileRange)) {
      return true;
    }
    --z;
  }
  return false;
};

/**
 * Get the extent for this tile grid, if it was configured.
 * @return {import("../extent.js").Extent} Extent.
 */
TileGrid.prototype.getExtent = function getExtent () {
  return this.extent_;
};

/**
 * Get the maximum zoom level for the grid.
 * @return {number} Max zoom.
 * @api
 */
TileGrid.prototype.getMaxZoom = function getMaxZoom () {
  return this.maxZoom;
};

/**
 * Get the minimum zoom level for the grid.
 * @return {number} Min zoom.
 * @api
 */
TileGrid.prototype.getMinZoom = function getMinZoom () {
  return this.minZoom;
};

/**
 * Get the origin for the grid at the given zoom level.
 * @param {number} z Integer zoom level.
 * @return {import("../coordinate.js").Coordinate} Origin.
 * @api
 */
TileGrid.prototype.getOrigin = function getOrigin (z) {
  if (this.origin_) {
    return this.origin_;
  } else {
    return this.origins_[z];
  }
};

/**
 * Get the resolution for the given zoom level.
 * @param {number} z Integer zoom level.
 * @return {number} Resolution.
 * @api
 */
TileGrid.prototype.getResolution = function getResolution (z) {
  return this.resolutions_[z];
};

/**
 * Get the list of resolutions for the tile grid.
 * @return {Array<number>} Resolutions.
 * @api
 */
TileGrid.prototype.getResolutions = function getResolutions () {
  return this.resolutions_;
};

/**
 * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @param {import("../TileRange.js").default=} opt_tileRange Temporary import("../TileRange.js").default object.
 * @param {import("../extent.js").Extent=} opt_extent Temporary import("../extent.js").Extent object.
 * @return {import("../TileRange.js").default} Tile range.
 */
TileGrid.prototype.getTileCoordChildTileRange = function getTileCoordChildTileRange (tileCoord, opt_tileRange, opt_extent) {
  if (tileCoord[0] < this.maxZoom) {
    if (this.zoomFactor_ === 2) {
      var minX = tileCoord[1] * 2;
      var minY = tileCoord[2] * 2;
      return Object(_TileRange_js__WEBPACK_IMPORTED_MODULE_2__["createOrUpdate"])(minX, minX + 1, minY, minY + 1, opt_tileRange);
    }
    var tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);
    return this.getTileRangeForExtentAndZ(
      tileCoordExtent, tileCoord[0] + 1, opt_tileRange);
  }
  return null;
};

/**
 * Get the extent for a tile range.
 * @param {number} z Integer zoom level.
 * @param {import("../TileRange.js").default} tileRange Tile range.
 * @param {import("../extent.js").Extent=} opt_extent Temporary import("../extent.js").Extent object.
 * @return {import("../extent.js").Extent} Extent.
 */
TileGrid.prototype.getTileRangeExtent = function getTileRangeExtent (z, tileRange, opt_extent) {
  var origin = this.getOrigin(z);
  var resolution = this.getResolution(z);
  var tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_6__["toSize"])(this.getTileSize(z), this.tmpSize_);
  var minX = origin[0] + tileRange.minX * tileSize[0] * resolution;
  var maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;
  var minY = origin[1] + tileRange.minY * tileSize[1] * resolution;
  var maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;
  return Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["createOrUpdate"])(minX, minY, maxX, maxY, opt_extent);
};

/**
 * Get a tile range for the given extent and integer zoom level.
 * @param {import("../extent.js").Extent} extent Extent.
 * @param {number} z Integer zoom level.
 * @param {import("../TileRange.js").default=} opt_tileRange Temporary tile range object.
 * @return {import("../TileRange.js").default} Tile range.
 */
TileGrid.prototype.getTileRangeForExtentAndZ = function getTileRangeForExtentAndZ (extent, z, opt_tileRange) {
  var tileCoord = tmpTileCoord;
  this.getTileCoordForXYAndZ_(extent[0], extent[1], z, false, tileCoord);
  var minX = tileCoord[1];
  var minY = tileCoord[2];
  this.getTileCoordForXYAndZ_(extent[2], extent[3], z, true, tileCoord);
  return Object(_TileRange_js__WEBPACK_IMPORTED_MODULE_2__["createOrUpdate"])(minX, tileCoord[1], minY, tileCoord[2], opt_tileRange);
};

/**
 * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @return {import("../coordinate.js").Coordinate} Tile center.
 */
TileGrid.prototype.getTileCoordCenter = function getTileCoordCenter (tileCoord) {
  var origin = this.getOrigin(tileCoord[0]);
  var resolution = this.getResolution(tileCoord[0]);
  var tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_6__["toSize"])(this.getTileSize(tileCoord[0]), this.tmpSize_);
  return [
    origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,
    origin[1] + (tileCoord[2] + 0.5) * tileSize[1] * resolution
  ];
};

/**
 * Get the extent of a tile coordinate.
 *
 * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @param {import("../extent.js").Extent=} opt_extent Temporary extent object.
 * @return {import("../extent.js").Extent} Extent.
 * @api
 */
TileGrid.prototype.getTileCoordExtent = function getTileCoordExtent (tileCoord, opt_extent) {
  var origin = this.getOrigin(tileCoord[0]);
  var resolution = this.getResolution(tileCoord[0]);
  var tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_6__["toSize"])(this.getTileSize(tileCoord[0]), this.tmpSize_);
  var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
  var minY = origin[1] + tileCoord[2] * tileSize[1] * resolution;
  var maxX = minX + tileSize[0] * resolution;
  var maxY = minY + tileSize[1] * resolution;
  return Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["createOrUpdate"])(minX, minY, maxX, maxY, opt_extent);
};

/**
 * Get the tile coordinate for the given map coordinate and resolution.This
 * method considers that coordinates that intersect tile boundaries should be
 * assigned the higher tile coordinate.
 *
 * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
 * @param {number} resolution Resolution.
 * @param {import("../tilecoord.js").TileCoord=} opt_tileCoord Destination import("../tilecoord.js").TileCoord object.
 * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
 * @api
 */
TileGrid.prototype.getTileCoordForCoordAndResolution = function getTileCoordForCoordAndResolution (coordinate, resolution, opt_tileCoord) {
  return this.getTileCoordForXYAndResolution_(
    coordinate[0], coordinate[1], resolution, false, opt_tileCoord);
};

/**
 * Note that this method should not be called for resolutions that correspond
 * to an integer zoom level.Instead call the `getTileCoordForXYAndZ_` method.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} resolution Resolution (for a non-integer zoom level).
 * @param {boolean} reverseIntersectionPolicy Instead of letting edge
 *   intersections go to the higher tile coordinate, let edge intersections
 *   go to the lower tile coordinate.
 * @param {import("../tilecoord.js").TileCoord=} opt_tileCoord Temporary import("../tilecoord.js").TileCoord object.
 * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
 * @private
 */
TileGrid.prototype.getTileCoordForXYAndResolution_ = function getTileCoordForXYAndResolution_ (x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {
  var z = this.getZForResolution(resolution);
  var scale = resolution / this.getResolution(z);
  var origin = this.getOrigin(z);
  var tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_6__["toSize"])(this.getTileSize(z), this.tmpSize_);

  var adjustX = reverseIntersectionPolicy ? 0.5 : 0;
  var adjustY = reverseIntersectionPolicy ? 0 : 0.5;
  var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);
  var yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY);
  var tileCoordX = scale * xFromOrigin / tileSize[0];
  var tileCoordY = scale * yFromOrigin / tileSize[1];

  if (reverseIntersectionPolicy) {
    tileCoordX = Math.ceil(tileCoordX) - 1;
    tileCoordY = Math.ceil(tileCoordY) - 1;
  } else {
    tileCoordX = Math.floor(tileCoordX);
    tileCoordY = Math.floor(tileCoordY);
  }

  return Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_7__["createOrUpdate"])(z, tileCoordX, tileCoordY, opt_tileCoord);
};

/**
 * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
 * they should have separate implementations.This method is for integer zoom
 * levels.The other method should only be called for resolutions corresponding
 * to non-integer zoom levels.
 * @param {number} x Map x coordinate.
 * @param {number} y Map y coordinate.
 * @param {number} z Integer zoom level.
 * @param {boolean} reverseIntersectionPolicy Instead of letting edge
 *   intersections go to the higher tile coordinate, let edge intersections
 *   go to the lower tile coordinate.
 * @param {import("../tilecoord.js").TileCoord=} opt_tileCoord Temporary import("../tilecoord.js").TileCoord object.
 * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
 * @private
 */
TileGrid.prototype.getTileCoordForXYAndZ_ = function getTileCoordForXYAndZ_ (x, y, z, reverseIntersectionPolicy, opt_tileCoord) {
  var origin = this.getOrigin(z);
  var resolution = this.getResolution(z);
  var tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_6__["toSize"])(this.getTileSize(z), this.tmpSize_);

  var adjustX = reverseIntersectionPolicy ? 0.5 : 0;
  var adjustY = reverseIntersectionPolicy ? 0 : 0.5;
  var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);
  var yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY);
  var tileCoordX = xFromOrigin / tileSize[0];
  var tileCoordY = yFromOrigin / tileSize[1];

  if (reverseIntersectionPolicy) {
    tileCoordX = Math.ceil(tileCoordX) - 1;
    tileCoordY = Math.ceil(tileCoordY) - 1;
  } else {
    tileCoordX = Math.floor(tileCoordX);
    tileCoordY = Math.floor(tileCoordY);
  }

  return Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_7__["createOrUpdate"])(z, tileCoordX, tileCoordY, opt_tileCoord);
};

/**
 * Get a tile coordinate given a map coordinate and zoom level.
 * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
 * @param {number} z Zoom level.
 * @param {import("../tilecoord.js").TileCoord=} opt_tileCoord Destination import("../tilecoord.js").TileCoord object.
 * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
 * @api
 */
TileGrid.prototype.getTileCoordForCoordAndZ = function getTileCoordForCoordAndZ (coordinate, z, opt_tileCoord) {
  return this.getTileCoordForXYAndZ_(
    coordinate[0], coordinate[1], z, false, opt_tileCoord);
};

/**
 * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @return {number} Tile resolution.
 */
TileGrid.prototype.getTileCoordResolution = function getTileCoordResolution (tileCoord) {
  return this.resolutions_[tileCoord[0]];
};

/**
 * Get the tile size for a zoom level. The type of the return value matches the
 * `tileSize` or `tileSizes` that the tile grid was configured with. To always
 * get an `import("../size.js").Size`, run the result through `import("../size.js").Size.toSize()`.
 * @param {number} z Z.
 * @return {number|import("../size.js").Size} Tile size.
 * @api
 */
TileGrid.prototype.getTileSize = function getTileSize (z) {
  if (this.tileSize_) {
    return this.tileSize_;
  } else {
    return this.tileSizes_[z];
  }
};

/**
 * @param {number} z Zoom level.
 * @return {import("../TileRange.js").default} Extent tile range for the specified zoom level.
 */
TileGrid.prototype.getFullTileRange = function getFullTileRange (z) {
  if (!this.fullTileRanges_) {
    return null;
  } else {
    return this.fullTileRanges_[z];
  }
};

/**
 * @param {number} resolution Resolution.
 * @param {number=} opt_direction If 0, the nearest resolution will be used.
 *   If 1, the nearest lower resolution will be used. If -1, the nearest
 *   higher resolution will be used. Default is 0.
 * @return {number} Z.
 * @api
 */
TileGrid.prototype.getZForResolution = function getZForResolution (resolution, opt_direction) {
  var z = Object(_array_js__WEBPACK_IMPORTED_MODULE_3__["linearFindNearest"])(this.resolutions_, resolution, opt_direction || 0);
  return Object(_math_js__WEBPACK_IMPORTED_MODULE_5__["clamp"])(z, this.minZoom, this.maxZoom);
};

/**
 * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
 * @private
 */
TileGrid.prototype.calculateTileRanges_ = function calculateTileRanges_ (extent) {
  var length = this.resolutions_.length;
  var fullTileRanges = new Array(length);
  for (var z = this.minZoom; z < length; ++z) {
    fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);
  }
  this.fullTileRanges_ = fullTileRanges;
};


/* harmony default export */ __webpack_exports__["default"] = (TileGrid);

//# sourceMappingURL=TileGrid.js.map

/***/ }),

/***/ "./node_modules/ol/tilegrid/common.js":
/*!********************************************!*\
  !*** ./node_modules/ol/tilegrid/common.js ***!
  \********************************************/
/*! exports provided: DEFAULT_MAX_ZOOM, DEFAULT_TILE_SIZE */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_MAX_ZOOM", function() { return DEFAULT_MAX_ZOOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_TILE_SIZE", function() { return DEFAULT_TILE_SIZE; });
/**
 * @module ol/tilegrid/common
 */

/**
 * Default maximum zoom for default tile grids.
 * @type {number}
 */
var DEFAULT_MAX_ZOOM = 42;

/**
 * Default tile size.
 * @type {number}
 */
var DEFAULT_TILE_SIZE = 256;

//# sourceMappingURL=common.js.map

/***/ }),

/***/ "./node_modules/ol/tileurlfunction.js":
/*!********************************************!*\
  !*** ./node_modules/ol/tileurlfunction.js ***!
  \********************************************/
/*! exports provided: createFromTemplate, createFromTemplates, createFromTileUrlFunctions, nullTileUrlFunction, expandUrl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createFromTemplate", function() { return createFromTemplate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createFromTemplates", function() { return createFromTemplates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createFromTileUrlFunctions", function() { return createFromTileUrlFunctions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nullTileUrlFunction", function() { return nullTileUrlFunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expandUrl", function() { return expandUrl; });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tilecoord.js */ "./node_modules/ol/tilecoord.js");
/**
 * @module ol/tileurlfunction
 */





/**
 * @param {string} template Template.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */
function createFromTemplate(template, tileGrid) {
  var zRegEx = /\{z\}/g;
  var xRegEx = /\{x\}/g;
  var yRegEx = /\{y\}/g;
  var dashYRegEx = /\{-y\}/g;
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return undefined;
      } else {
        return template.replace(zRegEx, tileCoord[0].toString())
          .replace(xRegEx, tileCoord[1].toString())
          .replace(yRegEx, function() {
            var y = -tileCoord[2] - 1;
            return y.toString();
          })
          .replace(dashYRegEx, function() {
            var z = tileCoord[0];
            var range = tileGrid.getFullTileRange(z);
            Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(range, 55); // The {-y} placeholder requires a tile grid with extent
            var y = range.getHeight() + tileCoord[2];
            return y.toString();
          });
      }
    }
  );
}


/**
 * @param {Array<string>} templates Templates.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */
function createFromTemplates(templates, tileGrid) {
  var len = templates.length;
  var tileUrlFunctions = new Array(len);
  for (var i = 0; i < len; ++i) {
    tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);
  }
  return createFromTileUrlFunctions(tileUrlFunctions);
}


/**
 * @param {Array<import("./Tile.js").UrlFunction>} tileUrlFunctions Tile URL Functions.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */
function createFromTileUrlFunctions(tileUrlFunctions) {
  if (tileUrlFunctions.length === 1) {
    return tileUrlFunctions[0];
  }
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return undefined;
      } else {
        var h = Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_2__["hash"])(tileCoord);
        var index = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["modulo"])(h, tileUrlFunctions.length);
        return tileUrlFunctions[index](tileCoord, pixelRatio, projection);
      }
    }
  );
}


/**
 * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @param {number} pixelRatio Pixel ratio.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {string|undefined} Tile URL.
 */
function nullTileUrlFunction(tileCoord, pixelRatio, projection) {
  return undefined;
}


/**
 * @param {string} url URL.
 * @return {Array<string>} Array of urls.
 */
function expandUrl(url) {
  var urls = [];
  var match = /\{([a-z])-([a-z])\}/.exec(url);
  if (match) {
    // char range
    var startCharCode = match[1].charCodeAt(0);
    var stopCharCode = match[2].charCodeAt(0);
    var charCode;
    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
      urls.push(url.replace(match[0], String.fromCharCode(charCode)));
    }
    return urls;
  }
  match = match = /\{(\d+)-(\d+)\}/.exec(url);
  if (match) {
    // number range
    var stop = parseInt(match[2], 10);
    for (var i = parseInt(match[1], 10); i <= stop; i++) {
      urls.push(url.replace(match[0], i.toString()));
    }
    return urls;
  }
  urls.push(url);
  return urls;
}

//# sourceMappingURL=tileurlfunction.js.map

/***/ }),

/***/ "./node_modules/ol/transform.js":
/*!**************************************!*\
  !*** ./node_modules/ol/transform.js ***!
  \**************************************/
/*! exports provided: create, reset, multiply, set, setFromArray, apply, rotate, scale, translate, compose, invert, determinant */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reset", function() { return reset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setFromArray", function() { return setFromArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "apply", function() { return apply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compose", function() { return compose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/**
 * @module ol/transform
 */



/**
 * An array representing an affine 2d transformation for use with
 * {@link module:ol/transform} functions. The array has 6 elements.
 * @typedef {!Array<number>} Transform
 */


/**
 * Collection of affine 2d transformation functions. The functions work on an
 * array of 6 elements. The element order is compatible with the [SVGMatrix
 * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is
 * a subset (elements a to f) of a 3×3 matrix:
 * ```
 * [ a c e ]
 * [ b d f ]
 * [ 0 0 1 ]
 * ```
 */


/**
 * @private
 * @type {Transform}
 */
var tmp_ = new Array(6);


/**
 * Create an identity transform.
 * @return {!Transform} Identity transform.
 */
function create() {
  return [1, 0, 0, 1, 0, 0];
}


/**
 * Resets the given transform to an identity transform.
 * @param {!Transform} transform Transform.
 * @return {!Transform} Transform.
 */
function reset(transform) {
  return set(transform, 1, 0, 0, 1, 0, 0);
}


/**
 * Multiply the underlying matrices of two transforms and return the result in
 * the first transform.
 * @param {!Transform} transform1 Transform parameters of matrix 1.
 * @param {!Transform} transform2 Transform parameters of matrix 2.
 * @return {!Transform} transform1 multiplied with transform2.
 */
function multiply(transform1, transform2) {
  var a1 = transform1[0];
  var b1 = transform1[1];
  var c1 = transform1[2];
  var d1 = transform1[3];
  var e1 = transform1[4];
  var f1 = transform1[5];
  var a2 = transform2[0];
  var b2 = transform2[1];
  var c2 = transform2[2];
  var d2 = transform2[3];
  var e2 = transform2[4];
  var f2 = transform2[5];

  transform1[0] = a1 * a2 + c1 * b2;
  transform1[1] = b1 * a2 + d1 * b2;
  transform1[2] = a1 * c2 + c1 * d2;
  transform1[3] = b1 * c2 + d1 * d2;
  transform1[4] = a1 * e2 + c1 * f2 + e1;
  transform1[5] = b1 * e2 + d1 * f2 + f1;

  return transform1;
}

/**
 * Set the transform components a-f on a given transform.
 * @param {!Transform} transform Transform.
 * @param {number} a The a component of the transform.
 * @param {number} b The b component of the transform.
 * @param {number} c The c component of the transform.
 * @param {number} d The d component of the transform.
 * @param {number} e The e component of the transform.
 * @param {number} f The f component of the transform.
 * @return {!Transform} Matrix with transform applied.
 */
function set(transform, a, b, c, d, e, f) {
  transform[0] = a;
  transform[1] = b;
  transform[2] = c;
  transform[3] = d;
  transform[4] = e;
  transform[5] = f;
  return transform;
}


/**
 * Set transform on one matrix from another matrix.
 * @param {!Transform} transform1 Matrix to set transform to.
 * @param {!Transform} transform2 Matrix to set transform from.
 * @return {!Transform} transform1 with transform from transform2 applied.
 */
function setFromArray(transform1, transform2) {
  transform1[0] = transform2[0];
  transform1[1] = transform2[1];
  transform1[2] = transform2[2];
  transform1[3] = transform2[3];
  transform1[4] = transform2[4];
  transform1[5] = transform2[5];
  return transform1;
}


/**
 * Transforms the given coordinate with the given transform returning the
 * resulting, transformed coordinate. The coordinate will be modified in-place.
 *
 * @param {Transform} transform The transformation.
 * @param {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} coordinate The coordinate to transform.
 * @return {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} return coordinate so that operations can be
 *     chained together.
 */
function apply(transform, coordinate) {
  var x = coordinate[0];
  var y = coordinate[1];
  coordinate[0] = transform[0] * x + transform[2] * y + transform[4];
  coordinate[1] = transform[1] * x + transform[3] * y + transform[5];
  return coordinate;
}


/**
 * Applies rotation to the given transform.
 * @param {!Transform} transform Transform.
 * @param {number} angle Angle in radians.
 * @return {!Transform} The rotated transform.
 */
function rotate(transform, angle) {
  var cos = Math.cos(angle);
  var sin = Math.sin(angle);
  return multiply(transform, set(tmp_, cos, sin, -sin, cos, 0, 0));
}


/**
 * Applies scale to a given transform.
 * @param {!Transform} transform Transform.
 * @param {number} x Scale factor x.
 * @param {number} y Scale factor y.
 * @return {!Transform} The scaled transform.
 */
function scale(transform, x, y) {
  return multiply(transform, set(tmp_, x, 0, 0, y, 0, 0));
}


/**
 * Applies translation to the given transform.
 * @param {!Transform} transform Transform.
 * @param {number} dx Translation x.
 * @param {number} dy Translation y.
 * @return {!Transform} The translated transform.
 */
function translate(transform, dx, dy) {
  return multiply(transform, set(tmp_, 1, 0, 0, 1, dx, dy));
}


/**
 * Creates a composite transform given an initial translation, scale, rotation, and
 * final translation (in that order only, not commutative).
 * @param {!Transform} transform The transform (will be modified in place).
 * @param {number} dx1 Initial translation x.
 * @param {number} dy1 Initial translation y.
 * @param {number} sx Scale factor x.
 * @param {number} sy Scale factor y.
 * @param {number} angle Rotation (in counter-clockwise radians).
 * @param {number} dx2 Final translation x.
 * @param {number} dy2 Final translation y.
 * @return {!Transform} The composite transform.
 */
function compose(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {
  var sin = Math.sin(angle);
  var cos = Math.cos(angle);
  transform[0] = sx * cos;
  transform[1] = sy * sin;
  transform[2] = -sx * sin;
  transform[3] = sy * cos;
  transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
  transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
  return transform;
}


/**
 * Invert the given transform.
 * @param {!Transform} transform Transform.
 * @return {!Transform} Inverse of the transform.
 */
function invert(transform) {
  var det = determinant(transform);
  Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(det !== 0, 32); // Transformation matrix cannot be inverted

  var a = transform[0];
  var b = transform[1];
  var c = transform[2];
  var d = transform[3];
  var e = transform[4];
  var f = transform[5];

  transform[0] = d / det;
  transform[1] = -b / det;
  transform[2] = -c / det;
  transform[3] = a / det;
  transform[4] = (c * f - d * e) / det;
  transform[5] = -(a * f - b * e) / det;

  return transform;
}


/**
 * Returns the determinant of the given matrix.
 * @param {!Transform} mat Matrix.
 * @return {number} Determinant.
 */
function determinant(mat) {
  return mat[0] * mat[3] - mat[1] * mat[2];
}

//# sourceMappingURL=transform.js.map

/***/ }),

/***/ "./node_modules/ol/util.js":
/*!*********************************!*\
  !*** ./node_modules/ol/util.js ***!
  \*********************************/
/*! exports provided: abstract, inherits, getUid, VERSION */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "abstract", function() { return abstract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inherits", function() { return inherits; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getUid", function() { return getUid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return VERSION; });
/**
 * @module ol/util
 */

/**
 * @return {?} Any return.
 */
function abstract() {
  return /** @type {?} */ ((function() {
    throw new Error('Unimplemented abstract method.');
  })());
}

/**
 * Inherit the prototype methods from one constructor into another.
 *
 * Usage:
 *
 *     function ParentClass(a, b) { }
 *     ParentClass.prototype.foo = function(a) { }
 *
 *     function ChildClass(a, b, c) {
 *       // Call parent constructor
 *       ParentClass.call(this, a, b);
 *     }
 *     inherits(ChildClass, ParentClass);
 *
 *     var child = new ChildClass('a', 'b', 'see');
 *     child.foo(); // This works.
 *
 * @param {!Function} childCtor Child constructor.
 * @param {!Function} parentCtor Parent constructor.
 * @function module:ol.inherits
 * @deprecated
 * @api
 */
function inherits(childCtor, parentCtor) {
  childCtor.prototype = Object.create(parentCtor.prototype);
  childCtor.prototype.constructor = childCtor;
}

/**
 * Counter for getUid.
 * @type {number}
 * @private
 */
var uidCounter_ = 0;

/**
 * Gets a unique ID for an object. This mutates the object so that further calls
 * with the same object as a parameter returns the same value. Unique IDs are generated
 * as a strictly increasing sequence. Adapted from goog.getUid.
 *
 * @param {Object} obj The object to get the unique ID for.
 * @return {string} The unique ID for the object.
 * @function module:ol.getUid
 * @api
 */
function getUid(obj) {
  return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));
}

/**
 * OpenLayers version.
 * @type {string}
 */
var VERSION = '5.3.3';

//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/ol/webgl.js":
/*!**********************************!*\
  !*** ./node_modules/ol/webgl.js ***!
  \**********************************/
/*! exports provided: ONE, SRC_ALPHA, COLOR_ATTACHMENT0, COLOR_BUFFER_BIT, TRIANGLES, TRIANGLE_STRIP, ONE_MINUS_SRC_ALPHA, ARRAY_BUFFER, ELEMENT_ARRAY_BUFFER, STREAM_DRAW, STATIC_DRAW, DYNAMIC_DRAW, CULL_FACE, BLEND, STENCIL_TEST, DEPTH_TEST, SCISSOR_TEST, UNSIGNED_BYTE, UNSIGNED_SHORT, UNSIGNED_INT, FLOAT, RGBA, FRAGMENT_SHADER, VERTEX_SHADER, LINK_STATUS, LINEAR, TEXTURE_MAG_FILTER, TEXTURE_MIN_FILTER, TEXTURE_WRAP_S, TEXTURE_WRAP_T, TEXTURE_2D, TEXTURE0, CLAMP_TO_EDGE, COMPILE_STATUS, FRAMEBUFFER, getContext, DEBUG, HAS, MAX_TEXTURE_SIZE, EXTENSIONS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ONE", function() { return ONE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRC_ALPHA", function() { return SRC_ALPHA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COLOR_ATTACHMENT0", function() { return COLOR_ATTACHMENT0; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COLOR_BUFFER_BIT", function() { return COLOR_BUFFER_BIT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TRIANGLES", function() { return TRIANGLES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TRIANGLE_STRIP", function() { return TRIANGLE_STRIP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ONE_MINUS_SRC_ALPHA", function() { return ONE_MINUS_SRC_ALPHA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ARRAY_BUFFER", function() { return ARRAY_BUFFER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ELEMENT_ARRAY_BUFFER", function() { return ELEMENT_ARRAY_BUFFER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STREAM_DRAW", function() { return STREAM_DRAW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STATIC_DRAW", function() { return STATIC_DRAW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DYNAMIC_DRAW", function() { return DYNAMIC_DRAW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CULL_FACE", function() { return CULL_FACE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BLEND", function() { return BLEND; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STENCIL_TEST", function() { return STENCIL_TEST; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEPTH_TEST", function() { return DEPTH_TEST; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SCISSOR_TEST", function() { return SCISSOR_TEST; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNSIGNED_BYTE", function() { return UNSIGNED_BYTE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNSIGNED_SHORT", function() { return UNSIGNED_SHORT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNSIGNED_INT", function() { return UNSIGNED_INT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FLOAT", function() { return FLOAT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA", function() { return RGBA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FRAGMENT_SHADER", function() { return FRAGMENT_SHADER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERTEX_SHADER", function() { return VERTEX_SHADER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LINK_STATUS", function() { return LINK_STATUS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LINEAR", function() { return LINEAR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXTURE_MAG_FILTER", function() { return TEXTURE_MAG_FILTER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXTURE_MIN_FILTER", function() { return TEXTURE_MIN_FILTER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXTURE_WRAP_S", function() { return TEXTURE_WRAP_S; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXTURE_WRAP_T", function() { return TEXTURE_WRAP_T; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXTURE_2D", function() { return TEXTURE_2D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXTURE0", function() { return TEXTURE0; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLAMP_TO_EDGE", function() { return CLAMP_TO_EDGE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COMPILE_STATUS", function() { return COMPILE_STATUS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FRAMEBUFFER", function() { return FRAMEBUFFER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getContext", function() { return getContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEBUG", function() { return DEBUG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HAS", function() { return HAS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAX_TEXTURE_SIZE", function() { return MAX_TEXTURE_SIZE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EXTENSIONS", function() { return EXTENSIONS; });
/**
 * @module ol/webgl
 */


/**
 * Constants taken from goog.webgl
 */


/**
 * @const
 * @type {number}
 */
var ONE = 1;


/**
 * @const
 * @type {number}
 */
var SRC_ALPHA = 0x0302;


/**
 * @const
 * @type {number}
 */
var COLOR_ATTACHMENT0 = 0x8CE0;


/**
 * @const
 * @type {number}
 */
var COLOR_BUFFER_BIT = 0x00004000;


/**
 * @const
 * @type {number}
 */
var TRIANGLES = 0x0004;


/**
 * @const
 * @type {number}
 */
var TRIANGLE_STRIP = 0x0005;


/**
 * @const
 * @type {number}
 */
var ONE_MINUS_SRC_ALPHA = 0x0303;


/**
 * @const
 * @type {number}
 */
var ARRAY_BUFFER = 0x8892;


/**
 * @const
 * @type {number}
 */
var ELEMENT_ARRAY_BUFFER = 0x8893;


/**
 * @const
 * @type {number}
 */
var STREAM_DRAW = 0x88E0;


/**
 * @const
 * @type {number}
 */
var STATIC_DRAW = 0x88E4;


/**
 * @const
 * @type {number}
 */
var DYNAMIC_DRAW = 0x88E8;


/**
 * @const
 * @type {number}
 */
var CULL_FACE = 0x0B44;


/**
 * @const
 * @type {number}
 */
var BLEND = 0x0BE2;


/**
 * @const
 * @type {number}
 */
var STENCIL_TEST = 0x0B90;


/**
 * @const
 * @type {number}
 */
var DEPTH_TEST = 0x0B71;


/**
 * @const
 * @type {number}
 */
var SCISSOR_TEST = 0x0C11;


/**
 * @const
 * @type {number}
 */
var UNSIGNED_BYTE = 0x1401;


/**
 * @const
 * @type {number}
 */
var UNSIGNED_SHORT = 0x1403;


/**
 * @const
 * @type {number}
 */
var UNSIGNED_INT = 0x1405;


/**
 * @const
 * @type {number}
 */
var FLOAT = 0x1406;


/**
 * @const
 * @type {number}
 */
var RGBA = 0x1908;


/**
 * @const
 * @type {number}
 */
var FRAGMENT_SHADER = 0x8B30;


/**
 * @const
 * @type {number}
 */
var VERTEX_SHADER = 0x8B31;


/**
 * @const
 * @type {number}
 */
var LINK_STATUS = 0x8B82;


/**
 * @const
 * @type {number}
 */
var LINEAR = 0x2601;


/**
 * @const
 * @type {number}
 */
var TEXTURE_MAG_FILTER = 0x2800;


/**
 * @const
 * @type {number}
 */
var TEXTURE_MIN_FILTER = 0x2801;


/**
 * @const
 * @type {number}
 */
var TEXTURE_WRAP_S = 0x2802;


/**
 * @const
 * @type {number}
 */
var TEXTURE_WRAP_T = 0x2803;


/**
 * @const
 * @type {number}
 */
var TEXTURE_2D = 0x0DE1;


/**
 * @const
 * @type {number}
 */
var TEXTURE0 = 0x84C0;


/**
 * @const
 * @type {number}
 */
var CLAMP_TO_EDGE = 0x812F;


/**
 * @const
 * @type {number}
 */
var COMPILE_STATUS = 0x8B81;


/**
 * @const
 * @type {number}
 */
var FRAMEBUFFER = 0x8D40;


/** end of goog.webgl constants
 */


/**
 * @const
 * @type {Array<string>}
 */
var CONTEXT_IDS = [
  'experimental-webgl',
  'webgl',
  'webkit-3d',
  'moz-webgl'
];


/**
 * @param {HTMLCanvasElement} canvas Canvas.
 * @param {Object=} opt_attributes Attributes.
 * @return {WebGLRenderingContext} WebGL rendering context.
 */
function getContext(canvas, opt_attributes) {
  var ii = CONTEXT_IDS.length;
  for (var i = 0; i < ii; ++i) {
    try {
      var context = canvas.getContext(CONTEXT_IDS[i], opt_attributes);
      if (context) {
        return /** @type {!WebGLRenderingContext} */ (context);
      }
    } catch (e) {
      // pass
    }
  }
  return null;
}


/**
 * Include debuggable shader sources.  Default is `true`. This should be set to
 * `false` for production builds.
 * @type {boolean}
 */
var DEBUG = true;


/**
 * The maximum supported WebGL texture size in pixels. If WebGL is not
 * supported, the value is set to `undefined`.
 * @type {number|undefined}
 */
var MAX_TEXTURE_SIZE; // value is set below


/**
 * List of supported WebGL extensions.
 * @type {Array<string>}
 */
var EXTENSIONS; // value is set below


/**
 * True if both OpenLayers and browser support WebGL.
 * @type {boolean}
 * @api
 */
var HAS = false;

//TODO Remove side effects
if (typeof window !== 'undefined' && 'WebGLRenderingContext' in window) {
  try {
    var canvas = /** @type {HTMLCanvasElement} */ (document.createElement('canvas'));
    var gl = getContext(canvas, {failIfMajorPerformanceCaveat: true});
    if (gl) {
      HAS = true;
      MAX_TEXTURE_SIZE = /** @type {number} */ (gl.getParameter(gl.MAX_TEXTURE_SIZE));
      EXTENSIONS = gl.getSupportedExtensions();
    }
  } catch (e) {
    // pass
  }
}



//# sourceMappingURL=webgl.js.map

/***/ }),

/***/ "./node_modules/quickselect/quickselect.js":
/*!*************************************************!*\
  !*** ./node_modules/quickselect/quickselect.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

(function (global, factory) {
	 true ? module.exports = factory() :
	undefined;
}(this, (function () { 'use strict';

function quickselect(arr, k, left, right, compare) {
    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);
}

function quickselectStep(arr, k, left, right, compare) {

    while (right > left) {
        if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            quickselectStep(arr, k, newLeft, newRight, compare);
        }

        var t = arr[k];
        var i = left;
        var j = right;

        swap(arr, left, k);
        if (compare(arr[right], t) > 0) swap(arr, left, right);

        while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (compare(arr[i], t) < 0) i++;
            while (compare(arr[j], t) > 0) j--;
        }

        if (compare(arr[left], t) === 0) swap(arr, left, j);
        else {
            j++;
            swap(arr, j, right);
        }

        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
    }
}

function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}

return quickselect;

})));


/***/ }),

/***/ "./node_modules/rbush/index.js":
/*!*************************************!*\
  !*** ./node_modules/rbush/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = rbush;
module.exports.default = rbush;

var quickselect = __webpack_require__(/*! quickselect */ "./node_modules/quickselect/quickselect.js");

function rbush(maxEntries, format) {
    if (!(this instanceof rbush)) return new rbush(maxEntries, format);

    // max entries in a node is 9 by default; min node fill is 40% for best performance
    this._maxEntries = Math.max(4, maxEntries || 9);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

    if (format) {
        this._initFormat(format);
    }

    this.clear();
}

rbush.prototype = {

    all: function () {
        return this._all(this.data, []);
    },

    search: function (bbox) {

        var node = this.data,
            result = [],
            toBBox = this.toBBox;

        if (!intersects(bbox, node)) return result;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf) result.push(child);
                    else if (contains(bbox, childBBox)) this._all(child, result);
                    else nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return result;
    },

    collides: function (bbox) {

        var node = this.data,
            toBBox = this.toBBox;

        if (!intersects(bbox, node)) return false;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf || contains(bbox, childBBox)) return true;
                    nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return false;
    },

    load: function (data) {
        if (!(data && data.length)) return this;

        if (data.length < this._minEntries) {
            for (var i = 0, len = data.length; i < len; i++) {
                this.insert(data[i]);
            }
            return this;
        }

        // recursively build the tree with the given data from scratch using OMT algorithm
        var node = this._build(data.slice(), 0, data.length - 1, 0);

        if (!this.data.children.length) {
            // save as is if tree is empty
            this.data = node;

        } else if (this.data.height === node.height) {
            // split root if trees have the same height
            this._splitRoot(this.data, node);

        } else {
            if (this.data.height < node.height) {
                // swap trees if inserted one is bigger
                var tmpNode = this.data;
                this.data = node;
                node = tmpNode;
            }

            // insert the small tree into the large tree at appropriate level
            this._insert(node, this.data.height - node.height - 1, true);
        }

        return this;
    },

    insert: function (item) {
        if (item) this._insert(item, this.data.height - 1);
        return this;
    },

    clear: function () {
        this.data = createNode([]);
        return this;
    },

    remove: function (item, equalsFn) {
        if (!item) return this;

        var node = this.data,
            bbox = this.toBBox(item),
            path = [],
            indexes = [],
            i, parent, index, goingUp;

        // depth-first iterative tree traversal
        while (node || path.length) {

            if (!node) { // go up
                node = path.pop();
                parent = path[path.length - 1];
                i = indexes.pop();
                goingUp = true;
            }

            if (node.leaf) { // check current node
                index = findItem(item, node.children, equalsFn);

                if (index !== -1) {
                    // item found, remove the item and condense tree upwards
                    node.children.splice(index, 1);
                    path.push(node);
                    this._condense(path);
                    return this;
                }
            }

            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down
                path.push(node);
                indexes.push(i);
                i = 0;
                parent = node;
                node = node.children[0];

            } else if (parent) { // go right
                i++;
                node = parent.children[i];
                goingUp = false;

            } else node = null; // nothing found
        }

        return this;
    },

    toBBox: function (item) { return item; },

    compareMinX: compareNodeMinX,
    compareMinY: compareNodeMinY,

    toJSON: function () { return this.data; },

    fromJSON: function (data) {
        this.data = data;
        return this;
    },

    _all: function (node, result) {
        var nodesToSearch = [];
        while (node) {
            if (node.leaf) result.push.apply(result, node.children);
            else nodesToSearch.push.apply(nodesToSearch, node.children);

            node = nodesToSearch.pop();
        }
        return result;
    },

    _build: function (items, left, right, height) {

        var N = right - left + 1,
            M = this._maxEntries,
            node;

        if (N <= M) {
            // reached leaf level; return leaf
            node = createNode(items.slice(left, right + 1));
            calcBBox(node, this.toBBox);
            return node;
        }

        if (!height) {
            // target height of the bulk-loaded tree
            height = Math.ceil(Math.log(N) / Math.log(M));

            // target number of root entries to maximize storage utilization
            M = Math.ceil(N / Math.pow(M, height - 1));
        }

        node = createNode([]);
        node.leaf = false;
        node.height = height;

        // split the items into M mostly square tiles

        var N2 = Math.ceil(N / M),
            N1 = N2 * Math.ceil(Math.sqrt(M)),
            i, j, right2, right3;

        multiSelect(items, left, right, N1, this.compareMinX);

        for (i = left; i <= right; i += N1) {

            right2 = Math.min(i + N1 - 1, right);

            multiSelect(items, i, right2, N2, this.compareMinY);

            for (j = i; j <= right2; j += N2) {

                right3 = Math.min(j + N2 - 1, right2);

                // pack each entry recursively
                node.children.push(this._build(items, j, right3, height - 1));
            }
        }

        calcBBox(node, this.toBBox);

        return node;
    },

    _chooseSubtree: function (bbox, node, level, path) {

        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

        while (true) {
            path.push(node);

            if (node.leaf || path.length - 1 === level) break;

            minArea = minEnlargement = Infinity;

            for (i = 0, len = node.children.length; i < len; i++) {
                child = node.children[i];
                area = bboxArea(child);
                enlargement = enlargedArea(bbox, child) - area;

                // choose entry with the least area enlargement
                if (enlargement < minEnlargement) {
                    minEnlargement = enlargement;
                    minArea = area < minArea ? area : minArea;
                    targetNode = child;

                } else if (enlargement === minEnlargement) {
                    // otherwise choose one with the smallest area
                    if (area < minArea) {
                        minArea = area;
                        targetNode = child;
                    }
                }
            }

            node = targetNode || node.children[0];
        }

        return node;
    },

    _insert: function (item, level, isNode) {

        var toBBox = this.toBBox,
            bbox = isNode ? item : toBBox(item),
            insertPath = [];

        // find the best node for accommodating the item, saving all nodes along the path too
        var node = this._chooseSubtree(bbox, this.data, level, insertPath);

        // put the item into the node
        node.children.push(item);
        extend(node, bbox);

        // split on node overflow; propagate upwards if necessary
        while (level >= 0) {
            if (insertPath[level].children.length > this._maxEntries) {
                this._split(insertPath, level);
                level--;
            } else break;
        }

        // adjust bboxes along the insertion path
        this._adjustParentBBoxes(bbox, insertPath, level);
    },

    // split overflowed node into two
    _split: function (insertPath, level) {

        var node = insertPath[level],
            M = node.children.length,
            m = this._minEntries;

        this._chooseSplitAxis(node, m, M);

        var splitIndex = this._chooseSplitIndex(node, m, M);

        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;

        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);

        if (level) insertPath[level - 1].children.push(newNode);
        else this._splitRoot(node, newNode);
    },

    _splitRoot: function (node, newNode) {
        // split root node
        this.data = createNode([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
    },

    _chooseSplitIndex: function (node, m, M) {

        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;

        minOverlap = minArea = Infinity;

        for (i = m; i <= M - m; i++) {
            bbox1 = distBBox(node, 0, i, this.toBBox);
            bbox2 = distBBox(node, i, M, this.toBBox);

            overlap = intersectionArea(bbox1, bbox2);
            area = bboxArea(bbox1) + bboxArea(bbox2);

            // choose distribution with minimum overlap
            if (overlap < minOverlap) {
                minOverlap = overlap;
                index = i;

                minArea = area < minArea ? area : minArea;

            } else if (overlap === minOverlap) {
                // otherwise choose distribution with minimum area
                if (area < minArea) {
                    minArea = area;
                    index = i;
                }
            }
        }

        return index;
    },

    // sorts node children by the best axis for split
    _chooseSplitAxis: function (node, m, M) {

        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
            xMargin = this._allDistMargin(node, m, M, compareMinX),
            yMargin = this._allDistMargin(node, m, M, compareMinY);

        // if total distributions margin value is minimal for x, sort by minX,
        // otherwise it's already sorted by minY
        if (xMargin < yMargin) node.children.sort(compareMinX);
    },

    // total margin of all possible split distributions where each node is at least m full
    _allDistMargin: function (node, m, M, compare) {

        node.children.sort(compare);

        var toBBox = this.toBBox,
            leftBBox = distBBox(node, 0, m, toBBox),
            rightBBox = distBBox(node, M - m, M, toBBox),
            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
            i, child;

        for (i = m; i < M - m; i++) {
            child = node.children[i];
            extend(leftBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(leftBBox);
        }

        for (i = M - m - 1; i >= m; i--) {
            child = node.children[i];
            extend(rightBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(rightBBox);
        }

        return margin;
    },

    _adjustParentBBoxes: function (bbox, path, level) {
        // adjust bboxes along the given tree path
        for (var i = level; i >= 0; i--) {
            extend(path[i], bbox);
        }
    },

    _condense: function (path) {
        // go through the path, removing empty nodes and updating bboxes
        for (var i = path.length - 1, siblings; i >= 0; i--) {
            if (path[i].children.length === 0) {
                if (i > 0) {
                    siblings = path[i - 1].children;
                    siblings.splice(siblings.indexOf(path[i]), 1);

                } else this.clear();

            } else calcBBox(path[i], this.toBBox);
        }
    },

    _initFormat: function (format) {
        // data format (minX, minY, maxX, maxY accessors)

        // uses eval-type function compilation instead of just accepting a toBBox function
        // because the algorithms are very sensitive to sorting functions performance,
        // so they should be dead simple and without inner calls

        var compareArr = ['return a', ' - b', ';'];

        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));

        this.toBBox = new Function('a',
            'return {minX: a' + format[0] +
            ', minY: a' + format[1] +
            ', maxX: a' + format[2] +
            ', maxY: a' + format[3] + '};');
    }
};

function findItem(item, items, equalsFn) {
    if (!equalsFn) return items.indexOf(item);

    for (var i = 0; i < items.length; i++) {
        if (equalsFn(item, items[i])) return i;
    }
    return -1;
}

// calculate node's bbox from bboxes of its children
function calcBBox(node, toBBox) {
    distBBox(node, 0, node.children.length, toBBox, node);
}

// min bounding rectangle of node children from k to p-1
function distBBox(node, k, p, toBBox, destNode) {
    if (!destNode) destNode = createNode(null);
    destNode.minX = Infinity;
    destNode.minY = Infinity;
    destNode.maxX = -Infinity;
    destNode.maxY = -Infinity;

    for (var i = k, child; i < p; i++) {
        child = node.children[i];
        extend(destNode, node.leaf ? toBBox(child) : child);
    }

    return destNode;
}

function extend(a, b) {
    a.minX = Math.min(a.minX, b.minX);
    a.minY = Math.min(a.minY, b.minY);
    a.maxX = Math.max(a.maxX, b.maxX);
    a.maxY = Math.max(a.maxY, b.maxY);
    return a;
}

function compareNodeMinX(a, b) { return a.minX - b.minX; }
function compareNodeMinY(a, b) { return a.minY - b.minY; }

function bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }
function bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }

function enlargedArea(a, b) {
    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
}

function intersectionArea(a, b) {
    var minX = Math.max(a.minX, b.minX),
        minY = Math.max(a.minY, b.minY),
        maxX = Math.min(a.maxX, b.maxX),
        maxY = Math.min(a.maxY, b.maxY);

    return Math.max(0, maxX - minX) *
           Math.max(0, maxY - minY);
}

function contains(a, b) {
    return a.minX <= b.minX &&
           a.minY <= b.minY &&
           b.maxX <= a.maxX &&
           b.maxY <= a.maxY;
}

function intersects(a, b) {
    return b.minX <= a.maxX &&
           b.minY <= a.maxY &&
           b.maxX >= a.minX &&
           b.maxY >= a.minY;
}

function createNode(children) {
    return {
        children: children,
        height: 1,
        leaf: true,
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity
    };
}

// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
// combines selection algorithm with binary divide & conquer approach

function multiSelect(arr, left, right, n, compare) {
    var stack = [left, right],
        mid;

    while (stack.length) {
        right = stack.pop();
        left = stack.pop();

        if (right - left <= n) continue;

        mid = left + Math.ceil((right - left) / n / 2) * n;
        quickselect(arr, mid, left, right, compare);

        stack.push(left, mid, mid, right);
    }
}


/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target, parent) {
  if (parent){
    return parent.querySelector(target);
  }
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target, parent) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target, parent);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "./node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertAt.before, target);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	if(options.attrs.nonce === undefined) {
		var nonce = getNonce();
		if (nonce) {
			options.attrs.nonce = nonce;
		}
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function getNonce() {
	if (false) {}

	return __webpack_require__.nc;
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = typeof options.transform === 'function'
		 ? options.transform(obj.css) 
		 : options.transform.default(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _modules_LizmapMapElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules/LizmapMapElement.js */ "./src/modules/LizmapMapElement.js");
/* harmony import */ var _modules_LizmapBaseLayersElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/LizmapBaseLayersElement.js */ "./src/modules/LizmapBaseLayersElement.js");



window.customElements.define('lizmap-map', _modules_LizmapMapElement_js__WEBPACK_IMPORTED_MODULE_0__["default"]);
window.customElements.define('lizmap-baselayers', _modules_LizmapBaseLayersElement_js__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***/ }),

/***/ "./src/modules/LizmapBaseLayersElement.js":
/*!************************************************!*\
  !*** ./src/modules/LizmapBaseLayersElement.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LizmapBaseLayersElement; });
/* harmony import */ var _LizmapLayerGroup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LizmapLayerGroup.js */ "./src/modules/LizmapLayerGroup.js");


class LizmapBaseLayersElement extends HTMLElement {
    constructor() {
        super();

        const shadowRoot = this.attachShadow({ mode: 'open' });

        this._mapElement;
    }

    connectedCallback() {

        const self = this;

        // TODO addeventlistener
        window.onload = function() {
            const mapSelector = self.getAttribute('map-selector');

            if (mapSelector) {
                const mapElement = document.querySelector(mapSelector);

                if (mapElement) {
                    if (mapElement.nodeName === "LIZMAP-MAP") {
                        self._mapElement = mapElement;
                        const baseLayerGroup = new _LizmapLayerGroup_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
                            mutuallyExclusive: true,
                            layersList: mapElement.baseLayers
                        });

                        mapElement.baseLayerGroup = baseLayerGroup;

                        self.render();
                    } else {
                        console.warn("Element is not a lizmap-map element.");
                    }
                } else {
                    console.warn("map-selector does not reference an element.");
                }
            } else {
                console.warn("map-selector undefined.");
            }
        };
    }

    render() {
        let newSelect = document.createElement('select');

        for (let [layerId, config] of this._mapElement.baseLayers) {
            let newNode = document.createElement('option');
            newNode.setAttribute('value', layerId);
            if (config.visible) {
                newNode.setAttribute('selected', 'selected');
            }
            newNode.innerText = config.name;

            newSelect.appendChild(newNode);
        }

        // Event change
        newSelect.onchange = (event) => {
            this._mapElement.baseLayerVisible = event.target.value;
        };

        this.shadowRoot.appendChild(newSelect);
    }
}



/***/ }),

/***/ "./src/modules/LizmapLayer.js":
/*!************************************!*\
  !*** ./src/modules/LizmapLayer.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LizmapLayer; });
/* harmony import */ var ol_layer_Tile_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ol/layer/Tile.js */ "./node_modules/ol/layer/Tile.js");
/* harmony import */ var ol_source_OSM_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ol/source/OSM.js */ "./node_modules/ol/source/OSM.js");
/* harmony import */ var ol_source_Stamen_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ol/source/Stamen.js */ "./node_modules/ol/source/Stamen.js");




class LizmapLayer {
    constructor(layerId, visible) {
        this._OLlayer;
        this._layerId = layerId;
        if (layerId === 'osmMapnik') {
            this._OLlayer = new ol_layer_Tile_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
                layerId: layerId,
                visible: visible,
                source: new ol_source_OSM_js__WEBPACK_IMPORTED_MODULE_1__["default"]()
            })
        } else if (layerId === 'osmStamenToner') {
            this._OLlayer = new ol_layer_Tile_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
                layerId: layerId,
                visible: visible,
                source: new ol_source_Stamen_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
                    layer: 'toner'
                })
            });
        }
    }

    get OLlayer() {
        return this._OLlayer;
    }

    get layerId() {
        return this._layerId;
    }

    set layerVisible(visible) {
        this._OLlayer.setVisible(visible);
    }
}

/***/ }),

/***/ "./src/modules/LizmapLayerGroup.js":
/*!*****************************************!*\
  !*** ./src/modules/LizmapLayerGroup.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LizmapLayerGroup; });
/* harmony import */ var _LizmapLayer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LizmapLayer.js */ "./src/modules/LizmapLayer.js");
/* harmony import */ var ol_layer_Group__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ol/layer/Group */ "./node_modules/ol/layer/Group.js");



// attribut selected
class LizmapLayerGroup {
    constructor(opt_options) {

        this._mutuallyExclusive = opt_options.mutuallyExclusive;

        this._lizmapLayers = [];

        for (let [layerId, config] of opt_options.layersList) {
            const lizmapLayer = new _LizmapLayer_js__WEBPACK_IMPORTED_MODULE_0__["default"](layerId, config.visible);

            this._lizmapLayers.push(lizmapLayer);
        }

        this._OLlayerGroup = new ol_layer_Group__WEBPACK_IMPORTED_MODULE_1__["default"]({
            layers: this.OLLayers()
        });
    }

    // Make class iterable
    [Symbol.iterator]() {
        let index = -1;

        return {
            next: () => ({ value: this._lizmapLayers[++index], done: !(index in this._lizmapLayers) })
        };
    };

    get OLlayerGroup() {
        return this._OLlayerGroup;
    }

    set layerVisible(layerId) {
        for (let i = 0; i < this._lizmapLayers.length; i++) {
            // Set visibility to false when mutually exclusive
            if (this._mutuallyExclusive) {
                this._lizmapLayers[i].layerVisible = false;
            }
            if (this._lizmapLayers[i].layerId === layerId) {
                this._lizmapLayers[i].layerVisible = true;
            }
        }
    }

    // TODO : utiliser map()
    OLLayers() {
        let OLLayers = [];

        for (let i = 0; i < this._lizmapLayers.length; i++) {
            OLLayers.push(this._lizmapLayers[i].OLlayer);
        }

        return OLLayers;
    }
}

/***/ }),

/***/ "./src/modules/LizmapMapElement.js":
/*!*****************************************!*\
  !*** ./src/modules/LizmapMapElement.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LizmapMapElement; });
/* harmony import */ var ol_ol_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ol/ol.css */ "./node_modules/ol/ol.css");
/* harmony import */ var ol_ol_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ol_ol_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ol_Map_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ol/Map.js */ "./node_modules/ol/Map.js");
/* harmony import */ var ol_View_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ol/View.js */ "./node_modules/ol/View.js");
/* harmony import */ var ol_layer_Tile_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ol/layer/Tile.js */ "./node_modules/ol/layer/Tile.js");
/* harmony import */ var ol_source_OSM_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ol/source/OSM.js */ "./node_modules/ol/source/OSM.js");
/* harmony import */ var _LizmapLayerGroup_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./LizmapLayerGroup.js */ "./src/modules/LizmapLayerGroup.js");


// OLMap and not Map to avoid collision with global object Map







class LizmapMapElement extends HTMLElement {
    constructor() {
        super();

        this._OLMap;
        this._baseLayerGroup;
    }

    connectedCallback() {
    	const map  = new ol_Map_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
            target: this,
            view: new ol_View_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
                center: [0, 0],
                zoom: 2
            })
        });
        this._OLMap = map;

        const baseLayerGroup = new _LizmapLayerGroup_js__WEBPACK_IMPORTED_MODULE_5__["default"]({
            mutuallyExclusive: true,
            layersList: this.baseLayers
        });

        this._baseLayerGroup = baseLayerGroup;
    }

    get baseLayerGroup(){
    	return this._baseLayerGroup;
    }

    /**
    * @param LizmapLayerGroup lizmapLayerGroup
    **/

    set baseLayerGroup(lizmapLayerGroup){
    	this._baseLayerGroup = lizmapLayerGroup;
    	this._OLMap.addLayer(lizmapLayerGroup.OLlayerGroup);
    }

    set baseLayerVisible(layerId){
    	this._baseLayerGroup.layerVisible = layerId;
    }

    // TODO get base layers list from config
    get baseLayers(){
    	return new Map([
            ['osmMapnik',{name: 'OSM', visible: false}],
            ['osmStamenToner',{name: 'OSM Toner', visible: true}]
        ]);
    }
}


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL29sLmNzcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9Bc3NlcnRpb25FcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvQ29sbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvQ29sbGVjdGlvbkV2ZW50VHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvRGlzcG9zYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvRmVhdHVyZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvSW1hZ2VCYXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9JbWFnZUNhbnZhcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvSW1hZ2VTdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvSW1hZ2VUaWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9LaW5ldGljLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9MYXllclR5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL01hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvTWFwQnJvd3NlckV2ZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9NYXBCcm93c2VyRXZlbnRIYW5kbGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9NYXBCcm93c2VyRXZlbnRUeXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9NYXBCcm93c2VyUG9pbnRlckV2ZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9NYXBFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvTWFwRXZlbnRUeXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9NYXBQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvT2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9PYmplY3RFdmVudFR5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL09ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL1BsdWdnYWJsZU1hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvVGlsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvVGlsZUNhY2hlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9UaWxlUXVldWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL1RpbGVSYW5nZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvVGlsZVN0YXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9WaWV3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9WaWV3SGludC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvVmlld1Byb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvYXNzZXJ0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvY2VudGVyY29uc3RyYWludC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvY29sb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2NvbG9ybGlrZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvY29udHJvbC9BdHRyaWJ1dGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvY29udHJvbC9Db250cm9sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9jb250cm9sL1JvdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvY29udHJvbC9ab29tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9jb250cm9sL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2Nvb3JkaW5hdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2Nzcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZG9tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9lYXNpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZXZlbnRzL0V2ZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9ldmVudHMvRXZlbnRUeXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9ldmVudHMvS2V5Q29kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZXZlbnRzL1RhcmdldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZXZlbnRzL2NvbmRpdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZXh0ZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9leHRlbnQvQ29ybmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9leHRlbnQvUmVsYXRpb25zaGlwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9mZWF0dXJlbG9hZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9mb3JtYXQvRm9ybWF0VHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZnVuY3Rpb25zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL0NpcmNsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9HZW9tZXRyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9HZW9tZXRyeUxheW91dC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9HZW9tZXRyeVR5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2dlb20vTGluZVN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9MaW5lYXJSaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL011bHRpTGluZVN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9NdWx0aVBvaW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL011bHRpUG9seWdvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9Qb2ludC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9Qb2x5Z29uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvYXJlYS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L2NlbnRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L2Nsb3Nlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2dlb20vZmxhdC9jb250YWlucy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L2RlZmxhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2dlb20vZmxhdC9pbmZsYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvaW50ZXJpb3Jwb2ludC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L2ludGVycG9sYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvaW50ZXJzZWN0c2V4dGVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L2xlbmd0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L29yaWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L3JldmVyc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2dlb20vZmxhdC9zZWdtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L3NpbXBsaWZ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvc3RyYWlnaHRjaHVuay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L3RleHRwYXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvdHJhbnNmb3JtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9oYXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9Eb3VibGVDbGlja1pvb20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL0RyYWdBbmREcm9wLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9EcmFnQm94LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9EcmFnUGFuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9EcmFnUm90YXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9EcmFnUm90YXRlQW5kWm9vbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvaW50ZXJhY3Rpb24vRHJhZ1pvb20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL0RyYXcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL0V4dGVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvaW50ZXJhY3Rpb24vSW50ZXJhY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL0tleWJvYXJkUGFuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9LZXlib2FyZFpvb20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL01vZGlmeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvaW50ZXJhY3Rpb24vTW91c2VXaGVlbFpvb20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL1BpbmNoUm90YXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9QaW5jaFpvb20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL1BvaW50ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL1Byb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9TZWxlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL1NuYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL1RyYW5zbGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvbGF5ZXIvQmFzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvbGF5ZXIvR3JvdXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2xheWVyL0xheWVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9sYXllci9Qcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvbGF5ZXIvVGlsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvbGF5ZXIvVGlsZVByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9sYXllci9WZWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2xheWVyL1ZlY3RvclJlbmRlclR5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2xheWVyL1ZlY3RvclRpbGVSZW5kZXJUeXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9sb2FkaW5nc3RyYXRlZ3kuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL21hdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL29iai5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvb2wuY3NzPzA1ZmEiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3BvaW50ZXIvRXZlbnRTb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3BvaW50ZXIvRXZlbnRUeXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9wb2ludGVyL01vdXNlU291cmNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9wb2ludGVyL01zU291cmNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9wb2ludGVyL05hdGl2ZVNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvcG9pbnRlci9Qb2ludGVyRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3BvaW50ZXIvUG9pbnRlckV2ZW50SGFuZGxlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvcG9pbnRlci9Ub3VjaFNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvcHJvai5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvcHJvai9Qcm9qZWN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9wcm9qL1VuaXRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9wcm9qL2Vwc2czODU3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9wcm9qL2Vwc2c0MzI2LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9wcm9qL3Byb2plY3Rpb25zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9wcm9qL3RyYW5zZm9ybXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9Cb3guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9FdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyL0V2ZW50VHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyL1JlcGxheUdyb3VwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvUmVwbGF5VHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyL1ZlY3RvckNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9jYW52YXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9jYW52YXMvSW1hZ2VSZXBsYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9jYW52YXMvSW1tZWRpYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvY2FudmFzL0luc3RydWN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvY2FudmFzL0xpbmVTdHJpbmdSZXBsYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9jYW52YXMvUG9seWdvblJlcGxheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyL2NhbnZhcy9SZXBsYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9jYW52YXMvUmVwbGF5R3JvdXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9jYW52YXMvVGV4dFJlcGxheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyL3JlcGxheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyZXIvTGF5ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3JlbmRlcmVyL01hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyZXIvY2FudmFzL0ltYWdlTGF5ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3JlbmRlcmVyL2NhbnZhcy9JbnRlcm1lZGlhdGVDYW52YXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3JlbmRlcmVyL2NhbnZhcy9MYXllci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyZXIvY2FudmFzL01hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyZXIvY2FudmFzL1RpbGVMYXllci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyZXIvY2FudmFzL1ZlY3RvckxheWVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXJlci9jYW52YXMvVmVjdG9yVGlsZUxheWVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXJlci92ZWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3JlcHJvai5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvcmVwcm9qL1RpbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3JlcHJvai9Ucmlhbmd1bGF0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9yZXByb2ovY29tbW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9yZXNvbHV0aW9uY29uc3RyYWludC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvcm90YXRpb25jb25zdHJhaW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9zaXplLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9zb3VyY2UvT1NNLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9zb3VyY2UvU291cmNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9zb3VyY2UvU3RhbWVuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9zb3VyY2UvU3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3NvdXJjZS9UaWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9zb3VyY2UvVGlsZUV2ZW50VHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvc291cmNlL1RpbGVJbWFnZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvc291cmNlL1VybFRpbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3NvdXJjZS9WZWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3NvdXJjZS9WZWN0b3JFdmVudFR5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3NvdXJjZS9YWVouanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3NwaGVyZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvc3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9zdHJ1Y3RzL0xSVUNhY2hlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9zdHJ1Y3RzL1ByaW9yaXR5UXVldWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3N0cnVjdHMvUkJ1c2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3N0eWxlL0NpcmNsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvc3R5bGUvRmlsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvc3R5bGUvSWNvbkltYWdlQ2FjaGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3N0eWxlL0ltYWdlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9zdHlsZS9SZWd1bGFyU2hhcGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3N0eWxlL1N0cm9rZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvc3R5bGUvU3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3N0eWxlL1RleHRQbGFjZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3RpbGVjb29yZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvdGlsZWdyaWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3RpbGVncmlkL1RpbGVHcmlkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC90aWxlZ3JpZC9jb21tb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3RpbGV1cmxmdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvdHJhbnNmb3JtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC91dGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC93ZWJnbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVpY2tzZWxlY3QvcXVpY2tzZWxlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JidXNoL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzIiwid2VicGFjazovLy8uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9MaXptYXBCYXNlTGF5ZXJzRWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9MaXptYXBMYXllci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9MaXptYXBMYXllckdyb3VwLmpzIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL0xpem1hcE1hcEVsZW1lbnQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7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QUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDLENBQUMsd0RBQU07OztBQUdSO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNB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QSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLDhCQUE4QixPQUFPO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLDRCQUE0QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzREFBVTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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QUdQO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTzs7O0FBR1A7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPOzs7QUFHUDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ087OztBQUdQO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTzs7O0FBR1A7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPOzs7QUFHUDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ087OztBQUdQO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTzs7O0FBR1A7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPOzs7QUFHUDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ087OztBQUdQO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTzs7O0FBR1A7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPOzs7QUFHUDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ087OztBQUdQO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTzs7O0FBR1A7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPOzs7QUFHUDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ087OztBQUdQO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTzs7O0FBR1A7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPOzs7QUFHUDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ087OztBQUdQO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTzs7O0FBR1A7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPOzs7QUFHUDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ087OztBQUdQO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTzs7O0FBR1A7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPOzs7QUFHUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVcsUUFBUTtBQUNuQixZQUFZLHNCQUFzQjtBQUNsQztBQUNPO0FBQ1A7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtB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QUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBLEtBQUssS0FBd0MsRUFBRSxFQUU3Qzs7QUFFRixRQUFRLHNCQUFpQjtBQUN6Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztB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LGtEQUFJO0FBQzFCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUOztBQUVBLG1DQUFtQyw0REFBZ0I7QUFDbkQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNEJBQTRCO0FBQ3RELCtCQUErQixpQ0FBaUM7QUFDaEU7QUFDQTtBQUNBIiwiZmlsZSI6Ii4uLy4uL2xpem1hcC93d3cvanMvbWFwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvaW5kZXguanNcIik7XG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCIpKGZhbHNlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLm9sLWJveCB7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgYm9yZGVyLXJhZGl1czogMnB4O1xcbiAgYm9yZGVyOiAycHggc29saWQgYmx1ZTtcXG59XFxuXFxuLm9sLW1vdXNlLXBvc2l0aW9uIHtcXG4gIHRvcDogOHB4O1xcbiAgcmlnaHQ6IDhweDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuXFxuLm9sLXNjYWxlLWxpbmUge1xcbiAgYmFja2dyb3VuZDogcmdiYSgwLDYwLDEzNiwwLjMpO1xcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xcbiAgYm90dG9tOiA4cHg7XFxuICBsZWZ0OiA4cHg7XFxuICBwYWRkaW5nOiAycHg7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxufVxcbi5vbC1zY2FsZS1saW5lLWlubmVyIHtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNlZWU7XFxuICBib3JkZXItdG9wOiBub25lO1xcbiAgY29sb3I6ICNlZWU7XFxuICBmb250LXNpemU6IDEwcHg7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBtYXJnaW46IDFweDtcXG4gIHdpbGwtY2hhbmdlOiBjb250ZW50cywgd2lkdGg7XFxufVxcbi5vbC1vdmVybGF5LWNvbnRhaW5lciB7XFxuICB3aWxsLWNoYW5nZTogbGVmdCxyaWdodCx0b3AsYm90dG9tO1xcbn1cXG5cXG4ub2wtdW5zdXBwb3J0ZWQge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuLm9sLXZpZXdwb3J0LCAub2wtdW5zZWxlY3RhYmxlIHtcXG4gIC13ZWJraXQtdG91Y2gtY2FsbG91dDogbm9uZTtcXG4gIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbiAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHJnYmEoMCwwLDAsMCk7XFxufVxcbi5vbC1zZWxlY3RhYmxlIHtcXG4gIC13ZWJraXQtdG91Y2gtY2FsbG91dDogZGVmYXVsdDtcXG4gIC13ZWJraXQtdXNlci1zZWxlY3Q6IHRleHQ7XFxuICAtbW96LXVzZXItc2VsZWN0OiB0ZXh0O1xcbiAgLW1zLXVzZXItc2VsZWN0OiB0ZXh0O1xcbiAgdXNlci1zZWxlY3Q6IHRleHQ7XFxufVxcbi5vbC1ncmFiYmluZyB7XFxuICBjdXJzb3I6IC13ZWJraXQtZ3JhYmJpbmc7XFxuICBjdXJzb3I6IC1tb3otZ3JhYmJpbmc7XFxuICBjdXJzb3I6IGdyYWJiaW5nO1xcbn1cXG4ub2wtZ3JhYiB7XFxuICBjdXJzb3I6IG1vdmU7XFxuICBjdXJzb3I6IC13ZWJraXQtZ3JhYjtcXG4gIGN1cnNvcjogLW1vei1ncmFiO1xcbiAgY3Vyc29yOiBncmFiO1xcbn1cXG4ub2wtY29udHJvbCB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwyNTUsMjU1LDAuNCk7XFxuICBib3JkZXItcmFkaXVzOiA0cHg7XFxuICBwYWRkaW5nOiAycHg7XFxufVxcbi5vbC1jb250cm9sOmhvdmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LDI1NSwyNTUsMC42KTtcXG59XFxuLm9sLXpvb20ge1xcbiAgdG9wOiAuNWVtO1xcbiAgbGVmdDogLjVlbTtcXG59XFxuLm9sLXJvdGF0ZSB7XFxuICB0b3A6IC41ZW07XFxuICByaWdodDogLjVlbTtcXG4gIHRyYW5zaXRpb246IG9wYWNpdHkgLjI1cyBsaW5lYXIsIHZpc2liaWxpdHkgMHMgbGluZWFyO1xcbn1cXG4ub2wtcm90YXRlLm9sLWhpZGRlbiB7XFxuICBvcGFjaXR5OiAwO1xcbiAgdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgdHJhbnNpdGlvbjogb3BhY2l0eSAuMjVzIGxpbmVhciwgdmlzaWJpbGl0eSAwcyBsaW5lYXIgLjI1cztcXG59XFxuLm9sLXpvb20tZXh0ZW50IHtcXG4gIHRvcDogNC42NDNlbTtcXG4gIGxlZnQ6IC41ZW07XFxufVxcbi5vbC1mdWxsLXNjcmVlbiB7XFxuICByaWdodDogLjVlbTtcXG4gIHRvcDogLjVlbTtcXG59XFxuQG1lZGlhIHByaW50IHtcXG4gIC5vbC1jb250cm9sIHtcXG4gICAgZGlzcGxheTogbm9uZTtcXG4gIH1cXG59XFxuXFxuLm9sLWNvbnRyb2wgYnV0dG9uIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgbWFyZ2luOiAxcHg7XFxuICBwYWRkaW5nOiAwO1xcbiAgY29sb3I6IHdoaXRlO1xcbiAgZm9udC1zaXplOiAxLjE0ZW07XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGhlaWdodDogMS4zNzVlbTtcXG4gIHdpZHRoOiAxLjM3NWVtO1xcbiAgbGluZS1oZWlnaHQ6IC40ZW07XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsNjAsMTM2LDAuNSk7XFxuICBib3JkZXI6IG5vbmU7XFxuICBib3JkZXItcmFkaXVzOiAycHg7XFxufVxcbi5vbC1jb250cm9sIGJ1dHRvbjo6LW1vei1mb2N1cy1pbm5lciB7XFxuICBib3JkZXI6IG5vbmU7XFxuICBwYWRkaW5nOiAwO1xcbn1cXG4ub2wtem9vbS1leHRlbnQgYnV0dG9uIHtcXG4gIGxpbmUtaGVpZ2h0OiAxLjRlbTtcXG59XFxuLm9sLWNvbXBhc3Mge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBmb250LXdlaWdodDogbm9ybWFsO1xcbiAgZm9udC1zaXplOiAxLjJlbTtcXG4gIHdpbGwtY2hhbmdlOiB0cmFuc2Zvcm07XFxufVxcbi5vbC10b3VjaCAub2wtY29udHJvbCBidXR0b24ge1xcbiAgZm9udC1zaXplOiAxLjVlbTtcXG59XFxuLm9sLXRvdWNoIC5vbC16b29tLWV4dGVudCB7XFxuICB0b3A6IDUuNWVtO1xcbn1cXG4ub2wtY29udHJvbCBidXR0b246aG92ZXIsXFxuLm9sLWNvbnRyb2wgYnV0dG9uOmZvY3VzIHtcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCw2MCwxMzYsMC43KTtcXG59XFxuLm9sLXpvb20gLm9sLXpvb20taW4ge1xcbiAgYm9yZGVyLXJhZGl1czogMnB4IDJweCAwIDA7XFxufVxcbi5vbC16b29tIC5vbC16b29tLW91dCB7XFxuICBib3JkZXItcmFkaXVzOiAwIDAgMnB4IDJweDtcXG59XFxuXFxuXFxuLm9sLWF0dHJpYnV0aW9uIHtcXG4gIHRleHQtYWxpZ246IHJpZ2h0O1xcbiAgYm90dG9tOiAuNWVtO1xcbiAgcmlnaHQ6IC41ZW07XFxuICBtYXgtd2lkdGg6IGNhbGMoMTAwJSAtIDEuM2VtKTtcXG59XFxuXFxuLm9sLWF0dHJpYnV0aW9uIHVsIHtcXG4gIG1hcmdpbjogMDtcXG4gIHBhZGRpbmc6IDAgLjVlbTtcXG4gIGZvbnQtc2l6ZTogLjdyZW07XFxuICBsaW5lLWhlaWdodDogMS4zNzVlbTtcXG4gIGNvbG9yOiAjMDAwO1xcbiAgdGV4dC1zaGFkb3c6IDAgMCAycHggI2ZmZjtcXG59XFxuLm9sLWF0dHJpYnV0aW9uIGxpIHtcXG4gIGRpc3BsYXk6IGlubGluZTtcXG4gIGxpc3Qtc3R5bGU6IG5vbmU7XFxuICBsaW5lLWhlaWdodDogaW5oZXJpdDtcXG59XFxuLm9sLWF0dHJpYnV0aW9uIGxpOm5vdCg6bGFzdC1jaGlsZCk6YWZ0ZXIge1xcbiAgY29udGVudDogXFxcIiBcXFwiO1xcbn1cXG4ub2wtYXR0cmlidXRpb24gaW1nIHtcXG4gIG1heC1oZWlnaHQ6IDJlbTtcXG4gIG1heC13aWR0aDogaW5oZXJpdDtcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxufVxcbi5vbC1hdHRyaWJ1dGlvbiB1bCwgLm9sLWF0dHJpYnV0aW9uIGJ1dHRvbiB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxufVxcbi5vbC1hdHRyaWJ1dGlvbi5vbC1jb2xsYXBzZWQgdWwge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuLm9sLWF0dHJpYnV0aW9uOm5vdCgub2wtY29sbGFwc2VkKSB7XFxuICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwyNTUsMjU1LDAuOCk7XFxufVxcbi5vbC1hdHRyaWJ1dGlvbi5vbC11bmNvbGxhcHNpYmxlIHtcXG4gIGJvdHRvbTogMDtcXG4gIHJpZ2h0OiAwO1xcbiAgYm9yZGVyLXJhZGl1czogNHB4IDAgMDtcXG4gIGhlaWdodDogMS4xZW07XFxuICBsaW5lLWhlaWdodDogMWVtO1xcbn1cXG4ub2wtYXR0cmlidXRpb24ub2wtdW5jb2xsYXBzaWJsZSBpbWcge1xcbiAgbWFyZ2luLXRvcDogLS4yZW07XFxuICBtYXgtaGVpZ2h0OiAxLjZlbTtcXG59XFxuLm9sLWF0dHJpYnV0aW9uLm9sLXVuY29sbGFwc2libGUgYnV0dG9uIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcblxcbi5vbC16b29tc2xpZGVyIHtcXG4gIHRvcDogNC41ZW07XFxuICBsZWZ0OiAuNWVtO1xcbiAgaGVpZ2h0OiAyMDBweDtcXG59XFxuLm9sLXpvb21zbGlkZXIgYnV0dG9uIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGhlaWdodDogMTBweDtcXG59XFxuXFxuLm9sLXRvdWNoIC5vbC16b29tc2xpZGVyIHtcXG4gIHRvcDogNS41ZW07XFxufVxcblxcbi5vbC1vdmVydmlld21hcCB7XFxuICBsZWZ0OiAwLjVlbTtcXG4gIGJvdHRvbTogMC41ZW07XFxufVxcbi5vbC1vdmVydmlld21hcC5vbC11bmNvbGxhcHNpYmxlIHtcXG4gIGJvdHRvbTogMDtcXG4gIGxlZnQ6IDA7XFxuICBib3JkZXItcmFkaXVzOiAwIDRweCAwIDA7XFxufVxcbi5vbC1vdmVydmlld21hcCAub2wtb3ZlcnZpZXdtYXAtbWFwLFxcbi5vbC1vdmVydmlld21hcCBidXR0b24ge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbn1cXG4ub2wtb3ZlcnZpZXdtYXAgLm9sLW92ZXJ2aWV3bWFwLW1hcCB7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjN2I5OGJjO1xcbiAgaGVpZ2h0OiAxNTBweDtcXG4gIG1hcmdpbjogMnB4O1xcbiAgd2lkdGg6IDE1MHB4O1xcbn1cXG4ub2wtb3ZlcnZpZXdtYXA6bm90KC5vbC1jb2xsYXBzZWQpIGJ1dHRvbntcXG4gIGJvdHRvbTogMXB4O1xcbiAgbGVmdDogMnB4O1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbn1cXG4ub2wtb3ZlcnZpZXdtYXAub2wtY29sbGFwc2VkIC5vbC1vdmVydmlld21hcC1tYXAsXFxuLm9sLW92ZXJ2aWV3bWFwLm9sLXVuY29sbGFwc2libGUgYnV0dG9uIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcbi5vbC1vdmVydmlld21hcDpub3QoLm9sLWNvbGxhcHNlZCkge1xcbiAgYmFja2dyb3VuZDogcmdiYSgyNTUsMjU1LDI1NSwwLjgpO1xcbn1cXG4ub2wtb3ZlcnZpZXdtYXAtYm94IHtcXG4gIGJvcmRlcjogMnB4IGRvdHRlZCByZ2JhKDAsNjAsMTM2LDAuNyk7XFxufVxcblxcbi5vbC1vdmVydmlld21hcCAub2wtb3ZlcnZpZXdtYXAtYm94OmhvdmVyIHtcXG4gIGN1cnNvcjogbW92ZTtcXG59XFxuXCIsIFwiXCJdKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1c2VTb3VyY2VNYXApIHtcbiAgdmFyIGxpc3QgPSBbXTsgLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXG4gIGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICByZXR1cm4gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwie1wiKS5jb25jYXQoY29udGVudCwgXCJ9XCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKCcnKTtcbiAgfTsgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblxuXG4gIGxpc3QuaSA9IGZ1bmN0aW9uIChtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCAnJ11dO1xuICAgIH1cblxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgdmFyIGlkID0gdGhpc1tpXVswXTtcblxuICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBtb2R1bGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGl0ZW0gPSBtb2R1bGVzW19pXTsgLy8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuICAgICAgLy8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcbiAgICAgIC8vIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cbiAgICAgIC8vIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcblxuICAgICAgaWYgKGl0ZW1bMF0gPT0gbnVsbCB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICBpZiAobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuICAgICAgICB9IGVsc2UgaWYgKG1lZGlhUXVlcnkpIHtcbiAgICAgICAgICBpdGVtWzJdID0gXCIoXCIuY29uY2F0KGl0ZW1bMl0sIFwiKSBhbmQgKFwiKS5jb25jYXQobWVkaWFRdWVyeSwgXCIpXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJzsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG5cbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QpLmNvbmNhdChzb3VyY2UsIFwiICovXCIpO1xuICAgIH0pO1xuICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn0gLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuXG5cbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gIHJldHVybiBcIi8qIyBcIi5jb25jYXQoZGF0YSwgXCIgKi9cIik7XG59IiwiLyoqXG4gKiBAbW9kdWxlIG9sL0Fzc2VydGlvbkVycm9yXG4gKi9cbmltcG9ydCB7VkVSU0lPTn0gZnJvbSAnLi91dGlsLmpzJztcblxuLyoqXG4gKiBFcnJvciBvYmplY3QgdGhyb3duIHdoZW4gYW4gYXNzZXJ0aW9uIGZhaWxlZC4gVGhpcyBpcyBhbiBFQ01BLTI2MiBFcnJvcixcbiAqIGV4dGVuZGVkIHdpdGggYSBgY29kZWAgcHJvcGVydHkuXG4gKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3IuXG4gKi9cbnZhciBBc3NlcnRpb25FcnJvciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEVycm9yKSB7XG4gIGZ1bmN0aW9uIEFzc2VydGlvbkVycm9yKGNvZGUpIHtcbiAgICB2YXIgcGF0aCA9IFZFUlNJT04gPT09ICdsYXRlc3QnID8gVkVSU0lPTiA6ICd2JyArIFZFUlNJT04uc3BsaXQoJy0nKVswXTtcbiAgICB2YXIgbWVzc2FnZSA9ICdBc3NlcnRpb24gZmFpbGVkLiBTZWUgaHR0cHM6Ly9vcGVubGF5ZXJzLm9yZy9lbi8nICsgcGF0aCArXG4gICAgJy9kb2MvZXJyb3JzLyMnICsgY29kZSArICcgZm9yIGRldGFpbHMuJztcblxuICAgIEVycm9yLmNhbGwodGhpcywgbWVzc2FnZSk7XG5cbiAgICAvKipcbiAgICAgKiBFcnJvciBjb2RlLiBUaGUgbWVhbmluZyBvZiB0aGUgY29kZSBjYW4gYmUgZm91bmQgb25cbiAgICAgKiBodHRwczovL29wZW5sYXllcnMub3JnL2VuL2xhdGVzdC9kb2MvZXJyb3JzLyAocmVwbGFjZSBgbGF0ZXN0YCB3aXRoXG4gICAgICogdGhlIHZlcnNpb24gZm91bmQgaW4gdGhlIE9wZW5MYXllcnMgc2NyaXB0J3MgaGVhZGVyIGNvbW1lbnQgaWYgYSB2ZXJzaW9uXG4gICAgICogb3RoZXIgdGhhbiB0aGUgbGF0ZXN0IGlzIHVzZWQpLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7XG5cbiAgICAvLyBSZS1hc3NpZ24gbWVzc2FnZSwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9SaWNoLUhhcnJpcy9idWJsZS9pc3N1ZXMvNDBcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB9XG5cbiAgaWYgKCBFcnJvciApIEFzc2VydGlvbkVycm9yLl9fcHJvdG9fXyA9IEVycm9yO1xuICBBc3NlcnRpb25FcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFcnJvciAmJiBFcnJvci5wcm90b3R5cGUgKTtcbiAgQXNzZXJ0aW9uRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQXNzZXJ0aW9uRXJyb3I7XG5cbiAgcmV0dXJuIEFzc2VydGlvbkVycm9yO1xufShFcnJvcikpO1xuXG5leHBvcnQgZGVmYXVsdCBBc3NlcnRpb25FcnJvcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXNzZXJ0aW9uRXJyb3IuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL0NvbGxlY3Rpb25cbiAqL1xuaW1wb3J0IEFzc2VydGlvbkVycm9yIGZyb20gJy4vQXNzZXJ0aW9uRXJyb3IuanMnO1xuaW1wb3J0IENvbGxlY3Rpb25FdmVudFR5cGUgZnJvbSAnLi9Db2xsZWN0aW9uRXZlbnRUeXBlLmpzJztcbmltcG9ydCBCYXNlT2JqZWN0IGZyb20gJy4vT2JqZWN0LmpzJztcbmltcG9ydCBFdmVudCBmcm9tICcuL2V2ZW50cy9FdmVudC5qcyc7XG5cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xudmFyIFByb3BlcnR5ID0ge1xuICBMRU5HVEg6ICdsZW5ndGgnXG59O1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogRXZlbnRzIGVtaXR0ZWQgYnkge0BsaW5rIG1vZHVsZTpvbC9Db2xsZWN0aW9ufkNvbGxlY3Rpb259IGluc3RhbmNlcyBhcmUgaW5zdGFuY2VzIG9mIHRoaXNcbiAqIHR5cGUuXG4gKi9cbmV4cG9ydCB2YXIgQ29sbGVjdGlvbkV2ZW50ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoRXZlbnQpIHtcbiAgZnVuY3Rpb24gQ29sbGVjdGlvbkV2ZW50KHR5cGUsIG9wdF9lbGVtZW50KSB7XG4gICAgRXZlbnQuY2FsbCh0aGlzLCB0eXBlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBlbGVtZW50IHRoYXQgaXMgYWRkZWQgdG8gb3IgcmVtb3ZlZCBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqIEB0eXBlIHsqfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLmVsZW1lbnQgPSBvcHRfZWxlbWVudDtcblxuICB9XG5cbiAgaWYgKCBFdmVudCApIENvbGxlY3Rpb25FdmVudC5fX3Byb3RvX18gPSBFdmVudDtcbiAgQ29sbGVjdGlvbkV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEV2ZW50ICYmIEV2ZW50LnByb3RvdHlwZSApO1xuICBDb2xsZWN0aW9uRXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29sbGVjdGlvbkV2ZW50O1xuXG4gIHJldHVybiBDb2xsZWN0aW9uRXZlbnQ7XG59KEV2ZW50KSk7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt1bmlxdWU9ZmFsc2VdIERpc2FsbG93IHRoZSBzYW1lIGl0ZW0gZnJvbSBiZWluZyBhZGRlZCB0b1xuICogdGhlIGNvbGxlY3Rpb24gdHdpY2UuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBbiBleHBhbmRlZCB2ZXJzaW9uIG9mIHN0YW5kYXJkIEpTIEFycmF5LCBhZGRpbmcgY29udmVuaWVuY2UgbWV0aG9kcyBmb3JcbiAqIG1hbmlwdWxhdGlvbi4gQWRkIGFuZCByZW1vdmUgY2hhbmdlcyB0byB0aGUgQ29sbGVjdGlvbiB0cmlnZ2VyIGEgQ29sbGVjdGlvblxuICogZXZlbnQuIE5vdGUgdGhhdCB0aGlzIGRvZXMgbm90IGNvdmVyIGNoYW5nZXMgdG8gdGhlIG9iamVjdHMgX3dpdGhpbl8gdGhlXG4gKiBDb2xsZWN0aW9uOyB0aGV5IHRyaWdnZXIgZXZlbnRzIG9uIHRoZSBhcHByb3ByaWF0ZSBvYmplY3QsIG5vdCBvbiB0aGVcbiAqIENvbGxlY3Rpb24gYXMgYSB3aG9sZS5cbiAqXG4gKiBAZmlyZXMgQ29sbGVjdGlvbkV2ZW50XG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBhcGlcbiAqL1xudmFyIENvbGxlY3Rpb24gPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChCYXNlT2JqZWN0KSB7XG4gIGZ1bmN0aW9uIENvbGxlY3Rpb24ob3B0X2FycmF5LCBvcHRfb3B0aW9ucykge1xuXG4gICAgQmFzZU9iamVjdC5jYWxsKHRoaXMpO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBvcHRfb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy51bmlxdWVfID0gISFvcHRpb25zLnVuaXF1ZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFBcnJheTxUPn1cbiAgICAgKi9cbiAgICB0aGlzLmFycmF5XyA9IG9wdF9hcnJheSA/IG9wdF9hcnJheSA6IFtdO1xuXG4gICAgaWYgKHRoaXMudW5pcXVlXykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdGhpcy5hcnJheV8ubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICB0aGlzLmFzc2VydFVuaXF1ZV8odGhpcy5hcnJheV9baV0sIGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudXBkYXRlTGVuZ3RoXygpO1xuXG4gIH1cblxuICBpZiAoIEJhc2VPYmplY3QgKSBDb2xsZWN0aW9uLl9fcHJvdG9fXyA9IEJhc2VPYmplY3Q7XG4gIENvbGxlY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQmFzZU9iamVjdCAmJiBCYXNlT2JqZWN0LnByb3RvdHlwZSApO1xuICBDb2xsZWN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbGxlY3Rpb247XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbGwgZWxlbWVudHMgZnJvbSB0aGUgY29sbGVjdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgQ29sbGVjdGlvbi5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgd2hpbGUgKHRoaXMuZ2V0TGVuZ3RoKCkgPiAwKSB7XG4gICAgICB0aGlzLnBvcCgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQWRkIGVsZW1lbnRzIHRvIHRoZSBjb2xsZWN0aW9uLiAgVGhpcyBwdXNoZXMgZWFjaCBpdGVtIGluIHRoZSBwcm92aWRlZCBhcnJheVxuICAgKiB0byB0aGUgZW5kIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgKiBAcGFyYW0geyFBcnJheTxUPn0gYXJyIEFycmF5LlxuICAgKiBAcmV0dXJuIHtDb2xsZWN0aW9uPFQ+fSBUaGlzIGNvbGxlY3Rpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIENvbGxlY3Rpb24ucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uIGV4dGVuZCAoYXJyKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gYXJyLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIHRoaXMucHVzaChhcnJbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogSXRlcmF0ZSBvdmVyIGVhY2ggZWxlbWVudCwgY2FsbGluZyB0aGUgcHJvdmlkZWQgY2FsbGJhY2suXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oVCwgbnVtYmVyLCBBcnJheTxUPik6ICp9IGYgVGhlIGZ1bmN0aW9uIHRvIGNhbGxcbiAgICogICAgIGZvciBldmVyeSBlbGVtZW50LiBUaGlzIGZ1bmN0aW9uIHRha2VzIDMgYXJndW1lbnRzICh0aGUgZWxlbWVudCwgdGhlXG4gICAqICAgICBpbmRleCBhbmQgdGhlIGFycmF5KS4gVGhlIHJldHVybiB2YWx1ZSBpcyBpZ25vcmVkLlxuICAgKiBAYXBpXG4gICAqL1xuICBDb2xsZWN0aW9uLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaCAoZikge1xuICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXlfO1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGFycmF5Lmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGYoYXJyYXlbaV0sIGksIGFycmF5KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhIHJlZmVyZW5jZSB0byB0aGUgdW5kZXJseWluZyBBcnJheSBvYmplY3QuIFdhcm5pbmc6IGlmIHRoZSBhcnJheVxuICAgKiBpcyBtdXRhdGVkLCBubyBldmVudHMgd2lsbCBiZSBkaXNwYXRjaGVkIGJ5IHRoZSBjb2xsZWN0aW9uLCBhbmQgdGhlXG4gICAqIGNvbGxlY3Rpb24ncyBcImxlbmd0aFwiIHByb3BlcnR5IHdvbid0IGJlIGluIHN5bmMgd2l0aCB0aGUgYWN0dWFsIGxlbmd0aFxuICAgKiBvZiB0aGUgYXJyYXkuXG4gICAqIEByZXR1cm4geyFBcnJheTxUPn0gQXJyYXkuXG4gICAqIEBhcGlcbiAgICovXG4gIENvbGxlY3Rpb24ucHJvdG90eXBlLmdldEFycmF5ID0gZnVuY3Rpb24gZ2V0QXJyYXkgKCkge1xuICAgIHJldHVybiB0aGlzLmFycmF5XztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBlbGVtZW50IGF0IHRoZSBwcm92aWRlZCBpbmRleC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4LlxuICAgKiBAcmV0dXJuIHtUfSBFbGVtZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBDb2xsZWN0aW9uLnByb3RvdHlwZS5pdGVtID0gZnVuY3Rpb24gaXRlbSAoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5hcnJheV9baW5kZXhdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxlbmd0aCBvZiB0aGlzIGNvbGxlY3Rpb24uXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIENvbGxlY3Rpb24ucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uIGdldExlbmd0aCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFByb3BlcnR5LkxFTkdUSCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluc2VydCBhbiBlbGVtZW50IGF0IHRoZSBwcm92aWRlZCBpbmRleC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4LlxuICAgKiBAcGFyYW0ge1R9IGVsZW0gRWxlbWVudC5cbiAgICogQGFwaVxuICAgKi9cbiAgQ29sbGVjdGlvbi5wcm90b3R5cGUuaW5zZXJ0QXQgPSBmdW5jdGlvbiBpbnNlcnRBdCAoaW5kZXgsIGVsZW0pIHtcbiAgICBpZiAodGhpcy51bmlxdWVfKSB7XG4gICAgICB0aGlzLmFzc2VydFVuaXF1ZV8oZWxlbSk7XG4gICAgfVxuICAgIHRoaXMuYXJyYXlfLnNwbGljZShpbmRleCwgMCwgZWxlbSk7XG4gICAgdGhpcy51cGRhdGVMZW5ndGhfKCk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgbmV3IENvbGxlY3Rpb25FdmVudChDb2xsZWN0aW9uRXZlbnRUeXBlLkFERCwgZWxlbSkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGxhc3QgZWxlbWVudCBvZiB0aGUgY29sbGVjdGlvbiBhbmQgcmV0dXJuIGl0LlxuICAgKiBSZXR1cm4gYHVuZGVmaW5lZGAgaWYgdGhlIGNvbGxlY3Rpb24gaXMgZW1wdHkuXG4gICAqIEByZXR1cm4ge1R8dW5kZWZpbmVkfSBFbGVtZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBDb2xsZWN0aW9uLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiBwb3AgKCkge1xuICAgIHJldHVybiB0aGlzLnJlbW92ZUF0KHRoaXMuZ2V0TGVuZ3RoKCkgLSAxKTtcbiAgfTtcblxuICAvKipcbiAgICogSW5zZXJ0IHRoZSBwcm92aWRlZCBlbGVtZW50IGF0IHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAqIEBwYXJhbSB7VH0gZWxlbSBFbGVtZW50LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE5ldyBsZW5ndGggb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIENvbGxlY3Rpb24ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoIChlbGVtKSB7XG4gICAgaWYgKHRoaXMudW5pcXVlXykge1xuICAgICAgdGhpcy5hc3NlcnRVbmlxdWVfKGVsZW0pO1xuICAgIH1cbiAgICB2YXIgbiA9IHRoaXMuZ2V0TGVuZ3RoKCk7XG4gICAgdGhpcy5pbnNlcnRBdChuLCBlbGVtKTtcbiAgICByZXR1cm4gdGhpcy5nZXRMZW5ndGgoKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGFuIGVsZW1lbnQgZnJvbSB0aGUgY29sbGVjdGlvbi5cbiAgICogQHBhcmFtIHtUfSBlbGVtIEVsZW1lbnQuXG4gICAqIEByZXR1cm4ge1R8dW5kZWZpbmVkfSBUaGUgcmVtb3ZlZCBlbGVtZW50IG9yIHVuZGVmaW5lZCBpZiBub25lIGZvdW5kLlxuICAgKiBAYXBpXG4gICAqL1xuICBDb2xsZWN0aW9uLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUgKGVsZW0pIHtcbiAgICB2YXIgYXJyID0gdGhpcy5hcnJheV87XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gYXJyLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGlmIChhcnJbaV0gPT09IGVsZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlQXQoaSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgZWxlbWVudCBhdCB0aGUgcHJvdmlkZWQgaW5kZXggYW5kIHJldHVybiBpdC5cbiAgICogUmV0dXJuIGB1bmRlZmluZWRgIGlmIHRoZSBjb2xsZWN0aW9uIGRvZXMgbm90IGNvbnRhaW4gdGhpcyBpbmRleC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4LlxuICAgKiBAcmV0dXJuIHtUfHVuZGVmaW5lZH0gVmFsdWUuXG4gICAqIEBhcGlcbiAgICovXG4gIENvbGxlY3Rpb24ucHJvdG90eXBlLnJlbW92ZUF0ID0gZnVuY3Rpb24gcmVtb3ZlQXQgKGluZGV4KSB7XG4gICAgdmFyIHByZXYgPSB0aGlzLmFycmF5X1tpbmRleF07XG4gICAgdGhpcy5hcnJheV8uc3BsaWNlKGluZGV4LCAxKTtcbiAgICB0aGlzLnVwZGF0ZUxlbmd0aF8oKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IENvbGxlY3Rpb25FdmVudChDb2xsZWN0aW9uRXZlbnRUeXBlLlJFTU9WRSwgcHJldikpO1xuICAgIHJldHVybiBwcmV2O1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGVsZW1lbnQgYXQgdGhlIHByb3ZpZGVkIGluZGV4LlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXguXG4gICAqIEBwYXJhbSB7VH0gZWxlbSBFbGVtZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBDb2xsZWN0aW9uLnByb3RvdHlwZS5zZXRBdCA9IGZ1bmN0aW9uIHNldEF0IChpbmRleCwgZWxlbSkge1xuICAgIHZhciBuID0gdGhpcy5nZXRMZW5ndGgoKTtcbiAgICBpZiAoaW5kZXggPCBuKSB7XG4gICAgICBpZiAodGhpcy51bmlxdWVfKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0VW5pcXVlXyhlbGVtLCBpbmRleCk7XG4gICAgICB9XG4gICAgICB2YXIgcHJldiA9IHRoaXMuYXJyYXlfW2luZGV4XTtcbiAgICAgIHRoaXMuYXJyYXlfW2luZGV4XSA9IGVsZW07XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICAgIG5ldyBDb2xsZWN0aW9uRXZlbnQoQ29sbGVjdGlvbkV2ZW50VHlwZS5SRU1PVkUsIHByZXYpKTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgbmV3IENvbGxlY3Rpb25FdmVudChDb2xsZWN0aW9uRXZlbnRUeXBlLkFERCwgZWxlbSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBqID0gbjsgaiA8IGluZGV4OyArK2opIHtcbiAgICAgICAgdGhpcy5pbnNlcnRBdChqLCB1bmRlZmluZWQpO1xuICAgICAgfVxuICAgICAgdGhpcy5pbnNlcnRBdChpbmRleCwgZWxlbSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQ29sbGVjdGlvbi5wcm90b3R5cGUudXBkYXRlTGVuZ3RoXyA9IGZ1bmN0aW9uIHVwZGF0ZUxlbmd0aF8gKCkge1xuICAgIHRoaXMuc2V0KFByb3BlcnR5LkxFTkdUSCwgdGhpcy5hcnJheV8ubGVuZ3RoKTtcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtUfSBlbGVtIEVsZW1lbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2V4Y2VwdCBPcHRpb25hbCBpbmRleCB0byBpZ25vcmUuXG4gICAqL1xuICBDb2xsZWN0aW9uLnByb3RvdHlwZS5hc3NlcnRVbmlxdWVfID0gZnVuY3Rpb24gYXNzZXJ0VW5pcXVlXyAoZWxlbSwgb3B0X2V4Y2VwdCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHRoaXMuYXJyYXlfLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGlmICh0aGlzLmFycmF5X1tpXSA9PT0gZWxlbSAmJiBpICE9PSBvcHRfZXhjZXB0KSB7XG4gICAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcig1OCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBDb2xsZWN0aW9uO1xufShCYXNlT2JqZWN0KSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgQ29sbGVjdGlvbjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29sbGVjdGlvbi5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvQ29sbGVjdGlvbkV2ZW50VHlwZVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICAvKipcbiAgICogVHJpZ2dlcmVkIHdoZW4gYW4gaXRlbSBpcyBhZGRlZCB0byB0aGUgY29sbGVjdGlvbi5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9Db2xsZWN0aW9uLkNvbGxlY3Rpb25FdmVudCNhZGRcbiAgICogQGFwaVxuICAgKi9cbiAgQUREOiAnYWRkJyxcbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB3aGVuIGFuIGl0ZW0gaXMgcmVtb3ZlZCBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL0NvbGxlY3Rpb24uQ29sbGVjdGlvbkV2ZW50I3JlbW92ZVxuICAgKiBAYXBpXG4gICAqL1xuICBSRU1PVkU6ICdyZW1vdmUnXG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db2xsZWN0aW9uRXZlbnRUeXBlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9EaXNwb3NhYmxlXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBPYmplY3RzIHRoYXQgbmVlZCB0byBjbGVhbiB1cCBhZnRlciB0aGVtc2VsdmVzLlxuICovXG52YXIgRGlzcG9zYWJsZSA9IGZ1bmN0aW9uIERpc3Bvc2FibGUoKSB7XG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IGhhcyBhbHJlYWR5IGJlZW4gZGlzcG9zZWQuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5kaXNwb3NlZF8gPSBmYWxzZTtcbn07XG5cbi8qKlxuICogQ2xlYW4gdXAuXG4gKi9cbkRpc3Bvc2FibGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlICgpIHtcbiAgaWYgKCF0aGlzLmRpc3Bvc2VkXykge1xuICAgIHRoaXMuZGlzcG9zZWRfID0gdHJ1ZTtcbiAgICB0aGlzLmRpc3Bvc2VJbnRlcm5hbCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEV4dGVuc2lvbiBwb2ludCBmb3IgZGlzcG9zYWJsZSBvYmplY3RzLlxuICogQHByb3RlY3RlZFxuICovXG5EaXNwb3NhYmxlLnByb3RvdHlwZS5kaXNwb3NlSW50ZXJuYWwgPSBmdW5jdGlvbiBkaXNwb3NlSW50ZXJuYWwgKCkge307XG5cbmV4cG9ydCBkZWZhdWx0IERpc3Bvc2FibGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURpc3Bvc2FibGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL0ZlYXR1cmVcbiAqL1xuaW1wb3J0IHthc3NlcnR9IGZyb20gJy4vYXNzZXJ0cy5qcyc7XG5pbXBvcnQge2xpc3RlbiwgdW5saXN0ZW4sIHVubGlzdGVuQnlLZXl9IGZyb20gJy4vZXZlbnRzLmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBCYXNlT2JqZWN0LCB7Z2V0Q2hhbmdlRXZlbnRUeXBlfSBmcm9tICcuL09iamVjdC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge3R5cGVvZiBGZWF0dXJlfHR5cGVvZiBpbXBvcnQoXCIuL3JlbmRlci9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IEZlYXR1cmVDbGFzc1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge0ZlYXR1cmV8aW1wb3J0KFwiLi9yZW5kZXIvRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBGZWF0dXJlTGlrZVxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQSB2ZWN0b3Igb2JqZWN0IGZvciBnZW9ncmFwaGljIGZlYXR1cmVzIHdpdGggYSBnZW9tZXRyeSBhbmQgb3RoZXJcbiAqIGF0dHJpYnV0ZSBwcm9wZXJ0aWVzLCBzaW1pbGFyIHRvIHRoZSBmZWF0dXJlcyBpbiB2ZWN0b3IgZmlsZSBmb3JtYXRzIGxpa2VcbiAqIEdlb0pTT04uXG4gKlxuICogRmVhdHVyZXMgY2FuIGJlIHN0eWxlZCBpbmRpdmlkdWFsbHkgd2l0aCBgc2V0U3R5bGVgOyBvdGhlcndpc2UgdGhleSB1c2UgdGhlXG4gKiBzdHlsZSBvZiB0aGVpciB2ZWN0b3IgbGF5ZXIuXG4gKlxuICogTm90ZSB0aGF0IGF0dHJpYnV0ZSBwcm9wZXJ0aWVzIGFyZSBzZXQgYXMge0BsaW5rIG1vZHVsZTpvbC9PYmplY3R9IHByb3BlcnRpZXMgb25cbiAqIHRoZSBmZWF0dXJlIG9iamVjdCwgc28gdGhleSBhcmUgb2JzZXJ2YWJsZSwgYW5kIGhhdmUgZ2V0L3NldCBhY2Nlc3NvcnMuXG4gKlxuICogVHlwaWNhbGx5LCBhIGZlYXR1cmUgaGFzIGEgc2luZ2xlIGdlb21ldHJ5IHByb3BlcnR5LiBZb3UgY2FuIHNldCB0aGVcbiAqIGdlb21ldHJ5IHVzaW5nIHRoZSBgc2V0R2VvbWV0cnlgIG1ldGhvZCBhbmQgZ2V0IGl0IHdpdGggYGdldEdlb21ldHJ5YC5cbiAqIEl0IGlzIHBvc3NpYmxlIHRvIHN0b3JlIG1vcmUgdGhhbiBvbmUgZ2VvbWV0cnkgb24gYSBmZWF0dXJlIHVzaW5nIGF0dHJpYnV0ZVxuICogcHJvcGVydGllcy4gQnkgZGVmYXVsdCwgdGhlIGdlb21ldHJ5IHVzZWQgZm9yIHJlbmRlcmluZyBpcyBpZGVudGlmaWVkIGJ5XG4gKiB0aGUgcHJvcGVydHkgbmFtZSBgZ2VvbWV0cnlgLiBJZiB5b3Ugd2FudCB0byB1c2UgYW5vdGhlciBnZW9tZXRyeSBwcm9wZXJ0eVxuICogZm9yIHJlbmRlcmluZywgdXNlIHRoZSBgc2V0R2VvbWV0cnlOYW1lYCBtZXRob2QgdG8gY2hhbmdlIHRoZSBhdHRyaWJ1dGVcbiAqIHByb3BlcnR5IGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2VvbWV0cnkgZm9yIHRoZSBmZWF0dXJlLiAgRm9yIGV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqXG4gKiBpbXBvcnQgRmVhdHVyZSBmcm9tICdvbC9GZWF0dXJlJztcbiAqIGltcG9ydCBQb2x5Z29uIGZyb20gJ29sL2dlb20vUG9seWdvbic7XG4gKiBpbXBvcnQgUG9pbnQgZnJvbSAnb2wvZ2VvbS9Qb2ludCc7XG4gKlxuICogdmFyIGZlYXR1cmUgPSBuZXcgRmVhdHVyZSh7XG4gKiAgIGdlb21ldHJ5OiBuZXcgUG9seWdvbihwb2x5Q29vcmRzKSxcbiAqICAgbGFiZWxQb2ludDogbmV3IFBvaW50KGxhYmVsQ29vcmRzKSxcbiAqICAgbmFtZTogJ015IFBvbHlnb24nXG4gKiB9KTtcbiAqXG4gKiAvLyBnZXQgdGhlIHBvbHlnb24gZ2VvbWV0cnlcbiAqIHZhciBwb2x5ID0gZmVhdHVyZS5nZXRHZW9tZXRyeSgpO1xuICpcbiAqIC8vIFJlbmRlciB0aGUgZmVhdHVyZSBhcyBhIHBvaW50IHVzaW5nIHRoZSBjb29yZGluYXRlcyBmcm9tIGxhYmVsUG9pbnRcbiAqIGZlYXR1cmUuc2V0R2VvbWV0cnlOYW1lKCdsYWJlbFBvaW50Jyk7XG4gKlxuICogLy8gZ2V0IHRoZSBwb2ludCBnZW9tZXRyeVxuICogdmFyIHBvaW50ID0gZmVhdHVyZS5nZXRHZW9tZXRyeSgpO1xuICogYGBgXG4gKlxuICogQGFwaVxuICovXG52YXIgRmVhdHVyZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEJhc2VPYmplY3QpIHtcbiAgZnVuY3Rpb24gRmVhdHVyZShvcHRfZ2VvbWV0cnlPclByb3BlcnRpZXMpIHtcblxuICAgIEJhc2VPYmplY3QuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnxzdHJpbmd8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuaWRfID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZ2VvbWV0cnlOYW1lXyA9ICdnZW9tZXRyeSc7XG5cbiAgICAvKipcbiAgICAgKiBVc2VyIHByb3ZpZGVkIHN0eWxlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVMaWtlfVxuICAgICAqL1xuICAgIHRoaXMuc3R5bGVfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVGdW5jdGlvbnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5zdHlsZUZ1bmN0aW9uXyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXl9XG4gICAgICovXG4gICAgdGhpcy5nZW9tZXRyeUNoYW5nZUtleV8gPSBudWxsO1xuXG4gICAgbGlzdGVuKFxuICAgICAgdGhpcywgZ2V0Q2hhbmdlRXZlbnRUeXBlKHRoaXMuZ2VvbWV0cnlOYW1lXyksXG4gICAgICB0aGlzLmhhbmRsZUdlb21ldHJ5Q2hhbmdlZF8sIHRoaXMpO1xuXG4gICAgaWYgKG9wdF9nZW9tZXRyeU9yUHJvcGVydGllcykge1xuICAgICAgaWYgKHR5cGVvZiAvKiogQHR5cGUgez99ICovIChvcHRfZ2VvbWV0cnlPclByb3BlcnRpZXMpLmdldFNpbXBsaWZpZWRHZW9tZXRyeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgZ2VvbWV0cnkgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSAqLyAob3B0X2dlb21ldHJ5T3JQcm9wZXJ0aWVzKTtcbiAgICAgICAgdGhpcy5zZXRHZW9tZXRyeShnZW9tZXRyeSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiogQHR5cGUge09iamVjdDxzdHJpbmcsICo+fSAqL1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IG9wdF9nZW9tZXRyeU9yUHJvcGVydGllcztcbiAgICAgICAgdGhpcy5zZXRQcm9wZXJ0aWVzKHByb3BlcnRpZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICggQmFzZU9iamVjdCApIEZlYXR1cmUuX19wcm90b19fID0gQmFzZU9iamVjdDtcbiAgRmVhdHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCYXNlT2JqZWN0ICYmIEJhc2VPYmplY3QucHJvdG90eXBlICk7XG4gIEZlYXR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRmVhdHVyZTtcblxuICAvKipcbiAgICogQ2xvbmUgdGhpcyBmZWF0dXJlLiBJZiB0aGUgb3JpZ2luYWwgZmVhdHVyZSBoYXMgYSBnZW9tZXRyeSBpdFxuICAgKiBpcyBhbHNvIGNsb25lZC4gVGhlIGZlYXR1cmUgaWQgaXMgbm90IHNldCBpbiB0aGUgY2xvbmUuXG4gICAqIEByZXR1cm4ge0ZlYXR1cmV9IFRoZSBjbG9uZS5cbiAgICogQGFwaVxuICAgKi9cbiAgRmVhdHVyZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgdmFyIGNsb25lID0gbmV3IEZlYXR1cmUodGhpcy5nZXRQcm9wZXJ0aWVzKCkpO1xuICAgIGNsb25lLnNldEdlb21ldHJ5TmFtZSh0aGlzLmdldEdlb21ldHJ5TmFtZSgpKTtcbiAgICB2YXIgZ2VvbWV0cnkgPSB0aGlzLmdldEdlb21ldHJ5KCk7XG4gICAgaWYgKGdlb21ldHJ5KSB7XG4gICAgICBjbG9uZS5zZXRHZW9tZXRyeShnZW9tZXRyeS5jbG9uZSgpKTtcbiAgICB9XG4gICAgdmFyIHN0eWxlID0gdGhpcy5nZXRTdHlsZSgpO1xuICAgIGlmIChzdHlsZSkge1xuICAgICAgY2xvbmUuc2V0U3R5bGUoc3R5bGUpO1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZmVhdHVyZSdzIGRlZmF1bHQgZ2VvbWV0cnkuICBBIGZlYXR1cmUgbWF5IGhhdmUgYW55IG51bWJlciBvZiBuYW1lZFxuICAgKiBnZW9tZXRyaWVzLiAgVGhlIFwiZGVmYXVsdFwiIGdlb21ldHJ5ICh0aGUgb25lIHRoYXQgaXMgcmVuZGVyZWQgYnkgZGVmYXVsdCkgaXNcbiAgICogc2V0IHdoZW4gY2FsbGluZyB7QGxpbmsgbW9kdWxlOm9sL0ZlYXR1cmV+RmVhdHVyZSNzZXRHZW9tZXRyeX0uXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fHVuZGVmaW5lZH0gVGhlIGRlZmF1bHQgZ2VvbWV0cnkgZm9yIHRoZSBmZWF0dXJlLlxuICAgKiBAYXBpXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqL1xuICBGZWF0dXJlLnByb3RvdHlwZS5nZXRHZW9tZXRyeSA9IGZ1bmN0aW9uIGdldEdlb21ldHJ5ICgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdHx1bmRlZmluZWR9ICovICh0aGlzLmdldCh0aGlzLmdlb21ldHJ5TmFtZV8pKVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZmVhdHVyZSBpZGVudGlmaWVyLiAgVGhpcyBpcyBhIHN0YWJsZSBpZGVudGlmaWVyIGZvciB0aGUgZmVhdHVyZSBhbmRcbiAgICogaXMgZWl0aGVyIHNldCB3aGVuIHJlYWRpbmcgZGF0YSBmcm9tIGEgcmVtb3RlIHNvdXJjZSBvciBzZXQgZXhwbGljaXRseSBieVxuICAgKiBjYWxsaW5nIHtAbGluayBtb2R1bGU6b2wvRmVhdHVyZX5GZWF0dXJlI3NldElkfS5cbiAgICogQHJldHVybiB7bnVtYmVyfHN0cmluZ3x1bmRlZmluZWR9IElkLlxuICAgKiBAYXBpXG4gICAqL1xuICBGZWF0dXJlLnByb3RvdHlwZS5nZXRJZCA9IGZ1bmN0aW9uIGdldElkICgpIHtcbiAgICByZXR1cm4gdGhpcy5pZF87XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmFtZSBvZiB0aGUgZmVhdHVyZSdzIGRlZmF1bHQgZ2VvbWV0cnkuICBCeSBkZWZhdWx0LCB0aGUgZGVmYXVsdFxuICAgKiBnZW9tZXRyeSBpcyBuYW1lZCBgZ2VvbWV0cnlgLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEdldCB0aGUgcHJvcGVydHkgbmFtZSBhc3NvY2lhdGVkIHdpdGggdGhlIGRlZmF1bHQgZ2VvbWV0cnlcbiAgICogICAgIGZvciB0aGlzIGZlYXR1cmUuXG4gICAqIEBhcGlcbiAgICovXG4gIEZlYXR1cmUucHJvdG90eXBlLmdldEdlb21ldHJ5TmFtZSA9IGZ1bmN0aW9uIGdldEdlb21ldHJ5TmFtZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlOYW1lXztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBmZWF0dXJlJ3Mgc3R5bGUuIFdpbGwgcmV0dXJuIHdoYXQgd2FzIHByb3ZpZGVkIHRvIHRoZVxuICAgKiB7QGxpbmsgbW9kdWxlOm9sL0ZlYXR1cmV+RmVhdHVyZSNzZXRTdHlsZX0gbWV0aG9kLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL3N0eWxlL1N0eWxlLmpzXCIpLlN0eWxlTGlrZX0gVGhlIGZlYXR1cmUgc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIEZlYXR1cmUucHJvdG90eXBlLmdldFN0eWxlID0gZnVuY3Rpb24gZ2V0U3R5bGUgKCkge1xuICAgIHJldHVybiB0aGlzLnN0eWxlXztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBmZWF0dXJlJ3Mgc3R5bGUgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVGdW5jdGlvbnx1bmRlZmluZWR9IFJldHVybiBhIGZ1bmN0aW9uXG4gICAqIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBzdHlsZSBvZiB0aGlzIGZlYXR1cmUuXG4gICAqIEBhcGlcbiAgICovXG4gIEZlYXR1cmUucHJvdG90eXBlLmdldFN0eWxlRnVuY3Rpb24gPSBmdW5jdGlvbiBnZXRTdHlsZUZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHlsZUZ1bmN0aW9uXztcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEZlYXR1cmUucHJvdG90eXBlLmhhbmRsZUdlb21ldHJ5Q2hhbmdlXyA9IGZ1bmN0aW9uIGhhbmRsZUdlb21ldHJ5Q2hhbmdlXyAoKSB7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBGZWF0dXJlLnByb3RvdHlwZS5oYW5kbGVHZW9tZXRyeUNoYW5nZWRfID0gZnVuY3Rpb24gaGFuZGxlR2VvbWV0cnlDaGFuZ2VkXyAoKSB7XG4gICAgaWYgKHRoaXMuZ2VvbWV0cnlDaGFuZ2VLZXlfKSB7XG4gICAgICB1bmxpc3RlbkJ5S2V5KHRoaXMuZ2VvbWV0cnlDaGFuZ2VLZXlfKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnlDaGFuZ2VLZXlfID0gbnVsbDtcbiAgICB9XG4gICAgdmFyIGdlb21ldHJ5ID0gdGhpcy5nZXRHZW9tZXRyeSgpO1xuICAgIGlmIChnZW9tZXRyeSkge1xuICAgICAgdGhpcy5nZW9tZXRyeUNoYW5nZUtleV8gPSBsaXN0ZW4oZ2VvbWV0cnksXG4gICAgICAgIEV2ZW50VHlwZS5DSEFOR0UsIHRoaXMuaGFuZGxlR2VvbWV0cnlDaGFuZ2VfLCB0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZGVmYXVsdCBnZW9tZXRyeSBmb3IgdGhlIGZlYXR1cmUuICBUaGlzIHdpbGwgdXBkYXRlIHRoZSBwcm9wZXJ0eVxuICAgKiB3aXRoIHRoZSBuYW1lIHJldHVybmVkIGJ5IHtAbGluayBtb2R1bGU6b2wvRmVhdHVyZX5GZWF0dXJlI2dldEdlb21ldHJ5TmFtZX0uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR8dW5kZWZpbmVkfSBnZW9tZXRyeSBUaGUgbmV3IGdlb21ldHJ5LlxuICAgKiBAYXBpXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqL1xuICBGZWF0dXJlLnByb3RvdHlwZS5zZXRHZW9tZXRyeSA9IGZ1bmN0aW9uIHNldEdlb21ldHJ5IChnZW9tZXRyeSkge1xuICAgIHRoaXMuc2V0KHRoaXMuZ2VvbWV0cnlOYW1lXywgZ2VvbWV0cnkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHN0eWxlIGZvciB0aGUgZmVhdHVyZS4gIFRoaXMgY2FuIGJlIGEgc2luZ2xlIHN0eWxlIG9iamVjdCwgYW4gYXJyYXlcbiAgICogb2Ygc3R5bGVzLCBvciBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSByZXNvbHV0aW9uIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mXG4gICAqIHN0eWxlcy4gSWYgaXQgaXMgYG51bGxgIHRoZSBmZWF0dXJlIGhhcyBubyBzdHlsZSAoYSBgbnVsbGAgc3R5bGUpLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVMaWtlfSBzdHlsZSBTdHlsZSBmb3IgdGhpcyBmZWF0dXJlLlxuICAgKiBAYXBpXG4gICAqIEBmaXJlcyBtb2R1bGU6b2wvZXZlbnRzL0V2ZW50fkV2ZW50I2V2ZW50OmNoYW5nZVxuICAgKi9cbiAgRmVhdHVyZS5wcm90b3R5cGUuc2V0U3R5bGUgPSBmdW5jdGlvbiBzZXRTdHlsZSAoc3R5bGUpIHtcbiAgICB0aGlzLnN0eWxlXyA9IHN0eWxlO1xuICAgIHRoaXMuc3R5bGVGdW5jdGlvbl8gPSAhc3R5bGUgPyB1bmRlZmluZWQgOiBjcmVhdGVTdHlsZUZ1bmN0aW9uKHN0eWxlKTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBmZWF0dXJlIGlkLiAgVGhlIGZlYXR1cmUgaWQgaXMgY29uc2lkZXJlZCBzdGFibGUgYW5kIG1heSBiZSB1c2VkIHdoZW5cbiAgICogcmVxdWVzdGluZyBmZWF0dXJlcyBvciBjb21wYXJpbmcgaWRlbnRpZmllcnMgcmV0dXJuZWQgZnJvbSBhIHJlbW90ZSBzb3VyY2UuXG4gICAqIFRoZSBmZWF0dXJlIGlkIGNhbiBiZSB1c2VkIHdpdGggdGhlXG4gICAqIHtAbGluayBtb2R1bGU6b2wvc291cmNlL1ZlY3Rvcn5WZWN0b3JTb3VyY2UjZ2V0RmVhdHVyZUJ5SWR9IG1ldGhvZC5cbiAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfHVuZGVmaW5lZH0gaWQgVGhlIGZlYXR1cmUgaWQuXG4gICAqIEBhcGlcbiAgICogQGZpcmVzIG1vZHVsZTpvbC9ldmVudHMvRXZlbnR+RXZlbnQjZXZlbnQ6Y2hhbmdlXG4gICAqL1xuICBGZWF0dXJlLnByb3RvdHlwZS5zZXRJZCA9IGZ1bmN0aW9uIHNldElkIChpZCkge1xuICAgIHRoaXMuaWRfID0gaWQ7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcHJvcGVydHkgbmFtZSB0byBiZSB1c2VkIHdoZW4gZ2V0dGluZyB0aGUgZmVhdHVyZSdzIGRlZmF1bHQgZ2VvbWV0cnkuXG4gICAqIFdoZW4gY2FsbGluZyB7QGxpbmsgbW9kdWxlOm9sL0ZlYXR1cmV+RmVhdHVyZSNnZXRHZW9tZXRyeX0sIHRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgd2l0aFxuICAgKiB0aGlzIG5hbWUgd2lsbCBiZSByZXR1cm5lZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIHByb3BlcnR5IG5hbWUgb2YgdGhlIGRlZmF1bHQgZ2VvbWV0cnkuXG4gICAqIEBhcGlcbiAgICovXG4gIEZlYXR1cmUucHJvdG90eXBlLnNldEdlb21ldHJ5TmFtZSA9IGZ1bmN0aW9uIHNldEdlb21ldHJ5TmFtZSAobmFtZSkge1xuICAgIHVubGlzdGVuKFxuICAgICAgdGhpcywgZ2V0Q2hhbmdlRXZlbnRUeXBlKHRoaXMuZ2VvbWV0cnlOYW1lXyksXG4gICAgICB0aGlzLmhhbmRsZUdlb21ldHJ5Q2hhbmdlZF8sIHRoaXMpO1xuICAgIHRoaXMuZ2VvbWV0cnlOYW1lXyA9IG5hbWU7XG4gICAgbGlzdGVuKFxuICAgICAgdGhpcywgZ2V0Q2hhbmdlRXZlbnRUeXBlKHRoaXMuZ2VvbWV0cnlOYW1lXyksXG4gICAgICB0aGlzLmhhbmRsZUdlb21ldHJ5Q2hhbmdlZF8sIHRoaXMpO1xuICAgIHRoaXMuaGFuZGxlR2VvbWV0cnlDaGFuZ2VkXygpO1xuICB9O1xuXG4gIHJldHVybiBGZWF0dXJlO1xufShCYXNlT2JqZWN0KSk7XG5cblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBwcm92aWRlZCBvYmplY3QgaW50byBhIGZlYXR1cmUgc3R5bGUgZnVuY3Rpb24uICBGdW5jdGlvbnMgcGFzc2VkXG4gKiB0aHJvdWdoIHVuY2hhbmdlZC4gIEFycmF5cyBvZiBTdHlsZSBvciBzaW5nbGUgc3R5bGUgb2JqZWN0cyB3cmFwcGVkXG4gKiBpbiBhIG5ldyBmZWF0dXJlIHN0eWxlIGZ1bmN0aW9uLlxuICogQHBhcmFtIHshaW1wb3J0KFwiLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUZ1bmN0aW9ufCFBcnJheTxpbXBvcnQoXCIuL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHQ+fCFpbXBvcnQoXCIuL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHR9IG9ialxuICogICAgIEEgZmVhdHVyZSBzdHlsZSBmdW5jdGlvbiwgYSBzaW5nbGUgc3R5bGUsIG9yIGFuIGFycmF5IG9mIHN0eWxlcy5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVGdW5jdGlvbn0gQSBzdHlsZSBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN0eWxlRnVuY3Rpb24ob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfSBlbHNlIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi9zdHlsZS9TdHlsZS5qc1wiKS5kZWZhdWx0Pn1cbiAgICAgKi9cbiAgICB2YXIgc3R5bGVzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgIHN0eWxlcyA9IG9iajtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KHR5cGVvZiAvKiogQHR5cGUgez99ICovIChvYmopLmdldFpJbmRleCA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgNDEpOyAvLyBFeHBlY3RlZCBhbiBgaW1wb3J0KFwiLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZWAgb3IgYW4gYXJyYXkgb2YgYGltcG9ydChcIi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVgXG4gICAgICB2YXIgc3R5bGUgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdH0gKi8gKG9iaik7XG4gICAgICBzdHlsZXMgPSBbc3R5bGVdO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3R5bGVzO1xuICAgIH07XG4gIH1cbn1cbmV4cG9ydCBkZWZhdWx0IEZlYXR1cmU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZlYXR1cmUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL0ltYWdlQmFzZVxuICovXG5pbXBvcnQge2Fic3RyYWN0fSBmcm9tICcuL3V0aWwuanMnO1xuaW1wb3J0IEV2ZW50VGFyZ2V0IGZyb20gJy4vZXZlbnRzL1RhcmdldC5qcyc7XG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5cbi8qKlxuICogQGFic3RyYWN0XG4gKi9cbnZhciBJbWFnZUJhc2UgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChFdmVudFRhcmdldCkge1xuICBmdW5jdGlvbiBJbWFnZUJhc2UoZXh0ZW50LCByZXNvbHV0aW9uLCBwaXhlbFJhdGlvLCBzdGF0ZSkge1xuXG4gICAgRXZlbnRUYXJnZXQuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgICAqL1xuICAgIHRoaXMuZXh0ZW50ID0gZXh0ZW50O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucGl4ZWxSYXRpb18gPSBwaXhlbFJhdGlvO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vSW1hZ2VTdGF0ZS5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcblxuICB9XG5cbiAgaWYgKCBFdmVudFRhcmdldCApIEltYWdlQmFzZS5fX3Byb3RvX18gPSBFdmVudFRhcmdldDtcbiAgSW1hZ2VCYXNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEV2ZW50VGFyZ2V0ICYmIEV2ZW50VGFyZ2V0LnByb3RvdHlwZSApO1xuICBJbWFnZUJhc2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW1hZ2VCYXNlO1xuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBJbWFnZUJhc2UucHJvdG90eXBlLmNoYW5nZWQgPSBmdW5jdGlvbiBjaGFuZ2VkICgpIHtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRUeXBlLkNIQU5HRSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gRXh0ZW50LlxuICAgKi9cbiAgSW1hZ2VCYXNlLnByb3RvdHlwZS5nZXRFeHRlbnQgPSBmdW5jdGlvbiBnZXRFeHRlbnQgKCkge1xuICAgIHJldHVybiB0aGlzLmV4dGVudDtcbiAgfTtcblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fEhUTUxJbWFnZUVsZW1lbnR8SFRNTFZpZGVvRWxlbWVudH0gSW1hZ2UuXG4gICAqL1xuICBJbWFnZUJhc2UucHJvdG90eXBlLmdldEltYWdlID0gZnVuY3Rpb24gZ2V0SW1hZ2UgKCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFBpeGVsUmF0aW8uXG4gICAqL1xuICBJbWFnZUJhc2UucHJvdG90eXBlLmdldFBpeGVsUmF0aW8gPSBmdW5jdGlvbiBnZXRQaXhlbFJhdGlvICgpIHtcbiAgICByZXR1cm4gdGhpcy5waXhlbFJhdGlvXztcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBSZXNvbHV0aW9uLlxuICAgKi9cbiAgSW1hZ2VCYXNlLnByb3RvdHlwZS5nZXRSZXNvbHV0aW9uID0gZnVuY3Rpb24gZ2V0UmVzb2x1dGlvbiAoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5yZXNvbHV0aW9uKTtcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9JbWFnZVN0YXRlLmpzXCIpLmRlZmF1bHR9IFN0YXRlLlxuICAgKi9cbiAgSW1hZ2VCYXNlLnByb3RvdHlwZS5nZXRTdGF0ZSA9IGZ1bmN0aW9uIGdldFN0YXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZTtcbiAgfTtcblxuICAvKipcbiAgICogTG9hZCBub3QgeWV0IGxvYWRlZCBVUkkuXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgSW1hZ2VCYXNlLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gbG9hZCAoKSB7XG4gICAgYWJzdHJhY3QoKTtcbiAgfTtcblxuICByZXR1cm4gSW1hZ2VCYXNlO1xufShFdmVudFRhcmdldCkpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IEltYWdlQmFzZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW1hZ2VCYXNlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9JbWFnZUNhbnZhc1xuICovXG5pbXBvcnQgSW1hZ2VCYXNlIGZyb20gJy4vSW1hZ2VCYXNlLmpzJztcbmltcG9ydCBJbWFnZVN0YXRlIGZyb20gJy4vSW1hZ2VTdGF0ZS5qcyc7XG5cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHRvIHRyaWdnZXIgYXN5bmNocm9ub3VzIGNhbnZhcyBkcmF3aW5nLiAgSXQgaXNcbiAqIGNhbGxlZCB3aXRoIGEgXCJkb25lXCIgY2FsbGJhY2sgdGhhdCBzaG91bGQgYmUgY2FsbGVkIHdoZW4gZHJhd2luZyBpcyBkb25lLlxuICogSWYgYW55IGVycm9yIG9jY3VycyBkdXJpbmcgZHJhd2luZywgdGhlIFwiZG9uZVwiIGNhbGxiYWNrIHNob3VsZCBiZSBjYWxsZWQgd2l0aFxuICogdGhhdCBlcnJvci5cbiAqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oZnVuY3Rpb24oRXJyb3I9KSl9IExvYWRlclxuICovXG5cblxudmFyIEltYWdlQ2FudmFzID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoSW1hZ2VCYXNlKSB7XG4gIGZ1bmN0aW9uIEltYWdlQ2FudmFzKGV4dGVudCwgcmVzb2x1dGlvbiwgcGl4ZWxSYXRpbywgY2FudmFzLCBvcHRfbG9hZGVyKSB7XG5cbiAgICB2YXIgc3RhdGUgPSBvcHRfbG9hZGVyICE9PSB1bmRlZmluZWQgPyBJbWFnZVN0YXRlLklETEUgOiBJbWFnZVN0YXRlLkxPQURFRDtcblxuICAgIEltYWdlQmFzZS5jYWxsKHRoaXMsIGV4dGVudCwgcmVzb2x1dGlvbiwgcGl4ZWxSYXRpbywgc3RhdGUpO1xuXG4gICAgLyoqXG4gICAgICogT3B0aW9uYWwgY2FudmFzIGxvYWRlciBmdW5jdGlvbi5cbiAgICAgKiBAdHlwZSB7P0xvYWRlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubG9hZGVyXyA9IG9wdF9sb2FkZXIgIT09IHVuZGVmaW5lZCA/IG9wdF9sb2FkZXIgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5jYW52YXNfID0gY2FudmFzO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7RXJyb3J9XG4gICAgICovXG4gICAgdGhpcy5lcnJvcl8gPSBudWxsO1xuXG4gIH1cblxuICBpZiAoIEltYWdlQmFzZSApIEltYWdlQ2FudmFzLl9fcHJvdG9fXyA9IEltYWdlQmFzZTtcbiAgSW1hZ2VDYW52YXMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSW1hZ2VCYXNlICYmIEltYWdlQmFzZS5wcm90b3R5cGUgKTtcbiAgSW1hZ2VDYW52YXMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW1hZ2VDYW52YXM7XG5cbiAgLyoqXG4gICAqIEdldCBhbnkgZXJyb3IgYXNzb2NpYXRlZCB3aXRoIGFzeW5jaHJvbm91cyByZW5kZXJpbmcuXG4gICAqIEByZXR1cm4ge0Vycm9yfSBBbnkgZXJyb3IgdGhhdCBvY2N1cnJlZCBkdXJpbmcgcmVuZGVyaW5nLlxuICAgKi9cbiAgSW1hZ2VDYW52YXMucHJvdG90eXBlLmdldEVycm9yID0gZnVuY3Rpb24gZ2V0RXJyb3IgKCkge1xuICAgIHJldHVybiB0aGlzLmVycm9yXztcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGFzeW5jIGRyYXdpbmcgY29tcGxldGUuXG4gICAqIEBwYXJhbSB7RXJyb3I9fSBlcnIgQW55IGVycm9yIGR1cmluZyBkcmF3aW5nLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgSW1hZ2VDYW52YXMucHJvdG90eXBlLmhhbmRsZUxvYWRfID0gZnVuY3Rpb24gaGFuZGxlTG9hZF8gKGVycikge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHRoaXMuZXJyb3JfID0gZXJyO1xuICAgICAgdGhpcy5zdGF0ZSA9IEltYWdlU3RhdGUuRVJST1I7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBJbWFnZVN0YXRlLkxPQURFRDtcbiAgICB9XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBJbWFnZUNhbnZhcy5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIGxvYWQgKCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09IEltYWdlU3RhdGUuSURMRSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IEltYWdlU3RhdGUuTE9BRElORztcbiAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgICAgdGhpcy5sb2FkZXJfKHRoaXMuaGFuZGxlTG9hZF8uYmluZCh0aGlzKSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH0gQ2FudmFzIGVsZW1lbnQuXG4gICAqL1xuICBJbWFnZUNhbnZhcy5wcm90b3R5cGUuZ2V0SW1hZ2UgPSBmdW5jdGlvbiBnZXRJbWFnZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzXztcbiAgfTtcblxuICByZXR1cm4gSW1hZ2VDYW52YXM7XG59KEltYWdlQmFzZSkpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IEltYWdlQ2FudmFzO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbWFnZUNhbnZhcy5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvSW1hZ2VTdGF0ZVxuICovXG5cbi8qKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBJRExFOiAwLFxuICBMT0FESU5HOiAxLFxuICBMT0FERUQ6IDIsXG4gIEVSUk9SOiAzXG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbWFnZVN0YXRlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9JbWFnZVRpbGVcbiAqL1xuaW1wb3J0IFRpbGUgZnJvbSAnLi9UaWxlLmpzJztcbmltcG9ydCBUaWxlU3RhdGUgZnJvbSAnLi9UaWxlU3RhdGUuanMnO1xuaW1wb3J0IHtjcmVhdGVDYW52YXNDb250ZXh0MkR9IGZyb20gJy4vZG9tLmpzJztcbmltcG9ydCB7bGlzdGVuT25jZSwgdW5saXN0ZW5CeUtleX0gZnJvbSAnLi9ldmVudHMuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuXG5cbnZhciBJbWFnZVRpbGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChUaWxlKSB7XG4gIGZ1bmN0aW9uIEltYWdlVGlsZSh0aWxlQ29vcmQsIHN0YXRlLCBzcmMsIGNyb3NzT3JpZ2luLCB0aWxlTG9hZEZ1bmN0aW9uLCBvcHRfb3B0aW9ucykge1xuXG4gICAgVGlsZS5jYWxsKHRoaXMsIHRpbGVDb29yZCwgc3RhdGUsIG9wdF9vcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9zdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5jcm9zc09yaWdpbl8gPSBjcm9zc09yaWdpbjtcblxuICAgIC8qKlxuICAgICAqIEltYWdlIFVSSVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuc3JjXyA9IHNyYztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5pbWFnZV8gPSBuZXcgSW1hZ2UoKTtcbiAgICBpZiAoY3Jvc3NPcmlnaW4gIT09IG51bGwpIHtcbiAgICAgIHRoaXMuaW1hZ2VfLmNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi9ldmVudHMuanNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlTGlzdGVuZXJLZXlzXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL1RpbGUuanNcIikuTG9hZEZ1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMudGlsZUxvYWRGdW5jdGlvbl8gPSB0aWxlTG9hZEZ1bmN0aW9uO1xuXG4gIH1cblxuICBpZiAoIFRpbGUgKSBJbWFnZVRpbGUuX19wcm90b19fID0gVGlsZTtcbiAgSW1hZ2VUaWxlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRpbGUgJiYgVGlsZS5wcm90b3R5cGUgKTtcbiAgSW1hZ2VUaWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEltYWdlVGlsZTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIEltYWdlVGlsZS5wcm90b3R5cGUuZGlzcG9zZUludGVybmFsID0gZnVuY3Rpb24gZGlzcG9zZUludGVybmFsICgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PSBUaWxlU3RhdGUuTE9BRElORykge1xuICAgICAgdGhpcy51bmxpc3RlbkltYWdlXygpO1xuICAgICAgdGhpcy5pbWFnZV8gPSBnZXRCbGFua0ltYWdlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmludGVyaW1UaWxlKSB7XG4gICAgICB0aGlzLmludGVyaW1UaWxlLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5BQk9SVDtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICBUaWxlLnByb3RvdHlwZS5kaXNwb3NlSW50ZXJuYWwuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBIVE1MIGltYWdlIGVsZW1lbnQgZm9yIHRoaXMgdGlsZSAobWF5IGJlIGEgQ2FudmFzLCBJbWFnZSwgb3IgVmlkZW8pLlxuICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudHxIVE1MSW1hZ2VFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR9IEltYWdlLlxuICAgKiBAYXBpXG4gICAqL1xuICBJbWFnZVRpbGUucHJvdG90eXBlLmdldEltYWdlID0gZnVuY3Rpb24gZ2V0SW1hZ2UgKCkge1xuICAgIHJldHVybiB0aGlzLmltYWdlXztcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIEltYWdlVGlsZS5wcm90b3R5cGUuZ2V0S2V5ID0gZnVuY3Rpb24gZ2V0S2V5ICgpIHtcbiAgICByZXR1cm4gdGhpcy5zcmNfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUcmFja3MgbG9hZGluZyBvciByZWFkIGVycm9ycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEltYWdlVGlsZS5wcm90b3R5cGUuaGFuZGxlSW1hZ2VFcnJvcl8gPSBmdW5jdGlvbiBoYW5kbGVJbWFnZUVycm9yXyAoKSB7XG4gICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5FUlJPUjtcbiAgICB0aGlzLnVubGlzdGVuSW1hZ2VfKCk7XG4gICAgdGhpcy5pbWFnZV8gPSBnZXRCbGFua0ltYWdlKCk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRyYWNrcyBzdWNjZXNzZnVsIGltYWdlIGxvYWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBJbWFnZVRpbGUucHJvdG90eXBlLmhhbmRsZUltYWdlTG9hZF8gPSBmdW5jdGlvbiBoYW5kbGVJbWFnZUxvYWRfICgpIHtcbiAgICB2YXIgaW1hZ2UgPSAvKiogQHR5cGUge0hUTUxJbWFnZUVsZW1lbnR9ICovICh0aGlzLmltYWdlXyk7XG4gICAgaWYgKGltYWdlLm5hdHVyYWxXaWR0aCAmJiBpbWFnZS5uYXR1cmFsSGVpZ2h0KSB7XG4gICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkxPQURFRDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5FTVBUWTtcbiAgICB9XG4gICAgdGhpcy51bmxpc3RlbkltYWdlXygpO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKiBAYXBpXG4gICAqL1xuICBJbWFnZVRpbGUucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiBsb2FkICgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PSBUaWxlU3RhdGUuRVJST1IpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuSURMRTtcbiAgICAgIHRoaXMuaW1hZ2VfID0gbmV3IEltYWdlKCk7XG4gICAgICBpZiAodGhpcy5jcm9zc09yaWdpbl8gIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5pbWFnZV8uY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luXztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuc3RhdGUgPT0gVGlsZVN0YXRlLklETEUpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuTE9BRElORztcbiAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgICAgdGhpcy5pbWFnZUxpc3RlbmVyS2V5c18gPSBbXG4gICAgICAgIGxpc3Rlbk9uY2UodGhpcy5pbWFnZV8sIEV2ZW50VHlwZS5FUlJPUixcbiAgICAgICAgICB0aGlzLmhhbmRsZUltYWdlRXJyb3JfLCB0aGlzKSxcbiAgICAgICAgbGlzdGVuT25jZSh0aGlzLmltYWdlXywgRXZlbnRUeXBlLkxPQUQsXG4gICAgICAgICAgdGhpcy5oYW5kbGVJbWFnZUxvYWRfLCB0aGlzKVxuICAgICAgXTtcbiAgICAgIHRoaXMudGlsZUxvYWRGdW5jdGlvbl8odGhpcywgdGhpcy5zcmNfKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIERpc2NhcmRzIGV2ZW50IGhhbmRsZXJzIHdoaWNoIGxpc3RlbiBmb3IgbG9hZCBjb21wbGV0aW9uIG9yIGVycm9ycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEltYWdlVGlsZS5wcm90b3R5cGUudW5saXN0ZW5JbWFnZV8gPSBmdW5jdGlvbiB1bmxpc3RlbkltYWdlXyAoKSB7XG4gICAgdGhpcy5pbWFnZUxpc3RlbmVyS2V5c18uZm9yRWFjaCh1bmxpc3RlbkJ5S2V5KTtcbiAgICB0aGlzLmltYWdlTGlzdGVuZXJLZXlzXyA9IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIEltYWdlVGlsZTtcbn0oVGlsZSkpO1xuXG5cbi8qKlxuICogR2V0IGEgMS1waXhlbCBibGFuayBpbWFnZS5cbiAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBCbGFuayBpbWFnZS5cbiAqL1xuZnVuY3Rpb24gZ2V0QmxhbmtJbWFnZSgpIHtcbiAgdmFyIGN0eCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQyRCgxLCAxKTtcbiAgY3R4LmZpbGxTdHlsZSA9ICdyZ2JhKDAsMCwwLDApJztcbiAgY3R4LmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xuICByZXR1cm4gY3R4LmNhbnZhcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgSW1hZ2VUaWxlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbWFnZVRpbGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL0tpbmV0aWNcbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEltcGxlbWVudGF0aW9uIG9mIGluZXJ0aWFsIGRlY2VsZXJhdGlvbiBmb3IgbWFwIG1vdmVtZW50LlxuICpcbiAqIEBhcGlcbiAqL1xudmFyIEtpbmV0aWMgPSBmdW5jdGlvbiBLaW5ldGljKGRlY2F5LCBtaW5WZWxvY2l0eSwgZGVsYXkpIHtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMuZGVjYXlfID0gZGVjYXk7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLm1pblZlbG9jaXR5XyA9IG1pblZlbG9jaXR5O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5kZWxheV8gPSBkZWxheTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAqL1xuICB0aGlzLnBvaW50c18gPSBbXTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMuYW5nbGVfID0gMDtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMuaW5pdGlhbFZlbG9jaXR5XyA9IDA7XG59O1xuXG4vKipcbiAqIEZJWE1FIGVtcHR5IGRlc2NyaXB0aW9uIGZvciBqc2RvY1xuICovXG5LaW5ldGljLnByb3RvdHlwZS5iZWdpbiA9IGZ1bmN0aW9uIGJlZ2luICgpIHtcbiAgdGhpcy5wb2ludHNfLmxlbmd0aCA9IDA7XG4gIHRoaXMuYW5nbGVfID0gMDtcbiAgdGhpcy5pbml0aWFsVmVsb2NpdHlfID0gMDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKi9cbktpbmV0aWMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoeCwgeSkge1xuICB0aGlzLnBvaW50c18ucHVzaCh4LCB5LCBEYXRlLm5vdygpKTtcbn07XG5cbi8qKlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB3ZSBzaG91bGQgZG8ga2luZXRpYyBhbmltYXRpb24uXG4gKi9cbktpbmV0aWMucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIGVuZCAoKSB7XG4gIGlmICh0aGlzLnBvaW50c18ubGVuZ3RoIDwgNikge1xuICAgIC8vIGF0IGxlYXN0IDIgcG9pbnRzIGFyZSByZXF1aXJlZCAoaS5lLiB0aGVyZSBtdXN0IGJlIGF0IGxlYXN0IDYgZWxlbWVudHNcbiAgICAvLyBpbiB0aGUgYXJyYXkpXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBkZWxheSA9IERhdGUubm93KCkgLSB0aGlzLmRlbGF5XztcbiAgdmFyIGxhc3RJbmRleCA9IHRoaXMucG9pbnRzXy5sZW5ndGggLSAzO1xuICBpZiAodGhpcy5wb2ludHNfW2xhc3RJbmRleCArIDJdIDwgZGVsYXkpIHtcbiAgICAvLyB0aGUgbGFzdCB0cmFja2VkIHBvaW50IGlzIHRvbyBvbGQsIHdoaWNoIG1lYW5zIHRoYXQgdGhlIHVzZXIgc3RvcHBlZFxuICAgIC8vIHBhbm5pbmcgYmVmb3JlIHJlbGVhc2luZyB0aGUgbWFwXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gZ2V0IHRoZSBmaXJzdCBwb2ludCB3aGljaCBzdGlsbCBmYWxscyBpbnRvIHRoZSBkZWxheSB0aW1lXG4gIHZhciBmaXJzdEluZGV4ID0gbGFzdEluZGV4IC0gMztcbiAgd2hpbGUgKGZpcnN0SW5kZXggPiAwICYmIHRoaXMucG9pbnRzX1tmaXJzdEluZGV4ICsgMl0gPiBkZWxheSkge1xuICAgIGZpcnN0SW5kZXggLT0gMztcbiAgfVxuXG4gIHZhciBkdXJhdGlvbiA9IHRoaXMucG9pbnRzX1tsYXN0SW5kZXggKyAyXSAtIHRoaXMucG9pbnRzX1tmaXJzdEluZGV4ICsgMl07XG4gIC8vIHdlIGRvbid0IHdhbnQgYSBkdXJhdGlvbiBvZiAwIChkaXZpZGUgYnkgemVybylcbiAgLy8gd2UgYWxzbyBtYWtlIHN1cmUgdGhlIHVzZXIgcGFubmVkIGZvciBhIGR1cmF0aW9uIG9mIGF0IGxlYXN0IG9uZSBmcmFtZVxuICAvLyAoMS82MHMpIHRvIGNvbXB1dGUgc2FuZSBkaXNwbGFjZW1lbnQgdmFsdWVzXG4gIGlmIChkdXJhdGlvbiA8IDEwMDAgLyA2MCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBkeCA9IHRoaXMucG9pbnRzX1tsYXN0SW5kZXhdIC0gdGhpcy5wb2ludHNfW2ZpcnN0SW5kZXhdO1xuICB2YXIgZHkgPSB0aGlzLnBvaW50c19bbGFzdEluZGV4ICsgMV0gLSB0aGlzLnBvaW50c19bZmlyc3RJbmRleCArIDFdO1xuICB0aGlzLmFuZ2xlXyA9IE1hdGguYXRhbjIoZHksIGR4KTtcbiAgdGhpcy5pbml0aWFsVmVsb2NpdHlfID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KSAvIGR1cmF0aW9uO1xuICByZXR1cm4gdGhpcy5pbml0aWFsVmVsb2NpdHlfID4gdGhpcy5taW5WZWxvY2l0eV87XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge251bWJlcn0gVG90YWwgZGlzdGFuY2UgdHJhdmVsbGVkIChwaXhlbHMpLlxuICovXG5LaW5ldGljLnByb3RvdHlwZS5nZXREaXN0YW5jZSA9IGZ1bmN0aW9uIGdldERpc3RhbmNlICgpIHtcbiAgcmV0dXJuICh0aGlzLm1pblZlbG9jaXR5XyAtIHRoaXMuaW5pdGlhbFZlbG9jaXR5XykgLyB0aGlzLmRlY2F5Xztcbn07XG5cbi8qKlxuICogQHJldHVybiB7bnVtYmVyfSBBbmdsZSBvZiB0aGUga2luZXRpYyBwYW5uaW5nIGFuaW1hdGlvbiAocmFkaWFucykuXG4gKi9cbktpbmV0aWMucHJvdG90eXBlLmdldEFuZ2xlID0gZnVuY3Rpb24gZ2V0QW5nbGUgKCkge1xuICByZXR1cm4gdGhpcy5hbmdsZV87XG59O1xuXG5leHBvcnQgZGVmYXVsdCBLaW5ldGljO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1LaW5ldGljLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9MYXllclR5cGVcbiAqL1xuXG4vKipcbiAqIEEgbGF5ZXIgdHlwZSB1c2VkIHdoZW4gY3JlYXRpbmcgbGF5ZXIgcmVuZGVyZXJzLlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBJTUFHRTogJ0lNQUdFJyxcbiAgVElMRTogJ1RJTEUnLFxuICBWRUNUT1JfVElMRTogJ1ZFQ1RPUl9USUxFJyxcbiAgVkVDVE9SOiAnVkVDVE9SJ1xufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGF5ZXJUeXBlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9NYXBcbiAqL1xuaW1wb3J0IFBsdWdnYWJsZU1hcCBmcm9tICcuL1BsdWdnYWJsZU1hcC5qcyc7XG5pbXBvcnQge2RlZmF1bHRzIGFzIGRlZmF1bHRDb250cm9sc30gZnJvbSAnLi9jb250cm9sL3V0aWwuanMnO1xuaW1wb3J0IHtkZWZhdWx0cyBhcyBkZWZhdWx0SW50ZXJhY3Rpb25zfSBmcm9tICcuL2ludGVyYWN0aW9uLmpzJztcbmltcG9ydCB7YXNzaWdufSBmcm9tICcuL29iai5qcyc7XG5pbXBvcnQgQ2FudmFzSW1hZ2VMYXllclJlbmRlcmVyIGZyb20gJy4vcmVuZGVyZXIvY2FudmFzL0ltYWdlTGF5ZXIuanMnO1xuaW1wb3J0IENhbnZhc01hcFJlbmRlcmVyIGZyb20gJy4vcmVuZGVyZXIvY2FudmFzL01hcC5qcyc7XG5pbXBvcnQgQ2FudmFzVGlsZUxheWVyUmVuZGVyZXIgZnJvbSAnLi9yZW5kZXJlci9jYW52YXMvVGlsZUxheWVyLmpzJztcbmltcG9ydCBDYW52YXNWZWN0b3JMYXllclJlbmRlcmVyIGZyb20gJy4vcmVuZGVyZXIvY2FudmFzL1ZlY3RvckxheWVyLmpzJztcbmltcG9ydCBDYW52YXNWZWN0b3JUaWxlTGF5ZXJSZW5kZXJlciBmcm9tICcuL3JlbmRlcmVyL2NhbnZhcy9WZWN0b3JUaWxlTGF5ZXIuanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFRoZSBtYXAgaXMgdGhlIGNvcmUgY29tcG9uZW50IG9mIE9wZW5MYXllcnMuIEZvciBhIG1hcCB0byByZW5kZXIsIGEgdmlldyxcbiAqIG9uZSBvciBtb3JlIGxheWVycywgYW5kIGEgdGFyZ2V0IGNvbnRhaW5lciBhcmUgbmVlZGVkOlxuICpcbiAqICAgICBpbXBvcnQgTWFwIGZyb20gJ29sL01hcCc7XG4gKiAgICAgaW1wb3J0IFZpZXcgZnJvbSAnb2wvVmlldyc7XG4gKiAgICAgaW1wb3J0IFRpbGVMYXllciBmcm9tICdvbC9sYXllci9UaWxlJztcbiAqICAgICBpbXBvcnQgT1NNIGZyb20gJ29sL3NvdXJjZS9PU00nO1xuICpcbiAqICAgICB2YXIgbWFwID0gbmV3IE1hcCh7XG4gKiAgICAgICB2aWV3OiBuZXcgVmlldyh7XG4gKiAgICAgICAgIGNlbnRlcjogWzAsIDBdLFxuICogICAgICAgICB6b29tOiAxXG4gKiAgICAgICB9KSxcbiAqICAgICAgIGxheWVyczogW1xuICogICAgICAgICBuZXcgVGlsZUxheWVyKHtcbiAqICAgICAgICAgICBzb3VyY2U6IG5ldyBPU00oKVxuICogICAgICAgICB9KVxuICogICAgICAgXSxcbiAqICAgICAgIHRhcmdldDogJ21hcCdcbiAqICAgICB9KTtcbiAqXG4gKiBUaGUgYWJvdmUgc25pcHBldCBjcmVhdGVzIGEgbWFwIHVzaW5nIGEge0BsaW5rIG1vZHVsZTpvbC9sYXllci9UaWxlfSB0b1xuICogZGlzcGxheSB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9PU01+T1NNfSBPU00gZGF0YSBhbmQgcmVuZGVyIGl0IHRvIGEgRE9NXG4gKiBlbGVtZW50IHdpdGggdGhlIGlkIGBtYXBgLlxuICpcbiAqIFRoZSBjb25zdHJ1Y3RvciBwbGFjZXMgYSB2aWV3cG9ydCBjb250YWluZXIgKHdpdGggQ1NTIGNsYXNzIG5hbWVcbiAqIGBvbC12aWV3cG9ydGApIGluIHRoZSB0YXJnZXQgZWxlbWVudCAoc2VlIGBnZXRWaWV3cG9ydCgpYCksIGFuZCB0aGVuIHR3b1xuICogZnVydGhlciBlbGVtZW50cyB3aXRoaW4gdGhlIHZpZXdwb3J0OiBvbmUgd2l0aCBDU1MgY2xhc3MgbmFtZVxuICogYG9sLW92ZXJsYXljb250YWluZXItc3RvcGV2ZW50YCBmb3IgY29udHJvbHMgYW5kIHNvbWUgb3ZlcmxheXMsIGFuZCBvbmUgd2l0aFxuICogQ1NTIGNsYXNzIG5hbWUgYG9sLW92ZXJsYXljb250YWluZXJgIGZvciBvdGhlciBvdmVybGF5cyAoc2VlIHRoZSBgc3RvcEV2ZW50YFxuICogb3B0aW9uIG9mIHtAbGluayBtb2R1bGU6b2wvT3ZlcmxheX5PdmVybGF5fSBmb3IgdGhlIGRpZmZlcmVuY2UpLiBUaGUgbWFwXG4gKiBpdHNlbGYgaXMgcGxhY2VkIGluIGEgZnVydGhlciBlbGVtZW50IHdpdGhpbiB0aGUgdmlld3BvcnQuXG4gKlxuICogTGF5ZXJzIGFyZSBzdG9yZWQgYXMgYSB7QGxpbmsgbW9kdWxlOm9sL0NvbGxlY3Rpb25+Q29sbGVjdGlvbn0gaW5cbiAqIGxheWVyR3JvdXBzLiBBIHRvcC1sZXZlbCBncm91cCBpcyBwcm92aWRlZCBieSB0aGUgbGlicmFyeS4gVGhpcyBpcyB3aGF0IGlzXG4gKiBhY2Nlc3NlZCBieSBgZ2V0TGF5ZXJHcm91cGAgYW5kIGBzZXRMYXllckdyb3VwYC4gTGF5ZXJzIGVudGVyZWQgaW4gdGhlXG4gKiBvcHRpb25zIGFyZSBhZGRlZCB0byB0aGlzIGdyb3VwLCBhbmQgYGFkZExheWVyYCBhbmQgYHJlbW92ZUxheWVyYCBjaGFuZ2UgdGhlXG4gKiBsYXllciBjb2xsZWN0aW9uIGluIHRoZSBncm91cC4gYGdldExheWVyc2AgaXMgYSBjb252ZW5pZW5jZSBmdW5jdGlvbiBmb3JcbiAqIGBnZXRMYXllckdyb3VwKCkuZ2V0TGF5ZXJzKClgLiBOb3RlIHRoYXQge0BsaW5rIG1vZHVsZTpvbC9sYXllci9Hcm91cH5Hcm91cH1cbiAqIGlzIGEgc3ViY2xhc3Mgb2Yge0BsaW5rIG1vZHVsZTpvbC9sYXllci9CYXNlfSwgc28gbGF5ZXJzIGVudGVyZWQgaW4gdGhlXG4gKiBvcHRpb25zIG9yIGFkZGVkIHdpdGggYGFkZExheWVyYCBjYW4gYmUgZ3JvdXBzLCB3aGljaCBjYW4gY29udGFpbiBmdXJ0aGVyXG4gKiBncm91cHMsIGFuZCBzbyBvbi5cbiAqXG4gKiBAZmlyZXMgaW1wb3J0KFwiLi9NYXBCcm93c2VyRXZlbnQuanNcIikuTWFwQnJvd3NlckV2ZW50XG4gKiBAZmlyZXMgaW1wb3J0KFwiLi9NYXBFdmVudC5qc1wiKS5NYXBFdmVudFxuICogQGZpcmVzIG1vZHVsZTpvbC9yZW5kZXIvRXZlbnR+UmVuZGVyRXZlbnQjcG9zdGNvbXBvc2VcbiAqIEBmaXJlcyBtb2R1bGU6b2wvcmVuZGVyL0V2ZW50flJlbmRlckV2ZW50I3ByZWNvbXBvc2VcbiAqIEBhcGlcbiAqL1xudmFyIE1hcCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFBsdWdnYWJsZU1hcCkge1xuICBmdW5jdGlvbiBNYXAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBhc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgIGlmICghb3B0aW9ucy5jb250cm9scykge1xuICAgICAgb3B0aW9ucy5jb250cm9scyA9IGRlZmF1bHRDb250cm9scygpO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMuaW50ZXJhY3Rpb25zKSB7XG4gICAgICBvcHRpb25zLmludGVyYWN0aW9ucyA9IGRlZmF1bHRJbnRlcmFjdGlvbnMoKTtcbiAgICB9XG5cbiAgICBQbHVnZ2FibGVNYXAuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmICggUGx1Z2dhYmxlTWFwICkgTWFwLl9fcHJvdG9fXyA9IFBsdWdnYWJsZU1hcDtcbiAgTWFwLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBsdWdnYWJsZU1hcCAmJiBQbHVnZ2FibGVNYXAucHJvdG90eXBlICk7XG4gIE1hcC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNYXA7XG5cbiAgTWFwLnByb3RvdHlwZS5jcmVhdGVSZW5kZXJlciA9IGZ1bmN0aW9uIGNyZWF0ZVJlbmRlcmVyICgpIHtcbiAgICB2YXIgcmVuZGVyZXIgPSBuZXcgQ2FudmFzTWFwUmVuZGVyZXIodGhpcyk7XG4gICAgcmVuZGVyZXIucmVnaXN0ZXJMYXllclJlbmRlcmVycyhbXG4gICAgICBDYW52YXNJbWFnZUxheWVyUmVuZGVyZXIsXG4gICAgICBDYW52YXNUaWxlTGF5ZXJSZW5kZXJlcixcbiAgICAgIENhbnZhc1ZlY3RvckxheWVyUmVuZGVyZXIsXG4gICAgICBDYW52YXNWZWN0b3JUaWxlTGF5ZXJSZW5kZXJlclxuICAgIF0pO1xuICAgIHJldHVybiByZW5kZXJlcjtcbiAgfTtcblxuICByZXR1cm4gTWFwO1xufShQbHVnZ2FibGVNYXApKTtcblxuXG5leHBvcnQgZGVmYXVsdCBNYXA7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1hcC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvTWFwQnJvd3NlckV2ZW50XG4gKi9cbmltcG9ydCBNYXBFdmVudCBmcm9tICcuL01hcEV2ZW50LmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBFdmVudHMgZW1pdHRlZCBhcyBtYXAgYnJvd3NlciBldmVudHMgYXJlIGluc3RhbmNlcyBvZiB0aGlzIHR5cGUuXG4gKiBTZWUge0BsaW5rIG1vZHVsZTpvbC9QbHVnZ2FibGVNYXB+UGx1Z2dhYmxlTWFwfSBmb3Igd2hpY2ggZXZlbnRzIHRyaWdnZXIgYSBtYXAgYnJvd3NlciBldmVudC5cbiAqL1xudmFyIE1hcEJyb3dzZXJFdmVudCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKE1hcEV2ZW50KSB7XG4gIGZ1bmN0aW9uIE1hcEJyb3dzZXJFdmVudCh0eXBlLCBtYXAsIGJyb3dzZXJFdmVudCwgb3B0X2RyYWdnaW5nLCBvcHRfZnJhbWVTdGF0ZSkge1xuXG4gICAgTWFwRXZlbnQuY2FsbCh0aGlzLCB0eXBlLCBtYXAsIG9wdF9mcmFtZVN0YXRlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcmlnaW5hbCBicm93c2VyIGV2ZW50LlxuICAgICAqIEBjb25zdFxuICAgICAqIEB0eXBlIHtFdmVudH1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gYnJvd3NlckV2ZW50O1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1hcCBwaXhlbCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQgY29ycmVzcG9uZGluZyB0byB0aGUgb3JpZ2luYWwgYnJvd3NlciBldmVudC5cbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9waXhlbC5qc1wiKS5QaXhlbH1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5waXhlbCA9IG1hcC5nZXRFdmVudFBpeGVsKGJyb3dzZXJFdmVudCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29vcmRpbmF0ZSBpbiB2aWV3IHByb2plY3Rpb24gY29ycmVzcG9uZGluZyB0byB0aGUgb3JpZ2luYWwgYnJvd3NlciBldmVudC5cbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMuY29vcmRpbmF0ZSA9IG1hcC5nZXRDb29yZGluYXRlRnJvbVBpeGVsKHRoaXMucGl4ZWwpO1xuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIHRoZSBtYXAgaXMgY3VycmVudGx5IGJlaW5nIGRyYWdnZWQuIE9ubHkgc2V0IGZvclxuICAgICAqIGBQT0lOVEVSRFJBR2AgYW5kIGBQT0lOVEVSTU9WRWAgZXZlbnRzLiBEZWZhdWx0IGlzIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5kcmFnZ2luZyA9IG9wdF9kcmFnZ2luZyAhPT0gdW5kZWZpbmVkID8gb3B0X2RyYWdnaW5nIDogZmFsc2U7XG5cbiAgfVxuXG4gIGlmICggTWFwRXZlbnQgKSBNYXBCcm93c2VyRXZlbnQuX19wcm90b19fID0gTWFwRXZlbnQ7XG4gIE1hcEJyb3dzZXJFdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNYXBFdmVudCAmJiBNYXBFdmVudC5wcm90b3R5cGUgKTtcbiAgTWFwQnJvd3NlckV2ZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1hcEJyb3dzZXJFdmVudDtcblxuICAvKipcbiAgICogUHJldmVudHMgdGhlIGRlZmF1bHQgYnJvd3NlciBhY3Rpb24uXG4gICAqIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvZXZlbnQucHJldmVudERlZmF1bHQuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBNYXBCcm93c2VyRXZlbnQucHJvdG90eXBlLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gcHJldmVudERlZmF1bHQgKCkge1xuICAgIE1hcEV2ZW50LnByb3RvdHlwZS5wcmV2ZW50RGVmYXVsdC5jYWxsKHRoaXMpO1xuICAgIHRoaXMub3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcmV2ZW50cyBmdXJ0aGVyIHByb3BhZ2F0aW9uIG9mIHRoZSBjdXJyZW50IGV2ZW50LlxuICAgKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL2V2ZW50LnN0b3BQcm9wYWdhdGlvbi5cbiAgICogQG92ZXJyaWRlXG4gICAqIEBhcGlcbiAgICovXG4gIE1hcEJyb3dzZXJFdmVudC5wcm90b3R5cGUuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uICgpIHtcbiAgICBNYXBFdmVudC5wcm90b3R5cGUuc3RvcFByb3BhZ2F0aW9uLmNhbGwodGhpcyk7XG4gICAgdGhpcy5vcmlnaW5hbEV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9O1xuXG4gIHJldHVybiBNYXBCcm93c2VyRXZlbnQ7XG59KE1hcEV2ZW50KSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgTWFwQnJvd3NlckV2ZW50O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXBCcm93c2VyRXZlbnQuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL01hcEJyb3dzZXJFdmVudEhhbmRsZXJcbiAqL1xuaW1wb3J0IHtERVZJQ0VfUElYRUxfUkFUSU99IGZyb20gJy4vaGFzLmpzJztcbmltcG9ydCBNYXBCcm93c2VyRXZlbnRUeXBlIGZyb20gJy4vTWFwQnJvd3NlckV2ZW50VHlwZS5qcyc7XG5pbXBvcnQgTWFwQnJvd3NlclBvaW50ZXJFdmVudCBmcm9tICcuL01hcEJyb3dzZXJQb2ludGVyRXZlbnQuanMnO1xuaW1wb3J0IHtsaXN0ZW4sIHVubGlzdGVuQnlLZXl9IGZyb20gJy4vZXZlbnRzLmpzJztcbmltcG9ydCBFdmVudFRhcmdldCBmcm9tICcuL2V2ZW50cy9UYXJnZXQuanMnO1xuaW1wb3J0IFBvaW50ZXJFdmVudFR5cGUgZnJvbSAnLi9wb2ludGVyL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgUG9pbnRlckV2ZW50SGFuZGxlciBmcm9tICcuL3BvaW50ZXIvUG9pbnRlckV2ZW50SGFuZGxlci5qcyc7XG5cbnZhciBNYXBCcm93c2VyRXZlbnRIYW5kbGVyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoRXZlbnRUYXJnZXQpIHtcbiAgZnVuY3Rpb24gTWFwQnJvd3NlckV2ZW50SGFuZGxlcihtYXAsIG1vdmVUb2xlcmFuY2UpIHtcblxuICAgIEV2ZW50VGFyZ2V0LmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBlbGVtZW50IHRoYXQgd2Ugd2lsbCBsaXN0ZW4gdG8gdGhlIHJlYWwgZXZlbnRzIG9uLlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL1BsdWdnYWJsZU1hcC5qc1wiKS5kZWZhdWx0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5tYXBfID0gbWFwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2FueX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuY2xpY2tUaW1lb3V0SWRfO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmRyYWdnaW5nXyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgeyFBcnJheTxpbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXk+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5kcmFnTGlzdGVuZXJLZXlzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubW92ZVRvbGVyYW5jZV8gPSBtb3ZlVG9sZXJhbmNlID9cbiAgICAgIG1vdmVUb2xlcmFuY2UgKiBERVZJQ0VfUElYRUxfUkFUSU8gOiBERVZJQ0VfUElYRUxfUkFUSU87XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbW9zdCByZWNlbnQgXCJkb3duXCIgdHlwZSBldmVudCAob3IgbnVsbCBpZiBub25lIGhhdmUgb2NjdXJyZWQpLlxuICAgICAqIFNldCBvbiBwb2ludGVyZG93bi5cbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9wb2ludGVyL1BvaW50ZXJFdmVudC5qc1wiKS5kZWZhdWx0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5kb3duXyA9IG51bGw7XG5cbiAgICB2YXIgZWxlbWVudCA9IHRoaXMubWFwXy5nZXRWaWV3cG9ydCgpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuYWN0aXZlUG9pbnRlcnNfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHshT2JqZWN0PG51bWJlciwgYm9vbGVhbj59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnRyYWNrZWRUb3VjaGVzXyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgaGFuZGxlciB3aGljaCBnZW5lcmF0ZXMgcG9pbnRlciBldmVudHMgZm9yXG4gICAgICogdGhlIHZpZXdwb3J0IGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7UG9pbnRlckV2ZW50SGFuZGxlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucG9pbnRlckV2ZW50SGFuZGxlcl8gPSBuZXcgUG9pbnRlckV2ZW50SGFuZGxlcihlbGVtZW50KTtcblxuICAgIC8qKlxuICAgICAqIEV2ZW50IGhhbmRsZXIgd2hpY2ggZ2VuZXJhdGVzIHBvaW50ZXIgZXZlbnRzIGZvclxuICAgICAqIHRoZSBkb2N1bWVudCAodXNlZCB3aGVuIGRyYWdnaW5nKS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtQb2ludGVyRXZlbnRIYW5kbGVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5kb2N1bWVudFBvaW50ZXJFdmVudEhhbmRsZXJfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi9ldmVudHMuanNcIikuRXZlbnRzS2V5fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5wb2ludGVyZG93bkxpc3RlbmVyS2V5XyA9IGxpc3Rlbih0aGlzLnBvaW50ZXJFdmVudEhhbmRsZXJfLFxuICAgICAgUG9pbnRlckV2ZW50VHlwZS5QT0lOVEVSRE9XTixcbiAgICAgIHRoaXMuaGFuZGxlUG9pbnRlckRvd25fLCB0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi9ldmVudHMuanNcIikuRXZlbnRzS2V5fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5yZWxheWVkTGlzdGVuZXJLZXlfID0gbGlzdGVuKHRoaXMucG9pbnRlckV2ZW50SGFuZGxlcl8sXG4gICAgICBQb2ludGVyRXZlbnRUeXBlLlBPSU5URVJNT1ZFLFxuICAgICAgdGhpcy5yZWxheUV2ZW50XywgdGhpcyk7XG5cbiAgfVxuXG4gIGlmICggRXZlbnRUYXJnZXQgKSBNYXBCcm93c2VyRXZlbnRIYW5kbGVyLl9fcHJvdG9fXyA9IEV2ZW50VGFyZ2V0O1xuICBNYXBCcm93c2VyRXZlbnRIYW5kbGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEV2ZW50VGFyZ2V0ICYmIEV2ZW50VGFyZ2V0LnByb3RvdHlwZSApO1xuICBNYXBCcm93c2VyRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1hcEJyb3dzZXJFdmVudEhhbmRsZXI7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wb2ludGVyL1BvaW50ZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBwb2ludGVyRXZlbnQgUG9pbnRlclxuICAgKiBldmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIE1hcEJyb3dzZXJFdmVudEhhbmRsZXIucHJvdG90eXBlLmVtdWxhdGVDbGlja18gPSBmdW5jdGlvbiBlbXVsYXRlQ2xpY2tfIChwb2ludGVyRXZlbnQpIHtcbiAgICB2YXIgbmV3RXZlbnQgPSBuZXcgTWFwQnJvd3NlclBvaW50ZXJFdmVudChcbiAgICAgIE1hcEJyb3dzZXJFdmVudFR5cGUuQ0xJQ0ssIHRoaXMubWFwXywgcG9pbnRlckV2ZW50KTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuICAgIGlmICh0aGlzLmNsaWNrVGltZW91dElkXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBkb3VibGUtY2xpY2tcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNsaWNrVGltZW91dElkXyk7XG4gICAgICB0aGlzLmNsaWNrVGltZW91dElkXyA9IHVuZGVmaW5lZDtcbiAgICAgIG5ld0V2ZW50ID0gbmV3IE1hcEJyb3dzZXJQb2ludGVyRXZlbnQoXG4gICAgICAgIE1hcEJyb3dzZXJFdmVudFR5cGUuREJMQ0xJQ0ssIHRoaXMubWFwXywgcG9pbnRlckV2ZW50KTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXdFdmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNsaWNrXG4gICAgICB0aGlzLmNsaWNrVGltZW91dElkXyA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2xpY2tUaW1lb3V0SWRfID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgbmV3RXZlbnQgPSBuZXcgTWFwQnJvd3NlclBvaW50ZXJFdmVudChcbiAgICAgICAgICBNYXBCcm93c2VyRXZlbnRUeXBlLlNJTkdMRUNMSUNLLCB0aGlzLm1hcF8sIHBvaW50ZXJFdmVudCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXdFdmVudCk7XG4gICAgICB9LmJpbmQodGhpcyksIDI1MCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBLZWVwcyB0cmFjayBvbiBob3cgbWFueSBwb2ludGVycyBhcmUgY3VycmVudGx5IGFjdGl2ZS5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3BvaW50ZXIvUG9pbnRlckV2ZW50LmpzXCIpLmRlZmF1bHR9IHBvaW50ZXJFdmVudCBQb2ludGVyXG4gICAqIGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTWFwQnJvd3NlckV2ZW50SGFuZGxlci5wcm90b3R5cGUudXBkYXRlQWN0aXZlUG9pbnRlcnNfID0gZnVuY3Rpb24gdXBkYXRlQWN0aXZlUG9pbnRlcnNfIChwb2ludGVyRXZlbnQpIHtcbiAgICB2YXIgZXZlbnQgPSBwb2ludGVyRXZlbnQ7XG5cbiAgICBpZiAoZXZlbnQudHlwZSA9PSBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJVUCB8fFxuICAgICAgICBldmVudC50eXBlID09IE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUkNBTkNFTCkge1xuICAgICAgZGVsZXRlIHRoaXMudHJhY2tlZFRvdWNoZXNfW2V2ZW50LnBvaW50ZXJJZF07XG4gICAgfSBlbHNlIGlmIChldmVudC50eXBlID09IE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUkRPV04pIHtcbiAgICAgIHRoaXMudHJhY2tlZFRvdWNoZXNfW2V2ZW50LnBvaW50ZXJJZF0gPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZVBvaW50ZXJzXyA9IE9iamVjdC5rZXlzKHRoaXMudHJhY2tlZFRvdWNoZXNfKS5sZW5ndGg7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wb2ludGVyL1BvaW50ZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBwb2ludGVyRXZlbnQgUG9pbnRlclxuICAgKiBldmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIE1hcEJyb3dzZXJFdmVudEhhbmRsZXIucHJvdG90eXBlLmhhbmRsZVBvaW50ZXJVcF8gPSBmdW5jdGlvbiBoYW5kbGVQb2ludGVyVXBfIChwb2ludGVyRXZlbnQpIHtcbiAgICB0aGlzLnVwZGF0ZUFjdGl2ZVBvaW50ZXJzXyhwb2ludGVyRXZlbnQpO1xuICAgIHZhciBuZXdFdmVudCA9IG5ldyBNYXBCcm93c2VyUG9pbnRlckV2ZW50KFxuICAgICAgTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSVVAsIHRoaXMubWFwXywgcG9pbnRlckV2ZW50KTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuXG4gICAgLy8gV2UgZW11bGF0ZSBjbGljayBldmVudHMgb24gbGVmdCBtb3VzZSBidXR0b24gY2xpY2ssIHRvdWNoIGNvbnRhY3QsIGFuZCBwZW5cbiAgICAvLyBjb250YWN0LiBpc01vdXNlQWN0aW9uQnV0dG9uIHJldHVybnMgdHJ1ZSBpbiB0aGVzZSBjYXNlcyAoZXZ0LmJ1dHRvbiBpcyBzZXRcbiAgICAvLyB0byAwKS5cbiAgICAvLyBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy8jYnV0dG9uLXN0YXRlc1xuICAgIC8vIFdlIG9ubHkgZmlyZSBjbGljaywgc2luZ2xlY2xpY2ssIGFuZCBkb3VibGVjbGljayBpZiBub2JvZHkgaGFzIGNhbGxlZFxuICAgIC8vIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpIG9yIGV2ZW50LnByZXZlbnREZWZhdWx0KCkuXG4gICAgaWYgKCFuZXdFdmVudC5wcm9wYWdhdGlvblN0b3BwZWQgJiYgIXRoaXMuZHJhZ2dpbmdfICYmIHRoaXMuaXNNb3VzZUFjdGlvbkJ1dHRvbl8ocG9pbnRlckV2ZW50KSkge1xuICAgICAgdGhpcy5lbXVsYXRlQ2xpY2tfKHRoaXMuZG93bl8pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmFjdGl2ZVBvaW50ZXJzXyA9PT0gMCkge1xuICAgICAgdGhpcy5kcmFnTGlzdGVuZXJLZXlzXy5mb3JFYWNoKHVubGlzdGVuQnlLZXkpO1xuICAgICAgdGhpcy5kcmFnTGlzdGVuZXJLZXlzXy5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5kcmFnZ2luZ18gPSBmYWxzZTtcbiAgICAgIHRoaXMuZG93bl8gPSBudWxsO1xuICAgICAgdGhpcy5kb2N1bWVudFBvaW50ZXJFdmVudEhhbmRsZXJfLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuZG9jdW1lbnRQb2ludGVyRXZlbnRIYW5kbGVyXyA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vcG9pbnRlci9Qb2ludGVyRXZlbnQuanNcIikuZGVmYXVsdH0gcG9pbnRlckV2ZW50IFBvaW50ZXJcbiAgICogZXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElmIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiB3YXMgcHJlc3NlZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIE1hcEJyb3dzZXJFdmVudEhhbmRsZXIucHJvdG90eXBlLmlzTW91c2VBY3Rpb25CdXR0b25fID0gZnVuY3Rpb24gaXNNb3VzZUFjdGlvbkJ1dHRvbl8gKHBvaW50ZXJFdmVudCkge1xuICAgIHJldHVybiBwb2ludGVyRXZlbnQuYnV0dG9uID09PSAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vcG9pbnRlci9Qb2ludGVyRXZlbnQuanNcIikuZGVmYXVsdH0gcG9pbnRlckV2ZW50IFBvaW50ZXJcbiAgICogZXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBNYXBCcm93c2VyRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVQb2ludGVyRG93bl8gPSBmdW5jdGlvbiBoYW5kbGVQb2ludGVyRG93bl8gKHBvaW50ZXJFdmVudCkge1xuICAgIHRoaXMudXBkYXRlQWN0aXZlUG9pbnRlcnNfKHBvaW50ZXJFdmVudCk7XG4gICAgdmFyIG5ld0V2ZW50ID0gbmV3IE1hcEJyb3dzZXJQb2ludGVyRXZlbnQoXG4gICAgICBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJET1dOLCB0aGlzLm1hcF8sIHBvaW50ZXJFdmVudCk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcblxuICAgIHRoaXMuZG93bl8gPSBwb2ludGVyRXZlbnQ7XG5cbiAgICBpZiAodGhpcy5kcmFnTGlzdGVuZXJLZXlzXy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8qIFNldCB1cCBhIHBvaW50ZXIgZXZlbnQgaGFuZGxlciBvbiB0aGUgYGRvY3VtZW50YCxcbiAgICAgICAqIHdoaWNoIGlzIHJlcXVpcmVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgbW92ZWQgb3V0c2lkZVxuICAgICAgICogdGhlIHZpZXdwb3J0IHdoZW4gZHJhZ2dpbmcuXG4gICAgICAgKi9cbiAgICAgIHRoaXMuZG9jdW1lbnRQb2ludGVyRXZlbnRIYW5kbGVyXyA9XG4gICAgICAgICAgbmV3IFBvaW50ZXJFdmVudEhhbmRsZXIoZG9jdW1lbnQpO1xuXG4gICAgICB0aGlzLmRyYWdMaXN0ZW5lcktleXNfLnB1c2goXG4gICAgICAgIGxpc3Rlbih0aGlzLmRvY3VtZW50UG9pbnRlckV2ZW50SGFuZGxlcl8sXG4gICAgICAgICAgTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSTU9WRSxcbiAgICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJNb3ZlXywgdGhpcyksXG4gICAgICAgIGxpc3Rlbih0aGlzLmRvY3VtZW50UG9pbnRlckV2ZW50SGFuZGxlcl8sXG4gICAgICAgICAgTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSVVAsXG4gICAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyVXBfLCB0aGlzKSxcbiAgICAgICAgLyogTm90ZSB0aGF0IHRoZSBsaXN0ZW5lciBmb3IgYHBvaW50ZXJjYW5jZWwgaXMgc2V0IHVwIG9uXG4gICAgICAgICAqIGBwb2ludGVyRXZlbnRIYW5kbGVyX2AgYW5kIG5vdCBgZG9jdW1lbnRQb2ludGVyRXZlbnRIYW5kbGVyX2AgbGlrZVxuICAgICAgICAgKiB0aGUgYHBvaW50ZXJ1cGAgYW5kIGBwb2ludGVybW92ZWAgbGlzdGVuZXJzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgcmVhc29uIGZvciB0aGlzIGlzIHRoZSBmb2xsb3dpbmc6IGBUb3VjaFNvdXJjZS52YWN1dW1Ub3VjaGVzXygpYFxuICAgICAgICAgKiBpc3N1ZXMgYHBvaW50ZXJjYW5jZWxgIGV2ZW50cywgd2hlbiB0aGVyZSB3YXMgbm8gYHRvdWNoZW5kYCBmb3IgYVxuICAgICAgICAgKiBgdG91Y2hzdGFydGAuIE5vdywgbGV0J3Mgc2F5IGEgZmlyc3QgYHRvdWNoc3RhcnRgIGlzIHJlZ2lzdGVyZWQgb25cbiAgICAgICAgICogYHBvaW50ZXJFdmVudEhhbmRsZXJfYC4gVGhlIGBkb2N1bWVudFBvaW50ZXJFdmVudEhhbmRsZXJfYCBpcyBzZXQgdXAuXG4gICAgICAgICAqIEJ1dCBgZG9jdW1lbnRQb2ludGVyRXZlbnRIYW5kbGVyX2AgZG9lc24ndCBrbm93IGFib3V0IHRoZSBmaXJzdFxuICAgICAgICAgKiBgdG91Y2hzdGFydGAuIElmIHRoZXJlIGlzIG5vIGB0b3VjaGVuZGAgZm9yIHRoZSBgdG91Y2hzdGFydGAsIHdlIGNhblxuICAgICAgICAgKiBvbmx5IHJlY2VpdmUgYSBgdG91Y2hjYW5jZWxgIGZyb20gYHBvaW50ZXJFdmVudEhhbmRsZXJfYCwgYmVjYXVzZSBpdCBpc1xuICAgICAgICAgKiBvbmx5IHJlZ2lzdGVyZWQgdGhlcmUuXG4gICAgICAgICAqL1xuICAgICAgICBsaXN0ZW4odGhpcy5wb2ludGVyRXZlbnRIYW5kbGVyXyxcbiAgICAgICAgICBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJDQU5DRUwsXG4gICAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyVXBfLCB0aGlzKVxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wb2ludGVyL1BvaW50ZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBwb2ludGVyRXZlbnQgUG9pbnRlclxuICAgKiBldmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIE1hcEJyb3dzZXJFdmVudEhhbmRsZXIucHJvdG90eXBlLmhhbmRsZVBvaW50ZXJNb3ZlXyA9IGZ1bmN0aW9uIGhhbmRsZVBvaW50ZXJNb3ZlXyAocG9pbnRlckV2ZW50KSB7XG4gICAgLy8gQmV0d2VlbiBwb2ludGVyZG93biBhbmQgcG9pbnRlcnVwLCBwb2ludGVybW92ZSBldmVudHMgYXJlIHRyaWdnZXJlZC5cbiAgICAvLyBUbyBhdm9pZCBhICdmYWxzZScgdG91Y2htb3ZlIGV2ZW50IHRvIGJlIGRpc3BhdGNoZWQsIHdlIHRlc3QgaWYgdGhlIHBvaW50ZXJcbiAgICAvLyBtb3ZlZCBhIHNpZ25pZmljYW50IGRpc3RhbmNlLlxuICAgIGlmICh0aGlzLmlzTW92aW5nXyhwb2ludGVyRXZlbnQpKSB7XG4gICAgICB0aGlzLmRyYWdnaW5nXyA9IHRydWU7XG4gICAgICB2YXIgbmV3RXZlbnQgPSBuZXcgTWFwQnJvd3NlclBvaW50ZXJFdmVudChcbiAgICAgICAgTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSRFJBRywgdGhpcy5tYXBfLCBwb2ludGVyRXZlbnQsXG4gICAgICAgIHRoaXMuZHJhZ2dpbmdfKTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXdFdmVudCk7XG4gICAgfVxuXG4gICAgLy8gU29tZSBuYXRpdmUgYW5kcm9pZCBicm93c2VyIHRyaWdnZXJzIG1vdXNlbW92ZSBldmVudHMgZHVyaW5nIHNtYWxsIHBlcmlvZFxuICAgIC8vIG9mIHRpbWUuIFNlZTogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9hbmRyb2lkL2lzc3Vlcy9kZXRhaWw/aWQ9NTQ5MSBvclxuICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvYW5kcm9pZC9pc3N1ZXMvZGV0YWlsP2lkPTE5ODI3XG4gICAgLy8gZXg6IEdhbGF4eSBUYWIgUDMxMTAgKyBBbmRyb2lkIDQuMS4xXG4gICAgcG9pbnRlckV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdyYXAgYW5kIHJlbGF5IGEgcG9pbnRlciBldmVudC4gIE5vdGUgdGhhdCB0aGlzIHJlcXVpcmVzIHRoYXQgdGhlIHR5cGVcbiAgICogc3RyaW5nIGZvciB0aGUgTWFwQnJvd3NlclBvaW50ZXJFdmVudCBtYXRjaGVzIHRoZSBQb2ludGVyRXZlbnQgdHlwZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3BvaW50ZXIvUG9pbnRlckV2ZW50LmpzXCIpLmRlZmF1bHR9IHBvaW50ZXJFdmVudCBQb2ludGVyXG4gICAqIGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTWFwQnJvd3NlckV2ZW50SGFuZGxlci5wcm90b3R5cGUucmVsYXlFdmVudF8gPSBmdW5jdGlvbiByZWxheUV2ZW50XyAocG9pbnRlckV2ZW50KSB7XG4gICAgdmFyIGRyYWdnaW5nID0gISEodGhpcy5kb3duXyAmJiB0aGlzLmlzTW92aW5nXyhwb2ludGVyRXZlbnQpKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IE1hcEJyb3dzZXJQb2ludGVyRXZlbnQoXG4gICAgICBwb2ludGVyRXZlbnQudHlwZSwgdGhpcy5tYXBfLCBwb2ludGVyRXZlbnQsIGRyYWdnaW5nKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wb2ludGVyL1BvaW50ZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBwb2ludGVyRXZlbnQgUG9pbnRlclxuICAgKiBldmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSXMgbW92aW5nLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTWFwQnJvd3NlckV2ZW50SGFuZGxlci5wcm90b3R5cGUuaXNNb3ZpbmdfID0gZnVuY3Rpb24gaXNNb3ZpbmdfIChwb2ludGVyRXZlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnZ2luZ18gfHxcbiAgICAgICAgTWF0aC5hYnMocG9pbnRlckV2ZW50LmNsaWVudFggLSB0aGlzLmRvd25fLmNsaWVudFgpID4gdGhpcy5tb3ZlVG9sZXJhbmNlXyB8fFxuICAgICAgICBNYXRoLmFicyhwb2ludGVyRXZlbnQuY2xpZW50WSAtIHRoaXMuZG93bl8uY2xpZW50WSkgPiB0aGlzLm1vdmVUb2xlcmFuY2VfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgTWFwQnJvd3NlckV2ZW50SGFuZGxlci5wcm90b3R5cGUuZGlzcG9zZUludGVybmFsID0gZnVuY3Rpb24gZGlzcG9zZUludGVybmFsICgpIHtcbiAgICBpZiAodGhpcy5yZWxheWVkTGlzdGVuZXJLZXlfKSB7XG4gICAgICB1bmxpc3RlbkJ5S2V5KHRoaXMucmVsYXllZExpc3RlbmVyS2V5Xyk7XG4gICAgICB0aGlzLnJlbGF5ZWRMaXN0ZW5lcktleV8gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5wb2ludGVyZG93bkxpc3RlbmVyS2V5Xykge1xuICAgICAgdW5saXN0ZW5CeUtleSh0aGlzLnBvaW50ZXJkb3duTGlzdGVuZXJLZXlfKTtcbiAgICAgIHRoaXMucG9pbnRlcmRvd25MaXN0ZW5lcktleV8gPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuZHJhZ0xpc3RlbmVyS2V5c18uZm9yRWFjaCh1bmxpc3RlbkJ5S2V5KTtcbiAgICB0aGlzLmRyYWdMaXN0ZW5lcktleXNfLmxlbmd0aCA9IDA7XG5cbiAgICBpZiAodGhpcy5kb2N1bWVudFBvaW50ZXJFdmVudEhhbmRsZXJfKSB7XG4gICAgICB0aGlzLmRvY3VtZW50UG9pbnRlckV2ZW50SGFuZGxlcl8uZGlzcG9zZSgpO1xuICAgICAgdGhpcy5kb2N1bWVudFBvaW50ZXJFdmVudEhhbmRsZXJfID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMucG9pbnRlckV2ZW50SGFuZGxlcl8pIHtcbiAgICAgIHRoaXMucG9pbnRlckV2ZW50SGFuZGxlcl8uZGlzcG9zZSgpO1xuICAgICAgdGhpcy5wb2ludGVyRXZlbnRIYW5kbGVyXyA9IG51bGw7XG4gICAgfVxuICAgIEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5kaXNwb3NlSW50ZXJuYWwuY2FsbCh0aGlzKTtcbiAgfTtcblxuICByZXR1cm4gTWFwQnJvd3NlckV2ZW50SGFuZGxlcjtcbn0oRXZlbnRUYXJnZXQpKTtcblxuXG5leHBvcnQgZGVmYXVsdCBNYXBCcm93c2VyRXZlbnRIYW5kbGVyO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXBCcm93c2VyRXZlbnRIYW5kbGVyLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9NYXBCcm93c2VyRXZlbnRUeXBlXG4gKi9cbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcblxuLyoqXG4gKiBDb25zdGFudHMgZm9yIGV2ZW50IG5hbWVzLlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuXG4gIC8qKlxuICAgKiBBIHRydWUgc2luZ2xlIGNsaWNrIHdpdGggbm8gZHJhZ2dpbmcgYW5kIG5vIGRvdWJsZSBjbGljay4gTm90ZSB0aGF0IHRoaXNcbiAgICogZXZlbnQgaXMgZGVsYXllZCBieSAyNTAgbXMgdG8gZW5zdXJlIHRoYXQgaXQgaXMgbm90IGEgZG91YmxlIGNsaWNrLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnQjc2luZ2xlY2xpY2tcbiAgICogQGFwaVxuICAgKi9cbiAgU0lOR0xFQ0xJQ0s6ICdzaW5nbGVjbGljaycsXG5cbiAgLyoqXG4gICAqIEEgY2xpY2sgd2l0aCBubyBkcmFnZ2luZy4gQSBkb3VibGUgY2xpY2sgd2lsbCBmaXJlIHR3byBvZiB0aGlzLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnQjY2xpY2tcbiAgICogQGFwaVxuICAgKi9cbiAgQ0xJQ0s6IEV2ZW50VHlwZS5DTElDSyxcblxuICAvKipcbiAgICogQSB0cnVlIGRvdWJsZSBjbGljaywgd2l0aCBubyBkcmFnZ2luZy5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50I2RibGNsaWNrXG4gICAqIEBhcGlcbiAgICovXG4gIERCTENMSUNLOiBFdmVudFR5cGUuREJMQ0xJQ0ssXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB3aGVuIGEgcG9pbnRlciBpcyBkcmFnZ2VkLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnQjcG9pbnRlcmRyYWdcbiAgICogQGFwaVxuICAgKi9cbiAgUE9JTlRFUkRSQUc6ICdwb2ludGVyZHJhZycsXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB3aGVuIGEgcG9pbnRlciBpcyBtb3ZlZC4gTm90ZSB0aGF0IG9uIHRvdWNoIGRldmljZXMgdGhpcyBpc1xuICAgKiB0cmlnZ2VyZWQgd2hlbiB0aGUgbWFwIGlzIHBhbm5lZCwgc28gaXMgbm90IHRoZSBzYW1lIGFzIG1vdXNlbW92ZS5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50I3BvaW50ZXJtb3ZlXG4gICAqIEBhcGlcbiAgICovXG4gIFBPSU5URVJNT1ZFOiAncG9pbnRlcm1vdmUnLFxuXG4gIFBPSU5URVJET1dOOiAncG9pbnRlcmRvd24nLFxuICBQT0lOVEVSVVA6ICdwb2ludGVydXAnLFxuICBQT0lOVEVST1ZFUjogJ3BvaW50ZXJvdmVyJyxcbiAgUE9JTlRFUk9VVDogJ3BvaW50ZXJvdXQnLFxuICBQT0lOVEVSRU5URVI6ICdwb2ludGVyZW50ZXInLFxuICBQT0lOVEVSTEVBVkU6ICdwb2ludGVybGVhdmUnLFxuICBQT0lOVEVSQ0FOQ0VMOiAncG9pbnRlcmNhbmNlbCdcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1hcEJyb3dzZXJFdmVudFR5cGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL01hcEJyb3dzZXJQb2ludGVyRXZlbnRcbiAqL1xuaW1wb3J0IE1hcEJyb3dzZXJFdmVudCBmcm9tICcuL01hcEJyb3dzZXJFdmVudC5qcyc7XG5cbnZhciBNYXBCcm93c2VyUG9pbnRlckV2ZW50ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoTWFwQnJvd3NlckV2ZW50KSB7XG4gIGZ1bmN0aW9uIE1hcEJyb3dzZXJQb2ludGVyRXZlbnQodHlwZSwgbWFwLCBwb2ludGVyRXZlbnQsIG9wdF9kcmFnZ2luZywgb3B0X2ZyYW1lU3RhdGUpIHtcblxuICAgIE1hcEJyb3dzZXJFdmVudC5jYWxsKHRoaXMsIHR5cGUsIG1hcCwgcG9pbnRlckV2ZW50Lm9yaWdpbmFsRXZlbnQsIG9wdF9kcmFnZ2luZywgb3B0X2ZyYW1lU3RhdGUpO1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0XG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vcG9pbnRlci9Qb2ludGVyRXZlbnQuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLnBvaW50ZXJFdmVudCA9IHBvaW50ZXJFdmVudDtcblxuICB9XG5cbiAgaWYgKCBNYXBCcm93c2VyRXZlbnQgKSBNYXBCcm93c2VyUG9pbnRlckV2ZW50Ll9fcHJvdG9fXyA9IE1hcEJyb3dzZXJFdmVudDtcbiAgTWFwQnJvd3NlclBvaW50ZXJFdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNYXBCcm93c2VyRXZlbnQgJiYgTWFwQnJvd3NlckV2ZW50LnByb3RvdHlwZSApO1xuICBNYXBCcm93c2VyUG9pbnRlckV2ZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1hcEJyb3dzZXJQb2ludGVyRXZlbnQ7XG5cbiAgcmV0dXJuIE1hcEJyb3dzZXJQb2ludGVyRXZlbnQ7XG59KE1hcEJyb3dzZXJFdmVudCkpO1xuXG5leHBvcnQgZGVmYXVsdCBNYXBCcm93c2VyUG9pbnRlckV2ZW50O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXBCcm93c2VyUG9pbnRlckV2ZW50LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9NYXBFdmVudFxuICovXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi9ldmVudHMvRXZlbnQuanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEV2ZW50cyBlbWl0dGVkIGFzIG1hcCBldmVudHMgYXJlIGluc3RhbmNlcyBvZiB0aGlzIHR5cGUuXG4gKiBTZWUge0BsaW5rIG1vZHVsZTpvbC9QbHVnZ2FibGVNYXB+UGx1Z2dhYmxlTWFwfSBmb3Igd2hpY2ggZXZlbnRzIHRyaWdnZXIgYSBtYXAgZXZlbnQuXG4gKi9cbnZhciBNYXBFdmVudCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEV2ZW50KSB7XG4gIGZ1bmN0aW9uIE1hcEV2ZW50KHR5cGUsIG1hcCwgb3B0X2ZyYW1lU3RhdGUpIHtcblxuICAgIEV2ZW50LmNhbGwodGhpcywgdHlwZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWFwIHdoZXJlIHRoZSBldmVudCBvY2N1cnJlZC5cbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9QbHVnZ2FibGVNYXAuanNcIikuZGVmYXVsdH1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5tYXAgPSBtYXA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJhbWUgc3RhdGUgYXQgdGhlIHRpbWUgb2YgdGhlIGV2ZW50LlxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi9QbHVnZ2FibGVNYXAuanNcIikuRnJhbWVTdGF0ZX1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5mcmFtZVN0YXRlID0gb3B0X2ZyYW1lU3RhdGUgIT09IHVuZGVmaW5lZCA/IG9wdF9mcmFtZVN0YXRlIDogbnVsbDtcblxuICB9XG5cbiAgaWYgKCBFdmVudCApIE1hcEV2ZW50Ll9fcHJvdG9fXyA9IEV2ZW50O1xuICBNYXBFdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFdmVudCAmJiBFdmVudC5wcm90b3R5cGUgKTtcbiAgTWFwRXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWFwRXZlbnQ7XG5cbiAgcmV0dXJuIE1hcEV2ZW50O1xufShFdmVudCkpO1xuXG5leHBvcnQgZGVmYXVsdCBNYXBFdmVudDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWFwRXZlbnQuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL01hcEV2ZW50VHlwZVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgYSBtYXAgZnJhbWUgaXMgcmVuZGVyZWQuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvTWFwRXZlbnR+TWFwRXZlbnQjcG9zdHJlbmRlclxuICAgKiBAYXBpXG4gICAqL1xuICBQT1NUUkVOREVSOiAncG9zdHJlbmRlcicsXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB3aGVuIHRoZSBtYXAgc3RhcnRzIG1vdmluZy5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9NYXBFdmVudH5NYXBFdmVudCNtb3Zlc3RhcnRcbiAgICogQGFwaVxuICAgKi9cbiAgTU9WRVNUQVJUOiAnbW92ZXN0YXJ0JyxcblxuICAvKipcbiAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBtYXAgaXMgbW92ZWQuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvTWFwRXZlbnR+TWFwRXZlbnQjbW92ZWVuZFxuICAgKiBAYXBpXG4gICAqL1xuICBNT1ZFRU5EOiAnbW92ZWVuZCdcblxufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWFwRXZlbnRUeXBlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9NYXBQcm9wZXJ0eVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBMQVlFUkdST1VQOiAnbGF5ZXJncm91cCcsXG4gIFNJWkU6ICdzaXplJyxcbiAgVEFSR0VUOiAndGFyZ2V0JyxcbiAgVklFVzogJ3ZpZXcnXG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXBQcm9wZXJ0eS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvT2JqZWN0XG4gKi9cbmltcG9ydCB7Z2V0VWlkfSBmcm9tICcuL3V0aWwuanMnO1xuaW1wb3J0IE9iamVjdEV2ZW50VHlwZSBmcm9tICcuL09iamVjdEV2ZW50VHlwZS5qcyc7XG5pbXBvcnQgT2JzZXJ2YWJsZSBmcm9tICcuL09ic2VydmFibGUuanMnO1xuaW1wb3J0IEV2ZW50IGZyb20gJy4vZXZlbnRzL0V2ZW50LmpzJztcbmltcG9ydCB7YXNzaWdufSBmcm9tICcuL29iai5qcyc7XG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBFdmVudHMgZW1pdHRlZCBieSB7QGxpbmsgbW9kdWxlOm9sL09iamVjdH5CYXNlT2JqZWN0fSBpbnN0YW5jZXMgYXJlIGluc3RhbmNlcyBvZiB0aGlzIHR5cGUuXG4gKi9cbmV4cG9ydCB2YXIgT2JqZWN0RXZlbnQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChFdmVudCkge1xuICBmdW5jdGlvbiBPYmplY3RFdmVudCh0eXBlLCBrZXksIG9sZFZhbHVlKSB7XG4gICAgRXZlbnQuY2FsbCh0aGlzLCB0eXBlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB3aG9zZSB2YWx1ZSBpcyBjaGFuZ2luZy5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLmtleSA9IGtleTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvbGQgdmFsdWUuIFRvIGdldCB0aGUgbmV3IHZhbHVlIHVzZSBgZS50YXJnZXQuZ2V0KGUua2V5KWAgd2hlcmVcbiAgICAgKiBgZWAgaXMgdGhlIGV2ZW50IG9iamVjdC5cbiAgICAgKiBAdHlwZSB7Kn1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5vbGRWYWx1ZSA9IG9sZFZhbHVlO1xuXG4gIH1cblxuICBpZiAoIEV2ZW50ICkgT2JqZWN0RXZlbnQuX19wcm90b19fID0gRXZlbnQ7XG4gIE9iamVjdEV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEV2ZW50ICYmIEV2ZW50LnByb3RvdHlwZSApO1xuICBPYmplY3RFdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBPYmplY3RFdmVudDtcblxuICByZXR1cm4gT2JqZWN0RXZlbnQ7XG59KEV2ZW50KSk7XG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzOyBub3JtYWxseSBvbmx5IHVzZWQgZm9yIGNyZWF0aW5nIHN1YmNsYXNzZXMgYW5kIG5vdFxuICogaW5zdGFudGlhdGVkIGluIGFwcHMuXG4gKiBNb3N0IG5vbi10cml2aWFsIGNsYXNzZXMgaW5oZXJpdCBmcm9tIHRoaXMuXG4gKlxuICogVGhpcyBleHRlbmRzIHtAbGluayBtb2R1bGU6b2wvT2JzZXJ2YWJsZX0gd2l0aCBvYnNlcnZhYmxlXG4gKiBwcm9wZXJ0aWVzLCB3aGVyZSBlYWNoIHByb3BlcnR5IGlzIG9ic2VydmFibGUgYXMgd2VsbCBhcyB0aGUgb2JqZWN0IGFzIGFcbiAqIHdob2xlLlxuICpcbiAqIENsYXNzZXMgdGhhdCBpbmhlcml0IGZyb20gdGhpcyBoYXZlIHByZS1kZWZpbmVkIHByb3BlcnRpZXMsIHRvIHdoaWNoIHlvdSBjYW5cbiAqIGFkZCB5b3VyIG93bnMuIFRoZSBwcmUtZGVmaW5lZCBwcm9wZXJ0aWVzIGFyZSBsaXN0ZWQgaW4gdGhpcyBkb2N1bWVudGF0aW9uIGFzXG4gKiAnT2JzZXJ2YWJsZSBQcm9wZXJ0aWVzJywgYW5kIGhhdmUgdGhlaXIgb3duIGFjY2Vzc29yczsgZm9yIGV4YW1wbGUsXG4gKiB7QGxpbmsgbW9kdWxlOm9sL01hcH5NYXB9IGhhcyBhIGB0YXJnZXRgIHByb3BlcnR5LCBhY2Nlc3NlZCB3aXRoXG4gKiBgZ2V0VGFyZ2V0KClgIGFuZCBjaGFuZ2VkIHdpdGggYHNldFRhcmdldCgpYC4gTm90IGFsbCBwcm9wZXJ0aWVzIGFyZSBob3dldmVyXG4gKiBzZXR0YWJsZS4gVGhlcmUgYXJlIGFsc28gZ2VuZXJhbC1wdXJwb3NlIGFjY2Vzc29ycyBgZ2V0KClgIGFuZCBgc2V0KClgLiBGb3JcbiAqIGV4YW1wbGUsIGBnZXQoJ3RhcmdldCcpYCBpcyBlcXVpdmFsZW50IHRvIGBnZXRUYXJnZXQoKWAuXG4gKlxuICogVGhlIGBzZXRgIGFjY2Vzc29ycyB0cmlnZ2VyIGEgY2hhbmdlIGV2ZW50LCBhbmQgeW91IGNhbiBtb25pdG9yIHRoaXMgYnlcbiAqIHJlZ2lzdGVyaW5nIGEgbGlzdGVuZXIuIEZvciBleGFtcGxlLCB7QGxpbmsgbW9kdWxlOm9sL1ZpZXd+Vmlld30gaGFzIGFcbiAqIGBjZW50ZXJgIHByb3BlcnR5LCBzbyBgdmlldy5vbignY2hhbmdlOmNlbnRlcicsIGZ1bmN0aW9uKGV2dCkgey4uLn0pO2Agd291bGRcbiAqIGNhbGwgdGhlIGZ1bmN0aW9uIHdoZW5ldmVyIHRoZSB2YWx1ZSBvZiB0aGUgY2VudGVyIHByb3BlcnR5IGNoYW5nZXMuIFdpdGhpblxuICogdGhlIGZ1bmN0aW9uLCBgZXZ0LnRhcmdldGAgd291bGQgYmUgdGhlIHZpZXcsIHNvIGBldnQudGFyZ2V0LmdldENlbnRlcigpYFxuICogd291bGQgcmV0dXJuIHRoZSBuZXcgY2VudGVyLlxuICpcbiAqIFlvdSBjYW4gYWRkIHlvdXIgb3duIG9ic2VydmFibGUgcHJvcGVydGllcyB3aXRoXG4gKiBgb2JqZWN0LnNldCgncHJvcCcsICd2YWx1ZScpYCwgYW5kIHJldHJpZXZlIHRoYXQgd2l0aCBgb2JqZWN0LmdldCgncHJvcCcpYC5cbiAqIFlvdSBjYW4gbGlzdGVuIGZvciBjaGFuZ2VzIG9uIHRoYXQgcHJvcGVydHkgdmFsdWUgd2l0aFxuICogYG9iamVjdC5vbignY2hhbmdlOnByb3AnLCBsaXN0ZW5lcilgLiBZb3UgY2FuIGdldCBhIGxpc3Qgb2YgYWxsXG4gKiBwcm9wZXJ0aWVzIHdpdGgge0BsaW5rIG1vZHVsZTpvbC9PYmplY3R+QmFzZU9iamVjdCNnZXRQcm9wZXJ0aWVzfS5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIG9ic2VydmFibGUgcHJvcGVydGllcyBhcmUgc2VwYXJhdGUgZnJvbSBzdGFuZGFyZCBKUyBwcm9wZXJ0aWVzLlxuICogWW91IGNhbiwgZm9yIGV4YW1wbGUsIGdpdmUgeW91ciBtYXAgb2JqZWN0IGEgdGl0bGUgd2l0aFxuICogYG1hcC50aXRsZT0nTmV3IHRpdGxlJ2AgYW5kIHdpdGggYG1hcC5zZXQoJ3RpdGxlJywgJ0Fub3RoZXIgdGl0bGUnKWAuIFRoZVxuICogZmlyc3Qgd2lsbCBiZSBhIGBoYXNPd25Qcm9wZXJ0eWA7IHRoZSBzZWNvbmQgd2lsbCBhcHBlYXIgaW5cbiAqIGBnZXRQcm9wZXJ0aWVzKClgLiBPbmx5IHRoZSBzZWNvbmQgaXMgb2JzZXJ2YWJsZS5cbiAqXG4gKiBQcm9wZXJ0aWVzIGNhbiBiZSBkZWxldGVkIGJ5IHVzaW5nIHRoZSB1bnNldCBtZXRob2QuIEUuZy5cbiAqIG9iamVjdC51bnNldCgnZm9vJykuXG4gKlxuICogQGZpcmVzIE9iamVjdEV2ZW50XG4gKiBAYXBpXG4gKi9cbnZhciBCYXNlT2JqZWN0ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoT2JzZXJ2YWJsZSkge1xuICBmdW5jdGlvbiBCYXNlT2JqZWN0KG9wdF92YWx1ZXMpIHtcbiAgICBPYnNlcnZhYmxlLmNhbGwodGhpcyk7XG5cbiAgICAvLyBDYWxsIHtAbGluayBtb2R1bGU6b2wvdXRpbH5nZXRVaWR9IHRvIGVuc3VyZSB0aGF0IHRoZSBvcmRlciBvZiBvYmplY3RzJyBpZHMgaXNcbiAgICAvLyB0aGUgc2FtZSBhcyB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSB3ZXJlIGNyZWF0ZWQuICBUaGlzIGFsc28gaGVscHMgdG9cbiAgICAvLyBlbnN1cmUgdGhhdCBvYmplY3QgcHJvcGVydGllcyBhcmUgYWx3YXlzIGFkZGVkIGluIHRoZSBzYW1lIG9yZGVyLCB3aGljaFxuICAgIC8vIGhlbHBzIG1hbnkgSmF2YVNjcmlwdCBlbmdpbmVzIGdlbmVyYXRlIGZhc3RlciBjb2RlLlxuICAgIGdldFVpZCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCAqPn1cbiAgICAgKi9cbiAgICB0aGlzLnZhbHVlc18gPSB7fTtcblxuICAgIGlmIChvcHRfdmFsdWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuc2V0UHJvcGVydGllcyhvcHRfdmFsdWVzKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIE9ic2VydmFibGUgKSBCYXNlT2JqZWN0Ll9fcHJvdG9fXyA9IE9ic2VydmFibGU7XG4gIEJhc2VPYmplY3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggT2JzZXJ2YWJsZSAmJiBPYnNlcnZhYmxlLnByb3RvdHlwZSApO1xuICBCYXNlT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJhc2VPYmplY3Q7XG5cbiAgLyoqXG4gICAqIEdldHMgYSB2YWx1ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkgbmFtZS5cbiAgICogQHJldHVybiB7Kn0gVmFsdWUuXG4gICAqIEBhcGlcbiAgICovXG4gIEJhc2VPYmplY3QucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoa2V5KSB7XG4gICAgdmFyIHZhbHVlO1xuICAgIGlmICh0aGlzLnZhbHVlc18uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgdmFsdWUgPSB0aGlzLnZhbHVlc19ba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSBsaXN0IG9mIG9iamVjdCBwcm9wZXJ0eSBuYW1lcy5cbiAgICogQHJldHVybiB7QXJyYXk8c3RyaW5nPn0gTGlzdCBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICogQGFwaVxuICAgKi9cbiAgQmFzZU9iamVjdC5wcm90b3R5cGUuZ2V0S2V5cyA9IGZ1bmN0aW9uIGdldEtleXMgKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnZhbHVlc18pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYW4gb2JqZWN0IG9mIGFsbCBwcm9wZXJ0eSBuYW1lcyBhbmQgdmFsdWVzLlxuICAgKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLCAqPn0gT2JqZWN0LlxuICAgKiBAYXBpXG4gICAqL1xuICBCYXNlT2JqZWN0LnByb3RvdHlwZS5nZXRQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZ2V0UHJvcGVydGllcyAoKSB7XG4gICAgcmV0dXJuIGFzc2lnbih7fSwgdGhpcy52YWx1ZXNfKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkgbmFtZS5cbiAgICogQHBhcmFtIHsqfSBvbGRWYWx1ZSBPbGQgdmFsdWUuXG4gICAqL1xuICBCYXNlT2JqZWN0LnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiBub3RpZnkgKGtleSwgb2xkVmFsdWUpIHtcbiAgICB2YXIgZXZlbnRUeXBlO1xuICAgIGV2ZW50VHlwZSA9IGdldENoYW5nZUV2ZW50VHlwZShrZXkpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgT2JqZWN0RXZlbnQoZXZlbnRUeXBlLCBrZXksIG9sZFZhbHVlKSk7XG4gICAgZXZlbnRUeXBlID0gT2JqZWN0RXZlbnRUeXBlLlBST1BFUlRZQ0hBTkdFO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgT2JqZWN0RXZlbnQoZXZlbnRUeXBlLCBrZXksIG9sZFZhbHVlKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHMgYSB2YWx1ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkgbmFtZS5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZS5cbiAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3NpbGVudCBVcGRhdGUgd2l0aG91dCB0cmlnZ2VyaW5nIGFuIGV2ZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBCYXNlT2JqZWN0LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQgKGtleSwgdmFsdWUsIG9wdF9zaWxlbnQpIHtcbiAgICBpZiAob3B0X3NpbGVudCkge1xuICAgICAgdGhpcy52YWx1ZXNfW2tleV0gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZXNfW2tleV07XG4gICAgICB0aGlzLnZhbHVlc19ba2V5XSA9IHZhbHVlO1xuICAgICAgaWYgKG9sZFZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICB0aGlzLm5vdGlmeShrZXksIG9sZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHMgYSBjb2xsZWN0aW9uIG9mIGtleS12YWx1ZSBwYWlycy4gIE5vdGUgdGhhdCB0aGlzIGNoYW5nZXMgYW55IGV4aXN0aW5nXG4gICAqIHByb3BlcnRpZXMgYW5kIGFkZHMgbmV3IG9uZXMgKGl0IGRvZXMgbm90IHJlbW92ZSBhbnkgZXhpc3RpbmcgcHJvcGVydGllcykuXG4gICAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgKj59IHZhbHVlcyBWYWx1ZXMuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9zaWxlbnQgVXBkYXRlIHdpdGhvdXQgdHJpZ2dlcmluZyBhbiBldmVudC5cbiAgICogQGFwaVxuICAgKi9cbiAgQmFzZU9iamVjdC5wcm90b3R5cGUuc2V0UHJvcGVydGllcyA9IGZ1bmN0aW9uIHNldFByb3BlcnRpZXMgKHZhbHVlcywgb3B0X3NpbGVudCkge1xuICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZXMpIHtcbiAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWVzW2tleV0sIG9wdF9zaWxlbnQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVW5zZXRzIGEgcHJvcGVydHkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgS2V5IG5hbWUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9zaWxlbnQgVW5zZXQgd2l0aG91dCB0cmlnZ2VyaW5nIGFuIGV2ZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBCYXNlT2JqZWN0LnByb3RvdHlwZS51bnNldCA9IGZ1bmN0aW9uIHVuc2V0IChrZXksIG9wdF9zaWxlbnQpIHtcbiAgICBpZiAoa2V5IGluIHRoaXMudmFsdWVzXykge1xuICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZXNfW2tleV07XG4gICAgICBkZWxldGUgdGhpcy52YWx1ZXNfW2tleV07XG4gICAgICBpZiAoIW9wdF9zaWxlbnQpIHtcbiAgICAgICAgdGhpcy5ub3RpZnkoa2V5LCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBCYXNlT2JqZWN0O1xufShPYnNlcnZhYmxlKSk7XG5cblxuLyoqXG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgc3RyaW5nPn1cbiAqL1xudmFyIGNoYW5nZUV2ZW50VHlwZUNhY2hlID0ge307XG5cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleSBuYW1lLlxuICogQHJldHVybiB7c3RyaW5nfSBDaGFuZ2UgbmFtZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENoYW5nZUV2ZW50VHlwZShrZXkpIHtcbiAgcmV0dXJuIGNoYW5nZUV2ZW50VHlwZUNhY2hlLmhhc093blByb3BlcnR5KGtleSkgP1xuICAgIGNoYW5nZUV2ZW50VHlwZUNhY2hlW2tleV0gOlxuICAgIChjaGFuZ2VFdmVudFR5cGVDYWNoZVtrZXldID0gJ2NoYW5nZTonICsga2V5KTtcbn1cblxuXG5leHBvcnQgZGVmYXVsdCBCYXNlT2JqZWN0O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1PYmplY3QuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL09iamVjdEV2ZW50VHlwZVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICAvKipcbiAgICogVHJpZ2dlcmVkIHdoZW4gYSBwcm9wZXJ0eSBpcyBjaGFuZ2VkLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL09iamVjdC5PYmplY3RFdmVudCNwcm9wZXJ0eWNoYW5nZVxuICAgKiBAYXBpXG4gICAqL1xuICBQUk9QRVJUWUNIQU5HRTogJ3Byb3BlcnR5Y2hhbmdlJ1xufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JqZWN0RXZlbnRUeXBlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9PYnNlcnZhYmxlXG4gKi9cbmltcG9ydCB7bGlzdGVuLCB1bmxpc3RlbkJ5S2V5LCB1bmxpc3RlbiwgbGlzdGVuT25jZX0gZnJvbSAnLi9ldmVudHMuanMnO1xuaW1wb3J0IEV2ZW50VGFyZ2V0IGZyb20gJy4vZXZlbnRzL1RhcmdldC5qcyc7XG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWJzdHJhY3QgYmFzZSBjbGFzczsgbm9ybWFsbHkgb25seSB1c2VkIGZvciBjcmVhdGluZyBzdWJjbGFzc2VzIGFuZCBub3RcbiAqIGluc3RhbnRpYXRlZCBpbiBhcHBzLlxuICogQW4gZXZlbnQgdGFyZ2V0IHByb3ZpZGluZyBjb252ZW5pZW50IG1ldGhvZHMgZm9yIGxpc3RlbmVyIHJlZ2lzdHJhdGlvblxuICogYW5kIHVucmVnaXN0cmF0aW9uLiBBIGdlbmVyaWMgYGNoYW5nZWAgZXZlbnQgaXMgYWx3YXlzIGF2YWlsYWJsZSB0aHJvdWdoXG4gKiB7QGxpbmsgbW9kdWxlOm9sL09ic2VydmFibGV+T2JzZXJ2YWJsZSNjaGFuZ2VkfS5cbiAqXG4gKiBAZmlyZXMgaW1wb3J0KFwiLi9ldmVudHMvRXZlbnQuanNcIikuRXZlbnRcbiAqIEBhcGlcbiAqL1xudmFyIE9ic2VydmFibGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChFdmVudFRhcmdldCkge1xuICBmdW5jdGlvbiBPYnNlcnZhYmxlKCkge1xuXG4gICAgRXZlbnRUYXJnZXQuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJldmlzaW9uXyA9IDA7XG5cbiAgfVxuXG4gIGlmICggRXZlbnRUYXJnZXQgKSBPYnNlcnZhYmxlLl9fcHJvdG9fXyA9IEV2ZW50VGFyZ2V0O1xuICBPYnNlcnZhYmxlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEV2ZW50VGFyZ2V0ICYmIEV2ZW50VGFyZ2V0LnByb3RvdHlwZSApO1xuICBPYnNlcnZhYmxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE9ic2VydmFibGU7XG5cbiAgLyoqXG4gICAqIEluY3JlYXNlcyB0aGUgcmV2aXNpb24gY291bnRlciBhbmQgZGlzcGF0Y2hlcyBhICdjaGFuZ2UnIGV2ZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBPYnNlcnZhYmxlLnByb3RvdHlwZS5jaGFuZ2VkID0gZnVuY3Rpb24gY2hhbmdlZCAoKSB7XG4gICAgKyt0aGlzLnJldmlzaW9uXztcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRUeXBlLkNIQU5HRSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmVyc2lvbiBudW1iZXIgZm9yIHRoaXMgb2JqZWN0LiAgRWFjaCB0aW1lIHRoZSBvYmplY3QgaXMgbW9kaWZpZWQsXG4gICAqIGl0cyB2ZXJzaW9uIG51bWJlciB3aWxsIGJlIGluY3JlbWVudGVkLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFJldmlzaW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBPYnNlcnZhYmxlLnByb3RvdHlwZS5nZXRSZXZpc2lvbiA9IGZ1bmN0aW9uIGdldFJldmlzaW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXZpc2lvbl87XG4gIH07XG5cbiAgLyoqXG4gICAqIExpc3RlbiBmb3IgYSBjZXJ0YWluIHR5cGUgb2YgZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5PHN0cmluZz59IHR5cGUgVGhlIGV2ZW50IHR5cGUgb3IgYXJyYXkgb2YgZXZlbnQgdHlwZXMuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oPyk6ID99IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9ldmVudHMuanNcIikuRXZlbnRzS2V5fEFycmF5PGltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleT59IFVuaXF1ZSBrZXkgZm9yIHRoZSBsaXN0ZW5lci4gSWZcbiAgICogICAgIGNhbGxlZCB3aXRoIGFuIGFycmF5IG9mIGV2ZW50IHR5cGVzIGFzIHRoZSBmaXJzdCBhcmd1bWVudCwgdGhlIHJldHVyblxuICAgKiAgICAgd2lsbCBiZSBhbiBhcnJheSBvZiBrZXlzLlxuICAgKiBAYXBpXG4gICAqL1xuICBPYnNlcnZhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uICh0eXBlLCBsaXN0ZW5lcikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB2YXIgbGVuID0gdHlwZS5sZW5ndGg7XG4gICAgICB2YXIga2V5cyA9IG5ldyBBcnJheShsZW4pO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBrZXlzW2ldID0gbGlzdGVuKHRoaXMsIHR5cGVbaV0sIGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbGlzdGVuKHRoaXMsIC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAodHlwZSksIGxpc3RlbmVyKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIExpc3RlbiBvbmNlIGZvciBhIGNlcnRhaW4gdHlwZSBvZiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXk8c3RyaW5nPn0gdHlwZSBUaGUgZXZlbnQgdHlwZSBvciBhcnJheSBvZiBldmVudCB0eXBlcy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbig/KTogP30gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXl8QXJyYXk8aW1wb3J0KFwiLi9ldmVudHMuanNcIikuRXZlbnRzS2V5Pn0gVW5pcXVlIGtleSBmb3IgdGhlIGxpc3RlbmVyLiBJZlxuICAgKiAgICAgY2FsbGVkIHdpdGggYW4gYXJyYXkgb2YgZXZlbnQgdHlwZXMgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LCB0aGUgcmV0dXJuXG4gICAqICAgICB3aWxsIGJlIGFuIGFycmF5IG9mIGtleXMuXG4gICAqIEBhcGlcbiAgICovXG4gIE9ic2VydmFibGUucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlICh0eXBlLCBsaXN0ZW5lcikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB2YXIgbGVuID0gdHlwZS5sZW5ndGg7XG4gICAgICB2YXIga2V5cyA9IG5ldyBBcnJheShsZW4pO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBrZXlzW2ldID0gbGlzdGVuT25jZSh0aGlzLCB0eXBlW2ldLCBsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICByZXR1cm4ga2V5cztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGxpc3Rlbk9uY2UodGhpcywgLyoqIEB0eXBlIHtzdHJpbmd9ICovICh0eXBlKSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVW5saXN0ZW4gZm9yIGEgY2VydGFpbiB0eXBlIG9mIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheTxzdHJpbmc+fSB0eXBlIFRoZSBldmVudCB0eXBlIG9yIGFycmF5IG9mIGV2ZW50IHR5cGVzLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKD8pOiA/fSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIE9ic2VydmFibGUucHJvdG90eXBlLnVuID0gZnVuY3Rpb24gdW4gKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHR5cGUubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICB1bmxpc3Rlbih0aGlzLCB0eXBlW2ldLCBsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHVubGlzdGVuKHRoaXMsIC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAodHlwZSksIGxpc3RlbmVyKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIE9ic2VydmFibGU7XG59KEV2ZW50VGFyZ2V0KSk7XG5cblxuLyoqXG4gKiBSZW1vdmVzIGFuIGV2ZW50IGxpc3RlbmVyIHVzaW5nIHRoZSBrZXkgcmV0dXJuZWQgYnkgYG9uKClgIG9yIGBvbmNlKClgLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXl8QXJyYXk8aW1wb3J0KFwiLi9ldmVudHMuanNcIikuRXZlbnRzS2V5Pn0ga2V5IFRoZSBrZXkgcmV0dXJuZWQgYnkgYG9uKClgXG4gKiAgICAgb3IgYG9uY2UoKWAgKG9yIGFuIGFycmF5IG9mIGtleXMpLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5CeUtleShrZXkpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoa2V5KSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGtleS5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB1bmxpc3RlbkJ5S2V5KGtleVtpXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHVubGlzdGVuQnlLZXkoLyoqIEB0eXBlIHtpbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXl9ICovIChrZXkpKTtcbiAgfVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IE9ic2VydmFibGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9ic2VydmFibGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL1BsdWdnYWJsZU1hcFxuICovXG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi91dGlsLmpzJztcbmltcG9ydCBDb2xsZWN0aW9uIGZyb20gJy4vQ29sbGVjdGlvbi5qcyc7XG5pbXBvcnQgQ29sbGVjdGlvbkV2ZW50VHlwZSBmcm9tICcuL0NvbGxlY3Rpb25FdmVudFR5cGUuanMnO1xuaW1wb3J0IE1hcEJyb3dzZXJFdmVudCBmcm9tICcuL01hcEJyb3dzZXJFdmVudC5qcyc7XG5pbXBvcnQgTWFwQnJvd3NlckV2ZW50SGFuZGxlciBmcm9tICcuL01hcEJyb3dzZXJFdmVudEhhbmRsZXIuanMnO1xuaW1wb3J0IE1hcEJyb3dzZXJFdmVudFR5cGUgZnJvbSAnLi9NYXBCcm93c2VyRXZlbnRUeXBlLmpzJztcbmltcG9ydCBNYXBFdmVudCBmcm9tICcuL01hcEV2ZW50LmpzJztcbmltcG9ydCBNYXBFdmVudFR5cGUgZnJvbSAnLi9NYXBFdmVudFR5cGUuanMnO1xuaW1wb3J0IE1hcFByb3BlcnR5IGZyb20gJy4vTWFwUHJvcGVydHkuanMnO1xuaW1wb3J0IFJlbmRlckV2ZW50VHlwZSBmcm9tICcuL3JlbmRlci9FdmVudFR5cGUuanMnO1xuaW1wb3J0IEJhc2VPYmplY3QsIHtnZXRDaGFuZ2VFdmVudFR5cGV9IGZyb20gJy4vT2JqZWN0LmpzJztcbmltcG9ydCBPYmplY3RFdmVudFR5cGUgZnJvbSAnLi9PYmplY3RFdmVudFR5cGUuanMnO1xuaW1wb3J0IFRpbGVRdWV1ZSBmcm9tICcuL1RpbGVRdWV1ZS5qcyc7XG5pbXBvcnQgVmlldyBmcm9tICcuL1ZpZXcuanMnO1xuaW1wb3J0IFZpZXdIaW50IGZyb20gJy4vVmlld0hpbnQuanMnO1xuaW1wb3J0IHthc3NlcnR9IGZyb20gJy4vYXNzZXJ0cy5qcyc7XG5pbXBvcnQge3JlbW92ZU5vZGV9IGZyb20gJy4vZG9tLmpzJztcbmltcG9ydCB7bGlzdGVuLCB1bmxpc3RlbkJ5S2V5LCB1bmxpc3Rlbn0gZnJvbSAnLi9ldmVudHMuanMnO1xuaW1wb3J0IHtzdG9wUHJvcGFnYXRpb259IGZyb20gJy4vZXZlbnRzL0V2ZW50LmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7Y3JlYXRlRW1wdHksIGNsb25lLCBjcmVhdGVPclVwZGF0ZUVtcHR5LCBlcXVhbHMsIGdldEZvclZpZXdBbmRTaXplLCBpc0VtcHR5fSBmcm9tICcuL2V4dGVudC5qcyc7XG5pbXBvcnQge1RSVUV9IGZyb20gJy4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCB7REVWSUNFX1BJWEVMX1JBVElPLCBUT1VDSH0gZnJvbSAnLi9oYXMuanMnO1xuaW1wb3J0IExheWVyR3JvdXAgZnJvbSAnLi9sYXllci9Hcm91cC5qcyc7XG5pbXBvcnQge2hhc0FyZWF9IGZyb20gJy4vc2l6ZS5qcyc7XG5pbXBvcnQge0RST1B9IGZyb20gJy4vc3RydWN0cy9Qcmlvcml0eVF1ZXVlLmpzJztcbmltcG9ydCB7Y3JlYXRlIGFzIGNyZWF0ZVRyYW5zZm9ybSwgYXBwbHkgYXMgYXBwbHlUcmFuc2Zvcm19IGZyb20gJy4vdHJhbnNmb3JtLmpzJztcblxuXG4vKipcbiAqIFN0YXRlIG9mIHRoZSBjdXJyZW50IGZyYW1lLiBPbmx5IGBwaXhlbFJhdGlvYCwgYHRpbWVgIGFuZCBgdmlld1N0YXRlYCBzaG91bGRcbiAqIGJlIHVzZWQgaW4gYXBwbGljYXRpb25zLlxuICogQHR5cGVkZWYge09iamVjdH0gRnJhbWVTdGF0ZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHBpeGVsUmF0aW8gVGhlIHBpeGVsIHJhdGlvIG9mIHRoZSBmcmFtZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lIFRoZSB0aW1lIHdoZW4gcmVuZGVyaW5nIG9mIHRoZSBmcmFtZSB3YXMgcmVxdWVzdGVkLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL1ZpZXcuanNcIikuU3RhdGV9IHZpZXdTdGF0ZSBUaGUgc3RhdGUgb2YgdGhlIGN1cnJlbnQgdmlldy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYW5pbWF0ZVxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19IGNvb3JkaW5hdGVUb1BpeGVsVHJhbnNmb3JtXG4gKiBAcHJvcGVydHkge251bGx8aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnRcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGZvY3VzXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW5kZXhcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi9sYXllci9MYXllci5qc1wiKS5TdGF0ZT59IGxheWVyU3RhdGVzXG4gKiBAcHJvcGVydHkge0FycmF5PGltcG9ydChcIi4vbGF5ZXIvTGF5ZXIuanNcIikuU3RhdGU+fSBsYXllclN0YXRlc0FycmF5XG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX0gcGl4ZWxUb0Nvb3JkaW5hdGVUcmFuc2Zvcm1cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8UG9zdFJlbmRlckZ1bmN0aW9uPn0gcG9zdFJlbmRlckZ1bmN0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gc2l6ZVxuICogQHByb3BlcnR5IHshT2JqZWN0PHN0cmluZywgYm9vbGVhbj59IHNraXBwZWRGZWF0dXJlVWlkc1xuICogQHByb3BlcnR5IHtUaWxlUXVldWV9IHRpbGVRdWV1ZVxuICogQHByb3BlcnR5IHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0Pj59IHVzZWRUaWxlc1xuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSB2aWV3SGludHNcbiAqIEBwcm9wZXJ0eSB7IU9iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGJvb2xlYW4+Pn0gd2FudGVkVGlsZXNcbiAqL1xuXG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKFBsdWdnYWJsZU1hcCwgP0ZyYW1lU3RhdGUpOiBib29sZWFufSBQb3N0UmVuZGVyRnVuY3Rpb25cbiAqL1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQXRQaXhlbE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7dW5kZWZpbmVkfGZ1bmN0aW9uKGltcG9ydChcIi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdCk6IGJvb2xlYW59IGxheWVyRmlsdGVyIExheWVyIGZpbHRlclxuICogZnVuY3Rpb24uIFRoZSBmaWx0ZXIgZnVuY3Rpb24gd2lsbCByZWNlaXZlIG9uZSBhcmd1bWVudCwgdGhlXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL0xheWVyIGxheWVyLWNhbmRpZGF0ZX0gYW5kIGl0IHNob3VsZCByZXR1cm4gYSBib29sZWFuIHZhbHVlLlxuICogT25seSBsYXllcnMgd2hpY2ggYXJlIHZpc2libGUgYW5kIGZvciB3aGljaCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYHRydWVgXG4gKiB3aWxsIGJlIHRlc3RlZCBmb3IgZmVhdHVyZXMuIEJ5IGRlZmF1bHQsIGFsbCB2aXNpYmxlIGxheWVycyB3aWxsIGJlIHRlc3RlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbaGl0VG9sZXJhbmNlPTBdIEhpdC1kZXRlY3Rpb24gdG9sZXJhbmNlIGluIHBpeGVscy4gUGl4ZWxzXG4gKiBpbnNpZGUgdGhlIHJhZGl1cyBhcm91bmQgdGhlIGdpdmVuIHBvc2l0aW9uIHdpbGwgYmUgY2hlY2tlZCBmb3IgZmVhdHVyZXMuIFRoaXMgb25seVxuICogd29ya3MgZm9yIHRoZSBjYW52YXMgcmVuZGVyZXIgYW5kIG5vdCBmb3IgV2ViR0wuXG4gKi9cblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1hcE9wdGlvbnNJbnRlcm5hbFxuICogQHByb3BlcnR5IHtDb2xsZWN0aW9uPGltcG9ydChcIi4vY29udHJvbC9Db250cm9sLmpzXCIpLmRlZmF1bHQ+fSBbY29udHJvbHNdXG4gKiBAcHJvcGVydHkge0NvbGxlY3Rpb248aW1wb3J0KFwiLi9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbi5qc1wiKS5kZWZhdWx0Pn0gW2ludGVyYWN0aW9uc11cbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR8RG9jdW1lbnR9IGtleWJvYXJkRXZlbnRUYXJnZXRcbiAqIEBwcm9wZXJ0eSB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuL092ZXJsYXkuanNcIikuZGVmYXVsdD59IG92ZXJsYXlzXG4gKiBAcHJvcGVydHkge09iamVjdDxzdHJpbmcsICo+fSB2YWx1ZXNcbiAqL1xuXG5cbi8qKlxuICogT2JqZWN0IGxpdGVyYWwgd2l0aCBjb25maWcgb3B0aW9ucyBmb3IgdGhlIG1hcC5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1hcE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuL2NvbnRyb2wvQ29udHJvbC5qc1wiKS5kZWZhdWx0PnxBcnJheTxpbXBvcnQoXCIuL2NvbnRyb2wvQ29udHJvbC5qc1wiKS5kZWZhdWx0Pn0gW2NvbnRyb2xzXVxuICogQ29udHJvbHMgaW5pdGlhbGx5IGFkZGVkIHRvIHRoZSBtYXAuIElmIG5vdCBzcGVjaWZpZWQsXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2NvbnRyb2x+ZGVmYXVsdHN9IGlzIHVzZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3BpeGVsUmF0aW89d2luZG93LmRldmljZVBpeGVsUmF0aW9dIFRoZSByYXRpbyBiZXR3ZWVuXG4gKiBwaHlzaWNhbCBwaXhlbHMgYW5kIGRldmljZS1pbmRlcGVuZGVudCBwaXhlbHMgKGRpcHMpIG9uIHRoZSBkZXZpY2UuXG4gKiBAcHJvcGVydHkge0NvbGxlY3Rpb248aW1wb3J0KFwiLi9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbi5qc1wiKS5kZWZhdWx0PnxBcnJheTxpbXBvcnQoXCIuL2ludGVyYWN0aW9uL0ludGVyYWN0aW9uLmpzXCIpLmRlZmF1bHQ+fSBbaW50ZXJhY3Rpb25zXVxuICogSW50ZXJhY3Rpb25zIHRoYXQgYXJlIGluaXRpYWxseSBhZGRlZCB0byB0aGUgbWFwLiBJZiBub3Qgc3BlY2lmaWVkLFxuICoge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbn5kZWZhdWx0c30gaXMgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR8RG9jdW1lbnR8c3RyaW5nfSBba2V5Ym9hcmRFdmVudFRhcmdldF0gVGhlIGVsZW1lbnQgdG9cbiAqIGxpc3RlbiB0byBrZXlib2FyZCBldmVudHMgb24uIFRoaXMgZGV0ZXJtaW5lcyB3aGVuIHRoZSBgS2V5Ym9hcmRQYW5gIGFuZFxuICogYEtleWJvYXJkWm9vbWAgaW50ZXJhY3Rpb25zIHRyaWdnZXIuIEZvciBleGFtcGxlLCBpZiB0aGlzIG9wdGlvbiBpcyBzZXQgdG9cbiAqIGBkb2N1bWVudGAgdGhlIGtleWJvYXJkIGludGVyYWN0aW9ucyB3aWxsIGFsd2F5cyB0cmlnZ2VyLiBJZiB0aGlzIG9wdGlvbiBpc1xuICogbm90IHNwZWNpZmllZCwgdGhlIGVsZW1lbnQgdGhlIGxpYnJhcnkgbGlzdGVucyB0byBrZXlib2FyZCBldmVudHMgb24gaXMgdGhlXG4gKiBtYXAgdGFyZ2V0IChpLmUuIHRoZSB1c2VyLXByb3ZpZGVkIGRpdiBmb3IgdGhlIG1hcCkuIElmIHRoaXMgaXMgbm90XG4gKiBgZG9jdW1lbnRgLCB0aGUgdGFyZ2V0IGVsZW1lbnQgbmVlZHMgdG8gYmUgZm9jdXNlZCBmb3Iga2V5IGV2ZW50cyB0byBiZVxuICogZW1pdHRlZCwgcmVxdWlyaW5nIHRoYXQgdGhlIHRhcmdldCBlbGVtZW50IGhhcyBhIGB0YWJpbmRleGAgYXR0cmlidXRlLlxuICogQHByb3BlcnR5IHtBcnJheTxpbXBvcnQoXCIuL2xheWVyL0Jhc2UuanNcIikuZGVmYXVsdD58Q29sbGVjdGlvbjxpbXBvcnQoXCIuL2xheWVyL0Jhc2UuanNcIikuZGVmYXVsdD58TGF5ZXJHcm91cH0gW2xheWVyc11cbiAqIExheWVycy4gSWYgdGhpcyBpcyBub3QgZGVmaW5lZCwgYSBtYXAgd2l0aCBubyBsYXllcnMgd2lsbCBiZSByZW5kZXJlZC4gTm90ZVxuICogdGhhdCBsYXllcnMgYXJlIHJlbmRlcmVkIGluIHRoZSBvcmRlciBzdXBwbGllZCwgc28gaWYgeW91IHdhbnQsIGZvciBleGFtcGxlLFxuICogYSB2ZWN0b3IgbGF5ZXIgdG8gYXBwZWFyIG9uIHRvcCBvZiBhIHRpbGUgbGF5ZXIsIGl0IG11c3QgY29tZSBhZnRlciB0aGUgdGlsZVxuICogbGF5ZXIuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFRpbGVzTG9hZGluZz0xNl0gTWF4aW11bSBudW1iZXIgdGlsZXMgdG8gbG9hZFxuICogc2ltdWx0YW5lb3VzbHkuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtsb2FkVGlsZXNXaGlsZUFuaW1hdGluZz1mYWxzZV0gV2hlbiBzZXQgdG8gYHRydWVgLCB0aWxlc1xuICogd2lsbCBiZSBsb2FkZWQgZHVyaW5nIGFuaW1hdGlvbnMuIFRoaXMgbWF5IGltcHJvdmUgdGhlIHVzZXIgZXhwZXJpZW5jZSwgYnV0XG4gKiBjYW4gYWxzbyBtYWtlIGFuaW1hdGlvbnMgc3R1dHRlciBvbiBkZXZpY2VzIHdpdGggc2xvdyBtZW1vcnkuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtsb2FkVGlsZXNXaGlsZUludGVyYWN0aW5nPWZhbHNlXSBXaGVuIHNldCB0byBgdHJ1ZWAsXG4gKiB0aWxlcyB3aWxsIGJlIGxvYWRlZCB3aGlsZSBpbnRlcmFjdGluZyB3aXRoIHRoZSBtYXAuIFRoaXMgbWF5IGltcHJvdmUgdGhlXG4gKiB1c2VyIGV4cGVyaWVuY2UsIGJ1dCBjYW4gYWxzbyBtYWtlIG1hcCBwYW5uaW5nIGFuZCB6b29taW5nIGNob3BweSBvbiBkZXZpY2VzXG4gKiB3aXRoIHNsb3cgbWVtb3J5LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttb3ZlVG9sZXJhbmNlPTFdIFRoZSBtaW5pbXVtIGRpc3RhbmNlIGluIHBpeGVscyB0aGVcbiAqIGN1cnNvciBtdXN0IG1vdmUgdG8gYmUgZGV0ZWN0ZWQgYXMgYSBtYXAgbW92ZSBldmVudCBpbnN0ZWFkIG9mIGEgY2xpY2suXG4gKiBJbmNyZWFzaW5nIHRoaXMgdmFsdWUgY2FuIG1ha2UgaXQgZWFzaWVyIHRvIGNsaWNrIG9uIHRoZSBtYXAuXG4gKiBAcHJvcGVydHkge0NvbGxlY3Rpb248aW1wb3J0KFwiLi9PdmVybGF5LmpzXCIpLmRlZmF1bHQ+fEFycmF5PGltcG9ydChcIi4vT3ZlcmxheS5qc1wiKS5kZWZhdWx0Pn0gW292ZXJsYXlzXVxuICogT3ZlcmxheXMgaW5pdGlhbGx5IGFkZGVkIHRvIHRoZSBtYXAuIEJ5IGRlZmF1bHQsIG5vIG92ZXJsYXlzIGFyZSBhZGRlZC5cbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR8c3RyaW5nfSBbdGFyZ2V0XSBUaGUgY29udGFpbmVyIGZvciB0aGUgbWFwLCBlaXRoZXIgdGhlXG4gKiBlbGVtZW50IGl0c2VsZiBvciB0aGUgYGlkYCBvZiB0aGUgZWxlbWVudC4gSWYgbm90IHNwZWNpZmllZCBhdCBjb25zdHJ1Y3Rpb25cbiAqIHRpbWUsIHtAbGluayBtb2R1bGU6b2wvTWFwfk1hcCNzZXRUYXJnZXR9IG11c3QgYmUgY2FsbGVkIGZvciB0aGUgbWFwIHRvIGJlXG4gKiByZW5kZXJlZC5cbiAqIEBwcm9wZXJ0eSB7Vmlld30gW3ZpZXddIFRoZSBtYXAncyB2aWV3LiAgTm8gbGF5ZXIgc291cmNlcyB3aWxsIGJlXG4gKiBmZXRjaGVkIHVubGVzcyB0aGlzIGlzIHNwZWNpZmllZCBhdCBjb25zdHJ1Y3Rpb24gdGltZSBvciB0aHJvdWdoXG4gKiB7QGxpbmsgbW9kdWxlOm9sL01hcH5NYXAjc2V0Vmlld30uXG4gKi9cblxuXG4vKipcbiAqIEBmaXJlcyBpbXBvcnQoXCIuL01hcEJyb3dzZXJFdmVudC5qc1wiKS5NYXBCcm93c2VyRXZlbnRcbiAqIEBmaXJlcyBpbXBvcnQoXCIuL01hcEV2ZW50LmpzXCIpLk1hcEV2ZW50XG4gKiBAZmlyZXMgbW9kdWxlOm9sL3JlbmRlci9FdmVudH5SZW5kZXJFdmVudCNwb3N0Y29tcG9zZVxuICogQGZpcmVzIG1vZHVsZTpvbC9yZW5kZXIvRXZlbnR+UmVuZGVyRXZlbnQjcHJlY29tcG9zZVxuICogQGZpcmVzIG1vZHVsZTpvbC9yZW5kZXIvRXZlbnR+UmVuZGVyRXZlbnQjcmVuZGVyY29tcGxldGVcbiAqIEBhcGlcbiAqL1xudmFyIFBsdWdnYWJsZU1hcCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEJhc2VPYmplY3QpIHtcbiAgZnVuY3Rpb24gUGx1Z2dhYmxlTWFwKG9wdGlvbnMpIHtcblxuICAgIEJhc2VPYmplY3QuY2FsbCh0aGlzKTtcblxuICAgIHZhciBvcHRpb25zSW50ZXJuYWwgPSBjcmVhdGVPcHRpb25zSW50ZXJuYWwob3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5tYXhUaWxlc0xvYWRpbmdfID0gb3B0aW9ucy5tYXhUaWxlc0xvYWRpbmcgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubWF4VGlsZXNMb2FkaW5nIDogMTY7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubG9hZFRpbGVzV2hpbGVBbmltYXRpbmdfID1cbiAgICAgICAgb3B0aW9ucy5sb2FkVGlsZXNXaGlsZUFuaW1hdGluZyAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICBvcHRpb25zLmxvYWRUaWxlc1doaWxlQW5pbWF0aW5nIDogZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubG9hZFRpbGVzV2hpbGVJbnRlcmFjdGluZ18gPVxuICAgICAgICBvcHRpb25zLmxvYWRUaWxlc1doaWxlSW50ZXJhY3RpbmcgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgb3B0aW9ucy5sb2FkVGlsZXNXaGlsZUludGVyYWN0aW5nIDogZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5waXhlbFJhdGlvXyA9IG9wdGlvbnMucGl4ZWxSYXRpbyAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdGlvbnMucGl4ZWxSYXRpbyA6IERFVklDRV9QSVhFTF9SQVRJTztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5hbmltYXRpb25EZWxheUtleV87XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuYW5pbWF0aW9uRGVsYXlfID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvbkRlbGF5S2V5XyA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMucmVuZGVyRnJhbWVfLmNhbGwodGhpcywgRGF0ZS5ub3coKSk7XG4gICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfVxuICAgICAqL1xuICAgIHRoaXMuY29vcmRpbmF0ZVRvUGl4ZWxUcmFuc2Zvcm1fID0gY3JlYXRlVHJhbnNmb3JtKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19XG4gICAgICovXG4gICAgdGhpcy5waXhlbFRvQ29vcmRpbmF0ZVRyYW5zZm9ybV8gPSBjcmVhdGVUcmFuc2Zvcm0oKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmZyYW1lSW5kZXhfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9GcmFtZVN0YXRlfVxuICAgICAqL1xuICAgIHRoaXMuZnJhbWVTdGF0ZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGV4dGVudCBhdCB0aGUgcHJldmlvdXMgJ21vdmVlbmQnIGV2ZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAgICAgKi9cbiAgICB0aGlzLnByZXZpb3VzRXh0ZW50XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi9ldmVudHMuanNcIikuRXZlbnRzS2V5fVxuICAgICAqL1xuICAgIHRoaXMudmlld1Byb3BlcnR5TGlzdGVuZXJLZXlfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXl9XG4gICAgICovXG4gICAgdGhpcy52aWV3Q2hhbmdlTGlzdGVuZXJLZXlfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PGltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5sYXllckdyb3VwUHJvcGVydHlMaXN0ZW5lcktleXNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLnZpZXdwb3J0XyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMudmlld3BvcnRfLmNsYXNzTmFtZSA9ICdvbC12aWV3cG9ydCcgKyAoVE9VQ0ggPyAnIG9sLXRvdWNoJyA6ICcnKTtcbiAgICB0aGlzLnZpZXdwb3J0Xy5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgdGhpcy52aWV3cG9ydF8uc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICB0aGlzLnZpZXdwb3J0Xy5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICB0aGlzLnZpZXdwb3J0Xy5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgLy8gcHJldmVudCBwYWdlIHpvb20gb24gSUUgPj0gMTAgYnJvd3NlcnNcbiAgICB0aGlzLnZpZXdwb3J0Xy5zdHlsZS5tc1RvdWNoQWN0aW9uID0gJ25vbmUnO1xuICAgIHRoaXMudmlld3BvcnRfLnN0eWxlLnRvdWNoQWN0aW9uID0gJ25vbmUnO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IUhUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMub3ZlcmxheUNvbnRhaW5lcl8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLm92ZXJsYXlDb250YWluZXJfLmNsYXNzTmFtZSA9ICdvbC1vdmVybGF5Y29udGFpbmVyJztcbiAgICB0aGlzLnZpZXdwb3J0Xy5hcHBlbmRDaGlsZCh0aGlzLm92ZXJsYXlDb250YWluZXJfKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLm92ZXJsYXlDb250YWluZXJTdG9wRXZlbnRfID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5vdmVybGF5Q29udGFpbmVyU3RvcEV2ZW50Xy5jbGFzc05hbWUgPSAnb2wtb3ZlcmxheWNvbnRhaW5lci1zdG9wZXZlbnQnO1xuICAgIHZhciBvdmVybGF5RXZlbnRzID0gW1xuICAgICAgRXZlbnRUeXBlLkNMSUNLLFxuICAgICAgRXZlbnRUeXBlLkRCTENMSUNLLFxuICAgICAgRXZlbnRUeXBlLk1PVVNFRE9XTixcbiAgICAgIEV2ZW50VHlwZS5UT1VDSFNUQVJULFxuICAgICAgRXZlbnRUeXBlLk1TUE9JTlRFUkRPV04sXG4gICAgICBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJET1dOLFxuICAgICAgRXZlbnRUeXBlLk1PVVNFV0hFRUwsXG4gICAgICBFdmVudFR5cGUuV0hFRUxcbiAgICBdO1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IG92ZXJsYXlFdmVudHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgbGlzdGVuKHRoaXMub3ZlcmxheUNvbnRhaW5lclN0b3BFdmVudF8sIG92ZXJsYXlFdmVudHNbaV0sIHN0b3BQcm9wYWdhdGlvbik7XG4gICAgfVxuICAgIHRoaXMudmlld3BvcnRfLmFwcGVuZENoaWxkKHRoaXMub3ZlcmxheUNvbnRhaW5lclN0b3BFdmVudF8pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7TWFwQnJvd3NlckV2ZW50SGFuZGxlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1hcEJyb3dzZXJFdmVudEhhbmRsZXJfID0gbmV3IE1hcEJyb3dzZXJFdmVudEhhbmRsZXIodGhpcywgb3B0aW9ucy5tb3ZlVG9sZXJhbmNlKTtcbiAgICBmb3IgKHZhciBrZXkgaW4gTWFwQnJvd3NlckV2ZW50VHlwZSkge1xuICAgICAgbGlzdGVuKHRoaXMubWFwQnJvd3NlckV2ZW50SGFuZGxlcl8sIE1hcEJyb3dzZXJFdmVudFR5cGVba2V5XSxcbiAgICAgICAgdGhpcy5oYW5kbGVNYXBCcm93c2VyRXZlbnQsIHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fERvY3VtZW50fVxuICAgICAqL1xuICAgIHRoaXMua2V5Ym9hcmRFdmVudFRhcmdldF8gPSBvcHRpb25zSW50ZXJuYWwua2V5Ym9hcmRFdmVudFRhcmdldDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PGltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5rZXlIYW5kbGVyS2V5c18gPSBudWxsO1xuXG4gICAgbGlzdGVuKHRoaXMudmlld3BvcnRfLCBFdmVudFR5cGUuQ09OVEVYVE1FTlUsIHRoaXMuaGFuZGxlQnJvd3NlckV2ZW50LCB0aGlzKTtcbiAgICBsaXN0ZW4odGhpcy52aWV3cG9ydF8sIEV2ZW50VHlwZS5XSEVFTCwgdGhpcy5oYW5kbGVCcm93c2VyRXZlbnQsIHRoaXMpO1xuICAgIGxpc3Rlbih0aGlzLnZpZXdwb3J0XywgRXZlbnRUeXBlLk1PVVNFV0hFRUwsIHRoaXMuaGFuZGxlQnJvd3NlckV2ZW50LCB0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtDb2xsZWN0aW9uPGltcG9ydChcIi4vY29udHJvbC9Db250cm9sLmpzXCIpLmRlZmF1bHQ+fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0aGlzLmNvbnRyb2xzID0gb3B0aW9uc0ludGVybmFsLmNvbnRyb2xzIHx8IG5ldyBDb2xsZWN0aW9uKCk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuL2ludGVyYWN0aW9uL0ludGVyYWN0aW9uLmpzXCIpLmRlZmF1bHQ+fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0aGlzLmludGVyYWN0aW9ucyA9IG9wdGlvbnNJbnRlcm5hbC5pbnRlcmFjdGlvbnMgfHwgbmV3IENvbGxlY3Rpb24oKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtDb2xsZWN0aW9uPGltcG9ydChcIi4vT3ZlcmxheS5qc1wiKS5kZWZhdWx0Pn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMub3ZlcmxheXNfID0gb3B0aW9uc0ludGVybmFsLm92ZXJsYXlzO1xuXG4gICAgLyoqXG4gICAgICogQSBsb29rdXAgb2Ygb3ZlcmxheXMgYnkgaWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi9PdmVybGF5LmpzXCIpLmRlZmF1bHQ+fVxuICAgICAqL1xuICAgIHRoaXMub3ZlcmxheUlkSW5kZXhfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9yZW5kZXJlci9NYXAuanNcIikuZGVmYXVsdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZXJfID0gdGhpcy5jcmVhdGVSZW5kZXJlcigpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKEV2ZW50KXx1bmRlZmluZWR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmhhbmRsZVJlc2l6ZV87XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLmZvY3VzXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshQXJyYXk8UG9zdFJlbmRlckZ1bmN0aW9uPn1cbiAgICAgKi9cbiAgICB0aGlzLnBvc3RSZW5kZXJGdW5jdGlvbnNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtUaWxlUXVldWV9XG4gICAgICovXG4gICAgdGhpcy50aWxlUXVldWVfID0gbmV3IFRpbGVRdWV1ZShcbiAgICAgIHRoaXMuZ2V0VGlsZVByaW9yaXR5LmJpbmQodGhpcyksXG4gICAgICB0aGlzLmhhbmRsZVRpbGVDaGFuZ2VfLmJpbmQodGhpcykpO1xuXG4gICAgLyoqXG4gICAgICogVWlkcyBvZiBmZWF0dXJlcyB0byBza2lwIGF0IHJlbmRlcmluZyB0aW1lLlxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBib29sZWFuPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc2tpcHBlZEZlYXR1cmVVaWRzXyA9IHt9O1xuXG4gICAgbGlzdGVuKFxuICAgICAgdGhpcywgZ2V0Q2hhbmdlRXZlbnRUeXBlKE1hcFByb3BlcnR5LkxBWUVSR1JPVVApLFxuICAgICAgdGhpcy5oYW5kbGVMYXllckdyb3VwQ2hhbmdlZF8sIHRoaXMpO1xuICAgIGxpc3Rlbih0aGlzLCBnZXRDaGFuZ2VFdmVudFR5cGUoTWFwUHJvcGVydHkuVklFVyksXG4gICAgICB0aGlzLmhhbmRsZVZpZXdDaGFuZ2VkXywgdGhpcyk7XG4gICAgbGlzdGVuKHRoaXMsIGdldENoYW5nZUV2ZW50VHlwZShNYXBQcm9wZXJ0eS5TSVpFKSxcbiAgICAgIHRoaXMuaGFuZGxlU2l6ZUNoYW5nZWRfLCB0aGlzKTtcbiAgICBsaXN0ZW4odGhpcywgZ2V0Q2hhbmdlRXZlbnRUeXBlKE1hcFByb3BlcnR5LlRBUkdFVCksXG4gICAgICB0aGlzLmhhbmRsZVRhcmdldENoYW5nZWRfLCB0aGlzKTtcblxuICAgIC8vIHNldFByb3BlcnRpZXMgd2lsbCB0cmlnZ2VyIHRoZSByZW5kZXJpbmcgb2YgdGhlIG1hcCBpZiB0aGUgbWFwXG4gICAgLy8gaXMgXCJkZWZpbmVkXCIgYWxyZWFkeS5cbiAgICB0aGlzLnNldFByb3BlcnRpZXMob3B0aW9uc0ludGVybmFsLnZhbHVlcyk7XG5cbiAgICB0aGlzLmNvbnRyb2xzLmZvckVhY2goXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb250cm9sL0NvbnRyb2wuanNcIikuZGVmYXVsdH0gY29udHJvbCBDb250cm9sLlxuICAgICAgICogQHRoaXMge1BsdWdnYWJsZU1hcH1cbiAgICAgICAqL1xuICAgICAgKGZ1bmN0aW9uKGNvbnRyb2wpIHtcbiAgICAgICAgY29udHJvbC5zZXRNYXAodGhpcyk7XG4gICAgICB9KS5iaW5kKHRoaXMpKTtcblxuICAgIGxpc3Rlbih0aGlzLmNvbnRyb2xzLCBDb2xsZWN0aW9uRXZlbnRUeXBlLkFERCxcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0NvbGxlY3Rpb24uanNcIikuQ29sbGVjdGlvbkV2ZW50fSBldmVudCBDb2xsZWN0aW9uRXZlbnQuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LmVsZW1lbnQuc2V0TWFwKHRoaXMpO1xuICAgICAgfSwgdGhpcyk7XG5cbiAgICBsaXN0ZW4odGhpcy5jb250cm9scywgQ29sbGVjdGlvbkV2ZW50VHlwZS5SRU1PVkUsXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9Db2xsZWN0aW9uLmpzXCIpLkNvbGxlY3Rpb25FdmVudH0gZXZlbnQgQ29sbGVjdGlvbkV2ZW50LlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBldmVudC5lbGVtZW50LnNldE1hcChudWxsKTtcbiAgICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5pbnRlcmFjdGlvbnMuZm9yRWFjaChcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2ludGVyYWN0aW9uL0ludGVyYWN0aW9uLmpzXCIpLmRlZmF1bHR9IGludGVyYWN0aW9uIEludGVyYWN0aW9uLlxuICAgICAgICogQHRoaXMge1BsdWdnYWJsZU1hcH1cbiAgICAgICAqL1xuICAgICAgKGZ1bmN0aW9uKGludGVyYWN0aW9uKSB7XG4gICAgICAgIGludGVyYWN0aW9uLnNldE1hcCh0aGlzKTtcbiAgICAgIH0pLmJpbmQodGhpcykpO1xuXG4gICAgbGlzdGVuKHRoaXMuaW50ZXJhY3Rpb25zLCBDb2xsZWN0aW9uRXZlbnRUeXBlLkFERCxcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0NvbGxlY3Rpb24uanNcIikuQ29sbGVjdGlvbkV2ZW50fSBldmVudCBDb2xsZWN0aW9uRXZlbnQuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LmVsZW1lbnQuc2V0TWFwKHRoaXMpO1xuICAgICAgfSwgdGhpcyk7XG5cbiAgICBsaXN0ZW4odGhpcy5pbnRlcmFjdGlvbnMsIENvbGxlY3Rpb25FdmVudFR5cGUuUkVNT1ZFLFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vQ29sbGVjdGlvbi5qc1wiKS5Db2xsZWN0aW9uRXZlbnR9IGV2ZW50IENvbGxlY3Rpb25FdmVudC5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgZXZlbnQuZWxlbWVudC5zZXRNYXAobnVsbCk7XG4gICAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMub3ZlcmxheXNfLmZvckVhY2godGhpcy5hZGRPdmVybGF5SW50ZXJuYWxfLmJpbmQodGhpcykpO1xuXG4gICAgbGlzdGVuKHRoaXMub3ZlcmxheXNfLCBDb2xsZWN0aW9uRXZlbnRUeXBlLkFERCxcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0NvbGxlY3Rpb24uanNcIikuQ29sbGVjdGlvbkV2ZW50fSBldmVudCBDb2xsZWN0aW9uRXZlbnQuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuYWRkT3ZlcmxheUludGVybmFsXygvKiogQHR5cGUge2ltcG9ydChcIi4vT3ZlcmxheS5qc1wiKS5kZWZhdWx0fSAqLyAoZXZlbnQuZWxlbWVudCkpO1xuICAgICAgfSwgdGhpcyk7XG5cbiAgICBsaXN0ZW4odGhpcy5vdmVybGF5c18sIENvbGxlY3Rpb25FdmVudFR5cGUuUkVNT1ZFLFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vQ29sbGVjdGlvbi5qc1wiKS5Db2xsZWN0aW9uRXZlbnR9IGV2ZW50IENvbGxlY3Rpb25FdmVudC5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIG92ZXJsYXkgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vT3ZlcmxheS5qc1wiKS5kZWZhdWx0fSAqLyAoZXZlbnQuZWxlbWVudCk7XG4gICAgICAgIHZhciBpZCA9IG92ZXJsYXkuZ2V0SWQoKTtcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5vdmVybGF5SWRJbmRleF9baWQudG9TdHJpbmcoKV07XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQuZWxlbWVudC5zZXRNYXAobnVsbCk7XG4gICAgICB9LCB0aGlzKTtcblxuICB9XG5cbiAgaWYgKCBCYXNlT2JqZWN0ICkgUGx1Z2dhYmxlTWFwLl9fcHJvdG9fXyA9IEJhc2VPYmplY3Q7XG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCYXNlT2JqZWN0ICYmIEJhc2VPYmplY3QucHJvdG90eXBlICk7XG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQbHVnZ2FibGVNYXA7XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL3JlbmRlcmVyL01hcC5qc1wiKS5kZWZhdWx0fSBUaGUgbWFwIHJlbmRlcmVyXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLmNyZWF0ZVJlbmRlcmVyID0gZnVuY3Rpb24gY3JlYXRlUmVuZGVyZXIgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVXNlIGEgbWFwIHR5cGUgdGhhdCBoYXMgYSBjcmVhdGVSZW5kZXJlciBtZXRob2QnKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIHRoZSBnaXZlbiBjb250cm9sIHRvIHRoZSBtYXAuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb250cm9sL0NvbnRyb2wuanNcIikuZGVmYXVsdH0gY29udHJvbCBDb250cm9sLlxuICAgKiBAYXBpXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLmFkZENvbnRyb2wgPSBmdW5jdGlvbiBhZGRDb250cm9sIChjb250cm9sKSB7XG4gICAgdGhpcy5nZXRDb250cm9scygpLnB1c2goY29udHJvbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCB0aGUgZ2l2ZW4gaW50ZXJhY3Rpb24gdG8gdGhlIG1hcC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2ludGVyYWN0aW9uL0ludGVyYWN0aW9uLmpzXCIpLmRlZmF1bHR9IGludGVyYWN0aW9uIEludGVyYWN0aW9uIHRvIGFkZC5cbiAgICogQGFwaVxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5hZGRJbnRlcmFjdGlvbiA9IGZ1bmN0aW9uIGFkZEludGVyYWN0aW9uIChpbnRlcmFjdGlvbikge1xuICAgIHRoaXMuZ2V0SW50ZXJhY3Rpb25zKCkucHVzaChpbnRlcmFjdGlvbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIGdpdmVuIGxheWVyIHRvIHRoZSB0b3Agb2YgdGhpcyBtYXAuIElmIHlvdSB3YW50IHRvIGFkZCBhIGxheWVyXG4gICAqIGVsc2V3aGVyZSBpbiB0aGUgc3RhY2ssIHVzZSBgZ2V0TGF5ZXJzKClgIGFuZCB0aGUgbWV0aG9kcyBhdmFpbGFibGUgb25cbiAgICoge0BsaW5rIG1vZHVsZTpvbC9Db2xsZWN0aW9ufkNvbGxlY3Rpb259LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vbGF5ZXIvQmFzZS5qc1wiKS5kZWZhdWx0fSBsYXllciBMYXllci5cbiAgICogQGFwaVxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5hZGRMYXllciA9IGZ1bmN0aW9uIGFkZExheWVyIChsYXllcikge1xuICAgIHZhciBsYXllcnMgPSB0aGlzLmdldExheWVyR3JvdXAoKS5nZXRMYXllcnMoKTtcbiAgICBsYXllcnMucHVzaChsYXllcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCB0aGUgZ2l2ZW4gb3ZlcmxheSB0byB0aGUgbWFwLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vT3ZlcmxheS5qc1wiKS5kZWZhdWx0fSBvdmVybGF5IE92ZXJsYXkuXG4gICAqIEBhcGlcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuYWRkT3ZlcmxheSA9IGZ1bmN0aW9uIGFkZE92ZXJsYXkgKG92ZXJsYXkpIHtcbiAgICB0aGlzLmdldE92ZXJsYXlzKCkucHVzaChvdmVybGF5KTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBkZWFscyB3aXRoIG1hcCdzIG92ZXJsYXkgY29sbGVjdGlvbiBjaGFuZ2VzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vT3ZlcmxheS5qc1wiKS5kZWZhdWx0fSBvdmVybGF5IE92ZXJsYXkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLmFkZE92ZXJsYXlJbnRlcm5hbF8gPSBmdW5jdGlvbiBhZGRPdmVybGF5SW50ZXJuYWxfIChvdmVybGF5KSB7XG4gICAgdmFyIGlkID0gb3ZlcmxheS5nZXRJZCgpO1xuICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm92ZXJsYXlJZEluZGV4X1tpZC50b1N0cmluZygpXSA9IG92ZXJsYXk7XG4gICAgfVxuICAgIG92ZXJsYXkuc2V0TWFwKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5kaXNwb3NlSW50ZXJuYWwgPSBmdW5jdGlvbiBkaXNwb3NlSW50ZXJuYWwgKCkge1xuICAgIHRoaXMubWFwQnJvd3NlckV2ZW50SGFuZGxlcl8uZGlzcG9zZSgpO1xuICAgIHVubGlzdGVuKHRoaXMudmlld3BvcnRfLCBFdmVudFR5cGUuQ09OVEVYVE1FTlUsIHRoaXMuaGFuZGxlQnJvd3NlckV2ZW50LCB0aGlzKTtcbiAgICB1bmxpc3Rlbih0aGlzLnZpZXdwb3J0XywgRXZlbnRUeXBlLldIRUVMLCB0aGlzLmhhbmRsZUJyb3dzZXJFdmVudCwgdGhpcyk7XG4gICAgdW5saXN0ZW4odGhpcy52aWV3cG9ydF8sIEV2ZW50VHlwZS5NT1VTRVdIRUVMLCB0aGlzLmhhbmRsZUJyb3dzZXJFdmVudCwgdGhpcyk7XG4gICAgaWYgKHRoaXMuaGFuZGxlUmVzaXplXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKEV2ZW50VHlwZS5SRVNJWkUsIHRoaXMuaGFuZGxlUmVzaXplXywgZmFsc2UpO1xuICAgICAgdGhpcy5oYW5kbGVSZXNpemVfID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodGhpcy5hbmltYXRpb25EZWxheUtleV8pIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uRGVsYXlLZXlfKTtcbiAgICAgIHRoaXMuYW5pbWF0aW9uRGVsYXlLZXlfID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB0aGlzLnNldFRhcmdldChudWxsKTtcbiAgICBCYXNlT2JqZWN0LnByb3RvdHlwZS5kaXNwb3NlSW50ZXJuYWwuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogRGV0ZWN0IGZlYXR1cmVzIHRoYXQgaW50ZXJzZWN0IGEgcGl4ZWwgb24gdGhlIHZpZXdwb3J0LCBhbmQgZXhlY3V0ZSBhXG4gICAqIGNhbGxiYWNrIHdpdGggZWFjaCBpbnRlcnNlY3RpbmcgZmVhdHVyZS4gTGF5ZXJzIGluY2x1ZGVkIGluIHRoZSBkZXRlY3Rpb24gY2FuXG4gICAqIGJlIGNvbmZpZ3VyZWQgdGhyb3VnaCB0aGUgYGxheWVyRmlsdGVyYCBvcHRpb24gaW4gYG9wdF9vcHRpb25zYC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3BpeGVsLmpzXCIpLlBpeGVsfSBwaXhlbCBQaXhlbC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBTLCBpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2UsXG4gICAqICAgICBpbXBvcnQoXCIuL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHQpOiBUfSBjYWxsYmFjayBGZWF0dXJlIGNhbGxiYWNrLiBUaGUgY2FsbGJhY2sgd2lsbCBiZVxuICAgKiAgICAgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50cy4gVGhlIGZpcnN0IGFyZ3VtZW50IGlzIG9uZVxuICAgKiAgICAge0BsaW5rIG1vZHVsZTpvbC9GZWF0dXJlIGZlYXR1cmV9IG9yXG4gICAqICAgICB7QGxpbmsgbW9kdWxlOm9sL3JlbmRlci9GZWF0dXJlIHJlbmRlciBmZWF0dXJlfSBhdCB0aGUgcGl4ZWwsIHRoZSBzZWNvbmQgaXNcbiAgICogICAgIHRoZSB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL0xheWVyIGxheWVyfSBvZiB0aGUgZmVhdHVyZSBhbmQgd2lsbCBiZSBudWxsIGZvclxuICAgKiAgICAgdW5tYW5hZ2VkIGxheWVycy4gVG8gc3RvcCBkZXRlY3Rpb24sIGNhbGxiYWNrIGZ1bmN0aW9ucyBjYW4gcmV0dXJuIGFcbiAgICogICAgIHRydXRoeSB2YWx1ZS5cbiAgICogQHBhcmFtIHtBdFBpeGVsT3B0aW9ucz19IG9wdF9vcHRpb25zIE9wdGlvbmFsIG9wdGlvbnMuXG4gICAqIEByZXR1cm4ge1R8dW5kZWZpbmVkfSBDYWxsYmFjayByZXN1bHQsIGkuZS4gdGhlIHJldHVybiB2YWx1ZSBvZiBsYXN0XG4gICAqIGNhbGxiYWNrIGV4ZWN1dGlvbiwgb3IgdGhlIGZpcnN0IHRydXRoeSBjYWxsYmFjayByZXR1cm4gdmFsdWUuXG4gICAqIEB0ZW1wbGF0ZSBTLFRcbiAgICogQGFwaVxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5mb3JFYWNoRmVhdHVyZUF0UGl4ZWwgPSBmdW5jdGlvbiBmb3JFYWNoRmVhdHVyZUF0UGl4ZWwgKHBpeGVsLCBjYWxsYmFjaywgb3B0X29wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuZnJhbWVTdGF0ZV8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNvb3JkaW5hdGUgPSB0aGlzLmdldENvb3JkaW5hdGVGcm9tUGl4ZWwocGl4ZWwpO1xuICAgIG9wdF9vcHRpb25zID0gb3B0X29wdGlvbnMgIT09IHVuZGVmaW5lZCA/IG9wdF9vcHRpb25zIDpcbiAgICAgIC8qKiBAdHlwZSB7QXRQaXhlbE9wdGlvbnN9ICovICh7fSk7XG4gICAgdmFyIGhpdFRvbGVyYW5jZSA9IG9wdF9vcHRpb25zLmhpdFRvbGVyYW5jZSAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdF9vcHRpb25zLmhpdFRvbGVyYW5jZSAqIHRoaXMuZnJhbWVTdGF0ZV8ucGl4ZWxSYXRpbyA6IDA7XG4gICAgdmFyIGxheWVyRmlsdGVyID0gb3B0X29wdGlvbnMubGF5ZXJGaWx0ZXIgIT09IHVuZGVmaW5lZCA/XG4gICAgICBvcHRfb3B0aW9ucy5sYXllckZpbHRlciA6IFRSVUU7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZXJfLmZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlKFxuICAgICAgY29vcmRpbmF0ZSwgdGhpcy5mcmFtZVN0YXRlXywgaGl0VG9sZXJhbmNlLCBjYWxsYmFjaywgbnVsbCxcbiAgICAgIGxheWVyRmlsdGVyLCBudWxsKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGFsbCBmZWF0dXJlcyB0aGF0IGludGVyc2VjdCBhIHBpeGVsIG9uIHRoZSB2aWV3cG9ydC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3BpeGVsLmpzXCIpLlBpeGVsfSBwaXhlbCBQaXhlbC5cbiAgICogQHBhcmFtIHtBdFBpeGVsT3B0aW9ucz19IG9wdF9vcHRpb25zIE9wdGlvbmFsIG9wdGlvbnMuXG4gICAqIEByZXR1cm4ge0FycmF5PGltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZT59IFRoZSBkZXRlY3RlZCBmZWF0dXJlcyBvclxuICAgKiBgbnVsbGAgaWYgbm9uZSB3ZXJlIGZvdW5kLlxuICAgKiBAYXBpXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLmdldEZlYXR1cmVzQXRQaXhlbCA9IGZ1bmN0aW9uIGdldEZlYXR1cmVzQXRQaXhlbCAocGl4ZWwsIG9wdF9vcHRpb25zKSB7XG4gICAgdmFyIGZlYXR1cmVzID0gbnVsbDtcbiAgICB0aGlzLmZvckVhY2hGZWF0dXJlQXRQaXhlbChwaXhlbCwgZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgICAgaWYgKCFmZWF0dXJlcykge1xuICAgICAgICBmZWF0dXJlcyA9IFtdO1xuICAgICAgfVxuICAgICAgZmVhdHVyZXMucHVzaChmZWF0dXJlKTtcbiAgICB9LCBvcHRfb3B0aW9ucyk7XG4gICAgcmV0dXJuIGZlYXR1cmVzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXRlY3QgbGF5ZXJzIHRoYXQgaGF2ZSBhIGNvbG9yIHZhbHVlIGF0IGEgcGl4ZWwgb24gdGhlIHZpZXdwb3J0LCBhbmRcbiAgICogZXhlY3V0ZSBhIGNhbGxiYWNrIHdpdGggZWFjaCBtYXRjaGluZyBsYXllci4gTGF5ZXJzIGluY2x1ZGVkIGluIHRoZVxuICAgKiBkZXRlY3Rpb24gY2FuIGJlIGNvbmZpZ3VyZWQgdGhyb3VnaCBgb3B0X2xheWVyRmlsdGVyYC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3BpeGVsLmpzXCIpLlBpeGVsfSBwaXhlbCBQaXhlbC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBTLCBpbXBvcnQoXCIuL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHQsIChVaW50OENsYW1wZWRBcnJheXxVaW50OEFycmF5KSk6IFR9IGNhbGxiYWNrXG4gICAqICAgICBMYXllciBjYWxsYmFjay4gVGhpcyBjYWxsYmFjayB3aWxsIHJlY2VpdmUgdHdvIGFyZ3VtZW50czogZmlyc3QgaXMgdGhlXG4gICAqICAgICB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL0xheWVyIGxheWVyfSwgc2Vjb25kIGFyZ3VtZW50IGlzIGFuIGFycmF5IHJlcHJlc2VudGluZ1xuICAgKiAgICAgW1IsIEcsIEIsIEFdIHBpeGVsIHZhbHVlcyAoMCAtIDI1NSkgYW5kIHdpbGwgYmUgYG51bGxgIGZvciBsYXllciB0eXBlc1xuICAgKiAgICAgdGhhdCBkbyBub3QgY3VycmVudGx5IHN1cHBvcnQgdGhpcyBhcmd1bWVudC4gVG8gc3RvcCBkZXRlY3Rpb24sIGNhbGxiYWNrXG4gICAqICAgICBmdW5jdGlvbnMgY2FuIHJldHVybiBhIHRydXRoeSB2YWx1ZS5cbiAgICogQHBhcmFtIHtBdFBpeGVsT3B0aW9ucz19IG9wdF9vcHRpb25zIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICogQHJldHVybiB7VHx1bmRlZmluZWR9IENhbGxiYWNrIHJlc3VsdCwgaS5lLiB0aGUgcmV0dXJuIHZhbHVlIG9mIGxhc3RcbiAgICogY2FsbGJhY2sgZXhlY3V0aW9uLCBvciB0aGUgZmlyc3QgdHJ1dGh5IGNhbGxiYWNrIHJldHVybiB2YWx1ZS5cbiAgICogQHRlbXBsYXRlIFMsVFxuICAgKiBAYXBpXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLmZvckVhY2hMYXllckF0UGl4ZWwgPSBmdW5jdGlvbiBmb3JFYWNoTGF5ZXJBdFBpeGVsIChwaXhlbCwgY2FsbGJhY2ssIG9wdF9vcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmZyYW1lU3RhdGVfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgfHwgLyoqIEB0eXBlIHtBdFBpeGVsT3B0aW9uc30gKi8gKHt9KTtcbiAgICB2YXIgaGl0VG9sZXJhbmNlID0gb3B0aW9ucy5oaXRUb2xlcmFuY2UgIT09IHVuZGVmaW5lZCA/XG4gICAgICBvcHRfb3B0aW9ucy5oaXRUb2xlcmFuY2UgKiB0aGlzLmZyYW1lU3RhdGVfLnBpeGVsUmF0aW8gOiAwO1xuICAgIHZhciBsYXllckZpbHRlciA9IG9wdGlvbnMubGF5ZXJGaWx0ZXIgfHwgVFJVRTtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJlcl8uZm9yRWFjaExheWVyQXRQaXhlbChcbiAgICAgIHBpeGVsLCB0aGlzLmZyYW1lU3RhdGVfLCBoaXRUb2xlcmFuY2UsIGNhbGxiYWNrLCBudWxsLCBsYXllckZpbHRlciwgbnVsbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERldGVjdCBpZiBmZWF0dXJlcyBpbnRlcnNlY3QgYSBwaXhlbCBvbiB0aGUgdmlld3BvcnQuIExheWVycyBpbmNsdWRlZCBpbiB0aGVcbiAgICogZGV0ZWN0aW9uIGNhbiBiZSBjb25maWd1cmVkIHRocm91Z2ggYG9wdF9sYXllckZpbHRlcmAuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9waXhlbC5qc1wiKS5QaXhlbH0gcGl4ZWwgUGl4ZWwuXG4gICAqIEBwYXJhbSB7QXRQaXhlbE9wdGlvbnM9fSBvcHRfb3B0aW9ucyBPcHRpb25hbCBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJcyB0aGVyZSBhIGZlYXR1cmUgYXQgdGhlIGdpdmVuIHBpeGVsP1xuICAgKiBAdGVtcGxhdGUgVVxuICAgKiBAYXBpXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLmhhc0ZlYXR1cmVBdFBpeGVsID0gZnVuY3Rpb24gaGFzRmVhdHVyZUF0UGl4ZWwgKHBpeGVsLCBvcHRfb3B0aW9ucykge1xuICAgIGlmICghdGhpcy5mcmFtZVN0YXRlXykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgY29vcmRpbmF0ZSA9IHRoaXMuZ2V0Q29vcmRpbmF0ZUZyb21QaXhlbChwaXhlbCk7XG4gICAgb3B0X29wdGlvbnMgPSBvcHRfb3B0aW9ucyAhPT0gdW5kZWZpbmVkID8gb3B0X29wdGlvbnMgOlxuICAgICAgLyoqIEB0eXBlIHtBdFBpeGVsT3B0aW9uc30gKi8gKHt9KTtcbiAgICB2YXIgbGF5ZXJGaWx0ZXIgPSBvcHRfb3B0aW9ucy5sYXllckZpbHRlciAhPT0gdW5kZWZpbmVkID8gb3B0X29wdGlvbnMubGF5ZXJGaWx0ZXIgOiBUUlVFO1xuICAgIHZhciBoaXRUb2xlcmFuY2UgPSBvcHRfb3B0aW9ucy5oaXRUb2xlcmFuY2UgIT09IHVuZGVmaW5lZCA/XG4gICAgICBvcHRfb3B0aW9ucy5oaXRUb2xlcmFuY2UgKiB0aGlzLmZyYW1lU3RhdGVfLnBpeGVsUmF0aW8gOiAwO1xuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyXy5oYXNGZWF0dXJlQXRDb29yZGluYXRlKFxuICAgICAgY29vcmRpbmF0ZSwgdGhpcy5mcmFtZVN0YXRlXywgaGl0VG9sZXJhbmNlLCBsYXllckZpbHRlciwgbnVsbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvb3JkaW5hdGUgaW4gdmlldyBwcm9qZWN0aW9uIGZvciBhIGJyb3dzZXIgZXZlbnQuXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IEV2ZW50LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gQ29vcmRpbmF0ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5nZXRFdmVudENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRFdmVudENvb3JkaW5hdGUgKGV2ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q29vcmRpbmF0ZUZyb21QaXhlbCh0aGlzLmdldEV2ZW50UGl4ZWwoZXZlbnQpKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbWFwIHBpeGVsIHBvc2l0aW9uIGZvciBhIGJyb3dzZXIgZXZlbnQgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0LlxuICAgKiBAcGFyYW0ge0V2ZW50fFRvdWNoRXZlbnR9IGV2ZW50IEV2ZW50LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL3BpeGVsLmpzXCIpLlBpeGVsfSBQaXhlbC5cbiAgICogQGFwaVxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5nZXRFdmVudFBpeGVsID0gZnVuY3Rpb24gZ2V0RXZlbnRQaXhlbCAoZXZlbnQpIHtcbiAgICB2YXIgdmlld3BvcnRQb3NpdGlvbiA9IHRoaXMudmlld3BvcnRfLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciBldmVudFBvc2l0aW9uID0gJ2NoYW5nZWRUb3VjaGVzJyBpbiBldmVudCA/XG4gICAgICAvKiogQHR5cGUge1RvdWNoRXZlbnR9ICovIChldmVudCkuY2hhbmdlZFRvdWNoZXNbMF0gOlxuICAgICAgLyoqIEB0eXBlIHtNb3VzZUV2ZW50fSAqLyAoZXZlbnQpO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgIGV2ZW50UG9zaXRpb24uY2xpZW50WCAtIHZpZXdwb3J0UG9zaXRpb24ubGVmdCxcbiAgICAgIGV2ZW50UG9zaXRpb24uY2xpZW50WSAtIHZpZXdwb3J0UG9zaXRpb24udG9wXG4gICAgXTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSB0YXJnZXQgaW4gd2hpY2ggdGhpcyBtYXAgaXMgcmVuZGVyZWQuXG4gICAqIE5vdGUgdGhhdCB0aGlzIHJldHVybnMgd2hhdCBpcyBlbnRlcmVkIGFzIGFuIG9wdGlvbiBvciBpbiBzZXRUYXJnZXQ6XG4gICAqIGlmIHRoYXQgd2FzIGFuIGVsZW1lbnQsIGl0IHJldHVybnMgYW4gZWxlbWVudDsgaWYgYSBzdHJpbmcsIGl0IHJldHVybnMgdGhhdC5cbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR8c3RyaW5nfHVuZGVmaW5lZH0gVGhlIEVsZW1lbnQgb3IgaWQgb2YgdGhlIEVsZW1lbnQgdGhhdCB0aGVcbiAgICogICAgIG1hcCBpcyByZW5kZXJlZCBpbi5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5nZXRUYXJnZXQgPSBmdW5jdGlvbiBnZXRUYXJnZXQgKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge0hUTUxFbGVtZW50fHN0cmluZ3x1bmRlZmluZWR9ICovICh0aGlzLmdldChNYXBQcm9wZXJ0eS5UQVJHRVQpKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBET00gZWxlbWVudCBpbnRvIHdoaWNoIHRoaXMgbWFwIGlzIHJlbmRlcmVkLiBJbiBjb250cmFzdCB0b1xuICAgKiBgZ2V0VGFyZ2V0YCB0aGlzIG1ldGhvZCBhbHdheXMgcmV0dXJuIGFuIGBFbGVtZW50YCwgb3IgYG51bGxgIGlmIHRoZVxuICAgKiBtYXAgaGFzIG5vIHRhcmdldC5cbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9IFRoZSBlbGVtZW50IHRoYXQgdGhlIG1hcCBpcyByZW5kZXJlZCBpbi5cbiAgICogQGFwaVxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5nZXRUYXJnZXRFbGVtZW50ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0RWxlbWVudCAoKSB7XG4gICAgdmFyIHRhcmdldCA9IHRoaXMuZ2V0VGFyZ2V0KCk7XG4gICAgaWYgKHRhcmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0YXJnZXQpIDogdGFyZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY29vcmRpbmF0ZSBmb3IgYSBnaXZlbiBwaXhlbC4gIFRoaXMgcmV0dXJucyBhIGNvb3JkaW5hdGUgaW4gdGhlXG4gICAqIG1hcCB2aWV3IHByb2plY3Rpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9waXhlbC5qc1wiKS5QaXhlbH0gcGl4ZWwgUGl4ZWwgcG9zaXRpb24gaW4gdGhlIG1hcCB2aWV3cG9ydC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFRoZSBjb29yZGluYXRlIGZvciB0aGUgcGl4ZWwgcG9zaXRpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZUZyb21QaXhlbCA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVGcm9tUGl4ZWwgKHBpeGVsKSB7XG4gICAgdmFyIGZyYW1lU3RhdGUgPSB0aGlzLmZyYW1lU3RhdGVfO1xuICAgIGlmICghZnJhbWVTdGF0ZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhcHBseVRyYW5zZm9ybShmcmFtZVN0YXRlLnBpeGVsVG9Db29yZGluYXRlVHJhbnNmb3JtLCBwaXhlbC5zbGljZSgpKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWFwIGNvbnRyb2xzLiBNb2RpZnlpbmcgdGhpcyBjb2xsZWN0aW9uIGNoYW5nZXMgdGhlIGNvbnRyb2xzXG4gICAqIGFzc29jaWF0ZWQgd2l0aCB0aGUgbWFwLlxuICAgKiBAcmV0dXJuIHtDb2xsZWN0aW9uPGltcG9ydChcIi4vY29udHJvbC9Db250cm9sLmpzXCIpLmRlZmF1bHQ+fSBDb250cm9scy5cbiAgICogQGFwaVxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5nZXRDb250cm9scyA9IGZ1bmN0aW9uIGdldENvbnRyb2xzICgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250cm9scztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBtYXAgb3ZlcmxheXMuIE1vZGlmeWluZyB0aGlzIGNvbGxlY3Rpb24gY2hhbmdlcyB0aGUgb3ZlcmxheXNcbiAgICogYXNzb2NpYXRlZCB3aXRoIHRoZSBtYXAuXG4gICAqIEByZXR1cm4ge0NvbGxlY3Rpb248aW1wb3J0KFwiLi9PdmVybGF5LmpzXCIpLmRlZmF1bHQ+fSBPdmVybGF5cy5cbiAgICogQGFwaVxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5nZXRPdmVybGF5cyA9IGZ1bmN0aW9uIGdldE92ZXJsYXlzICgpIHtcbiAgICByZXR1cm4gdGhpcy5vdmVybGF5c187XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhbiBvdmVybGF5IGJ5IGl0cyBpZGVudGlmaWVyICh0aGUgdmFsdWUgcmV0dXJuZWQgYnkgb3ZlcmxheS5nZXRJZCgpKS5cbiAgICogTm90ZSB0aGF0IHRoZSBpbmRleCB0cmVhdHMgc3RyaW5nIGFuZCBudW1lcmljIGlkZW50aWZpZXJzIGFzIHRoZSBzYW1lLiBTb1xuICAgKiBgbWFwLmdldE92ZXJsYXlCeUlkKDIpYCB3aWxsIHJldHVybiBhbiBvdmVybGF5IHdpdGggaWQgYCcyJ2Agb3IgYDJgLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGlkIE92ZXJsYXkgaWRlbnRpZmllci5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9PdmVybGF5LmpzXCIpLmRlZmF1bHR9IE92ZXJsYXkuXG4gICAqIEBhcGlcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuZ2V0T3ZlcmxheUJ5SWQgPSBmdW5jdGlvbiBnZXRPdmVybGF5QnlJZCAoaWQpIHtcbiAgICB2YXIgb3ZlcmxheSA9IHRoaXMub3ZlcmxheUlkSW5kZXhfW2lkLnRvU3RyaW5nKCldO1xuICAgIHJldHVybiBvdmVybGF5ICE9PSB1bmRlZmluZWQgPyBvdmVybGF5IDogbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBtYXAgaW50ZXJhY3Rpb25zLiBNb2RpZnlpbmcgdGhpcyBjb2xsZWN0aW9uIGNoYW5nZXMgdGhlIGludGVyYWN0aW9uc1xuICAgKiBhc3NvY2lhdGVkIHdpdGggdGhlIG1hcC5cbiAgICpcbiAgICogSW50ZXJhY3Rpb25zIGFyZSB1c2VkIGZvciBlLmcuIHBhbiwgem9vbSBhbmQgcm90YXRlLlxuICAgKiBAcmV0dXJuIHtDb2xsZWN0aW9uPGltcG9ydChcIi4vaW50ZXJhY3Rpb24vSW50ZXJhY3Rpb24uanNcIikuZGVmYXVsdD59IEludGVyYWN0aW9ucy5cbiAgICogQGFwaVxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5nZXRJbnRlcmFjdGlvbnMgPSBmdW5jdGlvbiBnZXRJbnRlcmFjdGlvbnMgKCkge1xuICAgIHJldHVybiB0aGlzLmludGVyYWN0aW9ucztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBsYXllcmdyb3VwIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG1hcC5cbiAgICogQHJldHVybiB7TGF5ZXJHcm91cH0gQSBsYXllciBncm91cCBjb250YWluaW5nIHRoZSBsYXllcnMgaW4gdGhpcyBtYXAuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuZ2V0TGF5ZXJHcm91cCA9IGZ1bmN0aW9uIGdldExheWVyR3JvdXAgKCkge1xuICAgIHJldHVybiAoXG4gICAgICAvKiogQHR5cGUge0xheWVyR3JvdXB9ICovICh0aGlzLmdldChNYXBQcm9wZXJ0eS5MQVlFUkdST1VQKSlcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvbGxlY3Rpb24gb2YgbGF5ZXJzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG1hcC5cbiAgICogQHJldHVybiB7IUNvbGxlY3Rpb248aW1wb3J0KFwiLi9sYXllci9CYXNlLmpzXCIpLmRlZmF1bHQ+fSBMYXllcnMuXG4gICAqIEBhcGlcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuZ2V0TGF5ZXJzID0gZnVuY3Rpb24gZ2V0TGF5ZXJzICgpIHtcbiAgICB2YXIgbGF5ZXJzID0gdGhpcy5nZXRMYXllckdyb3VwKCkuZ2V0TGF5ZXJzKCk7XG4gICAgcmV0dXJuIGxheWVycztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBwaXhlbCBmb3IgYSBjb29yZGluYXRlLiAgVGhpcyB0YWtlcyBhIGNvb3JkaW5hdGUgaW4gdGhlIG1hcCB2aWV3XG4gICAqIHByb2plY3Rpb24gYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGl4ZWwuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQSBtYXAgY29vcmRpbmF0ZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9waXhlbC5qc1wiKS5QaXhlbH0gQSBwaXhlbCBwb3NpdGlvbiBpbiB0aGUgbWFwIHZpZXdwb3J0LlxuICAgKiBAYXBpXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLmdldFBpeGVsRnJvbUNvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRQaXhlbEZyb21Db29yZGluYXRlIChjb29yZGluYXRlKSB7XG4gICAgdmFyIGZyYW1lU3RhdGUgPSB0aGlzLmZyYW1lU3RhdGVfO1xuICAgIGlmICghZnJhbWVTdGF0ZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhcHBseVRyYW5zZm9ybShmcmFtZVN0YXRlLmNvb3JkaW5hdGVUb1BpeGVsVHJhbnNmb3JtLCBjb29yZGluYXRlLnNsaWNlKDAsIDIpKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWFwIHJlbmRlcmVyLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL3JlbmRlcmVyL01hcC5qc1wiKS5kZWZhdWx0fSBSZW5kZXJlclxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5nZXRSZW5kZXJlciA9IGZ1bmN0aW9uIGdldFJlbmRlcmVyICgpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJlcl87XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2l6ZSBvZiB0aGlzIG1hcC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV8dW5kZWZpbmVkfSBUaGUgc2l6ZSBpbiBwaXhlbHMgb2YgdGhlIG1hcCBpbiB0aGUgRE9NLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLmdldFNpemUgPSBmdW5jdGlvbiBnZXRTaXplICgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZXx1bmRlZmluZWR9ICovICh0aGlzLmdldChNYXBQcm9wZXJ0eS5TSVpFKSlcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZpZXcgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbWFwLiBBIHZpZXcgbWFuYWdlcyBwcm9wZXJ0aWVzIHN1Y2ggYXNcbiAgICogY2VudGVyIGFuZCByZXNvbHV0aW9uLlxuICAgKiBAcmV0dXJuIHtWaWV3fSBUaGUgdmlldyB0aGF0IGNvbnRyb2xzIHRoaXMgbWFwLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLmdldFZpZXcgPSBmdW5jdGlvbiBnZXRWaWV3ICgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgLyoqIEB0eXBlIHtWaWV3fSAqLyAodGhpcy5nZXQoTWFwUHJvcGVydHkuVklFVykpXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBlbGVtZW50IHRoYXQgc2VydmVzIGFzIHRoZSBtYXAgdmlld3BvcnQuXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBWaWV3cG9ydC5cbiAgICogQGFwaVxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5nZXRWaWV3cG9ydCA9IGZ1bmN0aW9uIGdldFZpZXdwb3J0ICgpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3cG9ydF87XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZWxlbWVudCB0aGF0IHNlcnZlcyBhcyB0aGUgY29udGFpbmVyIGZvciBvdmVybGF5cy4gIEVsZW1lbnRzIGFkZGVkIHRvXG4gICAqIHRoaXMgY29udGFpbmVyIHdpbGwgbGV0IG1vdXNlZG93biBhbmQgdG91Y2hzdGFydCBldmVudHMgdGhyb3VnaCB0byB0aGUgbWFwLFxuICAgKiBzbyBjbGlja3MgYW5kIGdlc3R1cmVzIG9uIGFuIG92ZXJsYXkgd2lsbCB0cmlnZ2VyIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH1cbiAgICogZXZlbnRzLlxuICAgKiBAcmV0dXJuIHshSFRNTEVsZW1lbnR9IFRoZSBtYXAncyBvdmVybGF5IGNvbnRhaW5lci5cbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuZ2V0T3ZlcmxheUNvbnRhaW5lciA9IGZ1bmN0aW9uIGdldE92ZXJsYXlDb250YWluZXIgKCkge1xuICAgIHJldHVybiB0aGlzLm92ZXJsYXlDb250YWluZXJfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGVsZW1lbnQgdGhhdCBzZXJ2ZXMgYXMgYSBjb250YWluZXIgZm9yIG92ZXJsYXlzIHRoYXQgZG9uJ3QgYWxsb3dcbiAgICogZXZlbnQgcHJvcGFnYXRpb24uIEVsZW1lbnRzIGFkZGVkIHRvIHRoaXMgY29udGFpbmVyIHdvbid0IGxldCBtb3VzZWRvd24gYW5kXG4gICAqIHRvdWNoc3RhcnQgZXZlbnRzIHRocm91Z2ggdG8gdGhlIG1hcCwgc28gY2xpY2tzIGFuZCBnZXN0dXJlcyBvbiBhbiBvdmVybGF5XG4gICAqIGRvbid0IHRyaWdnZXIgYW55IHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0uXG4gICAqIEByZXR1cm4geyFIVE1MRWxlbWVudH0gVGhlIG1hcCdzIG92ZXJsYXkgY29udGFpbmVyIHRoYXQgc3RvcHMgZXZlbnRzLlxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5nZXRPdmVybGF5Q29udGFpbmVyU3RvcEV2ZW50ID0gZnVuY3Rpb24gZ2V0T3ZlcmxheUNvbnRhaW5lclN0b3BFdmVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMub3ZlcmxheUNvbnRhaW5lclN0b3BFdmVudF87XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9UaWxlLmpzXCIpLmRlZmF1bHR9IHRpbGUgVGlsZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRpbGVTb3VyY2VLZXkgVGlsZSBzb3VyY2Uga2V5LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSB0aWxlQ2VudGVyIFRpbGUgY2VudGVyLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdGlsZVJlc29sdXRpb24gVGlsZSByZXNvbHV0aW9uLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRpbGUgcHJpb3JpdHkuXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLmdldFRpbGVQcmlvcml0eSA9IGZ1bmN0aW9uIGdldFRpbGVQcmlvcml0eSAodGlsZSwgdGlsZVNvdXJjZUtleSwgdGlsZUNlbnRlciwgdGlsZVJlc29sdXRpb24pIHtcbiAgICAvLyBGaWx0ZXIgb3V0IHRpbGVzIGF0IGhpZ2hlciB6b29tIGxldmVscyB0aGFuIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwsIG9yIHRoYXRcbiAgICAvLyBhcmUgb3V0c2lkZSB0aGUgdmlzaWJsZSBleHRlbnQuXG4gICAgdmFyIGZyYW1lU3RhdGUgPSB0aGlzLmZyYW1lU3RhdGVfO1xuICAgIGlmICghZnJhbWVTdGF0ZSB8fCAhKHRpbGVTb3VyY2VLZXkgaW4gZnJhbWVTdGF0ZS53YW50ZWRUaWxlcykpIHtcbiAgICAgIHJldHVybiBEUk9QO1xuICAgIH1cbiAgICBpZiAoIWZyYW1lU3RhdGUud2FudGVkVGlsZXNbdGlsZVNvdXJjZUtleV1bdGlsZS5nZXRLZXkoKV0pIHtcbiAgICAgIHJldHVybiBEUk9QO1xuICAgIH1cbiAgICAvLyBQcmlvcml0aXplIHRoZSBoaWdoZXN0IHpvb20gbGV2ZWwgdGlsZXMgY2xvc2VzdCB0byB0aGUgZm9jdXMuXG4gICAgLy8gVGlsZXMgYXQgaGlnaGVyIHpvb20gbGV2ZWxzIGFyZSBwcmlvcml0aXplZCB1c2luZyBNYXRoLmxvZyh0aWxlUmVzb2x1dGlvbikuXG4gICAgLy8gV2l0aGluIGEgem9vbSBsZXZlbCwgdGlsZXMgYXJlIHByaW9yaXRpemVkIGJ5IHRoZSBkaXN0YW5jZSBpbiBwaXhlbHNcbiAgICAvLyBiZXR3ZWVuIHRoZSBjZW50ZXIgb2YgdGhlIHRpbGUgYW5kIHRoZSBmb2N1cy4gIFRoZSBmYWN0b3Igb2YgNjU1MzYgbWVhbnNcbiAgICAvLyB0aGF0IHRoZSBwcmlvcml0aXphdGlvbiBzaG91bGQgYmVoYXZlIGFzIGRlc2lyZWQgZm9yIHRpbGVzIHVwIHRvXG4gICAgLy8gNjU1MzYgKiBNYXRoLmxvZygyKSA9IDQ1NDI2IHBpeGVscyBmcm9tIHRoZSBmb2N1cy5cbiAgICB2YXIgZGVsdGFYID0gdGlsZUNlbnRlclswXSAtIGZyYW1lU3RhdGUuZm9jdXNbMF07XG4gICAgdmFyIGRlbHRhWSA9IHRpbGVDZW50ZXJbMV0gLSBmcmFtZVN0YXRlLmZvY3VzWzFdO1xuICAgIHJldHVybiA2NTUzNiAqIE1hdGgubG9nKHRpbGVSZXNvbHV0aW9uKSArXG4gICAgICAgIE1hdGguc3FydChkZWx0YVggKiBkZWx0YVggKyBkZWx0YVkgKiBkZWx0YVkpIC8gdGlsZVJlc29sdXRpb247XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGJyb3dzZXJFdmVudCBCcm93c2VyIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG9wdF90eXBlIFR5cGUuXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLmhhbmRsZUJyb3dzZXJFdmVudCA9IGZ1bmN0aW9uIGhhbmRsZUJyb3dzZXJFdmVudCAoYnJvd3NlckV2ZW50LCBvcHRfdHlwZSkge1xuICAgIHZhciB0eXBlID0gb3B0X3R5cGUgfHwgYnJvd3NlckV2ZW50LnR5cGU7XG4gICAgdmFyIG1hcEJyb3dzZXJFdmVudCA9IG5ldyBNYXBCcm93c2VyRXZlbnQodHlwZSwgdGhpcywgYnJvd3NlckV2ZW50KTtcbiAgICB0aGlzLmhhbmRsZU1hcEJyb3dzZXJFdmVudChtYXBCcm93c2VyRXZlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge01hcEJyb3dzZXJFdmVudH0gbWFwQnJvd3NlckV2ZW50IFRoZSBldmVudCB0byBoYW5kbGUuXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLmhhbmRsZU1hcEJyb3dzZXJFdmVudCA9IGZ1bmN0aW9uIGhhbmRsZU1hcEJyb3dzZXJFdmVudCAobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmZyYW1lU3RhdGVfKSB7XG4gICAgICAvLyBXaXRoIG5vIHZpZXcgZGVmaW5lZCwgd2UgY2Fubm90IHRyYW5zbGF0ZSBwaXhlbHMgaW50byBnZW9ncmFwaGljYWxcbiAgICAgIC8vIGNvb3JkaW5hdGVzIHNvIGludGVyYWN0aW9ucyBjYW5ub3QgYmUgdXNlZC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5mb2N1c18gPSBtYXBCcm93c2VyRXZlbnQuY29vcmRpbmF0ZTtcbiAgICBtYXBCcm93c2VyRXZlbnQuZnJhbWVTdGF0ZSA9IHRoaXMuZnJhbWVTdGF0ZV87XG4gICAgdmFyIGludGVyYWN0aW9uc0FycmF5ID0gdGhpcy5nZXRJbnRlcmFjdGlvbnMoKS5nZXRBcnJheSgpO1xuICAgIGlmICh0aGlzLmRpc3BhdGNoRXZlbnQobWFwQnJvd3NlckV2ZW50KSAhPT0gZmFsc2UpIHtcbiAgICAgIGZvciAodmFyIGkgPSBpbnRlcmFjdGlvbnNBcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgaW50ZXJhY3Rpb24gPSBpbnRlcmFjdGlvbnNBcnJheVtpXTtcbiAgICAgICAgaWYgKCFpbnRlcmFjdGlvbi5nZXRBY3RpdmUoKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb250ID0gaW50ZXJhY3Rpb24uaGFuZGxlRXZlbnQobWFwQnJvd3NlckV2ZW50KTtcbiAgICAgICAgaWYgKCFjb250KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuaGFuZGxlUG9zdFJlbmRlciA9IGZ1bmN0aW9uIGhhbmRsZVBvc3RSZW5kZXIgKCkge1xuXG4gICAgdmFyIGZyYW1lU3RhdGUgPSB0aGlzLmZyYW1lU3RhdGVfO1xuXG4gICAgLy8gTWFuYWdlIHRoZSB0aWxlIHF1ZXVlXG4gICAgLy8gSW1hZ2UgbG9hZHMgYXJlIGV4cGVuc2l2ZSBhbmQgYSBsaW1pdGVkIHJlc291cmNlLCBzbyB0cnkgdG8gdXNlIHRoZW1cbiAgICAvLyBlZmZpY2llbnRseTpcbiAgICAvLyAqIFdoZW4gdGhlIHZpZXcgaXMgc3RhdGljIHdlIGFsbG93IGEgbGFyZ2UgbnVtYmVyIG9mIHBhcmFsbGVsIHRpbGUgbG9hZHNcbiAgICAvLyAgIHRvIGNvbXBsZXRlIHRoZSBmcmFtZSBhcyBxdWlja2x5IGFzIHBvc3NpYmxlLlxuICAgIC8vICogV2hlbiBhbmltYXRpbmcgb3IgaW50ZXJhY3RpbmcsIGltYWdlIGxvYWRzIGNhbiBjYXVzZSBqYW5rcywgc28gd2UgcmVkdWNlXG4gICAgLy8gICB0aGUgbWF4aW11bSBudW1iZXIgb2YgbG9hZHMgcGVyIGZyYW1lIGFuZCBsaW1pdCB0aGUgbnVtYmVyIG9mIHBhcmFsbGVsXG4gICAgLy8gICB0aWxlIGxvYWRzIHRvIHJlbWFpbiByZWFjdGl2ZSB0byB2aWV3IGNoYW5nZXMgYW5kIHRvIHJlZHVjZSB0aGUgY2hhbmNlIG9mXG4gICAgLy8gICBsb2FkaW5nIHRpbGVzIHRoYXQgd2lsbCBxdWlja2x5IGRpc2FwcGVhciBmcm9tIHZpZXcuXG4gICAgdmFyIHRpbGVRdWV1ZSA9IHRoaXMudGlsZVF1ZXVlXztcbiAgICBpZiAoIXRpbGVRdWV1ZS5pc0VtcHR5KCkpIHtcbiAgICAgIHZhciBtYXhUb3RhbExvYWRpbmcgPSB0aGlzLm1heFRpbGVzTG9hZGluZ187XG4gICAgICB2YXIgbWF4TmV3TG9hZHMgPSBtYXhUb3RhbExvYWRpbmc7XG4gICAgICBpZiAoZnJhbWVTdGF0ZSkge1xuICAgICAgICB2YXIgaGludHMgPSBmcmFtZVN0YXRlLnZpZXdIaW50cztcbiAgICAgICAgaWYgKGhpbnRzW1ZpZXdIaW50LkFOSU1BVElOR10pIHtcbiAgICAgICAgICBtYXhUb3RhbExvYWRpbmcgPSB0aGlzLmxvYWRUaWxlc1doaWxlQW5pbWF0aW5nXyA/IDggOiAwO1xuICAgICAgICAgIG1heE5ld0xvYWRzID0gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGludHNbVmlld0hpbnQuSU5URVJBQ1RJTkddKSB7XG4gICAgICAgICAgbWF4VG90YWxMb2FkaW5nID0gdGhpcy5sb2FkVGlsZXNXaGlsZUludGVyYWN0aW5nXyA/IDggOiAwO1xuICAgICAgICAgIG1heE5ld0xvYWRzID0gMjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRpbGVRdWV1ZS5nZXRUaWxlc0xvYWRpbmcoKSA8IG1heFRvdGFsTG9hZGluZykge1xuICAgICAgICB0aWxlUXVldWUucmVwcmlvcml0aXplKCk7IC8vIEZJWE1FIG9ubHkgY2FsbCBpZiB2aWV3IGhhcyBjaGFuZ2VkXG4gICAgICAgIHRpbGVRdWV1ZS5sb2FkTW9yZVRpbGVzKG1heFRvdGFsTG9hZGluZywgbWF4TmV3TG9hZHMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZnJhbWVTdGF0ZSAmJiB0aGlzLmhhc0xpc3RlbmVyKFJlbmRlckV2ZW50VHlwZS5SRU5ERVJDT01QTEVURSkgJiYgIWZyYW1lU3RhdGUuYW5pbWF0ZSAmJlxuICAgICAgICAhdGhpcy50aWxlUXVldWVfLmdldFRpbGVzTG9hZGluZygpICYmICFnZXRMb2FkaW5nKHRoaXMuZ2V0TGF5ZXJzKCkuZ2V0QXJyYXkoKSkpIHtcbiAgICAgIHRoaXMucmVuZGVyZXJfLmRpc3BhdGNoUmVuZGVyRXZlbnQoUmVuZGVyRXZlbnRUeXBlLlJFTkRFUkNPTVBMRVRFLCBmcmFtZVN0YXRlKTtcbiAgICB9XG5cbiAgICB2YXIgcG9zdFJlbmRlckZ1bmN0aW9ucyA9IHRoaXMucG9zdFJlbmRlckZ1bmN0aW9uc187XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcG9zdFJlbmRlckZ1bmN0aW9ucy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBwb3N0UmVuZGVyRnVuY3Rpb25zW2ldKHRoaXMsIGZyYW1lU3RhdGUpO1xuICAgIH1cbiAgICBwb3N0UmVuZGVyRnVuY3Rpb25zLmxlbmd0aCA9IDA7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLmhhbmRsZVNpemVDaGFuZ2VkXyA9IGZ1bmN0aW9uIGhhbmRsZVNpemVDaGFuZ2VkXyAoKSB7XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuaGFuZGxlVGFyZ2V0Q2hhbmdlZF8gPSBmdW5jdGlvbiBoYW5kbGVUYXJnZXRDaGFuZ2VkXyAoKSB7XG4gICAgLy8gdGFyZ2V0IG1heSBiZSB1bmRlZmluZWQsIG51bGwsIGEgc3RyaW5nIG9yIGFuIEVsZW1lbnQuXG4gICAgLy8gSWYgaXQncyBhIHN0cmluZyB3ZSBjb252ZXJ0IGl0IHRvIGFuIEVsZW1lbnQgYmVmb3JlIHByb2NlZWRpbmcuXG4gICAgLy8gSWYgaXQncyBub3Qgbm93IGFuIEVsZW1lbnQgd2UgcmVtb3ZlIHRoZSB2aWV3cG9ydCBmcm9tIHRoZSBET00uXG4gICAgLy8gSWYgaXQncyBhbiBFbGVtZW50IHdlIGFwcGVuZCB0aGUgdmlld3BvcnQgZWxlbWVudCB0byBpdC5cblxuICAgIHZhciB0YXJnZXRFbGVtZW50O1xuICAgIGlmICh0aGlzLmdldFRhcmdldCgpKSB7XG4gICAgICB0YXJnZXRFbGVtZW50ID0gdGhpcy5nZXRUYXJnZXRFbGVtZW50KCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMua2V5SGFuZGxlcktleXNfKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLmtleUhhbmRsZXJLZXlzXy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIHVubGlzdGVuQnlLZXkodGhpcy5rZXlIYW5kbGVyS2V5c19baV0pO1xuICAgICAgfVxuICAgICAgdGhpcy5rZXlIYW5kbGVyS2V5c18gPSBudWxsO1xuICAgIH1cblxuICAgIGlmICghdGFyZ2V0RWxlbWVudCkge1xuICAgICAgdGhpcy5yZW5kZXJlcl8ucmVtb3ZlTGF5ZXJSZW5kZXJlcnMoKTtcbiAgICAgIHJlbW92ZU5vZGUodGhpcy52aWV3cG9ydF8pO1xuICAgICAgaWYgKHRoaXMuaGFuZGxlUmVzaXplXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoRXZlbnRUeXBlLlJFU0laRSwgdGhpcy5oYW5kbGVSZXNpemVfLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuaGFuZGxlUmVzaXplXyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnZpZXdwb3J0Xyk7XG5cbiAgICAgIHZhciBrZXlib2FyZEV2ZW50VGFyZ2V0ID0gIXRoaXMua2V5Ym9hcmRFdmVudFRhcmdldF8gP1xuICAgICAgICB0YXJnZXRFbGVtZW50IDogdGhpcy5rZXlib2FyZEV2ZW50VGFyZ2V0XztcbiAgICAgIHRoaXMua2V5SGFuZGxlcktleXNfID0gW1xuICAgICAgICBsaXN0ZW4oa2V5Ym9hcmRFdmVudFRhcmdldCwgRXZlbnRUeXBlLktFWURPV04sIHRoaXMuaGFuZGxlQnJvd3NlckV2ZW50LCB0aGlzKSxcbiAgICAgICAgbGlzdGVuKGtleWJvYXJkRXZlbnRUYXJnZXQsIEV2ZW50VHlwZS5LRVlQUkVTUywgdGhpcy5oYW5kbGVCcm93c2VyRXZlbnQsIHRoaXMpXG4gICAgICBdO1xuXG4gICAgICBpZiAoIXRoaXMuaGFuZGxlUmVzaXplXykge1xuICAgICAgICB0aGlzLmhhbmRsZVJlc2l6ZV8gPSB0aGlzLnVwZGF0ZVNpemUuYmluZCh0aGlzKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRUeXBlLlJFU0laRSwgdGhpcy5oYW5kbGVSZXNpemVfLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVTaXplKCk7XG4gICAgLy8gdXBkYXRlU2l6ZSBjYWxscyBzZXRTaXplLCBzbyBubyBuZWVkIHRvIGNhbGwgdGhpcy5yZW5kZXJcbiAgICAvLyBvdXJzZWx2ZXMgaGVyZS5cbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuaGFuZGxlVGlsZUNoYW5nZV8gPSBmdW5jdGlvbiBoYW5kbGVUaWxlQ2hhbmdlXyAoKSB7XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuaGFuZGxlVmlld1Byb3BlcnR5Q2hhbmdlZF8gPSBmdW5jdGlvbiBoYW5kbGVWaWV3UHJvcGVydHlDaGFuZ2VkXyAoKSB7XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuaGFuZGxlVmlld0NoYW5nZWRfID0gZnVuY3Rpb24gaGFuZGxlVmlld0NoYW5nZWRfICgpIHtcbiAgICBpZiAodGhpcy52aWV3UHJvcGVydHlMaXN0ZW5lcktleV8pIHtcbiAgICAgIHVubGlzdGVuQnlLZXkodGhpcy52aWV3UHJvcGVydHlMaXN0ZW5lcktleV8pO1xuICAgICAgdGhpcy52aWV3UHJvcGVydHlMaXN0ZW5lcktleV8gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy52aWV3Q2hhbmdlTGlzdGVuZXJLZXlfKSB7XG4gICAgICB1bmxpc3RlbkJ5S2V5KHRoaXMudmlld0NoYW5nZUxpc3RlbmVyS2V5Xyk7XG4gICAgICB0aGlzLnZpZXdDaGFuZ2VMaXN0ZW5lcktleV8gPSBudWxsO1xuICAgIH1cbiAgICB2YXIgdmlldyA9IHRoaXMuZ2V0VmlldygpO1xuICAgIGlmICh2aWV3KSB7XG4gICAgICB0aGlzLnZpZXdwb3J0Xy5zZXRBdHRyaWJ1dGUoJ2RhdGEtdmlldycsIGdldFVpZCh2aWV3KSk7XG4gICAgICB0aGlzLnZpZXdQcm9wZXJ0eUxpc3RlbmVyS2V5XyA9IGxpc3RlbihcbiAgICAgICAgdmlldywgT2JqZWN0RXZlbnRUeXBlLlBST1BFUlRZQ0hBTkdFLFxuICAgICAgICB0aGlzLmhhbmRsZVZpZXdQcm9wZXJ0eUNoYW5nZWRfLCB0aGlzKTtcbiAgICAgIHRoaXMudmlld0NoYW5nZUxpc3RlbmVyS2V5XyA9IGxpc3RlbihcbiAgICAgICAgdmlldywgRXZlbnRUeXBlLkNIQU5HRSxcbiAgICAgICAgdGhpcy5oYW5kbGVWaWV3UHJvcGVydHlDaGFuZ2VkXywgdGhpcyk7XG4gICAgfVxuICAgIHRoaXMucmVuZGVyKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLmhhbmRsZUxheWVyR3JvdXBDaGFuZ2VkXyA9IGZ1bmN0aW9uIGhhbmRsZUxheWVyR3JvdXBDaGFuZ2VkXyAoKSB7XG4gICAgaWYgKHRoaXMubGF5ZXJHcm91cFByb3BlcnR5TGlzdGVuZXJLZXlzXykge1xuICAgICAgdGhpcy5sYXllckdyb3VwUHJvcGVydHlMaXN0ZW5lcktleXNfLmZvckVhY2godW5saXN0ZW5CeUtleSk7XG4gICAgICB0aGlzLmxheWVyR3JvdXBQcm9wZXJ0eUxpc3RlbmVyS2V5c18gPSBudWxsO1xuICAgIH1cbiAgICB2YXIgbGF5ZXJHcm91cCA9IHRoaXMuZ2V0TGF5ZXJHcm91cCgpO1xuICAgIGlmIChsYXllckdyb3VwKSB7XG4gICAgICB0aGlzLmxheWVyR3JvdXBQcm9wZXJ0eUxpc3RlbmVyS2V5c18gPSBbXG4gICAgICAgIGxpc3RlbihcbiAgICAgICAgICBsYXllckdyb3VwLCBPYmplY3RFdmVudFR5cGUuUFJPUEVSVFlDSEFOR0UsXG4gICAgICAgICAgdGhpcy5yZW5kZXIsIHRoaXMpLFxuICAgICAgICBsaXN0ZW4oXG4gICAgICAgICAgbGF5ZXJHcm91cCwgRXZlbnRUeXBlLkNIQU5HRSxcbiAgICAgICAgICB0aGlzLnJlbmRlciwgdGhpcylcbiAgICAgIF07XG4gICAgfVxuICAgIHRoaXMucmVuZGVyKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIHJlbmRlcmVkLlxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5pc1JlbmRlcmVkID0gZnVuY3Rpb24gaXNSZW5kZXJlZCAoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5mcmFtZVN0YXRlXztcbiAgfTtcblxuICAvKipcbiAgICogUmVxdWVzdHMgYW4gaW1tZWRpYXRlIHJlbmRlciBpbiBhIHN5bmNocm9ub3VzIG1hbm5lci5cbiAgICogQGFwaVxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5yZW5kZXJTeW5jID0gZnVuY3Rpb24gcmVuZGVyU3luYyAoKSB7XG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uRGVsYXlLZXlfKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGlvbkRlbGF5S2V5Xyk7XG4gICAgfVxuICAgIHRoaXMuYW5pbWF0aW9uRGVsYXlfKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgYSBtYXAgcmVuZGVyaW5nIChhdCB0aGUgbmV4dCBhbmltYXRpb24gZnJhbWUpLlxuICAgKiBAYXBpXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlciAoKSB7XG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uRGVsYXlLZXlfID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uRGVsYXlLZXlfID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uRGVsYXlfKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgZ2l2ZW4gY29udHJvbCBmcm9tIHRoZSBtYXAuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb250cm9sL0NvbnRyb2wuanNcIikuZGVmYXVsdH0gY29udHJvbCBDb250cm9sLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2NvbnRyb2wvQ29udHJvbC5qc1wiKS5kZWZhdWx0fHVuZGVmaW5lZH0gVGhlIHJlbW92ZWQgY29udHJvbCAob3IgdW5kZWZpbmVkXG4gICAqICAgICBpZiB0aGUgY29udHJvbCB3YXMgbm90IGZvdW5kKS5cbiAgICogQGFwaVxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5yZW1vdmVDb250cm9sID0gZnVuY3Rpb24gcmVtb3ZlQ29udHJvbCAoY29udHJvbCkge1xuICAgIHJldHVybiB0aGlzLmdldENvbnRyb2xzKCkucmVtb3ZlKGNvbnRyb2wpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGdpdmVuIGludGVyYWN0aW9uIGZyb20gdGhlIG1hcC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2ludGVyYWN0aW9uL0ludGVyYWN0aW9uLmpzXCIpLmRlZmF1bHR9IGludGVyYWN0aW9uIEludGVyYWN0aW9uIHRvIHJlbW92ZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbi5qc1wiKS5kZWZhdWx0fHVuZGVmaW5lZH0gVGhlIHJlbW92ZWQgaW50ZXJhY3Rpb24gKG9yXG4gICAqICAgICB1bmRlZmluZWQgaWYgdGhlIGludGVyYWN0aW9uIHdhcyBub3QgZm91bmQpLlxuICAgKiBAYXBpXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLnJlbW92ZUludGVyYWN0aW9uID0gZnVuY3Rpb24gcmVtb3ZlSW50ZXJhY3Rpb24gKGludGVyYWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW50ZXJhY3Rpb25zKCkucmVtb3ZlKGludGVyYWN0aW9uKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gbGF5ZXIgZnJvbSB0aGUgbWFwLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vbGF5ZXIvQmFzZS5qc1wiKS5kZWZhdWx0fSBsYXllciBMYXllci5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9sYXllci9CYXNlLmpzXCIpLmRlZmF1bHR8dW5kZWZpbmVkfSBUaGUgcmVtb3ZlZCBsYXllciAob3IgdW5kZWZpbmVkIGlmIHRoZVxuICAgKiAgICAgbGF5ZXIgd2FzIG5vdCBmb3VuZCkuXG4gICAqIEBhcGlcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUucmVtb3ZlTGF5ZXIgPSBmdW5jdGlvbiByZW1vdmVMYXllciAobGF5ZXIpIHtcbiAgICB2YXIgbGF5ZXJzID0gdGhpcy5nZXRMYXllckdyb3VwKCkuZ2V0TGF5ZXJzKCk7XG4gICAgcmV0dXJuIGxheWVycy5yZW1vdmUobGF5ZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGdpdmVuIG92ZXJsYXkgZnJvbSB0aGUgbWFwLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vT3ZlcmxheS5qc1wiKS5kZWZhdWx0fSBvdmVybGF5IE92ZXJsYXkuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vT3ZlcmxheS5qc1wiKS5kZWZhdWx0fHVuZGVmaW5lZH0gVGhlIHJlbW92ZWQgb3ZlcmxheSAob3IgdW5kZWZpbmVkXG4gICAqICAgICBpZiB0aGUgb3ZlcmxheSB3YXMgbm90IGZvdW5kKS5cbiAgICogQGFwaVxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5yZW1vdmVPdmVybGF5ID0gZnVuY3Rpb24gcmVtb3ZlT3ZlcmxheSAob3ZlcmxheSkge1xuICAgIHJldHVybiB0aGlzLmdldE92ZXJsYXlzKCkucmVtb3ZlKG92ZXJsYXkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdGltZSBUaW1lLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5yZW5kZXJGcmFtZV8gPSBmdW5jdGlvbiByZW5kZXJGcmFtZV8gKHRpbWUpIHtcbiAgICB2YXIgdmlld1N0YXRlO1xuXG4gICAgdmFyIHNpemUgPSB0aGlzLmdldFNpemUoKTtcbiAgICB2YXIgdmlldyA9IHRoaXMuZ2V0VmlldygpO1xuICAgIHZhciBleHRlbnQgPSBjcmVhdGVFbXB0eSgpO1xuICAgIHZhciBwcmV2aW91c0ZyYW1lU3RhdGUgPSB0aGlzLmZyYW1lU3RhdGVfO1xuICAgIC8qKiBAdHlwZSB7P0ZyYW1lU3RhdGV9ICovXG4gICAgdmFyIGZyYW1lU3RhdGUgPSBudWxsO1xuICAgIGlmIChzaXplICE9PSB1bmRlZmluZWQgJiYgaGFzQXJlYShzaXplKSAmJiB2aWV3ICYmIHZpZXcuaXNEZWYoKSkge1xuICAgICAgdmFyIHZpZXdIaW50cyA9IHZpZXcuZ2V0SGludHModGhpcy5mcmFtZVN0YXRlXyA/IHRoaXMuZnJhbWVTdGF0ZV8udmlld0hpbnRzIDogdW5kZWZpbmVkKTtcbiAgICAgIHZhciBsYXllclN0YXRlc0FycmF5ID0gdGhpcy5nZXRMYXllckdyb3VwKCkuZ2V0TGF5ZXJTdGF0ZXNBcnJheSgpO1xuICAgICAgdmFyIGxheWVyU3RhdGVzID0ge307XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBsYXllclN0YXRlc0FycmF5Lmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgbGF5ZXJTdGF0ZXNbZ2V0VWlkKGxheWVyU3RhdGVzQXJyYXlbaV0ubGF5ZXIpXSA9IGxheWVyU3RhdGVzQXJyYXlbaV07XG4gICAgICB9XG4gICAgICB2aWV3U3RhdGUgPSB2aWV3LmdldFN0YXRlKHRoaXMucGl4ZWxSYXRpb18pO1xuICAgICAgZnJhbWVTdGF0ZSA9IC8qKiBAdHlwZSB7RnJhbWVTdGF0ZX0gKi8gKHtcbiAgICAgICAgYW5pbWF0ZTogZmFsc2UsXG4gICAgICAgIGNvb3JkaW5hdGVUb1BpeGVsVHJhbnNmb3JtOiB0aGlzLmNvb3JkaW5hdGVUb1BpeGVsVHJhbnNmb3JtXyxcbiAgICAgICAgZXh0ZW50OiBleHRlbnQsXG4gICAgICAgIGZvY3VzOiB0aGlzLmZvY3VzXyA/IHRoaXMuZm9jdXNfIDogdmlld1N0YXRlLmNlbnRlcixcbiAgICAgICAgaW5kZXg6IHRoaXMuZnJhbWVJbmRleF8rKyxcbiAgICAgICAgbGF5ZXJTdGF0ZXM6IGxheWVyU3RhdGVzLFxuICAgICAgICBsYXllclN0YXRlc0FycmF5OiBsYXllclN0YXRlc0FycmF5LFxuICAgICAgICBwaXhlbFJhdGlvOiB0aGlzLnBpeGVsUmF0aW9fLFxuICAgICAgICBwaXhlbFRvQ29vcmRpbmF0ZVRyYW5zZm9ybTogdGhpcy5waXhlbFRvQ29vcmRpbmF0ZVRyYW5zZm9ybV8sXG4gICAgICAgIHBvc3RSZW5kZXJGdW5jdGlvbnM6IFtdLFxuICAgICAgICBzaXplOiBzaXplLFxuICAgICAgICBza2lwcGVkRmVhdHVyZVVpZHM6IHRoaXMuc2tpcHBlZEZlYXR1cmVVaWRzXyxcbiAgICAgICAgdGlsZVF1ZXVlOiB0aGlzLnRpbGVRdWV1ZV8sXG4gICAgICAgIHRpbWU6IHRpbWUsXG4gICAgICAgIHVzZWRUaWxlczoge30sXG4gICAgICAgIHZpZXdTdGF0ZTogdmlld1N0YXRlLFxuICAgICAgICB2aWV3SGludHM6IHZpZXdIaW50cyxcbiAgICAgICAgd2FudGVkVGlsZXM6IHt9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoZnJhbWVTdGF0ZSkge1xuICAgICAgZnJhbWVTdGF0ZS5leHRlbnQgPSBnZXRGb3JWaWV3QW5kU2l6ZSh2aWV3U3RhdGUuY2VudGVyLFxuICAgICAgICB2aWV3U3RhdGUucmVzb2x1dGlvbiwgdmlld1N0YXRlLnJvdGF0aW9uLCBmcmFtZVN0YXRlLnNpemUsIGV4dGVudCk7XG4gICAgfVxuXG4gICAgdGhpcy5mcmFtZVN0YXRlXyA9IGZyYW1lU3RhdGU7XG4gICAgdGhpcy5yZW5kZXJlcl8ucmVuZGVyRnJhbWUoZnJhbWVTdGF0ZSk7XG5cbiAgICBpZiAoZnJhbWVTdGF0ZSkge1xuICAgICAgaWYgKGZyYW1lU3RhdGUuYW5pbWF0ZSkge1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgfVxuICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGhpcy5wb3N0UmVuZGVyRnVuY3Rpb25zXywgZnJhbWVTdGF0ZS5wb3N0UmVuZGVyRnVuY3Rpb25zKTtcblxuICAgICAgaWYgKHByZXZpb3VzRnJhbWVTdGF0ZSkge1xuICAgICAgICB2YXIgbW92ZVN0YXJ0ID0gIXRoaXMucHJldmlvdXNFeHRlbnRfIHx8XG4gICAgICAgICAgICAgICAgICAgICghaXNFbXB0eSh0aGlzLnByZXZpb3VzRXh0ZW50XykgJiZcbiAgICAgICAgICAgICAgICAgICAgIWVxdWFscyhmcmFtZVN0YXRlLmV4dGVudCwgdGhpcy5wcmV2aW91c0V4dGVudF8pKTtcbiAgICAgICAgaWYgKG1vdmVTdGFydCkge1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgICAgIG5ldyBNYXBFdmVudChNYXBFdmVudFR5cGUuTU9WRVNUQVJULCB0aGlzLCBwcmV2aW91c0ZyYW1lU3RhdGUpKTtcbiAgICAgICAgICB0aGlzLnByZXZpb3VzRXh0ZW50XyA9IGNyZWF0ZU9yVXBkYXRlRW1wdHkodGhpcy5wcmV2aW91c0V4dGVudF8pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBpZGxlID0gdGhpcy5wcmV2aW91c0V4dGVudF8gJiZcbiAgICAgICAgICAhZnJhbWVTdGF0ZS52aWV3SGludHNbVmlld0hpbnQuQU5JTUFUSU5HXSAmJlxuICAgICAgICAgICFmcmFtZVN0YXRlLnZpZXdIaW50c1tWaWV3SGludC5JTlRFUkFDVElOR10gJiZcbiAgICAgICAgICAhZXF1YWxzKGZyYW1lU3RhdGUuZXh0ZW50LCB0aGlzLnByZXZpb3VzRXh0ZW50Xyk7XG5cbiAgICAgIGlmIChpZGxlKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgTWFwRXZlbnQoTWFwRXZlbnRUeXBlLk1PVkVFTkQsIHRoaXMsIGZyYW1lU3RhdGUpKTtcbiAgICAgICAgY2xvbmUoZnJhbWVTdGF0ZS5leHRlbnQsIHRoaXMucHJldmlvdXNFeHRlbnRfKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IE1hcEV2ZW50KE1hcEV2ZW50VHlwZS5QT1NUUkVOREVSLCB0aGlzLCBmcmFtZVN0YXRlKSk7XG5cbiAgICBzZXRUaW1lb3V0KHRoaXMuaGFuZGxlUG9zdFJlbmRlci5iaW5kKHRoaXMpLCAwKTtcblxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBsYXllcmdyb3VwIG9mIHRoaXMgbWFwLlxuICAgKiBAcGFyYW0ge0xheWVyR3JvdXB9IGxheWVyR3JvdXAgQSBsYXllciBncm91cCBjb250YWluaW5nIHRoZSBsYXllcnMgaW4gdGhpcyBtYXAuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuc2V0TGF5ZXJHcm91cCA9IGZ1bmN0aW9uIHNldExheWVyR3JvdXAgKGxheWVyR3JvdXApIHtcbiAgICB0aGlzLnNldChNYXBQcm9wZXJ0eS5MQVlFUkdST1VQLCBsYXllckdyb3VwKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBzaXplIG9mIHRoaXMgbWFwLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfHVuZGVmaW5lZH0gc2l6ZSBUaGUgc2l6ZSBpbiBwaXhlbHMgb2YgdGhlIG1hcCBpbiB0aGUgRE9NLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLnNldFNpemUgPSBmdW5jdGlvbiBzZXRTaXplIChzaXplKSB7XG4gICAgdGhpcy5zZXQoTWFwUHJvcGVydHkuU0laRSwgc2l6ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdGFyZ2V0IGVsZW1lbnQgdG8gcmVuZGVyIHRoaXMgbWFwIGludG8uXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8c3RyaW5nfHVuZGVmaW5lZH0gdGFyZ2V0IFRoZSBFbGVtZW50IG9yIGlkIG9mIHRoZSBFbGVtZW50XG4gICAqICAgICB0aGF0IHRoZSBtYXAgaXMgcmVuZGVyZWQgaW4uXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuc2V0VGFyZ2V0ID0gZnVuY3Rpb24gc2V0VGFyZ2V0ICh0YXJnZXQpIHtcbiAgICB0aGlzLnNldChNYXBQcm9wZXJ0eS5UQVJHRVQsIHRhcmdldCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdmlldyBmb3IgdGhpcyBtYXAuXG4gICAqIEBwYXJhbSB7Vmlld30gdmlldyBUaGUgdmlldyB0aGF0IGNvbnRyb2xzIHRoaXMgbWFwLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLnNldFZpZXcgPSBmdW5jdGlvbiBzZXRWaWV3ICh2aWV3KSB7XG4gICAgdGhpcy5zZXQoTWFwUHJvcGVydHkuVklFVywgdmlldyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuc2tpcEZlYXR1cmUgPSBmdW5jdGlvbiBza2lwRmVhdHVyZSAoZmVhdHVyZSkge1xuICAgIHRoaXMuc2tpcHBlZEZlYXR1cmVVaWRzX1tnZXRVaWQoZmVhdHVyZSldID0gdHJ1ZTtcbiAgICB0aGlzLnJlbmRlcigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGb3JjZSBhIHJlY2FsY3VsYXRpb24gb2YgdGhlIG1hcCB2aWV3cG9ydCBzaXplLiAgVGhpcyBzaG91bGQgYmUgY2FsbGVkIHdoZW5cbiAgICogdGhpcmQtcGFydHkgY29kZSBjaGFuZ2VzIHRoZSBzaXplIG9mIHRoZSBtYXAgdmlld3BvcnQuXG4gICAqIEBhcGlcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUudXBkYXRlU2l6ZSA9IGZ1bmN0aW9uIHVwZGF0ZVNpemUgKCkge1xuICAgIHZhciB0YXJnZXRFbGVtZW50ID0gdGhpcy5nZXRUYXJnZXRFbGVtZW50KCk7XG5cbiAgICBpZiAoIXRhcmdldEVsZW1lbnQpIHtcbiAgICAgIHRoaXMuc2V0U2l6ZSh1bmRlZmluZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0RWxlbWVudCk7XG4gICAgICB0aGlzLnNldFNpemUoW1xuICAgICAgICB0YXJnZXRFbGVtZW50Lm9mZnNldFdpZHRoIC1cbiAgICAgICAgICAgIHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZVsnYm9yZGVyTGVmdFdpZHRoJ10pIC1cbiAgICAgICAgICAgIHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZVsncGFkZGluZ0xlZnQnXSkgLVxuICAgICAgICAgICAgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlWydwYWRkaW5nUmlnaHQnXSkgLVxuICAgICAgICAgICAgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlWydib3JkZXJSaWdodFdpZHRoJ10pLFxuICAgICAgICB0YXJnZXRFbGVtZW50Lm9mZnNldEhlaWdodCAtXG4gICAgICAgICAgICBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGVbJ2JvcmRlclRvcFdpZHRoJ10pIC1cbiAgICAgICAgICAgIHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZVsncGFkZGluZ1RvcCddKSAtXG4gICAgICAgICAgICBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGVbJ3BhZGRpbmdCb3R0b20nXSkgLVxuICAgICAgICAgICAgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlWydib3JkZXJCb3R0b21XaWR0aCddKVxuICAgICAgXSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmUuXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLnVuc2tpcEZlYXR1cmUgPSBmdW5jdGlvbiB1bnNraXBGZWF0dXJlIChmZWF0dXJlKSB7XG4gICAgZGVsZXRlIHRoaXMuc2tpcHBlZEZlYXR1cmVVaWRzX1tnZXRVaWQoZmVhdHVyZSldO1xuICAgIHRoaXMucmVuZGVyKCk7XG4gIH07XG5cbiAgcmV0dXJuIFBsdWdnYWJsZU1hcDtcbn0oQmFzZU9iamVjdCkpO1xuXG5cbi8qKlxuICogQHBhcmFtIHtNYXBPcHRpb25zfSBvcHRpb25zIE1hcCBvcHRpb25zLlxuICogQHJldHVybiB7TWFwT3B0aW9uc0ludGVybmFsfSBJbnRlcm5hbCBtYXAgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlT3B0aW9uc0ludGVybmFsKG9wdGlvbnMpIHtcblxuICAvKipcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fERvY3VtZW50fVxuICAgKi9cbiAgdmFyIGtleWJvYXJkRXZlbnRUYXJnZXQgPSBudWxsO1xuICBpZiAob3B0aW9ucy5rZXlib2FyZEV2ZW50VGFyZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBrZXlib2FyZEV2ZW50VGFyZ2V0ID0gdHlwZW9mIG9wdGlvbnMua2V5Ym9hcmRFdmVudFRhcmdldCA9PT0gJ3N0cmluZycgP1xuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQob3B0aW9ucy5rZXlib2FyZEV2ZW50VGFyZ2V0KSA6XG4gICAgICBvcHRpb25zLmtleWJvYXJkRXZlbnRUYXJnZXQ7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge09iamVjdDxzdHJpbmcsICo+fVxuICAgKi9cbiAgdmFyIHZhbHVlcyA9IHt9O1xuXG4gIHZhciBsYXllckdyb3VwID0gb3B0aW9ucy5sYXllcnMgJiYgdHlwZW9mIC8qKiBAdHlwZSB7P30gKi8gKG9wdGlvbnMubGF5ZXJzKS5nZXRMYXllcnMgPT09ICdmdW5jdGlvbicgP1xuICAgIC8qKiBAdHlwZSB7TGF5ZXJHcm91cH0gKi8gKG9wdGlvbnMubGF5ZXJzKSA6IG5ldyBMYXllckdyb3VwKHtsYXllcnM6IC8qKiBAdHlwZSB7Q29sbGVjdGlvbn0gKi8gKG9wdGlvbnMubGF5ZXJzKX0pO1xuICB2YWx1ZXNbTWFwUHJvcGVydHkuTEFZRVJHUk9VUF0gPSBsYXllckdyb3VwO1xuXG4gIHZhbHVlc1tNYXBQcm9wZXJ0eS5UQVJHRVRdID0gb3B0aW9ucy50YXJnZXQ7XG5cbiAgdmFsdWVzW01hcFByb3BlcnR5LlZJRVddID0gb3B0aW9ucy52aWV3ICE9PSB1bmRlZmluZWQgP1xuICAgIG9wdGlvbnMudmlldyA6IG5ldyBWaWV3KCk7XG5cbiAgdmFyIGNvbnRyb2xzO1xuICBpZiAob3B0aW9ucy5jb250cm9scyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5jb250cm9scykpIHtcbiAgICAgIGNvbnRyb2xzID0gbmV3IENvbGxlY3Rpb24ob3B0aW9ucy5jb250cm9scy5zbGljZSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KHR5cGVvZiAvKiogQHR5cGUgez99ICovIChvcHRpb25zLmNvbnRyb2xzKS5nZXRBcnJheSA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgNDcpOyAvLyBFeHBlY3RlZCBgY29udHJvbHNgIHRvIGJlIGFuIGFycmF5IG9yIGFuIGBpbXBvcnQoXCIuL0NvbGxlY3Rpb24uanNcIikuQ29sbGVjdGlvbmBcbiAgICAgIGNvbnRyb2xzID0gLyoqIEB0eXBlIHtDb2xsZWN0aW9ufSAqLyAob3B0aW9ucy5jb250cm9scyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGludGVyYWN0aW9ucztcbiAgaWYgKG9wdGlvbnMuaW50ZXJhY3Rpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLmludGVyYWN0aW9ucykpIHtcbiAgICAgIGludGVyYWN0aW9ucyA9IG5ldyBDb2xsZWN0aW9uKG9wdGlvbnMuaW50ZXJhY3Rpb25zLnNsaWNlKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQodHlwZW9mIC8qKiBAdHlwZSB7P30gKi8gKG9wdGlvbnMuaW50ZXJhY3Rpb25zKS5nZXRBcnJheSA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgNDgpOyAvLyBFeHBlY3RlZCBgaW50ZXJhY3Rpb25zYCB0byBiZSBhbiBhcnJheSBvciBhbiBgaW1wb3J0KFwiLi9Db2xsZWN0aW9uLmpzXCIpLkNvbGxlY3Rpb25gXG4gICAgICBpbnRlcmFjdGlvbnMgPSAvKiogQHR5cGUge0NvbGxlY3Rpb259ICovIChvcHRpb25zLmludGVyYWN0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIG92ZXJsYXlzO1xuICBpZiAob3B0aW9ucy5vdmVybGF5cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5vdmVybGF5cykpIHtcbiAgICAgIG92ZXJsYXlzID0gbmV3IENvbGxlY3Rpb24ob3B0aW9ucy5vdmVybGF5cy5zbGljZSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KHR5cGVvZiAvKiogQHR5cGUgez99ICovIChvcHRpb25zLm92ZXJsYXlzKS5nZXRBcnJheSA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgNDkpOyAvLyBFeHBlY3RlZCBgb3ZlcmxheXNgIHRvIGJlIGFuIGFycmF5IG9yIGFuIGBpbXBvcnQoXCIuL0NvbGxlY3Rpb24uanNcIikuQ29sbGVjdGlvbmBcbiAgICAgIG92ZXJsYXlzID0gb3B0aW9ucy5vdmVybGF5cztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb3ZlcmxheXMgPSBuZXcgQ29sbGVjdGlvbigpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjb250cm9sczogY29udHJvbHMsXG4gICAgaW50ZXJhY3Rpb25zOiBpbnRlcmFjdGlvbnMsXG4gICAga2V5Ym9hcmRFdmVudFRhcmdldDoga2V5Ym9hcmRFdmVudFRhcmdldCxcbiAgICBvdmVybGF5czogb3ZlcmxheXMsXG4gICAgdmFsdWVzOiB2YWx1ZXNcbiAgfTtcblxufVxuZXhwb3J0IGRlZmF1bHQgUGx1Z2dhYmxlTWFwO1xuXG4vKipcbiAqIEBwYXJhbSAge0FycmF5PGltcG9ydChcIi4vbGF5ZXIvQmFzZS5qc1wiKS5kZWZhdWx0Pn0gbGF5ZXJzIExheWVycy5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IExheWVycyBoYXZlIHNvdXJjZXMgdGhhdCBhcmUgc3RpbGwgbG9hZGluZy5cbiAqL1xuZnVuY3Rpb24gZ2V0TG9hZGluZyhsYXllcnMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICB2YXIgbGF5ZXIgPSBsYXllcnNbaV07XG4gICAgaWYgKHR5cGVvZiAvKiogQHR5cGUgez99ICovIChsYXllcikuZ2V0TGF5ZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gZ2V0TG9hZGluZygvKiogQHR5cGUge0xheWVyR3JvdXB9ICovIChsYXllcikuZ2V0TGF5ZXJzKCkuZ2V0QXJyYXkoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzb3VyY2UgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdH0gKi8gKFxuICAgICAgICBsYXllcikuZ2V0U291cmNlKCk7XG4gICAgICBpZiAoc291cmNlICYmIHNvdXJjZS5sb2FkaW5nKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBsdWdnYWJsZU1hcC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvVGlsZVxuICovXG5pbXBvcnQgVGlsZVN0YXRlIGZyb20gJy4vVGlsZVN0YXRlLmpzJztcbmltcG9ydCB7ZWFzZUlufSBmcm9tICcuL2Vhc2luZy5qcyc7XG5pbXBvcnQgRXZlbnRUYXJnZXQgZnJvbSAnLi9ldmVudHMvVGFyZ2V0LmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcblxuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL1RpbGV9IGZvciB0aGUgdGlsZSBhbmQgYVxuICogYHtzdHJpbmd9YCBmb3IgdGhlIHVybCBhcyBhcmd1bWVudHMuIFRoZSBkZWZhdWx0IGlzXG4gKiBgYGBqc1xuICogc291cmNlLnNldFRpbGVMb2FkRnVuY3Rpb24oZnVuY3Rpb24odGlsZSwgc3JjKSB7XG4gKiAgIHRpbGUuZ2V0SW1hZ2UoKS5zcmMgPSBzcmM7XG4gKiB9KTtcbiAqIGBgYFxuICogRm9yIG1vcmUgZmluZSBncmFpbmVkIGNvbnRyb2wsIHRoZSBsb2FkIGZ1bmN0aW9uIGNhbiB1c2UgZmV0Y2ggb3IgWE1MSHR0cFJlcXVlc3QgYW5kIGludm9sdmVcbiAqIGVycm9yIGhhbmRsaW5nOlxuICpcbiAqIGBgYGpzXG4gKiBpbXBvcnQgVGlsZVN0YXRlIGZyb20gJ29sL1RpbGVTdGF0ZSc7XG4gKlxuICogc291cmNlLnNldFRpbGVMb2FkRnVuY3Rpb24oZnVuY3Rpb24odGlsZSwgc3JjKSB7XG4gKiAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAqICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdibG9iJztcbiAqICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlbmQnLCBmdW5jdGlvbiAoZXZ0KSB7XG4gKiAgICAgdmFyIGRhdGEgPSB0aGlzLnJlc3BvbnNlO1xuICogICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAqICAgICAgIHRpbGUuZ2V0SW1hZ2UoKS5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGRhdGEpO1xuICogICAgIH0gZWxzZSB7XG4gKiAgICAgICB0aWxlLnNldFN0YXRlKFRpbGVTdGF0ZS5FUlJPUik7XG4gKiAgICAgfVxuICogICB9KTtcbiAqICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24gKCkge1xuICogICAgIHRpbGUuc2V0U3RhdGUoVGlsZVN0YXRlLkVSUk9SKTtcbiAqICAgfSk7XG4gKiAgIHhoci5vcGVuKCdHRVQnLCBzcmMpO1xuICogICB4aHIuc2VuZCgpO1xuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oVGlsZSwgc3RyaW5nKX0gTG9hZEZ1bmN0aW9uXG4gKiBAYXBpXG4gKi9cblxuLyoqXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9UaWxlflRpbGV9IHNvdXJjZXMgdXNlIGEgZnVuY3Rpb24gb2YgdGhpcyB0eXBlIHRvIGdldFxuICogdGhlIHVybCB0aGF0IHByb3ZpZGVzIGEgdGlsZSBmb3IgYSBnaXZlbiB0aWxlIGNvb3JkaW5hdGUuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmR9IGZvciB0aGUgdGlsZVxuICogY29vcmRpbmF0ZSwgYSBge251bWJlcn1gIHJlcHJlc2VudGluZyB0aGUgcGl4ZWwgcmF0aW8gYW5kIGFcbiAqIHtAbGluayBtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBmb3IgdGhlIHByb2plY3Rpb24gIGFzIGFyZ3VtZW50c1xuICogYW5kIHJldHVybnMgYSBge3N0cmluZ31gIHJlcHJlc2VudGluZyB0aGUgdGlsZSBVUkwsIG9yIHVuZGVmaW5lZCBpZiBubyB0aWxlXG4gKiBzaG91bGQgYmUgcmVxdWVzdGVkIGZvciB0aGUgcGFzc2VkIHRpbGUgY29vcmRpbmF0ZS5cbiAqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oaW1wb3J0KFwiLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkLCBudW1iZXIsXG4gKiAgICAgICAgICAgaW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdCk6IChzdHJpbmd8dW5kZWZpbmVkKX0gVXJsRnVuY3Rpb25cbiAqIEBhcGlcbiAqL1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0cmFuc2l0aW9uPTI1MF0gQSBkdXJhdGlvbiBmb3IgdGlsZSBvcGFjaXR5XG4gKiB0cmFuc2l0aW9ucyBpbiBtaWxsaXNlY29uZHMuIEEgZHVyYXRpb24gb2YgMCBkaXNhYmxlcyB0aGUgb3BhY2l0eSB0cmFuc2l0aW9uLlxuICogQGFwaVxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBCYXNlIGNsYXNzIGZvciB0aWxlcy5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqL1xudmFyIFRpbGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChFdmVudFRhcmdldCkge1xuICBmdW5jdGlvbiBUaWxlKHRpbGVDb29yZCwgc3RhdGUsIG9wdF9vcHRpb25zKSB7XG4gICAgRXZlbnRUYXJnZXQuY2FsbCh0aGlzKTtcblxuICAgIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgPyBvcHRfb3B0aW9ucyA6IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH1cbiAgICAgKi9cbiAgICB0aGlzLnRpbGVDb29yZCA9IHRpbGVDb29yZDtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7VGlsZVN0YXRlfVxuICAgICAqL1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcblxuICAgIC8qKlxuICAgICAqIEFuIFwiaW50ZXJpbVwiIHRpbGUgZm9yIHRoaXMgdGlsZS4gVGhlIGludGVyaW0gdGlsZSBtYXkgYmUgdXNlZCB3aGlsZSB0aGlzXG4gICAgICogb25lIGlzIGxvYWRpbmcsIGZvciBcInNtb290aFwiIHRyYW5zaXRpb25zIHdoZW4gY2hhbmdpbmcgcGFyYW1zL2RpbWVuc2lvbnNcbiAgICAgKiBvbiB0aGUgc291cmNlLlxuICAgICAqIEB0eXBlIHtUaWxlfVxuICAgICAqL1xuICAgIHRoaXMuaW50ZXJpbVRpbGUgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQSBrZXkgYXNzaWduZWQgdG8gdGhlIHRpbGUuIFRoaXMgaXMgdXNlZCBieSB0aGUgdGlsZSBzb3VyY2UgdG8gZGV0ZXJtaW5lXG4gICAgICogaWYgdGhpcyB0aWxlIGNhbiBlZmZlY3RpdmVseSBiZSB1c2VkLCBvciBpZiBhIG5ldyB0aWxlIHNob3VsZCBiZSBjcmVhdGVkXG4gICAgICogYW5kIHRoaXMgb25lIGJlIHVzZWQgYXMgYW4gaW50ZXJpbSB0aWxlIGZvciB0aGlzIG5ldyB0aWxlLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5rZXkgPSAnJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBkdXJhdGlvbiBmb3IgdGhlIG9wYWNpdHkgdHJhbnNpdGlvbi5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudHJhbnNpdGlvbl8gPSBvcHRpb25zLnRyYW5zaXRpb24gPT09IHVuZGVmaW5lZCA/IDI1MCA6IG9wdGlvbnMudHJhbnNpdGlvbjtcblxuICAgIC8qKlxuICAgICAqIExvb2t1cCBvZiBzdGFydCB0aW1lcyBmb3IgcmVuZGVyaW5nIHRyYW5zaXRpb25zLiAgSWYgdGhlIHN0YXJ0IHRpbWUgaXNcbiAgICAgKiBlcXVhbCB0byAtMSwgdGhlIHRyYW5zaXRpb24gaXMgY29tcGxldGUuXG4gICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsIG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy50cmFuc2l0aW9uU3RhcnRzXyA9IHt9O1xuXG4gIH1cblxuICBpZiAoIEV2ZW50VGFyZ2V0ICkgVGlsZS5fX3Byb3RvX18gPSBFdmVudFRhcmdldDtcbiAgVGlsZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFdmVudFRhcmdldCAmJiBFdmVudFRhcmdldC5wcm90b3R5cGUgKTtcbiAgVGlsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUaWxlO1xuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBUaWxlLnByb3RvdHlwZS5jaGFuZ2VkID0gZnVuY3Rpb24gY2hhbmdlZCAoKSB7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KEV2ZW50VHlwZS5DSEFOR0UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEtleS5cbiAgICovXG4gIFRpbGUucHJvdG90eXBlLmdldEtleSA9IGZ1bmN0aW9uIGdldEtleSAoKSB7XG4gICAgcmV0dXJuIHRoaXMua2V5ICsgJy8nICsgdGhpcy50aWxlQ29vcmQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaW50ZXJpbSB0aWxlIG1vc3Qgc3VpdGFibGUgZm9yIHJlbmRlcmluZyB1c2luZyB0aGUgY2hhaW4gb2YgaW50ZXJpbVxuICAgKiB0aWxlcy4gVGhpcyBjb3JyZXNwb25kcyB0byB0aGUgIG1vc3QgcmVjZW50IHRpbGUgdGhhdCBoYXMgYmVlbiBsb2FkZWQsIGlmIG5vXG4gICAqIHN1Y2ggdGlsZSBleGlzdHMsIHRoZSBvcmlnaW5hbCB0aWxlIGlzIHJldHVybmVkLlxuICAgKiBAcmV0dXJuIHshVGlsZX0gQmVzdCB0aWxlIGZvciByZW5kZXJpbmcuXG4gICAqL1xuICBUaWxlLnByb3RvdHlwZS5nZXRJbnRlcmltVGlsZSA9IGZ1bmN0aW9uIGdldEludGVyaW1UaWxlICgpIHtcbiAgICBpZiAoIXRoaXMuaW50ZXJpbVRpbGUpIHtcbiAgICAgIC8vZW1wdHkgY2hhaW5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgdGlsZSA9IHRoaXMuaW50ZXJpbVRpbGU7XG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBsb2FkZWQgdGlsZSBhbmQgcmV0dXJuIGl0LiBTaW5jZSB0aGUgY2hhaW4gaXMgc29ydGVkIGluXG4gICAgLy8gZGVjcmVhc2luZyBvcmRlciBvZiBjcmVhdGlvbiB0aW1lLCB0aGVyZSBpcyBubyBuZWVkIHRvIHNlYXJjaCB0aGUgcmVtYWluZGVyXG4gICAgLy8gb2YgdGhlIGxpc3QgKGFsbCB0aG9zZSB0aWxlcyBjb3JyZXNwb25kIHRvIG9sZGVyIHJlcXVlc3RzIGFuZCB3aWxsIGJlXG4gICAgLy8gY2xlYW5lZCB1cCBieSByZWZyZXNoSW50ZXJpbUNoYWluKVxuICAgIGRvIHtcbiAgICAgIGlmICh0aWxlLmdldFN0YXRlKCkgPT0gVGlsZVN0YXRlLkxPQURFRCkge1xuICAgICAgICByZXR1cm4gdGlsZTtcbiAgICAgIH1cbiAgICAgIHRpbGUgPSB0aWxlLmludGVyaW1UaWxlO1xuICAgIH0gd2hpbGUgKHRpbGUpO1xuXG4gICAgLy8gd2UgY2FuIG5vdCBmaW5kIGEgYmV0dGVyIHRpbGVcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogR29lcyB0aHJvdWdoIHRoZSBjaGFpbiBvZiBpbnRlcmltIHRpbGVzIGFuZCBkaXNjYXJkcyBzZWN0aW9ucyBvZiB0aGUgY2hhaW5cbiAgICogdGhhdCBhcmUgbm8gbG9uZ2VyIHJlbGV2YW50LlxuICAgKi9cbiAgVGlsZS5wcm90b3R5cGUucmVmcmVzaEludGVyaW1DaGFpbiA9IGZ1bmN0aW9uIHJlZnJlc2hJbnRlcmltQ2hhaW4gKCkge1xuICAgIGlmICghdGhpcy5pbnRlcmltVGlsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0aWxlID0gdGhpcy5pbnRlcmltVGlsZTtcbiAgICB2YXIgcHJldiA9IC8qKiBAdHlwZSB7VGlsZX0gKi8gKHRoaXMpO1xuXG4gICAgZG8ge1xuICAgICAgaWYgKHRpbGUuZ2V0U3RhdGUoKSA9PSBUaWxlU3RhdGUuTE9BREVEKSB7XG4gICAgICAgIC8vd2UgaGF2ZSBhIGxvYWRlZCB0aWxlLCB3ZSBjYW4gZGlzY2FyZCB0aGUgcmVzdCBvZiB0aGUgbGlzdFxuICAgICAgICAvL3dlIHdvdWxkIGNvdWxkIGFib3J0IGFueSBMT0FESU5HIHRpbGUgcmVxdWVzdFxuICAgICAgICAvL29sZGVyIHRoYW4gdGhpcyB0aWxlIChpLmUuIGFueSBMT0FESU5HIHRpbGUgZm9sbG93aW5nIHRoaXMgZW50cnkgaW4gdGhlIGNoYWluKVxuICAgICAgICB0aWxlLmludGVyaW1UaWxlID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKHRpbGUuZ2V0U3RhdGUoKSA9PSBUaWxlU3RhdGUuTE9BRElORykge1xuICAgICAgICAvL2tlZXAgdGhpcyBMT0FESU5HIHRpbGUgYW55IGxvYWRlZCB0aWxlcyBsYXRlciBpbiB0aGUgY2hhaW4gYXJlXG4gICAgICAgIC8vb2xkZXIgdGhhbiB0aGlzIHRpbGUsIHNvIHdlJ3JlIHN0aWxsIGludGVyZXN0ZWQgaW4gdGhlIHJlcXVlc3RcbiAgICAgICAgcHJldiA9IHRpbGU7XG4gICAgICB9IGVsc2UgaWYgKHRpbGUuZ2V0U3RhdGUoKSA9PSBUaWxlU3RhdGUuSURMRSkge1xuICAgICAgICAvL3RoZSBoZWFkIG9mIHRoZSBsaXN0IGlzIHRoZSBtb3N0IGN1cnJlbnQgdGlsZSwgd2UgZG9uJ3QgbmVlZFxuICAgICAgICAvL3RvIHN0YXJ0IGFueSBvdGhlciByZXF1ZXN0cyBmb3IgdGhpcyBjaGFpblxuICAgICAgICBwcmV2LmludGVyaW1UaWxlID0gdGlsZS5pbnRlcmltVGlsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZXYgPSB0aWxlO1xuICAgICAgfVxuICAgICAgdGlsZSA9IHByZXYuaW50ZXJpbVRpbGU7XG4gICAgfSB3aGlsZSAodGlsZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdGlsZSBjb29yZGluYXRlIGZvciB0aGlzIHRpbGUuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gVGhlIHRpbGUgY29vcmRpbmF0ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgVGlsZS5wcm90b3R5cGUuZ2V0VGlsZUNvb3JkID0gZnVuY3Rpb24gZ2V0VGlsZUNvb3JkICgpIHtcbiAgICByZXR1cm4gdGhpcy50aWxlQ29vcmQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1RpbGVTdGF0ZX0gU3RhdGUuXG4gICAqL1xuICBUaWxlLnByb3RvdHlwZS5nZXRTdGF0ZSA9IGZ1bmN0aW9uIGdldFN0YXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB0aGUgc3RhdGUgb2YgdGhpcyB0aWxlLiBJZiB5b3Ugd3JpdGUgeW91ciBvd24ge0BsaW5rIG1vZHVsZTpvbC9UaWxlfkxvYWRGdW5jdGlvbiB0aWxlTG9hZEZ1bmN0aW9ufSAsXG4gICAqIGl0IGlzIGltcG9ydGFudCB0byBzZXQgdGhlIHN0YXRlIGNvcnJlY3RseSB0byB7QGxpbmsgbW9kdWxlOm9sL1RpbGVTdGF0ZX5FUlJPUn1cbiAgICogd2hlbiB0aGUgdGlsZSBjYW5ub3QgYmUgbG9hZGVkLiBPdGhlcndpc2UgdGhlIHRpbGUgY2Fubm90IGJlIHJlbW92ZWQgZnJvbVxuICAgKiB0aGUgdGlsZSBxdWV1ZSBhbmQgd2lsbCBibG9jayBvdGhlciByZXF1ZXN0cy5cbiAgICogQHBhcmFtIHtUaWxlU3RhdGV9IHN0YXRlIFN0YXRlLlxuICAgKiBAYXBpXG4gICAqL1xuICBUaWxlLnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIHNldFN0YXRlIChzdGF0ZSkge1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuICAvKipcbiAgICogTG9hZCB0aGUgaW1hZ2Ugb3IgcmV0cnkgaWYgbG9hZGluZyBwcmV2aW91c2x5IGZhaWxlZC5cbiAgICogTG9hZGluZyBpcyB0YWtlbiBjYXJlIG9mIGJ5IHRoZSB0aWxlIHF1ZXVlLCBhbmQgY2FsbGluZyB0aGlzIG1ldGhvZCBpc1xuICAgKiBvbmx5IG5lZWRlZCBmb3IgcHJlbG9hZGluZyBvciBmb3IgcmVsb2FkaW5nIGluIGNhc2Ugb2YgYW4gZXJyb3IuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAYXBpXG4gICAqL1xuICBUaWxlLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gbG9hZCAoKSB7fTtcblxuICAvKipcbiAgICogR2V0IHRoZSBhbHBoYSB2YWx1ZSBmb3IgcmVuZGVyaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgQW4gaWQgZm9yIHRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgVGhlIHJlbmRlciBmcmFtZSB0aW1lLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMS5cbiAgICovXG4gIFRpbGUucHJvdG90eXBlLmdldEFscGhhID0gZnVuY3Rpb24gZ2V0QWxwaGEgKGlkLCB0aW1lKSB7XG4gICAgaWYgKCF0aGlzLnRyYW5zaXRpb25fKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnQgPSB0aGlzLnRyYW5zaXRpb25TdGFydHNfW2lkXTtcbiAgICBpZiAoIXN0YXJ0KSB7XG4gICAgICBzdGFydCA9IHRpbWU7XG4gICAgICB0aGlzLnRyYW5zaXRpb25TdGFydHNfW2lkXSA9IHN0YXJ0O1xuICAgIH0gZWxzZSBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICB2YXIgZGVsdGEgPSB0aW1lIC0gc3RhcnQgKyAoMTAwMCAvIDYwKTsgLy8gYXZvaWQgcmVuZGVyaW5nIGF0IDBcbiAgICBpZiAoZGVsdGEgPj0gdGhpcy50cmFuc2l0aW9uXykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiBlYXNlSW4oZGVsdGEgLyB0aGlzLnRyYW5zaXRpb25fKTtcbiAgfTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIGEgdGlsZSBpcyBpbiBhbiBhbHBoYSB0cmFuc2l0aW9uLiAgQSB0aWxlIGlzIGNvbnNpZGVyZWQgaW5cbiAgICogdHJhbnNpdGlvbiBpZiB0aWxlLmdldEFscGhhKCkgaGFzIG5vdCB5ZXQgYmVlbiBjYWxsZWQgb3IgaGFzIGJlZW4gY2FsbGVkXG4gICAqIGFuZCByZXR1cm5lZCAxLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgQW4gaWQgZm9yIHRoZSByZW5kZXJlci5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHRpbGUgaXMgaW4gdHJhbnNpdGlvbi5cbiAgICovXG4gIFRpbGUucHJvdG90eXBlLmluVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIGluVHJhbnNpdGlvbiAoaWQpIHtcbiAgICBpZiAoIXRoaXMudHJhbnNpdGlvbl8pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblN0YXJ0c19baWRdICE9PSAtMTtcbiAgfTtcblxuICAvKipcbiAgICogTWFyayBhIHRyYW5zaXRpb24gYXMgY29tcGxldGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBBbiBpZCBmb3IgdGhlIHJlbmRlcmVyLlxuICAgKi9cbiAgVGlsZS5wcm90b3R5cGUuZW5kVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIGVuZFRyYW5zaXRpb24gKGlkKSB7XG4gICAgaWYgKHRoaXMudHJhbnNpdGlvbl8pIHtcbiAgICAgIHRoaXMudHJhbnNpdGlvblN0YXJ0c19baWRdID0gLTE7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBUaWxlO1xufShFdmVudFRhcmdldCkpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IFRpbGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpbGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL1RpbGVDYWNoZVxuICovXG5pbXBvcnQgTFJVQ2FjaGUgZnJvbSAnLi9zdHJ1Y3RzL0xSVUNhY2hlLmpzJztcbmltcG9ydCB7ZnJvbUtleSwgZ2V0S2V5fSBmcm9tICcuL3RpbGVjb29yZC5qcyc7XG5cbnZhciBUaWxlQ2FjaGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChMUlVDYWNoZSkge1xuICBmdW5jdGlvbiBUaWxlQ2FjaGUob3B0X2hpZ2hXYXRlck1hcmspIHtcblxuICAgIExSVUNhY2hlLmNhbGwodGhpcywgb3B0X2hpZ2hXYXRlck1hcmspO1xuXG4gIH1cblxuICBpZiAoIExSVUNhY2hlICkgVGlsZUNhY2hlLl9fcHJvdG9fXyA9IExSVUNhY2hlO1xuICBUaWxlQ2FjaGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTFJVQ2FjaGUgJiYgTFJVQ2FjaGUucHJvdG90eXBlICk7XG4gIFRpbGVDYWNoZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUaWxlQ2FjaGU7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHQ+fSB1c2VkVGlsZXMgVXNlZCB0aWxlcy5cbiAgICovXG4gIFRpbGVDYWNoZS5wcm90b3R5cGUuZXhwaXJlQ2FjaGUgPSBmdW5jdGlvbiBleHBpcmVDYWNoZSAodXNlZFRpbGVzKSB7XG4gICAgd2hpbGUgKHRoaXMuY2FuRXhwaXJlQ2FjaGUoKSkge1xuICAgICAgdmFyIHRpbGUgPSB0aGlzLnBlZWtMYXN0KCk7XG4gICAgICB2YXIgektleSA9IHRpbGUudGlsZUNvb3JkWzBdLnRvU3RyaW5nKCk7XG4gICAgICBpZiAoektleSBpbiB1c2VkVGlsZXMgJiYgdXNlZFRpbGVzW3pLZXldLmNvbnRhaW5zKHRpbGUudGlsZUNvb3JkKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucG9wKCkuZGlzcG9zZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUHJ1bmUgYWxsIHRpbGVzIGZyb20gdGhlIGNhY2hlIHRoYXQgZG9uJ3QgaGF2ZSB0aGUgc2FtZSB6IGFzIHRoZSBuZXdlc3QgdGlsZS5cbiAgICovXG4gIFRpbGVDYWNoZS5wcm90b3R5cGUucHJ1bmVFeGNlcHROZXdlc3RaID0gZnVuY3Rpb24gcHJ1bmVFeGNlcHROZXdlc3RaICgpIHtcbiAgICBpZiAodGhpcy5nZXRDb3VudCgpID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBrZXkgPSB0aGlzLnBlZWtGaXJzdEtleSgpO1xuICAgIHZhciB0aWxlQ29vcmQgPSBmcm9tS2V5KGtleSk7XG4gICAgdmFyIHogPSB0aWxlQ29vcmRbMF07XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHRpbGUpIHtcbiAgICAgIGlmICh0aWxlLnRpbGVDb29yZFswXSAhPT0geikge1xuICAgICAgICB0aGlzLnJlbW92ZShnZXRLZXkodGlsZS50aWxlQ29vcmQpKTtcbiAgICAgICAgdGlsZS5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH07XG5cbiAgcmV0dXJuIFRpbGVDYWNoZTtcbn0oTFJVQ2FjaGUpKTtcblxuXG5leHBvcnQgZGVmYXVsdCBUaWxlQ2FjaGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpbGVDYWNoZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvVGlsZVF1ZXVlXG4gKi9cbmltcG9ydCBUaWxlU3RhdGUgZnJvbSAnLi9UaWxlU3RhdGUuanMnO1xuaW1wb3J0IHtsaXN0ZW4sIHVubGlzdGVufSBmcm9tICcuL2V2ZW50cy5qcyc7XG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgUHJpb3JpdHlRdWV1ZSBmcm9tICcuL3N0cnVjdHMvUHJpb3JpdHlRdWV1ZS5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oaW1wb3J0KFwiLi9UaWxlLmpzXCIpLmRlZmF1bHQsIHN0cmluZywgaW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGUsIG51bWJlcik6IG51bWJlcn0gUHJpb3JpdHlGdW5jdGlvblxuICovXG5cblxudmFyIFRpbGVRdWV1ZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFByaW9yaXR5UXVldWUpIHtcbiAgZnVuY3Rpb24gVGlsZVF1ZXVlKHRpbGVQcmlvcml0eUZ1bmN0aW9uLCB0aWxlQ2hhbmdlQ2FsbGJhY2spIHtcblxuICAgIFByaW9yaXR5UXVldWUuY2FsbChcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtBcnJheX0gZWxlbWVudCBFbGVtZW50LlxuICAgICAgICogQHJldHVybiB7bnVtYmVyfSBQcmlvcml0eS5cbiAgICAgICAqL1xuICAgICAgdGhpcywgZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdGlsZVByaW9yaXR5RnVuY3Rpb24uYXBwbHkobnVsbCwgZWxlbWVudCk7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge0FycmF5fSBlbGVtZW50IEVsZW1lbnQuXG4gICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEtleS5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gKC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9UaWxlLmpzXCIpLmRlZmF1bHR9ICovIChlbGVtZW50WzBdKS5nZXRLZXkoKSk7XG4gICAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKCk6ID99XG4gICAgICovXG4gICAgdGhpcy50aWxlQ2hhbmdlQ2FsbGJhY2tfID0gdGlsZUNoYW5nZUNhbGxiYWNrO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudGlsZXNMb2FkaW5nXyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZyxib29sZWFuPn1cbiAgICAgKi9cbiAgICB0aGlzLnRpbGVzTG9hZGluZ0tleXNfID0ge307XG5cbiAgfVxuXG4gIGlmICggUHJpb3JpdHlRdWV1ZSApIFRpbGVRdWV1ZS5fX3Byb3RvX18gPSBQcmlvcml0eVF1ZXVlO1xuICBUaWxlUXVldWUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUHJpb3JpdHlRdWV1ZSAmJiBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZSApO1xuICBUaWxlUXVldWUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGlsZVF1ZXVlO1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgVGlsZVF1ZXVlLnByb3RvdHlwZS5lbnF1ZXVlID0gZnVuY3Rpb24gZW5xdWV1ZSAoZWxlbWVudCkge1xuICAgIHZhciBhZGRlZCA9IFByaW9yaXR5UXVldWUucHJvdG90eXBlLmVucXVldWUuY2FsbCh0aGlzLCBlbGVtZW50KTtcbiAgICBpZiAoYWRkZWQpIHtcbiAgICAgIHZhciB0aWxlID0gZWxlbWVudFswXTtcbiAgICAgIGxpc3Rlbih0aWxlLCBFdmVudFR5cGUuQ0hBTkdFLCB0aGlzLmhhbmRsZVRpbGVDaGFuZ2UsIHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gYWRkZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gTnVtYmVyIG9mIHRpbGVzIGxvYWRpbmcuXG4gICAqL1xuICBUaWxlUXVldWUucHJvdG90eXBlLmdldFRpbGVzTG9hZGluZyA9IGZ1bmN0aW9uIGdldFRpbGVzTG9hZGluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudGlsZXNMb2FkaW5nXztcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0fSBldmVudCBFdmVudC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgVGlsZVF1ZXVlLnByb3RvdHlwZS5oYW5kbGVUaWxlQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlVGlsZUNoYW5nZSAoZXZlbnQpIHtcbiAgICB2YXIgdGlsZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9UaWxlLmpzXCIpLmRlZmF1bHR9ICovIChldmVudC50YXJnZXQpO1xuICAgIHZhciBzdGF0ZSA9IHRpbGUuZ2V0U3RhdGUoKTtcbiAgICBpZiAoc3RhdGUgPT09IFRpbGVTdGF0ZS5MT0FERUQgfHwgc3RhdGUgPT09IFRpbGVTdGF0ZS5FUlJPUiB8fFxuICAgICAgICBzdGF0ZSA9PT0gVGlsZVN0YXRlLkVNUFRZIHx8IHN0YXRlID09PSBUaWxlU3RhdGUuQUJPUlQpIHtcbiAgICAgIHVubGlzdGVuKHRpbGUsIEV2ZW50VHlwZS5DSEFOR0UsIHRoaXMuaGFuZGxlVGlsZUNoYW5nZSwgdGhpcyk7XG4gICAgICB2YXIgdGlsZUtleSA9IHRpbGUuZ2V0S2V5KCk7XG4gICAgICBpZiAodGlsZUtleSBpbiB0aGlzLnRpbGVzTG9hZGluZ0tleXNfKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnRpbGVzTG9hZGluZ0tleXNfW3RpbGVLZXldO1xuICAgICAgICAtLXRoaXMudGlsZXNMb2FkaW5nXztcbiAgICAgIH1cbiAgICAgIHRoaXMudGlsZUNoYW5nZUNhbGxiYWNrXygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heFRvdGFsTG9hZGluZyBNYXhpbXVtIG51bWJlciB0aWxlcyB0byBsb2FkIHNpbXVsdGFuZW91c2x5LlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4TmV3TG9hZHMgTWF4aW11bSBudW1iZXIgb2YgbmV3IHRpbGVzIHRvIGxvYWQuXG4gICAqL1xuICBUaWxlUXVldWUucHJvdG90eXBlLmxvYWRNb3JlVGlsZXMgPSBmdW5jdGlvbiBsb2FkTW9yZVRpbGVzIChtYXhUb3RhbExvYWRpbmcsIG1heE5ld0xvYWRzKSB7XG4gICAgdmFyIG5ld0xvYWRzID0gMDtcbiAgICB2YXIgYWJvcnRlZFRpbGVzID0gZmFsc2U7XG4gICAgdmFyIHN0YXRlLCB0aWxlLCB0aWxlS2V5O1xuICAgIHdoaWxlICh0aGlzLnRpbGVzTG9hZGluZ18gPCBtYXhUb3RhbExvYWRpbmcgJiYgbmV3TG9hZHMgPCBtYXhOZXdMb2FkcyAmJlxuICAgICAgICAgICB0aGlzLmdldENvdW50KCkgPiAwKSB7XG4gICAgICB0aWxlID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL1RpbGUuanNcIikuZGVmYXVsdH0gKi8gKHRoaXMuZGVxdWV1ZSgpWzBdKTtcbiAgICAgIHRpbGVLZXkgPSB0aWxlLmdldEtleSgpO1xuICAgICAgc3RhdGUgPSB0aWxlLmdldFN0YXRlKCk7XG4gICAgICBpZiAoc3RhdGUgPT09IFRpbGVTdGF0ZS5BQk9SVCkge1xuICAgICAgICBhYm9ydGVkVGlsZXMgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gVGlsZVN0YXRlLklETEUgJiYgISh0aWxlS2V5IGluIHRoaXMudGlsZXNMb2FkaW5nS2V5c18pKSB7XG4gICAgICAgIHRoaXMudGlsZXNMb2FkaW5nS2V5c19bdGlsZUtleV0gPSB0cnVlO1xuICAgICAgICArK3RoaXMudGlsZXNMb2FkaW5nXztcbiAgICAgICAgKytuZXdMb2FkcztcbiAgICAgICAgdGlsZS5sb2FkKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuZXdMb2FkcyA9PT0gMCAmJiBhYm9ydGVkVGlsZXMpIHtcbiAgICAgIC8vIERvIG5vdCBzdG9wIHRoZSByZW5kZXIgbG9vcCB3aGVuIGFsbCB3YW50ZWQgdGlsZXMgd2VyZSBhYm9ydGVkIGR1ZSB0b1xuICAgICAgLy8gYSBzbWFsbCwgc2F0dXJhdGVkIHRpbGUgY2FjaGUuXG4gICAgICB0aGlzLnRpbGVDaGFuZ2VDYWxsYmFja18oKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFRpbGVRdWV1ZTtcbn0oUHJpb3JpdHlRdWV1ZSkpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IFRpbGVRdWV1ZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGlsZVF1ZXVlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9UaWxlUmFuZ2VcbiAqL1xuXG4vKipcbiAqIEEgcmVwcmVzZW50YXRpb24gb2YgYSBjb250aWd1b3VzIGJsb2NrIG9mIHRpbGVzLiAgQSB0aWxlIHJhbmdlIGlzIHNwZWNpZmllZFxuICogYnkgaXRzIG1pbi9tYXggdGlsZSBjb29yZGluYXRlcyBhbmQgaXMgaW5jbHVzaXZlIG9mIGNvb3JkaW5hdGVzLlxuICovXG52YXIgVGlsZVJhbmdlID0gZnVuY3Rpb24gVGlsZVJhbmdlKG1pblgsIG1heFgsIG1pblksIG1heFkpIHtcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMubWluWCA9IG1pblg7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLm1heFggPSBtYXhYO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5taW5ZID0gbWluWTtcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMubWF4WSA9IG1heFk7XG5cbn07XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBDb250YWlucyB0aWxlIGNvb3JkaW5hdGUuXG4gKi9cblRpbGVSYW5nZS5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiBjb250YWlucyAodGlsZUNvb3JkKSB7XG4gIHJldHVybiB0aGlzLmNvbnRhaW5zWFkodGlsZUNvb3JkWzFdLCB0aWxlQ29vcmRbMl0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1RpbGVSYW5nZX0gdGlsZVJhbmdlIFRpbGUgcmFuZ2UuXG4gKiBAcmV0dXJuIHtib29sZWFufSBDb250YWlucy5cbiAqL1xuVGlsZVJhbmdlLnByb3RvdHlwZS5jb250YWluc1RpbGVSYW5nZSA9IGZ1bmN0aW9uIGNvbnRhaW5zVGlsZVJhbmdlICh0aWxlUmFuZ2UpIHtcbiAgcmV0dXJuIHRoaXMubWluWCA8PSB0aWxlUmFuZ2UubWluWCAmJiB0aWxlUmFuZ2UubWF4WCA8PSB0aGlzLm1heFggJiZcbiAgICAgdGhpcy5taW5ZIDw9IHRpbGVSYW5nZS5taW5ZICYmIHRpbGVSYW5nZS5tYXhZIDw9IHRoaXMubWF4WTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHggVGlsZSBjb29yZGluYXRlIHguXG4gKiBAcGFyYW0ge251bWJlcn0geSBUaWxlIGNvb3JkaW5hdGUgeS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IENvbnRhaW5zIGNvb3JkaW5hdGUuXG4gKi9cblRpbGVSYW5nZS5wcm90b3R5cGUuY29udGFpbnNYWSA9IGZ1bmN0aW9uIGNvbnRhaW5zWFkgKHgsIHkpIHtcbiAgcmV0dXJuIHRoaXMubWluWCA8PSB4ICYmIHggPD0gdGhpcy5tYXhYICYmIHRoaXMubWluWSA8PSB5ICYmIHkgPD0gdGhpcy5tYXhZO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1RpbGVSYW5nZX0gdGlsZVJhbmdlIFRpbGUgcmFuZ2UuXG4gKiBAcmV0dXJuIHtib29sZWFufSBFcXVhbHMuXG4gKi9cblRpbGVSYW5nZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzICh0aWxlUmFuZ2UpIHtcbiAgcmV0dXJuIHRoaXMubWluWCA9PSB0aWxlUmFuZ2UubWluWCAmJiB0aGlzLm1pblkgPT0gdGlsZVJhbmdlLm1pblkgJiZcbiAgICAgdGhpcy5tYXhYID09IHRpbGVSYW5nZS5tYXhYICYmIHRoaXMubWF4WSA9PSB0aWxlUmFuZ2UubWF4WTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtUaWxlUmFuZ2V9IHRpbGVSYW5nZSBUaWxlIHJhbmdlLlxuICovXG5UaWxlUmFuZ2UucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uIGV4dGVuZCAodGlsZVJhbmdlKSB7XG4gIGlmICh0aWxlUmFuZ2UubWluWCA8IHRoaXMubWluWCkge1xuICAgIHRoaXMubWluWCA9IHRpbGVSYW5nZS5taW5YO1xuICB9XG4gIGlmICh0aWxlUmFuZ2UubWF4WCA+IHRoaXMubWF4WCkge1xuICAgIHRoaXMubWF4WCA9IHRpbGVSYW5nZS5tYXhYO1xuICB9XG4gIGlmICh0aWxlUmFuZ2UubWluWSA8IHRoaXMubWluWSkge1xuICAgIHRoaXMubWluWSA9IHRpbGVSYW5nZS5taW5ZO1xuICB9XG4gIGlmICh0aWxlUmFuZ2UubWF4WSA+IHRoaXMubWF4WSkge1xuICAgIHRoaXMubWF4WSA9IHRpbGVSYW5nZS5tYXhZO1xuICB9XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge251bWJlcn0gSGVpZ2h0LlxuICovXG5UaWxlUmFuZ2UucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uIGdldEhlaWdodCAoKSB7XG4gIHJldHVybiB0aGlzLm1heFkgLSB0aGlzLm1pblkgKyAxO1xufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gU2l6ZS5cbiAqL1xuVGlsZVJhbmdlLnByb3RvdHlwZS5nZXRTaXplID0gZnVuY3Rpb24gZ2V0U2l6ZSAoKSB7XG4gIHJldHVybiBbdGhpcy5nZXRXaWR0aCgpLCB0aGlzLmdldEhlaWdodCgpXTtcbn07XG5cbi8qKlxuICogQHJldHVybiB7bnVtYmVyfSBXaWR0aC5cbiAqL1xuVGlsZVJhbmdlLnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uIGdldFdpZHRoICgpIHtcbiAgcmV0dXJuIHRoaXMubWF4WCAtIHRoaXMubWluWCArIDE7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VGlsZVJhbmdlfSB0aWxlUmFuZ2UgVGlsZSByYW5nZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IEludGVyc2VjdHMuXG4gKi9cblRpbGVSYW5nZS5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uIGludGVyc2VjdHMgKHRpbGVSYW5nZSkge1xuICByZXR1cm4gdGhpcy5taW5YIDw9IHRpbGVSYW5nZS5tYXhYICYmXG4gICAgIHRoaXMubWF4WCA+PSB0aWxlUmFuZ2UubWluWCAmJlxuICAgICB0aGlzLm1pblkgPD0gdGlsZVJhbmdlLm1heFkgJiZcbiAgICAgdGhpcy5tYXhZID49IHRpbGVSYW5nZS5taW5ZO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5YIE1pbmltdW0gWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhYIE1heGltdW0gWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5ZIE1pbmltdW0gWS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhZIE1heGltdW0gWS5cbiAqIEBwYXJhbSB7VGlsZVJhbmdlPX0gdGlsZVJhbmdlIFRpbGVSYW5nZS5cbiAqIEByZXR1cm4ge1RpbGVSYW5nZX0gVGlsZSByYW5nZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlKG1pblgsIG1heFgsIG1pblksIG1heFksIHRpbGVSYW5nZSkge1xuICBpZiAodGlsZVJhbmdlICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aWxlUmFuZ2UubWluWCA9IG1pblg7XG4gICAgdGlsZVJhbmdlLm1heFggPSBtYXhYO1xuICAgIHRpbGVSYW5nZS5taW5ZID0gbWluWTtcbiAgICB0aWxlUmFuZ2UubWF4WSA9IG1heFk7XG4gICAgcmV0dXJuIHRpbGVSYW5nZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IFRpbGVSYW5nZShtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZKTtcbiAgfVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IFRpbGVSYW5nZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGlsZVJhbmdlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9UaWxlU3RhdGVcbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgSURMRTogMCxcbiAgTE9BRElORzogMSxcbiAgTE9BREVEOiAyLFxuICAvKipcbiAgICogSW5kaWNhdGVzIHRoYXQgdGlsZSBsb2FkaW5nIGZhaWxlZFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgRVJST1I6IDMsXG4gIEVNUFRZOiA0LFxuICBBQk9SVDogNVxufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGlsZVN0YXRlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9WaWV3XG4gKi9cbmltcG9ydCB7REVGQVVMVF9USUxFX1NJWkV9IGZyb20gJy4vdGlsZWdyaWQvY29tbW9uLmpzJztcbmltcG9ydCB7Z2V0VWlkfSBmcm9tICcuL3V0aWwuanMnO1xuaW1wb3J0IHtWT0lEfSBmcm9tICcuL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQge2NyZWF0ZUV4dGVudCwgbm9uZSBhcyBjZW50ZXJOb25lfSBmcm9tICcuL2NlbnRlcmNvbnN0cmFpbnQuanMnO1xuaW1wb3J0IEJhc2VPYmplY3QgZnJvbSAnLi9PYmplY3QuanMnO1xuaW1wb3J0IHtjcmVhdGVTbmFwVG9SZXNvbHV0aW9ucywgY3JlYXRlU25hcFRvUG93ZXJ9IGZyb20gJy4vcmVzb2x1dGlvbmNvbnN0cmFpbnQuanMnO1xuaW1wb3J0IHtjcmVhdGVTbmFwVG9aZXJvLCBjcmVhdGVTbmFwVG9OLCBub25lIGFzIHJvdGF0aW9uTm9uZSwgZGlzYWJsZX0gZnJvbSAnLi9yb3RhdGlvbmNvbnN0cmFpbnQuanMnO1xuaW1wb3J0IFZpZXdIaW50IGZyb20gJy4vVmlld0hpbnQuanMnO1xuaW1wb3J0IFZpZXdQcm9wZXJ0eSBmcm9tICcuL1ZpZXdQcm9wZXJ0eS5qcyc7XG5pbXBvcnQge2xpbmVhckZpbmROZWFyZXN0fSBmcm9tICcuL2FycmF5LmpzJztcbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuL2Fzc2VydHMuanMnO1xuaW1wb3J0IHthZGQgYXMgYWRkQ29vcmRpbmF0ZSwgcm90YXRlIGFzIHJvdGF0ZUNvb3JkaW5hdGUsIGVxdWFscyBhcyBjb29yZGluYXRlc0VxdWFsfSBmcm9tICcuL2Nvb3JkaW5hdGUuanMnO1xuaW1wb3J0IHtpbkFuZE91dH0gZnJvbSAnLi9lYXNpbmcuanMnO1xuaW1wb3J0IHtnZXRGb3JWaWV3QW5kU2l6ZSwgZ2V0Q2VudGVyLCBnZXRIZWlnaHQsIGdldFdpZHRoLCBpc0VtcHR5fSBmcm9tICcuL2V4dGVudC5qcyc7XG5pbXBvcnQgR2VvbWV0cnlUeXBlIGZyb20gJy4vZ2VvbS9HZW9tZXRyeVR5cGUuanMnO1xuaW1wb3J0IHtmcm9tRXh0ZW50IGFzIHBvbHlnb25Gcm9tRXh0ZW50fSBmcm9tICcuL2dlb20vUG9seWdvbi5qcyc7XG5pbXBvcnQge2NsYW1wLCBtb2R1bG99IGZyb20gJy4vbWF0aC5qcyc7XG5pbXBvcnQge2Fzc2lnbn0gZnJvbSAnLi9vYmouanMnO1xuaW1wb3J0IHtjcmVhdGVQcm9qZWN0aW9uLCBNRVRFUlNfUEVSX1VOSVR9IGZyb20gJy4vcHJvai5qcyc7XG5pbXBvcnQgVW5pdHMgZnJvbSAnLi9wcm9qL1VuaXRzLmpzJztcblxuXG4vKipcbiAqIEFuIGFuaW1hdGlvbiBjb25maWd1cmF0aW9uXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gQW5pbWF0aW9uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBbc291cmNlQ2VudGVyXVxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gW3RhcmdldENlbnRlcl1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc291cmNlUmVzb2x1dGlvbl1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdGFyZ2V0UmVzb2x1dGlvbl1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc291cmNlUm90YXRpb25dXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RhcmdldFJvdGF0aW9uXVxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gW2FuY2hvcl1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdGFydFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGR1cmF0aW9uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGNvbXBsZXRlXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKG51bWJlcik6bnVtYmVyfSBlYXNpbmdcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oYm9vbGVhbil9IGNhbGxiYWNrXG4gKi9cblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENvbnN0cmFpbnRzXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vY2VudGVyY29uc3RyYWludC5qc1wiKS5UeXBlfSBjZW50ZXJcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9yZXNvbHV0aW9uY29uc3RyYWludC5qc1wiKS5UeXBlfSByZXNvbHV0aW9uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vcm90YXRpb25jb25zdHJhaW50LmpzXCIpLlR5cGV9IHJvdGF0aW9uXG4gKi9cblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEZpdE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9IFtzaXplXSBUaGUgc2l6ZSBpbiBwaXhlbHMgb2YgdGhlIGJveCB0byBmaXRcbiAqIHRoZSBleHRlbnQgaW50by4gRGVmYXVsdCBpcyB0aGUgY3VycmVudCBzaXplIG9mIHRoZSBmaXJzdCBtYXAgaW4gdGhlIERPTSB0aGF0XG4gKiB1c2VzIHRoaXMgdmlldywgb3IgYFsxMDAsIDEwMF1gIGlmIG5vIHN1Y2ggbWFwIGlzIGZvdW5kLlxuICogQHByb3BlcnR5IHshQXJyYXk8bnVtYmVyPn0gW3BhZGRpbmc9WzAsIDAsIDAsIDBdXSBQYWRkaW5nIChpbiBwaXhlbHMpIHRvIGJlXG4gKiBjbGVhcmVkIGluc2lkZSB0aGUgdmlldy4gVmFsdWVzIGluIHRoZSBhcnJheSBhcmUgdG9wLCByaWdodCwgYm90dG9tIGFuZCBsZWZ0XG4gKiBwYWRkaW5nLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbY29uc3RyYWluUmVzb2x1dGlvbj10cnVlXSBDb25zdHJhaW4gdGhlIHJlc29sdXRpb24uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtuZWFyZXN0PWZhbHNlXSBJZiBgY29uc3RyYWluUmVzb2x1dGlvbmAgaXMgYHRydWVgLCBnZXRcbiAqIHRoZSBuZWFyZXN0IGV4dGVudCBpbnN0ZWFkIG9mIHRoZSBjbG9zZXN0IHRoYXQgYWN0dWFsbHkgZml0cyB0aGUgdmlldy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluUmVzb2x1dGlvbj0wXSBNaW5pbXVtIHJlc29sdXRpb24gdGhhdCB3ZSB6b29tIHRvLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhab29tXSBNYXhpbXVtIHpvb20gbGV2ZWwgdGhhdCB3ZSB6b29tIHRvLiBJZlxuICogYG1pblJlc29sdXRpb25gIGlzIGdpdmVuLCB0aGlzIHByb3BlcnR5IGlzIGlnbm9yZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2R1cmF0aW9uXSBUaGUgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gKiBCeSBkZWZhdWx0LCB0aGVyZSBpcyBubyBhbmltYXRpb24gdG8gdGhlIHRhcmdldCBleHRlbnQuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKG51bWJlcik6bnVtYmVyfSBbZWFzaW5nXSBUaGUgZWFzaW5nIGZ1bmN0aW9uIHVzZWQgZHVyaW5nXG4gKiB0aGUgYW5pbWF0aW9uIChkZWZhdWx0cyB0byB7QGxpbmsgbW9kdWxlOm9sL2Vhc2luZ35pbkFuZE91dH0pLlxuICogVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIGZyYW1lIHdpdGggYSBudW1iZXIgcmVwcmVzZW50aW5nIGFcbiAqIGZyYWN0aW9uIG9mIHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbi4gIFRoZSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgbnVtYmVyXG4gKiBiZXR3ZWVuIDAgYW5kIDEgcmVwcmVzZW50aW5nIHRoZSBwcm9ncmVzcyB0b3dhcmQgdGhlIGRlc3RpbmF0aW9uIHN0YXRlLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbihib29sZWFuKX0gW2NhbGxiYWNrXSBGdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgdmlldyBpcyBpblxuICogaXRzIGZpbmFsIHBvc2l0aW9uLiBUaGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2l0aCBgdHJ1ZWAgaWYgdGhlIGFuaW1hdGlvblxuICogc2VyaWVzIGNvbXBsZXRlZCBvbiBpdHMgb3duIG9yIGBmYWxzZWAgaWYgaXQgd2FzIGNhbmNlbGxlZC5cbiAqL1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVmlld09wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFtjZW50ZXJdIFRoZSBpbml0aWFsIGNlbnRlciBmb3JcbiAqIHRoZSB2aWV3LiBUaGUgY29vcmRpbmF0ZSBzeXN0ZW0gZm9yIHRoZSBjZW50ZXIgaXMgc3BlY2lmaWVkIHdpdGggdGhlXG4gKiBgcHJvamVjdGlvbmAgb3B0aW9uLiBMYXllciBzb3VyY2VzIHdpbGwgbm90IGJlIGZldGNoZWQgaWYgdGhpcyBpcyBub3Qgc2V0LFxuICogYnV0IHRoZSBjZW50ZXIgY2FuIGJlIHNldCBsYXRlciB3aXRoIHtAbGluayAjc2V0Q2VudGVyfS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbnxudW1iZXJ9IFtjb25zdHJhaW5Sb3RhdGlvbj10cnVlXSBSb3RhdGlvbiBjb25zdHJhaW50LlxuICogYGZhbHNlYCBtZWFucyBubyBjb25zdHJhaW50LiBgdHJ1ZWAgbWVhbnMgbm8gY29uc3RyYWludCwgYnV0IHNuYXAgdG8gemVyb1xuICogbmVhciB6ZXJvLiBBIG51bWJlciBjb25zdHJhaW5zIHRoZSByb3RhdGlvbiB0byB0aGF0IG51bWJlciBvZiB2YWx1ZXMuIEZvclxuICogZXhhbXBsZSwgYDRgIHdpbGwgY29uc3RyYWluIHRoZSByb3RhdGlvbiB0byAwLCA5MCwgMTgwLCBhbmQgMjcwIGRlZ3JlZXMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtlbmFibGVSb3RhdGlvbj10cnVlXSBFbmFibGUgcm90YXRpb24uXG4gKiBJZiBgZmFsc2VgLCBhIHJvdGF0aW9uIGNvbnN0cmFpbnQgdGhhdCBhbHdheXMgc2V0cyB0aGUgcm90YXRpb24gdG8gemVybyBpc1xuICogdXNlZC4gVGhlIGBjb25zdHJhaW5Sb3RhdGlvbmAgb3B0aW9uIGhhcyBubyBlZmZlY3QgaWYgYGVuYWJsZVJvdGF0aW9uYCBpc1xuICogYGZhbHNlYC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBbZXh0ZW50XSBUaGUgZXh0ZW50IHRoYXQgY29uc3RyYWlucyB0aGVcbiAqIGNlbnRlciwgaW4gb3RoZXIgd29yZHMsIGNlbnRlciBjYW5ub3QgYmUgc2V0IG91dHNpZGUgdGhpcyBleHRlbnQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFJlc29sdXRpb25dIFRoZSBtYXhpbXVtIHJlc29sdXRpb24gdXNlZCB0byBkZXRlcm1pbmVcbiAqIHRoZSByZXNvbHV0aW9uIGNvbnN0cmFpbnQuIEl0IGlzIHVzZWQgdG9nZXRoZXIgd2l0aCBgbWluUmVzb2x1dGlvbmAgKG9yXG4gKiBgbWF4Wm9vbWApIGFuZCBgem9vbUZhY3RvcmAuIElmIHVuc3BlY2lmaWVkIGl0IGlzIGNhbGN1bGF0ZWQgaW4gc3VjaCBhIHdheVxuICogdGhhdCB0aGUgcHJvamVjdGlvbidzIHZhbGlkaXR5IGV4dGVudCBmaXRzIGluIGEgMjU2eDI1NiBweCB0aWxlLiBJZiB0aGVcbiAqIHByb2plY3Rpb24gaXMgU3BoZXJpY2FsIE1lcmNhdG9yICh0aGUgZGVmYXVsdCkgdGhlbiBgbWF4UmVzb2x1dGlvbmAgZGVmYXVsdHNcbiAqIHRvIGA0MDA3NTAxNi42ODU1Nzg0OSAvIDI1NiA9IDE1NjU0My4wMzM5MjgwNDA5N2AuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pblJlc29sdXRpb25dIFRoZSBtaW5pbXVtIHJlc29sdXRpb24gdXNlZCB0byBkZXRlcm1pbmVcbiAqIHRoZSByZXNvbHV0aW9uIGNvbnN0cmFpbnQuICBJdCBpcyB1c2VkIHRvZ2V0aGVyIHdpdGggYG1heFJlc29sdXRpb25gIChvclxuICogYG1pblpvb21gKSBhbmQgYHpvb21GYWN0b3JgLiAgSWYgdW5zcGVjaWZpZWQgaXQgaXMgY2FsY3VsYXRlZCBhc3N1bWluZyAyOVxuICogem9vbSBsZXZlbHMgKHdpdGggYSBmYWN0b3Igb2YgMikuIElmIHRoZSBwcm9qZWN0aW9uIGlzIFNwaGVyaWNhbCBNZXJjYXRvclxuICogKHRoZSBkZWZhdWx0KSB0aGVuIGBtaW5SZXNvbHV0aW9uYCBkZWZhdWx0cyB0b1xuICogYDQwMDc1MDE2LjY4NTU3ODQ5IC8gMjU2IC8gTWF0aC5wb3coMiwgMjgpID0gMC4wMDA1ODMxNjgyNDU1ODM5MjUzYC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4Wm9vbT0yOF0gVGhlIG1heGltdW0gem9vbSBsZXZlbCB1c2VkIHRvIGRldGVybWluZSB0aGVcbiAqIHJlc29sdXRpb24gY29uc3RyYWludC4gSXQgaXMgdXNlZCB0b2dldGhlciB3aXRoIGBtaW5ab29tYCAob3JcbiAqIGBtYXhSZXNvbHV0aW9uYCkgYW5kIGB6b29tRmFjdG9yYC4gIE5vdGUgdGhhdCBpZiBgbWluUmVzb2x1dGlvbmAgaXMgYWxzb1xuICogcHJvdmlkZWQsIGl0IGlzIGdpdmVuIHByZWNlZGVuY2Ugb3ZlciBgbWF4Wm9vbWAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pblpvb209MF0gVGhlIG1pbmltdW0gem9vbSBsZXZlbCB1c2VkIHRvIGRldGVybWluZSB0aGVcbiAqIHJlc29sdXRpb24gY29uc3RyYWludC4gSXQgaXMgdXNlZCB0b2dldGhlciB3aXRoIGBtYXhab29tYCAob3JcbiAqIGBtaW5SZXNvbHV0aW9uYCkgYW5kIGB6b29tRmFjdG9yYC4gIE5vdGUgdGhhdCBpZiBgbWF4UmVzb2x1dGlvbmAgaXMgYWxzb1xuICogcHJvdmlkZWQsIGl0IGlzIGdpdmVuIHByZWNlZGVuY2Ugb3ZlciBgbWluWm9vbWAuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gW3Byb2plY3Rpb249J0VQU0c6Mzg1NyddIFRoZVxuICogcHJvamVjdGlvbi4gVGhlIGRlZmF1bHQgaXMgU3BoZXJpY2FsIE1lcmNhdG9yLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyZXNvbHV0aW9uXSBUaGUgaW5pdGlhbCByZXNvbHV0aW9uIGZvciB0aGUgdmlldy4gVGhlXG4gKiB1bml0cyBhcmUgYHByb2plY3Rpb25gIHVuaXRzIHBlciBwaXhlbCAoZS5nLiBtZXRlcnMgcGVyIHBpeGVsKS4gQW5cbiAqIGFsdGVybmF0aXZlIHRvIHNldHRpbmcgdGhpcyBpcyB0byBzZXQgYHpvb21gLiBMYXllciBzb3VyY2VzIHdpbGwgbm90IGJlXG4gKiBmZXRjaGVkIGlmIG5laXRoZXIgdGhpcyBub3IgYHpvb21gIGFyZSBkZWZpbmVkLCBidXQgdGhleSBjYW4gYmUgc2V0IGxhdGVyXG4gKiB3aXRoIHtAbGluayAjc2V0Wm9vbX0gb3Ige0BsaW5rICNzZXRSZXNvbHV0aW9ufS5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gW3Jlc29sdXRpb25zXSBSZXNvbHV0aW9ucyB0byBkZXRlcm1pbmUgdGhlXG4gKiByZXNvbHV0aW9uIGNvbnN0cmFpbnQuIElmIHNldCB0aGUgYG1heFJlc29sdXRpb25gLCBgbWluUmVzb2x1dGlvbmAsXG4gKiBgbWluWm9vbWAsIGBtYXhab29tYCwgYW5kIGB6b29tRmFjdG9yYCBvcHRpb25zIGFyZSBpZ25vcmVkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyb3RhdGlvbj0wXSBUaGUgaW5pdGlhbCByb3RhdGlvbiBmb3IgdGhlIHZpZXcgaW4gcmFkaWFuc1xuICogKHBvc2l0aXZlIHJvdGF0aW9uIGNsb2Nrd2lzZSwgMCBtZWFucyBOb3J0aCkuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3pvb21dIE9ubHkgdXNlZCBpZiBgcmVzb2x1dGlvbmAgaXMgbm90IGRlZmluZWQuIFpvb21cbiAqIGxldmVsIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBpbml0aWFsIHJlc29sdXRpb24gZm9yIHRoZSB2aWV3LiBUaGUgaW5pdGlhbFxuICogcmVzb2x1dGlvbiBpcyBkZXRlcm1pbmVkIHVzaW5nIHRoZSB7QGxpbmsgI2NvbnN0cmFpblJlc29sdXRpb259IG1ldGhvZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbem9vbUZhY3Rvcj0yXSBUaGUgem9vbSBmYWN0b3IgdXNlZCB0byBkZXRlcm1pbmUgdGhlXG4gKiByZXNvbHV0aW9uIGNvbnN0cmFpbnQuXG4gKi9cblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEFuaW1hdGlvbk9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFtjZW50ZXJdIFRoZSBjZW50ZXIgb2YgdGhlIHZpZXcgYXQgdGhlIGVuZCBvZlxuICogdGhlIGFuaW1hdGlvbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbem9vbV0gVGhlIHpvb20gbGV2ZWwgb2YgdGhlIHZpZXcgYXQgdGhlIGVuZCBvZiB0aGVcbiAqIGFuaW1hdGlvbi4gVGhpcyB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgYHJlc29sdXRpb25gLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyZXNvbHV0aW9uXSBUaGUgcmVzb2x1dGlvbiBvZiB0aGUgdmlldyBhdCB0aGUgZW5kXG4gKiBvZiB0aGUgYW5pbWF0aW9uLiAgSWYgYHpvb21gIGlzIGFsc28gcHJvdmlkZWQsIHRoaXMgb3B0aW9uIHdpbGwgYmUgaWdub3JlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcm90YXRpb25dIFRoZSByb3RhdGlvbiBvZiB0aGUgdmlldyBhdCB0aGUgZW5kIG9mXG4gKiB0aGUgYW5pbWF0aW9uLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gW2FuY2hvcl0gT3B0aW9uYWwgYW5jaG9yIHRvIHJlbWFpbmVkIGZpeGVkXG4gKiBkdXJpbmcgYSByb3RhdGlvbiBvciByZXNvbHV0aW9uIGFuaW1hdGlvbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHVyYXRpb249MTAwMF0gVGhlIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbihudW1iZXIpOm51bWJlcn0gW2Vhc2luZ10gVGhlIGVhc2luZyBmdW5jdGlvbiB1c2VkXG4gKiBkdXJpbmcgdGhlIGFuaW1hdGlvbiAoZGVmYXVsdHMgdG8ge0BsaW5rIG1vZHVsZTpvbC9lYXNpbmd+aW5BbmRPdXR9KS5cbiAqIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaCBmcmFtZSB3aXRoIGEgbnVtYmVyIHJlcHJlc2VudGluZyBhXG4gKiBmcmFjdGlvbiBvZiB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24uICBUaGUgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIG51bWJlclxuICogYmV0d2VlbiAwIGFuZCAxIHJlcHJlc2VudGluZyB0aGUgcHJvZ3Jlc3MgdG93YXJkIHRoZSBkZXN0aW5hdGlvbiBzdGF0ZS5cbiAqL1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU3RhdGVcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNlbnRlclxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uXG4gKiBAcHJvcGVydHkge251bWJlcn0gcmVzb2x1dGlvblxuICogQHByb3BlcnR5IHtudW1iZXJ9IHJvdGF0aW9uXG4gKiBAcHJvcGVydHkge251bWJlcn0gem9vbVxuICovXG5cblxuLyoqXG4gKiBEZWZhdWx0IG1pbiB6b29tIGxldmVsIGZvciB0aGUgbWFwIHZpZXcuXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG52YXIgREVGQVVMVF9NSU5fWk9PTSA9IDA7XG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBIFZpZXcgb2JqZWN0IHJlcHJlc2VudHMgYSBzaW1wbGUgMkQgdmlldyBvZiB0aGUgbWFwLlxuICpcbiAqIFRoaXMgaXMgdGhlIG9iamVjdCB0byBhY3QgdXBvbiB0byBjaGFuZ2UgdGhlIGNlbnRlciwgcmVzb2x1dGlvbixcbiAqIGFuZCByb3RhdGlvbiBvZiB0aGUgbWFwLlxuICpcbiAqICMjIyBUaGUgdmlldyBzdGF0ZXNcbiAqXG4gKiBBbiBWaWV3IGlzIGRldGVybWluZWQgYnkgdGhyZWUgc3RhdGVzOiBgY2VudGVyYCwgYHJlc29sdXRpb25gLFxuICogYW5kIGByb3RhdGlvbmAuIEVhY2ggc3RhdGUgaGFzIGEgY29ycmVzcG9uZGluZyBnZXR0ZXIgYW5kIHNldHRlciwgZS5nLlxuICogYGdldENlbnRlcmAgYW5kIGBzZXRDZW50ZXJgIGZvciB0aGUgYGNlbnRlcmAgc3RhdGUuXG4gKlxuICogQW4gVmlldyBoYXMgYSBgcHJvamVjdGlvbmAuIFRoZSBwcm9qZWN0aW9uIGRldGVybWluZXMgdGhlXG4gKiBjb29yZGluYXRlIHN5c3RlbSBvZiB0aGUgY2VudGVyLCBhbmQgaXRzIHVuaXRzIGRldGVybWluZSB0aGUgdW5pdHMgb2YgdGhlXG4gKiByZXNvbHV0aW9uIChwcm9qZWN0aW9uIHVuaXRzIHBlciBwaXhlbCkuIFRoZSBkZWZhdWx0IHByb2plY3Rpb24gaXNcbiAqIFNwaGVyaWNhbCBNZXJjYXRvciAoRVBTRzozODU3KS5cbiAqXG4gKiAjIyMgVGhlIGNvbnN0cmFpbnRzXG4gKlxuICogYHNldENlbnRlcmAsIGBzZXRSZXNvbHV0aW9uYCBhbmQgYHNldFJvdGF0aW9uYCBjYW4gYmUgdXNlZCB0byBjaGFuZ2UgdGhlXG4gKiBzdGF0ZXMgb2YgdGhlIHZpZXcuIEFueSB2YWx1ZSBjYW4gYmUgcGFzc2VkIHRvIHRoZSBzZXR0ZXJzLiBBbmQgdGhlIHZhbHVlXG4gKiB0aGF0IGlzIHBhc3NlZCB0byBhIHNldHRlciB3aWxsIGVmZmVjdGl2ZWx5IGJlIHRoZSB2YWx1ZSBzZXQgaW4gdGhlIHZpZXcsXG4gKiBhbmQgcmV0dXJuZWQgYnkgdGhlIGNvcnJlc3BvbmRpbmcgZ2V0dGVyLlxuICpcbiAqIEJ1dCBhIFZpZXcgb2JqZWN0IGFsc28gaGFzIGEgKnJlc29sdXRpb24gY29uc3RyYWludCosIGFcbiAqICpyb3RhdGlvbiBjb25zdHJhaW50KiBhbmQgYSAqY2VudGVyIGNvbnN0cmFpbnQqLlxuICpcbiAqIEFzIHNhaWQgYWJvdmUsIG5vIGNvbnN0cmFpbnRzIGFyZSBhcHBsaWVkIHdoZW4gdGhlIHNldHRlcnMgYXJlIHVzZWQgdG8gc2V0XG4gKiBuZXcgc3RhdGVzIGZvciB0aGUgdmlldy4gQXBwbHlpbmcgY29uc3RyYWludHMgaXMgZG9uZSBleHBsaWNpdGx5IHRocm91Z2hcbiAqIHRoZSB1c2Ugb2YgdGhlIGBjb25zdHJhaW4qYCBmdW5jdGlvbnMgKGBjb25zdHJhaW5SZXNvbHV0aW9uYCBhbmRcbiAqIGBjb25zdHJhaW5Sb3RhdGlvbmAgYW5kIGBjb25zdHJhaW5DZW50ZXJgKS5cbiAqXG4gKiBUaGUgbWFpbiB1c2VycyBvZiB0aGUgY29uc3RyYWludHMgYXJlIHRoZSBpbnRlcmFjdGlvbnMgYW5kIHRoZVxuICogY29udHJvbHMuIEZvciBleGFtcGxlLCBkb3VibGUtY2xpY2tpbmcgb24gdGhlIG1hcCBjaGFuZ2VzIHRoZSB2aWV3IHRvXG4gKiB0aGUgXCJuZXh0XCIgcmVzb2x1dGlvbi4gQW5kIHJlbGVhc2luZyB0aGUgZmluZ2VycyBhZnRlciBwaW5jaC16b29taW5nXG4gKiBzbmFwcyB0byB0aGUgY2xvc2VzdCByZXNvbHV0aW9uICh3aXRoIGFuIGFuaW1hdGlvbikuXG4gKlxuICogVGhlICpyZXNvbHV0aW9uIGNvbnN0cmFpbnQqIHNuYXBzIHRvIHNwZWNpZmljIHJlc29sdXRpb25zLiBJdCBpc1xuICogZGV0ZXJtaW5lZCBieSB0aGUgZm9sbG93aW5nIG9wdGlvbnM6IGByZXNvbHV0aW9uc2AsIGBtYXhSZXNvbHV0aW9uYCxcbiAqIGBtYXhab29tYCwgYW5kIGB6b29tRmFjdG9yYC4gSWYgYHJlc29sdXRpb25zYCBpcyBzZXQsIHRoZSBvdGhlciB0aHJlZVxuICogb3B0aW9ucyBhcmUgaWdub3JlZC4gU2VlIGRvY3VtZW50YXRpb24gZm9yIGVhY2ggb3B0aW9uIGZvciBtb3JlXG4gKiBpbmZvcm1hdGlvbi5cbiAqXG4gKiBUaGUgKnJvdGF0aW9uIGNvbnN0cmFpbnQqIHNuYXBzIHRvIHNwZWNpZmljIGFuZ2xlcy4gSXQgaXMgZGV0ZXJtaW5lZFxuICogYnkgdGhlIGZvbGxvd2luZyBvcHRpb25zOiBgZW5hYmxlUm90YXRpb25gIGFuZCBgY29uc3RyYWluUm90YXRpb25gLlxuICogQnkgZGVmYXVsdCB0aGUgcm90YXRpb24gdmFsdWUgaXMgc25hcHBlZCB0byB6ZXJvIHdoZW4gYXBwcm9hY2hpbmcgdGhlXG4gKiBob3Jpem9udGFsLlxuICpcbiAqIFRoZSAqY2VudGVyIGNvbnN0cmFpbnQqIGlzIGRldGVybWluZWQgYnkgdGhlIGBleHRlbnRgIG9wdGlvbi4gQnlcbiAqIGRlZmF1bHQgdGhlIGNlbnRlciBpcyBub3QgY29uc3RyYWluZWQgYXQgYWxsLlxuICpcbiAgKiBAYXBpXG4gKi9cbnZhciBWaWV3ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoQmFzZU9iamVjdCkge1xuICBmdW5jdGlvbiBWaWV3KG9wdF9vcHRpb25zKSB7XG4gICAgQmFzZU9iamVjdC5jYWxsKHRoaXMpO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBhc3NpZ24oe30sIG9wdF9vcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5oaW50c18gPSBbMCwgMF07XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxBcnJheTxBbmltYXRpb24+Pn1cbiAgICAgKi9cbiAgICB0aGlzLmFuaW1hdGlvbnNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMudXBkYXRlQW5pbWF0aW9uS2V5XztcblxuICAgIHRoaXMudXBkYXRlQW5pbWF0aW9uc18gPSB0aGlzLnVwZGF0ZUFuaW1hdGlvbnNfLmJpbmQodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMucHJvamVjdGlvbl8gPSBjcmVhdGVQcm9qZWN0aW9uKG9wdGlvbnMucHJvamVjdGlvbiwgJ0VQU0c6Mzg1NycpO1xuXG4gICAgdGhpcy5hcHBseU9wdGlvbnNfKG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKCBCYXNlT2JqZWN0ICkgVmlldy5fX3Byb3RvX18gPSBCYXNlT2JqZWN0O1xuICBWaWV3LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJhc2VPYmplY3QgJiYgQmFzZU9iamVjdC5wcm90b3R5cGUgKTtcbiAgVmlldy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBWaWV3O1xuXG4gIC8qKlxuICAgKiBTZXQgdXAgdGhlIHZpZXcgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbiAgICogQHBhcmFtIHtWaWV3T3B0aW9uc30gb3B0aW9ucyBWaWV3IG9wdGlvbnMuXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5hcHBseU9wdGlvbnNfID0gZnVuY3Rpb24gYXBwbHlPcHRpb25zXyAob3B0aW9ucykge1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsICo+fVxuICAgICAqL1xuICAgIHZhciBwcm9wZXJ0aWVzID0ge307XG4gICAgcHJvcGVydGllc1tWaWV3UHJvcGVydHkuQ0VOVEVSXSA9IG9wdGlvbnMuY2VudGVyICE9PSB1bmRlZmluZWQgP1xuICAgICAgb3B0aW9ucy5jZW50ZXIgOiBudWxsO1xuXG4gICAgdmFyIHJlc29sdXRpb25Db25zdHJhaW50SW5mbyA9IGNyZWF0ZVJlc29sdXRpb25Db25zdHJhaW50KG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4UmVzb2x1dGlvbl8gPSByZXNvbHV0aW9uQ29uc3RyYWludEluZm8ubWF4UmVzb2x1dGlvbjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1pblJlc29sdXRpb25fID0gcmVzb2x1dGlvbkNvbnN0cmFpbnRJbmZvLm1pblJlc29sdXRpb247XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy56b29tRmFjdG9yXyA9IHJlc29sdXRpb25Db25zdHJhaW50SW5mby56b29tRmFjdG9yO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5yZXNvbHV0aW9uc18gPSBvcHRpb25zLnJlc29sdXRpb25zO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWluWm9vbV8gPSByZXNvbHV0aW9uQ29uc3RyYWludEluZm8ubWluWm9vbTtcblxuICAgIHZhciBjZW50ZXJDb25zdHJhaW50ID0gY3JlYXRlQ2VudGVyQ29uc3RyYWludChvcHRpb25zKTtcbiAgICB2YXIgcmVzb2x1dGlvbkNvbnN0cmFpbnQgPSByZXNvbHV0aW9uQ29uc3RyYWludEluZm8uY29uc3RyYWludDtcbiAgICB2YXIgcm90YXRpb25Db25zdHJhaW50ID0gY3JlYXRlUm90YXRpb25Db25zdHJhaW50KG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Q29uc3RyYWludHN9XG4gICAgICovXG4gICAgdGhpcy5jb25zdHJhaW50c18gPSB7XG4gICAgICBjZW50ZXI6IGNlbnRlckNvbnN0cmFpbnQsXG4gICAgICByZXNvbHV0aW9uOiByZXNvbHV0aW9uQ29uc3RyYWludCxcbiAgICAgIHJvdGF0aW9uOiByb3RhdGlvbkNvbnN0cmFpbnRcbiAgICB9O1xuXG4gICAgaWYgKG9wdGlvbnMucmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwcm9wZXJ0aWVzW1ZpZXdQcm9wZXJ0eS5SRVNPTFVUSU9OXSA9IG9wdGlvbnMucmVzb2x1dGlvbjtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuem9vbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwcm9wZXJ0aWVzW1ZpZXdQcm9wZXJ0eS5SRVNPTFVUSU9OXSA9IHRoaXMuY29uc3RyYWluUmVzb2x1dGlvbihcbiAgICAgICAgdGhpcy5tYXhSZXNvbHV0aW9uXywgb3B0aW9ucy56b29tIC0gdGhpcy5taW5ab29tXyk7XG5cbiAgICAgIGlmICh0aGlzLnJlc29sdXRpb25zXykgeyAvLyBpbiBjYXNlIG1hcCB6b29tIGlzIG91dCBvZiBtaW4vbWF4IHpvb20gcmFuZ2VcbiAgICAgICAgcHJvcGVydGllc1tWaWV3UHJvcGVydHkuUkVTT0xVVElPTl0gPSBjbGFtcChcbiAgICAgICAgICBOdW1iZXIodGhpcy5nZXRSZXNvbHV0aW9uKCkgfHwgcHJvcGVydGllc1tWaWV3UHJvcGVydHkuUkVTT0xVVElPTl0pLFxuICAgICAgICAgIHRoaXMubWluUmVzb2x1dGlvbl8sIHRoaXMubWF4UmVzb2x1dGlvbl8pO1xuICAgICAgfVxuICAgIH1cbiAgICBwcm9wZXJ0aWVzW1ZpZXdQcm9wZXJ0eS5ST1RBVElPTl0gPSBvcHRpb25zLnJvdGF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnJvdGF0aW9uIDogMDtcbiAgICB0aGlzLnNldFByb3BlcnRpZXMocHJvcGVydGllcyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtWaWV3T3B0aW9uc31cbiAgICAgKi9cbiAgICB0aGlzLm9wdGlvbnNfID0gb3B0aW9ucztcblxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYW4gdXBkYXRlZCB2ZXJzaW9uIG9mIHRoZSB2aWV3IG9wdGlvbnMgdXNlZCB0byBjb25zdHJ1Y3QgdGhlIHZpZXcuICBUaGVcbiAgICogY3VycmVudCByZXNvbHV0aW9uIChvciB6b29tKSwgY2VudGVyLCBhbmQgcm90YXRpb24gYXJlIGFwcGxpZWQgdG8gYW55IHN0b3JlZFxuICAgKiBvcHRpb25zLiAgVGhlIHByb3ZpZGVkIG9wdGlvbnMgY2FuIGJlIHVzZWQgdG8gYXBwbHkgbmV3IG1pbi9tYXggem9vbSBvclxuICAgKiByZXNvbHV0aW9uIGxpbWl0cy5cbiAgICogQHBhcmFtIHtWaWV3T3B0aW9uc30gbmV3T3B0aW9ucyBOZXcgb3B0aW9ucyB0byBiZSBhcHBsaWVkLlxuICAgKiBAcmV0dXJuIHtWaWV3T3B0aW9uc30gTmV3IG9wdGlvbnMgdXBkYXRlZCB3aXRoIHRoZSBjdXJyZW50IHZpZXcgc3RhdGUuXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5nZXRVcGRhdGVkT3B0aW9uc18gPSBmdW5jdGlvbiBnZXRVcGRhdGVkT3B0aW9uc18gKG5ld09wdGlvbnMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFzc2lnbih7fSwgdGhpcy5vcHRpb25zXyk7XG5cbiAgICAvLyBwcmVzZXJ2ZSByZXNvbHV0aW9uIChvciB6b29tKVxuICAgIGlmIChvcHRpb25zLnJlc29sdXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0aW9ucy5yZXNvbHV0aW9uID0gdGhpcy5nZXRSZXNvbHV0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMuem9vbSA9IHRoaXMuZ2V0Wm9vbSgpO1xuICAgIH1cblxuICAgIC8vIHByZXNlcnZlIGNlbnRlclxuICAgIG9wdGlvbnMuY2VudGVyID0gdGhpcy5nZXRDZW50ZXIoKTtcblxuICAgIC8vIHByZXNlcnZlIHJvdGF0aW9uXG4gICAgb3B0aW9ucy5yb3RhdGlvbiA9IHRoaXMuZ2V0Um90YXRpb24oKTtcblxuICAgIHJldHVybiBhc3NpZ24oe30sIG9wdGlvbnMsIG5ld09wdGlvbnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBbmltYXRlIHRoZSB2aWV3LiAgVGhlIHZpZXcncyBjZW50ZXIsIHpvb20gKG9yIHJlc29sdXRpb24pLCBhbmQgcm90YXRpb25cbiAgICogY2FuIGJlIGFuaW1hdGVkIGZvciBzbW9vdGggdHJhbnNpdGlvbnMgYmV0d2VlbiB2aWV3IHN0YXRlcy4gIEZvciBleGFtcGxlLFxuICAgKiB0byBhbmltYXRlIHRoZSB2aWV3IHRvIGEgbmV3IHpvb20gbGV2ZWw6XG4gICAqXG4gICAqICAgICB2aWV3LmFuaW1hdGUoe3pvb206IHZpZXcuZ2V0Wm9vbSgpICsgMX0pO1xuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGUgYW5pbWF0aW9uIGxhc3RzIG9uZSBzZWNvbmQgYW5kIHVzZXMgaW4tYW5kLW91dCBlYXNpbmcuICBZb3VcbiAgICogY2FuIGN1c3RvbWl6ZSB0aGlzIGJlaGF2aW9yIGJ5IGluY2x1ZGluZyBgZHVyYXRpb25gIChpbiBtaWxsaXNlY29uZHMpIGFuZFxuICAgKiBgZWFzaW5nYCBvcHRpb25zIChzZWUge0BsaW5rIG1vZHVsZTpvbC9lYXNpbmd9KS5cbiAgICpcbiAgICogVG8gY2hhaW4gdG9nZXRoZXIgbXVsdGlwbGUgYW5pbWF0aW9ucywgY2FsbCB0aGUgbWV0aG9kIHdpdGggbXVsdGlwbGVcbiAgICogYW5pbWF0aW9uIG9iamVjdHMuICBGb3IgZXhhbXBsZSwgdG8gZmlyc3Qgem9vbSBhbmQgdGhlbiBwYW46XG4gICAqXG4gICAqICAgICB2aWV3LmFuaW1hdGUoe3pvb206IDEwfSwge2NlbnRlcjogWzAsIDBdfSk7XG4gICAqXG4gICAqIElmIHlvdSBwcm92aWRlIGEgZnVuY3Rpb24gYXMgdGhlIGxhc3QgYXJndW1lbnQgdG8gdGhlIGFuaW1hdGUgbWV0aG9kLCBpdFxuICAgKiB3aWxsIGdldCBjYWxsZWQgYXQgdGhlIGVuZCBvZiBhbiBhbmltYXRpb24gc2VyaWVzLiAgVGhlIGNhbGxiYWNrIHdpbGwgYmVcbiAgICogY2FsbGVkIHdpdGggYHRydWVgIGlmIHRoZSBhbmltYXRpb24gc2VyaWVzIGNvbXBsZXRlZCBvbiBpdHMgb3duIG9yIGBmYWxzZWBcbiAgICogaWYgaXQgd2FzIGNhbmNlbGxlZC5cbiAgICpcbiAgICogQW5pbWF0aW9ucyBhcmUgY2FuY2VsbGVkIGJ5IHVzZXIgaW50ZXJhY3Rpb25zIChlLmcuIGRyYWdnaW5nIHRoZSBtYXApIG9yIGJ5XG4gICAqIGNhbGxpbmcgYHZpZXcuc2V0Q2VudGVyKClgLCBgdmlldy5zZXRSZXNvbHV0aW9uKClgLCBvciBgdmlldy5zZXRSb3RhdGlvbigpYFxuICAgKiAob3IgYW5vdGhlciBtZXRob2QgdGhhdCBjYWxscyBvbmUgb2YgdGhlc2UpLlxuICAgKlxuICAgKiBAcGFyYW0gey4uLihBbmltYXRpb25PcHRpb25zfGZ1bmN0aW9uKGJvb2xlYW4pKX0gdmFyX2FyZ3MgQW5pbWF0aW9uXG4gICAqICAgICBvcHRpb25zLiAgTXVsdGlwbGUgYW5pbWF0aW9ucyBjYW4gYmUgcnVuIGluIHNlcmllcyBieSBwYXNzaW5nIG11bHRpcGxlXG4gICAqICAgICBvcHRpb25zIG9iamVjdHMuICBUbyBydW4gbXVsdGlwbGUgYW5pbWF0aW9ucyBpbiBwYXJhbGxlbCwgY2FsbCB0aGUgbWV0aG9kXG4gICAqICAgICBtdWx0aXBsZSB0aW1lcy4gIEFuIG9wdGlvbmFsIGNhbGxiYWNrIGNhbiBiZSBwcm92aWRlZCBhcyBhIGZpbmFsXG4gICAqICAgICBhcmd1bWVudC4gIFRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCB3aXRoIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXJcbiAgICogICAgIHRoZSBhbmltYXRpb24gY29tcGxldGVkIHdpdGhvdXQgYmVpbmcgY2FuY2VsbGVkLlxuICAgKiBAYXBpXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5hbmltYXRlID0gZnVuY3Rpb24gYW5pbWF0ZSAodmFyX2FyZ3MpIHtcbiAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cbiAgICB2YXIgYW5pbWF0aW9uQ291bnQgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBjYWxsYmFjaztcbiAgICBpZiAoYW5pbWF0aW9uQ291bnQgPiAxICYmIHR5cGVvZiBhcmd1bWVudHNbYW5pbWF0aW9uQ291bnQgLSAxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBhcmd1bWVudHNbYW5pbWF0aW9uQ291bnQgLSAxXTtcbiAgICAgIC0tYW5pbWF0aW9uQ291bnQ7XG4gICAgfVxuICAgIGlmICghdGhpcy5pc0RlZigpKSB7XG4gICAgICAvLyBpZiB2aWV3IHByb3BlcnRpZXMgYXJlIG5vdCB5ZXQgc2V0LCBzaG9ydGN1dCB0byB0aGUgZmluYWwgc3RhdGVcbiAgICAgIHZhciBzdGF0ZSA9IGFyZ3VtZW50c1thbmltYXRpb25Db3VudCAtIDFdO1xuICAgICAgaWYgKHN0YXRlLmNlbnRlcikge1xuICAgICAgICB0aGlzLnNldENlbnRlcihzdGF0ZS5jZW50ZXIpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLnpvb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnNldFpvb20oc3RhdGUuem9vbSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUucm90YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnNldFJvdGF0aW9uKHN0YXRlLnJvdGF0aW9uKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBhbmltYXRpb25DYWxsYmFjayhjYWxsYmFjaywgdHJ1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBzdGFydCA9IERhdGUubm93KCk7XG4gICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyKCkuc2xpY2UoKTtcbiAgICB2YXIgcmVzb2x1dGlvbiA9IHRoaXMuZ2V0UmVzb2x1dGlvbigpO1xuICAgIHZhciByb3RhdGlvbiA9IHRoaXMuZ2V0Um90YXRpb24oKTtcbiAgICB2YXIgc2VyaWVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmltYXRpb25Db3VudDsgKytpKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IC8qKiBAdHlwZSB7QW5pbWF0aW9uT3B0aW9uc30gKi8gKGFyZ3VtZW50cyQxW2ldKTtcblxuICAgICAgdmFyIGFuaW1hdGlvbiA9IC8qKiBAdHlwZSB7QW5pbWF0aW9ufSAqLyAoe1xuICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgIGNvbXBsZXRlOiBmYWxzZSxcbiAgICAgICAgYW5jaG9yOiBvcHRpb25zLmFuY2hvcixcbiAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiAxMDAwLFxuICAgICAgICBlYXNpbmc6IG9wdGlvbnMuZWFzaW5nIHx8IGluQW5kT3V0XG4gICAgICB9KTtcblxuICAgICAgaWYgKG9wdGlvbnMuY2VudGVyKSB7XG4gICAgICAgIGFuaW1hdGlvbi5zb3VyY2VDZW50ZXIgPSBjZW50ZXI7XG4gICAgICAgIGFuaW1hdGlvbi50YXJnZXRDZW50ZXIgPSBvcHRpb25zLmNlbnRlcjtcbiAgICAgICAgY2VudGVyID0gYW5pbWF0aW9uLnRhcmdldENlbnRlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuem9vbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFuaW1hdGlvbi5zb3VyY2VSZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcbiAgICAgICAgYW5pbWF0aW9uLnRhcmdldFJlc29sdXRpb24gPSB0aGlzLmNvbnN0cmFpblJlc29sdXRpb24oXG4gICAgICAgICAgdGhpcy5tYXhSZXNvbHV0aW9uXywgb3B0aW9ucy56b29tIC0gdGhpcy5taW5ab29tXywgMCk7XG4gICAgICAgIHJlc29sdXRpb24gPSBhbmltYXRpb24udGFyZ2V0UmVzb2x1dGlvbjtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5yZXNvbHV0aW9uKSB7XG4gICAgICAgIGFuaW1hdGlvbi5zb3VyY2VSZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcbiAgICAgICAgYW5pbWF0aW9uLnRhcmdldFJlc29sdXRpb24gPSBvcHRpb25zLnJlc29sdXRpb247XG4gICAgICAgIHJlc29sdXRpb24gPSBhbmltYXRpb24udGFyZ2V0UmVzb2x1dGlvbjtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMucm90YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhbmltYXRpb24uc291cmNlUm90YXRpb24gPSByb3RhdGlvbjtcbiAgICAgICAgdmFyIGRlbHRhID0gbW9kdWxvKG9wdGlvbnMucm90YXRpb24gLSByb3RhdGlvbiArIE1hdGguUEksIDIgKiBNYXRoLlBJKSAtIE1hdGguUEk7XG4gICAgICAgIGFuaW1hdGlvbi50YXJnZXRSb3RhdGlvbiA9IHJvdGF0aW9uICsgZGVsdGE7XG4gICAgICAgIHJvdGF0aW9uID0gYW5pbWF0aW9uLnRhcmdldFJvdGF0aW9uO1xuICAgICAgfVxuXG4gICAgICBhbmltYXRpb24uY2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICAgICAgLy8gY2hlY2sgaWYgYW5pbWF0aW9uIGlzIGEgbm8tb3BcbiAgICAgIGlmIChpc05vb3BBbmltYXRpb24oYW5pbWF0aW9uKSkge1xuICAgICAgICBhbmltYXRpb24uY29tcGxldGUgPSB0cnVlO1xuICAgICAgICAvLyB3ZSBzdGlsbCBwdXNoIGl0IG9udG8gdGhlIHNlcmllcyBmb3IgY2FsbGJhY2sgaGFuZGxpbmdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0ICs9IGFuaW1hdGlvbi5kdXJhdGlvbjtcbiAgICAgIH1cbiAgICAgIHNlcmllcy5wdXNoKGFuaW1hdGlvbik7XG4gICAgfVxuICAgIHRoaXMuYW5pbWF0aW9uc18ucHVzaChzZXJpZXMpO1xuICAgIHRoaXMuc2V0SGludChWaWV3SGludC5BTklNQVRJTkcsIDEpO1xuICAgIHRoaXMudXBkYXRlQW5pbWF0aW9uc18oKTtcbiAgfTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIHRoZSB2aWV3IGlzIGJlaW5nIGFuaW1hdGVkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgdmlldyBpcyBiZWluZyBhbmltYXRlZC5cbiAgICogQGFwaVxuICAgKi9cbiAgVmlldy5wcm90b3R5cGUuZ2V0QW5pbWF0aW5nID0gZnVuY3Rpb24gZ2V0QW5pbWF0aW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy5oaW50c19bVmlld0hpbnQuQU5JTUFUSU5HXSA+IDA7XG4gIH07XG5cbiAgLyoqXG4gICAqIERldGVybWluZSBpZiB0aGUgdXNlciBpcyBpbnRlcmFjdGluZyB3aXRoIHRoZSB2aWV3LCBzdWNoIGFzIHBhbm5pbmcgb3Igem9vbWluZy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHZpZXcgaXMgYmVpbmcgaW50ZXJhY3RlZCB3aXRoLlxuICAgKiBAYXBpXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5nZXRJbnRlcmFjdGluZyA9IGZ1bmN0aW9uIGdldEludGVyYWN0aW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy5oaW50c19bVmlld0hpbnQuSU5URVJBQ1RJTkddID4gMDtcbiAgfTtcblxuICAvKipcbiAgICogQ2FuY2VsIGFueSBvbmdvaW5nIGFuaW1hdGlvbnMuXG4gICAqIEBhcGlcbiAgICovXG4gIFZpZXcucHJvdG90eXBlLmNhbmNlbEFuaW1hdGlvbnMgPSBmdW5jdGlvbiBjYW5jZWxBbmltYXRpb25zICgpIHtcbiAgICB0aGlzLnNldEhpbnQoVmlld0hpbnQuQU5JTUFUSU5HLCAtdGhpcy5oaW50c19bVmlld0hpbnQuQU5JTUFUSU5HXSk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdGhpcy5hbmltYXRpb25zXy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB2YXIgc2VyaWVzID0gdGhpcy5hbmltYXRpb25zX1tpXTtcbiAgICAgIGlmIChzZXJpZXNbMF0uY2FsbGJhY2spIHtcbiAgICAgICAgYW5pbWF0aW9uQ2FsbGJhY2soc2VyaWVzWzBdLmNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYW5pbWF0aW9uc18ubGVuZ3RoID0gMDtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIGFsbCBhbmltYXRpb25zLlxuICAgKi9cbiAgVmlldy5wcm90b3R5cGUudXBkYXRlQW5pbWF0aW9uc18gPSBmdW5jdGlvbiB1cGRhdGVBbmltYXRpb25zXyAoKSB7XG4gICAgaWYgKHRoaXMudXBkYXRlQW5pbWF0aW9uS2V5XyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnVwZGF0ZUFuaW1hdGlvbktleV8pO1xuICAgICAgdGhpcy51cGRhdGVBbmltYXRpb25LZXlfID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuZ2V0QW5pbWF0aW5nKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgdmFyIG1vcmUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5hbmltYXRpb25zXy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdmFyIHNlcmllcyA9IHRoaXMuYW5pbWF0aW9uc19baV07XG4gICAgICB2YXIgc2VyaWVzQ29tcGxldGUgPSB0cnVlO1xuICAgICAgZm9yICh2YXIgaiA9IDAsIGpqID0gc2VyaWVzLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICAgICAgdmFyIGFuaW1hdGlvbiA9IHNlcmllc1tqXTtcbiAgICAgICAgaWYgKGFuaW1hdGlvbi5jb21wbGV0ZSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbGFwc2VkID0gbm93IC0gYW5pbWF0aW9uLnN0YXJ0O1xuICAgICAgICB2YXIgZnJhY3Rpb24gPSBhbmltYXRpb24uZHVyYXRpb24gPiAwID8gZWxhcHNlZCAvIGFuaW1hdGlvbi5kdXJhdGlvbiA6IDE7XG4gICAgICAgIGlmIChmcmFjdGlvbiA+PSAxKSB7XG4gICAgICAgICAgYW5pbWF0aW9uLmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICBmcmFjdGlvbiA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VyaWVzQ29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvZ3Jlc3MgPSBhbmltYXRpb24uZWFzaW5nKGZyYWN0aW9uKTtcbiAgICAgICAgaWYgKGFuaW1hdGlvbi5zb3VyY2VDZW50ZXIpIHtcbiAgICAgICAgICB2YXIgeDAgPSBhbmltYXRpb24uc291cmNlQ2VudGVyWzBdO1xuICAgICAgICAgIHZhciB5MCA9IGFuaW1hdGlvbi5zb3VyY2VDZW50ZXJbMV07XG4gICAgICAgICAgdmFyIHgxID0gYW5pbWF0aW9uLnRhcmdldENlbnRlclswXTtcbiAgICAgICAgICB2YXIgeTEgPSBhbmltYXRpb24udGFyZ2V0Q2VudGVyWzFdO1xuICAgICAgICAgIHZhciB4ID0geDAgKyBwcm9ncmVzcyAqICh4MSAtIHgwKTtcbiAgICAgICAgICB2YXIgeSA9IHkwICsgcHJvZ3Jlc3MgKiAoeTEgLSB5MCk7XG4gICAgICAgICAgdGhpcy5zZXQoVmlld1Byb3BlcnR5LkNFTlRFUiwgW3gsIHldKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5pbWF0aW9uLnNvdXJjZVJlc29sdXRpb24gJiYgYW5pbWF0aW9uLnRhcmdldFJlc29sdXRpb24pIHtcbiAgICAgICAgICB2YXIgcmVzb2x1dGlvbiA9IHByb2dyZXNzID09PSAxID9cbiAgICAgICAgICAgIGFuaW1hdGlvbi50YXJnZXRSZXNvbHV0aW9uIDpcbiAgICAgICAgICAgIGFuaW1hdGlvbi5zb3VyY2VSZXNvbHV0aW9uICsgcHJvZ3Jlc3MgKiAoYW5pbWF0aW9uLnRhcmdldFJlc29sdXRpb24gLSBhbmltYXRpb24uc291cmNlUmVzb2x1dGlvbik7XG4gICAgICAgICAgaWYgKGFuaW1hdGlvbi5hbmNob3IpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KFZpZXdQcm9wZXJ0eS5DRU5URVIsXG4gICAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlQ2VudGVyWm9vbShyZXNvbHV0aW9uLCBhbmltYXRpb24uYW5jaG9yKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc2V0KFZpZXdQcm9wZXJ0eS5SRVNPTFVUSU9OLCByZXNvbHV0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5pbWF0aW9uLnNvdXJjZVJvdGF0aW9uICE9PSB1bmRlZmluZWQgJiYgYW5pbWF0aW9uLnRhcmdldFJvdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgcm90YXRpb24gPSBwcm9ncmVzcyA9PT0gMSA/XG4gICAgICAgICAgICBtb2R1bG8oYW5pbWF0aW9uLnRhcmdldFJvdGF0aW9uICsgTWF0aC5QSSwgMiAqIE1hdGguUEkpIC0gTWF0aC5QSSA6XG4gICAgICAgICAgICBhbmltYXRpb24uc291cmNlUm90YXRpb24gKyBwcm9ncmVzcyAqIChhbmltYXRpb24udGFyZ2V0Um90YXRpb24gLSBhbmltYXRpb24uc291cmNlUm90YXRpb24pO1xuICAgICAgICAgIGlmIChhbmltYXRpb24uYW5jaG9yKSB7XG4gICAgICAgICAgICB0aGlzLnNldChWaWV3UHJvcGVydHkuQ0VOVEVSLFxuICAgICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZUNlbnRlclJvdGF0ZShyb3RhdGlvbiwgYW5pbWF0aW9uLmFuY2hvcikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnNldChWaWV3UHJvcGVydHkuUk9UQVRJT04sIHJvdGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBtb3JlID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFhbmltYXRpb24uY29tcGxldGUpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNlcmllc0NvbXBsZXRlKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uc19baV0gPSBudWxsO1xuICAgICAgICB0aGlzLnNldEhpbnQoVmlld0hpbnQuQU5JTUFUSU5HLCAtMSk7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHNlcmllc1swXS5jYWxsYmFjaztcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgYW5pbWF0aW9uQ2FsbGJhY2soY2FsbGJhY2ssIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHBydW5lIGNvbXBsZXRlZCBzZXJpZXNcbiAgICB0aGlzLmFuaW1hdGlvbnNfID0gdGhpcy5hbmltYXRpb25zXy5maWx0ZXIoQm9vbGVhbik7XG4gICAgaWYgKG1vcmUgJiYgdGhpcy51cGRhdGVBbmltYXRpb25LZXlfID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMudXBkYXRlQW5pbWF0aW9uS2V5XyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnVwZGF0ZUFuaW1hdGlvbnNfKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvbiBUYXJnZXQgcm90YXRpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGFuY2hvciBSb3RhdGlvbiBhbmNob3IuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfHVuZGVmaW5lZH0gQ2VudGVyIGZvciByb3RhdGlvbiBhbmQgYW5jaG9yLlxuICAgKi9cbiAgVmlldy5wcm90b3R5cGUuY2FsY3VsYXRlQ2VudGVyUm90YXRlID0gZnVuY3Rpb24gY2FsY3VsYXRlQ2VudGVyUm90YXRlIChyb3RhdGlvbiwgYW5jaG9yKSB7XG4gICAgdmFyIGNlbnRlcjtcbiAgICB2YXIgY3VycmVudENlbnRlciA9IHRoaXMuZ2V0Q2VudGVyKCk7XG4gICAgaWYgKGN1cnJlbnRDZW50ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2VudGVyID0gW2N1cnJlbnRDZW50ZXJbMF0gLSBhbmNob3JbMF0sIGN1cnJlbnRDZW50ZXJbMV0gLSBhbmNob3JbMV1dO1xuICAgICAgcm90YXRlQ29vcmRpbmF0ZShjZW50ZXIsIHJvdGF0aW9uIC0gdGhpcy5nZXRSb3RhdGlvbigpKTtcbiAgICAgIGFkZENvb3JkaW5hdGUoY2VudGVyLCBhbmNob3IpO1xuICAgIH1cbiAgICByZXR1cm4gY2VudGVyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBUYXJnZXQgcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gYW5jaG9yIFpvb20gYW5jaG9yLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZXx1bmRlZmluZWR9IENlbnRlciBmb3IgcmVzb2x1dGlvbiBhbmQgYW5jaG9yLlxuICAgKi9cbiAgVmlldy5wcm90b3R5cGUuY2FsY3VsYXRlQ2VudGVyWm9vbSA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUNlbnRlclpvb20gKHJlc29sdXRpb24sIGFuY2hvcikge1xuICAgIHZhciBjZW50ZXI7XG4gICAgdmFyIGN1cnJlbnRDZW50ZXIgPSB0aGlzLmdldENlbnRlcigpO1xuICAgIHZhciBjdXJyZW50UmVzb2x1dGlvbiA9IHRoaXMuZ2V0UmVzb2x1dGlvbigpO1xuICAgIGlmIChjdXJyZW50Q2VudGVyICE9PSB1bmRlZmluZWQgJiYgY3VycmVudFJlc29sdXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHggPSBhbmNob3JbMF0gLSByZXNvbHV0aW9uICogKGFuY2hvclswXSAtIGN1cnJlbnRDZW50ZXJbMF0pIC8gY3VycmVudFJlc29sdXRpb247XG4gICAgICB2YXIgeSA9IGFuY2hvclsxXSAtIHJlc29sdXRpb24gKiAoYW5jaG9yWzFdIC0gY3VycmVudENlbnRlclsxXSkgLyBjdXJyZW50UmVzb2x1dGlvbjtcbiAgICAgIGNlbnRlciA9IFt4LCB5XTtcbiAgICB9XG4gICAgcmV0dXJuIGNlbnRlcjtcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9IFZpZXdwb3J0IHNpemUgb3IgYFsxMDAsIDEwMF1gIHdoZW4gbm8gdmlld3BvcnQgaXMgZm91bmQuXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5nZXRTaXplRnJvbVZpZXdwb3J0XyA9IGZ1bmN0aW9uIGdldFNpemVGcm9tVmlld3BvcnRfICgpIHtcbiAgICB2YXIgc2l6ZSA9IFsxMDAsIDEwMF07XG4gICAgdmFyIHNlbGVjdG9yID0gJy5vbC12aWV3cG9ydFtkYXRhLXZpZXc9XCInICsgZ2V0VWlkKHRoaXMpICsgJ1wiXSc7XG4gICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG1ldHJpY3MgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgICAgc2l6ZVswXSA9IHBhcnNlSW50KG1ldHJpY3Mud2lkdGgsIDEwKTtcbiAgICAgIHNpemVbMV0gPSBwYXJzZUludChtZXRyaWNzLmhlaWdodCwgMTApO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjb25zdHJhaW5lZCBjZW50ZXIgb2YgdGhpcyB2aWV3LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfHVuZGVmaW5lZH0gY2VudGVyIENlbnRlci5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8dW5kZWZpbmVkfSBDb25zdHJhaW5lZCBjZW50ZXIuXG4gICAqIEBhcGlcbiAgICovXG4gIFZpZXcucHJvdG90eXBlLmNvbnN0cmFpbkNlbnRlciA9IGZ1bmN0aW9uIGNvbnN0cmFpbkNlbnRlciAoY2VudGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RyYWludHNfLmNlbnRlcihjZW50ZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvbnN0cmFpbmVkIHJlc29sdXRpb24gb2YgdGhpcyB2aWV3LlxuICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZGVsdGEgRGVsdGEuIERlZmF1bHQgaXMgYDBgLlxuICAgKiBAcGFyYW0ge251bWJlcj19IG9wdF9kaXJlY3Rpb24gRGlyZWN0aW9uLiBEZWZhdWx0IGlzIGAwYC5cbiAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gQ29uc3RyYWluZWQgcmVzb2x1dGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgVmlldy5wcm90b3R5cGUuY29uc3RyYWluUmVzb2x1dGlvbiA9IGZ1bmN0aW9uIGNvbnN0cmFpblJlc29sdXRpb24gKHJlc29sdXRpb24sIG9wdF9kZWx0YSwgb3B0X2RpcmVjdGlvbikge1xuICAgIHZhciBkZWx0YSA9IG9wdF9kZWx0YSB8fCAwO1xuICAgIHZhciBkaXJlY3Rpb24gPSBvcHRfZGlyZWN0aW9uIHx8IDA7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RyYWludHNfLnJlc29sdXRpb24ocmVzb2x1dGlvbiwgZGVsdGEsIGRpcmVjdGlvbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY29uc3RyYWluZWQgcm90YXRpb24gb2YgdGhpcyB2aWV3LlxuICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcj19IG9wdF9kZWx0YSBEZWx0YS4gRGVmYXVsdCBpcyBgMGAuXG4gICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IENvbnN0cmFpbmVkIHJvdGF0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5jb25zdHJhaW5Sb3RhdGlvbiA9IGZ1bmN0aW9uIGNvbnN0cmFpblJvdGF0aW9uIChyb3RhdGlvbiwgb3B0X2RlbHRhKSB7XG4gICAgdmFyIGRlbHRhID0gb3B0X2RlbHRhIHx8IDA7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RyYWludHNfLnJvdGF0aW9uKHJvdGF0aW9uLCBkZWx0YSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmlldyBjZW50ZXIuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfHVuZGVmaW5lZH0gVGhlIGNlbnRlciBvZiB0aGUgdmlldy5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgVmlldy5wcm90b3R5cGUuZ2V0Q2VudGVyID0gZnVuY3Rpb24gZ2V0Q2VudGVyICgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZXx1bmRlZmluZWR9ICovICh0aGlzLmdldChWaWV3UHJvcGVydHkuQ0VOVEVSKSlcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtDb25zdHJhaW50c30gQ29uc3RyYWludHMuXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5nZXRDb25zdHJhaW50cyA9IGZ1bmN0aW9uIGdldENvbnN0cmFpbnRzICgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJhaW50c187XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPj19IG9wdF9oaW50cyBEZXN0aW5hdGlvbiBhcnJheS5cbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gSGludC5cbiAgICovXG4gIFZpZXcucHJvdG90eXBlLmdldEhpbnRzID0gZnVuY3Rpb24gZ2V0SGludHMgKG9wdF9oaW50cykge1xuICAgIGlmIChvcHRfaGludHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0X2hpbnRzWzBdID0gdGhpcy5oaW50c19bMF07XG4gICAgICBvcHRfaGludHNbMV0gPSB0aGlzLmhpbnRzX1sxXTtcbiAgICAgIHJldHVybiBvcHRfaGludHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmhpbnRzXy5zbGljZSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBleHRlbnQgZm9yIHRoZSBjdXJyZW50IHZpZXcgc3RhdGUgYW5kIHRoZSBwYXNzZWQgc2l6ZS5cbiAgICogVGhlIHNpemUgaXMgdGhlIHBpeGVsIGRpbWVuc2lvbnMgb2YgdGhlIGJveCBpbnRvIHdoaWNoIHRoZSBjYWxjdWxhdGVkIGV4dGVudFxuICAgKiBzaG91bGQgZml0LiBJbiBtb3N0IGNhc2VzIHlvdSB3YW50IHRvIGdldCB0aGUgZXh0ZW50IG9mIHRoZSBlbnRpcmUgbWFwLFxuICAgKiB0aGF0IGlzIGBtYXAuZ2V0U2l6ZSgpYC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZT19IG9wdF9zaXplIEJveCBwaXhlbCBzaXplLiBJZiBub3QgcHJvdmlkZWQsIHRoZSBzaXplIG9mIHRoZVxuICAgKiBmaXJzdCBtYXAgdGhhdCB1c2VzIHRoaXMgdmlldyB3aWxsIGJlIHVzZWQuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gRXh0ZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5jYWxjdWxhdGVFeHRlbnQgPSBmdW5jdGlvbiBjYWxjdWxhdGVFeHRlbnQgKG9wdF9zaXplKSB7XG4gICAgdmFyIHNpemUgPSBvcHRfc2l6ZSB8fCB0aGlzLmdldFNpemVGcm9tVmlld3BvcnRfKCk7XG4gICAgdmFyIGNlbnRlciA9IC8qKiBAdHlwZSB7IWltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSAqLyAodGhpcy5nZXRDZW50ZXIoKSk7XG4gICAgYXNzZXJ0KGNlbnRlciwgMSk7IC8vIFRoZSB2aWV3IGNlbnRlciBpcyBub3QgZGVmaW5lZFxuICAgIHZhciByZXNvbHV0aW9uID0gLyoqIEB0eXBlIHshbnVtYmVyfSAqLyAodGhpcy5nZXRSZXNvbHV0aW9uKCkpO1xuICAgIGFzc2VydChyZXNvbHV0aW9uICE9PSB1bmRlZmluZWQsIDIpOyAvLyBUaGUgdmlldyByZXNvbHV0aW9uIGlzIG5vdCBkZWZpbmVkXG4gICAgdmFyIHJvdGF0aW9uID0gLyoqIEB0eXBlIHshbnVtYmVyfSAqLyAodGhpcy5nZXRSb3RhdGlvbigpKTtcbiAgICBhc3NlcnQocm90YXRpb24gIT09IHVuZGVmaW5lZCwgMyk7IC8vIFRoZSB2aWV3IHJvdGF0aW9uIGlzIG5vdCBkZWZpbmVkXG5cbiAgICByZXR1cm4gZ2V0Rm9yVmlld0FuZFNpemUoY2VudGVyLCByZXNvbHV0aW9uLCByb3RhdGlvbiwgc2l6ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWF4aW11bSByZXNvbHV0aW9uIG9mIHRoZSB2aWV3LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBtYXhpbXVtIHJlc29sdXRpb24gb2YgdGhlIHZpZXcuXG4gICAqIEBhcGlcbiAgICovXG4gIFZpZXcucHJvdG90eXBlLmdldE1heFJlc29sdXRpb24gPSBmdW5jdGlvbiBnZXRNYXhSZXNvbHV0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXhSZXNvbHV0aW9uXztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBtaW5pbXVtIHJlc29sdXRpb24gb2YgdGhlIHZpZXcuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1pbmltdW0gcmVzb2x1dGlvbiBvZiB0aGUgdmlldy5cbiAgICogQGFwaVxuICAgKi9cbiAgVmlldy5wcm90b3R5cGUuZ2V0TWluUmVzb2x1dGlvbiA9IGZ1bmN0aW9uIGdldE1pblJlc29sdXRpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1pblJlc29sdXRpb25fO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1heGltdW0gem9vbSBsZXZlbCBmb3IgdGhlIHZpZXcuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1heGltdW0gem9vbSBsZXZlbC5cbiAgICogQGFwaVxuICAgKi9cbiAgVmlldy5wcm90b3R5cGUuZ2V0TWF4Wm9vbSA9IGZ1bmN0aW9uIGdldE1heFpvb20gKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge251bWJlcn0gKi8gKHRoaXMuZ2V0Wm9vbUZvclJlc29sdXRpb24odGhpcy5taW5SZXNvbHV0aW9uXykpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgYSBuZXcgbWF4aW11bSB6b29tIGxldmVsIGZvciB0aGUgdmlldy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHpvb20gVGhlIG1heGltdW0gem9vbSBsZXZlbC5cbiAgICogQGFwaVxuICAgKi9cbiAgVmlldy5wcm90b3R5cGUuc2V0TWF4Wm9vbSA9IGZ1bmN0aW9uIHNldE1heFpvb20gKHpvb20pIHtcbiAgICB0aGlzLmFwcGx5T3B0aW9uc18odGhpcy5nZXRVcGRhdGVkT3B0aW9uc18oe21heFpvb206IHpvb219KSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWluaW11bSB6b29tIGxldmVsIGZvciB0aGUgdmlldy5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWluaW11bSB6b29tIGxldmVsLlxuICAgKiBAYXBpXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5nZXRNaW5ab29tID0gZnVuY3Rpb24gZ2V0TWluWm9vbSAoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5nZXRab29tRm9yUmVzb2x1dGlvbih0aGlzLm1heFJlc29sdXRpb25fKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBhIG5ldyBtaW5pbXVtIHpvb20gbGV2ZWwgZm9yIHRoZSB2aWV3LlxuICAgKiBAcGFyYW0ge251bWJlcn0gem9vbSBUaGUgbWluaW11bSB6b29tIGxldmVsLlxuICAgKiBAYXBpXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5zZXRNaW5ab29tID0gZnVuY3Rpb24gc2V0TWluWm9vbSAoem9vbSkge1xuICAgIHRoaXMuYXBwbHlPcHRpb25zXyh0aGlzLmdldFVwZGF0ZWRPcHRpb25zXyh7bWluWm9vbTogem9vbX0pKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSB2aWV3IHByb2plY3Rpb24uXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IFRoZSBwcm9qZWN0aW9uIG9mIHRoZSB2aWV3LlxuICAgKiBAYXBpXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5nZXRQcm9qZWN0aW9uID0gZnVuY3Rpb24gZ2V0UHJvamVjdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvamVjdGlvbl87XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmlldyByZXNvbHV0aW9uLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBUaGUgcmVzb2x1dGlvbiBvZiB0aGUgdmlldy5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgVmlldy5wcm90b3R5cGUuZ2V0UmVzb2x1dGlvbiA9IGZ1bmN0aW9uIGdldFJlc29sdXRpb24gKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovICh0aGlzLmdldChWaWV3UHJvcGVydHkuUkVTT0xVVElPTikpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHJlc29sdXRpb25zIGZvciB0aGUgdmlldy4gVGhpcyByZXR1cm5zIHRoZSBhcnJheSBvZiByZXNvbHV0aW9uc1xuICAgKiBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBWaWV3LCBvciB1bmRlZmluZWQgaWYgbm9uZSB3ZXJlIGdpdmVuLlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fHVuZGVmaW5lZH0gVGhlIHJlc29sdXRpb25zIG9mIHRoZSB2aWV3LlxuICAgKiBAYXBpXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5nZXRSZXNvbHV0aW9ucyA9IGZ1bmN0aW9uIGdldFJlc29sdXRpb25zICgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uc187XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcmVzb2x1dGlvbiBmb3IgYSBwcm92aWRlZCBleHRlbnQgKGluIG1hcCB1bml0cykgYW5kIHNpemUgKGluIHBpeGVscykuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplPX0gb3B0X3NpemUgQm94IHBpeGVsIHNpemUuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHJlc29sdXRpb24gYXQgd2hpY2ggdGhlIHByb3ZpZGVkIGV4dGVudCB3aWxsIHJlbmRlciBhdFxuICAgKiAgICAgdGhlIGdpdmVuIHNpemUuXG4gICAqIEBhcGlcbiAgICovXG4gIFZpZXcucHJvdG90eXBlLmdldFJlc29sdXRpb25Gb3JFeHRlbnQgPSBmdW5jdGlvbiBnZXRSZXNvbHV0aW9uRm9yRXh0ZW50IChleHRlbnQsIG9wdF9zaXplKSB7XG4gICAgdmFyIHNpemUgPSBvcHRfc2l6ZSB8fCB0aGlzLmdldFNpemVGcm9tVmlld3BvcnRfKCk7XG4gICAgdmFyIHhSZXNvbHV0aW9uID0gZ2V0V2lkdGgoZXh0ZW50KSAvIHNpemVbMF07XG4gICAgdmFyIHlSZXNvbHV0aW9uID0gZ2V0SGVpZ2h0KGV4dGVudCkgLyBzaXplWzFdO1xuICAgIHJldHVybiBNYXRoLm1heCh4UmVzb2x1dGlvbiwgeVJlc29sdXRpb24pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEgZm9yIGFcbiAgICogcmVzb2x1dGlvbi4gRXhwb25lbnRpYWwgc2NhbGluZyBpcyBhc3N1bWVkLlxuICAgKiBAcGFyYW0ge251bWJlcj19IG9wdF9wb3dlciBQb3dlci5cbiAgICogQHJldHVybiB7ZnVuY3Rpb24obnVtYmVyKTogbnVtYmVyfSBSZXNvbHV0aW9uIGZvciB2YWx1ZSBmdW5jdGlvbi5cbiAgICovXG4gIFZpZXcucHJvdG90eXBlLmdldFJlc29sdXRpb25Gb3JWYWx1ZUZ1bmN0aW9uID0gZnVuY3Rpb24gZ2V0UmVzb2x1dGlvbkZvclZhbHVlRnVuY3Rpb24gKG9wdF9wb3dlcikge1xuICAgIHZhciBwb3dlciA9IG9wdF9wb3dlciB8fCAyO1xuICAgIHZhciBtYXhSZXNvbHV0aW9uID0gdGhpcy5tYXhSZXNvbHV0aW9uXztcbiAgICB2YXIgbWluUmVzb2x1dGlvbiA9IHRoaXMubWluUmVzb2x1dGlvbl87XG4gICAgdmFyIG1heCA9IE1hdGgubG9nKG1heFJlc29sdXRpb24gLyBtaW5SZXNvbHV0aW9uKSAvIE1hdGgubG9nKHBvd2VyKTtcbiAgICByZXR1cm4gKFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUuXG4gICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFJlc29sdXRpb24uXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXNvbHV0aW9uID0gbWF4UmVzb2x1dGlvbiAvIE1hdGgucG93KHBvd2VyLCB2YWx1ZSAqIG1heCk7XG4gICAgICAgIHJldHVybiByZXNvbHV0aW9uO1xuICAgICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmlldyByb3RhdGlvbi5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgcm90YXRpb24gb2YgdGhlIHZpZXcgaW4gcmFkaWFucy5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgVmlldy5wcm90b3R5cGUuZ2V0Um90YXRpb24gPSBmdW5jdGlvbiBnZXRSb3RhdGlvbiAoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5nZXQoVmlld1Byb3BlcnR5LlJPVEFUSU9OKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHJlc29sdXRpb24gZm9yIGEgdmFsdWUgYmV0d2VlblxuICAgKiAwIGFuZCAxLiBFeHBvbmVudGlhbCBzY2FsaW5nIGlzIGFzc3VtZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X3Bvd2VyIFBvd2VyLlxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbihudW1iZXIpOiBudW1iZXJ9IFZhbHVlIGZvciByZXNvbHV0aW9uIGZ1bmN0aW9uLlxuICAgKi9cbiAgVmlldy5wcm90b3R5cGUuZ2V0VmFsdWVGb3JSZXNvbHV0aW9uRnVuY3Rpb24gPSBmdW5jdGlvbiBnZXRWYWx1ZUZvclJlc29sdXRpb25GdW5jdGlvbiAob3B0X3Bvd2VyKSB7XG4gICAgdmFyIHBvd2VyID0gb3B0X3Bvd2VyIHx8IDI7XG4gICAgdmFyIG1heFJlc29sdXRpb24gPSB0aGlzLm1heFJlc29sdXRpb25fO1xuICAgIHZhciBtaW5SZXNvbHV0aW9uID0gdGhpcy5taW5SZXNvbHV0aW9uXztcbiAgICB2YXIgbWF4ID0gTWF0aC5sb2cobWF4UmVzb2x1dGlvbiAvIG1pblJlc29sdXRpb24pIC8gTWF0aC5sb2cocG93ZXIpO1xuICAgIHJldHVybiAoXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFZhbHVlLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbihyZXNvbHV0aW9uKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IChNYXRoLmxvZyhtYXhSZXNvbHV0aW9uIC8gcmVzb2x1dGlvbikgLyBNYXRoLmxvZyhwb3dlcikpIC8gbWF4O1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8gZm9yIGNlbnRlciByb3VuZGluZy5cbiAgICogQHJldHVybiB7U3RhdGV9IFZpZXcgc3RhdGUuXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5nZXRTdGF0ZSA9IGZ1bmN0aW9uIGdldFN0YXRlIChwaXhlbFJhdGlvKSB7XG4gICAgdmFyIGNlbnRlciA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9ICovICh0aGlzLmdldENlbnRlcigpKTtcbiAgICB2YXIgcHJvamVjdGlvbiA9IHRoaXMuZ2V0UHJvamVjdGlvbigpO1xuICAgIHZhciByZXNvbHV0aW9uID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovICh0aGlzLmdldFJlc29sdXRpb24oKSk7XG4gICAgdmFyIHBpeGVsUmVzb2x1dGlvbiA9IHJlc29sdXRpb24gLyBwaXhlbFJhdGlvO1xuICAgIHZhciByb3RhdGlvbiA9IHRoaXMuZ2V0Um90YXRpb24oKTtcbiAgICByZXR1cm4gKFxuICAgICAgLyoqIEB0eXBlIHtTdGF0ZX0gKi8gKHtcbiAgICAgICAgY2VudGVyOiBbXG4gICAgICAgICAgTWF0aC5yb3VuZChjZW50ZXJbMF0gLyBwaXhlbFJlc29sdXRpb24pICogcGl4ZWxSZXNvbHV0aW9uLFxuICAgICAgICAgIE1hdGgucm91bmQoY2VudGVyWzFdIC8gcGl4ZWxSZXNvbHV0aW9uKSAqIHBpeGVsUmVzb2x1dGlvblxuICAgICAgICBdLFxuICAgICAgICBwcm9qZWN0aW9uOiBwcm9qZWN0aW9uICE9PSB1bmRlZmluZWQgPyBwcm9qZWN0aW9uIDogbnVsbCxcbiAgICAgICAgcmVzb2x1dGlvbjogcmVzb2x1dGlvbixcbiAgICAgICAgcm90YXRpb246IHJvdGF0aW9uLFxuICAgICAgICB6b29tOiB0aGlzLmdldFpvb20oKVxuICAgICAgfSlcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgem9vbSBsZXZlbC4gIElmIHlvdSBjb25maWd1cmVkIHlvdXIgdmlldyB3aXRoIGEgcmVzb2x1dGlvbnNcbiAgICogYXJyYXkgKHRoaXMgaXMgcmFyZSksIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gbm9uLWludGVnZXIgem9vbSBsZXZlbHMgKHNvXG4gICAqIHRoZSB6b29tIGxldmVsIGlzIG5vdCBzYWZlIHRvIHVzZSBhcyBhbiBpbmRleCBpbnRvIGEgcmVzb2x1dGlvbnMgYXJyYXkpLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBab29tLlxuICAgKiBAYXBpXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5nZXRab29tID0gZnVuY3Rpb24gZ2V0Wm9vbSAoKSB7XG4gICAgdmFyIHpvb207XG4gICAgdmFyIHJlc29sdXRpb24gPSB0aGlzLmdldFJlc29sdXRpb24oKTtcbiAgICBpZiAocmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB6b29tID0gdGhpcy5nZXRab29tRm9yUmVzb2x1dGlvbihyZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHpvb207XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgem9vbSBsZXZlbCBmb3IgYSByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBUaGUgcmVzb2x1dGlvbi5cbiAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gVGhlIHpvb20gbGV2ZWwgZm9yIHRoZSBwcm92aWRlZCByZXNvbHV0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5nZXRab29tRm9yUmVzb2x1dGlvbiA9IGZ1bmN0aW9uIGdldFpvb21Gb3JSZXNvbHV0aW9uIChyZXNvbHV0aW9uKSB7XG4gICAgdmFyIG9mZnNldCA9IHRoaXMubWluWm9vbV8gfHwgMDtcbiAgICB2YXIgbWF4LCB6b29tRmFjdG9yO1xuICAgIGlmICh0aGlzLnJlc29sdXRpb25zXykge1xuICAgICAgdmFyIG5lYXJlc3QgPSBsaW5lYXJGaW5kTmVhcmVzdCh0aGlzLnJlc29sdXRpb25zXywgcmVzb2x1dGlvbiwgMSk7XG4gICAgICBvZmZzZXQgPSBuZWFyZXN0O1xuICAgICAgbWF4ID0gdGhpcy5yZXNvbHV0aW9uc19bbmVhcmVzdF07XG4gICAgICBpZiAobmVhcmVzdCA9PSB0aGlzLnJlc29sdXRpb25zXy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHpvb21GYWN0b3IgPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgem9vbUZhY3RvciA9IG1heCAvIHRoaXMucmVzb2x1dGlvbnNfW25lYXJlc3QgKyAxXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4ID0gdGhpcy5tYXhSZXNvbHV0aW9uXztcbiAgICAgIHpvb21GYWN0b3IgPSB0aGlzLnpvb21GYWN0b3JfO1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0ICsgTWF0aC5sb2cobWF4IC8gcmVzb2x1dGlvbikgLyBNYXRoLmxvZyh6b29tRmFjdG9yKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSByZXNvbHV0aW9uIGZvciBhIHpvb20gbGV2ZWwuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6b29tIFpvb20gbGV2ZWwuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHZpZXcgcmVzb2x1dGlvbiBmb3IgdGhlIHByb3ZpZGVkIHpvb20gbGV2ZWwuXG4gICAqIEBhcGlcbiAgICovXG4gIFZpZXcucHJvdG90eXBlLmdldFJlc29sdXRpb25Gb3Jab29tID0gZnVuY3Rpb24gZ2V0UmVzb2x1dGlvbkZvclpvb20gKHpvb20pIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ9ICovICh0aGlzLmNvbnN0cmFpblJlc29sdXRpb24oXG4gICAgICB0aGlzLm1heFJlc29sdXRpb25fLCB6b29tIC0gdGhpcy5taW5ab29tXywgMCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGaXQgdGhlIGdpdmVuIGdlb21ldHJ5IG9yIGV4dGVudCBiYXNlZCBvbiB0aGUgZ2l2ZW4gbWFwIHNpemUgYW5kIGJvcmRlci5cbiAgICogVGhlIHNpemUgaXMgcGl4ZWwgZGltZW5zaW9ucyBvZiB0aGUgYm94IHRvIGZpdCB0aGUgZXh0ZW50IGludG8uXG4gICAqIEluIG1vc3QgY2FzZXMgeW91IHdpbGwgd2FudCB0byB1c2UgdGhlIG1hcCBzaXplLCB0aGF0IGlzIGBtYXAuZ2V0U2l6ZSgpYC5cbiAgICogVGFrZXMgY2FyZSBvZiB0aGUgbWFwIGFuZ2xlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZ2VvbWV0cnlPckV4dGVudCBUaGUgZ2VvbWV0cnkgb3JcbiAgICogICAgIGV4dGVudCB0byBmaXQgdGhlIHZpZXcgdG8uXG4gICAqIEBwYXJhbSB7Rml0T3B0aW9ucz19IG9wdF9vcHRpb25zIE9wdGlvbnMuXG4gICAqIEBhcGlcbiAgICovXG4gIFZpZXcucHJvdG90eXBlLmZpdCA9IGZ1bmN0aW9uIGZpdCAoZ2VvbWV0cnlPckV4dGVudCwgb3B0X29wdGlvbnMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IG9wdF9vcHRpb25zIHx8IHt9O1xuICAgIHZhciBzaXplID0gb3B0aW9ucy5zaXplO1xuICAgIGlmICghc2l6ZSkge1xuICAgICAgc2l6ZSA9IHRoaXMuZ2V0U2l6ZUZyb21WaWV3cG9ydF8oKTtcbiAgICB9XG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuL2dlb20vU2ltcGxlR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gKi9cbiAgICB2YXIgZ2VvbWV0cnk7XG4gICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkoZ2VvbWV0cnlPckV4dGVudCkgfHwgdHlwZW9mIC8qKiBAdHlwZSB7P30gKi8gKGdlb21ldHJ5T3JFeHRlbnQpLmdldFNpbXBsaWZpZWRHZW9tZXRyeSA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAgIDI0KTsgLy8gSW52YWxpZCBleHRlbnQgb3IgZ2VvbWV0cnkgcHJvdmlkZWQgYXMgYGdlb21ldHJ5YFxuICAgIGlmIChBcnJheS5pc0FycmF5KGdlb21ldHJ5T3JFeHRlbnQpKSB7XG4gICAgICBhc3NlcnQoIWlzRW1wdHkoZ2VvbWV0cnlPckV4dGVudCksXG4gICAgICAgIDI1KTsgLy8gQ2Fubm90IGZpdCBlbXB0eSBleHRlbnQgcHJvdmlkZWQgYXMgYGdlb21ldHJ5YFxuICAgICAgZ2VvbWV0cnkgPSBwb2x5Z29uRnJvbUV4dGVudChnZW9tZXRyeU9yRXh0ZW50KTtcbiAgICB9IGVsc2UgaWYgKGdlb21ldHJ5T3JFeHRlbnQuZ2V0VHlwZSgpID09PSBHZW9tZXRyeVR5cGUuQ0lSQ0xFKSB7XG4gICAgICBnZW9tZXRyeU9yRXh0ZW50ID0gZ2VvbWV0cnlPckV4dGVudC5nZXRFeHRlbnQoKTtcbiAgICAgIGdlb21ldHJ5ID0gcG9seWdvbkZyb21FeHRlbnQoZ2VvbWV0cnlPckV4dGVudCk7XG4gICAgICBnZW9tZXRyeS5yb3RhdGUodGhpcy5nZXRSb3RhdGlvbigpLCBnZXRDZW50ZXIoZ2VvbWV0cnlPckV4dGVudCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW9tZXRyeSA9IGdlb21ldHJ5T3JFeHRlbnQ7XG4gICAgfVxuXG4gICAgdmFyIHBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmcgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucGFkZGluZyA6IFswLCAwLCAwLCAwXTtcbiAgICB2YXIgY29uc3RyYWluUmVzb2x1dGlvbiA9IG9wdGlvbnMuY29uc3RyYWluUmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdGlvbnMuY29uc3RyYWluUmVzb2x1dGlvbiA6IHRydWU7XG4gICAgdmFyIG5lYXJlc3QgPSBvcHRpb25zLm5lYXJlc3QgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubmVhcmVzdCA6IGZhbHNlO1xuICAgIHZhciBtaW5SZXNvbHV0aW9uO1xuICAgIGlmIChvcHRpb25zLm1pblJlc29sdXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgbWluUmVzb2x1dGlvbiA9IG9wdGlvbnMubWluUmVzb2x1dGlvbjtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMubWF4Wm9vbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBtaW5SZXNvbHV0aW9uID0gdGhpcy5jb25zdHJhaW5SZXNvbHV0aW9uKFxuICAgICAgICB0aGlzLm1heFJlc29sdXRpb25fLCBvcHRpb25zLm1heFpvb20gLSB0aGlzLm1pblpvb21fLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWluUmVzb2x1dGlvbiA9IDA7XG4gICAgfVxuICAgIHZhciBjb29yZHMgPSBnZW9tZXRyeS5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcblxuICAgIC8vIGNhbGN1bGF0ZSByb3RhdGVkIGV4dGVudFxuICAgIHZhciByb3RhdGlvbiA9IHRoaXMuZ2V0Um90YXRpb24oKTtcbiAgICB2YXIgY29zQW5nbGUgPSBNYXRoLmNvcygtcm90YXRpb24pO1xuICAgIHZhciBzaW5BbmdsZSA9IE1hdGguc2luKC1yb3RhdGlvbik7XG4gICAgdmFyIG1pblJvdFggPSArSW5maW5pdHk7XG4gICAgdmFyIG1pblJvdFkgPSArSW5maW5pdHk7XG4gICAgdmFyIG1heFJvdFggPSAtSW5maW5pdHk7XG4gICAgdmFyIG1heFJvdFkgPSAtSW5maW5pdHk7XG4gICAgdmFyIHN0cmlkZSA9IGdlb21ldHJ5LmdldFN0cmlkZSgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGNvb3Jkcy5sZW5ndGg7IGkgPCBpaTsgaSArPSBzdHJpZGUpIHtcbiAgICAgIHZhciByb3RYID0gY29vcmRzW2ldICogY29zQW5nbGUgLSBjb29yZHNbaSArIDFdICogc2luQW5nbGU7XG4gICAgICB2YXIgcm90WSA9IGNvb3Jkc1tpXSAqIHNpbkFuZ2xlICsgY29vcmRzW2kgKyAxXSAqIGNvc0FuZ2xlO1xuICAgICAgbWluUm90WCA9IE1hdGgubWluKG1pblJvdFgsIHJvdFgpO1xuICAgICAgbWluUm90WSA9IE1hdGgubWluKG1pblJvdFksIHJvdFkpO1xuICAgICAgbWF4Um90WCA9IE1hdGgubWF4KG1heFJvdFgsIHJvdFgpO1xuICAgICAgbWF4Um90WSA9IE1hdGgubWF4KG1heFJvdFksIHJvdFkpO1xuICAgIH1cblxuICAgIC8vIGNhbGN1bGF0ZSByZXNvbHV0aW9uXG4gICAgdmFyIHJlc29sdXRpb24gPSB0aGlzLmdldFJlc29sdXRpb25Gb3JFeHRlbnQoXG4gICAgICBbbWluUm90WCwgbWluUm90WSwgbWF4Um90WCwgbWF4Um90WV0sXG4gICAgICBbc2l6ZVswXSAtIHBhZGRpbmdbMV0gLSBwYWRkaW5nWzNdLCBzaXplWzFdIC0gcGFkZGluZ1swXSAtIHBhZGRpbmdbMl1dKTtcbiAgICByZXNvbHV0aW9uID0gaXNOYU4ocmVzb2x1dGlvbikgPyBtaW5SZXNvbHV0aW9uIDpcbiAgICAgIE1hdGgubWF4KHJlc29sdXRpb24sIG1pblJlc29sdXRpb24pO1xuICAgIGlmIChjb25zdHJhaW5SZXNvbHV0aW9uKSB7XG4gICAgICB2YXIgY29uc3RyYWluZWRSZXNvbHV0aW9uID0gdGhpcy5jb25zdHJhaW5SZXNvbHV0aW9uKHJlc29sdXRpb24sIDAsIDApO1xuICAgICAgaWYgKCFuZWFyZXN0ICYmIGNvbnN0cmFpbmVkUmVzb2x1dGlvbiA8IHJlc29sdXRpb24pIHtcbiAgICAgICAgY29uc3RyYWluZWRSZXNvbHV0aW9uID0gdGhpcy5jb25zdHJhaW5SZXNvbHV0aW9uKFxuICAgICAgICAgIGNvbnN0cmFpbmVkUmVzb2x1dGlvbiwgLTEsIDApO1xuICAgICAgfVxuICAgICAgcmVzb2x1dGlvbiA9IGNvbnN0cmFpbmVkUmVzb2x1dGlvbjtcbiAgICB9XG5cbiAgICAvLyBjYWxjdWxhdGUgY2VudGVyXG4gICAgc2luQW5nbGUgPSAtc2luQW5nbGU7IC8vIGdvIGJhY2sgdG8gb3JpZ2luYWwgcm90YXRpb25cbiAgICB2YXIgY2VudGVyUm90WCA9IChtaW5Sb3RYICsgbWF4Um90WCkgLyAyO1xuICAgIHZhciBjZW50ZXJSb3RZID0gKG1pblJvdFkgKyBtYXhSb3RZKSAvIDI7XG4gICAgY2VudGVyUm90WCArPSAocGFkZGluZ1sxXSAtIHBhZGRpbmdbM10pIC8gMiAqIHJlc29sdXRpb247XG4gICAgY2VudGVyUm90WSArPSAocGFkZGluZ1swXSAtIHBhZGRpbmdbMl0pIC8gMiAqIHJlc29sdXRpb247XG4gICAgdmFyIGNlbnRlclggPSBjZW50ZXJSb3RYICogY29zQW5nbGUgLSBjZW50ZXJSb3RZICogc2luQW5nbGU7XG4gICAgdmFyIGNlbnRlclkgPSBjZW50ZXJSb3RZICogY29zQW5nbGUgKyBjZW50ZXJSb3RYICogc2luQW5nbGU7XG4gICAgdmFyIGNlbnRlciA9IFtjZW50ZXJYLCBjZW50ZXJZXTtcbiAgICB2YXIgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrID8gb3B0aW9ucy5jYWxsYmFjayA6IFZPSUQ7XG5cbiAgICBpZiAob3B0aW9ucy5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmFuaW1hdGUoe1xuICAgICAgICByZXNvbHV0aW9uOiByZXNvbHV0aW9uLFxuICAgICAgICBjZW50ZXI6IGNlbnRlcixcbiAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG4gICAgICAgIGVhc2luZzogb3B0aW9ucy5lYXNpbmdcbiAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRSZXNvbHV0aW9uKHJlc29sdXRpb24pO1xuICAgICAgdGhpcy5zZXRDZW50ZXIoY2VudGVyKTtcbiAgICAgIGFuaW1hdGlvbkNhbGxiYWNrKGNhbGxiYWNrLCB0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENlbnRlciBvbiBjb29yZGluYXRlIGFuZCB2aWV3IHBvc2l0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9IHNpemUgQm94IHBpeGVsIHNpemUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9waXhlbC5qc1wiKS5QaXhlbH0gcG9zaXRpb24gUG9zaXRpb24gb24gdGhlIHZpZXcgdG8gY2VudGVyIG9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5jZW50ZXJPbiA9IGZ1bmN0aW9uIGNlbnRlck9uIChjb29yZGluYXRlLCBzaXplLCBwb3NpdGlvbikge1xuICAgIC8vIGNhbGN1bGF0ZSByb3RhdGVkIHBvc2l0aW9uXG4gICAgdmFyIHJvdGF0aW9uID0gdGhpcy5nZXRSb3RhdGlvbigpO1xuICAgIHZhciBjb3NBbmdsZSA9IE1hdGguY29zKC1yb3RhdGlvbik7XG4gICAgdmFyIHNpbkFuZ2xlID0gTWF0aC5zaW4oLXJvdGF0aW9uKTtcbiAgICB2YXIgcm90WCA9IGNvb3JkaW5hdGVbMF0gKiBjb3NBbmdsZSAtIGNvb3JkaW5hdGVbMV0gKiBzaW5BbmdsZTtcbiAgICB2YXIgcm90WSA9IGNvb3JkaW5hdGVbMV0gKiBjb3NBbmdsZSArIGNvb3JkaW5hdGVbMF0gKiBzaW5BbmdsZTtcbiAgICB2YXIgcmVzb2x1dGlvbiA9IHRoaXMuZ2V0UmVzb2x1dGlvbigpO1xuICAgIHJvdFggKz0gKHNpemVbMF0gLyAyIC0gcG9zaXRpb25bMF0pICogcmVzb2x1dGlvbjtcbiAgICByb3RZICs9IChwb3NpdGlvblsxXSAtIHNpemVbMV0gLyAyKSAqIHJlc29sdXRpb247XG5cbiAgICAvLyBnbyBiYWNrIHRvIG9yaWdpbmFsIGFuZ2xlXG4gICAgc2luQW5nbGUgPSAtc2luQW5nbGU7IC8vIGdvIGJhY2sgdG8gb3JpZ2luYWwgcm90YXRpb25cbiAgICB2YXIgY2VudGVyWCA9IHJvdFggKiBjb3NBbmdsZSAtIHJvdFkgKiBzaW5BbmdsZTtcbiAgICB2YXIgY2VudGVyWSA9IHJvdFkgKiBjb3NBbmdsZSArIHJvdFggKiBzaW5BbmdsZTtcblxuICAgIHRoaXMuc2V0Q2VudGVyKFtjZW50ZXJYLCBjZW50ZXJZXSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIGRlZmluZWQuXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5pc0RlZiA9IGZ1bmN0aW9uIGlzRGVmICgpIHtcbiAgICByZXR1cm4gISF0aGlzLmdldENlbnRlcigpICYmIHRoaXMuZ2V0UmVzb2x1dGlvbigpICE9PSB1bmRlZmluZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJvdGF0ZSB0aGUgdmlldyBhcm91bmQgYSBnaXZlbiBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcm90YXRpb24gTmV3IHJvdGF0aW9uIHZhbHVlIGZvciB0aGUgdmlldy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT19IG9wdF9hbmNob3IgVGhlIHJvdGF0aW9uIGNlbnRlci5cbiAgICogQGFwaVxuICAgKi9cbiAgVmlldy5wcm90b3R5cGUucm90YXRlID0gZnVuY3Rpb24gcm90YXRlIChyb3RhdGlvbiwgb3B0X2FuY2hvcikge1xuICAgIGlmIChvcHRfYW5jaG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmNhbGN1bGF0ZUNlbnRlclJvdGF0ZShyb3RhdGlvbiwgb3B0X2FuY2hvcik7XG4gICAgICB0aGlzLnNldENlbnRlcihjZW50ZXIpO1xuICAgIH1cbiAgICB0aGlzLnNldFJvdGF0aW9uKHJvdGF0aW9uKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBjZW50ZXIgb2YgdGhlIGN1cnJlbnQgdmlldy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZXx1bmRlZmluZWR9IGNlbnRlciBUaGUgY2VudGVyIG9mIHRoZSB2aWV3LlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5zZXRDZW50ZXIgPSBmdW5jdGlvbiBzZXRDZW50ZXIgKGNlbnRlcikge1xuICAgIHRoaXMuc2V0KFZpZXdQcm9wZXJ0eS5DRU5URVIsIGNlbnRlcik7XG4gICAgaWYgKHRoaXMuZ2V0QW5pbWF0aW5nKCkpIHtcbiAgICAgIHRoaXMuY2FuY2VsQW5pbWF0aW9ucygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtWaWV3SGludH0gaGludCBIaW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGEgRGVsdGEuXG4gICAqIEByZXR1cm4ge251bWJlcn0gTmV3IHZhbHVlLlxuICAgKi9cbiAgVmlldy5wcm90b3R5cGUuc2V0SGludCA9IGZ1bmN0aW9uIHNldEhpbnQgKGhpbnQsIGRlbHRhKSB7XG4gICAgdGhpcy5oaW50c19baGludF0gKz0gZGVsdGE7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgcmV0dXJuIHRoaXMuaGludHNfW2hpbnRdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHJlc29sdXRpb24gZm9yIHRoaXMgdmlldy5cbiAgICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSByZXNvbHV0aW9uIFRoZSByZXNvbHV0aW9uIG9mIHRoZSB2aWV3LlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5zZXRSZXNvbHV0aW9uID0gZnVuY3Rpb24gc2V0UmVzb2x1dGlvbiAocmVzb2x1dGlvbikge1xuICAgIHRoaXMuc2V0KFZpZXdQcm9wZXJ0eS5SRVNPTFVUSU9OLCByZXNvbHV0aW9uKTtcbiAgICBpZiAodGhpcy5nZXRBbmltYXRpbmcoKSkge1xuICAgICAgdGhpcy5jYW5jZWxBbmltYXRpb25zKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHJvdGF0aW9uIGZvciB0aGlzIHZpZXcuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvbiBUaGUgcm90YXRpb24gb2YgdGhlIHZpZXcgaW4gcmFkaWFucy5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgVmlldy5wcm90b3R5cGUuc2V0Um90YXRpb24gPSBmdW5jdGlvbiBzZXRSb3RhdGlvbiAocm90YXRpb24pIHtcbiAgICB0aGlzLnNldChWaWV3UHJvcGVydHkuUk9UQVRJT04sIHJvdGF0aW9uKTtcbiAgICBpZiAodGhpcy5nZXRBbmltYXRpbmcoKSkge1xuICAgICAgdGhpcy5jYW5jZWxBbmltYXRpb25zKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBab29tIHRvIGEgc3BlY2lmaWMgem9vbSBsZXZlbC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHpvb20gWm9vbSBsZXZlbC5cbiAgICogQGFwaVxuICAgKi9cbiAgVmlldy5wcm90b3R5cGUuc2V0Wm9vbSA9IGZ1bmN0aW9uIHNldFpvb20gKHpvb20pIHtcbiAgICB0aGlzLnNldFJlc29sdXRpb24odGhpcy5nZXRSZXNvbHV0aW9uRm9yWm9vbSh6b29tKSk7XG4gIH07XG5cbiAgcmV0dXJuIFZpZXc7XG59KEJhc2VPYmplY3QpKTtcblxuXG4vKipcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrLlxuICogQHBhcmFtIHsqfSByZXR1cm5WYWx1ZSBSZXR1cm4gdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFuaW1hdGlvbkNhbGxiYWNrKGNhbGxiYWNrLCByZXR1cm5WYWx1ZSkge1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGNhbGxiYWNrKHJldHVyblZhbHVlKTtcbiAgfSwgMCk7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge1ZpZXdPcHRpb25zfSBvcHRpb25zIFZpZXcgb3B0aW9ucy5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vY2VudGVyY29uc3RyYWludC5qc1wiKS5UeXBlfSBUaGUgY29uc3RyYWludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNlbnRlckNvbnN0cmFpbnQob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5leHRlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBjcmVhdGVFeHRlbnQob3B0aW9ucy5leHRlbnQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjZW50ZXJOb25lO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge1ZpZXdPcHRpb25zfSBvcHRpb25zIFZpZXcgb3B0aW9ucy5cbiAqIEByZXR1cm4ge3tjb25zdHJhaW50OiBpbXBvcnQoXCIuL3Jlc29sdXRpb25jb25zdHJhaW50LmpzXCIpLlR5cGUsIG1heFJlc29sdXRpb246IG51bWJlcixcbiAqICAgICBtaW5SZXNvbHV0aW9uOiBudW1iZXIsIG1pblpvb206IG51bWJlciwgem9vbUZhY3RvcjogbnVtYmVyfX0gVGhlIGNvbnN0cmFpbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSZXNvbHV0aW9uQ29uc3RyYWludChvcHRpb25zKSB7XG4gIHZhciByZXNvbHV0aW9uQ29uc3RyYWludDtcbiAgdmFyIG1heFJlc29sdXRpb247XG4gIHZhciBtaW5SZXNvbHV0aW9uO1xuXG4gIC8vIFRPRE86IG1vdmUgdGhlc2UgdG8gYmUgb2wgY29uc3RhbnRzXG4gIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vb3BlbmxheWVycy9vcGVubGF5ZXJzL2lzc3Vlcy8yMDc2XG4gIHZhciBkZWZhdWx0TWF4Wm9vbSA9IDI4O1xuICB2YXIgZGVmYXVsdFpvb21GYWN0b3IgPSAyO1xuXG4gIHZhciBtaW5ab29tID0gb3B0aW9ucy5taW5ab29tICE9PSB1bmRlZmluZWQgP1xuICAgIG9wdGlvbnMubWluWm9vbSA6IERFRkFVTFRfTUlOX1pPT007XG5cbiAgdmFyIG1heFpvb20gPSBvcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCA/XG4gICAgb3B0aW9ucy5tYXhab29tIDogZGVmYXVsdE1heFpvb207XG5cbiAgdmFyIHpvb21GYWN0b3IgPSBvcHRpb25zLnpvb21GYWN0b3IgIT09IHVuZGVmaW5lZCA/XG4gICAgb3B0aW9ucy56b29tRmFjdG9yIDogZGVmYXVsdFpvb21GYWN0b3I7XG5cbiAgaWYgKG9wdGlvbnMucmVzb2x1dGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciByZXNvbHV0aW9ucyA9IG9wdGlvbnMucmVzb2x1dGlvbnM7XG4gICAgbWF4UmVzb2x1dGlvbiA9IHJlc29sdXRpb25zW21pblpvb21dO1xuICAgIG1pblJlc29sdXRpb24gPSByZXNvbHV0aW9uc1ttYXhab29tXSAhPT0gdW5kZWZpbmVkID9cbiAgICAgIHJlc29sdXRpb25zW21heFpvb21dIDogcmVzb2x1dGlvbnNbcmVzb2x1dGlvbnMubGVuZ3RoIC0gMV07XG4gICAgcmVzb2x1dGlvbkNvbnN0cmFpbnQgPSBjcmVhdGVTbmFwVG9SZXNvbHV0aW9ucyhcbiAgICAgIHJlc29sdXRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBjYWxjdWxhdGUgdGhlIGRlZmF1bHQgbWluIGFuZCBtYXggcmVzb2x1dGlvblxuICAgIHZhciBwcm9qZWN0aW9uID0gY3JlYXRlUHJvamVjdGlvbihvcHRpb25zLnByb2plY3Rpb24sICdFUFNHOjM4NTcnKTtcbiAgICB2YXIgZXh0ZW50ID0gcHJvamVjdGlvbi5nZXRFeHRlbnQoKTtcbiAgICB2YXIgc2l6ZSA9ICFleHRlbnQgP1xuICAgICAgLy8gdXNlIGFuIGV4dGVudCB0aGF0IGNhbiBmaXQgdGhlIHdob2xlIHdvcmxkIGlmIG5lZWQgYmVcbiAgICAgIDM2MCAqIE1FVEVSU19QRVJfVU5JVFtVbml0cy5ERUdSRUVTXSAvXG4gICAgICAgICAgICBwcm9qZWN0aW9uLmdldE1ldGVyc1BlclVuaXQoKSA6XG4gICAgICBNYXRoLm1heChnZXRXaWR0aChleHRlbnQpLCBnZXRIZWlnaHQoZXh0ZW50KSk7XG5cbiAgICB2YXIgZGVmYXVsdE1heFJlc29sdXRpb24gPSBzaXplIC8gREVGQVVMVF9USUxFX1NJWkUgLyBNYXRoLnBvdyhcbiAgICAgIGRlZmF1bHRab29tRmFjdG9yLCBERUZBVUxUX01JTl9aT09NKTtcblxuICAgIHZhciBkZWZhdWx0TWluUmVzb2x1dGlvbiA9IGRlZmF1bHRNYXhSZXNvbHV0aW9uIC8gTWF0aC5wb3coXG4gICAgICBkZWZhdWx0Wm9vbUZhY3RvciwgZGVmYXVsdE1heFpvb20gLSBERUZBVUxUX01JTl9aT09NKTtcblxuICAgIC8vIHVzZXIgcHJvdmlkZWQgbWF4UmVzb2x1dGlvbiB0YWtlcyBwcmVjZWRlbmNlXG4gICAgbWF4UmVzb2x1dGlvbiA9IG9wdGlvbnMubWF4UmVzb2x1dGlvbjtcbiAgICBpZiAobWF4UmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBtaW5ab29tID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF4UmVzb2x1dGlvbiA9IGRlZmF1bHRNYXhSZXNvbHV0aW9uIC8gTWF0aC5wb3coem9vbUZhY3RvciwgbWluWm9vbSk7XG4gICAgfVxuXG4gICAgLy8gdXNlciBwcm92aWRlZCBtaW5SZXNvbHV0aW9uIHRha2VzIHByZWNlZGVuY2VcbiAgICBtaW5SZXNvbHV0aW9uID0gb3B0aW9ucy5taW5SZXNvbHV0aW9uO1xuICAgIGlmIChtaW5SZXNvbHV0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChvcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAob3B0aW9ucy5tYXhSZXNvbHV0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBtaW5SZXNvbHV0aW9uID0gbWF4UmVzb2x1dGlvbiAvIE1hdGgucG93KHpvb21GYWN0b3IsIG1heFpvb20pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1pblJlc29sdXRpb24gPSBkZWZhdWx0TWF4UmVzb2x1dGlvbiAvIE1hdGgucG93KHpvb21GYWN0b3IsIG1heFpvb20pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaW5SZXNvbHV0aW9uID0gZGVmYXVsdE1pblJlc29sdXRpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZ2l2ZW4gZGlzY3JldGUgem9vbSBsZXZlbHMsIG1pblJlc29sdXRpb24gbWF5IGJlIGRpZmZlcmVudCB0aGFuIHByb3ZpZGVkXG4gICAgbWF4Wm9vbSA9IG1pblpvb20gKyBNYXRoLmZsb29yKFxuICAgICAgTWF0aC5sb2cobWF4UmVzb2x1dGlvbiAvIG1pblJlc29sdXRpb24pIC8gTWF0aC5sb2coem9vbUZhY3RvcikpO1xuICAgIG1pblJlc29sdXRpb24gPSBtYXhSZXNvbHV0aW9uIC8gTWF0aC5wb3coem9vbUZhY3RvciwgbWF4Wm9vbSAtIG1pblpvb20pO1xuXG4gICAgcmVzb2x1dGlvbkNvbnN0cmFpbnQgPSBjcmVhdGVTbmFwVG9Qb3dlcihcbiAgICAgIHpvb21GYWN0b3IsIG1heFJlc29sdXRpb24sIG1heFpvb20gLSBtaW5ab29tKTtcbiAgfVxuICByZXR1cm4ge2NvbnN0cmFpbnQ6IHJlc29sdXRpb25Db25zdHJhaW50LCBtYXhSZXNvbHV0aW9uOiBtYXhSZXNvbHV0aW9uLFxuICAgIG1pblJlc29sdXRpb246IG1pblJlc29sdXRpb24sIG1pblpvb206IG1pblpvb20sIHpvb21GYWN0b3I6IHpvb21GYWN0b3J9O1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtWaWV3T3B0aW9uc30gb3B0aW9ucyBWaWV3IG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL3JvdGF0aW9uY29uc3RyYWludC5qc1wiKS5UeXBlfSBSb3RhdGlvbiBjb25zdHJhaW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUm90YXRpb25Db25zdHJhaW50KG9wdGlvbnMpIHtcbiAgdmFyIGVuYWJsZVJvdGF0aW9uID0gb3B0aW9ucy5lbmFibGVSb3RhdGlvbiAhPT0gdW5kZWZpbmVkID9cbiAgICBvcHRpb25zLmVuYWJsZVJvdGF0aW9uIDogdHJ1ZTtcbiAgaWYgKGVuYWJsZVJvdGF0aW9uKSB7XG4gICAgdmFyIGNvbnN0cmFpblJvdGF0aW9uID0gb3B0aW9ucy5jb25zdHJhaW5Sb3RhdGlvbjtcbiAgICBpZiAoY29uc3RyYWluUm90YXRpb24gPT09IHVuZGVmaW5lZCB8fCBjb25zdHJhaW5Sb3RhdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVNuYXBUb1plcm8oKTtcbiAgICB9IGVsc2UgaWYgKGNvbnN0cmFpblJvdGF0aW9uID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHJvdGF0aW9uTm9uZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb25zdHJhaW5Sb3RhdGlvbiA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBjcmVhdGVTbmFwVG9OKGNvbnN0cmFpblJvdGF0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJvdGF0aW9uTm9uZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRpc2FibGU7XG4gIH1cbn1cblxuXG4vKipcbiAqIERldGVybWluZSBpZiBhbiBhbmltYXRpb24gaW52b2x2ZXMgbm8gdmlldyBjaGFuZ2UuXG4gKiBAcGFyYW0ge0FuaW1hdGlvbn0gYW5pbWF0aW9uIFRoZSBhbmltYXRpb24uXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgYW5pbWF0aW9uIGludm9sdmVzIG5vIHZpZXcgY2hhbmdlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOb29wQW5pbWF0aW9uKGFuaW1hdGlvbikge1xuICBpZiAoYW5pbWF0aW9uLnNvdXJjZUNlbnRlciAmJiBhbmltYXRpb24udGFyZ2V0Q2VudGVyKSB7XG4gICAgaWYgKCFjb29yZGluYXRlc0VxdWFsKGFuaW1hdGlvbi5zb3VyY2VDZW50ZXIsIGFuaW1hdGlvbi50YXJnZXRDZW50ZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChhbmltYXRpb24uc291cmNlUmVzb2x1dGlvbiAhPT0gYW5pbWF0aW9uLnRhcmdldFJlc29sdXRpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGFuaW1hdGlvbi5zb3VyY2VSb3RhdGlvbiAhPT0gYW5pbWF0aW9uLnRhcmdldFJvdGF0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBWaWV3O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1WaWV3LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9WaWV3SGludFxuICovXG5cbi8qKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBBTklNQVRJTkc6IDAsXG4gIElOVEVSQUNUSU5HOiAxXG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1WaWV3SGludC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvVmlld1Byb3BlcnR5XG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIENFTlRFUjogJ2NlbnRlcicsXG4gIFJFU09MVVRJT046ICdyZXNvbHV0aW9uJyxcbiAgUk9UQVRJT046ICdyb3RhdGlvbidcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZpZXdQcm9wZXJ0eS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvYXJyYXlcbiAqL1xuXG5cbi8qKlxuICogUGVyZm9ybXMgYSBiaW5hcnkgc2VhcmNoIG9uIHRoZSBwcm92aWRlZCBzb3J0ZWQgbGlzdCBhbmQgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGl0ZW0gaWYgZm91bmQuIElmIGl0IGNhbid0IGJlIGZvdW5kIGl0J2xsIHJldHVybiAtMS5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXJrc2t5YXBwL2JpbmFyeS1zZWFyY2hcbiAqXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBoYXlzdGFjayBJdGVtcyB0byBzZWFyY2ggdGhyb3VnaC5cbiAqIEBwYXJhbSB7Kn0gbmVlZGxlIFRoZSBpdGVtIHRvIGxvb2sgZm9yLlxuICogQHBhcmFtIHtGdW5jdGlvbj19IG9wdF9jb21wYXJhdG9yIENvbXBhcmF0b3IgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgaXRlbSBpZiBmb3VuZCwgLTEgaWYgbm90LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluYXJ5U2VhcmNoKGhheXN0YWNrLCBuZWVkbGUsIG9wdF9jb21wYXJhdG9yKSB7XG4gIHZhciBtaWQsIGNtcDtcbiAgdmFyIGNvbXBhcmF0b3IgPSBvcHRfY29tcGFyYXRvciB8fCBudW1iZXJTYWZlQ29tcGFyZUZ1bmN0aW9uO1xuICB2YXIgbG93ID0gMDtcbiAgdmFyIGhpZ2ggPSBoYXlzdGFjay5sZW5ndGg7XG4gIHZhciBmb3VuZCA9IGZhbHNlO1xuXG4gIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgLyogTm90ZSB0aGF0IFwiKGxvdyArIGhpZ2gpID4+PiAxXCIgbWF5IG92ZXJmbG93LCBhbmQgcmVzdWx0cyBpbiBhIHR5cGVjYXN0XG4gICAgICogdG8gZG91YmxlICh3aGljaCBnaXZlcyB0aGUgd3JvbmcgcmVzdWx0cykuICovXG4gICAgbWlkID0gbG93ICsgKGhpZ2ggLSBsb3cgPj4gMSk7XG4gICAgY21wID0gK2NvbXBhcmF0b3IoaGF5c3RhY2tbbWlkXSwgbmVlZGxlKTtcblxuICAgIGlmIChjbXAgPCAwLjApIHsgLyogVG9vIGxvdy4gKi9cbiAgICAgIGxvdyA9IG1pZCArIDE7XG5cbiAgICB9IGVsc2UgeyAvKiBLZXkgZm91bmQgb3IgdG9vIGhpZ2ggKi9cbiAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICBmb3VuZCA9ICFjbXA7XG4gICAgfVxuICB9XG5cbiAgLyogS2V5IG5vdCBmb3VuZC4gKi9cbiAgcmV0dXJuIGZvdW5kID8gbG93IDogfmxvdztcbn1cblxuXG4vKipcbiAqIENvbXBhcmUgZnVuY3Rpb24gZm9yIGFycmF5IHNvcnQgdGhhdCBpcyBzYWZlIGZvciBudW1iZXJzLlxuICogQHBhcmFtIHsqfSBhIFRoZSBmaXJzdCBvYmplY3QgdG8gYmUgY29tcGFyZWQuXG4gKiBAcGFyYW0geyp9IGIgVGhlIHNlY29uZCBvYmplY3QgdG8gYmUgY29tcGFyZWQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgbmVnYXRpdmUgbnVtYmVyLCB6ZXJvLCBvciBhIHBvc2l0aXZlIG51bWJlciBhcyB0aGUgZmlyc3RcbiAqICAgICBhcmd1bWVudCBpcyBsZXNzIHRoYW4sIGVxdWFsIHRvLCBvciBncmVhdGVyIHRoYW4gdGhlIHNlY29uZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclNhZmVDb21wYXJlRnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gYSA+IGIgPyAxIDogYSA8IGIgPyAtMSA6IDA7XG59XG5cblxuLyoqXG4gKiBXaGV0aGVyIHRoZSBhcnJheSBjb250YWlucyB0aGUgZ2l2ZW4gb2JqZWN0LlxuICogQHBhcmFtIHtBcnJheTwqPn0gYXJyIFRoZSBhcnJheSB0byB0ZXN0IGZvciB0aGUgcHJlc2VuY2Ugb2YgdGhlIGVsZW1lbnQuXG4gKiBAcGFyYW0geyp9IG9iaiBUaGUgb2JqZWN0IGZvciB3aGljaCB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIG9iamVjdCBpcyBpbiB0aGUgYXJyYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmNsdWRlcyhhcnIsIG9iaikge1xuICByZXR1cm4gYXJyLmluZGV4T2Yob2JqKSA+PSAwO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBhcnIgQXJyYXkuXG4gKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0IFRhcmdldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXJlY3Rpb24gMCBtZWFucyByZXR1cm4gdGhlIG5lYXJlc3QsID4gMFxuICogICAgbWVhbnMgcmV0dXJuIHRoZSBsYXJnZXN0IG5lYXJlc3QsIDwgMCBtZWFucyByZXR1cm4gdGhlXG4gKiAgICBzbWFsbGVzdCBuZWFyZXN0LlxuICogQHJldHVybiB7bnVtYmVyfSBJbmRleC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhckZpbmROZWFyZXN0KGFyciwgdGFyZ2V0LCBkaXJlY3Rpb24pIHtcbiAgdmFyIG4gPSBhcnIubGVuZ3RoO1xuICBpZiAoYXJyWzBdIDw9IHRhcmdldCkge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2UgaWYgKHRhcmdldCA8PSBhcnJbbiAtIDFdKSB7XG4gICAgcmV0dXJuIG4gLSAxO1xuICB9IGVsc2Uge1xuICAgIHZhciBpO1xuICAgIGlmIChkaXJlY3Rpb24gPiAwKSB7XG4gICAgICBmb3IgKGkgPSAxOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmIChhcnJbaV0gPCB0YXJnZXQpIHtcbiAgICAgICAgICByZXR1cm4gaSAtIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA8IDApIHtcbiAgICAgIGZvciAoaSA9IDE7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaWYgKGFycltpXSA8PSB0YXJnZXQpIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAxOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmIChhcnJbaV0gPT0gdGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJyW2ldIDwgdGFyZ2V0KSB7XG4gICAgICAgICAgaWYgKGFycltpIC0gMV0gLSB0YXJnZXQgPCB0YXJnZXQgLSBhcnJbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBpIC0gMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuIC0gMTtcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTwqPn0gYXJyIEFycmF5LlxuICogQHBhcmFtIHtudW1iZXJ9IGJlZ2luIEJlZ2luIGluZGV4LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQgaW5kZXguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXZlcnNlU3ViQXJyYXkoYXJyLCBiZWdpbiwgZW5kKSB7XG4gIHdoaWxlIChiZWdpbiA8IGVuZCkge1xuICAgIHZhciB0bXAgPSBhcnJbYmVnaW5dO1xuICAgIGFycltiZWdpbl0gPSBhcnJbZW5kXTtcbiAgICBhcnJbZW5kXSA9IHRtcDtcbiAgICArK2JlZ2luO1xuICAgIC0tZW5kO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PFZBTFVFPn0gYXJyIFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0geyFBcnJheTxWQUxVRT58VkFMVUV9IGRhdGEgVGhlIGVsZW1lbnRzIG9yIGFycmF5cyBvZiBlbGVtZW50cyB0byBhZGQgdG8gYXJyLlxuICogQHRlbXBsYXRlIFZBTFVFXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQoYXJyLCBkYXRhKSB7XG4gIHZhciBleHRlbnNpb24gPSBBcnJheS5pc0FycmF5KGRhdGEpID8gZGF0YSA6IFtkYXRhXTtcbiAgdmFyIGxlbmd0aCA9IGV4dGVuc2lvbi5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBhcnJbYXJyLmxlbmd0aF0gPSBleHRlbnNpb25baV07XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8VkFMVUU+fSBhcnIgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7VkFMVUV9IG9iaiBUaGUgZWxlbWVudCB0byByZW1vdmUuXG4gKiBAdGVtcGxhdGUgVkFMVUVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IElmIHRoZSBlbGVtZW50IHdhcyByZW1vdmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlKGFyciwgb2JqKSB7XG4gIHZhciBpID0gYXJyLmluZGV4T2Yob2JqKTtcbiAgdmFyIGZvdW5kID0gaSA+IC0xO1xuICBpZiAoZm91bmQpIHtcbiAgICBhcnIuc3BsaWNlKGksIDEpO1xuICB9XG4gIHJldHVybiBmb3VuZDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8VkFMVUU+fSBhcnIgVGhlIGFycmF5IHRvIHNlYXJjaCBpbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVkFMVUUsIG51bWJlciwgPykgOiBib29sZWFufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb21wYXJlLlxuICogQHRlbXBsYXRlIFZBTFVFXG4gKiBAcmV0dXJuIHtWQUxVRXxudWxsfSBUaGUgZWxlbWVudCBmb3VuZCBvciBudWxsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZChhcnIsIGZ1bmMpIHtcbiAgdmFyIGxlbmd0aCA9IGFyci5sZW5ndGggPj4+IDA7XG4gIHZhciB2YWx1ZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFsdWUgPSBhcnJbaV07XG4gICAgaWYgKGZ1bmModmFsdWUsIGksIGFycikpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5fFVpbnQ4Q2xhbXBlZEFycmF5fSBhcnIxIFRoZSBmaXJzdCBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheXxVaW50OENsYW1wZWRBcnJheX0gYXJyMiBUaGUgc2Vjb25kIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSB0d28gYXJyYXlzIGFyZSBlcXVhbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhcnIxLCBhcnIyKSB7XG4gIHZhciBsZW4xID0gYXJyMS5sZW5ndGg7XG4gIGlmIChsZW4xICE9PSBhcnIyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjE7IGkrKykge1xuICAgIGlmIChhcnIxW2ldICE9PSBhcnIyW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5cbi8qKlxuICogU29ydCB0aGUgcGFzc2VkIGFycmF5IHN1Y2ggdGhhdCB0aGUgcmVsYXRpdmUgb3JkZXIgb2YgZXF1YWwgZWxlbWVudHMgaXMgcHJldmVydmVkLlxuICogU2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NvcnRpbmdfYWxnb3JpdGhtI1N0YWJpbGl0eSBmb3IgZGV0YWlscy5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IGFyciBUaGUgYXJyYXkgdG8gc29ydCAobW9kaWZpZXMgb3JpZ2luYWwpLlxuICogQHBhcmFtIHshZnVuY3Rpb24oKiwgKik6IG51bWJlcn0gY29tcGFyZUZuYyBDb21wYXJpc29uIGZ1bmN0aW9uLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhYmxlU29ydChhcnIsIGNvbXBhcmVGbmMpIHtcbiAgdmFyIGxlbmd0aCA9IGFyci5sZW5ndGg7XG4gIHZhciB0bXAgPSBBcnJheShhcnIubGVuZ3RoKTtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHRtcFtpXSA9IHtpbmRleDogaSwgdmFsdWU6IGFycltpXX07XG4gIH1cbiAgdG1wLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBjb21wYXJlRm5jKGEudmFsdWUsIGIudmFsdWUpIHx8IGEuaW5kZXggLSBiLmluZGV4O1xuICB9KTtcbiAgZm9yIChpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGFycltpXSA9IHRtcFtpXS52YWx1ZTtcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTwqPn0gYXJyIFRoZSBhcnJheSB0byBzZWFyY2ggaW4uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIENvbXBhcmlzb24gZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFJldHVybiBpbmRleC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRJbmRleChhcnIsIGZ1bmMpIHtcbiAgdmFyIGluZGV4O1xuICB2YXIgZm91bmQgPSAhYXJyLmV2ZXJ5KGZ1bmN0aW9uKGVsLCBpZHgpIHtcbiAgICBpbmRleCA9IGlkeDtcbiAgICByZXR1cm4gIWZ1bmMoZWwsIGlkeCwgYXJyKTtcbiAgfSk7XG4gIHJldHVybiBmb3VuZCA/IGluZGV4IDogLTE7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhcnIgVGhlIGFycmF5IHRvIHRlc3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb3B0X2Z1bmMgQ29tcGFyaXNvbiBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9zdHJpY3QgU3RyaWN0bHkgc29ydGVkIChkZWZhdWx0IGZhbHNlKS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybiBpbmRleC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU29ydGVkKGFyciwgb3B0X2Z1bmMsIG9wdF9zdHJpY3QpIHtcbiAgdmFyIGNvbXBhcmUgPSBvcHRfZnVuYyB8fCBudW1iZXJTYWZlQ29tcGFyZUZ1bmN0aW9uO1xuICByZXR1cm4gYXJyLmV2ZXJ5KGZ1bmN0aW9uKGN1cnJlbnRWYWwsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIHJlcyA9IGNvbXBhcmUoYXJyW2luZGV4IC0gMV0sIGN1cnJlbnRWYWwpO1xuICAgIHJldHVybiAhKHJlcyA+IDAgfHwgb3B0X3N0cmljdCAmJiByZXMgPT09IDApO1xuICB9KTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJyYXkuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2Fzc2VydHNcbiAqL1xuaW1wb3J0IEFzc2VydGlvbkVycm9yIGZyb20gJy4vQXNzZXJ0aW9uRXJyb3IuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gYXNzZXJ0aW9uIEFzc2VydGlvbiB3ZSBleHBlY3RlZCB0byBiZSB0cnV0aHkuXG4gKiBAcGFyYW0ge251bWJlcn0gZXJyb3JDb2RlIEVycm9yIGNvZGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQoYXNzZXJ0aW9uLCBlcnJvckNvZGUpIHtcbiAgaWYgKCFhc3NlcnRpb24pIHtcbiAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IoZXJyb3JDb2RlKTtcbiAgfVxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3NlcnRzLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9jZW50ZXJjb25zdHJhaW50XG4gKi9cbmltcG9ydCB7Y2xhbXB9IGZyb20gJy4vbWF0aC5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oKGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfHVuZGVmaW5lZCkpOiAoaW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8dW5kZWZpbmVkKX0gVHlwZVxuICovXG5cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge1R5cGV9IFRoZSBjb25zdHJhaW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXh0ZW50KGV4dGVudCkge1xuICByZXR1cm4gKFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU9fSBjZW50ZXIgQ2VudGVyLlxuICAgICAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfHVuZGVmaW5lZH0gQ2VudGVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uKGNlbnRlcikge1xuICAgICAgaWYgKGNlbnRlcikge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIGNsYW1wKGNlbnRlclswXSwgZXh0ZW50WzBdLCBleHRlbnRbMl0pLFxuICAgICAgICAgIGNsYW1wKGNlbnRlclsxXSwgZXh0ZW50WzFdLCBleHRlbnRbM10pXG4gICAgICAgIF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU9fSBjZW50ZXIgQ2VudGVyLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8dW5kZWZpbmVkfSBDZW50ZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub25lKGNlbnRlcikge1xuICByZXR1cm4gY2VudGVyO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jZW50ZXJjb25zdHJhaW50LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9jb2xvclxuICovXG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi9hc3NlcnRzLmpzJztcbmltcG9ydCB7Y2xhbXB9IGZyb20gJy4vbWF0aC5qcyc7XG5cblxuLyoqXG4gKiBBIGNvbG9yIHJlcHJlc2VudGVkIGFzIGEgc2hvcnQgYXJyYXkgW3JlZCwgZ3JlZW4sIGJsdWUsIGFscGhhXS5cbiAqIHJlZCwgZ3JlZW4sIGFuZCBibHVlIHNob3VsZCBiZSBpbnRlZ2VycyBpbiB0aGUgcmFuZ2UgMC4uMjU1IGluY2x1c2l2ZS5cbiAqIGFscGhhIHNob3VsZCBiZSBhIGZsb2F0IGluIHRoZSByYW5nZSAwLi4xIGluY2x1c2l2ZS4gSWYgbm8gYWxwaGEgdmFsdWUgaXNcbiAqIGdpdmVuIHRoZW4gYDFgIHdpbGwgYmUgdXNlZC5cbiAqIEB0eXBlZGVmIHtBcnJheTxudW1iZXI+fSBDb2xvclxuICogQGFwaVxuICovXG5cblxuLyoqXG4gKiBUaGlzIFJlZ0V4cCBtYXRjaGVzICMgZm9sbG93ZWQgYnkgMywgNCwgNiwgb3IgOCBoZXggZGlnaXRzLlxuICogQGNvbnN0XG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQHByaXZhdGVcbiAqL1xudmFyIEhFWF9DT0xPUl9SRV8gPSAvXiMoW2EtZjAtOV17M318W2EtZjAtOV17NH0oPzpbYS1mMC05XXsyfSl7MCwyfSkkL2k7XG5cblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gZm9yIG1hdGNoaW5nIHBvdGVudGlhbCBuYW1lZCBjb2xvciBzdHlsZSBzdHJpbmdzLlxuICogQGNvbnN0XG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQHByaXZhdGVcbiAqL1xudmFyIE5BTUVEX0NPTE9SX1JFXyA9IC9eKFthLXpdKikkL2k7XG5cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGNvbG9yIGFzIGFuIHJnYmEgc3RyaW5nLlxuICogQHBhcmFtIHtDb2xvcnxzdHJpbmd9IGNvbG9yIENvbG9yLlxuICogQHJldHVybiB7c3RyaW5nfSBSZ2JhIHN0cmluZy5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzU3RyaW5nKGNvbG9yKSB7XG4gIGlmICh0eXBlb2YgY29sb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0b1N0cmluZyhjb2xvcik7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm4gbmFtZWQgY29sb3IgYXMgYW4gcmdiYSBzdHJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3IgTmFtZWQgY29sb3IuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFJnYiBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGZyb21OYW1lZChjb2xvcikge1xuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZWwuc3R5bGUuY29sb3IgPSBjb2xvcjtcbiAgaWYgKGVsLnN0eWxlLmNvbG9yICE9PSAnJykge1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIHZhciByZ2IgPSBnZXRDb21wdXRlZFN0eWxlKGVsKS5jb2xvcjtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKTtcbiAgICByZXR1cm4gcmdiO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHMgU3RyaW5nLlxuICogQHJldHVybiB7Q29sb3J9IENvbG9yLlxuICovXG5leHBvcnQgdmFyIGZyb21TdHJpbmcgPSAoXG4gIGZ1bmN0aW9uKCkge1xuXG4gICAgLy8gV2UgbWFpbnRhaW4gYSBzbWFsbCBjYWNoZSBvZiBwYXJzZWQgc3RyaW5ncy4gIFRvIHByb3ZpZGUgY2hlYXAgTFJVLWxpa2VcbiAgICAvLyBzZW1hbnRpY3MsIHdoZW5ldmVyIHRoZSBjYWNoZSBncm93cyB0b28gbGFyZ2Ugd2Ugc2ltcGx5IGRlbGV0ZSBhblxuICAgIC8vIGFyYml0cmFyeSAyNSUgb2YgdGhlIGVudHJpZXMuXG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHZhciBNQVhfQ0FDSEVfU0laRSA9IDEwMjQ7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgQ29sb3I+fVxuICAgICAqL1xuICAgIHZhciBjYWNoZSA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB2YXIgY2FjaGVTaXplID0gMDtcblxuICAgIHJldHVybiAoXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzIFN0cmluZy5cbiAgICAgICAqIEByZXR1cm4ge0NvbG9yfSBDb2xvci5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24ocykge1xuICAgICAgICB2YXIgY29sb3I7XG4gICAgICAgIGlmIChjYWNoZS5oYXNPd25Qcm9wZXJ0eShzKSkge1xuICAgICAgICAgIGNvbG9yID0gY2FjaGVbc107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNhY2hlU2l6ZSA+PSBNQVhfQ0FDSEVfU0laRSkge1xuICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGNhY2hlKSB7XG4gICAgICAgICAgICAgIGlmICgoaSsrICYgMykgPT09IDApIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgY2FjaGVba2V5XTtcbiAgICAgICAgICAgICAgICAtLWNhY2hlU2l6ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb2xvciA9IGZyb21TdHJpbmdJbnRlcm5hbF8ocyk7XG4gICAgICAgICAgY2FjaGVbc10gPSBjb2xvcjtcbiAgICAgICAgICArK2NhY2hlU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sb3I7XG4gICAgICB9XG4gICAgKTtcblxuICB9KSgpO1xuXG4vKipcbiAqIFJldHVybiB0aGUgY29sb3IgYXMgYW4gYXJyYXkuIFRoaXMgZnVuY3Rpb24gbWFpbnRhaW5zIGEgY2FjaGUgb2YgY2FsY3VsYXRlZFxuICogYXJyYXlzIHdoaWNoIG1lYW5zIHRoZSByZXN1bHQgc2hvdWxkIG5vdCBiZSBtb2RpZmllZC5cbiAqIEBwYXJhbSB7Q29sb3J8c3RyaW5nfSBjb2xvciBDb2xvci5cbiAqIEByZXR1cm4ge0NvbG9yfSBDb2xvci5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzQXJyYXkoY29sb3IpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY29sb3IpKSB7XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKGNvbG9yKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzIFN0cmluZy5cbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJuIHtDb2xvcn0gQ29sb3IuXG4gKi9cbmZ1bmN0aW9uIGZyb21TdHJpbmdJbnRlcm5hbF8ocykge1xuICB2YXIgciwgZywgYiwgYSwgY29sb3I7XG5cbiAgaWYgKE5BTUVEX0NPTE9SX1JFXy5leGVjKHMpKSB7XG4gICAgcyA9IGZyb21OYW1lZChzKTtcbiAgfVxuXG4gIGlmIChIRVhfQ09MT1JfUkVfLmV4ZWMocykpIHsgLy8gaGV4XG4gICAgdmFyIG4gPSBzLmxlbmd0aCAtIDE7IC8vIG51bWJlciBvZiBoZXggZGlnaXRzXG4gICAgdmFyIGQ7IC8vIG51bWJlciBvZiBkaWdpdHMgcGVyIGNoYW5uZWxcbiAgICBpZiAobiA8PSA0KSB7XG4gICAgICBkID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgZCA9IDI7XG4gICAgfVxuICAgIHZhciBoYXNBbHBoYSA9IG4gPT09IDQgfHwgbiA9PT0gODtcbiAgICByID0gcGFyc2VJbnQocy5zdWJzdHIoMSArIDAgKiBkLCBkKSwgMTYpO1xuICAgIGcgPSBwYXJzZUludChzLnN1YnN0cigxICsgMSAqIGQsIGQpLCAxNik7XG4gICAgYiA9IHBhcnNlSW50KHMuc3Vic3RyKDEgKyAyICogZCwgZCksIDE2KTtcbiAgICBpZiAoaGFzQWxwaGEpIHtcbiAgICAgIGEgPSBwYXJzZUludChzLnN1YnN0cigxICsgMyAqIGQsIGQpLCAxNik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSAyNTU7XG4gICAgfVxuICAgIGlmIChkID09IDEpIHtcbiAgICAgIHIgPSAociA8PCA0KSArIHI7XG4gICAgICBnID0gKGcgPDwgNCkgKyBnO1xuICAgICAgYiA9IChiIDw8IDQpICsgYjtcbiAgICAgIGlmIChoYXNBbHBoYSkge1xuICAgICAgICBhID0gKGEgPDwgNCkgKyBhO1xuICAgICAgfVxuICAgIH1cbiAgICBjb2xvciA9IFtyLCBnLCBiLCBhIC8gMjU1XTtcbiAgfSBlbHNlIGlmIChzLmluZGV4T2YoJ3JnYmEoJykgPT0gMCkgeyAvLyByZ2JhKClcbiAgICBjb2xvciA9IHMuc2xpY2UoNSwgLTEpLnNwbGl0KCcsJykubWFwKE51bWJlcik7XG4gICAgbm9ybWFsaXplKGNvbG9yKTtcbiAgfSBlbHNlIGlmIChzLmluZGV4T2YoJ3JnYignKSA9PSAwKSB7IC8vIHJnYigpXG4gICAgY29sb3IgPSBzLnNsaWNlKDQsIC0xKS5zcGxpdCgnLCcpLm1hcChOdW1iZXIpO1xuICAgIGNvbG9yLnB1c2goMSk7XG4gICAgbm9ybWFsaXplKGNvbG9yKTtcbiAgfSBlbHNlIHtcbiAgICBhc3NlcnQoZmFsc2UsIDE0KTsgLy8gSW52YWxpZCBjb2xvclxuICB9XG4gIHJldHVybiBjb2xvcjtcbn1cblxuXG4vKipcbiAqIFRPRE8gdGhpcyBmdW5jdGlvbiBpcyBvbmx5IHVzZWQgaW4gdGhlIHRlc3QsIHdlIHByb2JhYmx5IHNob3VsZG4ndCBleHBvcnQgaXRcbiAqIEBwYXJhbSB7Q29sb3J9IGNvbG9yIENvbG9yLlxuICogQHJldHVybiB7Q29sb3J9IENsYW1wZWQgY29sb3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUoY29sb3IpIHtcbiAgY29sb3JbMF0gPSBjbGFtcCgoY29sb3JbMF0gKyAwLjUpIHwgMCwgMCwgMjU1KTtcbiAgY29sb3JbMV0gPSBjbGFtcCgoY29sb3JbMV0gKyAwLjUpIHwgMCwgMCwgMjU1KTtcbiAgY29sb3JbMl0gPSBjbGFtcCgoY29sb3JbMl0gKyAwLjUpIHwgMCwgMCwgMjU1KTtcbiAgY29sb3JbM10gPSBjbGFtcChjb2xvclszXSwgMCwgMSk7XG4gIHJldHVybiBjb2xvcjtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7Q29sb3J9IGNvbG9yIENvbG9yLlxuICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1N0cmluZyhjb2xvcikge1xuICB2YXIgciA9IGNvbG9yWzBdO1xuICBpZiAociAhPSAociB8IDApKSB7XG4gICAgciA9IChyICsgMC41KSB8IDA7XG4gIH1cbiAgdmFyIGcgPSBjb2xvclsxXTtcbiAgaWYgKGcgIT0gKGcgfCAwKSkge1xuICAgIGcgPSAoZyArIDAuNSkgfCAwO1xuICB9XG4gIHZhciBiID0gY29sb3JbMl07XG4gIGlmIChiICE9IChiIHwgMCkpIHtcbiAgICBiID0gKGIgKyAwLjUpIHwgMDtcbiAgfVxuICB2YXIgYSA9IGNvbG9yWzNdID09PSB1bmRlZmluZWQgPyAxIDogY29sb3JbM107XG4gIHJldHVybiAncmdiYSgnICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICcpJztcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29sb3IuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2NvbG9ybGlrZVxuICovXG5pbXBvcnQge3RvU3RyaW5nfSBmcm9tICcuL2NvbG9yLmpzJztcblxuXG4vKipcbiAqIEEgdHlwZSBhY2NlcHRlZCBieSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQuZmlsbFN0eWxlXG4gKiBvciBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQuc3Ryb2tlU3R5bGUuXG4gKiBSZXByZXNlbnRzIGEgY29sb3IsIHBhdHRlcm4sIG9yIGdyYWRpZW50LiBUaGUgb3JpZ2luIGZvciBwYXR0ZXJucyBhbmRcbiAqIGdyYWRpZW50cyBhcyBmaWxsIHN0eWxlIGlzIGFuIGluY3JlbWVudCBvZiA1MTIgY3NzIHBpeGVscyBmcm9tIG1hcCBjb29yZGluYXRlXG4gKiBgWzAsIDBdYC4gRm9yIHNlYW1sZXNzIHJlcGVhdCBwYXR0ZXJucywgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgcGF0dGVybiBpbWFnZVxuICogbXVzdCBiZSBhIGZhY3RvciBvZiB0d28gKDIsIDQsIDgsIC4uLiwgNTEyKS5cbiAqXG4gKiBAdHlwZWRlZiB7c3RyaW5nfENhbnZhc1BhdHRlcm58Q2FudmFzR3JhZGllbnR9IENvbG9yTGlrZVxuICogQGFwaVxuICovXG5cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29sb3IuanNcIikuQ29sb3J8Q29sb3JMaWtlfSBjb2xvciBDb2xvci5cbiAqIEByZXR1cm4ge0NvbG9yTGlrZX0gVGhlIGNvbG9yIGFzIGFuIHtAbGluayBvbC9jb2xvcmxpa2V+Q29sb3JMaWtlfS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzQ29sb3JMaWtlKGNvbG9yKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNvbG9yKSkge1xuICAgIHJldHVybiB0b1N0cmluZyhjb2xvcik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbG9ybGlrZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvY29udHJvbC9BdHRyaWJ1dGlvblxuICovXG5pbXBvcnQge2VxdWFsc30gZnJvbSAnLi4vYXJyYXkuanMnO1xuaW1wb3J0IENvbnRyb2wgZnJvbSAnLi9Db250cm9sLmpzJztcbmltcG9ydCB7Q0xBU1NfQ09OVFJPTCwgQ0xBU1NfVU5TRUxFQ1RBQkxFLCBDTEFTU19DT0xMQVBTRUR9IGZyb20gJy4uL2Nzcy5qcyc7XG5pbXBvcnQge3JlbW92ZUNoaWxkcmVuLCByZXBsYWNlTm9kZX0gZnJvbSAnLi4vZG9tLmpzJztcbmltcG9ydCB7bGlzdGVufSBmcm9tICcuLi9ldmVudHMuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7dmlzaWJsZUF0UmVzb2x1dGlvbn0gZnJvbSAnLi4vbGF5ZXIvTGF5ZXIuanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc05hbWU9J29sLWF0dHJpYnV0aW9uJ10gQ1NTIGNsYXNzIG5hbWUuXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fHN0cmluZ30gW3RhcmdldF0gU3BlY2lmeSBhIHRhcmdldCBpZiB5b3VcbiAqIHdhbnQgdGhlIGNvbnRyb2wgdG8gYmUgcmVuZGVyZWQgb3V0c2lkZSBvZiB0aGUgbWFwJ3NcbiAqIHZpZXdwb3J0LlxuICogQHByb3BlcnR5IHtib29sZWFufSBbY29sbGFwc2libGVdIFNwZWNpZnkgaWYgYXR0cmlidXRpb25zIGNhblxuICogYmUgY29sbGFwc2VkLiBJZiBub3Qgc3BlY2lmaWVkLCBzb3VyY2VzIGNvbnRyb2wgdGhpcyBiZWhhdmlvciB3aXRoIHRoZWlyXG4gKiBgYXR0cmlidXRpb25zQ29sbGFwc2libGVgIHNldHRpbmcuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjb2xsYXBzZWQ9dHJ1ZV0gU3BlY2lmeSBpZiBhdHRyaWJ1dGlvbnMgc2hvdWxkXG4gKiBiZSBjb2xsYXBzZWQgYXQgc3RhcnR1cC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdGlwTGFiZWw9J0F0dHJpYnV0aW9ucyddIFRleHQgbGFiZWwgdG8gdXNlIGZvciB0aGUgYnV0dG9uIHRpcC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbGFiZWw9J2knXSBUZXh0IGxhYmVsIHRvIHVzZSBmb3IgdGhlXG4gKiBjb2xsYXBzZWQgYXR0cmlidXRpb25zIGJ1dHRvbi5cbiAqIEluc3RlYWQgb2YgdGV4dCwgYWxzbyBhbiBlbGVtZW50IChlLmcuIGEgYHNwYW5gIGVsZW1lbnQpIGNhbiBiZSB1c2VkLlxuICogQHByb3BlcnR5IHtzdHJpbmd8SFRNTEVsZW1lbnR9IFtjb2xsYXBzZUxhYmVsPSfCuyddIFRleHQgbGFiZWwgdG8gdXNlXG4gKiBmb3IgdGhlIGV4cGFuZGVkIGF0dHJpYnV0aW9ucyBidXR0b24uXG4gKiBJbnN0ZWFkIG9mIHRleHQsIGFsc28gYW4gZWxlbWVudCAoZS5nLiBhIGBzcGFuYCBlbGVtZW50KSBjYW4gYmUgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vTWFwRXZlbnQuanNcIikuZGVmYXVsdCl9IFtyZW5kZXJdIEZ1bmN0aW9uIGNhbGxlZCB3aGVuXG4gKiB0aGUgY29udHJvbCBzaG91bGQgYmUgcmUtcmVuZGVyZWQuIFRoaXMgaXMgY2FsbGVkIGluIGEgYHJlcXVlc3RBbmltYXRpb25GcmFtZWBcbiAqIGNhbGxiYWNrLlxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBDb250cm9sIHRvIHNob3cgYWxsIHRoZSBhdHRyaWJ1dGlvbnMgYXNzb2NpYXRlZCB3aXRoIHRoZSBsYXllciBzb3VyY2VzXG4gKiBpbiB0aGUgbWFwLiBUaGlzIGNvbnRyb2wgaXMgb25lIG9mIHRoZSBkZWZhdWx0IGNvbnRyb2xzIGluY2x1ZGVkIGluIG1hcHMuXG4gKiBCeSBkZWZhdWx0IGl0IHdpbGwgc2hvdyBpbiB0aGUgYm90dG9tIHJpZ2h0IHBvcnRpb24gb2YgdGhlIG1hcCwgYnV0IHRoaXMgY2FuXG4gKiBiZSBjaGFuZ2VkIGJ5IHVzaW5nIGEgY3NzIHNlbGVjdG9yIGZvciBgLm9sLWF0dHJpYnV0aW9uYC5cbiAqXG4gKiBAYXBpXG4gKi9cbnZhciBBdHRyaWJ1dGlvbiA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKENvbnRyb2wpIHtcbiAgZnVuY3Rpb24gQXR0cmlidXRpb24ob3B0X29wdGlvbnMpIHtcblxuICAgIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgPyBvcHRfb3B0aW9ucyA6IHt9O1xuXG4gICAgQ29udHJvbC5jYWxsKHRoaXMsIHtcbiAgICAgIGVsZW1lbnQ6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgcmVuZGVyOiBvcHRpb25zLnJlbmRlciB8fCByZW5kZXIsXG4gICAgICB0YXJnZXQ6IG9wdGlvbnMudGFyZ2V0XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLnVsRWxlbWVudF8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbGxhcHNlZF8gPSBvcHRpb25zLmNvbGxhcHNlZCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jb2xsYXBzZWQgOiB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLm92ZXJyaWRlQ29sbGFwc2libGVfID0gb3B0aW9ucy5jb2xsYXBzaWJsZSAhPT0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbGxhcHNpYmxlXyA9IG9wdGlvbnMuY29sbGFwc2libGUgIT09IHVuZGVmaW5lZCA/XG4gICAgICBvcHRpb25zLmNvbGxhcHNpYmxlIDogdHJ1ZTtcblxuICAgIGlmICghdGhpcy5jb2xsYXBzaWJsZV8pIHtcbiAgICAgIHRoaXMuY29sbGFwc2VkXyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBjbGFzc05hbWUgPSBvcHRpb25zLmNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jbGFzc05hbWUgOiAnb2wtYXR0cmlidXRpb24nO1xuXG4gICAgdmFyIHRpcExhYmVsID0gb3B0aW9ucy50aXBMYWJlbCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy50aXBMYWJlbCA6ICdBdHRyaWJ1dGlvbnMnO1xuXG4gICAgdmFyIGNvbGxhcHNlTGFiZWwgPSBvcHRpb25zLmNvbGxhcHNlTGFiZWwgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY29sbGFwc2VMYWJlbCA6ICdcXHUwMEJCJztcblxuICAgIGlmICh0eXBlb2YgY29sbGFwc2VMYWJlbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgICAqL1xuICAgICAgdGhpcy5jb2xsYXBzZUxhYmVsXyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgIHRoaXMuY29sbGFwc2VMYWJlbF8udGV4dENvbnRlbnQgPSBjb2xsYXBzZUxhYmVsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbGxhcHNlTGFiZWxfID0gY29sbGFwc2VMYWJlbDtcbiAgICB9XG5cbiAgICB2YXIgbGFiZWwgPSBvcHRpb25zLmxhYmVsICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmxhYmVsIDogJ2knO1xuXG4gICAgaWYgKHR5cGVvZiBsYWJlbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgICAqL1xuICAgICAgdGhpcy5sYWJlbF8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICB0aGlzLmxhYmVsXy50ZXh0Q29udGVudCA9IGxhYmVsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxhYmVsXyA9IGxhYmVsO1xuICAgIH1cblxuXG4gICAgdmFyIGFjdGl2ZUxhYmVsID0gKHRoaXMuY29sbGFwc2libGVfICYmICF0aGlzLmNvbGxhcHNlZF8pID9cbiAgICAgIHRoaXMuY29sbGFwc2VMYWJlbF8gOiB0aGlzLmxhYmVsXztcbiAgICB2YXIgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgYnV0dG9uLnNldEF0dHJpYnV0ZSgndHlwZScsICdidXR0b24nKTtcbiAgICBidXR0b24udGl0bGUgPSB0aXBMYWJlbDtcbiAgICBidXR0b24uYXBwZW5kQ2hpbGQoYWN0aXZlTGFiZWwpO1xuXG4gICAgbGlzdGVuKGJ1dHRvbiwgRXZlbnRUeXBlLkNMSUNLLCB0aGlzLmhhbmRsZUNsaWNrXywgdGhpcyk7XG5cbiAgICB2YXIgY3NzQ2xhc3NlcyA9IGNsYXNzTmFtZSArICcgJyArIENMQVNTX1VOU0VMRUNUQUJMRSArICcgJyArIENMQVNTX0NPTlRST0wgK1xuICAgICAgICAodGhpcy5jb2xsYXBzZWRfICYmIHRoaXMuY29sbGFwc2libGVfID8gJyAnICsgQ0xBU1NfQ09MTEFQU0VEIDogJycpICtcbiAgICAgICAgKHRoaXMuY29sbGFwc2libGVfID8gJycgOiAnIG9sLXVuY29sbGFwc2libGUnKTtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGNzc0NsYXNzZXM7XG4gICAgZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnVsRWxlbWVudF8pO1xuICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcblxuICAgIC8qKlxuICAgICAqIEEgbGlzdCBvZiBjdXJyZW50bHkgcmVuZGVyZWQgcmVzb2x1dGlvbnMuXG4gICAgICogQHR5cGUge0FycmF5PHN0cmluZz59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVkQXR0cmlidXRpb25zXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVkVmlzaWJsZV8gPSB0cnVlO1xuXG4gIH1cblxuICBpZiAoIENvbnRyb2wgKSBBdHRyaWJ1dGlvbi5fX3Byb3RvX18gPSBDb250cm9sO1xuICBBdHRyaWJ1dGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDb250cm9sICYmIENvbnRyb2wucHJvdG90eXBlICk7XG4gIEF0dHJpYnV0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEF0dHJpYnV0aW9uO1xuXG4gIC8qKlxuICAgKiBDb2xsZWN0IGEgbGlzdCBvZiB2aXNpYmxlIGF0dHJpYnV0aW9ucyBhbmQgc2V0IHRoZSBjb2xsYXBzaWJsZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHJldHVybiB7QXJyYXk8c3RyaW5nPn0gQXR0cmlidXRpb25zLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQXR0cmlidXRpb24ucHJvdG90eXBlLmNvbGxlY3RTb3VyY2VBdHRyaWJ1dGlvbnNfID0gZnVuY3Rpb24gY29sbGVjdFNvdXJjZUF0dHJpYnV0aW9uc18gKGZyYW1lU3RhdGUpIHtcbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGRldGVybWluZSBpZiBhbiBhdHRyaWJ1dGlvbiBhbHJlYWR5IGV4aXN0cy5cbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIGJvb2xlYW4+fVxuICAgICAqL1xuICAgIHZhciBsb29rdXAgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEEgbGlzdCBvZiB2aXNpYmxlIGF0dHJpYnV0aW9ucy5cbiAgICAgKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn1cbiAgICAgKi9cbiAgICB2YXIgdmlzaWJsZUF0dHJpYnV0aW9ucyA9IFtdO1xuXG4gICAgdmFyIGxheWVyU3RhdGVzQXJyYXkgPSBmcmFtZVN0YXRlLmxheWVyU3RhdGVzQXJyYXk7XG4gICAgdmFyIHJlc29sdXRpb24gPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZS5yZXNvbHV0aW9uO1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGxheWVyU3RhdGVzQXJyYXkubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgdmFyIGxheWVyU3RhdGUgPSBsYXllclN0YXRlc0FycmF5W2ldO1xuICAgICAgaWYgKCF2aXNpYmxlQXRSZXNvbHV0aW9uKGxheWVyU3RhdGUsIHJlc29sdXRpb24pKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0fSAqLyAobGF5ZXJTdGF0ZS5sYXllcikuZ2V0U291cmNlKCk7XG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGF0dHJpYnV0aW9uR2V0dGVyID0gc291cmNlLmdldEF0dHJpYnV0aW9ucygpO1xuICAgICAgaWYgKCFhdHRyaWJ1dGlvbkdldHRlcikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGF0dHJpYnV0aW9ucyA9IGF0dHJpYnV0aW9uR2V0dGVyKGZyYW1lU3RhdGUpO1xuICAgICAgaWYgKCFhdHRyaWJ1dGlvbnMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5vdmVycmlkZUNvbGxhcHNpYmxlXyAmJiBzb3VyY2UuZ2V0QXR0cmlidXRpb25zQ29sbGFwc2libGUoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5zZXRDb2xsYXBzaWJsZShmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGF0dHJpYnV0aW9ucykpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpqID0gYXR0cmlidXRpb25zLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICAgICAgICBpZiAoIShhdHRyaWJ1dGlvbnNbal0gaW4gbG9va3VwKSkge1xuICAgICAgICAgICAgdmlzaWJsZUF0dHJpYnV0aW9ucy5wdXNoKGF0dHJpYnV0aW9uc1tqXSk7XG4gICAgICAgICAgICBsb29rdXBbYXR0cmlidXRpb25zW2pdXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIShhdHRyaWJ1dGlvbnMgaW4gbG9va3VwKSkge1xuICAgICAgICAgIHZpc2libGVBdHRyaWJ1dGlvbnMucHVzaChhdHRyaWJ1dGlvbnMpO1xuICAgICAgICAgIGxvb2t1cFthdHRyaWJ1dGlvbnNdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmlzaWJsZUF0dHJpYnV0aW9ucztcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHs/aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqL1xuICBBdHRyaWJ1dGlvbi5wcm90b3R5cGUudXBkYXRlRWxlbWVudF8gPSBmdW5jdGlvbiB1cGRhdGVFbGVtZW50XyAoZnJhbWVTdGF0ZSkge1xuICAgIGlmICghZnJhbWVTdGF0ZSkge1xuICAgICAgaWYgKHRoaXMucmVuZGVyZWRWaXNpYmxlXykge1xuICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgdGhpcy5yZW5kZXJlZFZpc2libGVfID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGF0dHJpYnV0aW9ucyA9IHRoaXMuY29sbGVjdFNvdXJjZUF0dHJpYnV0aW9uc18oZnJhbWVTdGF0ZSk7XG5cbiAgICB2YXIgdmlzaWJsZSA9IGF0dHJpYnV0aW9ucy5sZW5ndGggPiAwO1xuICAgIGlmICh0aGlzLnJlbmRlcmVkVmlzaWJsZV8gIT0gdmlzaWJsZSkge1xuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSB2aXNpYmxlID8gJycgOiAnbm9uZSc7XG4gICAgICB0aGlzLnJlbmRlcmVkVmlzaWJsZV8gPSB2aXNpYmxlO1xuICAgIH1cblxuICAgIGlmIChlcXVhbHMoYXR0cmlidXRpb25zLCB0aGlzLnJlbmRlcmVkQXR0cmlidXRpb25zXykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZW1vdmVDaGlsZHJlbih0aGlzLnVsRWxlbWVudF8pO1xuXG4gICAgLy8gYXBwZW5kIHRoZSBhdHRyaWJ1dGlvbnNcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBhdHRyaWJ1dGlvbnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSBhdHRyaWJ1dGlvbnNbaV07XG4gICAgICB0aGlzLnVsRWxlbWVudF8uYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJlZEF0dHJpYnV0aW9uc18gPSBhdHRyaWJ1dGlvbnM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgVGhlIGV2ZW50IHRvIGhhbmRsZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQXR0cmlidXRpb24ucHJvdG90eXBlLmhhbmRsZUNsaWNrXyA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrXyAoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuaGFuZGxlVG9nZ2xlXygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQXR0cmlidXRpb24ucHJvdG90eXBlLmhhbmRsZVRvZ2dsZV8gPSBmdW5jdGlvbiBoYW5kbGVUb2dnbGVfICgpIHtcbiAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShDTEFTU19DT0xMQVBTRUQpO1xuICAgIGlmICh0aGlzLmNvbGxhcHNlZF8pIHtcbiAgICAgIHJlcGxhY2VOb2RlKHRoaXMuY29sbGFwc2VMYWJlbF8sIHRoaXMubGFiZWxfKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVwbGFjZU5vZGUodGhpcy5sYWJlbF8sIHRoaXMuY29sbGFwc2VMYWJlbF8pO1xuICAgIH1cbiAgICB0aGlzLmNvbGxhcHNlZF8gPSAhdGhpcy5jb2xsYXBzZWRfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBhdHRyaWJ1dGlvbiBpcyBjb2xsYXBzaWJsZSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHdpZGdldCBpcyBjb2xsYXBzaWJsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgQXR0cmlidXRpb24ucHJvdG90eXBlLmdldENvbGxhcHNpYmxlID0gZnVuY3Rpb24gZ2V0Q29sbGFwc2libGUgKCkge1xuICAgIHJldHVybiB0aGlzLmNvbGxhcHNpYmxlXztcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHdoZXRoZXIgdGhlIGF0dHJpYnV0aW9uIHNob3VsZCBiZSBjb2xsYXBzaWJsZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBjb2xsYXBzaWJsZSBUcnVlIGlmIHRoZSB3aWRnZXQgaXMgY29sbGFwc2libGUuXG4gICAqIEBhcGlcbiAgICovXG4gIEF0dHJpYnV0aW9uLnByb3RvdHlwZS5zZXRDb2xsYXBzaWJsZSA9IGZ1bmN0aW9uIHNldENvbGxhcHNpYmxlIChjb2xsYXBzaWJsZSkge1xuICAgIGlmICh0aGlzLmNvbGxhcHNpYmxlXyA9PT0gY29sbGFwc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jb2xsYXBzaWJsZV8gPSBjb2xsYXBzaWJsZTtcbiAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZSgnb2wtdW5jb2xsYXBzaWJsZScpO1xuICAgIGlmICghY29sbGFwc2libGUgJiYgdGhpcy5jb2xsYXBzZWRfKSB7XG4gICAgICB0aGlzLmhhbmRsZVRvZ2dsZV8oKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbGxhcHNlIG9yIGV4cGFuZCB0aGUgYXR0cmlidXRpb24gYWNjb3JkaW5nIHRvIHRoZSBwYXNzZWQgcGFyYW1ldGVyLiBXaWxsXG4gICAqIG5vdCBkbyBhbnl0aGluZyBpZiB0aGUgYXR0cmlidXRpb24gaXNuJ3QgY29sbGFwc2libGUgb3IgaWYgdGhlIGN1cnJlbnRcbiAgICogY29sbGFwc2VkIHN0YXRlIGlzIGFscmVhZHkgdGhlIG9uZSByZXF1ZXN0ZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY29sbGFwc2VkIFRydWUgaWYgdGhlIHdpZGdldCBpcyBjb2xsYXBzZWQuXG4gICAqIEBhcGlcbiAgICovXG4gIEF0dHJpYnV0aW9uLnByb3RvdHlwZS5zZXRDb2xsYXBzZWQgPSBmdW5jdGlvbiBzZXRDb2xsYXBzZWQgKGNvbGxhcHNlZCkge1xuICAgIGlmICghdGhpcy5jb2xsYXBzaWJsZV8gfHwgdGhpcy5jb2xsYXBzZWRfID09PSBjb2xsYXBzZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5oYW5kbGVUb2dnbGVfKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiBgdHJ1ZWAgd2hlbiB0aGUgYXR0cmlidXRpb24gaXMgY3VycmVudGx5IGNvbGxhcHNlZCBvciBgZmFsc2VgXG4gICAqIG90aGVyd2lzZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgd2lkZ2V0IGlzIGNvbGxhcHNlZC5cbiAgICogQGFwaVxuICAgKi9cbiAgQXR0cmlidXRpb24ucHJvdG90eXBlLmdldENvbGxhcHNlZCA9IGZ1bmN0aW9uIGdldENvbGxhcHNlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sbGFwc2VkXztcbiAgfTtcblxuICByZXR1cm4gQXR0cmlidXRpb247XG59KENvbnRyb2wpKTtcblxuXG4vKipcbiAqIFVwZGF0ZSB0aGUgYXR0cmlidXRpb24gZWxlbWVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwRXZlbnQgTWFwIGV2ZW50LlxuICogQHRoaXMge0F0dHJpYnV0aW9ufVxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyKG1hcEV2ZW50KSB7XG4gIHRoaXMudXBkYXRlRWxlbWVudF8obWFwRXZlbnQuZnJhbWVTdGF0ZSk7XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgQXR0cmlidXRpb247XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUF0dHJpYnV0aW9uLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9jb250cm9sL0NvbnRyb2xcbiAqL1xuaW1wb3J0IHtWT0lEfSBmcm9tICcuLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IE1hcEV2ZW50VHlwZSBmcm9tICcuLi9NYXBFdmVudFR5cGUuanMnO1xuaW1wb3J0IEJhc2VPYmplY3QgZnJvbSAnLi4vT2JqZWN0LmpzJztcbmltcG9ydCB7cmVtb3ZlTm9kZX0gZnJvbSAnLi4vZG9tLmpzJztcbmltcG9ydCB7bGlzdGVuLCB1bmxpc3RlbkJ5S2V5fSBmcm9tICcuLi9ldmVudHMuanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gW2VsZW1lbnRdIFRoZSBlbGVtZW50IGlzIHRoZSBjb250cm9sJ3NcbiAqIGNvbnRhaW5lciBlbGVtZW50LiBUaGlzIG9ubHkgbmVlZHMgdG8gYmUgc3BlY2lmaWVkIGlmIHlvdSdyZSBkZXZlbG9waW5nXG4gKiBhIGN1c3RvbSBjb250cm9sLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbihpbXBvcnQoXCIuLi9NYXBFdmVudC5qc1wiKS5kZWZhdWx0KX0gW3JlbmRlcl0gRnVuY3Rpb24gY2FsbGVkIHdoZW5cbiAqIHRoZSBjb250cm9sIHNob3VsZCBiZSByZS1yZW5kZXJlZC4gVGhpcyBpcyBjYWxsZWQgaW4gYSBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYFxuICogY2FsbGJhY2suXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fHN0cmluZ30gW3RhcmdldF0gU3BlY2lmeSBhIHRhcmdldCBpZiB5b3Ugd2FudFxuICogdGhlIGNvbnRyb2wgdG8gYmUgcmVuZGVyZWQgb3V0c2lkZSBvZiB0aGUgbWFwJ3Mgdmlld3BvcnQuXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEEgY29udHJvbCBpcyBhIHZpc2libGUgd2lkZ2V0IHdpdGggYSBET00gZWxlbWVudCBpbiBhIGZpeGVkIHBvc2l0aW9uIG9uIHRoZVxuICogc2NyZWVuLiBUaGV5IGNhbiBpbnZvbHZlIHVzZXIgaW5wdXQgKGJ1dHRvbnMpLCBvciBiZSBpbmZvcm1hdGlvbmFsIG9ubHk7XG4gKiB0aGUgcG9zaXRpb24gaXMgZGV0ZXJtaW5lZCB1c2luZyBDU1MuIEJ5IGRlZmF1bHQgdGhlc2UgYXJlIHBsYWNlZCBpbiB0aGVcbiAqIGNvbnRhaW5lciB3aXRoIENTUyBjbGFzcyBuYW1lIGBvbC1vdmVybGF5Y29udGFpbmVyLXN0b3BldmVudGAsIGJ1dCBjYW4gdXNlXG4gKiBhbnkgb3V0c2lkZSBET00gZWxlbWVudC5cbiAqXG4gKiBUaGlzIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBjb250cm9scy4gWW91IGNhbiB1c2UgaXQgZm9yIHNpbXBsZSBjdXN0b21cbiAqIGNvbnRyb2xzIGJ5IGNyZWF0aW5nIHRoZSBlbGVtZW50IHdpdGggbGlzdGVuZXJzLCBjcmVhdGluZyBhbiBpbnN0YW5jZTpcbiAqIGBgYGpzXG4gKiB2YXIgbXlDb250cm9sID0gbmV3IENvbnRyb2woe2VsZW1lbnQ6IG15RWxlbWVudH0pO1xuICogYGBgXG4gKiBhbmQgdGhlbiBhZGRpbmcgdGhpcyB0byB0aGUgbWFwLlxuICpcbiAqIFRoZSBtYWluIGFkdmFudGFnZSBvZiBoYXZpbmcgdGhpcyBhcyBhIGNvbnRyb2wgcmF0aGVyIHRoYW4gYSBzaW1wbGUgc2VwYXJhdGVcbiAqIERPTSBlbGVtZW50IGlzIHRoYXQgcHJldmVudGluZyBwcm9wYWdhdGlvbiBpcyBoYW5kbGVkIGZvciB5b3UuIENvbnRyb2xzXG4gKiB3aWxsIGFsc28gYmUgb2JqZWN0cyBpbiBhIHtAbGluayBtb2R1bGU6b2wvQ29sbGVjdGlvbn5Db2xsZWN0aW9ufSwgc28geW91IGNhbiB1c2UgdGhlaXIgbWV0aG9kcy5cbiAqXG4gKiBZb3UgY2FuIGFsc28gZXh0ZW5kIHRoaXMgYmFzZSBmb3IgeW91ciBvd24gY29udHJvbCBjbGFzcy4gU2VlXG4gKiBleGFtcGxlcy9jdXN0b20tY29udHJvbHMgZm9yIGFuIGV4YW1wbGUgb2YgaG93IHRvIGRvIHRoaXMuXG4gKlxuICogQGFwaVxuICovXG52YXIgQ29udHJvbCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEJhc2VPYmplY3QpIHtcbiAgZnVuY3Rpb24gQ29udHJvbChvcHRpb25zKSB7XG5cbiAgICBCYXNlT2JqZWN0LmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuZWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudCA/IG9wdGlvbnMuZWxlbWVudCA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5tYXBfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7IUFycmF5PGltcG9ydChcIi4uL2V2ZW50cy5qc1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMubGlzdGVuZXJLZXlzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vTWFwRXZlbnQuanNcIikuZGVmYXVsdCl9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlciA/IG9wdGlvbnMucmVuZGVyIDogVk9JRDtcblxuICAgIGlmIChvcHRpb25zLnRhcmdldCkge1xuICAgICAgdGhpcy5zZXRUYXJnZXQob3B0aW9ucy50YXJnZXQpO1xuICAgIH1cblxuICB9XG5cbiAgaWYgKCBCYXNlT2JqZWN0ICkgQ29udHJvbC5fX3Byb3RvX18gPSBCYXNlT2JqZWN0O1xuICBDb250cm9sLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJhc2VPYmplY3QgJiYgQmFzZU9iamVjdC5wcm90b3R5cGUgKTtcbiAgQ29udHJvbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb250cm9sO1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQ29udHJvbC5wcm90b3R5cGUuZGlzcG9zZUludGVybmFsID0gZnVuY3Rpb24gZGlzcG9zZUludGVybmFsICgpIHtcbiAgICByZW1vdmVOb2RlKHRoaXMuZWxlbWVudCk7XG4gICAgQmFzZU9iamVjdC5wcm90b3R5cGUuZGlzcG9zZUludGVybmFsLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWFwIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNvbnRyb2wuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL1BsdWdnYWJsZU1hcC5qc1wiKS5kZWZhdWx0fSBNYXAuXG4gICAqIEBhcGlcbiAgICovXG4gIENvbnRyb2wucHJvdG90eXBlLmdldE1hcCA9IGZ1bmN0aW9uIGdldE1hcCAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwXztcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBjb250cm9sIGZyb20gaXRzIGN1cnJlbnQgbWFwIGFuZCBhdHRhY2ggaXQgdG8gdGhlIG5ldyBtYXAuXG4gICAqIFN1YmNsYXNzZXMgbWF5IHNldCB1cCBldmVudCBoYW5kbGVycyB0byBnZXQgbm90aWZpZWQgYWJvdXQgY2hhbmdlcyB0b1xuICAgKiB0aGUgbWFwIGhlcmUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLmRlZmF1bHR9IG1hcCBNYXAuXG4gICAqIEBhcGlcbiAgICovXG4gIENvbnRyb2wucHJvdG90eXBlLnNldE1hcCA9IGZ1bmN0aW9uIHNldE1hcCAobWFwKSB7XG4gICAgaWYgKHRoaXMubWFwXykge1xuICAgICAgcmVtb3ZlTm9kZSh0aGlzLmVsZW1lbnQpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLmxpc3RlbmVyS2V5cy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB1bmxpc3RlbkJ5S2V5KHRoaXMubGlzdGVuZXJLZXlzW2ldKTtcbiAgICB9XG4gICAgdGhpcy5saXN0ZW5lcktleXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLm1hcF8gPSBtYXA7XG4gICAgaWYgKHRoaXMubWFwXykge1xuICAgICAgdmFyIHRhcmdldCA9IHRoaXMudGFyZ2V0XyA/XG4gICAgICAgIHRoaXMudGFyZ2V0XyA6IG1hcC5nZXRPdmVybGF5Q29udGFpbmVyU3RvcEV2ZW50KCk7XG4gICAgICB0YXJnZXQuYXBwZW5kQ2hpbGQodGhpcy5lbGVtZW50KTtcbiAgICAgIGlmICh0aGlzLnJlbmRlciAhPT0gVk9JRCkge1xuICAgICAgICB0aGlzLmxpc3RlbmVyS2V5cy5wdXNoKGxpc3RlbihtYXAsXG4gICAgICAgICAgTWFwRXZlbnRUeXBlLlBPU1RSRU5ERVIsIHRoaXMucmVuZGVyLCB0aGlzKSk7XG4gICAgICB9XG4gICAgICBtYXAucmVuZGVyKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gc2V0IGEgdGFyZ2V0IGVsZW1lbnQgZm9yIHRoZSBjb250cm9sLiBJdCBoYXMgbm9cbiAgICogZWZmZWN0IGlmIGl0IGlzIGNhbGxlZCBhZnRlciB0aGUgY29udHJvbCBoYXMgYmVlbiBhZGRlZCB0byB0aGUgbWFwIChpLmUuXG4gICAqIGFmdGVyIGBzZXRNYXBgIGlzIGNhbGxlZCBvbiB0aGUgY29udHJvbCkuIElmIG5vIGB0YXJnZXRgIGlzIHNldCBpbiB0aGVcbiAgICogb3B0aW9ucyBwYXNzZWQgdG8gdGhlIGNvbnRyb2wgY29uc3RydWN0b3IgYW5kIGlmIGBzZXRUYXJnZXRgIGlzIG5vdCBjYWxsZWRcbiAgICogdGhlbiB0aGUgY29udHJvbCBpcyBhZGRlZCB0byB0aGUgbWFwJ3Mgb3ZlcmxheSBjb250YWluZXIuXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8c3RyaW5nfSB0YXJnZXQgVGFyZ2V0LlxuICAgKiBAYXBpXG4gICAqL1xuICBDb250cm9sLnByb3RvdHlwZS5zZXRUYXJnZXQgPSBmdW5jdGlvbiBzZXRUYXJnZXQgKHRhcmdldCkge1xuICAgIHRoaXMudGFyZ2V0XyA9IHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnID9cbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRhcmdldCkgOlxuICAgICAgdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBDb250cm9sO1xufShCYXNlT2JqZWN0KSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgQ29udHJvbDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29udHJvbC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvY29udHJvbC9Sb3RhdGVcbiAqL1xuaW1wb3J0IENvbnRyb2wgZnJvbSAnLi9Db250cm9sLmpzJztcbmltcG9ydCB7Q0xBU1NfQ09OVFJPTCwgQ0xBU1NfSElEREVOLCBDTEFTU19VTlNFTEVDVEFCTEV9IGZyb20gJy4uL2Nzcy5qcyc7XG5pbXBvcnQge2Vhc2VPdXR9IGZyb20gJy4uL2Vhc2luZy5qcyc7XG5pbXBvcnQge2xpc3Rlbn0gZnJvbSAnLi4vZXZlbnRzLmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzTmFtZT0nb2wtcm90YXRlJ10gQ1NTIGNsYXNzIG5hbWUuXG4gKiBAcHJvcGVydHkge3N0cmluZ3xIVE1MRWxlbWVudH0gW2xhYmVsPSfih6cnXSBUZXh0IGxhYmVsIHRvIHVzZSBmb3IgdGhlIHJvdGF0ZSBidXR0b24uXG4gKiBJbnN0ZWFkIG9mIHRleHQsIGFsc28gYW4gZWxlbWVudCAoZS5nLiBhIGBzcGFuYCBlbGVtZW50KSBjYW4gYmUgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdGlwTGFiZWw9J1Jlc2V0IHJvdGF0aW9uJ10gVGV4dCBsYWJlbCB0byB1c2UgZm9yIHRoZSByb3RhdGUgdGlwLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkdXJhdGlvbj0yNTBdIEFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthdXRvSGlkZT10cnVlXSBIaWRlIHRoZSBjb250cm9sIHdoZW4gcm90YXRpb24gaXMgMC5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vTWFwRXZlbnQuanNcIikuZGVmYXVsdCl9IFtyZW5kZXJdIEZ1bmN0aW9uIGNhbGxlZCB3aGVuIHRoZSBjb250cm9sIHNob3VsZFxuICogYmUgcmUtcmVuZGVyZWQuIFRoaXMgaXMgY2FsbGVkIGluIGEgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgY2FsbGJhY2suXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKCl9IFtyZXNldE5vcnRoXSBGdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgY29udHJvbCBpcyBjbGlja2VkLlxuICogVGhpcyB3aWxsIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGByZXNldE5vcnRoYC5cbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR8c3RyaW5nfSBbdGFyZ2V0XSBTcGVjaWZ5IGEgdGFyZ2V0IGlmIHlvdSB3YW50IHRoZSBjb250cm9sIHRvIGJlXG4gKiByZW5kZXJlZCBvdXRzaWRlIG9mIHRoZSBtYXAncyB2aWV3cG9ydC5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQSBidXR0b24gY29udHJvbCB0byByZXNldCByb3RhdGlvbiB0byAwLlxuICogVG8gc3R5bGUgdGhpcyBjb250cm9sIHVzZSBjc3Mgc2VsZWN0b3IgYC5vbC1yb3RhdGVgLiBBIGAub2wtaGlkZGVuYCBjc3NcbiAqIHNlbGVjdG9yIGlzIGFkZGVkIHRvIHRoZSBidXR0b24gd2hlbiB0aGUgcm90YXRpb24gaXMgMC5cbiAqXG4gKiBAYXBpXG4gKi9cbnZhciBSb3RhdGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChDb250cm9sKSB7XG4gIGZ1bmN0aW9uIFJvdGF0ZShvcHRfb3B0aW9ucykge1xuXG4gICAgdmFyIG9wdGlvbnMgPSBvcHRfb3B0aW9ucyA/IG9wdF9vcHRpb25zIDoge307XG5cbiAgICBDb250cm9sLmNhbGwodGhpcywge1xuICAgICAgZWxlbWVudDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICByZW5kZXI6IG9wdGlvbnMucmVuZGVyIHx8IHJlbmRlcixcbiAgICAgIHRhcmdldDogb3B0aW9ucy50YXJnZXRcbiAgICB9KTtcblxuICAgIHZhciBjbGFzc05hbWUgPSBvcHRpb25zLmNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jbGFzc05hbWUgOiAnb2wtcm90YXRlJztcblxuICAgIHZhciBsYWJlbCA9IG9wdGlvbnMubGFiZWwgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubGFiZWwgOiAnXFx1MjFFNyc7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmxhYmVsXyA9IG51bGw7XG5cbiAgICBpZiAodHlwZW9mIGxhYmVsID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5sYWJlbF8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICB0aGlzLmxhYmVsXy5jbGFzc05hbWUgPSAnb2wtY29tcGFzcyc7XG4gICAgICB0aGlzLmxhYmVsXy50ZXh0Q29udGVudCA9IGxhYmVsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxhYmVsXyA9IGxhYmVsO1xuICAgICAgdGhpcy5sYWJlbF8uY2xhc3NMaXN0LmFkZCgnb2wtY29tcGFzcycpO1xuICAgIH1cblxuICAgIHZhciB0aXBMYWJlbCA9IG9wdGlvbnMudGlwTGFiZWwgPyBvcHRpb25zLnRpcExhYmVsIDogJ1Jlc2V0IHJvdGF0aW9uJztcblxuICAgIHZhciBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICBidXR0b24uY2xhc3NOYW1lID0gY2xhc3NOYW1lICsgJy1yZXNldCc7XG4gICAgYnV0dG9uLnNldEF0dHJpYnV0ZSgndHlwZScsICdidXR0b24nKTtcbiAgICBidXR0b24udGl0bGUgPSB0aXBMYWJlbDtcbiAgICBidXR0b24uYXBwZW5kQ2hpbGQodGhpcy5sYWJlbF8pO1xuXG4gICAgbGlzdGVuKGJ1dHRvbiwgRXZlbnRUeXBlLkNMSUNLLCB0aGlzLmhhbmRsZUNsaWNrXywgdGhpcyk7XG5cbiAgICB2YXIgY3NzQ2xhc3NlcyA9IGNsYXNzTmFtZSArICcgJyArIENMQVNTX1VOU0VMRUNUQUJMRSArICcgJyArIENMQVNTX0NPTlRST0w7XG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSBjc3NDbGFzc2VzO1xuICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcblxuICAgIHRoaXMuY2FsbFJlc2V0Tm9ydGhfID0gb3B0aW9ucy5yZXNldE5vcnRoID8gb3B0aW9ucy5yZXNldE5vcnRoIDogdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZHVyYXRpb25fID0gb3B0aW9ucy5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kdXJhdGlvbiA6IDI1MDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5hdXRvSGlkZV8gPSBvcHRpb25zLmF1dG9IaWRlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmF1dG9IaWRlIDogdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5yb3RhdGlvbl8gPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAodGhpcy5hdXRvSGlkZV8pIHtcbiAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX0hJRERFTik7XG4gICAgfVxuXG4gIH1cblxuICBpZiAoIENvbnRyb2wgKSBSb3RhdGUuX19wcm90b19fID0gQ29udHJvbDtcbiAgUm90YXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIENvbnRyb2wgJiYgQ29udHJvbC5wcm90b3R5cGUgKTtcbiAgUm90YXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJvdGF0ZTtcblxuICAvKipcbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gaGFuZGxlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBSb3RhdGUucHJvdG90eXBlLmhhbmRsZUNsaWNrXyA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrXyAoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmICh0aGlzLmNhbGxSZXNldE5vcnRoXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmNhbGxSZXNldE5vcnRoXygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlc2V0Tm9ydGhfKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgUm90YXRlLnByb3RvdHlwZS5yZXNldE5vcnRoXyA9IGZ1bmN0aW9uIHJlc2V0Tm9ydGhfICgpIHtcbiAgICB2YXIgbWFwID0gdGhpcy5nZXRNYXAoKTtcbiAgICB2YXIgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgaWYgKCF2aWV3KSB7XG4gICAgICAvLyB0aGUgbWFwIGRvZXMgbm90IGhhdmUgYSB2aWV3LCBzbyB3ZSBjYW4ndCBhY3RcbiAgICAgIC8vIHVwb24gaXRcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHZpZXcuZ2V0Um90YXRpb24oKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodGhpcy5kdXJhdGlvbl8gPiAwKSB7XG4gICAgICAgIHZpZXcuYW5pbWF0ZSh7XG4gICAgICAgICAgcm90YXRpb246IDAsXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb25fLFxuICAgICAgICAgIGVhc2luZzogZWFzZU91dFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZpZXcuc2V0Um90YXRpb24oMCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBSb3RhdGU7XG59KENvbnRyb2wpKTtcblxuXG4vKipcbiAqIFVwZGF0ZSB0aGUgcm90YXRlIGNvbnRyb2wgZWxlbWVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwRXZlbnQgTWFwIGV2ZW50LlxuICogQHRoaXMge1JvdGF0ZX1cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihtYXBFdmVudCkge1xuICB2YXIgZnJhbWVTdGF0ZSA9IG1hcEV2ZW50LmZyYW1lU3RhdGU7XG4gIGlmICghZnJhbWVTdGF0ZSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcm90YXRpb24gPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZS5yb3RhdGlvbjtcbiAgaWYgKHJvdGF0aW9uICE9IHRoaXMucm90YXRpb25fKSB7XG4gICAgdmFyIHRyYW5zZm9ybSA9ICdyb3RhdGUoJyArIHJvdGF0aW9uICsgJ3JhZCknO1xuICAgIGlmICh0aGlzLmF1dG9IaWRlXykge1xuICAgICAgdmFyIGNvbnRhaW5zID0gdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19ISURERU4pO1xuICAgICAgaWYgKCFjb250YWlucyAmJiByb3RhdGlvbiA9PT0gMCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19ISURERU4pO1xuICAgICAgfSBlbHNlIGlmIChjb250YWlucyAmJiByb3RhdGlvbiAhPT0gMCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19ISURERU4pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxhYmVsXy5zdHlsZS5tc1RyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICB0aGlzLmxhYmVsXy5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgdGhpcy5sYWJlbF8uc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICB9XG4gIHRoaXMucm90YXRpb25fID0gcm90YXRpb247XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJvdGF0ZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Um90YXRlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9jb250cm9sL1pvb21cbiAqL1xuaW1wb3J0IHtsaXN0ZW59IGZyb20gJy4uL2V2ZW50cy5qcyc7XG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4uL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IENvbnRyb2wgZnJvbSAnLi9Db250cm9sLmpzJztcbmltcG9ydCB7Q0xBU1NfQ09OVFJPTCwgQ0xBU1NfVU5TRUxFQ1RBQkxFfSBmcm9tICcuLi9jc3MuanMnO1xuaW1wb3J0IHtlYXNlT3V0fSBmcm9tICcuLi9lYXNpbmcuanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkdXJhdGlvbj0yNTBdIEFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzTmFtZT0nb2wtem9vbSddIENTUyBjbGFzcyBuYW1lLlxuICogQHByb3BlcnR5IHtzdHJpbmd8SFRNTEVsZW1lbnR9IFt6b29tSW5MYWJlbD0nKyddIFRleHQgbGFiZWwgdG8gdXNlIGZvciB0aGUgem9vbS1pblxuICogYnV0dG9uLiBJbnN0ZWFkIG9mIHRleHQsIGFsc28gYW4gZWxlbWVudCAoZS5nLiBhIGBzcGFuYCBlbGVtZW50KSBjYW4gYmUgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfEhUTUxFbGVtZW50fSBbem9vbU91dExhYmVsPSctJ10gVGV4dCBsYWJlbCB0byB1c2UgZm9yIHRoZSB6b29tLW91dCBidXR0b24uXG4gKiBJbnN0ZWFkIG9mIHRleHQsIGFsc28gYW4gZWxlbWVudCAoZS5nLiBhIGBzcGFuYCBlbGVtZW50KSBjYW4gYmUgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbem9vbUluVGlwTGFiZWw9J1pvb20gaW4nXSBUZXh0IGxhYmVsIHRvIHVzZSBmb3IgdGhlIGJ1dHRvbiB0aXAuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3pvb21PdXRUaXBMYWJlbD0nWm9vbSBvdXQnXSBUZXh0IGxhYmVsIHRvIHVzZSBmb3IgdGhlIGJ1dHRvbiB0aXAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2RlbHRhPTFdIFRoZSB6b29tIGRlbHRhIGFwcGxpZWQgb24gZWFjaCBjbGljay5cbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR8c3RyaW5nfSBbdGFyZ2V0XSBTcGVjaWZ5IGEgdGFyZ2V0IGlmIHlvdSB3YW50IHRoZSBjb250cm9sIHRvIGJlXG4gKiByZW5kZXJlZCBvdXRzaWRlIG9mIHRoZSBtYXAncyB2aWV3cG9ydC5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQSBjb250cm9sIHdpdGggMiBidXR0b25zLCBvbmUgZm9yIHpvb20gaW4gYW5kIG9uZSBmb3Igem9vbSBvdXQuXG4gKiBUaGlzIGNvbnRyb2wgaXMgb25lIG9mIHRoZSBkZWZhdWx0IGNvbnRyb2xzIG9mIGEgbWFwLiBUbyBzdHlsZSB0aGlzIGNvbnRyb2xcbiAqIHVzZSBjc3Mgc2VsZWN0b3JzIGAub2wtem9vbS1pbmAgYW5kIGAub2wtem9vbS1vdXRgLlxuICpcbiAqIEBhcGlcbiAqL1xudmFyIFpvb20gPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChDb250cm9sKSB7XG4gIGZ1bmN0aW9uIFpvb20ob3B0X29wdGlvbnMpIHtcblxuICAgIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgPyBvcHRfb3B0aW9ucyA6IHt9O1xuXG4gICAgQ29udHJvbC5jYWxsKHRoaXMsIHtcbiAgICAgIGVsZW1lbnQ6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgdGFyZ2V0OiBvcHRpb25zLnRhcmdldFxuICAgIH0pO1xuXG4gICAgdmFyIGNsYXNzTmFtZSA9IG9wdGlvbnMuY2xhc3NOYW1lICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsYXNzTmFtZSA6ICdvbC16b29tJztcblxuICAgIHZhciBkZWx0YSA9IG9wdGlvbnMuZGVsdGEgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZGVsdGEgOiAxO1xuXG4gICAgdmFyIHpvb21JbkxhYmVsID0gb3B0aW9ucy56b29tSW5MYWJlbCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy56b29tSW5MYWJlbCA6ICcrJztcbiAgICB2YXIgem9vbU91dExhYmVsID0gb3B0aW9ucy56b29tT3V0TGFiZWwgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuem9vbU91dExhYmVsIDogJ1xcdTIyMTInO1xuXG4gICAgdmFyIHpvb21JblRpcExhYmVsID0gb3B0aW9ucy56b29tSW5UaXBMYWJlbCAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdGlvbnMuem9vbUluVGlwTGFiZWwgOiAnWm9vbSBpbic7XG4gICAgdmFyIHpvb21PdXRUaXBMYWJlbCA9IG9wdGlvbnMuem9vbU91dFRpcExhYmVsICE9PSB1bmRlZmluZWQgP1xuICAgICAgb3B0aW9ucy56b29tT3V0VGlwTGFiZWwgOiAnWm9vbSBvdXQnO1xuXG4gICAgdmFyIGluRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgIGluRWxlbWVudC5jbGFzc05hbWUgPSBjbGFzc05hbWUgKyAnLWluJztcbiAgICBpbkVsZW1lbnQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ2J1dHRvbicpO1xuICAgIGluRWxlbWVudC50aXRsZSA9IHpvb21JblRpcExhYmVsO1xuICAgIGluRWxlbWVudC5hcHBlbmRDaGlsZChcbiAgICAgIHR5cGVvZiB6b29tSW5MYWJlbCA9PT0gJ3N0cmluZycgPyBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh6b29tSW5MYWJlbCkgOiB6b29tSW5MYWJlbFxuICAgICk7XG5cbiAgICBsaXN0ZW4oaW5FbGVtZW50LCBFdmVudFR5cGUuQ0xJQ0ssIHRoaXMuaGFuZGxlQ2xpY2tfLmJpbmQodGhpcywgZGVsdGEpKTtcblxuICAgIHZhciBvdXRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgb3V0RWxlbWVudC5jbGFzc05hbWUgPSBjbGFzc05hbWUgKyAnLW91dCc7XG4gICAgb3V0RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnYnV0dG9uJyk7XG4gICAgb3V0RWxlbWVudC50aXRsZSA9IHpvb21PdXRUaXBMYWJlbDtcbiAgICBvdXRFbGVtZW50LmFwcGVuZENoaWxkKFxuICAgICAgdHlwZW9mIHpvb21PdXRMYWJlbCA9PT0gJ3N0cmluZycgPyBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh6b29tT3V0TGFiZWwpIDogem9vbU91dExhYmVsXG4gICAgKTtcblxuICAgIGxpc3RlbihvdXRFbGVtZW50LCBFdmVudFR5cGUuQ0xJQ0ssIHRoaXMuaGFuZGxlQ2xpY2tfLmJpbmQodGhpcywgLWRlbHRhKSk7XG5cbiAgICB2YXIgY3NzQ2xhc3NlcyA9IGNsYXNzTmFtZSArICcgJyArIENMQVNTX1VOU0VMRUNUQUJMRSArICcgJyArIENMQVNTX0NPTlRST0w7XG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSBjc3NDbGFzc2VzO1xuICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoaW5FbGVtZW50KTtcbiAgICBlbGVtZW50LmFwcGVuZENoaWxkKG91dEVsZW1lbnQpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZHVyYXRpb25fID0gb3B0aW9ucy5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kdXJhdGlvbiA6IDI1MDtcblxuICB9XG5cbiAgaWYgKCBDb250cm9sICkgWm9vbS5fX3Byb3RvX18gPSBDb250cm9sO1xuICBab29tLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIENvbnRyb2wgJiYgQ29udHJvbC5wcm90b3R5cGUgKTtcbiAgWm9vbS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBab29tO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGEgWm9vbSBkZWx0YS5cbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gaGFuZGxlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBab29tLnByb3RvdHlwZS5oYW5kbGVDbGlja18gPSBmdW5jdGlvbiBoYW5kbGVDbGlja18gKGRlbHRhLCBldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy56b29tQnlEZWx0YV8oZGVsdGEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGEgWm9vbSBkZWx0YS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFpvb20ucHJvdG90eXBlLnpvb21CeURlbHRhXyA9IGZ1bmN0aW9uIHpvb21CeURlbHRhXyAoZGVsdGEpIHtcbiAgICB2YXIgbWFwID0gdGhpcy5nZXRNYXAoKTtcbiAgICB2YXIgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgaWYgKCF2aWV3KSB7XG4gICAgICAvLyB0aGUgbWFwIGRvZXMgbm90IGhhdmUgYSB2aWV3LCBzbyB3ZSBjYW4ndCBhY3RcbiAgICAgIC8vIHVwb24gaXRcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGN1cnJlbnRSZXNvbHV0aW9uID0gdmlldy5nZXRSZXNvbHV0aW9uKCk7XG4gICAgaWYgKGN1cnJlbnRSZXNvbHV0aW9uKSB7XG4gICAgICB2YXIgbmV3UmVzb2x1dGlvbiA9IHZpZXcuY29uc3RyYWluUmVzb2x1dGlvbihjdXJyZW50UmVzb2x1dGlvbiwgZGVsdGEpO1xuICAgICAgaWYgKHRoaXMuZHVyYXRpb25fID4gMCkge1xuICAgICAgICBpZiAodmlldy5nZXRBbmltYXRpbmcoKSkge1xuICAgICAgICAgIHZpZXcuY2FuY2VsQW5pbWF0aW9ucygpO1xuICAgICAgICB9XG4gICAgICAgIHZpZXcuYW5pbWF0ZSh7XG4gICAgICAgICAgcmVzb2x1dGlvbjogbmV3UmVzb2x1dGlvbixcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbl8sXG4gICAgICAgICAgZWFzaW5nOiBlYXNlT3V0XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmlldy5zZXRSZXNvbHV0aW9uKG5ld1Jlc29sdXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gWm9vbTtcbn0oQ29udHJvbCkpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IFpvb207XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVpvb20uanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2NvbnRyb2wvdXRpbFxuICovXG5pbXBvcnQgQ29sbGVjdGlvbiBmcm9tICcuLi9Db2xsZWN0aW9uLmpzJztcbmltcG9ydCBBdHRyaWJ1dGlvbiBmcm9tICcuL0F0dHJpYnV0aW9uLmpzJztcbmltcG9ydCBSb3RhdGUgZnJvbSAnLi9Sb3RhdGUuanMnO1xuaW1wb3J0IFpvb20gZnJvbSAnLi9ab29tLmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERlZmF1bHRzT3B0aW9uc1xuICogQHByb3BlcnR5IHtib29sZWFufSBbYXR0cmlidXRpb249dHJ1ZV0gSW5jbHVkZVxuICoge0BsaW5rIG1vZHVsZTpvbC9jb250cm9sL0F0dHJpYnV0aW9ufkF0dHJpYnV0aW9ufS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9BdHRyaWJ1dGlvbi5qc1wiKS5PcHRpb25zfSBbYXR0cmlidXRpb25PcHRpb25zXVxuICogT3B0aW9ucyBmb3Ige0BsaW5rIG1vZHVsZTpvbC9jb250cm9sL0F0dHJpYnV0aW9ufkF0dHJpYnV0aW9ufS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JvdGF0ZT10cnVlXSBJbmNsdWRlXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2NvbnRyb2wvUm90YXRlflJvdGF0ZX0uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vUm90YXRlLmpzXCIpLk9wdGlvbnN9IFtyb3RhdGVPcHRpb25zXSBPcHRpb25zXG4gKiBmb3Ige0BsaW5rIG1vZHVsZTpvbC9jb250cm9sL1JvdGF0ZX5Sb3RhdGV9LlxuICogQHByb3BlcnR5IHtib29sZWFufSBbem9vbV0gSW5jbHVkZSB7QGxpbmsgbW9kdWxlOm9sL2NvbnRyb2wvWm9vbX5ab29tfS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9ab29tLmpzXCIpLk9wdGlvbnN9IFt6b29tT3B0aW9uc10gT3B0aW9ucyBmb3JcbiAqIHtAbGluayBtb2R1bGU6b2wvY29udHJvbC9ab29tflpvb219LlxuICogQGFwaVxuICovXG5cblxuLyoqXG4gKiBTZXQgb2YgY29udHJvbHMgaW5jbHVkZWQgaW4gbWFwcyBieSBkZWZhdWx0LiBVbmxlc3MgY29uZmlndXJlZCBvdGhlcndpc2UsXG4gKiB0aGlzIHJldHVybnMgYSBjb2xsZWN0aW9uIGNvbnRhaW5pbmcgYW4gaW5zdGFuY2Ugb2YgZWFjaCBvZiB0aGUgZm9sbG93aW5nXG4gKiBjb250cm9sczpcbiAqICoge0BsaW5rIG1vZHVsZTpvbC9jb250cm9sL1pvb21+Wm9vbX1cbiAqICoge0BsaW5rIG1vZHVsZTpvbC9jb250cm9sL1JvdGF0ZX5Sb3RhdGV9XG4gKiAqIHtAbGluayBtb2R1bGU6b2wvY29udHJvbC9BdHRyaWJ1dGlvbn5BdHRyaWJ1dGlvbn1cbiAqXG4gKiBAcGFyYW0ge0RlZmF1bHRzT3B0aW9ucz19IG9wdF9vcHRpb25zXG4gKiBEZWZhdWx0cyBvcHRpb25zLlxuICogQHJldHVybiB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuL0NvbnRyb2wuanNcIikuZGVmYXVsdD59XG4gKiBDb250cm9scy5cbiAqIEBmdW5jdGlvbiBtb2R1bGU6b2wvY29udHJvbC5kZWZhdWx0c1xuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdHMob3B0X29wdGlvbnMpIHtcblxuICB2YXIgb3B0aW9ucyA9IG9wdF9vcHRpb25zID8gb3B0X29wdGlvbnMgOiB7fTtcblxuICB2YXIgY29udHJvbHMgPSBuZXcgQ29sbGVjdGlvbigpO1xuXG4gIHZhciB6b29tQ29udHJvbCA9IG9wdGlvbnMuem9vbSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy56b29tIDogdHJ1ZTtcbiAgaWYgKHpvb21Db250cm9sKSB7XG4gICAgY29udHJvbHMucHVzaChuZXcgWm9vbShvcHRpb25zLnpvb21PcHRpb25zKSk7XG4gIH1cblxuICB2YXIgcm90YXRlQ29udHJvbCA9IG9wdGlvbnMucm90YXRlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnJvdGF0ZSA6IHRydWU7XG4gIGlmIChyb3RhdGVDb250cm9sKSB7XG4gICAgY29udHJvbHMucHVzaChuZXcgUm90YXRlKG9wdGlvbnMucm90YXRlT3B0aW9ucykpO1xuICB9XG5cbiAgdmFyIGF0dHJpYnV0aW9uQ29udHJvbCA9IG9wdGlvbnMuYXR0cmlidXRpb24gIT09IHVuZGVmaW5lZCA/XG4gICAgb3B0aW9ucy5hdHRyaWJ1dGlvbiA6IHRydWU7XG4gIGlmIChhdHRyaWJ1dGlvbkNvbnRyb2wpIHtcbiAgICBjb250cm9scy5wdXNoKG5ldyBBdHRyaWJ1dGlvbihvcHRpb25zLmF0dHJpYnV0aW9uT3B0aW9ucykpO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRyb2xzO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9jb29yZGluYXRlXG4gKi9cbmltcG9ydCB7bW9kdWxvfSBmcm9tICcuL21hdGguanMnO1xuaW1wb3J0IHtwYWROdW1iZXJ9IGZyb20gJy4vc3RyaW5nLmpzJztcblxuXG4vKipcbiAqIEFuIGFycmF5IG9mIG51bWJlcnMgcmVwcmVzZW50aW5nIGFuIHh5IGNvb3JkaW5hdGUuIEV4YW1wbGU6IGBbMTYsIDQ4XWAuXG4gKiBAdHlwZWRlZiB7QXJyYXk8bnVtYmVyPn0gQ29vcmRpbmF0ZVxuICogQGFwaVxuICovXG5cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSB7QGxpbmsgbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gYW5kXG4gKiB0cmFuc2Zvcm1zIGl0IGludG8gYSBge3N0cmluZ31gLlxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbigoQ29vcmRpbmF0ZXx1bmRlZmluZWQpKTogc3RyaW5nfSBDb29yZGluYXRlRm9ybWF0XG4gKiBAYXBpXG4gKi9cblxuXG4vKipcbiAqIEFkZCBgZGVsdGFgIHRvIGBjb29yZGluYXRlYC4gYGNvb3JkaW5hdGVgIGlzIG1vZGlmaWVkIGluIHBsYWNlIGFuZCByZXR1cm5lZFxuICogYnkgdGhlIGZ1bmN0aW9uLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIGltcG9ydCB7YWRkfSBmcm9tICdvbC9jb29yZGluYXRlJztcbiAqXG4gKiAgICAgdmFyIGNvb3JkID0gWzcuODUsIDQ3Ljk4MzMzM107XG4gKiAgICAgYWRkKGNvb3JkLCBbLTIsIDRdKTtcbiAqICAgICAvLyBjb29yZCBpcyBub3cgWzUuODUsIDUxLjk4MzMzM11cbiAqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gZGVsdGEgRGVsdGEuXG4gKiBAcmV0dXJuIHtDb29yZGluYXRlfSBUaGUgaW5wdXQgY29vcmRpbmF0ZSBhZGp1c3RlZCBieVxuICogdGhlIGdpdmVuIGRlbHRhLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkKGNvb3JkaW5hdGUsIGRlbHRhKSB7XG4gIGNvb3JkaW5hdGVbMF0gKz0gZGVsdGFbMF07XG4gIGNvb3JkaW5hdGVbMV0gKz0gZGVsdGFbMV07XG4gIHJldHVybiBjb29yZGluYXRlO1xufVxuXG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgcG9pbnQgY2xvc2VzdCB0byB0aGUgcGFzc2VkIGNvb3JkaW5hdGUgb24gdGhlIHBhc3NlZCBjaXJjbGUuXG4gKlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZGluYXRlIFRoZSBjb29yZGluYXRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2dlb20vQ2lyY2xlLmpzXCIpLmRlZmF1bHR9IGNpcmNsZSBUaGUgY2lyY2xlLlxuICogQHJldHVybiB7Q29vcmRpbmF0ZX0gQ2xvc2VzdCBwb2ludCBvbiB0aGUgY2lyY3VtZmVyZW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb3Nlc3RPbkNpcmNsZShjb29yZGluYXRlLCBjaXJjbGUpIHtcbiAgdmFyIHIgPSBjaXJjbGUuZ2V0UmFkaXVzKCk7XG4gIHZhciBjZW50ZXIgPSBjaXJjbGUuZ2V0Q2VudGVyKCk7XG4gIHZhciB4MCA9IGNlbnRlclswXTtcbiAgdmFyIHkwID0gY2VudGVyWzFdO1xuICB2YXIgeDEgPSBjb29yZGluYXRlWzBdO1xuICB2YXIgeTEgPSBjb29yZGluYXRlWzFdO1xuXG4gIHZhciBkeCA9IHgxIC0geDA7XG4gIHZhciBkeSA9IHkxIC0geTA7XG4gIGlmIChkeCA9PT0gMCAmJiBkeSA9PT0gMCkge1xuICAgIGR4ID0gMTtcbiAgfVxuICB2YXIgZCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgdmFyIHggPSB4MCArIHIgKiBkeCAvIGQ7XG4gIHZhciB5ID0geTAgKyByICogZHkgLyBkO1xuXG4gIHJldHVybiBbeCwgeV07XG59XG5cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBwb2ludCBjbG9zZXN0IHRvIHRoZSBwYXNzZWQgY29vcmRpbmF0ZSBvbiB0aGUgcGFzc2VkIHNlZ21lbnQuXG4gKiBUaGlzIGlzIHRoZSBmb290IG9mIHRoZSBwZXJwZW5kaWN1bGFyIG9mIHRoZSBjb29yZGluYXRlIHRvIHRoZSBzZWdtZW50IHdoZW5cbiAqIHRoZSBmb290IGlzIG9uIHRoZSBzZWdtZW50LCBvciB0aGUgY2xvc2VzdCBzZWdtZW50IGNvb3JkaW5hdGUgd2hlbiB0aGUgZm9vdFxuICogaXMgb3V0c2lkZSB0aGUgc2VnbWVudC5cbiAqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkaW5hdGUgVGhlIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge0FycmF5PENvb3JkaW5hdGU+fSBzZWdtZW50IFRoZSB0d28gY29vcmRpbmF0ZXNcbiAqIG9mIHRoZSBzZWdtZW50LlxuICogQHJldHVybiB7Q29vcmRpbmF0ZX0gVGhlIGZvb3Qgb2YgdGhlIHBlcnBlbmRpY3VsYXIgb2ZcbiAqIHRoZSBjb29yZGluYXRlIHRvIHRoZSBzZWdtZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvc2VzdE9uU2VnbWVudChjb29yZGluYXRlLCBzZWdtZW50KSB7XG4gIHZhciB4MCA9IGNvb3JkaW5hdGVbMF07XG4gIHZhciB5MCA9IGNvb3JkaW5hdGVbMV07XG4gIHZhciBzdGFydCA9IHNlZ21lbnRbMF07XG4gIHZhciBlbmQgPSBzZWdtZW50WzFdO1xuICB2YXIgeDEgPSBzdGFydFswXTtcbiAgdmFyIHkxID0gc3RhcnRbMV07XG4gIHZhciB4MiA9IGVuZFswXTtcbiAgdmFyIHkyID0gZW5kWzFdO1xuICB2YXIgZHggPSB4MiAtIHgxO1xuICB2YXIgZHkgPSB5MiAtIHkxO1xuICB2YXIgYWxvbmcgPSAoZHggPT09IDAgJiYgZHkgPT09IDApID8gMCA6XG4gICAgKChkeCAqICh4MCAtIHgxKSkgKyAoZHkgKiAoeTAgLSB5MSkpKSAvICgoZHggKiBkeCArIGR5ICogZHkpIHx8IDApO1xuICB2YXIgeCwgeTtcbiAgaWYgKGFsb25nIDw9IDApIHtcbiAgICB4ID0geDE7XG4gICAgeSA9IHkxO1xuICB9IGVsc2UgaWYgKGFsb25nID49IDEpIHtcbiAgICB4ID0geDI7XG4gICAgeSA9IHkyO1xuICB9IGVsc2Uge1xuICAgIHggPSB4MSArIGFsb25nICogZHg7XG4gICAgeSA9IHkxICsgYWxvbmcgKiBkeTtcbiAgfVxuICByZXR1cm4gW3gsIHldO1xufVxuXG5cbi8qKlxuICogUmV0dXJucyBhIHtAbGluayBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlRm9ybWF0fSBmdW5jdGlvbiB0aGF0IGNhbiBiZVxuICogdXNlZCB0byBmb3JtYXRcbiAqIGEge0Nvb3JkaW5hdGV9IHRvIGEgc3RyaW5nLlxuICpcbiAqIEV4YW1wbGUgd2l0aG91dCBzcGVjaWZ5aW5nIHRoZSBmcmFjdGlvbmFsIGRpZ2l0czpcbiAqXG4gKiAgICAgaW1wb3J0IHtjcmVhdGVTdHJpbmdYWX0gZnJvbSAnb2wvY29vcmRpbmF0ZSc7XG4gKlxuICogICAgIHZhciBjb29yZCA9IFs3Ljg1LCA0Ny45ODMzMzNdO1xuICogICAgIHZhciBzdHJpbmdpZnlGdW5jID0gY3JlYXRlU3RyaW5nWFkoKTtcbiAqICAgICB2YXIgb3V0ID0gc3RyaW5naWZ5RnVuYyhjb29yZCk7XG4gKiAgICAgLy8gb3V0IGlzIG5vdyAnOCwgNDgnXG4gKlxuICogRXhhbXBsZSB3aXRoIGV4cGxpY2l0bHkgc3BlY2lmeWluZyAyIGZyYWN0aW9uYWwgZGlnaXRzOlxuICpcbiAqICAgICBpbXBvcnQge2NyZWF0ZVN0cmluZ1hZfSBmcm9tICdvbC9jb29yZGluYXRlJztcbiAqXG4gKiAgICAgdmFyIGNvb3JkID0gWzcuODUsIDQ3Ljk4MzMzM107XG4gKiAgICAgdmFyIHN0cmluZ2lmeUZ1bmMgPSBjcmVhdGVTdHJpbmdYWSgyKTtcbiAqICAgICB2YXIgb3V0ID0gc3RyaW5naWZ5RnVuYyhjb29yZCk7XG4gKiAgICAgLy8gb3V0IGlzIG5vdyAnNy44NSwgNDcuOTgnXG4gKlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZnJhY3Rpb25EaWdpdHMgVGhlIG51bWJlciBvZiBkaWdpdHMgdG8gaW5jbHVkZVxuICogICAgYWZ0ZXIgdGhlIGRlY2ltYWwgcG9pbnQuIERlZmF1bHQgaXMgYDBgLlxuICogQHJldHVybiB7Q29vcmRpbmF0ZUZvcm1hdH0gQ29vcmRpbmF0ZSBmb3JtYXQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdHJpbmdYWShvcHRfZnJhY3Rpb25EaWdpdHMpIHtcbiAgcmV0dXJuIChcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFN0cmluZyBYWS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbihjb29yZGluYXRlKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmdYWShjb29yZGluYXRlLCBvcHRfZnJhY3Rpb25EaWdpdHMpO1xuICAgIH1cbiAgKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBoZW1pc3BoZXJlcyBIZW1pc3BoZXJlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWdyZWVzIERlZ3JlZXMuXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9mcmFjdGlvbkRpZ2l0cyBUaGUgbnVtYmVyIG9mIGRpZ2l0cyB0byBpbmNsdWRlXG4gKiAgICBhZnRlciB0aGUgZGVjaW1hbCBwb2ludC4gRGVmYXVsdCBpcyBgMGAuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZ3JlZXNUb1N0cmluZ0hETVMoaGVtaXNwaGVyZXMsIGRlZ3JlZXMsIG9wdF9mcmFjdGlvbkRpZ2l0cykge1xuICB2YXIgbm9ybWFsaXplZERlZ3JlZXMgPSBtb2R1bG8oZGVncmVlcyArIDE4MCwgMzYwKSAtIDE4MDtcbiAgdmFyIHggPSBNYXRoLmFicygzNjAwICogbm9ybWFsaXplZERlZ3JlZXMpO1xuICB2YXIgZGZsUHJlY2lzaW9uID0gb3B0X2ZyYWN0aW9uRGlnaXRzIHx8IDA7XG4gIHZhciBwcmVjaXNpb24gPSBNYXRoLnBvdygxMCwgZGZsUHJlY2lzaW9uKTtcblxuICB2YXIgZGVnID0gTWF0aC5mbG9vcih4IC8gMzYwMCk7XG4gIHZhciBtaW4gPSBNYXRoLmZsb29yKCh4IC0gZGVnICogMzYwMCkgLyA2MCk7XG4gIHZhciBzZWMgPSB4IC0gKGRlZyAqIDM2MDApIC0gKG1pbiAqIDYwKTtcbiAgc2VjID0gTWF0aC5jZWlsKHNlYyAqIHByZWNpc2lvbikgLyBwcmVjaXNpb247XG5cbiAgaWYgKHNlYyA+PSA2MCkge1xuICAgIHNlYyA9IDA7XG4gICAgbWluICs9IDE7XG4gIH1cblxuICBpZiAobWluID49IDYwKSB7XG4gICAgbWluID0gMDtcbiAgICBkZWcgKz0gMTtcbiAgfVxuXG4gIHJldHVybiBkZWcgKyAnXFx1MDBiMCAnICsgcGFkTnVtYmVyKG1pbiwgMikgKyAnXFx1MjAzMiAnICtcbiAgICBwYWROdW1iZXIoc2VjLCAyLCBkZmxQcmVjaXNpb24pICsgJ1xcdTIwMzMnICtcbiAgICAobm9ybWFsaXplZERlZ3JlZXMgPT0gMCA/ICcnIDogJyAnICsgaGVtaXNwaGVyZXMuY2hhckF0KG5vcm1hbGl6ZWREZWdyZWVzIDwgMCA/IDEgOiAwKSk7XG59XG5cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSBnaXZlbiB7QGxpbmsgbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gdG8gYSBzdHJpbmdcbiAqIHVzaW5nIHRoZSBnaXZlbiBzdHJpbmcgdGVtcGxhdGUuIFRoZSBzdHJpbmdzIGB7eH1gIGFuZCBge3l9YCBpbiB0aGUgdGVtcGxhdGVcbiAqIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGUgZmlyc3QgYW5kIHNlY29uZCBjb29yZGluYXRlIHZhbHVlcyByZXNwZWN0aXZlbHkuXG4gKlxuICogRXhhbXBsZSB3aXRob3V0IHNwZWNpZnlpbmcgdGhlIGZyYWN0aW9uYWwgZGlnaXRzOlxuICpcbiAqICAgICBpbXBvcnQge2Zvcm1hdH0gZnJvbSAnb2wvY29vcmRpbmF0ZSc7XG4gKlxuICogICAgIHZhciBjb29yZCA9IFs3Ljg1LCA0Ny45ODMzMzNdO1xuICogICAgIHZhciB0ZW1wbGF0ZSA9ICdDb29yZGluYXRlIGlzICh7eH18e3l9KS4nO1xuICogICAgIHZhciBvdXQgPSBmb3JtYXQoY29vcmQsIHRlbXBsYXRlKTtcbiAqICAgICAvLyBvdXQgaXMgbm93ICdDb29yZGluYXRlIGlzICg4fDQ4KS4nXG4gKlxuICogRXhhbXBsZSBleHBsaWNpdGx5IHNwZWNpZnlpbmcgdGhlIGZyYWN0aW9uYWwgZGlnaXRzOlxuICpcbiAqICAgICBpbXBvcnQge2Zvcm1hdH0gZnJvbSAnb2wvY29vcmRpbmF0ZSc7XG4gKlxuICogICAgIHZhciBjb29yZCA9IFs3Ljg1LCA0Ny45ODMzMzNdO1xuICogICAgIHZhciB0ZW1wbGF0ZSA9ICdDb29yZGluYXRlIGlzICh7eH18e3l9KS4nO1xuICogICAgIHZhciBvdXQgPSBmb3JtYXQoY29vcmQsIHRlbXBsYXRlLCAyKTtcbiAqICAgICAvLyBvdXQgaXMgbm93ICdDb29yZGluYXRlIGlzICg3Ljg1fDQ3Ljk4KS4nXG4gKlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGVtcGxhdGUgQSB0ZW1wbGF0ZSBzdHJpbmcgd2l0aCBge3h9YCBhbmQgYHt5fWAgcGxhY2Vob2xkZXJzXG4gKiAgICAgdGhhdCB3aWxsIGJlIHJlcGxhY2VkIGJ5IGZpcnN0IGFuZCBzZWNvbmQgY29vcmRpbmF0ZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9mcmFjdGlvbkRpZ2l0cyBUaGUgbnVtYmVyIG9mIGRpZ2l0cyB0byBpbmNsdWRlXG4gKiAgICBhZnRlciB0aGUgZGVjaW1hbCBwb2ludC4gRGVmYXVsdCBpcyBgMGAuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEZvcm1hdHRlZCBjb29yZGluYXRlLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0KGNvb3JkaW5hdGUsIHRlbXBsYXRlLCBvcHRfZnJhY3Rpb25EaWdpdHMpIHtcbiAgaWYgKGNvb3JkaW5hdGUpIHtcbiAgICByZXR1cm4gdGVtcGxhdGVcbiAgICAgIC5yZXBsYWNlKCd7eH0nLCBjb29yZGluYXRlWzBdLnRvRml4ZWQob3B0X2ZyYWN0aW9uRGlnaXRzKSlcbiAgICAgIC5yZXBsYWNlKCd7eX0nLCBjb29yZGluYXRlWzFdLnRvRml4ZWQob3B0X2ZyYWN0aW9uRGlnaXRzKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkaW5hdGUxIEZpcnN0IGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkaW5hdGUyIFNlY29uZCBjb29yZGluYXRlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHR3byBjb29yZGluYXRlcyBhcmUgZXF1YWwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoY29vcmRpbmF0ZTEsIGNvb3JkaW5hdGUyKSB7XG4gIHZhciBlcXVhbHMgPSB0cnVlO1xuICBmb3IgKHZhciBpID0gY29vcmRpbmF0ZTEubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBpZiAoY29vcmRpbmF0ZTFbaV0gIT0gY29vcmRpbmF0ZTJbaV0pIHtcbiAgICAgIGVxdWFscyA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBlcXVhbHM7XG59XG5cblxuLyoqXG4gKiBSb3RhdGUgYGNvb3JkaW5hdGVgIGJ5IGBhbmdsZWAuIGBjb29yZGluYXRlYCBpcyBtb2RpZmllZCBpbiBwbGFjZSBhbmRcbiAqIHJldHVybmVkIGJ5IHRoZSBmdW5jdGlvbi5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICBpbXBvcnQge3JvdGF0ZX0gZnJvbSAnb2wvY29vcmRpbmF0ZSc7XG4gKlxuICogICAgIHZhciBjb29yZCA9IFs3Ljg1LCA0Ny45ODMzMzNdO1xuICogICAgIHZhciByb3RhdGVSYWRpYW5zID0gTWF0aC5QSSAvIDI7IC8vIDkwIGRlZ3JlZXNcbiAqICAgICByb3RhdGUoY29vcmQsIHJvdGF0ZVJhZGlhbnMpO1xuICogICAgIC8vIGNvb3JkIGlzIG5vdyBbLTQ3Ljk4MzMzMywgNy44NV1cbiAqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSBBbmdsZSBpbiByYWRpYW4uXG4gKiBAcmV0dXJuIHtDb29yZGluYXRlfSBDb29yZGluYXRlLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKGNvb3JkaW5hdGUsIGFuZ2xlKSB7XG4gIHZhciBjb3NBbmdsZSA9IE1hdGguY29zKGFuZ2xlKTtcbiAgdmFyIHNpbkFuZ2xlID0gTWF0aC5zaW4oYW5nbGUpO1xuICB2YXIgeCA9IGNvb3JkaW5hdGVbMF0gKiBjb3NBbmdsZSAtIGNvb3JkaW5hdGVbMV0gKiBzaW5BbmdsZTtcbiAgdmFyIHkgPSBjb29yZGluYXRlWzFdICogY29zQW5nbGUgKyBjb29yZGluYXRlWzBdICogc2luQW5nbGU7XG4gIGNvb3JkaW5hdGVbMF0gPSB4O1xuICBjb29yZGluYXRlWzFdID0geTtcbiAgcmV0dXJuIGNvb3JkaW5hdGU7XG59XG5cblxuLyoqXG4gKiBTY2FsZSBgY29vcmRpbmF0ZWAgYnkgYHNjYWxlYC4gYGNvb3JkaW5hdGVgIGlzIG1vZGlmaWVkIGluIHBsYWNlIGFuZCByZXR1cm5lZFxuICogYnkgdGhlIGZ1bmN0aW9uLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIGltcG9ydCB7c2NhbGUgYXMgc2NhbGVDb29yZGluYXRlfSBmcm9tICdvbC9jb29yZGluYXRlJztcbiAqXG4gKiAgICAgdmFyIGNvb3JkID0gWzcuODUsIDQ3Ljk4MzMzM107XG4gKiAgICAgdmFyIHNjYWxlID0gMS4yO1xuICogICAgIHNjYWxlQ29vcmRpbmF0ZShjb29yZCwgc2NhbGUpO1xuICogICAgIC8vIGNvb3JkIGlzIG5vdyBbOS40MiwgNTcuNTc5OTk5Nl1cbiAqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZSBTY2FsZSBmYWN0b3IuXG4gKiBAcmV0dXJuIHtDb29yZGluYXRlfSBDb29yZGluYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUoY29vcmRpbmF0ZSwgc2NhbGUpIHtcbiAgY29vcmRpbmF0ZVswXSAqPSBzY2FsZTtcbiAgY29vcmRpbmF0ZVsxXSAqPSBzY2FsZTtcbiAgcmV0dXJuIGNvb3JkaW5hdGU7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkMSBGaXJzdCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZDIgU2Vjb25kIGNvb3JkaW5hdGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBjb29yZDEgYW5kIGNvb3JkMi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZShjb29yZDEsIGNvb3JkMikge1xuICB2YXIgZHggPSBjb29yZDFbMF0gLSBjb29yZDJbMF07XG4gIHZhciBkeSA9IGNvb3JkMVsxXSAtIGNvb3JkMlsxXTtcbiAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZDEgRmlyc3QgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmQyIFNlY29uZCBjb29yZGluYXRlLlxuICogQHJldHVybiB7bnVtYmVyfSBEaXN0YW5jZSBiZXR3ZWVuIGNvb3JkMSBhbmQgY29vcmQyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2UoY29vcmQxLCBjb29yZDIpIHtcbiAgcmV0dXJuIE1hdGguc3FydChzcXVhcmVkRGlzdGFuY2UoY29vcmQxLCBjb29yZDIpKTtcbn1cblxuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgc3F1YXJlZCBkaXN0YW5jZSBmcm9tIGEgY29vcmRpbmF0ZSB0byBhIGxpbmUgc2VnbWVudC5cbiAqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQuXG4gKiBAcGFyYW0ge0FycmF5PENvb3JkaW5hdGU+fSBzZWdtZW50IExpbmUgc2VnbWVudCAoMlxuICogY29vcmRpbmF0ZXMpLlxuICogQHJldHVybiB7bnVtYmVyfSBTcXVhcmVkIGRpc3RhbmNlIGZyb20gdGhlIHBvaW50IHRvIHRoZSBsaW5lIHNlZ21lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2VUb1NlZ21lbnQoY29vcmRpbmF0ZSwgc2VnbWVudCkge1xuICByZXR1cm4gc3F1YXJlZERpc3RhbmNlKGNvb3JkaW5hdGUsXG4gICAgY2xvc2VzdE9uU2VnbWVudChjb29yZGluYXRlLCBzZWdtZW50KSk7XG59XG5cblxuLyoqXG4gKiBGb3JtYXQgYSBnZW9ncmFwaGljIGNvb3JkaW5hdGUgd2l0aCB0aGUgaGVtaXNwaGVyZSwgZGVncmVlcywgbWludXRlcywgYW5kXG4gKiBzZWNvbmRzLlxuICpcbiAqIEV4YW1wbGUgd2l0aG91dCBzcGVjaWZ5aW5nIGZyYWN0aW9uYWwgZGlnaXRzOlxuICpcbiAqICAgICBpbXBvcnQge3RvU3RyaW5nSERNU30gZnJvbSAnb2wvY29vcmRpbmF0ZSc7XG4gKlxuICogICAgIHZhciBjb29yZCA9IFs3Ljg1LCA0Ny45ODMzMzNdO1xuICogICAgIHZhciBvdXQgPSB0b1N0cmluZ0hETVMoY29vcmQpO1xuICogICAgIC8vIG91dCBpcyBub3cgJzQ3wrAgNTjigLIgNjDigLMgTiA3wrAgNTDigLIgNjDigLMgRSdcbiAqXG4gKiBFeGFtcGxlIGV4cGxpY2l0bHkgc3BlY2lmeWluZyAxIGZyYWN0aW9uYWwgZGlnaXQ6XG4gKlxuICogICAgIGltcG9ydCB7dG9TdHJpbmdIRE1TfSBmcm9tICdvbC9jb29yZGluYXRlJztcbiAqXG4gKiAgICAgdmFyIGNvb3JkID0gWzcuODUsIDQ3Ljk4MzMzM107XG4gKiAgICAgdmFyIG91dCA9IHRvU3RyaW5nSERNUyhjb29yZCwgMSk7XG4gKiAgICAgLy8gb3V0IGlzIG5vdyAnNDfCsCA1OOKAsiA2MC4w4oCzIE4gN8KwIDUw4oCyIDYwLjDigLMgRSdcbiAqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2ZyYWN0aW9uRGlnaXRzIFRoZSBudW1iZXIgb2YgZGlnaXRzIHRvIGluY2x1ZGVcbiAqICAgIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50LiBEZWZhdWx0IGlzIGAwYC5cbiAqIEByZXR1cm4ge3N0cmluZ30gSGVtaXNwaGVyZSwgZGVncmVlcywgbWludXRlcyBhbmQgc2Vjb25kcy5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvU3RyaW5nSERNUyhjb29yZGluYXRlLCBvcHRfZnJhY3Rpb25EaWdpdHMpIHtcbiAgaWYgKGNvb3JkaW5hdGUpIHtcbiAgICByZXR1cm4gZGVncmVlc1RvU3RyaW5nSERNUygnTlMnLCBjb29yZGluYXRlWzFdLCBvcHRfZnJhY3Rpb25EaWdpdHMpICsgJyAnICtcbiAgICAgICAgZGVncmVlc1RvU3RyaW5nSERNUygnRVcnLCBjb29yZGluYXRlWzBdLCBvcHRfZnJhY3Rpb25EaWdpdHMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5cbi8qKlxuICogRm9ybWF0IGEgY29vcmRpbmF0ZSBhcyBhIGNvbW1hIGRlbGltaXRlZCBzdHJpbmcuXG4gKlxuICogRXhhbXBsZSB3aXRob3V0IHNwZWNpZnlpbmcgZnJhY3Rpb25hbCBkaWdpdHM6XG4gKlxuICogICAgIGltcG9ydCB7dG9TdHJpbmdYWX0gZnJvbSAnb2wvY29vcmRpbmF0ZSc7XG4gKlxuICogICAgIHZhciBjb29yZCA9IFs3Ljg1LCA0Ny45ODMzMzNdO1xuICogICAgIHZhciBvdXQgPSB0b1N0cmluZ1hZKGNvb3JkKTtcbiAqICAgICAvLyBvdXQgaXMgbm93ICc4LCA0OCdcbiAqXG4gKiBFeGFtcGxlIGV4cGxpY2l0bHkgc3BlY2lmeWluZyAxIGZyYWN0aW9uYWwgZGlnaXQ6XG4gKlxuICogICAgIGltcG9ydCB7dG9TdHJpbmdYWX0gZnJvbSAnb2wvY29vcmRpbmF0ZSc7XG4gKlxuICogICAgIHZhciBjb29yZCA9IFs3Ljg1LCA0Ny45ODMzMzNdO1xuICogICAgIHZhciBvdXQgPSB0b1N0cmluZ1hZKGNvb3JkLCAxKTtcbiAqICAgICAvLyBvdXQgaXMgbm93ICc3LjgsIDQ4LjAnXG4gKlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9mcmFjdGlvbkRpZ2l0cyBUaGUgbnVtYmVyIG9mIGRpZ2l0cyB0byBpbmNsdWRlXG4gKiAgICBhZnRlciB0aGUgZGVjaW1hbCBwb2ludC4gRGVmYXVsdCBpcyBgMGAuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFhZLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9TdHJpbmdYWShjb29yZGluYXRlLCBvcHRfZnJhY3Rpb25EaWdpdHMpIHtcbiAgcmV0dXJuIGZvcm1hdChjb29yZGluYXRlLCAne3h9LCB7eX0nLCBvcHRfZnJhY3Rpb25EaWdpdHMpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb29yZGluYXRlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9jc3NcbiAqL1xuXG5cbi8qKlxuICogVGhlIENTUyBjbGFzcyBmb3IgaGlkZGVuIGZlYXR1cmUuXG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgdmFyIENMQVNTX0hJRERFTiA9ICdvbC1oaWRkZW4nO1xuXG5cbi8qKlxuICogVGhlIENTUyBjbGFzcyB0aGF0IHdlJ2xsIGdpdmUgdGhlIERPTSBlbGVtZW50cyB0byBoYXZlIHRoZW0gc2VsZWN0YWJsZS5cbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCB2YXIgQ0xBU1NfU0VMRUNUQUJMRSA9ICdvbC1zZWxlY3RhYmxlJztcblxuXG4vKipcbiAqIFRoZSBDU1MgY2xhc3MgdGhhdCB3ZSdsbCBnaXZlIHRoZSBET00gZWxlbWVudHMgdG8gaGF2ZSB0aGVtIHVuc2VsZWN0YWJsZS5cbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCB2YXIgQ0xBU1NfVU5TRUxFQ1RBQkxFID0gJ29sLXVuc2VsZWN0YWJsZSc7XG5cblxuLyoqXG4gKiBUaGUgQ1NTIGNsYXNzIGZvciB1bnN1cHBvcnRlZCBmZWF0dXJlLlxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IHZhciBDTEFTU19VTlNVUFBPUlRFRCA9ICdvbC11bnN1cHBvcnRlZCc7XG5cblxuLyoqXG4gKiBUaGUgQ1NTIGNsYXNzIGZvciBjb250cm9scy5cbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCB2YXIgQ0xBU1NfQ09OVFJPTCA9ICdvbC1jb250cm9sJztcblxuXG4vKipcbiAqIFRoZSBDU1MgY2xhc3MgdGhhdCB3ZSdsbCBnaXZlIHRoZSBET00gZWxlbWVudHMgdGhhdCBhcmUgY29sbGFwc2VkLCBpLmUuXG4gKiB0byB0aG9zZSBlbGVtZW50cyB3aGljaCB1c3VhbGx5IGNhbiBiZSBleHBhbmRlZC5cbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCB2YXIgQ0xBU1NfQ09MTEFQU0VEID0gJ29sLWNvbGxhcHNlZCc7XG5cblxuLyoqXG4gKiBHZXQgdGhlIGxpc3Qgb2YgZm9udCBmYW1pbGllcyBmcm9tIGEgZm9udCBzcGVjLiAgTm90ZSB0aGF0IHRoaXMgZG9lc24ndCB3b3JrXG4gKiBmb3IgZm9udCBmYW1pbGllcyB0aGF0IGhhdmUgY29tbWFzIGluIHRoZW0uXG4gKiBAcGFyYW0ge3N0cmluZ30gVGhlIENTUyBmb250IHByb3BlcnR5LlxuICogQHJldHVybiB7T2JqZWN0PHN0cmluZz59IFRoZSBmb250IGZhbWlsaWVzIChvciBudWxsIGlmIHRoZSBpbnB1dCBzcGVjIGlzIGludmFsaWQpLlxuICovXG5leHBvcnQgdmFyIGdldEZvbnRGYW1pbGllcyA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHN0eWxlO1xuICB2YXIgY2FjaGUgPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGZvbnQpIHtcbiAgICBpZiAoIXN0eWxlKSB7XG4gICAgICBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xuICAgIH1cbiAgICBpZiAoIShmb250IGluIGNhY2hlKSkge1xuICAgICAgc3R5bGUuZm9udCA9IGZvbnQ7XG4gICAgICB2YXIgZmFtaWx5ID0gc3R5bGUuZm9udEZhbWlseTtcbiAgICAgIHN0eWxlLmZvbnQgPSAnJztcbiAgICAgIGlmICghZmFtaWx5KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY2FjaGVbZm9udF0gPSBmYW1pbHkuc3BsaXQoLyxcXHM/Lyk7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZVtmb250XTtcbiAgfTtcbn0pKCk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNzcy5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvZG9tXG4gKi9cblxuXG4vKipcbiAqIENyZWF0ZSBhbiBodG1sIGNhbnZhcyBlbGVtZW50IGFuZCByZXR1cm5zIGl0cyAyZCBjb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfd2lkdGggQ2FudmFzIHdpZHRoLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfaGVpZ2h0IENhbnZhcyBoZWlnaHQuXG4gKiBAcmV0dXJuIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IFRoZSBjb250ZXh0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2FudmFzQ29udGV4dDJEKG9wdF93aWR0aCwgb3B0X2hlaWdodCkge1xuICB2YXIgY2FudmFzID0gLyoqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudH0gKi8gKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpKTtcbiAgaWYgKG9wdF93aWR0aCkge1xuICAgIGNhbnZhcy53aWR0aCA9IG9wdF93aWR0aDtcbiAgfVxuICBpZiAob3B0X2hlaWdodCkge1xuICAgIGNhbnZhcy5oZWlnaHQgPSBvcHRfaGVpZ2h0O1xuICB9XG4gIHJldHVybiAvKiogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gKi8gKGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpKTtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBjb21wdXRlZCB3aWR0aCBmb3IgdGhlIGdpdmVuIGVsZW1lbnQgaW5jbHVkaW5nIG1hcmdpbixcbiAqIHBhZGRpbmcgYW5kIGJvcmRlci5cbiAqIEVxdWl2YWxlbnQgdG8galF1ZXJ5J3MgYCQoZWwpLm91dGVyV2lkdGgodHJ1ZSlgLlxuICogQHBhcmFtIHshSFRNTEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHdpZHRoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gb3V0ZXJXaWR0aChlbGVtZW50KSB7XG4gIHZhciB3aWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIHdpZHRoICs9IHBhcnNlSW50KHN0eWxlLm1hcmdpbkxlZnQsIDEwKSArIHBhcnNlSW50KHN0eWxlLm1hcmdpblJpZ2h0LCAxMCk7XG5cbiAgcmV0dXJuIHdpZHRoO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IGNvbXB1dGVkIGhlaWdodCBmb3IgdGhlIGdpdmVuIGVsZW1lbnQgaW5jbHVkaW5nIG1hcmdpbixcbiAqIHBhZGRpbmcgYW5kIGJvcmRlci5cbiAqIEVxdWl2YWxlbnQgdG8galF1ZXJ5J3MgYCQoZWwpLm91dGVySGVpZ2h0KHRydWUpYC5cbiAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBoZWlnaHQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvdXRlckhlaWdodChlbGVtZW50KSB7XG4gIHZhciBoZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgaGVpZ2h0ICs9IHBhcnNlSW50KHN0eWxlLm1hcmdpblRvcCwgMTApICsgcGFyc2VJbnQoc3R5bGUubWFyZ2luQm90dG9tLCAxMCk7XG5cbiAgcmV0dXJuIGhlaWdodDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5ld05vZGUgTm9kZSB0byByZXBsYWNlIG9sZCBub2RlXG4gKiBAcGFyYW0ge05vZGV9IG9sZE5vZGUgVGhlIG5vZGUgdG8gYmUgcmVwbGFjZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlcGxhY2VOb2RlKG5ld05vZGUsIG9sZE5vZGUpIHtcbiAgdmFyIHBhcmVudCA9IG9sZE5vZGUucGFyZW50Tm9kZTtcbiAgaWYgKHBhcmVudCkge1xuICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQobmV3Tm9kZSwgb2xkTm9kZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIG5vZGUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge05vZGV9IFRoZSBub2RlIHRoYXQgd2FzIHJlbW92ZWQgb3IgbnVsbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZU5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSAmJiBub2RlLnBhcmVudE5vZGUgPyBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSkgOiBudWxsO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUaGUgbm9kZSB0byByZW1vdmUgdGhlIGNoaWxkcmVuIGZyb20uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVDaGlsZHJlbihub2RlKSB7XG4gIHdoaWxlIChub2RlLmxhc3RDaGlsZCkge1xuICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5sYXN0Q2hpbGQpO1xuICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRvbS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvZWFzaW5nXG4gKi9cblxuXG4vKipcbiAqIFN0YXJ0IHNsb3cgYW5kIHNwZWVkIHVwLlxuICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWFzZUluKHQpIHtcbiAgcmV0dXJuIE1hdGgucG93KHQsIDMpO1xufVxuXG5cbi8qKlxuICogU3RhcnQgZmFzdCBhbmQgc2xvdyBkb3duLlxuICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWFzZU91dCh0KSB7XG4gIHJldHVybiAxIC0gZWFzZUluKDEgLSB0KTtcbn1cblxuXG4vKipcbiAqIFN0YXJ0IHNsb3csIHNwZWVkIHVwLCBhbmQgdGhlbiBzbG93IGRvd24gYWdhaW4uXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbkFuZE91dCh0KSB7XG4gIHJldHVybiAzICogdCAqIHQgLSAyICogdCAqIHQgKiB0O1xufVxuXG5cbi8qKlxuICogTWFpbnRhaW4gYSBjb25zdGFudCBzcGVlZCBvdmVyIHRpbWUuXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXIodCkge1xuICByZXR1cm4gdDtcbn1cblxuXG4vKipcbiAqIFN0YXJ0IHNsb3csIHNwZWVkIHVwLCBhbmQgYXQgdGhlIHZlcnkgZW5kIHNsb3cgZG93biBhZ2Fpbi4gIFRoaXMgaGFzIHRoZVxuICogc2FtZSBnZW5lcmFsIGJlaGF2aW9yIGFzIHtAbGluayBtb2R1bGU6b2wvZWFzaW5nfmluQW5kT3V0fSwgYnV0IHRoZSBmaW5hbFxuICogc2xvd2Rvd24gaXMgZGVsYXllZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEByZXR1cm4ge251bWJlcn0gT3V0cHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwQW5kRG93bih0KSB7XG4gIGlmICh0IDwgMC41KSB7XG4gICAgcmV0dXJuIGluQW5kT3V0KDIgKiB0KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMSAtIGluQW5kT3V0KDIgKiAodCAtIDAuNSkpO1xuICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVhc2luZy5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvZXZlbnRzXG4gKi9cbmltcG9ydCB7Y2xlYXJ9IGZyb20gJy4vb2JqLmpzJztcblxuXG4vKipcbiAqIEtleSB0byB1c2Ugd2l0aCB7QGxpbmsgbW9kdWxlOm9sL09ic2VydmFibGV+T2JzZXJ2YWJsZSN1bkJ5S2V5fS5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IEV2ZW50c0tleVxuICogQHByb3BlcnR5IHtPYmplY3R9IFtiaW5kVG9dXG4gKiBAcHJvcGVydHkge0xpc3RlbmVyRnVuY3Rpb259IFtib3VuZExpc3RlbmVyXVxuICogQHByb3BlcnR5IHtib29sZWFufSBjYWxsT25jZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkZWxldGVJbmRleF1cbiAqIEBwcm9wZXJ0eSB7TGlzdGVuZXJGdW5jdGlvbn0gbGlzdGVuZXJcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9ldmVudHMvVGFyZ2V0LmpzXCIpLkV2ZW50VGFyZ2V0TGlrZX0gdGFyZ2V0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZVxuICogQGFwaVxuICovXG5cblxuLyoqXG4gKiBMaXN0ZW5lciBmdW5jdGlvbi4gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBhbiBldmVudCBvYmplY3QgYXMgYXJndW1lbnQuXG4gKiBXaGVuIHRoZSBmdW5jdGlvbiByZXR1cm5zIGBmYWxzZWAsIGV2ZW50IHByb3BhZ2F0aW9uIHdpbGwgc3RvcC5cbiAqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oKEV2ZW50fGltcG9ydChcIi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHQpKTogKHZvaWR8Ym9vbGVhbil9IExpc3RlbmVyRnVuY3Rpb25cbiAqIEBhcGlcbiAqL1xuXG5cbi8qKlxuICogQHBhcmFtIHtFdmVudHNLZXl9IGxpc3RlbmVyT2JqIExpc3RlbmVyIG9iamVjdC5cbiAqIEByZXR1cm4ge0xpc3RlbmVyRnVuY3Rpb259IEJvdW5kIGxpc3RlbmVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZExpc3RlbmVyKGxpc3RlbmVyT2JqKSB7XG4gIHZhciBib3VuZExpc3RlbmVyID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJPYmoubGlzdGVuZXI7XG4gICAgdmFyIGJpbmRUbyA9IGxpc3RlbmVyT2JqLmJpbmRUbyB8fCBsaXN0ZW5lck9iai50YXJnZXQ7XG4gICAgaWYgKGxpc3RlbmVyT2JqLmNhbGxPbmNlKSB7XG4gICAgICB1bmxpc3RlbkJ5S2V5KGxpc3RlbmVyT2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3RlbmVyLmNhbGwoYmluZFRvLCBldnQpO1xuICB9O1xuICBsaXN0ZW5lck9iai5ib3VuZExpc3RlbmVyID0gYm91bmRMaXN0ZW5lcjtcbiAgcmV0dXJuIGJvdW5kTGlzdGVuZXI7XG59XG5cblxuLyoqXG4gKiBGaW5kcyB0aGUgbWF0Y2hpbmcge0BsaW5rIG1vZHVsZTpvbC9ldmVudHN+RXZlbnRzS2V5fSBpbiB0aGUgZ2l2ZW4gbGlzdGVuZXJcbiAqIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7IUFycmF5PCFFdmVudHNLZXk+fSBsaXN0ZW5lcnMgQXJyYXkgb2YgbGlzdGVuZXJzLlxuICogQHBhcmFtIHshRnVuY3Rpb259IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X3RoaXMgVGhlIGB0aGlzYCB2YWx1ZSBpbnNpZGUgdGhlIGxpc3RlbmVyLlxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3NldERlbGV0ZUluZGV4IFNldCB0aGUgZGVsZXRlSW5kZXggb24gdGhlIG1hdGNoaW5nXG4gKiAgICAgbGlzdGVuZXIsIGZvciB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50c351bmxpc3RlbkJ5S2V5fS5cbiAqIEByZXR1cm4ge0V2ZW50c0tleXx1bmRlZmluZWR9IFRoZSBtYXRjaGluZyBsaXN0ZW5lciBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kTGlzdGVuZXIobGlzdGVuZXJzLCBsaXN0ZW5lciwgb3B0X3RoaXMsIG9wdF9zZXREZWxldGVJbmRleCkge1xuICB2YXIgbGlzdGVuZXJPYmo7XG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgbGlzdGVuZXJPYmogPSBsaXN0ZW5lcnNbaV07XG4gICAgaWYgKGxpc3RlbmVyT2JqLmxpc3RlbmVyID09PSBsaXN0ZW5lciAmJlxuICAgICAgICBsaXN0ZW5lck9iai5iaW5kVG8gPT09IG9wdF90aGlzKSB7XG4gICAgICBpZiAob3B0X3NldERlbGV0ZUluZGV4KSB7XG4gICAgICAgIGxpc3RlbmVyT2JqLmRlbGV0ZUluZGV4ID0gaTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaXN0ZW5lck9iajtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9ldmVudHMvVGFyZ2V0LmpzXCIpLkV2ZW50VGFyZ2V0TGlrZX0gdGFyZ2V0IFRhcmdldC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFR5cGUuXG4gKiBAcmV0dXJuIHtBcnJheTxFdmVudHNLZXk+fHVuZGVmaW5lZH0gTGlzdGVuZXJzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGlzdGVuZXJzKHRhcmdldCwgdHlwZSkge1xuICB2YXIgbGlzdGVuZXJNYXAgPSBnZXRMaXN0ZW5lck1hcCh0YXJnZXQpO1xuICByZXR1cm4gbGlzdGVuZXJNYXAgPyBsaXN0ZW5lck1hcFt0eXBlXSA6IHVuZGVmaW5lZDtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgbG9va3VwIG9mIGxpc3RlbmVycy5cbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGFyZ2V0LlxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X2NyZWF0ZSBJZiBhIG1hcCBzaG91bGQgYmUgY3JlYXRlZCBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuICogQHJldHVybiB7IU9iamVjdDxzdHJpbmcsIEFycmF5PEV2ZW50c0tleT4+fSBNYXAgb2ZcbiAqICAgICBsaXN0ZW5lcnMgYnkgZXZlbnQgdHlwZS5cbiAqL1xuZnVuY3Rpb24gZ2V0TGlzdGVuZXJNYXAodGFyZ2V0LCBvcHRfY3JlYXRlKSB7XG4gIHZhciBsaXN0ZW5lck1hcCA9IHRhcmdldC5vbF9sbTtcbiAgaWYgKCFsaXN0ZW5lck1hcCAmJiBvcHRfY3JlYXRlKSB7XG4gICAgbGlzdGVuZXJNYXAgPSB0YXJnZXQub2xfbG0gPSB7fTtcbiAgfVxuICByZXR1cm4gbGlzdGVuZXJNYXA7XG59XG5cblxuLyoqXG4gKiBSZW1vdmUgdGhlIGxpc3RlbmVyIG1hcCBmcm9tIGEgdGFyZ2V0LlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUYXJnZXQuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyTWFwKHRhcmdldCkge1xuICBkZWxldGUgdGFyZ2V0Lm9sX2xtO1xufVxuXG5cbi8qKlxuICogQ2xlYW4gdXAgYWxsIGxpc3RlbmVyIG9iamVjdHMgb2YgdGhlIGdpdmVuIHR5cGUuICBBbGwgcHJvcGVydGllcyBvbiB0aGVcbiAqIGxpc3RlbmVyIG9iamVjdHMgd2lsbCBiZSByZW1vdmVkLCBhbmQgaWYgbm8gbGlzdGVuZXJzIHJlbWFpbiBpbiB0aGUgbGlzdGVuZXJcbiAqIG1hcCwgaXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIHRhcmdldC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9ldmVudHMvVGFyZ2V0LmpzXCIpLkV2ZW50VGFyZ2V0TGlrZX0gdGFyZ2V0IFRhcmdldC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFR5cGUuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVycyh0YXJnZXQsIHR5cGUpIHtcbiAgdmFyIGxpc3RlbmVycyA9IGdldExpc3RlbmVycyh0YXJnZXQsIHR5cGUpO1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9ldmVudHMvVGFyZ2V0LmpzXCIpLmRlZmF1bHR9ICovICh0YXJnZXQpLlxuICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXS5ib3VuZExpc3RlbmVyKTtcbiAgICAgIGNsZWFyKGxpc3RlbmVyc1tpXSk7XG4gICAgfVxuICAgIGxpc3RlbmVycy5sZW5ndGggPSAwO1xuICAgIHZhciBsaXN0ZW5lck1hcCA9IGdldExpc3RlbmVyTWFwKHRhcmdldCk7XG4gICAgaWYgKGxpc3RlbmVyTWFwKSB7XG4gICAgICBkZWxldGUgbGlzdGVuZXJNYXBbdHlwZV07XG4gICAgICBpZiAoT2JqZWN0LmtleXMobGlzdGVuZXJNYXApLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZW1vdmVMaXN0ZW5lck1hcCh0YXJnZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5cbi8qKlxuICogUmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyIG9uIGFuIGV2ZW50IHRhcmdldC4gSW5zcGlyZWQgYnlcbiAqIGh0dHBzOi8vZ29vZ2xlLmdpdGh1Yi5pby9jbG9zdXJlLWxpYnJhcnkvYXBpL3NvdXJjZS9jbG9zdXJlL2dvb2cvZXZlbnRzL2V2ZW50cy5qcy5zcmMuaHRtbFxuICpcbiAqIFRoaXMgZnVuY3Rpb24gZWZmaWNpZW50bHkgYmluZHMgYSBgbGlzdGVuZXJgIHRvIGEgYHRoaXNgIG9iamVjdCwgYW5kIHJldHVybnNcbiAqIGEga2V5IGZvciB1c2Ugd2l0aCB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50c351bmxpc3RlbkJ5S2V5fS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXZlbnRzL1RhcmdldC5qc1wiKS5FdmVudFRhcmdldExpa2V9IHRhcmdldCBFdmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlLlxuICogQHBhcmFtIHtMaXN0ZW5lckZ1bmN0aW9ufSBsaXN0ZW5lciBMaXN0ZW5lci5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X3RoaXMgT2JqZWN0IHJlZmVyZW5jZWQgYnkgdGhlIGB0aGlzYCBrZXl3b3JkIGluIHRoZVxuICogICAgIGxpc3RlbmVyLiBEZWZhdWx0IGlzIHRoZSBgdGFyZ2V0YC5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9vbmNlIElmIHRydWUsIGFkZCB0aGUgbGlzdGVuZXIgYXMgb25lLW9mZiBsaXN0ZW5lci5cbiAqIEByZXR1cm4ge0V2ZW50c0tleX0gVW5pcXVlIGtleSBmb3IgdGhlIGxpc3RlbmVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIG9wdF90aGlzLCBvcHRfb25jZSkge1xuICB2YXIgbGlzdGVuZXJNYXAgPSBnZXRMaXN0ZW5lck1hcCh0YXJnZXQsIHRydWUpO1xuICB2YXIgbGlzdGVuZXJzID0gbGlzdGVuZXJNYXBbdHlwZV07XG4gIGlmICghbGlzdGVuZXJzKSB7XG4gICAgbGlzdGVuZXJzID0gbGlzdGVuZXJNYXBbdHlwZV0gPSBbXTtcbiAgfVxuICB2YXIgbGlzdGVuZXJPYmogPSBmaW5kTGlzdGVuZXIobGlzdGVuZXJzLCBsaXN0ZW5lciwgb3B0X3RoaXMsIGZhbHNlKTtcbiAgaWYgKGxpc3RlbmVyT2JqKSB7XG4gICAgaWYgKCFvcHRfb25jZSkge1xuICAgICAgLy8gVHVybiBvbmUtb2ZmIGxpc3RlbmVyIGludG8gYSBwZXJtYW5lbnQgb25lLlxuICAgICAgbGlzdGVuZXJPYmouY2FsbE9uY2UgPSBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGlzdGVuZXJPYmogPSAvKiogQHR5cGUge0V2ZW50c0tleX0gKi8gKHtcbiAgICAgIGJpbmRUbzogb3B0X3RoaXMsXG4gICAgICBjYWxsT25jZTogISFvcHRfb25jZSxcbiAgICAgIGxpc3RlbmVyOiBsaXN0ZW5lcixcbiAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgdHlwZTogdHlwZVxuICAgIH0pO1xuICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9ldmVudHMvVGFyZ2V0LmpzXCIpLmRlZmF1bHR9ICovICh0YXJnZXQpLlxuICAgICAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBiaW5kTGlzdGVuZXIobGlzdGVuZXJPYmopKTtcbiAgICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lck9iaik7XG4gIH1cblxuICByZXR1cm4gbGlzdGVuZXJPYmo7XG59XG5cblxuLyoqXG4gKiBSZWdpc3RlcnMgYSBvbmUtb2ZmIGV2ZW50IGxpc3RlbmVyIG9uIGFuIGV2ZW50IHRhcmdldC4gSW5zcGlyZWQgYnlcbiAqIGh0dHBzOi8vZ29vZ2xlLmdpdGh1Yi5pby9jbG9zdXJlLWxpYnJhcnkvYXBpL3NvdXJjZS9jbG9zdXJlL2dvb2cvZXZlbnRzL2V2ZW50cy5qcy5zcmMuaHRtbFxuICpcbiAqIFRoaXMgZnVuY3Rpb24gZWZmaWNpZW50bHkgYmluZHMgYSBgbGlzdGVuZXJgIGFzIHNlbGYtdW5yZWdpc3RlcmluZyBsaXN0ZW5lclxuICogdG8gYSBgdGhpc2Agb2JqZWN0LCBhbmQgcmV0dXJucyBhIGtleSBmb3IgdXNlIHdpdGhcbiAqIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzfnVubGlzdGVuQnlLZXl9IGluIGNhc2UgdGhlIGxpc3RlbmVyIG5lZWRzIHRvIGJlXG4gKiB1bnJlZ2lzdGVyZWQgYmVmb3JlIGl0IGlzIGNhbGxlZC5cbiAqXG4gKiBXaGVuIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzfmxpc3Rlbn0gaXMgY2FsbGVkIHdpdGggdGhlIHNhbWUgYXJndW1lbnRzIGFmdGVyIHRoaXNcbiAqIGZ1bmN0aW9uLCB0aGUgc2VsZi11bnJlZ2lzdGVyaW5nIGxpc3RlbmVyIHdpbGwgYmUgdHVybmVkIGludG8gYSBwZXJtYW5lbnRcbiAqIGxpc3RlbmVyLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9ldmVudHMvVGFyZ2V0LmpzXCIpLkV2ZW50VGFyZ2V0TGlrZX0gdGFyZ2V0IEV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEV2ZW50IHR5cGUuXG4gKiBAcGFyYW0ge0xpc3RlbmVyRnVuY3Rpb259IGxpc3RlbmVyIExpc3RlbmVyLlxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfdGhpcyBPYmplY3QgcmVmZXJlbmNlZCBieSB0aGUgYHRoaXNgIGtleXdvcmQgaW4gdGhlXG4gKiAgICAgbGlzdGVuZXIuIERlZmF1bHQgaXMgdGhlIGB0YXJnZXRgLlxuICogQHJldHVybiB7RXZlbnRzS2V5fSBLZXkgZm9yIHVubGlzdGVuQnlLZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaXN0ZW5PbmNlKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIG9wdF90aGlzKSB7XG4gIHJldHVybiBsaXN0ZW4odGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgb3B0X3RoaXMsIHRydWUpO1xufVxuXG5cbi8qKlxuICogVW5yZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgb24gYW4gZXZlbnQgdGFyZ2V0LiBJbnNwaXJlZCBieVxuICogaHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2Nsb3N1cmUtbGlicmFyeS9hcGkvc291cmNlL2Nsb3N1cmUvZ29vZy9ldmVudHMvZXZlbnRzLmpzLnNyYy5odG1sXG4gKlxuICogVG8gcmV0dXJuIGEgbGlzdGVuZXIsIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgY2FsbGVkIHdpdGggdGhlIGV4YWN0IHNhbWVcbiAqIGFyZ3VtZW50cyB0aGF0IHdlcmUgdXNlZCBmb3IgYSBwcmV2aW91cyB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50c35saXN0ZW59IGNhbGwuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V2ZW50cy9UYXJnZXQuanNcIikuRXZlbnRUYXJnZXRMaWtlfSB0YXJnZXQgRXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZS5cbiAqIEBwYXJhbSB7TGlzdGVuZXJGdW5jdGlvbn0gbGlzdGVuZXIgTGlzdGVuZXIuXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdF90aGlzIE9iamVjdCByZWZlcmVuY2VkIGJ5IHRoZSBgdGhpc2Aga2V5d29yZCBpbiB0aGVcbiAqICAgICBsaXN0ZW5lci4gRGVmYXVsdCBpcyB0aGUgYHRhcmdldGAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bmxpc3Rlbih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBvcHRfdGhpcykge1xuICB2YXIgbGlzdGVuZXJzID0gZ2V0TGlzdGVuZXJzKHRhcmdldCwgdHlwZSk7XG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICB2YXIgbGlzdGVuZXJPYmogPSBmaW5kTGlzdGVuZXIobGlzdGVuZXJzLCBsaXN0ZW5lciwgb3B0X3RoaXMsIHRydWUpO1xuICAgIGlmIChsaXN0ZW5lck9iaikge1xuICAgICAgdW5saXN0ZW5CeUtleShsaXN0ZW5lck9iaik7XG4gICAgfVxuICB9XG59XG5cblxuLyoqXG4gKiBVbnJlZ2lzdGVycyBldmVudCBsaXN0ZW5lcnMgb24gYW4gZXZlbnQgdGFyZ2V0LiBJbnNwaXJlZCBieVxuICogaHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2Nsb3N1cmUtbGlicmFyeS9hcGkvc291cmNlL2Nsb3N1cmUvZ29vZy9ldmVudHMvZXZlbnRzLmpzLnNyYy5odG1sXG4gKlxuICogVGhlIGFyZ3VtZW50IHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uIGlzIHRoZSBrZXkgcmV0dXJuZWQgZnJvbVxuICoge0BsaW5rIG1vZHVsZTpvbC9ldmVudHN+bGlzdGVufSBvciB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50c35saXN0ZW5PbmNlfS5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50c0tleX0ga2V5IFRoZSBrZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bmxpc3RlbkJ5S2V5KGtleSkge1xuICBpZiAoa2V5ICYmIGtleS50YXJnZXQpIHtcbiAgICAvKiogQHR5cGUge2ltcG9ydChcIi4vZXZlbnRzL1RhcmdldC5qc1wiKS5kZWZhdWx0fSAqLyAoa2V5LnRhcmdldCkuXG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKGtleS50eXBlLCBrZXkuYm91bmRMaXN0ZW5lcik7XG4gICAgdmFyIGxpc3RlbmVycyA9IGdldExpc3RlbmVycyhrZXkudGFyZ2V0LCBrZXkudHlwZSk7XG4gICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgdmFyIGkgPSAnZGVsZXRlSW5kZXgnIGluIGtleSA/IGtleS5kZWxldGVJbmRleCA6IGxpc3RlbmVycy5pbmRleE9mKGtleSk7XG4gICAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChsaXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJlbW92ZUxpc3RlbmVycyhrZXkudGFyZ2V0LCBrZXkudHlwZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNsZWFyKGtleSk7XG4gIH1cbn1cblxuXG4vKipcbiAqIFVucmVnaXN0ZXJzIGFsbCBldmVudCBsaXN0ZW5lcnMgb24gYW4gZXZlbnQgdGFyZ2V0LiBJbnNwaXJlZCBieVxuICogaHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2Nsb3N1cmUtbGlicmFyeS9hcGkvc291cmNlL2Nsb3N1cmUvZ29vZy9ldmVudHMvZXZlbnRzLmpzLnNyYy5odG1sXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V2ZW50cy9UYXJnZXQuanNcIikuRXZlbnRUYXJnZXRMaWtlfSB0YXJnZXQgVGFyZ2V0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5saXN0ZW5BbGwodGFyZ2V0KSB7XG4gIHZhciBsaXN0ZW5lck1hcCA9IGdldExpc3RlbmVyTWFwKHRhcmdldCk7XG4gIGlmIChsaXN0ZW5lck1hcCkge1xuICAgIGZvciAodmFyIHR5cGUgaW4gbGlzdGVuZXJNYXApIHtcbiAgICAgIHJlbW92ZUxpc3RlbmVycyh0YXJnZXQsIHR5cGUpO1xuICAgIH1cbiAgfVxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldmVudHMuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2V2ZW50cy9FdmVudFxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogU3RyaXBwZWQgZG93biBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgVzNDIERPTSBMZXZlbCAyIEV2ZW50IGludGVyZmFjZS5cbiAqIFNlZSBodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTItRXZlbnRzL2V2ZW50cy5odG1sI0V2ZW50cy1pbnRlcmZhY2UuXG4gKlxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiBvbmx5IHByb3ZpZGVzIGB0eXBlYCBhbmQgYHRhcmdldGAgcHJvcGVydGllcywgYW5kXG4gKiBgc3RvcFByb3BhZ2F0aW9uYCBhbmQgYHByZXZlbnREZWZhdWx0YCBtZXRob2RzLiBJdCBpcyBtZWFudCBhcyBiYXNlIGNsYXNzXG4gKiBmb3IgaGlnaGVyIGxldmVsIGV2ZW50cyBkZWZpbmVkIGluIHRoZSBsaWJyYXJ5LCBhbmQgd29ya3Mgd2l0aFxuICoge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvVGFyZ2V0flRhcmdldH0uXG4gKi9cbnZhciBFdmVudCA9IGZ1bmN0aW9uIEV2ZW50KHR5cGUpIHtcblxuICAvKipcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICB0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZDtcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHR5cGUuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBhcGlcbiAgICovXG4gIHRoaXMudHlwZSA9IHR5cGU7XG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCB0YXJnZXQuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBhcGlcbiAgICovXG4gIHRoaXMudGFyZ2V0ID0gbnVsbDtcbn07XG5cbi8qKlxuICogU3RvcCBldmVudCBwcm9wYWdhdGlvbi5cbiAqIEBhcGlcbiAqL1xuRXZlbnQucHJvdG90eXBlLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gcHJldmVudERlZmF1bHQgKCkge1xuICB0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XG59O1xuXG4vKipcbiAqIFN0b3AgZXZlbnQgcHJvcGFnYXRpb24uXG4gKiBAYXBpXG4gKi9cbkV2ZW50LnByb3RvdHlwZS5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24gKCkge1xuICB0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHtFdmVudHxpbXBvcnQoXCIuL0V2ZW50LmpzXCIpLmRlZmF1bHR9IGV2dCBFdmVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKGV2dCkge1xuICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0V2ZW50fGltcG9ydChcIi4vRXZlbnQuanNcIikuZGVmYXVsdH0gZXZ0IEV2ZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldnQpIHtcbiAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IEV2ZW50O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1FdmVudC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvZXZlbnRzL0V2ZW50VHlwZVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqIEBjb25zdFxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIC8qKlxuICAgKiBHZW5lcmljIGNoYW5nZSBldmVudC4gVHJpZ2dlcmVkIHdoZW4gdGhlIHJldmlzaW9uIGNvdW50ZXIgaXMgaW5jcmVhc2VkLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL2V2ZW50cy9FdmVudH5FdmVudCNjaGFuZ2VcbiAgICogQGFwaVxuICAgKi9cbiAgQ0hBTkdFOiAnY2hhbmdlJyxcblxuICBDTEVBUjogJ2NsZWFyJyxcbiAgQ09OVEVYVE1FTlU6ICdjb250ZXh0bWVudScsXG4gIENMSUNLOiAnY2xpY2snLFxuICBEQkxDTElDSzogJ2RibGNsaWNrJyxcbiAgRFJBR0VOVEVSOiAnZHJhZ2VudGVyJyxcbiAgRFJBR09WRVI6ICdkcmFnb3ZlcicsXG4gIERST1A6ICdkcm9wJyxcbiAgRVJST1I6ICdlcnJvcicsXG4gIEtFWURPV046ICdrZXlkb3duJyxcbiAgS0VZUFJFU1M6ICdrZXlwcmVzcycsXG4gIExPQUQ6ICdsb2FkJyxcbiAgTU9VU0VET1dOOiAnbW91c2Vkb3duJyxcbiAgTU9VU0VNT1ZFOiAnbW91c2Vtb3ZlJyxcbiAgTU9VU0VPVVQ6ICdtb3VzZW91dCcsXG4gIE1PVVNFVVA6ICdtb3VzZXVwJyxcbiAgTU9VU0VXSEVFTDogJ21vdXNld2hlZWwnLFxuICBNU1BPSU5URVJET1dOOiAnTVNQb2ludGVyRG93bicsXG4gIFJFU0laRTogJ3Jlc2l6ZScsXG4gIFRPVUNIU1RBUlQ6ICd0b3VjaHN0YXJ0JyxcbiAgVE9VQ0hNT1ZFOiAndG91Y2htb3ZlJyxcbiAgVE9VQ0hFTkQ6ICd0b3VjaGVuZCcsXG4gIFdIRUVMOiAnd2hlZWwnXG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1FdmVudFR5cGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2V2ZW50cy9LZXlDb2RlXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7bnVtYmVyfVxuICogQGNvbnN0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgTEVGVDogMzcsXG4gIFVQOiAzOCxcbiAgUklHSFQ6IDM5LFxuICBET1dOOiA0MFxufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9S2V5Q29kZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvZXZlbnRzL1RhcmdldFxuICovXG5pbXBvcnQgRGlzcG9zYWJsZSBmcm9tICcuLi9EaXNwb3NhYmxlLmpzJztcbmltcG9ydCB7dW5saXN0ZW5BbGx9IGZyb20gJy4uL2V2ZW50cy5qcyc7XG5pbXBvcnQge1ZPSUR9IGZyb20gJy4uL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi9FdmVudC5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7RXZlbnRUYXJnZXR8VGFyZ2V0fSBFdmVudFRhcmdldExpa2VcbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQSBzaW1wbGlmaWVkIGltcGxlbWVudGF0aW9uIG9mIHRoZSBXM0MgRE9NIExldmVsIDIgRXZlbnRUYXJnZXQgaW50ZXJmYWNlLlxuICogU2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDAwL1JFQy1ET00tTGV2ZWwtMi1FdmVudHMtMjAwMDExMTMvZXZlbnRzLmh0bWwjRXZlbnRzLUV2ZW50VGFyZ2V0LlxuICpcbiAqIFRoZXJlIGFyZSB0d28gaW1wb3J0YW50IHNpbXBsaWZpY2F0aW9ucyBjb21wYXJlZCB0byB0aGUgc3BlY2lmaWNhdGlvbjpcbiAqXG4gKiAxLiBUaGUgaGFuZGxpbmcgb2YgYHVzZUNhcHR1cmVgIGluIGBhZGRFdmVudExpc3RlbmVyYCBhbmRcbiAqICAgIGByZW1vdmVFdmVudExpc3RlbmVyYC4gVGhlcmUgaXMgbm8gcmVhbCBjYXB0dXJlIG1vZGVsLlxuICogMi4gVGhlIGhhbmRsaW5nIG9mIGBzdG9wUHJvcGFnYXRpb25gIGFuZCBgcHJldmVudERlZmF1bHRgIG9uIGBkaXNwYXRjaEV2ZW50YC5cbiAqICAgIFRoZXJlIGlzIG5vIGV2ZW50IHRhcmdldCBoaWVyYXJjaHkuIFdoZW4gYSBsaXN0ZW5lciBjYWxsc1xuICogICAgYHN0b3BQcm9wYWdhdGlvbmAgb3IgYHByZXZlbnREZWZhdWx0YCBvbiBhbiBldmVudCBvYmplY3QsIGl0IG1lYW5zIHRoYXQgbm9cbiAqICAgIG1vcmUgbGlzdGVuZXJzIGFmdGVyIHRoaXMgb25lIHdpbGwgYmUgY2FsbGVkLiBTYW1lIGFzIHdoZW4gdGhlIGxpc3RlbmVyXG4gKiAgICByZXR1cm5zIGZhbHNlLlxuICovXG52YXIgVGFyZ2V0ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoRGlzcG9zYWJsZSkge1xuICBmdW5jdGlvbiBUYXJnZXQoKSB7XG5cbiAgICBEaXNwb3NhYmxlLmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgbnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLnBlbmRpbmdSZW1vdmFsc18gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMuZGlzcGF0Y2hpbmdfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgQXJyYXk8aW1wb3J0KFwiLi4vZXZlbnRzLmpzXCIpLkxpc3RlbmVyRnVuY3Rpb24+Pn1cbiAgICAgKi9cbiAgICB0aGlzLmxpc3RlbmVyc18gPSB7fTtcblxuICB9XG5cbiAgaWYgKCBEaXNwb3NhYmxlICkgVGFyZ2V0Ll9fcHJvdG9fXyA9IERpc3Bvc2FibGU7XG4gIFRhcmdldC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBEaXNwb3NhYmxlICYmIERpc3Bvc2FibGUucHJvdG90eXBlICk7XG4gIFRhcmdldC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUYXJnZXQ7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFR5cGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXZlbnRzLmpzXCIpLkxpc3RlbmVyRnVuY3Rpb259IGxpc3RlbmVyIExpc3RlbmVyLlxuICAgKi9cbiAgVGFyZ2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lciAodHlwZSwgbGlzdGVuZXIpIHtcbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnNfW3R5cGVdO1xuICAgIGlmICghbGlzdGVuZXJzKSB7XG4gICAgICBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVyc19bdHlwZV0gPSBbXTtcbiAgICB9XG4gICAgaWYgKGxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKSA9PT0gLTEpIHtcbiAgICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMgYW4gZXZlbnQgYW5kIGNhbGxzIGFsbCBsaXN0ZW5lcnMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICogb2YgdGhpcyB0eXBlLiBUaGUgZXZlbnQgcGFyYW1ldGVyIGNhbiBlaXRoZXIgYmUgYSBzdHJpbmcgb3IgYW5cbiAgICogT2JqZWN0IHdpdGggYSBgdHlwZWAgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7e3R5cGU6IHN0cmluZyxcbiAgICogICAgIHRhcmdldDogKEV2ZW50VGFyZ2V0TGlrZXx1bmRlZmluZWQpLFxuICAgKiAgICAgcHJvcGFnYXRpb25TdG9wcGVkOiAoYm9vbGVhbnx1bmRlZmluZWQpfXxcbiAgICogICAgIGltcG9ydChcIi4vRXZlbnQuanNcIikuZGVmYXVsdHxzdHJpbmd9IGV2ZW50IEV2ZW50IG9iamVjdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbnx1bmRlZmluZWR9IGBmYWxzZWAgaWYgYW55b25lIGNhbGxlZCBwcmV2ZW50RGVmYXVsdCBvbiB0aGVcbiAgICogICAgIGV2ZW50IG9iamVjdCBvciBpZiBhbnkgb2YgdGhlIGxpc3RlbmVycyByZXR1cm5lZCBmYWxzZS5cbiAgICogQGFwaVxuICAgKi9cbiAgVGFyZ2V0LnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24gZGlzcGF0Y2hFdmVudCAoZXZlbnQpIHtcbiAgICB2YXIgZXZ0ID0gdHlwZW9mIGV2ZW50ID09PSAnc3RyaW5nJyA/IG5ldyBFdmVudChldmVudCkgOiBldmVudDtcbiAgICB2YXIgdHlwZSA9IGV2dC50eXBlO1xuICAgIGV2dC50YXJnZXQgPSB0aGlzO1xuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVyc19bdHlwZV07XG4gICAgdmFyIHByb3BhZ2F0ZTtcbiAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICBpZiAoISh0eXBlIGluIHRoaXMuZGlzcGF0Y2hpbmdfKSkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoaW5nX1t0eXBlXSA9IDA7XG4gICAgICAgIHRoaXMucGVuZGluZ1JlbW92YWxzX1t0eXBlXSA9IDA7XG4gICAgICB9XG4gICAgICArK3RoaXMuZGlzcGF0Y2hpbmdfW3R5cGVdO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgaWYgKGxpc3RlbmVyc1tpXS5jYWxsKHRoaXMsIGV2dCkgPT09IGZhbHNlIHx8IGV2dC5wcm9wYWdhdGlvblN0b3BwZWQpIHtcbiAgICAgICAgICBwcm9wYWdhdGUgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLS10aGlzLmRpc3BhdGNoaW5nX1t0eXBlXTtcbiAgICAgIGlmICh0aGlzLmRpc3BhdGNoaW5nX1t0eXBlXSA9PT0gMCkge1xuICAgICAgICB2YXIgcGVuZGluZ1JlbW92YWxzID0gdGhpcy5wZW5kaW5nUmVtb3ZhbHNfW3R5cGVdO1xuICAgICAgICBkZWxldGUgdGhpcy5wZW5kaW5nUmVtb3ZhbHNfW3R5cGVdO1xuICAgICAgICB3aGlsZSAocGVuZGluZ1JlbW92YWxzLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgVk9JRCk7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMuZGlzcGF0Y2hpbmdfW3R5cGVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3BhZ2F0ZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBUYXJnZXQucHJvdG90eXBlLmRpc3Bvc2VJbnRlcm5hbCA9IGZ1bmN0aW9uIGRpc3Bvc2VJbnRlcm5hbCAoKSB7XG4gICAgdW5saXN0ZW5BbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGlzdGVuZXJzIGZvciBhIHNwZWNpZmllZCBldmVudCB0eXBlLiBMaXN0ZW5lcnMgYXJlIHJldHVybmVkIGluIHRoZVxuICAgKiBvcmRlciB0aGF0IHRoZXkgd2lsbCBiZSBjYWxsZWQgaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFR5cGUuXG4gICAqIEByZXR1cm4ge0FycmF5PGltcG9ydChcIi4uL2V2ZW50cy5qc1wiKS5MaXN0ZW5lckZ1bmN0aW9uPn0gTGlzdGVuZXJzLlxuICAgKi9cbiAgVGFyZ2V0LnByb3RvdHlwZS5nZXRMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRMaXN0ZW5lcnMgKHR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lcnNfW3R5cGVdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG9wdF90eXBlIFR5cGUuIElmIG5vdCBwcm92aWRlZCxcbiAgICogICAgIGB0cnVlYCB3aWxsIGJlIHJldHVybmVkIGlmIHRoaXMgZXZlbnQgdGFyZ2V0IGhhcyBhbnkgbGlzdGVuZXJzLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBIYXMgbGlzdGVuZXJzLlxuICAgKi9cbiAgVGFyZ2V0LnByb3RvdHlwZS5oYXNMaXN0ZW5lciA9IGZ1bmN0aW9uIGhhc0xpc3RlbmVyIChvcHRfdHlwZSkge1xuICAgIHJldHVybiBvcHRfdHlwZSA/XG4gICAgICBvcHRfdHlwZSBpbiB0aGlzLmxpc3RlbmVyc18gOlxuICAgICAgT2JqZWN0LmtleXModGhpcy5saXN0ZW5lcnNfKS5sZW5ndGggPiAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUeXBlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V2ZW50cy5qc1wiKS5MaXN0ZW5lckZ1bmN0aW9ufSBsaXN0ZW5lciBMaXN0ZW5lci5cbiAgICovXG4gIFRhcmdldC5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIgKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzX1t0eXBlXTtcbiAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICB2YXIgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICBpZiAodHlwZSBpbiB0aGlzLnBlbmRpbmdSZW1vdmFsc18pIHtcbiAgICAgICAgLy8gbWFrZSBsaXN0ZW5lciBhIG5vLW9wLCBhbmQgcmVtb3ZlIGxhdGVyIGluICNkaXNwYXRjaEV2ZW50KClcbiAgICAgICAgbGlzdGVuZXJzW2luZGV4XSA9IFZPSUQ7XG4gICAgICAgICsrdGhpcy5wZW5kaW5nUmVtb3ZhbHNfW3R5cGVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGlmIChsaXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMubGlzdGVuZXJzX1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVGFyZ2V0O1xufShEaXNwb3NhYmxlKSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgVGFyZ2V0O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1UYXJnZXQuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2V2ZW50cy9jb25kaXRpb25cbiAqL1xuaW1wb3J0IE1hcEJyb3dzZXJFdmVudFR5cGUgZnJvbSAnLi4vTWFwQnJvd3NlckV2ZW50VHlwZS5qcyc7XG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi4vYXNzZXJ0cy5qcyc7XG5pbXBvcnQge1RSVUUsIEZBTFNFfSBmcm9tICcuLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IHtXRUJLSVQsIE1BQ30gZnJvbSAnLi4vaGFzLmpzJztcblxuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH0gYW5kIHJldHVybnMgYVxuICogYHtib29sZWFufWAuIElmIHRoZSBjb25kaXRpb24gaXMgbWV0LCB0cnVlIHNob3VsZCBiZSByZXR1cm5lZC5cbiAqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24odGhpczogPywgaW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHQpOiBib29sZWFufSBDb25kaXRpb25cbiAqL1xuXG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiBvbmx5IHRoZSBhbHQta2V5IGlzIHByZXNzZWQsIGBmYWxzZWAgb3RoZXJ3aXNlIChlLmcuIHdoZW5cbiAqIGFkZGl0aW9uYWxseSB0aGUgc2hpZnQta2V5IGlzIHByZXNzZWQpLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgb25seSB0aGUgYWx0IGtleSBpcyBwcmVzc2VkLlxuICogQGFwaVxuICovXG5leHBvcnQgdmFyIGFsdEtleU9ubHkgPSBmdW5jdGlvbihtYXBCcm93c2VyRXZlbnQpIHtcbiAgdmFyIG9yaWdpbmFsRXZlbnQgPSAvKiogQHR5cGUge0tleWJvYXJkRXZlbnR8TW91c2VFdmVudHxUb3VjaEV2ZW50fSAqLyAobWFwQnJvd3NlckV2ZW50Lm9yaWdpbmFsRXZlbnQpO1xuICByZXR1cm4gKFxuICAgIG9yaWdpbmFsRXZlbnQuYWx0S2V5ICYmXG4gICAgICAhKG9yaWdpbmFsRXZlbnQubWV0YUtleSB8fCBvcmlnaW5hbEV2ZW50LmN0cmxLZXkpICYmXG4gICAgICAhb3JpZ2luYWxFdmVudC5zaGlmdEtleSk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiBvbmx5IHRoZSBhbHQta2V5IGFuZCBzaGlmdC1rZXkgaXMgcHJlc3NlZCwgYGZhbHNlYCBvdGhlcndpc2VcbiAqIChlLmcuIHdoZW4gYWRkaXRpb25hbGx5IHRoZSBwbGF0Zm9ybS1tb2RpZmllci1rZXkgaXMgcHJlc3NlZCkuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBvbmx5IHRoZSBhbHQgYW5kIHNoaWZ0IGtleXMgYXJlIHByZXNzZWQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCB2YXIgYWx0U2hpZnRLZXlzT25seSA9IGZ1bmN0aW9uKG1hcEJyb3dzZXJFdmVudCkge1xuICB2YXIgb3JpZ2luYWxFdmVudCA9IC8qKiBAdHlwZSB7S2V5Ym9hcmRFdmVudHxNb3VzZUV2ZW50fFRvdWNoRXZlbnR9ICovIChtYXBCcm93c2VyRXZlbnQub3JpZ2luYWxFdmVudCk7XG4gIHJldHVybiAoXG4gICAgb3JpZ2luYWxFdmVudC5hbHRLZXkgJiZcbiAgICAgICEob3JpZ2luYWxFdmVudC5tZXRhS2V5IHx8IG9yaWdpbmFsRXZlbnQuY3RybEtleSkgJiZcbiAgICAgIG9yaWdpbmFsRXZlbnQuc2hpZnRLZXkpO1xufTtcblxuXG4vKipcbiAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIG1hcCBoYXMgdGhlIGZvY3VzLiBUaGlzIGNvbmRpdGlvbiByZXF1aXJlcyBhIG1hcCB0YXJnZXRcbiAqIGVsZW1lbnQgd2l0aCBhIGB0YWJpbmRleGAgYXR0cmlidXRlLCBlLmcuIGA8ZGl2IGlkPVwibWFwXCIgdGFiaW5kZXg9XCIxXCI+YC5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBldmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBtYXAgaGFzIHRoZSBmb2N1cy5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IHZhciBmb2N1cyA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIHJldHVybiBldmVudC50YXJnZXQuZ2V0VGFyZ2V0RWxlbWVudCgpID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xufTtcblxuXG4vKipcbiAqIFJldHVybiBhbHdheXMgdHJ1ZS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlLlxuICogQGFwaVxuICovXG5leHBvcnQgdmFyIGFsd2F5cyA9IFRSVUU7XG5cblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBldmVudCBpcyBhIGBjbGlja2AgZXZlbnQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IGlzIGEgbWFwIGBjbGlja2AgZXZlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCB2YXIgY2xpY2sgPSBmdW5jdGlvbihtYXBCcm93c2VyRXZlbnQpIHtcbiAgcmV0dXJuIG1hcEJyb3dzZXJFdmVudC50eXBlID09IE1hcEJyb3dzZXJFdmVudFR5cGUuQ0xJQ0s7XG59O1xuXG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgZXZlbnQgaGFzIGFuIFwiYWN0aW9uXCItcHJvZHVjaW5nIG1vdXNlIGJ1dHRvbi5cbiAqXG4gKiBCeSBkZWZpbml0aW9uLCB0aGlzIGluY2x1ZGVzIGxlZnQtY2xpY2sgb24gd2luZG93cy9saW51eCwgYW5kIGxlZnQtY2xpY2tcbiAqIHdpdGhvdXQgdGhlIGN0cmwga2V5IG9uIE1hY3MuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHJlc3VsdC5cbiAqL1xuZXhwb3J0IHZhciBtb3VzZUFjdGlvbkJ1dHRvbiA9IGZ1bmN0aW9uKG1hcEJyb3dzZXJFdmVudCkge1xuICB2YXIgb3JpZ2luYWxFdmVudCA9IC8qKiBAdHlwZSB7TW91c2VFdmVudH0gKi8gKG1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50KTtcbiAgcmV0dXJuIG9yaWdpbmFsRXZlbnQuYnV0dG9uID09IDAgJiZcbiAgICAgICEoV0VCS0lUICYmIE1BQyAmJiBvcmlnaW5hbEV2ZW50LmN0cmxLZXkpO1xufTtcblxuXG4vKipcbiAqIFJldHVybiBhbHdheXMgZmFsc2UuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gRmFsc2UuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCB2YXIgbmV2ZXIgPSBGQUxTRTtcblxuXG4vKipcbiAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIGJyb3dzZXIgZXZlbnQgaXMgYSBgcG9pbnRlcm1vdmVgIGV2ZW50LCBgZmFsc2VgXG4gKiBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgYnJvd3NlciBldmVudCBpcyBhIGBwb2ludGVybW92ZWAgZXZlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCB2YXIgcG9pbnRlck1vdmUgPSBmdW5jdGlvbihtYXBCcm93c2VyRXZlbnQpIHtcbiAgcmV0dXJuIG1hcEJyb3dzZXJFdmVudC50eXBlID09ICdwb2ludGVybW92ZSc7XG59O1xuXG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgZXZlbnQgaXMgYSBtYXAgYHNpbmdsZWNsaWNrYCBldmVudCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgaXMgYSBtYXAgYHNpbmdsZWNsaWNrYCBldmVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IHZhciBzaW5nbGVDbGljayA9IGZ1bmN0aW9uKG1hcEJyb3dzZXJFdmVudCkge1xuICByZXR1cm4gbWFwQnJvd3NlckV2ZW50LnR5cGUgPT0gTWFwQnJvd3NlckV2ZW50VHlwZS5TSU5HTEVDTElDSztcbn07XG5cblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBldmVudCBpcyBhIG1hcCBgZGJsY2xpY2tgIGV2ZW50LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBpcyBhIG1hcCBgZGJsY2xpY2tgIGV2ZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgdmFyIGRvdWJsZUNsaWNrID0gZnVuY3Rpb24obWFwQnJvd3NlckV2ZW50KSB7XG4gIHJldHVybiBtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBNYXBCcm93c2VyRXZlbnRUeXBlLkRCTENMSUNLO1xufTtcblxuXG4vKipcbiAqIFJldHVybiBgdHJ1ZWAgaWYgbm8gbW9kaWZpZXIga2V5IChhbHQtLCBzaGlmdC0gb3IgcGxhdGZvcm0tbW9kaWZpZXIta2V5KSBpc1xuICogcHJlc3NlZC5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIG9ubHkgaWYgdGhlcmUgbm8gbW9kaWZpZXIga2V5cyBhcmUgcHJlc3NlZC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IHZhciBub01vZGlmaWVyS2V5cyA9IGZ1bmN0aW9uKG1hcEJyb3dzZXJFdmVudCkge1xuICB2YXIgb3JpZ2luYWxFdmVudCA9IC8qKiBAdHlwZSB7S2V5Ym9hcmRFdmVudHxNb3VzZUV2ZW50fFRvdWNoRXZlbnR9ICovIChtYXBCcm93c2VyRXZlbnQub3JpZ2luYWxFdmVudCk7XG4gIHJldHVybiAoXG4gICAgIW9yaWdpbmFsRXZlbnQuYWx0S2V5ICYmXG4gICAgICAhKG9yaWdpbmFsRXZlbnQubWV0YUtleSB8fCBvcmlnaW5hbEV2ZW50LmN0cmxLZXkpICYmXG4gICAgICAhb3JpZ2luYWxFdmVudC5zaGlmdEtleSk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiBvbmx5IHRoZSBwbGF0Zm9ybS1tb2RpZmllci1rZXkgKHRoZSBtZXRhLWtleSBvbiBNYWMsXG4gKiBjdHJsLWtleSBvdGhlcndpc2UpIGlzIHByZXNzZWQsIGBmYWxzZWAgb3RoZXJ3aXNlIChlLmcuIHdoZW4gYWRkaXRpb25hbGx5XG4gKiB0aGUgc2hpZnQta2V5IGlzIHByZXNzZWQpLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgb25seSB0aGUgcGxhdGZvcm0gbW9kaWZpZXIga2V5IGlzIHByZXNzZWQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCB2YXIgcGxhdGZvcm1Nb2RpZmllcktleU9ubHkgPSBmdW5jdGlvbihtYXBCcm93c2VyRXZlbnQpIHtcbiAgdmFyIG9yaWdpbmFsRXZlbnQgPSAvKiogQHR5cGUge0tleWJvYXJkRXZlbnR8TW91c2VFdmVudHxUb3VjaEV2ZW50fSAqLyAobWFwQnJvd3NlckV2ZW50Lm9yaWdpbmFsRXZlbnQpO1xuICByZXR1cm4gIW9yaWdpbmFsRXZlbnQuYWx0S2V5ICYmXG4gICAgKE1BQyA/IG9yaWdpbmFsRXZlbnQubWV0YUtleSA6IG9yaWdpbmFsRXZlbnQuY3RybEtleSkgJiZcbiAgICAhb3JpZ2luYWxFdmVudC5zaGlmdEtleTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIG9ubHkgdGhlIHNoaWZ0LWtleSBpcyBwcmVzc2VkLCBgZmFsc2VgIG90aGVyd2lzZSAoZS5nLiB3aGVuXG4gKiBhZGRpdGlvbmFsbHkgdGhlIGFsdC1rZXkgaXMgcHJlc3NlZCkuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBvbmx5IHRoZSBzaGlmdCBrZXkgaXMgcHJlc3NlZC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IHZhciBzaGlmdEtleU9ubHkgPSBmdW5jdGlvbihtYXBCcm93c2VyRXZlbnQpIHtcbiAgdmFyIG9yaWdpbmFsRXZlbnQgPSAvKiogQHR5cGUge0tleWJvYXJkRXZlbnR8TW91c2VFdmVudHxUb3VjaEV2ZW50fSAqLyAobWFwQnJvd3NlckV2ZW50Lm9yaWdpbmFsRXZlbnQpO1xuICByZXR1cm4gKFxuICAgICFvcmlnaW5hbEV2ZW50LmFsdEtleSAmJlxuICAgICAgIShvcmlnaW5hbEV2ZW50Lm1ldGFLZXkgfHwgb3JpZ2luYWxFdmVudC5jdHJsS2V5KSAmJlxuICAgICAgb3JpZ2luYWxFdmVudC5zaGlmdEtleSk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgdGFyZ2V0IGVsZW1lbnQgaXMgbm90IGVkaXRhYmxlLCBpLmUuIG5vdCBhIGA8aW5wdXQ+YC0sXG4gKiBgPHNlbGVjdD5gLSBvciBgPHRleHRhcmVhPmAtZWxlbWVudCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBvbmx5IGlmIHRoZSB0YXJnZXQgZWxlbWVudCBpcyBub3QgZWRpdGFibGUuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCB2YXIgdGFyZ2V0Tm90RWRpdGFibGUgPSBmdW5jdGlvbihtYXBCcm93c2VyRXZlbnQpIHtcbiAgdmFyIHRhcmdldCA9IG1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50LnRhcmdldDtcbiAgdmFyIHRhZ05hbWUgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovICh0YXJnZXQpLnRhZ05hbWU7XG4gIHJldHVybiAoXG4gICAgdGFnTmFtZSAhPT0gJ0lOUFVUJyAmJlxuICAgICAgdGFnTmFtZSAhPT0gJ1NFTEVDVCcgJiZcbiAgICAgIHRhZ05hbWUgIT09ICdURVhUQVJFQScpO1xufTtcblxuXG4vKipcbiAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIGV2ZW50IG9yaWdpbmF0ZXMgZnJvbSBhIG1vdXNlIGRldmljZS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBvcmlnaW5hdGVzIGZyb20gYSBtb3VzZSBkZXZpY2UuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCB2YXIgbW91c2VPbmx5ID0gZnVuY3Rpb24obWFwQnJvd3NlckV2ZW50KSB7XG4gIHZhciBwb2ludGVyRXZlbnQgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL01hcEJyb3dzZXJQb2ludGVyRXZlbnRcIikuZGVmYXVsdH0gKi8gKG1hcEJyb3dzZXJFdmVudCkucG9pbnRlckV2ZW50O1xuICBhc3NlcnQocG9pbnRlckV2ZW50ICE9PSB1bmRlZmluZWQsIDU2KTsgLy8gbWFwQnJvd3NlckV2ZW50IG11c3Qgb3JpZ2luYXRlIGZyb20gYSBwb2ludGVyIGV2ZW50XG4gIC8vIHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9wb2ludGVyZXZlbnRzLyN3aWRsLVBvaW50ZXJFdmVudC1wb2ludGVyVHlwZVxuICByZXR1cm4gcG9pbnRlckV2ZW50LnBvaW50ZXJUeXBlID09ICdtb3VzZSc7XG59O1xuXG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgZXZlbnQgb3JpZ2luYXRlcyBmcm9tIGEgcHJpbWFyeSBwb2ludGVyIGluXG4gKiBjb250YWN0IHdpdGggdGhlIHN1cmZhY2Ugb3IgaWYgdGhlIGxlZnQgbW91c2UgYnV0dG9uIGlzIHByZXNzZWQuXG4gKiBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy8jYnV0dG9uLXN0YXRlcy5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBvcmlnaW5hdGVzIGZyb20gYSBwcmltYXJ5IHBvaW50ZXIuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCB2YXIgcHJpbWFyeUFjdGlvbiA9IGZ1bmN0aW9uKG1hcEJyb3dzZXJFdmVudCkge1xuICB2YXIgcG9pbnRlckV2ZW50ID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyUG9pbnRlckV2ZW50XCIpLmRlZmF1bHR9ICovIChtYXBCcm93c2VyRXZlbnQpLnBvaW50ZXJFdmVudDtcbiAgYXNzZXJ0KHBvaW50ZXJFdmVudCAhPT0gdW5kZWZpbmVkLCA1Nik7IC8vIG1hcEJyb3dzZXJFdmVudCBtdXN0IG9yaWdpbmF0ZSBmcm9tIGEgcG9pbnRlciBldmVudFxuICByZXR1cm4gcG9pbnRlckV2ZW50LmlzUHJpbWFyeSAmJiBwb2ludGVyRXZlbnQuYnV0dG9uID09PSAwO1xufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uZGl0aW9uLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9leHRlbnRcbiAqL1xuaW1wb3J0IHthc3NlcnR9IGZyb20gJy4vYXNzZXJ0cy5qcyc7XG5pbXBvcnQgQ29ybmVyIGZyb20gJy4vZXh0ZW50L0Nvcm5lci5qcyc7XG5pbXBvcnQgUmVsYXRpb25zaGlwIGZyb20gJy4vZXh0ZW50L1JlbGF0aW9uc2hpcC5qcyc7XG5cblxuLyoqXG4gKiBBbiBhcnJheSBvZiBudW1iZXJzIHJlcHJlc2VudGluZyBhbiBleHRlbnQ6IGBbbWlueCwgbWlueSwgbWF4eCwgbWF4eV1gLlxuICogQHR5cGVkZWYge0FycmF5PG51bWJlcj59IEV4dGVudFxuICogQGFwaVxuICovXG5cbi8qKlxuICogQnVpbGQgYW4gZXh0ZW50IHRoYXQgaW5jbHVkZXMgYWxsIGdpdmVuIGNvb3JkaW5hdGVzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAqIEByZXR1cm4ge0V4dGVudH0gQm91bmRpbmcgZXh0ZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gYm91bmRpbmdFeHRlbnQoY29vcmRpbmF0ZXMpIHtcbiAgdmFyIGV4dGVudCA9IGNyZWF0ZUVtcHR5KCk7XG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBleHRlbmRDb29yZGluYXRlKGV4dGVudCwgY29vcmRpbmF0ZXNbaV0pO1xuICB9XG4gIHJldHVybiBleHRlbnQ7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHhzIFhzLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB5cyBZcy5cbiAqIEBwYXJhbSB7RXh0ZW50PX0gb3B0X2V4dGVudCBEZXN0aW5hdGlvbiBleHRlbnQuXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybiB7RXh0ZW50fSBFeHRlbnQuXG4gKi9cbmZ1bmN0aW9uIF9ib3VuZGluZ0V4dGVudFhZcyh4cywgeXMsIG9wdF9leHRlbnQpIHtcbiAgdmFyIG1pblggPSBNYXRoLm1pbi5hcHBseShudWxsLCB4cyk7XG4gIHZhciBtaW5ZID0gTWF0aC5taW4uYXBwbHkobnVsbCwgeXMpO1xuICB2YXIgbWF4WCA9IE1hdGgubWF4LmFwcGx5KG51bGwsIHhzKTtcbiAgdmFyIG1heFkgPSBNYXRoLm1heC5hcHBseShudWxsLCB5cyk7XG4gIHJldHVybiBjcmVhdGVPclVwZGF0ZShtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZLCBvcHRfZXh0ZW50KTtcbn1cblxuXG4vKipcbiAqIFJldHVybiBleHRlbnQgaW5jcmVhc2VkIGJ5IHRoZSBwcm92aWRlZCB2YWx1ZS5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBhbW91bnQgYnkgd2hpY2ggdGhlIGV4dGVudCBzaG91bGQgYmUgYnVmZmVyZWQuXG4gKiBAcGFyYW0ge0V4dGVudD19IG9wdF9leHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7RXh0ZW50fSBFeHRlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWZmZXIoZXh0ZW50LCB2YWx1ZSwgb3B0X2V4dGVudCkge1xuICBpZiAob3B0X2V4dGVudCkge1xuICAgIG9wdF9leHRlbnRbMF0gPSBleHRlbnRbMF0gLSB2YWx1ZTtcbiAgICBvcHRfZXh0ZW50WzFdID0gZXh0ZW50WzFdIC0gdmFsdWU7XG4gICAgb3B0X2V4dGVudFsyXSA9IGV4dGVudFsyXSArIHZhbHVlO1xuICAgIG9wdF9leHRlbnRbM10gPSBleHRlbnRbM10gKyB2YWx1ZTtcbiAgICByZXR1cm4gb3B0X2V4dGVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW1xuICAgICAgZXh0ZW50WzBdIC0gdmFsdWUsXG4gICAgICBleHRlbnRbMV0gLSB2YWx1ZSxcbiAgICAgIGV4dGVudFsyXSArIHZhbHVlLFxuICAgICAgZXh0ZW50WzNdICsgdmFsdWVcbiAgICBdO1xuICB9XG59XG5cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYW4gZXh0ZW50LlxuICpcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50IHRvIGNsb25lLlxuICogQHBhcmFtIHtFeHRlbnQ9fSBvcHRfZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge0V4dGVudH0gVGhlIGNsb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUoZXh0ZW50LCBvcHRfZXh0ZW50KSB7XG4gIGlmIChvcHRfZXh0ZW50KSB7XG4gICAgb3B0X2V4dGVudFswXSA9IGV4dGVudFswXTtcbiAgICBvcHRfZXh0ZW50WzFdID0gZXh0ZW50WzFdO1xuICAgIG9wdF9leHRlbnRbMl0gPSBleHRlbnRbMl07XG4gICAgb3B0X2V4dGVudFszXSA9IGV4dGVudFszXTtcbiAgICByZXR1cm4gb3B0X2V4dGVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZXh0ZW50LnNsaWNlKCk7XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IENsb3Nlc3Qgc3F1YXJlZCBkaXN0YW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb3Nlc3RTcXVhcmVkRGlzdGFuY2VYWShleHRlbnQsIHgsIHkpIHtcbiAgdmFyIGR4LCBkeTtcbiAgaWYgKHggPCBleHRlbnRbMF0pIHtcbiAgICBkeCA9IGV4dGVudFswXSAtIHg7XG4gIH0gZWxzZSBpZiAoZXh0ZW50WzJdIDwgeCkge1xuICAgIGR4ID0geCAtIGV4dGVudFsyXTtcbiAgfSBlbHNlIHtcbiAgICBkeCA9IDA7XG4gIH1cbiAgaWYgKHkgPCBleHRlbnRbMV0pIHtcbiAgICBkeSA9IGV4dGVudFsxXSAtIHk7XG4gIH0gZWxzZSBpZiAoZXh0ZW50WzNdIDwgeSkge1xuICAgIGR5ID0geSAtIGV4dGVudFszXTtcbiAgfSBlbHNlIHtcbiAgICBkeSA9IDA7XG4gIH1cbiAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufVxuXG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHBhc3NlZCBjb29yZGluYXRlIGlzIGNvbnRhaW5lZCBvciBvbiB0aGUgZWRnZSBvZiB0aGUgZXh0ZW50LlxuICpcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGNvb3JkaW5hdGUgaXMgY29udGFpbmVkIGluIHRoZSBleHRlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb250YWluc0Nvb3JkaW5hdGUoZXh0ZW50LCBjb29yZGluYXRlKSB7XG4gIHJldHVybiBjb250YWluc1hZKGV4dGVudCwgY29vcmRpbmF0ZVswXSwgY29vcmRpbmF0ZVsxXSk7XG59XG5cblxuLyoqXG4gKiBDaGVjayBpZiBvbmUgZXh0ZW50IGNvbnRhaW5zIGFub3RoZXIuXG4gKlxuICogQW4gZXh0ZW50IGlzIGRlZW1lZCBjb250YWluZWQgaWYgaXQgbGllcyBjb21wbGV0ZWx5IHdpdGhpbiB0aGUgb3RoZXIgZXh0ZW50LFxuICogaW5jbHVkaW5nIGlmIHRoZXkgc2hhcmUgb25lIG9yIG1vcmUgZWRnZXMuXG4gKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDEgRXh0ZW50IDEuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50MiBFeHRlbnQgMi5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBzZWNvbmQgZXh0ZW50IGlzIGNvbnRhaW5lZCBieSBvciBvbiB0aGUgZWRnZSBvZiB0aGVcbiAqICAgICBmaXJzdC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zRXh0ZW50KGV4dGVudDEsIGV4dGVudDIpIHtcbiAgcmV0dXJuIGV4dGVudDFbMF0gPD0gZXh0ZW50MlswXSAmJiBleHRlbnQyWzJdIDw9IGV4dGVudDFbMl0gJiZcbiAgICAgIGV4dGVudDFbMV0gPD0gZXh0ZW50MlsxXSAmJiBleHRlbnQyWzNdIDw9IGV4dGVudDFbM107XG59XG5cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgcGFzc2VkIGNvb3JkaW5hdGUgaXMgY29udGFpbmVkIG9yIG9uIHRoZSBlZGdlIG9mIHRoZSBleHRlbnQuXG4gKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0geSBZIGNvb3JkaW5hdGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgeCwgeSB2YWx1ZXMgYXJlIGNvbnRhaW5lZCBpbiB0aGUgZXh0ZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udGFpbnNYWShleHRlbnQsIHgsIHkpIHtcbiAgcmV0dXJuIGV4dGVudFswXSA8PSB4ICYmIHggPD0gZXh0ZW50WzJdICYmIGV4dGVudFsxXSA8PSB5ICYmIHkgPD0gZXh0ZW50WzNdO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSByZWxhdGlvbnNoaXAgYmV0d2VlbiBhIGNvb3JkaW5hdGUgYW5kIGV4dGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgVGhlIGV4dGVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgVGhlIGNvb3JkaW5hdGUuXG4gKiBAcmV0dXJuIHtSZWxhdGlvbnNoaXB9IFRoZSByZWxhdGlvbnNoaXAgKGJpdHdpc2UgY29tcGFyZSB3aXRoXG4gKiAgICAgaW1wb3J0KFwiLi9leHRlbnQvUmVsYXRpb25zaGlwLmpzXCIpLlJlbGF0aW9uc2hpcCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb29yZGluYXRlUmVsYXRpb25zaGlwKGV4dGVudCwgY29vcmRpbmF0ZSkge1xuICB2YXIgbWluWCA9IGV4dGVudFswXTtcbiAgdmFyIG1pblkgPSBleHRlbnRbMV07XG4gIHZhciBtYXhYID0gZXh0ZW50WzJdO1xuICB2YXIgbWF4WSA9IGV4dGVudFszXTtcbiAgdmFyIHggPSBjb29yZGluYXRlWzBdO1xuICB2YXIgeSA9IGNvb3JkaW5hdGVbMV07XG4gIHZhciByZWxhdGlvbnNoaXAgPSBSZWxhdGlvbnNoaXAuVU5LTk9XTjtcbiAgaWYgKHggPCBtaW5YKSB7XG4gICAgcmVsYXRpb25zaGlwID0gcmVsYXRpb25zaGlwIHwgUmVsYXRpb25zaGlwLkxFRlQ7XG4gIH0gZWxzZSBpZiAoeCA+IG1heFgpIHtcbiAgICByZWxhdGlvbnNoaXAgPSByZWxhdGlvbnNoaXAgfCBSZWxhdGlvbnNoaXAuUklHSFQ7XG4gIH1cbiAgaWYgKHkgPCBtaW5ZKSB7XG4gICAgcmVsYXRpb25zaGlwID0gcmVsYXRpb25zaGlwIHwgUmVsYXRpb25zaGlwLkJFTE9XO1xuICB9IGVsc2UgaWYgKHkgPiBtYXhZKSB7XG4gICAgcmVsYXRpb25zaGlwID0gcmVsYXRpb25zaGlwIHwgUmVsYXRpb25zaGlwLkFCT1ZFO1xuICB9XG4gIGlmIChyZWxhdGlvbnNoaXAgPT09IFJlbGF0aW9uc2hpcC5VTktOT1dOKSB7XG4gICAgcmVsYXRpb25zaGlwID0gUmVsYXRpb25zaGlwLklOVEVSU0VDVElORztcbiAgfVxuICByZXR1cm4gcmVsYXRpb25zaGlwO1xufVxuXG5cbi8qKlxuICogQ3JlYXRlIGFuIGVtcHR5IGV4dGVudC5cbiAqIEByZXR1cm4ge0V4dGVudH0gRW1wdHkgZXh0ZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRW1wdHkoKSB7XG4gIHJldHVybiBbSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV07XG59XG5cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgZXh0ZW50IG9yIHVwZGF0ZSB0aGUgcHJvdmlkZWQgZXh0ZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IG1pblggTWluaW11bSBYLlxuICogQHBhcmFtIHtudW1iZXJ9IG1pblkgTWluaW11bSBZLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heFggTWF4aW11bSBYLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heFkgTWF4aW11bSBZLlxuICogQHBhcmFtIHtFeHRlbnQ9fSBvcHRfZXh0ZW50IERlc3RpbmF0aW9uIGV4dGVudC5cbiAqIEByZXR1cm4ge0V4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGUobWluWCwgbWluWSwgbWF4WCwgbWF4WSwgb3B0X2V4dGVudCkge1xuICBpZiAob3B0X2V4dGVudCkge1xuICAgIG9wdF9leHRlbnRbMF0gPSBtaW5YO1xuICAgIG9wdF9leHRlbnRbMV0gPSBtaW5ZO1xuICAgIG9wdF9leHRlbnRbMl0gPSBtYXhYO1xuICAgIG9wdF9leHRlbnRbM10gPSBtYXhZO1xuICAgIHJldHVybiBvcHRfZXh0ZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbbWluWCwgbWluWSwgbWF4WCwgbWF4WV07XG4gIH1cbn1cblxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBlbXB0eSBleHRlbnQgb3IgbWFrZSB0aGUgcHJvdmlkZWQgb25lIGVtcHR5LlxuICogQHBhcmFtIHtFeHRlbnQ9fSBvcHRfZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge0V4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVFbXB0eShvcHRfZXh0ZW50KSB7XG4gIHJldHVybiBjcmVhdGVPclVwZGF0ZShcbiAgICBJbmZpbml0eSwgSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5LCBvcHRfZXh0ZW50KTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7RXh0ZW50PX0gb3B0X2V4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlRnJvbUNvb3JkaW5hdGUoY29vcmRpbmF0ZSwgb3B0X2V4dGVudCkge1xuICB2YXIgeCA9IGNvb3JkaW5hdGVbMF07XG4gIHZhciB5ID0gY29vcmRpbmF0ZVsxXTtcbiAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlKHgsIHksIHgsIHksIG9wdF9leHRlbnQpO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59IGNvb3JkaW5hdGVzIENvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtFeHRlbnQ9fSBvcHRfZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge0V4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVGcm9tQ29vcmRpbmF0ZXMoY29vcmRpbmF0ZXMsIG9wdF9leHRlbnQpIHtcbiAgdmFyIGV4dGVudCA9IGNyZWF0ZU9yVXBkYXRlRW1wdHkob3B0X2V4dGVudCk7XG4gIHJldHVybiBleHRlbmRDb29yZGluYXRlcyhleHRlbnQsIGNvb3JkaW5hdGVzKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge0V4dGVudD19IG9wdF9leHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7RXh0ZW50fSBFeHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVPclVwZGF0ZUZyb21GbGF0Q29vcmRpbmF0ZXMoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCBvcHRfZXh0ZW50KSB7XG4gIHZhciBleHRlbnQgPSBjcmVhdGVPclVwZGF0ZUVtcHR5KG9wdF9leHRlbnQpO1xuICByZXR1cm4gZXh0ZW5kRmxhdENvb3JkaW5hdGVzKGV4dGVudCwgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj59IHJpbmdzIFJpbmdzLlxuICogQHBhcmFtIHtFeHRlbnQ9fSBvcHRfZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge0V4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVGcm9tUmluZ3MocmluZ3MsIG9wdF9leHRlbnQpIHtcbiAgdmFyIGV4dGVudCA9IGNyZWF0ZU9yVXBkYXRlRW1wdHkob3B0X2V4dGVudCk7XG4gIHJldHVybiBleHRlbmRSaW5ncyhleHRlbnQsIHJpbmdzKTtcbn1cblxuXG4vKipcbiAqIERldGVybWluZSBpZiB0d28gZXh0ZW50cyBhcmUgZXF1aXZhbGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQxIEV4dGVudCAxLlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDIgRXh0ZW50IDIuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgdHdvIGV4dGVudHMgYXJlIGVxdWl2YWxlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoZXh0ZW50MSwgZXh0ZW50Mikge1xuICByZXR1cm4gZXh0ZW50MVswXSA9PSBleHRlbnQyWzBdICYmIGV4dGVudDFbMl0gPT0gZXh0ZW50MlsyXSAmJlxuICAgICAgZXh0ZW50MVsxXSA9PSBleHRlbnQyWzFdICYmIGV4dGVudDFbM10gPT0gZXh0ZW50MlszXTtcbn1cblxuXG4vKipcbiAqIE1vZGlmeSBhbiBleHRlbnQgdG8gaW5jbHVkZSBhbm90aGVyIGV4dGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQxIFRoZSBleHRlbnQgdG8gYmUgbW9kaWZpZWQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50MiBUaGUgZXh0ZW50IHRoYXQgd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgZmlyc3QuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEEgcmVmZXJlbmNlIHRvIHRoZSBmaXJzdCAoZXh0ZW5kZWQpIGV4dGVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChleHRlbnQxLCBleHRlbnQyKSB7XG4gIGlmIChleHRlbnQyWzBdIDwgZXh0ZW50MVswXSkge1xuICAgIGV4dGVudDFbMF0gPSBleHRlbnQyWzBdO1xuICB9XG4gIGlmIChleHRlbnQyWzJdID4gZXh0ZW50MVsyXSkge1xuICAgIGV4dGVudDFbMl0gPSBleHRlbnQyWzJdO1xuICB9XG4gIGlmIChleHRlbnQyWzFdIDwgZXh0ZW50MVsxXSkge1xuICAgIGV4dGVudDFbMV0gPSBleHRlbnQyWzFdO1xuICB9XG4gIGlmIChleHRlbnQyWzNdID4gZXh0ZW50MVszXSkge1xuICAgIGV4dGVudDFbM10gPSBleHRlbnQyWzNdO1xuICB9XG4gIHJldHVybiBleHRlbnQxO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmRDb29yZGluYXRlKGV4dGVudCwgY29vcmRpbmF0ZSkge1xuICBpZiAoY29vcmRpbmF0ZVswXSA8IGV4dGVudFswXSkge1xuICAgIGV4dGVudFswXSA9IGNvb3JkaW5hdGVbMF07XG4gIH1cbiAgaWYgKGNvb3JkaW5hdGVbMF0gPiBleHRlbnRbMl0pIHtcbiAgICBleHRlbnRbMl0gPSBjb29yZGluYXRlWzBdO1xuICB9XG4gIGlmIChjb29yZGluYXRlWzFdIDwgZXh0ZW50WzFdKSB7XG4gICAgZXh0ZW50WzFdID0gY29vcmRpbmF0ZVsxXTtcbiAgfVxuICBpZiAoY29vcmRpbmF0ZVsxXSA+IGV4dGVudFszXSkge1xuICAgIGV4dGVudFszXSA9IGNvb3JkaW5hdGVbMV07XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59IGNvb3JkaW5hdGVzIENvb3JkaW5hdGVzLlxuICogQHJldHVybiB7RXh0ZW50fSBFeHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmRDb29yZGluYXRlcyhleHRlbnQsIGNvb3JkaW5hdGVzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBleHRlbmRDb29yZGluYXRlKGV4dGVudCwgY29vcmRpbmF0ZXNbaV0pO1xuICB9XG4gIHJldHVybiBleHRlbnQ7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZEZsYXRDb29yZGluYXRlcyhleHRlbnQsIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSkge1xuICBmb3IgKDsgb2Zmc2V0IDwgZW5kOyBvZmZzZXQgKz0gc3RyaWRlKSB7XG4gICAgZXh0ZW5kWFkoZXh0ZW50LCBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XSwgZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdKTtcbiAgfVxuICByZXR1cm4gZXh0ZW50O1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj59IHJpbmdzIFJpbmdzLlxuICogQHJldHVybiB7RXh0ZW50fSBFeHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmRSaW5ncyhleHRlbnQsIHJpbmdzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IHJpbmdzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBleHRlbmRDb29yZGluYXRlcyhleHRlbnQsIHJpbmdzW2ldKTtcbiAgfVxuICByZXR1cm4gZXh0ZW50O1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZFhZKGV4dGVudCwgeCwgeSkge1xuICBleHRlbnRbMF0gPSBNYXRoLm1pbihleHRlbnRbMF0sIHgpO1xuICBleHRlbnRbMV0gPSBNYXRoLm1pbihleHRlbnRbMV0sIHkpO1xuICBleHRlbnRbMl0gPSBNYXRoLm1heChleHRlbnRbMl0sIHgpO1xuICBleHRlbnRbM10gPSBNYXRoLm1heChleHRlbnRbM10sIHkpO1xufVxuXG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjYWxscyBgY2FsbGJhY2tgIGZvciBlYWNoIGNvcm5lciBvZiB0aGUgZXh0ZW50LiBJZiB0aGVcbiAqIGNhbGxiYWNrIHJldHVybnMgYSB0cnV0aHkgdmFsdWUgdGhlIGZ1bmN0aW9uIHJldHVybnMgdGhhdCB2YWx1ZVxuICogaW1tZWRpYXRlbHkuIE90aGVyd2lzZSB0aGUgZnVuY3Rpb24gcmV0dXJucyBgZmFsc2VgLlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6VCwgaW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGUpOiBTfSBjYWxsYmFjayBDYWxsYmFjay5cbiAqIEBwYXJhbSB7VD19IG9wdF90aGlzIFZhbHVlIHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgYGNhbGxiYWNrYC5cbiAqIEByZXR1cm4ge1N8Ym9vbGVhbn0gVmFsdWUuXG4gKiBAdGVtcGxhdGUgUywgVFxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9yRWFjaENvcm5lcihleHRlbnQsIGNhbGxiYWNrLCBvcHRfdGhpcykge1xuICB2YXIgdmFsO1xuICB2YWwgPSBjYWxsYmFjay5jYWxsKG9wdF90aGlzLCBnZXRCb3R0b21MZWZ0KGV4dGVudCkpO1xuICBpZiAodmFsKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICB2YWwgPSBjYWxsYmFjay5jYWxsKG9wdF90aGlzLCBnZXRCb3R0b21SaWdodChleHRlbnQpKTtcbiAgaWYgKHZhbCkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgdmFsID0gY2FsbGJhY2suY2FsbChvcHRfdGhpcywgZ2V0VG9wUmlnaHQoZXh0ZW50KSk7XG4gIGlmICh2YWwpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIHZhbCA9IGNhbGxiYWNrLmNhbGwob3B0X3RoaXMsIGdldFRvcExlZnQoZXh0ZW50KSk7XG4gIGlmICh2YWwpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgc2l6ZSBvZiBhbiBleHRlbnQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gQXJlYS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFyZWEoZXh0ZW50KSB7XG4gIHZhciBhcmVhID0gMDtcbiAgaWYgKCFpc0VtcHR5KGV4dGVudCkpIHtcbiAgICBhcmVhID0gZ2V0V2lkdGgoZXh0ZW50KSAqIGdldEhlaWdodChleHRlbnQpO1xuICB9XG4gIHJldHVybiBhcmVhO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBib3R0b20gbGVmdCBjb29yZGluYXRlIG9mIGFuIGV4dGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IEJvdHRvbSBsZWZ0IGNvb3JkaW5hdGUuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRCb3R0b21MZWZ0KGV4dGVudCkge1xuICByZXR1cm4gW2V4dGVudFswXSwgZXh0ZW50WzFdXTtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgYm90dG9tIHJpZ2h0IGNvb3JkaW5hdGUgb2YgYW4gZXh0ZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gQm90dG9tIHJpZ2h0IGNvb3JkaW5hdGUuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRCb3R0b21SaWdodChleHRlbnQpIHtcbiAgcmV0dXJuIFtleHRlbnRbMl0sIGV4dGVudFsxXV07XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIGNlbnRlciBjb29yZGluYXRlIG9mIGFuIGV4dGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IENlbnRlci5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENlbnRlcihleHRlbnQpIHtcbiAgcmV0dXJuIFsoZXh0ZW50WzBdICsgZXh0ZW50WzJdKSAvIDIsIChleHRlbnRbMV0gKyBleHRlbnRbM10pIC8gMl07XG59XG5cblxuLyoqXG4gKiBHZXQgYSBjb3JuZXIgY29vcmRpbmF0ZSBvZiBhbiBleHRlbnQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7Q29ybmVyfSBjb3JuZXIgQ29ybmVyLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IENvcm5lciBjb29yZGluYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29ybmVyKGV4dGVudCwgY29ybmVyKSB7XG4gIHZhciBjb29yZGluYXRlO1xuICBpZiAoY29ybmVyID09PSBDb3JuZXIuQk9UVE9NX0xFRlQpIHtcbiAgICBjb29yZGluYXRlID0gZ2V0Qm90dG9tTGVmdChleHRlbnQpO1xuICB9IGVsc2UgaWYgKGNvcm5lciA9PT0gQ29ybmVyLkJPVFRPTV9SSUdIVCkge1xuICAgIGNvb3JkaW5hdGUgPSBnZXRCb3R0b21SaWdodChleHRlbnQpO1xuICB9IGVsc2UgaWYgKGNvcm5lciA9PT0gQ29ybmVyLlRPUF9MRUZUKSB7XG4gICAgY29vcmRpbmF0ZSA9IGdldFRvcExlZnQoZXh0ZW50KTtcbiAgfSBlbHNlIGlmIChjb3JuZXIgPT09IENvcm5lci5UT1BfUklHSFQpIHtcbiAgICBjb29yZGluYXRlID0gZ2V0VG9wUmlnaHQoZXh0ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBhc3NlcnQoZmFsc2UsIDEzKTsgLy8gSW52YWxpZCBjb3JuZXJcbiAgfVxuICByZXR1cm4gY29vcmRpbmF0ZTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQxIEV4dGVudCAxLlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDIgRXh0ZW50IDIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEVubGFyZ2VkIGFyZWEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbmxhcmdlZEFyZWEoZXh0ZW50MSwgZXh0ZW50Mikge1xuICB2YXIgbWluWCA9IE1hdGgubWluKGV4dGVudDFbMF0sIGV4dGVudDJbMF0pO1xuICB2YXIgbWluWSA9IE1hdGgubWluKGV4dGVudDFbMV0sIGV4dGVudDJbMV0pO1xuICB2YXIgbWF4WCA9IE1hdGgubWF4KGV4dGVudDFbMl0sIGV4dGVudDJbMl0pO1xuICB2YXIgbWF4WSA9IE1hdGgubWF4KGV4dGVudDFbM10sIGV4dGVudDJbM10pO1xuICByZXR1cm4gKG1heFggLSBtaW5YKSAqIChtYXhZIC0gbWluWSk7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjZW50ZXIgQ2VudGVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9IHNpemUgU2l6ZS5cbiAqIEBwYXJhbSB7RXh0ZW50PX0gb3B0X2V4dGVudCBEZXN0aW5hdGlvbiBleHRlbnQuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZvclZpZXdBbmRTaXplKGNlbnRlciwgcmVzb2x1dGlvbiwgcm90YXRpb24sIHNpemUsIG9wdF9leHRlbnQpIHtcbiAgdmFyIGR4ID0gcmVzb2x1dGlvbiAqIHNpemVbMF0gLyAyO1xuICB2YXIgZHkgPSByZXNvbHV0aW9uICogc2l6ZVsxXSAvIDI7XG4gIHZhciBjb3NSb3RhdGlvbiA9IE1hdGguY29zKHJvdGF0aW9uKTtcbiAgdmFyIHNpblJvdGF0aW9uID0gTWF0aC5zaW4ocm90YXRpb24pO1xuICB2YXIgeENvcyA9IGR4ICogY29zUm90YXRpb247XG4gIHZhciB4U2luID0gZHggKiBzaW5Sb3RhdGlvbjtcbiAgdmFyIHlDb3MgPSBkeSAqIGNvc1JvdGF0aW9uO1xuICB2YXIgeVNpbiA9IGR5ICogc2luUm90YXRpb247XG4gIHZhciB4ID0gY2VudGVyWzBdO1xuICB2YXIgeSA9IGNlbnRlclsxXTtcbiAgdmFyIHgwID0geCAtIHhDb3MgKyB5U2luO1xuICB2YXIgeDEgPSB4IC0geENvcyAtIHlTaW47XG4gIHZhciB4MiA9IHggKyB4Q29zIC0geVNpbjtcbiAgdmFyIHgzID0geCArIHhDb3MgKyB5U2luO1xuICB2YXIgeTAgPSB5IC0geFNpbiAtIHlDb3M7XG4gIHZhciB5MSA9IHkgLSB4U2luICsgeUNvcztcbiAgdmFyIHkyID0geSArIHhTaW4gKyB5Q29zO1xuICB2YXIgeTMgPSB5ICsgeFNpbiAtIHlDb3M7XG4gIHJldHVybiBjcmVhdGVPclVwZGF0ZShcbiAgICBNYXRoLm1pbih4MCwgeDEsIHgyLCB4MyksIE1hdGgubWluKHkwLCB5MSwgeTIsIHkzKSxcbiAgICBNYXRoLm1heCh4MCwgeDEsIHgyLCB4MyksIE1hdGgubWF4KHkwLCB5MSwgeTIsIHkzKSxcbiAgICBvcHRfZXh0ZW50KTtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgaGVpZ2h0IG9mIGFuIGV4dGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7bnVtYmVyfSBIZWlnaHQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRIZWlnaHQoZXh0ZW50KSB7XG4gIHJldHVybiBleHRlbnRbM10gLSBleHRlbnRbMV07XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50MSBFeHRlbnQgMS5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQyIEV4dGVudCAyLlxuICogQHJldHVybiB7bnVtYmVyfSBJbnRlcnNlY3Rpb24gYXJlYS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEludGVyc2VjdGlvbkFyZWEoZXh0ZW50MSwgZXh0ZW50Mikge1xuICB2YXIgaW50ZXJzZWN0aW9uID0gZ2V0SW50ZXJzZWN0aW9uKGV4dGVudDEsIGV4dGVudDIpO1xuICByZXR1cm4gZ2V0QXJlYShpbnRlcnNlY3Rpb24pO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBpbnRlcnNlY3Rpb24gb2YgdHdvIGV4dGVudHMuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50MSBFeHRlbnQgMS5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQyIEV4dGVudCAyLlxuICogQHBhcmFtIHtFeHRlbnQ9fSBvcHRfZXh0ZW50IE9wdGlvbmFsIGV4dGVudCB0byBwb3B1bGF0ZSB3aXRoIGludGVyc2VjdGlvbi5cbiAqIEByZXR1cm4ge0V4dGVudH0gSW50ZXJzZWN0aW5nIGV4dGVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEludGVyc2VjdGlvbihleHRlbnQxLCBleHRlbnQyLCBvcHRfZXh0ZW50KSB7XG4gIHZhciBpbnRlcnNlY3Rpb24gPSBvcHRfZXh0ZW50ID8gb3B0X2V4dGVudCA6IGNyZWF0ZUVtcHR5KCk7XG4gIGlmIChpbnRlcnNlY3RzKGV4dGVudDEsIGV4dGVudDIpKSB7XG4gICAgaWYgKGV4dGVudDFbMF0gPiBleHRlbnQyWzBdKSB7XG4gICAgICBpbnRlcnNlY3Rpb25bMF0gPSBleHRlbnQxWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnRlcnNlY3Rpb25bMF0gPSBleHRlbnQyWzBdO1xuICAgIH1cbiAgICBpZiAoZXh0ZW50MVsxXSA+IGV4dGVudDJbMV0pIHtcbiAgICAgIGludGVyc2VjdGlvblsxXSA9IGV4dGVudDFbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGludGVyc2VjdGlvblsxXSA9IGV4dGVudDJbMV07XG4gICAgfVxuICAgIGlmIChleHRlbnQxWzJdIDwgZXh0ZW50MlsyXSkge1xuICAgICAgaW50ZXJzZWN0aW9uWzJdID0gZXh0ZW50MVsyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW50ZXJzZWN0aW9uWzJdID0gZXh0ZW50MlsyXTtcbiAgICB9XG4gICAgaWYgKGV4dGVudDFbM10gPCBleHRlbnQyWzNdKSB7XG4gICAgICBpbnRlcnNlY3Rpb25bM10gPSBleHRlbnQxWzNdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnRlcnNlY3Rpb25bM10gPSBleHRlbnQyWzNdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjcmVhdGVPclVwZGF0ZUVtcHR5KGludGVyc2VjdGlvbik7XG4gIH1cbiAgcmV0dXJuIGludGVyc2VjdGlvbjtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7bnVtYmVyfSBNYXJnaW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXJnaW4oZXh0ZW50KSB7XG4gIHJldHVybiBnZXRXaWR0aChleHRlbnQpICsgZ2V0SGVpZ2h0KGV4dGVudCk7XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIHNpemUgKHdpZHRoLCBoZWlnaHQpIG9mIGFuIGV4dGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgVGhlIGV4dGVudC5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBUaGUgZXh0ZW50IHNpemUuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaXplKGV4dGVudCkge1xuICByZXR1cm4gW2V4dGVudFsyXSAtIGV4dGVudFswXSwgZXh0ZW50WzNdIC0gZXh0ZW50WzFdXTtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgdG9wIGxlZnQgY29vcmRpbmF0ZSBvZiBhbiBleHRlbnQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBUb3AgbGVmdCBjb29yZGluYXRlLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VG9wTGVmdChleHRlbnQpIHtcbiAgcmV0dXJuIFtleHRlbnRbMF0sIGV4dGVudFszXV07XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIHRvcCByaWdodCBjb29yZGluYXRlIG9mIGFuIGV4dGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFRvcCByaWdodCBjb29yZGluYXRlLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VG9wUmlnaHQoZXh0ZW50KSB7XG4gIHJldHVybiBbZXh0ZW50WzJdLCBleHRlbnRbM11dO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSB3aWR0aCBvZiBhbiBleHRlbnQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gV2lkdGguXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRXaWR0aChleHRlbnQpIHtcbiAgcmV0dXJuIGV4dGVudFsyXSAtIGV4dGVudFswXTtcbn1cblxuXG4vKipcbiAqIERldGVybWluZSBpZiBvbmUgZXh0ZW50IGludGVyc2VjdHMgYW5vdGhlci5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQxIEV4dGVudCAxLlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDIgRXh0ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHR3byBleHRlbnRzIGludGVyc2VjdC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdHMoZXh0ZW50MSwgZXh0ZW50Mikge1xuICByZXR1cm4gZXh0ZW50MVswXSA8PSBleHRlbnQyWzJdICYmXG4gICAgICBleHRlbnQxWzJdID49IGV4dGVudDJbMF0gJiZcbiAgICAgIGV4dGVudDFbMV0gPD0gZXh0ZW50MlszXSAmJlxuICAgICAgZXh0ZW50MVszXSA+PSBleHRlbnQyWzFdO1xufVxuXG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGFuIGV4dGVudCBpcyBlbXB0eS5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gSXMgZW1wdHkuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VtcHR5KGV4dGVudCkge1xuICByZXR1cm4gZXh0ZW50WzJdIDwgZXh0ZW50WzBdIHx8IGV4dGVudFszXSA8IGV4dGVudFsxXTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtFeHRlbnQ9fSBvcHRfZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge0V4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuT3JVcGRhdGUoZXh0ZW50LCBvcHRfZXh0ZW50KSB7XG4gIGlmIChvcHRfZXh0ZW50KSB7XG4gICAgb3B0X2V4dGVudFswXSA9IGV4dGVudFswXTtcbiAgICBvcHRfZXh0ZW50WzFdID0gZXh0ZW50WzFdO1xuICAgIG9wdF9leHRlbnRbMl0gPSBleHRlbnRbMl07XG4gICAgb3B0X2V4dGVudFszXSA9IGV4dGVudFszXTtcbiAgICByZXR1cm4gb3B0X2V4dGVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZXh0ZW50O1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlRnJvbUNlbnRlcihleHRlbnQsIHZhbHVlKSB7XG4gIHZhciBkZWx0YVggPSAoKGV4dGVudFsyXSAtIGV4dGVudFswXSkgLyAyKSAqICh2YWx1ZSAtIDEpO1xuICB2YXIgZGVsdGFZID0gKChleHRlbnRbM10gLSBleHRlbnRbMV0pIC8gMikgKiAodmFsdWUgLSAxKTtcbiAgZXh0ZW50WzBdIC09IGRlbHRhWDtcbiAgZXh0ZW50WzJdICs9IGRlbHRhWDtcbiAgZXh0ZW50WzFdIC09IGRlbHRhWTtcbiAgZXh0ZW50WzNdICs9IGRlbHRhWTtcbn1cblxuXG4vKipcbiAqIERldGVybWluZSBpZiB0aGUgc2VnbWVudCBiZXR3ZWVuIHR3byBjb29yZGluYXRlcyBpbnRlcnNlY3RzIChjcm9zc2VzLFxuICogdG91Y2hlcywgb3IgaXMgY29udGFpbmVkIGJ5KSB0aGUgcHJvdmlkZWQgZXh0ZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBUaGUgZXh0ZW50LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gc3RhcnQgU2VnbWVudCBzdGFydCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gZW5kIFNlZ21lbnQgZW5kIGNvb3JkaW5hdGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgc2VnbWVudCBpbnRlcnNlY3RzIHRoZSBleHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnNlY3RzU2VnbWVudChleHRlbnQsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGludGVyc2VjdHMgPSBmYWxzZTtcbiAgdmFyIHN0YXJ0UmVsID0gY29vcmRpbmF0ZVJlbGF0aW9uc2hpcChleHRlbnQsIHN0YXJ0KTtcbiAgdmFyIGVuZFJlbCA9IGNvb3JkaW5hdGVSZWxhdGlvbnNoaXAoZXh0ZW50LCBlbmQpO1xuICBpZiAoc3RhcnRSZWwgPT09IFJlbGF0aW9uc2hpcC5JTlRFUlNFQ1RJTkcgfHxcbiAgICAgIGVuZFJlbCA9PT0gUmVsYXRpb25zaGlwLklOVEVSU0VDVElORykge1xuICAgIGludGVyc2VjdHMgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBtaW5YID0gZXh0ZW50WzBdO1xuICAgIHZhciBtaW5ZID0gZXh0ZW50WzFdO1xuICAgIHZhciBtYXhYID0gZXh0ZW50WzJdO1xuICAgIHZhciBtYXhZID0gZXh0ZW50WzNdO1xuICAgIHZhciBzdGFydFggPSBzdGFydFswXTtcbiAgICB2YXIgc3RhcnRZID0gc3RhcnRbMV07XG4gICAgdmFyIGVuZFggPSBlbmRbMF07XG4gICAgdmFyIGVuZFkgPSBlbmRbMV07XG4gICAgdmFyIHNsb3BlID0gKGVuZFkgLSBzdGFydFkpIC8gKGVuZFggLSBzdGFydFgpO1xuICAgIHZhciB4LCB5O1xuICAgIGlmICghIShlbmRSZWwgJiBSZWxhdGlvbnNoaXAuQUJPVkUpICYmXG4gICAgICAgICEoc3RhcnRSZWwgJiBSZWxhdGlvbnNoaXAuQUJPVkUpKSB7XG4gICAgICAvLyBwb3RlbnRpYWxseSBpbnRlcnNlY3RzIHRvcFxuICAgICAgeCA9IGVuZFggLSAoKGVuZFkgLSBtYXhZKSAvIHNsb3BlKTtcbiAgICAgIGludGVyc2VjdHMgPSB4ID49IG1pblggJiYgeCA8PSBtYXhYO1xuICAgIH1cbiAgICBpZiAoIWludGVyc2VjdHMgJiYgISEoZW5kUmVsICYgUmVsYXRpb25zaGlwLlJJR0hUKSAmJlxuICAgICAgICAhKHN0YXJ0UmVsICYgUmVsYXRpb25zaGlwLlJJR0hUKSkge1xuICAgICAgLy8gcG90ZW50aWFsbHkgaW50ZXJzZWN0cyByaWdodFxuICAgICAgeSA9IGVuZFkgLSAoKGVuZFggLSBtYXhYKSAqIHNsb3BlKTtcbiAgICAgIGludGVyc2VjdHMgPSB5ID49IG1pblkgJiYgeSA8PSBtYXhZO1xuICAgIH1cbiAgICBpZiAoIWludGVyc2VjdHMgJiYgISEoZW5kUmVsICYgUmVsYXRpb25zaGlwLkJFTE9XKSAmJlxuICAgICAgICAhKHN0YXJ0UmVsICYgUmVsYXRpb25zaGlwLkJFTE9XKSkge1xuICAgICAgLy8gcG90ZW50aWFsbHkgaW50ZXJzZWN0cyBib3R0b21cbiAgICAgIHggPSBlbmRYIC0gKChlbmRZIC0gbWluWSkgLyBzbG9wZSk7XG4gICAgICBpbnRlcnNlY3RzID0geCA+PSBtaW5YICYmIHggPD0gbWF4WDtcbiAgICB9XG4gICAgaWYgKCFpbnRlcnNlY3RzICYmICEhKGVuZFJlbCAmIFJlbGF0aW9uc2hpcC5MRUZUKSAmJlxuICAgICAgICAhKHN0YXJ0UmVsICYgUmVsYXRpb25zaGlwLkxFRlQpKSB7XG4gICAgICAvLyBwb3RlbnRpYWxseSBpbnRlcnNlY3RzIGxlZnRcbiAgICAgIHkgPSBlbmRZIC0gKChlbmRYIC0gbWluWCkgKiBzbG9wZSk7XG4gICAgICBpbnRlcnNlY3RzID0geSA+PSBtaW5ZICYmIHkgPD0gbWF4WTtcbiAgICB9XG5cbiAgfVxuICByZXR1cm4gaW50ZXJzZWN0cztcbn1cblxuXG4vKipcbiAqIEFwcGx5IGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHRvIHRoZSBleHRlbnQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qLmpzXCIpLlRyYW5zZm9ybUZ1bmN0aW9ufSB0cmFuc2Zvcm1GbiBUcmFuc2Zvcm0gZnVuY3Rpb24uXG4gKiBDYWxsZWQgd2l0aCBgW21pblgsIG1pblksIG1heFgsIG1heFldYCBleHRlbnQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge0V4dGVudD19IG9wdF9leHRlbnQgRGVzdGluYXRpb24gZXh0ZW50LlxuICogQHJldHVybiB7RXh0ZW50fSBFeHRlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVRyYW5zZm9ybShleHRlbnQsIHRyYW5zZm9ybUZuLCBvcHRfZXh0ZW50KSB7XG4gIHZhciBjb29yZGluYXRlcyA9IFtcbiAgICBleHRlbnRbMF0sIGV4dGVudFsxXSxcbiAgICBleHRlbnRbMF0sIGV4dGVudFszXSxcbiAgICBleHRlbnRbMl0sIGV4dGVudFsxXSxcbiAgICBleHRlbnRbMl0sIGV4dGVudFszXVxuICBdO1xuICB0cmFuc2Zvcm1Gbihjb29yZGluYXRlcywgY29vcmRpbmF0ZXMsIDIpO1xuICB2YXIgeHMgPSBbY29vcmRpbmF0ZXNbMF0sIGNvb3JkaW5hdGVzWzJdLCBjb29yZGluYXRlc1s0XSwgY29vcmRpbmF0ZXNbNl1dO1xuICB2YXIgeXMgPSBbY29vcmRpbmF0ZXNbMV0sIGNvb3JkaW5hdGVzWzNdLCBjb29yZGluYXRlc1s1XSwgY29vcmRpbmF0ZXNbN11dO1xuICByZXR1cm4gX2JvdW5kaW5nRXh0ZW50WFlzKHhzLCB5cywgb3B0X2V4dGVudCk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4dGVudC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvZXh0ZW50L0Nvcm5lclxuICovXG5cbi8qKlxuICogRXh0ZW50IGNvcm5lci5cbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgQk9UVE9NX0xFRlQ6ICdib3R0b20tbGVmdCcsXG4gIEJPVFRPTV9SSUdIVDogJ2JvdHRvbS1yaWdodCcsXG4gIFRPUF9MRUZUOiAndG9wLWxlZnQnLFxuICBUT1BfUklHSFQ6ICd0b3AtcmlnaHQnXG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db3JuZXIuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2V4dGVudC9SZWxhdGlvbnNoaXBcbiAqL1xuXG4vKipcbiAqIFJlbGF0aW9uc2hpcCB0byBhbiBleHRlbnQuXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIFVOS05PV046IDAsXG4gIElOVEVSU0VDVElORzogMSxcbiAgQUJPVkU6IDIsXG4gIFJJR0hUOiA0LFxuICBCRUxPVzogOCxcbiAgTEVGVDogMTZcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlbGF0aW9uc2hpcC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvZmVhdHVyZWxvYWRlclxuICovXG5pbXBvcnQge1ZPSUR9IGZyb20gJy4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCBGb3JtYXRUeXBlIGZyb20gJy4vZm9ybWF0L0Zvcm1hdFR5cGUuanMnO1xuXG4vKipcbiAqIHtAbGluayBtb2R1bGU6b2wvc291cmNlL1ZlY3Rvcn0gc291cmNlcyB1c2UgYSBmdW5jdGlvbiBvZiB0aGlzIHR5cGUgdG9cbiAqIGxvYWQgZmVhdHVyZXMuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IHJlcHJlc2VudGluZyB0aGUgYXJlYSB0byBiZSBsb2FkZWQsXG4gKiBhIGB7bnVtYmVyfWAgcmVwcmVzZW50aW5nIHRoZSByZXNvbHV0aW9uIChtYXAgdW5pdHMgcGVyIHBpeGVsKSBhbmQgYW5cbiAqIHtAbGluayBtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBmb3IgdGhlIHByb2plY3Rpb24gIGFzXG4gKiBhcmd1bWVudHMuIGB0aGlzYCB3aXRoaW4gdGhlIGZ1bmN0aW9uIGlzIGJvdW5kIHRvIHRoZVxuICoge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yfSBpdCdzIGNhbGxlZCBmcm9tLlxuICpcbiAqIFRoZSBmdW5jdGlvbiBpcyByZXNwb25zaWJsZSBmb3IgbG9hZGluZyB0aGUgZmVhdHVyZXMgYW5kIGFkZGluZyB0aGVtIHRvIHRoZVxuICogc291cmNlLlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKHRoaXM6KGltcG9ydChcIi4vc291cmNlL1ZlY3RvclwiKS5kZWZhdWx0fGltcG9ydChcIi4vVmVjdG9yVGlsZS5qc1wiKS5kZWZhdWx0KSwgaW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50LCBudW1iZXIsXG4gKiAgICAgICAgICAgICAgICAgICAgaW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdCl9IEZlYXR1cmVMb2FkZXJcbiAqIEBhcGlcbiAqL1xuXG5cbi8qKlxuICoge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yfSBzb3VyY2VzIHVzZSBhIGZ1bmN0aW9uIG9mIHRoaXMgdHlwZSB0b1xuICogZ2V0IHRoZSB1cmwgdG8gbG9hZCBmZWF0dXJlcyBmcm9tLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSByZXByZXNlbnRpbmcgdGhlIGFyZWFcbiAqIHRvIGJlIGxvYWRlZCwgYSBge251bWJlcn1gIHJlcHJlc2VudGluZyB0aGUgcmVzb2x1dGlvbiAobWFwIHVuaXRzIHBlciBwaXhlbClcbiAqIGFuZCBhbiB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gZm9yIHRoZSBwcm9qZWN0aW9uICBhc1xuICogYXJndW1lbnRzIGFuZCByZXR1cm5zIGEgYHtzdHJpbmd9YCByZXByZXNlbnRpbmcgdGhlIFVSTC5cbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnQsIG51bWJlciwgaW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdCk6IHN0cmluZ30gRmVhdHVyZVVybEZ1bmN0aW9uXG4gKiBAYXBpXG4gKi9cblxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEZlYXR1cmVVcmxGdW5jdGlvbn0gdXJsIEZlYXR1cmUgVVJMIHNlcnZpY2UuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZm9ybWF0L0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZm9ybWF0IEZlYXR1cmUgZm9ybWF0LlxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOmltcG9ydChcIi4vVmVjdG9yVGlsZS5qc1wiKS5kZWZhdWx0LCBBcnJheTxpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuZGVmYXVsdD4sIGltcG9ydChcIi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHQsIGltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudCl8ZnVuY3Rpb24odGhpczppbXBvcnQoXCIuL3NvdXJjZS9WZWN0b3JcIikuZGVmYXVsdCwgQXJyYXk8aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+KX0gc3VjY2Vzc1xuICogICAgIEZ1bmN0aW9uIGNhbGxlZCB3aXRoIHRoZSBsb2FkZWQgZmVhdHVyZXMgYW5kIG9wdGlvbmFsbHkgd2l0aCB0aGUgZGF0YVxuICogICAgIHByb2plY3Rpb24uIENhbGxlZCB3aXRoIHRoZSB2ZWN0b3IgdGlsZSBvciBzb3VyY2UgYXMgYHRoaXNgLlxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOmltcG9ydChcIi4vVmVjdG9yVGlsZS5qc1wiKS5kZWZhdWx0KXxmdW5jdGlvbih0aGlzOmltcG9ydChcIi4vc291cmNlL1ZlY3RvclwiKS5kZWZhdWx0KX0gZmFpbHVyZVxuICogICAgIEZ1bmN0aW9uIGNhbGxlZCB3aGVuIGxvYWRpbmcgZmFpbGVkLiBDYWxsZWQgd2l0aCB0aGUgdmVjdG9yIHRpbGUgb3JcbiAqICAgICBzb3VyY2UgYXMgYHRoaXNgLlxuICogQHJldHVybiB7RmVhdHVyZUxvYWRlcn0gVGhlIGZlYXR1cmUgbG9hZGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbG9hZEZlYXR1cmVzWGhyKHVybCwgZm9ybWF0LCBzdWNjZXNzLCBmYWlsdXJlKSB7XG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICAgKiBAdGhpcyB7aW1wb3J0KFwiLi9zb3VyY2UvVmVjdG9yXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi9WZWN0b3JUaWxlLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgZnVuY3Rpb24oZXh0ZW50LCByZXNvbHV0aW9uLCBwcm9qZWN0aW9uKSB7XG4gICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICB4aHIub3BlbignR0VUJyxcbiAgICAgICAgdHlwZW9mIHVybCA9PT0gJ2Z1bmN0aW9uJyA/IHVybChleHRlbnQsIHJlc29sdXRpb24sIHByb2plY3Rpb24pIDogdXJsLFxuICAgICAgICB0cnVlKTtcbiAgICAgIGlmIChmb3JtYXQuZ2V0VHlwZSgpID09IEZvcm1hdFR5cGUuQVJSQVlfQlVGRkVSKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBFdmVudC5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAvLyBzdGF0dXMgd2lsbCBiZSAwIGZvciBmaWxlOi8vIHVybHNcbiAgICAgICAgaWYgKCF4aHIuc3RhdHVzIHx8IHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGZvcm1hdC5nZXRUeXBlKCk7XG4gICAgICAgICAgLyoqIEB0eXBlIHtEb2N1bWVudHxOb2RlfE9iamVjdHxzdHJpbmd8dW5kZWZpbmVkfSAqL1xuICAgICAgICAgIHZhciBzb3VyY2U7XG4gICAgICAgICAgaWYgKHR5cGUgPT0gRm9ybWF0VHlwZS5KU09OIHx8IHR5cGUgPT0gRm9ybWF0VHlwZS5URVhUKSB7XG4gICAgICAgICAgICBzb3VyY2UgPSB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSBGb3JtYXRUeXBlLlhNTCkge1xuICAgICAgICAgICAgc291cmNlID0geGhyLnJlc3BvbnNlWE1MO1xuICAgICAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICAgICAgc291cmNlID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyh4aHIucmVzcG9uc2VUZXh0LCAnYXBwbGljYXRpb24veG1sJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09IEZvcm1hdFR5cGUuQVJSQVlfQlVGRkVSKSB7XG4gICAgICAgICAgICBzb3VyY2UgPSAvKiogQHR5cGUge0FycmF5QnVmZmVyfSAqLyAoeGhyLnJlc3BvbnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgc3VjY2Vzcy5jYWxsKHRoaXMsIGZvcm1hdC5yZWFkRmVhdHVyZXMoc291cmNlLFxuICAgICAgICAgICAgICB7ZmVhdHVyZVByb2plY3Rpb246IHByb2plY3Rpb259KSxcbiAgICAgICAgICAgIGZvcm1hdC5yZWFkUHJvamVjdGlvbihzb3VyY2UpLCBmb3JtYXQuZ2V0TGFzdEV4dGVudCgpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmFpbHVyZS5jYWxsKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmYWlsdXJlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKTtcbiAgICAgIC8qKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZmFpbHVyZS5jYWxsKHRoaXMpO1xuICAgICAgfS5iaW5kKHRoaXMpO1xuICAgICAgeGhyLnNlbmQoKTtcbiAgICB9XG4gICk7XG59XG5cblxuLyoqXG4gKiBDcmVhdGUgYW4gWEhSIGZlYXR1cmUgbG9hZGVyIGZvciBhIGB1cmxgIGFuZCBgZm9ybWF0YC4gVGhlIGZlYXR1cmUgbG9hZGVyXG4gKiBsb2FkcyBmZWF0dXJlcyAod2l0aCBYSFIpLCBwYXJzZXMgdGhlIGZlYXR1cmVzLCBhbmQgYWRkcyB0aGVtIHRvIHRoZVxuICogdmVjdG9yIHNvdXJjZS5cbiAqIEBwYXJhbSB7c3RyaW5nfEZlYXR1cmVVcmxGdW5jdGlvbn0gdXJsIEZlYXR1cmUgVVJMIHNlcnZpY2UuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZm9ybWF0L0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZm9ybWF0IEZlYXR1cmUgZm9ybWF0LlxuICogQHJldHVybiB7RmVhdHVyZUxvYWRlcn0gVGhlIGZlYXR1cmUgbG9hZGVyLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24geGhyKHVybCwgZm9ybWF0KSB7XG4gIHJldHVybiBsb2FkRmVhdHVyZXNYaHIodXJsLCBmb3JtYXQsXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59IGZlYXR1cmVzIFRoZSBsb2FkZWQgZmVhdHVyZXMuXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBkYXRhUHJvamVjdGlvbiBEYXRhXG4gICAgICogcHJvamVjdGlvbi5cbiAgICAgKiBAdGhpcyB7aW1wb3J0KFwiLi9zb3VyY2UvVmVjdG9yXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi9WZWN0b3JUaWxlLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgZnVuY3Rpb24oZmVhdHVyZXMsIGRhdGFQcm9qZWN0aW9uKSB7XG4gICAgICB2YXIgc291cmNlT3JUaWxlID0gLyoqIEB0eXBlIHs/fSAqLyAodGhpcyk7XG4gICAgICBpZiAodHlwZW9mIHNvdXJjZU9yVGlsZS5hZGRGZWF0dXJlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4vc291cmNlL1ZlY3RvclwiKS5kZWZhdWx0fSAqLyAoc291cmNlT3JUaWxlKS5hZGRGZWF0dXJlcyhmZWF0dXJlcyk7XG4gICAgICB9XG4gICAgfSwgLyogRklYTUUgaGFuZGxlIGVycm9yICovIFZPSUQpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mZWF0dXJlbG9hZGVyLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9mb3JtYXQvRm9ybWF0VHlwZVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBBUlJBWV9CVUZGRVI6ICdhcnJheWJ1ZmZlcicsXG4gIEpTT046ICdqc29uJyxcbiAgVEVYVDogJ3RleHQnLFxuICBYTUw6ICd4bWwnXG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Gb3JtYXRUeXBlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9mdW5jdGlvbnNcbiAqL1xuXG4vKipcbiAqIEFsd2F5cyByZXR1cm5zIHRydWUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFRSVUUoKSB7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEFsd2F5cyByZXR1cm5zIGZhbHNlLlxuICogQHJldHVybnMge2Jvb2xlYW59IGZhbHNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gRkFMU0UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBBIHJldXNhYmxlIGZ1bmN0aW9uLCB1c2VkIGUuZy4gYXMgYSBkZWZhdWx0IGZvciBjYWxsYmFja3MuXG4gKlxuICogQHJldHVybiB7dm9pZH0gTm90aGluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFZPSUQoKSB7fVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mdW5jdGlvbnMuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vQ2lyY2xlXG4gKi9cbmltcG9ydCB7Y3JlYXRlT3JVcGRhdGUsIGZvckVhY2hDb3JuZXIsIGludGVyc2VjdHN9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQgR2VvbWV0cnlUeXBlIGZyb20gJy4vR2VvbWV0cnlUeXBlLmpzJztcbmltcG9ydCBTaW1wbGVHZW9tZXRyeSBmcm9tICcuL1NpbXBsZUdlb21ldHJ5LmpzJztcbmltcG9ydCB7ZGVmbGF0ZUNvb3JkaW5hdGV9IGZyb20gJy4vZmxhdC9kZWZsYXRlLmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBDaXJjbGUgZ2VvbWV0cnkuXG4gKlxuICogQGFwaVxuICovXG52YXIgQ2lyY2xlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoU2ltcGxlR2VvbWV0cnkpIHtcbiAgZnVuY3Rpb24gQ2lyY2xlKGNlbnRlciwgb3B0X3JhZGl1cywgb3B0X2xheW91dCkge1xuICAgIFNpbXBsZUdlb21ldHJ5LmNhbGwodGhpcyk7XG4gICAgaWYgKG9wdF9sYXlvdXQgIT09IHVuZGVmaW5lZCAmJiBvcHRfcmFkaXVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuc2V0RmxhdENvb3JkaW5hdGVzKG9wdF9sYXlvdXQsIGNlbnRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByYWRpdXMgPSBvcHRfcmFkaXVzID8gb3B0X3JhZGl1cyA6IDA7XG4gICAgICB0aGlzLnNldENlbnRlckFuZFJhZGl1cyhjZW50ZXIsIHJhZGl1cywgb3B0X2xheW91dCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCBTaW1wbGVHZW9tZXRyeSApIENpcmNsZS5fX3Byb3RvX18gPSBTaW1wbGVHZW9tZXRyeTtcbiAgQ2lyY2xlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFNpbXBsZUdlb21ldHJ5ICYmIFNpbXBsZUdlb21ldHJ5LnByb3RvdHlwZSApO1xuICBDaXJjbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2lyY2xlO1xuXG4gIC8qKlxuICAgKiBNYWtlIGEgY29tcGxldGUgY29weSBvZiB0aGUgZ2VvbWV0cnkuXG4gICAqIEByZXR1cm4geyFDaXJjbGV9IENsb25lLlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGFwaVxuICAgKi9cbiAgQ2lyY2xlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgICByZXR1cm4gbmV3IENpcmNsZSh0aGlzLmZsYXRDb29yZGluYXRlcy5zbGljZSgpLCB1bmRlZmluZWQsIHRoaXMubGF5b3V0KTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENpcmNsZS5wcm90b3R5cGUuY2xvc2VzdFBvaW50WFkgPSBmdW5jdGlvbiBjbG9zZXN0UG9pbnRYWSAoeCwgeSwgY2xvc2VzdFBvaW50LCBtaW5TcXVhcmVkRGlzdGFuY2UpIHtcbiAgICB2YXIgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5mbGF0Q29vcmRpbmF0ZXM7XG4gICAgdmFyIGR4ID0geCAtIGZsYXRDb29yZGluYXRlc1swXTtcbiAgICB2YXIgZHkgPSB5IC0gZmxhdENvb3JkaW5hdGVzWzFdO1xuICAgIHZhciBzcXVhcmVkRGlzdGFuY2UgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICBpZiAoc3F1YXJlZERpc3RhbmNlIDwgbWluU3F1YXJlZERpc3RhbmNlKSB7XG4gICAgICBpZiAoc3F1YXJlZERpc3RhbmNlID09PSAwKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdHJpZGU7ICsraSkge1xuICAgICAgICAgIGNsb3Nlc3RQb2ludFtpXSA9IGZsYXRDb29yZGluYXRlc1tpXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGRlbHRhID0gdGhpcy5nZXRSYWRpdXMoKSAvIE1hdGguc3FydChzcXVhcmVkRGlzdGFuY2UpO1xuICAgICAgICBjbG9zZXN0UG9pbnRbMF0gPSBmbGF0Q29vcmRpbmF0ZXNbMF0gKyBkZWx0YSAqIGR4O1xuICAgICAgICBjbG9zZXN0UG9pbnRbMV0gPSBmbGF0Q29vcmRpbmF0ZXNbMV0gKyBkZWx0YSAqIGR5O1xuICAgICAgICBmb3IgKHZhciBpJDEgPSAyOyBpJDEgPCB0aGlzLnN0cmlkZTsgKytpJDEpIHtcbiAgICAgICAgICBjbG9zZXN0UG9pbnRbaSQxXSA9IGZsYXRDb29yZGluYXRlc1tpJDFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjbG9zZXN0UG9pbnQubGVuZ3RoID0gdGhpcy5zdHJpZGU7XG4gICAgICByZXR1cm4gc3F1YXJlZERpc3RhbmNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWluU3F1YXJlZERpc3RhbmNlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENpcmNsZS5wcm90b3R5cGUuY29udGFpbnNYWSA9IGZ1bmN0aW9uIGNvbnRhaW5zWFkgKHgsIHkpIHtcbiAgICB2YXIgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5mbGF0Q29vcmRpbmF0ZXM7XG4gICAgdmFyIGR4ID0geCAtIGZsYXRDb29yZGluYXRlc1swXTtcbiAgICB2YXIgZHkgPSB5IC0gZmxhdENvb3JkaW5hdGVzWzFdO1xuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeSA8PSB0aGlzLmdldFJhZGl1c1NxdWFyZWRfKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGUgYXMge0BsaW5rIG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGUgY29vcmRpbmF0ZX0uXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gQ2VudGVyLlxuICAgKiBAYXBpXG4gICAqL1xuICBDaXJjbGUucHJvdG90eXBlLmdldENlbnRlciA9IGZ1bmN0aW9uIGdldENlbnRlciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmxhdENvb3JkaW5hdGVzLnNsaWNlKDAsIHRoaXMuc3RyaWRlKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENpcmNsZS5wcm90b3R5cGUuY29tcHV0ZUV4dGVudCA9IGZ1bmN0aW9uIGNvbXB1dGVFeHRlbnQgKGV4dGVudCkge1xuICAgIHZhciBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmZsYXRDb29yZGluYXRlcztcbiAgICB2YXIgcmFkaXVzID0gZmxhdENvb3JkaW5hdGVzW3RoaXMuc3RyaWRlXSAtIGZsYXRDb29yZGluYXRlc1swXTtcbiAgICByZXR1cm4gY3JlYXRlT3JVcGRhdGUoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXNbMF0gLSByYWRpdXMsIGZsYXRDb29yZGluYXRlc1sxXSAtIHJhZGl1cyxcbiAgICAgIGZsYXRDb29yZGluYXRlc1swXSArIHJhZGl1cywgZmxhdENvb3JkaW5hdGVzWzFdICsgcmFkaXVzLFxuICAgICAgZXh0ZW50KTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBSYWRpdXMuXG4gICAqIEBhcGlcbiAgICovXG4gIENpcmNsZS5wcm90b3R5cGUuZ2V0UmFkaXVzID0gZnVuY3Rpb24gZ2V0UmFkaXVzICgpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZ2V0UmFkaXVzU3F1YXJlZF8oKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge251bWJlcn0gUmFkaXVzIHNxdWFyZWQuXG4gICAqL1xuICBDaXJjbGUucHJvdG90eXBlLmdldFJhZGl1c1NxdWFyZWRfID0gZnVuY3Rpb24gZ2V0UmFkaXVzU3F1YXJlZF8gKCkge1xuICAgIHZhciBkeCA9IHRoaXMuZmxhdENvb3JkaW5hdGVzW3RoaXMuc3RyaWRlXSAtIHRoaXMuZmxhdENvb3JkaW5hdGVzWzBdO1xuICAgIHZhciBkeSA9IHRoaXMuZmxhdENvb3JkaW5hdGVzW3RoaXMuc3RyaWRlICsgMV0gLSB0aGlzLmZsYXRDb29yZGluYXRlc1sxXTtcbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqIEBhcGlcbiAgICovXG4gIENpcmNsZS5wcm90b3R5cGUuZ2V0VHlwZSA9IGZ1bmN0aW9uIGdldFR5cGUgKCkge1xuICAgIHJldHVybiBHZW9tZXRyeVR5cGUuQ0lSQ0xFO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKiBAYXBpXG4gICAqL1xuICBDaXJjbGUucHJvdG90eXBlLmludGVyc2VjdHNFeHRlbnQgPSBmdW5jdGlvbiBpbnRlcnNlY3RzRXh0ZW50IChleHRlbnQpIHtcbiAgICB2YXIgY2lyY2xlRXh0ZW50ID0gdGhpcy5nZXRFeHRlbnQoKTtcbiAgICBpZiAoaW50ZXJzZWN0cyhleHRlbnQsIGNpcmNsZUV4dGVudCkpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlcigpO1xuXG4gICAgICBpZiAoZXh0ZW50WzBdIDw9IGNlbnRlclswXSAmJiBleHRlbnRbMl0gPj0gY2VudGVyWzBdKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGV4dGVudFsxXSA8PSBjZW50ZXJbMV0gJiYgZXh0ZW50WzNdID49IGNlbnRlclsxXSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZvckVhY2hDb3JuZXIoZXh0ZW50LCB0aGlzLmludGVyc2VjdHNDb29yZGluYXRlLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGUgYXMge0BsaW5rIG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGUgY29vcmRpbmF0ZX0uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjZW50ZXIgQ2VudGVyLlxuICAgKiBAYXBpXG4gICAqL1xuICBDaXJjbGUucHJvdG90eXBlLnNldENlbnRlciA9IGZ1bmN0aW9uIHNldENlbnRlciAoY2VudGVyKSB7XG4gICAgdmFyIHN0cmlkZSA9IHRoaXMuc3RyaWRlO1xuICAgIHZhciByYWRpdXMgPSB0aGlzLmZsYXRDb29yZGluYXRlc1tzdHJpZGVdIC0gdGhpcy5mbGF0Q29vcmRpbmF0ZXNbMF07XG4gICAgdmFyIGZsYXRDb29yZGluYXRlcyA9IGNlbnRlci5zbGljZSgpO1xuICAgIGZsYXRDb29yZGluYXRlc1tzdHJpZGVdID0gZmxhdENvb3JkaW5hdGVzWzBdICsgcmFkaXVzO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgc3RyaWRlOyArK2kpIHtcbiAgICAgIGZsYXRDb29yZGluYXRlc1tzdHJpZGUgKyBpXSA9IGNlbnRlcltpXTtcbiAgICB9XG4gICAgdGhpcy5zZXRGbGF0Q29vcmRpbmF0ZXModGhpcy5sYXlvdXQsIGZsYXRDb29yZGluYXRlcyk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY2VudGVyIChhcyB7QGxpbmsgbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZSBjb29yZGluYXRlfSkgYW5kIHRoZSByYWRpdXMgKGFzXG4gICAqIG51bWJlcikgb2YgdGhlIGNpcmNsZS5cbiAgICogQHBhcmFtIHshaW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjZW50ZXIgQ2VudGVyLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFJhZGl1cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0dlb21ldHJ5TGF5b3V0LmpzXCIpLmRlZmF1bHQ9fSBvcHRfbGF5b3V0IExheW91dC5cbiAgICogQGFwaVxuICAgKi9cbiAgQ2lyY2xlLnByb3RvdHlwZS5zZXRDZW50ZXJBbmRSYWRpdXMgPSBmdW5jdGlvbiBzZXRDZW50ZXJBbmRSYWRpdXMgKGNlbnRlciwgcmFkaXVzLCBvcHRfbGF5b3V0KSB7XG4gICAgdGhpcy5zZXRMYXlvdXQob3B0X2xheW91dCwgY2VudGVyLCAwKTtcbiAgICBpZiAoIXRoaXMuZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyA9IFtdO1xuICAgIH1cbiAgICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovXG4gICAgdmFyIGZsYXRDb29yZGluYXRlcyA9IHRoaXMuZmxhdENvb3JkaW5hdGVzO1xuICAgIHZhciBvZmZzZXQgPSBkZWZsYXRlQ29vcmRpbmF0ZShcbiAgICAgIGZsYXRDb29yZGluYXRlcywgMCwgY2VudGVyLCB0aGlzLnN0cmlkZSk7XG4gICAgZmxhdENvb3JkaW5hdGVzW29mZnNldCsrXSA9IGZsYXRDb29yZGluYXRlc1swXSArIHJhZGl1cztcbiAgICBmb3IgKHZhciBpID0gMSwgaWkgPSB0aGlzLnN0cmlkZTsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGZsYXRDb29yZGluYXRlc1tvZmZzZXQrK10gPSBmbGF0Q29vcmRpbmF0ZXNbaV07XG4gICAgfVxuICAgIGZsYXRDb29yZGluYXRlcy5sZW5ndGggPSBvZmZzZXQ7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDaXJjbGUucHJvdG90eXBlLmdldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZXMgKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQ2lyY2xlLnByb3RvdHlwZS5zZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIHNldENvb3JkaW5hdGVzIChjb29yZGluYXRlcywgb3B0X2xheW91dCkge307XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcmFkaXVzIG9mIHRoZSBjaXJjbGUuIFRoZSByYWRpdXMgaXMgaW4gdGhlIHVuaXRzIG9mIHRoZSBwcm9qZWN0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFJhZGl1cy5cbiAgICogQGFwaVxuICAgKi9cbiAgQ2lyY2xlLnByb3RvdHlwZS5zZXRSYWRpdXMgPSBmdW5jdGlvbiBzZXRSYWRpdXMgKHJhZGl1cykge1xuICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzW3RoaXMuc3RyaWRlXSA9IHRoaXMuZmxhdENvb3JkaW5hdGVzWzBdICsgcmFkaXVzO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9O1xuXG4gIHJldHVybiBDaXJjbGU7XG59KFNpbXBsZUdlb21ldHJ5KSk7XG5cblxuLyoqXG4gKiBUcmFuc2Zvcm0gZWFjaCBjb29yZGluYXRlIG9mIHRoZSBjaXJjbGUgZnJvbSBvbmUgY29vcmRpbmF0ZSByZWZlcmVuY2Ugc3lzdGVtXG4gKiB0byBhbm90aGVyLiBUaGUgZ2VvbWV0cnkgaXMgbW9kaWZpZWQgaW4gcGxhY2UuXG4gKiBJZiB5b3UgZG8gbm90IHdhbnQgdGhlIGdlb21ldHJ5IG1vZGlmaWVkIGluIHBsYWNlLCBmaXJzdCBjbG9uZSgpIGl0IGFuZFxuICogdGhlbiB1c2UgdGhpcyBmdW5jdGlvbiBvbiB0aGUgY2xvbmUuXG4gKlxuICogSW50ZXJuYWxseSBhIGNpcmNsZSBpcyBjdXJyZW50bHkgcmVwcmVzZW50ZWQgYnkgdHdvIHBvaW50czogdGhlIGNlbnRlciBvZlxuICogdGhlIGNpcmNsZSBgW2N4LCBjeV1gLCBhbmQgdGhlIHBvaW50IHRvIHRoZSByaWdodCBvZiB0aGUgY2lyY2xlXG4gKiBgW2N4ICsgciwgY3ldYC4gVGhpcyBgdHJhbnNmb3JtYCBmdW5jdGlvbiBqdXN0IHRyYW5zZm9ybXMgdGhlc2UgdHdvIHBvaW50cy5cbiAqIFNvIHRoZSByZXN1bHRpbmcgZ2VvbWV0cnkgaXMgYWxzbyBhIGNpcmNsZSwgYW5kIHRoYXQgY2lyY2xlIGRvZXMgbm90XG4gKiBjb3JyZXNwb25kIHRvIHRoZSBzaGFwZSB0aGF0IHdvdWxkIGJlIG9idGFpbmVkIGJ5IHRyYW5zZm9ybWluZyBldmVyeSBwb2ludFxuICogb2YgdGhlIG9yaWdpbmFsIGNpcmNsZS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ouanNcIikuUHJvamVjdGlvbkxpa2V9IHNvdXJjZSBUaGUgY3VycmVudCBwcm9qZWN0aW9uLiAgQ2FuIGJlIGFcbiAqICAgICBzdHJpbmcgaWRlbnRpZmllciBvciBhIHtAbGluayBtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9uflByb2plY3Rpb259IG9iamVjdC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gZGVzdGluYXRpb24gVGhlIGRlc2lyZWQgcHJvamVjdGlvbi4gIENhbiBiZSBhXG4gKiAgICAgc3RyaW5nIGlkZW50aWZpZXIgb3IgYSB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn5Qcm9qZWN0aW9ufSBvYmplY3QuXG4gKiBAcmV0dXJuIHtDaXJjbGV9IFRoaXMgZ2VvbWV0cnkuICBOb3RlIHRoYXQgb3JpZ2luYWwgZ2VvbWV0cnkgaXNcbiAqICAgICBtb2RpZmllZCBpbiBwbGFjZS5cbiAqIEBmdW5jdGlvblxuICogQGFwaVxuICovXG5DaXJjbGUucHJvdG90eXBlLnRyYW5zZm9ybTtcbmV4cG9ydCBkZWZhdWx0IENpcmNsZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2lyY2xlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL0dlb21ldHJ5XG4gKi9cbmltcG9ydCB7YWJzdHJhY3R9IGZyb20gJy4uL3V0aWwuanMnO1xuaW1wb3J0IEJhc2VPYmplY3QgZnJvbSAnLi4vT2JqZWN0LmpzJztcbmltcG9ydCB7Y3JlYXRlRW1wdHksIGdldEhlaWdodCwgcmV0dXJuT3JVcGRhdGV9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge3RyYW5zZm9ybTJEfSBmcm9tICcuL2ZsYXQvdHJhbnNmb3JtLmpzJztcbmltcG9ydCB7Z2V0IGFzIGdldFByb2plY3Rpb24sIGdldFRyYW5zZm9ybX0gZnJvbSAnLi4vcHJvai5qcyc7XG5pbXBvcnQgVW5pdHMgZnJvbSAnLi4vcHJvai9Vbml0cy5qcyc7XG5pbXBvcnQge2NyZWF0ZSBhcyBjcmVhdGVUcmFuc2Zvcm0sIGNvbXBvc2UgYXMgY29tcG9zZVRyYW5zZm9ybX0gZnJvbSAnLi4vdHJhbnNmb3JtLmpzJztcblxuXG4vKipcbiAqIEB0eXBlIHtpbXBvcnQoXCIuLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfVxuICovXG52YXIgdG1wVHJhbnNmb3JtID0gY3JlYXRlVHJhbnNmb3JtKCk7XG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzOyBub3JtYWxseSBvbmx5IHVzZWQgZm9yIGNyZWF0aW5nIHN1YmNsYXNzZXMgYW5kIG5vdFxuICogaW5zdGFudGlhdGVkIGluIGFwcHMuXG4gKiBCYXNlIGNsYXNzIGZvciB2ZWN0b3IgZ2VvbWV0cmllcy5cbiAqXG4gKiBUbyBnZXQgbm90aWZpZWQgb2YgY2hhbmdlcyB0byB0aGUgZ2VvbWV0cnksIHJlZ2lzdGVyIGEgbGlzdGVuZXIgZm9yIHRoZVxuICogZ2VuZXJpYyBgY2hhbmdlYCBldmVudCBvbiB5b3VyIGdlb21ldHJ5IGluc3RhbmNlLlxuICpcbiAqIEBhYnN0cmFjdFxuICogQGFwaVxuICovXG52YXIgR2VvbWV0cnkgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChCYXNlT2JqZWN0KSB7XG4gIGZ1bmN0aW9uIEdlb21ldHJ5KCkge1xuXG4gICAgQmFzZU9iamVjdC5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAgICAgKi9cbiAgICB0aGlzLmV4dGVudF8gPSBjcmVhdGVFbXB0eSgpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZXh0ZW50UmV2aXNpb25fID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsIEdlb21ldHJ5Pn1cbiAgICAgKi9cbiAgICB0aGlzLnNpbXBsaWZpZWRHZW9tZXRyeUNhY2hlID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnNpbXBsaWZpZWRHZW9tZXRyeU1heE1pblNxdWFyZWRUb2xlcmFuY2UgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zaW1wbGlmaWVkR2VvbWV0cnlSZXZpc2lvbiA9IDA7XG5cbiAgfVxuXG4gIGlmICggQmFzZU9iamVjdCApIEdlb21ldHJ5Ll9fcHJvdG9fXyA9IEJhc2VPYmplY3Q7XG4gIEdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJhc2VPYmplY3QgJiYgQmFzZU9iamVjdC5wcm90b3R5cGUgKTtcbiAgR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VvbWV0cnk7XG5cbiAgLyoqXG4gICAqIE1ha2UgYSBjb21wbGV0ZSBjb3B5IG9mIHRoZSBnZW9tZXRyeS5cbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4geyFHZW9tZXRyeX0gQ2xvbmUuXG4gICAqL1xuICBHZW9tZXRyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY2xvc2VzdFBvaW50IENsb3Nlc3QgcG9pbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5TcXVhcmVkRGlzdGFuY2UgTWluaW11bSBzcXVhcmVkIGRpc3RhbmNlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE1pbmltdW0gc3F1YXJlZCBkaXN0YW5jZS5cbiAgICovXG4gIEdlb21ldHJ5LnByb3RvdHlwZS5jbG9zZXN0UG9pbnRYWSA9IGZ1bmN0aW9uIGNsb3Nlc3RQb2ludFhZICh4LCB5LCBjbG9zZXN0UG9pbnQsIG1pblNxdWFyZWREaXN0YW5jZSkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBDb250YWlucyAoeCwgeSkuXG4gICAqL1xuICBHZW9tZXRyeS5wcm90b3R5cGUuY29udGFpbnNYWSA9IGZ1bmN0aW9uIGNvbnRhaW5zWFkgKHgsIHkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY2xvc2VzdCBwb2ludCBvZiB0aGUgZ2VvbWV0cnkgdG8gdGhlIHBhc3NlZCBwb2ludCBhc1xuICAgKiB7QGxpbmsgbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZSBjb29yZGluYXRlfS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IHBvaW50IFBvaW50LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT19IG9wdF9jbG9zZXN0UG9pbnQgQ2xvc2VzdCBwb2ludC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBDbG9zZXN0IHBvaW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBHZW9tZXRyeS5wcm90b3R5cGUuZ2V0Q2xvc2VzdFBvaW50ID0gZnVuY3Rpb24gZ2V0Q2xvc2VzdFBvaW50IChwb2ludCwgb3B0X2Nsb3Nlc3RQb2ludCkge1xuICAgIHZhciBjbG9zZXN0UG9pbnQgPSBvcHRfY2xvc2VzdFBvaW50ID8gb3B0X2Nsb3Nlc3RQb2ludCA6IFtOYU4sIE5hTl07XG4gICAgdGhpcy5jbG9zZXN0UG9pbnRYWShwb2ludFswXSwgcG9pbnRbMV0sIGNsb3Nlc3RQb2ludCwgSW5maW5pdHkpO1xuICAgIHJldHVybiBjbG9zZXN0UG9pbnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGdlb21ldHJ5IGluY2x1ZGVzIHRoZSBzcGVjaWZpZWQgY29vcmRpbmF0ZS4gSWYgdGhlXG4gICAqIGNvb3JkaW5hdGUgaXMgb24gdGhlIGJvdW5kYXJ5IG9mIHRoZSBnZW9tZXRyeSwgcmV0dXJucyBmYWxzZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gQ29udGFpbnMgY29vcmRpbmF0ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgR2VvbWV0cnkucHJvdG90eXBlLmludGVyc2VjdHNDb29yZGluYXRlID0gZnVuY3Rpb24gaW50ZXJzZWN0c0Nvb3JkaW5hdGUgKGNvb3JkaW5hdGUpIHtcbiAgICByZXR1cm4gdGhpcy5jb250YWluc1hZKGNvb3JkaW5hdGVbMF0sIGNvb3JkaW5hdGVbMV0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqL1xuICBHZW9tZXRyeS5wcm90b3R5cGUuY29tcHV0ZUV4dGVudCA9IGZ1bmN0aW9uIGNvbXB1dGVFeHRlbnQgKGV4dGVudCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGV4dGVudCBvZiB0aGUgZ2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudD19IG9wdF9leHRlbnQgRXh0ZW50LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBHZW9tZXRyeS5wcm90b3R5cGUuZ2V0RXh0ZW50ID0gZnVuY3Rpb24gZ2V0RXh0ZW50IChvcHRfZXh0ZW50KSB7XG4gICAgaWYgKHRoaXMuZXh0ZW50UmV2aXNpb25fICE9IHRoaXMuZ2V0UmV2aXNpb24oKSkge1xuICAgICAgdGhpcy5leHRlbnRfID0gdGhpcy5jb21wdXRlRXh0ZW50KHRoaXMuZXh0ZW50Xyk7XG4gICAgICB0aGlzLmV4dGVudFJldmlzaW9uXyA9IHRoaXMuZ2V0UmV2aXNpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldHVybk9yVXBkYXRlKHRoaXMuZXh0ZW50Xywgb3B0X2V4dGVudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJvdGF0ZSB0aGUgZ2VvbWV0cnkgYXJvdW5kIGEgZ2l2ZW4gY29vcmRpbmF0ZS4gVGhpcyBtb2RpZmllcyB0aGUgZ2VvbWV0cnlcbiAgICogY29vcmRpbmF0ZXMgaW4gcGxhY2UuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGUgUm90YXRpb24gYW5nbGUgaW4gcmFkaWFucy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGFuY2hvciBUaGUgcm90YXRpb24gY2VudGVyLlxuICAgKiBAYXBpXG4gICAqL1xuICBHZW9tZXRyeS5wcm90b3R5cGUucm90YXRlID0gZnVuY3Rpb24gcm90YXRlIChhbmdsZSwgYW5jaG9yKSB7XG4gICAgYWJzdHJhY3QoKTtcbiAgfTtcblxuICAvKipcbiAgICogU2NhbGUgdGhlIGdlb21ldHJ5ICh3aXRoIGFuIG9wdGlvbmFsIG9yaWdpbikuICBUaGlzIG1vZGlmaWVzIHRoZSBnZW9tZXRyeVxuICAgKiBjb29yZGluYXRlcyBpbiBwbGFjZS5cbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzeCBUaGUgc2NhbGluZyBmYWN0b3IgaW4gdGhlIHgtZGlyZWN0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcj19IG9wdF9zeSBUaGUgc2NhbGluZyBmYWN0b3IgaW4gdGhlIHktZGlyZWN0aW9uIChkZWZhdWx0cyB0b1xuICAgKiAgICAgc3gpLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT19IG9wdF9hbmNob3IgVGhlIHNjYWxlIG9yaWdpbiAoZGVmYXVsdHMgdG8gdGhlIGNlbnRlclxuICAgKiAgICAgb2YgdGhlIGdlb21ldHJ5IGV4dGVudCkuXG4gICAqIEBhcGlcbiAgICovXG4gIEdlb21ldHJ5LnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uIHNjYWxlIChzeCwgb3B0X3N5LCBvcHRfYW5jaG9yKSB7XG4gICAgYWJzdHJhY3QoKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgc2ltcGxpZmllZCB2ZXJzaW9uIG9mIHRoaXMgZ2VvbWV0cnkuICBGb3IgbGluZXN0cmluZ3MsIHRoaXMgdXNlc1xuICAgKiB0aGUgdGhlIHtAbGlua1xuICAgKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SYW1lci1Eb3VnbGFzLVBldWNrZXJfYWxnb3JpdGhtXG4gICAqIERvdWdsYXMgUGV1Y2tlcn0gYWxnb3JpdGhtLiAgRm9yIHBvbHlnb25zLCBhIHF1YW50aXphdGlvbi1iYXNlZFxuICAgKiBzaW1wbGlmaWNhdGlvbiBpcyB1c2VkIHRvIHByZXNlcnZlIHRvcG9sb2d5LlxuICAgKiBAcGFyYW0ge251bWJlcn0gdG9sZXJhbmNlIFRoZSB0b2xlcmFuY2UgZGlzdGFuY2UgZm9yIHNpbXBsaWZpY2F0aW9uLlxuICAgKiBAcmV0dXJuIHtHZW9tZXRyeX0gQSBuZXcsIHNpbXBsaWZpZWQgdmVyc2lvbiBvZiB0aGUgb3JpZ2luYWwgZ2VvbWV0cnkuXG4gICAqIEBhcGlcbiAgICovXG4gIEdlb21ldHJ5LnByb3RvdHlwZS5zaW1wbGlmeSA9IGZ1bmN0aW9uIHNpbXBsaWZ5ICh0b2xlcmFuY2UpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTaW1wbGlmaWVkR2VvbWV0cnkodG9sZXJhbmNlICogdG9sZXJhbmNlKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgc2ltcGxpZmllZCB2ZXJzaW9uIG9mIHRoaXMgZ2VvbWV0cnkgdXNpbmcgdGhlIERvdWdsYXMgUGV1Y2tlclxuICAgKiBhbGdvcml0aG0uXG4gICAqIFNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SYW1lci1Eb3VnbGFzLVBldWNrZXJfYWxnb3JpdGhtLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNxdWFyZWRUb2xlcmFuY2UgU3F1YXJlZCB0b2xlcmFuY2UuXG4gICAqIEByZXR1cm4ge0dlb21ldHJ5fSBTaW1wbGlmaWVkIGdlb21ldHJ5LlxuICAgKi9cbiAgR2VvbWV0cnkucHJvdG90eXBlLmdldFNpbXBsaWZpZWRHZW9tZXRyeSA9IGZ1bmN0aW9uIGdldFNpbXBsaWZpZWRHZW9tZXRyeSAoc3F1YXJlZFRvbGVyYW5jZSkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHR5cGUgb2YgdGhpcyBnZW9tZXRyeS5cbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vR2VvbWV0cnlUeXBlLmpzXCIpLmRlZmF1bHR9IEdlb21ldHJ5IHR5cGUuXG4gICAqL1xuICBHZW9tZXRyeS5wcm90b3R5cGUuZ2V0VHlwZSA9IGZ1bmN0aW9uIGdldFR5cGUgKCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBcHBseSBhIHRyYW5zZm9ybSBmdW5jdGlvbiB0byBlYWNoIGNvb3JkaW5hdGUgb2YgdGhlIGdlb21ldHJ5LlxuICAgKiBUaGUgZ2VvbWV0cnkgaXMgbW9kaWZpZWQgaW4gcGxhY2UuXG4gICAqIElmIHlvdSBkbyBub3Qgd2FudCB0aGUgZ2VvbWV0cnkgbW9kaWZpZWQgaW4gcGxhY2UsIGZpcnN0IGBjbG9uZSgpYCBpdCBhbmRcbiAgICogdGhlbiB1c2UgdGhpcyBmdW5jdGlvbiBvbiB0aGUgY2xvbmUuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ouanNcIikuVHJhbnNmb3JtRnVuY3Rpb259IHRyYW5zZm9ybUZuIFRyYW5zZm9ybS5cbiAgICovXG4gIEdlb21ldHJ5LnByb3RvdHlwZS5hcHBseVRyYW5zZm9ybSA9IGZ1bmN0aW9uIGFwcGx5VHJhbnNmb3JtICh0cmFuc2Zvcm1Gbikge1xuICAgIGFic3RyYWN0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRlc3QgaWYgdGhlIGdlb21ldHJ5IGFuZCB0aGUgcGFzc2VkIGV4dGVudCBpbnRlcnNlY3QuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgZ2VvbWV0cnkgYW5kIHRoZSBleHRlbnQgaW50ZXJzZWN0LlxuICAgKi9cbiAgR2VvbWV0cnkucHJvdG90eXBlLmludGVyc2VjdHNFeHRlbnQgPSBmdW5jdGlvbiBpbnRlcnNlY3RzRXh0ZW50IChleHRlbnQpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfTtcblxuICAvKipcbiAgICogVHJhbnNsYXRlIHRoZSBnZW9tZXRyeS4gIFRoaXMgbW9kaWZpZXMgdGhlIGdlb21ldHJ5IGNvb3JkaW5hdGVzIGluIHBsYWNlLiAgSWZcbiAgICogaW5zdGVhZCB5b3Ugd2FudCBhIG5ldyBnZW9tZXRyeSwgZmlyc3QgYGNsb25lKClgIHRoaXMgZ2VvbWV0cnkuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFYIERlbHRhIFguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVkgRGVsdGEgWS5cbiAgICogQGFwaVxuICAgKi9cbiAgR2VvbWV0cnkucHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIHRyYW5zbGF0ZSAoZGVsdGFYLCBkZWx0YVkpIHtcbiAgICBhYnN0cmFjdCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm0gZWFjaCBjb29yZGluYXRlIG9mIHRoZSBnZW9tZXRyeSBmcm9tIG9uZSBjb29yZGluYXRlIHJlZmVyZW5jZVxuICAgKiBzeXN0ZW0gdG8gYW5vdGhlci4gVGhlIGdlb21ldHJ5IGlzIG1vZGlmaWVkIGluIHBsYWNlLlxuICAgKiBGb3IgZXhhbXBsZSwgYSBsaW5lIHdpbGwgYmUgdHJhbnNmb3JtZWQgdG8gYSBsaW5lIGFuZCBhIGNpcmNsZSB0byBhIGNpcmNsZS5cbiAgICogSWYgeW91IGRvIG5vdCB3YW50IHRoZSBnZW9tZXRyeSBtb2RpZmllZCBpbiBwbGFjZSwgZmlyc3QgYGNsb25lKClgIGl0IGFuZFxuICAgKiB0aGVuIHVzZSB0aGlzIGZ1bmN0aW9uIG9uIHRoZSBjbG9uZS5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qLmpzXCIpLlByb2plY3Rpb25MaWtlfSBzb3VyY2UgVGhlIGN1cnJlbnQgcHJvamVjdGlvbi4gIENhbiBiZSBhXG4gICAqICAgICBzdHJpbmcgaWRlbnRpZmllciBvciBhIHtAbGluayBtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9uflByb2plY3Rpb259IG9iamVjdC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qLmpzXCIpLlByb2plY3Rpb25MaWtlfSBkZXN0aW5hdGlvbiBUaGUgZGVzaXJlZCBwcm9qZWN0aW9uLiAgQ2FuIGJlIGFcbiAgICogICAgIHN0cmluZyBpZGVudGlmaWVyIG9yIGEge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb25+UHJvamVjdGlvbn0gb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtHZW9tZXRyeX0gVGhpcyBnZW9tZXRyeS4gIE5vdGUgdGhhdCBvcmlnaW5hbCBnZW9tZXRyeSBpc1xuICAgKiAgICAgbW9kaWZpZWQgaW4gcGxhY2UuXG4gICAqIEBhcGlcbiAgICovXG4gIEdlb21ldHJ5LnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiB0cmFuc2Zvcm0gKHNvdXJjZSwgZGVzdGluYXRpb24pIHtcbiAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSAqL1xuICAgIHZhciBzb3VyY2VQcm9qID0gZ2V0UHJvamVjdGlvbihzb3VyY2UpO1xuICAgIHZhciB0cmFuc2Zvcm1GbiA9IHNvdXJjZVByb2ouZ2V0VW5pdHMoKSA9PSBVbml0cy5USUxFX1BJWEVMUyA/XG4gICAgICBmdW5jdGlvbihpbkNvb3JkaW5hdGVzLCBvdXRDb29yZGluYXRlcywgc3RyaWRlKSB7XG4gICAgICAgIHZhciBwaXhlbEV4dGVudCA9IHNvdXJjZVByb2ouZ2V0RXh0ZW50KCk7XG4gICAgICAgIHZhciBwcm9qZWN0ZWRFeHRlbnQgPSBzb3VyY2VQcm9qLmdldFdvcmxkRXh0ZW50KCk7XG4gICAgICAgIHZhciBzY2FsZSA9IGdldEhlaWdodChwcm9qZWN0ZWRFeHRlbnQpIC8gZ2V0SGVpZ2h0KHBpeGVsRXh0ZW50KTtcbiAgICAgICAgY29tcG9zZVRyYW5zZm9ybSh0bXBUcmFuc2Zvcm0sXG4gICAgICAgICAgcHJvamVjdGVkRXh0ZW50WzBdLCBwcm9qZWN0ZWRFeHRlbnRbM10sXG4gICAgICAgICAgc2NhbGUsIC1zY2FsZSwgMCxcbiAgICAgICAgICAwLCAwKTtcbiAgICAgICAgdHJhbnNmb3JtMkQoaW5Db29yZGluYXRlcywgMCwgaW5Db29yZGluYXRlcy5sZW5ndGgsIHN0cmlkZSxcbiAgICAgICAgICB0bXBUcmFuc2Zvcm0sIG91dENvb3JkaW5hdGVzKTtcbiAgICAgICAgcmV0dXJuIGdldFRyYW5zZm9ybShzb3VyY2VQcm9qLCBkZXN0aW5hdGlvbikoaW5Db29yZGluYXRlcywgb3V0Q29vcmRpbmF0ZXMsIHN0cmlkZSk7XG4gICAgICB9IDpcbiAgICAgIGdldFRyYW5zZm9ybShzb3VyY2VQcm9qLCBkZXN0aW5hdGlvbik7XG4gICAgdGhpcy5hcHBseVRyYW5zZm9ybSh0cmFuc2Zvcm1Gbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcmV0dXJuIEdlb21ldHJ5O1xufShCYXNlT2JqZWN0KSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgR2VvbWV0cnk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdlb21ldHJ5LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL0dlb21ldHJ5TGF5b3V0XG4gKi9cblxuLyoqXG4gKiBUaGUgY29vcmRpbmF0ZSBsYXlvdXQgZm9yIGdlb21ldHJpZXMsIGluZGljYXRpbmcgd2hldGhlciBhIDNyZCBvciA0dGggeiAoJ1onKVxuICogb3IgbWVhc3VyZSAoJ00nKSBjb29yZGluYXRlIGlzIGF2YWlsYWJsZS4gU3VwcG9ydGVkIHZhbHVlcyBhcmUgYCdYWSdgLFxuICogYCdYWVonYCwgYCdYWU0nYCwgYCdYWVpNJ2AuXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIFhZOiAnWFknLFxuICBYWVo6ICdYWVonLFxuICBYWU06ICdYWU0nLFxuICBYWVpNOiAnWFlaTSdcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdlb21ldHJ5TGF5b3V0LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL0dlb21ldHJ5VHlwZVxuICovXG5cbi8qKlxuICogVGhlIGdlb21ldHJ5IHR5cGUuIE9uZSBvZiBgJ1BvaW50J2AsIGAnTGluZVN0cmluZydgLCBgJ0xpbmVhclJpbmcnYCxcbiAqIGAnUG9seWdvbidgLCBgJ011bHRpUG9pbnQnYCwgYCdNdWx0aUxpbmVTdHJpbmcnYCwgYCdNdWx0aVBvbHlnb24nYCxcbiAqIGAnR2VvbWV0cnlDb2xsZWN0aW9uJ2AsIGAnQ2lyY2xlJ2AuXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIFBPSU5UOiAnUG9pbnQnLFxuICBMSU5FX1NUUklORzogJ0xpbmVTdHJpbmcnLFxuICBMSU5FQVJfUklORzogJ0xpbmVhclJpbmcnLFxuICBQT0xZR09OOiAnUG9seWdvbicsXG4gIE1VTFRJX1BPSU5UOiAnTXVsdGlQb2ludCcsXG4gIE1VTFRJX0xJTkVfU1RSSU5HOiAnTXVsdGlMaW5lU3RyaW5nJyxcbiAgTVVMVElfUE9MWUdPTjogJ011bHRpUG9seWdvbicsXG4gIEdFT01FVFJZX0NPTExFQ1RJT046ICdHZW9tZXRyeUNvbGxlY3Rpb24nLFxuICBDSVJDTEU6ICdDaXJjbGUnXG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1HZW9tZXRyeVR5cGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vTGluZVN0cmluZ1xuICovXG5pbXBvcnQge2V4dGVuZH0gZnJvbSAnLi4vYXJyYXkuanMnO1xuaW1wb3J0IHtjbG9zZXN0U3F1YXJlZERpc3RhbmNlWFl9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQgR2VvbWV0cnlMYXlvdXQgZnJvbSAnLi9HZW9tZXRyeUxheW91dC5qcyc7XG5pbXBvcnQgR2VvbWV0cnlUeXBlIGZyb20gJy4vR2VvbWV0cnlUeXBlLmpzJztcbmltcG9ydCBTaW1wbGVHZW9tZXRyeSBmcm9tICcuL1NpbXBsZUdlb21ldHJ5LmpzJztcbmltcG9ydCB7YXNzaWduQ2xvc2VzdFBvaW50LCBtYXhTcXVhcmVkRGVsdGF9IGZyb20gJy4vZmxhdC9jbG9zZXN0LmpzJztcbmltcG9ydCB7ZGVmbGF0ZUNvb3JkaW5hdGVzfSBmcm9tICcuL2ZsYXQvZGVmbGF0ZS5qcyc7XG5pbXBvcnQge2luZmxhdGVDb29yZGluYXRlc30gZnJvbSAnLi9mbGF0L2luZmxhdGUuanMnO1xuaW1wb3J0IHtpbnRlcnBvbGF0ZVBvaW50LCBsaW5lU3RyaW5nQ29vcmRpbmF0ZUF0TX0gZnJvbSAnLi9mbGF0L2ludGVycG9sYXRlLmpzJztcbmltcG9ydCB7aW50ZXJzZWN0c0xpbmVTdHJpbmd9IGZyb20gJy4vZmxhdC9pbnRlcnNlY3RzZXh0ZW50LmpzJztcbmltcG9ydCB7bGluZVN0cmluZ0xlbmd0aH0gZnJvbSAnLi9mbGF0L2xlbmd0aC5qcyc7XG5pbXBvcnQge2ZvckVhY2ggYXMgZm9yRWFjaFNlZ21lbnR9IGZyb20gJy4vZmxhdC9zZWdtZW50cy5qcyc7XG5pbXBvcnQge2RvdWdsYXNQZXVja2VyfSBmcm9tICcuL2ZsYXQvc2ltcGxpZnkuanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIExpbmVzdHJpbmcgZ2VvbWV0cnkuXG4gKlxuICogQGFwaVxuICovXG52YXIgTGluZVN0cmluZyA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFNpbXBsZUdlb21ldHJ5KSB7XG4gIGZ1bmN0aW9uIExpbmVTdHJpbmcoY29vcmRpbmF0ZXMsIG9wdF9sYXlvdXQpIHtcblxuICAgIFNpbXBsZUdlb21ldHJ5LmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9XG4gICAgICovXG4gICAgdGhpcy5mbGF0TWlkcG9pbnRfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmZsYXRNaWRwb2ludFJldmlzaW9uXyA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4RGVsdGFfID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXhEZWx0YVJldmlzaW9uXyA9IC0xO1xuXG4gICAgaWYgKG9wdF9sYXlvdXQgIT09IHVuZGVmaW5lZCAmJiAhQXJyYXkuaXNBcnJheShjb29yZGluYXRlc1swXSkpIHtcbiAgICAgIHRoaXMuc2V0RmxhdENvb3JkaW5hdGVzKG9wdF9sYXlvdXQsIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi8gKGNvb3JkaW5hdGVzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0Q29vcmRpbmF0ZXMoLyoqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSAqLyAoY29vcmRpbmF0ZXMpLCBvcHRfbGF5b3V0KTtcbiAgICB9XG5cbiAgfVxuXG4gIGlmICggU2ltcGxlR2VvbWV0cnkgKSBMaW5lU3RyaW5nLl9fcHJvdG9fXyA9IFNpbXBsZUdlb21ldHJ5O1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFNpbXBsZUdlb21ldHJ5ICYmIFNpbXBsZUdlb21ldHJ5LnByb3RvdHlwZSApO1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExpbmVTdHJpbmc7XG5cbiAgLyoqXG4gICAqIEFwcGVuZCB0aGUgcGFzc2VkIGNvb3JkaW5hdGUgdG8gdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBsaW5lc3RyaW5nLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICAgKiBAYXBpXG4gICAqL1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5hcHBlbmRDb29yZGluYXRlID0gZnVuY3Rpb24gYXBwZW5kQ29vcmRpbmF0ZSAoY29vcmRpbmF0ZSkge1xuICAgIGlmICghdGhpcy5mbGF0Q29vcmRpbmF0ZXMpIHtcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzID0gY29vcmRpbmF0ZS5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHRlbmQodGhpcy5mbGF0Q29vcmRpbmF0ZXMsIGNvb3JkaW5hdGUpO1xuICAgIH1cbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuICAvKipcbiAgICogTWFrZSBhIGNvbXBsZXRlIGNvcHkgb2YgdGhlIGdlb21ldHJ5LlxuICAgKiBAcmV0dXJuIHshTGluZVN0cmluZ30gQ2xvbmUuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgICByZXR1cm4gbmV3IExpbmVTdHJpbmcodGhpcy5mbGF0Q29vcmRpbmF0ZXMuc2xpY2UoKSwgdGhpcy5sYXlvdXQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgTGluZVN0cmluZy5wcm90b3R5cGUuY2xvc2VzdFBvaW50WFkgPSBmdW5jdGlvbiBjbG9zZXN0UG9pbnRYWSAoeCwgeSwgY2xvc2VzdFBvaW50LCBtaW5TcXVhcmVkRGlzdGFuY2UpIHtcbiAgICBpZiAobWluU3F1YXJlZERpc3RhbmNlIDwgY2xvc2VzdFNxdWFyZWREaXN0YW5jZVhZKHRoaXMuZ2V0RXh0ZW50KCksIHgsIHkpKSB7XG4gICAgICByZXR1cm4gbWluU3F1YXJlZERpc3RhbmNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXhEZWx0YVJldmlzaW9uXyAhPSB0aGlzLmdldFJldmlzaW9uKCkpIHtcbiAgICAgIHRoaXMubWF4RGVsdGFfID0gTWF0aC5zcXJ0KG1heFNxdWFyZWREZWx0YShcbiAgICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCwgdGhpcy5zdHJpZGUsIDApKTtcbiAgICAgIHRoaXMubWF4RGVsdGFSZXZpc2lvbl8gPSB0aGlzLmdldFJldmlzaW9uKCk7XG4gICAgfVxuICAgIHJldHVybiBhc3NpZ25DbG9zZXN0UG9pbnQoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcywgMCwgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLCB0aGlzLnN0cmlkZSxcbiAgICAgIHRoaXMubWF4RGVsdGFfLCBmYWxzZSwgeCwgeSwgY2xvc2VzdFBvaW50LCBtaW5TcXVhcmVkRGlzdGFuY2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJdGVyYXRlIG92ZXIgZWFjaCBzZWdtZW50LCBjYWxsaW5nIHRoZSBwcm92aWRlZCBjYWxsYmFjay5cbiAgICogSWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYSB0cnV0aHkgdmFsdWUgdGhlIGZ1bmN0aW9uIHJldHVybnMgdGhhdFxuICAgKiB2YWx1ZSBpbW1lZGlhdGVseS4gT3RoZXJ3aXNlIHRoZSBmdW5jdGlvbiByZXR1cm5zIGBmYWxzZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczogUywgaW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlLCBpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGUpOiBUfSBjYWxsYmFjayBGdW5jdGlvblxuICAgKiAgICAgY2FsbGVkIGZvciBlYWNoIHNlZ21lbnQuXG4gICAqIEByZXR1cm4ge1R8Ym9vbGVhbn0gVmFsdWUuXG4gICAqIEB0ZW1wbGF0ZSBULFNcbiAgICogQGFwaVxuICAgKi9cbiAgTGluZVN0cmluZy5wcm90b3R5cGUuZm9yRWFjaFNlZ21lbnQgPSBmdW5jdGlvbiBmb3JFYWNoU2VnbWVudCQxIChjYWxsYmFjaykge1xuICAgIHJldHVybiBmb3JFYWNoU2VnbWVudCh0aGlzLmZsYXRDb29yZGluYXRlcywgMCwgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLCB0aGlzLnN0cmlkZSwgY2FsbGJhY2spO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb29yZGluYXRlIGF0IGBtYCB1c2luZyBsaW5lYXIgaW50ZXJwb2xhdGlvbiwgb3IgYG51bGxgIGlmIG5vXG4gICAqIHN1Y2ggY29vcmRpbmF0ZSBleGlzdHMuXG4gICAqXG4gICAqIGBvcHRfZXh0cmFwb2xhdGVgIGNvbnRyb2xzIGV4dHJhcG9sYXRpb24gYmV5b25kIHRoZSByYW5nZSBvZiBNcyBpbiB0aGVcbiAgICogTXVsdGlMaW5lU3RyaW5nLiBJZiBgb3B0X2V4dHJhcG9sYXRlYCBpcyBgdHJ1ZWAgdGhlbiBNcyBsZXNzIHRoYW4gdGhlIGZpcnN0XG4gICAqIE0gd2lsbCByZXR1cm4gdGhlIGZpcnN0IGNvb3JkaW5hdGUgYW5kIE1zIGdyZWF0ZXIgdGhhbiB0aGUgbGFzdCBNIHdpbGxcbiAgICogcmV0dXJuIHRoZSBsYXN0IGNvb3JkaW5hdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtIE0uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9leHRyYXBvbGF0ZSBFeHRyYXBvbGF0ZS4gRGVmYXVsdCBpcyBgZmFsc2VgLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IENvb3JkaW5hdGUuXG4gICAqIEBhcGlcbiAgICovXG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmdldENvb3JkaW5hdGVBdE0gPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlQXRNIChtLCBvcHRfZXh0cmFwb2xhdGUpIHtcbiAgICBpZiAodGhpcy5sYXlvdXQgIT0gR2VvbWV0cnlMYXlvdXQuWFlNICYmXG4gICAgICAgIHRoaXMubGF5b3V0ICE9IEdlb21ldHJ5TGF5b3V0LlhZWk0pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgZXh0cmFwb2xhdGUgPSBvcHRfZXh0cmFwb2xhdGUgIT09IHVuZGVmaW5lZCA/IG9wdF9leHRyYXBvbGF0ZSA6IGZhbHNlO1xuICAgIHJldHVybiBsaW5lU3RyaW5nQ29vcmRpbmF0ZUF0TSh0aGlzLmZsYXRDb29yZGluYXRlcywgMCxcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCwgdGhpcy5zdHJpZGUsIG0sIGV4dHJhcG9sYXRlKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgbGluZXN0cmluZy5cbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn0gQ29vcmRpbmF0ZXMuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVzICgpIHtcbiAgICByZXR1cm4gaW5mbGF0ZUNvb3JkaW5hdGVzKFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCwgdGhpcy5zdHJpZGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGNvb3JkaW5hdGUgYXQgdGhlIHByb3ZpZGVkIGZyYWN0aW9uIGFsb25nIHRoZSBsaW5lc3RyaW5nLlxuICAgKiBUaGUgYGZyYWN0aW9uYCBpcyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEsIHdoZXJlIDAgaXMgdGhlIHN0YXJ0IG9mIHRoZVxuICAgKiBsaW5lc3RyaW5nIGFuZCAxIGlzIHRoZSBlbmQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcmFjdGlvbiBGcmFjdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU9fSBvcHRfZGVzdCBPcHRpb25hbCBjb29yZGluYXRlIHdob3NlIHZhbHVlcyB3aWxsXG4gICAqICAgICBiZSBtb2RpZmllZC4gSWYgbm90IHByb3ZpZGVkLCBhIG5ldyBjb29yZGluYXRlIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gQ29vcmRpbmF0ZSBvZiB0aGUgaW50ZXJwb2xhdGVkIHBvaW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXRDb29yZGluYXRlQXQgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlQXQgKGZyYWN0aW9uLCBvcHRfZGVzdCkge1xuICAgIHJldHVybiBpbnRlcnBvbGF0ZVBvaW50KFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCwgdGhpcy5zdHJpZGUsXG4gICAgICBmcmFjdGlvbiwgb3B0X2Rlc3QpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgbGluZXN0cmluZyBvbiBwcm9qZWN0ZWQgcGxhbmUuXG4gICAqIEByZXR1cm4ge251bWJlcn0gTGVuZ3RoIChvbiBwcm9qZWN0ZWQgcGxhbmUpLlxuICAgKiBAYXBpXG4gICAqL1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbiBnZXRMZW5ndGggKCkge1xuICAgIHJldHVybiBsaW5lU3RyaW5nTGVuZ3RoKFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCwgdGhpcy5zdHJpZGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBGbGF0IG1pZHBvaW50LlxuICAgKi9cbiAgTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0RmxhdE1pZHBvaW50ID0gZnVuY3Rpb24gZ2V0RmxhdE1pZHBvaW50ICgpIHtcbiAgICBpZiAodGhpcy5mbGF0TWlkcG9pbnRSZXZpc2lvbl8gIT0gdGhpcy5nZXRSZXZpc2lvbigpKSB7XG4gICAgICB0aGlzLmZsYXRNaWRwb2ludF8gPSB0aGlzLmdldENvb3JkaW5hdGVBdCgwLjUsIHRoaXMuZmxhdE1pZHBvaW50Xyk7XG4gICAgICB0aGlzLmZsYXRNaWRwb2ludFJldmlzaW9uXyA9IHRoaXMuZ2V0UmV2aXNpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmxhdE1pZHBvaW50XztcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmdldFNpbXBsaWZpZWRHZW9tZXRyeUludGVybmFsID0gZnVuY3Rpb24gZ2V0U2ltcGxpZmllZEdlb21ldHJ5SW50ZXJuYWwgKHNxdWFyZWRUb2xlcmFuY2UpIHtcbiAgICB2YXIgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyA9IFtdO1xuICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMubGVuZ3RoID0gZG91Z2xhc1BldWNrZXIoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcywgMCwgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLCB0aGlzLnN0cmlkZSxcbiAgICAgIHNxdWFyZWRUb2xlcmFuY2UsIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsIDApO1xuICAgIHJldHVybiBuZXcgTGluZVN0cmluZyhzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLCBHZW9tZXRyeUxheW91dC5YWSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqIEBhcGlcbiAgICovXG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmdldFR5cGUgPSBmdW5jdGlvbiBnZXRUeXBlICgpIHtcbiAgICByZXR1cm4gR2VvbWV0cnlUeXBlLkxJTkVfU1RSSU5HO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKiBAYXBpXG4gICAqL1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5pbnRlcnNlY3RzRXh0ZW50ID0gZnVuY3Rpb24gaW50ZXJzZWN0c0V4dGVudCAoZXh0ZW50KSB7XG4gICAgcmV0dXJuIGludGVyc2VjdHNMaW5lU3RyaW5nKFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCwgdGhpcy5zdHJpZGUsXG4gICAgICBleHRlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBsaW5lc3RyaW5nLlxuICAgKiBAcGFyYW0geyFBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAgICogQHBhcmFtIHtHZW9tZXRyeUxheW91dD19IG9wdF9sYXlvdXQgTGF5b3V0LlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGFwaVxuICAgKi9cbiAgTGluZVN0cmluZy5wcm90b3R5cGUuc2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBzZXRDb29yZGluYXRlcyAoY29vcmRpbmF0ZXMsIG9wdF9sYXlvdXQpIHtcbiAgICB0aGlzLnNldExheW91dChvcHRfbGF5b3V0LCBjb29yZGluYXRlcywgMSk7XG4gICAgaWYgKCF0aGlzLmZsYXRDb29yZGluYXRlcykge1xuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoID0gZGVmbGF0ZUNvb3JkaW5hdGVzKFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIGNvb3JkaW5hdGVzLCB0aGlzLnN0cmlkZSk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH07XG5cbiAgcmV0dXJuIExpbmVTdHJpbmc7XG59KFNpbXBsZUdlb21ldHJ5KSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgTGluZVN0cmluZztcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGluZVN0cmluZy5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9MaW5lYXJSaW5nXG4gKi9cbmltcG9ydCB7Y2xvc2VzdFNxdWFyZWREaXN0YW5jZVhZfSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IEdlb21ldHJ5TGF5b3V0IGZyb20gJy4vR2VvbWV0cnlMYXlvdXQuanMnO1xuaW1wb3J0IEdlb21ldHJ5VHlwZSBmcm9tICcuL0dlb21ldHJ5VHlwZS5qcyc7XG5pbXBvcnQgU2ltcGxlR2VvbWV0cnkgZnJvbSAnLi9TaW1wbGVHZW9tZXRyeS5qcyc7XG5pbXBvcnQge2xpbmVhclJpbmcgYXMgbGluZWFyUmluZ0FyZWF9IGZyb20gJy4vZmxhdC9hcmVhLmpzJztcbmltcG9ydCB7YXNzaWduQ2xvc2VzdFBvaW50LCBtYXhTcXVhcmVkRGVsdGF9IGZyb20gJy4vZmxhdC9jbG9zZXN0LmpzJztcbmltcG9ydCB7ZGVmbGF0ZUNvb3JkaW5hdGVzfSBmcm9tICcuL2ZsYXQvZGVmbGF0ZS5qcyc7XG5pbXBvcnQge2luZmxhdGVDb29yZGluYXRlc30gZnJvbSAnLi9mbGF0L2luZmxhdGUuanMnO1xuaW1wb3J0IHtkb3VnbGFzUGV1Y2tlcn0gZnJvbSAnLi9mbGF0L3NpbXBsaWZ5LmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBMaW5lYXIgcmluZyBnZW9tZXRyeS4gT25seSB1c2VkIGFzIHBhcnQgb2YgcG9seWdvbjsgY2Fubm90IGJlIHJlbmRlcmVkXG4gKiBvbiBpdHMgb3duLlxuICpcbiAqIEBhcGlcbiAqL1xudmFyIExpbmVhclJpbmcgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChTaW1wbGVHZW9tZXRyeSkge1xuICBmdW5jdGlvbiBMaW5lYXJSaW5nKGNvb3JkaW5hdGVzLCBvcHRfbGF5b3V0KSB7XG5cbiAgICBTaW1wbGVHZW9tZXRyeS5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4RGVsdGFfID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXhEZWx0YVJldmlzaW9uXyA9IC0xO1xuXG4gICAgaWYgKG9wdF9sYXlvdXQgIT09IHVuZGVmaW5lZCAmJiAhQXJyYXkuaXNBcnJheShjb29yZGluYXRlc1swXSkpIHtcbiAgICAgIHRoaXMuc2V0RmxhdENvb3JkaW5hdGVzKG9wdF9sYXlvdXQsIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi8gKGNvb3JkaW5hdGVzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0Q29vcmRpbmF0ZXMoLyoqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSAqLyAoY29vcmRpbmF0ZXMpLCBvcHRfbGF5b3V0KTtcbiAgICB9XG5cbiAgfVxuXG4gIGlmICggU2ltcGxlR2VvbWV0cnkgKSBMaW5lYXJSaW5nLl9fcHJvdG9fXyA9IFNpbXBsZUdlb21ldHJ5O1xuICBMaW5lYXJSaW5nLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFNpbXBsZUdlb21ldHJ5ICYmIFNpbXBsZUdlb21ldHJ5LnByb3RvdHlwZSApO1xuICBMaW5lYXJSaW5nLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExpbmVhclJpbmc7XG5cbiAgLyoqXG4gICAqIE1ha2UgYSBjb21wbGV0ZSBjb3B5IG9mIHRoZSBnZW9tZXRyeS5cbiAgICogQHJldHVybiB7IUxpbmVhclJpbmd9IENsb25lLlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGFwaVxuICAgKi9cbiAgTGluZWFyUmluZy5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgcmV0dXJuIG5ldyBMaW5lYXJSaW5nKHRoaXMuZmxhdENvb3JkaW5hdGVzLnNsaWNlKCksIHRoaXMubGF5b3V0KTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIExpbmVhclJpbmcucHJvdG90eXBlLmNsb3Nlc3RQb2ludFhZID0gZnVuY3Rpb24gY2xvc2VzdFBvaW50WFkgKHgsIHksIGNsb3Nlc3RQb2ludCwgbWluU3F1YXJlZERpc3RhbmNlKSB7XG4gICAgaWYgKG1pblNxdWFyZWREaXN0YW5jZSA8IGNsb3Nlc3RTcXVhcmVkRGlzdGFuY2VYWSh0aGlzLmdldEV4dGVudCgpLCB4LCB5KSkge1xuICAgICAgcmV0dXJuIG1pblNxdWFyZWREaXN0YW5jZTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF4RGVsdGFSZXZpc2lvbl8gIT0gdGhpcy5nZXRSZXZpc2lvbigpKSB7XG4gICAgICB0aGlzLm1heERlbHRhXyA9IE1hdGguc3FydChtYXhTcXVhcmVkRGVsdGEoXG4gICAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHRoaXMuc3RyaWRlLCAwKSk7XG4gICAgICB0aGlzLm1heERlbHRhUmV2aXNpb25fID0gdGhpcy5nZXRSZXZpc2lvbigpO1xuICAgIH1cbiAgICByZXR1cm4gYXNzaWduQ2xvc2VzdFBvaW50KFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCwgdGhpcy5zdHJpZGUsXG4gICAgICB0aGlzLm1heERlbHRhXywgdHJ1ZSwgeCwgeSwgY2xvc2VzdFBvaW50LCBtaW5TcXVhcmVkRGlzdGFuY2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGFyZWEgb2YgdGhlIGxpbmVhciByaW5nIG9uIHByb2plY3RlZCBwbGFuZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBBcmVhIChvbiBwcm9qZWN0ZWQgcGxhbmUpLlxuICAgKiBAYXBpXG4gICAqL1xuICBMaW5lYXJSaW5nLnByb3RvdHlwZS5nZXRBcmVhID0gZnVuY3Rpb24gZ2V0QXJlYSAoKSB7XG4gICAgcmV0dXJuIGxpbmVhclJpbmdBcmVhKHRoaXMuZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHRoaXMuc3RyaWRlKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgbGluZWFyIHJpbmcuXG4gICAqIEByZXR1cm4ge0FycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59IENvb3JkaW5hdGVzLlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGFwaVxuICAgKi9cbiAgTGluZWFyUmluZy5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlcyAoKSB7XG4gICAgcmV0dXJuIGluZmxhdGVDb29yZGluYXRlcyhcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHRoaXMuc3RyaWRlKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIExpbmVhclJpbmcucHJvdG90eXBlLmdldFNpbXBsaWZpZWRHZW9tZXRyeUludGVybmFsID0gZnVuY3Rpb24gZ2V0U2ltcGxpZmllZEdlb21ldHJ5SW50ZXJuYWwgKHNxdWFyZWRUb2xlcmFuY2UpIHtcbiAgICB2YXIgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyA9IFtdO1xuICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMubGVuZ3RoID0gZG91Z2xhc1BldWNrZXIoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcywgMCwgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLCB0aGlzLnN0cmlkZSxcbiAgICAgIHNxdWFyZWRUb2xlcmFuY2UsIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsIDApO1xuICAgIHJldHVybiBuZXcgTGluZWFyUmluZyhzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLCBHZW9tZXRyeUxheW91dC5YWSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqIEBhcGlcbiAgICovXG4gIExpbmVhclJpbmcucHJvdG90eXBlLmdldFR5cGUgPSBmdW5jdGlvbiBnZXRUeXBlICgpIHtcbiAgICByZXR1cm4gR2VvbWV0cnlUeXBlLkxJTkVBUl9SSU5HO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgTGluZWFyUmluZy5wcm90b3R5cGUuaW50ZXJzZWN0c0V4dGVudCA9IGZ1bmN0aW9uIGludGVyc2VjdHNFeHRlbnQgKGV4dGVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBjb29yZGluYXRlcyBvZiB0aGUgbGluZWFyIHJpbmcuXG4gICAqIEBwYXJhbSB7IUFycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59IGNvb3JkaW5hdGVzIENvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0ge0dlb21ldHJ5TGF5b3V0PX0gb3B0X2xheW91dCBMYXlvdXQuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBMaW5lYXJSaW5nLnByb3RvdHlwZS5zZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIHNldENvb3JkaW5hdGVzIChjb29yZGluYXRlcywgb3B0X2xheW91dCkge1xuICAgIHRoaXMuc2V0TGF5b3V0KG9wdF9sYXlvdXQsIGNvb3JkaW5hdGVzLCAxKTtcbiAgICBpZiAoIXRoaXMuZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyA9IFtdO1xuICAgIH1cbiAgICB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGggPSBkZWZsYXRlQ29vcmRpbmF0ZXMoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcywgMCwgY29vcmRpbmF0ZXMsIHRoaXMuc3RyaWRlKTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuICByZXR1cm4gTGluZWFyUmluZztcbn0oU2ltcGxlR2VvbWV0cnkpKTtcblxuXG5leHBvcnQgZGVmYXVsdCBMaW5lYXJSaW5nO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1MaW5lYXJSaW5nLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL011bHRpTGluZVN0cmluZ1xuICovXG5pbXBvcnQge2V4dGVuZH0gZnJvbSAnLi4vYXJyYXkuanMnO1xuaW1wb3J0IHtjbG9zZXN0U3F1YXJlZERpc3RhbmNlWFl9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQgR2VvbWV0cnlMYXlvdXQgZnJvbSAnLi9HZW9tZXRyeUxheW91dC5qcyc7XG5pbXBvcnQgR2VvbWV0cnlUeXBlIGZyb20gJy4vR2VvbWV0cnlUeXBlLmpzJztcbmltcG9ydCBMaW5lU3RyaW5nIGZyb20gJy4vTGluZVN0cmluZy5qcyc7XG5pbXBvcnQgU2ltcGxlR2VvbWV0cnkgZnJvbSAnLi9TaW1wbGVHZW9tZXRyeS5qcyc7XG5pbXBvcnQge2Fzc2lnbkNsb3Nlc3RBcnJheVBvaW50LCBhcnJheU1heFNxdWFyZWREZWx0YX0gZnJvbSAnLi9mbGF0L2Nsb3Nlc3QuanMnO1xuaW1wb3J0IHtkZWZsYXRlQ29vcmRpbmF0ZXNBcnJheX0gZnJvbSAnLi9mbGF0L2RlZmxhdGUuanMnO1xuaW1wb3J0IHtpbmZsYXRlQ29vcmRpbmF0ZXNBcnJheX0gZnJvbSAnLi9mbGF0L2luZmxhdGUuanMnO1xuaW1wb3J0IHtpbnRlcnBvbGF0ZVBvaW50LCBsaW5lU3RyaW5nc0Nvb3JkaW5hdGVBdE19IGZyb20gJy4vZmxhdC9pbnRlcnBvbGF0ZS5qcyc7XG5pbXBvcnQge2ludGVyc2VjdHNMaW5lU3RyaW5nQXJyYXl9IGZyb20gJy4vZmxhdC9pbnRlcnNlY3RzZXh0ZW50LmpzJztcbmltcG9ydCB7ZG91Z2xhc1BldWNrZXJBcnJheX0gZnJvbSAnLi9mbGF0L3NpbXBsaWZ5LmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBNdWx0aS1saW5lc3RyaW5nIGdlb21ldHJ5LlxuICpcbiAqIEBhcGlcbiAqL1xudmFyIE11bHRpTGluZVN0cmluZyA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFNpbXBsZUdlb21ldHJ5KSB7XG4gIGZ1bmN0aW9uIE11bHRpTGluZVN0cmluZyhjb29yZGluYXRlcywgb3B0X2xheW91dCwgb3B0X2VuZHMpIHtcblxuICAgIFNpbXBsZUdlb21ldHJ5LmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZW5kc18gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1heERlbHRhXyA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4RGVsdGFSZXZpc2lvbl8gPSAtMTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGNvb3JkaW5hdGVzWzBdKSkge1xuICAgICAgdGhpcy5zZXRDb29yZGluYXRlcygvKiogQHR5cGUge0FycmF5PEFycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+fSAqLyAoY29vcmRpbmF0ZXMpLCBvcHRfbGF5b3V0KTtcbiAgICB9IGVsc2UgaWYgKG9wdF9sYXlvdXQgIT09IHVuZGVmaW5lZCAmJiBvcHRfZW5kcykge1xuICAgICAgdGhpcy5zZXRGbGF0Q29vcmRpbmF0ZXMob3B0X2xheW91dCwgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqLyAoY29vcmRpbmF0ZXMpKTtcbiAgICAgIHRoaXMuZW5kc18gPSBvcHRfZW5kcztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxheW91dCA9IHRoaXMuZ2V0TGF5b3V0KCk7XG4gICAgICB2YXIgbGluZVN0cmluZ3MgPSAvKiogQHR5cGUge0FycmF5PExpbmVTdHJpbmc+fSAqLyAoY29vcmRpbmF0ZXMpO1xuICAgICAgdmFyIGZsYXRDb29yZGluYXRlcyA9IFtdO1xuICAgICAgdmFyIGVuZHMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGxpbmVTdHJpbmdzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgdmFyIGxpbmVTdHJpbmcgPSBsaW5lU3RyaW5nc1tpXTtcbiAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICBsYXlvdXQgPSBsaW5lU3RyaW5nLmdldExheW91dCgpO1xuICAgICAgICB9XG4gICAgICAgIGV4dGVuZChmbGF0Q29vcmRpbmF0ZXMsIGxpbmVTdHJpbmcuZ2V0RmxhdENvb3JkaW5hdGVzKCkpO1xuICAgICAgICBlbmRzLnB1c2goZmxhdENvb3JkaW5hdGVzLmxlbmd0aCk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldEZsYXRDb29yZGluYXRlcyhsYXlvdXQsIGZsYXRDb29yZGluYXRlcyk7XG4gICAgICB0aGlzLmVuZHNfID0gZW5kcztcbiAgICB9XG5cbiAgfVxuXG4gIGlmICggU2ltcGxlR2VvbWV0cnkgKSBNdWx0aUxpbmVTdHJpbmcuX19wcm90b19fID0gU2ltcGxlR2VvbWV0cnk7XG4gIE11bHRpTGluZVN0cmluZy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBTaW1wbGVHZW9tZXRyeSAmJiBTaW1wbGVHZW9tZXRyeS5wcm90b3R5cGUgKTtcbiAgTXVsdGlMaW5lU3RyaW5nLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE11bHRpTGluZVN0cmluZztcblxuICAvKipcbiAgICogQXBwZW5kIHRoZSBwYXNzZWQgbGluZXN0cmluZyB0byB0aGUgbXVsdGlsaW5lc3RyaW5nLlxuICAgKiBAcGFyYW0ge0xpbmVTdHJpbmd9IGxpbmVTdHJpbmcgTGluZVN0cmluZy5cbiAgICogQGFwaVxuICAgKi9cbiAgTXVsdGlMaW5lU3RyaW5nLnByb3RvdHlwZS5hcHBlbmRMaW5lU3RyaW5nID0gZnVuY3Rpb24gYXBwZW5kTGluZVN0cmluZyAobGluZVN0cmluZykge1xuICAgIGlmICghdGhpcy5mbGF0Q29vcmRpbmF0ZXMpIHtcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzID0gbGluZVN0cmluZy5nZXRGbGF0Q29vcmRpbmF0ZXMoKS5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHRlbmQodGhpcy5mbGF0Q29vcmRpbmF0ZXMsIGxpbmVTdHJpbmcuZ2V0RmxhdENvb3JkaW5hdGVzKCkuc2xpY2UoKSk7XG4gICAgfVxuICAgIHRoaXMuZW5kc18ucHVzaCh0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGgpO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNYWtlIGEgY29tcGxldGUgY29weSBvZiB0aGUgZ2VvbWV0cnkuXG4gICAqIEByZXR1cm4geyFNdWx0aUxpbmVTdHJpbmd9IENsb25lLlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGFwaVxuICAgKi9cbiAgTXVsdGlMaW5lU3RyaW5nLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgICByZXR1cm4gbmV3IE11bHRpTGluZVN0cmluZyh0aGlzLmZsYXRDb29yZGluYXRlcy5zbGljZSgpLCB0aGlzLmxheW91dCwgdGhpcy5lbmRzXy5zbGljZSgpKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIE11bHRpTGluZVN0cmluZy5wcm90b3R5cGUuY2xvc2VzdFBvaW50WFkgPSBmdW5jdGlvbiBjbG9zZXN0UG9pbnRYWSAoeCwgeSwgY2xvc2VzdFBvaW50LCBtaW5TcXVhcmVkRGlzdGFuY2UpIHtcbiAgICBpZiAobWluU3F1YXJlZERpc3RhbmNlIDwgY2xvc2VzdFNxdWFyZWREaXN0YW5jZVhZKHRoaXMuZ2V0RXh0ZW50KCksIHgsIHkpKSB7XG4gICAgICByZXR1cm4gbWluU3F1YXJlZERpc3RhbmNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXhEZWx0YVJldmlzaW9uXyAhPSB0aGlzLmdldFJldmlzaW9uKCkpIHtcbiAgICAgIHRoaXMubWF4RGVsdGFfID0gTWF0aC5zcXJ0KGFycmF5TWF4U3F1YXJlZERlbHRhKFxuICAgICAgICB0aGlzLmZsYXRDb29yZGluYXRlcywgMCwgdGhpcy5lbmRzXywgdGhpcy5zdHJpZGUsIDApKTtcbiAgICAgIHRoaXMubWF4RGVsdGFSZXZpc2lvbl8gPSB0aGlzLmdldFJldmlzaW9uKCk7XG4gICAgfVxuICAgIHJldHVybiBhc3NpZ25DbG9zZXN0QXJyYXlQb2ludChcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmVuZHNfLCB0aGlzLnN0cmlkZSxcbiAgICAgIHRoaXMubWF4RGVsdGFfLCBmYWxzZSwgeCwgeSwgY2xvc2VzdFBvaW50LCBtaW5TcXVhcmVkRGlzdGFuY2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb29yZGluYXRlIGF0IGBtYCB1c2luZyBsaW5lYXIgaW50ZXJwb2xhdGlvbiwgb3IgYG51bGxgIGlmIG5vXG4gICAqIHN1Y2ggY29vcmRpbmF0ZSBleGlzdHMuXG4gICAqXG4gICAqIGBvcHRfZXh0cmFwb2xhdGVgIGNvbnRyb2xzIGV4dHJhcG9sYXRpb24gYmV5b25kIHRoZSByYW5nZSBvZiBNcyBpbiB0aGVcbiAgICogTXVsdGlMaW5lU3RyaW5nLiBJZiBgb3B0X2V4dHJhcG9sYXRlYCBpcyBgdHJ1ZWAgdGhlbiBNcyBsZXNzIHRoYW4gdGhlIGZpcnN0XG4gICAqIE0gd2lsbCByZXR1cm4gdGhlIGZpcnN0IGNvb3JkaW5hdGUgYW5kIE1zIGdyZWF0ZXIgdGhhbiB0aGUgbGFzdCBNIHdpbGxcbiAgICogcmV0dXJuIHRoZSBsYXN0IGNvb3JkaW5hdGUuXG4gICAqXG4gICAqIGBvcHRfaW50ZXJwb2xhdGVgIGNvbnRyb2xzIGludGVycG9sYXRpb24gYmV0d2VlbiBjb25zZWN1dGl2ZSBMaW5lU3RyaW5nc1xuICAgKiB3aXRoaW4gdGhlIE11bHRpTGluZVN0cmluZy4gSWYgYG9wdF9pbnRlcnBvbGF0ZWAgaXMgYHRydWVgIHRoZSBjb29yZGluYXRlc1xuICAgKiB3aWxsIGJlIGxpbmVhcmx5IGludGVycG9sYXRlZCBiZXR3ZWVuIHRoZSBsYXN0IGNvb3JkaW5hdGUgb2Ygb25lIExpbmVTdHJpbmdcbiAgICogYW5kIHRoZSBmaXJzdCBjb29yZGluYXRlIG9mIHRoZSBuZXh0IExpbmVTdHJpbmcuICBJZiBgb3B0X2ludGVycG9sYXRlYCBpc1xuICAgKiBgZmFsc2VgIHRoZW4gdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGBudWxsYCBmb3IgTXMgZmFsbGluZyBiZXR3ZWVuXG4gICAqIExpbmVTdHJpbmdzLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbSBNLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfZXh0cmFwb2xhdGUgRXh0cmFwb2xhdGUuIERlZmF1bHQgaXMgYGZhbHNlYC5cbiAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0X2ludGVycG9sYXRlIEludGVycG9sYXRlLiBEZWZhdWx0IGlzIGBmYWxzZWAuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gQ29vcmRpbmF0ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgTXVsdGlMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXRDb29yZGluYXRlQXRNID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZUF0TSAobSwgb3B0X2V4dHJhcG9sYXRlLCBvcHRfaW50ZXJwb2xhdGUpIHtcbiAgICBpZiAoKHRoaXMubGF5b3V0ICE9IEdlb21ldHJ5TGF5b3V0LlhZTSAmJlxuICAgICAgICAgdGhpcy5sYXlvdXQgIT0gR2VvbWV0cnlMYXlvdXQuWFlaTSkgfHxcbiAgICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGV4dHJhcG9sYXRlID0gb3B0X2V4dHJhcG9sYXRlICE9PSB1bmRlZmluZWQgPyBvcHRfZXh0cmFwb2xhdGUgOiBmYWxzZTtcbiAgICB2YXIgaW50ZXJwb2xhdGUgPSBvcHRfaW50ZXJwb2xhdGUgIT09IHVuZGVmaW5lZCA/IG9wdF9pbnRlcnBvbGF0ZSA6IGZhbHNlO1xuICAgIHJldHVybiBsaW5lU3RyaW5nc0Nvb3JkaW5hdGVBdE0odGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsXG4gICAgICB0aGlzLmVuZHNfLCB0aGlzLnN0cmlkZSwgbSwgZXh0cmFwb2xhdGUsIGludGVycG9sYXRlKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgbXVsdGlsaW5lc3RyaW5nLlxuICAgKiBAcmV0dXJuIHtBcnJheTxBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+Pn0gQ29vcmRpbmF0ZXMuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBNdWx0aUxpbmVTdHJpbmcucHJvdG90eXBlLmdldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZXMgKCkge1xuICAgIHJldHVybiBpbmZsYXRlQ29vcmRpbmF0ZXNBcnJheShcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmVuZHNfLCB0aGlzLnN0cmlkZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEVuZHMuXG4gICAqL1xuICBNdWx0aUxpbmVTdHJpbmcucHJvdG90eXBlLmdldEVuZHMgPSBmdW5jdGlvbiBnZXRFbmRzICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbmRzXztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBsaW5lc3RyaW5nIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleC5cbiAgICogQHJldHVybiB7TGluZVN0cmluZ30gTGluZVN0cmluZy5cbiAgICogQGFwaVxuICAgKi9cbiAgTXVsdGlMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXRMaW5lU3RyaW5nID0gZnVuY3Rpb24gZ2V0TGluZVN0cmluZyAoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPCAwIHx8IHRoaXMuZW5kc18ubGVuZ3RoIDw9IGluZGV4KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBMaW5lU3RyaW5nKHRoaXMuZmxhdENvb3JkaW5hdGVzLnNsaWNlKFxuICAgICAgaW5kZXggPT09IDAgPyAwIDogdGhpcy5lbmRzX1tpbmRleCAtIDFdLCB0aGlzLmVuZHNfW2luZGV4XSksIHRoaXMubGF5b3V0KTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBsaW5lc3RyaW5ncyBvZiB0aGlzIG11bHRpbGluZXN0cmluZy5cbiAgICogQHJldHVybiB7QXJyYXk8TGluZVN0cmluZz59IExpbmVTdHJpbmdzLlxuICAgKiBAYXBpXG4gICAqL1xuICBNdWx0aUxpbmVTdHJpbmcucHJvdG90eXBlLmdldExpbmVTdHJpbmdzID0gZnVuY3Rpb24gZ2V0TGluZVN0cmluZ3MgKCkge1xuICAgIHZhciBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmZsYXRDb29yZGluYXRlcztcbiAgICB2YXIgZW5kcyA9IHRoaXMuZW5kc187XG4gICAgdmFyIGxheW91dCA9IHRoaXMubGF5b3V0O1xuICAgIC8qKiBAdHlwZSB7QXJyYXk8TGluZVN0cmluZz59ICovXG4gICAgdmFyIGxpbmVTdHJpbmdzID0gW107XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB2YXIgZW5kID0gZW5kc1tpXTtcbiAgICAgIHZhciBsaW5lU3RyaW5nID0gbmV3IExpbmVTdHJpbmcoZmxhdENvb3JkaW5hdGVzLnNsaWNlKG9mZnNldCwgZW5kKSwgbGF5b3V0KTtcbiAgICAgIGxpbmVTdHJpbmdzLnB1c2gobGluZVN0cmluZyk7XG4gICAgICBvZmZzZXQgPSBlbmQ7XG4gICAgfVxuICAgIHJldHVybiBsaW5lU3RyaW5ncztcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gRmxhdCBtaWRwb2ludHMuXG4gICAqL1xuICBNdWx0aUxpbmVTdHJpbmcucHJvdG90eXBlLmdldEZsYXRNaWRwb2ludHMgPSBmdW5jdGlvbiBnZXRGbGF0TWlkcG9pbnRzICgpIHtcbiAgICB2YXIgbWlkcG9pbnRzID0gW107XG4gICAgdmFyIGZsYXRDb29yZGluYXRlcyA9IHRoaXMuZmxhdENvb3JkaW5hdGVzO1xuICAgIHZhciBvZmZzZXQgPSAwO1xuICAgIHZhciBlbmRzID0gdGhpcy5lbmRzXztcbiAgICB2YXIgc3RyaWRlID0gdGhpcy5zdHJpZGU7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB2YXIgZW5kID0gZW5kc1tpXTtcbiAgICAgIHZhciBtaWRwb2ludCA9IGludGVycG9sYXRlUG9pbnQoXG4gICAgICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgMC41KTtcbiAgICAgIGV4dGVuZChtaWRwb2ludHMsIG1pZHBvaW50KTtcbiAgICAgIG9mZnNldCA9IGVuZDtcbiAgICB9XG4gICAgcmV0dXJuIG1pZHBvaW50cztcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIE11bHRpTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0U2ltcGxpZmllZEdlb21ldHJ5SW50ZXJuYWwgPSBmdW5jdGlvbiBnZXRTaW1wbGlmaWVkR2VvbWV0cnlJbnRlcm5hbCAoc3F1YXJlZFRvbGVyYW5jZSkge1xuICAgIHZhciBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzID0gW107XG4gICAgdmFyIHNpbXBsaWZpZWRFbmRzID0gW107XG4gICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcy5sZW5ndGggPSBkb3VnbGFzUGV1Y2tlckFycmF5KFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZW5kc18sIHRoaXMuc3RyaWRlLCBzcXVhcmVkVG9sZXJhbmNlLFxuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcywgMCwgc2ltcGxpZmllZEVuZHMpO1xuICAgIHJldHVybiBuZXcgTXVsdGlMaW5lU3RyaW5nKHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsIEdlb21ldHJ5TGF5b3V0LlhZLCBzaW1wbGlmaWVkRW5kcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqIEBhcGlcbiAgICovXG4gIE11bHRpTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0VHlwZSA9IGZ1bmN0aW9uIGdldFR5cGUgKCkge1xuICAgIHJldHVybiBHZW9tZXRyeVR5cGUuTVVMVElfTElORV9TVFJJTkc7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqIEBhcGlcbiAgICovXG4gIE11bHRpTGluZVN0cmluZy5wcm90b3R5cGUuaW50ZXJzZWN0c0V4dGVudCA9IGZ1bmN0aW9uIGludGVyc2VjdHNFeHRlbnQgKGV4dGVudCkge1xuICAgIHJldHVybiBpbnRlcnNlY3RzTGluZVN0cmluZ0FycmF5KFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZW5kc18sIHRoaXMuc3RyaWRlLCBleHRlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBtdWx0aWxpbmVzdHJpbmcuXG4gICAqIEBwYXJhbSB7IUFycmF5PEFycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAgICogQHBhcmFtIHtHZW9tZXRyeUxheW91dD19IG9wdF9sYXlvdXQgTGF5b3V0LlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGFwaVxuICAgKi9cbiAgTXVsdGlMaW5lU3RyaW5nLnByb3RvdHlwZS5zZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIHNldENvb3JkaW5hdGVzIChjb29yZGluYXRlcywgb3B0X2xheW91dCkge1xuICAgIHRoaXMuc2V0TGF5b3V0KG9wdF9sYXlvdXQsIGNvb3JkaW5hdGVzLCAyKTtcbiAgICBpZiAoIXRoaXMuZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyA9IFtdO1xuICAgIH1cbiAgICB2YXIgZW5kcyA9IGRlZmxhdGVDb29yZGluYXRlc0FycmF5KFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIGNvb3JkaW5hdGVzLCB0aGlzLnN0cmlkZSwgdGhpcy5lbmRzXyk7XG4gICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoID0gZW5kcy5sZW5ndGggPT09IDAgPyAwIDogZW5kc1tlbmRzLmxlbmd0aCAtIDFdO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9O1xuXG4gIHJldHVybiBNdWx0aUxpbmVTdHJpbmc7XG59KFNpbXBsZUdlb21ldHJ5KSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgTXVsdGlMaW5lU3RyaW5nO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1NdWx0aUxpbmVTdHJpbmcuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vTXVsdGlQb2ludFxuICovXG5pbXBvcnQge2V4dGVuZH0gZnJvbSAnLi4vYXJyYXkuanMnO1xuaW1wb3J0IHtjbG9zZXN0U3F1YXJlZERpc3RhbmNlWFksIGNvbnRhaW5zWFl9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQgR2VvbWV0cnlUeXBlIGZyb20gJy4vR2VvbWV0cnlUeXBlLmpzJztcbmltcG9ydCBQb2ludCBmcm9tICcuL1BvaW50LmpzJztcbmltcG9ydCBTaW1wbGVHZW9tZXRyeSBmcm9tICcuL1NpbXBsZUdlb21ldHJ5LmpzJztcbmltcG9ydCB7ZGVmbGF0ZUNvb3JkaW5hdGVzfSBmcm9tICcuL2ZsYXQvZGVmbGF0ZS5qcyc7XG5pbXBvcnQge2luZmxhdGVDb29yZGluYXRlc30gZnJvbSAnLi9mbGF0L2luZmxhdGUuanMnO1xuaW1wb3J0IHtzcXVhcmVkRGlzdGFuY2UgYXMgc3F1YXJlZER4fSBmcm9tICcuLi9tYXRoLmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBNdWx0aS1wb2ludCBnZW9tZXRyeS5cbiAqXG4gKiBAYXBpXG4gKi9cbnZhciBNdWx0aVBvaW50ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoU2ltcGxlR2VvbWV0cnkpIHtcbiAgZnVuY3Rpb24gTXVsdGlQb2ludChjb29yZGluYXRlcywgb3B0X2xheW91dCkge1xuICAgIFNpbXBsZUdlb21ldHJ5LmNhbGwodGhpcyk7XG4gICAgaWYgKG9wdF9sYXlvdXQgJiYgIUFycmF5LmlzQXJyYXkoY29vcmRpbmF0ZXNbMF0pKSB7XG4gICAgICB0aGlzLnNldEZsYXRDb29yZGluYXRlcyhvcHRfbGF5b3V0LCAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovIChjb29yZGluYXRlcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldENvb3JkaW5hdGVzKC8qKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn0gKi8gKGNvb3JkaW5hdGVzKSwgb3B0X2xheW91dCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCBTaW1wbGVHZW9tZXRyeSApIE11bHRpUG9pbnQuX19wcm90b19fID0gU2ltcGxlR2VvbWV0cnk7XG4gIE11bHRpUG9pbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU2ltcGxlR2VvbWV0cnkgJiYgU2ltcGxlR2VvbWV0cnkucHJvdG90eXBlICk7XG4gIE11bHRpUG9pbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTXVsdGlQb2ludDtcblxuICAvKipcbiAgICogQXBwZW5kIHRoZSBwYXNzZWQgcG9pbnQgdG8gdGhpcyBtdWx0aXBvaW50LlxuICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludCBQb2ludC5cbiAgICogQGFwaVxuICAgKi9cbiAgTXVsdGlQb2ludC5wcm90b3R5cGUuYXBwZW5kUG9pbnQgPSBmdW5jdGlvbiBhcHBlbmRQb2ludCAocG9pbnQpIHtcbiAgICBpZiAoIXRoaXMuZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyA9IHBvaW50LmdldEZsYXRDb29yZGluYXRlcygpLnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4dGVuZCh0aGlzLmZsYXRDb29yZGluYXRlcywgcG9pbnQuZ2V0RmxhdENvb3JkaW5hdGVzKCkpO1xuICAgIH1cbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuICAvKipcbiAgICogTWFrZSBhIGNvbXBsZXRlIGNvcHkgb2YgdGhlIGdlb21ldHJ5LlxuICAgKiBAcmV0dXJuIHshTXVsdGlQb2ludH0gQ2xvbmUuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBNdWx0aVBvaW50LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgICB2YXIgbXVsdGlQb2ludCA9IG5ldyBNdWx0aVBvaW50KHRoaXMuZmxhdENvb3JkaW5hdGVzLnNsaWNlKCksIHRoaXMubGF5b3V0KTtcbiAgICByZXR1cm4gbXVsdGlQb2ludDtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIE11bHRpUG9pbnQucHJvdG90eXBlLmNsb3Nlc3RQb2ludFhZID0gZnVuY3Rpb24gY2xvc2VzdFBvaW50WFkgKHgsIHksIGNsb3Nlc3RQb2ludCwgbWluU3F1YXJlZERpc3RhbmNlKSB7XG4gICAgaWYgKG1pblNxdWFyZWREaXN0YW5jZSA8IGNsb3Nlc3RTcXVhcmVkRGlzdGFuY2VYWSh0aGlzLmdldEV4dGVudCgpLCB4LCB5KSkge1xuICAgICAgcmV0dXJuIG1pblNxdWFyZWREaXN0YW5jZTtcbiAgICB9XG4gICAgdmFyIGZsYXRDb29yZGluYXRlcyA9IHRoaXMuZmxhdENvb3JkaW5hdGVzO1xuICAgIHZhciBzdHJpZGUgPSB0aGlzLnN0cmlkZTtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gc3RyaWRlKSB7XG4gICAgICB2YXIgc3F1YXJlZERpc3RhbmNlID0gc3F1YXJlZER4KFxuICAgICAgICB4LCB5LCBmbGF0Q29vcmRpbmF0ZXNbaV0sIGZsYXRDb29yZGluYXRlc1tpICsgMV0pO1xuICAgICAgaWYgKHNxdWFyZWREaXN0YW5jZSA8IG1pblNxdWFyZWREaXN0YW5jZSkge1xuICAgICAgICBtaW5TcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkRGlzdGFuY2U7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3RyaWRlOyArK2opIHtcbiAgICAgICAgICBjbG9zZXN0UG9pbnRbal0gPSBmbGF0Q29vcmRpbmF0ZXNbaSArIGpdO1xuICAgICAgICB9XG4gICAgICAgIGNsb3Nlc3RQb2ludC5sZW5ndGggPSBzdHJpZGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtaW5TcXVhcmVkRGlzdGFuY2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIG11bHRpcG9pbnQuXG4gICAqIEByZXR1cm4ge0FycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59IENvb3JkaW5hdGVzLlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGFwaVxuICAgKi9cbiAgTXVsdGlQb2ludC5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlcyAoKSB7XG4gICAgcmV0dXJuIGluZmxhdGVDb29yZGluYXRlcyhcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHRoaXMuc3RyaWRlKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBwb2ludCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXguXG4gICAqIEByZXR1cm4ge1BvaW50fSBQb2ludC5cbiAgICogQGFwaVxuICAgKi9cbiAgTXVsdGlQb2ludC5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiBnZXRQb2ludCAoaW5kZXgpIHtcbiAgICB2YXIgbiA9ICF0aGlzLmZsYXRDb29yZGluYXRlcyA/IDAgOiB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGggLyB0aGlzLnN0cmlkZTtcbiAgICBpZiAoaW5kZXggPCAwIHx8IG4gPD0gaW5kZXgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMuZmxhdENvb3JkaW5hdGVzLnNsaWNlKFxuICAgICAgaW5kZXggKiB0aGlzLnN0cmlkZSwgKGluZGV4ICsgMSkgKiB0aGlzLnN0cmlkZSksIHRoaXMubGF5b3V0KTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBwb2ludHMgb2YgdGhpcyBtdWx0aXBvaW50LlxuICAgKiBAcmV0dXJuIHtBcnJheTxQb2ludD59IFBvaW50cy5cbiAgICogQGFwaVxuICAgKi9cbiAgTXVsdGlQb2ludC5wcm90b3R5cGUuZ2V0UG9pbnRzID0gZnVuY3Rpb24gZ2V0UG9pbnRzICgpIHtcbiAgICB2YXIgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5mbGF0Q29vcmRpbmF0ZXM7XG4gICAgdmFyIGxheW91dCA9IHRoaXMubGF5b3V0O1xuICAgIHZhciBzdHJpZGUgPSB0aGlzLnN0cmlkZTtcbiAgICAvKiogQHR5cGUge0FycmF5PFBvaW50Pn0gKi9cbiAgICB2YXIgcG9pbnRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZmxhdENvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpOyBpICs9IHN0cmlkZSkge1xuICAgICAgdmFyIHBvaW50ID0gbmV3IFBvaW50KGZsYXRDb29yZGluYXRlcy5zbGljZShpLCBpICsgc3RyaWRlKSwgbGF5b3V0KTtcbiAgICAgIHBvaW50cy5wdXNoKHBvaW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHBvaW50cztcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGFwaVxuICAgKi9cbiAgTXVsdGlQb2ludC5wcm90b3R5cGUuZ2V0VHlwZSA9IGZ1bmN0aW9uIGdldFR5cGUgKCkge1xuICAgIHJldHVybiBHZW9tZXRyeVR5cGUuTVVMVElfUE9JTlQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqIEBhcGlcbiAgICovXG4gIE11bHRpUG9pbnQucHJvdG90eXBlLmludGVyc2VjdHNFeHRlbnQgPSBmdW5jdGlvbiBpbnRlcnNlY3RzRXh0ZW50IChleHRlbnQpIHtcbiAgICB2YXIgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5mbGF0Q29vcmRpbmF0ZXM7XG4gICAgdmFyIHN0cmlkZSA9IHRoaXMuc3RyaWRlO1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGZsYXRDb29yZGluYXRlcy5sZW5ndGg7IGkgPCBpaTsgaSArPSBzdHJpZGUpIHtcbiAgICAgIHZhciB4ID0gZmxhdENvb3JkaW5hdGVzW2ldO1xuICAgICAgdmFyIHkgPSBmbGF0Q29vcmRpbmF0ZXNbaSArIDFdO1xuICAgICAgaWYgKGNvbnRhaW5zWFkoZXh0ZW50LCB4LCB5KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBtdWx0aXBvaW50LlxuICAgKiBAcGFyYW0geyFBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0dlb21ldHJ5TGF5b3V0LmpzXCIpLmRlZmF1bHQ9fSBvcHRfbGF5b3V0IExheW91dC5cbiAgICogQG92ZXJyaWRlXG4gICAqIEBhcGlcbiAgICovXG4gIE11bHRpUG9pbnQucHJvdG90eXBlLnNldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gc2V0Q29vcmRpbmF0ZXMgKGNvb3JkaW5hdGVzLCBvcHRfbGF5b3V0KSB7XG4gICAgdGhpcy5zZXRMYXlvdXQob3B0X2xheW91dCwgY29vcmRpbmF0ZXMsIDEpO1xuICAgIGlmICghdGhpcy5mbGF0Q29vcmRpbmF0ZXMpIHtcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzID0gW107XG4gICAgfVxuICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCA9IGRlZmxhdGVDb29yZGluYXRlcyhcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLCAwLCBjb29yZGluYXRlcywgdGhpcy5zdHJpZGUpO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9O1xuXG4gIHJldHVybiBNdWx0aVBvaW50O1xufShTaW1wbGVHZW9tZXRyeSkpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IE11bHRpUG9pbnQ7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU11bHRpUG9pbnQuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vTXVsdGlQb2x5Z29uXG4gKi9cbmltcG9ydCB7ZXh0ZW5kfSBmcm9tICcuLi9hcnJheS5qcyc7XG5pbXBvcnQge2Nsb3Nlc3RTcXVhcmVkRGlzdGFuY2VYWX0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCBHZW9tZXRyeUxheW91dCBmcm9tICcuL0dlb21ldHJ5TGF5b3V0LmpzJztcbmltcG9ydCBHZW9tZXRyeVR5cGUgZnJvbSAnLi9HZW9tZXRyeVR5cGUuanMnO1xuaW1wb3J0IE11bHRpUG9pbnQgZnJvbSAnLi9NdWx0aVBvaW50LmpzJztcbmltcG9ydCBQb2x5Z29uIGZyb20gJy4vUG9seWdvbi5qcyc7XG5pbXBvcnQgU2ltcGxlR2VvbWV0cnkgZnJvbSAnLi9TaW1wbGVHZW9tZXRyeS5qcyc7XG5pbXBvcnQge2xpbmVhclJpbmdzcyBhcyBsaW5lYXJSaW5nc3NBcmVhfSBmcm9tICcuL2ZsYXQvYXJlYS5qcyc7XG5pbXBvcnQge2xpbmVhclJpbmdzcyBhcyBsaW5lYXJSaW5nc3NDZW50ZXJ9IGZyb20gJy4vZmxhdC9jZW50ZXIuanMnO1xuaW1wb3J0IHthc3NpZ25DbG9zZXN0TXVsdGlBcnJheVBvaW50LCBtdWx0aUFycmF5TWF4U3F1YXJlZERlbHRhfSBmcm9tICcuL2ZsYXQvY2xvc2VzdC5qcyc7XG5pbXBvcnQge2xpbmVhclJpbmdzc0NvbnRhaW5zWFl9IGZyb20gJy4vZmxhdC9jb250YWlucy5qcyc7XG5pbXBvcnQge2RlZmxhdGVNdWx0aUNvb3JkaW5hdGVzQXJyYXl9IGZyb20gJy4vZmxhdC9kZWZsYXRlLmpzJztcbmltcG9ydCB7aW5mbGF0ZU11bHRpQ29vcmRpbmF0ZXNBcnJheX0gZnJvbSAnLi9mbGF0L2luZmxhdGUuanMnO1xuaW1wb3J0IHtnZXRJbnRlcmlvclBvaW50c09mTXVsdGlBcnJheX0gZnJvbSAnLi9mbGF0L2ludGVyaW9ycG9pbnQuanMnO1xuaW1wb3J0IHtpbnRlcnNlY3RzTGluZWFyUmluZ011bHRpQXJyYXl9IGZyb20gJy4vZmxhdC9pbnRlcnNlY3RzZXh0ZW50LmpzJztcbmltcG9ydCB7bGluZWFyUmluZ3NBcmVPcmllbnRlZCwgb3JpZW50TGluZWFyUmluZ3NBcnJheX0gZnJvbSAnLi9mbGF0L29yaWVudC5qcyc7XG5pbXBvcnQge3F1YW50aXplTXVsdGlBcnJheX0gZnJvbSAnLi9mbGF0L3NpbXBsaWZ5LmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBNdWx0aS1wb2x5Z29uIGdlb21ldHJ5LlxuICpcbiAqIEBhcGlcbiAqL1xudmFyIE11bHRpUG9seWdvbiA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFNpbXBsZUdlb21ldHJ5KSB7XG4gIGZ1bmN0aW9uIE11bHRpUG9seWdvbihjb29yZGluYXRlcywgb3B0X2xheW91dCwgb3B0X2VuZHNzKSB7XG5cbiAgICBTaW1wbGVHZW9tZXRyeS5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PEFycmF5PG51bWJlcj4+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5lbmRzc18gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmZsYXRJbnRlcmlvclBvaW50c1JldmlzaW9uXyA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLmZsYXRJbnRlcmlvclBvaW50c18gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4RGVsdGFfID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXhEZWx0YVJldmlzaW9uXyA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMub3JpZW50ZWRSZXZpc2lvbl8gPSAtMTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5vcmllbnRlZEZsYXRDb29yZGluYXRlc18gPSBudWxsO1xuXG4gICAgaWYgKCFvcHRfZW5kc3MgJiYgIUFycmF5LmlzQXJyYXkoY29vcmRpbmF0ZXNbMF0pKSB7XG4gICAgICB2YXIgbGF5b3V0ID0gdGhpcy5nZXRMYXlvdXQoKTtcbiAgICAgIHZhciBwb2x5Z29ucyA9IC8qKiBAdHlwZSB7QXJyYXk8UG9seWdvbj59ICovIChjb29yZGluYXRlcyk7XG4gICAgICB2YXIgZmxhdENvb3JkaW5hdGVzID0gW107XG4gICAgICB2YXIgZW5kc3MgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHBvbHlnb25zLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgdmFyIHBvbHlnb24gPSBwb2x5Z29uc1tpXTtcbiAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICBsYXlvdXQgPSBwb2x5Z29uLmdldExheW91dCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvZmZzZXQgPSBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgICAgICB2YXIgZW5kcyA9IHBvbHlnb24uZ2V0RW5kcygpO1xuICAgICAgICBmb3IgKHZhciBqID0gMCwgamogPSBlbmRzLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICAgICAgICBlbmRzW2pdICs9IG9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBleHRlbmQoZmxhdENvb3JkaW5hdGVzLCBwb2x5Z29uLmdldEZsYXRDb29yZGluYXRlcygpKTtcbiAgICAgICAgZW5kc3MucHVzaChlbmRzKTtcbiAgICAgIH1cbiAgICAgIG9wdF9sYXlvdXQgPSBsYXlvdXQ7XG4gICAgICBjb29yZGluYXRlcyA9IGZsYXRDb29yZGluYXRlcztcbiAgICAgIG9wdF9lbmRzcyA9IGVuZHNzO1xuICAgIH1cbiAgICBpZiAob3B0X2xheW91dCAhPT0gdW5kZWZpbmVkICYmIG9wdF9lbmRzcykge1xuICAgICAgdGhpcy5zZXRGbGF0Q29vcmRpbmF0ZXMob3B0X2xheW91dCwgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqLyAoY29vcmRpbmF0ZXMpKTtcbiAgICAgIHRoaXMuZW5kc3NfID0gb3B0X2VuZHNzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldENvb3JkaW5hdGVzKC8qKiBAdHlwZSB7QXJyYXk8QXJyYXk8QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj4+fSAqLyAoY29vcmRpbmF0ZXMpLFxuICAgICAgICBvcHRfbGF5b3V0KTtcbiAgICB9XG5cbiAgfVxuXG4gIGlmICggU2ltcGxlR2VvbWV0cnkgKSBNdWx0aVBvbHlnb24uX19wcm90b19fID0gU2ltcGxlR2VvbWV0cnk7XG4gIE11bHRpUG9seWdvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBTaW1wbGVHZW9tZXRyeSAmJiBTaW1wbGVHZW9tZXRyeS5wcm90b3R5cGUgKTtcbiAgTXVsdGlQb2x5Z29uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE11bHRpUG9seWdvbjtcblxuICAvKipcbiAgICogQXBwZW5kIHRoZSBwYXNzZWQgcG9seWdvbiB0byB0aGlzIG11bHRpcG9seWdvbi5cbiAgICogQHBhcmFtIHtQb2x5Z29ufSBwb2x5Z29uIFBvbHlnb24uXG4gICAqIEBhcGlcbiAgICovXG4gIE11bHRpUG9seWdvbi5wcm90b3R5cGUuYXBwZW5kUG9seWdvbiA9IGZ1bmN0aW9uIGFwcGVuZFBvbHlnb24gKHBvbHlnb24pIHtcbiAgICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovXG4gICAgdmFyIGVuZHM7XG4gICAgaWYgKCF0aGlzLmZsYXRDb29yZGluYXRlcykge1xuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMgPSBwb2x5Z29uLmdldEZsYXRDb29yZGluYXRlcygpLnNsaWNlKCk7XG4gICAgICBlbmRzID0gcG9seWdvbi5nZXRFbmRzKCkuc2xpY2UoKTtcbiAgICAgIHRoaXMuZW5kc3NfLnB1c2goKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG9mZnNldCA9IHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICAgIGV4dGVuZCh0aGlzLmZsYXRDb29yZGluYXRlcywgcG9seWdvbi5nZXRGbGF0Q29vcmRpbmF0ZXMoKSk7XG4gICAgICBlbmRzID0gcG9seWdvbi5nZXRFbmRzKCkuc2xpY2UoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGVuZHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBlbmRzW2ldICs9IG9mZnNldDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5lbmRzc18ucHVzaChlbmRzKTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuICAvKipcbiAgICogTWFrZSBhIGNvbXBsZXRlIGNvcHkgb2YgdGhlIGdlb21ldHJ5LlxuICAgKiBAcmV0dXJuIHshTXVsdGlQb2x5Z29ufSBDbG9uZS5cbiAgICogQG92ZXJyaWRlXG4gICAqIEBhcGlcbiAgICovXG4gIE11bHRpUG9seWdvbi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgdmFyIGxlbiA9IHRoaXMuZW5kc3NfLmxlbmd0aDtcbiAgICB2YXIgbmV3RW5kc3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBuZXdFbmRzc1tpXSA9IHRoaXMuZW5kc3NfW2ldLnNsaWNlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBNdWx0aVBvbHlnb24oXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcy5zbGljZSgpLCB0aGlzLmxheW91dCwgbmV3RW5kc3MpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgTXVsdGlQb2x5Z29uLnByb3RvdHlwZS5jbG9zZXN0UG9pbnRYWSA9IGZ1bmN0aW9uIGNsb3Nlc3RQb2ludFhZICh4LCB5LCBjbG9zZXN0UG9pbnQsIG1pblNxdWFyZWREaXN0YW5jZSkge1xuICAgIGlmIChtaW5TcXVhcmVkRGlzdGFuY2UgPCBjbG9zZXN0U3F1YXJlZERpc3RhbmNlWFkodGhpcy5nZXRFeHRlbnQoKSwgeCwgeSkpIHtcbiAgICAgIHJldHVybiBtaW5TcXVhcmVkRGlzdGFuY2U7XG4gICAgfVxuICAgIGlmICh0aGlzLm1heERlbHRhUmV2aXNpb25fICE9IHRoaXMuZ2V0UmV2aXNpb24oKSkge1xuICAgICAgdGhpcy5tYXhEZWx0YV8gPSBNYXRoLnNxcnQobXVsdGlBcnJheU1heFNxdWFyZWREZWx0YShcbiAgICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZW5kc3NfLCB0aGlzLnN0cmlkZSwgMCkpO1xuICAgICAgdGhpcy5tYXhEZWx0YVJldmlzaW9uXyA9IHRoaXMuZ2V0UmV2aXNpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIGFzc2lnbkNsb3Nlc3RNdWx0aUFycmF5UG9pbnQoXG4gICAgICB0aGlzLmdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzKCksIDAsIHRoaXMuZW5kc3NfLCB0aGlzLnN0cmlkZSxcbiAgICAgIHRoaXMubWF4RGVsdGFfLCB0cnVlLCB4LCB5LCBjbG9zZXN0UG9pbnQsIG1pblNxdWFyZWREaXN0YW5jZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBNdWx0aVBvbHlnb24ucHJvdG90eXBlLmNvbnRhaW5zWFkgPSBmdW5jdGlvbiBjb250YWluc1hZICh4LCB5KSB7XG4gICAgcmV0dXJuIGxpbmVhclJpbmdzc0NvbnRhaW5zWFkodGhpcy5nZXRPcmllbnRlZEZsYXRDb29yZGluYXRlcygpLCAwLCB0aGlzLmVuZHNzXywgdGhpcy5zdHJpZGUsIHgsIHkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGFyZWEgb2YgdGhlIG11bHRpcG9seWdvbiBvbiBwcm9qZWN0ZWQgcGxhbmUuXG4gICAqIEByZXR1cm4ge251bWJlcn0gQXJlYSAob24gcHJvamVjdGVkIHBsYW5lKS5cbiAgICogQGFwaVxuICAgKi9cbiAgTXVsdGlQb2x5Z29uLnByb3RvdHlwZS5nZXRBcmVhID0gZnVuY3Rpb24gZ2V0QXJlYSAoKSB7XG4gICAgcmV0dXJuIGxpbmVhclJpbmdzc0FyZWEodGhpcy5nZXRPcmllbnRlZEZsYXRDb29yZGluYXRlcygpLCAwLCB0aGlzLmVuZHNzXywgdGhpcy5zdHJpZGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvb3JkaW5hdGUgYXJyYXkgZm9yIHRoaXMgZ2VvbWV0cnkuICBUaGlzIGFycmF5IGhhcyB0aGUgc3RydWN0dXJlXG4gICAqIG9mIGEgR2VvSlNPTiBjb29yZGluYXRlIGFycmF5IGZvciBtdWx0aS1wb2x5Z29ucy5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3JpZ2h0IE9yaWVudCBjb29yZGluYXRlcyBhY2NvcmRpbmcgdG8gdGhlIHJpZ2h0LWhhbmRcbiAgICogICAgIHJ1bGUgKGNvdW50ZXItY2xvY2t3aXNlIGZvciBleHRlcmlvciBhbmQgY2xvY2t3aXNlIGZvciBpbnRlcmlvciByaW5ncykuXG4gICAqICAgICBJZiBgZmFsc2VgLCBjb29yZGluYXRlcyB3aWxsIGJlIG9yaWVudGVkIGFjY29yZGluZyB0byB0aGUgbGVmdC1oYW5kIHJ1bGVcbiAgICogICAgIChjbG9ja3dpc2UgZm9yIGV4dGVyaW9yIGFuZCBjb3VudGVyLWNsb2Nrd2lzZSBmb3IgaW50ZXJpb3IgcmluZ3MpLlxuICAgKiAgICAgQnkgZGVmYXVsdCwgY29vcmRpbmF0ZSBvcmllbnRhdGlvbiB3aWxsIGRlcGVuZCBvbiBob3cgdGhlIGdlb21ldHJ5IHdhc1xuICAgKiAgICAgY29uc3RydWN0ZWQuXG4gICAqIEByZXR1cm4ge0FycmF5PEFycmF5PEFycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+Pn0gQ29vcmRpbmF0ZXMuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBNdWx0aVBvbHlnb24ucHJvdG90eXBlLmdldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZXMgKG9wdF9yaWdodCkge1xuICAgIHZhciBmbGF0Q29vcmRpbmF0ZXM7XG4gICAgaWYgKG9wdF9yaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzKCkuc2xpY2UoKTtcbiAgICAgIG9yaWVudExpbmVhclJpbmdzQXJyYXkoXG4gICAgICAgIGZsYXRDb29yZGluYXRlcywgMCwgdGhpcy5lbmRzc18sIHRoaXMuc3RyaWRlLCBvcHRfcmlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmZsYXRDb29yZGluYXRlcztcbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbGF0ZU11bHRpQ29vcmRpbmF0ZXNBcnJheShcbiAgICAgIGZsYXRDb29yZGluYXRlcywgMCwgdGhpcy5lbmRzc18sIHRoaXMuc3RyaWRlKTtcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IEVuZHNzLlxuICAgKi9cbiAgTXVsdGlQb2x5Z29uLnByb3RvdHlwZS5nZXRFbmRzcyA9IGZ1bmN0aW9uIGdldEVuZHNzICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbmRzc187XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEZsYXQgaW50ZXJpb3IgcG9pbnRzLlxuICAgKi9cbiAgTXVsdGlQb2x5Z29uLnByb3RvdHlwZS5nZXRGbGF0SW50ZXJpb3JQb2ludHMgPSBmdW5jdGlvbiBnZXRGbGF0SW50ZXJpb3JQb2ludHMgKCkge1xuICAgIGlmICh0aGlzLmZsYXRJbnRlcmlvclBvaW50c1JldmlzaW9uXyAhPSB0aGlzLmdldFJldmlzaW9uKCkpIHtcbiAgICAgIHZhciBmbGF0Q2VudGVycyA9IGxpbmVhclJpbmdzc0NlbnRlcihcbiAgICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZW5kc3NfLCB0aGlzLnN0cmlkZSk7XG4gICAgICB0aGlzLmZsYXRJbnRlcmlvclBvaW50c18gPSBnZXRJbnRlcmlvclBvaW50c09mTXVsdGlBcnJheShcbiAgICAgICAgdGhpcy5nZXRPcmllbnRlZEZsYXRDb29yZGluYXRlcygpLCAwLCB0aGlzLmVuZHNzXywgdGhpcy5zdHJpZGUsXG4gICAgICAgIGZsYXRDZW50ZXJzKTtcbiAgICAgIHRoaXMuZmxhdEludGVyaW9yUG9pbnRzUmV2aXNpb25fID0gdGhpcy5nZXRSZXZpc2lvbigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mbGF0SW50ZXJpb3JQb2ludHNfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGludGVyaW9yIHBvaW50cyBhcyB7QGxpbmsgbW9kdWxlOm9sL2dlb20vTXVsdGlQb2ludCBtdWx0aXBvaW50fS5cbiAgICogQHJldHVybiB7TXVsdGlQb2ludH0gSW50ZXJpb3IgcG9pbnRzIGFzIFhZTSBjb29yZGluYXRlcywgd2hlcmUgTSBpc1xuICAgKiB0aGUgbGVuZ3RoIG9mIHRoZSBob3Jpem9udGFsIGludGVyc2VjdGlvbiB0aGF0IHRoZSBwb2ludCBiZWxvbmdzIHRvLlxuICAgKiBAYXBpXG4gICAqL1xuICBNdWx0aVBvbHlnb24ucHJvdG90eXBlLmdldEludGVyaW9yUG9pbnRzID0gZnVuY3Rpb24gZ2V0SW50ZXJpb3JQb2ludHMgKCkge1xuICAgIHJldHVybiBuZXcgTXVsdGlQb2ludCh0aGlzLmdldEZsYXRJbnRlcmlvclBvaW50cygpLnNsaWNlKCksIEdlb21ldHJ5TGF5b3V0LlhZTSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IE9yaWVudGVkIGZsYXQgY29vcmRpbmF0ZXMuXG4gICAqL1xuICBNdWx0aVBvbHlnb24ucHJvdG90eXBlLmdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMgKCkge1xuICAgIGlmICh0aGlzLm9yaWVudGVkUmV2aXNpb25fICE9IHRoaXMuZ2V0UmV2aXNpb24oKSkge1xuICAgICAgdmFyIGZsYXRDb29yZGluYXRlcyA9IHRoaXMuZmxhdENvb3JkaW5hdGVzO1xuICAgICAgaWYgKGxpbmVhclJpbmdzQXJlT3JpZW50ZWQoXG4gICAgICAgIGZsYXRDb29yZGluYXRlcywgMCwgdGhpcy5lbmRzc18sIHRoaXMuc3RyaWRlKSkge1xuICAgICAgICB0aGlzLm9yaWVudGVkRmxhdENvb3JkaW5hdGVzXyA9IGZsYXRDb29yZGluYXRlcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXNfID0gZmxhdENvb3JkaW5hdGVzLnNsaWNlKCk7XG4gICAgICAgIHRoaXMub3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXNfLmxlbmd0aCA9XG4gICAgICAgICAgICBvcmllbnRMaW5lYXJSaW5nc0FycmF5KFxuICAgICAgICAgICAgICB0aGlzLm9yaWVudGVkRmxhdENvb3JkaW5hdGVzXywgMCwgdGhpcy5lbmRzc18sIHRoaXMuc3RyaWRlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub3JpZW50ZWRSZXZpc2lvbl8gPSB0aGlzLmdldFJldmlzaW9uKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm9yaWVudGVkRmxhdENvb3JkaW5hdGVzXztcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIE11bHRpUG9seWdvbi5wcm90b3R5cGUuZ2V0U2ltcGxpZmllZEdlb21ldHJ5SW50ZXJuYWwgPSBmdW5jdGlvbiBnZXRTaW1wbGlmaWVkR2VvbWV0cnlJbnRlcm5hbCAoc3F1YXJlZFRvbGVyYW5jZSkge1xuICAgIHZhciBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzID0gW107XG4gICAgdmFyIHNpbXBsaWZpZWRFbmRzcyA9IFtdO1xuICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMubGVuZ3RoID0gcXVhbnRpemVNdWx0aUFycmF5KFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZW5kc3NfLCB0aGlzLnN0cmlkZSxcbiAgICAgIE1hdGguc3FydChzcXVhcmVkVG9sZXJhbmNlKSxcbiAgICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsIDAsIHNpbXBsaWZpZWRFbmRzcyk7XG4gICAgcmV0dXJuIG5ldyBNdWx0aVBvbHlnb24oc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcywgR2VvbWV0cnlMYXlvdXQuWFksIHNpbXBsaWZpZWRFbmRzcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgcG9seWdvbiBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXguXG4gICAqIEByZXR1cm4ge1BvbHlnb259IFBvbHlnb24uXG4gICAqIEBhcGlcbiAgICovXG4gIE11bHRpUG9seWdvbi5wcm90b3R5cGUuZ2V0UG9seWdvbiA9IGZ1bmN0aW9uIGdldFBvbHlnb24gKGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCB0aGlzLmVuZHNzXy5sZW5ndGggPD0gaW5kZXgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgb2Zmc2V0O1xuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHByZXZFbmRzID0gdGhpcy5lbmRzc19baW5kZXggLSAxXTtcbiAgICAgIG9mZnNldCA9IHByZXZFbmRzW3ByZXZFbmRzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICB2YXIgZW5kcyA9IHRoaXMuZW5kc3NfW2luZGV4XS5zbGljZSgpO1xuICAgIHZhciBlbmQgPSBlbmRzW2VuZHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKG9mZnNldCAhPT0gMCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGVuZHNbaV0gLT0gb2Zmc2V0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFBvbHlnb24odGhpcy5mbGF0Q29vcmRpbmF0ZXMuc2xpY2Uob2Zmc2V0LCBlbmQpLCB0aGlzLmxheW91dCwgZW5kcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgcG9seWdvbnMgb2YgdGhpcyBtdWx0aXBvbHlnb24uXG4gICAqIEByZXR1cm4ge0FycmF5PFBvbHlnb24+fSBQb2x5Z29ucy5cbiAgICogQGFwaVxuICAgKi9cbiAgTXVsdGlQb2x5Z29uLnByb3RvdHlwZS5nZXRQb2x5Z29ucyA9IGZ1bmN0aW9uIGdldFBvbHlnb25zICgpIHtcbiAgICB2YXIgbGF5b3V0ID0gdGhpcy5sYXlvdXQ7XG4gICAgdmFyIGZsYXRDb29yZGluYXRlcyA9IHRoaXMuZmxhdENvb3JkaW5hdGVzO1xuICAgIHZhciBlbmRzcyA9IHRoaXMuZW5kc3NfO1xuICAgIHZhciBwb2x5Z29ucyA9IFtdO1xuICAgIHZhciBvZmZzZXQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGVuZHNzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIHZhciBlbmRzID0gZW5kc3NbaV0uc2xpY2UoKTtcbiAgICAgIHZhciBlbmQgPSBlbmRzW2VuZHMubGVuZ3RoIC0gMV07XG4gICAgICBpZiAob2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBqaiA9IGVuZHMubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgICAgIGVuZHNbal0gLT0gb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgcG9seWdvbiA9IG5ldyBQb2x5Z29uKGZsYXRDb29yZGluYXRlcy5zbGljZShvZmZzZXQsIGVuZCksIGxheW91dCwgZW5kcyk7XG4gICAgICBwb2x5Z29ucy5wdXNoKHBvbHlnb24pO1xuICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgIH1cbiAgICByZXR1cm4gcG9seWdvbnM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqIEBhcGlcbiAgICovXG4gIE11bHRpUG9seWdvbi5wcm90b3R5cGUuZ2V0VHlwZSA9IGZ1bmN0aW9uIGdldFR5cGUgKCkge1xuICAgIHJldHVybiBHZW9tZXRyeVR5cGUuTVVMVElfUE9MWUdPTjtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGFwaVxuICAgKi9cbiAgTXVsdGlQb2x5Z29uLnByb3RvdHlwZS5pbnRlcnNlY3RzRXh0ZW50ID0gZnVuY3Rpb24gaW50ZXJzZWN0c0V4dGVudCAoZXh0ZW50KSB7XG4gICAgcmV0dXJuIGludGVyc2VjdHNMaW5lYXJSaW5nTXVsdGlBcnJheShcbiAgICAgIHRoaXMuZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMoKSwgMCwgdGhpcy5lbmRzc18sIHRoaXMuc3RyaWRlLCBleHRlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBtdWx0aXBvbHlnb24uXG4gICAqIEBwYXJhbSB7IUFycmF5PEFycmF5PEFycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+Pn0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7R2VvbWV0cnlMYXlvdXQ9fSBvcHRfbGF5b3V0IExheW91dC5cbiAgICogQG92ZXJyaWRlXG4gICAqIEBhcGlcbiAgICovXG4gIE11bHRpUG9seWdvbi5wcm90b3R5cGUuc2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBzZXRDb29yZGluYXRlcyAoY29vcmRpbmF0ZXMsIG9wdF9sYXlvdXQpIHtcbiAgICB0aGlzLnNldExheW91dChvcHRfbGF5b3V0LCBjb29yZGluYXRlcywgMyk7XG4gICAgaWYgKCF0aGlzLmZsYXRDb29yZGluYXRlcykge1xuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMgPSBbXTtcbiAgICB9XG4gICAgdmFyIGVuZHNzID0gZGVmbGF0ZU11bHRpQ29vcmRpbmF0ZXNBcnJheShcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLCAwLCBjb29yZGluYXRlcywgdGhpcy5zdHJpZGUsIHRoaXMuZW5kc3NfKTtcbiAgICBpZiAoZW5kc3MubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbGFzdEVuZHMgPSBlbmRzc1tlbmRzcy5sZW5ndGggLSAxXTtcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCA9IGxhc3RFbmRzLmxlbmd0aCA9PT0gMCA/XG4gICAgICAgIDAgOiBsYXN0RW5kc1tsYXN0RW5kcy5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH07XG5cbiAgcmV0dXJuIE11bHRpUG9seWdvbjtcbn0oU2ltcGxlR2VvbWV0cnkpKTtcblxuXG5leHBvcnQgZGVmYXVsdCBNdWx0aVBvbHlnb247XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU11bHRpUG9seWdvbi5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9Qb2ludFxuICovXG5pbXBvcnQge2NyZWF0ZU9yVXBkYXRlRnJvbUNvb3JkaW5hdGUsIGNvbnRhaW5zWFl9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQgR2VvbWV0cnlUeXBlIGZyb20gJy4vR2VvbWV0cnlUeXBlLmpzJztcbmltcG9ydCBTaW1wbGVHZW9tZXRyeSBmcm9tICcuL1NpbXBsZUdlb21ldHJ5LmpzJztcbmltcG9ydCB7ZGVmbGF0ZUNvb3JkaW5hdGV9IGZyb20gJy4vZmxhdC9kZWZsYXRlLmpzJztcbmltcG9ydCB7c3F1YXJlZERpc3RhbmNlIGFzIHNxdWFyZWREeH0gZnJvbSAnLi4vbWF0aC5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogUG9pbnQgZ2VvbWV0cnkuXG4gKlxuICogQGFwaVxuICovXG52YXIgUG9pbnQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChTaW1wbGVHZW9tZXRyeSkge1xuICBmdW5jdGlvbiBQb2ludChjb29yZGluYXRlcywgb3B0X2xheW91dCkge1xuICAgIFNpbXBsZUdlb21ldHJ5LmNhbGwodGhpcyk7XG4gICAgdGhpcy5zZXRDb29yZGluYXRlcyhjb29yZGluYXRlcywgb3B0X2xheW91dCk7XG4gIH1cblxuICBpZiAoIFNpbXBsZUdlb21ldHJ5ICkgUG9pbnQuX19wcm90b19fID0gU2ltcGxlR2VvbWV0cnk7XG4gIFBvaW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFNpbXBsZUdlb21ldHJ5ICYmIFNpbXBsZUdlb21ldHJ5LnByb3RvdHlwZSApO1xuICBQb2ludC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQb2ludDtcblxuICAvKipcbiAgICogTWFrZSBhIGNvbXBsZXRlIGNvcHkgb2YgdGhlIGdlb21ldHJ5LlxuICAgKiBAcmV0dXJuIHshUG9pbnR9IENsb25lLlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGFwaVxuICAgKi9cbiAgUG9pbnQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgIHZhciBwb2ludCA9IG5ldyBQb2ludCh0aGlzLmZsYXRDb29yZGluYXRlcy5zbGljZSgpLCB0aGlzLmxheW91dCk7XG4gICAgcmV0dXJuIHBvaW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgUG9pbnQucHJvdG90eXBlLmNsb3Nlc3RQb2ludFhZID0gZnVuY3Rpb24gY2xvc2VzdFBvaW50WFkgKHgsIHksIGNsb3Nlc3RQb2ludCwgbWluU3F1YXJlZERpc3RhbmNlKSB7XG4gICAgdmFyIGZsYXRDb29yZGluYXRlcyA9IHRoaXMuZmxhdENvb3JkaW5hdGVzO1xuICAgIHZhciBzcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkRHgoeCwgeSwgZmxhdENvb3JkaW5hdGVzWzBdLCBmbGF0Q29vcmRpbmF0ZXNbMV0pO1xuICAgIGlmIChzcXVhcmVkRGlzdGFuY2UgPCBtaW5TcXVhcmVkRGlzdGFuY2UpIHtcbiAgICAgIHZhciBzdHJpZGUgPSB0aGlzLnN0cmlkZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaWRlOyArK2kpIHtcbiAgICAgICAgY2xvc2VzdFBvaW50W2ldID0gZmxhdENvb3JkaW5hdGVzW2ldO1xuICAgICAgfVxuICAgICAgY2xvc2VzdFBvaW50Lmxlbmd0aCA9IHN0cmlkZTtcbiAgICAgIHJldHVybiBzcXVhcmVkRGlzdGFuY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtaW5TcXVhcmVkRGlzdGFuY2U7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IENvb3JkaW5hdGVzLlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGFwaVxuICAgKi9cbiAgUG9pbnQucHJvdG90eXBlLmdldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZXMgKCkge1xuICAgIHJldHVybiAhdGhpcy5mbGF0Q29vcmRpbmF0ZXMgPyBbXSA6IHRoaXMuZmxhdENvb3JkaW5hdGVzLnNsaWNlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBQb2ludC5wcm90b3R5cGUuY29tcHV0ZUV4dGVudCA9IGZ1bmN0aW9uIGNvbXB1dGVFeHRlbnQgKGV4dGVudCkge1xuICAgIHJldHVybiBjcmVhdGVPclVwZGF0ZUZyb21Db29yZGluYXRlKHRoaXMuZmxhdENvb3JkaW5hdGVzLCBleHRlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKiBAYXBpXG4gICAqL1xuICBQb2ludC5wcm90b3R5cGUuZ2V0VHlwZSA9IGZ1bmN0aW9uIGdldFR5cGUgKCkge1xuICAgIHJldHVybiBHZW9tZXRyeVR5cGUuUE9JTlQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqIEBhcGlcbiAgICovXG4gIFBvaW50LnByb3RvdHlwZS5pbnRlcnNlY3RzRXh0ZW50ID0gZnVuY3Rpb24gaW50ZXJzZWN0c0V4dGVudCAoZXh0ZW50KSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zWFkoZXh0ZW50LCB0aGlzLmZsYXRDb29yZGluYXRlc1swXSwgdGhpcy5mbGF0Q29vcmRpbmF0ZXNbMV0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKiBAYXBpXG4gICAqL1xuICBQb2ludC5wcm90b3R5cGUuc2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBzZXRDb29yZGluYXRlcyAoY29vcmRpbmF0ZXMsIG9wdF9sYXlvdXQpIHtcbiAgICB0aGlzLnNldExheW91dChvcHRfbGF5b3V0LCBjb29yZGluYXRlcywgMCk7XG4gICAgaWYgKCF0aGlzLmZsYXRDb29yZGluYXRlcykge1xuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoID0gZGVmbGF0ZUNvb3JkaW5hdGUoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcywgMCwgY29vcmRpbmF0ZXMsIHRoaXMuc3RyaWRlKTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuICByZXR1cm4gUG9pbnQ7XG59KFNpbXBsZUdlb21ldHJ5KSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgUG9pbnQ7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBvaW50LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL1BvbHlnb25cbiAqL1xuaW1wb3J0IHtleHRlbmR9IGZyb20gJy4uL2FycmF5LmpzJztcbmltcG9ydCB7Y2xvc2VzdFNxdWFyZWREaXN0YW5jZVhZLCBnZXRDZW50ZXJ9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQgR2VvbWV0cnlMYXlvdXQgZnJvbSAnLi9HZW9tZXRyeUxheW91dC5qcyc7XG5pbXBvcnQgR2VvbWV0cnlUeXBlIGZyb20gJy4vR2VvbWV0cnlUeXBlLmpzJztcbmltcG9ydCBMaW5lYXJSaW5nIGZyb20gJy4vTGluZWFyUmluZy5qcyc7XG5pbXBvcnQgUG9pbnQgZnJvbSAnLi9Qb2ludC5qcyc7XG5pbXBvcnQgU2ltcGxlR2VvbWV0cnkgZnJvbSAnLi9TaW1wbGVHZW9tZXRyeS5qcyc7XG5pbXBvcnQge29mZnNldCBhcyBzcGhlcmVPZmZzZXR9IGZyb20gJy4uL3NwaGVyZS5qcyc7XG5pbXBvcnQge2xpbmVhclJpbmdzIGFzIGxpbmVhclJpbmdzQXJlYX0gZnJvbSAnLi9mbGF0L2FyZWEuanMnO1xuaW1wb3J0IHthc3NpZ25DbG9zZXN0QXJyYXlQb2ludCwgYXJyYXlNYXhTcXVhcmVkRGVsdGF9IGZyb20gJy4vZmxhdC9jbG9zZXN0LmpzJztcbmltcG9ydCB7bGluZWFyUmluZ3NDb250YWluc1hZfSBmcm9tICcuL2ZsYXQvY29udGFpbnMuanMnO1xuaW1wb3J0IHtkZWZsYXRlQ29vcmRpbmF0ZXNBcnJheX0gZnJvbSAnLi9mbGF0L2RlZmxhdGUuanMnO1xuaW1wb3J0IHtpbmZsYXRlQ29vcmRpbmF0ZXNBcnJheX0gZnJvbSAnLi9mbGF0L2luZmxhdGUuanMnO1xuaW1wb3J0IHtnZXRJbnRlcmlvclBvaW50T2ZBcnJheX0gZnJvbSAnLi9mbGF0L2ludGVyaW9ycG9pbnQuanMnO1xuaW1wb3J0IHtpbnRlcnNlY3RzTGluZWFyUmluZ0FycmF5fSBmcm9tICcuL2ZsYXQvaW50ZXJzZWN0c2V4dGVudC5qcyc7XG5pbXBvcnQge2xpbmVhclJpbmdJc09yaWVudGVkLCBvcmllbnRMaW5lYXJSaW5nc30gZnJvbSAnLi9mbGF0L29yaWVudC5qcyc7XG5pbXBvcnQge3F1YW50aXplQXJyYXl9IGZyb20gJy4vZmxhdC9zaW1wbGlmeS5qcyc7XG5pbXBvcnQge21vZHVsb30gZnJvbSAnLi4vbWF0aC5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogUG9seWdvbiBnZW9tZXRyeS5cbiAqXG4gKiBAYXBpXG4gKi9cbnZhciBQb2x5Z29uID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoU2ltcGxlR2VvbWV0cnkpIHtcbiAgZnVuY3Rpb24gUG9seWdvbihjb29yZGluYXRlcywgb3B0X2xheW91dCwgb3B0X2VuZHMpIHtcblxuICAgIFNpbXBsZUdlb21ldHJ5LmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZW5kc18gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmZsYXRJbnRlcmlvclBvaW50UmV2aXNpb25fID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9XG4gICAgICovXG4gICAgdGhpcy5mbGF0SW50ZXJpb3JQb2ludF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4RGVsdGFfID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXhEZWx0YVJldmlzaW9uXyA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMub3JpZW50ZWRSZXZpc2lvbl8gPSAtMTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5vcmllbnRlZEZsYXRDb29yZGluYXRlc18gPSBudWxsO1xuXG4gICAgaWYgKG9wdF9sYXlvdXQgIT09IHVuZGVmaW5lZCAmJiBvcHRfZW5kcykge1xuICAgICAgdGhpcy5zZXRGbGF0Q29vcmRpbmF0ZXMob3B0X2xheW91dCwgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqLyAoY29vcmRpbmF0ZXMpKTtcbiAgICAgIHRoaXMuZW5kc18gPSBvcHRfZW5kcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRDb29yZGluYXRlcygvKiogQHR5cGUge0FycmF5PEFycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+fSAqLyAoY29vcmRpbmF0ZXMpLCBvcHRfbGF5b3V0KTtcbiAgICB9XG5cbiAgfVxuXG4gIGlmICggU2ltcGxlR2VvbWV0cnkgKSBQb2x5Z29uLl9fcHJvdG9fXyA9IFNpbXBsZUdlb21ldHJ5O1xuICBQb2x5Z29uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFNpbXBsZUdlb21ldHJ5ICYmIFNpbXBsZUdlb21ldHJ5LnByb3RvdHlwZSApO1xuICBQb2x5Z29uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBvbHlnb247XG5cbiAgLyoqXG4gICAqIEFwcGVuZCB0aGUgcGFzc2VkIGxpbmVhciByaW5nIHRvIHRoaXMgcG9seWdvbi5cbiAgICogQHBhcmFtIHtMaW5lYXJSaW5nfSBsaW5lYXJSaW5nIExpbmVhciByaW5nLlxuICAgKiBAYXBpXG4gICAqL1xuICBQb2x5Z29uLnByb3RvdHlwZS5hcHBlbmRMaW5lYXJSaW5nID0gZnVuY3Rpb24gYXBwZW5kTGluZWFyUmluZyAobGluZWFyUmluZykge1xuICAgIGlmICghdGhpcy5mbGF0Q29vcmRpbmF0ZXMpIHtcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzID0gbGluZWFyUmluZy5nZXRGbGF0Q29vcmRpbmF0ZXMoKS5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHRlbmQodGhpcy5mbGF0Q29vcmRpbmF0ZXMsIGxpbmVhclJpbmcuZ2V0RmxhdENvb3JkaW5hdGVzKCkpO1xuICAgIH1cbiAgICB0aGlzLmVuZHNfLnB1c2godGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoKTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuICAvKipcbiAgICogTWFrZSBhIGNvbXBsZXRlIGNvcHkgb2YgdGhlIGdlb21ldHJ5LlxuICAgKiBAcmV0dXJuIHshUG9seWdvbn0gQ2xvbmUuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBQb2x5Z29uLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgICByZXR1cm4gbmV3IFBvbHlnb24odGhpcy5mbGF0Q29vcmRpbmF0ZXMuc2xpY2UoKSwgdGhpcy5sYXlvdXQsIHRoaXMuZW5kc18uc2xpY2UoKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBQb2x5Z29uLnByb3RvdHlwZS5jbG9zZXN0UG9pbnRYWSA9IGZ1bmN0aW9uIGNsb3Nlc3RQb2ludFhZICh4LCB5LCBjbG9zZXN0UG9pbnQsIG1pblNxdWFyZWREaXN0YW5jZSkge1xuICAgIGlmIChtaW5TcXVhcmVkRGlzdGFuY2UgPCBjbG9zZXN0U3F1YXJlZERpc3RhbmNlWFkodGhpcy5nZXRFeHRlbnQoKSwgeCwgeSkpIHtcbiAgICAgIHJldHVybiBtaW5TcXVhcmVkRGlzdGFuY2U7XG4gICAgfVxuICAgIGlmICh0aGlzLm1heERlbHRhUmV2aXNpb25fICE9IHRoaXMuZ2V0UmV2aXNpb24oKSkge1xuICAgICAgdGhpcy5tYXhEZWx0YV8gPSBNYXRoLnNxcnQoYXJyYXlNYXhTcXVhcmVkRGVsdGEoXG4gICAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmVuZHNfLCB0aGlzLnN0cmlkZSwgMCkpO1xuICAgICAgdGhpcy5tYXhEZWx0YVJldmlzaW9uXyA9IHRoaXMuZ2V0UmV2aXNpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIGFzc2lnbkNsb3Nlc3RBcnJheVBvaW50KFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZW5kc18sIHRoaXMuc3RyaWRlLFxuICAgICAgdGhpcy5tYXhEZWx0YV8sIHRydWUsIHgsIHksIGNsb3Nlc3RQb2ludCwgbWluU3F1YXJlZERpc3RhbmNlKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIFBvbHlnb24ucHJvdG90eXBlLmNvbnRhaW5zWFkgPSBmdW5jdGlvbiBjb250YWluc1hZICh4LCB5KSB7XG4gICAgcmV0dXJuIGxpbmVhclJpbmdzQ29udGFpbnNYWSh0aGlzLmdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzKCksIDAsIHRoaXMuZW5kc18sIHRoaXMuc3RyaWRlLCB4LCB5KTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBhcmVhIG9mIHRoZSBwb2x5Z29uIG9uIHByb2plY3RlZCBwbGFuZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBBcmVhIChvbiBwcm9qZWN0ZWQgcGxhbmUpLlxuICAgKiBAYXBpXG4gICAqL1xuICBQb2x5Z29uLnByb3RvdHlwZS5nZXRBcmVhID0gZnVuY3Rpb24gZ2V0QXJlYSAoKSB7XG4gICAgcmV0dXJuIGxpbmVhclJpbmdzQXJlYSh0aGlzLmdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzKCksIDAsIHRoaXMuZW5kc18sIHRoaXMuc3RyaWRlKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjb29yZGluYXRlIGFycmF5IGZvciB0aGlzIGdlb21ldHJ5LiAgVGhpcyBhcnJheSBoYXMgdGhlIHN0cnVjdHVyZVxuICAgKiBvZiBhIEdlb0pTT04gY29vcmRpbmF0ZSBhcnJheSBmb3IgcG9seWdvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9yaWdodCBPcmllbnQgY29vcmRpbmF0ZXMgYWNjb3JkaW5nIHRvIHRoZSByaWdodC1oYW5kXG4gICAqICAgICBydWxlIChjb3VudGVyLWNsb2Nrd2lzZSBmb3IgZXh0ZXJpb3IgYW5kIGNsb2Nrd2lzZSBmb3IgaW50ZXJpb3IgcmluZ3MpLlxuICAgKiAgICAgSWYgYGZhbHNlYCwgY29vcmRpbmF0ZXMgd2lsbCBiZSBvcmllbnRlZCBhY2NvcmRpbmcgdG8gdGhlIGxlZnQtaGFuZCBydWxlXG4gICAqICAgICAoY2xvY2t3aXNlIGZvciBleHRlcmlvciBhbmQgY291bnRlci1jbG9ja3dpc2UgZm9yIGludGVyaW9yIHJpbmdzKS5cbiAgICogICAgIEJ5IGRlZmF1bHQsIGNvb3JkaW5hdGUgb3JpZW50YXRpb24gd2lsbCBkZXBlbmQgb24gaG93IHRoZSBnZW9tZXRyeSB3YXNcbiAgICogICAgIGNvbnN0cnVjdGVkLlxuICAgKiBAcmV0dXJuIHtBcnJheTxBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+Pn0gQ29vcmRpbmF0ZXMuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBQb2x5Z29uLnByb3RvdHlwZS5nZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVzIChvcHRfcmlnaHQpIHtcbiAgICB2YXIgZmxhdENvb3JkaW5hdGVzO1xuICAgIGlmIChvcHRfcmlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5nZXRPcmllbnRlZEZsYXRDb29yZGluYXRlcygpLnNsaWNlKCk7XG4gICAgICBvcmllbnRMaW5lYXJSaW5ncyhcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmVuZHNfLCB0aGlzLnN0cmlkZSwgb3B0X3JpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5mbGF0Q29vcmRpbmF0ZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZmxhdGVDb29yZGluYXRlc0FycmF5KFxuICAgICAgZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmVuZHNfLCB0aGlzLnN0cmlkZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEVuZHMuXG4gICAqL1xuICBQb2x5Z29uLnByb3RvdHlwZS5nZXRFbmRzID0gZnVuY3Rpb24gZ2V0RW5kcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5kc187XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEludGVyaW9yIHBvaW50LlxuICAgKi9cbiAgUG9seWdvbi5wcm90b3R5cGUuZ2V0RmxhdEludGVyaW9yUG9pbnQgPSBmdW5jdGlvbiBnZXRGbGF0SW50ZXJpb3JQb2ludCAoKSB7XG4gICAgaWYgKHRoaXMuZmxhdEludGVyaW9yUG9pbnRSZXZpc2lvbl8gIT0gdGhpcy5nZXRSZXZpc2lvbigpKSB7XG4gICAgICB2YXIgZmxhdENlbnRlciA9IGdldENlbnRlcih0aGlzLmdldEV4dGVudCgpKTtcbiAgICAgIHRoaXMuZmxhdEludGVyaW9yUG9pbnRfID0gZ2V0SW50ZXJpb3JQb2ludE9mQXJyYXkoXG4gICAgICAgIHRoaXMuZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMoKSwgMCwgdGhpcy5lbmRzXywgdGhpcy5zdHJpZGUsXG4gICAgICAgIGZsYXRDZW50ZXIsIDApO1xuICAgICAgdGhpcy5mbGF0SW50ZXJpb3JQb2ludFJldmlzaW9uXyA9IHRoaXMuZ2V0UmV2aXNpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmxhdEludGVyaW9yUG9pbnRfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gaW50ZXJpb3IgcG9pbnQgb2YgdGhlIHBvbHlnb24uXG4gICAqIEByZXR1cm4ge1BvaW50fSBJbnRlcmlvciBwb2ludCBhcyBYWU0gY29vcmRpbmF0ZSwgd2hlcmUgTSBpcyB0aGVcbiAgICogbGVuZ3RoIG9mIHRoZSBob3Jpem9udGFsIGludGVyc2VjdGlvbiB0aGF0IHRoZSBwb2ludCBiZWxvbmdzIHRvLlxuICAgKiBAYXBpXG4gICAqL1xuICBQb2x5Z29uLnByb3RvdHlwZS5nZXRJbnRlcmlvclBvaW50ID0gZnVuY3Rpb24gZ2V0SW50ZXJpb3JQb2ludCAoKSB7XG4gICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLmdldEZsYXRJbnRlcmlvclBvaW50KCksIEdlb21ldHJ5TGF5b3V0LlhZTSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbnVtYmVyIG9mIHJpbmdzIG9mIHRoZSBwb2x5Z29uLCAgdGhpcyBpbmNsdWRlcyB0aGUgZXh0ZXJpb3JcbiAgICogcmluZyBhbmQgYW55IGludGVyaW9yIHJpbmdzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE51bWJlciBvZiByaW5ncy5cbiAgICogQGFwaVxuICAgKi9cbiAgUG9seWdvbi5wcm90b3R5cGUuZ2V0TGluZWFyUmluZ0NvdW50ID0gZnVuY3Rpb24gZ2V0TGluZWFyUmluZ0NvdW50ICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbmRzXy5sZW5ndGg7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgTnRoIGxpbmVhciByaW5nIG9mIHRoZSBwb2x5Z29uIGdlb21ldHJ5LiBSZXR1cm4gYG51bGxgIGlmIHRoZVxuICAgKiBnaXZlbiBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG4gICAqIFRoZSBleHRlcmlvciBsaW5lYXIgcmluZyBpcyBhdmFpbGFibGUgYXQgaW5kZXggYDBgIGFuZCB0aGUgaW50ZXJpb3IgcmluZ3NcbiAgICogYXQgaW5kZXggYDFgIGFuZCBiZXlvbmQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleC5cbiAgICogQHJldHVybiB7TGluZWFyUmluZ30gTGluZWFyIHJpbmcuXG4gICAqIEBhcGlcbiAgICovXG4gIFBvbHlnb24ucHJvdG90eXBlLmdldExpbmVhclJpbmcgPSBmdW5jdGlvbiBnZXRMaW5lYXJSaW5nIChpbmRleCkge1xuICAgIGlmIChpbmRleCA8IDAgfHwgdGhpcy5lbmRzXy5sZW5ndGggPD0gaW5kZXgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IExpbmVhclJpbmcodGhpcy5mbGF0Q29vcmRpbmF0ZXMuc2xpY2UoXG4gICAgICBpbmRleCA9PT0gMCA/IDAgOiB0aGlzLmVuZHNfW2luZGV4IC0gMV0sIHRoaXMuZW5kc19baW5kZXhdKSwgdGhpcy5sYXlvdXQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGxpbmVhciByaW5ncyBvZiB0aGUgcG9seWdvbi5cbiAgICogQHJldHVybiB7QXJyYXk8TGluZWFyUmluZz59IExpbmVhciByaW5ncy5cbiAgICogQGFwaVxuICAgKi9cbiAgUG9seWdvbi5wcm90b3R5cGUuZ2V0TGluZWFyUmluZ3MgPSBmdW5jdGlvbiBnZXRMaW5lYXJSaW5ncyAoKSB7XG4gICAgdmFyIGxheW91dCA9IHRoaXMubGF5b3V0O1xuICAgIHZhciBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmZsYXRDb29yZGluYXRlcztcbiAgICB2YXIgZW5kcyA9IHRoaXMuZW5kc187XG4gICAgdmFyIGxpbmVhclJpbmdzID0gW107XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB2YXIgZW5kID0gZW5kc1tpXTtcbiAgICAgIHZhciBsaW5lYXJSaW5nID0gbmV3IExpbmVhclJpbmcoZmxhdENvb3JkaW5hdGVzLnNsaWNlKG9mZnNldCwgZW5kKSwgbGF5b3V0KTtcbiAgICAgIGxpbmVhclJpbmdzLnB1c2gobGluZWFyUmluZyk7XG4gICAgICBvZmZzZXQgPSBlbmQ7XG4gICAgfVxuICAgIHJldHVybiBsaW5lYXJSaW5ncztcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gT3JpZW50ZWQgZmxhdCBjb29yZGluYXRlcy5cbiAgICovXG4gIFBvbHlnb24ucHJvdG90eXBlLmdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMgKCkge1xuICAgIGlmICh0aGlzLm9yaWVudGVkUmV2aXNpb25fICE9IHRoaXMuZ2V0UmV2aXNpb24oKSkge1xuICAgICAgdmFyIGZsYXRDb29yZGluYXRlcyA9IHRoaXMuZmxhdENvb3JkaW5hdGVzO1xuICAgICAgaWYgKGxpbmVhclJpbmdJc09yaWVudGVkKFxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZW5kc18sIHRoaXMuc3RyaWRlKSkge1xuICAgICAgICB0aGlzLm9yaWVudGVkRmxhdENvb3JkaW5hdGVzXyA9IGZsYXRDb29yZGluYXRlcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXNfID0gZmxhdENvb3JkaW5hdGVzLnNsaWNlKCk7XG4gICAgICAgIHRoaXMub3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXNfLmxlbmd0aCA9XG4gICAgICAgICAgICBvcmllbnRMaW5lYXJSaW5ncyhcbiAgICAgICAgICAgICAgdGhpcy5vcmllbnRlZEZsYXRDb29yZGluYXRlc18sIDAsIHRoaXMuZW5kc18sIHRoaXMuc3RyaWRlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub3JpZW50ZWRSZXZpc2lvbl8gPSB0aGlzLmdldFJldmlzaW9uKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm9yaWVudGVkRmxhdENvb3JkaW5hdGVzXztcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIFBvbHlnb24ucHJvdG90eXBlLmdldFNpbXBsaWZpZWRHZW9tZXRyeUludGVybmFsID0gZnVuY3Rpb24gZ2V0U2ltcGxpZmllZEdlb21ldHJ5SW50ZXJuYWwgKHNxdWFyZWRUb2xlcmFuY2UpIHtcbiAgICB2YXIgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyA9IFtdO1xuICAgIHZhciBzaW1wbGlmaWVkRW5kcyA9IFtdO1xuICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMubGVuZ3RoID0gcXVhbnRpemVBcnJheShcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmVuZHNfLCB0aGlzLnN0cmlkZSxcbiAgICAgIE1hdGguc3FydChzcXVhcmVkVG9sZXJhbmNlKSxcbiAgICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsIDAsIHNpbXBsaWZpZWRFbmRzKTtcbiAgICByZXR1cm4gbmV3IFBvbHlnb24oc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcywgR2VvbWV0cnlMYXlvdXQuWFksIHNpbXBsaWZpZWRFbmRzKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGFwaVxuICAgKi9cbiAgUG9seWdvbi5wcm90b3R5cGUuZ2V0VHlwZSA9IGZ1bmN0aW9uIGdldFR5cGUgKCkge1xuICAgIHJldHVybiBHZW9tZXRyeVR5cGUuUE9MWUdPTjtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGFwaVxuICAgKi9cbiAgUG9seWdvbi5wcm90b3R5cGUuaW50ZXJzZWN0c0V4dGVudCA9IGZ1bmN0aW9uIGludGVyc2VjdHNFeHRlbnQgKGV4dGVudCkge1xuICAgIHJldHVybiBpbnRlcnNlY3RzTGluZWFyUmluZ0FycmF5KFxuICAgICAgdGhpcy5nZXRPcmllbnRlZEZsYXRDb29yZGluYXRlcygpLCAwLCB0aGlzLmVuZHNfLCB0aGlzLnN0cmlkZSwgZXh0ZW50KTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9seWdvbi5cbiAgICogQHBhcmFtIHshQXJyYXk8QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj59IGNvb3JkaW5hdGVzIENvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0ge0dlb21ldHJ5TGF5b3V0PX0gb3B0X2xheW91dCBMYXlvdXQuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBQb2x5Z29uLnByb3RvdHlwZS5zZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIHNldENvb3JkaW5hdGVzIChjb29yZGluYXRlcywgb3B0X2xheW91dCkge1xuICAgIHRoaXMuc2V0TGF5b3V0KG9wdF9sYXlvdXQsIGNvb3JkaW5hdGVzLCAyKTtcbiAgICBpZiAoIXRoaXMuZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyA9IFtdO1xuICAgIH1cbiAgICB2YXIgZW5kcyA9IGRlZmxhdGVDb29yZGluYXRlc0FycmF5KFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIGNvb3JkaW5hdGVzLCB0aGlzLnN0cmlkZSwgdGhpcy5lbmRzXyk7XG4gICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoID0gZW5kcy5sZW5ndGggPT09IDAgPyAwIDogZW5kc1tlbmRzLmxlbmd0aCAtIDFdO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9O1xuXG4gIHJldHVybiBQb2x5Z29uO1xufShTaW1wbGVHZW9tZXRyeSkpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IFBvbHlnb247XG5cblxuLyoqXG4gKiBDcmVhdGUgYW4gYXBwcm94aW1hdGlvbiBvZiBhIGNpcmNsZSBvbiB0aGUgc3VyZmFjZSBvZiBhIHNwaGVyZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjZW50ZXIgQ2VudGVyIChgW2xvbiwgbGF0XWAgaW4gZGVncmVlcykuXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFRoZSBncmVhdC1jaXJjbGUgZGlzdGFuY2UgZnJvbSB0aGUgY2VudGVyIHRvXG4gKiAgICAgdGhlIHBvbHlnb24gdmVydGljZXMuXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9uIE9wdGlvbmFsIG51bWJlciBvZiB2ZXJ0aWNlcyBmb3IgdGhlIHJlc3VsdGluZ1xuICogICAgIHBvbHlnb24uIERlZmF1bHQgaXMgYDMyYC5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X3NwaGVyZVJhZGl1cyBPcHRpb25hbCByYWRpdXMgZm9yIHRoZSBzcGhlcmUgKGRlZmF1bHRzIHRvXG4gKiAgICAgdGhlIEVhcnRoJ3MgbWVhbiByYWRpdXMgdXNpbmcgdGhlIFdHUzg0IGVsbGlwc29pZCkuXG4gKiBAcmV0dXJuIHtQb2x5Z29ufSBUaGUgXCJjaXJjdWxhclwiIHBvbHlnb24uXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaXJjdWxhcihjZW50ZXIsIHJhZGl1cywgb3B0X24sIG9wdF9zcGhlcmVSYWRpdXMpIHtcbiAgdmFyIG4gPSBvcHRfbiA/IG9wdF9uIDogMzI7XG4gIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi9cbiAgdmFyIGZsYXRDb29yZGluYXRlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgIGV4dGVuZChmbGF0Q29vcmRpbmF0ZXMsIHNwaGVyZU9mZnNldChjZW50ZXIsIHJhZGl1cywgMiAqIE1hdGguUEkgKiBpIC8gbiwgb3B0X3NwaGVyZVJhZGl1cykpO1xuICB9XG4gIGZsYXRDb29yZGluYXRlcy5wdXNoKGZsYXRDb29yZGluYXRlc1swXSwgZmxhdENvb3JkaW5hdGVzWzFdKTtcbiAgcmV0dXJuIG5ldyBQb2x5Z29uKGZsYXRDb29yZGluYXRlcywgR2VvbWV0cnlMYXlvdXQuWFksIFtmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoXSk7XG59XG5cblxuLyoqXG4gKiBDcmVhdGUgYSBwb2x5Z29uIGZyb20gYW4gZXh0ZW50LiBUaGUgbGF5b3V0IHVzZWQgaXMgYFhZYC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IFRoZSBleHRlbnQuXG4gKiBAcmV0dXJuIHtQb2x5Z29ufSBUaGUgcG9seWdvbi5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21FeHRlbnQoZXh0ZW50KSB7XG4gIHZhciBtaW5YID0gZXh0ZW50WzBdO1xuICB2YXIgbWluWSA9IGV4dGVudFsxXTtcbiAgdmFyIG1heFggPSBleHRlbnRbMl07XG4gIHZhciBtYXhZID0gZXh0ZW50WzNdO1xuICB2YXIgZmxhdENvb3JkaW5hdGVzID1cbiAgICAgIFttaW5YLCBtaW5ZLCBtaW5YLCBtYXhZLCBtYXhYLCBtYXhZLCBtYXhYLCBtaW5ZLCBtaW5YLCBtaW5ZXTtcbiAgcmV0dXJuIG5ldyBQb2x5Z29uKGZsYXRDb29yZGluYXRlcywgR2VvbWV0cnlMYXlvdXQuWFksIFtmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoXSk7XG59XG5cblxuLyoqXG4gKiBDcmVhdGUgYSByZWd1bGFyIHBvbHlnb24gZnJvbSBhIGNpcmNsZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9DaXJjbGUuanNcIikuZGVmYXVsdH0gY2lyY2xlIENpcmNsZSBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X3NpZGVzIE51bWJlciBvZiBzaWRlcyBvZiB0aGUgcG9seWdvbi4gRGVmYXVsdCBpcyAzMi5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2FuZ2xlIFN0YXJ0IGFuZ2xlIGZvciB0aGUgZmlyc3QgdmVydGV4IG9mIHRoZSBwb2x5Z29uIGluXG4gKiAgICAgcmFkaWFucy4gRGVmYXVsdCBpcyAwLlxuICogQHJldHVybiB7UG9seWdvbn0gUG9seWdvbiBnZW9tZXRyeS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21DaXJjbGUoY2lyY2xlLCBvcHRfc2lkZXMsIG9wdF9hbmdsZSkge1xuICB2YXIgc2lkZXMgPSBvcHRfc2lkZXMgPyBvcHRfc2lkZXMgOiAzMjtcbiAgdmFyIHN0cmlkZSA9IGNpcmNsZS5nZXRTdHJpZGUoKTtcbiAgdmFyIGxheW91dCA9IGNpcmNsZS5nZXRMYXlvdXQoKTtcbiAgdmFyIGNlbnRlciA9IGNpcmNsZS5nZXRDZW50ZXIoKTtcbiAgdmFyIGFycmF5TGVuZ3RoID0gc3RyaWRlICogKHNpZGVzICsgMSk7XG4gIHZhciBmbGF0Q29vcmRpbmF0ZXMgPSBuZXcgQXJyYXkoYXJyYXlMZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5TGVuZ3RoOyBpICs9IHN0cmlkZSkge1xuICAgIGZsYXRDb29yZGluYXRlc1tpXSA9IDA7XG4gICAgZmxhdENvb3JkaW5hdGVzW2kgKyAxXSA9IDA7XG4gICAgZm9yICh2YXIgaiA9IDI7IGogPCBzdHJpZGU7IGorKykge1xuICAgICAgZmxhdENvb3JkaW5hdGVzW2kgKyBqXSA9IGNlbnRlcltqXTtcbiAgICB9XG4gIH1cbiAgdmFyIGVuZHMgPSBbZmxhdENvb3JkaW5hdGVzLmxlbmd0aF07XG4gIHZhciBwb2x5Z29uID0gbmV3IFBvbHlnb24oZmxhdENvb3JkaW5hdGVzLCBsYXlvdXQsIGVuZHMpO1xuICBtYWtlUmVndWxhcihwb2x5Z29uLCBjZW50ZXIsIGNpcmNsZS5nZXRSYWRpdXMoKSwgb3B0X2FuZ2xlKTtcbiAgcmV0dXJuIHBvbHlnb247XG59XG5cblxuLyoqXG4gKiBNb2RpZnkgdGhlIGNvb3JkaW5hdGVzIG9mIGEgcG9seWdvbiB0byBtYWtlIGl0IGEgcmVndWxhciBwb2x5Z29uLlxuICogQHBhcmFtIHtQb2x5Z29ufSBwb2x5Z29uIFBvbHlnb24gZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY2VudGVyIENlbnRlciBvZiB0aGUgcmVndWxhciBwb2x5Z29uLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBSYWRpdXMgb2YgdGhlIHJlZ3VsYXIgcG9seWdvbi5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2FuZ2xlIFN0YXJ0IGFuZ2xlIGZvciB0aGUgZmlyc3QgdmVydGV4IG9mIHRoZSBwb2x5Z29uIGluXG4gKiAgICAgcmFkaWFucy4gRGVmYXVsdCBpcyAwLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZVJlZ3VsYXIocG9seWdvbiwgY2VudGVyLCByYWRpdXMsIG9wdF9hbmdsZSkge1xuICB2YXIgZmxhdENvb3JkaW5hdGVzID0gcG9seWdvbi5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgdmFyIHN0cmlkZSA9IHBvbHlnb24uZ2V0U3RyaWRlKCk7XG4gIHZhciBzaWRlcyA9IGZsYXRDb29yZGluYXRlcy5sZW5ndGggLyBzdHJpZGUgLSAxO1xuICB2YXIgc3RhcnRBbmdsZSA9IG9wdF9hbmdsZSA/IG9wdF9hbmdsZSA6IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDw9IHNpZGVzOyArK2kpIHtcbiAgICB2YXIgb2Zmc2V0ID0gaSAqIHN0cmlkZTtcbiAgICB2YXIgYW5nbGUgPSBzdGFydEFuZ2xlICsgKG1vZHVsbyhpLCBzaWRlcykgKiAyICogTWF0aC5QSSAvIHNpZGVzKTtcbiAgICBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XSA9IGNlbnRlclswXSArIChyYWRpdXMgKiBNYXRoLmNvcyhhbmdsZSkpO1xuICAgIGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXSA9IGNlbnRlclsxXSArIChyYWRpdXMgKiBNYXRoLnNpbihhbmdsZSkpO1xuICB9XG4gIHBvbHlnb24uY2hhbmdlZCgpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qb2x5Z29uLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL1NpbXBsZUdlb21ldHJ5XG4gKi9cbmltcG9ydCB7YWJzdHJhY3R9IGZyb20gJy4uL3V0aWwuanMnO1xuaW1wb3J0IHtjcmVhdGVPclVwZGF0ZUZyb21GbGF0Q29vcmRpbmF0ZXMsIGdldENlbnRlcn0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCBHZW9tZXRyeSBmcm9tICcuL0dlb21ldHJ5LmpzJztcbmltcG9ydCBHZW9tZXRyeUxheW91dCBmcm9tICcuL0dlb21ldHJ5TGF5b3V0LmpzJztcbmltcG9ydCB7cm90YXRlLCBzY2FsZSwgdHJhbnNsYXRlLCB0cmFuc2Zvcm0yRH0gZnJvbSAnLi9mbGF0L3RyYW5zZm9ybS5qcyc7XG5pbXBvcnQge2NsZWFyfSBmcm9tICcuLi9vYmouanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3M7IG9ubHkgdXNlZCBmb3IgY3JlYXRpbmcgc3ViY2xhc3NlczsgZG8gbm90IGluc3RhbnRpYXRlXG4gKiBpbiBhcHBzLCBhcyBjYW5ub3QgYmUgcmVuZGVyZWQuXG4gKlxuICogQGFic3RyYWN0XG4gKiBAYXBpXG4gKi9cbnZhciBTaW1wbGVHZW9tZXRyeSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEdlb21ldHJ5KSB7XG4gIGZ1bmN0aW9uIFNpbXBsZUdlb21ldHJ5KCkge1xuXG4gICAgR2VvbWV0cnkuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7R2VvbWV0cnlMYXlvdXR9XG4gICAgICovXG4gICAgdGhpcy5sYXlvdXQgPSBHZW9tZXRyeUxheW91dC5YWTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc3RyaWRlID0gMjtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLmZsYXRDb29yZGluYXRlcyA9IG51bGw7XG5cbiAgfVxuXG4gIGlmICggR2VvbWV0cnkgKSBTaW1wbGVHZW9tZXRyeS5fX3Byb3RvX18gPSBHZW9tZXRyeTtcbiAgU2ltcGxlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkgJiYgR2VvbWV0cnkucHJvdG90eXBlICk7XG4gIFNpbXBsZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNpbXBsZUdlb21ldHJ5O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgU2ltcGxlR2VvbWV0cnkucHJvdG90eXBlLmNvbXB1dGVFeHRlbnQgPSBmdW5jdGlvbiBjb21wdXRlRXh0ZW50IChleHRlbnQpIHtcbiAgICByZXR1cm4gY3JlYXRlT3JVcGRhdGVGcm9tRmxhdENvb3JkaW5hdGVzKHRoaXMuZmxhdENvb3JkaW5hdGVzLFxuICAgICAgMCwgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLCB0aGlzLnN0cmlkZSwgZXh0ZW50KTtcbiAgfTtcblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge0FycmF5fSBDb29yZGluYXRlcy5cbiAgICovXG4gIFNpbXBsZUdlb21ldHJ5LnByb3RvdHlwZS5nZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVzICgpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBmaXJzdCBjb29yZGluYXRlIG9mIHRoZSBnZW9tZXRyeS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBGaXJzdCBjb29yZGluYXRlLlxuICAgKiBAYXBpXG4gICAqL1xuICBTaW1wbGVHZW9tZXRyeS5wcm90b3R5cGUuZ2V0Rmlyc3RDb29yZGluYXRlID0gZnVuY3Rpb24gZ2V0Rmlyc3RDb29yZGluYXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5mbGF0Q29vcmRpbmF0ZXMuc2xpY2UoMCwgdGhpcy5zdHJpZGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBGbGF0IGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgU2ltcGxlR2VvbWV0cnkucHJvdG90eXBlLmdldEZsYXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIGdldEZsYXRDb29yZGluYXRlcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmxhdENvb3JkaW5hdGVzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGxhc3QgY29vcmRpbmF0ZSBvZiB0aGUgZ2VvbWV0cnkuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gTGFzdCBwb2ludC5cbiAgICogQGFwaVxuICAgKi9cbiAgU2ltcGxlR2VvbWV0cnkucHJvdG90eXBlLmdldExhc3RDb29yZGluYXRlID0gZnVuY3Rpb24gZ2V0TGFzdENvb3JkaW5hdGUgKCkge1xuICAgIHJldHVybiB0aGlzLmZsYXRDb29yZGluYXRlcy5zbGljZSh0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGggLSB0aGlzLnN0cmlkZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUge0BsaW5rIG1vZHVsZTpvbC9nZW9tL0dlb21ldHJ5TGF5b3V0IGxheW91dH0gb2YgdGhlIGdlb21ldHJ5LlxuICAgKiBAcmV0dXJuIHtHZW9tZXRyeUxheW91dH0gTGF5b3V0LlxuICAgKiBAYXBpXG4gICAqL1xuICBTaW1wbGVHZW9tZXRyeS5wcm90b3R5cGUuZ2V0TGF5b3V0ID0gZnVuY3Rpb24gZ2V0TGF5b3V0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5sYXlvdXQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBTaW1wbGVHZW9tZXRyeS5wcm90b3R5cGUuZ2V0U2ltcGxpZmllZEdlb21ldHJ5ID0gZnVuY3Rpb24gZ2V0U2ltcGxpZmllZEdlb21ldHJ5IChzcXVhcmVkVG9sZXJhbmNlKSB7XG4gICAgaWYgKHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5UmV2aXNpb24gIT0gdGhpcy5nZXRSZXZpc2lvbigpKSB7XG4gICAgICBjbGVhcih0aGlzLnNpbXBsaWZpZWRHZW9tZXRyeUNhY2hlKTtcbiAgICAgIHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5TWF4TWluU3F1YXJlZFRvbGVyYW5jZSA9IDA7XG4gICAgICB0aGlzLnNpbXBsaWZpZWRHZW9tZXRyeVJldmlzaW9uID0gdGhpcy5nZXRSZXZpc2lvbigpO1xuICAgIH1cbiAgICAvLyBJZiBzcXVhcmVkVG9sZXJhbmNlIGlzIG5lZ2F0aXZlIG9yIGlmIHdlIGtub3cgdGhhdCBzaW1wbGlmaWNhdGlvbiB3aWxsIG5vdFxuICAgIC8vIGhhdmUgYW55IGVmZmVjdCB0aGVuIGp1c3QgcmV0dXJuIHRoaXMuXG4gICAgaWYgKHNxdWFyZWRUb2xlcmFuY2UgPCAwIHx8XG4gICAgICAgICh0aGlzLnNpbXBsaWZpZWRHZW9tZXRyeU1heE1pblNxdWFyZWRUb2xlcmFuY2UgIT09IDAgJiZcbiAgICAgICAgIHNxdWFyZWRUb2xlcmFuY2UgPD0gdGhpcy5zaW1wbGlmaWVkR2VvbWV0cnlNYXhNaW5TcXVhcmVkVG9sZXJhbmNlKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciBrZXkgPSBzcXVhcmVkVG9sZXJhbmNlLnRvU3RyaW5nKCk7XG4gICAgaWYgKHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5Q2FjaGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5Q2FjaGVba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNpbXBsaWZpZWRHZW9tZXRyeSA9XG4gICAgICAgICAgdGhpcy5nZXRTaW1wbGlmaWVkR2VvbWV0cnlJbnRlcm5hbChzcXVhcmVkVG9sZXJhbmNlKTtcbiAgICAgIHZhciBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzID0gc2ltcGxpZmllZEdlb21ldHJ5LmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgICAgaWYgKHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMubGVuZ3RoIDwgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5Q2FjaGVba2V5XSA9IHNpbXBsaWZpZWRHZW9tZXRyeTtcbiAgICAgICAgcmV0dXJuIHNpbXBsaWZpZWRHZW9tZXRyeTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNpbXBsaWZpY2F0aW9uIGRpZCBub3QgYWN0dWFsbHkgcmVtb3ZlIGFueSBjb29yZGluYXRlcy4gIFdlIG5vdyBrbm93XG4gICAgICAgIC8vIHRoYXQgYW55IGNhbGxzIHRvIGdldFNpbXBsaWZpZWRHZW9tZXRyeSB3aXRoIGEgc3F1YXJlZFRvbGVyYW5jZSBsZXNzXG4gICAgICAgIC8vIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGN1cnJlbnQgc3F1YXJlZFRvbGVyYW5jZSB3aWxsIGFsc28gbm90IGhhdmUgYW55XG4gICAgICAgIC8vIGVmZmVjdC4gIFRoaXMgYWxsb3dzIHVzIHRvIHNob3J0IGNpcmN1aXQgc2ltcGxpZmljYXRpb24gKHNhdmluZyBDUFVcbiAgICAgICAgLy8gY3ljbGVzKSBhbmQgcHJldmVudHMgdGhlIGNhY2hlIG9mIHNpbXBsaWZpZWQgZ2VvbWV0cmllcyBmcm9tIGZpbGxpbmdcbiAgICAgICAgLy8gdXAgd2l0aCB1c2VsZXNzIGlkZW50aWNhbCBjb3BpZXMgb2YgdGhpcyBnZW9tZXRyeSAoc2F2aW5nIG1lbW9yeSkuXG4gICAgICAgIHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5TWF4TWluU3F1YXJlZFRvbGVyYW5jZSA9IHNxdWFyZWRUb2xlcmFuY2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNxdWFyZWRUb2xlcmFuY2UgU3F1YXJlZCB0b2xlcmFuY2UuXG4gICAqIEByZXR1cm4ge1NpbXBsZUdlb21ldHJ5fSBTaW1wbGlmaWVkIGdlb21ldHJ5LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBTaW1wbGVHZW9tZXRyeS5wcm90b3R5cGUuZ2V0U2ltcGxpZmllZEdlb21ldHJ5SW50ZXJuYWwgPSBmdW5jdGlvbiBnZXRTaW1wbGlmaWVkR2VvbWV0cnlJbnRlcm5hbCAoc3F1YXJlZFRvbGVyYW5jZSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFN0cmlkZS5cbiAgICovXG4gIFNpbXBsZUdlb21ldHJ5LnByb3RvdHlwZS5nZXRTdHJpZGUgPSBmdW5jdGlvbiBnZXRTdHJpZGUgKCkge1xuICAgIHJldHVybiB0aGlzLnN0cmlkZTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtHZW9tZXRyeUxheW91dH0gbGF5b3V0IExheW91dC5cbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAgICovXG4gIFNpbXBsZUdlb21ldHJ5LnByb3RvdHlwZS5zZXRGbGF0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBzZXRGbGF0Q29vcmRpbmF0ZXMgKGxheW91dCwgZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgdGhpcy5zdHJpZGUgPSBnZXRTdHJpZGVGb3JMYXlvdXQobGF5b3V0KTtcbiAgICB0aGlzLmxheW91dCA9IGxheW91dDtcbiAgICB0aGlzLmZsYXRDb29yZGluYXRlcyA9IGZsYXRDb29yZGluYXRlcztcbiAgfTtcblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7IUFycmF5fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAgICogQHBhcmFtIHtHZW9tZXRyeUxheW91dD19IG9wdF9sYXlvdXQgTGF5b3V0LlxuICAgKi9cbiAgU2ltcGxlR2VvbWV0cnkucHJvdG90eXBlLnNldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gc2V0Q29vcmRpbmF0ZXMgKGNvb3JkaW5hdGVzLCBvcHRfbGF5b3V0KSB7XG4gICAgYWJzdHJhY3QoKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtHZW9tZXRyeUxheW91dHx1bmRlZmluZWR9IGxheW91dCBMYXlvdXQuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNvb3JkaW5hdGVzIENvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbmVzdGluZyBOZXN0aW5nLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBTaW1wbGVHZW9tZXRyeS5wcm90b3R5cGUuc2V0TGF5b3V0ID0gZnVuY3Rpb24gc2V0TGF5b3V0IChsYXlvdXQsIGNvb3JkaW5hdGVzLCBuZXN0aW5nKSB7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdmFyIHN0cmlkZTtcbiAgICBpZiAobGF5b3V0KSB7XG4gICAgICBzdHJpZGUgPSBnZXRTdHJpZGVGb3JMYXlvdXQobGF5b3V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXN0aW5nOyArK2kpIHtcbiAgICAgICAgaWYgKGNvb3JkaW5hdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMubGF5b3V0ID0gR2VvbWV0cnlMYXlvdXQuWFk7XG4gICAgICAgICAgdGhpcy5zdHJpZGUgPSAyO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb29yZGluYXRlcyA9IC8qKiBAdHlwZSB7QXJyYXl9ICovIChjb29yZGluYXRlc1swXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0cmlkZSA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICAgIGxheW91dCA9IGdldExheW91dEZvclN0cmlkZShzdHJpZGUpO1xuICAgIH1cbiAgICB0aGlzLmxheW91dCA9IGxheW91dDtcbiAgICB0aGlzLnN0cmlkZSA9IHN0cmlkZTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGFwaVxuICAgKi9cbiAgU2ltcGxlR2VvbWV0cnkucHJvdG90eXBlLmFwcGx5VHJhbnNmb3JtID0gZnVuY3Rpb24gYXBwbHlUcmFuc2Zvcm0gKHRyYW5zZm9ybUZuKSB7XG4gICAgaWYgKHRoaXMuZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgICB0cmFuc2Zvcm1Gbih0aGlzLmZsYXRDb29yZGluYXRlcywgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIHRoaXMuc3RyaWRlKTtcbiAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGFwaVxuICAgKi9cbiAgU2ltcGxlR2VvbWV0cnkucHJvdG90eXBlLnJvdGF0ZSA9IGZ1bmN0aW9uIHJvdGF0ZSQxIChhbmdsZSwgYW5jaG9yKSB7XG4gICAgdmFyIGZsYXRDb29yZGluYXRlcyA9IHRoaXMuZ2V0RmxhdENvb3JkaW5hdGVzKCk7XG4gICAgaWYgKGZsYXRDb29yZGluYXRlcykge1xuICAgICAgdmFyIHN0cmlkZSA9IHRoaXMuZ2V0U3RyaWRlKCk7XG4gICAgICByb3RhdGUoXG4gICAgICAgIGZsYXRDb29yZGluYXRlcywgMCwgZmxhdENvb3JkaW5hdGVzLmxlbmd0aCxcbiAgICAgICAgc3RyaWRlLCBhbmdsZSwgYW5jaG9yLCBmbGF0Q29vcmRpbmF0ZXMpO1xuICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKiBAYXBpXG4gICAqL1xuICBTaW1wbGVHZW9tZXRyeS5wcm90b3R5cGUuc2NhbGUgPSBmdW5jdGlvbiBzY2FsZSQxIChzeCwgb3B0X3N5LCBvcHRfYW5jaG9yKSB7XG4gICAgdmFyIHN5ID0gb3B0X3N5O1xuICAgIGlmIChzeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzeSA9IHN4O1xuICAgIH1cbiAgICB2YXIgYW5jaG9yID0gb3B0X2FuY2hvcjtcbiAgICBpZiAoIWFuY2hvcikge1xuICAgICAgYW5jaG9yID0gZ2V0Q2VudGVyKHRoaXMuZ2V0RXh0ZW50KCkpO1xuICAgIH1cbiAgICB2YXIgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICBpZiAoZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgICB2YXIgc3RyaWRlID0gdGhpcy5nZXRTdHJpZGUoKTtcbiAgICAgIHNjYWxlKFxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXMsIDAsIGZsYXRDb29yZGluYXRlcy5sZW5ndGgsXG4gICAgICAgIHN0cmlkZSwgc3gsIHN5LCBhbmNob3IsIGZsYXRDb29yZGluYXRlcyk7XG4gICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqIEBhcGlcbiAgICovXG4gIFNpbXBsZUdlb21ldHJ5LnByb3RvdHlwZS50cmFuc2xhdGUgPSBmdW5jdGlvbiB0cmFuc2xhdGUkMSAoZGVsdGFYLCBkZWx0YVkpIHtcbiAgICB2YXIgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICBpZiAoZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgICB2YXIgc3RyaWRlID0gdGhpcy5nZXRTdHJpZGUoKTtcbiAgICAgIHRyYW5zbGF0ZShcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzLCAwLCBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLCBzdHJpZGUsXG4gICAgICAgIGRlbHRhWCwgZGVsdGFZLCBmbGF0Q29vcmRpbmF0ZXMpO1xuICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBTaW1wbGVHZW9tZXRyeTtcbn0oR2VvbWV0cnkpKTtcblxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHJldHVybiB7R2VvbWV0cnlMYXlvdXR9IGxheW91dCBMYXlvdXQuXG4gKi9cbmZ1bmN0aW9uIGdldExheW91dEZvclN0cmlkZShzdHJpZGUpIHtcbiAgdmFyIGxheW91dDtcbiAgaWYgKHN0cmlkZSA9PSAyKSB7XG4gICAgbGF5b3V0ID0gR2VvbWV0cnlMYXlvdXQuWFk7XG4gIH0gZWxzZSBpZiAoc3RyaWRlID09IDMpIHtcbiAgICBsYXlvdXQgPSBHZW9tZXRyeUxheW91dC5YWVo7XG4gIH0gZWxzZSBpZiAoc3RyaWRlID09IDQpIHtcbiAgICBsYXlvdXQgPSBHZW9tZXRyeUxheW91dC5YWVpNO1xuICB9XG4gIHJldHVybiAoXG4gICAgLyoqIEB0eXBlIHtHZW9tZXRyeUxheW91dH0gKi8gKGxheW91dClcbiAgKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7R2VvbWV0cnlMYXlvdXR9IGxheW91dCBMYXlvdXQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFN0cmlkZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFN0cmlkZUZvckxheW91dChsYXlvdXQpIHtcbiAgdmFyIHN0cmlkZTtcbiAgaWYgKGxheW91dCA9PSBHZW9tZXRyeUxheW91dC5YWSkge1xuICAgIHN0cmlkZSA9IDI7XG4gIH0gZWxzZSBpZiAobGF5b3V0ID09IEdlb21ldHJ5TGF5b3V0LlhZWiB8fCBsYXlvdXQgPT0gR2VvbWV0cnlMYXlvdXQuWFlNKSB7XG4gICAgc3RyaWRlID0gMztcbiAgfSBlbHNlIGlmIChsYXlvdXQgPT0gR2VvbWV0cnlMYXlvdXQuWFlaTSkge1xuICAgIHN0cmlkZSA9IDQ7XG4gIH1cbiAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoc3RyaWRlKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7U2ltcGxlR2VvbWV0cnl9IHNpbXBsZUdlb21ldHJ5IFNpbXBsZSBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPj19IG9wdF9kZXN0IERlc3RpbmF0aW9uLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVHJhbnNmb3JtZWQgZmxhdCBjb29yZGluYXRlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybUdlb20yRChzaW1wbGVHZW9tZXRyeSwgdHJhbnNmb3JtLCBvcHRfZGVzdCkge1xuICB2YXIgZmxhdENvb3JkaW5hdGVzID0gc2ltcGxlR2VvbWV0cnkuZ2V0RmxhdENvb3JkaW5hdGVzKCk7XG4gIGlmICghZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHN0cmlkZSA9IHNpbXBsZUdlb21ldHJ5LmdldFN0cmlkZSgpO1xuICAgIHJldHVybiB0cmFuc2Zvcm0yRChcbiAgICAgIGZsYXRDb29yZGluYXRlcywgMCwgZmxhdENvb3JkaW5hdGVzLmxlbmd0aCwgc3RyaWRlLFxuICAgICAgdHJhbnNmb3JtLCBvcHRfZGVzdCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU2ltcGxlR2VvbWV0cnk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNpbXBsZUdlb21ldHJ5LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL2ZsYXQvYXJlYVxuICovXG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHJldHVybiB7bnVtYmVyfSBBcmVhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyUmluZyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUpIHtcbiAgdmFyIHR3aWNlQXJlYSA9IDA7XG4gIHZhciB4MSA9IGZsYXRDb29yZGluYXRlc1tlbmQgLSBzdHJpZGVdO1xuICB2YXIgeTEgPSBmbGF0Q29vcmRpbmF0ZXNbZW5kIC0gc3RyaWRlICsgMV07XG4gIGZvciAoOyBvZmZzZXQgPCBlbmQ7IG9mZnNldCArPSBzdHJpZGUpIHtcbiAgICB2YXIgeDIgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XTtcbiAgICB2YXIgeTIgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gICAgdHdpY2VBcmVhICs9IHkxICogeDIgLSB4MSAqIHkyO1xuICAgIHgxID0geDI7XG4gICAgeTEgPSB5MjtcbiAgfVxuICByZXR1cm4gdHdpY2VBcmVhIC8gMjtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW5kcyBFbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFyZWEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJSaW5ncyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlKSB7XG4gIHZhciBhcmVhID0gMDtcbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgdmFyIGVuZCA9IGVuZHNbaV07XG4gICAgYXJlYSArPSBsaW5lYXJSaW5nKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSk7XG4gICAgb2Zmc2V0ID0gZW5kO1xuICB9XG4gIHJldHVybiBhcmVhO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gZW5kc3MgRW5kc3MuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEByZXR1cm4ge251bWJlcn0gQXJlYS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhclJpbmdzcyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kc3MsIHN0cmlkZSkge1xuICB2YXIgYXJlYSA9IDA7XG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IGVuZHNzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICB2YXIgZW5kcyA9IGVuZHNzW2ldO1xuICAgIGFyZWEgKz0gbGluZWFyUmluZ3MoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHMsIHN0cmlkZSk7XG4gICAgb2Zmc2V0ID0gZW5kc1tlbmRzLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBhcmVhO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcmVhLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL2ZsYXQvY2VudGVyXG4gKi9cbmltcG9ydCB7Y3JlYXRlRW1wdHksIGNyZWF0ZU9yVXBkYXRlRnJvbUZsYXRDb29yZGluYXRlc30gZnJvbSAnLi4vLi4vZXh0ZW50LmpzJztcblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGVuZHNzIEVuZHNzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBGbGF0IGNlbnRlcnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJSaW5nc3MoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHNzLCBzdHJpZGUpIHtcbiAgdmFyIGZsYXRDZW50ZXJzID0gW107XG4gIHZhciBleHRlbnQgPSBjcmVhdGVFbXB0eSgpO1xuICBmb3IgKHZhciBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgdmFyIGVuZHMgPSBlbmRzc1tpXTtcbiAgICBleHRlbnQgPSBjcmVhdGVPclVwZGF0ZUZyb21GbGF0Q29vcmRpbmF0ZXMoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHNbMF0sIHN0cmlkZSk7XG4gICAgZmxhdENlbnRlcnMucHVzaCgoZXh0ZW50WzBdICsgZXh0ZW50WzJdKSAvIDIsIChleHRlbnRbMV0gKyBleHRlbnRbM10pIC8gMik7XG4gICAgb2Zmc2V0ID0gZW5kc1tlbmRzLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBmbGF0Q2VudGVycztcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2VudGVyLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL2ZsYXQvY2xvc2VzdFxuICovXG5pbXBvcnQge2xlcnAsIHNxdWFyZWREaXN0YW5jZSBhcyBzcXVhcmVkRHh9IGZyb20gJy4uLy4uL21hdGguanMnO1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgcG9pbnQgb24gdGhlIDJEIGxpbmUgc2VnbWVudCBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0MV0gdG9cbiAqIGZsYXRDb29yZGluYXRlc1tvZmZzZXQyXSB0aGF0IGlzIGNsb3Nlc3QgdG8gdGhlIHBvaW50ICh4LCB5KS4gIEV4dHJhXG4gKiBkaW1lbnNpb25zIGFyZSBsaW5lYXJseSBpbnRlcnBvbGF0ZWQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldDEgT2Zmc2V0IDEuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0MiBPZmZzZXQgMi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNsb3Nlc3RQb2ludCBDbG9zZXN0IHBvaW50LlxuICovXG5mdW5jdGlvbiBhc3NpZ25DbG9zZXN0KGZsYXRDb29yZGluYXRlcywgb2Zmc2V0MSwgb2Zmc2V0Miwgc3RyaWRlLCB4LCB5LCBjbG9zZXN0UG9pbnQpIHtcbiAgdmFyIHgxID0gZmxhdENvb3JkaW5hdGVzW29mZnNldDFdO1xuICB2YXIgeTEgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0MSArIDFdO1xuICB2YXIgZHggPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0Ml0gLSB4MTtcbiAgdmFyIGR5ID0gZmxhdENvb3JkaW5hdGVzW29mZnNldDIgKyAxXSAtIHkxO1xuICB2YXIgb2Zmc2V0O1xuICBpZiAoZHggPT09IDAgJiYgZHkgPT09IDApIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQxO1xuICB9IGVsc2Uge1xuICAgIHZhciB0ID0gKCh4IC0geDEpICogZHggKyAoeSAtIHkxKSAqIGR5KSAvIChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgaWYgKHQgPiAxKSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQyO1xuICAgIH0gZWxzZSBpZiAodCA+IDApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaWRlOyArK2kpIHtcbiAgICAgICAgY2xvc2VzdFBvaW50W2ldID0gbGVycChmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0MSArIGldLFxuICAgICAgICAgIGZsYXRDb29yZGluYXRlc1tvZmZzZXQyICsgaV0sIHQpO1xuICAgICAgfVxuICAgICAgY2xvc2VzdFBvaW50Lmxlbmd0aCA9IHN0cmlkZTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0MTtcbiAgICB9XG4gIH1cbiAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgc3RyaWRlOyArK2kkMSkge1xuICAgIGNsb3Nlc3RQb2ludFtpJDFdID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIGkkMV07XG4gIH1cbiAgY2xvc2VzdFBvaW50Lmxlbmd0aCA9IHN0cmlkZTtcbn1cblxuXG4vKipcbiAqIFJldHVybiB0aGUgc3F1YXJlZCBvZiB0aGUgbGFyZ2VzdCBkaXN0YW5jZSBiZXR3ZWVuIGFueSBwYWlyIG9mIGNvbnNlY3V0aXZlXG4gKiBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IE1heCBzcXVhcmVkIGRlbHRhLlxuICogQHJldHVybiB7bnVtYmVyfSBNYXggc3F1YXJlZCBkZWx0YS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1heFNxdWFyZWREZWx0YShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIG1heCkge1xuICB2YXIgeDEgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XTtcbiAgdmFyIHkxID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdO1xuICBmb3IgKG9mZnNldCArPSBzdHJpZGU7IG9mZnNldCA8IGVuZDsgb2Zmc2V0ICs9IHN0cmlkZSkge1xuICAgIHZhciB4MiA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXRdO1xuICAgIHZhciB5MiA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXTtcbiAgICB2YXIgc3F1YXJlZERlbHRhID0gc3F1YXJlZER4KHgxLCB5MSwgeDIsIHkyKTtcbiAgICBpZiAoc3F1YXJlZERlbHRhID4gbWF4KSB7XG4gICAgICBtYXggPSBzcXVhcmVkRGVsdGE7XG4gICAgfVxuICAgIHgxID0geDI7XG4gICAgeTEgPSB5MjtcbiAgfVxuICByZXR1cm4gbWF4O1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbmRzIEVuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggTWF4IHNxdWFyZWQgZGVsdGEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE1heCBzcXVhcmVkIGRlbHRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlNYXhTcXVhcmVkRGVsdGEoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHMsIHN0cmlkZSwgbWF4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IGVuZHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIHZhciBlbmQgPSBlbmRzW2ldO1xuICAgIG1heCA9IG1heFNxdWFyZWREZWx0YShcbiAgICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgbWF4KTtcbiAgICBvZmZzZXQgPSBlbmQ7XG4gIH1cbiAgcmV0dXJuIG1heDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGVuZHNzIEVuZHNzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IE1heCBzcXVhcmVkIGRlbHRhLlxuICogQHJldHVybiB7bnVtYmVyfSBNYXggc3F1YXJlZCBkZWx0YS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpQXJyYXlNYXhTcXVhcmVkRGVsdGEoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHNzLCBzdHJpZGUsIG1heCkge1xuICBmb3IgKHZhciBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgdmFyIGVuZHMgPSBlbmRzc1tpXTtcbiAgICBtYXggPSBhcnJheU1heFNxdWFyZWREZWx0YShcbiAgICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLCBzdHJpZGUsIG1heCk7XG4gICAgb2Zmc2V0ID0gZW5kc1tlbmRzLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBtYXg7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heERlbHRhIE1heCBkZWx0YS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNSaW5nIElzIHJpbmcuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY2xvc2VzdFBvaW50IENsb3Nlc3QgcG9pbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gbWluU3F1YXJlZERpc3RhbmNlIE1pbmltdW0gc3F1YXJlZCBkaXN0YW5jZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPj19IG9wdF90bXBQb2ludCBUZW1wb3JhcnkgcG9pbnQgb2JqZWN0LlxuICogQHJldHVybiB7bnVtYmVyfSBNaW5pbXVtIHNxdWFyZWQgZGlzdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ25DbG9zZXN0UG9pbnQoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCxcbiAgc3RyaWRlLCBtYXhEZWx0YSwgaXNSaW5nLCB4LCB5LCBjbG9zZXN0UG9pbnQsIG1pblNxdWFyZWREaXN0YW5jZSxcbiAgb3B0X3RtcFBvaW50KSB7XG4gIGlmIChvZmZzZXQgPT0gZW5kKSB7XG4gICAgcmV0dXJuIG1pblNxdWFyZWREaXN0YW5jZTtcbiAgfVxuICB2YXIgaSwgc3F1YXJlZERpc3RhbmNlO1xuICBpZiAobWF4RGVsdGEgPT09IDApIHtcbiAgICAvLyBBbGwgcG9pbnRzIGFyZSBpZGVudGljYWwsIHNvIGp1c3QgdGVzdCB0aGUgZmlyc3QgcG9pbnQuXG4gICAgc3F1YXJlZERpc3RhbmNlID0gc3F1YXJlZER4KFxuICAgICAgeCwgeSwgZmxhdENvb3JkaW5hdGVzW29mZnNldF0sIGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXSk7XG4gICAgaWYgKHNxdWFyZWREaXN0YW5jZSA8IG1pblNxdWFyZWREaXN0YW5jZSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IHN0cmlkZTsgKytpKSB7XG4gICAgICAgIGNsb3Nlc3RQb2ludFtpXSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyBpXTtcbiAgICAgIH1cbiAgICAgIGNsb3Nlc3RQb2ludC5sZW5ndGggPSBzdHJpZGU7XG4gICAgICByZXR1cm4gc3F1YXJlZERpc3RhbmNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWluU3F1YXJlZERpc3RhbmNlO1xuICAgIH1cbiAgfVxuICB2YXIgdG1wUG9pbnQgPSBvcHRfdG1wUG9pbnQgPyBvcHRfdG1wUG9pbnQgOiBbTmFOLCBOYU5dO1xuICB2YXIgaW5kZXggPSBvZmZzZXQgKyBzdHJpZGU7XG4gIHdoaWxlIChpbmRleCA8IGVuZCkge1xuICAgIGFzc2lnbkNsb3Nlc3QoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsIGluZGV4IC0gc3RyaWRlLCBpbmRleCwgc3RyaWRlLCB4LCB5LCB0bXBQb2ludCk7XG4gICAgc3F1YXJlZERpc3RhbmNlID0gc3F1YXJlZER4KHgsIHksIHRtcFBvaW50WzBdLCB0bXBQb2ludFsxXSk7XG4gICAgaWYgKHNxdWFyZWREaXN0YW5jZSA8IG1pblNxdWFyZWREaXN0YW5jZSkge1xuICAgICAgbWluU3F1YXJlZERpc3RhbmNlID0gc3F1YXJlZERpc3RhbmNlO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHN0cmlkZTsgKytpKSB7XG4gICAgICAgIGNsb3Nlc3RQb2ludFtpXSA9IHRtcFBvaW50W2ldO1xuICAgICAgfVxuICAgICAgY2xvc2VzdFBvaW50Lmxlbmd0aCA9IHN0cmlkZTtcbiAgICAgIGluZGV4ICs9IHN0cmlkZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2tpcCBhaGVhZCBtdWx0aXBsZSBwb2ludHMsIGJlY2F1c2Ugd2Uga25vdyB0aGF0IGFsbCB0aGUgc2tpcHBlZFxuICAgICAgLy8gcG9pbnRzIGNhbm5vdCBiZSBhbnkgY2xvc2VyIHRoYW4gdGhlIGNsb3Nlc3QgcG9pbnQgd2UgaGF2ZSBmb3VuZCBzb1xuICAgICAgLy8gZmFyLiAgV2Uga25vdyB0aGlzIGJlY2F1c2Ugd2Uga25vdyBob3cgY2xvc2UgdGhlIGN1cnJlbnQgcG9pbnQgaXMsIGhvd1xuICAgICAgLy8gY2xvc2UgdGhlIGNsb3Nlc3QgcG9pbnQgd2UgaGF2ZSBmb3VuZCBzbyBmYXIgaXMsIGFuZCB0aGUgbWF4aW11bVxuICAgICAgLy8gZGlzdGFuY2UgYmV0d2VlbiBjb25zZWN1dGl2ZSBwb2ludHMuICBGb3IgZXhhbXBsZSwgaWYgd2UncmUgY3VycmVudGx5XG4gICAgICAvLyBhdCBkaXN0YW5jZSAxMCwgdGhlIGJlc3Qgd2UndmUgZm91bmQgc28gZmFyIGlzIDMsIGFuZCB0aGF0IHRoZSBtYXhpbXVtXG4gICAgICAvLyBkaXN0YW5jZSBiZXR3ZWVuIGNvbnNlY3V0aXZlIHBvaW50cyBpcyAyLCB0aGVuIHdlJ2xsIG5lZWQgdG8gc2tpcCBhdFxuICAgICAgLy8gbGVhc3QgKDEwIC0gMykgLyAyID09IDMgKHJvdW5kZWQgZG93bikgcG9pbnRzIHRvIGhhdmUgYW55IGNoYW5jZSBvZlxuICAgICAgLy8gZmluZGluZyBhIGNsb3NlciBwb2ludC4gIFdlIHVzZSBNYXRoLm1heCguLi4sIDEpIHRvIGVuc3VyZSB0aGF0IHdlXG4gICAgICAvLyBhbHdheXMgYWR2YW5jZSBhdCBsZWFzdCBvbmUgcG9pbnQsIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3AuXG4gICAgICBpbmRleCArPSBzdHJpZGUgKiBNYXRoLm1heChcbiAgICAgICAgKChNYXRoLnNxcnQoc3F1YXJlZERpc3RhbmNlKSAtXG4gICAgICAgICAgICBNYXRoLnNxcnQobWluU3F1YXJlZERpc3RhbmNlKSkgLyBtYXhEZWx0YSkgfCAwLCAxKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzUmluZykge1xuICAgIC8vIENoZWNrIHRoZSBjbG9zaW5nIHNlZ21lbnQuXG4gICAgYXNzaWduQ2xvc2VzdChcbiAgICAgIGZsYXRDb29yZGluYXRlcywgZW5kIC0gc3RyaWRlLCBvZmZzZXQsIHN0cmlkZSwgeCwgeSwgdG1wUG9pbnQpO1xuICAgIHNxdWFyZWREaXN0YW5jZSA9IHNxdWFyZWREeCh4LCB5LCB0bXBQb2ludFswXSwgdG1wUG9pbnRbMV0pO1xuICAgIGlmIChzcXVhcmVkRGlzdGFuY2UgPCBtaW5TcXVhcmVkRGlzdGFuY2UpIHtcbiAgICAgIG1pblNxdWFyZWREaXN0YW5jZSA9IHNxdWFyZWREaXN0YW5jZTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzdHJpZGU7ICsraSkge1xuICAgICAgICBjbG9zZXN0UG9pbnRbaV0gPSB0bXBQb2ludFtpXTtcbiAgICAgIH1cbiAgICAgIGNsb3Nlc3RQb2ludC5sZW5ndGggPSBzdHJpZGU7XG4gICAgfVxuICB9XG4gIHJldHVybiBtaW5TcXVhcmVkRGlzdGFuY2U7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGVuZHMgRW5kcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heERlbHRhIE1heCBkZWx0YS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNSaW5nIElzIHJpbmcuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY2xvc2VzdFBvaW50IENsb3Nlc3QgcG9pbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gbWluU3F1YXJlZERpc3RhbmNlIE1pbmltdW0gc3F1YXJlZCBkaXN0YW5jZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPj19IG9wdF90bXBQb2ludCBUZW1wb3JhcnkgcG9pbnQgb2JqZWN0LlxuICogQHJldHVybiB7bnVtYmVyfSBNaW5pbXVtIHNxdWFyZWQgZGlzdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ25DbG9zZXN0QXJyYXlQb2ludChmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcyxcbiAgc3RyaWRlLCBtYXhEZWx0YSwgaXNSaW5nLCB4LCB5LCBjbG9zZXN0UG9pbnQsIG1pblNxdWFyZWREaXN0YW5jZSxcbiAgb3B0X3RtcFBvaW50KSB7XG4gIHZhciB0bXBQb2ludCA9IG9wdF90bXBQb2ludCA/IG9wdF90bXBQb2ludCA6IFtOYU4sIE5hTl07XG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IGVuZHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIHZhciBlbmQgPSBlbmRzW2ldO1xuICAgIG1pblNxdWFyZWREaXN0YW5jZSA9IGFzc2lnbkNsb3Nlc3RQb2ludChcbiAgICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSxcbiAgICAgIG1heERlbHRhLCBpc1JpbmcsIHgsIHksIGNsb3Nlc3RQb2ludCwgbWluU3F1YXJlZERpc3RhbmNlLCB0bXBQb2ludCk7XG4gICAgb2Zmc2V0ID0gZW5kO1xuICB9XG4gIHJldHVybiBtaW5TcXVhcmVkRGlzdGFuY2U7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBlbmRzcyBFbmRzcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heERlbHRhIE1heCBkZWx0YS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNSaW5nIElzIHJpbmcuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY2xvc2VzdFBvaW50IENsb3Nlc3QgcG9pbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gbWluU3F1YXJlZERpc3RhbmNlIE1pbmltdW0gc3F1YXJlZCBkaXN0YW5jZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPj19IG9wdF90bXBQb2ludCBUZW1wb3JhcnkgcG9pbnQgb2JqZWN0LlxuICogQHJldHVybiB7bnVtYmVyfSBNaW5pbXVtIHNxdWFyZWQgZGlzdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ25DbG9zZXN0TXVsdGlBcnJheVBvaW50KGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LFxuICBlbmRzcywgc3RyaWRlLCBtYXhEZWx0YSwgaXNSaW5nLCB4LCB5LCBjbG9zZXN0UG9pbnQsIG1pblNxdWFyZWREaXN0YW5jZSxcbiAgb3B0X3RtcFBvaW50KSB7XG4gIHZhciB0bXBQb2ludCA9IG9wdF90bXBQb2ludCA/IG9wdF90bXBQb2ludCA6IFtOYU4sIE5hTl07XG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IGVuZHNzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICB2YXIgZW5kcyA9IGVuZHNzW2ldO1xuICAgIG1pblNxdWFyZWREaXN0YW5jZSA9IGFzc2lnbkNsb3Nlc3RBcnJheVBvaW50KFxuICAgICAgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHMsIHN0cmlkZSxcbiAgICAgIG1heERlbHRhLCBpc1JpbmcsIHgsIHksIGNsb3Nlc3RQb2ludCwgbWluU3F1YXJlZERpc3RhbmNlLCB0bXBQb2ludCk7XG4gICAgb2Zmc2V0ID0gZW5kc1tlbmRzLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBtaW5TcXVhcmVkRGlzdGFuY2U7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsb3Nlc3QuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9jb250YWluc1xuICovXG5pbXBvcnQge2ZvckVhY2hDb3JuZXJ9IGZyb20gJy4uLy4uL2V4dGVudC5qcyc7XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gQ29udGFpbnMgZXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyUmluZ0NvbnRhaW5zRXh0ZW50KGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgZXh0ZW50KSB7XG4gIHZhciBvdXRzaWRlID0gZm9yRWFjaENvcm5lcihleHRlbnQsXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBDb250YWlucyAoeCwgeSkuXG4gICAgICovXG4gICAgZnVuY3Rpb24oY29vcmRpbmF0ZSkge1xuICAgICAgcmV0dXJuICFsaW5lYXJSaW5nQ29udGFpbnNYWShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIGNvb3JkaW5hdGVbMF0sIGNvb3JkaW5hdGVbMV0pO1xuICAgIH0pO1xuICByZXR1cm4gIW91dHNpZGU7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKiBAcmV0dXJuIHtib29sZWFufSBDb250YWlucyAoeCwgeSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJSaW5nQ29udGFpbnNYWShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIHgsIHkpIHtcbiAgLy8gaHR0cDovL2dlb21hbGdvcml0aG1zLmNvbS9hMDMtX2luY2x1c2lvbi5odG1sXG4gIC8vIENvcHlyaWdodCAyMDAwIHNvZnRTdXJmZXIsIDIwMTIgRGFuIFN1bmRheVxuICAvLyBUaGlzIGNvZGUgbWF5IGJlIGZyZWVseSB1c2VkIGFuZCBtb2RpZmllZCBmb3IgYW55IHB1cnBvc2VcbiAgLy8gcHJvdmlkaW5nIHRoYXQgdGhpcyBjb3B5cmlnaHQgbm90aWNlIGlzIGluY2x1ZGVkIHdpdGggaXQuXG4gIC8vIFNvZnRTdXJmZXIgbWFrZXMgbm8gd2FycmFudHkgZm9yIHRoaXMgY29kZSwgYW5kIGNhbm5vdCBiZSBoZWxkXG4gIC8vIGxpYWJsZSBmb3IgYW55IHJlYWwgb3IgaW1hZ2luZWQgZGFtYWdlIHJlc3VsdGluZyBmcm9tIGl0cyB1c2UuXG4gIC8vIFVzZXJzIG9mIHRoaXMgY29kZSBtdXN0IHZlcmlmeSBjb3JyZWN0bmVzcyBmb3IgdGhlaXIgYXBwbGljYXRpb24uXG4gIHZhciB3biA9IDA7XG4gIHZhciB4MSA9IGZsYXRDb29yZGluYXRlc1tlbmQgLSBzdHJpZGVdO1xuICB2YXIgeTEgPSBmbGF0Q29vcmRpbmF0ZXNbZW5kIC0gc3RyaWRlICsgMV07XG4gIGZvciAoOyBvZmZzZXQgPCBlbmQ7IG9mZnNldCArPSBzdHJpZGUpIHtcbiAgICB2YXIgeDIgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XTtcbiAgICB2YXIgeTIgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gICAgaWYgKHkxIDw9IHkpIHtcbiAgICAgIGlmICh5MiA+IHkgJiYgKCh4MiAtIHgxKSAqICh5IC0geTEpKSAtICgoeCAtIHgxKSAqICh5MiAtIHkxKSkgPiAwKSB7XG4gICAgICAgIHduKys7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh5MiA8PSB5ICYmICgoeDIgLSB4MSkgKiAoeSAtIHkxKSkgLSAoKHggLSB4MSkgKiAoeTIgLSB5MSkpIDwgMCkge1xuICAgICAgd24tLTtcbiAgICB9XG4gICAgeDEgPSB4MjtcbiAgICB5MSA9IHkyO1xuICB9XG4gIHJldHVybiB3biAhPT0gMDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW5kcyBFbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IENvbnRhaW5zICh4LCB5KS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhclJpbmdzQ29udGFpbnNYWShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlLCB4LCB5KSB7XG4gIGlmIChlbmRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIWxpbmVhclJpbmdDb250YWluc1hZKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzWzBdLCBzdHJpZGUsIHgsIHkpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAodmFyIGkgPSAxLCBpaSA9IGVuZHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGlmIChsaW5lYXJSaW5nQ29udGFpbnNYWShmbGF0Q29vcmRpbmF0ZXMsIGVuZHNbaSAtIDFdLCBlbmRzW2ldLCBzdHJpZGUsIHgsIHkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gZW5kc3MgRW5kc3MuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICogQHJldHVybiB7Ym9vbGVhbn0gQ29udGFpbnMgKHgsIHkpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyUmluZ3NzQ29udGFpbnNYWShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kc3MsIHN0cmlkZSwgeCwgeSkge1xuICBpZiAoZW5kc3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IGVuZHNzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICB2YXIgZW5kcyA9IGVuZHNzW2ldO1xuICAgIGlmIChsaW5lYXJSaW5nc0NvbnRhaW5zWFkoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHMsIHN0cmlkZSwgeCwgeSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBvZmZzZXQgPSBlbmRzW2VuZHMubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250YWlucy5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9mbGF0L2RlZmxhdGVcbiAqL1xuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHJldHVybiB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVmbGF0ZUNvb3JkaW5hdGUoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGNvb3JkaW5hdGUsIHN0cmlkZSkge1xuICBmb3IgKHZhciBpID0gMCwgaWkgPSBjb29yZGluYXRlLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0KytdID0gY29vcmRpbmF0ZVtpXTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0O1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHJldHVybiB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVmbGF0ZUNvb3JkaW5hdGVzKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBjb29yZGluYXRlcywgc3RyaWRlKSB7XG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICB2YXIgY29vcmRpbmF0ZSA9IGNvb3JkaW5hdGVzW2ldO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3RyaWRlOyArK2opIHtcbiAgICAgIGZsYXRDb29yZGluYXRlc1tvZmZzZXQrK10gPSBjb29yZGluYXRlW2pdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2Zmc2V0O1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+Pn0gY29vcmRpbmF0ZXNzIENvb3JkaW5hdGVzcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+PX0gb3B0X2VuZHMgRW5kcy5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEVuZHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZsYXRlQ29vcmRpbmF0ZXNBcnJheShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgY29vcmRpbmF0ZXNzLCBzdHJpZGUsIG9wdF9lbmRzKSB7XG4gIHZhciBlbmRzID0gb3B0X2VuZHMgPyBvcHRfZW5kcyA6IFtdO1xuICB2YXIgaSA9IDA7XG4gIGZvciAodmFyIGogPSAwLCBqaiA9IGNvb3JkaW5hdGVzcy5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgdmFyIGVuZCA9IGRlZmxhdGVDb29yZGluYXRlcyhcbiAgICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBjb29yZGluYXRlc3Nbal0sIHN0cmlkZSk7XG4gICAgZW5kc1tpKytdID0gZW5kO1xuICAgIG9mZnNldCA9IGVuZDtcbiAgfVxuICBlbmRzLmxlbmd0aCA9IGk7XG4gIHJldHVybiBlbmRzO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxBcnJheTxpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+Pj59IGNvb3JkaW5hdGVzc3MgQ29vcmRpbmF0ZXNzcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pj19IG9wdF9lbmRzcyBFbmRzcy5cbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PG51bWJlcj4+fSBFbmRzcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmxhdGVNdWx0aUNvb3JkaW5hdGVzQXJyYXkoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGNvb3JkaW5hdGVzc3MsIHN0cmlkZSwgb3B0X2VuZHNzKSB7XG4gIHZhciBlbmRzcyA9IG9wdF9lbmRzcyA/IG9wdF9lbmRzcyA6IFtdO1xuICB2YXIgaSA9IDA7XG4gIGZvciAodmFyIGogPSAwLCBqaiA9IGNvb3JkaW5hdGVzc3MubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgIHZhciBlbmRzID0gZGVmbGF0ZUNvb3JkaW5hdGVzQXJyYXkoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgY29vcmRpbmF0ZXNzc1tqXSwgc3RyaWRlLCBlbmRzc1tpXSk7XG4gICAgZW5kc3NbaSsrXSA9IGVuZHM7XG4gICAgb2Zmc2V0ID0gZW5kc1tlbmRzLmxlbmd0aCAtIDFdO1xuICB9XG4gIGVuZHNzLmxlbmd0aCA9IGk7XG4gIHJldHVybiBlbmRzcztcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmbGF0ZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9mbGF0L2luZmxhdGVcbiAqL1xuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj19IG9wdF9jb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAqIEByZXR1cm4ge0FycmF5PGltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59IENvb3JkaW5hdGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5mbGF0ZUNvb3JkaW5hdGVzKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgb3B0X2Nvb3JkaW5hdGVzKSB7XG4gIHZhciBjb29yZGluYXRlcyA9IG9wdF9jb29yZGluYXRlcyAhPT0gdW5kZWZpbmVkID8gb3B0X2Nvb3JkaW5hdGVzIDogW107XG4gIHZhciBpID0gMDtcbiAgZm9yICh2YXIgaiA9IG9mZnNldDsgaiA8IGVuZDsgaiArPSBzdHJpZGUpIHtcbiAgICBjb29yZGluYXRlc1tpKytdID0gZmxhdENvb3JkaW5hdGVzLnNsaWNlKGosIGogKyBzdHJpZGUpO1xuICB9XG4gIGNvb3JkaW5hdGVzLmxlbmd0aCA9IGk7XG4gIHJldHVybiBjb29yZGluYXRlcztcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW5kcyBFbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PGltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+PX0gb3B0X2Nvb3JkaW5hdGVzcyBDb29yZGluYXRlc3MuXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTxpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+Pn0gQ29vcmRpbmF0ZXNzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5mbGF0ZUNvb3JkaW5hdGVzQXJyYXkoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHMsIHN0cmlkZSwgb3B0X2Nvb3JkaW5hdGVzcykge1xuICB2YXIgY29vcmRpbmF0ZXNzID0gb3B0X2Nvb3JkaW5hdGVzcyAhPT0gdW5kZWZpbmVkID8gb3B0X2Nvb3JkaW5hdGVzcyA6IFtdO1xuICB2YXIgaSA9IDA7XG4gIGZvciAodmFyIGogPSAwLCBqaiA9IGVuZHMubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgIHZhciBlbmQgPSBlbmRzW2pdO1xuICAgIGNvb3JkaW5hdGVzc1tpKytdID0gaW5mbGF0ZUNvb3JkaW5hdGVzKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCBjb29yZGluYXRlc3NbaV0pO1xuICAgIG9mZnNldCA9IGVuZDtcbiAgfVxuICBjb29yZGluYXRlc3MubGVuZ3RoID0gaTtcbiAgcmV0dXJuIGNvb3JkaW5hdGVzcztcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGVuZHNzIEVuZHNzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PEFycmF5PGltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+Pj19IG9wdF9jb29yZGluYXRlc3NzXG4gKiAgICAgQ29vcmRpbmF0ZXNzcy5cbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PEFycmF5PGltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+Pn0gQ29vcmRpbmF0ZXNzcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluZmxhdGVNdWx0aUNvb3JkaW5hdGVzQXJyYXkoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHNzLCBzdHJpZGUsIG9wdF9jb29yZGluYXRlc3NzKSB7XG4gIHZhciBjb29yZGluYXRlc3NzID0gb3B0X2Nvb3JkaW5hdGVzc3MgIT09IHVuZGVmaW5lZCA/IG9wdF9jb29yZGluYXRlc3NzIDogW107XG4gIHZhciBpID0gMDtcbiAgZm9yICh2YXIgaiA9IDAsIGpqID0gZW5kc3MubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgIHZhciBlbmRzID0gZW5kc3Nbal07XG4gICAgY29vcmRpbmF0ZXNzc1tpKytdID0gaW5mbGF0ZUNvb3JkaW5hdGVzQXJyYXkoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlLCBjb29yZGluYXRlc3NzW2ldKTtcbiAgICBvZmZzZXQgPSBlbmRzW2VuZHMubGVuZ3RoIC0gMV07XG4gIH1cbiAgY29vcmRpbmF0ZXNzcy5sZW5ndGggPSBpO1xuICByZXR1cm4gY29vcmRpbmF0ZXNzcztcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5mbGF0ZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9mbGF0L2ludGVyaW9ycG9pbnRcbiAqL1xuaW1wb3J0IHtudW1iZXJTYWZlQ29tcGFyZUZ1bmN0aW9ufSBmcm9tICcuLi8uLi9hcnJheS5qcyc7XG5pbXBvcnQge2xpbmVhclJpbmdzQ29udGFpbnNYWX0gZnJvbSAnLi9jb250YWlucy5qcyc7XG5cblxuLyoqXG4gKiBDYWxjdWxhdGVzIGEgcG9pbnQgdGhhdCBpcyBsaWtlbHkgdG8gbGllIGluIHRoZSBpbnRlcmlvciBvZiB0aGUgbGluZWFyIHJpbmdzLlxuICogSW5zcGlyZWQgYnkgSlRTJ3MgY29tLnZpdmlkc29sdXRpb25zLmp0cy5nZW9tLkdlb21ldHJ5I2dldEludGVyaW9yUG9pbnQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGVuZHMgRW5kcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q2VudGVycyBGbGF0IGNlbnRlcnMuXG4gKiBAcGFyYW0ge251bWJlcn0gZmxhdENlbnRlcnNPZmZzZXQgRmxhdCBjZW50ZXIgb2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+PX0gb3B0X2Rlc3QgRGVzdGluYXRpb24uXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBEZXN0aW5hdGlvbiBwb2ludCBhcyBYWU0gY29vcmRpbmF0ZSwgd2hlcmUgTSBpcyB0aGVcbiAqIGxlbmd0aCBvZiB0aGUgaG9yaXpvbnRhbCBpbnRlcnNlY3Rpb24gdGhhdCB0aGUgcG9pbnQgYmVsb25ncyB0by5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEludGVyaW9yUG9pbnRPZkFycmF5KGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LFxuICBlbmRzLCBzdHJpZGUsIGZsYXRDZW50ZXJzLCBmbGF0Q2VudGVyc09mZnNldCwgb3B0X2Rlc3QpIHtcbiAgdmFyIGksIGlpLCB4LCB4MSwgeDIsIHkxLCB5MjtcbiAgdmFyIHkgPSBmbGF0Q2VudGVyc1tmbGF0Q2VudGVyc09mZnNldCArIDFdO1xuICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovXG4gIHZhciBpbnRlcnNlY3Rpb25zID0gW107XG4gIC8vIENhbGN1bGF0ZSBpbnRlcnNlY3Rpb25zIHdpdGggdGhlIGhvcml6b250YWwgbGluZVxuICBmb3IgKHZhciByID0gMCwgcnIgPSBlbmRzLmxlbmd0aDsgciA8IHJyOyArK3IpIHtcbiAgICB2YXIgZW5kID0gZW5kc1tyXTtcbiAgICB4MSA9IGZsYXRDb29yZGluYXRlc1tlbmQgLSBzdHJpZGVdO1xuICAgIHkxID0gZmxhdENvb3JkaW5hdGVzW2VuZCAtIHN0cmlkZSArIDFdO1xuICAgIGZvciAoaSA9IG9mZnNldDsgaSA8IGVuZDsgaSArPSBzdHJpZGUpIHtcbiAgICAgIHgyID0gZmxhdENvb3JkaW5hdGVzW2ldO1xuICAgICAgeTIgPSBmbGF0Q29vcmRpbmF0ZXNbaSArIDFdO1xuICAgICAgaWYgKCh5IDw9IHkxICYmIHkyIDw9IHkpIHx8ICh5MSA8PSB5ICYmIHkgPD0geTIpKSB7XG4gICAgICAgIHggPSAoeSAtIHkxKSAvICh5MiAtIHkxKSAqICh4MiAtIHgxKSArIHgxO1xuICAgICAgICBpbnRlcnNlY3Rpb25zLnB1c2goeCk7XG4gICAgICB9XG4gICAgICB4MSA9IHgyO1xuICAgICAgeTEgPSB5MjtcbiAgICB9XG4gIH1cbiAgLy8gRmluZCB0aGUgbG9uZ2VzdCBzZWdtZW50IG9mIHRoZSBob3Jpem9udGFsIGxpbmUgdGhhdCBoYXMgaXRzIGNlbnRlciBwb2ludFxuICAvLyBpbnNpZGUgdGhlIGxpbmVhciByaW5nLlxuICB2YXIgcG9pbnRYID0gTmFOO1xuICB2YXIgbWF4U2VnbWVudExlbmd0aCA9IC1JbmZpbml0eTtcbiAgaW50ZXJzZWN0aW9ucy5zb3J0KG51bWJlclNhZmVDb21wYXJlRnVuY3Rpb24pO1xuICB4MSA9IGludGVyc2VjdGlvbnNbMF07XG4gIGZvciAoaSA9IDEsIGlpID0gaW50ZXJzZWN0aW9ucy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgeDIgPSBpbnRlcnNlY3Rpb25zW2ldO1xuICAgIHZhciBzZWdtZW50TGVuZ3RoID0gTWF0aC5hYnMoeDIgLSB4MSk7XG4gICAgaWYgKHNlZ21lbnRMZW5ndGggPiBtYXhTZWdtZW50TGVuZ3RoKSB7XG4gICAgICB4ID0gKHgxICsgeDIpIC8gMjtcbiAgICAgIGlmIChsaW5lYXJSaW5nc0NvbnRhaW5zWFkoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHMsIHN0cmlkZSwgeCwgeSkpIHtcbiAgICAgICAgcG9pbnRYID0geDtcbiAgICAgICAgbWF4U2VnbWVudExlbmd0aCA9IHNlZ21lbnRMZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIHgxID0geDI7XG4gIH1cbiAgaWYgKGlzTmFOKHBvaW50WCkpIHtcbiAgICAvLyBUaGVyZSBpcyBubyBob3Jpem9udGFsIGxpbmUgdGhhdCBoYXMgaXRzIGNlbnRlciBwb2ludCBpbnNpZGUgdGhlIGxpbmVhclxuICAgIC8vIHJpbmcuICBVc2UgdGhlIGNlbnRlciBvZiB0aGUgdGhlIGxpbmVhciByaW5nJ3MgZXh0ZW50LlxuICAgIHBvaW50WCA9IGZsYXRDZW50ZXJzW2ZsYXRDZW50ZXJzT2Zmc2V0XTtcbiAgfVxuICBpZiAob3B0X2Rlc3QpIHtcbiAgICBvcHRfZGVzdC5wdXNoKHBvaW50WCwgeSwgbWF4U2VnbWVudExlbmd0aCk7XG4gICAgcmV0dXJuIG9wdF9kZXN0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbcG9pbnRYLCB5LCBtYXhTZWdtZW50TGVuZ3RoXTtcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gZW5kc3MgRW5kc3MuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENlbnRlcnMgRmxhdCBjZW50ZXJzLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gSW50ZXJpb3IgcG9pbnRzIGFzIFhZTSBjb29yZGluYXRlcywgd2hlcmUgTSBpcyB0aGVcbiAqIGxlbmd0aCBvZiB0aGUgaG9yaXpvbnRhbCBpbnRlcnNlY3Rpb24gdGhhdCB0aGUgcG9pbnQgYmVsb25ncyB0by5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEludGVyaW9yUG9pbnRzT2ZNdWx0aUFycmF5KGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzcywgc3RyaWRlLCBmbGF0Q2VudGVycykge1xuICB2YXIgaW50ZXJpb3JQb2ludHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gZW5kc3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIHZhciBlbmRzID0gZW5kc3NbaV07XG4gICAgaW50ZXJpb3JQb2ludHMgPSBnZXRJbnRlcmlvclBvaW50T2ZBcnJheShmbGF0Q29vcmRpbmF0ZXMsXG4gICAgICBvZmZzZXQsIGVuZHMsIHN0cmlkZSwgZmxhdENlbnRlcnMsIDIgKiBpLCBpbnRlcmlvclBvaW50cyk7XG4gICAgb2Zmc2V0ID0gZW5kc1tlbmRzLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBpbnRlcmlvclBvaW50cztcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJpb3Jwb2ludC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9mbGF0L2ludGVycG9sYXRlXG4gKi9cbmltcG9ydCB7YmluYXJ5U2VhcmNofSBmcm9tICcuLi8uLi9hcnJheS5qcyc7XG5pbXBvcnQge2xlcnB9IGZyb20gJy4uLy4uL21hdGguanMnO1xuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcmFjdGlvbiBGcmFjdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPj19IG9wdF9kZXN0IERlc3RpbmF0aW9uLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gRGVzdGluYXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnBvbGF0ZVBvaW50KGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgZnJhY3Rpb24sIG9wdF9kZXN0KSB7XG4gIHZhciBwb2ludFggPSBOYU47XG4gIHZhciBwb2ludFkgPSBOYU47XG4gIHZhciBuID0gKGVuZCAtIG9mZnNldCkgLyBzdHJpZGU7XG4gIGlmIChuID09PSAxKSB7XG4gICAgcG9pbnRYID0gZmxhdENvb3JkaW5hdGVzW29mZnNldF07XG4gICAgcG9pbnRZID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdO1xuICB9IGVsc2UgaWYgKG4gPT0gMikge1xuICAgIHBvaW50WCA9ICgxIC0gZnJhY3Rpb24pICogZmxhdENvb3JkaW5hdGVzW29mZnNldF0gK1xuICAgICAgICBmcmFjdGlvbiAqIGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyBzdHJpZGVdO1xuICAgIHBvaW50WSA9ICgxIC0gZnJhY3Rpb24pICogZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdICtcbiAgICAgICAgZnJhY3Rpb24gKiBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgc3RyaWRlICsgMV07XG4gIH0gZWxzZSBpZiAobiAhPT0gMCkge1xuICAgIHZhciB4MSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXRdO1xuICAgIHZhciB5MSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXTtcbiAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICB2YXIgY3VtdWxhdGl2ZUxlbmd0aHMgPSBbMF07XG4gICAgZm9yICh2YXIgaSA9IG9mZnNldCArIHN0cmlkZTsgaSA8IGVuZDsgaSArPSBzdHJpZGUpIHtcbiAgICAgIHZhciB4MiA9IGZsYXRDb29yZGluYXRlc1tpXTtcbiAgICAgIHZhciB5MiA9IGZsYXRDb29yZGluYXRlc1tpICsgMV07XG4gICAgICBsZW5ndGggKz0gTWF0aC5zcXJ0KCh4MiAtIHgxKSAqICh4MiAtIHgxKSArICh5MiAtIHkxKSAqICh5MiAtIHkxKSk7XG4gICAgICBjdW11bGF0aXZlTGVuZ3Rocy5wdXNoKGxlbmd0aCk7XG4gICAgICB4MSA9IHgyO1xuICAgICAgeTEgPSB5MjtcbiAgICB9XG4gICAgdmFyIHRhcmdldCA9IGZyYWN0aW9uICogbGVuZ3RoO1xuICAgIHZhciBpbmRleCA9IGJpbmFyeVNlYXJjaChjdW11bGF0aXZlTGVuZ3RocywgdGFyZ2V0KTtcbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICB2YXIgdCA9ICh0YXJnZXQgLSBjdW11bGF0aXZlTGVuZ3Roc1staW5kZXggLSAyXSkgL1xuICAgICAgICAgIChjdW11bGF0aXZlTGVuZ3Roc1staW5kZXggLSAxXSAtIGN1bXVsYXRpdmVMZW5ndGhzWy1pbmRleCAtIDJdKTtcbiAgICAgIHZhciBvID0gb2Zmc2V0ICsgKC1pbmRleCAtIDIpICogc3RyaWRlO1xuICAgICAgcG9pbnRYID0gbGVycChcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzW29dLCBmbGF0Q29vcmRpbmF0ZXNbbyArIHN0cmlkZV0sIHQpO1xuICAgICAgcG9pbnRZID0gbGVycChcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzW28gKyAxXSwgZmxhdENvb3JkaW5hdGVzW28gKyBzdHJpZGUgKyAxXSwgdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50WCA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyBpbmRleCAqIHN0cmlkZV07XG4gICAgICBwb2ludFkgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgaW5kZXggKiBzdHJpZGUgKyAxXTtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdF9kZXN0KSB7XG4gICAgb3B0X2Rlc3RbMF0gPSBwb2ludFg7XG4gICAgb3B0X2Rlc3RbMV0gPSBwb2ludFk7XG4gICAgcmV0dXJuIG9wdF9kZXN0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbcG9pbnRYLCBwb2ludFldO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IG0gTS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZXh0cmFwb2xhdGUgRXh0cmFwb2xhdGUuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IENvb3JkaW5hdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lU3RyaW5nQ29vcmRpbmF0ZUF0TShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIG0sIGV4dHJhcG9sYXRlKSB7XG4gIGlmIChlbmQgPT0gb2Zmc2V0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGNvb3JkaW5hdGU7XG4gIGlmIChtIDwgZmxhdENvb3JkaW5hdGVzW29mZnNldCArIHN0cmlkZSAtIDFdKSB7XG4gICAgaWYgKGV4dHJhcG9sYXRlKSB7XG4gICAgICBjb29yZGluYXRlID0gZmxhdENvb3JkaW5hdGVzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgc3RyaWRlKTtcbiAgICAgIGNvb3JkaW5hdGVbc3RyaWRlIC0gMV0gPSBtO1xuICAgICAgcmV0dXJuIGNvb3JkaW5hdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSBlbHNlIGlmIChmbGF0Q29vcmRpbmF0ZXNbZW5kIC0gMV0gPCBtKSB7XG4gICAgaWYgKGV4dHJhcG9sYXRlKSB7XG4gICAgICBjb29yZGluYXRlID0gZmxhdENvb3JkaW5hdGVzLnNsaWNlKGVuZCAtIHN0cmlkZSwgZW5kKTtcbiAgICAgIGNvb3JkaW5hdGVbc3RyaWRlIC0gMV0gPSBtO1xuICAgICAgcmV0dXJuIGNvb3JkaW5hdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICAvLyBGSVhNRSB1c2UgTygxKSBzZWFyY2hcbiAgaWYgKG0gPT0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIHN0cmlkZSAtIDFdKSB7XG4gICAgcmV0dXJuIGZsYXRDb29yZGluYXRlcy5zbGljZShvZmZzZXQsIG9mZnNldCArIHN0cmlkZSk7XG4gIH1cbiAgdmFyIGxvID0gb2Zmc2V0IC8gc3RyaWRlO1xuICB2YXIgaGkgPSBlbmQgLyBzdHJpZGU7XG4gIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgdmFyIG1pZCA9IChsbyArIGhpKSA+PiAxO1xuICAgIGlmIChtIDwgZmxhdENvb3JkaW5hdGVzWyhtaWQgKyAxKSAqIHN0cmlkZSAtIDFdKSB7XG4gICAgICBoaSA9IG1pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgbG8gPSBtaWQgKyAxO1xuICAgIH1cbiAgfVxuICB2YXIgbTAgPSBmbGF0Q29vcmRpbmF0ZXNbbG8gKiBzdHJpZGUgLSAxXTtcbiAgaWYgKG0gPT0gbTApIHtcbiAgICByZXR1cm4gZmxhdENvb3JkaW5hdGVzLnNsaWNlKChsbyAtIDEpICogc3RyaWRlLCAobG8gLSAxKSAqIHN0cmlkZSArIHN0cmlkZSk7XG4gIH1cbiAgdmFyIG0xID0gZmxhdENvb3JkaW5hdGVzWyhsbyArIDEpICogc3RyaWRlIC0gMV07XG4gIHZhciB0ID0gKG0gLSBtMCkgLyAobTEgLSBtMCk7XG4gIGNvb3JkaW5hdGUgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpZGUgLSAxOyArK2kpIHtcbiAgICBjb29yZGluYXRlLnB1c2gobGVycChmbGF0Q29vcmRpbmF0ZXNbKGxvIC0gMSkgKiBzdHJpZGUgKyBpXSxcbiAgICAgIGZsYXRDb29yZGluYXRlc1tsbyAqIHN0cmlkZSArIGldLCB0KSk7XG4gIH1cbiAgY29vcmRpbmF0ZS5wdXNoKG0pO1xuICByZXR1cm4gY29vcmRpbmF0ZTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW5kcyBFbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gbSBNLlxuICogQHBhcmFtIHtib29sZWFufSBleHRyYXBvbGF0ZSBFeHRyYXBvbGF0ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW50ZXJwb2xhdGUgSW50ZXJwb2xhdGUuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IENvb3JkaW5hdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lU3RyaW5nc0Nvb3JkaW5hdGVBdE0oXG4gIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLCBzdHJpZGUsIG0sIGV4dHJhcG9sYXRlLCBpbnRlcnBvbGF0ZSkge1xuICBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICByZXR1cm4gbGluZVN0cmluZ0Nvb3JkaW5hdGVBdE0oXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kc1tlbmRzLmxlbmd0aCAtIDFdLCBzdHJpZGUsIG0sIGV4dHJhcG9sYXRlKTtcbiAgfVxuICB2YXIgY29vcmRpbmF0ZTtcbiAgaWYgKG0gPCBmbGF0Q29vcmRpbmF0ZXNbc3RyaWRlIC0gMV0pIHtcbiAgICBpZiAoZXh0cmFwb2xhdGUpIHtcbiAgICAgIGNvb3JkaW5hdGUgPSBmbGF0Q29vcmRpbmF0ZXMuc2xpY2UoMCwgc3RyaWRlKTtcbiAgICAgIGNvb3JkaW5hdGVbc3RyaWRlIC0gMV0gPSBtO1xuICAgICAgcmV0dXJuIGNvb3JkaW5hdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBpZiAoZmxhdENvb3JkaW5hdGVzW2ZsYXRDb29yZGluYXRlcy5sZW5ndGggLSAxXSA8IG0pIHtcbiAgICBpZiAoZXh0cmFwb2xhdGUpIHtcbiAgICAgIGNvb3JkaW5hdGUgPSBmbGF0Q29vcmRpbmF0ZXMuc2xpY2UoZmxhdENvb3JkaW5hdGVzLmxlbmd0aCAtIHN0cmlkZSk7XG4gICAgICBjb29yZGluYXRlW3N0cmlkZSAtIDFdID0gbTtcbiAgICAgIHJldHVybiBjb29yZGluYXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgdmFyIGVuZCA9IGVuZHNbaV07XG4gICAgaWYgKG9mZnNldCA9PSBlbmQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobSA8IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyBzdHJpZGUgLSAxXSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIGlmIChtIDw9IGZsYXRDb29yZGluYXRlc1tlbmQgLSAxXSkge1xuICAgICAgcmV0dXJuIGxpbmVTdHJpbmdDb29yZGluYXRlQXRNKFxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIG0sIGZhbHNlKTtcbiAgICB9XG4gICAgb2Zmc2V0ID0gZW5kO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcnBvbGF0ZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9mbGF0L2ludGVyc2VjdHNleHRlbnRcbiAqL1xuaW1wb3J0IHtjb250YWluc0V4dGVudCwgY3JlYXRlRW1wdHksIGV4dGVuZEZsYXRDb29yZGluYXRlcywgaW50ZXJzZWN0cywgaW50ZXJzZWN0c1NlZ21lbnR9IGZyb20gJy4uLy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge2xpbmVhclJpbmdDb250YWluc1hZLCBsaW5lYXJSaW5nQ29udGFpbnNFeHRlbnR9IGZyb20gJy4vY29udGFpbnMuanMnO1xuaW1wb3J0IHtmb3JFYWNoIGFzIGZvckVhY2hTZWdtZW50fSBmcm9tICcuL3NlZ21lbnRzLmpzJztcblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBnZW9tZXRyeSBhbmQgdGhlIGV4dGVudCBpbnRlcnNlY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnNlY3RzTGluZVN0cmluZyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIGV4dGVudCkge1xuICB2YXIgY29vcmRpbmF0ZXNFeHRlbnQgPSBleHRlbmRGbGF0Q29vcmRpbmF0ZXMoXG4gICAgY3JlYXRlRW1wdHkoKSwgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKTtcbiAgaWYgKCFpbnRlcnNlY3RzKGV4dGVudCwgY29vcmRpbmF0ZXNFeHRlbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChjb250YWluc0V4dGVudChleHRlbnQsIGNvb3JkaW5hdGVzRXh0ZW50KSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChjb29yZGluYXRlc0V4dGVudFswXSA+PSBleHRlbnRbMF0gJiZcbiAgICAgIGNvb3JkaW5hdGVzRXh0ZW50WzJdIDw9IGV4dGVudFsyXSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChjb29yZGluYXRlc0V4dGVudFsxXSA+PSBleHRlbnRbMV0gJiZcbiAgICAgIGNvb3JkaW5hdGVzRXh0ZW50WzNdIDw9IGV4dGVudFszXSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmb3JFYWNoU2VnbWVudChmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IHBvaW50MSBTdGFydCBwb2ludC5cbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gcG9pbnQyIEVuZCBwb2ludC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHNlZ21lbnQgYW5kIHRoZSBleHRlbnQgaW50ZXJzZWN0LFxuICAgICAqICAgICBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbihwb2ludDEsIHBvaW50Mikge1xuICAgICAgcmV0dXJuIGludGVyc2VjdHNTZWdtZW50KGV4dGVudCwgcG9pbnQxLCBwb2ludDIpO1xuICAgIH0pO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbmRzIEVuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGdlb21ldHJ5IGFuZCB0aGUgZXh0ZW50IGludGVyc2VjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdHNMaW5lU3RyaW5nQXJyYXkoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHMsIHN0cmlkZSwgZXh0ZW50KSB7XG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IGVuZHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGlmIChpbnRlcnNlY3RzTGluZVN0cmluZyhcbiAgICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzW2ldLCBzdHJpZGUsIGV4dGVudCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBvZmZzZXQgPSBlbmRzW2ldO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBnZW9tZXRyeSBhbmQgdGhlIGV4dGVudCBpbnRlcnNlY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnNlY3RzTGluZWFyUmluZyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIGV4dGVudCkge1xuICBpZiAoaW50ZXJzZWN0c0xpbmVTdHJpbmcoXG4gICAgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCBleHRlbnQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGxpbmVhclJpbmdDb250YWluc1hZKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgZXh0ZW50WzBdLCBleHRlbnRbMV0pKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGxpbmVhclJpbmdDb250YWluc1hZKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgZXh0ZW50WzBdLCBleHRlbnRbM10pKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGxpbmVhclJpbmdDb250YWluc1hZKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgZXh0ZW50WzJdLCBleHRlbnRbMV0pKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGxpbmVhclJpbmdDb250YWluc1hZKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgZXh0ZW50WzJdLCBleHRlbnRbM10pKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbmRzIEVuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGdlb21ldHJ5IGFuZCB0aGUgZXh0ZW50IGludGVyc2VjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdHNMaW5lYXJSaW5nQXJyYXkoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHMsIHN0cmlkZSwgZXh0ZW50KSB7XG4gIGlmICghaW50ZXJzZWN0c0xpbmVhclJpbmcoXG4gICAgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHNbMF0sIHN0cmlkZSwgZXh0ZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZW5kcy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmb3IgKHZhciBpID0gMSwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBpZiAobGluZWFyUmluZ0NvbnRhaW5zRXh0ZW50KGZsYXRDb29yZGluYXRlcywgZW5kc1tpIC0gMV0sIGVuZHNbaV0sIHN0cmlkZSwgZXh0ZW50KSkge1xuICAgICAgaWYgKCFpbnRlcnNlY3RzTGluZVN0cmluZyhmbGF0Q29vcmRpbmF0ZXMsIGVuZHNbaSAtIDFdLCBlbmRzW2ldLCBzdHJpZGUsIGV4dGVudCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGVuZHNzIEVuZHNzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBnZW9tZXRyeSBhbmQgdGhlIGV4dGVudCBpbnRlcnNlY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnNlY3RzTGluZWFyUmluZ011bHRpQXJyYXkoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHNzLCBzdHJpZGUsIGV4dGVudCkge1xuICBmb3IgKHZhciBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgdmFyIGVuZHMgPSBlbmRzc1tpXTtcbiAgICBpZiAoaW50ZXJzZWN0c0xpbmVhclJpbmdBcnJheShcbiAgICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLCBzdHJpZGUsIGV4dGVudCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBvZmZzZXQgPSBlbmRzW2VuZHMubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcnNlY3RzZXh0ZW50LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL2ZsYXQvbGVuZ3RoXG4gKi9cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IExlbmd0aC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVTdHJpbmdMZW5ndGgoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKSB7XG4gIHZhciB4MSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXRdO1xuICB2YXIgeTEgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gIHZhciBsZW5ndGggPSAwO1xuICBmb3IgKHZhciBpID0gb2Zmc2V0ICsgc3RyaWRlOyBpIDwgZW5kOyBpICs9IHN0cmlkZSkge1xuICAgIHZhciB4MiA9IGZsYXRDb29yZGluYXRlc1tpXTtcbiAgICB2YXIgeTIgPSBmbGF0Q29vcmRpbmF0ZXNbaSArIDFdO1xuICAgIGxlbmd0aCArPSBNYXRoLnNxcnQoKHgyIC0geDEpICogKHgyIC0geDEpICsgKHkyIC0geTEpICogKHkyIC0geTEpKTtcbiAgICB4MSA9IHgyO1xuICAgIHkxID0geTI7XG4gIH1cbiAgcmV0dXJuIGxlbmd0aDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFBlcmltZXRlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhclJpbmdMZW5ndGgoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKSB7XG4gIHZhciBwZXJpbWV0ZXIgPSBsaW5lU3RyaW5nTGVuZ3RoKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSk7XG4gIHZhciBkeCA9IGZsYXRDb29yZGluYXRlc1tlbmQgLSBzdHJpZGVdIC0gZmxhdENvb3JkaW5hdGVzW29mZnNldF07XG4gIHZhciBkeSA9IGZsYXRDb29yZGluYXRlc1tlbmQgLSBzdHJpZGUgKyAxXSAtIGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXTtcbiAgcGVyaW1ldGVyICs9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gIHJldHVybiBwZXJpbWV0ZXI7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxlbmd0aC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9mbGF0L29yaWVudFxuICovXG5pbXBvcnQge2Nvb3JkaW5hdGVzIGFzIHJldmVyc2VDb29yZGluYXRlc30gZnJvbSAnLi9yZXZlcnNlLmpzJztcblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBJcyBjbG9ja3dpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJSaW5nSXNDbG9ja3dpc2UoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKSB7XG4gIC8vIGh0dHA6Ly90aW55dXJsLmNvbS9jbG9ja3dpc2UtbWV0aG9kXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9PU0dlby9nZGFsL2Jsb2IvdHJ1bmsvZ2RhbC9vZ3Ivb2dybGluZWFycmluZy5jcHBcbiAgdmFyIGVkZ2UgPSAwO1xuICB2YXIgeDEgPSBmbGF0Q29vcmRpbmF0ZXNbZW5kIC0gc3RyaWRlXTtcbiAgdmFyIHkxID0gZmxhdENvb3JkaW5hdGVzW2VuZCAtIHN0cmlkZSArIDFdO1xuICBmb3IgKDsgb2Zmc2V0IDwgZW5kOyBvZmZzZXQgKz0gc3RyaWRlKSB7XG4gICAgdmFyIHgyID0gZmxhdENvb3JkaW5hdGVzW29mZnNldF07XG4gICAgdmFyIHkyID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdO1xuICAgIGVkZ2UgKz0gKHgyIC0geDEpICogKHkyICsgeTEpO1xuICAgIHgxID0geDI7XG4gICAgeTEgPSB5MjtcbiAgfVxuICByZXR1cm4gZWRnZSA+IDA7XG59XG5cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGxpbmVhciByaW5ncyBhcmUgb3JpZW50ZWQuICBCeSBkZWZhdWx0LCBsZWZ0LWhhbmQgb3JpZW50YXRpb25cbiAqIGlzIHRlc3RlZCAoZmlyc3QgcmluZyBtdXN0IGJlIGNsb2Nrd2lzZSwgcmVtYWluaW5nIHJpbmdzIGNvdW50ZXItY2xvY2t3aXNlKS5cbiAqIFRvIHRlc3QgZm9yIHJpZ2h0LWhhbmQgb3JpZW50YXRpb24sIHVzZSB0aGUgYG9wdF9yaWdodGAgYXJndW1lbnQuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbmRzIEFycmF5IG9mIGVuZCBpbmRleGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfcmlnaHQgVGVzdCBmb3IgcmlnaHQtaGFuZCBvcmllbnRhdGlvblxuICogICAgIChjb3VudGVyLWNsb2Nrd2lzZSBleHRlcmlvciByaW5nIGFuZCBjbG9ja3dpc2UgaW50ZXJpb3IgcmluZ3MpLlxuICogQHJldHVybiB7Ym9vbGVhbn0gUmluZ3MgYXJlIGNvcnJlY3RseSBvcmllbnRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhclJpbmdJc09yaWVudGVkKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLCBzdHJpZGUsIG9wdF9yaWdodCkge1xuICB2YXIgcmlnaHQgPSBvcHRfcmlnaHQgIT09IHVuZGVmaW5lZCA/IG9wdF9yaWdodCA6IGZhbHNlO1xuICBmb3IgKHZhciBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICB2YXIgZW5kID0gZW5kc1tpXTtcbiAgICB2YXIgaXNDbG9ja3dpc2UgPSBsaW5lYXJSaW5nSXNDbG9ja3dpc2UoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUpO1xuICAgIGlmIChpID09PSAwKSB7XG4gICAgICBpZiAoKHJpZ2h0ICYmIGlzQ2xvY2t3aXNlKSB8fCAoIXJpZ2h0ICYmICFpc0Nsb2Nrd2lzZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoKHJpZ2h0ICYmICFpc0Nsb2Nrd2lzZSkgfHwgKCFyaWdodCAmJiBpc0Nsb2Nrd2lzZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBvZmZzZXQgPSBlbmQ7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGxpbmVhciByaW5ncyBhcmUgb3JpZW50ZWQuICBCeSBkZWZhdWx0LCBsZWZ0LWhhbmQgb3JpZW50YXRpb25cbiAqIGlzIHRlc3RlZCAoZmlyc3QgcmluZyBtdXN0IGJlIGNsb2Nrd2lzZSwgcmVtYWluaW5nIHJpbmdzIGNvdW50ZXItY2xvY2t3aXNlKS5cbiAqIFRvIHRlc3QgZm9yIHJpZ2h0LWhhbmQgb3JpZW50YXRpb24sIHVzZSB0aGUgYG9wdF9yaWdodGAgYXJndW1lbnQuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gZW5kc3MgQXJyYXkgb2YgYXJyYXkgb2YgZW5kIGluZGV4ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9yaWdodCBUZXN0IGZvciByaWdodC1oYW5kIG9yaWVudGF0aW9uXG4gKiAgICAgKGNvdW50ZXItY2xvY2t3aXNlIGV4dGVyaW9yIHJpbmcgYW5kIGNsb2Nrd2lzZSBpbnRlcmlvciByaW5ncykuXG4gKiBAcmV0dXJuIHtib29sZWFufSBSaW5ncyBhcmUgY29ycmVjdGx5IG9yaWVudGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyUmluZ3NBcmVPcmllbnRlZChmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kc3MsIHN0cmlkZSwgb3B0X3JpZ2h0KSB7XG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IGVuZHNzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBpZiAoIWxpbmVhclJpbmdJc09yaWVudGVkKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHNzW2ldLCBzdHJpZGUsIG9wdF9yaWdodCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cblxuLyoqXG4gKiBPcmllbnQgY29vcmRpbmF0ZXMgaW4gYSBmbGF0IGFycmF5IG9mIGxpbmVhciByaW5ncy4gIEJ5IGRlZmF1bHQsIHJpbmdzXG4gKiBhcmUgb3JpZW50ZWQgZm9sbG93aW5nIHRoZSBsZWZ0LWhhbmQgcnVsZSAoY2xvY2t3aXNlIGZvciBleHRlcmlvciBhbmRcbiAqIGNvdW50ZXItY2xvY2t3aXNlIGZvciBpbnRlcmlvciByaW5ncykuICBUbyBvcmllbnQgYWNjb3JkaW5nIHRvIHRoZVxuICogcmlnaHQtaGFuZCBydWxlLCB1c2UgdGhlIGBvcHRfcmlnaHRgIGFyZ3VtZW50LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW5kcyBFbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfcmlnaHQgRm9sbG93IHRoZSByaWdodC1oYW5kIHJ1bGUgZm9yIG9yaWVudGF0aW9uLlxuICogQHJldHVybiB7bnVtYmVyfSBFbmQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvcmllbnRMaW5lYXJSaW5ncyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlLCBvcHRfcmlnaHQpIHtcbiAgdmFyIHJpZ2h0ID0gb3B0X3JpZ2h0ICE9PSB1bmRlZmluZWQgPyBvcHRfcmlnaHQgOiBmYWxzZTtcbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgdmFyIGVuZCA9IGVuZHNbaV07XG4gICAgdmFyIGlzQ2xvY2t3aXNlID0gbGluZWFyUmluZ0lzQ2xvY2t3aXNlKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKTtcbiAgICB2YXIgcmV2ZXJzZSA9IGkgPT09IDAgP1xuICAgICAgKHJpZ2h0ICYmIGlzQ2xvY2t3aXNlKSB8fCAoIXJpZ2h0ICYmICFpc0Nsb2Nrd2lzZSkgOlxuICAgICAgKHJpZ2h0ICYmICFpc0Nsb2Nrd2lzZSkgfHwgKCFyaWdodCAmJiBpc0Nsb2Nrd2lzZSk7XG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIHJldmVyc2VDb29yZGluYXRlcyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUpO1xuICAgIH1cbiAgICBvZmZzZXQgPSBlbmQ7XG4gIH1cbiAgcmV0dXJuIG9mZnNldDtcbn1cblxuXG4vKipcbiAqIE9yaWVudCBjb29yZGluYXRlcyBpbiBhIGZsYXQgYXJyYXkgb2YgbGluZWFyIHJpbmdzLiAgQnkgZGVmYXVsdCwgcmluZ3NcbiAqIGFyZSBvcmllbnRlZCBmb2xsb3dpbmcgdGhlIGxlZnQtaGFuZCBydWxlIChjbG9ja3dpc2UgZm9yIGV4dGVyaW9yIGFuZFxuICogY291bnRlci1jbG9ja3dpc2UgZm9yIGludGVyaW9yIHJpbmdzKS4gIFRvIG9yaWVudCBhY2NvcmRpbmcgdG8gdGhlXG4gKiByaWdodC1oYW5kIHJ1bGUsIHVzZSB0aGUgYG9wdF9yaWdodGAgYXJndW1lbnQuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gZW5kc3MgQXJyYXkgb2YgYXJyYXkgb2YgZW5kIGluZGV4ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9yaWdodCBGb2xsb3cgdGhlIHJpZ2h0LWhhbmQgcnVsZSBmb3Igb3JpZW50YXRpb24uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEVuZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9yaWVudExpbmVhclJpbmdzQXJyYXkoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHNzLCBzdHJpZGUsIG9wdF9yaWdodCkge1xuICBmb3IgKHZhciBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgb2Zmc2V0ID0gb3JpZW50TGluZWFyUmluZ3MoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kc3NbaV0sIHN0cmlkZSwgb3B0X3JpZ2h0KTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcmllbnQuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9yZXZlcnNlXG4gKi9cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb29yZGluYXRlcyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUpIHtcbiAgd2hpbGUgKG9mZnNldCA8IGVuZCAtIHN0cmlkZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaWRlOyArK2kpIHtcbiAgICAgIHZhciB0bXAgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgaV07XG4gICAgICBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgaV0gPSBmbGF0Q29vcmRpbmF0ZXNbZW5kIC0gc3RyaWRlICsgaV07XG4gICAgICBmbGF0Q29vcmRpbmF0ZXNbZW5kIC0gc3RyaWRlICsgaV0gPSB0bXA7XG4gICAgfVxuICAgIG9mZnNldCArPSBzdHJpZGU7XG4gICAgZW5kIC09IHN0cmlkZTtcbiAgfVxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXZlcnNlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL2ZsYXQvc2VnbWVudHNcbiAqL1xuXG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjYWxscyBgY2FsbGJhY2tgIGZvciBlYWNoIHNlZ21lbnQgb2YgdGhlIGZsYXQgY29vcmRpbmF0ZXNcbiAqIGFycmF5LiBJZiB0aGUgY2FsbGJhY2sgcmV0dXJucyBhIHRydXRoeSB2YWx1ZSB0aGUgZnVuY3Rpb24gcmV0dXJucyB0aGF0XG4gKiB2YWx1ZSBpbW1lZGlhdGVseS4gT3RoZXJ3aXNlIHRoZSBmdW5jdGlvbiByZXR1cm5zIGBmYWxzZWAuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBTLCBpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGUsIGltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZSk6IFR9IGNhbGxiYWNrIEZ1bmN0aW9uXG4gKiAgICAgY2FsbGVkIGZvciBlYWNoIHNlZ21lbnQuXG4gKiBAcGFyYW0ge1M9fSBvcHRfdGhpcyBUaGUgb2JqZWN0IHRvIGJlIHVzZWQgYXMgdGhlIHZhbHVlIG9mICd0aGlzJ1xuICogICAgIHdpdGhpbiBjYWxsYmFjay5cbiAqIEByZXR1cm4ge1R8Ym9vbGVhbn0gVmFsdWUuXG4gKiBAdGVtcGxhdGUgVCxTXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JFYWNoKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgY2FsbGJhY2ssIG9wdF90aGlzKSB7XG4gIHZhciBwb2ludDEgPSBbZmxhdENvb3JkaW5hdGVzW29mZnNldF0sIGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXV07XG4gIHZhciBwb2ludDIgPSBbXTtcbiAgdmFyIHJldDtcbiAgZm9yICg7IChvZmZzZXQgKyBzdHJpZGUpIDwgZW5kOyBvZmZzZXQgKz0gc3RyaWRlKSB7XG4gICAgcG9pbnQyWzBdID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIHN0cmlkZV07XG4gICAgcG9pbnQyWzFdID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIHN0cmlkZSArIDFdO1xuICAgIHJldCA9IGNhbGxiYWNrLmNhbGwob3B0X3RoaXMsIHBvaW50MSwgcG9pbnQyKTtcbiAgICBpZiAocmV0KSB7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBwb2ludDFbMF0gPSBwb2ludDJbMF07XG4gICAgcG9pbnQxWzFdID0gcG9pbnQyWzFdO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VnbWVudHMuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9zaW1wbGlmeVxuICovXG4vLyBCYXNlZCBvbiBzaW1wbGlmeS1qcyBodHRwczovL2dpdGh1Yi5jb20vbW91cm5lci9zaW1wbGlmeS1qc1xuLy8gQ29weXJpZ2h0IChjKSAyMDEyLCBWbGFkaW1pciBBZ2Fmb25raW5cbi8vIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4vLyBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbi8vXG4vLyAgICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4vLyAgICAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuLy9cbi8vICAgIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4vLyAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4vLyAgICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuLy9cbi8vIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4vLyBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4vLyBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuLy8gQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRVxuLy8gTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuLy8gQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0Zcbi8vIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTU1xuLy8gSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU5cbi8vIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG4vLyBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuLy8gUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG5cbmltcG9ydCB7c3F1YXJlZFNlZ21lbnREaXN0YW5jZSwgc3F1YXJlZERpc3RhbmNlfSBmcm9tICcuLi8uLi9tYXRoLmpzJztcblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gc3F1YXJlZFRvbGVyYW5jZSBTcXVhcmVkIHRvbGVyYW5jZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaGlnaFF1YWxpdHkgSGlnaGVzdCBxdWFsaXR5LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+PX0gb3B0X3NpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMgU2ltcGxpZmllZCBmbGF0XG4gKiAgICAgY29vcmRpbmF0ZXMuXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBTaW1wbGlmaWVkIGxpbmUgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2ltcGxpZnlMaW5lU3RyaW5nKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsXG4gIHN0cmlkZSwgc3F1YXJlZFRvbGVyYW5jZSwgaGlnaFF1YWxpdHksIG9wdF9zaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzKSB7XG4gIHZhciBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzID0gb3B0X3NpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMgIT09IHVuZGVmaW5lZCA/XG4gICAgb3B0X3NpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMgOiBbXTtcbiAgaWYgKCFoaWdoUXVhbGl0eSkge1xuICAgIGVuZCA9IHJhZGlhbERpc3RhbmNlKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsXG4gICAgICBzdHJpZGUsIHNxdWFyZWRUb2xlcmFuY2UsXG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLCAwKTtcbiAgICBmbGF0Q29vcmRpbmF0ZXMgPSBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzO1xuICAgIG9mZnNldCA9IDA7XG4gICAgc3RyaWRlID0gMjtcbiAgfVxuICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLmxlbmd0aCA9IGRvdWdsYXNQZXVja2VyKFxuICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgc3F1YXJlZFRvbGVyYW5jZSxcbiAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLCAwKTtcbiAgcmV0dXJuIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXM7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHNxdWFyZWRUb2xlcmFuY2UgU3F1YXJlZCB0b2xlcmFuY2UuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMgU2ltcGxpZmllZCBmbGF0XG4gKiAgICAgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gc2ltcGxpZmllZE9mZnNldCBTaW1wbGlmaWVkIG9mZnNldC5cbiAqIEByZXR1cm4ge251bWJlcn0gU2ltcGxpZmllZCBvZmZzZXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkb3VnbGFzUGV1Y2tlcihmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLFxuICBzdHJpZGUsIHNxdWFyZWRUb2xlcmFuY2UsIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsIHNpbXBsaWZpZWRPZmZzZXQpIHtcbiAgdmFyIG4gPSAoZW5kIC0gb2Zmc2V0KSAvIHN0cmlkZTtcbiAgaWYgKG4gPCAzKSB7XG4gICAgZm9yICg7IG9mZnNldCA8IGVuZDsgb2Zmc2V0ICs9IHN0cmlkZSkge1xuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID1cbiAgICAgICAgICBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XTtcbiAgICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9XG4gICAgICAgICAgZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdO1xuICAgIH1cbiAgICByZXR1cm4gc2ltcGxpZmllZE9mZnNldDtcbiAgfVxuICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovXG4gIHZhciBtYXJrZXJzID0gbmV3IEFycmF5KG4pO1xuICBtYXJrZXJzWzBdID0gMTtcbiAgbWFya2Vyc1tuIC0gMV0gPSAxO1xuICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovXG4gIHZhciBzdGFjayA9IFtvZmZzZXQsIGVuZCAtIHN0cmlkZV07XG4gIHZhciBpbmRleCA9IDA7XG4gIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGxhc3QgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgZmlyc3QgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgbWF4U3F1YXJlZERpc3RhbmNlID0gMDtcbiAgICB2YXIgeDEgPSBmbGF0Q29vcmRpbmF0ZXNbZmlyc3RdO1xuICAgIHZhciB5MSA9IGZsYXRDb29yZGluYXRlc1tmaXJzdCArIDFdO1xuICAgIHZhciB4MiA9IGZsYXRDb29yZGluYXRlc1tsYXN0XTtcbiAgICB2YXIgeTIgPSBmbGF0Q29vcmRpbmF0ZXNbbGFzdCArIDFdO1xuICAgIGZvciAodmFyIGkgPSBmaXJzdCArIHN0cmlkZTsgaSA8IGxhc3Q7IGkgKz0gc3RyaWRlKSB7XG4gICAgICB2YXIgeCA9IGZsYXRDb29yZGluYXRlc1tpXTtcbiAgICAgIHZhciB5ID0gZmxhdENvb3JkaW5hdGVzW2kgKyAxXTtcbiAgICAgIHZhciBzcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkU2VnbWVudERpc3RhbmNlKFxuICAgICAgICB4LCB5LCB4MSwgeTEsIHgyLCB5Mik7XG4gICAgICBpZiAoc3F1YXJlZERpc3RhbmNlID4gbWF4U3F1YXJlZERpc3RhbmNlKSB7XG4gICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgbWF4U3F1YXJlZERpc3RhbmNlID0gc3F1YXJlZERpc3RhbmNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWF4U3F1YXJlZERpc3RhbmNlID4gc3F1YXJlZFRvbGVyYW5jZSkge1xuICAgICAgbWFya2Vyc1soaW5kZXggLSBvZmZzZXQpIC8gc3RyaWRlXSA9IDE7XG4gICAgICBpZiAoZmlyc3QgKyBzdHJpZGUgPCBpbmRleCkge1xuICAgICAgICBzdGFjay5wdXNoKGZpcnN0LCBpbmRleCk7XG4gICAgICB9XG4gICAgICBpZiAoaW5kZXggKyBzdHJpZGUgPCBsYXN0KSB7XG4gICAgICAgIHN0YWNrLnB1c2goaW5kZXgsIGxhc3QpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBuOyArK2kkMSkge1xuICAgIGlmIChtYXJrZXJzW2kkMV0pIHtcbiAgICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9XG4gICAgICAgICAgZmxhdENvb3JkaW5hdGVzW29mZnNldCArIGkkMSAqIHN0cmlkZV07XG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPVxuICAgICAgICAgIGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyBpJDEgKiBzdHJpZGUgKyAxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNpbXBsaWZpZWRPZmZzZXQ7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGVuZHMgRW5kcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHNxdWFyZWRUb2xlcmFuY2UgU3F1YXJlZCB0b2xlcmFuY2UuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMgU2ltcGxpZmllZCBmbGF0XG4gKiAgICAgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gc2ltcGxpZmllZE9mZnNldCBTaW1wbGlmaWVkIG9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc2ltcGxpZmllZEVuZHMgU2ltcGxpZmllZCBlbmRzLlxuICogQHJldHVybiB7bnVtYmVyfSBTaW1wbGlmaWVkIG9mZnNldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRvdWdsYXNQZXVja2VyQXJyYXkoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsXG4gIGVuZHMsIHN0cmlkZSwgc3F1YXJlZFRvbGVyYW5jZSwgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyxcbiAgc2ltcGxpZmllZE9mZnNldCwgc2ltcGxpZmllZEVuZHMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgdmFyIGVuZCA9IGVuZHNbaV07XG4gICAgc2ltcGxpZmllZE9mZnNldCA9IGRvdWdsYXNQZXVja2VyKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCBzcXVhcmVkVG9sZXJhbmNlLFxuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcywgc2ltcGxpZmllZE9mZnNldCk7XG4gICAgc2ltcGxpZmllZEVuZHMucHVzaChzaW1wbGlmaWVkT2Zmc2V0KTtcbiAgICBvZmZzZXQgPSBlbmQ7XG4gIH1cbiAgcmV0dXJuIHNpbXBsaWZpZWRPZmZzZXQ7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBlbmRzcyBFbmRzcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHNxdWFyZWRUb2xlcmFuY2UgU3F1YXJlZCB0b2xlcmFuY2UuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMgU2ltcGxpZmllZCBmbGF0XG4gKiAgICAgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gc2ltcGxpZmllZE9mZnNldCBTaW1wbGlmaWVkIG9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IHNpbXBsaWZpZWRFbmRzcyBTaW1wbGlmaWVkIGVuZHNzLlxuICogQHJldHVybiB7bnVtYmVyfSBTaW1wbGlmaWVkIG9mZnNldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRvdWdsYXNQZXVja2VyTXVsdGlBcnJheShcbiAgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHNzLCBzdHJpZGUsIHNxdWFyZWRUb2xlcmFuY2UsXG4gIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsIHNpbXBsaWZpZWRPZmZzZXQsIHNpbXBsaWZpZWRFbmRzcykge1xuICBmb3IgKHZhciBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgdmFyIGVuZHMgPSBlbmRzc1tpXTtcbiAgICB2YXIgc2ltcGxpZmllZEVuZHMgPSBbXTtcbiAgICBzaW1wbGlmaWVkT2Zmc2V0ID0gZG91Z2xhc1BldWNrZXJBcnJheShcbiAgICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLCBzdHJpZGUsIHNxdWFyZWRUb2xlcmFuY2UsXG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLCBzaW1wbGlmaWVkT2Zmc2V0LCBzaW1wbGlmaWVkRW5kcyk7XG4gICAgc2ltcGxpZmllZEVuZHNzLnB1c2goc2ltcGxpZmllZEVuZHMpO1xuICAgIG9mZnNldCA9IGVuZHNbZW5kcy5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gc2ltcGxpZmllZE9mZnNldDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gc3F1YXJlZFRvbGVyYW5jZSBTcXVhcmVkIHRvbGVyYW5jZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyBTaW1wbGlmaWVkIGZsYXRcbiAqICAgICBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaW1wbGlmaWVkT2Zmc2V0IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICogQHJldHVybiB7bnVtYmVyfSBTaW1wbGlmaWVkIG9mZnNldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhZGlhbERpc3RhbmNlKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsXG4gIHN0cmlkZSwgc3F1YXJlZFRvbGVyYW5jZSwgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcywgc2ltcGxpZmllZE9mZnNldCkge1xuICBpZiAoZW5kIDw9IG9mZnNldCArIHN0cmlkZSkge1xuICAgIC8vIHplcm8gb3Igb25lIHBvaW50LCBubyBzaW1wbGlmaWNhdGlvbiBwb3NzaWJsZSwgc28gY29weSBhbmQgcmV0dXJuXG4gICAgZm9yICg7IG9mZnNldCA8IGVuZDsgb2Zmc2V0ICs9IHN0cmlkZSkge1xuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID0gZmxhdENvb3JkaW5hdGVzW29mZnNldF07XG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPVxuICAgICAgICAgIGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXTtcbiAgICB9XG4gICAgcmV0dXJuIHNpbXBsaWZpZWRPZmZzZXQ7XG4gIH1cbiAgdmFyIHgxID0gZmxhdENvb3JkaW5hdGVzW29mZnNldF07XG4gIHZhciB5MSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXTtcbiAgLy8gY29weSBmaXJzdCBwb2ludFxuICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPSB4MTtcbiAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID0geTE7XG4gIHZhciB4MiA9IHgxO1xuICB2YXIgeTIgPSB5MTtcbiAgZm9yIChvZmZzZXQgKz0gc3RyaWRlOyBvZmZzZXQgPCBlbmQ7IG9mZnNldCArPSBzdHJpZGUpIHtcbiAgICB4MiA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXRdO1xuICAgIHkyID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdO1xuICAgIGlmIChzcXVhcmVkRGlzdGFuY2UoeDEsIHkxLCB4MiwgeTIpID4gc3F1YXJlZFRvbGVyYW5jZSkge1xuICAgICAgLy8gY29weSBwb2ludCBhdCBvZmZzZXRcbiAgICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IHgyO1xuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID0geTI7XG4gICAgICB4MSA9IHgyO1xuICAgICAgeTEgPSB5MjtcbiAgICB9XG4gIH1cbiAgaWYgKHgyICE9IHgxIHx8IHkyICE9IHkxKSB7XG4gICAgLy8gY29weSBsYXN0IHBvaW50XG4gICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID0geDI7XG4gICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID0geTI7XG4gIH1cbiAgcmV0dXJuIHNpbXBsaWZpZWRPZmZzZXQ7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9sZXJhbmNlIFRvbGVyYW5jZS5cbiAqIEByZXR1cm4ge251bWJlcn0gUm91bmRlZCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNuYXAodmFsdWUsIHRvbGVyYW5jZSkge1xuICByZXR1cm4gdG9sZXJhbmNlICogTWF0aC5yb3VuZCh2YWx1ZSAvIHRvbGVyYW5jZSk7XG59XG5cblxuLyoqXG4gKiBTaW1wbGlmaWVzIGEgbGluZSBzdHJpbmcgdXNpbmcgYW4gYWxnb3JpdGhtIGRlc2lnbmVkIGJ5IFRpbSBTY2hhdWIuXG4gKiBDb29yZGluYXRlcyBhcmUgc25hcHBlZCB0byB0aGUgbmVhcmVzdCB2YWx1ZSBpbiBhIHZpcnR1YWwgZ3JpZCBhbmRcbiAqIGNvbnNlY3V0aXZlIGR1cGxpY2F0ZSBjb29yZGluYXRlcyBhcmUgZGlzY2FyZGVkLiAgVGhpcyBlZmZlY3RpdmVseSBwcmVzZXJ2ZXNcbiAqIHRvcG9sb2d5IGFzIHRoZSBzaW1wbGlmaWNhdGlvbiBvZiBhbnkgc3Vic2VjdGlvbiBvZiBhIGxpbmUgc3RyaW5nIGlzXG4gKiBpbmRlcGVuZGVudCBvZiB0aGUgcmVzdCBvZiB0aGUgbGluZSBzdHJpbmcuICBUaGlzIG1lYW5zIHRoYXQsIGZvciBleGFtcGxlcyxcbiAqIHRoZSBjb21tb24gZWRnZSBiZXR3ZWVuIHR3byBwb2x5Z29ucyB3aWxsIGJlIHNpbXBsaWZpZWQgdG8gdGhlIHNhbWUgbGluZVxuICogc3RyaW5nIGluZGVwZW5kZW50bHkgaW4gYm90aCBwb2x5Z29ucy4gIFRoaXMgaW1wbGVtZW50YXRpb24gdXNlcyBhIHNpbmdsZVxuICogcGFzcyBvdmVyIHRoZSBjb29yZGluYXRlcyBhbmQgZWxpbWluYXRlcyBpbnRlcm1lZGlhdGUgY29sbGluZWFyIHBvaW50cy5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9sZXJhbmNlIFRvbGVyYW5jZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyBTaW1wbGlmaWVkIGZsYXRcbiAqICAgICBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaW1wbGlmaWVkT2Zmc2V0IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICogQHJldHVybiB7bnVtYmVyfSBTaW1wbGlmaWVkIG9mZnNldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1YW50aXplKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSxcbiAgdG9sZXJhbmNlLCBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLCBzaW1wbGlmaWVkT2Zmc2V0KSB7XG4gIC8vIGRvIG5vdGhpbmcgaWYgdGhlIGxpbmUgaXMgZW1wdHlcbiAgaWYgKG9mZnNldCA9PSBlbmQpIHtcbiAgICByZXR1cm4gc2ltcGxpZmllZE9mZnNldDtcbiAgfVxuICAvLyBzbmFwIHRoZSBmaXJzdCBjb29yZGluYXRlIChQMSlcbiAgdmFyIHgxID0gc25hcChmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XSwgdG9sZXJhbmNlKTtcbiAgdmFyIHkxID0gc25hcChmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV0sIHRvbGVyYW5jZSk7XG4gIG9mZnNldCArPSBzdHJpZGU7XG4gIC8vIGFkZCB0aGUgZmlyc3QgY29vcmRpbmF0ZSB0byB0aGUgb3V0cHV0XG4gIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IHgxO1xuICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPSB5MTtcbiAgLy8gZmluZCB0aGUgbmV4dCBjb29yZGluYXRlIHRoYXQgZG9lcyBub3Qgc25hcCB0byB0aGUgc2FtZSB2YWx1ZSBhcyB0aGUgZmlyc3RcbiAgLy8gY29vcmRpbmF0ZSAoUDIpXG4gIHZhciB4MiwgeTI7XG4gIGRvIHtcbiAgICB4MiA9IHNuYXAoZmxhdENvb3JkaW5hdGVzW29mZnNldF0sIHRvbGVyYW5jZSk7XG4gICAgeTIgPSBzbmFwKGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXSwgdG9sZXJhbmNlKTtcbiAgICBvZmZzZXQgKz0gc3RyaWRlO1xuICAgIGlmIChvZmZzZXQgPT0gZW5kKSB7XG4gICAgICAvLyBhbGwgY29vcmRpbmF0ZXMgc25hcCB0byB0aGUgc2FtZSB2YWx1ZSwgdGhlIGxpbmUgY29sbGFwc2VzIHRvIGEgcG9pbnRcbiAgICAgIC8vIHB1c2ggdGhlIGxhc3Qgc25hcHBlZCB2YWx1ZSBhbnl3YXkgdG8gZW5zdXJlIHRoYXQgdGhlIG91dHB1dCBjb250YWluc1xuICAgICAgLy8gYXQgbGVhc3QgdHdvIHBvaW50c1xuICAgICAgLy8gRklYTUUgc2hvdWxkIHdlIHJlYWxseSByZXR1cm4gYXQgbGVhc3QgdHdvIHBvaW50cyBhbnl3YXk/XG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPSB4MjtcbiAgICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IHkyO1xuICAgICAgcmV0dXJuIHNpbXBsaWZpZWRPZmZzZXQ7XG4gICAgfVxuICB9IHdoaWxlICh4MiA9PSB4MSAmJiB5MiA9PSB5MSk7XG4gIHdoaWxlIChvZmZzZXQgPCBlbmQpIHtcbiAgICAvLyBzbmFwIHRoZSBuZXh0IGNvb3JkaW5hdGUgKFAzKVxuICAgIHZhciB4MyA9IHNuYXAoZmxhdENvb3JkaW5hdGVzW29mZnNldF0sIHRvbGVyYW5jZSk7XG4gICAgdmFyIHkzID0gc25hcChmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV0sIHRvbGVyYW5jZSk7XG4gICAgb2Zmc2V0ICs9IHN0cmlkZTtcbiAgICAvLyBza2lwIFAzIGlmIGl0IGlzIGVxdWFsIHRvIFAyXG4gICAgaWYgKHgzID09IHgyICYmIHkzID09IHkyKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gY2FsY3VsYXRlIHRoZSBkZWx0YSBiZXR3ZWVuIFAxIGFuZCBQMlxuICAgIHZhciBkeDEgPSB4MiAtIHgxO1xuICAgIHZhciBkeTEgPSB5MiAtIHkxO1xuICAgIC8vIGNhbGN1bGF0ZSB0aGUgZGVsdGEgYmV0d2VlbiBQMyBhbmQgUDFcbiAgICB2YXIgZHgyID0geDMgLSB4MTtcbiAgICB2YXIgZHkyID0geTMgLSB5MTtcbiAgICAvLyBpZiBQMSwgUDIsIGFuZCBQMyBhcmUgY29saW5lYXIgYW5kIFAzIGlzIGZ1cnRoZXIgZnJvbSBQMSB0aGFuIFAyIGlzIGZyb21cbiAgICAvLyBQMSBpbiB0aGUgc2FtZSBkaXJlY3Rpb24gdGhlbiBQMiBpcyBvbiB0aGUgc3RyYWlnaHQgbGluZSBiZXR3ZWVuIFAxIGFuZFxuICAgIC8vIFAzXG4gICAgaWYgKChkeDEgKiBkeTIgPT0gZHkxICogZHgyKSAmJlxuICAgICAgICAoKGR4MSA8IDAgJiYgZHgyIDwgZHgxKSB8fCBkeDEgPT0gZHgyIHx8IChkeDEgPiAwICYmIGR4MiA+IGR4MSkpICYmXG4gICAgICAgICgoZHkxIDwgMCAmJiBkeTIgPCBkeTEpIHx8IGR5MSA9PSBkeTIgfHwgKGR5MSA+IDAgJiYgZHkyID4gZHkxKSkpIHtcbiAgICAgIC8vIGRpc2NhcmQgUDIgYW5kIHNldCBQMiA9IFAzXG4gICAgICB4MiA9IHgzO1xuICAgICAgeTIgPSB5MztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBlaXRoZXIgUDEsIFAyLCBhbmQgUDMgYXJlIG5vdCBjb2xpbmVhciwgb3IgdGhleSBhcmUgY29saW5lYXIgYnV0IFAzIGlzXG4gICAgLy8gYmV0d2VlbiBQMyBhbmQgUDEgb3Igb24gdGhlIG9wcG9zaXRlIGhhbGYgb2YgdGhlIGxpbmUgdG8gUDIuICBhZGQgUDIsXG4gICAgLy8gYW5kIGNvbnRpbnVlIHdpdGggUDEgPSBQMiBhbmQgUDIgPSBQM1xuICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IHgyO1xuICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IHkyO1xuICAgIHgxID0geDI7XG4gICAgeTEgPSB5MjtcbiAgICB4MiA9IHgzO1xuICAgIHkyID0geTM7XG4gIH1cbiAgLy8gYWRkIHRoZSBsYXN0IHBvaW50IChQMilcbiAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID0geDI7XG4gIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IHkyO1xuICByZXR1cm4gc2ltcGxpZmllZE9mZnNldDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW5kcyBFbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9sZXJhbmNlIFRvbGVyYW5jZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyBTaW1wbGlmaWVkIGZsYXRcbiAqICAgICBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaW1wbGlmaWVkT2Zmc2V0IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBzaW1wbGlmaWVkRW5kcyBTaW1wbGlmaWVkIGVuZHMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVhbnRpemVBcnJheShcbiAgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHMsIHN0cmlkZSxcbiAgdG9sZXJhbmNlLFxuICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLCBzaW1wbGlmaWVkT2Zmc2V0LCBzaW1wbGlmaWVkRW5kcykge1xuICBmb3IgKHZhciBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICB2YXIgZW5kID0gZW5kc1tpXTtcbiAgICBzaW1wbGlmaWVkT2Zmc2V0ID0gcXVhbnRpemUoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsXG4gICAgICB0b2xlcmFuY2UsXG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLCBzaW1wbGlmaWVkT2Zmc2V0KTtcbiAgICBzaW1wbGlmaWVkRW5kcy5wdXNoKHNpbXBsaWZpZWRPZmZzZXQpO1xuICAgIG9mZnNldCA9IGVuZDtcbiAgfVxuICByZXR1cm4gc2ltcGxpZmllZE9mZnNldDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGVuZHNzIEVuZHNzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9sZXJhbmNlIFRvbGVyYW5jZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyBTaW1wbGlmaWVkIGZsYXRcbiAqICAgICBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaW1wbGlmaWVkT2Zmc2V0IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gc2ltcGxpZmllZEVuZHNzIFNpbXBsaWZpZWQgZW5kc3MuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVhbnRpemVNdWx0aUFycmF5KFxuICBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kc3MsIHN0cmlkZSxcbiAgdG9sZXJhbmNlLFxuICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLCBzaW1wbGlmaWVkT2Zmc2V0LCBzaW1wbGlmaWVkRW5kc3MpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gZW5kc3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIHZhciBlbmRzID0gZW5kc3NbaV07XG4gICAgdmFyIHNpbXBsaWZpZWRFbmRzID0gW107XG4gICAgc2ltcGxpZmllZE9mZnNldCA9IHF1YW50aXplQXJyYXkoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlLFxuICAgICAgdG9sZXJhbmNlLFxuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcywgc2ltcGxpZmllZE9mZnNldCwgc2ltcGxpZmllZEVuZHMpO1xuICAgIHNpbXBsaWZpZWRFbmRzcy5wdXNoKHNpbXBsaWZpZWRFbmRzKTtcbiAgICBvZmZzZXQgPSBlbmRzW2VuZHMubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIHNpbXBsaWZpZWRPZmZzZXQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpbXBsaWZ5LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL2ZsYXQvc3RyYWlnaHRjaHVua1xuICovXG5cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4QW5nbGUgTWF4aW11bSBhY2NlcHRhYmxlIGFuZ2xlIGRlbHRhIGJldHdlZW4gc2VnbWVudHMuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gU3RhcnQgYW5kIGVuZCBvZiB0aGUgZmlyc3Qgc3VpdGFibGUgY2h1bmsgb2YgdGhlXG4gKiBnaXZlbiBgZmxhdENvb3JkaW5hdGVzYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoaW5nQ2h1bmsobWF4QW5nbGUsIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSkge1xuICB2YXIgY2h1bmtTdGFydCA9IG9mZnNldDtcbiAgdmFyIGNodW5rRW5kID0gb2Zmc2V0O1xuICB2YXIgY2h1bmtNID0gMDtcbiAgdmFyIG0gPSAwO1xuICB2YXIgc3RhcnQgPSBvZmZzZXQ7XG4gIHZhciBhY29zLCBpLCBtMTIsIG0yMywgeDEsIHkxLCB4MTIsIHkxMiwgeDIzLCB5MjM7XG4gIGZvciAoaSA9IG9mZnNldDsgaSA8IGVuZDsgaSArPSBzdHJpZGUpIHtcbiAgICB2YXIgeDIgPSBmbGF0Q29vcmRpbmF0ZXNbaV07XG4gICAgdmFyIHkyID0gZmxhdENvb3JkaW5hdGVzW2kgKyAxXTtcbiAgICBpZiAoeDEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgeDIzID0geDIgLSB4MTtcbiAgICAgIHkyMyA9IHkyIC0geTE7XG4gICAgICBtMjMgPSBNYXRoLnNxcnQoeDIzICogeDIzICsgeTIzICogeTIzKTtcbiAgICAgIGlmICh4MTIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtICs9IG0xMjtcbiAgICAgICAgYWNvcyA9IE1hdGguYWNvcygoeDEyICogeDIzICsgeTEyICogeTIzKSAvIChtMTIgKiBtMjMpKTtcbiAgICAgICAgaWYgKGFjb3MgPiBtYXhBbmdsZSkge1xuICAgICAgICAgIGlmIChtID4gY2h1bmtNKSB7XG4gICAgICAgICAgICBjaHVua00gPSBtO1xuICAgICAgICAgICAgY2h1bmtTdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgY2h1bmtFbmQgPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtID0gMDtcbiAgICAgICAgICBzdGFydCA9IGkgLSBzdHJpZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG0xMiA9IG0yMztcbiAgICAgIHgxMiA9IHgyMztcbiAgICAgIHkxMiA9IHkyMztcbiAgICB9XG4gICAgeDEgPSB4MjtcbiAgICB5MSA9IHkyO1xuICB9XG4gIG0gKz0gbTIzO1xuICByZXR1cm4gbSA+IGNodW5rTSA/IFtzdGFydCwgaV0gOiBbY2h1bmtTdGFydCwgY2h1bmtFbmRdO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJhaWdodGNodW5rLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL2ZsYXQvdGV4dHBhdGhcbiAqL1xuaW1wb3J0IHtsZXJwfSBmcm9tICcuLi8uLi9tYXRoLmpzJztcblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIFBhdGggdG8gcHV0IHRleHQgb24uXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFN0YXJ0IG9mZnNldCBvZiB0aGUgYGZsYXRDb29yZGluYXRlc2AuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZCBvZmZzZXQgb2YgdGhlIGBmbGF0Q29vcmRpbmF0ZXNgLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUZXh0IHRvIHBsYWNlIG9uIHRoZSBwYXRoLlxuICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcpOm51bWJlcn0gbWVhc3VyZSBNZWFzdXJlIGZ1bmN0aW9uIHJldHVybmluZyB0aGVcbiAqIHdpZHRoIG9mIHRoZSBjaGFyYWN0ZXIgcGFzc2VkIGFzIDFzdCBhcmd1bWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydE0gbSBhbG9uZyB0aGUgcGF0aCB3aGVyZSB0aGUgdGV4dCBzdGFydHMuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4QW5nbGUgTWF4IGFuZ2xlIGJldHdlZW4gYWRqYWNlbnQgY2hhcnMgaW4gcmFkaWFucy5cbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PCo+Pn0gVGhlIHJlc3VsdCBhcnJheSBvZiBudWxsIGlmIGBtYXhBbmdsZWAgd2FzXG4gKiBleGNlZWRlZC4gRW50cmllcyBvZiB0aGUgYXJyYXkgYXJlIHgsIHksIGFuY2hvclgsIGFuZ2xlLCBjaHVuay5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRyYXdUZXh0T25QYXRoKFxuICBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIHRleHQsIG1lYXN1cmUsIHN0YXJ0TSwgbWF4QW5nbGUpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIC8vIEtlZXAgdGV4dCB1cHJpZ2h0XG4gIHZhciByZXZlcnNlID0gZmxhdENvb3JkaW5hdGVzW29mZnNldF0gPiBmbGF0Q29vcmRpbmF0ZXNbZW5kIC0gc3RyaWRlXTtcblxuICB2YXIgbnVtQ2hhcnMgPSB0ZXh0Lmxlbmd0aDtcblxuICB2YXIgeDEgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XTtcbiAgdmFyIHkxID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdO1xuICBvZmZzZXQgKz0gc3RyaWRlO1xuICB2YXIgeDIgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XTtcbiAgdmFyIHkyID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdO1xuICB2YXIgc2VnbWVudE0gPSAwO1xuICB2YXIgc2VnbWVudExlbmd0aCA9IE1hdGguc3FydChNYXRoLnBvdyh4MiAtIHgxLCAyKSArIE1hdGgucG93KHkyIC0geTEsIDIpKTtcblxuICB2YXIgY2h1bmsgPSAnJztcbiAgdmFyIGNodW5rTGVuZ3RoID0gMDtcbiAgdmFyIGRhdGEsIGluZGV4LCBwcmV2aW91c0FuZ2xlO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUNoYXJzOyArK2kpIHtcbiAgICBpbmRleCA9IHJldmVyc2UgPyBudW1DaGFycyAtIGkgLSAxIDogaTtcbiAgICB2YXIgY2hhciA9IHRleHQuY2hhckF0KGluZGV4KTtcbiAgICBjaHVuayA9IHJldmVyc2UgPyBjaGFyICsgY2h1bmsgOiBjaHVuayArIGNoYXI7XG4gICAgdmFyIGNoYXJMZW5ndGggPSBtZWFzdXJlKGNodW5rKSAtIGNodW5rTGVuZ3RoO1xuICAgIGNodW5rTGVuZ3RoICs9IGNoYXJMZW5ndGg7XG4gICAgdmFyIGNoYXJNID0gc3RhcnRNICsgY2hhckxlbmd0aCAvIDI7XG4gICAgd2hpbGUgKG9mZnNldCA8IGVuZCAtIHN0cmlkZSAmJiBzZWdtZW50TSArIHNlZ21lbnRMZW5ndGggPCBjaGFyTSkge1xuICAgICAgeDEgPSB4MjtcbiAgICAgIHkxID0geTI7XG4gICAgICBvZmZzZXQgKz0gc3RyaWRlO1xuICAgICAgeDIgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XTtcbiAgICAgIHkyID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdO1xuICAgICAgc2VnbWVudE0gKz0gc2VnbWVudExlbmd0aDtcbiAgICAgIHNlZ21lbnRMZW5ndGggPSBNYXRoLnNxcnQoTWF0aC5wb3coeDIgLSB4MSwgMikgKyBNYXRoLnBvdyh5MiAtIHkxLCAyKSk7XG4gICAgfVxuICAgIHZhciBzZWdtZW50UG9zID0gY2hhck0gLSBzZWdtZW50TTtcbiAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKHkyIC0geTEsIHgyIC0geDEpO1xuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICBhbmdsZSArPSBhbmdsZSA+IDAgPyAtTWF0aC5QSSA6IE1hdGguUEk7XG4gICAgfVxuICAgIGlmIChwcmV2aW91c0FuZ2xlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBkZWx0YSA9IGFuZ2xlIC0gcHJldmlvdXNBbmdsZTtcbiAgICAgIGRlbHRhICs9IChkZWx0YSA+IE1hdGguUEkpID8gLTIgKiBNYXRoLlBJIDogKGRlbHRhIDwgLU1hdGguUEkpID8gMiAqIE1hdGguUEkgOiAwO1xuICAgICAgaWYgKE1hdGguYWJzKGRlbHRhKSA+IG1heEFuZ2xlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgaW50ZXJwb2xhdGUgPSBzZWdtZW50UG9zIC8gc2VnbWVudExlbmd0aDtcbiAgICB2YXIgeCA9IGxlcnAoeDEsIHgyLCBpbnRlcnBvbGF0ZSk7XG4gICAgdmFyIHkgPSBsZXJwKHkxLCB5MiwgaW50ZXJwb2xhdGUpO1xuICAgIGlmIChwcmV2aW91c0FuZ2xlID09IGFuZ2xlKSB7XG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICBkYXRhWzBdID0geDtcbiAgICAgICAgZGF0YVsxXSA9IHk7XG4gICAgICAgIGRhdGFbMl0gPSBjaGFyTGVuZ3RoIC8gMjtcbiAgICAgIH1cbiAgICAgIGRhdGFbNF0gPSBjaHVuaztcbiAgICB9IGVsc2Uge1xuICAgICAgY2h1bmsgPSBjaGFyO1xuICAgICAgY2h1bmtMZW5ndGggPSBjaGFyTGVuZ3RoO1xuICAgICAgZGF0YSA9IFt4LCB5LCBjaGFyTGVuZ3RoIC8gMiwgYW5nbGUsIGNodW5rXTtcbiAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIHJlc3VsdC51bnNoaWZ0KGRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0LnB1c2goZGF0YSk7XG4gICAgICB9XG4gICAgICBwcmV2aW91c0FuZ2xlID0gYW5nbGU7XG4gICAgfVxuICAgIHN0YXJ0TSArPSBjaGFyTGVuZ3RoO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRleHRwYXRoLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL2ZsYXQvdHJhbnNmb3JtXG4gKi9cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19IHRyYW5zZm9ybSBUcmFuc2Zvcm0uXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj49fSBvcHRfZGVzdCBEZXN0aW5hdGlvbi5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRyYW5zZm9ybWVkIGNvb3JkaW5hdGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtMkQoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCB0cmFuc2Zvcm0sIG9wdF9kZXN0KSB7XG4gIHZhciBkZXN0ID0gb3B0X2Rlc3QgPyBvcHRfZGVzdCA6IFtdO1xuICB2YXIgaSA9IDA7XG4gIGZvciAodmFyIGogPSBvZmZzZXQ7IGogPCBlbmQ7IGogKz0gc3RyaWRlKSB7XG4gICAgdmFyIHggPSBmbGF0Q29vcmRpbmF0ZXNbal07XG4gICAgdmFyIHkgPSBmbGF0Q29vcmRpbmF0ZXNbaiArIDFdO1xuICAgIGRlc3RbaSsrXSA9IHRyYW5zZm9ybVswXSAqIHggKyB0cmFuc2Zvcm1bMl0gKiB5ICsgdHJhbnNmb3JtWzRdO1xuICAgIGRlc3RbaSsrXSA9IHRyYW5zZm9ybVsxXSAqIHggKyB0cmFuc2Zvcm1bM10gKiB5ICsgdHJhbnNmb3JtWzVdO1xuICB9XG4gIGlmIChvcHRfZGVzdCAmJiBkZXN0Lmxlbmd0aCAhPSBpKSB7XG4gICAgZGVzdC5sZW5ndGggPSBpO1xuICB9XG4gIHJldHVybiBkZXN0O1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSBBbmdsZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYW5jaG9yIFJvdGF0aW9uIGFuY2hvciBwb2ludC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPj19IG9wdF9kZXN0IERlc3RpbmF0aW9uLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVHJhbnNmb3JtZWQgY29vcmRpbmF0ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGUoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCBhbmdsZSwgYW5jaG9yLCBvcHRfZGVzdCkge1xuICB2YXIgZGVzdCA9IG9wdF9kZXN0ID8gb3B0X2Rlc3QgOiBbXTtcbiAgdmFyIGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgdmFyIHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgdmFyIGFuY2hvclggPSBhbmNob3JbMF07XG4gIHZhciBhbmNob3JZID0gYW5jaG9yWzFdO1xuICB2YXIgaSA9IDA7XG4gIGZvciAodmFyIGogPSBvZmZzZXQ7IGogPCBlbmQ7IGogKz0gc3RyaWRlKSB7XG4gICAgdmFyIGRlbHRhWCA9IGZsYXRDb29yZGluYXRlc1tqXSAtIGFuY2hvclg7XG4gICAgdmFyIGRlbHRhWSA9IGZsYXRDb29yZGluYXRlc1tqICsgMV0gLSBhbmNob3JZO1xuICAgIGRlc3RbaSsrXSA9IGFuY2hvclggKyBkZWx0YVggKiBjb3MgLSBkZWx0YVkgKiBzaW47XG4gICAgZGVzdFtpKytdID0gYW5jaG9yWSArIGRlbHRhWCAqIHNpbiArIGRlbHRhWSAqIGNvcztcbiAgICBmb3IgKHZhciBrID0gaiArIDI7IGsgPCBqICsgc3RyaWRlOyArK2spIHtcbiAgICAgIGRlc3RbaSsrXSA9IGZsYXRDb29yZGluYXRlc1trXTtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdF9kZXN0ICYmIGRlc3QubGVuZ3RoICE9IGkpIHtcbiAgICBkZXN0Lmxlbmd0aCA9IGk7XG4gIH1cbiAgcmV0dXJuIGRlc3Q7XG59XG5cblxuLyoqXG4gKiBTY2FsZSB0aGUgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHN4IFNjYWxlIGZhY3RvciBpbiB0aGUgeC1kaXJlY3Rpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gc3kgU2NhbGUgZmFjdG9yIGluIHRoZSB5LWRpcmVjdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYW5jaG9yIFNjYWxlIGFuY2hvciBwb2ludC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPj19IG9wdF9kZXN0IERlc3RpbmF0aW9uLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVHJhbnNmb3JtZWQgY29vcmRpbmF0ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIHN4LCBzeSwgYW5jaG9yLCBvcHRfZGVzdCkge1xuICB2YXIgZGVzdCA9IG9wdF9kZXN0ID8gb3B0X2Rlc3QgOiBbXTtcbiAgdmFyIGFuY2hvclggPSBhbmNob3JbMF07XG4gIHZhciBhbmNob3JZID0gYW5jaG9yWzFdO1xuICB2YXIgaSA9IDA7XG4gIGZvciAodmFyIGogPSBvZmZzZXQ7IGogPCBlbmQ7IGogKz0gc3RyaWRlKSB7XG4gICAgdmFyIGRlbHRhWCA9IGZsYXRDb29yZGluYXRlc1tqXSAtIGFuY2hvclg7XG4gICAgdmFyIGRlbHRhWSA9IGZsYXRDb29yZGluYXRlc1tqICsgMV0gLSBhbmNob3JZO1xuICAgIGRlc3RbaSsrXSA9IGFuY2hvclggKyBzeCAqIGRlbHRhWDtcbiAgICBkZXN0W2krK10gPSBhbmNob3JZICsgc3kgKiBkZWx0YVk7XG4gICAgZm9yICh2YXIgayA9IGogKyAyOyBrIDwgaiArIHN0cmlkZTsgKytrKSB7XG4gICAgICBkZXN0W2krK10gPSBmbGF0Q29vcmRpbmF0ZXNba107XG4gICAgfVxuICB9XG4gIGlmIChvcHRfZGVzdCAmJiBkZXN0Lmxlbmd0aCAhPSBpKSB7XG4gICAgZGVzdC5sZW5ndGggPSBpO1xuICB9XG4gIHJldHVybiBkZXN0O1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVggRGVsdGEgWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVkgRGVsdGEgWS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPj19IG9wdF9kZXN0IERlc3RpbmF0aW9uLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVHJhbnNmb3JtZWQgY29vcmRpbmF0ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2xhdGUoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCBkZWx0YVgsIGRlbHRhWSwgb3B0X2Rlc3QpIHtcbiAgdmFyIGRlc3QgPSBvcHRfZGVzdCA/IG9wdF9kZXN0IDogW107XG4gIHZhciBpID0gMDtcbiAgZm9yICh2YXIgaiA9IG9mZnNldDsgaiA8IGVuZDsgaiArPSBzdHJpZGUpIHtcbiAgICBkZXN0W2krK10gPSBmbGF0Q29vcmRpbmF0ZXNbal0gKyBkZWx0YVg7XG4gICAgZGVzdFtpKytdID0gZmxhdENvb3JkaW5hdGVzW2ogKyAxXSArIGRlbHRhWTtcbiAgICBmb3IgKHZhciBrID0gaiArIDI7IGsgPCBqICsgc3RyaWRlOyArK2spIHtcbiAgICAgIGRlc3RbaSsrXSA9IGZsYXRDb29yZGluYXRlc1trXTtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdF9kZXN0ICYmIGRlc3QubGVuZ3RoICE9IGkpIHtcbiAgICBkZXN0Lmxlbmd0aCA9IGk7XG4gIH1cbiAgcmV0dXJuIGRlc3Q7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zZm9ybS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvaGFzXG4gKi9cblxudmFyIHVhID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgP1xuICBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkgOiAnJztcblxuLyoqXG4gKiBVc2VyIGFnZW50IHN0cmluZyBzYXlzIHdlIGFyZSBkZWFsaW5nIHdpdGggRmlyZWZveCBhcyBicm93c2VyLlxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCB2YXIgRklSRUZPWCA9IHVhLmluZGV4T2YoJ2ZpcmVmb3gnKSAhPT0gLTE7XG5cbi8qKlxuICogVXNlciBhZ2VudCBzdHJpbmcgc2F5cyB3ZSBhcmUgZGVhbGluZyB3aXRoIFNhZmFyaSBhcyBicm93c2VyLlxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCB2YXIgU0FGQVJJID0gdWEuaW5kZXhPZignc2FmYXJpJykgIT09IC0xICYmIHVhLmluZGV4T2YoJ2Nocm9tJykgPT0gLTE7XG5cbi8qKlxuICogVXNlciBhZ2VudCBzdHJpbmcgc2F5cyB3ZSBhcmUgZGVhbGluZyB3aXRoIGEgV2ViS2l0IGVuZ2luZS5cbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5leHBvcnQgdmFyIFdFQktJVCA9IHVhLmluZGV4T2YoJ3dlYmtpdCcpICE9PSAtMSAmJiB1YS5pbmRleE9mKCdlZGdlJykgPT0gLTE7XG5cbi8qKlxuICogVXNlciBhZ2VudCBzdHJpbmcgc2F5cyB3ZSBhcmUgZGVhbGluZyB3aXRoIGEgTWFjIGFzIHBsYXRmb3JtLlxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCB2YXIgTUFDID0gdWEuaW5kZXhPZignbWFjaW50b3NoJykgIT09IC0xO1xuXG5cbi8qKlxuICogVGhlIHJhdGlvIGJldHdlZW4gcGh5c2ljYWwgcGl4ZWxzIGFuZCBkZXZpY2UtaW5kZXBlbmRlbnQgcGl4ZWxzXG4gKiAoZGlwcykgb24gdGhlIGRldmljZSAoYHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvYCkuXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAYXBpXG4gKi9cbmV4cG9ydCB2YXIgREVWSUNFX1BJWEVMX1JBVElPID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcblxuXG4vKipcbiAqIFRydWUgaWYgdGhlIGJyb3dzZXIncyBDYW52YXMgaW1wbGVtZW50YXRpb24gaW1wbGVtZW50cyB7Z2V0LHNldH1MaW5lRGFzaC5cbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5leHBvcnQgdmFyIENBTlZBU19MSU5FX0RBU0ggPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhhcyA9IGZhbHNlO1xuICB0cnkge1xuICAgIGhhcyA9ICEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCgnMmQnKS5zZXRMaW5lRGFzaDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIHBhc3NcbiAgfVxuICByZXR1cm4gaGFzO1xufSgpO1xuXG5cbi8qKlxuICogSXMgSFRNTDUgZ2VvbG9jYXRpb24gc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGJyb3dzZXI/XG4gKiBAY29uc3RcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGFwaVxuICovXG5leHBvcnQgdmFyIEdFT0xPQ0FUSU9OID0gJ2dlb2xvY2F0aW9uJyBpbiBuYXZpZ2F0b3I7XG5cblxuLyoqXG4gKiBUcnVlIGlmIGJyb3dzZXIgc3VwcG9ydHMgdG91Y2ggZXZlbnRzLlxuICogQGNvbnN0XG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IHZhciBUT1VDSCA9ICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdztcblxuXG4vKipcbiAqIFRydWUgaWYgYnJvd3NlciBzdXBwb3J0cyBwb2ludGVyIGV2ZW50cy5cbiAqIEBjb25zdFxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCB2YXIgUE9JTlRFUiA9ICdQb2ludGVyRXZlbnQnIGluIHdpbmRvdztcblxuXG4vKipcbiAqIFRydWUgaWYgYnJvd3NlciBzdXBwb3J0cyBtcyBwb2ludGVyIGV2ZW50cyAoSUUgMTApLlxuICogQGNvbnN0XG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IHZhciBNU1BPSU5URVIgPSAhIShuYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZCk7XG5cblxuZXhwb3J0IHtIQVMgYXMgV0VCR0x9IGZyb20gJy4vd2ViZ2wuanMnO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXMuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uXG4gKi9cbmltcG9ydCBDb2xsZWN0aW9uIGZyb20gJy4vQ29sbGVjdGlvbi5qcyc7XG5pbXBvcnQgS2luZXRpYyBmcm9tICcuL0tpbmV0aWMuanMnO1xuaW1wb3J0IERvdWJsZUNsaWNrWm9vbSBmcm9tICcuL2ludGVyYWN0aW9uL0RvdWJsZUNsaWNrWm9vbS5qcyc7XG5pbXBvcnQgRHJhZ1BhbiBmcm9tICcuL2ludGVyYWN0aW9uL0RyYWdQYW4uanMnO1xuaW1wb3J0IERyYWdSb3RhdGUgZnJvbSAnLi9pbnRlcmFjdGlvbi9EcmFnUm90YXRlLmpzJztcbmltcG9ydCBEcmFnWm9vbSBmcm9tICcuL2ludGVyYWN0aW9uL0RyYWdab29tLmpzJztcbmltcG9ydCBLZXlib2FyZFBhbiBmcm9tICcuL2ludGVyYWN0aW9uL0tleWJvYXJkUGFuLmpzJztcbmltcG9ydCBLZXlib2FyZFpvb20gZnJvbSAnLi9pbnRlcmFjdGlvbi9LZXlib2FyZFpvb20uanMnO1xuaW1wb3J0IE1vdXNlV2hlZWxab29tIGZyb20gJy4vaW50ZXJhY3Rpb24vTW91c2VXaGVlbFpvb20uanMnO1xuaW1wb3J0IFBpbmNoUm90YXRlIGZyb20gJy4vaW50ZXJhY3Rpb24vUGluY2hSb3RhdGUuanMnO1xuaW1wb3J0IFBpbmNoWm9vbSBmcm9tICcuL2ludGVyYWN0aW9uL1BpbmNoWm9vbS5qcyc7XG5pbXBvcnQge2ZvY3VzfSBmcm9tICcuL2V2ZW50cy9jb25kaXRpb24uanMnO1xuXG5leHBvcnQge2RlZmF1bHQgYXMgRG91YmxlQ2xpY2tab29tfSBmcm9tICcuL2ludGVyYWN0aW9uL0RvdWJsZUNsaWNrWm9vbS5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgRHJhZ0FuZERyb3B9IGZyb20gJy4vaW50ZXJhY3Rpb24vRHJhZ0FuZERyb3AuanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIERyYWdCb3h9IGZyb20gJy4vaW50ZXJhY3Rpb24vRHJhZ0JveC5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgRHJhZ1Bhbn0gZnJvbSAnLi9pbnRlcmFjdGlvbi9EcmFnUGFuLmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBEcmFnUm90YXRlfSBmcm9tICcuL2ludGVyYWN0aW9uL0RyYWdSb3RhdGUuanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIERyYWdSb3RhdGVBbmRab29tfSBmcm9tICcuL2ludGVyYWN0aW9uL0RyYWdSb3RhdGVBbmRab29tLmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBEcmFnWm9vbX0gZnJvbSAnLi9pbnRlcmFjdGlvbi9EcmFnWm9vbS5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgRHJhd30gZnJvbSAnLi9pbnRlcmFjdGlvbi9EcmF3LmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBFeHRlbnR9IGZyb20gJy4vaW50ZXJhY3Rpb24vRXh0ZW50LmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBJbnRlcmFjdGlvbn0gZnJvbSAnLi9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbi5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgS2V5Ym9hcmRQYW59IGZyb20gJy4vaW50ZXJhY3Rpb24vS2V5Ym9hcmRQYW4uanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEtleWJvYXJkWm9vbX0gZnJvbSAnLi9pbnRlcmFjdGlvbi9LZXlib2FyZFpvb20uanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIE1vZGlmeX0gZnJvbSAnLi9pbnRlcmFjdGlvbi9Nb2RpZnkuanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIE1vdXNlV2hlZWxab29tfSBmcm9tICcuL2ludGVyYWN0aW9uL01vdXNlV2hlZWxab29tLmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBQaW5jaFJvdGF0ZX0gZnJvbSAnLi9pbnRlcmFjdGlvbi9QaW5jaFJvdGF0ZS5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgUGluY2hab29tfSBmcm9tICcuL2ludGVyYWN0aW9uL1BpbmNoWm9vbS5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgUG9pbnRlcn0gZnJvbSAnLi9pbnRlcmFjdGlvbi9Qb2ludGVyLmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBTZWxlY3R9IGZyb20gJy4vaW50ZXJhY3Rpb24vU2VsZWN0LmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBTbmFwfSBmcm9tICcuL2ludGVyYWN0aW9uL1NuYXAuanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFRyYW5zbGF0ZX0gZnJvbSAnLi9pbnRlcmFjdGlvbi9UcmFuc2xhdGUuanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRGVmYXVsdHNPcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthbHRTaGlmdERyYWdSb3RhdGU9dHJ1ZV0gV2hldGhlciBBbHQtU2hpZnQtZHJhZyByb3RhdGUgaXNcbiAqIGRlc2lyZWQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtvbkZvY3VzT25seT1mYWxzZV0gSW50ZXJhY3Qgb25seSB3aGVuIHRoZSBtYXAgaGFzIHRoZVxuICogZm9jdXMuIFRoaXMgYWZmZWN0cyB0aGUgYE1vdXNlV2hlZWxab29tYCBhbmQgYERyYWdQYW5gIGludGVyYWN0aW9ucyBhbmQgaXNcbiAqIHVzZWZ1bCB3aGVuIHBhZ2Ugc2Nyb2xsIGlzIGRlc2lyZWQgZm9yIG1hcHMgdGhhdCBkbyBub3QgaGF2ZSB0aGUgYnJvd3NlcidzXG4gKiBmb2N1cy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2NvbnN0cmFpblJlc29sdXRpb249ZmFsc2VdIFpvb20gdG8gdGhlIGNsb3Nlc3QgaW50ZWdlclxuICogem9vbSBsZXZlbCBhZnRlciB0aGUgd2hlZWwvdHJhY2twYWQgb3IgcGluY2ggZ2VzdHVyZSBlbmRzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbZG91YmxlQ2xpY2tab29tPXRydWVdIFdoZXRoZXIgZG91YmxlIGNsaWNrIHpvb20gaXNcbiAqIGRlc2lyZWQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtrZXlib2FyZD10cnVlXSBXaGV0aGVyIGtleWJvYXJkIGludGVyYWN0aW9uIGlzIGRlc2lyZWQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFttb3VzZVdoZWVsWm9vbT10cnVlXSBXaGV0aGVyIG1vdXNld2hlZWwgem9vbSBpcyBkZXNpcmVkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbc2hpZnREcmFnWm9vbT10cnVlXSBXaGV0aGVyIFNoaWZ0LWRyYWcgem9vbSBpcyBkZXNpcmVkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbZHJhZ1Bhbj10cnVlXSBXaGV0aGVyIGRyYWcgcGFuIGlzIGRlc2lyZWQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtwaW5jaFJvdGF0ZT10cnVlXSBXaGV0aGVyIHBpbmNoIHJvdGF0ZSBpcyBkZXNpcmVkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbcGluY2hab29tPXRydWVdIFdoZXRoZXIgcGluY2ggem9vbSBpcyBkZXNpcmVkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt6b29tRGVsdGFdIFpvb20gbGV2ZWwgZGVsdGEgd2hlbiB1c2luZyBrZXlib2FyZCBvclxuICogbW91c2V3aGVlbCB6b29tLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt6b29tRHVyYXRpb25dIER1cmF0aW9uIG9mIHRoZSB6b29tIGFuaW1hdGlvbiBpblxuICogbWlsbGlzZWNvbmRzLlxuICovXG5cblxuLyoqXG4gKiBTZXQgb2YgaW50ZXJhY3Rpb25zIGluY2x1ZGVkIGluIG1hcHMgYnkgZGVmYXVsdC4gU3BlY2lmaWMgaW50ZXJhY3Rpb25zIGNhbiBiZVxuICogZXhjbHVkZWQgYnkgc2V0dGluZyB0aGUgYXBwcm9wcmlhdGUgb3B0aW9uIHRvIGZhbHNlIGluIHRoZSBjb25zdHJ1Y3RvclxuICogb3B0aW9ucywgYnV0IHRoZSBvcmRlciBvZiB0aGUgaW50ZXJhY3Rpb25zIGlzIGZpeGVkLiAgSWYgeW91IHdhbnQgdG8gc3BlY2lmeVxuICogYSBkaWZmZXJlbnQgb3JkZXIgZm9yIGludGVyYWN0aW9ucywgeW91IHdpbGwgbmVlZCB0byBjcmVhdGUgeW91ciBvd25cbiAqIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vSW50ZXJhY3Rpb259IGluc3RhbmNlcyBhbmQgaW5zZXJ0XG4gKiB0aGVtIGludG8gYSB7QGxpbmsgbW9kdWxlOm9sL0NvbGxlY3Rpb259IGluIHRoZSBvcmRlciB5b3Ugd2FudFxuICogYmVmb3JlIGNyZWF0aW5nIHlvdXIge0BsaW5rIG1vZHVsZTpvbC9NYXB+TWFwfSBpbnN0YW5jZS4gVGhlIGRlZmF1bHQgc2V0IG9mXG4gKiBpbnRlcmFjdGlvbnMsIGluIHNlcXVlbmNlLCBpczpcbiAqICoge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9EcmFnUm90YXRlfkRyYWdSb3RhdGV9XG4gKiAqIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vRG91YmxlQ2xpY2tab29tfkRvdWJsZUNsaWNrWm9vbX1cbiAqICoge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9EcmFnUGFufkRyYWdQYW59XG4gKiAqIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vUGluY2hSb3RhdGV+UGluY2hSb3RhdGV9XG4gKiAqIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vUGluY2hab29tflBpbmNoWm9vbX1cbiAqICoge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9LZXlib2FyZFBhbn5LZXlib2FyZFBhbn1cbiAqICoge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9LZXlib2FyZFpvb21+S2V5Ym9hcmRab29tfVxuICogKiB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL01vdXNlV2hlZWxab29tfk1vdXNlV2hlZWxab29tfVxuICogKiB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL0RyYWdab29tfkRyYWdab29tfVxuICpcbiAqIEBwYXJhbSB7RGVmYXVsdHNPcHRpb25zPX0gb3B0X29wdGlvbnMgRGVmYXVsdHMgb3B0aW9ucy5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vQ29sbGVjdGlvbi5qc1wiKS5kZWZhdWx0PGltcG9ydChcIi4vaW50ZXJhY3Rpb24vSW50ZXJhY3Rpb24uanNcIikuZGVmYXVsdD59XG4gKiBBIGNvbGxlY3Rpb24gb2YgaW50ZXJhY3Rpb25zIHRvIGJlIHVzZWQgd2l0aCB0aGUge0BsaW5rIG1vZHVsZTpvbC9NYXB+TWFwfVxuICogY29uc3RydWN0b3IncyBgaW50ZXJhY3Rpb25zYCBvcHRpb24uXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0cyhvcHRfb3B0aW9ucykge1xuXG4gIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgPyBvcHRfb3B0aW9ucyA6IHt9O1xuXG4gIHZhciBpbnRlcmFjdGlvbnMgPSBuZXcgQ29sbGVjdGlvbigpO1xuXG4gIHZhciBraW5ldGljID0gbmV3IEtpbmV0aWMoLTAuMDA1LCAwLjA1LCAxMDApO1xuXG4gIHZhciBhbHRTaGlmdERyYWdSb3RhdGUgPSBvcHRpb25zLmFsdFNoaWZ0RHJhZ1JvdGF0ZSAhPT0gdW5kZWZpbmVkID9cbiAgICBvcHRpb25zLmFsdFNoaWZ0RHJhZ1JvdGF0ZSA6IHRydWU7XG4gIGlmIChhbHRTaGlmdERyYWdSb3RhdGUpIHtcbiAgICBpbnRlcmFjdGlvbnMucHVzaChuZXcgRHJhZ1JvdGF0ZSgpKTtcbiAgfVxuXG4gIHZhciBkb3VibGVDbGlja1pvb20gPSBvcHRpb25zLmRvdWJsZUNsaWNrWm9vbSAhPT0gdW5kZWZpbmVkID9cbiAgICBvcHRpb25zLmRvdWJsZUNsaWNrWm9vbSA6IHRydWU7XG4gIGlmIChkb3VibGVDbGlja1pvb20pIHtcbiAgICBpbnRlcmFjdGlvbnMucHVzaChuZXcgRG91YmxlQ2xpY2tab29tKHtcbiAgICAgIGRlbHRhOiBvcHRpb25zLnpvb21EZWx0YSxcbiAgICAgIGR1cmF0aW9uOiBvcHRpb25zLnpvb21EdXJhdGlvblxuICAgIH0pKTtcbiAgfVxuXG4gIHZhciBkcmFnUGFuID0gb3B0aW9ucy5kcmFnUGFuICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRyYWdQYW4gOiB0cnVlO1xuICBpZiAoZHJhZ1Bhbikge1xuICAgIGludGVyYWN0aW9ucy5wdXNoKG5ldyBEcmFnUGFuKHtcbiAgICAgIGNvbmRpdGlvbjogb3B0aW9ucy5vbkZvY3VzT25seSA/IGZvY3VzIDogdW5kZWZpbmVkLFxuICAgICAga2luZXRpYzoga2luZXRpY1xuICAgIH0pKTtcbiAgfVxuXG4gIHZhciBwaW5jaFJvdGF0ZSA9IG9wdGlvbnMucGluY2hSb3RhdGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucGluY2hSb3RhdGUgOlxuICAgIHRydWU7XG4gIGlmIChwaW5jaFJvdGF0ZSkge1xuICAgIGludGVyYWN0aW9ucy5wdXNoKG5ldyBQaW5jaFJvdGF0ZSgpKTtcbiAgfVxuXG4gIHZhciBwaW5jaFpvb20gPSBvcHRpb25zLnBpbmNoWm9vbSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5waW5jaFpvb20gOiB0cnVlO1xuICBpZiAocGluY2hab29tKSB7XG4gICAgaW50ZXJhY3Rpb25zLnB1c2gobmV3IFBpbmNoWm9vbSh7XG4gICAgICBjb25zdHJhaW5SZXNvbHV0aW9uOiBvcHRpb25zLmNvbnN0cmFpblJlc29sdXRpb24sXG4gICAgICBkdXJhdGlvbjogb3B0aW9ucy56b29tRHVyYXRpb25cbiAgICB9KSk7XG4gIH1cblxuICB2YXIga2V5Ym9hcmQgPSBvcHRpb25zLmtleWJvYXJkICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmtleWJvYXJkIDogdHJ1ZTtcbiAgaWYgKGtleWJvYXJkKSB7XG4gICAgaW50ZXJhY3Rpb25zLnB1c2gobmV3IEtleWJvYXJkUGFuKCkpO1xuICAgIGludGVyYWN0aW9ucy5wdXNoKG5ldyBLZXlib2FyZFpvb20oe1xuICAgICAgZGVsdGE6IG9wdGlvbnMuem9vbURlbHRhLFxuICAgICAgZHVyYXRpb246IG9wdGlvbnMuem9vbUR1cmF0aW9uXG4gICAgfSkpO1xuICB9XG5cbiAgdmFyIG1vdXNlV2hlZWxab29tID0gb3B0aW9ucy5tb3VzZVdoZWVsWm9vbSAhPT0gdW5kZWZpbmVkID9cbiAgICBvcHRpb25zLm1vdXNlV2hlZWxab29tIDogdHJ1ZTtcbiAgaWYgKG1vdXNlV2hlZWxab29tKSB7XG4gICAgaW50ZXJhY3Rpb25zLnB1c2gobmV3IE1vdXNlV2hlZWxab29tKHtcbiAgICAgIGNvbmRpdGlvbjogb3B0aW9ucy5vbkZvY3VzT25seSA/IGZvY3VzIDogdW5kZWZpbmVkLFxuICAgICAgY29uc3RyYWluUmVzb2x1dGlvbjogb3B0aW9ucy5jb25zdHJhaW5SZXNvbHV0aW9uLFxuICAgICAgZHVyYXRpb246IG9wdGlvbnMuem9vbUR1cmF0aW9uXG4gICAgfSkpO1xuICB9XG5cbiAgdmFyIHNoaWZ0RHJhZ1pvb20gPSBvcHRpb25zLnNoaWZ0RHJhZ1pvb20gIT09IHVuZGVmaW5lZCA/XG4gICAgb3B0aW9ucy5zaGlmdERyYWdab29tIDogdHJ1ZTtcbiAgaWYgKHNoaWZ0RHJhZ1pvb20pIHtcbiAgICBpbnRlcmFjdGlvbnMucHVzaChuZXcgRHJhZ1pvb20oe1xuICAgICAgZHVyYXRpb246IG9wdGlvbnMuem9vbUR1cmF0aW9uXG4gICAgfSkpO1xuICB9XG5cbiAgcmV0dXJuIGludGVyYWN0aW9ucztcblxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcmFjdGlvbi5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vRG91YmxlQ2xpY2tab29tXG4gKi9cbmltcG9ydCBNYXBCcm93c2VyRXZlbnRUeXBlIGZyb20gJy4uL01hcEJyb3dzZXJFdmVudFR5cGUuanMnO1xuaW1wb3J0IEludGVyYWN0aW9uLCB7em9vbUJ5RGVsdGF9IGZyb20gJy4vSW50ZXJhY3Rpb24uanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkdXJhdGlvbj0yNTBdIEFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2RlbHRhPTFdIFRoZSB6b29tIGRlbHRhIGFwcGxpZWQgb24gZWFjaCBkb3VibGUgY2xpY2suXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFsbG93cyB0aGUgdXNlciB0byB6b29tIGJ5IGRvdWJsZS1jbGlja2luZyBvbiB0aGUgbWFwLlxuICogQGFwaVxuICovXG52YXIgRG91YmxlQ2xpY2tab29tID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoSW50ZXJhY3Rpb24pIHtcbiAgZnVuY3Rpb24gRG91YmxlQ2xpY2tab29tKG9wdF9vcHRpb25zKSB7XG4gICAgSW50ZXJhY3Rpb24uY2FsbCh0aGlzLCB7XG4gICAgICBoYW5kbGVFdmVudDogaGFuZGxlRXZlbnRcbiAgICB9KTtcblxuICAgIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgPyBvcHRfb3B0aW9ucyA6IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZGVsdGFfID0gb3B0aW9ucy5kZWx0YSA/IG9wdGlvbnMuZGVsdGEgOiAxO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZHVyYXRpb25fID0gb3B0aW9ucy5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kdXJhdGlvbiA6IDI1MDtcblxuICB9XG5cbiAgaWYgKCBJbnRlcmFjdGlvbiApIERvdWJsZUNsaWNrWm9vbS5fX3Byb3RvX18gPSBJbnRlcmFjdGlvbjtcbiAgRG91YmxlQ2xpY2tab29tLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEludGVyYWN0aW9uICYmIEludGVyYWN0aW9uLnByb3RvdHlwZSApO1xuICBEb3VibGVDbGlja1pvb20ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRG91YmxlQ2xpY2tab29tO1xuXG4gIHJldHVybiBEb3VibGVDbGlja1pvb207XG59KEludGVyYWN0aW9uKSk7XG5cblxuLyoqXG4gKiBIYW5kbGVzIHRoZSB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudCBtYXAgYnJvd3NlciBldmVudH0gKGlmIGl0IHdhcyBhXG4gKiBkb3VibGVjbGljaykgYW5kIGV2ZW50dWFsbHkgem9vbXMgdGhlIG1hcC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IGBmYWxzZWAgdG8gc3RvcCBldmVudCBwcm9wYWdhdGlvbi5cbiAqIEB0aGlzIHtEb3VibGVDbGlja1pvb219XG4gKi9cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICB2YXIgc3RvcEV2ZW50ID0gZmFsc2U7XG4gIGlmIChtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBNYXBCcm93c2VyRXZlbnRUeXBlLkRCTENMSUNLKSB7XG4gICAgdmFyIGJyb3dzZXJFdmVudCA9IC8qKiBAdHlwZSB7TW91c2VFdmVudH0gKi8gKG1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50KTtcbiAgICB2YXIgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgICB2YXIgYW5jaG9yID0gbWFwQnJvd3NlckV2ZW50LmNvb3JkaW5hdGU7XG4gICAgdmFyIGRlbHRhID0gYnJvd3NlckV2ZW50LnNoaWZ0S2V5ID8gLXRoaXMuZGVsdGFfIDogdGhpcy5kZWx0YV87XG4gICAgdmFyIHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgIHpvb21CeURlbHRhKHZpZXcsIGRlbHRhLCBhbmNob3IsIHRoaXMuZHVyYXRpb25fKTtcbiAgICBtYXBCcm93c2VyRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBzdG9wRXZlbnQgPSB0cnVlO1xuICB9XG4gIHJldHVybiAhc3RvcEV2ZW50O1xufVxuXG5leHBvcnQgZGVmYXVsdCBEb3VibGVDbGlja1pvb207XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURvdWJsZUNsaWNrWm9vbS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vRHJhZ0FuZERyb3BcbiAqL1xuLy8gRklYTUUgc2hvdWxkIGhhbmRsZSBhbGwgZ2VvLXJlZmVyZW5jZWQgZGF0YSwgbm90IGp1c3QgdmVjdG9yIGRhdGFcblxuaW1wb3J0IHtUUlVFfSBmcm9tICcuLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IHtsaXN0ZW4sIHVubGlzdGVuQnlLZXl9IGZyb20gJy4uL2V2ZW50cy5qcyc7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzL0V2ZW50LmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgSW50ZXJhY3Rpb24gZnJvbSAnLi9JbnRlcmFjdGlvbi5qcyc7XG5pbXBvcnQge2dldCBhcyBnZXRQcm9qZWN0aW9ufSBmcm9tICcuLi9wcm9qLmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8dHlwZW9mIGltcG9ydChcIi4uL2Zvcm1hdC9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fSBbZm9ybWF0Q29uc3RydWN0b3JzXSBGb3JtYXQgY29uc3RydWN0b3JzLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9zb3VyY2UvVmVjdG9yLmpzXCIpLmRlZmF1bHR9IFtzb3VyY2VdIE9wdGlvbmFsIHZlY3RvciBzb3VyY2Ugd2hlcmUgZmVhdHVyZXMgd2lsbCBiZSBhZGRlZC4gIElmIGEgc291cmNlIGlzIHByb3ZpZGVkXG4gKiBhbGwgZXhpc3RpbmcgZmVhdHVyZXMgd2lsbCBiZSByZW1vdmVkIGFuZCBuZXcgZmVhdHVyZXMgd2lsbCBiZSBhZGRlZCB3aGVuXG4gKiB0aGV5IGFyZSBkcm9wcGVkIG9uIHRoZSB0YXJnZXQuICBJZiB5b3Ugd2FudCB0byBhZGQgZmVhdHVyZXMgdG8gYSB2ZWN0b3JcbiAqIHNvdXJjZSB3aXRob3V0IHJlbW92aW5nIHRoZSBleGlzdGluZyBmZWF0dXJlcyAoYXBwZW5kIG9ubHkpLCBpbnN0ZWFkIG9mXG4gKiBwcm92aWRpbmcgdGhlIHNvdXJjZSBvcHRpb24gbGlzdGVuIGZvciB0aGUgXCJhZGRmZWF0dXJlc1wiIGV2ZW50LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9wcm9qLmpzXCIpLlByb2plY3Rpb25MaWtlfSBbcHJvamVjdGlvbl0gVGFyZ2V0IHByb2plY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBtYXAncyB2aWV3J3MgcHJvamVjdGlvbiBpcyB1c2VkLlxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gW3RhcmdldF0gVGhlIGVsZW1lbnQgdGhhdCBpcyB1c2VkIGFzIHRoZSBkcm9wIHRhcmdldCwgZGVmYXVsdCBpcyB0aGUgdmlld3BvcnQgZWxlbWVudC5cbiAqL1xuXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xudmFyIERyYWdBbmREcm9wRXZlbnRUeXBlID0ge1xuICAvKipcbiAgICogVHJpZ2dlcmVkIHdoZW4gZmVhdHVyZXMgYXJlIGFkZGVkXG4gICAqIEBldmVudCBEcmFnQW5kRHJvcEV2ZW50I2FkZGZlYXR1cmVzXG4gICAqIEBhcGlcbiAgICovXG4gIEFERF9GRUFUVVJFUzogJ2FkZGZlYXR1cmVzJ1xufTtcblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEV2ZW50cyBlbWl0dGVkIGJ5IHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vRHJhZ0FuZERyb3B+RHJhZ0FuZERyb3B9IGluc3RhbmNlcyBhcmUgaW5zdGFuY2VzXG4gKiBvZiB0aGlzIHR5cGUuXG4gKi9cbnZhciBEcmFnQW5kRHJvcEV2ZW50ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoRXZlbnQpIHtcbiAgZnVuY3Rpb24gRHJhZ0FuZERyb3BFdmVudCh0eXBlLCBmaWxlLCBvcHRfZmVhdHVyZXMsIG9wdF9wcm9qZWN0aW9uKSB7XG5cbiAgICBFdmVudC5jYWxsKHRoaXMsIHR5cGUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZlYXR1cmVzIHBhcnNlZCBmcm9tIGRyb3BwZWQgZGF0YS5cbiAgICAgKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZT58dW5kZWZpbmVkfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLmZlYXR1cmVzID0gb3B0X2ZlYXR1cmVzO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRyb3BwZWQgZmlsZS5cbiAgICAgKiBAdHlwZSB7RmlsZX1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5maWxlID0gZmlsZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmZWF0dXJlIHByb2plY3Rpb24uXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fHVuZGVmaW5lZH1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5wcm9qZWN0aW9uID0gb3B0X3Byb2plY3Rpb247XG5cbiAgfVxuXG4gIGlmICggRXZlbnQgKSBEcmFnQW5kRHJvcEV2ZW50Ll9fcHJvdG9fXyA9IEV2ZW50O1xuICBEcmFnQW5kRHJvcEV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEV2ZW50ICYmIEV2ZW50LnByb3RvdHlwZSApO1xuICBEcmFnQW5kRHJvcEV2ZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERyYWdBbmREcm9wRXZlbnQ7XG5cbiAgcmV0dXJuIERyYWdBbmREcm9wRXZlbnQ7XG59KEV2ZW50KSk7XG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBIYW5kbGVzIGlucHV0IG9mIHZlY3RvciBkYXRhIGJ5IGRyYWcgYW5kIGRyb3AuXG4gKiBAYXBpXG4gKlxuICogQGZpcmVzIERyYWdBbmREcm9wRXZlbnRcbiAqL1xudmFyIERyYWdBbmREcm9wID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoSW50ZXJhY3Rpb24pIHtcbiAgZnVuY3Rpb24gRHJhZ0FuZERyb3Aob3B0X29wdGlvbnMpIHtcblxuICAgIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgPyBvcHRfb3B0aW9ucyA6IHt9O1xuXG4gICAgSW50ZXJhY3Rpb24uY2FsbCh0aGlzLCB7XG4gICAgICBoYW5kbGVFdmVudDogVFJVRVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8dHlwZW9mIGltcG9ydChcIi4uL2Zvcm1hdC9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fVxuICAgICAqL1xuICAgIHRoaXMuZm9ybWF0Q29uc3RydWN0b3JzXyA9IG9wdGlvbnMuZm9ybWF0Q29uc3RydWN0b3JzID9cbiAgICAgIG9wdGlvbnMuZm9ybWF0Q29uc3RydWN0b3JzIDogW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLnByb2plY3Rpb25fID0gb3B0aW9ucy5wcm9qZWN0aW9uID9cbiAgICAgIGdldFByb2plY3Rpb24ob3B0aW9ucy5wcm9qZWN0aW9uKSA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuLi9ldmVudHMuanNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLmRyb3BMaXN0ZW5LZXlzXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9zb3VyY2UvVmVjdG9yLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5zb3VyY2VfID0gb3B0aW9ucy5zb3VyY2UgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMudGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQgPyBvcHRpb25zLnRhcmdldCA6IG51bGw7XG5cbiAgfVxuXG4gIGlmICggSW50ZXJhY3Rpb24gKSBEcmFnQW5kRHJvcC5fX3Byb3RvX18gPSBJbnRlcmFjdGlvbjtcbiAgRHJhZ0FuZERyb3AucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSW50ZXJhY3Rpb24gJiYgSW50ZXJhY3Rpb24ucHJvdG90eXBlICk7XG4gIERyYWdBbmREcm9wLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERyYWdBbmREcm9wO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0ZpbGV9IGZpbGUgRmlsZS5cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgTG9hZCBldmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIERyYWdBbmREcm9wLnByb3RvdHlwZS5oYW5kbGVSZXN1bHRfID0gZnVuY3Rpb24gaGFuZGxlUmVzdWx0XyAoZmlsZSwgZXZlbnQpIHtcbiAgICB2YXIgcmVzdWx0ID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcbiAgICB2YXIgbWFwID0gdGhpcy5nZXRNYXAoKTtcbiAgICB2YXIgcHJvamVjdGlvbiA9IHRoaXMucHJvamVjdGlvbl87XG4gICAgaWYgKCFwcm9qZWN0aW9uKSB7XG4gICAgICB2YXIgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgICBwcm9qZWN0aW9uID0gdmlldy5nZXRQcm9qZWN0aW9uKCk7XG4gICAgfVxuXG4gICAgdmFyIGZvcm1hdENvbnN0cnVjdG9ycyA9IHRoaXMuZm9ybWF0Q29uc3RydWN0b3JzXztcbiAgICB2YXIgZmVhdHVyZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBmb3JtYXRDb25zdHJ1Y3RvcnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgdmFyIGZvcm1hdCA9IG5ldyBmb3JtYXRDb25zdHJ1Y3RvcnNbaV0oKTtcbiAgICAgIGZlYXR1cmVzID0gdGhpcy50cnlSZWFkRmVhdHVyZXNfKGZvcm1hdCwgcmVzdWx0LCB7XG4gICAgICAgIGZlYXR1cmVQcm9qZWN0aW9uOiBwcm9qZWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGlmIChmZWF0dXJlcyAmJiBmZWF0dXJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5zb3VyY2VfKSB7XG4gICAgICB0aGlzLnNvdXJjZV8uY2xlYXIoKTtcbiAgICAgIHRoaXMuc291cmNlXy5hZGRGZWF0dXJlcyhmZWF0dXJlcyk7XG4gICAgfVxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgIG5ldyBEcmFnQW5kRHJvcEV2ZW50KFxuICAgICAgICBEcmFnQW5kRHJvcEV2ZW50VHlwZS5BRERfRkVBVFVSRVMsIGZpbGUsXG4gICAgICAgIGZlYXR1cmVzLCBwcm9qZWN0aW9uKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBEcmFnQW5kRHJvcC5wcm90b3R5cGUucmVnaXN0ZXJMaXN0ZW5lcnNfID0gZnVuY3Rpb24gcmVnaXN0ZXJMaXN0ZW5lcnNfICgpIHtcbiAgICB2YXIgbWFwID0gdGhpcy5nZXRNYXAoKTtcbiAgICBpZiAobWFwKSB7XG4gICAgICB2YXIgZHJvcEFyZWEgPSB0aGlzLnRhcmdldCA/IHRoaXMudGFyZ2V0IDogbWFwLmdldFZpZXdwb3J0KCk7XG4gICAgICB0aGlzLmRyb3BMaXN0ZW5LZXlzXyA9IFtcbiAgICAgICAgbGlzdGVuKGRyb3BBcmVhLCBFdmVudFR5cGUuRFJPUCwgaGFuZGxlRHJvcCwgdGhpcyksXG4gICAgICAgIGxpc3Rlbihkcm9wQXJlYSwgRXZlbnRUeXBlLkRSQUdFTlRFUiwgaGFuZGxlU3RvcCwgdGhpcyksXG4gICAgICAgIGxpc3Rlbihkcm9wQXJlYSwgRXZlbnRUeXBlLkRSQUdPVkVSLCBoYW5kbGVTdG9wLCB0aGlzKSxcbiAgICAgICAgbGlzdGVuKGRyb3BBcmVhLCBFdmVudFR5cGUuRFJPUCwgaGFuZGxlU3RvcCwgdGhpcylcbiAgICAgIF07XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgRHJhZ0FuZERyb3AucHJvdG90eXBlLnNldEFjdGl2ZSA9IGZ1bmN0aW9uIHNldEFjdGl2ZSAoYWN0aXZlKSB7XG4gICAgSW50ZXJhY3Rpb24ucHJvdG90eXBlLnNldEFjdGl2ZS5jYWxsKHRoaXMsIGFjdGl2ZSk7XG4gICAgaWYgKGFjdGl2ZSkge1xuICAgICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVyc18oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzXygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIERyYWdBbmREcm9wLnByb3RvdHlwZS5zZXRNYXAgPSBmdW5jdGlvbiBzZXRNYXAgKG1hcCkge1xuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVyc18oKTtcbiAgICBJbnRlcmFjdGlvbi5wcm90b3R5cGUuc2V0TWFwLmNhbGwodGhpcywgbWFwKTtcbiAgICBpZiAodGhpcy5nZXRBY3RpdmUoKSkge1xuICAgICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVyc18oKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZm9ybWF0L0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZm9ybWF0IEZvcm1hdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGV4dC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9mb3JtYXQvRmVhdHVyZS5qc1wiKS5SZWFkT3B0aW9uc30gb3B0aW9ucyBSZWFkIG9wdGlvbnMuXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge0FycmF5PGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2U+fSBGZWF0dXJlcy5cbiAgICovXG4gIERyYWdBbmREcm9wLnByb3RvdHlwZS50cnlSZWFkRmVhdHVyZXNfID0gZnVuY3Rpb24gdHJ5UmVhZEZlYXR1cmVzXyAoZm9ybWF0LCB0ZXh0LCBvcHRpb25zKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmb3JtYXQucmVhZEZlYXR1cmVzKHRleHQsIG9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIERyYWdBbmREcm9wLnByb3RvdHlwZS51bnJlZ2lzdGVyTGlzdGVuZXJzXyA9IGZ1bmN0aW9uIHVucmVnaXN0ZXJMaXN0ZW5lcnNfICgpIHtcbiAgICBpZiAodGhpcy5kcm9wTGlzdGVuS2V5c18pIHtcbiAgICAgIHRoaXMuZHJvcExpc3RlbktleXNfLmZvckVhY2godW5saXN0ZW5CeUtleSk7XG4gICAgICB0aGlzLmRyb3BMaXN0ZW5LZXlzXyA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBEcmFnQW5kRHJvcDtcbn0oSW50ZXJhY3Rpb24pKTtcblxuXG4vKipcbiAqIEBwYXJhbSB7RHJhZ0V2ZW50fSBldmVudCBFdmVudC5cbiAqIEB0aGlzIHtEcmFnQW5kRHJvcH1cbiAqL1xuZnVuY3Rpb24gaGFuZGxlRHJvcChldmVudCkge1xuICB2YXIgZmlsZXMgPSBldmVudC5kYXRhVHJhbnNmZXIuZmlsZXM7XG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IGZpbGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICB2YXIgZmlsZSA9IGZpbGVzLml0ZW0oaSk7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgcmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRUeXBlLkxPQUQsIHRoaXMuaGFuZGxlUmVzdWx0Xy5iaW5kKHRoaXMsIGZpbGUpKTtcbiAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlKTtcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtEcmFnRXZlbnR9IGV2ZW50IEV2ZW50LlxuICovXG5mdW5jdGlvbiBoYW5kbGVTdG9wKGV2ZW50KSB7XG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICBldmVudC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9ICdjb3B5Jztcbn1cblxuXG5leHBvcnQgZGVmYXVsdCBEcmFnQW5kRHJvcDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RHJhZ0FuZERyb3AuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL0RyYWdCb3hcbiAqL1xuLy8gRklYTUUgZHJhdyBkcmFnIGJveFxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cy9FdmVudC5qcyc7XG5pbXBvcnQge2Fsd2F5cywgbW91c2VPbmx5LCBtb3VzZUFjdGlvbkJ1dHRvbn0gZnJvbSAnLi4vZXZlbnRzL2NvbmRpdGlvbi5qcyc7XG5pbXBvcnQge1ZPSUR9IGZyb20gJy4uL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQgUG9pbnRlckludGVyYWN0aW9uIGZyb20gJy4vUG9pbnRlci5qcyc7XG5pbXBvcnQgUmVuZGVyQm94IGZyb20gJy4uL3JlbmRlci9Cb3guanMnO1xuXG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHRha2VzIGEge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR9IGFuZCB0d29cbiAqIHtAbGluayBtb2R1bGU6b2wvcGl4ZWx+UGl4ZWx9cyBhbmQgcmV0dXJucyBhIGB7Ym9vbGVhbn1gLiBJZiB0aGUgY29uZGl0aW9uIGlzIG1ldCxcbiAqIHRydWUgc2hvdWxkIGJlIHJldHVybmVkLlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKHRoaXM6ID8sIGltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0LCBpbXBvcnQoXCIuLi9waXhlbC5qc1wiKS5QaXhlbCwgaW1wb3J0KFwiLi4vcGl4ZWwuanNcIikuUGl4ZWwpOmJvb2xlYW59IEVuZENvbmRpdGlvblxuICovXG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzTmFtZT0nb2wtZHJhZ2JveCddIENTUyBjbGFzcyBuYW1lIGZvciBzdHlsaW5nIHRoZSBib3guXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufSBbY29uZGl0aW9uXSBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmQgcmV0dXJucyBhIGJvb2xlYW5cbiAqIHRvIGluZGljYXRlIHdoZXRoZXIgdGhhdCBldmVudCBzaG91bGQgYmUgaGFuZGxlZC5cbiAqIERlZmF1bHQgaXMge0BsaW5rIG9sL2V2ZW50cy9jb25kaXRpb25+YWx3YXlzfS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluQXJlYT02NF0gVGhlIG1pbmltdW0gYXJlYSBvZiB0aGUgYm94IGluIHBpeGVsLCB0aGlzIHZhbHVlIGlzIHVzZWQgYnkgdGhlIGRlZmF1bHRcbiAqIGBib3hFbmRDb25kaXRpb25gIGZ1bmN0aW9uLlxuICogQHByb3BlcnR5IHtFbmRDb25kaXRpb259IFtib3hFbmRDb25kaXRpb25dIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0gYW5kIHR3b1xuICoge0BsaW5rIG1vZHVsZTpvbC9waXhlbH5QaXhlbH1zIHRvIGluZGljYXRlIHdoZXRoZXIgYSBgYm94ZW5kYCBldmVudCBzaG91bGQgYmUgZmlyZWQuXG4gKiBEZWZhdWx0IGlzIGB0cnVlYCBpZiB0aGUgYXJlYSBvZiB0aGUgYm94IGlzIGJpZ2dlciB0aGFuIHRoZSBgbWluQXJlYWAgb3B0aW9uLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbih0aGlzOkRyYWdCb3gsIGltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0KX0gb25Cb3hFbmQgQ29kZSB0byBleGVjdXRlIGp1c3RcbiAqIGJlZm9yZSBgYm94ZW5kYCBpcyBmaXJlZC5cbiAqL1xuXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xudmFyIERyYWdCb3hFdmVudFR5cGUgPSB7XG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgdXBvbiBkcmFnIGJveCBzdGFydC5cbiAgICogQGV2ZW50IERyYWdCb3hFdmVudCNib3hzdGFydFxuICAgKiBAYXBpXG4gICAqL1xuICBCT1hTVEFSVDogJ2JveHN0YXJ0JyxcblxuICAvKipcbiAgICogVHJpZ2dlcmVkIG9uIGRyYWcgd2hlbiBib3ggaXMgYWN0aXZlLlxuICAgKiBAZXZlbnQgRHJhZ0JveEV2ZW50I2JveGRyYWdcbiAgICogQGFwaVxuICAgKi9cbiAgQk9YRFJBRzogJ2JveGRyYWcnLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgdXBvbiBkcmFnIGJveCBlbmQuXG4gICAqIEBldmVudCBEcmFnQm94RXZlbnQjYm94ZW5kXG4gICAqIEBhcGlcbiAgICovXG4gIEJPWEVORDogJ2JveGVuZCdcbn07XG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBFdmVudHMgZW1pdHRlZCBieSB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL0RyYWdCb3h+RHJhZ0JveH0gaW5zdGFuY2VzIGFyZSBpbnN0YW5jZXMgb2ZcbiAqIHRoaXMgdHlwZS5cbiAqL1xudmFyIERyYWdCb3hFdmVudCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEV2ZW50KSB7XG4gIGZ1bmN0aW9uIERyYWdCb3hFdmVudCh0eXBlLCBjb29yZGluYXRlLCBtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBFdmVudC5jYWxsKHRoaXMsIHR5cGUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNvb3JkaW5hdGUgb2YgdGhlIGRyYWcgZXZlbnQuXG4gICAgICogQGNvbnN0XG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5jb29yZGluYXRlID0gY29vcmRpbmF0ZTtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5tYXBCcm93c2VyRXZlbnQgPSBtYXBCcm93c2VyRXZlbnQ7XG5cbiAgfVxuXG4gIGlmICggRXZlbnQgKSBEcmFnQm94RXZlbnQuX19wcm90b19fID0gRXZlbnQ7XG4gIERyYWdCb3hFdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFdmVudCAmJiBFdmVudC5wcm90b3R5cGUgKTtcbiAgRHJhZ0JveEV2ZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERyYWdCb3hFdmVudDtcblxuICByZXR1cm4gRHJhZ0JveEV2ZW50O1xufShFdmVudCkpO1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWxsb3dzIHRoZSB1c2VyIHRvIGRyYXcgYSB2ZWN0b3IgYm94IGJ5IGNsaWNraW5nIGFuZCBkcmFnZ2luZyBvbiB0aGUgbWFwLFxuICogbm9ybWFsbHkgY29tYmluZWQgd2l0aCBhbiB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb259IHRoYXQgbGltaXRzXG4gKiBpdCB0byB3aGVuIHRoZSBzaGlmdCBvciBvdGhlciBrZXkgaXMgaGVsZCBkb3duLiBUaGlzIGlzIHVzZWQsIGZvciBleGFtcGxlLFxuICogZm9yIHpvb21pbmcgdG8gYSBzcGVjaWZpYyBhcmVhIG9mIHRoZSBtYXBcbiAqIChzZWUge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9EcmFnWm9vbX5EcmFnWm9vbX0gYW5kXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL0RyYWdSb3RhdGVBbmRab29tfSkuXG4gKlxuICogVGhpcyBpbnRlcmFjdGlvbiBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgbW91c2UgZGV2aWNlcy5cbiAqXG4gKiBAZmlyZXMgRHJhZ0JveEV2ZW50XG4gKiBAYXBpXG4gKi9cbnZhciBEcmFnQm94ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoUG9pbnRlckludGVyYWN0aW9uKSB7XG4gIGZ1bmN0aW9uIERyYWdCb3gob3B0X29wdGlvbnMpIHtcblxuICAgIFBvaW50ZXJJbnRlcmFjdGlvbi5jYWxsKHRoaXMpO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBvcHRfb3B0aW9ucyA/IG9wdF9vcHRpb25zIDoge307XG5cbiAgICAvKipcbiAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9yZW5kZXIvQm94LmpzXCIpLmRlZmF1bHR9XG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgdGhpcy5ib3hfID0gbmV3IFJlbmRlckJveChvcHRpb25zLmNsYXNzTmFtZSB8fCAnb2wtZHJhZ2JveCcpO1xuXG4gICAgLyoqXG4gICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIHRoaXMubWluQXJlYV8gPSBvcHRpb25zLm1pbkFyZWEgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubWluQXJlYSA6IDY0O1xuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdG8gZXhlY3V0ZSBqdXN0IGJlZm9yZSBgb25ib3hlbmRgIGlzIGZpcmVkXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKHRoaXM6RHJhZ0JveCwgaW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHQpfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5vbkJveEVuZF8gPSBvcHRpb25zLm9uQm94RW5kID8gb3B0aW9ucy5vbkJveEVuZCA6IFZPSUQ7XG5cbiAgICAvKipcbiAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9waXhlbC5qc1wiKS5QaXhlbH1cbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICB0aGlzLnN0YXJ0UGl4ZWxfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICogQHByaXZhdGVcbiAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn1cbiAgICAqL1xuICAgIHRoaXMuY29uZGl0aW9uXyA9IG9wdGlvbnMuY29uZGl0aW9uID8gb3B0aW9ucy5jb25kaXRpb24gOiBhbHdheXM7XG5cbiAgICAvKipcbiAgICAqIEBwcml2YXRlXG4gICAgKiBAdHlwZSB7RW5kQ29uZGl0aW9ufVxuICAgICovXG4gICAgdGhpcy5ib3hFbmRDb25kaXRpb25fID0gb3B0aW9ucy5ib3hFbmRDb25kaXRpb24gP1xuICAgICAgb3B0aW9ucy5ib3hFbmRDb25kaXRpb24gOiB0aGlzLmRlZmF1bHRCb3hFbmRDb25kaXRpb247XG4gIH1cblxuICBpZiAoIFBvaW50ZXJJbnRlcmFjdGlvbiApIERyYWdCb3guX19wcm90b19fID0gUG9pbnRlckludGVyYWN0aW9uO1xuICBEcmFnQm94LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBvaW50ZXJJbnRlcmFjdGlvbiAmJiBQb2ludGVySW50ZXJhY3Rpb24ucHJvdG90eXBlICk7XG4gIERyYWdCb3gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRHJhZ0JveDtcblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgY29uZGl0aW9uIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIHRoZSBib3hlbmQgZXZlbnRcbiAgICogc2hvdWxkIGZpcmUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBUaGUgb3JpZ2luYXRpbmcgTWFwQnJvd3NlckV2ZW50XG4gICAqICAgICBsZWFkaW5nIHRvIHRoZSBib3ggZW5kLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsfSBzdGFydFBpeGVsIFRoZSBzdGFydGluZyBwaXhlbCBvZiB0aGUgYm94LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsfSBlbmRQaXhlbCBUaGUgZW5kIHBpeGVsIG9mIHRoZSBib3guXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBib3hlbmQgY29uZGl0aW9uIHNob3VsZCBiZSBmaXJlZC5cbiAgICovXG4gIERyYWdCb3gucHJvdG90eXBlLmRlZmF1bHRCb3hFbmRDb25kaXRpb24gPSBmdW5jdGlvbiBkZWZhdWx0Qm94RW5kQ29uZGl0aW9uIChtYXBCcm93c2VyRXZlbnQsIHN0YXJ0UGl4ZWwsIGVuZFBpeGVsKSB7XG4gICAgdmFyIHdpZHRoID0gZW5kUGl4ZWxbMF0gLSBzdGFydFBpeGVsWzBdO1xuICAgIHZhciBoZWlnaHQgPSBlbmRQaXhlbFsxXSAtIHN0YXJ0UGl4ZWxbMV07XG4gICAgcmV0dXJuIHdpZHRoICogd2lkdGggKyBoZWlnaHQgKiBoZWlnaHQgPj0gdGhpcy5taW5BcmVhXztcbiAgfTtcblxuICAvKipcbiAgKiBSZXR1cm5zIGdlb21ldHJ5IG9mIGxhc3QgZHJhd24gYm94LlxuICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2dlb20vUG9seWdvbi5qc1wiKS5kZWZhdWx0fSBHZW9tZXRyeS5cbiAgKiBAYXBpXG4gICovXG4gIERyYWdCb3gucHJvdG90eXBlLmdldEdlb21ldHJ5ID0gZnVuY3Rpb24gZ2V0R2VvbWV0cnkgKCkge1xuICAgIHJldHVybiB0aGlzLmJveF8uZ2V0R2VvbWV0cnkoKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIERyYWdCb3gucHJvdG90eXBlLmhhbmRsZURyYWdFdmVudCA9IGZ1bmN0aW9uIGhhbmRsZURyYWdFdmVudCAobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKCFtb3VzZU9ubHkobWFwQnJvd3NlckV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYm94Xy5zZXRQaXhlbHModGhpcy5zdGFydFBpeGVsXywgbWFwQnJvd3NlckV2ZW50LnBpeGVsKTtcblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRHJhZ0JveEV2ZW50KERyYWdCb3hFdmVudFR5cGUuQk9YRFJBRyxcbiAgICAgIG1hcEJyb3dzZXJFdmVudC5jb29yZGluYXRlLCBtYXBCcm93c2VyRXZlbnQpKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIERyYWdCb3gucHJvdG90eXBlLmhhbmRsZVVwRXZlbnQgPSBmdW5jdGlvbiBoYW5kbGVVcEV2ZW50IChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBpZiAoIW1vdXNlT25seShtYXBCcm93c2VyRXZlbnQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLmJveF8uc2V0TWFwKG51bGwpO1xuXG4gICAgaWYgKHRoaXMuYm94RW5kQ29uZGl0aW9uXyhtYXBCcm93c2VyRXZlbnQsIHRoaXMuc3RhcnRQaXhlbF8sIG1hcEJyb3dzZXJFdmVudC5waXhlbCkpIHtcbiAgICAgIHRoaXMub25Cb3hFbmRfKG1hcEJyb3dzZXJFdmVudCk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IERyYWdCb3hFdmVudChEcmFnQm94RXZlbnRUeXBlLkJPWEVORCxcbiAgICAgICAgbWFwQnJvd3NlckV2ZW50LmNvb3JkaW5hdGUsIG1hcEJyb3dzZXJFdmVudCkpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBEcmFnQm94LnByb3RvdHlwZS5oYW5kbGVEb3duRXZlbnQgPSBmdW5jdGlvbiBoYW5kbGVEb3duRXZlbnQgKG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGlmICghbW91c2VPbmx5KG1hcEJyb3dzZXJFdmVudCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAobW91c2VBY3Rpb25CdXR0b24obWFwQnJvd3NlckV2ZW50KSAmJlxuICAgICAgICB0aGlzLmNvbmRpdGlvbl8obWFwQnJvd3NlckV2ZW50KSkge1xuICAgICAgdGhpcy5zdGFydFBpeGVsXyA9IG1hcEJyb3dzZXJFdmVudC5waXhlbDtcbiAgICAgIHRoaXMuYm94Xy5zZXRNYXAobWFwQnJvd3NlckV2ZW50Lm1hcCk7XG4gICAgICB0aGlzLmJveF8uc2V0UGl4ZWxzKHRoaXMuc3RhcnRQaXhlbF8sIHRoaXMuc3RhcnRQaXhlbF8pO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBEcmFnQm94RXZlbnQoRHJhZ0JveEV2ZW50VHlwZS5CT1hTVEFSVCxcbiAgICAgICAgbWFwQnJvd3NlckV2ZW50LmNvb3JkaW5hdGUsIG1hcEJyb3dzZXJFdmVudCkpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIERyYWdCb3g7XG59KFBvaW50ZXJJbnRlcmFjdGlvbikpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IERyYWdCb3g7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURyYWdCb3guanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL0RyYWdQYW5cbiAqL1xuaW1wb3J0IFZpZXdIaW50IGZyb20gJy4uL1ZpZXdIaW50LmpzJztcbmltcG9ydCB7c2NhbGUgYXMgc2NhbGVDb29yZGluYXRlLCByb3RhdGUgYXMgcm90YXRlQ29vcmRpbmF0ZSwgYWRkIGFzIGFkZENvb3JkaW5hdGV9IGZyb20gJy4uL2Nvb3JkaW5hdGUuanMnO1xuaW1wb3J0IHtlYXNlT3V0fSBmcm9tICcuLi9lYXNpbmcuanMnO1xuaW1wb3J0IHtub01vZGlmaWVyS2V5c30gZnJvbSAnLi4vZXZlbnRzL2NvbmRpdGlvbi5qcyc7XG5pbXBvcnQge0ZBTFNFfSBmcm9tICcuLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IFBvaW50ZXJJbnRlcmFjdGlvbiwge2NlbnRyb2lkIGFzIGNlbnRyb2lkRnJvbVBvaW50ZXJzfSBmcm9tICcuL1BvaW50ZXIuanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn0gW2NvbmRpdGlvbl0gQSBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0gYW5kIHJldHVybnMgYSBib29sZWFuXG4gKiB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoYXQgZXZlbnQgc2hvdWxkIGJlIGhhbmRsZWQuXG4gKiBEZWZhdWx0IGlzIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbn5ub01vZGlmaWVyS2V5c30uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL0tpbmV0aWMuanNcIikuZGVmYXVsdH0gW2tpbmV0aWNdIEtpbmV0aWMgaW5lcnRpYSB0byBhcHBseSB0byB0aGUgcGFuLlxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBbGxvd3MgdGhlIHVzZXIgdG8gcGFuIHRoZSBtYXAgYnkgZHJhZ2dpbmcgdGhlIG1hcC5cbiAqIEBhcGlcbiAqL1xudmFyIERyYWdQYW4gPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChQb2ludGVySW50ZXJhY3Rpb24pIHtcbiAgZnVuY3Rpb24gRHJhZ1BhbihvcHRfb3B0aW9ucykge1xuXG4gICAgUG9pbnRlckludGVyYWN0aW9uLmNhbGwodGhpcywge1xuICAgICAgc3RvcERvd246IEZBTFNFXG4gICAgfSk7XG5cbiAgICB2YXIgb3B0aW9ucyA9IG9wdF9vcHRpb25zID8gb3B0X29wdGlvbnMgOiB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL0tpbmV0aWMuanNcIikuZGVmYXVsdHx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5raW5ldGljXyA9IG9wdGlvbnMua2luZXRpYztcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9waXhlbC5qc1wiKS5QaXhlbH1cbiAgICAgKi9cbiAgICB0aGlzLmxhc3RDZW50cm9pZCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGFzdFBvaW50ZXJzQ291bnRfO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5wYW5uaW5nXyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259XG4gICAgICovXG4gICAgdGhpcy5jb25kaXRpb25fID0gb3B0aW9ucy5jb25kaXRpb24gPyBvcHRpb25zLmNvbmRpdGlvbiA6IG5vTW9kaWZpZXJLZXlzO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLm5vS2luZXRpY18gPSBmYWxzZTtcblxuICB9XG5cbiAgaWYgKCBQb2ludGVySW50ZXJhY3Rpb24gKSBEcmFnUGFuLl9fcHJvdG9fXyA9IFBvaW50ZXJJbnRlcmFjdGlvbjtcbiAgRHJhZ1Bhbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQb2ludGVySW50ZXJhY3Rpb24gJiYgUG9pbnRlckludGVyYWN0aW9uLnByb3RvdHlwZSApO1xuICBEcmFnUGFuLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERyYWdQYW47XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBEcmFnUGFuLnByb3RvdHlwZS5oYW5kbGVEcmFnRXZlbnQgPSBmdW5jdGlvbiBoYW5kbGVEcmFnRXZlbnQgKG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGlmICghdGhpcy5wYW5uaW5nXykge1xuICAgICAgdGhpcy5wYW5uaW5nXyA9IHRydWU7XG4gICAgICB0aGlzLmdldE1hcCgpLmdldFZpZXcoKS5zZXRIaW50KFZpZXdIaW50LklOVEVSQUNUSU5HLCAxKTtcbiAgICB9XG4gICAgdmFyIHRhcmdldFBvaW50ZXJzID0gdGhpcy50YXJnZXRQb2ludGVycztcbiAgICB2YXIgY2VudHJvaWQgPSBjZW50cm9pZEZyb21Qb2ludGVycyh0YXJnZXRQb2ludGVycyk7XG4gICAgaWYgKHRhcmdldFBvaW50ZXJzLmxlbmd0aCA9PSB0aGlzLmxhc3RQb2ludGVyc0NvdW50Xykge1xuICAgICAgaWYgKHRoaXMua2luZXRpY18pIHtcbiAgICAgICAgdGhpcy5raW5ldGljXy51cGRhdGUoY2VudHJvaWRbMF0sIGNlbnRyb2lkWzFdKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmxhc3RDZW50cm9pZCkge1xuICAgICAgICB2YXIgZGVsdGFYID0gdGhpcy5sYXN0Q2VudHJvaWRbMF0gLSBjZW50cm9pZFswXTtcbiAgICAgICAgdmFyIGRlbHRhWSA9IGNlbnRyb2lkWzFdIC0gdGhpcy5sYXN0Q2VudHJvaWRbMV07XG4gICAgICAgIHZhciBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuICAgICAgICB2YXIgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgICAgIHZhciBjZW50ZXIgPSBbZGVsdGFYLCBkZWx0YVldO1xuICAgICAgICBzY2FsZUNvb3JkaW5hdGUoY2VudGVyLCB2aWV3LmdldFJlc29sdXRpb24oKSk7XG4gICAgICAgIHJvdGF0ZUNvb3JkaW5hdGUoY2VudGVyLCB2aWV3LmdldFJvdGF0aW9uKCkpO1xuICAgICAgICBhZGRDb29yZGluYXRlKGNlbnRlciwgdmlldy5nZXRDZW50ZXIoKSk7XG4gICAgICAgIGNlbnRlciA9IHZpZXcuY29uc3RyYWluQ2VudGVyKGNlbnRlcik7XG4gICAgICAgIHZpZXcuc2V0Q2VudGVyKGNlbnRlcik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmtpbmV0aWNfKSB7XG4gICAgICAvLyByZXNldCBzbyB3ZSBkb24ndCBvdmVyZXN0aW1hdGUgdGhlIGtpbmV0aWMgZW5lcmd5IGFmdGVyXG4gICAgICAvLyBhZnRlciBvbmUgZmluZ2VyIGRvd24sIHRpbnkgZHJhZywgc2Vjb25kIGZpbmdlciBkb3duXG4gICAgICB0aGlzLmtpbmV0aWNfLmJlZ2luKCk7XG4gICAgfVxuICAgIHRoaXMubGFzdENlbnRyb2lkID0gY2VudHJvaWQ7XG4gICAgdGhpcy5sYXN0UG9pbnRlcnNDb3VudF8gPSB0YXJnZXRQb2ludGVycy5sZW5ndGg7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBEcmFnUGFuLnByb3RvdHlwZS5oYW5kbGVVcEV2ZW50ID0gZnVuY3Rpb24gaGFuZGxlVXBFdmVudCAobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgdmFyIG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgdmFyIHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgIGlmICh0aGlzLnRhcmdldFBvaW50ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKCF0aGlzLm5vS2luZXRpY18gJiYgdGhpcy5raW5ldGljXyAmJiB0aGlzLmtpbmV0aWNfLmVuZCgpKSB7XG4gICAgICAgIHZhciBkaXN0YW5jZSA9IHRoaXMua2luZXRpY18uZ2V0RGlzdGFuY2UoKTtcbiAgICAgICAgdmFyIGFuZ2xlID0gdGhpcy5raW5ldGljXy5nZXRBbmdsZSgpO1xuICAgICAgICB2YXIgY2VudGVyID0gLyoqIEB0eXBlIHshaW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSAqLyAodmlldy5nZXRDZW50ZXIoKSk7XG4gICAgICAgIHZhciBjZW50ZXJweCA9IG1hcC5nZXRQaXhlbEZyb21Db29yZGluYXRlKGNlbnRlcik7XG4gICAgICAgIHZhciBkZXN0ID0gbWFwLmdldENvb3JkaW5hdGVGcm9tUGl4ZWwoW1xuICAgICAgICAgIGNlbnRlcnB4WzBdIC0gZGlzdGFuY2UgKiBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgICAgY2VudGVycHhbMV0gLSBkaXN0YW5jZSAqIE1hdGguc2luKGFuZ2xlKVxuICAgICAgICBdKTtcbiAgICAgICAgdmlldy5hbmltYXRlKHtcbiAgICAgICAgICBjZW50ZXI6IHZpZXcuY29uc3RyYWluQ2VudGVyKGRlc3QpLFxuICAgICAgICAgIGR1cmF0aW9uOiA1MDAsXG4gICAgICAgICAgZWFzaW5nOiBlYXNlT3V0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucGFubmluZ18pIHtcbiAgICAgICAgdGhpcy5wYW5uaW5nXyA9IGZhbHNlO1xuICAgICAgICB2aWV3LnNldEhpbnQoVmlld0hpbnQuSU5URVJBQ1RJTkcsIC0xKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMua2luZXRpY18pIHtcbiAgICAgICAgLy8gcmVzZXQgc28gd2UgZG9uJ3Qgb3ZlcmVzdGltYXRlIHRoZSBraW5ldGljIGVuZXJneSBhZnRlclxuICAgICAgICAvLyBhZnRlciBvbmUgZmluZ2VyIHVwLCB0aW55IGRyYWcsIHNlY29uZCBmaW5nZXIgdXBcbiAgICAgICAgdGhpcy5raW5ldGljXy5iZWdpbigpO1xuICAgICAgfVxuICAgICAgdGhpcy5sYXN0Q2VudHJvaWQgPSBudWxsO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgRHJhZ1Bhbi5wcm90b3R5cGUuaGFuZGxlRG93bkV2ZW50ID0gZnVuY3Rpb24gaGFuZGxlRG93bkV2ZW50IChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBpZiAodGhpcy50YXJnZXRQb2ludGVycy5sZW5ndGggPiAwICYmIHRoaXMuY29uZGl0aW9uXyhtYXBCcm93c2VyRXZlbnQpKSB7XG4gICAgICB2YXIgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgICAgIHZhciB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICAgIHRoaXMubGFzdENlbnRyb2lkID0gbnVsbDtcbiAgICAgIC8vIHN0b3AgYW55IGN1cnJlbnQgYW5pbWF0aW9uXG4gICAgICBpZiAodmlldy5nZXRBbmltYXRpbmcoKSkge1xuICAgICAgICB2aWV3LnNldENlbnRlcihtYXBCcm93c2VyRXZlbnQuZnJhbWVTdGF0ZS52aWV3U3RhdGUuY2VudGVyKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmtpbmV0aWNfKSB7XG4gICAgICAgIHRoaXMua2luZXRpY18uYmVnaW4oKTtcbiAgICAgIH1cbiAgICAgIC8vIE5vIGtpbmV0aWMgYXMgc29vbiBhcyBtb3JlIHRoYW4gb25lIHBvaW50ZXIgb24gdGhlIHNjcmVlbiBpc1xuICAgICAgLy8gZGV0ZWN0ZWQuIFRoaXMgaXMgdG8gcHJldmVudCBuYXN0eSBwYW5zIGFmdGVyIHBpbmNoLlxuICAgICAgdGhpcy5ub0tpbmV0aWNfID0gdGhpcy50YXJnZXRQb2ludGVycy5sZW5ndGggPiAxO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIERyYWdQYW47XG59KFBvaW50ZXJJbnRlcmFjdGlvbikpO1xuXG5leHBvcnQgZGVmYXVsdCBEcmFnUGFuO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1EcmFnUGFuLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9EcmFnUm90YXRlXG4gKi9cbmltcG9ydCB7ZGlzYWJsZX0gZnJvbSAnLi4vcm90YXRpb25jb25zdHJhaW50LmpzJztcbmltcG9ydCBWaWV3SGludCBmcm9tICcuLi9WaWV3SGludC5qcyc7XG5pbXBvcnQge2FsdFNoaWZ0S2V5c09ubHksIG1vdXNlT25seSwgbW91c2VBY3Rpb25CdXR0b259IGZyb20gJy4uL2V2ZW50cy9jb25kaXRpb24uanMnO1xuaW1wb3J0IHtGQUxTRX0gZnJvbSAnLi4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCB7cm90YXRlLCByb3RhdGVXaXRob3V0Q29uc3RyYWludHN9IGZyb20gJy4vSW50ZXJhY3Rpb24uanMnO1xuaW1wb3J0IFBvaW50ZXJJbnRlcmFjdGlvbiBmcm9tICcuL1BvaW50ZXIuanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn0gW2NvbmRpdGlvbl0gQSBmdW5jdGlvbiB0aGF0IHRha2VzIGFuXG4gKiB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnR9IGFuZCByZXR1cm5zIGEgYm9vbGVhblxuICogdG8gaW5kaWNhdGUgd2hldGhlciB0aGF0IGV2ZW50IHNob3VsZCBiZSBoYW5kbGVkLlxuICogRGVmYXVsdCBpcyB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb25+YWx0U2hpZnRLZXlzT25seX0uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2R1cmF0aW9uPTI1MF0gQW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWxsb3dzIHRoZSB1c2VyIHRvIHJvdGF0ZSB0aGUgbWFwIGJ5IGNsaWNraW5nIGFuZCBkcmFnZ2luZyBvbiB0aGUgbWFwLFxuICogbm9ybWFsbHkgY29tYmluZWQgd2l0aCBhbiB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb259IHRoYXQgbGltaXRzXG4gKiBpdCB0byB3aGVuIHRoZSBhbHQgYW5kIHNoaWZ0IGtleXMgYXJlIGhlbGQgZG93bi5cbiAqXG4gKiBUaGlzIGludGVyYWN0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBtb3VzZSBkZXZpY2VzLlxuICogQGFwaVxuICovXG52YXIgRHJhZ1JvdGF0ZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFBvaW50ZXJJbnRlcmFjdGlvbikge1xuICBmdW5jdGlvbiBEcmFnUm90YXRlKG9wdF9vcHRpb25zKSB7XG5cbiAgICB2YXIgb3B0aW9ucyA9IG9wdF9vcHRpb25zID8gb3B0X29wdGlvbnMgOiB7fTtcblxuICAgIFBvaW50ZXJJbnRlcmFjdGlvbi5jYWxsKHRoaXMsIHtcbiAgICAgIHN0b3BEb3duOiBGQUxTRVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259XG4gICAgICovXG4gICAgdGhpcy5jb25kaXRpb25fID0gb3B0aW9ucy5jb25kaXRpb24gPyBvcHRpb25zLmNvbmRpdGlvbiA6IGFsdFNoaWZ0S2V5c09ubHk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMubGFzdEFuZ2xlXyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmR1cmF0aW9uXyA9IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiAyNTA7XG5cbiAgfVxuXG4gIGlmICggUG9pbnRlckludGVyYWN0aW9uICkgRHJhZ1JvdGF0ZS5fX3Byb3RvX18gPSBQb2ludGVySW50ZXJhY3Rpb247XG4gIERyYWdSb3RhdGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUG9pbnRlckludGVyYWN0aW9uICYmIFBvaW50ZXJJbnRlcmFjdGlvbi5wcm90b3R5cGUgKTtcbiAgRHJhZ1JvdGF0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEcmFnUm90YXRlO1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgRHJhZ1JvdGF0ZS5wcm90b3R5cGUuaGFuZGxlRHJhZ0V2ZW50ID0gZnVuY3Rpb24gaGFuZGxlRHJhZ0V2ZW50IChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBpZiAoIW1vdXNlT25seShtYXBCcm93c2VyRXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgdmFyIHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgIGlmICh2aWV3LmdldENvbnN0cmFpbnRzKCkucm90YXRpb24gPT09IGRpc2FibGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHNpemUgPSBtYXAuZ2V0U2l6ZSgpO1xuICAgIHZhciBvZmZzZXQgPSBtYXBCcm93c2VyRXZlbnQucGl4ZWw7XG4gICAgdmFyIHRoZXRhID1cbiAgICAgICAgTWF0aC5hdGFuMihzaXplWzFdIC8gMiAtIG9mZnNldFsxXSwgb2Zmc2V0WzBdIC0gc2l6ZVswXSAvIDIpO1xuICAgIGlmICh0aGlzLmxhc3RBbmdsZV8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGRlbHRhID0gdGhldGEgLSB0aGlzLmxhc3RBbmdsZV87XG4gICAgICB2YXIgcm90YXRpb24gPSB2aWV3LmdldFJvdGF0aW9uKCk7XG4gICAgICByb3RhdGVXaXRob3V0Q29uc3RyYWludHModmlldywgcm90YXRpb24gLSBkZWx0YSk7XG4gICAgfVxuICAgIHRoaXMubGFzdEFuZ2xlXyA9IHRoZXRhO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBEcmFnUm90YXRlLnByb3RvdHlwZS5oYW5kbGVVcEV2ZW50ID0gZnVuY3Rpb24gaGFuZGxlVXBFdmVudCAobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKCFtb3VzZU9ubHkobWFwQnJvd3NlckV2ZW50KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgdmFyIHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgIHZpZXcuc2V0SGludChWaWV3SGludC5JTlRFUkFDVElORywgLTEpO1xuICAgIHZhciByb3RhdGlvbiA9IHZpZXcuZ2V0Um90YXRpb24oKTtcbiAgICByb3RhdGUodmlldywgcm90YXRpb24sIHVuZGVmaW5lZCwgdGhpcy5kdXJhdGlvbl8pO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgRHJhZ1JvdGF0ZS5wcm90b3R5cGUuaGFuZGxlRG93bkV2ZW50ID0gZnVuY3Rpb24gaGFuZGxlRG93bkV2ZW50IChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBpZiAoIW1vdXNlT25seShtYXBCcm93c2VyRXZlbnQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG1vdXNlQWN0aW9uQnV0dG9uKG1hcEJyb3dzZXJFdmVudCkgJiYgdGhpcy5jb25kaXRpb25fKG1hcEJyb3dzZXJFdmVudCkpIHtcbiAgICAgIHZhciBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuICAgICAgbWFwLmdldFZpZXcoKS5zZXRIaW50KFZpZXdIaW50LklOVEVSQUNUSU5HLCAxKTtcbiAgICAgIHRoaXMubGFzdEFuZ2xlXyA9IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBEcmFnUm90YXRlO1xufShQb2ludGVySW50ZXJhY3Rpb24pKTtcblxuZXhwb3J0IGRlZmF1bHQgRHJhZ1JvdGF0ZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RHJhZ1JvdGF0ZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vRHJhZ1JvdGF0ZUFuZFpvb21cbiAqL1xuaW1wb3J0IHtkaXNhYmxlfSBmcm9tICcuLi9yb3RhdGlvbmNvbnN0cmFpbnQuanMnO1xuaW1wb3J0IFZpZXdIaW50IGZyb20gJy4uL1ZpZXdIaW50LmpzJztcbmltcG9ydCB7c2hpZnRLZXlPbmx5LCBtb3VzZU9ubHl9IGZyb20gJy4uL2V2ZW50cy9jb25kaXRpb24uanMnO1xuaW1wb3J0IHtyb3RhdGUsIHJvdGF0ZVdpdGhvdXRDb25zdHJhaW50cywgem9vbSwgem9vbVdpdGhvdXRDb25zdHJhaW50c30gZnJvbSAnLi9JbnRlcmFjdGlvbi5qcyc7XG5pbXBvcnQgUG9pbnRlckludGVyYWN0aW9uIGZyb20gJy4vUG9pbnRlci5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufSBbY29uZGl0aW9uXSBBIGZ1bmN0aW9uIHRoYXRcbiAqIHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0gYW5kIHJldHVybnMgYVxuICogYm9vbGVhbiB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoYXQgZXZlbnQgc2hvdWxkIGJlIGhhbmRsZWQuXG4gKiBEZWZhdWx0IGlzIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbn5zaGlmdEtleU9ubHl9LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkdXJhdGlvbj00MDBdIEFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFsbG93cyB0aGUgdXNlciB0byB6b29tIGFuZCByb3RhdGUgdGhlIG1hcCBieSBjbGlja2luZyBhbmQgZHJhZ2dpbmdcbiAqIG9uIHRoZSBtYXAuICBCeSBkZWZhdWx0LCB0aGlzIGludGVyYWN0aW9uIGlzIGxpbWl0ZWQgdG8gd2hlbiB0aGUgc2hpZnRcbiAqIGtleSBpcyBoZWxkIGRvd24uXG4gKlxuICogVGhpcyBpbnRlcmFjdGlvbiBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgbW91c2UgZGV2aWNlcy5cbiAqXG4gKiBBbmQgdGhpcyBpbnRlcmFjdGlvbiBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIGRlZmF1bHQgaW50ZXJhY3Rpb25zLlxuICogQGFwaVxuICovXG52YXIgRHJhZ1JvdGF0ZUFuZFpvb20gPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChQb2ludGVySW50ZXJhY3Rpb24pIHtcbiAgZnVuY3Rpb24gRHJhZ1JvdGF0ZUFuZFpvb20ob3B0X29wdGlvbnMpIHtcblxuICAgIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgPyBvcHRfb3B0aW9ucyA6IHt9O1xuXG4gICAgUG9pbnRlckludGVyYWN0aW9uLmNhbGwoLyoqIEB0eXBlIHtpbXBvcnQoXCIuL1BvaW50ZXIuanNcIikuT3B0aW9uc30gKi8gdGhpcywgKG9wdGlvbnMpKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuY29uZGl0aW9uXyA9IG9wdGlvbnMuY29uZGl0aW9uID8gb3B0aW9ucy5jb25kaXRpb24gOiBzaGlmdEtleU9ubHk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMubGFzdEFuZ2xlXyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5sYXN0TWFnbml0dWRlXyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxhc3RTY2FsZURlbHRhXyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kdXJhdGlvbl8gPSBvcHRpb25zLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmR1cmF0aW9uIDogNDAwO1xuXG4gIH1cblxuICBpZiAoIFBvaW50ZXJJbnRlcmFjdGlvbiApIERyYWdSb3RhdGVBbmRab29tLl9fcHJvdG9fXyA9IFBvaW50ZXJJbnRlcmFjdGlvbjtcbiAgRHJhZ1JvdGF0ZUFuZFpvb20ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUG9pbnRlckludGVyYWN0aW9uICYmIFBvaW50ZXJJbnRlcmFjdGlvbi5wcm90b3R5cGUgKTtcbiAgRHJhZ1JvdGF0ZUFuZFpvb20ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRHJhZ1JvdGF0ZUFuZFpvb207XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBEcmFnUm90YXRlQW5kWm9vbS5wcm90b3R5cGUuaGFuZGxlRHJhZ0V2ZW50ID0gZnVuY3Rpb24gaGFuZGxlRHJhZ0V2ZW50IChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBpZiAoIW1vdXNlT25seShtYXBCcm93c2VyRXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgdmFyIHNpemUgPSBtYXAuZ2V0U2l6ZSgpO1xuICAgIHZhciBvZmZzZXQgPSBtYXBCcm93c2VyRXZlbnQucGl4ZWw7XG4gICAgdmFyIGRlbHRhWCA9IG9mZnNldFswXSAtIHNpemVbMF0gLyAyO1xuICAgIHZhciBkZWx0YVkgPSBzaXplWzFdIC8gMiAtIG9mZnNldFsxXTtcbiAgICB2YXIgdGhldGEgPSBNYXRoLmF0YW4yKGRlbHRhWSwgZGVsdGFYKTtcbiAgICB2YXIgbWFnbml0dWRlID0gTWF0aC5zcXJ0KGRlbHRhWCAqIGRlbHRhWCArIGRlbHRhWSAqIGRlbHRhWSk7XG4gICAgdmFyIHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgIGlmICh2aWV3LmdldENvbnN0cmFpbnRzKCkucm90YXRpb24gIT09IGRpc2FibGUgJiYgdGhpcy5sYXN0QW5nbGVfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBhbmdsZURlbHRhID0gdGhldGEgLSB0aGlzLmxhc3RBbmdsZV87XG4gICAgICByb3RhdGVXaXRob3V0Q29uc3RyYWludHModmlldywgdmlldy5nZXRSb3RhdGlvbigpIC0gYW5nbGVEZWx0YSk7XG4gICAgfVxuICAgIHRoaXMubGFzdEFuZ2xlXyA9IHRoZXRhO1xuICAgIGlmICh0aGlzLmxhc3RNYWduaXR1ZGVfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciByZXNvbHV0aW9uID0gdGhpcy5sYXN0TWFnbml0dWRlXyAqICh2aWV3LmdldFJlc29sdXRpb24oKSAvIG1hZ25pdHVkZSk7XG4gICAgICB6b29tV2l0aG91dENvbnN0cmFpbnRzKHZpZXcsIHJlc29sdXRpb24pO1xuICAgIH1cbiAgICBpZiAodGhpcy5sYXN0TWFnbml0dWRlXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmxhc3RTY2FsZURlbHRhXyA9IHRoaXMubGFzdE1hZ25pdHVkZV8gLyBtYWduaXR1ZGU7XG4gICAgfVxuICAgIHRoaXMubGFzdE1hZ25pdHVkZV8gPSBtYWduaXR1ZGU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBEcmFnUm90YXRlQW5kWm9vbS5wcm90b3R5cGUuaGFuZGxlVXBFdmVudCA9IGZ1bmN0aW9uIGhhbmRsZVVwRXZlbnQgKG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGlmICghbW91c2VPbmx5KG1hcEJyb3dzZXJFdmVudCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuICAgIHZhciB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICB2aWV3LnNldEhpbnQoVmlld0hpbnQuSU5URVJBQ1RJTkcsIC0xKTtcbiAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5sYXN0U2NhbGVEZWx0YV8gLSAxO1xuICAgIHJvdGF0ZSh2aWV3LCB2aWV3LmdldFJvdGF0aW9uKCkpO1xuICAgIHpvb20odmlldywgdmlldy5nZXRSZXNvbHV0aW9uKCksIHVuZGVmaW5lZCwgdGhpcy5kdXJhdGlvbl8sIGRpcmVjdGlvbik7XG4gICAgdGhpcy5sYXN0U2NhbGVEZWx0YV8gPSAwO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIERyYWdSb3RhdGVBbmRab29tLnByb3RvdHlwZS5oYW5kbGVEb3duRXZlbnQgPSBmdW5jdGlvbiBoYW5kbGVEb3duRXZlbnQgKG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGlmICghbW91c2VPbmx5KG1hcEJyb3dzZXJFdmVudCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jb25kaXRpb25fKG1hcEJyb3dzZXJFdmVudCkpIHtcbiAgICAgIG1hcEJyb3dzZXJFdmVudC5tYXAuZ2V0VmlldygpLnNldEhpbnQoVmlld0hpbnQuSU5URVJBQ1RJTkcsIDEpO1xuICAgICAgdGhpcy5sYXN0QW5nbGVfID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5sYXN0TWFnbml0dWRlXyA9IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBEcmFnUm90YXRlQW5kWm9vbTtcbn0oUG9pbnRlckludGVyYWN0aW9uKSk7XG5cbmV4cG9ydCBkZWZhdWx0IERyYWdSb3RhdGVBbmRab29tO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1EcmFnUm90YXRlQW5kWm9vbS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vRHJhZ1pvb21cbiAqL1xuaW1wb3J0IHtlYXNlT3V0fSBmcm9tICcuLi9lYXNpbmcuanMnO1xuaW1wb3J0IHtzaGlmdEtleU9ubHl9IGZyb20gJy4uL2V2ZW50cy9jb25kaXRpb24uanMnO1xuaW1wb3J0IHtjcmVhdGVPclVwZGF0ZUZyb21Db29yZGluYXRlcywgZ2V0Qm90dG9tTGVmdCwgZ2V0Q2VudGVyLCBnZXRUb3BSaWdodCwgc2NhbGVGcm9tQ2VudGVyfSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IERyYWdCb3ggZnJvbSAnLi9EcmFnQm94LmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3NOYW1lPSdvbC1kcmFnem9vbSddIENTUyBjbGFzcyBuYW1lIGZvciBzdHlsaW5nIHRoZVxuICogYm94LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn0gW2NvbmRpdGlvbl0gQSBmdW5jdGlvbiB0aGF0XG4gKiB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnR9IGFuZCByZXR1cm5zIGFcbiAqIGJvb2xlYW4gdG8gaW5kaWNhdGUgd2hldGhlciB0aGF0IGV2ZW50IHNob3VsZCBiZSBoYW5kbGVkLlxuICogRGVmYXVsdCBpcyB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb25+c2hpZnRLZXlPbmx5fS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHVyYXRpb249MjAwXSBBbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbb3V0PWZhbHNlXSBVc2UgaW50ZXJhY3Rpb24gZm9yIHpvb21pbmcgb3V0LlxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBbGxvd3MgdGhlIHVzZXIgdG8gem9vbSB0aGUgbWFwIGJ5IGNsaWNraW5nIGFuZCBkcmFnZ2luZyBvbiB0aGUgbWFwLFxuICogbm9ybWFsbHkgY29tYmluZWQgd2l0aCBhbiB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb259IHRoYXQgbGltaXRzXG4gKiBpdCB0byB3aGVuIGEga2V5LCBzaGlmdCBieSBkZWZhdWx0LCBpcyBoZWxkIGRvd24uXG4gKlxuICogVG8gY2hhbmdlIHRoZSBzdHlsZSBvZiB0aGUgYm94LCB1c2UgQ1NTIGFuZCB0aGUgYC5vbC1kcmFnem9vbWAgc2VsZWN0b3IsIG9yXG4gKiB5b3VyIGN1c3RvbSBvbmUgY29uZmlndXJlZCB3aXRoIGBjbGFzc05hbWVgLlxuICogQGFwaVxuICovXG52YXIgRHJhZ1pvb20gPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChEcmFnQm94KSB7XG4gIGZ1bmN0aW9uIERyYWdab29tKG9wdF9vcHRpb25zKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRfb3B0aW9ucyA/IG9wdF9vcHRpb25zIDoge307XG5cbiAgICB2YXIgY29uZGl0aW9uID0gb3B0aW9ucy5jb25kaXRpb24gPyBvcHRpb25zLmNvbmRpdGlvbiA6IHNoaWZ0S2V5T25seTtcblxuICAgIERyYWdCb3guY2FsbCh0aGlzLCB7XG4gICAgICBjb25kaXRpb246IGNvbmRpdGlvbixcbiAgICAgIGNsYXNzTmFtZTogb3B0aW9ucy5jbGFzc05hbWUgfHwgJ29sLWRyYWd6b29tJyxcbiAgICAgIG9uQm94RW5kOiBvbkJveEVuZFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZHVyYXRpb25fID0gb3B0aW9ucy5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kdXJhdGlvbiA6IDIwMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5vdXRfID0gb3B0aW9ucy5vdXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMub3V0IDogZmFsc2U7XG4gIH1cblxuICBpZiAoIERyYWdCb3ggKSBEcmFnWm9vbS5fX3Byb3RvX18gPSBEcmFnQm94O1xuICBEcmFnWm9vbS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBEcmFnQm94ICYmIERyYWdCb3gucHJvdG90eXBlICk7XG4gIERyYWdab29tLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERyYWdab29tO1xuXG4gIHJldHVybiBEcmFnWm9vbTtcbn0oRHJhZ0JveCkpO1xuXG5cbi8qKlxuICogQHRoaXMge0RyYWdab29tfVxuICovXG5mdW5jdGlvbiBvbkJveEVuZCgpIHtcbiAgdmFyIG1hcCA9IHRoaXMuZ2V0TWFwKCk7XG4gIHZhciB2aWV3ID0gLyoqIEB0eXBlIHshaW1wb3J0KFwiLi4vVmlldy5qc1wiKS5kZWZhdWx0fSAqLyAobWFwLmdldFZpZXcoKSk7XG4gIHZhciBzaXplID0gLyoqIEB0eXBlIHshaW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSAqLyAobWFwLmdldFNpemUoKSk7XG4gIHZhciBleHRlbnQgPSB0aGlzLmdldEdlb21ldHJ5KCkuZ2V0RXh0ZW50KCk7XG5cbiAgaWYgKHRoaXMub3V0Xykge1xuICAgIHZhciBtYXBFeHRlbnQgPSB2aWV3LmNhbGN1bGF0ZUV4dGVudChzaXplKTtcbiAgICB2YXIgYm94UGl4ZWxFeHRlbnQgPSBjcmVhdGVPclVwZGF0ZUZyb21Db29yZGluYXRlcyhbXG4gICAgICBtYXAuZ2V0UGl4ZWxGcm9tQ29vcmRpbmF0ZShnZXRCb3R0b21MZWZ0KGV4dGVudCkpLFxuICAgICAgbWFwLmdldFBpeGVsRnJvbUNvb3JkaW5hdGUoZ2V0VG9wUmlnaHQoZXh0ZW50KSldKTtcbiAgICB2YXIgZmFjdG9yID0gdmlldy5nZXRSZXNvbHV0aW9uRm9yRXh0ZW50KGJveFBpeGVsRXh0ZW50LCBzaXplKTtcblxuICAgIHNjYWxlRnJvbUNlbnRlcihtYXBFeHRlbnQsIDEgLyBmYWN0b3IpO1xuICAgIGV4dGVudCA9IG1hcEV4dGVudDtcbiAgfVxuXG4gIHZhciByZXNvbHV0aW9uID0gdmlldy5jb25zdHJhaW5SZXNvbHV0aW9uKFxuICAgIHZpZXcuZ2V0UmVzb2x1dGlvbkZvckV4dGVudChleHRlbnQsIHNpemUpKTtcblxuICB2YXIgY2VudGVyID0gZ2V0Q2VudGVyKGV4dGVudCk7XG4gIGNlbnRlciA9IHZpZXcuY29uc3RyYWluQ2VudGVyKGNlbnRlcik7XG5cbiAgdmlldy5hbmltYXRlKHtcbiAgICByZXNvbHV0aW9uOiByZXNvbHV0aW9uLFxuICAgIGNlbnRlcjogY2VudGVyLFxuICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uXyxcbiAgICBlYXNpbmc6IGVhc2VPdXRcbiAgfSk7XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgRHJhZ1pvb207XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURyYWdab29tLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9EcmF3XG4gKi9cbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgRmVhdHVyZSBmcm9tICcuLi9GZWF0dXJlLmpzJztcbmltcG9ydCBNYXBCcm93c2VyRXZlbnRUeXBlIGZyb20gJy4uL01hcEJyb3dzZXJFdmVudFR5cGUuanMnO1xuaW1wb3J0IE1hcEJyb3dzZXJQb2ludGVyRXZlbnQgZnJvbSAnLi4vTWFwQnJvd3NlclBvaW50ZXJFdmVudC5qcyc7XG5pbXBvcnQge2dldENoYW5nZUV2ZW50VHlwZX0gZnJvbSAnLi4vT2JqZWN0LmpzJztcbmltcG9ydCB7c3F1YXJlZERpc3RhbmNlIGFzIHNxdWFyZWRDb29yZGluYXRlRGlzdGFuY2V9IGZyb20gJy4uL2Nvb3JkaW5hdGUuanMnO1xuaW1wb3J0IHtsaXN0ZW59IGZyb20gJy4uL2V2ZW50cy5qcyc7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzL0V2ZW50LmpzJztcbmltcG9ydCB7bm9Nb2RpZmllcktleXMsIGFsd2F5cywgc2hpZnRLZXlPbmx5fSBmcm9tICcuLi9ldmVudHMvY29uZGl0aW9uLmpzJztcbmltcG9ydCB7Ym91bmRpbmdFeHRlbnQsIGdldEJvdHRvbUxlZnQsIGdldEJvdHRvbVJpZ2h0LCBnZXRUb3BMZWZ0LCBnZXRUb3BSaWdodH0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7VFJVRSwgRkFMU0V9IGZyb20gJy4uL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQgQ2lyY2xlIGZyb20gJy4uL2dlb20vQ2lyY2xlLmpzJztcbmltcG9ydCBHZW9tZXRyeVR5cGUgZnJvbSAnLi4vZ2VvbS9HZW9tZXRyeVR5cGUuanMnO1xuaW1wb3J0IExpbmVTdHJpbmcgZnJvbSAnLi4vZ2VvbS9MaW5lU3RyaW5nLmpzJztcbmltcG9ydCBNdWx0aUxpbmVTdHJpbmcgZnJvbSAnLi4vZ2VvbS9NdWx0aUxpbmVTdHJpbmcuanMnO1xuaW1wb3J0IE11bHRpUG9pbnQgZnJvbSAnLi4vZ2VvbS9NdWx0aVBvaW50LmpzJztcbmltcG9ydCBNdWx0aVBvbHlnb24gZnJvbSAnLi4vZ2VvbS9NdWx0aVBvbHlnb24uanMnO1xuaW1wb3J0IHtQT0lOVEVSX1RZUEV9IGZyb20gJy4uL3BvaW50ZXIvTW91c2VTb3VyY2UuanMnO1xuaW1wb3J0IFBvaW50IGZyb20gJy4uL2dlb20vUG9pbnQuanMnO1xuaW1wb3J0IFBvbHlnb24sIHtmcm9tQ2lyY2xlLCBtYWtlUmVndWxhcn0gZnJvbSAnLi4vZ2VvbS9Qb2x5Z29uLmpzJztcbmltcG9ydCBQb2ludGVySW50ZXJhY3Rpb24gZnJvbSAnLi9Qb2ludGVyLmpzJztcbmltcG9ydCBJbnRlcmFjdGlvblByb3BlcnR5IGZyb20gJy4vUHJvcGVydHkuanMnO1xuaW1wb3J0IFZlY3RvckxheWVyIGZyb20gJy4uL2xheWVyL1ZlY3Rvci5qcyc7XG5pbXBvcnQgVmVjdG9yU291cmNlIGZyb20gJy4uL3NvdXJjZS9WZWN0b3IuanMnO1xuaW1wb3J0IHtjcmVhdGVFZGl0aW5nU3R5bGV9IGZyb20gJy4uL3N0eWxlL1N0eWxlLmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7R2VvbWV0cnlUeXBlfSB0eXBlIEdlb21ldHJ5IHR5cGUgb2ZcbiAqIHRoZSBnZW9tZXRyaWVzIGJlaW5nIGRyYXduIHdpdGggdGhpcyBpbnN0YW5jZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY2xpY2tUb2xlcmFuY2U9Nl0gVGhlIG1heGltdW0gZGlzdGFuY2UgaW4gcGl4ZWxzIGJldHdlZW5cbiAqIFwiZG93blwiIGFuZCBcInVwXCIgZm9yIGEgXCJ1cFwiIGV2ZW50IHRvIGJlIGNvbnNpZGVyZWQgYSBcImNsaWNrXCIgZXZlbnQgYW5kXG4gKiBhY3R1YWxseSBhZGQgYSBwb2ludC92ZXJ0ZXggdG8gdGhlIGdlb21ldHJ5IGJlaW5nIGRyYXduLiAgVGhlIGRlZmF1bHQgb2YgYDZgXG4gKiB3YXMgY2hvc2VuIGZvciB0aGUgZHJhdyBpbnRlcmFjdGlvbiB0byBiZWhhdmUgY29ycmVjdGx5IG9uIG1vdXNlIGFzIHdlbGwgYXNcbiAqIG9uIHRvdWNoIGRldmljZXMuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL0NvbGxlY3Rpb24uanNcIikuZGVmYXVsdDxGZWF0dXJlPn0gW2ZlYXR1cmVzXVxuICogRGVzdGluYXRpb24gY29sbGVjdGlvbiBmb3IgdGhlIGRyYXduIGZlYXR1cmVzLlxuICogQHByb3BlcnR5IHtWZWN0b3JTb3VyY2V9IFtzb3VyY2VdIERlc3RpbmF0aW9uIHNvdXJjZSBmb3JcbiAqIHRoZSBkcmF3biBmZWF0dXJlcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHJhZ1ZlcnRleERlbGF5PTUwMF0gRGVsYXkgaW4gbWlsbGlzZWNvbmRzIGFmdGVyIHBvaW50ZXJkb3duXG4gKiBiZWZvcmUgdGhlIGN1cnJlbnQgdmVydGV4IGNhbiBiZSBkcmFnZ2VkIHRvIGl0cyBleGFjdCBwb3NpdGlvbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc25hcFRvbGVyYW5jZT0xMl0gUGl4ZWwgZGlzdGFuY2UgZm9yIHNuYXBwaW5nIHRvIHRoZVxuICogZHJhd2luZyBmaW5pc2guXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtzdG9wQ2xpY2s9ZmFsc2VdIFN0b3AgY2xpY2ssIHNpbmdsZWNsaWNrLCBhbmRcbiAqIGRvdWJsZWNsaWNrIGV2ZW50cyBmcm9tIGZpcmluZyBkdXJpbmcgZHJhd2luZy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4UG9pbnRzXSBUaGUgbnVtYmVyIG9mIHBvaW50cyB0aGF0IGNhbiBiZSBkcmF3biBiZWZvcmVcbiAqIGEgcG9seWdvbiByaW5nIG9yIGxpbmUgc3RyaW5nIGlzIGZpbmlzaGVkLiBCeSBkZWZhdWx0IHRoZXJlIGlzIG5vXG4gKiByZXN0cmljdGlvbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluUG9pbnRzXSBUaGUgbnVtYmVyIG9mIHBvaW50cyB0aGF0IG11c3QgYmUgZHJhd25cbiAqIGJlZm9yZSBhIHBvbHlnb24gcmluZyBvciBsaW5lIHN0cmluZyBjYW4gYmUgZmluaXNoZWQuIERlZmF1bHQgaXMgYDNgIGZvclxuICogcG9seWdvbiByaW5ncyBhbmQgYDJgIGZvciBsaW5lIHN0cmluZ3MuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufSBbZmluaXNoQ29uZGl0aW9uXSBBIGZ1bmN0aW9uXG4gKiB0aGF0IHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0gYW5kIHJldHVybnMgYVxuICogYm9vbGVhbiB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoZSBkcmF3aW5nIGNhbiBiZSBmaW5pc2hlZC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVMaWtlfSBbc3R5bGVdXG4gKiBTdHlsZSBmb3Igc2tldGNoIGZlYXR1cmVzLlxuICogQHByb3BlcnR5IHtHZW9tZXRyeUZ1bmN0aW9ufSBbZ2VvbWV0cnlGdW5jdGlvbl1cbiAqIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gYSBnZW9tZXRyeSdzIGNvb3JkaW5hdGVzIGFyZSB1cGRhdGVkLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtnZW9tZXRyeU5hbWVdIEdlb21ldHJ5IG5hbWUgdG8gdXNlIGZvciBmZWF0dXJlcyBjcmVhdGVkXG4gKiBieSB0aGUgZHJhdyBpbnRlcmFjdGlvbi5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259IFtjb25kaXRpb25dIEEgZnVuY3Rpb24gdGhhdFxuICogdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmQgcmV0dXJucyBhXG4gKiBib29sZWFuIHRvIGluZGljYXRlIHdoZXRoZXIgdGhhdCBldmVudCBzaG91bGQgYmUgaGFuZGxlZC5cbiAqIEJ5IGRlZmF1bHQge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9ufm5vTW9kaWZpZXJLZXlzfSwgaS5lLiBhIGNsaWNrLFxuICogYWRkcyBhIHZlcnRleCBvciBkZWFjdGl2YXRlcyBmcmVlaGFuZCBkcmF3aW5nLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbZnJlZWhhbmQ9ZmFsc2VdIE9wZXJhdGUgaW4gZnJlZWhhbmQgbW9kZSBmb3IgbGluZXMsXG4gKiBwb2x5Z29ucywgYW5kIGNpcmNsZXMuICBUaGlzIG1ha2VzIHRoZSBpbnRlcmFjdGlvbiBhbHdheXMgb3BlcmF0ZSBpbiBmcmVlaGFuZFxuICogbW9kZSBhbmQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGFueSBgZnJlZWhhbmRDb25kaXRpb25gIG9wdGlvbi5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259IFtmcmVlaGFuZENvbmRpdGlvbl1cbiAqIENvbmRpdGlvbiB0aGF0IGFjdGl2YXRlcyBmcmVlaGFuZCBkcmF3aW5nIGZvciBsaW5lcyBhbmQgcG9seWdvbnMuIFRoaXNcbiAqIGZ1bmN0aW9uIHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0gYW5kXG4gKiByZXR1cm5zIGEgYm9vbGVhbiB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoYXQgZXZlbnQgc2hvdWxkIGJlIGhhbmRsZWQuIFRoZVxuICogZGVmYXVsdCBpcyB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb25+c2hpZnRLZXlPbmx5fSwgbWVhbmluZyB0aGF0IHRoZVxuICogU2hpZnQga2V5IGFjdGl2YXRlcyBmcmVlaGFuZCBkcmF3aW5nLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbd3JhcFg9ZmFsc2VdIFdyYXAgdGhlIHdvcmxkIGhvcml6b250YWxseSBvbiB0aGUgc2tldGNoXG4gKiBvdmVybGF5LlxuICovXG5cblxuLyoqXG4gKiBDb29yZGluYXRlIHR5cGUgd2hlbiBkcmF3aW5nIHBvaW50cy5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFBvaW50Q29vcmRUeXBlXG4gKi9cblxuXG4vKipcbiAqIENvb3JkaW5hdGUgdHlwZSB3aGVuIGRyYXdpbmcgbGluZXMuXG4gKiBAdHlwZWRlZiB7QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn0gTGluZUNvb3JkVHlwZVxuICovXG5cblxuLyoqXG4gKiBDb29yZGluYXRlIHR5cGUgd2hlbiBkcmF3aW5nIHBvbHlnb25zLlxuICogQHR5cGVkZWYge0FycmF5PEFycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+fSBQb2x5Q29vcmRUeXBlXG4gKi9cblxuXG4vKipcbiAqIFR5cGVzIHVzZWQgZm9yIGRyYXdpbmcgY29vcmRpbmF0ZXMuXG4gKiBAdHlwZWRlZiB7UG9pbnRDb29yZFR5cGV8TGluZUNvb3JkVHlwZXxQb2x5Q29vcmRUeXBlfSBTa2V0Y2hDb29yZFR5cGVcbiAqL1xuXG5cbi8qKlxuICogRnVuY3Rpb24gdGhhdCB0YWtlcyBhbiBhcnJheSBvZiBjb29yZGluYXRlcyBhbmQgYW4gb3B0aW9uYWwgZXhpc3RpbmcgZ2VvbWV0cnkgYXNcbiAqIGFyZ3VtZW50cywgYW5kIHJldHVybnMgYSBnZW9tZXRyeS4gVGhlIG9wdGlvbmFsIGV4aXN0aW5nIGdlb21ldHJ5IGlzIHRoZVxuICogZ2VvbWV0cnkgdGhhdCBpcyByZXR1cm5lZCB3aGVuIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aG91dCBhIHNlY29uZFxuICogYXJndW1lbnQuXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oIVNrZXRjaENvb3JkVHlwZSwgaW1wb3J0KFwiLi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0PSk6XG4gKiAgICAgaW1wb3J0KFwiLi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSBHZW9tZXRyeUZ1bmN0aW9uXG4gKi9cblxuXG4vKipcbiAqIERyYXcgbW9kZS4gIFRoaXMgY29sbGFwc2VzIG11bHRpLXBhcnQgZ2VvbWV0cnkgdHlwZXMgd2l0aCB0aGVpciBzaW5nbGUtcGFydFxuICogY291c2lucy5cbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbnZhciBNb2RlID0ge1xuICBQT0lOVDogJ1BvaW50JyxcbiAgTElORV9TVFJJTkc6ICdMaW5lU3RyaW5nJyxcbiAgUE9MWUdPTjogJ1BvbHlnb24nLFxuICBDSVJDTEU6ICdDaXJjbGUnXG59O1xuXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xudmFyIERyYXdFdmVudFR5cGUgPSB7XG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgdXBvbiBmZWF0dXJlIGRyYXcgc3RhcnRcbiAgICogQGV2ZW50IERyYXdFdmVudCNkcmF3c3RhcnRcbiAgICogQGFwaVxuICAgKi9cbiAgRFJBV1NUQVJUOiAnZHJhd3N0YXJ0JyxcbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB1cG9uIGZlYXR1cmUgZHJhdyBlbmRcbiAgICogQGV2ZW50IERyYXdFdmVudCNkcmF3ZW5kXG4gICAqIEBhcGlcbiAgICovXG4gIERSQVdFTkQ6ICdkcmF3ZW5kJ1xufTtcblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEV2ZW50cyBlbWl0dGVkIGJ5IHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vRHJhd35EcmF3fSBpbnN0YW5jZXMgYXJlXG4gKiBpbnN0YW5jZXMgb2YgdGhpcyB0eXBlLlxuICovXG52YXIgRHJhd0V2ZW50ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoRXZlbnQpIHtcbiAgZnVuY3Rpb24gRHJhd0V2ZW50KHR5cGUsIGZlYXR1cmUpIHtcblxuICAgIEV2ZW50LmNhbGwodGhpcywgdHlwZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmVhdHVyZSBiZWluZyBkcmF3bi5cbiAgICAgKiBAdHlwZSB7RmVhdHVyZX1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5mZWF0dXJlID0gZmVhdHVyZTtcblxuICB9XG5cbiAgaWYgKCBFdmVudCApIERyYXdFdmVudC5fX3Byb3RvX18gPSBFdmVudDtcbiAgRHJhd0V2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEV2ZW50ICYmIEV2ZW50LnByb3RvdHlwZSApO1xuICBEcmF3RXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRHJhd0V2ZW50O1xuXG4gIHJldHVybiBEcmF3RXZlbnQ7XG59KEV2ZW50KSk7XG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBJbnRlcmFjdGlvbiBmb3IgZHJhd2luZyBmZWF0dXJlIGdlb21ldHJpZXMuXG4gKlxuICogQGZpcmVzIERyYXdFdmVudFxuICogQGFwaVxuICovXG52YXIgRHJhdyA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFBvaW50ZXJJbnRlcmFjdGlvbikge1xuICBmdW5jdGlvbiBEcmF3KG9wdGlvbnMpIHtcblxuICAgIHZhciBwb2ludGVyT3B0aW9ucyA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9Qb2ludGVyLmpzXCIpLk9wdGlvbnN9ICovIChvcHRpb25zKTtcbiAgICBpZiAoIXBvaW50ZXJPcHRpb25zLnN0b3BEb3duKSB7XG4gICAgICBwb2ludGVyT3B0aW9ucy5zdG9wRG93biA9IEZBTFNFO1xuICAgIH1cblxuICAgIFBvaW50ZXJJbnRlcmFjdGlvbi5jYWxsKHRoaXMsIHBvaW50ZXJPcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5zaG91bGRIYW5kbGVfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vcGl4ZWwuanNcIikuUGl4ZWx9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmRvd25QeF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmRvd25UaW1lb3V0XztcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5sYXN0RHJhZ1RpbWVfO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmZyZWVoYW5kXyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGFyZ2V0IHNvdXJjZSBmb3IgZHJhd24gZmVhdHVyZXMuXG4gICAgICogQHR5cGUge1ZlY3RvclNvdXJjZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc291cmNlXyA9IG9wdGlvbnMuc291cmNlID8gb3B0aW9ucy5zb3VyY2UgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGFyZ2V0IGNvbGxlY3Rpb24gZm9yIGRyYXduIGZlYXR1cmVzLlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9Db2xsZWN0aW9uLmpzXCIpLmRlZmF1bHQ8RmVhdHVyZT59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmZlYXR1cmVzXyA9IG9wdGlvbnMuZmVhdHVyZXMgPyBvcHRpb25zLmZlYXR1cmVzIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFBpeGVsIGRpc3RhbmNlIGZvciBzbmFwcGluZy5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5zbmFwVG9sZXJhbmNlXyA9IG9wdGlvbnMuc25hcFRvbGVyYW5jZSA/IG9wdGlvbnMuc25hcFRvbGVyYW5jZSA6IDEyO1xuXG4gICAgLyoqXG4gICAgICogR2VvbWV0cnkgdHlwZS5cbiAgICAgKiBAdHlwZSB7R2VvbWV0cnlUeXBlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy50eXBlXyA9IC8qKiBAdHlwZSB7R2VvbWV0cnlUeXBlfSAqLyAob3B0aW9ucy50eXBlKTtcblxuICAgIC8qKlxuICAgICAqIERyYXdpbmcgbW9kZSAoZGVyaXZlZCBmcm9tIGdlb21ldHJ5IHR5cGUuXG4gICAgICogQHR5cGUge01vZGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLm1vZGVfID0gZ2V0TW9kZSh0aGlzLnR5cGVfKTtcblxuICAgIC8qKlxuICAgICAqIFN0b3AgY2xpY2ssIHNpbmdsZWNsaWNrLCBhbmQgZG91YmxlY2xpY2sgZXZlbnRzIGZyb20gZmlyaW5nIGR1cmluZyBkcmF3aW5nLlxuICAgICAqIERlZmF1bHQgaXMgYGZhbHNlYC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc3RvcENsaWNrXyA9ICEhb3B0aW9ucy5zdG9wQ2xpY2s7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIHBvaW50cyB0aGF0IG11c3QgYmUgZHJhd24gYmVmb3JlIGEgcG9seWdvbiByaW5nIG9yIGxpbmVcbiAgICAgKiBzdHJpbmcgY2FuIGJlIGZpbmlzaGVkLiAgVGhlIGRlZmF1bHQgaXMgMyBmb3IgcG9seWdvbiByaW5ncyBhbmQgMiBmb3JcbiAgICAgKiBsaW5lIHN0cmluZ3MuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubWluUG9pbnRzXyA9IG9wdGlvbnMubWluUG9pbnRzID9cbiAgICAgIG9wdGlvbnMubWluUG9pbnRzIDpcbiAgICAgICh0aGlzLm1vZGVfID09PSBNb2RlLlBPTFlHT04gPyAzIDogMik7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIHBvaW50cyB0aGF0IGNhbiBiZSBkcmF3biBiZWZvcmUgYSBwb2x5Z29uIHJpbmcgb3IgbGluZSBzdHJpbmdcbiAgICAgKiBpcyBmaW5pc2hlZC4gVGhlIGRlZmF1bHQgaXMgbm8gcmVzdHJpY3Rpb24uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubWF4UG9pbnRzXyA9IG9wdGlvbnMubWF4UG9pbnRzID8gb3B0aW9ucy5tYXhQb2ludHMgOiBJbmZpbml0eTtcblxuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gdG8gZGVjaWRlIGlmIGEgcG90ZW50aWFsIGZpbmlzaCBjb29yZGluYXRlIGlzIHBlcm1pc3NpYmxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259XG4gICAgICovXG4gICAgdGhpcy5maW5pc2hDb25kaXRpb25fID0gb3B0aW9ucy5maW5pc2hDb25kaXRpb24gPyBvcHRpb25zLmZpbmlzaENvbmRpdGlvbiA6IFRSVUU7XG5cbiAgICB2YXIgZ2VvbWV0cnlGdW5jdGlvbiA9IG9wdGlvbnMuZ2VvbWV0cnlGdW5jdGlvbjtcbiAgICBpZiAoIWdlb21ldHJ5RnVuY3Rpb24pIHtcbiAgICAgIGlmICh0aGlzLnR5cGVfID09PSBHZW9tZXRyeVR5cGUuQ0lSQ0xFKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0geyFMaW5lQ29vcmRUeXBlfSBjb29yZGluYXRlcyBUaGUgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0PX0gb3B0X2dlb21ldHJ5IE9wdGlvbmFsIGdlb21ldHJ5LlxuICAgICAgICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IEEgZ2VvbWV0cnkuXG4gICAgICAgICAqL1xuICAgICAgICBnZW9tZXRyeUZ1bmN0aW9uID0gZnVuY3Rpb24oY29vcmRpbmF0ZXMsIG9wdF9nZW9tZXRyeSkge1xuICAgICAgICAgIHZhciBjaXJjbGUgPSBvcHRfZ2VvbWV0cnkgPyAvKiogQHR5cGUge0NpcmNsZX0gKi8gKG9wdF9nZW9tZXRyeSkgOlxuICAgICAgICAgICAgbmV3IENpcmNsZShbTmFOLCBOYU5dKTtcbiAgICAgICAgICB2YXIgc3F1YXJlZExlbmd0aCA9IHNxdWFyZWRDb29yZGluYXRlRGlzdGFuY2UoXG4gICAgICAgICAgICBjb29yZGluYXRlc1swXSwgY29vcmRpbmF0ZXNbMV0pO1xuICAgICAgICAgIGNpcmNsZS5zZXRDZW50ZXJBbmRSYWRpdXMoY29vcmRpbmF0ZXNbMF0sIE1hdGguc3FydChzcXVhcmVkTGVuZ3RoKSk7XG4gICAgICAgICAgcmV0dXJuIGNpcmNsZTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBDb25zdHJ1Y3RvcjtcbiAgICAgICAgdmFyIG1vZGUgPSB0aGlzLm1vZGVfO1xuICAgICAgICBpZiAobW9kZSA9PT0gTW9kZS5QT0lOVCkge1xuICAgICAgICAgIENvbnN0cnVjdG9yID0gUG9pbnQ7XG4gICAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gTW9kZS5MSU5FX1NUUklORykge1xuICAgICAgICAgIENvbnN0cnVjdG9yID0gTGluZVN0cmluZztcbiAgICAgICAgfSBlbHNlIGlmIChtb2RlID09PSBNb2RlLlBPTFlHT04pIHtcbiAgICAgICAgICBDb25zdHJ1Y3RvciA9IFBvbHlnb247XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7IUxpbmVDb29yZFR5cGV9IGNvb3JkaW5hdGVzIFRoZSBjb29yZGluYXRlcy5cbiAgICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHQ9fSBvcHRfZ2VvbWV0cnkgT3B0aW9uYWwgZ2VvbWV0cnkuXG4gICAgICAgICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2dlb20vU2ltcGxlR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gQSBnZW9tZXRyeS5cbiAgICAgICAgICovXG4gICAgICAgIGdlb21ldHJ5RnVuY3Rpb24gPSBmdW5jdGlvbihjb29yZGluYXRlcywgb3B0X2dlb21ldHJ5KSB7XG4gICAgICAgICAgdmFyIGdlb21ldHJ5ID0gb3B0X2dlb21ldHJ5O1xuICAgICAgICAgIGlmIChnZW9tZXRyeSkge1xuICAgICAgICAgICAgaWYgKG1vZGUgPT09IE1vZGUuUE9MWUdPTikge1xuICAgICAgICAgICAgICBpZiAoY29vcmRpbmF0ZXNbMF0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGEgY2xvc2luZyBjb29yZGluYXRlIHRvIG1hdGNoIHRoZSBmaXJzdFxuICAgICAgICAgICAgICAgIGdlb21ldHJ5LnNldENvb3JkaW5hdGVzKFtjb29yZGluYXRlc1swXS5jb25jYXQoW2Nvb3JkaW5hdGVzWzBdWzBdXSldKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZW9tZXRyeS5zZXRDb29yZGluYXRlcyhbXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGdlb21ldHJ5LnNldENvb3JkaW5hdGVzKGNvb3JkaW5hdGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgQ29uc3RydWN0b3IoY29vcmRpbmF0ZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZ2VvbWV0cnk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0dlb21ldHJ5RnVuY3Rpb259XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmdlb21ldHJ5RnVuY3Rpb25fID0gZ2VvbWV0cnlGdW5jdGlvbjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmRyYWdWZXJ0ZXhEZWxheV8gPSBvcHRpb25zLmRyYWdWZXJ0ZXhEZWxheSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kcmFnVmVydGV4RGVsYXkgOiA1MDA7XG5cbiAgICAvKipcbiAgICAgKiBGaW5pc2ggY29vcmRpbmF0ZSBmb3IgdGhlIGZlYXR1cmUgKGZpcnN0IHBvaW50IGZvciBwb2x5Z29ucywgbGFzdCBwb2ludCBmb3JcbiAgICAgKiBsaW5lc3RyaW5ncykuXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZmluaXNoQ29vcmRpbmF0ZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogU2tldGNoIGZlYXR1cmUuXG4gICAgICogQHR5cGUge0ZlYXR1cmV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnNrZXRjaEZlYXR1cmVfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFNrZXRjaCBwb2ludC5cbiAgICAgKiBAdHlwZSB7RmVhdHVyZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc2tldGNoUG9pbnRfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFNrZXRjaCBjb29yZGluYXRlcy4gVXNlZCB3aGVuIGRyYXdpbmcgYSBsaW5lIG9yIHBvbHlnb24uXG4gICAgICogQHR5cGUge1NrZXRjaENvb3JkVHlwZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc2tldGNoQ29vcmRzXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBTa2V0Y2ggbGluZS4gVXNlZCB3aGVuIGRyYXdpbmcgcG9seWdvbi5cbiAgICAgKiBAdHlwZSB7RmVhdHVyZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc2tldGNoTGluZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogU2tldGNoIGxpbmUgY29vcmRpbmF0ZXMuIFVzZWQgd2hlbiBkcmF3aW5nIGEgcG9seWdvbiBvciBjaXJjbGUuXG4gICAgICogQHR5cGUge0xpbmVDb29yZFR5cGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnNrZXRjaExpbmVDb29yZHNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFNxdWFyZWQgdG9sZXJhbmNlIGZvciBoYW5kbGluZyB1cCBldmVudHMuICBJZiB0aGUgc3F1YXJlZCBkaXN0YW5jZVxuICAgICAqIGJldHdlZW4gYSBkb3duIGFuZCB1cCBldmVudCBpcyBncmVhdGVyIHRoYW4gdGhpcyB0b2xlcmFuY2UsIHVwIGV2ZW50c1xuICAgICAqIHdpbGwgbm90IGJlIGhhbmRsZWQuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc3F1YXJlZENsaWNrVG9sZXJhbmNlXyA9IG9wdGlvbnMuY2xpY2tUb2xlcmFuY2UgP1xuICAgICAgb3B0aW9ucy5jbGlja1RvbGVyYW5jZSAqIG9wdGlvbnMuY2xpY2tUb2xlcmFuY2UgOiAzNjtcblxuICAgIC8qKlxuICAgICAqIERyYXcgb3ZlcmxheSB3aGVyZSBvdXIgc2tldGNoIGZlYXR1cmVzIGFyZSBkcmF3bi5cbiAgICAgKiBAdHlwZSB7VmVjdG9yTGF5ZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLm92ZXJsYXlfID0gbmV3IFZlY3RvckxheWVyKHtcbiAgICAgIHNvdXJjZTogbmV3IFZlY3RvclNvdXJjZSh7XG4gICAgICAgIHVzZVNwYXRpYWxJbmRleDogZmFsc2UsXG4gICAgICAgIHdyYXBYOiBvcHRpb25zLndyYXBYID8gb3B0aW9ucy53cmFwWCA6IGZhbHNlXG4gICAgICB9KSxcbiAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlID8gb3B0aW9ucy5zdHlsZSA6XG4gICAgICAgIGdldERlZmF1bHRTdHlsZUZ1bmN0aW9uKCksXG4gICAgICB1cGRhdGVXaGlsZUludGVyYWN0aW5nOiB0cnVlXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBOYW1lIG9mIHRoZSBnZW9tZXRyeSBhdHRyaWJ1dGUgZm9yIG5ld2x5IGNyZWF0ZWQgZmVhdHVyZXMuXG4gICAgICogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmdlb21ldHJ5TmFtZV8gPSBvcHRpb25zLmdlb21ldHJ5TmFtZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuY29uZGl0aW9uXyA9IG9wdGlvbnMuY29uZGl0aW9uID8gb3B0aW9ucy5jb25kaXRpb24gOiBub01vZGlmaWVyS2V5cztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuZnJlZWhhbmRDb25kaXRpb25fO1xuICAgIGlmIChvcHRpb25zLmZyZWVoYW5kKSB7XG4gICAgICB0aGlzLmZyZWVoYW5kQ29uZGl0aW9uXyA9IGFsd2F5cztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mcmVlaGFuZENvbmRpdGlvbl8gPSBvcHRpb25zLmZyZWVoYW5kQ29uZGl0aW9uID9cbiAgICAgICAgb3B0aW9ucy5mcmVlaGFuZENvbmRpdGlvbiA6IHNoaWZ0S2V5T25seTtcbiAgICB9XG5cbiAgICBsaXN0ZW4odGhpcyxcbiAgICAgIGdldENoYW5nZUV2ZW50VHlwZShJbnRlcmFjdGlvblByb3BlcnR5LkFDVElWRSksXG4gICAgICB0aGlzLnVwZGF0ZVN0YXRlXywgdGhpcyk7XG5cbiAgfVxuXG4gIGlmICggUG9pbnRlckludGVyYWN0aW9uICkgRHJhdy5fX3Byb3RvX18gPSBQb2ludGVySW50ZXJhY3Rpb247XG4gIERyYXcucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUG9pbnRlckludGVyYWN0aW9uICYmIFBvaW50ZXJJbnRlcmFjdGlvbi5wcm90b3R5cGUgKTtcbiAgRHJhdy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEcmF3O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgRHJhdy5wcm90b3R5cGUuc2V0TWFwID0gZnVuY3Rpb24gc2V0TWFwIChtYXApIHtcbiAgICBQb2ludGVySW50ZXJhY3Rpb24ucHJvdG90eXBlLnNldE1hcC5jYWxsKHRoaXMsIG1hcCk7XG4gICAgdGhpcy51cGRhdGVTdGF0ZV8oKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBvdmVybGF5IGxheWVyIHRoYXQgdGhpcyBpbnRlcmFjdGlvbiByZW5kZXJzIHNrZXRjaCBmZWF0dXJlcyB0by5cbiAgICogQHJldHVybiB7VmVjdG9yTGF5ZXJ9IE92ZXJsYXkgbGF5ZXIuXG4gICAqIEBhcGlcbiAgICovXG4gIERyYXcucHJvdG90eXBlLmdldE92ZXJsYXkgPSBmdW5jdGlvbiBnZXRPdmVybGF5ICgpIHtcbiAgICByZXR1cm4gdGhpcy5vdmVybGF5XztcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnQgbWFwIGJyb3dzZXIgZXZlbnR9IGFuZCBtYXkgYWN0dWFsbHkgZHJhdyBvciBmaW5pc2ggdGhlIGRyYXdpbmcuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBEcmF3LnByb3RvdHlwZS5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uIGhhbmRsZUV2ZW50IChldmVudCkge1xuICAgIGlmIChldmVudC5vcmlnaW5hbEV2ZW50LnR5cGUgPT09IEV2ZW50VHlwZS5DT05URVhUTUVOVSkge1xuICAgICAgLy8gQXZvaWQgY29udGV4dCBtZW51IGZvciBsb25nIHRhcHMgd2hlbiBkcmF3aW5nIG9uIG1vYmlsZVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgdGhpcy5mcmVlaGFuZF8gPSB0aGlzLm1vZGVfICE9PSBNb2RlLlBPSU5UICYmIHRoaXMuZnJlZWhhbmRDb25kaXRpb25fKGV2ZW50KTtcbiAgICB2YXIgbW92ZSA9IGV2ZW50LnR5cGUgPT09IE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUk1PVkU7XG4gICAgdmFyIHBhc3MgPSB0cnVlO1xuICAgIGlmICghdGhpcy5mcmVlaGFuZF8gJiYgdGhpcy5sYXN0RHJhZ1RpbWVfICYmIGV2ZW50LnR5cGUgPT09IE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUkRSQUcpIHtcbiAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgaWYgKG5vdyAtIHRoaXMubGFzdERyYWdUaW1lXyA+PSB0aGlzLmRyYWdWZXJ0ZXhEZWxheV8pIHtcbiAgICAgICAgdGhpcy5kb3duUHhfID0gZXZlbnQucGl4ZWw7XG4gICAgICAgIHRoaXMuc2hvdWxkSGFuZGxlXyA9ICF0aGlzLmZyZWVoYW5kXztcbiAgICAgICAgbW92ZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxhc3REcmFnVGltZV8gPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zaG91bGRIYW5kbGVfICYmIHRoaXMuZG93blRpbWVvdXRfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZG93blRpbWVvdXRfKTtcbiAgICAgICAgdGhpcy5kb3duVGltZW91dF8gPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmZyZWVoYW5kXyAmJlxuICAgICAgICBldmVudC50eXBlID09PSBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJEUkFHICYmXG4gICAgICAgIHRoaXMuc2tldGNoRmVhdHVyZV8gIT09IG51bGwpIHtcbiAgICAgIHRoaXMuYWRkVG9EcmF3aW5nXyhldmVudCk7XG4gICAgICBwYXNzID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh0aGlzLmZyZWVoYW5kXyAmJlxuICAgICAgICBldmVudC50eXBlID09PSBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJET1dOKSB7XG4gICAgICBwYXNzID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChtb3ZlKSB7XG4gICAgICBwYXNzID0gZXZlbnQudHlwZSA9PT0gTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSTU9WRTtcbiAgICAgIGlmIChwYXNzICYmIHRoaXMuZnJlZWhhbmRfKSB7XG4gICAgICAgIHBhc3MgPSB0aGlzLmhhbmRsZVBvaW50ZXJNb3ZlXyhldmVudCk7XG4gICAgICB9IGVsc2UgaWYgKC8qKiBAdHlwZSB7TWFwQnJvd3NlclBvaW50ZXJFdmVudH0gKi8gKGV2ZW50KS5wb2ludGVyRXZlbnQucG9pbnRlclR5cGUgPT0gUE9JTlRFUl9UWVBFIHx8XG4gICAgICAgICAgKGV2ZW50LnR5cGUgPT09IE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUkRSQUcgJiYgdGhpcy5kb3duVGltZW91dF8gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyTW92ZV8oZXZlbnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gTWFwQnJvd3NlckV2ZW50VHlwZS5EQkxDTElDSykge1xuICAgICAgcGFzcyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBQb2ludGVySW50ZXJhY3Rpb24ucHJvdG90eXBlLmhhbmRsZUV2ZW50LmNhbGwodGhpcywgZXZlbnQpICYmIHBhc3M7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBEcmF3LnByb3RvdHlwZS5oYW5kbGVEb3duRXZlbnQgPSBmdW5jdGlvbiBoYW5kbGVEb3duRXZlbnQgKGV2ZW50KSB7XG4gICAgdGhpcy5zaG91bGRIYW5kbGVfID0gIXRoaXMuZnJlZWhhbmRfO1xuXG4gICAgaWYgKHRoaXMuZnJlZWhhbmRfKSB7XG4gICAgICB0aGlzLmRvd25QeF8gPSBldmVudC5waXhlbDtcbiAgICAgIGlmICghdGhpcy5maW5pc2hDb29yZGluYXRlXykge1xuICAgICAgICB0aGlzLnN0YXJ0RHJhd2luZ18oZXZlbnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLmNvbmRpdGlvbl8oZXZlbnQpKSB7XG4gICAgICB0aGlzLmxhc3REcmFnVGltZV8gPSBEYXRlLm5vdygpO1xuICAgICAgdGhpcy5kb3duVGltZW91dF8gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJNb3ZlXyhuZXcgTWFwQnJvd3NlclBvaW50ZXJFdmVudChcbiAgICAgICAgICBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJNT1ZFLCBldmVudC5tYXAsIGV2ZW50LnBvaW50ZXJFdmVudCwgZmFsc2UsIGV2ZW50LmZyYW1lU3RhdGUpKTtcbiAgICAgIH0uYmluZCh0aGlzKSwgdGhpcy5kcmFnVmVydGV4RGVsYXlfKTtcbiAgICAgIHRoaXMuZG93blB4XyA9IGV2ZW50LnBpeGVsO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG5cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIERyYXcucHJvdG90eXBlLmhhbmRsZVVwRXZlbnQgPSBmdW5jdGlvbiBoYW5kbGVVcEV2ZW50IChldmVudCkge1xuICAgIHZhciBwYXNzID0gdHJ1ZTtcblxuICAgIGlmICh0aGlzLmRvd25UaW1lb3V0Xykge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZG93blRpbWVvdXRfKTtcbiAgICAgIHRoaXMuZG93blRpbWVvdXRfID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHRoaXMuaGFuZGxlUG9pbnRlck1vdmVfKGV2ZW50KTtcblxuICAgIHZhciBjaXJjbGVNb2RlID0gdGhpcy5tb2RlXyA9PT0gTW9kZS5DSVJDTEU7XG5cbiAgICBpZiAodGhpcy5zaG91bGRIYW5kbGVfKSB7XG4gICAgICBpZiAoIXRoaXMuZmluaXNoQ29vcmRpbmF0ZV8pIHtcbiAgICAgICAgdGhpcy5zdGFydERyYXdpbmdfKGV2ZW50KTtcbiAgICAgICAgaWYgKHRoaXMubW9kZV8gPT09IE1vZGUuUE9JTlQpIHtcbiAgICAgICAgICB0aGlzLmZpbmlzaERyYXdpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLmZyZWVoYW5kXyB8fCBjaXJjbGVNb2RlKSB7XG4gICAgICAgIHRoaXMuZmluaXNoRHJhd2luZygpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmF0RmluaXNoXyhldmVudCkpIHtcbiAgICAgICAgaWYgKHRoaXMuZmluaXNoQ29uZGl0aW9uXyhldmVudCkpIHtcbiAgICAgICAgICB0aGlzLmZpbmlzaERyYXdpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hZGRUb0RyYXdpbmdfKGV2ZW50KTtcbiAgICAgIH1cbiAgICAgIHBhc3MgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZnJlZWhhbmRfKSB7XG4gICAgICB0aGlzLmZpbmlzaENvb3JkaW5hdGVfID0gbnVsbDtcbiAgICAgIHRoaXMuYWJvcnREcmF3aW5nXygpO1xuICAgIH1cbiAgICBpZiAoIXBhc3MgJiYgdGhpcy5zdG9wQ2xpY2tfKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhc3M7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBtb3ZlIGV2ZW50cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gZXZlbnQgQSBtb3ZlIGV2ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBQYXNzIHRoZSBldmVudCB0byBvdGhlciBpbnRlcmFjdGlvbnMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBEcmF3LnByb3RvdHlwZS5oYW5kbGVQb2ludGVyTW92ZV8gPSBmdW5jdGlvbiBoYW5kbGVQb2ludGVyTW92ZV8gKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuZG93blB4XyAmJlxuICAgICAgICAoKCF0aGlzLmZyZWVoYW5kXyAmJiB0aGlzLnNob3VsZEhhbmRsZV8pIHx8XG4gICAgICAgICh0aGlzLmZyZWVoYW5kXyAmJiAhdGhpcy5zaG91bGRIYW5kbGVfKSkpIHtcbiAgICAgIHZhciBkb3duUHggPSB0aGlzLmRvd25QeF87XG4gICAgICB2YXIgY2xpY2tQeCA9IGV2ZW50LnBpeGVsO1xuICAgICAgdmFyIGR4ID0gZG93blB4WzBdIC0gY2xpY2tQeFswXTtcbiAgICAgIHZhciBkeSA9IGRvd25QeFsxXSAtIGNsaWNrUHhbMV07XG4gICAgICB2YXIgc3F1YXJlZERpc3RhbmNlID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICB0aGlzLnNob3VsZEhhbmRsZV8gPSB0aGlzLmZyZWVoYW5kXyA/XG4gICAgICAgIHNxdWFyZWREaXN0YW5jZSA+IHRoaXMuc3F1YXJlZENsaWNrVG9sZXJhbmNlXyA6XG4gICAgICAgIHNxdWFyZWREaXN0YW5jZSA8PSB0aGlzLnNxdWFyZWRDbGlja1RvbGVyYW5jZV87XG4gICAgICBpZiAoIXRoaXMuc2hvdWxkSGFuZGxlXykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5maW5pc2hDb29yZGluYXRlXykge1xuICAgICAgdGhpcy5tb2RpZnlEcmF3aW5nXyhldmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3JlYXRlT3JVcGRhdGVTa2V0Y2hQb2ludF8oZXZlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIGFuIGV2ZW50IGlzIHdpdGhpbiB0aGUgc25hcHBpbmcgdG9sZXJhbmNlIG9mIHRoZSBzdGFydCBjb29yZC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gZXZlbnQgRXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBldmVudCBpcyB3aXRoaW4gdGhlIHNuYXBwaW5nIHRvbGVyYW5jZSBvZiB0aGUgc3RhcnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBEcmF3LnByb3RvdHlwZS5hdEZpbmlzaF8gPSBmdW5jdGlvbiBhdEZpbmlzaF8gKGV2ZW50KSB7XG4gICAgdmFyIGF0ID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuc2tldGNoRmVhdHVyZV8pIHtcbiAgICAgIHZhciBwb3RlbnRpYWxseURvbmUgPSBmYWxzZTtcbiAgICAgIHZhciBwb3RlbnRpYWxseUZpbmlzaENvb3JkaW5hdGVzID0gW3RoaXMuZmluaXNoQ29vcmRpbmF0ZV9dO1xuICAgICAgaWYgKHRoaXMubW9kZV8gPT09IE1vZGUuTElORV9TVFJJTkcpIHtcbiAgICAgICAgcG90ZW50aWFsbHlEb25lID0gdGhpcy5za2V0Y2hDb29yZHNfLmxlbmd0aCA+IHRoaXMubWluUG9pbnRzXztcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5tb2RlXyA9PT0gTW9kZS5QT0xZR09OKSB7XG4gICAgICAgIHZhciBza2V0Y2hDb29yZHMgPSAvKiogQHR5cGUge1BvbHlDb29yZFR5cGV9ICovICh0aGlzLnNrZXRjaENvb3Jkc18pO1xuICAgICAgICBwb3RlbnRpYWxseURvbmUgPSBza2V0Y2hDb29yZHNbMF0ubGVuZ3RoID4gdGhpcy5taW5Qb2ludHNfO1xuICAgICAgICBwb3RlbnRpYWxseUZpbmlzaENvb3JkaW5hdGVzID0gW3NrZXRjaENvb3Jkc1swXVswXSwgc2tldGNoQ29vcmRzWzBdW3NrZXRjaENvb3Jkc1swXS5sZW5ndGggLSAyXV07XG4gICAgICB9XG4gICAgICBpZiAocG90ZW50aWFsbHlEb25lKSB7XG4gICAgICAgIHZhciBtYXAgPSBldmVudC5tYXA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHBvdGVudGlhbGx5RmluaXNoQ29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgIHZhciBmaW5pc2hDb29yZGluYXRlID0gcG90ZW50aWFsbHlGaW5pc2hDb29yZGluYXRlc1tpXTtcbiAgICAgICAgICB2YXIgZmluaXNoUGl4ZWwgPSBtYXAuZ2V0UGl4ZWxGcm9tQ29vcmRpbmF0ZShmaW5pc2hDb29yZGluYXRlKTtcbiAgICAgICAgICB2YXIgcGl4ZWwgPSBldmVudC5waXhlbDtcbiAgICAgICAgICB2YXIgZHggPSBwaXhlbFswXSAtIGZpbmlzaFBpeGVsWzBdO1xuICAgICAgICAgIHZhciBkeSA9IHBpeGVsWzFdIC0gZmluaXNoUGl4ZWxbMV07XG4gICAgICAgICAgdmFyIHNuYXBUb2xlcmFuY2UgPSB0aGlzLmZyZWVoYW5kXyA/IDEgOiB0aGlzLnNuYXBUb2xlcmFuY2VfO1xuICAgICAgICAgIGF0ID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KSA8PSBzbmFwVG9sZXJhbmNlO1xuICAgICAgICAgIGlmIChhdCkge1xuICAgICAgICAgICAgdGhpcy5maW5pc2hDb29yZGluYXRlXyA9IGZpbmlzaENvb3JkaW5hdGU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGF0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBldmVudCBFdmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIERyYXcucHJvdG90eXBlLmNyZWF0ZU9yVXBkYXRlU2tldGNoUG9pbnRfID0gZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVTa2V0Y2hQb2ludF8gKGV2ZW50KSB7XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gZXZlbnQuY29vcmRpbmF0ZS5zbGljZSgpO1xuICAgIGlmICghdGhpcy5za2V0Y2hQb2ludF8pIHtcbiAgICAgIHRoaXMuc2tldGNoUG9pbnRfID0gbmV3IEZlYXR1cmUobmV3IFBvaW50KGNvb3JkaW5hdGVzKSk7XG4gICAgICB0aGlzLnVwZGF0ZVNrZXRjaEZlYXR1cmVzXygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2tldGNoUG9pbnRHZW9tID0gLyoqIEB0eXBlIHtQb2ludH0gKi8gKHRoaXMuc2tldGNoUG9pbnRfLmdldEdlb21ldHJ5KCkpO1xuICAgICAgc2tldGNoUG9pbnRHZW9tLnNldENvb3JkaW5hdGVzKGNvb3JkaW5hdGVzKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHRoZSBkcmF3aW5nLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBldmVudCBFdmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIERyYXcucHJvdG90eXBlLnN0YXJ0RHJhd2luZ18gPSBmdW5jdGlvbiBzdGFydERyYXdpbmdfIChldmVudCkge1xuICAgIHZhciBzdGFydCA9IGV2ZW50LmNvb3JkaW5hdGU7XG4gICAgdGhpcy5maW5pc2hDb29yZGluYXRlXyA9IHN0YXJ0O1xuICAgIGlmICh0aGlzLm1vZGVfID09PSBNb2RlLlBPSU5UKSB7XG4gICAgICB0aGlzLnNrZXRjaENvb3Jkc18gPSBzdGFydC5zbGljZSgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tb2RlXyA9PT0gTW9kZS5QT0xZR09OKSB7XG4gICAgICB0aGlzLnNrZXRjaENvb3Jkc18gPSBbW3N0YXJ0LnNsaWNlKCksIHN0YXJ0LnNsaWNlKCldXTtcbiAgICAgIHRoaXMuc2tldGNoTGluZUNvb3Jkc18gPSB0aGlzLnNrZXRjaENvb3Jkc19bMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2tldGNoQ29vcmRzXyA9IFtzdGFydC5zbGljZSgpLCBzdGFydC5zbGljZSgpXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc2tldGNoTGluZUNvb3Jkc18pIHtcbiAgICAgIHRoaXMuc2tldGNoTGluZV8gPSBuZXcgRmVhdHVyZShcbiAgICAgICAgbmV3IExpbmVTdHJpbmcodGhpcy5za2V0Y2hMaW5lQ29vcmRzXykpO1xuICAgIH1cbiAgICB2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5RnVuY3Rpb25fKHRoaXMuc2tldGNoQ29vcmRzXyk7XG4gICAgdGhpcy5za2V0Y2hGZWF0dXJlXyA9IG5ldyBGZWF0dXJlKCk7XG4gICAgaWYgKHRoaXMuZ2VvbWV0cnlOYW1lXykge1xuICAgICAgdGhpcy5za2V0Y2hGZWF0dXJlXy5zZXRHZW9tZXRyeU5hbWUodGhpcy5nZW9tZXRyeU5hbWVfKTtcbiAgICB9XG4gICAgdGhpcy5za2V0Y2hGZWF0dXJlXy5zZXRHZW9tZXRyeShnZW9tZXRyeSk7XG4gICAgdGhpcy51cGRhdGVTa2V0Y2hGZWF0dXJlc18oKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IERyYXdFdmVudChEcmF3RXZlbnRUeXBlLkRSQVdTVEFSVCwgdGhpcy5za2V0Y2hGZWF0dXJlXykpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNb2RpZnkgdGhlIGRyYXdpbmcuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IGV2ZW50IEV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgRHJhdy5wcm90b3R5cGUubW9kaWZ5RHJhd2luZ18gPSBmdW5jdGlvbiBtb2RpZnlEcmF3aW5nXyAoZXZlbnQpIHtcbiAgICB2YXIgY29vcmRpbmF0ZSA9IGV2ZW50LmNvb3JkaW5hdGU7XG4gICAgdmFyIGdlb21ldHJ5ID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR9ICovICh0aGlzLnNrZXRjaEZlYXR1cmVfLmdldEdlb21ldHJ5KCkpO1xuICAgIHZhciBjb29yZGluYXRlcywgbGFzdDtcbiAgICBpZiAodGhpcy5tb2RlXyA9PT0gTW9kZS5QT0lOVCkge1xuICAgICAgbGFzdCA9IHRoaXMuc2tldGNoQ29vcmRzXztcbiAgICB9IGVsc2UgaWYgKHRoaXMubW9kZV8gPT09IE1vZGUuUE9MWUdPTikge1xuICAgICAgY29vcmRpbmF0ZXMgPSAvKiogQHR5cGUge1BvbHlDb29yZFR5cGV9ICovICh0aGlzLnNrZXRjaENvb3Jkc18pWzBdO1xuICAgICAgbGFzdCA9IGNvb3JkaW5hdGVzW2Nvb3JkaW5hdGVzLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKHRoaXMuYXRGaW5pc2hfKGV2ZW50KSkge1xuICAgICAgICAvLyBzbmFwIHRvIGZpbmlzaFxuICAgICAgICBjb29yZGluYXRlID0gdGhpcy5maW5pc2hDb29yZGluYXRlXy5zbGljZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb29yZGluYXRlcyA9IHRoaXMuc2tldGNoQ29vcmRzXztcbiAgICAgIGxhc3QgPSBjb29yZGluYXRlc1tjb29yZGluYXRlcy5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgbGFzdFswXSA9IGNvb3JkaW5hdGVbMF07XG4gICAgbGFzdFsxXSA9IGNvb3JkaW5hdGVbMV07XG4gICAgdGhpcy5nZW9tZXRyeUZ1bmN0aW9uXygvKiogQHR5cGUgeyFMaW5lQ29vcmRUeXBlfSAqLyAodGhpcy5za2V0Y2hDb29yZHNfKSwgZ2VvbWV0cnkpO1xuICAgIGlmICh0aGlzLnNrZXRjaFBvaW50Xykge1xuICAgICAgdmFyIHNrZXRjaFBvaW50R2VvbSA9IC8qKiBAdHlwZSB7UG9pbnR9ICovICh0aGlzLnNrZXRjaFBvaW50Xy5nZXRHZW9tZXRyeSgpKTtcbiAgICAgIHNrZXRjaFBvaW50R2VvbS5zZXRDb29yZGluYXRlcyhjb29yZGluYXRlKTtcbiAgICB9XG4gICAgLyoqIEB0eXBlIHtMaW5lU3RyaW5nfSAqL1xuICAgIHZhciBza2V0Y2hMaW5lR2VvbTtcbiAgICBpZiAoZ2VvbWV0cnkuZ2V0VHlwZSgpID09IEdlb21ldHJ5VHlwZS5QT0xZR09OICYmXG4gICAgICAgIHRoaXMubW9kZV8gIT09IE1vZGUuUE9MWUdPTikge1xuICAgICAgaWYgKCF0aGlzLnNrZXRjaExpbmVfKSB7XG4gICAgICAgIHRoaXMuc2tldGNoTGluZV8gPSBuZXcgRmVhdHVyZSgpO1xuICAgICAgfVxuICAgICAgdmFyIHJpbmcgPSAvKiogQHR5cGUge1BvbHlnb259ICovIChnZW9tZXRyeSkuZ2V0TGluZWFyUmluZygwKTtcbiAgICAgIHNrZXRjaExpbmVHZW9tID0gLyoqIEB0eXBlIHtMaW5lU3RyaW5nfSAqLyAodGhpcy5za2V0Y2hMaW5lXy5nZXRHZW9tZXRyeSgpKTtcbiAgICAgIGlmICghc2tldGNoTGluZUdlb20pIHtcbiAgICAgICAgc2tldGNoTGluZUdlb20gPSBuZXcgTGluZVN0cmluZyhyaW5nLmdldEZsYXRDb29yZGluYXRlcygpLCByaW5nLmdldExheW91dCgpKTtcbiAgICAgICAgdGhpcy5za2V0Y2hMaW5lXy5zZXRHZW9tZXRyeShza2V0Y2hMaW5lR2VvbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBza2V0Y2hMaW5lR2VvbS5zZXRGbGF0Q29vcmRpbmF0ZXMoXG4gICAgICAgICAgcmluZy5nZXRMYXlvdXQoKSwgcmluZy5nZXRGbGF0Q29vcmRpbmF0ZXMoKSk7XG4gICAgICAgIHNrZXRjaExpbmVHZW9tLmNoYW5nZWQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuc2tldGNoTGluZUNvb3Jkc18pIHtcbiAgICAgIHNrZXRjaExpbmVHZW9tID0gLyoqIEB0eXBlIHtMaW5lU3RyaW5nfSAqLyAodGhpcy5za2V0Y2hMaW5lXy5nZXRHZW9tZXRyeSgpKTtcbiAgICAgIHNrZXRjaExpbmVHZW9tLnNldENvb3JkaW5hdGVzKHRoaXMuc2tldGNoTGluZUNvb3Jkc18pO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVNrZXRjaEZlYXR1cmVzXygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSBuZXcgY29vcmRpbmF0ZSB0byB0aGUgZHJhd2luZy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gZXZlbnQgRXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBEcmF3LnByb3RvdHlwZS5hZGRUb0RyYXdpbmdfID0gZnVuY3Rpb24gYWRkVG9EcmF3aW5nXyAoZXZlbnQpIHtcbiAgICB2YXIgY29vcmRpbmF0ZSA9IGV2ZW50LmNvb3JkaW5hdGU7XG4gICAgdmFyIGdlb21ldHJ5ID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR9ICovICh0aGlzLnNrZXRjaEZlYXR1cmVfLmdldEdlb21ldHJ5KCkpO1xuICAgIHZhciBkb25lO1xuICAgIHZhciBjb29yZGluYXRlcztcbiAgICBpZiAodGhpcy5tb2RlXyA9PT0gTW9kZS5MSU5FX1NUUklORykge1xuICAgICAgdGhpcy5maW5pc2hDb29yZGluYXRlXyA9IGNvb3JkaW5hdGUuc2xpY2UoKTtcbiAgICAgIGNvb3JkaW5hdGVzID0gLyoqIEB0eXBlIHtMaW5lQ29vcmRUeXBlfSAqLyAodGhpcy5za2V0Y2hDb29yZHNfKTtcbiAgICAgIGlmIChjb29yZGluYXRlcy5sZW5ndGggPj0gdGhpcy5tYXhQb2ludHNfKSB7XG4gICAgICAgIGlmICh0aGlzLmZyZWVoYW5kXykge1xuICAgICAgICAgIGNvb3JkaW5hdGVzLnBvcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb29yZGluYXRlcy5wdXNoKGNvb3JkaW5hdGUuc2xpY2UoKSk7XG4gICAgICB0aGlzLmdlb21ldHJ5RnVuY3Rpb25fKGNvb3JkaW5hdGVzLCBnZW9tZXRyeSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1vZGVfID09PSBNb2RlLlBPTFlHT04pIHtcbiAgICAgIGNvb3JkaW5hdGVzID0gLyoqIEB0eXBlIHtQb2x5Q29vcmRUeXBlfSAqLyAodGhpcy5za2V0Y2hDb29yZHNfKVswXTtcbiAgICAgIGlmIChjb29yZGluYXRlcy5sZW5ndGggPj0gdGhpcy5tYXhQb2ludHNfKSB7XG4gICAgICAgIGlmICh0aGlzLmZyZWVoYW5kXykge1xuICAgICAgICAgIGNvb3JkaW5hdGVzLnBvcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb29yZGluYXRlcy5wdXNoKGNvb3JkaW5hdGUuc2xpY2UoKSk7XG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICB0aGlzLmZpbmlzaENvb3JkaW5hdGVfID0gY29vcmRpbmF0ZXNbMF07XG4gICAgICB9XG4gICAgICB0aGlzLmdlb21ldHJ5RnVuY3Rpb25fKHRoaXMuc2tldGNoQ29vcmRzXywgZ2VvbWV0cnkpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVNrZXRjaEZlYXR1cmVzXygpO1xuICAgIGlmIChkb25lKSB7XG4gICAgICB0aGlzLmZpbmlzaERyYXdpbmcoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBsYXN0IHBvaW50IG9mIHRoZSBmZWF0dXJlIGN1cnJlbnRseSBiZWluZyBkcmF3bi5cbiAgICogQGFwaVxuICAgKi9cbiAgRHJhdy5wcm90b3R5cGUucmVtb3ZlTGFzdFBvaW50ID0gZnVuY3Rpb24gcmVtb3ZlTGFzdFBvaW50ICgpIHtcbiAgICBpZiAoIXRoaXMuc2tldGNoRmVhdHVyZV8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGdlb21ldHJ5ID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzXCIpLmRlZmF1bHR9ICovICh0aGlzLnNrZXRjaEZlYXR1cmVfLmdldEdlb21ldHJ5KCkpO1xuICAgIHZhciBjb29yZGluYXRlcztcbiAgICAvKiogQHR5cGUge0xpbmVTdHJpbmd9ICovXG4gICAgdmFyIHNrZXRjaExpbmVHZW9tO1xuICAgIGlmICh0aGlzLm1vZGVfID09PSBNb2RlLkxJTkVfU1RSSU5HKSB7XG4gICAgICBjb29yZGluYXRlcyA9IC8qKiBAdHlwZSB7TGluZUNvb3JkVHlwZX0gKi8gKHRoaXMuc2tldGNoQ29vcmRzXyk7XG4gICAgICBjb29yZGluYXRlcy5zcGxpY2UoLTIsIDEpO1xuICAgICAgdGhpcy5nZW9tZXRyeUZ1bmN0aW9uXyhjb29yZGluYXRlcywgZ2VvbWV0cnkpO1xuICAgICAgaWYgKGNvb3JkaW5hdGVzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgIHRoaXMuZmluaXNoQ29vcmRpbmF0ZV8gPSBjb29yZGluYXRlc1tjb29yZGluYXRlcy5sZW5ndGggLSAyXS5zbGljZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5tb2RlXyA9PT0gTW9kZS5QT0xZR09OKSB7XG4gICAgICBjb29yZGluYXRlcyA9IC8qKiBAdHlwZSB7UG9seUNvb3JkVHlwZX0gKi8gKHRoaXMuc2tldGNoQ29vcmRzXylbMF07XG4gICAgICBjb29yZGluYXRlcy5zcGxpY2UoLTIsIDEpO1xuICAgICAgc2tldGNoTGluZUdlb20gPSAvKiogQHR5cGUge0xpbmVTdHJpbmd9ICovICh0aGlzLnNrZXRjaExpbmVfLmdldEdlb21ldHJ5KCkpO1xuICAgICAgc2tldGNoTGluZUdlb20uc2V0Q29vcmRpbmF0ZXMoY29vcmRpbmF0ZXMpO1xuICAgICAgdGhpcy5nZW9tZXRyeUZ1bmN0aW9uXyh0aGlzLnNrZXRjaENvb3Jkc18sIGdlb21ldHJ5KTtcbiAgICB9XG5cbiAgICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmZpbmlzaENvb3JkaW5hdGVfID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZVNrZXRjaEZlYXR1cmVzXygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdG9wIGRyYXdpbmcgYW5kIGFkZCB0aGUgc2tldGNoIGZlYXR1cmUgdG8gdGhlIHRhcmdldCBsYXllci5cbiAgICogVGhlIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vRHJhd35EcmF3RXZlbnRUeXBlLkRSQVdFTkR9IGV2ZW50IGlzXG4gICAqIGRpc3BhdGNoZWQgYmVmb3JlIGluc2VydGluZyB0aGUgZmVhdHVyZS5cbiAgICogQGFwaVxuICAgKi9cbiAgRHJhdy5wcm90b3R5cGUuZmluaXNoRHJhd2luZyA9IGZ1bmN0aW9uIGZpbmlzaERyYXdpbmcgKCkge1xuICAgIHZhciBza2V0Y2hGZWF0dXJlID0gdGhpcy5hYm9ydERyYXdpbmdfKCk7XG4gICAgaWYgKCFza2V0Y2hGZWF0dXJlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjb29yZGluYXRlcyA9IHRoaXMuc2tldGNoQ29vcmRzXztcbiAgICB2YXIgZ2VvbWV0cnkgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL2dlb20vU2ltcGxlR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gKi8gKHNrZXRjaEZlYXR1cmUuZ2V0R2VvbWV0cnkoKSk7XG4gICAgaWYgKHRoaXMubW9kZV8gPT09IE1vZGUuTElORV9TVFJJTkcpIHtcbiAgICAgIC8vIHJlbW92ZSB0aGUgcmVkdW5kYW50IGxhc3QgcG9pbnRcbiAgICAgIGNvb3JkaW5hdGVzLnBvcCgpO1xuICAgICAgdGhpcy5nZW9tZXRyeUZ1bmN0aW9uXyhjb29yZGluYXRlcywgZ2VvbWV0cnkpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tb2RlXyA9PT0gTW9kZS5QT0xZR09OKSB7XG4gICAgICAvLyByZW1vdmUgdGhlIHJlZHVuZGFudCBsYXN0IHBvaW50IGluIHJpbmdcbiAgICAgIC8qKiBAdHlwZSB7UG9seUNvb3JkVHlwZX0gKi8gKGNvb3JkaW5hdGVzKVswXS5wb3AoKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnlGdW5jdGlvbl8oY29vcmRpbmF0ZXMsIGdlb21ldHJ5KTtcbiAgICAgIGNvb3JkaW5hdGVzID0gZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICB9XG5cbiAgICAvLyBjYXN0IG11bHRpLXBhcnQgZ2VvbWV0cmllc1xuICAgIGlmICh0aGlzLnR5cGVfID09PSBHZW9tZXRyeVR5cGUuTVVMVElfUE9JTlQpIHtcbiAgICAgIHNrZXRjaEZlYXR1cmUuc2V0R2VvbWV0cnkobmV3IE11bHRpUG9pbnQoWy8qKiBAdHlwZSB7UG9pbnRDb29yZFR5cGV9ICovKGNvb3JkaW5hdGVzKV0pKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudHlwZV8gPT09IEdlb21ldHJ5VHlwZS5NVUxUSV9MSU5FX1NUUklORykge1xuICAgICAgc2tldGNoRmVhdHVyZS5zZXRHZW9tZXRyeShuZXcgTXVsdGlMaW5lU3RyaW5nKFsvKiogQHR5cGUge0xpbmVDb29yZFR5cGV9ICovKGNvb3JkaW5hdGVzKV0pKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudHlwZV8gPT09IEdlb21ldHJ5VHlwZS5NVUxUSV9QT0xZR09OKSB7XG4gICAgICBza2V0Y2hGZWF0dXJlLnNldEdlb21ldHJ5KG5ldyBNdWx0aVBvbHlnb24oWy8qKiBAdHlwZSB7UG9seUNvb3JkVHlwZX0gKi8oY29vcmRpbmF0ZXMpXSkpO1xuICAgIH1cblxuICAgIC8vIEZpcnN0IGRpc3BhdGNoIGV2ZW50IHRvIGFsbG93IGZ1bGwgc2V0IHVwIG9mIGZlYXR1cmVcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IERyYXdFdmVudChEcmF3RXZlbnRUeXBlLkRSQVdFTkQsIHNrZXRjaEZlYXR1cmUpKTtcblxuICAgIC8vIFRoZW4gaW5zZXJ0IGZlYXR1cmVcbiAgICBpZiAodGhpcy5mZWF0dXJlc18pIHtcbiAgICAgIHRoaXMuZmVhdHVyZXNfLnB1c2goc2tldGNoRmVhdHVyZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnNvdXJjZV8pIHtcbiAgICAgIHRoaXMuc291cmNlXy5hZGRGZWF0dXJlKHNrZXRjaEZlYXR1cmUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU3RvcCBkcmF3aW5nIHdpdGhvdXQgYWRkaW5nIHRoZSBza2V0Y2ggZmVhdHVyZSB0byB0aGUgdGFyZ2V0IGxheWVyLlxuICAgKiBAcmV0dXJuIHtGZWF0dXJlfSBUaGUgc2tldGNoIGZlYXR1cmUgKG9yIG51bGwgaWYgbm9uZSkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBEcmF3LnByb3RvdHlwZS5hYm9ydERyYXdpbmdfID0gZnVuY3Rpb24gYWJvcnREcmF3aW5nXyAoKSB7XG4gICAgdGhpcy5maW5pc2hDb29yZGluYXRlXyA9IG51bGw7XG4gICAgdmFyIHNrZXRjaEZlYXR1cmUgPSB0aGlzLnNrZXRjaEZlYXR1cmVfO1xuICAgIGlmIChza2V0Y2hGZWF0dXJlKSB7XG4gICAgICB0aGlzLnNrZXRjaEZlYXR1cmVfID0gbnVsbDtcbiAgICAgIHRoaXMuc2tldGNoUG9pbnRfID0gbnVsbDtcbiAgICAgIHRoaXMuc2tldGNoTGluZV8gPSBudWxsO1xuICAgICAgLyoqIEB0eXBlIHtWZWN0b3JTb3VyY2V9ICovICh0aGlzLm92ZXJsYXlfLmdldFNvdXJjZSgpKS5jbGVhcih0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHNrZXRjaEZlYXR1cmU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4dGVuZCBhbiBleGlzdGluZyBnZW9tZXRyeSBieSBhZGRpbmcgYWRkaXRpb25hbCBwb2ludHMuIFRoaXMgb25seSB3b3Jrc1xuICAgKiBvbiBmZWF0dXJlcyB3aXRoIGBMaW5lU3RyaW5nYCBnZW9tZXRyaWVzLCB3aGVyZSB0aGUgaW50ZXJhY3Rpb24gd2lsbFxuICAgKiBleHRlbmQgbGluZXMgYnkgYWRkaW5nIHBvaW50cyB0byB0aGUgZW5kIG9mIHRoZSBjb29yZGluYXRlcyBhcnJheS5cbiAgICogQHBhcmFtIHshRmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlIHRvIGJlIGV4dGVuZGVkLlxuICAgKiBAYXBpXG4gICAqL1xuICBEcmF3LnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbiBleHRlbmQgKGZlYXR1cmUpIHtcbiAgICB2YXIgZ2VvbWV0cnkgPSBmZWF0dXJlLmdldEdlb21ldHJ5KCk7XG4gICAgdmFyIGxpbmVTdHJpbmcgPSAvKiogQHR5cGUge0xpbmVTdHJpbmd9ICovIChnZW9tZXRyeSk7XG4gICAgdGhpcy5za2V0Y2hGZWF0dXJlXyA9IGZlYXR1cmU7XG4gICAgdGhpcy5za2V0Y2hDb29yZHNfID0gbGluZVN0cmluZy5nZXRDb29yZGluYXRlcygpO1xuICAgIHZhciBsYXN0ID0gdGhpcy5za2V0Y2hDb29yZHNfW3RoaXMuc2tldGNoQ29vcmRzXy5sZW5ndGggLSAxXTtcbiAgICB0aGlzLmZpbmlzaENvb3JkaW5hdGVfID0gbGFzdC5zbGljZSgpO1xuICAgIHRoaXMuc2tldGNoQ29vcmRzXy5wdXNoKGxhc3Quc2xpY2UoKSk7XG4gICAgdGhpcy51cGRhdGVTa2V0Y2hGZWF0dXJlc18oKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IERyYXdFdmVudChEcmF3RXZlbnRUeXBlLkRSQVdTVEFSVCwgdGhpcy5za2V0Y2hGZWF0dXJlXykpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWRyYXcgdGhlIHNrZXRjaCBmZWF0dXJlcy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIERyYXcucHJvdG90eXBlLnVwZGF0ZVNrZXRjaEZlYXR1cmVzXyA9IGZ1bmN0aW9uIHVwZGF0ZVNrZXRjaEZlYXR1cmVzXyAoKSB7XG4gICAgdmFyIHNrZXRjaEZlYXR1cmVzID0gW107XG4gICAgaWYgKHRoaXMuc2tldGNoRmVhdHVyZV8pIHtcbiAgICAgIHNrZXRjaEZlYXR1cmVzLnB1c2godGhpcy5za2V0Y2hGZWF0dXJlXyk7XG4gICAgfVxuICAgIGlmICh0aGlzLnNrZXRjaExpbmVfKSB7XG4gICAgICBza2V0Y2hGZWF0dXJlcy5wdXNoKHRoaXMuc2tldGNoTGluZV8pO1xuICAgIH1cbiAgICBpZiAodGhpcy5za2V0Y2hQb2ludF8pIHtcbiAgICAgIHNrZXRjaEZlYXR1cmVzLnB1c2godGhpcy5za2V0Y2hQb2ludF8pO1xuICAgIH1cbiAgICB2YXIgb3ZlcmxheVNvdXJjZSA9IC8qKiBAdHlwZSB7VmVjdG9yU291cmNlfSAqLyAodGhpcy5vdmVybGF5Xy5nZXRTb3VyY2UoKSk7XG4gICAgb3ZlcmxheVNvdXJjZS5jbGVhcih0cnVlKTtcbiAgICBvdmVybGF5U291cmNlLmFkZEZlYXR1cmVzKHNrZXRjaEZlYXR1cmVzKTtcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIERyYXcucHJvdG90eXBlLnVwZGF0ZVN0YXRlXyA9IGZ1bmN0aW9uIHVwZGF0ZVN0YXRlXyAoKSB7XG4gICAgdmFyIG1hcCA9IHRoaXMuZ2V0TWFwKCk7XG4gICAgdmFyIGFjdGl2ZSA9IHRoaXMuZ2V0QWN0aXZlKCk7XG4gICAgaWYgKCFtYXAgfHwgIWFjdGl2ZSkge1xuICAgICAgdGhpcy5hYm9ydERyYXdpbmdfKCk7XG4gICAgfVxuICAgIHRoaXMub3ZlcmxheV8uc2V0TWFwKGFjdGl2ZSA/IG1hcCA6IG51bGwpO1xuICB9O1xuXG4gIHJldHVybiBEcmF3O1xufShQb2ludGVySW50ZXJhY3Rpb24pKTtcblxuXG4vKipcbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLlN0eWxlRnVuY3Rpb259IFN0eWxlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0RGVmYXVsdFN0eWxlRnVuY3Rpb24oKSB7XG4gIHZhciBzdHlsZXMgPSBjcmVhdGVFZGl0aW5nU3R5bGUoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGZlYXR1cmUsIHJlc29sdXRpb24pIHtcbiAgICByZXR1cm4gc3R5bGVzW2ZlYXR1cmUuZ2V0R2VvbWV0cnkoKS5nZXRUeXBlKCldO1xuICB9O1xufVxuXG5cbi8qKlxuICogQ3JlYXRlIGEgYGdlb21ldHJ5RnVuY3Rpb25gIGZvciBgdHlwZTogJ0NpcmNsZSdgIHRoYXQgd2lsbCBjcmVhdGUgYSByZWd1bGFyXG4gKiBwb2x5Z29uIHdpdGggYSB1c2VyIHNwZWNpZmllZCBudW1iZXIgb2Ygc2lkZXMgYW5kIHN0YXJ0IGFuZ2xlIGluc3RlYWQgb2YgYW5cbiAqIGBpbXBvcnQoXCIuLi9nZW9tL0NpcmNsZS5qc1wiKS5DaXJjbGVgIGdlb21ldHJ5LlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfc2lkZXMgTnVtYmVyIG9mIHNpZGVzIG9mIHRoZSByZWd1bGFyIHBvbHlnb24uIERlZmF1bHQgaXNcbiAqICAgICAzMi5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2FuZ2xlIEFuZ2xlIG9mIHRoZSBmaXJzdCBwb2ludCBpbiByYWRpYW5zLiAwIG1lYW5zIEVhc3QuXG4gKiAgICAgRGVmYXVsdCBpcyB0aGUgYW5nbGUgZGVmaW5lZCBieSB0aGUgaGVhZGluZyBmcm9tIHRoZSBjZW50ZXIgb2YgdGhlXG4gKiAgICAgcmVndWxhciBwb2x5Z29uIHRvIHRoZSBjdXJyZW50IHBvaW50ZXIgcG9zaXRpb24uXG4gKiBAcmV0dXJuIHtHZW9tZXRyeUZ1bmN0aW9ufSBGdW5jdGlvbiB0aGF0IGRyYXdzIGFcbiAqICAgICBwb2x5Z29uLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmVndWxhclBvbHlnb24ob3B0X3NpZGVzLCBvcHRfYW5nbGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvb3JkaW5hdGVzLCBvcHRfZ2VvbWV0cnkpIHtcbiAgICB2YXIgY2VudGVyID0gLyoqIEB0eXBlIHtMaW5lQ29vcmRUeXBlfSAqLyAoY29vcmRpbmF0ZXMpWzBdO1xuICAgIHZhciBlbmQgPSAvKiogQHR5cGUge0xpbmVDb29yZFR5cGV9ICovIChjb29yZGluYXRlcylbMV07XG4gICAgdmFyIHJhZGl1cyA9IE1hdGguc3FydChcbiAgICAgIHNxdWFyZWRDb29yZGluYXRlRGlzdGFuY2UoY2VudGVyLCBlbmQpKTtcbiAgICB2YXIgZ2VvbWV0cnkgPSBvcHRfZ2VvbWV0cnkgPyAvKiogQHR5cGUge1BvbHlnb259ICovIChvcHRfZ2VvbWV0cnkpIDpcbiAgICAgIGZyb21DaXJjbGUobmV3IENpcmNsZShjZW50ZXIpLCBvcHRfc2lkZXMpO1xuICAgIHZhciBhbmdsZSA9IG9wdF9hbmdsZTtcbiAgICBpZiAoIW9wdF9hbmdsZSkge1xuICAgICAgdmFyIHggPSBlbmRbMF0gLSBjZW50ZXJbMF07XG4gICAgICB2YXIgeSA9IGVuZFsxXSAtIGNlbnRlclsxXTtcbiAgICAgIGFuZ2xlID0gTWF0aC5hdGFuKHkgLyB4KSAtICh4IDwgMCA/IE1hdGguUEkgOiAwKTtcbiAgICB9XG4gICAgbWFrZVJlZ3VsYXIoZ2VvbWV0cnksIGNlbnRlciwgcmFkaXVzLCBhbmdsZSk7XG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuICB9O1xufVxuXG5cbi8qKlxuICogQ3JlYXRlIGEgYGdlb21ldHJ5RnVuY3Rpb25gIHRoYXQgd2lsbCBjcmVhdGUgYSBib3gtc2hhcGVkIHBvbHlnb24gKGFsaWduZWRcbiAqIHdpdGggdGhlIGNvb3JkaW5hdGUgc3lzdGVtIGF4ZXMpLiAgVXNlIHRoaXMgd2l0aCB0aGUgZHJhdyBpbnRlcmFjdGlvbiBhbmRcbiAqIGB0eXBlOiAnQ2lyY2xlJ2AgdG8gcmV0dXJuIGEgYm94IGluc3RlYWQgb2YgYSBjaXJjbGUgZ2VvbWV0cnkuXG4gKiBAcmV0dXJuIHtHZW9tZXRyeUZ1bmN0aW9ufSBGdW5jdGlvbiB0aGF0IGRyYXdzIGEgYm94LXNoYXBlZCBwb2x5Z29uLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQm94KCkge1xuICByZXR1cm4gKFxuICAgIGZ1bmN0aW9uKGNvb3JkaW5hdGVzLCBvcHRfZ2VvbWV0cnkpIHtcbiAgICAgIHZhciBleHRlbnQgPSBib3VuZGluZ0V4dGVudCgvKiogQHR5cGUge0xpbmVDb29yZFR5cGV9ICovIChjb29yZGluYXRlcykpO1xuICAgICAgdmFyIGJveENvb3JkaW5hdGVzID0gW1tcbiAgICAgICAgZ2V0Qm90dG9tTGVmdChleHRlbnQpLFxuICAgICAgICBnZXRCb3R0b21SaWdodChleHRlbnQpLFxuICAgICAgICBnZXRUb3BSaWdodChleHRlbnQpLFxuICAgICAgICBnZXRUb3BMZWZ0KGV4dGVudCksXG4gICAgICAgIGdldEJvdHRvbUxlZnQoZXh0ZW50KVxuICAgICAgXV07XG4gICAgICB2YXIgZ2VvbWV0cnkgPSBvcHRfZ2VvbWV0cnk7XG4gICAgICBpZiAoZ2VvbWV0cnkpIHtcbiAgICAgICAgZ2VvbWV0cnkuc2V0Q29vcmRpbmF0ZXMoYm94Q29vcmRpbmF0ZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2VvbWV0cnkgPSBuZXcgUG9seWdvbihib3hDb29yZGluYXRlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2VvbWV0cnk7XG4gICAgfVxuICApO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBkcmF3aW5nIG1vZGUuICBUaGUgbW9kZSBmb3IgbXVsdC1wYXJ0IGdlb21ldHJpZXMgaXMgdGhlIHNhbWUgYXMgZm9yXG4gKiB0aGVpciBzaW5nbGUtcGFydCBjb3VzaW5zLlxuICogQHBhcmFtIHtHZW9tZXRyeVR5cGV9IHR5cGUgR2VvbWV0cnkgdHlwZS5cbiAqIEByZXR1cm4ge01vZGV9IERyYXdpbmcgbW9kZS5cbiAqL1xuZnVuY3Rpb24gZ2V0TW9kZSh0eXBlKSB7XG4gIHZhciBtb2RlO1xuICBpZiAodHlwZSA9PT0gR2VvbWV0cnlUeXBlLlBPSU5UIHx8XG4gICAgICB0eXBlID09PSBHZW9tZXRyeVR5cGUuTVVMVElfUE9JTlQpIHtcbiAgICBtb2RlID0gTW9kZS5QT0lOVDtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBHZW9tZXRyeVR5cGUuTElORV9TVFJJTkcgfHxcbiAgICAgIHR5cGUgPT09IEdlb21ldHJ5VHlwZS5NVUxUSV9MSU5FX1NUUklORykge1xuICAgIG1vZGUgPSBNb2RlLkxJTkVfU1RSSU5HO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IEdlb21ldHJ5VHlwZS5QT0xZR09OIHx8XG4gICAgICB0eXBlID09PSBHZW9tZXRyeVR5cGUuTVVMVElfUE9MWUdPTikge1xuICAgIG1vZGUgPSBNb2RlLlBPTFlHT047XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gR2VvbWV0cnlUeXBlLkNJUkNMRSkge1xuICAgIG1vZGUgPSBNb2RlLkNJUkNMRTtcbiAgfVxuICByZXR1cm4gKFxuICAgIC8qKiBAdHlwZSB7IU1vZGV9ICovIChtb2RlKVxuICApO1xufVxuXG5cbmV4cG9ydCBkZWZhdWx0IERyYXc7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURyYXcuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL0V4dGVudFxuICovXG5pbXBvcnQgRmVhdHVyZSBmcm9tICcuLi9GZWF0dXJlLmpzJztcbmltcG9ydCBNYXBCcm93c2VyRXZlbnRUeXBlIGZyb20gJy4uL01hcEJyb3dzZXJFdmVudFR5cGUuanMnO1xuaW1wb3J0IHtzcXVhcmVkRGlzdGFuY2VUb1NlZ21lbnQsIGNsb3Nlc3RPblNlZ21lbnQsIGRpc3RhbmNlIGFzIGNvb3JkaW5hdGVEaXN0YW5jZSwgc3F1YXJlZERpc3RhbmNlIGFzIHNxdWFyZWRDb29yZGluYXRlRGlzdGFuY2V9IGZyb20gJy4uL2Nvb3JkaW5hdGUuanMnO1xuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cy9FdmVudC5qcyc7XG5pbXBvcnQge2JvdW5kaW5nRXh0ZW50LCBnZXRBcmVhfSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IEdlb21ldHJ5VHlwZSBmcm9tICcuLi9nZW9tL0dlb21ldHJ5VHlwZS5qcyc7XG5pbXBvcnQgUG9pbnQgZnJvbSAnLi4vZ2VvbS9Qb2ludC5qcyc7XG5pbXBvcnQge2Zyb21FeHRlbnQgYXMgcG9seWdvbkZyb21FeHRlbnR9IGZyb20gJy4uL2dlb20vUG9seWdvbi5qcyc7XG5pbXBvcnQgUG9pbnRlckludGVyYWN0aW9uIGZyb20gJy4vUG9pbnRlci5qcyc7XG5pbXBvcnQgVmVjdG9yTGF5ZXIgZnJvbSAnLi4vbGF5ZXIvVmVjdG9yLmpzJztcbmltcG9ydCBWZWN0b3JTb3VyY2UgZnJvbSAnLi4vc291cmNlL1ZlY3Rvci5qcyc7XG5pbXBvcnQge2NyZWF0ZUVkaXRpbmdTdHlsZX0gZnJvbSAnLi4vc3R5bGUvU3R5bGUuanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBbZXh0ZW50XSBJbml0aWFsIGV4dGVudC4gRGVmYXVsdHMgdG8gbm9cbiAqIGluaXRpYWwgZXh0ZW50LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUxpa2V9IFtib3hTdHlsZV1cbiAqIFN0eWxlIGZvciB0aGUgZHJhd24gZXh0ZW50IGJveC4gRGVmYXVsdHMgdG9cbiAqIHtAbGluayBtb2R1bGU6b2wvc3R5bGUvU3R5bGV+Y3JlYXRlRWRpdGluZygpWydQb2x5Z29uJ119XG4gKiBAcHJvcGVydHkge251bWJlcn0gW3BpeGVsVG9sZXJhbmNlPTEwXSBQaXhlbCB0b2xlcmFuY2UgZm9yIGNvbnNpZGVyaW5nIHRoZVxuICogcG9pbnRlciBjbG9zZSBlbm91Z2ggdG8gYSBzZWdtZW50IG9yIHZlcnRleCBmb3IgZWRpdGluZy5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVMaWtlfSBbcG9pbnRlclN0eWxlXVxuICogU3R5bGUgZm9yIHRoZSBjdXJzb3IgdXNlZCB0byBkcmF3IHRoZSBleHRlbnQuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3N0eWxlL1N0eWxlfmNyZWF0ZUVkaXRpbmcoKVsnUG9pbnQnXX1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3dyYXBYPWZhbHNlXSBXcmFwIHRoZSBkcmF3biBleHRlbnQgYWNyb3NzIG11bHRpcGxlIG1hcHNcbiAqIGluIHRoZSBYIGRpcmVjdGlvbj8gT25seSBhZmZlY3RzIHZpc3VhbHMsIG5vdCBmdW5jdGlvbmFsaXR5LlxuICovXG5cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG52YXIgRXh0ZW50RXZlbnRUeXBlID0ge1xuICAvKipcbiAgICogVHJpZ2dlcmVkIGFmdGVyIHRoZSBleHRlbnQgaXMgY2hhbmdlZFxuICAgKiBAZXZlbnQgRXh0ZW50RXZlbnRUeXBlI2V4dGVudGNoYW5nZWRcbiAgICogQGFwaVxuICAgKi9cbiAgRVhURU5UQ0hBTkdFRDogJ2V4dGVudGNoYW5nZWQnXG59O1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogRXZlbnRzIGVtaXR0ZWQgYnkge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9FeHRlbnR+RXh0ZW50SW50ZXJhY3Rpb259IGluc3RhbmNlcyBhcmVcbiAqIGluc3RhbmNlcyBvZiB0aGlzIHR5cGUuXG4gKi9cbnZhciBFeHRlbnRJbnRlcmFjdGlvbkV2ZW50ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoRXZlbnQpIHtcbiAgZnVuY3Rpb24gRXh0ZW50SW50ZXJhY3Rpb25FdmVudChleHRlbnQpIHtcbiAgICBFdmVudC5jYWxsKHRoaXMsIEV4dGVudEV2ZW50VHlwZS5FWFRFTlRDSEFOR0VEKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IGV4dGVudC5cbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5leHRlbnQgPSBleHRlbnQ7XG4gIH1cblxuICBpZiAoIEV2ZW50ICkgRXh0ZW50SW50ZXJhY3Rpb25FdmVudC5fX3Byb3RvX18gPSBFdmVudDtcbiAgRXh0ZW50SW50ZXJhY3Rpb25FdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFdmVudCAmJiBFdmVudC5wcm90b3R5cGUgKTtcbiAgRXh0ZW50SW50ZXJhY3Rpb25FdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFeHRlbnRJbnRlcmFjdGlvbkV2ZW50O1xuXG4gIHJldHVybiBFeHRlbnRJbnRlcmFjdGlvbkV2ZW50O1xufShFdmVudCkpO1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWxsb3dzIHRoZSB1c2VyIHRvIGRyYXcgYSB2ZWN0b3IgYm94IGJ5IGNsaWNraW5nIGFuZCBkcmFnZ2luZyBvbiB0aGUgbWFwLlxuICogT25jZSBkcmF3biwgdGhlIHZlY3RvciBib3ggY2FuIGJlIG1vZGlmaWVkIGJ5IGRyYWdnaW5nIGl0cyB2ZXJ0aWNlcyBvciBlZGdlcy5cbiAqIFRoaXMgaW50ZXJhY3Rpb24gaXMgb25seSBzdXBwb3J0ZWQgZm9yIG1vdXNlIGRldmljZXMuXG4gKlxuICogQGZpcmVzIEV2ZW50XG4gKiBAYXBpXG4gKi9cbnZhciBFeHRlbnRJbnRlcmFjdGlvbiA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFBvaW50ZXJJbnRlcmFjdGlvbikge1xuICBmdW5jdGlvbiBFeHRlbnRJbnRlcmFjdGlvbihvcHRfb3B0aW9ucykge1xuXG4gICAgdmFyIG9wdGlvbnMgPSBvcHRfb3B0aW9ucyB8fCB7fTtcblxuICAgIFBvaW50ZXJJbnRlcmFjdGlvbi5jYWxsKC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9Qb2ludGVyLmpzXCIpLk9wdGlvbnN9ICovIHRoaXMsIChvcHRpb25zKSk7XG5cbiAgICAvKipcbiAgICAgKiBFeHRlbnQgb2YgdGhlIGRyYXduIGJveFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5leHRlbnRfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yIHBvaW50ZXIgbW92ZSBldmVudHNcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24gKGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZSk6IGltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR8bnVsbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucG9pbnRlckhhbmRsZXJfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFBpeGVsIHRocmVzaG9sZCB0byBzbmFwIHRvIGV4dGVudFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnBpeGVsVG9sZXJhbmNlXyA9IG9wdGlvbnMucGl4ZWxUb2xlcmFuY2UgIT09IHVuZGVmaW5lZCA/XG4gICAgICBvcHRpb25zLnBpeGVsVG9sZXJhbmNlIDogMTA7XG5cbiAgICAvKipcbiAgICAgKiBJcyB0aGUgcG9pbnRlciBzbmFwcGVkIHRvIGFuIGV4dGVudCB2ZXJ0ZXhcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc25hcHBlZFRvVmVydGV4XyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogRmVhdHVyZSBmb3IgZGlzcGxheWluZyB0aGUgdmlzaWJsZSBleHRlbnRcbiAgICAgKiBAdHlwZSB7RmVhdHVyZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZXh0ZW50RmVhdHVyZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogRmVhdHVyZSBmb3IgZGlzcGxheWluZyB0aGUgdmlzaWJsZSBwb2ludGVyXG4gICAgICogQHR5cGUge0ZlYXR1cmV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnZlcnRleEZlYXR1cmVfID0gbnVsbDtcblxuICAgIGlmICghb3B0X29wdGlvbnMpIHtcbiAgICAgIG9wdF9vcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGF5ZXIgZm9yIHRoZSBleHRlbnRGZWF0dXJlXG4gICAgICogQHR5cGUge1ZlY3RvckxheWVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5leHRlbnRPdmVybGF5XyA9IG5ldyBWZWN0b3JMYXllcih7XG4gICAgICBzb3VyY2U6IG5ldyBWZWN0b3JTb3VyY2Uoe1xuICAgICAgICB1c2VTcGF0aWFsSW5kZXg6IGZhbHNlLFxuICAgICAgICB3cmFwWDogISFvcHRfb3B0aW9ucy53cmFwWFxuICAgICAgfSksXG4gICAgICBzdHlsZTogb3B0X29wdGlvbnMuYm94U3R5bGUgPyBvcHRfb3B0aW9ucy5ib3hTdHlsZSA6IGdldERlZmF1bHRFeHRlbnRTdHlsZUZ1bmN0aW9uKCksXG4gICAgICB1cGRhdGVXaGlsZUFuaW1hdGluZzogdHJ1ZSxcbiAgICAgIHVwZGF0ZVdoaWxlSW50ZXJhY3Rpbmc6IHRydWVcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIExheWVyIGZvciB0aGUgdmVydGV4RmVhdHVyZVxuICAgICAqIEB0eXBlIHtWZWN0b3JMYXllcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudmVydGV4T3ZlcmxheV8gPSBuZXcgVmVjdG9yTGF5ZXIoe1xuICAgICAgc291cmNlOiBuZXcgVmVjdG9yU291cmNlKHtcbiAgICAgICAgdXNlU3BhdGlhbEluZGV4OiBmYWxzZSxcbiAgICAgICAgd3JhcFg6ICEhb3B0X29wdGlvbnMud3JhcFhcbiAgICAgIH0pLFxuICAgICAgc3R5bGU6IG9wdF9vcHRpb25zLnBvaW50ZXJTdHlsZSA/IG9wdF9vcHRpb25zLnBvaW50ZXJTdHlsZSA6IGdldERlZmF1bHRQb2ludGVyU3R5bGVGdW5jdGlvbigpLFxuICAgICAgdXBkYXRlV2hpbGVBbmltYXRpbmc6IHRydWUsXG4gICAgICB1cGRhdGVXaGlsZUludGVyYWN0aW5nOiB0cnVlXG4gICAgfSk7XG5cbiAgICBpZiAob3B0X29wdGlvbnMuZXh0ZW50KSB7XG4gICAgICB0aGlzLnNldEV4dGVudChvcHRfb3B0aW9ucy5leHRlbnQpO1xuICAgIH1cbiAgfVxuXG4gIGlmICggUG9pbnRlckludGVyYWN0aW9uICkgRXh0ZW50SW50ZXJhY3Rpb24uX19wcm90b19fID0gUG9pbnRlckludGVyYWN0aW9uO1xuICBFeHRlbnRJbnRlcmFjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQb2ludGVySW50ZXJhY3Rpb24gJiYgUG9pbnRlckludGVyYWN0aW9uLnByb3RvdHlwZSApO1xuICBFeHRlbnRJbnRlcmFjdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFeHRlbnRJbnRlcmFjdGlvbjtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9waXhlbC5qc1wiKS5QaXhlbH0gcGl4ZWwgY3Vyc29yIGxvY2F0aW9uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLmRlZmF1bHR9IG1hcCBtYXBcbiAgICogQHJldHVybnMge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZXxudWxsfSBzbmFwcGVkIHZlcnRleCBvbiBleHRlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEV4dGVudEludGVyYWN0aW9uLnByb3RvdHlwZS5zbmFwVG9WZXJ0ZXhfID0gZnVuY3Rpb24gc25hcFRvVmVydGV4XyAocGl4ZWwsIG1hcCkge1xuICAgIHZhciBwaXhlbENvb3JkaW5hdGUgPSBtYXAuZ2V0Q29vcmRpbmF0ZUZyb21QaXhlbChwaXhlbCk7XG4gICAgdmFyIHNvcnRCeURpc3RhbmNlID0gZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIHNxdWFyZWREaXN0YW5jZVRvU2VnbWVudChwaXhlbENvb3JkaW5hdGUsIGEpIC1cbiAgICAgICAgICBzcXVhcmVkRGlzdGFuY2VUb1NlZ21lbnQocGl4ZWxDb29yZGluYXRlLCBiKTtcbiAgICB9O1xuICAgIHZhciBleHRlbnQgPSB0aGlzLmdldEV4dGVudCgpO1xuICAgIGlmIChleHRlbnQpIHtcbiAgICAgIC8vY29udmVydCBleHRlbnRzIHRvIGxpbmUgc2VnbWVudHMgYW5kIGZpbmQgdGhlIHNlZ21lbnQgY2xvc2VzdCB0byBwaXhlbENvb3JkaW5hdGVcbiAgICAgIHZhciBzZWdtZW50cyA9IGdldFNlZ21lbnRzKGV4dGVudCk7XG4gICAgICBzZWdtZW50cy5zb3J0KHNvcnRCeURpc3RhbmNlKTtcbiAgICAgIHZhciBjbG9zZXN0U2VnbWVudCA9IHNlZ21lbnRzWzBdO1xuXG4gICAgICB2YXIgdmVydGV4ID0gKGNsb3Nlc3RPblNlZ21lbnQocGl4ZWxDb29yZGluYXRlLFxuICAgICAgICBjbG9zZXN0U2VnbWVudCkpO1xuICAgICAgdmFyIHZlcnRleFBpeGVsID0gbWFwLmdldFBpeGVsRnJvbUNvb3JkaW5hdGUodmVydGV4KTtcblxuICAgICAgLy9pZiB0aGUgZGlzdGFuY2UgaXMgd2l0aGluIHRvbGVyYW5jZSwgc25hcCB0byB0aGUgc2VnbWVudFxuICAgICAgaWYgKGNvb3JkaW5hdGVEaXN0YW5jZShwaXhlbCwgdmVydGV4UGl4ZWwpIDw9IHRoaXMucGl4ZWxUb2xlcmFuY2VfKSB7XG4gICAgICAgIC8vdGVzdCBpZiB3ZSBzaG91bGQgZnVydGhlciBzbmFwIHRvIGEgdmVydGV4XG4gICAgICAgIHZhciBwaXhlbDEgPSBtYXAuZ2V0UGl4ZWxGcm9tQ29vcmRpbmF0ZShjbG9zZXN0U2VnbWVudFswXSk7XG4gICAgICAgIHZhciBwaXhlbDIgPSBtYXAuZ2V0UGl4ZWxGcm9tQ29vcmRpbmF0ZShjbG9zZXN0U2VnbWVudFsxXSk7XG4gICAgICAgIHZhciBzcXVhcmVkRGlzdDEgPSBzcXVhcmVkQ29vcmRpbmF0ZURpc3RhbmNlKHZlcnRleFBpeGVsLCBwaXhlbDEpO1xuICAgICAgICB2YXIgc3F1YXJlZERpc3QyID0gc3F1YXJlZENvb3JkaW5hdGVEaXN0YW5jZSh2ZXJ0ZXhQaXhlbCwgcGl4ZWwyKTtcbiAgICAgICAgdmFyIGRpc3QgPSBNYXRoLnNxcnQoTWF0aC5taW4oc3F1YXJlZERpc3QxLCBzcXVhcmVkRGlzdDIpKTtcbiAgICAgICAgdGhpcy5zbmFwcGVkVG9WZXJ0ZXhfID0gZGlzdCA8PSB0aGlzLnBpeGVsVG9sZXJhbmNlXztcbiAgICAgICAgaWYgKHRoaXMuc25hcHBlZFRvVmVydGV4Xykge1xuICAgICAgICAgIHZlcnRleCA9IHNxdWFyZWREaXN0MSA+IHNxdWFyZWREaXN0MiA/XG4gICAgICAgICAgICBjbG9zZXN0U2VnbWVudFsxXSA6IGNsb3Nlc3RTZWdtZW50WzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2ZXJ0ZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgcG9pbnRlciBtb3ZlIGV2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBFeHRlbnRJbnRlcmFjdGlvbi5wcm90b3R5cGUuaGFuZGxlUG9pbnRlck1vdmVfID0gZnVuY3Rpb24gaGFuZGxlUG9pbnRlck1vdmVfIChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICB2YXIgcGl4ZWwgPSBtYXBCcm93c2VyRXZlbnQucGl4ZWw7XG4gICAgdmFyIG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG5cbiAgICB2YXIgdmVydGV4ID0gdGhpcy5zbmFwVG9WZXJ0ZXhfKHBpeGVsLCBtYXApO1xuICAgIGlmICghdmVydGV4KSB7XG4gICAgICB2ZXJ0ZXggPSBtYXAuZ2V0Q29vcmRpbmF0ZUZyb21QaXhlbChwaXhlbCk7XG4gICAgfVxuICAgIHRoaXMuY3JlYXRlT3JVcGRhdGVQb2ludGVyRmVhdHVyZV8odmVydGV4KTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgZXh0ZW50XG4gICAqIEByZXR1cm5zIHtGZWF0dXJlfSBleHRlbnQgYXMgZmVhdHJ1ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgRXh0ZW50SW50ZXJhY3Rpb24ucHJvdG90eXBlLmNyZWF0ZU9yVXBkYXRlRXh0ZW50RmVhdHVyZV8gPSBmdW5jdGlvbiBjcmVhdGVPclVwZGF0ZUV4dGVudEZlYXR1cmVfIChleHRlbnQpIHtcbiAgICB2YXIgZXh0ZW50RmVhdHVyZSA9IHRoaXMuZXh0ZW50RmVhdHVyZV87XG5cbiAgICBpZiAoIWV4dGVudEZlYXR1cmUpIHtcbiAgICAgIGlmICghZXh0ZW50KSB7XG4gICAgICAgIGV4dGVudEZlYXR1cmUgPSBuZXcgRmVhdHVyZSh7fSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleHRlbnRGZWF0dXJlID0gbmV3IEZlYXR1cmUocG9seWdvbkZyb21FeHRlbnQoZXh0ZW50KSk7XG4gICAgICB9XG4gICAgICB0aGlzLmV4dGVudEZlYXR1cmVfID0gZXh0ZW50RmVhdHVyZTtcbiAgICAgIC8qKiBAdHlwZSB7VmVjdG9yU291cmNlfSAqLyAodGhpcy5leHRlbnRPdmVybGF5Xy5nZXRTb3VyY2UoKSkuYWRkRmVhdHVyZShleHRlbnRGZWF0dXJlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFleHRlbnQpIHtcbiAgICAgICAgZXh0ZW50RmVhdHVyZS5zZXRHZW9tZXRyeSh1bmRlZmluZWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXh0ZW50RmVhdHVyZS5zZXRHZW9tZXRyeShwb2x5Z29uRnJvbUV4dGVudChleHRlbnQpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV4dGVudEZlYXR1cmU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSB2ZXJ0ZXggbG9jYXRpb24gb2YgZmVhdHVyZVxuICAgKiBAcmV0dXJucyB7RmVhdHVyZX0gdmVydGV4IGFzIGZlYXR1cmVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEV4dGVudEludGVyYWN0aW9uLnByb3RvdHlwZS5jcmVhdGVPclVwZGF0ZVBvaW50ZXJGZWF0dXJlXyA9IGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlUG9pbnRlckZlYXR1cmVfICh2ZXJ0ZXgpIHtcbiAgICB2YXIgdmVydGV4RmVhdHVyZSA9IHRoaXMudmVydGV4RmVhdHVyZV87XG4gICAgaWYgKCF2ZXJ0ZXhGZWF0dXJlKSB7XG4gICAgICB2ZXJ0ZXhGZWF0dXJlID0gbmV3IEZlYXR1cmUobmV3IFBvaW50KHZlcnRleCkpO1xuICAgICAgdGhpcy52ZXJ0ZXhGZWF0dXJlXyA9IHZlcnRleEZlYXR1cmU7XG4gICAgICAvKiogQHR5cGUge1ZlY3RvclNvdXJjZX0gKi8gKHRoaXMudmVydGV4T3ZlcmxheV8uZ2V0U291cmNlKCkpLmFkZEZlYXR1cmUodmVydGV4RmVhdHVyZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBnZW9tZXRyeSA9IC8qKiBAdHlwZSB7UG9pbnR9ICovICh2ZXJ0ZXhGZWF0dXJlLmdldEdlb21ldHJ5KCkpO1xuICAgICAgZ2VvbWV0cnkuc2V0Q29vcmRpbmF0ZXModmVydGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHZlcnRleEZlYXR1cmU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBFeHRlbnRJbnRlcmFjdGlvbi5wcm90b3R5cGUuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiBoYW5kbGVFdmVudCAobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKCEoLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyUG9pbnRlckV2ZW50LmpzXCIpLmRlZmF1bHR9ICovIChtYXBCcm93c2VyRXZlbnQpLnBvaW50ZXJFdmVudCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvL2Rpc3BsYXkgcG9pbnRlciAoaWYgbm90IGRyYWdnaW5nKVxuICAgIGlmIChtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJNT1ZFICYmICF0aGlzLmhhbmRsaW5nRG93blVwU2VxdWVuY2UpIHtcbiAgICAgIHRoaXMuaGFuZGxlUG9pbnRlck1vdmVfKG1hcEJyb3dzZXJFdmVudCk7XG4gICAgfVxuICAgIC8vY2FsbCBwb2ludGVyIHRvIGRldGVybWluZSB1cC9kb3duL2RyYWdcbiAgICBQb2ludGVySW50ZXJhY3Rpb24ucHJvdG90eXBlLmhhbmRsZUV2ZW50LmNhbGwodGhpcywgbWFwQnJvd3NlckV2ZW50KTtcbiAgICAvL3JldHVybiBmYWxzZSB0byBzdG9wIHByb3BhZ2F0aW9uXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgRXh0ZW50SW50ZXJhY3Rpb24ucHJvdG90eXBlLmhhbmRsZURvd25FdmVudCA9IGZ1bmN0aW9uIGhhbmRsZURvd25FdmVudCAobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgdmFyIHBpeGVsID0gbWFwQnJvd3NlckV2ZW50LnBpeGVsO1xuICAgIHZhciBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuXG4gICAgdmFyIGV4dGVudCA9IHRoaXMuZ2V0RXh0ZW50KCk7XG4gICAgdmFyIHZlcnRleCA9IHRoaXMuc25hcFRvVmVydGV4XyhwaXhlbCwgbWFwKTtcblxuICAgIC8vZmluZCB0aGUgZXh0ZW50IGNvcm5lciBvcHBvc2l0ZSB0aGUgcGFzc2VkIGNvcm5lclxuICAgIHZhciBnZXRPcHBvc2luZ1BvaW50ID0gZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgIHZhciB4XyA9IG51bGw7XG4gICAgICB2YXIgeV8gPSBudWxsO1xuICAgICAgaWYgKHBvaW50WzBdID09IGV4dGVudFswXSkge1xuICAgICAgICB4XyA9IGV4dGVudFsyXTtcbiAgICAgIH0gZWxzZSBpZiAocG9pbnRbMF0gPT0gZXh0ZW50WzJdKSB7XG4gICAgICAgIHhfID0gZXh0ZW50WzBdO1xuICAgICAgfVxuICAgICAgaWYgKHBvaW50WzFdID09IGV4dGVudFsxXSkge1xuICAgICAgICB5XyA9IGV4dGVudFszXTtcbiAgICAgIH0gZWxzZSBpZiAocG9pbnRbMV0gPT0gZXh0ZW50WzNdKSB7XG4gICAgICAgIHlfID0gZXh0ZW50WzFdO1xuICAgICAgfVxuICAgICAgaWYgKHhfICE9PSBudWxsICYmIHlfICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbeF8sIHlfXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgaWYgKHZlcnRleCAmJiBleHRlbnQpIHtcbiAgICAgIHZhciB4ID0gKHZlcnRleFswXSA9PSBleHRlbnRbMF0gfHwgdmVydGV4WzBdID09IGV4dGVudFsyXSkgPyB2ZXJ0ZXhbMF0gOiBudWxsO1xuICAgICAgdmFyIHkgPSAodmVydGV4WzFdID09IGV4dGVudFsxXSB8fCB2ZXJ0ZXhbMV0gPT0gZXh0ZW50WzNdKSA/IHZlcnRleFsxXSA6IG51bGw7XG5cbiAgICAgIC8vc25hcCB0byBwb2ludFxuICAgICAgaWYgKHggIT09IG51bGwgJiYgeSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnBvaW50ZXJIYW5kbGVyXyA9IGdldFBvaW50SGFuZGxlcihnZXRPcHBvc2luZ1BvaW50KHZlcnRleCkpO1xuICAgICAgLy9zbmFwIHRvIGVkZ2VcbiAgICAgIH0gZWxzZSBpZiAoeCAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnBvaW50ZXJIYW5kbGVyXyA9IGdldEVkZ2VIYW5kbGVyKFxuICAgICAgICAgIGdldE9wcG9zaW5nUG9pbnQoW3gsIGV4dGVudFsxXV0pLFxuICAgICAgICAgIGdldE9wcG9zaW5nUG9pbnQoW3gsIGV4dGVudFszXV0pXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKHkgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5wb2ludGVySGFuZGxlcl8gPSBnZXRFZGdlSGFuZGxlcihcbiAgICAgICAgICBnZXRPcHBvc2luZ1BvaW50KFtleHRlbnRbMF0sIHldKSxcbiAgICAgICAgICBnZXRPcHBvc2luZ1BvaW50KFtleHRlbnRbMl0sIHldKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIC8vbm8gc25hcCAtIG5ldyBiYm94XG4gICAgfSBlbHNlIHtcbiAgICAgIHZlcnRleCA9IG1hcC5nZXRDb29yZGluYXRlRnJvbVBpeGVsKHBpeGVsKTtcbiAgICAgIHRoaXMuc2V0RXh0ZW50KFt2ZXJ0ZXhbMF0sIHZlcnRleFsxXSwgdmVydGV4WzBdLCB2ZXJ0ZXhbMV1dKTtcbiAgICAgIHRoaXMucG9pbnRlckhhbmRsZXJfID0gZ2V0UG9pbnRIYW5kbGVyKHZlcnRleCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlOyAvL2V2ZW50IGhhbmRsZWQ7IHN0YXJ0IGRvd251cCBzZXF1ZW5jZVxuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgRXh0ZW50SW50ZXJhY3Rpb24ucHJvdG90eXBlLmhhbmRsZURyYWdFdmVudCA9IGZ1bmN0aW9uIGhhbmRsZURyYWdFdmVudCAobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKHRoaXMucG9pbnRlckhhbmRsZXJfKSB7XG4gICAgICB2YXIgcGl4ZWxDb29yZGluYXRlID0gbWFwQnJvd3NlckV2ZW50LmNvb3JkaW5hdGU7XG4gICAgICB0aGlzLnNldEV4dGVudCh0aGlzLnBvaW50ZXJIYW5kbGVyXyhwaXhlbENvb3JkaW5hdGUpKTtcbiAgICAgIHRoaXMuY3JlYXRlT3JVcGRhdGVQb2ludGVyRmVhdHVyZV8ocGl4ZWxDb29yZGluYXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBFeHRlbnRJbnRlcmFjdGlvbi5wcm90b3R5cGUuaGFuZGxlVXBFdmVudCA9IGZ1bmN0aW9uIGhhbmRsZVVwRXZlbnQgKG1hcEJyb3dzZXJFdmVudCkge1xuICAgIHRoaXMucG9pbnRlckhhbmRsZXJfID0gbnVsbDtcbiAgICAvL0lmIGJib3ggaXMgemVybyBhcmVhLCBzZXQgdG8gbnVsbDtcbiAgICB2YXIgZXh0ZW50ID0gdGhpcy5nZXRFeHRlbnQoKTtcbiAgICBpZiAoIWV4dGVudCB8fCBnZXRBcmVhKGV4dGVudCkgPT09IDApIHtcbiAgICAgIHRoaXMuc2V0RXh0ZW50KG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7IC8vU3RvcCBoYW5kbGluZyBkb3dudXAgc2VxdWVuY2VcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIEV4dGVudEludGVyYWN0aW9uLnByb3RvdHlwZS5zZXRNYXAgPSBmdW5jdGlvbiBzZXRNYXAgKG1hcCkge1xuICAgIHRoaXMuZXh0ZW50T3ZlcmxheV8uc2V0TWFwKG1hcCk7XG4gICAgdGhpcy52ZXJ0ZXhPdmVybGF5Xy5zZXRNYXAobWFwKTtcbiAgICBQb2ludGVySW50ZXJhY3Rpb24ucHJvdG90eXBlLnNldE1hcC5jYWxsKHRoaXMsIG1hcCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgZHJhd24gZXh0ZW50IGluIHRoZSB2aWV3IHByb2plY3Rpb25cbiAgICpcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gRHJhd24gZXh0ZW50IGluIHRoZSB2aWV3IHByb2plY3Rpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIEV4dGVudEludGVyYWN0aW9uLnByb3RvdHlwZS5nZXRFeHRlbnQgPSBmdW5jdGlvbiBnZXRFeHRlbnQgKCkge1xuICAgIHJldHVybiB0aGlzLmV4dGVudF87XG4gIH07XG5cbiAgLyoqXG4gICAqIE1hbnVhbGx5IHNldHMgdGhlIGRyYXduIGV4dGVudCwgdXNpbmcgdGhlIHZpZXcgcHJvamVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50XG4gICAqIEBhcGlcbiAgICovXG4gIEV4dGVudEludGVyYWN0aW9uLnByb3RvdHlwZS5zZXRFeHRlbnQgPSBmdW5jdGlvbiBzZXRFeHRlbnQgKGV4dGVudCkge1xuICAgIC8vTnVsbCBleHRlbnQgbWVhbnMgbm8gYmJveFxuICAgIHRoaXMuZXh0ZW50XyA9IGV4dGVudCA/IGV4dGVudCA6IG51bGw7XG4gICAgdGhpcy5jcmVhdGVPclVwZGF0ZUV4dGVudEZlYXR1cmVfKGV4dGVudCk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFeHRlbnRJbnRlcmFjdGlvbkV2ZW50KHRoaXMuZXh0ZW50XykpO1xuICB9O1xuXG4gIHJldHVybiBFeHRlbnRJbnRlcmFjdGlvbjtcbn0oUG9pbnRlckludGVyYWN0aW9uKSk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZGVmYXVsdCBzdHlsZSBmb3IgdGhlIGRyYXduIGJib3hcbiAqXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUZ1bmN0aW9ufSBEZWZhdWx0IEV4dGVudCBzdHlsZVxuICovXG5mdW5jdGlvbiBnZXREZWZhdWx0RXh0ZW50U3R5bGVGdW5jdGlvbigpIHtcbiAgdmFyIHN0eWxlID0gY3JlYXRlRWRpdGluZ1N0eWxlKCk7XG4gIHJldHVybiBmdW5jdGlvbihmZWF0dXJlLCByZXNvbHV0aW9uKSB7XG4gICAgcmV0dXJuIHN0eWxlW0dlb21ldHJ5VHlwZS5QT0xZR09OXTtcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkZWZhdWx0IHN0eWxlIGZvciB0aGUgcG9pbnRlclxuICpcbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLlN0eWxlRnVuY3Rpb259IERlZmF1bHQgcG9pbnRlciBzdHlsZVxuICovXG5mdW5jdGlvbiBnZXREZWZhdWx0UG9pbnRlclN0eWxlRnVuY3Rpb24oKSB7XG4gIHZhciBzdHlsZSA9IGNyZWF0ZUVkaXRpbmdTdHlsZSgpO1xuICByZXR1cm4gZnVuY3Rpb24oZmVhdHVyZSwgcmVzb2x1dGlvbikge1xuICAgIHJldHVybiBzdHlsZVtHZW9tZXRyeVR5cGUuUE9JTlRdO1xuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBmaXhlZFBvaW50IGNvcm5lciB0aGF0IHdpbGwgYmUgdW5jaGFuZ2VkIGluIHRoZSBuZXcgZXh0ZW50XG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24gKGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZSk6IGltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV2ZW50IGhhbmRsZXJcbiAqL1xuZnVuY3Rpb24gZ2V0UG9pbnRIYW5kbGVyKGZpeGVkUG9pbnQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgcmV0dXJuIGJvdW5kaW5nRXh0ZW50KFtmaXhlZFBvaW50LCBwb2ludF0pO1xuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBmaXhlZFAxIGZpcnN0IGNvcm5lciB0aGF0IHdpbGwgYmUgdW5jaGFuZ2VkIGluIHRoZSBuZXcgZXh0ZW50XG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gZml4ZWRQMiBzZWNvbmQgY29ybmVyIHRoYXQgd2lsbCBiZSB1bmNoYW5nZWQgaW4gdGhlIG5ldyBleHRlbnRcbiAqIEByZXR1cm5zIHtmdW5jdGlvbiAoaW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlKTogaW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudHxudWxsfSBldmVudCBoYW5kbGVyXG4gKi9cbmZ1bmN0aW9uIGdldEVkZ2VIYW5kbGVyKGZpeGVkUDEsIGZpeGVkUDIpIHtcbiAgaWYgKGZpeGVkUDFbMF0gPT0gZml4ZWRQMlswXSkge1xuICAgIHJldHVybiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgcmV0dXJuIGJvdW5kaW5nRXh0ZW50KFtmaXhlZFAxLCBbcG9pbnRbMF0sIGZpeGVkUDJbMV1dXSk7XG4gICAgfTtcbiAgfSBlbHNlIGlmIChmaXhlZFAxWzFdID09IGZpeGVkUDJbMV0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgIHJldHVybiBib3VuZGluZ0V4dGVudChbZml4ZWRQMSwgW2ZpeGVkUDJbMF0sIHBvaW50WzFdXV0pO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBleHRlbnRcbiAqIEByZXR1cm5zIHtBcnJheTxBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+Pn0gZXh0ZW50IGxpbmUgc2VnbWVudHNcbiAqL1xuZnVuY3Rpb24gZ2V0U2VnbWVudHMoZXh0ZW50KSB7XG4gIHJldHVybiBbXG4gICAgW1tleHRlbnRbMF0sIGV4dGVudFsxXV0sIFtleHRlbnRbMF0sIGV4dGVudFszXV1dLFxuICAgIFtbZXh0ZW50WzBdLCBleHRlbnRbM11dLCBbZXh0ZW50WzJdLCBleHRlbnRbM11dXSxcbiAgICBbW2V4dGVudFsyXSwgZXh0ZW50WzNdXSwgW2V4dGVudFsyXSwgZXh0ZW50WzFdXV0sXG4gICAgW1tleHRlbnRbMl0sIGV4dGVudFsxXV0sIFtleHRlbnRbMF0sIGV4dGVudFsxXV1dXG4gIF07XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgRXh0ZW50SW50ZXJhY3Rpb247XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUV4dGVudC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vSW50ZXJhY3Rpb25cbiAqL1xuaW1wb3J0IEJhc2VPYmplY3QgZnJvbSAnLi4vT2JqZWN0LmpzJztcbmltcG9ydCB7ZWFzZU91dCwgbGluZWFyfSBmcm9tICcuLi9lYXNpbmcuanMnO1xuaW1wb3J0IEludGVyYWN0aW9uUHJvcGVydHkgZnJvbSAnLi9Qcm9wZXJ0eS5qcyc7XG5pbXBvcnQge2NsYW1wfSBmcm9tICcuLi9tYXRoLmpzJztcblxuXG4vKipcbiAqIE9iamVjdCBsaXRlcmFsIHdpdGggY29uZmlnIG9wdGlvbnMgZm9yIGludGVyYWN0aW9ucy5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IEludGVyYWN0aW9uT3B0aW9uc1xuICogQHByb3BlcnR5IHtmdW5jdGlvbihpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdCk6Ym9vbGVhbn0gaGFuZGxlRXZlbnRcbiAqIE1ldGhvZCBjYWxsZWQgYnkgdGhlIG1hcCB0byBub3RpZnkgdGhlIGludGVyYWN0aW9uIHRoYXQgYSBicm93c2VyIGV2ZW50IHdhc1xuICogZGlzcGF0Y2hlZCB0byB0aGUgbWFwLiBJZiB0aGUgZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBwcm9wYWdhdGlvbiBvZlxuICogdGhlIGV2ZW50IHRvIG90aGVyIGludGVyYWN0aW9ucyBpbiB0aGUgbWFwJ3MgaW50ZXJhY3Rpb25zIGNoYWluIHdpbGwgYmVcbiAqIHByZXZlbnRlZCAodGhpcyBpbmNsdWRlcyBmdW5jdGlvbnMgd2l0aCBubyBleHBsaWNpdCByZXR1cm4pLlxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzOyBub3JtYWxseSBvbmx5IHVzZWQgZm9yIGNyZWF0aW5nIHN1YmNsYXNzZXMgYW5kIG5vdFxuICogaW5zdGFudGlhdGVkIGluIGFwcHMuXG4gKiBVc2VyIGFjdGlvbnMgdGhhdCBjaGFuZ2UgdGhlIHN0YXRlIG9mIHRoZSBtYXAuIFNvbWUgYXJlIHNpbWlsYXIgdG8gY29udHJvbHMsXG4gKiBidXQgYXJlIG5vdCBhc3NvY2lhdGVkIHdpdGggYSBET00gZWxlbWVudC5cbiAqIEZvciBleGFtcGxlLCB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL0tleWJvYXJkWm9vbX5LZXlib2FyZFpvb219IGlzXG4gKiBmdW5jdGlvbmFsbHkgdGhlIHNhbWUgYXMge0BsaW5rIG1vZHVsZTpvbC9jb250cm9sL1pvb21+Wm9vbX0sIGJ1dCB0cmlnZ2VyZWRcbiAqIGJ5IGEga2V5Ym9hcmQgZXZlbnQgbm90IGEgYnV0dG9uIGVsZW1lbnQgZXZlbnQuXG4gKiBBbHRob3VnaCBpbnRlcmFjdGlvbnMgZG8gbm90IGhhdmUgYSBET00gZWxlbWVudCwgc29tZSBvZiB0aGVtIGRvIHJlbmRlclxuICogdmVjdG9ycyBhbmQgc28gYXJlIHZpc2libGUgb24gdGhlIHNjcmVlbi5cbiAqIEBhcGlcbiAqL1xudmFyIEludGVyYWN0aW9uID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoQmFzZU9iamVjdCkge1xuICBmdW5jdGlvbiBJbnRlcmFjdGlvbihvcHRpb25zKSB7XG4gICAgQmFzZU9iamVjdC5jYWxsKHRoaXMpO1xuXG4gICAgaWYgKG9wdGlvbnMuaGFuZGxlRXZlbnQpIHtcbiAgICAgIHRoaXMuaGFuZGxlRXZlbnQgPSBvcHRpb25zLmhhbmRsZUV2ZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL1BsdWdnYWJsZU1hcC5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMubWFwXyA9IG51bGw7XG5cbiAgICB0aGlzLnNldEFjdGl2ZSh0cnVlKTtcbiAgfVxuXG4gIGlmICggQmFzZU9iamVjdCApIEludGVyYWN0aW9uLl9fcHJvdG9fXyA9IEJhc2VPYmplY3Q7XG4gIEludGVyYWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJhc2VPYmplY3QgJiYgQmFzZU9iamVjdC5wcm90b3R5cGUgKTtcbiAgSW50ZXJhY3Rpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW50ZXJhY3Rpb247XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoZSBpbnRlcmFjdGlvbiBpcyBjdXJyZW50bHkgYWN0aXZlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIGludGVyYWN0aW9uIGlzIGFjdGl2ZSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIEludGVyYWN0aW9uLnByb3RvdHlwZS5nZXRBY3RpdmUgPSBmdW5jdGlvbiBnZXRBY3RpdmUgKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge2Jvb2xlYW59ICovICh0aGlzLmdldChJbnRlcmFjdGlvblByb3BlcnR5LkFDVElWRSkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1hcCBhc3NvY2lhdGVkIHdpdGggdGhpcyBpbnRlcmFjdGlvbi5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLmRlZmF1bHR9IE1hcC5cbiAgICogQGFwaVxuICAgKi9cbiAgSW50ZXJhY3Rpb24ucHJvdG90eXBlLmdldE1hcCA9IGZ1bmN0aW9uIGdldE1hcCAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwXztcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnQgbWFwIGJyb3dzZXIgZXZlbnR9LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGBmYWxzZWAgdG8gc3RvcCBldmVudCBwcm9wYWdhdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgSW50ZXJhY3Rpb24ucHJvdG90eXBlLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24gaGFuZGxlRXZlbnQgKG1hcEJyb3dzZXJFdmVudCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBY3RpdmF0ZSBvciBkZWFjdGl2YXRlIHRoZSBpbnRlcmFjdGlvbi5cbiAgICogQHBhcmFtIHtib29sZWFufSBhY3RpdmUgQWN0aXZlLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBJbnRlcmFjdGlvbi5wcm90b3R5cGUuc2V0QWN0aXZlID0gZnVuY3Rpb24gc2V0QWN0aXZlIChhY3RpdmUpIHtcbiAgICB0aGlzLnNldChJbnRlcmFjdGlvblByb3BlcnR5LkFDVElWRSwgYWN0aXZlKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBpbnRlcmFjdGlvbiBmcm9tIGl0cyBjdXJyZW50IG1hcCBhbmQgYXR0YWNoIGl0IHRvIHRoZSBuZXcgbWFwLlxuICAgKiBTdWJjbGFzc2VzIG1heSBzZXQgdXAgZXZlbnQgaGFuZGxlcnMgdG8gZ2V0IG5vdGlmaWVkIGFib3V0IGNoYW5nZXMgdG9cbiAgICogdGhlIG1hcCBoZXJlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1BsdWdnYWJsZU1hcC5qc1wiKS5kZWZhdWx0fSBtYXAgTWFwLlxuICAgKi9cbiAgSW50ZXJhY3Rpb24ucHJvdG90eXBlLnNldE1hcCA9IGZ1bmN0aW9uIHNldE1hcCAobWFwKSB7XG4gICAgdGhpcy5tYXBfID0gbWFwO1xuICB9O1xuXG4gIHJldHVybiBJbnRlcmFjdGlvbjtcbn0oQmFzZU9iamVjdCkpO1xuXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9WaWV3LmpzXCIpLmRlZmF1bHR9IHZpZXcgVmlldy5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBkZWx0YSBEZWx0YS5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2R1cmF0aW9uIER1cmF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFuKHZpZXcsIGRlbHRhLCBvcHRfZHVyYXRpb24pIHtcbiAgdmFyIGN1cnJlbnRDZW50ZXIgPSB2aWV3LmdldENlbnRlcigpO1xuICBpZiAoY3VycmVudENlbnRlcikge1xuICAgIHZhciBjZW50ZXIgPSB2aWV3LmNvbnN0cmFpbkNlbnRlcihcbiAgICAgIFtjdXJyZW50Q2VudGVyWzBdICsgZGVsdGFbMF0sIGN1cnJlbnRDZW50ZXJbMV0gKyBkZWx0YVsxXV0pO1xuICAgIGlmIChvcHRfZHVyYXRpb24pIHtcbiAgICAgIHZpZXcuYW5pbWF0ZSh7XG4gICAgICAgIGR1cmF0aW9uOiBvcHRfZHVyYXRpb24sXG4gICAgICAgIGVhc2luZzogbGluZWFyLFxuICAgICAgICBjZW50ZXI6IGNlbnRlclxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpZXcuc2V0Q2VudGVyKGNlbnRlcik7XG4gICAgfVxuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL1ZpZXcuanNcIikuZGVmYXVsdH0gdmlldyBWaWV3LlxuICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPX0gb3B0X2FuY2hvciBBbmNob3IgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2R1cmF0aW9uIER1cmF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKHZpZXcsIHJvdGF0aW9uLCBvcHRfYW5jaG9yLCBvcHRfZHVyYXRpb24pIHtcbiAgcm90YXRpb24gPSB2aWV3LmNvbnN0cmFpblJvdGF0aW9uKHJvdGF0aW9uLCAwKTtcbiAgcm90YXRlV2l0aG91dENvbnN0cmFpbnRzKHZpZXcsIHJvdGF0aW9uLCBvcHRfYW5jaG9yLCBvcHRfZHVyYXRpb24pO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9WaWV3LmpzXCIpLmRlZmF1bHR9IHZpZXcgVmlldy5cbiAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gcm90YXRpb24gUm90YXRpb24uXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT19IG9wdF9hbmNob3IgQW5jaG9yIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9kdXJhdGlvbiBEdXJhdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVdpdGhvdXRDb25zdHJhaW50cyh2aWV3LCByb3RhdGlvbiwgb3B0X2FuY2hvciwgb3B0X2R1cmF0aW9uKSB7XG4gIGlmIChyb3RhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGN1cnJlbnRSb3RhdGlvbiA9IHZpZXcuZ2V0Um90YXRpb24oKTtcbiAgICB2YXIgY3VycmVudENlbnRlciA9IHZpZXcuZ2V0Q2VudGVyKCk7XG4gICAgaWYgKGN1cnJlbnRSb3RhdGlvbiAhPT0gdW5kZWZpbmVkICYmIGN1cnJlbnRDZW50ZXIgJiYgb3B0X2R1cmF0aW9uID4gMCkge1xuICAgICAgdmlldy5hbmltYXRlKHtcbiAgICAgICAgcm90YXRpb246IHJvdGF0aW9uLFxuICAgICAgICBhbmNob3I6IG9wdF9hbmNob3IsXG4gICAgICAgIGR1cmF0aW9uOiBvcHRfZHVyYXRpb24sXG4gICAgICAgIGVhc2luZzogZWFzZU91dFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpZXcucm90YXRlKHJvdGF0aW9uLCBvcHRfYW5jaG9yKTtcbiAgICB9XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vVmlldy5qc1wiKS5kZWZhdWx0fSB2aWV3IFZpZXcuXG4gKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHJlc29sdXRpb24gUmVzb2x1dGlvbiB0byBnbyB0by5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPX0gb3B0X2FuY2hvciBBbmNob3IgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2R1cmF0aW9uIER1cmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZGlyZWN0aW9uIFpvb21pbmcgZGlyZWN0aW9uOyA+IDAgaW5kaWNhdGVzXG4gKiAgICAgem9vbWluZyBvdXQsIGluIHdoaWNoIGNhc2UgdGhlIGNvbnN0cmFpbnRzIHN5c3RlbSB3aWxsIHNlbGVjdFxuICogICAgIHRoZSBsYXJnZXN0IG5lYXJlc3QgcmVzb2x1dGlvbjsgPCAwIGluZGljYXRlcyB6b29taW5nIGluLCBpblxuICogICAgIHdoaWNoIGNhc2UgdGhlIGNvbnN0cmFpbnRzIHN5c3RlbSB3aWxsIHNlbGVjdCB0aGUgc21hbGxlc3RcbiAqICAgICBuZWFyZXN0IHJlc29sdXRpb247ID09IDAgaW5kaWNhdGVzIHRoYXQgdGhlIHpvb21pbmcgZGlyZWN0aW9uXG4gKiAgICAgaXMgdW5rbm93bi9ub3QgcmVsZXZhbnQsIGluIHdoaWNoIGNhc2UgdGhlIGNvbnN0cmFpbnRzIHN5c3RlbVxuICogICAgIHdpbGwgc2VsZWN0IHRoZSBuZWFyZXN0IHJlc29sdXRpb24uIElmIG5vdCBkZWZpbmVkIDAgaXNcbiAqICAgICBhc3N1bWVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gem9vbSh2aWV3LCByZXNvbHV0aW9uLCBvcHRfYW5jaG9yLCBvcHRfZHVyYXRpb24sIG9wdF9kaXJlY3Rpb24pIHtcbiAgcmVzb2x1dGlvbiA9IHZpZXcuY29uc3RyYWluUmVzb2x1dGlvbihyZXNvbHV0aW9uLCAwLCBvcHRfZGlyZWN0aW9uKTtcbiAgem9vbVdpdGhvdXRDb25zdHJhaW50cyh2aWV3LCByZXNvbHV0aW9uLCBvcHRfYW5jaG9yLCBvcHRfZHVyYXRpb24pO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9WaWV3LmpzXCIpLmRlZmF1bHR9IHZpZXcgVmlldy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YSBEZWx0YSBmcm9tIHByZXZpb3VzIHpvb20gbGV2ZWwuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT19IG9wdF9hbmNob3IgQW5jaG9yIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9kdXJhdGlvbiBEdXJhdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHpvb21CeURlbHRhKHZpZXcsIGRlbHRhLCBvcHRfYW5jaG9yLCBvcHRfZHVyYXRpb24pIHtcbiAgdmFyIGN1cnJlbnRSZXNvbHV0aW9uID0gdmlldy5nZXRSZXNvbHV0aW9uKCk7XG4gIHZhciByZXNvbHV0aW9uID0gdmlldy5jb25zdHJhaW5SZXNvbHV0aW9uKGN1cnJlbnRSZXNvbHV0aW9uLCBkZWx0YSwgMCk7XG5cbiAgaWYgKHJlc29sdXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciByZXNvbHV0aW9ucyA9IHZpZXcuZ2V0UmVzb2x1dGlvbnMoKTtcbiAgICByZXNvbHV0aW9uID0gY2xhbXAoXG4gICAgICByZXNvbHV0aW9uLFxuICAgICAgdmlldy5nZXRNaW5SZXNvbHV0aW9uKCkgfHwgcmVzb2x1dGlvbnNbcmVzb2x1dGlvbnMubGVuZ3RoIC0gMV0sXG4gICAgICB2aWV3LmdldE1heFJlc29sdXRpb24oKSB8fCByZXNvbHV0aW9uc1swXSk7XG4gIH1cblxuICAvLyBJZiB3ZSBoYXZlIGEgY29uc3RyYWludCBvbiBjZW50ZXIsIHdlIG5lZWQgdG8gY2hhbmdlIHRoZSBhbmNob3Igc28gdGhhdCB0aGVcbiAgLy8gbmV3IGNlbnRlciBpcyB3aXRoaW4gdGhlIGV4dGVudC4gV2UgZmlyc3QgY2FsY3VsYXRlIHRoZSBuZXcgY2VudGVyLCBhcHBseVxuICAvLyB0aGUgY29uc3RyYWludCB0byBpdCwgYW5kIHRoZW4gY2FsY3VsYXRlIGJhY2sgdGhlIGFuY2hvclxuICBpZiAob3B0X2FuY2hvciAmJiByZXNvbHV0aW9uICE9PSB1bmRlZmluZWQgJiYgcmVzb2x1dGlvbiAhPT0gY3VycmVudFJlc29sdXRpb24pIHtcbiAgICB2YXIgY3VycmVudENlbnRlciA9IHZpZXcuZ2V0Q2VudGVyKCk7XG4gICAgdmFyIGNlbnRlciA9IHZpZXcuY2FsY3VsYXRlQ2VudGVyWm9vbShyZXNvbHV0aW9uLCBvcHRfYW5jaG9yKTtcbiAgICBjZW50ZXIgPSB2aWV3LmNvbnN0cmFpbkNlbnRlcihjZW50ZXIpO1xuXG4gICAgb3B0X2FuY2hvciA9IFtcbiAgICAgIChyZXNvbHV0aW9uICogY3VycmVudENlbnRlclswXSAtIGN1cnJlbnRSZXNvbHV0aW9uICogY2VudGVyWzBdKSAvXG4gICAgICAgICAgKHJlc29sdXRpb24gLSBjdXJyZW50UmVzb2x1dGlvbiksXG4gICAgICAocmVzb2x1dGlvbiAqIGN1cnJlbnRDZW50ZXJbMV0gLSBjdXJyZW50UmVzb2x1dGlvbiAqIGNlbnRlclsxXSkgL1xuICAgICAgICAgIChyZXNvbHV0aW9uIC0gY3VycmVudFJlc29sdXRpb24pXG4gICAgXTtcbiAgfVxuXG4gIHpvb21XaXRob3V0Q29uc3RyYWludHModmlldywgcmVzb2x1dGlvbiwgb3B0X2FuY2hvciwgb3B0X2R1cmF0aW9uKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vVmlldy5qc1wiKS5kZWZhdWx0fSB2aWV3IFZpZXcuXG4gKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHJlc29sdXRpb24gUmVzb2x1dGlvbiB0byBnbyB0by5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPX0gb3B0X2FuY2hvciBBbmNob3IgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2R1cmF0aW9uIER1cmF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gem9vbVdpdGhvdXRDb25zdHJhaW50cyh2aWV3LCByZXNvbHV0aW9uLCBvcHRfYW5jaG9yLCBvcHRfZHVyYXRpb24pIHtcbiAgaWYgKHJlc29sdXRpb24pIHtcbiAgICB2YXIgY3VycmVudFJlc29sdXRpb24gPSB2aWV3LmdldFJlc29sdXRpb24oKTtcbiAgICB2YXIgY3VycmVudENlbnRlciA9IHZpZXcuZ2V0Q2VudGVyKCk7XG4gICAgaWYgKGN1cnJlbnRSZXNvbHV0aW9uICE9PSB1bmRlZmluZWQgJiYgY3VycmVudENlbnRlciAmJlxuICAgICAgICByZXNvbHV0aW9uICE9PSBjdXJyZW50UmVzb2x1dGlvbiAmJiBvcHRfZHVyYXRpb24pIHtcbiAgICAgIHZpZXcuYW5pbWF0ZSh7XG4gICAgICAgIHJlc29sdXRpb246IHJlc29sdXRpb24sXG4gICAgICAgIGFuY2hvcjogb3B0X2FuY2hvcixcbiAgICAgICAgZHVyYXRpb246IG9wdF9kdXJhdGlvbixcbiAgICAgICAgZWFzaW5nOiBlYXNlT3V0XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG9wdF9hbmNob3IpIHtcbiAgICAgICAgdmFyIGNlbnRlciA9IHZpZXcuY2FsY3VsYXRlQ2VudGVyWm9vbShyZXNvbHV0aW9uLCBvcHRfYW5jaG9yKTtcbiAgICAgICAgdmlldy5zZXRDZW50ZXIoY2VudGVyKTtcbiAgICAgIH1cbiAgICAgIHZpZXcuc2V0UmVzb2x1dGlvbihyZXNvbHV0aW9uKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSW50ZXJhY3Rpb247XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUludGVyYWN0aW9uLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9LZXlib2FyZFBhblxuICovXG5pbXBvcnQge3JvdGF0ZSBhcyByb3RhdGVDb29yZGluYXRlfSBmcm9tICcuLi9jb29yZGluYXRlLmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgS2V5Q29kZSBmcm9tICcuLi9ldmVudHMvS2V5Q29kZS5qcyc7XG5pbXBvcnQge25vTW9kaWZpZXJLZXlzLCB0YXJnZXROb3RFZGl0YWJsZX0gZnJvbSAnLi4vZXZlbnRzL2NvbmRpdGlvbi5qcyc7XG5pbXBvcnQgSW50ZXJhY3Rpb24sIHtwYW59IGZyb20gJy4vSW50ZXJhY3Rpb24uanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn0gW2NvbmRpdGlvbl0gQSBmdW5jdGlvbiB0aGF0XG4gKiB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnR9IGFuZCByZXR1cm5zIGFcbiAqIGJvb2xlYW4gdG8gaW5kaWNhdGUgd2hldGhlciB0aGF0IGV2ZW50IHNob3VsZCBiZSBoYW5kbGVkLiBEZWZhdWx0IGlzXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb25+bm9Nb2RpZmllcktleXN9IGFuZFxuICoge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9ufnRhcmdldE5vdEVkaXRhYmxlfS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHVyYXRpb249MTAwXSBBbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtwaXhlbERlbHRhPTEyOF0gVGhlIGFtb3VudCBvZiBwaXhlbHMgdG8gcGFuIG9uIGVhY2gga2V5XG4gKiBwcmVzcy5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWxsb3dzIHRoZSB1c2VyIHRvIHBhbiB0aGUgbWFwIHVzaW5nIGtleWJvYXJkIGFycm93cy5cbiAqIE5vdGUgdGhhdCwgYWx0aG91Z2ggdGhpcyBpbnRlcmFjdGlvbiBpcyBieSBkZWZhdWx0IGluY2x1ZGVkIGluIG1hcHMsXG4gKiB0aGUga2V5cyBjYW4gb25seSBiZSB1c2VkIHdoZW4gYnJvd3NlciBmb2N1cyBpcyBvbiB0aGUgZWxlbWVudCB0byB3aGljaFxuICogdGhlIGtleWJvYXJkIGV2ZW50cyBhcmUgYXR0YWNoZWQuIEJ5IGRlZmF1bHQsIHRoaXMgaXMgdGhlIG1hcCBkaXYsXG4gKiB0aG91Z2ggeW91IGNhbiBjaGFuZ2UgdGhpcyB3aXRoIHRoZSBga2V5Ym9hcmRFdmVudFRhcmdldGAgaW5cbiAqIHtAbGluayBtb2R1bGU6b2wvTWFwfk1hcH0uIGBkb2N1bWVudGAgbmV2ZXIgbG9zZXMgZm9jdXMgYnV0LCBmb3IgYW55IG90aGVyXG4gKiBlbGVtZW50LCBmb2N1cyB3aWxsIGhhdmUgdG8gYmUgb24sIGFuZCByZXR1cm5lZCB0bywgdGhpcyBlbGVtZW50IGlmIHRoZSBrZXlzXG4gKiBhcmUgdG8gZnVuY3Rpb24uXG4gKiBTZWUgYWxzbyB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL0tleWJvYXJkWm9vbX5LZXlib2FyZFpvb219LlxuICogQGFwaVxuICovXG52YXIgS2V5Ym9hcmRQYW4gPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChJbnRlcmFjdGlvbikge1xuICBmdW5jdGlvbiBLZXlib2FyZFBhbihvcHRfb3B0aW9ucykge1xuXG4gICAgSW50ZXJhY3Rpb24uY2FsbCh0aGlzLCB7XG4gICAgICBoYW5kbGVFdmVudDogaGFuZGxlRXZlbnRcbiAgICB9KTtcblxuICAgIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBCcm93c2VyIGV2ZW50LlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IENvbWJpbmVkIGNvbmRpdGlvbiByZXN1bHQuXG4gICAgICovXG4gICAgdGhpcy5kZWZhdWx0Q29uZGl0aW9uXyA9IGZ1bmN0aW9uKG1hcEJyb3dzZXJFdmVudCkge1xuICAgICAgcmV0dXJuIG5vTW9kaWZpZXJLZXlzKG1hcEJyb3dzZXJFdmVudCkgJiZcbiAgICAgICAgdGFyZ2V0Tm90RWRpdGFibGUobWFwQnJvd3NlckV2ZW50KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259XG4gICAgICovXG4gICAgdGhpcy5jb25kaXRpb25fID0gb3B0aW9ucy5jb25kaXRpb24gIT09IHVuZGVmaW5lZCA/XG4gICAgICBvcHRpb25zLmNvbmRpdGlvbiA6IHRoaXMuZGVmYXVsdENvbmRpdGlvbl87XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kdXJhdGlvbl8gPSBvcHRpb25zLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmR1cmF0aW9uIDogMTAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucGl4ZWxEZWx0YV8gPSBvcHRpb25zLnBpeGVsRGVsdGEgIT09IHVuZGVmaW5lZCA/XG4gICAgICBvcHRpb25zLnBpeGVsRGVsdGEgOiAxMjg7XG5cbiAgfVxuXG4gIGlmICggSW50ZXJhY3Rpb24gKSBLZXlib2FyZFBhbi5fX3Byb3RvX18gPSBJbnRlcmFjdGlvbjtcbiAgS2V5Ym9hcmRQYW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSW50ZXJhY3Rpb24gJiYgSW50ZXJhY3Rpb24ucHJvdG90eXBlICk7XG4gIEtleWJvYXJkUGFuLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEtleWJvYXJkUGFuO1xuXG4gIHJldHVybiBLZXlib2FyZFBhbjtcbn0oSW50ZXJhY3Rpb24pKTtcblxuXG4vKipcbiAqIEhhbmRsZXMgdGhlIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50IG1hcCBicm93c2VyIGV2ZW50fSBpZiBpdCB3YXMgYVxuICogYEtleUV2ZW50YCwgYW5kIGRlY2lkZXMgdGhlIGRpcmVjdGlvbiB0byBwYW4gdG8gKGlmIGFuIGFycm93IGtleSB3YXNcbiAqIHByZXNzZWQpLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gYGZhbHNlYCB0byBzdG9wIGV2ZW50IHByb3BhZ2F0aW9uLlxuICogQHRoaXMge0tleWJvYXJkUGFufVxuICovXG5mdW5jdGlvbiBoYW5kbGVFdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgdmFyIHN0b3BFdmVudCA9IGZhbHNlO1xuICBpZiAobWFwQnJvd3NlckV2ZW50LnR5cGUgPT0gRXZlbnRUeXBlLktFWURPV04pIHtcbiAgICB2YXIga2V5RXZlbnQgPSAvKiogQHR5cGUge0tleWJvYXJkRXZlbnR9ICovIChtYXBCcm93c2VyRXZlbnQub3JpZ2luYWxFdmVudCk7XG4gICAgdmFyIGtleUNvZGUgPSBrZXlFdmVudC5rZXlDb2RlO1xuICAgIGlmICh0aGlzLmNvbmRpdGlvbl8obWFwQnJvd3NlckV2ZW50KSAmJlxuICAgICAgICAoa2V5Q29kZSA9PSBLZXlDb2RlLkRPV04gfHxcbiAgICAgICAga2V5Q29kZSA9PSBLZXlDb2RlLkxFRlQgfHxcbiAgICAgICAga2V5Q29kZSA9PSBLZXlDb2RlLlJJR0hUIHx8XG4gICAgICAgIGtleUNvZGUgPT0gS2V5Q29kZS5VUCkpIHtcbiAgICAgIHZhciBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuICAgICAgdmFyIHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgICAgdmFyIG1hcFVuaXRzRGVsdGEgPSB2aWV3LmdldFJlc29sdXRpb24oKSAqIHRoaXMucGl4ZWxEZWx0YV87XG4gICAgICB2YXIgZGVsdGFYID0gMCwgZGVsdGFZID0gMDtcbiAgICAgIGlmIChrZXlDb2RlID09IEtleUNvZGUuRE9XTikge1xuICAgICAgICBkZWx0YVkgPSAtbWFwVW5pdHNEZWx0YTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA9PSBLZXlDb2RlLkxFRlQpIHtcbiAgICAgICAgZGVsdGFYID0gLW1hcFVuaXRzRGVsdGE7XG4gICAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT0gS2V5Q29kZS5SSUdIVCkge1xuICAgICAgICBkZWx0YVggPSBtYXBVbml0c0RlbHRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsdGFZID0gbWFwVW5pdHNEZWx0YTtcbiAgICAgIH1cbiAgICAgIHZhciBkZWx0YSA9IFtkZWx0YVgsIGRlbHRhWV07XG4gICAgICByb3RhdGVDb29yZGluYXRlKGRlbHRhLCB2aWV3LmdldFJvdGF0aW9uKCkpO1xuICAgICAgcGFuKHZpZXcsIGRlbHRhLCB0aGlzLmR1cmF0aW9uXyk7XG4gICAgICBtYXBCcm93c2VyRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHN0b3BFdmVudCA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiAhc3RvcEV2ZW50O1xufVxuXG5leHBvcnQgZGVmYXVsdCBLZXlib2FyZFBhbjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9S2V5Ym9hcmRQYW4uanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL0tleWJvYXJkWm9vbVxuICovXG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4uL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IHt0YXJnZXROb3RFZGl0YWJsZX0gZnJvbSAnLi4vZXZlbnRzL2NvbmRpdGlvbi5qcyc7XG5pbXBvcnQgSW50ZXJhY3Rpb24sIHt6b29tQnlEZWx0YX0gZnJvbSAnLi9JbnRlcmFjdGlvbi5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2R1cmF0aW9uPTEwMF0gQW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259IFtjb25kaXRpb25dIEEgZnVuY3Rpb24gdGhhdFxuICogdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmQgcmV0dXJucyBhXG4gKiBib29sZWFuIHRvIGluZGljYXRlIHdoZXRoZXIgdGhhdCBldmVudCBzaG91bGQgYmUgaGFuZGxlZC4gRGVmYXVsdCBpc1xuICoge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9ufnRhcmdldE5vdEVkaXRhYmxlfS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZGVsdGE9MV0gVGhlIHpvb20gbGV2ZWwgZGVsdGEgb24gZWFjaCBrZXkgcHJlc3MuXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFsbG93cyB0aGUgdXNlciB0byB6b29tIHRoZSBtYXAgdXNpbmcga2V5Ym9hcmQgKyBhbmQgLS5cbiAqIE5vdGUgdGhhdCwgYWx0aG91Z2ggdGhpcyBpbnRlcmFjdGlvbiBpcyBieSBkZWZhdWx0IGluY2x1ZGVkIGluIG1hcHMsXG4gKiB0aGUga2V5cyBjYW4gb25seSBiZSB1c2VkIHdoZW4gYnJvd3NlciBmb2N1cyBpcyBvbiB0aGUgZWxlbWVudCB0byB3aGljaFxuICogdGhlIGtleWJvYXJkIGV2ZW50cyBhcmUgYXR0YWNoZWQuIEJ5IGRlZmF1bHQsIHRoaXMgaXMgdGhlIG1hcCBkaXYsXG4gKiB0aG91Z2ggeW91IGNhbiBjaGFuZ2UgdGhpcyB3aXRoIHRoZSBga2V5Ym9hcmRFdmVudFRhcmdldGAgaW5cbiAqIHtAbGluayBtb2R1bGU6b2wvTWFwfk1hcH0uIGBkb2N1bWVudGAgbmV2ZXIgbG9zZXMgZm9jdXMgYnV0LCBmb3IgYW55IG90aGVyXG4gKiBlbGVtZW50LCBmb2N1cyB3aWxsIGhhdmUgdG8gYmUgb24sIGFuZCByZXR1cm5lZCB0bywgdGhpcyBlbGVtZW50IGlmIHRoZSBrZXlzXG4gKiBhcmUgdG8gZnVuY3Rpb24uXG4gKiBTZWUgYWxzbyB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL0tleWJvYXJkUGFufktleWJvYXJkUGFufS5cbiAqIEBhcGlcbiAqL1xudmFyIEtleWJvYXJkWm9vbSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEludGVyYWN0aW9uKSB7XG4gIGZ1bmN0aW9uIEtleWJvYXJkWm9vbShvcHRfb3B0aW9ucykge1xuXG4gICAgSW50ZXJhY3Rpb24uY2FsbCh0aGlzLCB7XG4gICAgICBoYW5kbGVFdmVudDogaGFuZGxlRXZlbnRcbiAgICB9KTtcblxuICAgIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgPyBvcHRfb3B0aW9ucyA6IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259XG4gICAgICovXG4gICAgdGhpcy5jb25kaXRpb25fID0gb3B0aW9ucy5jb25kaXRpb24gPyBvcHRpb25zLmNvbmRpdGlvbiA6IHRhcmdldE5vdEVkaXRhYmxlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZGVsdGFfID0gb3B0aW9ucy5kZWx0YSA/IG9wdGlvbnMuZGVsdGEgOiAxO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZHVyYXRpb25fID0gb3B0aW9ucy5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kdXJhdGlvbiA6IDEwMDtcblxuICB9XG5cbiAgaWYgKCBJbnRlcmFjdGlvbiApIEtleWJvYXJkWm9vbS5fX3Byb3RvX18gPSBJbnRlcmFjdGlvbjtcbiAgS2V5Ym9hcmRab29tLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEludGVyYWN0aW9uICYmIEludGVyYWN0aW9uLnByb3RvdHlwZSApO1xuICBLZXlib2FyZFpvb20ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gS2V5Ym9hcmRab29tO1xuXG4gIHJldHVybiBLZXlib2FyZFpvb207XG59KEludGVyYWN0aW9uKSk7XG5cblxuLyoqXG4gKiBIYW5kbGVzIHRoZSB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudCBtYXAgYnJvd3NlciBldmVudH0gaWYgaXQgd2FzIGFcbiAqIGBLZXlFdmVudGAsIGFuZCBkZWNpZGVzIHdoZXRoZXIgdG8gem9vbSBpbiBvciBvdXQgKGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZVxuICoga2V5IHByZXNzZWQgd2FzICcrJyBvciAnLScpLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gYGZhbHNlYCB0byBzdG9wIGV2ZW50IHByb3BhZ2F0aW9uLlxuICogQHRoaXMge0tleWJvYXJkWm9vbX1cbiAqL1xuZnVuY3Rpb24gaGFuZGxlRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gIHZhciBzdG9wRXZlbnQgPSBmYWxzZTtcbiAgaWYgKG1hcEJyb3dzZXJFdmVudC50eXBlID09IEV2ZW50VHlwZS5LRVlET1dOIHx8XG4gICAgICBtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBFdmVudFR5cGUuS0VZUFJFU1MpIHtcbiAgICB2YXIga2V5RXZlbnQgPSAvKiogQHR5cGUge0tleWJvYXJkRXZlbnR9ICovIChtYXBCcm93c2VyRXZlbnQub3JpZ2luYWxFdmVudCk7XG4gICAgdmFyIGNoYXJDb2RlID0ga2V5RXZlbnQuY2hhckNvZGU7XG4gICAgaWYgKHRoaXMuY29uZGl0aW9uXyhtYXBCcm93c2VyRXZlbnQpICYmXG4gICAgICAgIChjaGFyQ29kZSA9PSAnKycuY2hhckNvZGVBdCgwKSB8fCBjaGFyQ29kZSA9PSAnLScuY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgIHZhciBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuICAgICAgdmFyIGRlbHRhID0gKGNoYXJDb2RlID09ICcrJy5jaGFyQ29kZUF0KDApKSA/IHRoaXMuZGVsdGFfIDogLXRoaXMuZGVsdGFfO1xuICAgICAgdmFyIHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgICAgem9vbUJ5RGVsdGEodmlldywgZGVsdGEsIHVuZGVmaW5lZCwgdGhpcy5kdXJhdGlvbl8pO1xuICAgICAgbWFwQnJvd3NlckV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBzdG9wRXZlbnQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gIXN0b3BFdmVudDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgS2V5Ym9hcmRab29tO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1LZXlib2FyZFpvb20uanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL01vZGlmeVxuICovXG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5pbXBvcnQgQ29sbGVjdGlvbiBmcm9tICcuLi9Db2xsZWN0aW9uLmpzJztcbmltcG9ydCBDb2xsZWN0aW9uRXZlbnRUeXBlIGZyb20gJy4uL0NvbGxlY3Rpb25FdmVudFR5cGUuanMnO1xuaW1wb3J0IEZlYXR1cmUgZnJvbSAnLi4vRmVhdHVyZS5qcyc7XG5pbXBvcnQgTWFwQnJvd3NlckV2ZW50VHlwZSBmcm9tICcuLi9NYXBCcm93c2VyRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7ZXF1YWxzfSBmcm9tICcuLi9hcnJheS5qcyc7XG5pbXBvcnQge2VxdWFscyBhcyBjb29yZGluYXRlc0VxdWFsLCBkaXN0YW5jZSBhcyBjb29yZGluYXRlRGlzdGFuY2UsIHNxdWFyZWREaXN0YW5jZSBhcyBzcXVhcmVkQ29vcmRpbmF0ZURpc3RhbmNlLCBzcXVhcmVkRGlzdGFuY2VUb1NlZ21lbnQsIGNsb3Nlc3RPblNlZ21lbnR9IGZyb20gJy4uL2Nvb3JkaW5hdGUuanMnO1xuaW1wb3J0IHtsaXN0ZW4sIHVubGlzdGVufSBmcm9tICcuLi9ldmVudHMuanMnO1xuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cy9FdmVudC5qcyc7XG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4uL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IHthbHdheXMsIHByaW1hcnlBY3Rpb24sIGFsdEtleU9ubHksIHNpbmdsZUNsaWNrfSBmcm9tICcuLi9ldmVudHMvY29uZGl0aW9uLmpzJztcbmltcG9ydCB7Ym91bmRpbmdFeHRlbnQsIGJ1ZmZlciwgY3JlYXRlT3JVcGRhdGVGcm9tQ29vcmRpbmF0ZX0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCBHZW9tZXRyeVR5cGUgZnJvbSAnLi4vZ2VvbS9HZW9tZXRyeVR5cGUuanMnO1xuaW1wb3J0IFBvaW50IGZyb20gJy4uL2dlb20vUG9pbnQuanMnO1xuaW1wb3J0IFBvaW50ZXJJbnRlcmFjdGlvbiBmcm9tICcuL1BvaW50ZXIuanMnO1xuaW1wb3J0IFZlY3RvckxheWVyIGZyb20gJy4uL2xheWVyL1ZlY3Rvci5qcyc7XG5pbXBvcnQgVmVjdG9yU291cmNlIGZyb20gJy4uL3NvdXJjZS9WZWN0b3IuanMnO1xuaW1wb3J0IFZlY3RvckV2ZW50VHlwZSBmcm9tICcuLi9zb3VyY2UvVmVjdG9yRXZlbnRUeXBlLmpzJztcbmltcG9ydCBSQnVzaCBmcm9tICcuLi9zdHJ1Y3RzL1JCdXNoLmpzJztcbmltcG9ydCB7Y3JlYXRlRWRpdGluZ1N0eWxlfSBmcm9tICcuLi9zdHlsZS9TdHlsZS5qcyc7XG5cblxuLyoqXG4gKiBUaGUgc2VnbWVudCBpbmRleCBhc3NpZ25lZCB0byBhIGNpcmNsZSdzIGNlbnRlciB3aGVuXG4gKiBicmVha2luZyB1cCBhIGNpcmNsZSBpbnRvIE1vZGlmeVNlZ21lbnREYXRhVHlwZSBzZWdtZW50cy5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbnZhciBDSVJDTEVfQ0VOVEVSX0lOREVYID0gMDtcblxuLyoqXG4gKiBUaGUgc2VnbWVudCBpbmRleCBhc3NpZ25lZCB0byBhIGNpcmNsZSdzIGNpcmN1bWZlcmVuY2Ugd2hlblxuICogYnJlYWtpbmcgdXAgYSBjaXJjbGUgaW50byBNb2RpZnlTZWdtZW50RGF0YVR5cGUgc2VnbWVudHMuXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG52YXIgQ0lSQ0xFX0NJUkNVTUZFUkVOQ0VfSU5ERVggPSAxO1xuXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xudmFyIE1vZGlmeUV2ZW50VHlwZSA9IHtcbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB1cG9uIGZlYXR1cmUgbW9kaWZpY2F0aW9uIHN0YXJ0XG4gICAqIEBldmVudCBNb2RpZnlFdmVudCNtb2RpZnlzdGFydFxuICAgKiBAYXBpXG4gICAqL1xuICBNT0RJRllTVEFSVDogJ21vZGlmeXN0YXJ0JyxcbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB1cG9uIGZlYXR1cmUgbW9kaWZpY2F0aW9uIGVuZFxuICAgKiBAZXZlbnQgTW9kaWZ5RXZlbnQjbW9kaWZ5ZW5kXG4gICAqIEBhcGlcbiAgICovXG4gIE1PRElGWUVORDogJ21vZGlmeWVuZCdcbn07XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTZWdtZW50RGF0YVxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBbZGVwdGhdXG4gKiBAcHJvcGVydHkge0ZlYXR1cmV9IGZlYXR1cmVcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtpbmRleF1cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudD59IHNlZ21lbnRcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8U2VnbWVudERhdGE+fSBbZmVhdHVyZVNlZ21lbnRzXVxuICovXG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufSBbY29uZGl0aW9uXSBBIGZ1bmN0aW9uIHRoYXRcbiAqIHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0gYW5kIHJldHVybnMgYVxuICogYm9vbGVhbiB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoYXQgZXZlbnQgd2lsbCBiZSBjb25zaWRlcmVkIHRvIGFkZCBvciBtb3ZlIGFcbiAqIHZlcnRleCB0byB0aGUgc2tldGNoLiBEZWZhdWx0IGlzXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb25+cHJpbWFyeUFjdGlvbn0uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufSBbZGVsZXRlQ29uZGl0aW9uXSBBIGZ1bmN0aW9uXG4gKiB0aGF0IHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0gYW5kIHJldHVybnMgYVxuICogYm9vbGVhbiB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoYXQgZXZlbnQgc2hvdWxkIGJlIGhhbmRsZWQuIEJ5IGRlZmF1bHQsXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb25+c2luZ2xlQ2xpY2t9IHdpdGhcbiAqIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbn5hbHRLZXlPbmx5fSByZXN1bHRzIGluIGEgdmVydGV4IGRlbGV0aW9uLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn0gW2luc2VydFZlcnRleENvbmRpdGlvbl0gQVxuICogZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnR9IGFuZFxuICogcmV0dXJucyBhIGJvb2xlYW4gdG8gaW5kaWNhdGUgd2hldGhlciBhIG5ldyB2ZXJ0ZXggY2FuIGJlIGFkZGVkIHRvIHRoZSBza2V0Y2hcbiAqIGZlYXR1cmVzLiBEZWZhdWx0IGlzIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbn5hbHdheXN9LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtwaXhlbFRvbGVyYW5jZT0xMF0gUGl4ZWwgdG9sZXJhbmNlIGZvciBjb25zaWRlcmluZyB0aGVcbiAqIHBvaW50ZXIgY2xvc2UgZW5vdWdoIHRvIGEgc2VnbWVudCBvciB2ZXJ0ZXggZm9yIGVkaXRpbmcuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLlN0eWxlTGlrZX0gW3N0eWxlXVxuICogU3R5bGUgdXNlZCBmb3IgdGhlIGZlYXR1cmVzIGJlaW5nIG1vZGlmaWVkLiBCeSBkZWZhdWx0IHRoZSBkZWZhdWx0IGVkaXRcbiAqIHN0eWxlIGlzIHVzZWQgKHNlZSB7QGxpbmsgbW9kdWxlOm9sL3N0eWxlfSkuXG4gKiBAcHJvcGVydHkge1ZlY3RvclNvdXJjZX0gW3NvdXJjZV0gVGhlIHZlY3RvciBzb3VyY2Ugd2l0aFxuICogZmVhdHVyZXMgdG8gbW9kaWZ5LiAgSWYgYSB2ZWN0b3Igc291cmNlIGlzIG5vdCBwcm92aWRlZCwgYSBmZWF0dXJlIGNvbGxlY3Rpb25cbiAqIG11c3QgYmUgcHJvdmlkZWQgd2l0aCB0aGUgZmVhdHVyZXMgb3B0aW9uLlxuICogQHByb3BlcnR5IHtDb2xsZWN0aW9uPEZlYXR1cmU+fSBbZmVhdHVyZXNdXG4gKiBUaGUgZmVhdHVyZXMgdGhlIGludGVyYWN0aW9uIHdvcmtzIG9uLiAgSWYgYSBmZWF0dXJlIGNvbGxlY3Rpb24gaXMgbm90XG4gKiBwcm92aWRlZCwgYSB2ZWN0b3Igc291cmNlIG11c3QgYmUgcHJvdmlkZWQgd2l0aCB0aGUgc291cmNlIG9wdGlvbi5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3dyYXBYPWZhbHNlXSBXcmFwIHRoZSB3b3JsZCBob3Jpem9udGFsbHkgb24gdGhlIHNrZXRjaFxuICogb3ZlcmxheS5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogRXZlbnRzIGVtaXR0ZWQgYnkge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9Nb2RpZnl+TW9kaWZ5fSBpbnN0YW5jZXMgYXJlXG4gKiBpbnN0YW5jZXMgb2YgdGhpcyB0eXBlLlxuICovXG5leHBvcnQgdmFyIE1vZGlmeUV2ZW50ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoRXZlbnQpIHtcbiAgZnVuY3Rpb24gTW9kaWZ5RXZlbnQodHlwZSwgZmVhdHVyZXMsIG1hcEJyb3dzZXJQb2ludGVyRXZlbnQpIHtcbiAgICBFdmVudC5jYWxsKHRoaXMsIHR5cGUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZlYXR1cmVzIGJlaW5nIG1vZGlmaWVkLlxuICAgICAqIEB0eXBlIHtDb2xsZWN0aW9uPEZlYXR1cmU+fVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLmZlYXR1cmVzID0gZmVhdHVyZXM7XG5cbiAgICAvKipcbiAgICAgKiBBc3NvY2lhdGVkIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fS5cbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMubWFwQnJvd3NlckV2ZW50ID0gbWFwQnJvd3NlclBvaW50ZXJFdmVudDtcblxuICB9XG5cbiAgaWYgKCBFdmVudCApIE1vZGlmeUV2ZW50Ll9fcHJvdG9fXyA9IEV2ZW50O1xuICBNb2RpZnlFdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFdmVudCAmJiBFdmVudC5wcm90b3R5cGUgKTtcbiAgTW9kaWZ5RXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTW9kaWZ5RXZlbnQ7XG5cbiAgcmV0dXJuIE1vZGlmeUV2ZW50O1xufShFdmVudCkpO1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogSW50ZXJhY3Rpb24gZm9yIG1vZGlmeWluZyBmZWF0dXJlIGdlb21ldHJpZXMuICBUbyBtb2RpZnkgZmVhdHVyZXMgdGhhdCBoYXZlXG4gKiBiZWVuIGFkZGVkIHRvIGFuIGV4aXN0aW5nIHNvdXJjZSwgY29uc3RydWN0IHRoZSBtb2RpZnkgaW50ZXJhY3Rpb24gd2l0aCB0aGVcbiAqIGBzb3VyY2VgIG9wdGlvbi4gIElmIHlvdSB3YW50IHRvIG1vZGlmeSBmZWF0dXJlcyBpbiBhIGNvbGxlY3Rpb24gKGZvciBleGFtcGxlLFxuICogdGhlIGNvbGxlY3Rpb24gdXNlZCBieSBhIHNlbGVjdCBpbnRlcmFjdGlvbiksIGNvbnN0cnVjdCB0aGUgaW50ZXJhY3Rpb24gd2l0aFxuICogdGhlIGBmZWF0dXJlc2Agb3B0aW9uLiAgVGhlIGludGVyYWN0aW9uIG11c3QgYmUgY29uc3RydWN0ZWQgd2l0aCBlaXRoZXIgYVxuICogYHNvdXJjZWAgb3IgYGZlYXR1cmVzYCBvcHRpb24uXG4gKlxuICogQnkgZGVmYXVsdCwgdGhlIGludGVyYWN0aW9uIHdpbGwgYWxsb3cgZGVsZXRpb24gb2YgdmVydGljZXMgd2hlbiB0aGUgYGFsdGBcbiAqIGtleSBpcyBwcmVzc2VkLiAgVG8gY29uZmlndXJlIHRoZSBpbnRlcmFjdGlvbiB3aXRoIGEgZGlmZmVyZW50IGNvbmRpdGlvblxuICogZm9yIGRlbGV0aW9uLCB1c2UgdGhlIGBkZWxldGVDb25kaXRpb25gIG9wdGlvbi5cbiAqIEBmaXJlcyBNb2RpZnlFdmVudFxuICogQGFwaVxuICovXG52YXIgTW9kaWZ5ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoUG9pbnRlckludGVyYWN0aW9uKSB7XG4gIGZ1bmN0aW9uIE1vZGlmeShvcHRpb25zKSB7XG5cbiAgICBQb2ludGVySW50ZXJhY3Rpb24uY2FsbCgvKiogQHR5cGUge2ltcG9ydChcIi4vUG9pbnRlci5qc1wiKS5PcHRpb25zfSAqLyB0aGlzLCAob3B0aW9ucykpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259XG4gICAgICovXG4gICAgdGhpcy5jb25kaXRpb25fID0gb3B0aW9ucy5jb25kaXRpb24gPyBvcHRpb25zLmNvbmRpdGlvbiA6IHByaW1hcnlBY3Rpb247XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBCcm93c2VyIGV2ZW50LlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IENvbWJpbmVkIGNvbmRpdGlvbiByZXN1bHQuXG4gICAgICovXG4gICAgdGhpcy5kZWZhdWx0RGVsZXRlQ29uZGl0aW9uXyA9IGZ1bmN0aW9uKG1hcEJyb3dzZXJFdmVudCkge1xuICAgICAgcmV0dXJuIGFsdEtleU9ubHkobWFwQnJvd3NlckV2ZW50KSAmJiBzaW5nbGVDbGljayhtYXBCcm93c2VyRXZlbnQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmRlbGV0ZUNvbmRpdGlvbl8gPSBvcHRpb25zLmRlbGV0ZUNvbmRpdGlvbiA/XG4gICAgICBvcHRpb25zLmRlbGV0ZUNvbmRpdGlvbiA6IHRoaXMuZGVmYXVsdERlbGV0ZUNvbmRpdGlvbl87XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmluc2VydFZlcnRleENvbmRpdGlvbl8gPSBvcHRpb25zLmluc2VydFZlcnRleENvbmRpdGlvbiA/XG4gICAgICBvcHRpb25zLmluc2VydFZlcnRleENvbmRpdGlvbiA6IGFsd2F5cztcblxuICAgIC8qKlxuICAgICAqIEVkaXRpbmcgdmVydGV4LlxuICAgICAqIEB0eXBlIHtGZWF0dXJlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy52ZXJ0ZXhGZWF0dXJlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBTZWdtZW50cyBpbnRlcnNlY3Rpbmcge0BsaW5rIHRoaXMudmVydGV4RmVhdHVyZV99IGJ5IHNlZ21lbnQgdWlkLlxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBib29sZWFuPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudmVydGV4U2VnbWVudHNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9waXhlbC5qc1wiKS5QaXhlbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubGFzdFBpeGVsXyA9IFswLCAwXTtcblxuICAgIC8qKlxuICAgICAqIFRyYWNrcyBpZiB0aGUgbmV4dCBgc2luZ2xlY2xpY2tgIGV2ZW50IHNob3VsZCBiZSBpZ25vcmVkIHRvIHByZXZlbnRcbiAgICAgKiBhY2NpZGVudGFsIGRlbGV0aW9uIHJpZ2h0IGFmdGVyIHZlcnRleCBjcmVhdGlvbi5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaWdub3JlTmV4dFNpbmdsZUNsaWNrXyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLm1vZGlmaWVkXyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogU2VnbWVudCBSVHJlZSBmb3IgZWFjaCBsYXllclxuICAgICAqIEB0eXBlIHtSQnVzaDxTZWdtZW50RGF0YT59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnJCdXNoXyA9IG5ldyBSQnVzaCgpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucGl4ZWxUb2xlcmFuY2VfID0gb3B0aW9ucy5waXhlbFRvbGVyYW5jZSAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdGlvbnMucGl4ZWxUb2xlcmFuY2UgOiAxMDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5zbmFwcGVkVG9WZXJ0ZXhfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZSB3aGV0aGVyIHRoZSBpbnRlcmFjdGlvbiBpcyBjdXJyZW50bHkgY2hhbmdpbmcgYSBmZWF0dXJlJ3NcbiAgICAgKiBjb29yZGluYXRlcy5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuY2hhbmdpbmdGZWF0dXJlXyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5kcmFnU2VnbWVudHNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBEcmF3IG92ZXJsYXkgd2hlcmUgc2tldGNoIGZlYXR1cmVzIGFyZSBkcmF3bi5cbiAgICAgKiBAdHlwZSB7VmVjdG9yTGF5ZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLm92ZXJsYXlfID0gbmV3IFZlY3RvckxheWVyKHtcbiAgICAgIHNvdXJjZTogbmV3IFZlY3RvclNvdXJjZSh7XG4gICAgICAgIHVzZVNwYXRpYWxJbmRleDogZmFsc2UsXG4gICAgICAgIHdyYXBYOiAhIW9wdGlvbnMud3JhcFhcbiAgICAgIH0pLFxuICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUgPyBvcHRpb25zLnN0eWxlIDpcbiAgICAgICAgZ2V0RGVmYXVsdFN0eWxlRnVuY3Rpb24oKSxcbiAgICAgIHVwZGF0ZVdoaWxlQW5pbWF0aW5nOiB0cnVlLFxuICAgICAgdXBkYXRlV2hpbGVJbnRlcmFjdGluZzogdHJ1ZVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIGZ1bmN0aW9uKEZlYXR1cmUsIGltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdCk+fVxuICAgICAqL1xuICAgIHRoaXMuU0VHTUVOVF9XUklURVJTXyA9IHtcbiAgICAgICdQb2ludCc6IHRoaXMud3JpdGVQb2ludEdlb21ldHJ5XyxcbiAgICAgICdMaW5lU3RyaW5nJzogdGhpcy53cml0ZUxpbmVTdHJpbmdHZW9tZXRyeV8sXG4gICAgICAnTGluZWFyUmluZyc6IHRoaXMud3JpdGVMaW5lU3RyaW5nR2VvbWV0cnlfLFxuICAgICAgJ1BvbHlnb24nOiB0aGlzLndyaXRlUG9seWdvbkdlb21ldHJ5XyxcbiAgICAgICdNdWx0aVBvaW50JzogdGhpcy53cml0ZU11bHRpUG9pbnRHZW9tZXRyeV8sXG4gICAgICAnTXVsdGlMaW5lU3RyaW5nJzogdGhpcy53cml0ZU11bHRpTGluZVN0cmluZ0dlb21ldHJ5XyxcbiAgICAgICdNdWx0aVBvbHlnb24nOiB0aGlzLndyaXRlTXVsdGlQb2x5Z29uR2VvbWV0cnlfLFxuICAgICAgJ0NpcmNsZSc6IHRoaXMud3JpdGVDaXJjbGVHZW9tZXRyeV8sXG4gICAgICAnR2VvbWV0cnlDb2xsZWN0aW9uJzogdGhpcy53cml0ZUdlb21ldHJ5Q29sbGVjdGlvbkdlb21ldHJ5X1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtWZWN0b3JTb3VyY2V9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnNvdXJjZV8gPSBudWxsO1xuXG4gICAgdmFyIGZlYXR1cmVzO1xuICAgIGlmIChvcHRpb25zLnNvdXJjZSkge1xuICAgICAgdGhpcy5zb3VyY2VfID0gb3B0aW9ucy5zb3VyY2U7XG4gICAgICBmZWF0dXJlcyA9IG5ldyBDb2xsZWN0aW9uKHRoaXMuc291cmNlXy5nZXRGZWF0dXJlcygpKTtcbiAgICAgIGxpc3Rlbih0aGlzLnNvdXJjZV8sIFZlY3RvckV2ZW50VHlwZS5BRERGRUFUVVJFLFxuICAgICAgICB0aGlzLmhhbmRsZVNvdXJjZUFkZF8sIHRoaXMpO1xuICAgICAgbGlzdGVuKHRoaXMuc291cmNlXywgVmVjdG9yRXZlbnRUeXBlLlJFTU9WRUZFQVRVUkUsXG4gICAgICAgIHRoaXMuaGFuZGxlU291cmNlUmVtb3ZlXywgdGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZlYXR1cmVzID0gb3B0aW9ucy5mZWF0dXJlcztcbiAgICB9XG4gICAgaWYgKCFmZWF0dXJlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgbW9kaWZ5IGludGVyYWN0aW9uIHJlcXVpcmVzIGZlYXR1cmVzIG9yIGEgc291cmNlJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0NvbGxlY3Rpb248RmVhdHVyZT59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmZlYXR1cmVzXyA9IGZlYXR1cmVzO1xuXG4gICAgdGhpcy5mZWF0dXJlc18uZm9yRWFjaCh0aGlzLmFkZEZlYXR1cmVfLmJpbmQodGhpcykpO1xuICAgIGxpc3Rlbih0aGlzLmZlYXR1cmVzXywgQ29sbGVjdGlvbkV2ZW50VHlwZS5BREQsXG4gICAgICB0aGlzLmhhbmRsZUZlYXR1cmVBZGRfLCB0aGlzKTtcbiAgICBsaXN0ZW4odGhpcy5mZWF0dXJlc18sIENvbGxlY3Rpb25FdmVudFR5cGUuUkVNT1ZFLFxuICAgICAgdGhpcy5oYW5kbGVGZWF0dXJlUmVtb3ZlXywgdGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlclBvaW50ZXJFdmVudC5qc1wiKS5kZWZhdWx0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5sYXN0UG9pbnRlckV2ZW50XyA9IG51bGw7XG5cbiAgfVxuXG4gIGlmICggUG9pbnRlckludGVyYWN0aW9uICkgTW9kaWZ5Ll9fcHJvdG9fXyA9IFBvaW50ZXJJbnRlcmFjdGlvbjtcbiAgTW9kaWZ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBvaW50ZXJJbnRlcmFjdGlvbiAmJiBQb2ludGVySW50ZXJhY3Rpb24ucHJvdG90eXBlICk7XG4gIE1vZGlmeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNb2RpZnk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTW9kaWZ5LnByb3RvdHlwZS5hZGRGZWF0dXJlXyA9IGZ1bmN0aW9uIGFkZEZlYXR1cmVfIChmZWF0dXJlKSB7XG4gICAgdmFyIGdlb21ldHJ5ID0gZmVhdHVyZS5nZXRHZW9tZXRyeSgpO1xuICAgIGlmIChnZW9tZXRyeSAmJiBnZW9tZXRyeS5nZXRUeXBlKCkgaW4gdGhpcy5TRUdNRU5UX1dSSVRFUlNfKSB7XG4gICAgICB0aGlzLlNFR01FTlRfV1JJVEVSU19bZ2VvbWV0cnkuZ2V0VHlwZSgpXS5jYWxsKHRoaXMsIGZlYXR1cmUsIGdlb21ldHJ5KTtcbiAgICB9XG4gICAgdmFyIG1hcCA9IHRoaXMuZ2V0TWFwKCk7XG4gICAgaWYgKG1hcCAmJiBtYXAuaXNSZW5kZXJlZCgpICYmIHRoaXMuZ2V0QWN0aXZlKCkpIHtcbiAgICAgIHRoaXMuaGFuZGxlUG9pbnRlckF0UGl4ZWxfKHRoaXMubGFzdFBpeGVsXywgbWFwKTtcbiAgICB9XG4gICAgbGlzdGVuKGZlYXR1cmUsIEV2ZW50VHlwZS5DSEFOR0UsXG4gICAgICB0aGlzLmhhbmRsZUZlYXR1cmVDaGFuZ2VfLCB0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyUG9pbnRlckV2ZW50LmpzXCIpLmRlZmF1bHR9IGV2dCBNYXAgYnJvd3NlciBldmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTW9kaWZ5LnByb3RvdHlwZS53aWxsTW9kaWZ5RmVhdHVyZXNfID0gZnVuY3Rpb24gd2lsbE1vZGlmeUZlYXR1cmVzXyAoZXZ0KSB7XG4gICAgaWYgKCF0aGlzLm1vZGlmaWVkXykge1xuICAgICAgdGhpcy5tb2RpZmllZF8gPSB0cnVlO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBNb2RpZnlFdmVudChcbiAgICAgICAgTW9kaWZ5RXZlbnRUeXBlLk1PRElGWVNUQVJULCB0aGlzLmZlYXR1cmVzXywgZXZ0KSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0ZlYXR1cmV9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIE1vZGlmeS5wcm90b3R5cGUucmVtb3ZlRmVhdHVyZV8gPSBmdW5jdGlvbiByZW1vdmVGZWF0dXJlXyAoZmVhdHVyZSkge1xuICAgIHRoaXMucmVtb3ZlRmVhdHVyZVNlZ21lbnREYXRhXyhmZWF0dXJlKTtcbiAgICAvLyBSZW1vdmUgdGhlIHZlcnRleCBmZWF0dXJlIGlmIHRoZSBjb2xsZWN0aW9uIG9mIGNhbmRpdGF0ZSBmZWF0dXJlc1xuICAgIC8vIGlzIGVtcHR5LlxuICAgIGlmICh0aGlzLnZlcnRleEZlYXR1cmVfICYmIHRoaXMuZmVhdHVyZXNfLmdldExlbmd0aCgpID09PSAwKSB7XG4gICAgICAvKiogQHR5cGUge1ZlY3RvclNvdXJjZX0gKi8gKHRoaXMub3ZlcmxheV8uZ2V0U291cmNlKCkpLnJlbW92ZUZlYXR1cmUodGhpcy52ZXJ0ZXhGZWF0dXJlXyk7XG4gICAgICB0aGlzLnZlcnRleEZlYXR1cmVfID0gbnVsbDtcbiAgICB9XG4gICAgdW5saXN0ZW4oZmVhdHVyZSwgRXZlbnRUeXBlLkNIQU5HRSxcbiAgICAgIHRoaXMuaGFuZGxlRmVhdHVyZUNoYW5nZV8sIHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0ZlYXR1cmV9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIE1vZGlmeS5wcm90b3R5cGUucmVtb3ZlRmVhdHVyZVNlZ21lbnREYXRhXyA9IGZ1bmN0aW9uIHJlbW92ZUZlYXR1cmVTZWdtZW50RGF0YV8gKGZlYXR1cmUpIHtcbiAgICB2YXIgckJ1c2ggPSB0aGlzLnJCdXNoXztcbiAgICB2YXIgLyoqIEB0eXBlIHtBcnJheTxTZWdtZW50RGF0YT59ICovIG5vZGVzVG9SZW1vdmUgPSBbXTtcbiAgICByQnVzaC5mb3JFYWNoKFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge1NlZ21lbnREYXRhfSBub2RlIFJUcmVlIG5vZGUuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgaWYgKGZlYXR1cmUgPT09IG5vZGUuZmVhdHVyZSkge1xuICAgICAgICAgIG5vZGVzVG9SZW1vdmUucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgZm9yICh2YXIgaSA9IG5vZGVzVG9SZW1vdmUubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHJCdXNoLnJlbW92ZShub2Rlc1RvUmVtb3ZlW2ldKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBNb2RpZnkucHJvdG90eXBlLnNldEFjdGl2ZSA9IGZ1bmN0aW9uIHNldEFjdGl2ZSAoYWN0aXZlKSB7XG4gICAgaWYgKHRoaXMudmVydGV4RmVhdHVyZV8gJiYgIWFjdGl2ZSkge1xuICAgICAgLyoqIEB0eXBlIHtWZWN0b3JTb3VyY2V9ICovICh0aGlzLm92ZXJsYXlfLmdldFNvdXJjZSgpKS5yZW1vdmVGZWF0dXJlKHRoaXMudmVydGV4RmVhdHVyZV8pO1xuICAgICAgdGhpcy52ZXJ0ZXhGZWF0dXJlXyA9IG51bGw7XG4gICAgfVxuICAgIFBvaW50ZXJJbnRlcmFjdGlvbi5wcm90b3R5cGUuc2V0QWN0aXZlLmNhbGwodGhpcywgYWN0aXZlKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIE1vZGlmeS5wcm90b3R5cGUuc2V0TWFwID0gZnVuY3Rpb24gc2V0TWFwIChtYXApIHtcbiAgICB0aGlzLm92ZXJsYXlfLnNldE1hcChtYXApO1xuICAgIFBvaW50ZXJJbnRlcmFjdGlvbi5wcm90b3R5cGUuc2V0TWFwLmNhbGwodGhpcywgbWFwKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBvdmVybGF5IGxheWVyIHRoYXQgdGhpcyBpbnRlcmFjdGlvbiByZW5kZXJzIHNrZXRjaCBmZWF0dXJlcyB0by5cbiAgICogQHJldHVybiB7VmVjdG9yTGF5ZXJ9IE92ZXJsYXkgbGF5ZXIuXG4gICAqIEBhcGlcbiAgICovXG4gIE1vZGlmeS5wcm90b3R5cGUuZ2V0T3ZlcmxheSA9IGZ1bmN0aW9uIGdldE92ZXJsYXkgKCkge1xuICAgIHJldHVybiB0aGlzLm92ZXJsYXlfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3NvdXJjZS9WZWN0b3IuanNcIikuVmVjdG9yU291cmNlRXZlbnR9IGV2ZW50IEV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTW9kaWZ5LnByb3RvdHlwZS5oYW5kbGVTb3VyY2VBZGRfID0gZnVuY3Rpb24gaGFuZGxlU291cmNlQWRkXyAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuZmVhdHVyZSkge1xuICAgICAgdGhpcy5mZWF0dXJlc18ucHVzaChldmVudC5mZWF0dXJlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc291cmNlL1ZlY3Rvci5qc1wiKS5WZWN0b3JTb3VyY2VFdmVudH0gZXZlbnQgRXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBNb2RpZnkucHJvdG90eXBlLmhhbmRsZVNvdXJjZVJlbW92ZV8gPSBmdW5jdGlvbiBoYW5kbGVTb3VyY2VSZW1vdmVfIChldmVudCkge1xuICAgIGlmIChldmVudC5mZWF0dXJlKSB7XG4gICAgICB0aGlzLmZlYXR1cmVzXy5yZW1vdmUoZXZlbnQuZmVhdHVyZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0NvbGxlY3Rpb24uanNcIikuQ29sbGVjdGlvbkV2ZW50fSBldnQgRXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBNb2RpZnkucHJvdG90eXBlLmhhbmRsZUZlYXR1cmVBZGRfID0gZnVuY3Rpb24gaGFuZGxlRmVhdHVyZUFkZF8gKGV2dCkge1xuICAgIHRoaXMuYWRkRmVhdHVyZV8oLyoqIEB0eXBlIHtGZWF0dXJlfSAqLyAoZXZ0LmVsZW1lbnQpKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdH0gZXZ0IEV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTW9kaWZ5LnByb3RvdHlwZS5oYW5kbGVGZWF0dXJlQ2hhbmdlXyA9IGZ1bmN0aW9uIGhhbmRsZUZlYXR1cmVDaGFuZ2VfIChldnQpIHtcbiAgICBpZiAoIXRoaXMuY2hhbmdpbmdGZWF0dXJlXykge1xuICAgICAgdmFyIGZlYXR1cmUgPSAvKiogQHR5cGUge0ZlYXR1cmV9ICovIChldnQudGFyZ2V0KTtcbiAgICAgIHRoaXMucmVtb3ZlRmVhdHVyZV8oZmVhdHVyZSk7XG4gICAgICB0aGlzLmFkZEZlYXR1cmVfKGZlYXR1cmUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9Db2xsZWN0aW9uLmpzXCIpLkNvbGxlY3Rpb25FdmVudH0gZXZ0IEV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTW9kaWZ5LnByb3RvdHlwZS5oYW5kbGVGZWF0dXJlUmVtb3ZlXyA9IGZ1bmN0aW9uIGhhbmRsZUZlYXR1cmVSZW1vdmVfIChldnQpIHtcbiAgICB2YXIgZmVhdHVyZSA9IC8qKiBAdHlwZSB7RmVhdHVyZX0gKi8gKGV2dC5lbGVtZW50KTtcbiAgICB0aGlzLnJlbW92ZUZlYXR1cmVfKGZlYXR1cmUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0ZlYXR1cmV9IGZlYXR1cmUgRmVhdHVyZVxuICAgKiBAcGFyYW0ge1BvaW50fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIE1vZGlmeS5wcm90b3R5cGUud3JpdGVQb2ludEdlb21ldHJ5XyA9IGZ1bmN0aW9uIHdyaXRlUG9pbnRHZW9tZXRyeV8gKGZlYXR1cmUsIGdlb21ldHJ5KSB7XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICB2YXIgc2VnbWVudERhdGEgPSAvKiogQHR5cGUge1NlZ21lbnREYXRhfSAqLyAoe1xuICAgICAgZmVhdHVyZTogZmVhdHVyZSxcbiAgICAgIGdlb21ldHJ5OiBnZW9tZXRyeSxcbiAgICAgIHNlZ21lbnQ6IFtjb29yZGluYXRlcywgY29vcmRpbmF0ZXNdXG4gICAgfSk7XG4gICAgdGhpcy5yQnVzaF8uaW5zZXJ0KGdlb21ldHJ5LmdldEV4dGVudCgpLCBzZWdtZW50RGF0YSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9NdWx0aVBvaW50LmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTW9kaWZ5LnByb3RvdHlwZS53cml0ZU11bHRpUG9pbnRHZW9tZXRyeV8gPSBmdW5jdGlvbiB3cml0ZU11bHRpUG9pbnRHZW9tZXRyeV8gKGZlYXR1cmUsIGdlb21ldHJ5KSB7XG4gICAgdmFyIHBvaW50cyA9IGdlb21ldHJ5LmdldENvb3JkaW5hdGVzKCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIHZhciBjb29yZGluYXRlcyA9IHBvaW50c1tpXTtcbiAgICAgIHZhciBzZWdtZW50RGF0YSA9IC8qKiBAdHlwZSB7U2VnbWVudERhdGF9ICovICh7XG4gICAgICAgIGZlYXR1cmU6IGZlYXR1cmUsXG4gICAgICAgIGdlb21ldHJ5OiBnZW9tZXRyeSxcbiAgICAgICAgZGVwdGg6IFtpXSxcbiAgICAgICAgaW5kZXg6IGksXG4gICAgICAgIHNlZ21lbnQ6IFtjb29yZGluYXRlcywgY29vcmRpbmF0ZXNdXG4gICAgICB9KTtcbiAgICAgIHRoaXMuckJ1c2hfLmluc2VydChnZW9tZXRyeS5nZXRFeHRlbnQoKSwgc2VnbWVudERhdGEpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtGZWF0dXJlfSBmZWF0dXJlIEZlYXR1cmVcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL0xpbmVTdHJpbmcuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBNb2RpZnkucHJvdG90eXBlLndyaXRlTGluZVN0cmluZ0dlb21ldHJ5XyA9IGZ1bmN0aW9uIHdyaXRlTGluZVN0cmluZ0dlb21ldHJ5XyAoZmVhdHVyZSwgZ2VvbWV0cnkpIHtcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRDb29yZGluYXRlcygpO1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aCAtIDE7IGkgPCBpaTsgKytpKSB7XG4gICAgICB2YXIgc2VnbWVudCA9IGNvb3JkaW5hdGVzLnNsaWNlKGksIGkgKyAyKTtcbiAgICAgIHZhciBzZWdtZW50RGF0YSA9IC8qKiBAdHlwZSB7U2VnbWVudERhdGF9ICovICh7XG4gICAgICAgIGZlYXR1cmU6IGZlYXR1cmUsXG4gICAgICAgIGdlb21ldHJ5OiBnZW9tZXRyeSxcbiAgICAgICAgaW5kZXg6IGksXG4gICAgICAgIHNlZ21lbnQ6IHNlZ21lbnRcbiAgICAgIH0pO1xuICAgICAgdGhpcy5yQnVzaF8uaW5zZXJ0KGJvdW5kaW5nRXh0ZW50KHNlZ21lbnQpLCBzZWdtZW50RGF0YSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0ZlYXR1cmV9IGZlYXR1cmUgRmVhdHVyZVxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vTXVsdGlMaW5lU3RyaW5nLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTW9kaWZ5LnByb3RvdHlwZS53cml0ZU11bHRpTGluZVN0cmluZ0dlb21ldHJ5XyA9IGZ1bmN0aW9uIHdyaXRlTXVsdGlMaW5lU3RyaW5nR2VvbWV0cnlfIChmZWF0dXJlLCBnZW9tZXRyeSkge1xuICAgIHZhciBsaW5lcyA9IGdlb21ldHJ5LmdldENvb3JkaW5hdGVzKCk7XG4gICAgZm9yICh2YXIgaiA9IDAsIGpqID0gbGluZXMubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgdmFyIGNvb3JkaW5hdGVzID0gbGluZXNbal07XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBjb29yZGluYXRlcy5sZW5ndGggLSAxOyBpIDwgaWk7ICsraSkge1xuICAgICAgICB2YXIgc2VnbWVudCA9IGNvb3JkaW5hdGVzLnNsaWNlKGksIGkgKyAyKTtcbiAgICAgICAgdmFyIHNlZ21lbnREYXRhID0gLyoqIEB0eXBlIHtTZWdtZW50RGF0YX0gKi8gKHtcbiAgICAgICAgICBmZWF0dXJlOiBmZWF0dXJlLFxuICAgICAgICAgIGdlb21ldHJ5OiBnZW9tZXRyeSxcbiAgICAgICAgICBkZXB0aDogW2pdLFxuICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgIHNlZ21lbnQ6IHNlZ21lbnRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuckJ1c2hfLmluc2VydChib3VuZGluZ0V4dGVudChzZWdtZW50KSwgc2VnbWVudERhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtGZWF0dXJlfSBmZWF0dXJlIEZlYXR1cmVcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL1BvbHlnb24uanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBNb2RpZnkucHJvdG90eXBlLndyaXRlUG9seWdvbkdlb21ldHJ5XyA9IGZ1bmN0aW9uIHdyaXRlUG9seWdvbkdlb21ldHJ5XyAoZmVhdHVyZSwgZ2VvbWV0cnkpIHtcbiAgICB2YXIgcmluZ3MgPSBnZW9tZXRyeS5nZXRDb29yZGluYXRlcygpO1xuICAgIGZvciAodmFyIGogPSAwLCBqaiA9IHJpbmdzLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICAgIHZhciBjb29yZGluYXRlcyA9IHJpbmdzW2pdO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoIC0gMTsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgdmFyIHNlZ21lbnQgPSBjb29yZGluYXRlcy5zbGljZShpLCBpICsgMik7XG4gICAgICAgIHZhciBzZWdtZW50RGF0YSA9IC8qKiBAdHlwZSB7U2VnbWVudERhdGF9ICovICh7XG4gICAgICAgICAgZmVhdHVyZTogZmVhdHVyZSxcbiAgICAgICAgICBnZW9tZXRyeTogZ2VvbWV0cnksXG4gICAgICAgICAgZGVwdGg6IFtqXSxcbiAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICBzZWdtZW50OiBzZWdtZW50XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJCdXNoXy5pbnNlcnQoYm91bmRpbmdFeHRlbnQoc2VnbWVudCksIHNlZ21lbnREYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9NdWx0aVBvbHlnb24uanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBNb2RpZnkucHJvdG90eXBlLndyaXRlTXVsdGlQb2x5Z29uR2VvbWV0cnlfID0gZnVuY3Rpb24gd3JpdGVNdWx0aVBvbHlnb25HZW9tZXRyeV8gKGZlYXR1cmUsIGdlb21ldHJ5KSB7XG4gICAgdmFyIHBvbHlnb25zID0gZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICBmb3IgKHZhciBrID0gMCwga2sgPSBwb2x5Z29ucy5sZW5ndGg7IGsgPCBrazsgKytrKSB7XG4gICAgICB2YXIgcmluZ3MgPSBwb2x5Z29uc1trXTtcbiAgICAgIGZvciAodmFyIGogPSAwLCBqaiA9IHJpbmdzLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gcmluZ3Nbal07XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aCAtIDE7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgdmFyIHNlZ21lbnQgPSBjb29yZGluYXRlcy5zbGljZShpLCBpICsgMik7XG4gICAgICAgICAgdmFyIHNlZ21lbnREYXRhID0gLyoqIEB0eXBlIHtTZWdtZW50RGF0YX0gKi8gKHtcbiAgICAgICAgICAgIGZlYXR1cmU6IGZlYXR1cmUsXG4gICAgICAgICAgICBnZW9tZXRyeTogZ2VvbWV0cnksXG4gICAgICAgICAgICBkZXB0aDogW2osIGtdLFxuICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICBzZWdtZW50OiBzZWdtZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5yQnVzaF8uaW5zZXJ0KGJvdW5kaW5nRXh0ZW50KHNlZ21lbnQpLCBzZWdtZW50RGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFdlIGNvbnZlcnQgYSBjaXJjbGUgaW50byB0d28gc2VnbWVudHMuICBUaGUgc2VnbWVudCBhdCBpbmRleFxuICAgKiB7QGxpbmsgQ0lSQ0xFX0NFTlRFUl9JTkRFWH0gaXMgdGhlXG4gICAqIGNpcmNsZSdzIGNlbnRlciAoYSBwb2ludCkuICBUaGUgc2VnbWVudCBhdCBpbmRleFxuICAgKiB7QGxpbmsgQ0lSQ0xFX0NJUkNVTUZFUkVOQ0VfSU5ERVh9IGlzXG4gICAqIHRoZSBjaXJjdW1mZXJlbmNlLCBhbmQgaXMgbm90IGEgbGluZSBzZWdtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0ZlYXR1cmV9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL0NpcmNsZS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIE1vZGlmeS5wcm90b3R5cGUud3JpdGVDaXJjbGVHZW9tZXRyeV8gPSBmdW5jdGlvbiB3cml0ZUNpcmNsZUdlb21ldHJ5XyAoZmVhdHVyZSwgZ2VvbWV0cnkpIHtcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRDZW50ZXIoKTtcbiAgICB2YXIgY2VudGVyU2VnbWVudERhdGEgPSAvKiogQHR5cGUge1NlZ21lbnREYXRhfSAqLyAoe1xuICAgICAgZmVhdHVyZTogZmVhdHVyZSxcbiAgICAgIGdlb21ldHJ5OiBnZW9tZXRyeSxcbiAgICAgIGluZGV4OiBDSVJDTEVfQ0VOVEVSX0lOREVYLFxuICAgICAgc2VnbWVudDogW2Nvb3JkaW5hdGVzLCBjb29yZGluYXRlc11cbiAgICB9KTtcbiAgICB2YXIgY2lyY3VtZmVyZW5jZVNlZ21lbnREYXRhID0gLyoqIEB0eXBlIHtTZWdtZW50RGF0YX0gKi8gKHtcbiAgICAgIGZlYXR1cmU6IGZlYXR1cmUsXG4gICAgICBnZW9tZXRyeTogZ2VvbWV0cnksXG4gICAgICBpbmRleDogQ0lSQ0xFX0NJUkNVTUZFUkVOQ0VfSU5ERVgsXG4gICAgICBzZWdtZW50OiBbY29vcmRpbmF0ZXMsIGNvb3JkaW5hdGVzXVxuICAgIH0pO1xuICAgIHZhciBmZWF0dXJlU2VnbWVudHMgPSBbY2VudGVyU2VnbWVudERhdGEsIGNpcmN1bWZlcmVuY2VTZWdtZW50RGF0YV07XG4gICAgY2VudGVyU2VnbWVudERhdGEuZmVhdHVyZVNlZ21lbnRzID0gY2lyY3VtZmVyZW5jZVNlZ21lbnREYXRhLmZlYXR1cmVTZWdtZW50cyA9IGZlYXR1cmVTZWdtZW50cztcbiAgICB0aGlzLnJCdXNoXy5pbnNlcnQoY3JlYXRlT3JVcGRhdGVGcm9tQ29vcmRpbmF0ZShjb29yZGluYXRlcyksIGNlbnRlclNlZ21lbnREYXRhKTtcbiAgICB0aGlzLnJCdXNoXy5pbnNlcnQoZ2VvbWV0cnkuZ2V0RXh0ZW50KCksIGNpcmN1bWZlcmVuY2VTZWdtZW50RGF0YSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeUNvbGxlY3Rpb24uanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBNb2RpZnkucHJvdG90eXBlLndyaXRlR2VvbWV0cnlDb2xsZWN0aW9uR2VvbWV0cnlfID0gZnVuY3Rpb24gd3JpdGVHZW9tZXRyeUNvbGxlY3Rpb25HZW9tZXRyeV8gKGZlYXR1cmUsIGdlb21ldHJ5KSB7XG4gICAgdmFyIGdlb21ldHJpZXMgPSBnZW9tZXRyeS5nZXRHZW9tZXRyaWVzQXJyYXkoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdlb21ldHJpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHRoaXMuU0VHTUVOVF9XUklURVJTX1tnZW9tZXRyaWVzW2ldLmdldFR5cGUoKV0uY2FsbCh0aGlzLCBmZWF0dXJlLCBnZW9tZXRyaWVzW2ldKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAgICogQHJldHVybiB7RmVhdHVyZX0gVmVydGV4IGZlYXR1cmUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBNb2RpZnkucHJvdG90eXBlLmNyZWF0ZU9yVXBkYXRlVmVydGV4RmVhdHVyZV8gPSBmdW5jdGlvbiBjcmVhdGVPclVwZGF0ZVZlcnRleEZlYXR1cmVfIChjb29yZGluYXRlcykge1xuICAgIHZhciB2ZXJ0ZXhGZWF0dXJlID0gdGhpcy52ZXJ0ZXhGZWF0dXJlXztcbiAgICBpZiAoIXZlcnRleEZlYXR1cmUpIHtcbiAgICAgIHZlcnRleEZlYXR1cmUgPSBuZXcgRmVhdHVyZShuZXcgUG9pbnQoY29vcmRpbmF0ZXMpKTtcbiAgICAgIHRoaXMudmVydGV4RmVhdHVyZV8gPSB2ZXJ0ZXhGZWF0dXJlO1xuICAgICAgLyoqIEB0eXBlIHtWZWN0b3JTb3VyY2V9ICovICh0aGlzLm92ZXJsYXlfLmdldFNvdXJjZSgpKS5hZGRGZWF0dXJlKHZlcnRleEZlYXR1cmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZ2VvbWV0cnkgPSAvKiogQHR5cGUge1BvaW50fSAqLyAodmVydGV4RmVhdHVyZS5nZXRHZW9tZXRyeSgpKTtcbiAgICAgIGdlb21ldHJ5LnNldENvb3JkaW5hdGVzKGNvb3JkaW5hdGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHZlcnRleEZlYXR1cmU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50IG1hcCBicm93c2VyIGV2ZW50fSBhbmQgbWF5IG1vZGlmeSB0aGUgZ2VvbWV0cnkuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgTW9kaWZ5LnByb3RvdHlwZS5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uIGhhbmRsZUV2ZW50IChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBpZiAoISgvKiogQHR5cGUge2ltcG9ydChcIi4uL01hcEJyb3dzZXJQb2ludGVyRXZlbnQuanNcIikuZGVmYXVsdH0gKi8gKG1hcEJyb3dzZXJFdmVudCkucG9pbnRlckV2ZW50KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHRoaXMubGFzdFBvaW50ZXJFdmVudF8gPSBtYXBCcm93c2VyRXZlbnQ7XG5cbiAgICB2YXIgaGFuZGxlZDtcbiAgICBpZiAoIW1hcEJyb3dzZXJFdmVudC5tYXAuZ2V0VmlldygpLmdldEludGVyYWN0aW5nKCkgJiZcbiAgICAgICAgbWFwQnJvd3NlckV2ZW50LnR5cGUgPT0gTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSTU9WRSAmJlxuICAgICAgICAhdGhpcy5oYW5kbGluZ0Rvd25VcFNlcXVlbmNlKSB7XG4gICAgICB0aGlzLmhhbmRsZVBvaW50ZXJNb3ZlXyhtYXBCcm93c2VyRXZlbnQpO1xuICAgIH1cbiAgICBpZiAodGhpcy52ZXJ0ZXhGZWF0dXJlXyAmJiB0aGlzLmRlbGV0ZUNvbmRpdGlvbl8obWFwQnJvd3NlckV2ZW50KSkge1xuICAgICAgaWYgKG1hcEJyb3dzZXJFdmVudC50eXBlICE9IE1hcEJyb3dzZXJFdmVudFR5cGUuU0lOR0xFQ0xJQ0sgfHwgIXRoaXMuaWdub3JlTmV4dFNpbmdsZUNsaWNrXykge1xuICAgICAgICBoYW5kbGVkID0gdGhpcy5yZW1vdmVQb2ludCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1hcEJyb3dzZXJFdmVudC50eXBlID09IE1hcEJyb3dzZXJFdmVudFR5cGUuU0lOR0xFQ0xJQ0spIHtcbiAgICAgIHRoaXMuaWdub3JlTmV4dFNpbmdsZUNsaWNrXyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBQb2ludGVySW50ZXJhY3Rpb24ucHJvdG90eXBlLmhhbmRsZUV2ZW50LmNhbGwodGhpcywgbWFwQnJvd3NlckV2ZW50KSAmJiAhaGFuZGxlZDtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIE1vZGlmeS5wcm90b3R5cGUuaGFuZGxlRHJhZ0V2ZW50ID0gZnVuY3Rpb24gaGFuZGxlRHJhZ0V2ZW50IChldnQpIHtcbiAgICB0aGlzLmlnbm9yZU5leHRTaW5nbGVDbGlja18gPSBmYWxzZTtcbiAgICB0aGlzLndpbGxNb2RpZnlGZWF0dXJlc18oZXZ0KTtcblxuICAgIHZhciB2ZXJ0ZXggPSBldnQuY29vcmRpbmF0ZTtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLmRyYWdTZWdtZW50c18ubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgdmFyIGRyYWdTZWdtZW50ID0gdGhpcy5kcmFnU2VnbWVudHNfW2ldO1xuICAgICAgdmFyIHNlZ21lbnREYXRhID0gZHJhZ1NlZ21lbnRbMF07XG4gICAgICB2YXIgZGVwdGggPSBzZWdtZW50RGF0YS5kZXB0aDtcbiAgICAgIHZhciBnZW9tZXRyeSA9IHNlZ21lbnREYXRhLmdlb21ldHJ5O1xuICAgICAgdmFyIGNvb3JkaW5hdGVzID0gKHZvaWQgMCk7XG4gICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnREYXRhLnNlZ21lbnQ7XG4gICAgICB2YXIgaW5kZXggPSBkcmFnU2VnbWVudFsxXTtcblxuICAgICAgd2hpbGUgKHZlcnRleC5sZW5ndGggPCBnZW9tZXRyeS5nZXRTdHJpZGUoKSkge1xuICAgICAgICB2ZXJ0ZXgucHVzaChzZWdtZW50W2luZGV4XVt2ZXJ0ZXgubGVuZ3RoXSk7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoZ2VvbWV0cnkuZ2V0VHlwZSgpKSB7XG4gICAgICAgIGNhc2UgR2VvbWV0cnlUeXBlLlBPSU5UOlxuICAgICAgICAgIGNvb3JkaW5hdGVzID0gdmVydGV4O1xuICAgICAgICAgIHNlZ21lbnRbMF0gPSBzZWdtZW50WzFdID0gdmVydGV4O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdlb21ldHJ5VHlwZS5NVUxUSV9QT0lOVDpcbiAgICAgICAgICBjb29yZGluYXRlcyA9IGdlb21ldHJ5LmdldENvb3JkaW5hdGVzKCk7XG4gICAgICAgICAgY29vcmRpbmF0ZXNbc2VnbWVudERhdGEuaW5kZXhdID0gdmVydGV4O1xuICAgICAgICAgIHNlZ21lbnRbMF0gPSBzZWdtZW50WzFdID0gdmVydGV4O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdlb21ldHJ5VHlwZS5MSU5FX1NUUklORzpcbiAgICAgICAgICBjb29yZGluYXRlcyA9IGdlb21ldHJ5LmdldENvb3JkaW5hdGVzKCk7XG4gICAgICAgICAgY29vcmRpbmF0ZXNbc2VnbWVudERhdGEuaW5kZXggKyBpbmRleF0gPSB2ZXJ0ZXg7XG4gICAgICAgICAgc2VnbWVudFtpbmRleF0gPSB2ZXJ0ZXg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR2VvbWV0cnlUeXBlLk1VTFRJX0xJTkVfU1RSSU5HOlxuICAgICAgICAgIGNvb3JkaW5hdGVzID0gZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgICAgICBjb29yZGluYXRlc1tkZXB0aFswXV1bc2VnbWVudERhdGEuaW5kZXggKyBpbmRleF0gPSB2ZXJ0ZXg7XG4gICAgICAgICAgc2VnbWVudFtpbmRleF0gPSB2ZXJ0ZXg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR2VvbWV0cnlUeXBlLlBPTFlHT046XG4gICAgICAgICAgY29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgICAgIGNvb3JkaW5hdGVzW2RlcHRoWzBdXVtzZWdtZW50RGF0YS5pbmRleCArIGluZGV4XSA9IHZlcnRleDtcbiAgICAgICAgICBzZWdtZW50W2luZGV4XSA9IHZlcnRleDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuTVVMVElfUE9MWUdPTjpcbiAgICAgICAgICBjb29yZGluYXRlcyA9IGdlb21ldHJ5LmdldENvb3JkaW5hdGVzKCk7XG4gICAgICAgICAgY29vcmRpbmF0ZXNbZGVwdGhbMV1dW2RlcHRoWzBdXVtzZWdtZW50RGF0YS5pbmRleCArIGluZGV4XSA9IHZlcnRleDtcbiAgICAgICAgICBzZWdtZW50W2luZGV4XSA9IHZlcnRleDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuQ0lSQ0xFOlxuICAgICAgICAgIHNlZ21lbnRbMF0gPSBzZWdtZW50WzFdID0gdmVydGV4O1xuICAgICAgICAgIGlmIChzZWdtZW50RGF0YS5pbmRleCA9PT0gQ0lSQ0xFX0NFTlRFUl9JTkRFWCkge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2luZ0ZlYXR1cmVfID0gdHJ1ZTtcbiAgICAgICAgICAgIGdlb21ldHJ5LnNldENlbnRlcih2ZXJ0ZXgpO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2luZ0ZlYXR1cmVfID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHsgLy8gV2UncmUgZHJhZ2dpbmcgdGhlIGNpcmNsZSdzIGNpcmN1bWZlcmVuY2U6XG4gICAgICAgICAgICB0aGlzLmNoYW5naW5nRmVhdHVyZV8gPSB0cnVlO1xuICAgICAgICAgICAgZ2VvbWV0cnkuc2V0UmFkaXVzKGNvb3JkaW5hdGVEaXN0YW5jZShnZW9tZXRyeS5nZXRDZW50ZXIoKSwgdmVydGV4KSk7XG4gICAgICAgICAgICB0aGlzLmNoYW5naW5nRmVhdHVyZV8gPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gcGFzc1xuICAgICAgfVxuXG4gICAgICBpZiAoY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgdGhpcy5zZXRHZW9tZXRyeUNvb3JkaW5hdGVzXyhnZW9tZXRyeSwgY29vcmRpbmF0ZXMpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNyZWF0ZU9yVXBkYXRlVmVydGV4RmVhdHVyZV8odmVydGV4KTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIE1vZGlmeS5wcm90b3R5cGUuaGFuZGxlRG93bkV2ZW50ID0gZnVuY3Rpb24gaGFuZGxlRG93bkV2ZW50IChldnQpIHtcbiAgICBpZiAoIXRoaXMuY29uZGl0aW9uXyhldnQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuaGFuZGxlUG9pbnRlckF0UGl4ZWxfKGV2dC5waXhlbCwgZXZ0Lm1hcCk7XG4gICAgdmFyIHBpeGVsQ29vcmRpbmF0ZSA9IGV2dC5tYXAuZ2V0Q29vcmRpbmF0ZUZyb21QaXhlbChldnQucGl4ZWwpO1xuICAgIHRoaXMuZHJhZ1NlZ21lbnRzXy5sZW5ndGggPSAwO1xuICAgIHRoaXMubW9kaWZpZWRfID0gZmFsc2U7XG4gICAgdmFyIHZlcnRleEZlYXR1cmUgPSB0aGlzLnZlcnRleEZlYXR1cmVfO1xuICAgIGlmICh2ZXJ0ZXhGZWF0dXJlKSB7XG4gICAgICB2YXIgaW5zZXJ0VmVydGljZXMgPSBbXTtcbiAgICAgIHZhciBnZW9tZXRyeSA9IC8qKiBAdHlwZSB7UG9pbnR9ICovICh2ZXJ0ZXhGZWF0dXJlLmdldEdlb21ldHJ5KCkpO1xuICAgICAgdmFyIHZlcnRleCA9IGdlb21ldHJ5LmdldENvb3JkaW5hdGVzKCk7XG4gICAgICB2YXIgdmVydGV4RXh0ZW50ID0gYm91bmRpbmdFeHRlbnQoW3ZlcnRleF0pO1xuICAgICAgdmFyIHNlZ21lbnREYXRhTWF0Y2hlcyA9IHRoaXMuckJ1c2hfLmdldEluRXh0ZW50KHZlcnRleEV4dGVudCk7XG4gICAgICB2YXIgY29tcG9uZW50U2VnbWVudHMgPSB7fTtcbiAgICAgIHNlZ21lbnREYXRhTWF0Y2hlcy5zb3J0KGNvbXBhcmVJbmRleGVzKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHNlZ21lbnREYXRhTWF0Y2hlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIHZhciBzZWdtZW50RGF0YU1hdGNoID0gc2VnbWVudERhdGFNYXRjaGVzW2ldO1xuICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnREYXRhTWF0Y2guc2VnbWVudDtcbiAgICAgICAgdmFyIHVpZCA9IGdldFVpZChzZWdtZW50RGF0YU1hdGNoLmZlYXR1cmUpO1xuICAgICAgICB2YXIgZGVwdGggPSBzZWdtZW50RGF0YU1hdGNoLmRlcHRoO1xuICAgICAgICBpZiAoZGVwdGgpIHtcbiAgICAgICAgICB1aWQgKz0gJy0nICsgZGVwdGguam9pbignLScpOyAvLyBzZXBhcmF0ZSBmZWF0dXJlIGNvbXBvbmVudHNcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbXBvbmVudFNlZ21lbnRzW3VpZF0pIHtcbiAgICAgICAgICBjb21wb25lbnRTZWdtZW50c1t1aWRdID0gbmV3IEFycmF5KDIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWdtZW50RGF0YU1hdGNoLmdlb21ldHJ5LmdldFR5cGUoKSA9PT0gR2VvbWV0cnlUeXBlLkNJUkNMRSAmJlxuICAgICAgICBzZWdtZW50RGF0YU1hdGNoLmluZGV4ID09PSBDSVJDTEVfQ0lSQ1VNRkVSRU5DRV9JTkRFWCkge1xuXG4gICAgICAgICAgdmFyIGNsb3Nlc3RWZXJ0ZXggPSBjbG9zZXN0T25TZWdtZW50RGF0YShwaXhlbENvb3JkaW5hdGUsIHNlZ21lbnREYXRhTWF0Y2gpO1xuICAgICAgICAgIGlmIChjb29yZGluYXRlc0VxdWFsKGNsb3Nlc3RWZXJ0ZXgsIHZlcnRleCkgJiYgIWNvbXBvbmVudFNlZ21lbnRzW3VpZF1bMF0pIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ1NlZ21lbnRzXy5wdXNoKFtzZWdtZW50RGF0YU1hdGNoLCAwXSk7XG4gICAgICAgICAgICBjb21wb25lbnRTZWdtZW50c1t1aWRdWzBdID0gc2VnbWVudERhdGFNYXRjaDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY29vcmRpbmF0ZXNFcXVhbChzZWdtZW50WzBdLCB2ZXJ0ZXgpICYmXG4gICAgICAgICAgICAhY29tcG9uZW50U2VnbWVudHNbdWlkXVswXSkge1xuICAgICAgICAgIHRoaXMuZHJhZ1NlZ21lbnRzXy5wdXNoKFtzZWdtZW50RGF0YU1hdGNoLCAwXSk7XG4gICAgICAgICAgY29tcG9uZW50U2VnbWVudHNbdWlkXVswXSA9IHNlZ21lbnREYXRhTWF0Y2g7XG4gICAgICAgIH0gZWxzZSBpZiAoY29vcmRpbmF0ZXNFcXVhbChzZWdtZW50WzFdLCB2ZXJ0ZXgpICYmXG4gICAgICAgICAgICAhY29tcG9uZW50U2VnbWVudHNbdWlkXVsxXSkge1xuXG4gICAgICAgICAgLy8gcHJldmVudCBkcmFnZ2luZyBjbG9zZWQgbGluZXN0cmluZ3MgYnkgdGhlIGNvbm5lY3Rpbmcgbm9kZVxuICAgICAgICAgIGlmICgoc2VnbWVudERhdGFNYXRjaC5nZW9tZXRyeS5nZXRUeXBlKCkgPT09XG4gICAgICAgICAgICAgIEdlb21ldHJ5VHlwZS5MSU5FX1NUUklORyB8fFxuICAgICAgICAgICAgICBzZWdtZW50RGF0YU1hdGNoLmdlb21ldHJ5LmdldFR5cGUoKSA9PT1cbiAgICAgICAgICAgICAgR2VvbWV0cnlUeXBlLk1VTFRJX0xJTkVfU1RSSU5HKSAmJlxuICAgICAgICAgICAgICBjb21wb25lbnRTZWdtZW50c1t1aWRdWzBdICYmXG4gICAgICAgICAgICAgIGNvbXBvbmVudFNlZ21lbnRzW3VpZF1bMF0uaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZHJhZ1NlZ21lbnRzXy5wdXNoKFtzZWdtZW50RGF0YU1hdGNoLCAxXSk7XG4gICAgICAgICAgY29tcG9uZW50U2VnbWVudHNbdWlkXVsxXSA9IHNlZ21lbnREYXRhTWF0Y2g7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pbnNlcnRWZXJ0ZXhDb25kaXRpb25fKGV2dCkgJiYgZ2V0VWlkKHNlZ21lbnQpIGluIHRoaXMudmVydGV4U2VnbWVudHNfICYmXG4gICAgICAgICAgICAoIWNvbXBvbmVudFNlZ21lbnRzW3VpZF1bMF0gJiYgIWNvbXBvbmVudFNlZ21lbnRzW3VpZF1bMV0pKSB7XG4gICAgICAgICAgaW5zZXJ0VmVydGljZXMucHVzaChbc2VnbWVudERhdGFNYXRjaCwgdmVydGV4XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpbnNlcnRWZXJ0aWNlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy53aWxsTW9kaWZ5RmVhdHVyZXNfKGV2dCk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBqID0gaW5zZXJ0VmVydGljZXMubGVuZ3RoIC0gMTsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgdGhpcy5pbnNlcnRWZXJ0ZXhfLmFwcGx5KHRoaXMsIGluc2VydFZlcnRpY2VzW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICEhdGhpcy52ZXJ0ZXhGZWF0dXJlXztcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIE1vZGlmeS5wcm90b3R5cGUuaGFuZGxlVXBFdmVudCA9IGZ1bmN0aW9uIGhhbmRsZVVwRXZlbnQgKGV2dCkge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmRyYWdTZWdtZW50c18ubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHZhciBzZWdtZW50RGF0YSA9IHRoaXMuZHJhZ1NlZ21lbnRzX1tpXVswXTtcbiAgICAgIHZhciBnZW9tZXRyeSA9IHNlZ21lbnREYXRhLmdlb21ldHJ5O1xuICAgICAgaWYgKGdlb21ldHJ5LmdldFR5cGUoKSA9PT0gR2VvbWV0cnlUeXBlLkNJUkNMRSkge1xuICAgICAgICAvLyBVcGRhdGUgYSBjaXJjbGUgb2JqZWN0IGluIHRoZSBSKiBidXNoOlxuICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRDZW50ZXIoKTtcbiAgICAgICAgdmFyIGNlbnRlclNlZ21lbnREYXRhID0gc2VnbWVudERhdGEuZmVhdHVyZVNlZ21lbnRzWzBdO1xuICAgICAgICB2YXIgY2lyY3VtZmVyZW5jZVNlZ21lbnREYXRhID0gc2VnbWVudERhdGEuZmVhdHVyZVNlZ21lbnRzWzFdO1xuICAgICAgICBjZW50ZXJTZWdtZW50RGF0YS5zZWdtZW50WzBdID0gY2VudGVyU2VnbWVudERhdGEuc2VnbWVudFsxXSA9IGNvb3JkaW5hdGVzO1xuICAgICAgICBjaXJjdW1mZXJlbmNlU2VnbWVudERhdGEuc2VnbWVudFswXSA9IGNpcmN1bWZlcmVuY2VTZWdtZW50RGF0YS5zZWdtZW50WzFdID0gY29vcmRpbmF0ZXM7XG4gICAgICAgIHRoaXMuckJ1c2hfLnVwZGF0ZShjcmVhdGVPclVwZGF0ZUZyb21Db29yZGluYXRlKGNvb3JkaW5hdGVzKSwgY2VudGVyU2VnbWVudERhdGEpO1xuICAgICAgICB0aGlzLnJCdXNoXy51cGRhdGUoZ2VvbWV0cnkuZ2V0RXh0ZW50KCksIGNpcmN1bWZlcmVuY2VTZWdtZW50RGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJCdXNoXy51cGRhdGUoYm91bmRpbmdFeHRlbnQoc2VnbWVudERhdGEuc2VnbWVudCksIHNlZ21lbnREYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMubW9kaWZpZWRfKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IE1vZGlmeUV2ZW50KE1vZGlmeUV2ZW50VHlwZS5NT0RJRllFTkQsIHRoaXMuZmVhdHVyZXNfLCBldnQpKTtcbiAgICAgIHRoaXMubW9kaWZpZWRfID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gZXZ0IEV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTW9kaWZ5LnByb3RvdHlwZS5oYW5kbGVQb2ludGVyTW92ZV8gPSBmdW5jdGlvbiBoYW5kbGVQb2ludGVyTW92ZV8gKGV2dCkge1xuICAgIHRoaXMubGFzdFBpeGVsXyA9IGV2dC5waXhlbDtcbiAgICB0aGlzLmhhbmRsZVBvaW50ZXJBdFBpeGVsXyhldnQucGl4ZWwsIGV2dC5tYXApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsfSBwaXhlbCBQaXhlbFxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1BsdWdnYWJsZU1hcC5qc1wiKS5kZWZhdWx0fSBtYXAgTWFwLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTW9kaWZ5LnByb3RvdHlwZS5oYW5kbGVQb2ludGVyQXRQaXhlbF8gPSBmdW5jdGlvbiBoYW5kbGVQb2ludGVyQXRQaXhlbF8gKHBpeGVsLCBtYXApIHtcbiAgICB2YXIgcGl4ZWxDb29yZGluYXRlID0gbWFwLmdldENvb3JkaW5hdGVGcm9tUGl4ZWwocGl4ZWwpO1xuICAgIHZhciBzb3J0QnlEaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHJldHVybiBwb2ludERpc3RhbmNlVG9TZWdtZW50RGF0YVNxdWFyZWQocGl4ZWxDb29yZGluYXRlLCBhKSAtXG4gICAgICAgICAgcG9pbnREaXN0YW5jZVRvU2VnbWVudERhdGFTcXVhcmVkKHBpeGVsQ29vcmRpbmF0ZSwgYik7XG4gICAgfTtcblxuICAgIHZhciBib3ggPSBidWZmZXIoY3JlYXRlT3JVcGRhdGVGcm9tQ29vcmRpbmF0ZShwaXhlbENvb3JkaW5hdGUpLFxuICAgICAgbWFwLmdldFZpZXcoKS5nZXRSZXNvbHV0aW9uKCkgKiB0aGlzLnBpeGVsVG9sZXJhbmNlXyk7XG5cbiAgICB2YXIgckJ1c2ggPSB0aGlzLnJCdXNoXztcbiAgICB2YXIgbm9kZXMgPSByQnVzaC5nZXRJbkV4dGVudChib3gpO1xuICAgIGlmIChub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICBub2Rlcy5zb3J0KHNvcnRCeURpc3RhbmNlKTtcbiAgICAgIHZhciBub2RlID0gbm9kZXNbMF07XG4gICAgICB2YXIgY2xvc2VzdFNlZ21lbnQgPSBub2RlLnNlZ21lbnQ7XG4gICAgICB2YXIgdmVydGV4ID0gY2xvc2VzdE9uU2VnbWVudERhdGEocGl4ZWxDb29yZGluYXRlLCBub2RlKTtcbiAgICAgIHZhciB2ZXJ0ZXhQaXhlbCA9IG1hcC5nZXRQaXhlbEZyb21Db29yZGluYXRlKHZlcnRleCk7XG4gICAgICB2YXIgZGlzdCA9IGNvb3JkaW5hdGVEaXN0YW5jZShwaXhlbCwgdmVydGV4UGl4ZWwpO1xuICAgICAgaWYgKGRpc3QgPD0gdGhpcy5waXhlbFRvbGVyYW5jZV8pIHtcbiAgICAgICAgLyoqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBib29sZWFuPn0gKi9cbiAgICAgICAgdmFyIHZlcnRleFNlZ21lbnRzID0ge307XG5cbiAgICAgICAgaWYgKG5vZGUuZ2VvbWV0cnkuZ2V0VHlwZSgpID09PSBHZW9tZXRyeVR5cGUuQ0lSQ0xFICYmXG4gICAgICAgIG5vZGUuaW5kZXggPT09IENJUkNMRV9DSVJDVU1GRVJFTkNFX0lOREVYKSB7XG5cbiAgICAgICAgICB0aGlzLnNuYXBwZWRUb1ZlcnRleF8gPSB0cnVlO1xuICAgICAgICAgIHRoaXMuY3JlYXRlT3JVcGRhdGVWZXJ0ZXhGZWF0dXJlXyh2ZXJ0ZXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwaXhlbDEgPSBtYXAuZ2V0UGl4ZWxGcm9tQ29vcmRpbmF0ZShjbG9zZXN0U2VnbWVudFswXSk7XG4gICAgICAgICAgdmFyIHBpeGVsMiA9IG1hcC5nZXRQaXhlbEZyb21Db29yZGluYXRlKGNsb3Nlc3RTZWdtZW50WzFdKTtcbiAgICAgICAgICB2YXIgc3F1YXJlZERpc3QxID0gc3F1YXJlZENvb3JkaW5hdGVEaXN0YW5jZSh2ZXJ0ZXhQaXhlbCwgcGl4ZWwxKTtcbiAgICAgICAgICB2YXIgc3F1YXJlZERpc3QyID0gc3F1YXJlZENvb3JkaW5hdGVEaXN0YW5jZSh2ZXJ0ZXhQaXhlbCwgcGl4ZWwyKTtcbiAgICAgICAgICBkaXN0ID0gTWF0aC5zcXJ0KE1hdGgubWluKHNxdWFyZWREaXN0MSwgc3F1YXJlZERpc3QyKSk7XG4gICAgICAgICAgdGhpcy5zbmFwcGVkVG9WZXJ0ZXhfID0gZGlzdCA8PSB0aGlzLnBpeGVsVG9sZXJhbmNlXztcbiAgICAgICAgICBpZiAodGhpcy5zbmFwcGVkVG9WZXJ0ZXhfKSB7XG4gICAgICAgICAgICB2ZXJ0ZXggPSBzcXVhcmVkRGlzdDEgPiBzcXVhcmVkRGlzdDIgPyBjbG9zZXN0U2VnbWVudFsxXSA6IGNsb3Nlc3RTZWdtZW50WzBdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmNyZWF0ZU9yVXBkYXRlVmVydGV4RmVhdHVyZV8odmVydGV4KTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMSwgaWkgPSBub2Rlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgICB2YXIgc2VnbWVudCA9IG5vZGVzW2ldLnNlZ21lbnQ7XG4gICAgICAgICAgICBpZiAoKGNvb3JkaW5hdGVzRXF1YWwoY2xvc2VzdFNlZ21lbnRbMF0sIHNlZ21lbnRbMF0pICYmXG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZXNFcXVhbChjbG9zZXN0U2VnbWVudFsxXSwgc2VnbWVudFsxXSkgfHxcbiAgICAgICAgICAgICAgICAoY29vcmRpbmF0ZXNFcXVhbChjbG9zZXN0U2VnbWVudFswXSwgc2VnbWVudFsxXSkgJiZcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlc0VxdWFsKGNsb3Nlc3RTZWdtZW50WzFdLCBzZWdtZW50WzBdKSkpKSB7XG4gICAgICAgICAgICAgIHZlcnRleFNlZ21lbnRzW2dldFVpZChzZWdtZW50KV0gPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmVydGV4U2VnbWVudHNbZ2V0VWlkKGNsb3Nlc3RTZWdtZW50KV0gPSB0cnVlO1xuICAgICAgICB0aGlzLnZlcnRleFNlZ21lbnRzXyA9IHZlcnRleFNlZ21lbnRzO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnZlcnRleEZlYXR1cmVfKSB7XG4gICAgICAvKiogQHR5cGUge1ZlY3RvclNvdXJjZX0gKi8gKHRoaXMub3ZlcmxheV8uZ2V0U291cmNlKCkpLnJlbW92ZUZlYXR1cmUodGhpcy52ZXJ0ZXhGZWF0dXJlXyk7XG4gICAgICB0aGlzLnZlcnRleEZlYXR1cmVfID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U2VnbWVudERhdGF9IHNlZ21lbnREYXRhIFNlZ21lbnQgZGF0YS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IHZlcnRleCBWZXJ0ZXguXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBNb2RpZnkucHJvdG90eXBlLmluc2VydFZlcnRleF8gPSBmdW5jdGlvbiBpbnNlcnRWZXJ0ZXhfIChzZWdtZW50RGF0YSwgdmVydGV4KSB7XG4gICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50RGF0YS5zZWdtZW50O1xuICAgIHZhciBmZWF0dXJlID0gc2VnbWVudERhdGEuZmVhdHVyZTtcbiAgICB2YXIgZ2VvbWV0cnkgPSBzZWdtZW50RGF0YS5nZW9tZXRyeTtcbiAgICB2YXIgZGVwdGggPSBzZWdtZW50RGF0YS5kZXB0aDtcbiAgICB2YXIgaW5kZXggPSAvKiogQHR5cGUge251bWJlcn0gKi8gKHNlZ21lbnREYXRhLmluZGV4KTtcbiAgICB2YXIgY29vcmRpbmF0ZXM7XG5cbiAgICB3aGlsZSAodmVydGV4Lmxlbmd0aCA8IGdlb21ldHJ5LmdldFN0cmlkZSgpKSB7XG4gICAgICB2ZXJ0ZXgucHVzaCgwKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGdlb21ldHJ5LmdldFR5cGUoKSkge1xuICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuTVVMVElfTElORV9TVFJJTkc6XG4gICAgICAgIGNvb3JkaW5hdGVzID0gZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgICAgY29vcmRpbmF0ZXNbZGVwdGhbMF1dLnNwbGljZShpbmRleCArIDEsIDAsIHZlcnRleCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuUE9MWUdPTjpcbiAgICAgICAgY29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgICBjb29yZGluYXRlc1tkZXB0aFswXV0uc3BsaWNlKGluZGV4ICsgMSwgMCwgdmVydGV4KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEdlb21ldHJ5VHlwZS5NVUxUSV9QT0xZR09OOlxuICAgICAgICBjb29yZGluYXRlcyA9IGdlb21ldHJ5LmdldENvb3JkaW5hdGVzKCk7XG4gICAgICAgIGNvb3JkaW5hdGVzW2RlcHRoWzFdXVtkZXB0aFswXV0uc3BsaWNlKGluZGV4ICsgMSwgMCwgdmVydGV4KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEdlb21ldHJ5VHlwZS5MSU5FX1NUUklORzpcbiAgICAgICAgY29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgICBjb29yZGluYXRlcy5zcGxpY2UoaW5kZXggKyAxLCAwLCB2ZXJ0ZXgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnNldEdlb21ldHJ5Q29vcmRpbmF0ZXNfKGdlb21ldHJ5LCBjb29yZGluYXRlcyk7XG4gICAgdmFyIHJUcmVlID0gdGhpcy5yQnVzaF87XG4gICAgclRyZWUucmVtb3ZlKHNlZ21lbnREYXRhKTtcbiAgICB0aGlzLnVwZGF0ZVNlZ21lbnRJbmRpY2VzXyhnZW9tZXRyeSwgaW5kZXgsIGRlcHRoLCAxKTtcbiAgICB2YXIgbmV3U2VnbWVudERhdGEgPSAvKiogQHR5cGUge1NlZ21lbnREYXRhfSAqLyAoe1xuICAgICAgc2VnbWVudDogW3NlZ21lbnRbMF0sIHZlcnRleF0sXG4gICAgICBmZWF0dXJlOiBmZWF0dXJlLFxuICAgICAgZ2VvbWV0cnk6IGdlb21ldHJ5LFxuICAgICAgZGVwdGg6IGRlcHRoLFxuICAgICAgaW5kZXg6IGluZGV4XG4gICAgfSk7XG4gICAgclRyZWUuaW5zZXJ0KGJvdW5kaW5nRXh0ZW50KG5ld1NlZ21lbnREYXRhLnNlZ21lbnQpLFxuICAgICAgbmV3U2VnbWVudERhdGEpO1xuICAgIHRoaXMuZHJhZ1NlZ21lbnRzXy5wdXNoKFtuZXdTZWdtZW50RGF0YSwgMV0pO1xuXG4gICAgdmFyIG5ld1NlZ21lbnREYXRhMiA9IC8qKiBAdHlwZSB7U2VnbWVudERhdGF9ICovICh7XG4gICAgICBzZWdtZW50OiBbdmVydGV4LCBzZWdtZW50WzFdXSxcbiAgICAgIGZlYXR1cmU6IGZlYXR1cmUsXG4gICAgICBnZW9tZXRyeTogZ2VvbWV0cnksXG4gICAgICBkZXB0aDogZGVwdGgsXG4gICAgICBpbmRleDogaW5kZXggKyAxXG4gICAgfSk7XG4gICAgclRyZWUuaW5zZXJ0KGJvdW5kaW5nRXh0ZW50KG5ld1NlZ21lbnREYXRhMi5zZWdtZW50KSwgbmV3U2VnbWVudERhdGEyKTtcbiAgICB0aGlzLmRyYWdTZWdtZW50c18ucHVzaChbbmV3U2VnbWVudERhdGEyLCAwXSk7XG4gICAgdGhpcy5pZ25vcmVOZXh0U2luZ2xlQ2xpY2tfID0gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgdmVydGV4IGN1cnJlbnRseSBiZWluZyBwb2ludGVkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIHdoZW4gYSB2ZXJ0ZXggd2FzIHJlbW92ZWQuXG4gICAqIEBhcGlcbiAgICovXG4gIE1vZGlmeS5wcm90b3R5cGUucmVtb3ZlUG9pbnQgPSBmdW5jdGlvbiByZW1vdmVQb2ludCAoKSB7XG4gICAgaWYgKHRoaXMubGFzdFBvaW50ZXJFdmVudF8gJiYgdGhpcy5sYXN0UG9pbnRlckV2ZW50Xy50eXBlICE9IE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUkRSQUcpIHtcbiAgICAgIHZhciBldnQgPSB0aGlzLmxhc3RQb2ludGVyRXZlbnRfO1xuICAgICAgdGhpcy53aWxsTW9kaWZ5RmVhdHVyZXNfKGV2dCk7XG4gICAgICB0aGlzLnJlbW92ZVZlcnRleF8oKTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgTW9kaWZ5RXZlbnQoTW9kaWZ5RXZlbnRUeXBlLk1PRElGWUVORCwgdGhpcy5mZWF0dXJlc18sIGV2dCkpO1xuICAgICAgdGhpcy5tb2RpZmllZF8gPSBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSB2ZXJ0ZXggZnJvbSBhbGwgbWF0Y2hpbmcgZmVhdHVyZXMuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgd2hlbiBhIHZlcnRleCB3YXMgcmVtb3ZlZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIE1vZGlmeS5wcm90b3R5cGUucmVtb3ZlVmVydGV4XyA9IGZ1bmN0aW9uIHJlbW92ZVZlcnRleF8gKCkge1xuICAgIHZhciBkcmFnU2VnbWVudHMgPSB0aGlzLmRyYWdTZWdtZW50c187XG4gICAgdmFyIHNlZ21lbnRzQnlGZWF0dXJlID0ge307XG4gICAgdmFyIGRlbGV0ZWQgPSBmYWxzZTtcbiAgICB2YXIgY29tcG9uZW50LCBjb29yZGluYXRlcywgZHJhZ1NlZ21lbnQsIGdlb21ldHJ5LCBpLCBpbmRleCwgbGVmdDtcbiAgICB2YXIgbmV3SW5kZXgsIHJpZ2h0LCBzZWdtZW50RGF0YSwgdWlkO1xuICAgIGZvciAoaSA9IGRyYWdTZWdtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgZHJhZ1NlZ21lbnQgPSBkcmFnU2VnbWVudHNbaV07XG4gICAgICBzZWdtZW50RGF0YSA9IGRyYWdTZWdtZW50WzBdO1xuICAgICAgdWlkID0gZ2V0VWlkKHNlZ21lbnREYXRhLmZlYXR1cmUpO1xuICAgICAgaWYgKHNlZ21lbnREYXRhLmRlcHRoKSB7XG4gICAgICAgIC8vIHNlcGFyYXRlIGZlYXR1cmUgY29tcG9uZW50c1xuICAgICAgICB1aWQgKz0gJy0nICsgc2VnbWVudERhdGEuZGVwdGguam9pbignLScpO1xuICAgICAgfVxuICAgICAgaWYgKCEodWlkIGluIHNlZ21lbnRzQnlGZWF0dXJlKSkge1xuICAgICAgICBzZWdtZW50c0J5RmVhdHVyZVt1aWRdID0ge307XG4gICAgICB9XG4gICAgICBpZiAoZHJhZ1NlZ21lbnRbMV0gPT09IDApIHtcbiAgICAgICAgc2VnbWVudHNCeUZlYXR1cmVbdWlkXS5yaWdodCA9IHNlZ21lbnREYXRhO1xuICAgICAgICBzZWdtZW50c0J5RmVhdHVyZVt1aWRdLmluZGV4ID0gc2VnbWVudERhdGEuaW5kZXg7XG4gICAgICB9IGVsc2UgaWYgKGRyYWdTZWdtZW50WzFdID09IDEpIHtcbiAgICAgICAgc2VnbWVudHNCeUZlYXR1cmVbdWlkXS5sZWZ0ID0gc2VnbWVudERhdGE7XG4gICAgICAgIHNlZ21lbnRzQnlGZWF0dXJlW3VpZF0uaW5kZXggPSBzZWdtZW50RGF0YS5pbmRleCArIDE7XG4gICAgICB9XG5cbiAgICB9XG4gICAgZm9yICh1aWQgaW4gc2VnbWVudHNCeUZlYXR1cmUpIHtcbiAgICAgIHJpZ2h0ID0gc2VnbWVudHNCeUZlYXR1cmVbdWlkXS5yaWdodDtcbiAgICAgIGxlZnQgPSBzZWdtZW50c0J5RmVhdHVyZVt1aWRdLmxlZnQ7XG4gICAgICBpbmRleCA9IHNlZ21lbnRzQnlGZWF0dXJlW3VpZF0uaW5kZXg7XG4gICAgICBuZXdJbmRleCA9IGluZGV4IC0gMTtcbiAgICAgIGlmIChsZWZ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2VnbWVudERhdGEgPSBsZWZ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VnbWVudERhdGEgPSByaWdodDtcbiAgICAgIH1cbiAgICAgIGlmIChuZXdJbmRleCA8IDApIHtcbiAgICAgICAgbmV3SW5kZXggPSAwO1xuICAgICAgfVxuICAgICAgZ2VvbWV0cnkgPSBzZWdtZW50RGF0YS5nZW9tZXRyeTtcbiAgICAgIGNvb3JkaW5hdGVzID0gZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIGNvbXBvbmVudCA9IGNvb3JkaW5hdGVzO1xuICAgICAgZGVsZXRlZCA9IGZhbHNlO1xuICAgICAgc3dpdGNoIChnZW9tZXRyeS5nZXRUeXBlKCkpIHtcbiAgICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuTVVMVElfTElORV9TVFJJTkc6XG4gICAgICAgICAgaWYgKGNvb3JkaW5hdGVzW3NlZ21lbnREYXRhLmRlcHRoWzBdXS5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICBjb29yZGluYXRlc1tzZWdtZW50RGF0YS5kZXB0aFswXV0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIGRlbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuTElORV9TVFJJTkc6XG4gICAgICAgICAgaWYgKGNvb3JkaW5hdGVzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICBkZWxldGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR2VvbWV0cnlUeXBlLk1VTFRJX1BPTFlHT046XG4gICAgICAgICAgY29tcG9uZW50ID0gY29tcG9uZW50W3NlZ21lbnREYXRhLmRlcHRoWzFdXTtcbiAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgR2VvbWV0cnlUeXBlLlBPTFlHT046XG4gICAgICAgICAgY29tcG9uZW50ID0gY29tcG9uZW50W3NlZ21lbnREYXRhLmRlcHRoWzBdXTtcbiAgICAgICAgICBpZiAoY29tcG9uZW50Lmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSBjb21wb25lbnQubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21wb25lbnQuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIGRlbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgIC8vIGNsb3NlIHRoZSByaW5nIGFnYWluXG4gICAgICAgICAgICAgIGNvbXBvbmVudC5wb3AoKTtcbiAgICAgICAgICAgICAgY29tcG9uZW50LnB1c2goY29tcG9uZW50WzBdKTtcbiAgICAgICAgICAgICAgbmV3SW5kZXggPSBjb21wb25lbnQubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gcGFzc1xuICAgICAgfVxuXG4gICAgICBpZiAoZGVsZXRlZCkge1xuICAgICAgICB0aGlzLnNldEdlb21ldHJ5Q29vcmRpbmF0ZXNfKGdlb21ldHJ5LCBjb29yZGluYXRlcyk7XG4gICAgICAgIHZhciBzZWdtZW50cyA9IFtdO1xuICAgICAgICBpZiAobGVmdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5yQnVzaF8ucmVtb3ZlKGxlZnQpO1xuICAgICAgICAgIHNlZ21lbnRzLnB1c2gobGVmdC5zZWdtZW50WzBdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuckJ1c2hfLnJlbW92ZShyaWdodCk7XG4gICAgICAgICAgc2VnbWVudHMucHVzaChyaWdodC5zZWdtZW50WzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVmdCAhPT0gdW5kZWZpbmVkICYmIHJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgbmV3U2VnbWVudERhdGEgPSAvKiogQHR5cGUge1NlZ21lbnREYXRhfSAqLyAoe1xuICAgICAgICAgICAgZGVwdGg6IHNlZ21lbnREYXRhLmRlcHRoLFxuICAgICAgICAgICAgZmVhdHVyZTogc2VnbWVudERhdGEuZmVhdHVyZSxcbiAgICAgICAgICAgIGdlb21ldHJ5OiBzZWdtZW50RGF0YS5nZW9tZXRyeSxcbiAgICAgICAgICAgIGluZGV4OiBuZXdJbmRleCxcbiAgICAgICAgICAgIHNlZ21lbnQ6IHNlZ21lbnRzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5yQnVzaF8uaW5zZXJ0KGJvdW5kaW5nRXh0ZW50KG5ld1NlZ21lbnREYXRhLnNlZ21lbnQpLFxuICAgICAgICAgICAgbmV3U2VnbWVudERhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlU2VnbWVudEluZGljZXNfKGdlb21ldHJ5LCBpbmRleCwgc2VnbWVudERhdGEuZGVwdGgsIC0xKTtcbiAgICAgICAgaWYgKHRoaXMudmVydGV4RmVhdHVyZV8pIHtcbiAgICAgICAgICAvKiogQHR5cGUge1ZlY3RvclNvdXJjZX0gKi8gKHRoaXMub3ZlcmxheV8uZ2V0U291cmNlKCkpLnJlbW92ZUZlYXR1cmUodGhpcy52ZXJ0ZXhGZWF0dXJlXyk7XG4gICAgICAgICAgdGhpcy52ZXJ0ZXhGZWF0dXJlXyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZHJhZ1NlZ21lbnRzLmxlbmd0aCA9IDA7XG4gICAgICB9XG5cbiAgICB9XG4gICAgcmV0dXJuIGRlbGV0ZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICogQHBhcmFtIHtBcnJheX0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBNb2RpZnkucHJvdG90eXBlLnNldEdlb21ldHJ5Q29vcmRpbmF0ZXNfID0gZnVuY3Rpb24gc2V0R2VvbWV0cnlDb29yZGluYXRlc18gKGdlb21ldHJ5LCBjb29yZGluYXRlcykge1xuICAgIHRoaXMuY2hhbmdpbmdGZWF0dXJlXyA9IHRydWU7XG4gICAgZ2VvbWV0cnkuc2V0Q29vcmRpbmF0ZXMoY29vcmRpbmF0ZXMpO1xuICAgIHRoaXMuY2hhbmdpbmdGZWF0dXJlXyA9IGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vU2ltcGxlR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleC5cbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fHVuZGVmaW5lZH0gZGVwdGggRGVwdGguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YSBEZWx0YSAoMSBvciAtMSkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBNb2RpZnkucHJvdG90eXBlLnVwZGF0ZVNlZ21lbnRJbmRpY2VzXyA9IGZ1bmN0aW9uIHVwZGF0ZVNlZ21lbnRJbmRpY2VzXyAoZ2VvbWV0cnksIGluZGV4LCBkZXB0aCwgZGVsdGEpIHtcbiAgICB0aGlzLnJCdXNoXy5mb3JFYWNoSW5FeHRlbnQoZ2VvbWV0cnkuZ2V0RXh0ZW50KCksIGZ1bmN0aW9uKHNlZ21lbnREYXRhTWF0Y2gpIHtcbiAgICAgIGlmIChzZWdtZW50RGF0YU1hdGNoLmdlb21ldHJ5ID09PSBnZW9tZXRyeSAmJlxuICAgICAgICAgIChkZXB0aCA9PT0gdW5kZWZpbmVkIHx8IHNlZ21lbnREYXRhTWF0Y2guZGVwdGggPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgIGVxdWFscyhzZWdtZW50RGF0YU1hdGNoLmRlcHRoLCBkZXB0aCkpICYmXG4gICAgICAgICAgc2VnbWVudERhdGFNYXRjaC5pbmRleCA+IGluZGV4KSB7XG4gICAgICAgIHNlZ21lbnREYXRhTWF0Y2guaW5kZXggKz0gZGVsdGE7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIE1vZGlmeTtcbn0oUG9pbnRlckludGVyYWN0aW9uKSk7XG5cblxuLyoqXG4gKiBAcGFyYW0ge1NlZ21lbnREYXRhfSBhIFRoZSBmaXJzdCBzZWdtZW50IGRhdGEuXG4gKiBAcGFyYW0ge1NlZ21lbnREYXRhfSBiIFRoZSBzZWNvbmQgc2VnbWVudCBkYXRhLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgZGlmZmVyZW5jZSBpbiBpbmRleGVzLlxuICovXG5mdW5jdGlvbiBjb21wYXJlSW5kZXhlcyhhLCBiKSB7XG4gIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcbn1cblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGRpc3RhbmNlIGZyb20gYSBwb2ludCB0byBhIGxpbmUgc2VnbWVudC5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gcG9pbnRDb29yZGluYXRlcyBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50IGZyb21cbiAqICAgICAgICB3aGljaCB0byBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlLlxuICogQHBhcmFtIHtTZWdtZW50RGF0YX0gc2VnbWVudERhdGEgVGhlIG9iamVjdCBkZXNjcmliaW5nIHRoZSBsaW5lXG4gKiAgICAgICAgc2VnbWVudCB3ZSBhcmUgY2FsY3VsYXRpbmcgdGhlIGRpc3RhbmNlIHRvLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgc3F1YXJlIG9mIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGEgcG9pbnQgYW5kIGEgbGluZSBzZWdtZW50LlxuICovXG5mdW5jdGlvbiBwb2ludERpc3RhbmNlVG9TZWdtZW50RGF0YVNxdWFyZWQocG9pbnRDb29yZGluYXRlcywgc2VnbWVudERhdGEpIHtcbiAgdmFyIGdlb21ldHJ5ID0gc2VnbWVudERhdGEuZ2VvbWV0cnk7XG5cbiAgaWYgKGdlb21ldHJ5LmdldFR5cGUoKSA9PT0gR2VvbWV0cnlUeXBlLkNJUkNMRSkge1xuICAgIHZhciBjaXJjbGVHZW9tZXRyeSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vZ2VvbS9DaXJjbGUuanNcIikuZGVmYXVsdH0gKi8gKGdlb21ldHJ5KTtcblxuICAgIGlmIChzZWdtZW50RGF0YS5pbmRleCA9PT0gQ0lSQ0xFX0NJUkNVTUZFUkVOQ0VfSU5ERVgpIHtcbiAgICAgIHZhciBkaXN0YW5jZVRvQ2VudGVyU3F1YXJlZCA9XG4gICAgICAgICAgICBzcXVhcmVkQ29vcmRpbmF0ZURpc3RhbmNlKGNpcmNsZUdlb21ldHJ5LmdldENlbnRlcigpLCBwb2ludENvb3JkaW5hdGVzKTtcbiAgICAgIHZhciBkaXN0YW5jZVRvQ2lyY3VtZmVyZW5jZSA9XG4gICAgICAgICAgICBNYXRoLnNxcnQoZGlzdGFuY2VUb0NlbnRlclNxdWFyZWQpIC0gY2lyY2xlR2VvbWV0cnkuZ2V0UmFkaXVzKCk7XG4gICAgICByZXR1cm4gZGlzdGFuY2VUb0NpcmN1bWZlcmVuY2UgKiBkaXN0YW5jZVRvQ2lyY3VtZmVyZW5jZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNxdWFyZWREaXN0YW5jZVRvU2VnbWVudChwb2ludENvb3JkaW5hdGVzLCBzZWdtZW50RGF0YS5zZWdtZW50KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwb2ludCBjbG9zZXN0IHRvIGEgZ2l2ZW4gbGluZSBzZWdtZW50LlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBwb2ludENvb3JkaW5hdGVzIFRoZSBwb2ludCB0byB3aGljaCBhIGNsb3Nlc3QgcG9pbnRcbiAqICAgICAgICBzaG91bGQgYmUgZm91bmQuXG4gKiBAcGFyYW0ge1NlZ21lbnREYXRhfSBzZWdtZW50RGF0YSBUaGUgb2JqZWN0IGRlc2NyaWJpbmcgdGhlIGxpbmVcbiAqICAgICAgICBzZWdtZW50IHdoaWNoIHNob3VsZCBjb250YWluIHRoZSBjbG9zZXN0IHBvaW50LlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBUaGUgcG9pbnQgY2xvc2VzdCB0byB0aGUgc3BlY2lmaWVkIGxpbmUgc2VnbWVudC5cbiAqL1xuZnVuY3Rpb24gY2xvc2VzdE9uU2VnbWVudERhdGEocG9pbnRDb29yZGluYXRlcywgc2VnbWVudERhdGEpIHtcbiAgdmFyIGdlb21ldHJ5ID0gc2VnbWVudERhdGEuZ2VvbWV0cnk7XG5cbiAgaWYgKGdlb21ldHJ5LmdldFR5cGUoKSA9PT0gR2VvbWV0cnlUeXBlLkNJUkNMRSAmJlxuICBzZWdtZW50RGF0YS5pbmRleCA9PT0gQ0lSQ0xFX0NJUkNVTUZFUkVOQ0VfSU5ERVgpIHtcbiAgICByZXR1cm4gZ2VvbWV0cnkuZ2V0Q2xvc2VzdFBvaW50KHBvaW50Q29vcmRpbmF0ZXMpO1xuICB9XG4gIHJldHVybiBjbG9zZXN0T25TZWdtZW50KHBvaW50Q29vcmRpbmF0ZXMsIHNlZ21lbnREYXRhLnNlZ21lbnQpO1xufVxuXG5cbi8qKlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVGdW5jdGlvbn0gU3R5bGVzLlxuICovXG5mdW5jdGlvbiBnZXREZWZhdWx0U3R5bGVGdW5jdGlvbigpIHtcbiAgdmFyIHN0eWxlID0gY3JlYXRlRWRpdGluZ1N0eWxlKCk7XG4gIHJldHVybiBmdW5jdGlvbihmZWF0dXJlLCByZXNvbHV0aW9uKSB7XG4gICAgcmV0dXJuIHN0eWxlW0dlb21ldHJ5VHlwZS5QT0lOVF07XG4gIH07XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgTW9kaWZ5O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Nb2RpZnkuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL01vdXNlV2hlZWxab29tXG4gKi9cbmltcG9ydCBWaWV3SGludCBmcm9tICcuLi9WaWV3SGludC5qcyc7XG5pbXBvcnQge2Fsd2F5c30gZnJvbSAnLi4vZXZlbnRzL2NvbmRpdGlvbi5qcyc7XG5pbXBvcnQge2Vhc2VPdXR9IGZyb20gJy4uL2Vhc2luZy5qcyc7XG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4uL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IHtERVZJQ0VfUElYRUxfUkFUSU8sIEZJUkVGT1gsIFNBRkFSSX0gZnJvbSAnLi4vaGFzLmpzJztcbmltcG9ydCBJbnRlcmFjdGlvbiwge3pvb21CeURlbHRhfSBmcm9tICcuL0ludGVyYWN0aW9uLmpzJztcbmltcG9ydCB7Y2xhbXB9IGZyb20gJy4uL21hdGguanMnO1xuXG5cbi8qKlxuICogTWF4aW11bSBtb3VzZSB3aGVlbCBkZWx0YS5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbnZhciBNQVhfREVMVEEgPSAxO1xuXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IHZhciBNb2RlID0ge1xuICBUUkFDS1BBRDogJ3RyYWNrcGFkJyxcbiAgV0hFRUw6ICd3aGVlbCdcbn07XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufSBbY29uZGl0aW9uXSBBIGZ1bmN0aW9uIHRoYXRcbiAqIHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0gYW5kIHJldHVybnMgYVxuICogYm9vbGVhbiB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoYXQgZXZlbnQgc2hvdWxkIGJlIGhhbmRsZWQuIERlZmF1bHQgaXNcbiAqIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbn5hbHdheXN9LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkdXJhdGlvbj0yNTBdIEFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RpbWVvdXQ9ODBdIE1vdXNlIHdoZWVsIHRpbWVvdXQgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbY29uc3RyYWluUmVzb2x1dGlvbj1mYWxzZV0gV2hlbiB1c2luZyBhIHRyYWNrcGFkIG9yXG4gKiBtYWdpYyBtb3VzZSwgem9vbSB0byB0aGUgY2xvc2VzdCBpbnRlZ2VyIHpvb20gbGV2ZWwgYWZ0ZXIgdGhlIHNjcm9sbCBnZXN0dXJlXG4gKiBlbmRzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbdXNlQW5jaG9yPXRydWVdIEVuYWJsZSB6b29taW5nIHVzaW5nIHRoZSBtb3VzZSdzXG4gKiBsb2NhdGlvbiBhcyB0aGUgYW5jaG9yLiBXaGVuIHNldCB0byBgZmFsc2VgLCB6b29taW5nIGluIGFuZCBvdXQgd2lsbCB6b29tIHRvXG4gKiB0aGUgY2VudGVyIG9mIHRoZSBzY3JlZW4gaW5zdGVhZCBvZiB6b29taW5nIG9uIHRoZSBtb3VzZSdzIGxvY2F0aW9uLlxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBbGxvd3MgdGhlIHVzZXIgdG8gem9vbSB0aGUgbWFwIGJ5IHNjcm9sbGluZyB0aGUgbW91c2Ugd2hlZWwuXG4gKiBAYXBpXG4gKi9cbnZhciBNb3VzZVdoZWVsWm9vbSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEludGVyYWN0aW9uKSB7XG4gIGZ1bmN0aW9uIE1vdXNlV2hlZWxab29tKG9wdF9vcHRpb25zKSB7XG5cbiAgICB2YXIgb3B0aW9ucyA9IG9wdF9vcHRpb25zID8gb3B0X29wdGlvbnMgOiB7fTtcblxuICAgIEludGVyYWN0aW9uLmNhbGwoLyoqIEB0eXBlIHtpbXBvcnQoXCIuL0ludGVyYWN0aW9uLmpzXCIpLkludGVyYWN0aW9uT3B0aW9uc30gKi8gdGhpcywgKG9wdGlvbnMpKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmRlbHRhXyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kdXJhdGlvbl8gPSBvcHRpb25zLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmR1cmF0aW9uIDogMjUwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudGltZW91dF8gPSBvcHRpb25zLnRpbWVvdXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudGltZW91dCA6IDgwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnVzZUFuY2hvcl8gPSBvcHRpb25zLnVzZUFuY2hvciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy51c2VBbmNob3IgOiB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnN0cmFpblJlc29sdXRpb25fID0gb3B0aW9ucy5jb25zdHJhaW5SZXNvbHV0aW9uIHx8IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259XG4gICAgICovXG4gICAgdGhpcy5jb25kaXRpb25fID0gb3B0aW9ucy5jb25kaXRpb24gPyBvcHRpb25zLmNvbmRpdGlvbiA6IGFsd2F5cztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9XG4gICAgICovXG4gICAgdGhpcy5sYXN0QW5jaG9yXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuc3RhcnRUaW1lXyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgdGhpcy50aW1lb3V0SWRfO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7TW9kZXx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5tb2RlXyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIFRyYWNrcGFkIGV2ZW50cyBzZXBhcmF0ZWQgYnkgdGhpcyBkZWxheSB3aWxsIGJlIGNvbnNpZGVyZWQgc2VwYXJhdGVcbiAgICAgKiBpbnRlcmFjdGlvbnMuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRyYWNrcGFkRXZlbnRHYXBfID0gNDAwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgdGhpcy50cmFja3BhZFRpbWVvdXRJZF87XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGRlbHRhIHZhbHVlcyBwZXIgem9vbSBsZXZlbFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRyYWNrcGFkRGVsdGFQZXJab29tXyA9IDMwMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSB6b29tIGZhY3RvciBieSB3aGljaCBzY3JvbGwgem9vbWluZyBpcyBhbGxvd2VkIHRvIGV4Y2VlZCB0aGUgbGltaXRzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRyYWNrcGFkWm9vbUJ1ZmZlcl8gPSAxLjU7XG5cbiAgfVxuXG4gIGlmICggSW50ZXJhY3Rpb24gKSBNb3VzZVdoZWVsWm9vbS5fX3Byb3RvX18gPSBJbnRlcmFjdGlvbjtcbiAgTW91c2VXaGVlbFpvb20ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSW50ZXJhY3Rpb24gJiYgSW50ZXJhY3Rpb24ucHJvdG90eXBlICk7XG4gIE1vdXNlV2hlZWxab29tLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1vdXNlV2hlZWxab29tO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTW91c2VXaGVlbFpvb20ucHJvdG90eXBlLmRlY3JlbWVudEludGVyYWN0aW5nSGludF8gPSBmdW5jdGlvbiBkZWNyZW1lbnRJbnRlcmFjdGluZ0hpbnRfICgpIHtcbiAgICB0aGlzLnRyYWNrcGFkVGltZW91dElkXyA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdmlldyA9IHRoaXMuZ2V0TWFwKCkuZ2V0VmlldygpO1xuICAgIHZpZXcuc2V0SGludChWaWV3SGludC5JTlRFUkFDVElORywgLTEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudCBtYXAgYnJvd3NlciBldmVudH0gKGlmIGl0IHdhcyBhIG1vdXNld2hlZWwtZXZlbnQpIGFuZCBldmVudHVhbGx5XG4gICAqIHpvb21zIHRoZSBtYXAuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgTW91c2VXaGVlbFpvb20ucHJvdG90eXBlLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24gaGFuZGxlRXZlbnQgKG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGlmICghdGhpcy5jb25kaXRpb25fKG1hcEJyb3dzZXJFdmVudCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgdHlwZSA9IG1hcEJyb3dzZXJFdmVudC50eXBlO1xuICAgIGlmICh0eXBlICE9PSBFdmVudFR5cGUuV0hFRUwgJiYgdHlwZSAhPT0gRXZlbnRUeXBlLk1PVVNFV0hFRUwpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIG1hcEJyb3dzZXJFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgdmFyIG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgdmFyIHdoZWVsRXZlbnQgPSAvKiogQHR5cGUge1doZWVsRXZlbnR9ICovIChtYXBCcm93c2VyRXZlbnQub3JpZ2luYWxFdmVudCk7XG5cbiAgICBpZiAodGhpcy51c2VBbmNob3JfKSB7XG4gICAgICB0aGlzLmxhc3RBbmNob3JfID0gbWFwQnJvd3NlckV2ZW50LmNvb3JkaW5hdGU7XG4gICAgfVxuXG4gICAgLy8gRGVsdGEgbm9ybWFsaXNhdGlvbiBpbnNwaXJlZCBieVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvbWFwYm94LWdsLWpzL2Jsb2IvMDAxYzdiOS9qcy91aS9oYW5kbGVyL3Njcm9sbF96b29tLmpzXG4gICAgdmFyIGRlbHRhO1xuICAgIGlmIChtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBFdmVudFR5cGUuV0hFRUwpIHtcbiAgICAgIGRlbHRhID0gd2hlZWxFdmVudC5kZWx0YVk7XG4gICAgICBpZiAoRklSRUZPWCAmJlxuICAgICAgICAgIHdoZWVsRXZlbnQuZGVsdGFNb2RlID09PSBXaGVlbEV2ZW50LkRPTV9ERUxUQV9QSVhFTCkge1xuICAgICAgICBkZWx0YSAvPSBERVZJQ0VfUElYRUxfUkFUSU87XG4gICAgICB9XG4gICAgICBpZiAod2hlZWxFdmVudC5kZWx0YU1vZGUgPT09IFdoZWVsRXZlbnQuRE9NX0RFTFRBX0xJTkUpIHtcbiAgICAgICAgZGVsdGEgKj0gNDA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBFdmVudFR5cGUuTU9VU0VXSEVFTCkge1xuICAgICAgZGVsdGEgPSAtd2hlZWxFdmVudC53aGVlbERlbHRhWTtcbiAgICAgIGlmIChTQUZBUkkpIHtcbiAgICAgICAgZGVsdGEgLz0gMztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGVsdGEgPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgIGlmICh0aGlzLnN0YXJ0VGltZV8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zdGFydFRpbWVfID0gbm93O1xuICAgIH1cblxuICAgIGlmICghdGhpcy5tb2RlXyB8fCBub3cgLSB0aGlzLnN0YXJ0VGltZV8gPiB0aGlzLnRyYWNrcGFkRXZlbnRHYXBfKSB7XG4gICAgICB0aGlzLm1vZGVfID0gTWF0aC5hYnMoZGVsdGEpIDwgNCA/XG4gICAgICAgIE1vZGUuVFJBQ0tQQUQgOlxuICAgICAgICBNb2RlLldIRUVMO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1vZGVfID09PSBNb2RlLlRSQUNLUEFEKSB7XG4gICAgICB2YXIgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgICBpZiAodGhpcy50cmFja3BhZFRpbWVvdXRJZF8pIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudHJhY2twYWRUaW1lb3V0SWRfKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZpZXcuc2V0SGludChWaWV3SGludC5JTlRFUkFDVElORywgMSk7XG4gICAgICB9XG4gICAgICB0aGlzLnRyYWNrcGFkVGltZW91dElkXyA9IHNldFRpbWVvdXQodGhpcy5kZWNyZW1lbnRJbnRlcmFjdGluZ0hpbnRfLmJpbmQodGhpcyksIHRoaXMudHJhY2twYWRFdmVudEdhcF8pO1xuICAgICAgdmFyIHJlc29sdXRpb24gPSB2aWV3LmdldFJlc29sdXRpb24oKSAqIE1hdGgucG93KDIsIGRlbHRhIC8gdGhpcy50cmFja3BhZERlbHRhUGVyWm9vbV8pO1xuICAgICAgdmFyIG1pblJlc29sdXRpb24gPSB2aWV3LmdldE1pblJlc29sdXRpb24oKTtcbiAgICAgIHZhciBtYXhSZXNvbHV0aW9uID0gdmlldy5nZXRNYXhSZXNvbHV0aW9uKCk7XG4gICAgICB2YXIgcmVib3VuZCA9IDA7XG4gICAgICBpZiAocmVzb2x1dGlvbiA8IG1pblJlc29sdXRpb24pIHtcbiAgICAgICAgcmVzb2x1dGlvbiA9IE1hdGgubWF4KHJlc29sdXRpb24sIG1pblJlc29sdXRpb24gLyB0aGlzLnRyYWNrcGFkWm9vbUJ1ZmZlcl8pO1xuICAgICAgICByZWJvdW5kID0gMTtcbiAgICAgIH0gZWxzZSBpZiAocmVzb2x1dGlvbiA+IG1heFJlc29sdXRpb24pIHtcbiAgICAgICAgcmVzb2x1dGlvbiA9IE1hdGgubWluKHJlc29sdXRpb24sIG1heFJlc29sdXRpb24gKiB0aGlzLnRyYWNrcGFkWm9vbUJ1ZmZlcl8pO1xuICAgICAgICByZWJvdW5kID0gLTE7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5sYXN0QW5jaG9yXykge1xuICAgICAgICB2YXIgY2VudGVyID0gdmlldy5jYWxjdWxhdGVDZW50ZXJab29tKHJlc29sdXRpb24sIHRoaXMubGFzdEFuY2hvcl8pO1xuICAgICAgICB2aWV3LnNldENlbnRlcih2aWV3LmNvbnN0cmFpbkNlbnRlcihjZW50ZXIpKTtcbiAgICAgIH1cbiAgICAgIHZpZXcuc2V0UmVzb2x1dGlvbihyZXNvbHV0aW9uKTtcblxuICAgICAgaWYgKHJlYm91bmQgPT09IDAgJiYgdGhpcy5jb25zdHJhaW5SZXNvbHV0aW9uXykge1xuICAgICAgICB2aWV3LmFuaW1hdGUoe1xuICAgICAgICAgIHJlc29sdXRpb246IHZpZXcuY29uc3RyYWluUmVzb2x1dGlvbihyZXNvbHV0aW9uLCBkZWx0YSA+IDAgPyAtMSA6IDEpLFxuICAgICAgICAgIGVhc2luZzogZWFzZU91dCxcbiAgICAgICAgICBhbmNob3I6IHRoaXMubGFzdEFuY2hvcl8sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb25fXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVib3VuZCA+IDApIHtcbiAgICAgICAgdmlldy5hbmltYXRlKHtcbiAgICAgICAgICByZXNvbHV0aW9uOiBtaW5SZXNvbHV0aW9uLFxuICAgICAgICAgIGVhc2luZzogZWFzZU91dCxcbiAgICAgICAgICBhbmNob3I6IHRoaXMubGFzdEFuY2hvcl8sXG4gICAgICAgICAgZHVyYXRpb246IDUwMFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAocmVib3VuZCA8IDApIHtcbiAgICAgICAgdmlldy5hbmltYXRlKHtcbiAgICAgICAgICByZXNvbHV0aW9uOiBtYXhSZXNvbHV0aW9uLFxuICAgICAgICAgIGVhc2luZzogZWFzZU91dCxcbiAgICAgICAgICBhbmNob3I6IHRoaXMubGFzdEFuY2hvcl8sXG4gICAgICAgICAgZHVyYXRpb246IDUwMFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhcnRUaW1lXyA9IG5vdztcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmRlbHRhXyArPSBkZWx0YTtcblxuICAgIHZhciB0aW1lTGVmdCA9IE1hdGgubWF4KHRoaXMudGltZW91dF8gLSAobm93IC0gdGhpcy5zdGFydFRpbWVfKSwgMCk7XG5cbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SWRfKTtcbiAgICB0aGlzLnRpbWVvdXRJZF8gPSBzZXRUaW1lb3V0KHRoaXMuaGFuZGxlV2hlZWxab29tXy5iaW5kKHRoaXMsIG1hcCksIHRpbWVMZWZ0KTtcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuZGVmYXVsdH0gbWFwIE1hcC5cbiAgICovXG4gIE1vdXNlV2hlZWxab29tLnByb3RvdHlwZS5oYW5kbGVXaGVlbFpvb21fID0gZnVuY3Rpb24gaGFuZGxlV2hlZWxab29tXyAobWFwKSB7XG4gICAgdmFyIHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgIGlmICh2aWV3LmdldEFuaW1hdGluZygpKSB7XG4gICAgICB2aWV3LmNhbmNlbEFuaW1hdGlvbnMoKTtcbiAgICB9XG4gICAgdmFyIG1heERlbHRhID0gTUFYX0RFTFRBO1xuICAgIHZhciBkZWx0YSA9IGNsYW1wKHRoaXMuZGVsdGFfLCAtbWF4RGVsdGEsIG1heERlbHRhKTtcbiAgICB6b29tQnlEZWx0YSh2aWV3LCAtZGVsdGEsIHRoaXMubGFzdEFuY2hvcl8sIHRoaXMuZHVyYXRpb25fKTtcbiAgICB0aGlzLm1vZGVfID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZGVsdGFfID0gMDtcbiAgICB0aGlzLmxhc3RBbmNob3JfID0gbnVsbDtcbiAgICB0aGlzLnN0YXJ0VGltZV8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50aW1lb3V0SWRfID0gdW5kZWZpbmVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbmFibGUgb3IgZGlzYWJsZSB1c2luZyB0aGUgbW91c2UncyBsb2NhdGlvbiBhcyBhbiBhbmNob3Igd2hlbiB6b29taW5nXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlQW5jaG9yIHRydWUgdG8gem9vbSB0byB0aGUgbW91c2UncyBsb2NhdGlvbiwgZmFsc2VcbiAgICogdG8gem9vbSB0byB0aGUgY2VudGVyIG9mIHRoZSBtYXBcbiAgICogQGFwaVxuICAgKi9cbiAgTW91c2VXaGVlbFpvb20ucHJvdG90eXBlLnNldE1vdXNlQW5jaG9yID0gZnVuY3Rpb24gc2V0TW91c2VBbmNob3IgKHVzZUFuY2hvcikge1xuICAgIHRoaXMudXNlQW5jaG9yXyA9IHVzZUFuY2hvcjtcbiAgICBpZiAoIXVzZUFuY2hvcikge1xuICAgICAgdGhpcy5sYXN0QW5jaG9yXyA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBNb3VzZVdoZWVsWm9vbTtcbn0oSW50ZXJhY3Rpb24pKTtcblxuZXhwb3J0IGRlZmF1bHQgTW91c2VXaGVlbFpvb207XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1vdXNlV2hlZWxab29tLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9QaW5jaFJvdGF0ZVxuICovXG5pbXBvcnQgVmlld0hpbnQgZnJvbSAnLi4vVmlld0hpbnQuanMnO1xuaW1wb3J0IHtGQUxTRX0gZnJvbSAnLi4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCB7cm90YXRlLCByb3RhdGVXaXRob3V0Q29uc3RyYWludHN9IGZyb20gJy4vSW50ZXJhY3Rpb24uanMnO1xuaW1wb3J0IFBvaW50ZXJJbnRlcmFjdGlvbiwge2NlbnRyb2lkIGFzIGNlbnRyb2lkRnJvbVBvaW50ZXJzfSBmcm9tICcuL1BvaW50ZXIuanMnO1xuaW1wb3J0IHtkaXNhYmxlfSBmcm9tICcuLi9yb3RhdGlvbmNvbnN0cmFpbnQuanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkdXJhdGlvbj0yNTBdIFRoZSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uIGluXG4gKiBtaWxsaXNlY29uZHMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RocmVzaG9sZD0wLjNdIE1pbmltYWwgYW5nbGUgaW4gcmFkaWFucyB0byBzdGFydCBhIHJvdGF0aW9uLlxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBbGxvd3MgdGhlIHVzZXIgdG8gcm90YXRlIHRoZSBtYXAgYnkgdHdpc3Rpbmcgd2l0aCB0d28gZmluZ2Vyc1xuICogb24gYSB0b3VjaCBzY3JlZW4uXG4gKiBAYXBpXG4gKi9cbnZhciBQaW5jaFJvdGF0ZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFBvaW50ZXJJbnRlcmFjdGlvbikge1xuICBmdW5jdGlvbiBQaW5jaFJvdGF0ZShvcHRfb3B0aW9ucykge1xuXG4gICAgdmFyIG9wdGlvbnMgPSBvcHRfb3B0aW9ucyA/IG9wdF9vcHRpb25zIDoge307XG5cbiAgICB2YXIgcG9pbnRlck9wdGlvbnMgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vUG9pbnRlci5qc1wiKS5PcHRpb25zfSAqLyAob3B0aW9ucyk7XG5cbiAgICBpZiAoIXBvaW50ZXJPcHRpb25zLnN0b3BEb3duKSB7XG4gICAgICBwb2ludGVyT3B0aW9ucy5zdG9wRG93biA9IEZBTFNFO1xuICAgIH1cblxuICAgIFBvaW50ZXJJbnRlcmFjdGlvbi5jYWxsKHRoaXMsIHBvaW50ZXJPcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLmFuY2hvcl8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmxhc3RBbmdsZV8gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucm90YXRpbmdfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yb3RhdGlvbkRlbHRhXyA9IDAuMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRocmVzaG9sZF8gPSBvcHRpb25zLnRocmVzaG9sZCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy50aHJlc2hvbGQgOiAwLjM7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kdXJhdGlvbl8gPSBvcHRpb25zLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmR1cmF0aW9uIDogMjUwO1xuXG4gIH1cblxuICBpZiAoIFBvaW50ZXJJbnRlcmFjdGlvbiApIFBpbmNoUm90YXRlLl9fcHJvdG9fXyA9IFBvaW50ZXJJbnRlcmFjdGlvbjtcbiAgUGluY2hSb3RhdGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUG9pbnRlckludGVyYWN0aW9uICYmIFBvaW50ZXJJbnRlcmFjdGlvbi5wcm90b3R5cGUgKTtcbiAgUGluY2hSb3RhdGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGluY2hSb3RhdGU7XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBQaW5jaFJvdGF0ZS5wcm90b3R5cGUuaGFuZGxlRHJhZ0V2ZW50ID0gZnVuY3Rpb24gaGFuZGxlRHJhZ0V2ZW50IChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICB2YXIgcm90YXRpb25EZWx0YSA9IDAuMDtcblxuICAgIHZhciB0b3VjaDAgPSB0aGlzLnRhcmdldFBvaW50ZXJzWzBdO1xuICAgIHZhciB0b3VjaDEgPSB0aGlzLnRhcmdldFBvaW50ZXJzWzFdO1xuXG4gICAgLy8gYW5nbGUgYmV0d2VlbiB0b3VjaGVzXG4gICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMihcbiAgICAgIHRvdWNoMS5jbGllbnRZIC0gdG91Y2gwLmNsaWVudFksXG4gICAgICB0b3VjaDEuY2xpZW50WCAtIHRvdWNoMC5jbGllbnRYKTtcblxuICAgIGlmICh0aGlzLmxhc3RBbmdsZV8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGRlbHRhID0gYW5nbGUgLSB0aGlzLmxhc3RBbmdsZV87XG4gICAgICB0aGlzLnJvdGF0aW9uRGVsdGFfICs9IGRlbHRhO1xuICAgICAgaWYgKCF0aGlzLnJvdGF0aW5nXyAmJlxuICAgICAgICAgIE1hdGguYWJzKHRoaXMucm90YXRpb25EZWx0YV8pID4gdGhpcy50aHJlc2hvbGRfKSB7XG4gICAgICAgIHRoaXMucm90YXRpbmdfID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJvdGF0aW9uRGVsdGEgPSBkZWx0YTtcbiAgICB9XG4gICAgdGhpcy5sYXN0QW5nbGVfID0gYW5nbGU7XG5cbiAgICB2YXIgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgICB2YXIgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgaWYgKHZpZXcuZ2V0Q29uc3RyYWludHMoKS5yb3RhdGlvbiA9PT0gZGlzYWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHJvdGF0ZSBhbmNob3IgcG9pbnQuXG4gICAgLy8gRklYTUU6IHNob3VsZCBiZSB0aGUgaW50ZXJzZWN0aW9uIHBvaW50IGJldHdlZW4gdGhlIGxpbmVzOlxuICAgIC8vICAgICB0b3VjaDAsdG91Y2gxIGFuZCBwcmV2aW91c1RvdWNoMCxwcmV2aW91c1RvdWNoMVxuICAgIHZhciB2aWV3cG9ydFBvc2l0aW9uID0gbWFwLmdldFZpZXdwb3J0KCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIGNlbnRyb2lkID0gY2VudHJvaWRGcm9tUG9pbnRlcnModGhpcy50YXJnZXRQb2ludGVycyk7XG4gICAgY2VudHJvaWRbMF0gLT0gdmlld3BvcnRQb3NpdGlvbi5sZWZ0O1xuICAgIGNlbnRyb2lkWzFdIC09IHZpZXdwb3J0UG9zaXRpb24udG9wO1xuICAgIHRoaXMuYW5jaG9yXyA9IG1hcC5nZXRDb29yZGluYXRlRnJvbVBpeGVsKGNlbnRyb2lkKTtcblxuICAgIC8vIHJvdGF0ZVxuICAgIGlmICh0aGlzLnJvdGF0aW5nXykge1xuICAgICAgdmFyIHJvdGF0aW9uID0gdmlldy5nZXRSb3RhdGlvbigpO1xuICAgICAgbWFwLnJlbmRlcigpO1xuICAgICAgcm90YXRlV2l0aG91dENvbnN0cmFpbnRzKHZpZXcsIHJvdGF0aW9uICsgcm90YXRpb25EZWx0YSwgdGhpcy5hbmNob3JfKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBQaW5jaFJvdGF0ZS5wcm90b3R5cGUuaGFuZGxlVXBFdmVudCA9IGZ1bmN0aW9uIGhhbmRsZVVwRXZlbnQgKG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGlmICh0aGlzLnRhcmdldFBvaW50ZXJzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHZhciBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuICAgICAgdmFyIHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgICAgdmlldy5zZXRIaW50KFZpZXdIaW50LklOVEVSQUNUSU5HLCAtMSk7XG4gICAgICBpZiAodGhpcy5yb3RhdGluZ18pIHtcbiAgICAgICAgdmFyIHJvdGF0aW9uID0gdmlldy5nZXRSb3RhdGlvbigpO1xuICAgICAgICByb3RhdGUodmlldywgcm90YXRpb24sIHRoaXMuYW5jaG9yXywgdGhpcy5kdXJhdGlvbl8pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBQaW5jaFJvdGF0ZS5wcm90b3R5cGUuaGFuZGxlRG93bkV2ZW50ID0gZnVuY3Rpb24gaGFuZGxlRG93bkV2ZW50IChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBpZiAodGhpcy50YXJnZXRQb2ludGVycy5sZW5ndGggPj0gMikge1xuICAgICAgdmFyIG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgICB0aGlzLmFuY2hvcl8gPSBudWxsO1xuICAgICAgdGhpcy5sYXN0QW5nbGVfID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5yb3RhdGluZ18gPSBmYWxzZTtcbiAgICAgIHRoaXMucm90YXRpb25EZWx0YV8gPSAwLjA7XG4gICAgICBpZiAoIXRoaXMuaGFuZGxpbmdEb3duVXBTZXF1ZW5jZSkge1xuICAgICAgICBtYXAuZ2V0VmlldygpLnNldEhpbnQoVmlld0hpbnQuSU5URVJBQ1RJTkcsIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFBpbmNoUm90YXRlO1xufShQb2ludGVySW50ZXJhY3Rpb24pKTtcblxuZXhwb3J0IGRlZmF1bHQgUGluY2hSb3RhdGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBpbmNoUm90YXRlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9QaW5jaFpvb21cbiAqL1xuaW1wb3J0IFZpZXdIaW50IGZyb20gJy4uL1ZpZXdIaW50LmpzJztcbmltcG9ydCB7RkFMU0V9IGZyb20gJy4uL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQge3pvb20sIHpvb21XaXRob3V0Q29uc3RyYWludHN9IGZyb20gJy4vSW50ZXJhY3Rpb24uanMnO1xuaW1wb3J0IFBvaW50ZXJJbnRlcmFjdGlvbiwge2NlbnRyb2lkIGFzIGNlbnRyb2lkRnJvbVBvaW50ZXJzfSBmcm9tICcuL1BvaW50ZXIuanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkdXJhdGlvbj00MDBdIEFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjb25zdHJhaW5SZXNvbHV0aW9uPWZhbHNlXSBab29tIHRvIHRoZSBjbG9zZXN0IGludGVnZXJcbiAqIHpvb20gbGV2ZWwgYWZ0ZXIgdGhlIHBpbmNoIGdlc3R1cmUgZW5kcy5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWxsb3dzIHRoZSB1c2VyIHRvIHpvb20gdGhlIG1hcCBieSBwaW5jaGluZyB3aXRoIHR3byBmaW5nZXJzXG4gKiBvbiBhIHRvdWNoIHNjcmVlbi5cbiAqIEBhcGlcbiAqL1xudmFyIFBpbmNoWm9vbSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFBvaW50ZXJJbnRlcmFjdGlvbikge1xuICBmdW5jdGlvbiBQaW5jaFpvb20ob3B0X29wdGlvbnMpIHtcblxuICAgIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgPyBvcHRfb3B0aW9ucyA6IHt9O1xuXG4gICAgdmFyIHBvaW50ZXJPcHRpb25zID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL1BvaW50ZXIuanNcIikuT3B0aW9uc30gKi8gKG9wdGlvbnMpO1xuXG4gICAgaWYgKCFwb2ludGVyT3B0aW9ucy5zdG9wRG93bikge1xuICAgICAgcG9pbnRlck9wdGlvbnMuc3RvcERvd24gPSBGQUxTRTtcbiAgICB9XG5cbiAgICBQb2ludGVySW50ZXJhY3Rpb24uY2FsbCh0aGlzLCBwb2ludGVyT3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuY29uc3RyYWluUmVzb2x1dGlvbl8gPSBvcHRpb25zLmNvbnN0cmFpblJlc29sdXRpb24gfHwgZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9XG4gICAgICovXG4gICAgdGhpcy5hbmNob3JfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmR1cmF0aW9uXyA9IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiA0MDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMubGFzdERpc3RhbmNlXyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxhc3RTY2FsZURlbHRhXyA9IDE7XG5cbiAgfVxuXG4gIGlmICggUG9pbnRlckludGVyYWN0aW9uICkgUGluY2hab29tLl9fcHJvdG9fXyA9IFBvaW50ZXJJbnRlcmFjdGlvbjtcbiAgUGluY2hab29tLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBvaW50ZXJJbnRlcmFjdGlvbiAmJiBQb2ludGVySW50ZXJhY3Rpb24ucHJvdG90eXBlICk7XG4gIFBpbmNoWm9vbS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQaW5jaFpvb207XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBQaW5jaFpvb20ucHJvdG90eXBlLmhhbmRsZURyYWdFdmVudCA9IGZ1bmN0aW9uIGhhbmRsZURyYWdFdmVudCAobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgdmFyIHNjYWxlRGVsdGEgPSAxLjA7XG5cbiAgICB2YXIgdG91Y2gwID0gdGhpcy50YXJnZXRQb2ludGVyc1swXTtcbiAgICB2YXIgdG91Y2gxID0gdGhpcy50YXJnZXRQb2ludGVyc1sxXTtcbiAgICB2YXIgZHggPSB0b3VjaDAuY2xpZW50WCAtIHRvdWNoMS5jbGllbnRYO1xuICAgIHZhciBkeSA9IHRvdWNoMC5jbGllbnRZIC0gdG91Y2gxLmNsaWVudFk7XG5cbiAgICAvLyBkaXN0YW5jZSBiZXR3ZWVuIHRvdWNoZXNcbiAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgaWYgKHRoaXMubGFzdERpc3RhbmNlXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzY2FsZURlbHRhID0gdGhpcy5sYXN0RGlzdGFuY2VfIC8gZGlzdGFuY2U7XG4gICAgfVxuICAgIHRoaXMubGFzdERpc3RhbmNlXyA9IGRpc3RhbmNlO1xuXG5cbiAgICB2YXIgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgICB2YXIgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgdmFyIHJlc29sdXRpb24gPSB2aWV3LmdldFJlc29sdXRpb24oKTtcbiAgICB2YXIgbWF4UmVzb2x1dGlvbiA9IHZpZXcuZ2V0TWF4UmVzb2x1dGlvbigpO1xuICAgIHZhciBtaW5SZXNvbHV0aW9uID0gdmlldy5nZXRNaW5SZXNvbHV0aW9uKCk7XG4gICAgdmFyIG5ld1Jlc29sdXRpb24gPSByZXNvbHV0aW9uICogc2NhbGVEZWx0YTtcbiAgICBpZiAobmV3UmVzb2x1dGlvbiA+IG1heFJlc29sdXRpb24pIHtcbiAgICAgIHNjYWxlRGVsdGEgPSBtYXhSZXNvbHV0aW9uIC8gcmVzb2x1dGlvbjtcbiAgICAgIG5ld1Jlc29sdXRpb24gPSBtYXhSZXNvbHV0aW9uO1xuICAgIH0gZWxzZSBpZiAobmV3UmVzb2x1dGlvbiA8IG1pblJlc29sdXRpb24pIHtcbiAgICAgIHNjYWxlRGVsdGEgPSBtaW5SZXNvbHV0aW9uIC8gcmVzb2x1dGlvbjtcbiAgICAgIG5ld1Jlc29sdXRpb24gPSBtaW5SZXNvbHV0aW9uO1xuICAgIH1cblxuICAgIGlmIChzY2FsZURlbHRhICE9IDEuMCkge1xuICAgICAgdGhpcy5sYXN0U2NhbGVEZWx0YV8gPSBzY2FsZURlbHRhO1xuICAgIH1cblxuICAgIC8vIHNjYWxlIGFuY2hvciBwb2ludC5cbiAgICB2YXIgdmlld3BvcnRQb3NpdGlvbiA9IG1hcC5nZXRWaWV3cG9ydCgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciBjZW50cm9pZCA9IGNlbnRyb2lkRnJvbVBvaW50ZXJzKHRoaXMudGFyZ2V0UG9pbnRlcnMpO1xuICAgIGNlbnRyb2lkWzBdIC09IHZpZXdwb3J0UG9zaXRpb24ubGVmdDtcbiAgICBjZW50cm9pZFsxXSAtPSB2aWV3cG9ydFBvc2l0aW9uLnRvcDtcbiAgICB0aGlzLmFuY2hvcl8gPSBtYXAuZ2V0Q29vcmRpbmF0ZUZyb21QaXhlbChjZW50cm9pZCk7XG5cbiAgICAvLyBzY2FsZSwgYnlwYXNzIHRoZSByZXNvbHV0aW9uIGNvbnN0cmFpbnRcbiAgICBtYXAucmVuZGVyKCk7XG4gICAgem9vbVdpdGhvdXRDb25zdHJhaW50cyh2aWV3LCBuZXdSZXNvbHV0aW9uLCB0aGlzLmFuY2hvcl8pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgUGluY2hab29tLnByb3RvdHlwZS5oYW5kbGVVcEV2ZW50ID0gZnVuY3Rpb24gaGFuZGxlVXBFdmVudCAobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKHRoaXMudGFyZ2V0UG9pbnRlcnMubGVuZ3RoIDwgMikge1xuICAgICAgdmFyIG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgICB2YXIgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgICB2aWV3LnNldEhpbnQoVmlld0hpbnQuSU5URVJBQ1RJTkcsIC0xKTtcbiAgICAgIHZhciByZXNvbHV0aW9uID0gdmlldy5nZXRSZXNvbHV0aW9uKCk7XG4gICAgICBpZiAodGhpcy5jb25zdHJhaW5SZXNvbHV0aW9uXyB8fFxuICAgICAgICAgIHJlc29sdXRpb24gPCB2aWV3LmdldE1pblJlc29sdXRpb24oKSB8fFxuICAgICAgICAgIHJlc29sdXRpb24gPiB2aWV3LmdldE1heFJlc29sdXRpb24oKSkge1xuICAgICAgICAvLyBab29tIHRvIGZpbmFsIHJlc29sdXRpb24sIHdpdGggYW4gYW5pbWF0aW9uLCBhbmQgcHJvdmlkZSBhXG4gICAgICAgIC8vIGRpcmVjdGlvbiBub3QgdG8gem9vbSBvdXQvaW4gaWYgdXNlciB3YXMgcGluY2hpbmcgaW4vb3V0LlxuICAgICAgICAvLyBEaXJlY3Rpb24gaXMgPiAwIGlmIHBpbmNoaW5nIG91dCwgYW5kIDwgMCBpZiBwaW5jaGluZyBpbi5cbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMubGFzdFNjYWxlRGVsdGFfIC0gMTtcbiAgICAgICAgem9vbSh2aWV3LCByZXNvbHV0aW9uLCB0aGlzLmFuY2hvcl8sIHRoaXMuZHVyYXRpb25fLCBkaXJlY3Rpb24pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBQaW5jaFpvb20ucHJvdG90eXBlLmhhbmRsZURvd25FdmVudCA9IGZ1bmN0aW9uIGhhbmRsZURvd25FdmVudCAobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKHRoaXMudGFyZ2V0UG9pbnRlcnMubGVuZ3RoID49IDIpIHtcbiAgICAgIHZhciBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuICAgICAgdGhpcy5hbmNob3JfID0gbnVsbDtcbiAgICAgIHRoaXMubGFzdERpc3RhbmNlXyA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMubGFzdFNjYWxlRGVsdGFfID0gMTtcbiAgICAgIGlmICghdGhpcy5oYW5kbGluZ0Rvd25VcFNlcXVlbmNlKSB7XG4gICAgICAgIG1hcC5nZXRWaWV3KCkuc2V0SGludChWaWV3SGludC5JTlRFUkFDVElORywgMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gUGluY2hab29tO1xufShQb2ludGVySW50ZXJhY3Rpb24pKTtcblxuZXhwb3J0IGRlZmF1bHQgUGluY2hab29tO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1QaW5jaFpvb20uanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL1BvaW50ZXJcbiAqL1xuaW1wb3J0IE1hcEJyb3dzZXJFdmVudFR5cGUgZnJvbSAnLi4vTWFwQnJvd3NlckV2ZW50VHlwZS5qcyc7XG5pbXBvcnQgSW50ZXJhY3Rpb24gZnJvbSAnLi9JbnRlcmFjdGlvbi5qcyc7XG5pbXBvcnQge2dldFZhbHVlc30gZnJvbSAnLi4vb2JqLmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vTWFwQnJvd3NlclBvaW50ZXJFdmVudC5qc1wiKS5kZWZhdWx0KTpib29sZWFufSBbaGFuZGxlRG93bkV2ZW50XVxuICogRnVuY3Rpb24gaGFuZGxpbmcgXCJkb3duXCIgZXZlbnRzLiBJZiB0aGUgZnVuY3Rpb24gcmV0dXJucyBgdHJ1ZWAgdGhlbiBhIGRyYWdcbiAqIHNlcXVlbmNlIGlzIHN0YXJ0ZWQuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGltcG9ydChcIi4uL01hcEJyb3dzZXJQb2ludGVyRXZlbnQuanNcIikuZGVmYXVsdCl9IFtoYW5kbGVEcmFnRXZlbnRdXG4gKiBGdW5jdGlvbiBoYW5kbGluZyBcImRyYWdcIiBldmVudHMuIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIFwibW92ZVwiIGV2ZW50c1xuICogZHVyaW5nIGEgZHJhZyBzZXF1ZW5jZS5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHQpOmJvb2xlYW59IFtoYW5kbGVFdmVudF1cbiAqIE1ldGhvZCBjYWxsZWQgYnkgdGhlIG1hcCB0byBub3RpZnkgdGhlIGludGVyYWN0aW9uIHRoYXQgYSBicm93c2VyIGV2ZW50IHdhc1xuICogZGlzcGF0Y2hlZCB0byB0aGUgbWFwLiBUaGUgZnVuY3Rpb24gbWF5IHJldHVybiBgZmFsc2VgIHRvIHByZXZlbnQgdGhlXG4gKiBwcm9wYWdhdGlvbiBvZiB0aGUgZXZlbnQgdG8gb3RoZXIgaW50ZXJhY3Rpb25zIGluIHRoZSBtYXAncyBpbnRlcmFjdGlvbnNcbiAqIGNoYWluLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbihpbXBvcnQoXCIuLi9NYXBCcm93c2VyUG9pbnRlckV2ZW50LmpzXCIpLmRlZmF1bHQpfSBbaGFuZGxlTW92ZUV2ZW50XVxuICogRnVuY3Rpb24gaGFuZGxpbmcgXCJtb3ZlXCIgZXZlbnRzLiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBcIm1vdmVcIiBldmVudHMsXG4gKiBhbHNvIGR1cmluZyBhIGRyYWcgc2VxdWVuY2UgKHNvIGR1cmluZyBhIGRyYWcgc2VxdWVuY2UgYm90aCB0aGVcbiAqIGBoYW5kbGVEcmFnRXZlbnRgIGZ1bmN0aW9uIGFuZCB0aGlzIGZ1bmN0aW9uIGFyZSBjYWxsZWQpLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbihpbXBvcnQoXCIuLi9NYXBCcm93c2VyUG9pbnRlckV2ZW50LmpzXCIpLmRlZmF1bHQpOmJvb2xlYW59IFtoYW5kbGVVcEV2ZW50XVxuICogIEZ1bmN0aW9uIGhhbmRsaW5nIFwidXBcIiBldmVudHMuIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIGBmYWxzZWAgdGhlbiB0aGVcbiAqIGN1cnJlbnQgZHJhZyBzZXF1ZW5jZSBpcyBzdG9wcGVkLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbihib29sZWFuKTpib29sZWFufSBbc3RvcERvd25dXG4gKiBTaG91bGQgdGhlIGRvd24gZXZlbnQgYmUgcHJvcGFnYXRlZCB0byBvdGhlciBpbnRlcmFjdGlvbnMsIG9yIHNob3VsZCBiZVxuICogc3RvcHBlZD9cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQmFzZSBjbGFzcyB0aGF0IGNhbGxzIHVzZXItZGVmaW5lZCBmdW5jdGlvbnMgb24gYGRvd25gLCBgbW92ZWAgYW5kIGB1cGBcbiAqIGV2ZW50cy4gVGhpcyBjbGFzcyBhbHNvIG1hbmFnZXMgXCJkcmFnIHNlcXVlbmNlc1wiLlxuICpcbiAqIFdoZW4gdGhlIGBoYW5kbGVEb3duRXZlbnRgIHVzZXIgZnVuY3Rpb24gcmV0dXJucyBgdHJ1ZWAgYSBkcmFnIHNlcXVlbmNlIGlzXG4gKiBzdGFydGVkLiBEdXJpbmcgYSBkcmFnIHNlcXVlbmNlIHRoZSBgaGFuZGxlRHJhZ0V2ZW50YCB1c2VyIGZ1bmN0aW9uIGlzXG4gKiBjYWxsZWQgb24gYG1vdmVgIGV2ZW50cy4gVGhlIGRyYWcgc2VxdWVuY2UgZW5kcyB3aGVuIHRoZSBgaGFuZGxlVXBFdmVudGBcbiAqIHVzZXIgZnVuY3Rpb24gaXMgY2FsbGVkIGFuZCByZXR1cm5zIGBmYWxzZWAuXG4gKiBAYXBpXG4gKi9cbnZhciBQb2ludGVySW50ZXJhY3Rpb24gPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChJbnRlcmFjdGlvbikge1xuICBmdW5jdGlvbiBQb2ludGVySW50ZXJhY3Rpb24ob3B0X29wdGlvbnMpIHtcblxuICAgIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgPyBvcHRfb3B0aW9ucyA6IHt9O1xuXG4gICAgSW50ZXJhY3Rpb24uY2FsbCgvKiogQHR5cGUge2ltcG9ydChcIi4vSW50ZXJhY3Rpb24uanNcIikuSW50ZXJhY3Rpb25PcHRpb25zfSAqLyB0aGlzLCAob3B0aW9ucykpO1xuXG4gICAgaWYgKG9wdGlvbnMuaGFuZGxlRG93bkV2ZW50KSB7XG4gICAgICB0aGlzLmhhbmRsZURvd25FdmVudCA9IG9wdGlvbnMuaGFuZGxlRG93bkV2ZW50O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmhhbmRsZURyYWdFdmVudCkge1xuICAgICAgdGhpcy5oYW5kbGVEcmFnRXZlbnQgPSBvcHRpb25zLmhhbmRsZURyYWdFdmVudDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5oYW5kbGVNb3ZlRXZlbnQpIHtcbiAgICAgIHRoaXMuaGFuZGxlTW92ZUV2ZW50ID0gb3B0aW9ucy5oYW5kbGVNb3ZlRXZlbnQ7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaGFuZGxlVXBFdmVudCkge1xuICAgICAgdGhpcy5oYW5kbGVVcEV2ZW50ID0gb3B0aW9ucy5oYW5kbGVVcEV2ZW50O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnN0b3BEb3duKSB7XG4gICAgICB0aGlzLnN0b3BEb3duID0gb3B0aW9ucy5zdG9wRG93bjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdGhpcy5oYW5kbGluZ0Rvd25VcFNlcXVlbmNlID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3BvaW50ZXIvUG9pbnRlckV2ZW50LmpzXCIpLmRlZmF1bHQ+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy50cmFja2VkUG9pbnRlcnNfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi4vcG9pbnRlci9Qb2ludGVyRXZlbnQuanNcIikuZGVmYXVsdD59XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRoaXMudGFyZ2V0UG9pbnRlcnMgPSBbXTtcblxuICB9XG5cbiAgaWYgKCBJbnRlcmFjdGlvbiApIFBvaW50ZXJJbnRlcmFjdGlvbi5fX3Byb3RvX18gPSBJbnRlcmFjdGlvbjtcbiAgUG9pbnRlckludGVyYWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEludGVyYWN0aW9uICYmIEludGVyYWN0aW9uLnByb3RvdHlwZSApO1xuICBQb2ludGVySW50ZXJhY3Rpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUG9pbnRlckludGVyYWN0aW9uO1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgcG9pbnRlciBkb3duIGV2ZW50cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyUG9pbnRlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIGV2ZW50IHdhcyBjb25zdW1lZC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgUG9pbnRlckludGVyYWN0aW9uLnByb3RvdHlwZS5oYW5kbGVEb3duRXZlbnQgPSBmdW5jdGlvbiBoYW5kbGVEb3duRXZlbnQgKG1hcEJyb3dzZXJFdmVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIHBvaW50ZXIgZHJhZyBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlclBvaW50ZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgRXZlbnQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIFBvaW50ZXJJbnRlcmFjdGlvbi5wcm90b3R5cGUuaGFuZGxlRHJhZ0V2ZW50ID0gZnVuY3Rpb24gaGFuZGxlRHJhZ0V2ZW50IChtYXBCcm93c2VyRXZlbnQpIHt9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudCBtYXAgYnJvd3NlciBldmVudH0gYW5kIG1heSBjYWxsIGludG9cbiAgICogb3RoZXIgZnVuY3Rpb25zLCBpZiBldmVudCBzZXF1ZW5jZXMgbGlrZSBlLmcuICdkcmFnJyBvciAnZG93bi11cCcgZXRjLiBhcmVcbiAgICogZGV0ZWN0ZWQuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBQb2ludGVySW50ZXJhY3Rpb24ucHJvdG90eXBlLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24gaGFuZGxlRXZlbnQgKG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGlmICghKC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlclBvaW50ZXJFdmVudC5qc1wiKS5kZWZhdWx0fSAqLyAobWFwQnJvd3NlckV2ZW50KS5wb2ludGVyRXZlbnQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgc3RvcEV2ZW50ID0gZmFsc2U7XG4gICAgdGhpcy51cGRhdGVUcmFja2VkUG9pbnRlcnNfKG1hcEJyb3dzZXJFdmVudCk7XG4gICAgaWYgKHRoaXMuaGFuZGxpbmdEb3duVXBTZXF1ZW5jZSkge1xuICAgICAgaWYgKG1hcEJyb3dzZXJFdmVudC50eXBlID09IE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUkRSQUcpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVEcmFnRXZlbnQobWFwQnJvd3NlckV2ZW50KTtcbiAgICAgIH0gZWxzZSBpZiAobWFwQnJvd3NlckV2ZW50LnR5cGUgPT0gTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSVVApIHtcbiAgICAgICAgdmFyIGhhbmRsZWRVcCA9IHRoaXMuaGFuZGxlVXBFdmVudChtYXBCcm93c2VyRXZlbnQpO1xuICAgICAgICB0aGlzLmhhbmRsaW5nRG93blVwU2VxdWVuY2UgPSBoYW5kbGVkVXAgJiYgdGhpcy50YXJnZXRQb2ludGVycy5sZW5ndGggPiAwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobWFwQnJvd3NlckV2ZW50LnR5cGUgPT0gTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSRE9XTikge1xuICAgICAgICB2YXIgaGFuZGxlZCA9IHRoaXMuaGFuZGxlRG93bkV2ZW50KG1hcEJyb3dzZXJFdmVudCk7XG4gICAgICAgIGlmIChoYW5kbGVkKSB7XG4gICAgICAgICAgbWFwQnJvd3NlckV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYW5kbGluZ0Rvd25VcFNlcXVlbmNlID0gaGFuZGxlZDtcbiAgICAgICAgc3RvcEV2ZW50ID0gdGhpcy5zdG9wRG93bihoYW5kbGVkKTtcbiAgICAgIH0gZWxzZSBpZiAobWFwQnJvd3NlckV2ZW50LnR5cGUgPT0gTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSTU9WRSkge1xuICAgICAgICB0aGlzLmhhbmRsZU1vdmVFdmVudChtYXBCcm93c2VyRXZlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gIXN0b3BFdmVudDtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIHBvaW50ZXIgbW92ZSBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlclBvaW50ZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgRXZlbnQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIFBvaW50ZXJJbnRlcmFjdGlvbi5wcm90b3R5cGUuaGFuZGxlTW92ZUV2ZW50ID0gZnVuY3Rpb24gaGFuZGxlTW92ZUV2ZW50IChtYXBCcm93c2VyRXZlbnQpIHt9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgcG9pbnRlciB1cCBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlclBvaW50ZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgRXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElmIHRoZSBldmVudCB3YXMgY29uc3VtZWQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIFBvaW50ZXJJbnRlcmFjdGlvbi5wcm90b3R5cGUuaGFuZGxlVXBFdmVudCA9IGZ1bmN0aW9uIGhhbmRsZVVwRXZlbnQgKG1hcEJyb3dzZXJFdmVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGRldGVybWluZSBpZiBcImRvd25cIiBldmVudHMgc2hvdWxkIGJlIHByb3BhZ2F0ZWRcbiAgICogdG8gb3RoZXIgaW50ZXJhY3Rpb25zIG9yIHNob3VsZCBiZSBzdG9wcGVkLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhhbmRsZWQgV2FzIHRoZSBldmVudCBoYW5kbGVkIGJ5IHRoZSBpbnRlcmFjdGlvbj9cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gU2hvdWxkIHRoZSBgZG93bmAgZXZlbnQgYmUgc3RvcHBlZD9cbiAgICovXG4gIFBvaW50ZXJJbnRlcmFjdGlvbi5wcm90b3R5cGUuc3RvcERvd24gPSBmdW5jdGlvbiBzdG9wRG93biAoaGFuZGxlZCkge1xuICAgIHJldHVybiBoYW5kbGVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJQb2ludGVyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IEV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgUG9pbnRlckludGVyYWN0aW9uLnByb3RvdHlwZS51cGRhdGVUcmFja2VkUG9pbnRlcnNfID0gZnVuY3Rpb24gdXBkYXRlVHJhY2tlZFBvaW50ZXJzXyAobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKGlzUG9pbnRlckRyYWdnaW5nRXZlbnQobWFwQnJvd3NlckV2ZW50KSkge1xuICAgICAgdmFyIGV2ZW50ID0gbWFwQnJvd3NlckV2ZW50LnBvaW50ZXJFdmVudDtcblxuICAgICAgdmFyIGlkID0gZXZlbnQucG9pbnRlcklkLnRvU3RyaW5nKCk7XG4gICAgICBpZiAobWFwQnJvd3NlckV2ZW50LnR5cGUgPT0gTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSVVApIHtcbiAgICAgICAgZGVsZXRlIHRoaXMudHJhY2tlZFBvaW50ZXJzX1tpZF07XG4gICAgICB9IGVsc2UgaWYgKG1hcEJyb3dzZXJFdmVudC50eXBlID09XG4gICAgICAgICAgTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSRE9XTikge1xuICAgICAgICB0aGlzLnRyYWNrZWRQb2ludGVyc19baWRdID0gZXZlbnQ7XG4gICAgICB9IGVsc2UgaWYgKGlkIGluIHRoaXMudHJhY2tlZFBvaW50ZXJzXykge1xuICAgICAgICAvLyB1cGRhdGUgb25seSB3aGVuIHRoZXJlIHdhcyBhIHBvaW50ZXJkb3duIGV2ZW50IGZvciB0aGlzIHBvaW50ZXJcbiAgICAgICAgdGhpcy50cmFja2VkUG9pbnRlcnNfW2lkXSA9IGV2ZW50O1xuICAgICAgfVxuICAgICAgdGhpcy50YXJnZXRQb2ludGVycyA9IGdldFZhbHVlcyh0aGlzLnRyYWNrZWRQb2ludGVyc18pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gUG9pbnRlckludGVyYWN0aW9uO1xufShJbnRlcmFjdGlvbikpO1xuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuLi9wb2ludGVyL1BvaW50ZXJFdmVudC5qc1wiKS5kZWZhdWx0Pn0gcG9pbnRlckV2ZW50cyBMaXN0IG9mIGV2ZW50cy5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsfSBDZW50cm9pZCBwaXhlbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNlbnRyb2lkKHBvaW50ZXJFdmVudHMpIHtcbiAgdmFyIGxlbmd0aCA9IHBvaW50ZXJFdmVudHMubGVuZ3RoO1xuICB2YXIgY2xpZW50WCA9IDA7XG4gIHZhciBjbGllbnRZID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNsaWVudFggKz0gcG9pbnRlckV2ZW50c1tpXS5jbGllbnRYO1xuICAgIGNsaWVudFkgKz0gcG9pbnRlckV2ZW50c1tpXS5jbGllbnRZO1xuICB9XG4gIHJldHVybiBbY2xpZW50WCAvIGxlbmd0aCwgY2xpZW50WSAvIGxlbmd0aF07XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJQb2ludGVyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IEV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgZXZlbnQgaXMgYSBwb2ludGVyZG93biwgcG9pbnRlcmRyYWdcbiAqICAgICBvciBwb2ludGVydXAgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGlzUG9pbnRlckRyYWdnaW5nRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gIHZhciB0eXBlID0gbWFwQnJvd3NlckV2ZW50LnR5cGU7XG4gIHJldHVybiB0eXBlID09PSBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJET1dOIHx8XG4gICAgdHlwZSA9PT0gTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSRFJBRyB8fFxuICAgIHR5cGUgPT09IE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUlVQO1xufVxuXG5cbmV4cG9ydCBkZWZhdWx0IFBvaW50ZXJJbnRlcmFjdGlvbjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UG9pbnRlci5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vUHJvcGVydHlcbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgQUNUSVZFOiAnYWN0aXZlJ1xufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHJvcGVydHkuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL1NlbGVjdFxuICovXG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5pbXBvcnQgQ29sbGVjdGlvbkV2ZW50VHlwZSBmcm9tICcuLi9Db2xsZWN0aW9uRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7ZXh0ZW5kLCBpbmNsdWRlc30gZnJvbSAnLi4vYXJyYXkuanMnO1xuaW1wb3J0IHtsaXN0ZW59IGZyb20gJy4uL2V2ZW50cy5qcyc7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzL0V2ZW50LmpzJztcbmltcG9ydCB7c2luZ2xlQ2xpY2ssIG5ldmVyLCBzaGlmdEtleU9ubHksIHBvaW50ZXJNb3ZlfSBmcm9tICcuLi9ldmVudHMvY29uZGl0aW9uLmpzJztcbmltcG9ydCB7VFJVRX0gZnJvbSAnLi4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCBHZW9tZXRyeVR5cGUgZnJvbSAnLi4vZ2VvbS9HZW9tZXRyeVR5cGUuanMnO1xuaW1wb3J0IEludGVyYWN0aW9uIGZyb20gJy4vSW50ZXJhY3Rpb24uanMnO1xuaW1wb3J0IFZlY3RvckxheWVyIGZyb20gJy4uL2xheWVyL1ZlY3Rvci5qcyc7XG5pbXBvcnQge2NsZWFyfSBmcm9tICcuLi9vYmouanMnO1xuaW1wb3J0IFZlY3RvclNvdXJjZSBmcm9tICcuLi9zb3VyY2UvVmVjdG9yLmpzJztcbmltcG9ydCB7Y3JlYXRlRWRpdGluZ1N0eWxlfSBmcm9tICcuLi9zdHlsZS9TdHlsZS5qcyc7XG5cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG52YXIgU2VsZWN0RXZlbnRUeXBlID0ge1xuICAvKipcbiAgICogVHJpZ2dlcmVkIHdoZW4gZmVhdHVyZShzKSBoYXMgYmVlbiAoZGUpc2VsZWN0ZWQuXG4gICAqIEBldmVudCBTZWxlY3RFdmVudCNzZWxlY3RcbiAgICogQGFwaVxuICAgKi9cbiAgU0VMRUNUOiAnc2VsZWN0J1xufTtcblxuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL0ZlYXR1cmV9IG9yXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3JlbmRlci9GZWF0dXJlfSBhbmQgYW5cbiAqIHtAbGluayBtb2R1bGU6b2wvbGF5ZXIvTGF5ZXJ9IGFuZCByZXR1cm5zIGB0cnVlYCBpZiB0aGUgZmVhdHVyZSBtYXkgYmVcbiAqIHNlbGVjdGVkIG9yIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2UsIGltcG9ydChcIi4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHQpOmJvb2xlYW59IEZpbHRlckZ1bmN0aW9uXG4gKi9cblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259IFthZGRDb25kaXRpb25dIEEgZnVuY3Rpb25cbiAqIHRoYXQgdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmQgcmV0dXJucyBhXG4gKiBib29sZWFuIHRvIGluZGljYXRlIHdoZXRoZXIgdGhhdCBldmVudCBzaG91bGQgYmUgaGFuZGxlZC5cbiAqIEJ5IGRlZmF1bHQsIHRoaXMgaXMge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9ufm5ldmVyfS4gVXNlIHRoaXMgaWYgeW91XG4gKiB3YW50IHRvIHVzZSBkaWZmZXJlbnQgZXZlbnRzIGZvciBhZGQgYW5kIHJlbW92ZSBpbnN0ZWFkIG9mIGB0b2dnbGVgLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn0gW2NvbmRpdGlvbl0gQSBmdW5jdGlvbiB0aGF0XG4gKiB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnR9IGFuZCByZXR1cm5zIGFcbiAqIGJvb2xlYW4gdG8gaW5kaWNhdGUgd2hldGhlciB0aGF0IGV2ZW50IHNob3VsZCBiZSBoYW5kbGVkLiBUaGlzIGlzIHRoZSBldmVudFxuICogZm9yIHRoZSBzZWxlY3RlZCBmZWF0dXJlcyBhcyBhIHdob2xlLiBCeSBkZWZhdWx0LCB0aGlzIGlzXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb25+c2luZ2xlQ2xpY2t9LiBDbGlja2luZyBvbiBhIGZlYXR1cmUgc2VsZWN0cyB0aGF0XG4gKiBmZWF0dXJlIGFuZCByZW1vdmVzIGFueSB0aGF0IHdlcmUgaW4gdGhlIHNlbGVjdGlvbi4gQ2xpY2tpbmcgb3V0c2lkZSBhbnlcbiAqIGZlYXR1cmUgcmVtb3ZlcyBhbGwgZnJvbSB0aGUgc2VsZWN0aW9uLlxuICogU2VlIGB0b2dnbGVgLCBgYWRkYCwgYHJlbW92ZWAgb3B0aW9ucyBmb3IgYWRkaW5nL3JlbW92aW5nIGV4dHJhIGZlYXR1cmVzIHRvL1xuICogZnJvbSB0aGUgc2VsZWN0aW9uLlxuICogQHByb3BlcnR5IHtBcnJheTxpbXBvcnQoXCIuLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0PnxmdW5jdGlvbihpbXBvcnQoXCIuLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0KTogYm9vbGVhbn0gW2xheWVyc11cbiAqIEEgbGlzdCBvZiBsYXllcnMgZnJvbSB3aGljaCBmZWF0dXJlcyBzaG91bGQgYmUgc2VsZWN0ZWQuIEFsdGVybmF0aXZlbHksIGFcbiAqIGZpbHRlciBmdW5jdGlvbiBjYW4gYmUgcHJvdmlkZWQuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaCBsYXllclxuICogaW4gdGhlIG1hcCBhbmQgc2hvdWxkIHJldHVybiBgdHJ1ZWAgZm9yIGxheWVycyB0aGF0IHlvdSB3YW50IHRvIGJlXG4gKiBzZWxlY3RhYmxlLiBJZiB0aGUgb3B0aW9uIGlzIGFic2VudCwgYWxsIHZpc2libGUgbGF5ZXJzIHdpbGwgYmUgY29uc2lkZXJlZFxuICogc2VsZWN0YWJsZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVMaWtlfSBbc3R5bGVdXG4gKiBTdHlsZSBmb3IgdGhlIHNlbGVjdGVkIGZlYXR1cmVzLiBCeSBkZWZhdWx0IHRoZSBkZWZhdWx0IGVkaXQgc3R5bGUgaXMgdXNlZFxuICogKHNlZSB7QGxpbmsgbW9kdWxlOm9sL3N0eWxlfSkuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufSBbcmVtb3ZlQ29uZGl0aW9uXSBBIGZ1bmN0aW9uXG4gKiB0aGF0IHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0gYW5kIHJldHVybnMgYVxuICogYm9vbGVhbiB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoYXQgZXZlbnQgc2hvdWxkIGJlIGhhbmRsZWQuXG4gKiBCeSBkZWZhdWx0LCB0aGlzIGlzIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbn5uZXZlcn0uIFVzZSB0aGlzIGlmIHlvdVxuICogd2FudCB0byB1c2UgZGlmZmVyZW50IGV2ZW50cyBmb3IgYWRkIGFuZCByZW1vdmUgaW5zdGVhZCBvZiBgdG9nZ2xlYC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259IFt0b2dnbGVDb25kaXRpb25dIEEgZnVuY3Rpb25cbiAqIHRoYXQgdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmQgcmV0dXJucyBhXG4gKiBib29sZWFuIHRvIGluZGljYXRlIHdoZXRoZXIgdGhhdCBldmVudCBzaG91bGQgYmUgaGFuZGxlZC4gVGhpcyBpcyBpbiBhZGRpdGlvblxuICogdG8gdGhlIGBjb25kaXRpb25gIGV2ZW50LiBCeSBkZWZhdWx0LFxuICoge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9ufnNoaWZ0S2V5T25seX0sIGkuZS4gcHJlc3NpbmcgYHNoaWZ0YCBhc1xuICogd2VsbCBhcyB0aGUgYGNvbmRpdGlvbmAgZXZlbnQsIGFkZHMgdGhhdCBmZWF0dXJlIHRvIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBpZlxuICogaXQgaXMgbm90IGN1cnJlbnRseSBzZWxlY3RlZCwgYW5kIHJlbW92ZXMgaXQgaWYgaXQgaXMuIFNlZSBgYWRkYCBhbmQgYHJlbW92ZWBcbiAqIGlmIHlvdSB3YW50IHRvIHVzZSBkaWZmZXJlbnQgZXZlbnRzIGluc3RlYWQgb2YgYSB0b2dnbGUuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFttdWx0aT1mYWxzZV0gQSBib29sZWFuIHRoYXQgZGV0ZXJtaW5lcyBpZiB0aGUgZGVmYXVsdFxuICogYmVoYXZpb3VyIHNob3VsZCBzZWxlY3Qgb25seSBzaW5nbGUgZmVhdHVyZXMgb3IgYWxsIChvdmVybGFwcGluZykgZmVhdHVyZXMgYXRcbiAqIHRoZSBjbGlja2VkIG1hcCBwb3NpdGlvbi4gVGhlIGRlZmF1bHQgb2YgYGZhbHNlYCBtZWFucyBzaW5nbGUgc2VsZWN0LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9Db2xsZWN0aW9uLmpzXCIpLmRlZmF1bHQ8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn0gW2ZlYXR1cmVzXVxuICogQ29sbGVjdGlvbiB3aGVyZSB0aGUgaW50ZXJhY3Rpb24gd2lsbCBwbGFjZSBzZWxlY3RlZCBmZWF0dXJlcy4gT3B0aW9uYWwuIElmXG4gKiBub3Qgc2V0IHRoZSBpbnRlcmFjdGlvbiB3aWxsIGNyZWF0ZSBhIGNvbGxlY3Rpb24uIEluIGFueSBjYXNlIHRoZSBjb2xsZWN0aW9uXG4gKiB1c2VkIGJ5IHRoZSBpbnRlcmFjdGlvbiBpcyByZXR1cm5lZCBieVxuICoge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9TZWxlY3R+U2VsZWN0I2dldEZlYXR1cmVzfS5cbiAqIEBwcm9wZXJ0eSB7RmlsdGVyRnVuY3Rpb259IFtmaWx0ZXJdIEEgZnVuY3Rpb25cbiAqIHRoYXQgdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9GZWF0dXJlfSBhbmQgYW5cbiAqIHtAbGluayBtb2R1bGU6b2wvbGF5ZXIvTGF5ZXJ9IGFuZCByZXR1cm5zIGB0cnVlYCBpZiB0aGUgZmVhdHVyZSBtYXkgYmVcbiAqIHNlbGVjdGVkIG9yIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbd3JhcFg9dHJ1ZV0gV3JhcCB0aGUgd29ybGQgaG9yaXpvbnRhbGx5IG9uIHRoZSBzZWxlY3Rpb25cbiAqIG92ZXJsYXkuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2hpdFRvbGVyYW5jZT0wXSBIaXQtZGV0ZWN0aW9uIHRvbGVyYW5jZS4gUGl4ZWxzIGluc2lkZVxuICogdGhlIHJhZGl1cyBhcm91bmQgdGhlIGdpdmVuIHBvc2l0aW9uIHdpbGwgYmUgY2hlY2tlZCBmb3IgZmVhdHVyZXMuIFRoaXMgb25seVxuICogd29ya3MgZm9yIHRoZSBjYW52YXMgcmVuZGVyZXIgYW5kIG5vdCBmb3IgV2ViR0wuXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEV2ZW50cyBlbWl0dGVkIGJ5IHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vU2VsZWN0flNlbGVjdH0gaW5zdGFuY2VzIGFyZSBpbnN0YW5jZXMgb2ZcbiAqIHRoaXMgdHlwZS5cbiAqL1xudmFyIFNlbGVjdEV2ZW50ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoRXZlbnQpIHtcbiAgZnVuY3Rpb24gU2VsZWN0RXZlbnQodHlwZSwgc2VsZWN0ZWQsIGRlc2VsZWN0ZWQsIG1hcEJyb3dzZXJFdmVudCkge1xuICAgIEV2ZW50LmNhbGwodGhpcywgdHlwZSk7XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3RlZCBmZWF0dXJlcyBhcnJheS5cbiAgICAgKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuXG4gICAgLyoqXG4gICAgICogRGVzZWxlY3RlZCBmZWF0dXJlcyBhcnJheS5cbiAgICAgKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5kZXNlbGVjdGVkID0gZGVzZWxlY3RlZDtcblxuICAgIC8qKlxuICAgICAqIEFzc29jaWF0ZWQge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR9LlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5tYXBCcm93c2VyRXZlbnQgPSBtYXBCcm93c2VyRXZlbnQ7XG5cbiAgfVxuXG4gIGlmICggRXZlbnQgKSBTZWxlY3RFdmVudC5fX3Byb3RvX18gPSBFdmVudDtcbiAgU2VsZWN0RXZlbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXZlbnQgJiYgRXZlbnQucHJvdG90eXBlICk7XG4gIFNlbGVjdEV2ZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNlbGVjdEV2ZW50O1xuXG4gIHJldHVybiBTZWxlY3RFdmVudDtcbn0oRXZlbnQpKTtcblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEludGVyYWN0aW9uIGZvciBzZWxlY3RpbmcgdmVjdG9yIGZlYXR1cmVzLiBCeSBkZWZhdWx0LCBzZWxlY3RlZCBmZWF0dXJlcyBhcmVcbiAqIHN0eWxlZCBkaWZmZXJlbnRseSwgc28gdGhpcyBpbnRlcmFjdGlvbiBjYW4gYmUgdXNlZCBmb3IgdmlzdWFsIGhpZ2hsaWdodGluZyxcbiAqIGFzIHdlbGwgYXMgc2VsZWN0aW5nIGZlYXR1cmVzIGZvciBvdGhlciBhY3Rpb25zLCBzdWNoIGFzIG1vZGlmaWNhdGlvbiBvclxuICogb3V0cHV0LiBUaGVyZSBhcmUgdGhyZWUgd2F5cyBvZiBjb250cm9sbGluZyB3aGljaCBmZWF0dXJlcyBhcmUgc2VsZWN0ZWQ6XG4gKiB1c2luZyB0aGUgYnJvd3NlciBldmVudCBhcyBkZWZpbmVkIGJ5IHRoZSBgY29uZGl0aW9uYCBhbmQgb3B0aW9uYWxseSB0aGVcbiAqIGB0b2dnbGVgLCBgYWRkYC9gcmVtb3ZlYCwgYW5kIGBtdWx0aWAgb3B0aW9uczsgYSBgbGF5ZXJzYCBmaWx0ZXI7IGFuZCBhXG4gKiBmdXJ0aGVyIGZlYXR1cmUgZmlsdGVyIHVzaW5nIHRoZSBgZmlsdGVyYCBvcHRpb24uXG4gKlxuICogU2VsZWN0ZWQgZmVhdHVyZXMgYXJlIGFkZGVkIHRvIGFuIGludGVybmFsIHVubWFuYWdlZCBsYXllci5cbiAqXG4gKiBAZmlyZXMgU2VsZWN0RXZlbnRcbiAqIEBhcGlcbiAqL1xudmFyIFNlbGVjdCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEludGVyYWN0aW9uKSB7XG4gIGZ1bmN0aW9uIFNlbGVjdChvcHRfb3B0aW9ucykge1xuXG4gICAgSW50ZXJhY3Rpb24uY2FsbCh0aGlzLCB7XG4gICAgICBoYW5kbGVFdmVudDogaGFuZGxlRXZlbnRcbiAgICB9KTtcblxuICAgIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgPyBvcHRfb3B0aW9ucyA6IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259XG4gICAgICovXG4gICAgdGhpcy5jb25kaXRpb25fID0gb3B0aW9ucy5jb25kaXRpb24gPyBvcHRpb25zLmNvbmRpdGlvbiA6IHNpbmdsZUNsaWNrO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259XG4gICAgICovXG4gICAgdGhpcy5hZGRDb25kaXRpb25fID0gb3B0aW9ucy5hZGRDb25kaXRpb24gPyBvcHRpb25zLmFkZENvbmRpdGlvbiA6IG5ldmVyO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259XG4gICAgICovXG4gICAgdGhpcy5yZW1vdmVDb25kaXRpb25fID0gb3B0aW9ucy5yZW1vdmVDb25kaXRpb24gPyBvcHRpb25zLnJlbW92ZUNvbmRpdGlvbiA6IG5ldmVyO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259XG4gICAgICovXG4gICAgdGhpcy50b2dnbGVDb25kaXRpb25fID0gb3B0aW9ucy50b2dnbGVDb25kaXRpb24gPyBvcHRpb25zLnRvZ2dsZUNvbmRpdGlvbiA6IHNoaWZ0S2V5T25seTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5tdWx0aV8gPSBvcHRpb25zLm11bHRpID8gb3B0aW9ucy5tdWx0aSA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7RmlsdGVyRnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy5maWx0ZXJfID0gb3B0aW9ucy5maWx0ZXIgPyBvcHRpb25zLmZpbHRlciA6IFRSVUU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5oaXRUb2xlcmFuY2VfID0gb3B0aW9ucy5oaXRUb2xlcmFuY2UgPyBvcHRpb25zLmhpdFRvbGVyYW5jZSA6IDA7XG5cbiAgICB2YXIgZmVhdHVyZU92ZXJsYXkgPSBuZXcgVmVjdG9yTGF5ZXIoe1xuICAgICAgc291cmNlOiBuZXcgVmVjdG9yU291cmNlKHtcbiAgICAgICAgdXNlU3BhdGlhbEluZGV4OiBmYWxzZSxcbiAgICAgICAgZmVhdHVyZXM6IG9wdGlvbnMuZmVhdHVyZXMsXG4gICAgICAgIHdyYXBYOiBvcHRpb25zLndyYXBYXG4gICAgICB9KSxcbiAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlID8gb3B0aW9ucy5zdHlsZSA6XG4gICAgICAgIGdldERlZmF1bHRTdHlsZUZ1bmN0aW9uKCksXG4gICAgICB1cGRhdGVXaGlsZUFuaW1hdGluZzogdHJ1ZSxcbiAgICAgIHVwZGF0ZVdoaWxlSW50ZXJhY3Rpbmc6IHRydWVcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge1ZlY3RvckxheWVyfVxuICAgICAqL1xuICAgIHRoaXMuZmVhdHVyZU92ZXJsYXlfID0gZmVhdHVyZU92ZXJsYXk7XG5cbiAgICAvKiogQHR5cGUge2Z1bmN0aW9uKGltcG9ydChcIi4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHQpOiBib29sZWFufSAqL1xuICAgIHZhciBsYXllckZpbHRlcjtcbiAgICBpZiAob3B0aW9ucy5sYXllcnMpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5sYXllcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbGF5ZXJGaWx0ZXIgPSBvcHRpb25zLmxheWVycztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBsYXllcnMgPSBvcHRpb25zLmxheWVycztcbiAgICAgICAgbGF5ZXJGaWx0ZXIgPSBmdW5jdGlvbihsYXllcikge1xuICAgICAgICAgIHJldHVybiBpbmNsdWRlcyhsYXllcnMsIGxheWVyKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGF5ZXJGaWx0ZXIgPSBUUlVFO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKGltcG9ydChcIi4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHQpOiBib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMubGF5ZXJGaWx0ZXJfID0gbGF5ZXJGaWx0ZXI7XG5cbiAgICAvKipcbiAgICAgKiBBbiBhc3NvY2lhdGlvbiBiZXR3ZWVuIHNlbGVjdGVkIGZlYXR1cmUgKGtleSlcbiAgICAgKiBhbmQgbGF5ZXIgKHZhbHVlKVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHQ+fVxuICAgICAqL1xuICAgIHRoaXMuZmVhdHVyZUxheWVyQXNzb2NpYXRpb25fID0ge307XG5cbiAgICB2YXIgZmVhdHVyZXMgPSB0aGlzLmdldEZlYXR1cmVzKCk7XG4gICAgbGlzdGVuKGZlYXR1cmVzLCBDb2xsZWN0aW9uRXZlbnRUeXBlLkFERCxcbiAgICAgIHRoaXMuYWRkRmVhdHVyZV8sIHRoaXMpO1xuICAgIGxpc3RlbihmZWF0dXJlcywgQ29sbGVjdGlvbkV2ZW50VHlwZS5SRU1PVkUsXG4gICAgICB0aGlzLnJlbW92ZUZlYXR1cmVfLCB0aGlzKTtcbiAgfVxuXG4gIGlmICggSW50ZXJhY3Rpb24gKSBTZWxlY3QuX19wcm90b19fID0gSW50ZXJhY3Rpb247XG4gIFNlbGVjdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbnRlcmFjdGlvbiAmJiBJbnRlcmFjdGlvbi5wcm90b3R5cGUgKTtcbiAgU2VsZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNlbGVjdDtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdH0gbGF5ZXIgTGF5ZXIuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBTZWxlY3QucHJvdG90eXBlLmFkZEZlYXR1cmVMYXllckFzc29jaWF0aW9uXyA9IGZ1bmN0aW9uIGFkZEZlYXR1cmVMYXllckFzc29jaWF0aW9uXyAoZmVhdHVyZSwgbGF5ZXIpIHtcbiAgICB0aGlzLmZlYXR1cmVMYXllckFzc29jaWF0aW9uX1tnZXRVaWQoZmVhdHVyZSldID0gbGF5ZXI7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2VsZWN0ZWQgZmVhdHVyZXMuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL0NvbGxlY3Rpb24uanNcIikuZGVmYXVsdDxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fSBGZWF0dXJlcyBjb2xsZWN0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBTZWxlY3QucHJvdG90eXBlLmdldEZlYXR1cmVzID0gZnVuY3Rpb24gZ2V0RmVhdHVyZXMgKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge1ZlY3RvclNvdXJjZX0gKi8gKHRoaXMuZmVhdHVyZU92ZXJsYXlfLmdldFNvdXJjZSgpKS5nZXRGZWF0dXJlc0NvbGxlY3Rpb24oKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgSGl0LWRldGVjdGlvbiB0b2xlcmFuY2UuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IEhpdCB0b2xlcmFuY2UgaW4gcGl4ZWxzLlxuICAgKiBAYXBpXG4gICAqL1xuICBTZWxlY3QucHJvdG90eXBlLmdldEhpdFRvbGVyYW5jZSA9IGZ1bmN0aW9uIGdldEhpdFRvbGVyYW5jZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGl0VG9sZXJhbmNlXztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXNzb2NpYXRlZCB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL1ZlY3Rvcn5WZWN0b3IgdmVjdG9ybGF5ZXJ9IG9mXG4gICAqIHRoZSAobGFzdCkgc2VsZWN0ZWQgZmVhdHVyZS4gTm90ZSB0aGF0IHRoaXMgd2lsbCBub3Qgd29yayB3aXRoIGFueVxuICAgKiBwcm9ncmFtbWF0aWMgbWV0aG9kIGxpa2UgcHVzaGluZyBmZWF0dXJlcyB0b1xuICAgKiB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL1NlbGVjdH5TZWxlY3QjZ2V0RmVhdHVyZXMgY29sbGVjdGlvbn0uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZSBGZWF0dXJlXG4gICAqIEByZXR1cm4ge1ZlY3RvckxheWVyfSBMYXllci5cbiAgICogQGFwaVxuICAgKi9cbiAgU2VsZWN0LnByb3RvdHlwZS5nZXRMYXllciA9IGZ1bmN0aW9uIGdldExheWVyIChmZWF0dXJlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIC8qKiBAdHlwZSB7VmVjdG9yTGF5ZXJ9ICovICh0aGlzLmZlYXR1cmVMYXllckFzc29jaWF0aW9uX1tnZXRVaWQoZmVhdHVyZSldKVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgb3ZlcmxheSBsYXllciB0aGF0IHRoaXMgaW50ZXJhY3Rpb24gcmVuZGVycyBzZWxlY3RlZCBmZWF0dXJlcyB0by5cbiAgICogQHJldHVybiB7VmVjdG9yTGF5ZXJ9IE92ZXJsYXkgbGF5ZXIuXG4gICAqIEBhcGlcbiAgICovXG4gIFNlbGVjdC5wcm90b3R5cGUuZ2V0T3ZlcmxheSA9IGZ1bmN0aW9uIGdldE92ZXJsYXkgKCkge1xuICAgIHJldHVybiB0aGlzLmZlYXR1cmVPdmVybGF5XztcbiAgfTtcblxuICAvKipcbiAgICogSGl0LWRldGVjdGlvbiB0b2xlcmFuY2UuIFBpeGVscyBpbnNpZGUgdGhlIHJhZGl1cyBhcm91bmQgdGhlIGdpdmVuIHBvc2l0aW9uXG4gICAqIHdpbGwgYmUgY2hlY2tlZCBmb3IgZmVhdHVyZXMuIFRoaXMgb25seSB3b3JrcyBmb3IgdGhlIGNhbnZhcyByZW5kZXJlciBhbmRcbiAgICogbm90IGZvciBXZWJHTC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGhpdFRvbGVyYW5jZSBIaXQgdG9sZXJhbmNlIGluIHBpeGVscy5cbiAgICogQGFwaVxuICAgKi9cbiAgU2VsZWN0LnByb3RvdHlwZS5zZXRIaXRUb2xlcmFuY2UgPSBmdW5jdGlvbiBzZXRIaXRUb2xlcmFuY2UgKGhpdFRvbGVyYW5jZSkge1xuICAgIHRoaXMuaGl0VG9sZXJhbmNlXyA9IGhpdFRvbGVyYW5jZTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBpbnRlcmFjdGlvbiBmcm9tIGl0cyBjdXJyZW50IG1hcCwgaWYgYW55LCAgYW5kIGF0dGFjaCBpdCB0byBhIG5ld1xuICAgKiBtYXAsIGlmIGFueS4gUGFzcyBgbnVsbGAgdG8ganVzdCByZW1vdmUgdGhlIGludGVyYWN0aW9uIGZyb20gdGhlIGN1cnJlbnQgbWFwLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1BsdWdnYWJsZU1hcC5qc1wiKS5kZWZhdWx0fSBtYXAgTWFwLlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGFwaVxuICAgKi9cbiAgU2VsZWN0LnByb3RvdHlwZS5zZXRNYXAgPSBmdW5jdGlvbiBzZXRNYXAgKG1hcCkge1xuICAgIHZhciBjdXJyZW50TWFwID0gdGhpcy5nZXRNYXAoKTtcbiAgICB2YXIgc2VsZWN0ZWRGZWF0dXJlcyA9IHRoaXMuZ2V0RmVhdHVyZXMoKTtcbiAgICBpZiAoY3VycmVudE1hcCkge1xuICAgICAgc2VsZWN0ZWRGZWF0dXJlcy5mb3JFYWNoKGN1cnJlbnRNYXAudW5za2lwRmVhdHVyZS5iaW5kKGN1cnJlbnRNYXApKTtcbiAgICB9XG4gICAgSW50ZXJhY3Rpb24ucHJvdG90eXBlLnNldE1hcC5jYWxsKHRoaXMsIG1hcCk7XG4gICAgdGhpcy5mZWF0dXJlT3ZlcmxheV8uc2V0TWFwKG1hcCk7XG4gICAgaWYgKG1hcCkge1xuICAgICAgc2VsZWN0ZWRGZWF0dXJlcy5mb3JFYWNoKG1hcC5za2lwRmVhdHVyZS5iaW5kKG1hcCkpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9Db2xsZWN0aW9uLmpzXCIpLkNvbGxlY3Rpb25FdmVudH0gZXZ0IEV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgU2VsZWN0LnByb3RvdHlwZS5hZGRGZWF0dXJlXyA9IGZ1bmN0aW9uIGFkZEZlYXR1cmVfIChldnQpIHtcbiAgICB2YXIgbWFwID0gdGhpcy5nZXRNYXAoKTtcbiAgICBpZiAobWFwKSB7XG4gICAgICBtYXAuc2tpcEZlYXR1cmUoLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9ICovIChldnQuZWxlbWVudCkpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9Db2xsZWN0aW9uLmpzXCIpLkNvbGxlY3Rpb25FdmVudH0gZXZ0IEV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgU2VsZWN0LnByb3RvdHlwZS5yZW1vdmVGZWF0dXJlXyA9IGZ1bmN0aW9uIHJlbW92ZUZlYXR1cmVfIChldnQpIHtcbiAgICB2YXIgbWFwID0gdGhpcy5nZXRNYXAoKTtcbiAgICBpZiAobWFwKSB7XG4gICAgICBtYXAudW5za2lwRmVhdHVyZSgvKiogQHR5cGUge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gKi8gKGV2dC5lbGVtZW50KSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFNlbGVjdC5wcm90b3R5cGUucmVtb3ZlRmVhdHVyZUxheWVyQXNzb2NpYXRpb25fID0gZnVuY3Rpb24gcmVtb3ZlRmVhdHVyZUxheWVyQXNzb2NpYXRpb25fIChmZWF0dXJlKSB7XG4gICAgZGVsZXRlIHRoaXMuZmVhdHVyZUxheWVyQXNzb2NpYXRpb25fW2dldFVpZChmZWF0dXJlKV07XG4gIH07XG5cbiAgcmV0dXJuIFNlbGVjdDtcbn0oSW50ZXJhY3Rpb24pKTtcblxuXG4vKipcbiAqIEhhbmRsZXMgdGhlIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50IG1hcCBicm93c2VyIGV2ZW50fSBhbmQgbWF5IGNoYW5nZSB0aGVcbiAqIHNlbGVjdGVkIHN0YXRlIG9mIGZlYXR1cmVzLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gYGZhbHNlYCB0byBzdG9wIGV2ZW50IHByb3BhZ2F0aW9uLlxuICogQHRoaXMge1NlbGVjdH1cbiAqL1xuZnVuY3Rpb24gaGFuZGxlRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gIGlmICghdGhpcy5jb25kaXRpb25fKG1hcEJyb3dzZXJFdmVudCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgYWRkID0gdGhpcy5hZGRDb25kaXRpb25fKG1hcEJyb3dzZXJFdmVudCk7XG4gIHZhciByZW1vdmUgPSB0aGlzLnJlbW92ZUNvbmRpdGlvbl8obWFwQnJvd3NlckV2ZW50KTtcbiAgdmFyIHRvZ2dsZSA9IHRoaXMudG9nZ2xlQ29uZGl0aW9uXyhtYXBCcm93c2VyRXZlbnQpO1xuICB2YXIgc2V0ID0gIWFkZCAmJiAhcmVtb3ZlICYmICF0b2dnbGU7XG4gIHZhciBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuICB2YXIgZmVhdHVyZXMgPSB0aGlzLmdldEZlYXR1cmVzKCk7XG4gIHZhciBkZXNlbGVjdGVkID0gW107XG4gIHZhciBzZWxlY3RlZCA9IFtdO1xuICBpZiAoc2V0KSB7XG4gICAgLy8gUmVwbGFjZSB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGZlYXR1cmUocykgd2l0aCB0aGUgZmVhdHVyZShzKSBhdCB0aGVcbiAgICAvLyBwaXhlbCwgb3IgY2xlYXIgdGhlIHNlbGVjdGVkIGZlYXR1cmUocykgaWYgdGhlcmUgaXMgbm8gZmVhdHVyZSBhdFxuICAgIC8vIHRoZSBwaXhlbC5cbiAgICBjbGVhcih0aGlzLmZlYXR1cmVMYXllckFzc29jaWF0aW9uXyk7XG4gICAgbWFwLmZvckVhY2hGZWF0dXJlQXRQaXhlbChtYXBCcm93c2VyRXZlbnQucGl4ZWwsXG4gICAgICAoXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0fSBsYXllciBMYXllci5cbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbnx1bmRlZmluZWR9IENvbnRpbnVlIHRvIGl0ZXJhdGUgb3ZlciB0aGUgZmVhdHVyZXMuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbihmZWF0dXJlLCBsYXllcikge1xuICAgICAgICAgIGlmICh0aGlzLmZpbHRlcl8oZmVhdHVyZSwgbGF5ZXIpKSB7XG4gICAgICAgICAgICBzZWxlY3RlZC5wdXNoKGZlYXR1cmUpO1xuICAgICAgICAgICAgdGhpcy5hZGRGZWF0dXJlTGF5ZXJBc3NvY2lhdGlvbl8oZmVhdHVyZSwgbGF5ZXIpO1xuICAgICAgICAgICAgcmV0dXJuICF0aGlzLm11bHRpXztcbiAgICAgICAgICB9XG4gICAgICAgIH0pLmJpbmQodGhpcyksIHtcbiAgICAgICAgbGF5ZXJGaWx0ZXI6IHRoaXMubGF5ZXJGaWx0ZXJfLFxuICAgICAgICBoaXRUb2xlcmFuY2U6IHRoaXMuaGl0VG9sZXJhbmNlX1xuICAgICAgfSk7XG4gICAgZm9yICh2YXIgaSA9IGZlYXR1cmVzLmdldExlbmd0aCgpIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHZhciBmZWF0dXJlID0gZmVhdHVyZXMuaXRlbShpKTtcbiAgICAgIHZhciBpbmRleCA9IHNlbGVjdGVkLmluZGV4T2YoZmVhdHVyZSk7XG4gICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAvLyBmZWF0dXJlIGlzIGFscmVhZHkgc2VsZWN0ZWRcbiAgICAgICAgc2VsZWN0ZWQuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZlYXR1cmVzLnJlbW92ZShmZWF0dXJlKTtcbiAgICAgICAgZGVzZWxlY3RlZC5wdXNoKGZlYXR1cmUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2VsZWN0ZWQubGVuZ3RoICE9PSAwKSB7XG4gICAgICBmZWF0dXJlcy5leHRlbmQoc2VsZWN0ZWQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBNb2RpZnkgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBmZWF0dXJlKHMpLlxuICAgIG1hcC5mb3JFYWNoRmVhdHVyZUF0UGl4ZWwobWFwQnJvd3NlckV2ZW50LnBpeGVsLFxuICAgICAgKFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gICAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdH0gbGF5ZXIgTGF5ZXIuXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW58dW5kZWZpbmVkfSBDb250aW51ZSB0byBpdGVyYXRlIG92ZXIgdGhlIGZlYXR1cmVzLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24oZmVhdHVyZSwgbGF5ZXIpIHtcbiAgICAgICAgICBpZiAodGhpcy5maWx0ZXJfKGZlYXR1cmUsIGxheWVyKSkge1xuICAgICAgICAgICAgaWYgKChhZGQgfHwgdG9nZ2xlKSAmJiAhaW5jbHVkZXMoZmVhdHVyZXMuZ2V0QXJyYXkoKSwgZmVhdHVyZSkpIHtcbiAgICAgICAgICAgICAgc2VsZWN0ZWQucHVzaChmZWF0dXJlKTtcbiAgICAgICAgICAgICAgdGhpcy5hZGRGZWF0dXJlTGF5ZXJBc3NvY2lhdGlvbl8oZmVhdHVyZSwgbGF5ZXIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgocmVtb3ZlIHx8IHRvZ2dsZSkgJiYgaW5jbHVkZXMoZmVhdHVyZXMuZ2V0QXJyYXkoKSwgZmVhdHVyZSkpIHtcbiAgICAgICAgICAgICAgZGVzZWxlY3RlZC5wdXNoKGZlYXR1cmUpO1xuICAgICAgICAgICAgICB0aGlzLnJlbW92ZUZlYXR1cmVMYXllckFzc29jaWF0aW9uXyhmZWF0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5tdWx0aV87XG4gICAgICAgICAgfVxuICAgICAgICB9KS5iaW5kKHRoaXMpLCB7XG4gICAgICAgIGxheWVyRmlsdGVyOiB0aGlzLmxheWVyRmlsdGVyXyxcbiAgICAgICAgaGl0VG9sZXJhbmNlOiB0aGlzLmhpdFRvbGVyYW5jZV9cbiAgICAgIH0pO1xuICAgIGZvciAodmFyIGogPSBkZXNlbGVjdGVkLmxlbmd0aCAtIDE7IGogPj0gMDsgLS1qKSB7XG4gICAgICBmZWF0dXJlcy5yZW1vdmUoZGVzZWxlY3RlZFtqXSk7XG4gICAgfVxuICAgIGZlYXR1cmVzLmV4dGVuZChzZWxlY3RlZCk7XG4gIH1cbiAgaWYgKHNlbGVjdGVkLmxlbmd0aCA+IDAgfHwgZGVzZWxlY3RlZC5sZW5ndGggPiAwKSB7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgbmV3IFNlbGVjdEV2ZW50KFNlbGVjdEV2ZW50VHlwZS5TRUxFQ1QsXG4gICAgICAgIHNlbGVjdGVkLCBkZXNlbGVjdGVkLCBtYXBCcm93c2VyRXZlbnQpKTtcbiAgfVxuICByZXR1cm4gcG9pbnRlck1vdmUobWFwQnJvd3NlckV2ZW50KTtcbn1cblxuXG4vKipcbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLlN0eWxlRnVuY3Rpb259IFN0eWxlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0RGVmYXVsdFN0eWxlRnVuY3Rpb24oKSB7XG4gIHZhciBzdHlsZXMgPSBjcmVhdGVFZGl0aW5nU3R5bGUoKTtcbiAgZXh0ZW5kKHN0eWxlc1tHZW9tZXRyeVR5cGUuUE9MWUdPTl0sIHN0eWxlc1tHZW9tZXRyeVR5cGUuTElORV9TVFJJTkddKTtcbiAgZXh0ZW5kKHN0eWxlc1tHZW9tZXRyeVR5cGUuR0VPTUVUUllfQ09MTEVDVElPTl0sIHN0eWxlc1tHZW9tZXRyeVR5cGUuTElORV9TVFJJTkddKTtcblxuICByZXR1cm4gZnVuY3Rpb24oZmVhdHVyZSwgcmVzb2x1dGlvbikge1xuICAgIGlmICghZmVhdHVyZS5nZXRHZW9tZXRyeSgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlc1tmZWF0dXJlLmdldEdlb21ldHJ5KCkuZ2V0VHlwZSgpXTtcbiAgfTtcbn1cblxuXG5leHBvcnQgZGVmYXVsdCBTZWxlY3Q7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNlbGVjdC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vU25hcFxuICovXG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5pbXBvcnQgQ29sbGVjdGlvbkV2ZW50VHlwZSBmcm9tICcuLi9Db2xsZWN0aW9uRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7ZGlzdGFuY2UgYXMgY29vcmRpbmF0ZURpc3RhbmNlLCBzcXVhcmVkRGlzdGFuY2UgYXMgc3F1YXJlZENvb3JkaW5hdGVEaXN0YW5jZSwgY2xvc2VzdE9uQ2lyY2xlLCBjbG9zZXN0T25TZWdtZW50LCBzcXVhcmVkRGlzdGFuY2VUb1NlZ21lbnR9IGZyb20gJy4uL2Nvb3JkaW5hdGUuanMnO1xuaW1wb3J0IHtsaXN0ZW4sIHVubGlzdGVuQnlLZXl9IGZyb20gJy4uL2V2ZW50cy5qcyc7XG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4uL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IHtib3VuZGluZ0V4dGVudCwgY3JlYXRlRW1wdHl9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge1RSVUUsIEZBTFNFfSBmcm9tICcuLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IEdlb21ldHJ5VHlwZSBmcm9tICcuLi9nZW9tL0dlb21ldHJ5VHlwZS5qcyc7XG5pbXBvcnQge2Zyb21DaXJjbGV9IGZyb20gJy4uL2dlb20vUG9seWdvbi5qcyc7XG5pbXBvcnQgUG9pbnRlckludGVyYWN0aW9uIGZyb20gJy4vUG9pbnRlci5qcyc7XG5pbXBvcnQge2dldFZhbHVlc30gZnJvbSAnLi4vb2JqLmpzJztcbmltcG9ydCBWZWN0b3JFdmVudFR5cGUgZnJvbSAnLi4vc291cmNlL1ZlY3RvckV2ZW50VHlwZS5qcyc7XG5pbXBvcnQgUkJ1c2ggZnJvbSAnLi4vc3RydWN0cy9SQnVzaC5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBSZXN1bHRcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc25hcHBlZFxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8bnVsbH0gdmVydGV4XG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsfG51bGx9IHZlcnRleFBpeGVsXG4gKi9cblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNlZ21lbnREYXRhXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZVxuICogQHByb3BlcnR5IHtBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSBzZWdtZW50XG4gKi9cblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vQ29sbGVjdGlvbi5qc1wiKS5kZWZhdWx0PGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59IFtmZWF0dXJlc10gU25hcCB0byB0aGVzZSBmZWF0dXJlcy4gRWl0aGVyIHRoaXMgb3B0aW9uIG9yIHNvdXJjZSBzaG91bGQgYmUgcHJvdmlkZWQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtlZGdlPXRydWVdIFNuYXAgdG8gZWRnZXMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt2ZXJ0ZXg9dHJ1ZV0gU25hcCB0byB2ZXJ0aWNlcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcGl4ZWxUb2xlcmFuY2U9MTBdIFBpeGVsIHRvbGVyYW5jZSBmb3IgY29uc2lkZXJpbmcgdGhlIHBvaW50ZXIgY2xvc2UgZW5vdWdoIHRvIGEgc2VnbWVudCBvclxuICogdmVydGV4IGZvciBzbmFwcGluZy5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vc291cmNlL1ZlY3Rvci5qc1wiKS5kZWZhdWx0fSBbc291cmNlXSBTbmFwIHRvIGZlYXR1cmVzIGZyb20gdGhpcyBzb3VyY2UuIEVpdGhlciB0aGlzIG9wdGlvbiBvciBmZWF0dXJlcyBzaG91bGQgYmUgcHJvdmlkZWRcbiAqL1xuXG5cbi8qKlxuICogQHBhcmFtICB7aW1wb3J0KFwiLi4vc291cmNlL1ZlY3Rvci5qc1wiKS5WZWN0b3JTb3VyY2VFdmVudHxpbXBvcnQoXCIuLi9Db2xsZWN0aW9uLmpzXCIpLkNvbGxlY3Rpb25FdmVudH0gZXZ0IEV2ZW50LlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBGZWF0dXJlLlxuICovXG5mdW5jdGlvbiBnZXRGZWF0dXJlRnJvbUV2ZW50KGV2dCkge1xuICBpZiAoLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9zb3VyY2UvVmVjdG9yLmpzXCIpLlZlY3RvclNvdXJjZUV2ZW50fSAqLyAoZXZ0KS5mZWF0dXJlKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vc291cmNlL1ZlY3Rvci5qc1wiKS5WZWN0b3JTb3VyY2VFdmVudH0gKi8gKGV2dCkuZmVhdHVyZTtcbiAgfSBlbHNlIGlmICgvKiogQHR5cGUge2ltcG9ydChcIi4uL0NvbGxlY3Rpb24uanNcIikuQ29sbGVjdGlvbkV2ZW50fSAqLyAoZXZ0KS5lbGVtZW50KSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSAqLyAoLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9Db2xsZWN0aW9uLmpzXCIpLkNvbGxlY3Rpb25FdmVudH0gKi8gKGV2dCkuZWxlbWVudCk7XG4gIH1cblxufVxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEhhbmRsZXMgc25hcHBpbmcgb2YgdmVjdG9yIGZlYXR1cmVzIHdoaWxlIG1vZGlmeWluZyBvciBkcmF3aW5nIHRoZW0uICBUaGVcbiAqIGZlYXR1cmVzIGNhbiBjb21lIGZyb20gYSB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3J9IG9yIHtAbGluayBtb2R1bGU6b2wvQ29sbGVjdGlvbn5Db2xsZWN0aW9ufVxuICogQW55IGludGVyYWN0aW9uIG9iamVjdCB0aGF0IGFsbG93cyB0aGUgdXNlciB0byBpbnRlcmFjdFxuICogd2l0aCB0aGUgZmVhdHVyZXMgdXNpbmcgdGhlIG1vdXNlIGNhbiBiZW5lZml0IGZyb20gdGhlIHNuYXBwaW5nLCBhcyBsb25nXG4gKiBhcyBpdCBpcyBhZGRlZCBiZWZvcmUuXG4gKlxuICogVGhlIHNuYXAgaW50ZXJhY3Rpb24gbW9kaWZpZXMgbWFwIGJyb3dzZXIgZXZlbnQgYGNvb3JkaW5hdGVgIGFuZCBgcGl4ZWxgXG4gKiBwcm9wZXJ0aWVzIHRvIGZvcmNlIHRoZSBzbmFwIHRvIG9jY3VyIHRvIGFueSBpbnRlcmFjdGlvbiB0aGF0IHRoZW0uXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgaW1wb3J0IFNuYXAgZnJvbSAnb2wvaW50ZXJhY3Rpb24vU25hcCc7XG4gKlxuICogICAgIHZhciBzbmFwID0gbmV3IFNuYXAoe1xuICogICAgICAgc291cmNlOiBzb3VyY2VcbiAqICAgICB9KTtcbiAqXG4gKiBAYXBpXG4gKi9cbnZhciBTbmFwID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoUG9pbnRlckludGVyYWN0aW9uKSB7XG4gIGZ1bmN0aW9uIFNuYXAob3B0X29wdGlvbnMpIHtcblxuICAgIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgPyBvcHRfb3B0aW9ucyA6IHt9O1xuXG4gICAgdmFyIHBvaW50ZXJPcHRpb25zID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL1BvaW50ZXIuanNcIikuT3B0aW9uc30gKi8gKG9wdGlvbnMpO1xuXG4gICAgaWYgKCFwb2ludGVyT3B0aW9ucy5oYW5kbGVEb3duRXZlbnQpIHtcbiAgICAgIHBvaW50ZXJPcHRpb25zLmhhbmRsZURvd25FdmVudCA9IFRSVUU7XG4gICAgfVxuXG4gICAgaWYgKCFwb2ludGVyT3B0aW9ucy5zdG9wRG93bikge1xuICAgICAgcG9pbnRlck9wdGlvbnMuc3RvcERvd24gPSBGQUxTRTtcbiAgICB9XG5cbiAgICBQb2ludGVySW50ZXJhY3Rpb24uY2FsbCh0aGlzLCBwb2ludGVyT3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vc291cmNlL1ZlY3Rvci5qc1wiKS5kZWZhdWx0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5zb3VyY2VfID0gb3B0aW9ucy5zb3VyY2UgPyBvcHRpb25zLnNvdXJjZSA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMudmVydGV4XyA9IG9wdGlvbnMudmVydGV4ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnZlcnRleCA6IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZWRnZV8gPSBvcHRpb25zLmVkZ2UgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZWRnZSA6IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vQ29sbGVjdGlvbi5qc1wiKS5kZWZhdWx0PGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmZlYXR1cmVzXyA9IG9wdGlvbnMuZmVhdHVyZXMgPyBvcHRpb25zLmZlYXR1cmVzIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuLi9ldmVudHMuanNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZmVhdHVyZXNMaXN0ZW5lcktleXNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleT59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmZlYXR1cmVDaGFuZ2VMaXN0ZW5lcktleXNfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBFeHRlbnRzIGFyZSBwcmVzZXJ2ZWQgc28gaW5kZXhlZCBzZWdtZW50IGNhbiBiZSBxdWlja2x5IHJlbW92ZWRcbiAgICAgKiB3aGVuIGl0cyBmZWF0dXJlIGdlb21ldHJ5IGNoYW5nZXNcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudD59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmluZGV4ZWRGZWF0dXJlc0V4dGVudHNfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBJZiBhIGZlYXR1cmUgZ2VvbWV0cnkgY2hhbmdlcyB3aGlsZSBhIHBvaW50ZXIgZHJhZ3xtb3ZlIGV2ZW50IG9jY3VycywgdGhlXG4gICAgICogZmVhdHVyZSBkb2Vzbid0IGdldCB1cGRhdGVkIHJpZ2h0IGF3YXkuICBJdCB3aWxsIGJlIGF0IHRoZSBuZXh0ICdwb2ludGVydXAnXG4gICAgICogZXZlbnQgZmlyZWQuXG4gICAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5wZW5kaW5nRmVhdHVyZXNfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBkaXN0YW5jZSBzb3J0aW5nIGluIHNvcnRCeURpc3RhbmNlX1xuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnBpeGVsQ29vcmRpbmF0ZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucGl4ZWxUb2xlcmFuY2VfID0gb3B0aW9ucy5waXhlbFRvbGVyYW5jZSAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdGlvbnMucGl4ZWxUb2xlcmFuY2UgOiAxMDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbihTZWdtZW50RGF0YSwgU2VnbWVudERhdGEpOiBudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnNvcnRCeURpc3RhbmNlXyA9IHNvcnRCeURpc3RhbmNlLmJpbmQodGhpcyk7XG5cblxuICAgIC8qKlxuICAgICogU2VnbWVudCBSVHJlZSBmb3IgZWFjaCBsYXllclxuICAgICogQHR5cGUge2ltcG9ydChcIi4uL3N0cnVjdHMvUkJ1c2guanNcIikuZGVmYXVsdDxTZWdtZW50RGF0YT59XG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgdGhpcy5yQnVzaF8gPSBuZXcgUkJ1c2goKTtcblxuXG4gICAgLyoqXG4gICAgKiBAY29uc3RcbiAgICAqIEBwcml2YXRlXG4gICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgZnVuY3Rpb24oaW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0LCBpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHQpPn1cbiAgICAqL1xuICAgIHRoaXMuU0VHTUVOVF9XUklURVJTXyA9IHtcbiAgICAgICdQb2ludCc6IHRoaXMud3JpdGVQb2ludEdlb21ldHJ5XyxcbiAgICAgICdMaW5lU3RyaW5nJzogdGhpcy53cml0ZUxpbmVTdHJpbmdHZW9tZXRyeV8sXG4gICAgICAnTGluZWFyUmluZyc6IHRoaXMud3JpdGVMaW5lU3RyaW5nR2VvbWV0cnlfLFxuICAgICAgJ1BvbHlnb24nOiB0aGlzLndyaXRlUG9seWdvbkdlb21ldHJ5XyxcbiAgICAgICdNdWx0aVBvaW50JzogdGhpcy53cml0ZU11bHRpUG9pbnRHZW9tZXRyeV8sXG4gICAgICAnTXVsdGlMaW5lU3RyaW5nJzogdGhpcy53cml0ZU11bHRpTGluZVN0cmluZ0dlb21ldHJ5XyxcbiAgICAgICdNdWx0aVBvbHlnb24nOiB0aGlzLndyaXRlTXVsdGlQb2x5Z29uR2VvbWV0cnlfLFxuICAgICAgJ0dlb21ldHJ5Q29sbGVjdGlvbic6IHRoaXMud3JpdGVHZW9tZXRyeUNvbGxlY3Rpb25HZW9tZXRyeV8sXG4gICAgICAnQ2lyY2xlJzogdGhpcy53cml0ZUNpcmNsZUdlb21ldHJ5X1xuICAgIH07XG4gIH1cblxuICBpZiAoIFBvaW50ZXJJbnRlcmFjdGlvbiApIFNuYXAuX19wcm90b19fID0gUG9pbnRlckludGVyYWN0aW9uO1xuICBTbmFwLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBvaW50ZXJJbnRlcmFjdGlvbiAmJiBQb2ludGVySW50ZXJhY3Rpb24ucHJvdG90eXBlICk7XG4gIFNuYXAucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU25hcDtcblxuICAvKipcbiAgICogQWRkIGEgZmVhdHVyZSB0byB0aGUgY29sbGVjdGlvbiBvZiBmZWF0dXJlcyB0aGF0IHdlIG1heSBzbmFwIHRvLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfbGlzdGVuIFdoZXRoZXIgdG8gbGlzdGVuIHRvIHRoZSBmZWF0dXJlIGNoYW5nZSBvciBub3RcbiAgICogICAgIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAgICogQGFwaVxuICAgKi9cbiAgU25hcC5wcm90b3R5cGUuYWRkRmVhdHVyZSA9IGZ1bmN0aW9uIGFkZEZlYXR1cmUgKGZlYXR1cmUsIG9wdF9saXN0ZW4pIHtcbiAgICB2YXIgcmVnaXN0ZXIgPSBvcHRfbGlzdGVuICE9PSB1bmRlZmluZWQgPyBvcHRfbGlzdGVuIDogdHJ1ZTtcbiAgICB2YXIgZmVhdHVyZV91aWQgPSBnZXRVaWQoZmVhdHVyZSk7XG4gICAgdmFyIGdlb21ldHJ5ID0gZmVhdHVyZS5nZXRHZW9tZXRyeSgpO1xuICAgIGlmIChnZW9tZXRyeSkge1xuICAgICAgdmFyIHNlZ21lbnRXcml0ZXIgPSB0aGlzLlNFR01FTlRfV1JJVEVSU19bZ2VvbWV0cnkuZ2V0VHlwZSgpXTtcbiAgICAgIGlmIChzZWdtZW50V3JpdGVyKSB7XG4gICAgICAgIHRoaXMuaW5kZXhlZEZlYXR1cmVzRXh0ZW50c19bZmVhdHVyZV91aWRdID0gZ2VvbWV0cnkuZ2V0RXh0ZW50KGNyZWF0ZUVtcHR5KCkpO1xuICAgICAgICBzZWdtZW50V3JpdGVyLmNhbGwodGhpcywgZmVhdHVyZSwgZ2VvbWV0cnkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZWdpc3Rlcikge1xuICAgICAgdGhpcy5mZWF0dXJlQ2hhbmdlTGlzdGVuZXJLZXlzX1tmZWF0dXJlX3VpZF0gPSBsaXN0ZW4oXG4gICAgICAgIGZlYXR1cmUsXG4gICAgICAgIEV2ZW50VHlwZS5DSEFOR0UsXG4gICAgICAgIHRoaXMuaGFuZGxlRmVhdHVyZUNoYW5nZV8sIHRoaXMpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFNuYXAucHJvdG90eXBlLmZvckVhY2hGZWF0dXJlQWRkXyA9IGZ1bmN0aW9uIGZvckVhY2hGZWF0dXJlQWRkXyAoZmVhdHVyZSkge1xuICAgIHRoaXMuYWRkRmVhdHVyZShmZWF0dXJlKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFNuYXAucHJvdG90eXBlLmZvckVhY2hGZWF0dXJlUmVtb3ZlXyA9IGZ1bmN0aW9uIGZvckVhY2hGZWF0dXJlUmVtb3ZlXyAoZmVhdHVyZSkge1xuICAgIHRoaXMucmVtb3ZlRmVhdHVyZShmZWF0dXJlKTtcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vQ29sbGVjdGlvbi5qc1wiKS5kZWZhdWx0PGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD58QXJyYXk8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn0gRmVhdHVyZXMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBTbmFwLnByb3RvdHlwZS5nZXRGZWF0dXJlc18gPSBmdW5jdGlvbiBnZXRGZWF0dXJlc18gKCkge1xuICAgIHZhciBmZWF0dXJlcztcbiAgICBpZiAodGhpcy5mZWF0dXJlc18pIHtcbiAgICAgIGZlYXR1cmVzID0gdGhpcy5mZWF0dXJlc187XG4gICAgfSBlbHNlIGlmICh0aGlzLnNvdXJjZV8pIHtcbiAgICAgIGZlYXR1cmVzID0gdGhpcy5zb3VyY2VfLmdldEZlYXR1cmVzKCk7XG4gICAgfVxuICAgIHJldHVybiBmZWF0dXJlcztcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIFNuYXAucHJvdG90eXBlLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24gaGFuZGxlRXZlbnQgKGV2dCkge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLnNuYXBUbyhldnQucGl4ZWwsIGV2dC5jb29yZGluYXRlLCBldnQubWFwKTtcbiAgICBpZiAocmVzdWx0LnNuYXBwZWQpIHtcbiAgICAgIGV2dC5jb29yZGluYXRlID0gcmVzdWx0LnZlcnRleC5zbGljZSgwLCAyKTtcbiAgICAgIGV2dC5waXhlbCA9IHJlc3VsdC52ZXJ0ZXhQaXhlbDtcbiAgICB9XG4gICAgcmV0dXJuIFBvaW50ZXJJbnRlcmFjdGlvbi5wcm90b3R5cGUuaGFuZGxlRXZlbnQuY2FsbCh0aGlzLCBldnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3NvdXJjZS9WZWN0b3IuanNcIikuVmVjdG9yU291cmNlRXZlbnR8aW1wb3J0KFwiLi4vQ29sbGVjdGlvbi5qc1wiKS5Db2xsZWN0aW9uRXZlbnR9IGV2dCBFdmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFNuYXAucHJvdG90eXBlLmhhbmRsZUZlYXR1cmVBZGRfID0gZnVuY3Rpb24gaGFuZGxlRmVhdHVyZUFkZF8gKGV2dCkge1xuICAgIHZhciBmZWF0dXJlID0gZ2V0RmVhdHVyZUZyb21FdmVudChldnQpO1xuICAgIHRoaXMuYWRkRmVhdHVyZShmZWF0dXJlKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zb3VyY2UvVmVjdG9yLmpzXCIpLlZlY3RvclNvdXJjZUV2ZW50fGltcG9ydChcIi4uL0NvbGxlY3Rpb24uanNcIikuQ29sbGVjdGlvbkV2ZW50fSBldnQgRXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBTbmFwLnByb3RvdHlwZS5oYW5kbGVGZWF0dXJlUmVtb3ZlXyA9IGZ1bmN0aW9uIGhhbmRsZUZlYXR1cmVSZW1vdmVfIChldnQpIHtcbiAgICB2YXIgZmVhdHVyZSA9IGdldEZlYXR1cmVGcm9tRXZlbnQoZXZ0KTtcbiAgICB0aGlzLnJlbW92ZUZlYXR1cmUoZmVhdHVyZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHR9IGV2dCBFdmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFNuYXAucHJvdG90eXBlLmhhbmRsZUZlYXR1cmVDaGFuZ2VfID0gZnVuY3Rpb24gaGFuZGxlRmVhdHVyZUNoYW5nZV8gKGV2dCkge1xuICAgIHZhciBmZWF0dXJlID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9ICovIChldnQudGFyZ2V0KTtcbiAgICBpZiAodGhpcy5oYW5kbGluZ0Rvd25VcFNlcXVlbmNlKSB7XG4gICAgICB2YXIgdWlkID0gZ2V0VWlkKGZlYXR1cmUpO1xuICAgICAgaWYgKCEodWlkIGluIHRoaXMucGVuZGluZ0ZlYXR1cmVzXykpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nRmVhdHVyZXNfW3VpZF0gPSBmZWF0dXJlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVwZGF0ZUZlYXR1cmVfKGZlYXR1cmUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIFNuYXAucHJvdG90eXBlLmhhbmRsZVVwRXZlbnQgPSBmdW5jdGlvbiBoYW5kbGVVcEV2ZW50IChldnQpIHtcbiAgICB2YXIgZmVhdHVyZXNUb1VwZGF0ZSA9IGdldFZhbHVlcyh0aGlzLnBlbmRpbmdGZWF0dXJlc18pO1xuICAgIGlmIChmZWF0dXJlc1RvVXBkYXRlLmxlbmd0aCkge1xuICAgICAgZmVhdHVyZXNUb1VwZGF0ZS5mb3JFYWNoKHRoaXMudXBkYXRlRmVhdHVyZV8uYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLnBlbmRpbmdGZWF0dXJlc18gPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBmZWF0dXJlIGZyb20gdGhlIGNvbGxlY3Rpb24gb2YgZmVhdHVyZXMgdGhhdCB3ZSBtYXkgc25hcCB0by5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfdW5saXN0ZW4gV2hldGhlciB0byB1bmxpc3RlbiB0byB0aGUgZmVhdHVyZSBjaGFuZ2VcbiAgICogICAgIG9yIG5vdC4gRGVmYXVsdHMgdG8gYHRydWVgLlxuICAgKiBAYXBpXG4gICAqL1xuICBTbmFwLnByb3RvdHlwZS5yZW1vdmVGZWF0dXJlID0gZnVuY3Rpb24gcmVtb3ZlRmVhdHVyZSAoZmVhdHVyZSwgb3B0X3VubGlzdGVuKSB7XG4gICAgdmFyIHVucmVnaXN0ZXIgPSBvcHRfdW5saXN0ZW4gIT09IHVuZGVmaW5lZCA/IG9wdF91bmxpc3RlbiA6IHRydWU7XG4gICAgdmFyIGZlYXR1cmVfdWlkID0gZ2V0VWlkKGZlYXR1cmUpO1xuICAgIHZhciBleHRlbnQgPSB0aGlzLmluZGV4ZWRGZWF0dXJlc0V4dGVudHNfW2ZlYXR1cmVfdWlkXTtcbiAgICBpZiAoZXh0ZW50KSB7XG4gICAgICB2YXIgckJ1c2ggPSB0aGlzLnJCdXNoXztcbiAgICAgIHZhciBub2Rlc1RvUmVtb3ZlID0gW107XG4gICAgICByQnVzaC5mb3JFYWNoSW5FeHRlbnQoZXh0ZW50LCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIGlmIChmZWF0dXJlID09PSBub2RlLmZlYXR1cmUpIHtcbiAgICAgICAgICBub2Rlc1RvUmVtb3ZlLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZm9yICh2YXIgaSA9IG5vZGVzVG9SZW1vdmUubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgckJ1c2gucmVtb3ZlKG5vZGVzVG9SZW1vdmVbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh1bnJlZ2lzdGVyKSB7XG4gICAgICB1bmxpc3RlbkJ5S2V5KHRoaXMuZmVhdHVyZUNoYW5nZUxpc3RlbmVyS2V5c19bZmVhdHVyZV91aWRdKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmZlYXR1cmVDaGFuZ2VMaXN0ZW5lcktleXNfW2ZlYXR1cmVfdWlkXTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBTbmFwLnByb3RvdHlwZS5zZXRNYXAgPSBmdW5jdGlvbiBzZXRNYXAgKG1hcCkge1xuICAgIHZhciBjdXJyZW50TWFwID0gdGhpcy5nZXRNYXAoKTtcbiAgICB2YXIga2V5cyA9IHRoaXMuZmVhdHVyZXNMaXN0ZW5lcktleXNfO1xuICAgIHZhciBmZWF0dXJlcyA9IC8qKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn0gKi8gKHRoaXMuZ2V0RmVhdHVyZXNfKCkpO1xuXG4gICAgaWYgKGN1cnJlbnRNYXApIHtcbiAgICAgIGtleXMuZm9yRWFjaCh1bmxpc3RlbkJ5S2V5KTtcbiAgICAgIGtleXMubGVuZ3RoID0gMDtcbiAgICAgIGZlYXR1cmVzLmZvckVhY2godGhpcy5mb3JFYWNoRmVhdHVyZVJlbW92ZV8uYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIFBvaW50ZXJJbnRlcmFjdGlvbi5wcm90b3R5cGUuc2V0TWFwLmNhbGwodGhpcywgbWFwKTtcblxuICAgIGlmIChtYXApIHtcbiAgICAgIGlmICh0aGlzLmZlYXR1cmVzXykge1xuICAgICAgICBrZXlzLnB1c2goXG4gICAgICAgICAgbGlzdGVuKHRoaXMuZmVhdHVyZXNfLCBDb2xsZWN0aW9uRXZlbnRUeXBlLkFERCxcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRmVhdHVyZUFkZF8sIHRoaXMpLFxuICAgICAgICAgIGxpc3Rlbih0aGlzLmZlYXR1cmVzXywgQ29sbGVjdGlvbkV2ZW50VHlwZS5SRU1PVkUsXG4gICAgICAgICAgICB0aGlzLmhhbmRsZUZlYXR1cmVSZW1vdmVfLCB0aGlzKVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnNvdXJjZV8pIHtcbiAgICAgICAga2V5cy5wdXNoKFxuICAgICAgICAgIGxpc3Rlbih0aGlzLnNvdXJjZV8sIFZlY3RvckV2ZW50VHlwZS5BRERGRUFUVVJFLFxuICAgICAgICAgICAgdGhpcy5oYW5kbGVGZWF0dXJlQWRkXywgdGhpcyksXG4gICAgICAgICAgbGlzdGVuKHRoaXMuc291cmNlXywgVmVjdG9yRXZlbnRUeXBlLlJFTU9WRUZFQVRVUkUsXG4gICAgICAgICAgICB0aGlzLmhhbmRsZUZlYXR1cmVSZW1vdmVfLCB0aGlzKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZmVhdHVyZXMuZm9yRWFjaCh0aGlzLmZvckVhY2hGZWF0dXJlQWRkXy5iaW5kKHRoaXMpKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcGl4ZWwuanNcIikuUGl4ZWx9IHBpeGVsIFBpeGVsXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBwaXhlbENvb3JkaW5hdGUgQ29vcmRpbmF0ZVxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1BsdWdnYWJsZU1hcC5qc1wiKS5kZWZhdWx0fSBtYXAgTWFwLlxuICAgKiBAcmV0dXJuIHtSZXN1bHR9IFNuYXAgcmVzdWx0XG4gICAqL1xuICBTbmFwLnByb3RvdHlwZS5zbmFwVG8gPSBmdW5jdGlvbiBzbmFwVG8gKHBpeGVsLCBwaXhlbENvb3JkaW5hdGUsIG1hcCkge1xuXG4gICAgdmFyIGxvd2VyTGVmdCA9IG1hcC5nZXRDb29yZGluYXRlRnJvbVBpeGVsKFxuICAgICAgW3BpeGVsWzBdIC0gdGhpcy5waXhlbFRvbGVyYW5jZV8sIHBpeGVsWzFdICsgdGhpcy5waXhlbFRvbGVyYW5jZV9dKTtcbiAgICB2YXIgdXBwZXJSaWdodCA9IG1hcC5nZXRDb29yZGluYXRlRnJvbVBpeGVsKFxuICAgICAgW3BpeGVsWzBdICsgdGhpcy5waXhlbFRvbGVyYW5jZV8sIHBpeGVsWzFdIC0gdGhpcy5waXhlbFRvbGVyYW5jZV9dKTtcbiAgICB2YXIgYm94ID0gYm91bmRpbmdFeHRlbnQoW2xvd2VyTGVmdCwgdXBwZXJSaWdodF0pO1xuXG4gICAgdmFyIHNlZ21lbnRzID0gdGhpcy5yQnVzaF8uZ2V0SW5FeHRlbnQoYm94KTtcblxuICAgIC8vIElmIHNuYXBwaW5nIG9uIHZlcnRpY2VzIG9ubHksIGRvbid0IGNvbnNpZGVyIGNpcmNsZXNcbiAgICBpZiAodGhpcy52ZXJ0ZXhfICYmICF0aGlzLmVkZ2VfKSB7XG4gICAgICBzZWdtZW50cyA9IHNlZ21lbnRzLmZpbHRlcihmdW5jdGlvbihzZWdtZW50KSB7XG4gICAgICAgIHJldHVybiBzZWdtZW50LmZlYXR1cmUuZ2V0R2VvbWV0cnkoKS5nZXRUeXBlKCkgIT09XG4gICAgICAgICAgICBHZW9tZXRyeVR5cGUuQ0lSQ0xFO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIHNuYXBwZWRUb1ZlcnRleCA9IGZhbHNlO1xuICAgIHZhciBzbmFwcGVkID0gZmFsc2U7XG4gICAgdmFyIHZlcnRleCA9IG51bGw7XG4gICAgdmFyIHZlcnRleFBpeGVsID0gbnVsbDtcbiAgICB2YXIgZGlzdCwgcGl4ZWwxLCBwaXhlbDIsIHNxdWFyZWREaXN0MSwgc3F1YXJlZERpc3QyO1xuICAgIGlmIChzZWdtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnBpeGVsQ29vcmRpbmF0ZV8gPSBwaXhlbENvb3JkaW5hdGU7XG4gICAgICBzZWdtZW50cy5zb3J0KHRoaXMuc29ydEJ5RGlzdGFuY2VfKTtcbiAgICAgIHZhciBjbG9zZXN0U2VnbWVudCA9IHNlZ21lbnRzWzBdLnNlZ21lbnQ7XG4gICAgICB2YXIgaXNDaXJjbGUgPSBzZWdtZW50c1swXS5mZWF0dXJlLmdldEdlb21ldHJ5KCkuZ2V0VHlwZSgpID09PVxuICAgICAgICAgIEdlb21ldHJ5VHlwZS5DSVJDTEU7XG4gICAgICBpZiAodGhpcy52ZXJ0ZXhfICYmICF0aGlzLmVkZ2VfKSB7XG4gICAgICAgIHBpeGVsMSA9IG1hcC5nZXRQaXhlbEZyb21Db29yZGluYXRlKGNsb3Nlc3RTZWdtZW50WzBdKTtcbiAgICAgICAgcGl4ZWwyID0gbWFwLmdldFBpeGVsRnJvbUNvb3JkaW5hdGUoY2xvc2VzdFNlZ21lbnRbMV0pO1xuICAgICAgICBzcXVhcmVkRGlzdDEgPSBzcXVhcmVkQ29vcmRpbmF0ZURpc3RhbmNlKHBpeGVsLCBwaXhlbDEpO1xuICAgICAgICBzcXVhcmVkRGlzdDIgPSBzcXVhcmVkQ29vcmRpbmF0ZURpc3RhbmNlKHBpeGVsLCBwaXhlbDIpO1xuICAgICAgICBkaXN0ID0gTWF0aC5zcXJ0KE1hdGgubWluKHNxdWFyZWREaXN0MSwgc3F1YXJlZERpc3QyKSk7XG4gICAgICAgIHNuYXBwZWRUb1ZlcnRleCA9IGRpc3QgPD0gdGhpcy5waXhlbFRvbGVyYW5jZV87XG4gICAgICAgIGlmIChzbmFwcGVkVG9WZXJ0ZXgpIHtcbiAgICAgICAgICBzbmFwcGVkID0gdHJ1ZTtcbiAgICAgICAgICB2ZXJ0ZXggPSBzcXVhcmVkRGlzdDEgPiBzcXVhcmVkRGlzdDIgPyBjbG9zZXN0U2VnbWVudFsxXSA6IGNsb3Nlc3RTZWdtZW50WzBdO1xuICAgICAgICAgIHZlcnRleFBpeGVsID0gbWFwLmdldFBpeGVsRnJvbUNvb3JkaW5hdGUodmVydGV4KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLmVkZ2VfKSB7XG4gICAgICAgIGlmIChpc0NpcmNsZSkge1xuICAgICAgICAgIHZlcnRleCA9IGNsb3Nlc3RPbkNpcmNsZShwaXhlbENvb3JkaW5hdGUsXG4gICAgICAgICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uL2dlb20vQ2lyY2xlLmpzXCIpLmRlZmF1bHR9ICovIChzZWdtZW50c1swXS5mZWF0dXJlLmdldEdlb21ldHJ5KCkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2ZXJ0ZXggPSBjbG9zZXN0T25TZWdtZW50KHBpeGVsQ29vcmRpbmF0ZSwgY2xvc2VzdFNlZ21lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHZlcnRleFBpeGVsID0gbWFwLmdldFBpeGVsRnJvbUNvb3JkaW5hdGUodmVydGV4KTtcbiAgICAgICAgaWYgKGNvb3JkaW5hdGVEaXN0YW5jZShwaXhlbCwgdmVydGV4UGl4ZWwpIDw9IHRoaXMucGl4ZWxUb2xlcmFuY2VfKSB7XG4gICAgICAgICAgc25hcHBlZCA9IHRydWU7XG4gICAgICAgICAgaWYgKHRoaXMudmVydGV4XyAmJiAhaXNDaXJjbGUpIHtcbiAgICAgICAgICAgIHBpeGVsMSA9IG1hcC5nZXRQaXhlbEZyb21Db29yZGluYXRlKGNsb3Nlc3RTZWdtZW50WzBdKTtcbiAgICAgICAgICAgIHBpeGVsMiA9IG1hcC5nZXRQaXhlbEZyb21Db29yZGluYXRlKGNsb3Nlc3RTZWdtZW50WzFdKTtcbiAgICAgICAgICAgIHNxdWFyZWREaXN0MSA9IHNxdWFyZWRDb29yZGluYXRlRGlzdGFuY2UodmVydGV4UGl4ZWwsIHBpeGVsMSk7XG4gICAgICAgICAgICBzcXVhcmVkRGlzdDIgPSBzcXVhcmVkQ29vcmRpbmF0ZURpc3RhbmNlKHZlcnRleFBpeGVsLCBwaXhlbDIpO1xuICAgICAgICAgICAgZGlzdCA9IE1hdGguc3FydChNYXRoLm1pbihzcXVhcmVkRGlzdDEsIHNxdWFyZWREaXN0MikpO1xuICAgICAgICAgICAgc25hcHBlZFRvVmVydGV4ID0gZGlzdCA8PSB0aGlzLnBpeGVsVG9sZXJhbmNlXztcbiAgICAgICAgICAgIGlmIChzbmFwcGVkVG9WZXJ0ZXgpIHtcbiAgICAgICAgICAgICAgdmVydGV4ID0gc3F1YXJlZERpc3QxID4gc3F1YXJlZERpc3QyID8gY2xvc2VzdFNlZ21lbnRbMV0gOiBjbG9zZXN0U2VnbWVudFswXTtcbiAgICAgICAgICAgICAgdmVydGV4UGl4ZWwgPSBtYXAuZ2V0UGl4ZWxGcm9tQ29vcmRpbmF0ZSh2ZXJ0ZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNuYXBwZWQpIHtcbiAgICAgICAgdmVydGV4UGl4ZWwgPSBbTWF0aC5yb3VuZCh2ZXJ0ZXhQaXhlbFswXSksIE1hdGgucm91bmQodmVydGV4UGl4ZWxbMV0pXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAgIC8qKiBAdHlwZSB7UmVzdWx0fSAqLyAoe1xuICAgICAgICBzbmFwcGVkOiBzbmFwcGVkLFxuICAgICAgICB2ZXJ0ZXg6IHZlcnRleCxcbiAgICAgICAgdmVydGV4UGl4ZWw6IHZlcnRleFBpeGVsXG4gICAgICB9KVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFNuYXAucHJvdG90eXBlLnVwZGF0ZUZlYXR1cmVfID0gZnVuY3Rpb24gdXBkYXRlRmVhdHVyZV8gKGZlYXR1cmUpIHtcbiAgICB0aGlzLnJlbW92ZUZlYXR1cmUoZmVhdHVyZSwgZmFsc2UpO1xuICAgIHRoaXMuYWRkRmVhdHVyZShmZWF0dXJlLCBmYWxzZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmVcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL0NpcmNsZS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFNuYXAucHJvdG90eXBlLndyaXRlQ2lyY2xlR2VvbWV0cnlfID0gZnVuY3Rpb24gd3JpdGVDaXJjbGVHZW9tZXRyeV8gKGZlYXR1cmUsIGdlb21ldHJ5KSB7XG4gICAgdmFyIHBvbHlnb24gPSBmcm9tQ2lyY2xlKGdlb21ldHJ5KTtcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBwb2x5Z29uLmdldENvb3JkaW5hdGVzKClbMF07XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoIC0gMTsgaSA8IGlpOyArK2kpIHtcbiAgICAgIHZhciBzZWdtZW50ID0gY29vcmRpbmF0ZXMuc2xpY2UoaSwgaSArIDIpO1xuICAgICAgdmFyIHNlZ21lbnREYXRhID0gLyoqIEB0eXBlIHtTZWdtZW50RGF0YX0gKi8gKHtcbiAgICAgICAgZmVhdHVyZTogZmVhdHVyZSxcbiAgICAgICAgc2VnbWVudDogc2VnbWVudFxuICAgICAgfSk7XG4gICAgICB0aGlzLnJCdXNoXy5pbnNlcnQoYm91bmRpbmdFeHRlbnQoc2VnbWVudCksIHNlZ21lbnREYXRhKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmVcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5Q29sbGVjdGlvbi5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFNuYXAucHJvdG90eXBlLndyaXRlR2VvbWV0cnlDb2xsZWN0aW9uR2VvbWV0cnlfID0gZnVuY3Rpb24gd3JpdGVHZW9tZXRyeUNvbGxlY3Rpb25HZW9tZXRyeV8gKGZlYXR1cmUsIGdlb21ldHJ5KSB7XG4gICAgdmFyIGdlb21ldHJpZXMgPSBnZW9tZXRyeS5nZXRHZW9tZXRyaWVzQXJyYXkoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdlb21ldHJpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBzZWdtZW50V3JpdGVyID0gdGhpcy5TRUdNRU5UX1dSSVRFUlNfW2dlb21ldHJpZXNbaV0uZ2V0VHlwZSgpXTtcbiAgICAgIGlmIChzZWdtZW50V3JpdGVyKSB7XG4gICAgICAgIHNlZ21lbnRXcml0ZXIuY2FsbCh0aGlzLCBmZWF0dXJlLCBnZW9tZXRyaWVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmVcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL0xpbmVTdHJpbmcuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBTbmFwLnByb3RvdHlwZS53cml0ZUxpbmVTdHJpbmdHZW9tZXRyeV8gPSBmdW5jdGlvbiB3cml0ZUxpbmVTdHJpbmdHZW9tZXRyeV8gKGZlYXR1cmUsIGdlb21ldHJ5KSB7XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBjb29yZGluYXRlcy5sZW5ndGggLSAxOyBpIDwgaWk7ICsraSkge1xuICAgICAgdmFyIHNlZ21lbnQgPSBjb29yZGluYXRlcy5zbGljZShpLCBpICsgMik7XG4gICAgICB2YXIgc2VnbWVudERhdGEgPSAvKiogQHR5cGUge1NlZ21lbnREYXRhfSAqLyAoe1xuICAgICAgICBmZWF0dXJlOiBmZWF0dXJlLFxuICAgICAgICBzZWdtZW50OiBzZWdtZW50XG4gICAgICB9KTtcbiAgICAgIHRoaXMuckJ1c2hfLmluc2VydChib3VuZGluZ0V4dGVudChzZWdtZW50KSwgc2VnbWVudERhdGEpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZVxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vTXVsdGlMaW5lU3RyaW5nLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgU25hcC5wcm90b3R5cGUud3JpdGVNdWx0aUxpbmVTdHJpbmdHZW9tZXRyeV8gPSBmdW5jdGlvbiB3cml0ZU11bHRpTGluZVN0cmluZ0dlb21ldHJ5XyAoZmVhdHVyZSwgZ2VvbWV0cnkpIHtcbiAgICB2YXIgbGluZXMgPSBnZW9tZXRyeS5nZXRDb29yZGluYXRlcygpO1xuICAgIGZvciAodmFyIGogPSAwLCBqaiA9IGxpbmVzLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICAgIHZhciBjb29yZGluYXRlcyA9IGxpbmVzW2pdO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoIC0gMTsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgdmFyIHNlZ21lbnQgPSBjb29yZGluYXRlcy5zbGljZShpLCBpICsgMik7XG4gICAgICAgIHZhciBzZWdtZW50RGF0YSA9IC8qKiBAdHlwZSB7U2VnbWVudERhdGF9ICovICh7XG4gICAgICAgICAgZmVhdHVyZTogZmVhdHVyZSxcbiAgICAgICAgICBzZWdtZW50OiBzZWdtZW50XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJCdXNoXy5pbnNlcnQoYm91bmRpbmdFeHRlbnQoc2VnbWVudCksIHNlZ21lbnREYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmVcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL011bHRpUG9pbnQuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBTbmFwLnByb3RvdHlwZS53cml0ZU11bHRpUG9pbnRHZW9tZXRyeV8gPSBmdW5jdGlvbiB3cml0ZU11bHRpUG9pbnRHZW9tZXRyeV8gKGZlYXR1cmUsIGdlb21ldHJ5KSB7XG4gICAgdmFyIHBvaW50cyA9IGdlb21ldHJ5LmdldENvb3JkaW5hdGVzKCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIHZhciBjb29yZGluYXRlcyA9IHBvaW50c1tpXTtcbiAgICAgIHZhciBzZWdtZW50RGF0YSA9IC8qKiBAdHlwZSB7U2VnbWVudERhdGF9ICovICh7XG4gICAgICAgIGZlYXR1cmU6IGZlYXR1cmUsXG4gICAgICAgIHNlZ21lbnQ6IFtjb29yZGluYXRlcywgY29vcmRpbmF0ZXNdXG4gICAgICB9KTtcbiAgICAgIHRoaXMuckJ1c2hfLmluc2VydChnZW9tZXRyeS5nZXRFeHRlbnQoKSwgc2VnbWVudERhdGEpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZVxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vTXVsdGlQb2x5Z29uLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgU25hcC5wcm90b3R5cGUud3JpdGVNdWx0aVBvbHlnb25HZW9tZXRyeV8gPSBmdW5jdGlvbiB3cml0ZU11bHRpUG9seWdvbkdlb21ldHJ5XyAoZmVhdHVyZSwgZ2VvbWV0cnkpIHtcbiAgICB2YXIgcG9seWdvbnMgPSBnZW9tZXRyeS5nZXRDb29yZGluYXRlcygpO1xuICAgIGZvciAodmFyIGsgPSAwLCBrayA9IHBvbHlnb25zLmxlbmd0aDsgayA8IGtrOyArK2spIHtcbiAgICAgIHZhciByaW5ncyA9IHBvbHlnb25zW2tdO1xuICAgICAgZm9yICh2YXIgaiA9IDAsIGpqID0gcmluZ3MubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSByaW5nc1tqXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoIC0gMTsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICB2YXIgc2VnbWVudCA9IGNvb3JkaW5hdGVzLnNsaWNlKGksIGkgKyAyKTtcbiAgICAgICAgICB2YXIgc2VnbWVudERhdGEgPSAvKiogQHR5cGUge1NlZ21lbnREYXRhfSAqLyAoe1xuICAgICAgICAgICAgZmVhdHVyZTogZmVhdHVyZSxcbiAgICAgICAgICAgIHNlZ21lbnQ6IHNlZ21lbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnJCdXNoXy5pbnNlcnQoYm91bmRpbmdFeHRlbnQoc2VnbWVudCksIHNlZ21lbnREYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZVxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vUG9pbnQuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBTbmFwLnByb3RvdHlwZS53cml0ZVBvaW50R2VvbWV0cnlfID0gZnVuY3Rpb24gd3JpdGVQb2ludEdlb21ldHJ5XyAoZmVhdHVyZSwgZ2VvbWV0cnkpIHtcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRDb29yZGluYXRlcygpO1xuICAgIHZhciBzZWdtZW50RGF0YSA9IC8qKiBAdHlwZSB7U2VnbWVudERhdGF9ICovICh7XG4gICAgICBmZWF0dXJlOiBmZWF0dXJlLFxuICAgICAgc2VnbWVudDogW2Nvb3JkaW5hdGVzLCBjb29yZGluYXRlc11cbiAgICB9KTtcbiAgICB0aGlzLnJCdXNoXy5pbnNlcnQoZ2VvbWV0cnkuZ2V0RXh0ZW50KCksIHNlZ21lbnREYXRhKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZVxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vUG9seWdvbi5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFNuYXAucHJvdG90eXBlLndyaXRlUG9seWdvbkdlb21ldHJ5XyA9IGZ1bmN0aW9uIHdyaXRlUG9seWdvbkdlb21ldHJ5XyAoZmVhdHVyZSwgZ2VvbWV0cnkpIHtcbiAgICB2YXIgcmluZ3MgPSBnZW9tZXRyeS5nZXRDb29yZGluYXRlcygpO1xuICAgIGZvciAodmFyIGogPSAwLCBqaiA9IHJpbmdzLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICAgIHZhciBjb29yZGluYXRlcyA9IHJpbmdzW2pdO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoIC0gMTsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgdmFyIHNlZ21lbnQgPSBjb29yZGluYXRlcy5zbGljZShpLCBpICsgMik7XG4gICAgICAgIHZhciBzZWdtZW50RGF0YSA9IC8qKiBAdHlwZSB7U2VnbWVudERhdGF9ICovICh7XG4gICAgICAgICAgZmVhdHVyZTogZmVhdHVyZSxcbiAgICAgICAgICBzZWdtZW50OiBzZWdtZW50XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJCdXNoXy5pbnNlcnQoYm91bmRpbmdFeHRlbnQoc2VnbWVudCksIHNlZ21lbnREYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFNuYXA7XG59KFBvaW50ZXJJbnRlcmFjdGlvbikpO1xuXG5cbi8qKlxuICogU29ydCBzZWdtZW50cyBieSBkaXN0YW5jZSwgaGVscGVyIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1NlZ21lbnREYXRhfSBhIFRoZSBmaXJzdCBzZWdtZW50IGRhdGEuXG4gKiBAcGFyYW0ge1NlZ21lbnREYXRhfSBiIFRoZSBzZWNvbmQgc2VnbWVudCBkYXRhLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgZGlmZmVyZW5jZSBpbiBkaXN0YW5jZS5cbiAqIEB0aGlzIHtTbmFwfVxuICovXG5mdW5jdGlvbiBzb3J0QnlEaXN0YW5jZShhLCBiKSB7XG4gIHZhciBkZWx0YUEgPSBzcXVhcmVkRGlzdGFuY2VUb1NlZ21lbnQodGhpcy5waXhlbENvb3JkaW5hdGVfLCBhLnNlZ21lbnQpO1xuICB2YXIgZGVsdGFCID0gc3F1YXJlZERpc3RhbmNlVG9TZWdtZW50KHRoaXMucGl4ZWxDb29yZGluYXRlXywgYi5zZWdtZW50KTtcbiAgcmV0dXJuIGRlbHRhQSAtIGRlbHRhQjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgU25hcDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U25hcC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vVHJhbnNsYXRlXG4gKi9cbmltcG9ydCBDb2xsZWN0aW9uIGZyb20gJy4uL0NvbGxlY3Rpb24uanMnO1xuaW1wb3J0IHtnZXRDaGFuZ2VFdmVudFR5cGV9IGZyb20gJy4uL09iamVjdC5qcyc7XG5pbXBvcnQge2xpc3Rlbn0gZnJvbSAnLi4vZXZlbnRzLmpzJztcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMvRXZlbnQuanMnO1xuaW1wb3J0IHtUUlVFfSBmcm9tICcuLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IHtpbmNsdWRlc30gZnJvbSAnLi4vYXJyYXkuanMnO1xuaW1wb3J0IFBvaW50ZXJJbnRlcmFjdGlvbiBmcm9tICcuL1BvaW50ZXIuanMnO1xuaW1wb3J0IEludGVyYWN0aW9uUHJvcGVydHkgZnJvbSAnLi9Qcm9wZXJ0eS5qcyc7XG5cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG52YXIgVHJhbnNsYXRlRXZlbnRUeXBlID0ge1xuICAvKipcbiAgICogVHJpZ2dlcmVkIHVwb24gZmVhdHVyZSB0cmFuc2xhdGlvbiBzdGFydC5cbiAgICogQGV2ZW50IFRyYW5zbGF0ZUV2ZW50I3RyYW5zbGF0ZXN0YXJ0XG4gICAqIEBhcGlcbiAgICovXG4gIFRSQU5TTEFURVNUQVJUOiAndHJhbnNsYXRlc3RhcnQnLFxuICAvKipcbiAgICogVHJpZ2dlcmVkIHVwb24gZmVhdHVyZSB0cmFuc2xhdGlvbi5cbiAgICogQGV2ZW50IFRyYW5zbGF0ZUV2ZW50I3RyYW5zbGF0aW5nXG4gICAqIEBhcGlcbiAgICovXG4gIFRSQU5TTEFUSU5HOiAndHJhbnNsYXRpbmcnLFxuICAvKipcbiAgICogVHJpZ2dlcmVkIHVwb24gZmVhdHVyZSB0cmFuc2xhdGlvbiBlbmQuXG4gICAqIEBldmVudCBUcmFuc2xhdGVFdmVudCN0cmFuc2xhdGVlbmRcbiAgICogQGFwaVxuICAgKi9cbiAgVFJBTlNMQVRFRU5EOiAndHJhbnNsYXRlZW5kJ1xufTtcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fSBbZmVhdHVyZXNdIE9ubHkgZmVhdHVyZXMgY29udGFpbmVkIGluIHRoaXMgY29sbGVjdGlvbiB3aWxsIGJlIGFibGUgdG8gYmUgdHJhbnNsYXRlZC4gSWZcbiAqIG5vdCBzcGVjaWZpZWQsIGFsbCBmZWF0dXJlcyBvbiB0aGUgbWFwIHdpbGwgYmUgYWJsZSB0byBiZSB0cmFuc2xhdGVkLlxuICogQHByb3BlcnR5IHtBcnJheTxpbXBvcnQoXCIuLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0PnxmdW5jdGlvbihpbXBvcnQoXCIuLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0KTogYm9vbGVhbn0gW2xheWVyc10gQSBsaXN0IG9mIGxheWVycyBmcm9tIHdoaWNoIGZlYXR1cmVzIHNob3VsZCBiZVxuICogdHJhbnNsYXRlZC4gQWx0ZXJuYXRpdmVseSwgYSBmaWx0ZXIgZnVuY3Rpb24gY2FuIGJlIHByb3ZpZGVkLiBUaGVcbiAqIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIGxheWVyIGluIHRoZSBtYXAgYW5kIHNob3VsZCByZXR1cm5cbiAqIGB0cnVlYCBmb3IgbGF5ZXJzIHRoYXQgeW91IHdhbnQgdG8gYmUgdHJhbnNsYXRhYmxlLiBJZiB0aGUgb3B0aW9uIGlzXG4gKiBhYnNlbnQsIGFsbCB2aXNpYmxlIGxheWVycyB3aWxsIGJlIGNvbnNpZGVyZWQgdHJhbnNsYXRhYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtoaXRUb2xlcmFuY2U9MF0gSGl0LWRldGVjdGlvbiB0b2xlcmFuY2UuIFBpeGVscyBpbnNpZGUgdGhlIHJhZGl1cyBhcm91bmQgdGhlIGdpdmVuIHBvc2l0aW9uXG4gKiB3aWxsIGJlIGNoZWNrZWQgZm9yIGZlYXR1cmVzLiBUaGlzIG9ubHkgd29ya3MgZm9yIHRoZSBjYW52YXMgcmVuZGVyZXIgYW5kXG4gKiBub3QgZm9yIFdlYkdMLlxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBFdmVudHMgZW1pdHRlZCBieSB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL1RyYW5zbGF0ZX5UcmFuc2xhdGV9IGluc3RhbmNlc1xuICogYXJlIGluc3RhbmNlcyBvZiB0aGlzIHR5cGUuXG4gKi9cbmV4cG9ydCB2YXIgVHJhbnNsYXRlRXZlbnQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChFdmVudCkge1xuICBmdW5jdGlvbiBUcmFuc2xhdGVFdmVudCh0eXBlLCBmZWF0dXJlcywgY29vcmRpbmF0ZSkge1xuXG4gICAgRXZlbnQuY2FsbCh0aGlzLCB0eXBlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmZWF0dXJlcyBiZWluZyB0cmFuc2xhdGVkLlxuICAgICAqIEB0eXBlIHtDb2xsZWN0aW9uPGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMuZmVhdHVyZXMgPSBmZWF0dXJlcztcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb29yZGluYXRlIG9mIHRoZSBkcmFnIGV2ZW50LlxuICAgICAqIEBjb25zdFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMuY29vcmRpbmF0ZSA9IGNvb3JkaW5hdGU7XG5cbiAgfVxuXG4gIGlmICggRXZlbnQgKSBUcmFuc2xhdGVFdmVudC5fX3Byb3RvX18gPSBFdmVudDtcbiAgVHJhbnNsYXRlRXZlbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXZlbnQgJiYgRXZlbnQucHJvdG90eXBlICk7XG4gIFRyYW5zbGF0ZUV2ZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRyYW5zbGF0ZUV2ZW50O1xuXG4gIHJldHVybiBUcmFuc2xhdGVFdmVudDtcbn0oRXZlbnQpKTtcblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEludGVyYWN0aW9uIGZvciB0cmFuc2xhdGluZyAobW92aW5nKSBmZWF0dXJlcy5cbiAqXG4gKiBAZmlyZXMgVHJhbnNsYXRlRXZlbnRcbiAqIEBhcGlcbiAqL1xudmFyIFRyYW5zbGF0ZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFBvaW50ZXJJbnRlcmFjdGlvbikge1xuICBmdW5jdGlvbiBUcmFuc2xhdGUob3B0X29wdGlvbnMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IG9wdF9vcHRpb25zID8gb3B0X29wdGlvbnMgOiB7fTtcblxuICAgIFBvaW50ZXJJbnRlcmFjdGlvbi5jYWxsKC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9Qb2ludGVyLmpzXCIpLk9wdGlvbnN9ICovIHRoaXMsIChvcHRpb25zKSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGFzdCBwb3NpdGlvbiB3ZSB0cmFuc2xhdGVkIHRvLlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmxhc3RDb29yZGluYXRlXyA9IG51bGw7XG5cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtDb2xsZWN0aW9uPGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmZlYXR1cmVzXyA9IG9wdGlvbnMuZmVhdHVyZXMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZmVhdHVyZXMgOiBudWxsO1xuXG4gICAgLyoqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0KTogYm9vbGVhbn0gKi9cbiAgICB2YXIgbGF5ZXJGaWx0ZXI7XG4gICAgaWYgKG9wdGlvbnMubGF5ZXJzKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMubGF5ZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGxheWVyRmlsdGVyID0gb3B0aW9ucy5sYXllcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbGF5ZXJzID0gb3B0aW9ucy5sYXllcnM7XG4gICAgICAgIGxheWVyRmlsdGVyID0gZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgICAgICByZXR1cm4gaW5jbHVkZXMobGF5ZXJzLCBsYXllcik7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxheWVyRmlsdGVyID0gVFJVRTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0KTogYm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmxheWVyRmlsdGVyXyA9IGxheWVyRmlsdGVyO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaGl0VG9sZXJhbmNlXyA9IG9wdGlvbnMuaGl0VG9sZXJhbmNlID8gb3B0aW9ucy5oaXRUb2xlcmFuY2UgOiAwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubGFzdEZlYXR1cmVfID0gbnVsbDtcblxuICAgIGxpc3Rlbih0aGlzLFxuICAgICAgZ2V0Q2hhbmdlRXZlbnRUeXBlKEludGVyYWN0aW9uUHJvcGVydHkuQUNUSVZFKSxcbiAgICAgIHRoaXMuaGFuZGxlQWN0aXZlQ2hhbmdlZF8sIHRoaXMpO1xuXG4gIH1cblxuICBpZiAoIFBvaW50ZXJJbnRlcmFjdGlvbiApIFRyYW5zbGF0ZS5fX3Byb3RvX18gPSBQb2ludGVySW50ZXJhY3Rpb247XG4gIFRyYW5zbGF0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQb2ludGVySW50ZXJhY3Rpb24gJiYgUG9pbnRlckludGVyYWN0aW9uLnByb3RvdHlwZSApO1xuICBUcmFuc2xhdGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHJhbnNsYXRlO1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgVHJhbnNsYXRlLnByb3RvdHlwZS5oYW5kbGVEb3duRXZlbnQgPSBmdW5jdGlvbiBoYW5kbGVEb3duRXZlbnQgKGV2ZW50KSB7XG4gICAgdGhpcy5sYXN0RmVhdHVyZV8gPSB0aGlzLmZlYXR1cmVzQXRQaXhlbF8oZXZlbnQucGl4ZWwsIGV2ZW50Lm1hcCk7XG4gICAgaWYgKCF0aGlzLmxhc3RDb29yZGluYXRlXyAmJiB0aGlzLmxhc3RGZWF0dXJlXykge1xuICAgICAgdGhpcy5sYXN0Q29vcmRpbmF0ZV8gPSBldmVudC5jb29yZGluYXRlO1xuICAgICAgdGhpcy5oYW5kbGVNb3ZlRXZlbnQoZXZlbnQpO1xuXG4gICAgICB2YXIgZmVhdHVyZXMgPSB0aGlzLmZlYXR1cmVzXyB8fCBuZXcgQ29sbGVjdGlvbihbdGhpcy5sYXN0RmVhdHVyZV9dKTtcblxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgICBuZXcgVHJhbnNsYXRlRXZlbnQoXG4gICAgICAgICAgVHJhbnNsYXRlRXZlbnRUeXBlLlRSQU5TTEFURVNUQVJULCBmZWF0dXJlcyxcbiAgICAgICAgICBldmVudC5jb29yZGluYXRlKSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgVHJhbnNsYXRlLnByb3RvdHlwZS5oYW5kbGVVcEV2ZW50ID0gZnVuY3Rpb24gaGFuZGxlVXBFdmVudCAoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5sYXN0Q29vcmRpbmF0ZV8pIHtcbiAgICAgIHRoaXMubGFzdENvb3JkaW5hdGVfID0gbnVsbDtcbiAgICAgIHRoaXMuaGFuZGxlTW92ZUV2ZW50KGV2ZW50KTtcblxuICAgICAgdmFyIGZlYXR1cmVzID0gdGhpcy5mZWF0dXJlc18gfHwgbmV3IENvbGxlY3Rpb24oW3RoaXMubGFzdEZlYXR1cmVfXSk7XG5cbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgbmV3IFRyYW5zbGF0ZUV2ZW50KFxuICAgICAgICAgIFRyYW5zbGF0ZUV2ZW50VHlwZS5UUkFOU0xBVEVFTkQsIGZlYXR1cmVzLFxuICAgICAgICAgIGV2ZW50LmNvb3JkaW5hdGUpKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBUcmFuc2xhdGUucHJvdG90eXBlLmhhbmRsZURyYWdFdmVudCA9IGZ1bmN0aW9uIGhhbmRsZURyYWdFdmVudCAoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5sYXN0Q29vcmRpbmF0ZV8pIHtcbiAgICAgIHZhciBuZXdDb29yZGluYXRlID0gZXZlbnQuY29vcmRpbmF0ZTtcbiAgICAgIHZhciBkZWx0YVggPSBuZXdDb29yZGluYXRlWzBdIC0gdGhpcy5sYXN0Q29vcmRpbmF0ZV9bMF07XG4gICAgICB2YXIgZGVsdGFZID0gbmV3Q29vcmRpbmF0ZVsxXSAtIHRoaXMubGFzdENvb3JkaW5hdGVfWzFdO1xuXG4gICAgICB2YXIgZmVhdHVyZXMgPSB0aGlzLmZlYXR1cmVzXyB8fCBuZXcgQ29sbGVjdGlvbihbdGhpcy5sYXN0RmVhdHVyZV9dKTtcblxuICAgICAgZmVhdHVyZXMuZm9yRWFjaChmdW5jdGlvbihmZWF0dXJlKSB7XG4gICAgICAgIHZhciBnZW9tID0gZmVhdHVyZS5nZXRHZW9tZXRyeSgpO1xuICAgICAgICBnZW9tLnRyYW5zbGF0ZShkZWx0YVgsIGRlbHRhWSk7XG4gICAgICAgIGZlYXR1cmUuc2V0R2VvbWV0cnkoZ2VvbSk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5sYXN0Q29vcmRpbmF0ZV8gPSBuZXdDb29yZGluYXRlO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgICBuZXcgVHJhbnNsYXRlRXZlbnQoXG4gICAgICAgICAgVHJhbnNsYXRlRXZlbnRUeXBlLlRSQU5TTEFUSU5HLCBmZWF0dXJlcyxcbiAgICAgICAgICBuZXdDb29yZGluYXRlKSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgVHJhbnNsYXRlLnByb3RvdHlwZS5oYW5kbGVNb3ZlRXZlbnQgPSBmdW5jdGlvbiBoYW5kbGVNb3ZlRXZlbnQgKGV2ZW50KSB7XG4gICAgdmFyIGVsZW0gPSBldmVudC5tYXAuZ2V0Vmlld3BvcnQoKTtcblxuICAgIC8vIENoYW5nZSB0aGUgY3Vyc29yIHRvIGdyYWIvZ3JhYmJpbmcgaWYgaG92ZXJpbmcgYW55IG9mIHRoZSBmZWF0dXJlcyBtYW5hZ2VkXG4gICAgLy8gYnkgdGhlIGludGVyYWN0aW9uXG4gICAgaWYgKHRoaXMuZmVhdHVyZXNBdFBpeGVsXyhldmVudC5waXhlbCwgZXZlbnQubWFwKSkge1xuICAgICAgZWxlbS5jbGFzc0xpc3QucmVtb3ZlKHRoaXMubGFzdENvb3JkaW5hdGVfID8gJ29sLWdyYWInIDogJ29sLWdyYWJiaW5nJyk7XG4gICAgICBlbGVtLmNsYXNzTGlzdC5hZGQodGhpcy5sYXN0Q29vcmRpbmF0ZV8gPyAnb2wtZ3JhYmJpbmcnIDogJ29sLWdyYWInKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbS5jbGFzc0xpc3QucmVtb3ZlKCdvbC1ncmFiJywgJ29sLWdyYWJiaW5nJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUZXN0cyB0byBzZWUgaWYgdGhlIGdpdmVuIGNvb3JkaW5hdGVzIGludGVyc2VjdHMgYW55IG9mIG91ciBzZWxlY3RlZFxuICAgKiBmZWF0dXJlcy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9waXhlbC5qc1wiKS5QaXhlbH0gcGl4ZWwgUGl4ZWwgY29vcmRpbmF0ZSB0byB0ZXN0IGZvciBpbnRlcnNlY3Rpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLmRlZmF1bHR9IG1hcCBNYXAgdG8gdGVzdCB0aGUgaW50ZXJzZWN0aW9uIG9uLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IFJldHVybnMgdGhlIGZlYXR1cmUgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBwaXhlbFxuICAgKiBjb29yZGluYXRlcy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFRyYW5zbGF0ZS5wcm90b3R5cGUuZmVhdHVyZXNBdFBpeGVsXyA9IGZ1bmN0aW9uIGZlYXR1cmVzQXRQaXhlbF8gKHBpeGVsLCBtYXApIHtcbiAgICByZXR1cm4gbWFwLmZvckVhY2hGZWF0dXJlQXRQaXhlbChwaXhlbCxcbiAgICAgIGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZlYXR1cmVzXyB8fCBpbmNsdWRlcyh0aGlzLmZlYXR1cmVzXy5nZXRBcnJheSgpLCBmZWF0dXJlKSkge1xuICAgICAgICAgIHJldHVybiBmZWF0dXJlO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcyksIHtcbiAgICAgICAgbGF5ZXJGaWx0ZXI6IHRoaXMubGF5ZXJGaWx0ZXJfLFxuICAgICAgICBoaXRUb2xlcmFuY2U6IHRoaXMuaGl0VG9sZXJhbmNlX1xuICAgICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIEhpdC1kZXRlY3Rpb24gdG9sZXJhbmNlLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBIaXQgdG9sZXJhbmNlIGluIHBpeGVscy5cbiAgICogQGFwaVxuICAgKi9cbiAgVHJhbnNsYXRlLnByb3RvdHlwZS5nZXRIaXRUb2xlcmFuY2UgPSBmdW5jdGlvbiBnZXRIaXRUb2xlcmFuY2UgKCkge1xuICAgIHJldHVybiB0aGlzLmhpdFRvbGVyYW5jZV87XG4gIH07XG5cbiAgLyoqXG4gICAqIEhpdC1kZXRlY3Rpb24gdG9sZXJhbmNlLiBQaXhlbHMgaW5zaWRlIHRoZSByYWRpdXMgYXJvdW5kIHRoZSBnaXZlbiBwb3NpdGlvblxuICAgKiB3aWxsIGJlIGNoZWNrZWQgZm9yIGZlYXR1cmVzLiBUaGlzIG9ubHkgd29ya3MgZm9yIHRoZSBjYW52YXMgcmVuZGVyZXIgYW5kXG4gICAqIG5vdCBmb3IgV2ViR0wuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoaXRUb2xlcmFuY2UgSGl0IHRvbGVyYW5jZSBpbiBwaXhlbHMuXG4gICAqIEBhcGlcbiAgICovXG4gIFRyYW5zbGF0ZS5wcm90b3R5cGUuc2V0SGl0VG9sZXJhbmNlID0gZnVuY3Rpb24gc2V0SGl0VG9sZXJhbmNlIChoaXRUb2xlcmFuY2UpIHtcbiAgICB0aGlzLmhpdFRvbGVyYW5jZV8gPSBoaXRUb2xlcmFuY2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBUcmFuc2xhdGUucHJvdG90eXBlLnNldE1hcCA9IGZ1bmN0aW9uIHNldE1hcCAobWFwKSB7XG4gICAgdmFyIG9sZE1hcCA9IHRoaXMuZ2V0TWFwKCk7XG4gICAgUG9pbnRlckludGVyYWN0aW9uLnByb3RvdHlwZS5zZXRNYXAuY2FsbCh0aGlzLCBtYXApO1xuICAgIHRoaXMudXBkYXRlU3RhdGVfKG9sZE1hcCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBUcmFuc2xhdGUucHJvdG90eXBlLmhhbmRsZUFjdGl2ZUNoYW5nZWRfID0gZnVuY3Rpb24gaGFuZGxlQWN0aXZlQ2hhbmdlZF8gKCkge1xuICAgIHRoaXMudXBkYXRlU3RhdGVfKG51bGwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1BsdWdnYWJsZU1hcC5qc1wiKS5kZWZhdWx0fSBvbGRNYXAgT2xkIG1hcC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFRyYW5zbGF0ZS5wcm90b3R5cGUudXBkYXRlU3RhdGVfID0gZnVuY3Rpb24gdXBkYXRlU3RhdGVfIChvbGRNYXApIHtcbiAgICB2YXIgbWFwID0gdGhpcy5nZXRNYXAoKTtcbiAgICB2YXIgYWN0aXZlID0gdGhpcy5nZXRBY3RpdmUoKTtcbiAgICBpZiAoIW1hcCB8fCAhYWN0aXZlKSB7XG4gICAgICBtYXAgPSBtYXAgfHwgb2xkTWFwO1xuICAgICAgaWYgKG1hcCkge1xuICAgICAgICB2YXIgZWxlbSA9IG1hcC5nZXRWaWV3cG9ydCgpO1xuICAgICAgICBlbGVtLmNsYXNzTGlzdC5yZW1vdmUoJ29sLWdyYWInLCAnb2wtZ3JhYmJpbmcnKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFRyYW5zbGF0ZTtcbn0oUG9pbnRlckludGVyYWN0aW9uKSk7XG5cbmV4cG9ydCBkZWZhdWx0IFRyYW5zbGF0ZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VHJhbnNsYXRlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9sYXllci9CYXNlXG4gKi9cbmltcG9ydCB7YWJzdHJhY3R9IGZyb20gJy4uL3V0aWwuanMnO1xuaW1wb3J0IEJhc2VPYmplY3QgZnJvbSAnLi4vT2JqZWN0LmpzJztcbmltcG9ydCBMYXllclByb3BlcnR5IGZyb20gJy4vUHJvcGVydHkuanMnO1xuaW1wb3J0IHtjbGFtcH0gZnJvbSAnLi4vbWF0aC5qcyc7XG5pbXBvcnQge2Fzc2lnbn0gZnJvbSAnLi4vb2JqLmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbb3BhY2l0eT0xXSBPcGFjaXR5ICgwLCAxKS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Zpc2libGU9dHJ1ZV0gVmlzaWJpbGl0eS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW2V4dGVudF0gVGhlIGJvdW5kaW5nIGV4dGVudCBmb3IgbGF5ZXIgcmVuZGVyaW5nLiAgVGhlIGxheWVyIHdpbGwgbm90IGJlXG4gKiByZW5kZXJlZCBvdXRzaWRlIG9mIHRoaXMgZXh0ZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt6SW5kZXhdIFRoZSB6LWluZGV4IGZvciBsYXllciByZW5kZXJpbmcuICBBdCByZW5kZXJpbmcgdGltZSwgdGhlIGxheWVyc1xuICogd2lsbCBiZSBvcmRlcmVkLCBmaXJzdCBieSBaLWluZGV4IGFuZCB0aGVuIGJ5IHBvc2l0aW9uLiBXaGVuIGB1bmRlZmluZWRgLCBhIGB6SW5kZXhgIG9mIDAgaXMgYXNzdW1lZFxuICogZm9yIGxheWVycyB0aGF0IGFyZSBhZGRlZCB0byB0aGUgbWFwJ3MgYGxheWVyc2AgY29sbGVjdGlvbiwgb3IgYEluZmluaXR5YCB3aGVuIHRoZSBsYXllcidzIGBzZXRNYXAoKWBcbiAqIG1ldGhvZCB3YXMgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluUmVzb2x1dGlvbl0gVGhlIG1pbmltdW0gcmVzb2x1dGlvbiAoaW5jbHVzaXZlKSBhdCB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmVcbiAqIHZpc2libGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFJlc29sdXRpb25dIFRoZSBtYXhpbXVtIHJlc29sdXRpb24gKGV4Y2x1c2l2ZSkgYmVsb3cgd2hpY2ggdGhpcyBsYXllciB3aWxsXG4gKiBiZSB2aXNpYmxlLlxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzOyBub3JtYWxseSBvbmx5IHVzZWQgZm9yIGNyZWF0aW5nIHN1YmNsYXNzZXMgYW5kIG5vdFxuICogaW5zdGFudGlhdGVkIGluIGFwcHMuXG4gKiBOb3RlIHRoYXQgd2l0aCB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL0Jhc2V9IGFuZCBhbGwgaXRzIHN1YmNsYXNzZXMsIGFueSBwcm9wZXJ0eSBzZXQgaW5cbiAqIHRoZSBvcHRpb25zIGlzIHNldCBhcyBhIHtAbGluayBtb2R1bGU6b2wvT2JqZWN0fSBwcm9wZXJ0eSBvbiB0aGUgbGF5ZXIgb2JqZWN0LCBzb1xuICogaXMgb2JzZXJ2YWJsZSwgYW5kIGhhcyBnZXQvc2V0IGFjY2Vzc29ycy5cbiAqXG4gKiBAYXBpXG4gKi9cbnZhciBCYXNlTGF5ZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChCYXNlT2JqZWN0KSB7XG4gIGZ1bmN0aW9uIEJhc2VMYXllcihvcHRpb25zKSB7XG5cbiAgICBCYXNlT2JqZWN0LmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgKj59XG4gICAgICovXG4gICAgdmFyIHByb3BlcnRpZXMgPSBhc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgIHByb3BlcnRpZXNbTGF5ZXJQcm9wZXJ0eS5PUEFDSVRZXSA9XG4gICAgICAgb3B0aW9ucy5vcGFjaXR5ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm9wYWNpdHkgOiAxO1xuICAgIHByb3BlcnRpZXNbTGF5ZXJQcm9wZXJ0eS5WSVNJQkxFXSA9XG4gICAgICAgb3B0aW9ucy52aXNpYmxlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnZpc2libGUgOiB0cnVlO1xuICAgIHByb3BlcnRpZXNbTGF5ZXJQcm9wZXJ0eS5aX0lOREVYXSA9IG9wdGlvbnMuekluZGV4O1xuICAgIHByb3BlcnRpZXNbTGF5ZXJQcm9wZXJ0eS5NQVhfUkVTT0xVVElPTl0gPVxuICAgICAgIG9wdGlvbnMubWF4UmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tYXhSZXNvbHV0aW9uIDogSW5maW5pdHk7XG4gICAgcHJvcGVydGllc1tMYXllclByb3BlcnR5Lk1JTl9SRVNPTFVUSU9OXSA9XG4gICAgICAgb3B0aW9ucy5taW5SZXNvbHV0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1pblJlc29sdXRpb24gOiAwO1xuXG4gICAgdGhpcy5zZXRQcm9wZXJ0aWVzKHByb3BlcnRpZXMpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vTGF5ZXIuanNcIikuU3RhdGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnN0YXRlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGF5ZXIgdHlwZS5cbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vTGF5ZXJUeXBlLmpzXCIpLmRlZmF1bHR9XG4gICAgICogQHByb3RlY3RlZDtcbiAgICAgKi9cbiAgICB0aGlzLnR5cGU7XG5cbiAgfVxuXG4gIGlmICggQmFzZU9iamVjdCApIEJhc2VMYXllci5fX3Byb3RvX18gPSBCYXNlT2JqZWN0O1xuICBCYXNlTGF5ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQmFzZU9iamVjdCAmJiBCYXNlT2JqZWN0LnByb3RvdHlwZSApO1xuICBCYXNlTGF5ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQmFzZUxheWVyO1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxheWVyIHR5cGUgKHVzZWQgd2hlbiBjcmVhdGluZyBhIGxheWVyIHJlbmRlcmVyKS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vTGF5ZXJUeXBlLmpzXCIpLmRlZmF1bHR9IFRoZSBsYXllciB0eXBlLlxuICAgKi9cbiAgQmFzZUxheWVyLnByb3RvdHlwZS5nZXRUeXBlID0gZnVuY3Rpb24gZ2V0VHlwZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZTtcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9MYXllci5qc1wiKS5TdGF0ZX0gTGF5ZXIgc3RhdGUuXG4gICAqL1xuICBCYXNlTGF5ZXIucHJvdG90eXBlLmdldExheWVyU3RhdGUgPSBmdW5jdGlvbiBnZXRMYXllclN0YXRlICgpIHtcbiAgICAvKiogQHR5cGUge2ltcG9ydChcIi4vTGF5ZXIuanNcIikuU3RhdGV9ICovXG4gICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZV8gfHwgLyoqIEB0eXBlIHs/fSAqLyAoe1xuICAgICAgbGF5ZXI6IHRoaXMsXG4gICAgICBtYW5hZ2VkOiB0cnVlXG4gICAgfSk7XG4gICAgc3RhdGUub3BhY2l0eSA9IGNsYW1wKHRoaXMuZ2V0T3BhY2l0eSgpLCAwLCAxKTtcbiAgICBzdGF0ZS5zb3VyY2VTdGF0ZSA9IHRoaXMuZ2V0U291cmNlU3RhdGUoKTtcbiAgICBzdGF0ZS52aXNpYmxlID0gdGhpcy5nZXRWaXNpYmxlKCk7XG4gICAgc3RhdGUuZXh0ZW50ID0gdGhpcy5nZXRFeHRlbnQoKTtcbiAgICBzdGF0ZS56SW5kZXggPSB0aGlzLmdldFpJbmRleCgpIHx8IDA7XG4gICAgc3RhdGUubWF4UmVzb2x1dGlvbiA9IHRoaXMuZ2V0TWF4UmVzb2x1dGlvbigpO1xuICAgIHN0YXRlLm1pblJlc29sdXRpb24gPSBNYXRoLm1heCh0aGlzLmdldE1pblJlc29sdXRpb24oKSwgMCk7XG4gICAgdGhpcy5zdGF0ZV8gPSBzdGF0ZTtcblxuICAgIHJldHVybiBzdGF0ZTtcbiAgfTtcblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi9MYXllci5qc1wiKS5kZWZhdWx0Pj19IG9wdF9hcnJheSBBcnJheSBvZiBsYXllcnMgKHRvIGJlXG4gICAqICAgICBtb2RpZmllZCBpbiBwbGFjZSkuXG4gICAqIEByZXR1cm4ge0FycmF5PGltcG9ydChcIi4vTGF5ZXIuanNcIikuZGVmYXVsdD59IEFycmF5IG9mIGxheWVycy5cbiAgICovXG4gIEJhc2VMYXllci5wcm90b3R5cGUuZ2V0TGF5ZXJzQXJyYXkgPSBmdW5jdGlvbiBnZXRMYXllcnNBcnJheSAob3B0X2FycmF5KSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4vTGF5ZXIuanNcIikuU3RhdGU+PX0gb3B0X3N0YXRlcyBPcHRpb25hbCBsaXN0IG9mIGxheWVyXG4gICAqICAgICBzdGF0ZXMgKHRvIGJlIG1vZGlmaWVkIGluIHBsYWNlKS5cbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi9MYXllci5qc1wiKS5TdGF0ZT59IExpc3Qgb2YgbGF5ZXIgc3RhdGVzLlxuICAgKi9cbiAgQmFzZUxheWVyLnByb3RvdHlwZS5nZXRMYXllclN0YXRlc0FycmF5ID0gZnVuY3Rpb24gZ2V0TGF5ZXJTdGF0ZXNBcnJheSAob3B0X3N0YXRlcykge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHtAbGluayBtb2R1bGU6b2wvZXh0ZW50fkV4dGVudCBleHRlbnR9IG9mIHRoZSBsYXllciBvciBgdW5kZWZpbmVkYCBpZiBpdFxuICAgKiB3aWxsIGJlIHZpc2libGUgcmVnYXJkbGVzcyBvZiBleHRlbnQuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR8dW5kZWZpbmVkfSBUaGUgbGF5ZXIgZXh0ZW50LlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBCYXNlTGF5ZXIucHJvdG90eXBlLmdldEV4dGVudCA9IGZ1bmN0aW9uIGdldEV4dGVudCAoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudHx1bmRlZmluZWR9ICovICh0aGlzLmdldChMYXllclByb3BlcnR5LkVYVEVOVCkpXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBtYXhpbXVtIHJlc29sdXRpb24gb2YgdGhlIGxheWVyLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBtYXhpbXVtIHJlc29sdXRpb24gb2YgdGhlIGxheWVyLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBCYXNlTGF5ZXIucHJvdG90eXBlLmdldE1heFJlc29sdXRpb24gPSBmdW5jdGlvbiBnZXRNYXhSZXNvbHV0aW9uICgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ9ICovICh0aGlzLmdldChMYXllclByb3BlcnR5Lk1BWF9SRVNPTFVUSU9OKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbWluaW11bSByZXNvbHV0aW9uIG9mIHRoZSBsYXllci5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWluaW11bSByZXNvbHV0aW9uIG9mIHRoZSBsYXllci5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgQmFzZUxheWVyLnByb3RvdHlwZS5nZXRNaW5SZXNvbHV0aW9uID0gZnVuY3Rpb24gZ2V0TWluUmVzb2x1dGlvbiAoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5nZXQoTGF5ZXJQcm9wZXJ0eS5NSU5fUkVTT0xVVElPTikpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG9wYWNpdHkgb2YgdGhlIGxheWVyIChiZXR3ZWVuIDAgYW5kIDEpLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBvcGFjaXR5IG9mIHRoZSBsYXllci5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgQmFzZUxheWVyLnByb3RvdHlwZS5nZXRPcGFjaXR5ID0gZnVuY3Rpb24gZ2V0T3BhY2l0eSAoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5nZXQoTGF5ZXJQcm9wZXJ0eS5PUEFDSVRZKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zb3VyY2UvU3RhdGUuanNcIikuZGVmYXVsdH0gU291cmNlIHN0YXRlLlxuICAgKi9cbiAgQmFzZUxheWVyLnByb3RvdHlwZS5nZXRTb3VyY2VTdGF0ZSA9IGZ1bmN0aW9uIGdldFNvdXJjZVN0YXRlICgpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBsYXllciAoYHRydWVgIG9yIGBmYWxzZWApLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgdmlzaWJpbGl0eSBvZiB0aGUgbGF5ZXIuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIEJhc2VMYXllci5wcm90b3R5cGUuZ2V0VmlzaWJsZSA9IGZ1bmN0aW9uIGdldFZpc2libGUgKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge2Jvb2xlYW59ICovICh0aGlzLmdldChMYXllclByb3BlcnR5LlZJU0lCTEUpKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBaLWluZGV4IG9mIHRoZSBsYXllciwgd2hpY2ggaXMgdXNlZCB0byBvcmRlciBsYXllcnMgYmVmb3JlXG4gICAqIHJlbmRlcmluZy4gVGhlIGRlZmF1bHQgWi1pbmRleCBpcyAwLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBaLWluZGV4IG9mIHRoZSBsYXllci5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgQmFzZUxheWVyLnByb3RvdHlwZS5nZXRaSW5kZXggPSBmdW5jdGlvbiBnZXRaSW5kZXggKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge251bWJlcn0gKi8gKHRoaXMuZ2V0KExheWVyUHJvcGVydHkuWl9JTkRFWCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGV4dGVudCBhdCB3aGljaCB0aGUgbGF5ZXIgaXMgdmlzaWJsZS4gIElmIGB1bmRlZmluZWRgLCB0aGUgbGF5ZXJcbiAgICogd2lsbCBiZSB2aXNpYmxlIGF0IGFsbCBleHRlbnRzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR8dW5kZWZpbmVkfSBleHRlbnQgVGhlIGV4dGVudCBvZiB0aGUgbGF5ZXIuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIEJhc2VMYXllci5wcm90b3R5cGUuc2V0RXh0ZW50ID0gZnVuY3Rpb24gc2V0RXh0ZW50IChleHRlbnQpIHtcbiAgICB0aGlzLnNldChMYXllclByb3BlcnR5LkVYVEVOVCwgZXh0ZW50KTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBtYXhpbXVtIHJlc29sdXRpb24gYXQgd2hpY2ggdGhlIGxheWVyIGlzIHZpc2libGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhSZXNvbHV0aW9uIFRoZSBtYXhpbXVtIHJlc29sdXRpb24gb2YgdGhlIGxheWVyLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBCYXNlTGF5ZXIucHJvdG90eXBlLnNldE1heFJlc29sdXRpb24gPSBmdW5jdGlvbiBzZXRNYXhSZXNvbHV0aW9uIChtYXhSZXNvbHV0aW9uKSB7XG4gICAgdGhpcy5zZXQoTGF5ZXJQcm9wZXJ0eS5NQVhfUkVTT0xVVElPTiwgbWF4UmVzb2x1dGlvbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbWluaW11bSByZXNvbHV0aW9uIGF0IHdoaWNoIHRoZSBsYXllciBpcyB2aXNpYmxlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluUmVzb2x1dGlvbiBUaGUgbWluaW11bSByZXNvbHV0aW9uIG9mIHRoZSBsYXllci5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgQmFzZUxheWVyLnByb3RvdHlwZS5zZXRNaW5SZXNvbHV0aW9uID0gZnVuY3Rpb24gc2V0TWluUmVzb2x1dGlvbiAobWluUmVzb2x1dGlvbikge1xuICAgIHRoaXMuc2V0KExheWVyUHJvcGVydHkuTUlOX1JFU09MVVRJT04sIG1pblJlc29sdXRpb24pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIG9wYWNpdHkgb2YgdGhlIGxheWVyLCBhbGxvd2VkIHZhbHVlcyByYW5nZSBmcm9tIDAgdG8gMS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wYWNpdHkgVGhlIG9wYWNpdHkgb2YgdGhlIGxheWVyLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBCYXNlTGF5ZXIucHJvdG90eXBlLnNldE9wYWNpdHkgPSBmdW5jdGlvbiBzZXRPcGFjaXR5IChvcGFjaXR5KSB7XG4gICAgdGhpcy5zZXQoTGF5ZXJQcm9wZXJ0eS5PUEFDSVRZLCBvcGFjaXR5KTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBsYXllciAoYHRydWVgIG9yIGBmYWxzZWApLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZpc2libGUgVGhlIHZpc2liaWxpdHkgb2YgdGhlIGxheWVyLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBCYXNlTGF5ZXIucHJvdG90eXBlLnNldFZpc2libGUgPSBmdW5jdGlvbiBzZXRWaXNpYmxlICh2aXNpYmxlKSB7XG4gICAgdGhpcy5zZXQoTGF5ZXJQcm9wZXJ0eS5WSVNJQkxFLCB2aXNpYmxlKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IFotaW5kZXggb2YgdGhlIGxheWVyLCB3aGljaCBpcyB1c2VkIHRvIG9yZGVyIGxheWVycyBiZWZvcmUgcmVuZGVyaW5nLlxuICAgKiBUaGUgZGVmYXVsdCBaLWluZGV4IGlzIDAuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6aW5kZXggVGhlIHotaW5kZXggb2YgdGhlIGxheWVyLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBCYXNlTGF5ZXIucHJvdG90eXBlLnNldFpJbmRleCA9IGZ1bmN0aW9uIHNldFpJbmRleCAoemluZGV4KSB7XG4gICAgdGhpcy5zZXQoTGF5ZXJQcm9wZXJ0eS5aX0lOREVYLCB6aW5kZXgpO1xuICB9O1xuXG4gIHJldHVybiBCYXNlTGF5ZXI7XG59KEJhc2VPYmplY3QpKTtcblxuXG5leHBvcnQgZGVmYXVsdCBCYXNlTGF5ZXI7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhc2UuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2xheWVyL0dyb3VwXG4gKi9cbmltcG9ydCB7Z2V0VWlkfSBmcm9tICcuLi91dGlsLmpzJztcbmltcG9ydCBDb2xsZWN0aW9uIGZyb20gJy4uL0NvbGxlY3Rpb24uanMnO1xuaW1wb3J0IENvbGxlY3Rpb25FdmVudFR5cGUgZnJvbSAnLi4vQ29sbGVjdGlvbkV2ZW50VHlwZS5qcyc7XG5pbXBvcnQge2dldENoYW5nZUV2ZW50VHlwZX0gZnJvbSAnLi4vT2JqZWN0LmpzJztcbmltcG9ydCBPYmplY3RFdmVudFR5cGUgZnJvbSAnLi4vT2JqZWN0RXZlbnRUeXBlLmpzJztcbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuLi9hc3NlcnRzLmpzJztcbmltcG9ydCB7bGlzdGVuLCB1bmxpc3RlbkJ5S2V5fSBmcm9tICcuLi9ldmVudHMuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7Z2V0SW50ZXJzZWN0aW9ufSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IEJhc2VMYXllciBmcm9tICcuL0Jhc2UuanMnO1xuaW1wb3J0IHthc3NpZ24sIGNsZWFyfSBmcm9tICcuLi9vYmouanMnO1xuaW1wb3J0IFNvdXJjZVN0YXRlIGZyb20gJy4uL3NvdXJjZS9TdGF0ZS5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW29wYWNpdHk9MV0gT3BhY2l0eSAoMCwgMSkuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt2aXNpYmxlPXRydWVdIFZpc2liaWxpdHkuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IFtleHRlbnRdIFRoZSBib3VuZGluZyBleHRlbnQgZm9yIGxheWVyIHJlbmRlcmluZy4gIFRoZSBsYXllciB3aWxsIG5vdCBiZVxuICogcmVuZGVyZWQgb3V0c2lkZSBvZiB0aGlzIGV4dGVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbekluZGV4XSBUaGUgei1pbmRleCBmb3IgbGF5ZXIgcmVuZGVyaW5nLiAgQXQgcmVuZGVyaW5nIHRpbWUsIHRoZSBsYXllcnNcbiAqIHdpbGwgYmUgb3JkZXJlZCwgZmlyc3QgYnkgWi1pbmRleCBhbmQgdGhlbiBieSBwb3NpdGlvbi4gV2hlbiBgdW5kZWZpbmVkYCwgYSBgekluZGV4YCBvZiAwIGlzIGFzc3VtZWRcbiAqIGZvciBsYXllcnMgdGhhdCBhcmUgYWRkZWQgdG8gdGhlIG1hcCdzIGBsYXllcnNgIGNvbGxlY3Rpb24sIG9yIGBJbmZpbml0eWAgd2hlbiB0aGUgbGF5ZXIncyBgc2V0TWFwKClgXG4gKiBtZXRob2Qgd2FzIHVzZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pblJlc29sdXRpb25dIFRoZSBtaW5pbXVtIHJlc29sdXRpb24gKGluY2x1c2l2ZSkgYXQgd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlXG4gKiB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhSZXNvbHV0aW9uXSBUaGUgbWF4aW11bSByZXNvbHV0aW9uIChleGNsdXNpdmUpIGJlbG93IHdoaWNoIHRoaXMgbGF5ZXIgd2lsbFxuICogYmUgdmlzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8aW1wb3J0KFwiLi9CYXNlLmpzXCIpLmRlZmF1bHQ+fGltcG9ydChcIi4uL0NvbGxlY3Rpb24uanNcIikuZGVmYXVsdDxpbXBvcnQoXCIuL0Jhc2UuanNcIikuZGVmYXVsdD59IFtsYXllcnNdIENoaWxkIGxheWVycy5cbiAqL1xuXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBQcm9wZXJ0eSA9IHtcbiAgTEFZRVJTOiAnbGF5ZXJzJ1xufTtcblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEEge0BsaW5rIG1vZHVsZTpvbC9Db2xsZWN0aW9ufkNvbGxlY3Rpb259IG9mIGxheWVycyB0aGF0IGFyZSBoYW5kbGVkIHRvZ2V0aGVyLlxuICpcbiAqIEEgZ2VuZXJpYyBgY2hhbmdlYCBldmVudCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgZ3JvdXAvQ29sbGVjdGlvbiBjaGFuZ2VzLlxuICpcbiAqIEBhcGlcbiAqL1xudmFyIExheWVyR3JvdXAgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChCYXNlTGF5ZXIpIHtcbiAgZnVuY3Rpb24gTGF5ZXJHcm91cChvcHRfb3B0aW9ucykge1xuXG4gICAgdmFyIG9wdGlvbnMgPSBvcHRfb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgYmFzZU9wdGlvbnMgPSAvKiogQHR5cGUge09wdGlvbnN9ICovIChhc3NpZ24oe30sIG9wdGlvbnMpKTtcbiAgICBkZWxldGUgYmFzZU9wdGlvbnMubGF5ZXJzO1xuXG4gICAgdmFyIGxheWVycyA9IG9wdGlvbnMubGF5ZXJzO1xuXG4gICAgQmFzZUxheWVyLmNhbGwodGhpcywgYmFzZU9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5sYXllcnNMaXN0ZW5lcktleXNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBBcnJheTxpbXBvcnQoXCIuLi9ldmVudHMuanNcIikuRXZlbnRzS2V5Pj59XG4gICAgICovXG4gICAgdGhpcy5saXN0ZW5lcktleXNfID0ge307XG5cbiAgICBsaXN0ZW4odGhpcyxcbiAgICAgIGdldENoYW5nZUV2ZW50VHlwZShQcm9wZXJ0eS5MQVlFUlMpLFxuICAgICAgdGhpcy5oYW5kbGVMYXllcnNDaGFuZ2VkXywgdGhpcyk7XG5cbiAgICBpZiAobGF5ZXJzKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShsYXllcnMpKSB7XG4gICAgICAgIGxheWVycyA9IG5ldyBDb2xsZWN0aW9uKGxheWVycy5zbGljZSgpLCB7dW5pcXVlOiB0cnVlfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhc3NlcnQodHlwZW9mIC8qKiBAdHlwZSB7P30gKi8gKGxheWVycykuZ2V0QXJyYXkgPT09ICdmdW5jdGlvbicsXG4gICAgICAgICAgNDMpOyAvLyBFeHBlY3RlZCBgbGF5ZXJzYCB0byBiZSBhbiBhcnJheSBvciBhIGBDb2xsZWN0aW9uYFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsYXllcnMgPSBuZXcgQ29sbGVjdGlvbih1bmRlZmluZWQsIHt1bmlxdWU6IHRydWV9KTtcbiAgICB9XG5cbiAgICB0aGlzLnNldExheWVycyhsYXllcnMpO1xuXG4gIH1cblxuICBpZiAoIEJhc2VMYXllciApIExheWVyR3JvdXAuX19wcm90b19fID0gQmFzZUxheWVyO1xuICBMYXllckdyb3VwLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJhc2VMYXllciAmJiBCYXNlTGF5ZXIucHJvdG90eXBlICk7XG4gIExheWVyR3JvdXAucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGF5ZXJHcm91cDtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIExheWVyR3JvdXAucHJvdG90eXBlLmhhbmRsZUxheWVyQ2hhbmdlXyA9IGZ1bmN0aW9uIGhhbmRsZUxheWVyQ2hhbmdlXyAoKSB7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBMYXllckdyb3VwLnByb3RvdHlwZS5oYW5kbGVMYXllcnNDaGFuZ2VkXyA9IGZ1bmN0aW9uIGhhbmRsZUxheWVyc0NoYW5nZWRfICgpIHtcbiAgICB0aGlzLmxheWVyc0xpc3RlbmVyS2V5c18uZm9yRWFjaCh1bmxpc3RlbkJ5S2V5KTtcbiAgICB0aGlzLmxheWVyc0xpc3RlbmVyS2V5c18ubGVuZ3RoID0gMDtcblxuICAgIHZhciBsYXllcnMgPSB0aGlzLmdldExheWVycygpO1xuICAgIHRoaXMubGF5ZXJzTGlzdGVuZXJLZXlzXy5wdXNoKFxuICAgICAgbGlzdGVuKGxheWVycywgQ29sbGVjdGlvbkV2ZW50VHlwZS5BREQsIHRoaXMuaGFuZGxlTGF5ZXJzQWRkXywgdGhpcyksXG4gICAgICBsaXN0ZW4obGF5ZXJzLCBDb2xsZWN0aW9uRXZlbnRUeXBlLlJFTU9WRSwgdGhpcy5oYW5kbGVMYXllcnNSZW1vdmVfLCB0aGlzKVxuICAgICk7XG5cbiAgICBmb3IgKHZhciBpZCBpbiB0aGlzLmxpc3RlbmVyS2V5c18pIHtcbiAgICAgIHRoaXMubGlzdGVuZXJLZXlzX1tpZF0uZm9yRWFjaCh1bmxpc3RlbkJ5S2V5KTtcbiAgICB9XG4gICAgY2xlYXIodGhpcy5saXN0ZW5lcktleXNfKTtcblxuICAgIHZhciBsYXllcnNBcnJheSA9IGxheWVycy5nZXRBcnJheSgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGxheWVyc0FycmF5Lmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIHZhciBsYXllciA9IGxheWVyc0FycmF5W2ldO1xuICAgICAgdGhpcy5saXN0ZW5lcktleXNfW2dldFVpZChsYXllcildID0gW1xuICAgICAgICBsaXN0ZW4obGF5ZXIsIE9iamVjdEV2ZW50VHlwZS5QUk9QRVJUWUNIQU5HRSwgdGhpcy5oYW5kbGVMYXllckNoYW5nZV8sIHRoaXMpLFxuICAgICAgICBsaXN0ZW4obGF5ZXIsIEV2ZW50VHlwZS5DSEFOR0UsIHRoaXMuaGFuZGxlTGF5ZXJDaGFuZ2VfLCB0aGlzKVxuICAgICAgXTtcbiAgICB9XG5cbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9Db2xsZWN0aW9uLmpzXCIpLkNvbGxlY3Rpb25FdmVudH0gY29sbGVjdGlvbkV2ZW50IENvbGxlY3Rpb25FdmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIExheWVyR3JvdXAucHJvdG90eXBlLmhhbmRsZUxheWVyc0FkZF8gPSBmdW5jdGlvbiBoYW5kbGVMYXllcnNBZGRfIChjb2xsZWN0aW9uRXZlbnQpIHtcbiAgICB2YXIgbGF5ZXIgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vQmFzZS5qc1wiKS5kZWZhdWx0fSAqLyAoY29sbGVjdGlvbkV2ZW50LmVsZW1lbnQpO1xuICAgIHRoaXMubGlzdGVuZXJLZXlzX1tnZXRVaWQobGF5ZXIpXSA9IFtcbiAgICAgIGxpc3RlbihsYXllciwgT2JqZWN0RXZlbnRUeXBlLlBST1BFUlRZQ0hBTkdFLCB0aGlzLmhhbmRsZUxheWVyQ2hhbmdlXywgdGhpcyksXG4gICAgICBsaXN0ZW4obGF5ZXIsIEV2ZW50VHlwZS5DSEFOR0UsIHRoaXMuaGFuZGxlTGF5ZXJDaGFuZ2VfLCB0aGlzKVxuICAgIF07XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vQ29sbGVjdGlvbi5qc1wiKS5Db2xsZWN0aW9uRXZlbnR9IGNvbGxlY3Rpb25FdmVudCBDb2xsZWN0aW9uRXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBMYXllckdyb3VwLnByb3RvdHlwZS5oYW5kbGVMYXllcnNSZW1vdmVfID0gZnVuY3Rpb24gaGFuZGxlTGF5ZXJzUmVtb3ZlXyAoY29sbGVjdGlvbkV2ZW50KSB7XG4gICAgdmFyIGxheWVyID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL0Jhc2UuanNcIikuZGVmYXVsdH0gKi8gKGNvbGxlY3Rpb25FdmVudC5lbGVtZW50KTtcbiAgICB2YXIga2V5ID0gZ2V0VWlkKGxheWVyKTtcbiAgICB0aGlzLmxpc3RlbmVyS2V5c19ba2V5XS5mb3JFYWNoKHVubGlzdGVuQnlLZXkpO1xuICAgIGRlbGV0ZSB0aGlzLmxpc3RlbmVyS2V5c19ba2V5XTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUge0BsaW5rIG1vZHVsZTpvbC9Db2xsZWN0aW9uIGNvbGxlY3Rpb259IG9mIHtAbGluayBtb2R1bGU6b2wvbGF5ZXIvTGF5ZXJ+TGF5ZXIgbGF5ZXJzfVxuICAgKiBpbiB0aGlzIGdyb3VwLlxuICAgKiBAcmV0dXJuIHshaW1wb3J0KFwiLi4vQ29sbGVjdGlvbi5qc1wiKS5kZWZhdWx0PGltcG9ydChcIi4vQmFzZS5qc1wiKS5kZWZhdWx0Pn0gQ29sbGVjdGlvbiBvZlxuICAgKiAgIHtAbGluayBtb2R1bGU6b2wvbGF5ZXIvQmFzZSBsYXllcnN9IHRoYXQgYXJlIHBhcnQgb2YgdGhpcyBncm91cC5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgTGF5ZXJHcm91cC5wcm90b3R5cGUuZ2V0TGF5ZXJzID0gZnVuY3Rpb24gZ2V0TGF5ZXJzICgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgLyoqIEB0eXBlIHshaW1wb3J0KFwiLi4vQ29sbGVjdGlvbi5qc1wiKS5kZWZhdWx0PGltcG9ydChcIi4vQmFzZS5qc1wiKS5kZWZhdWx0Pn0gKi8gKHRoaXMuZ2V0KFByb3BlcnR5LkxBWUVSUykpXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSB7QGxpbmsgbW9kdWxlOm9sL0NvbGxlY3Rpb24gY29sbGVjdGlvbn0gb2Yge0BsaW5rIG1vZHVsZTpvbC9sYXllci9MYXllcn5MYXllciBsYXllcnN9XG4gICAqIGluIHRoaXMgZ3JvdXAuXG4gICAqIEBwYXJhbSB7IWltcG9ydChcIi4uL0NvbGxlY3Rpb24uanNcIikuZGVmYXVsdDxpbXBvcnQoXCIuL0Jhc2UuanNcIikuZGVmYXVsdD59IGxheWVycyBDb2xsZWN0aW9uIG9mXG4gICAqICAge0BsaW5rIG1vZHVsZTpvbC9sYXllci9CYXNlIGxheWVyc30gdGhhdCBhcmUgcGFydCBvZiB0aGlzIGdyb3VwLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBMYXllckdyb3VwLnByb3RvdHlwZS5zZXRMYXllcnMgPSBmdW5jdGlvbiBzZXRMYXllcnMgKGxheWVycykge1xuICAgIHRoaXMuc2V0KFByb3BlcnR5LkxBWUVSUywgbGF5ZXJzKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIExheWVyR3JvdXAucHJvdG90eXBlLmdldExheWVyc0FycmF5ID0gZnVuY3Rpb24gZ2V0TGF5ZXJzQXJyYXkgKG9wdF9hcnJheSkge1xuICAgIHZhciBhcnJheSA9IG9wdF9hcnJheSAhPT0gdW5kZWZpbmVkID8gb3B0X2FycmF5IDogW107XG4gICAgdGhpcy5nZXRMYXllcnMoKS5mb3JFYWNoKGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgICBsYXllci5nZXRMYXllcnNBcnJheShhcnJheSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFycmF5O1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgTGF5ZXJHcm91cC5wcm90b3R5cGUuZ2V0TGF5ZXJTdGF0ZXNBcnJheSA9IGZ1bmN0aW9uIGdldExheWVyU3RhdGVzQXJyYXkgKG9wdF9zdGF0ZXMpIHtcbiAgICB2YXIgc3RhdGVzID0gb3B0X3N0YXRlcyAhPT0gdW5kZWZpbmVkID8gb3B0X3N0YXRlcyA6IFtdO1xuXG4gICAgdmFyIHBvcyA9IHN0YXRlcy5sZW5ndGg7XG5cbiAgICB0aGlzLmdldExheWVycygpLmZvckVhY2goZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgIGxheWVyLmdldExheWVyU3RhdGVzQXJyYXkoc3RhdGVzKTtcbiAgICB9KTtcblxuICAgIHZhciBvd25MYXllclN0YXRlID0gdGhpcy5nZXRMYXllclN0YXRlKCk7XG4gICAgZm9yICh2YXIgaSA9IHBvcywgaWkgPSBzdGF0ZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgdmFyIGxheWVyU3RhdGUgPSBzdGF0ZXNbaV07XG4gICAgICBsYXllclN0YXRlLm9wYWNpdHkgKj0gb3duTGF5ZXJTdGF0ZS5vcGFjaXR5O1xuICAgICAgbGF5ZXJTdGF0ZS52aXNpYmxlID0gbGF5ZXJTdGF0ZS52aXNpYmxlICYmIG93bkxheWVyU3RhdGUudmlzaWJsZTtcbiAgICAgIGxheWVyU3RhdGUubWF4UmVzb2x1dGlvbiA9IE1hdGgubWluKFxuICAgICAgICBsYXllclN0YXRlLm1heFJlc29sdXRpb24sIG93bkxheWVyU3RhdGUubWF4UmVzb2x1dGlvbik7XG4gICAgICBsYXllclN0YXRlLm1pblJlc29sdXRpb24gPSBNYXRoLm1heChcbiAgICAgICAgbGF5ZXJTdGF0ZS5taW5SZXNvbHV0aW9uLCBvd25MYXllclN0YXRlLm1pblJlc29sdXRpb24pO1xuICAgICAgaWYgKG93bkxheWVyU3RhdGUuZXh0ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGxheWVyU3RhdGUuZXh0ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBsYXllclN0YXRlLmV4dGVudCA9IGdldEludGVyc2VjdGlvbihsYXllclN0YXRlLmV4dGVudCwgb3duTGF5ZXJTdGF0ZS5leHRlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxheWVyU3RhdGUuZXh0ZW50ID0gb3duTGF5ZXJTdGF0ZS5leHRlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RhdGVzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgTGF5ZXJHcm91cC5wcm90b3R5cGUuZ2V0U291cmNlU3RhdGUgPSBmdW5jdGlvbiBnZXRTb3VyY2VTdGF0ZSAoKSB7XG4gICAgcmV0dXJuIFNvdXJjZVN0YXRlLlJFQURZO1xuICB9O1xuXG4gIHJldHVybiBMYXllckdyb3VwO1xufShCYXNlTGF5ZXIpKTtcblxuXG5leHBvcnQgZGVmYXVsdCBMYXllckdyb3VwO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Hcm91cC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvbGF5ZXIvTGF5ZXJcbiAqL1xuaW1wb3J0IHtsaXN0ZW4sIHVubGlzdGVuQnlLZXl9IGZyb20gJy4uL2V2ZW50cy5qcyc7XG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4uL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4uL3V0aWwuanMnO1xuaW1wb3J0IHtnZXRDaGFuZ2VFdmVudFR5cGV9IGZyb20gJy4uL09iamVjdC5qcyc7XG5pbXBvcnQgQmFzZUxheWVyIGZyb20gJy4vQmFzZS5qcyc7XG5pbXBvcnQgTGF5ZXJQcm9wZXJ0eSBmcm9tICcuL1Byb3BlcnR5LmpzJztcbmltcG9ydCB7YXNzaWdufSBmcm9tICcuLi9vYmouanMnO1xuaW1wb3J0IFJlbmRlckV2ZW50VHlwZSBmcm9tICcuLi9yZW5kZXIvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBTb3VyY2VTdGF0ZSBmcm9tICcuLi9zb3VyY2UvU3RhdGUuanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtvcGFjaXR5PTFdIE9wYWNpdHkgKDAsIDEpLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbdmlzaWJsZT10cnVlXSBWaXNpYmlsaXR5LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBbZXh0ZW50XSBUaGUgYm91bmRpbmcgZXh0ZW50IGZvciBsYXllciByZW5kZXJpbmcuICBUaGUgbGF5ZXIgd2lsbCBub3QgYmVcbiAqIHJlbmRlcmVkIG91dHNpZGUgb2YgdGhpcyBleHRlbnQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3pJbmRleF0gVGhlIHotaW5kZXggZm9yIGxheWVyIHJlbmRlcmluZy4gIEF0IHJlbmRlcmluZyB0aW1lLCB0aGUgbGF5ZXJzXG4gKiB3aWxsIGJlIG9yZGVyZWQsIGZpcnN0IGJ5IFotaW5kZXggYW5kIHRoZW4gYnkgcG9zaXRpb24uIFdoZW4gYHVuZGVmaW5lZGAsIGEgYHpJbmRleGAgb2YgMCBpcyBhc3N1bWVkXG4gKiBmb3IgbGF5ZXJzIHRoYXQgYXJlIGFkZGVkIHRvIHRoZSBtYXAncyBgbGF5ZXJzYCBjb2xsZWN0aW9uLCBvciBgSW5maW5pdHlgIHdoZW4gdGhlIGxheWVyJ3MgYHNldE1hcCgpYFxuICogbWV0aG9kIHdhcyB1c2VkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5SZXNvbHV0aW9uXSBUaGUgbWluaW11bSByZXNvbHV0aW9uIChpbmNsdXNpdmUpIGF0IHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZVxuICogdmlzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4UmVzb2x1dGlvbl0gVGhlIG1heGltdW0gcmVzb2x1dGlvbiAoZXhjbHVzaXZlKSBiZWxvdyB3aGljaCB0aGlzIGxheWVyIHdpbGxcbiAqIGJlIHZpc2libGUuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3NvdXJjZS9Tb3VyY2UuanNcIikuZGVmYXVsdH0gW3NvdXJjZV0gU291cmNlIGZvciB0aGlzIGxheWVyLiAgSWYgbm90IHByb3ZpZGVkIHRvIHRoZSBjb25zdHJ1Y3RvcixcbiAqIHRoZSBzb3VyY2UgY2FuIGJlIHNldCBieSBjYWxsaW5nIHtAbGluayBtb2R1bGU6b2wvbGF5ZXIvTGF5ZXIjc2V0U291cmNlIGxheWVyLnNldFNvdXJjZShzb3VyY2UpfSBhZnRlclxuICogY29uc3RydWN0aW9uLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuZGVmYXVsdH0gW21hcF0gTWFwLlxuICovXG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTdGF0ZVxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL0Jhc2UuanNcIikuZGVmYXVsdH0gbGF5ZXJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBvcGFjaXR5XG4gKiBAcHJvcGVydHkge1NvdXJjZVN0YXRlfSBzb3VyY2VTdGF0ZVxuICogQHByb3BlcnR5IHtib29sZWFufSB2aXNpYmxlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IG1hbmFnZWRcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW2V4dGVudF1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB6SW5kZXhcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhSZXNvbHV0aW9uXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWluUmVzb2x1dGlvblxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWJzdHJhY3QgYmFzZSBjbGFzczsgbm9ybWFsbHkgb25seSB1c2VkIGZvciBjcmVhdGluZyBzdWJjbGFzc2VzIGFuZCBub3RcbiAqIGluc3RhbnRpYXRlZCBpbiBhcHBzLlxuICogQSB2aXN1YWwgcmVwcmVzZW50YXRpb24gb2YgcmFzdGVyIG9yIHZlY3RvciBtYXAgZGF0YS5cbiAqIExheWVycyBncm91cCB0b2dldGhlciB0aG9zZSBwcm9wZXJ0aWVzIHRoYXQgcGVydGFpbiB0byBob3cgdGhlIGRhdGEgaXMgdG8gYmVcbiAqIGRpc3BsYXllZCwgaXJyZXNwZWN0aXZlIG9mIHRoZSBzb3VyY2Ugb2YgdGhhdCBkYXRhLlxuICpcbiAqIExheWVycyBhcmUgdXN1YWxseSBhZGRlZCB0byBhIG1hcCB3aXRoIHtAbGluayBtb2R1bGU6b2wvTWFwI2FkZExheWVyfS4gQ29tcG9uZW50c1xuICogbGlrZSB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL1NlbGVjdH5TZWxlY3R9IHVzZSB1bm1hbmFnZWQgbGF5ZXJzXG4gKiBpbnRlcm5hbGx5LiBUaGVzZSB1bm1hbmFnZWQgbGF5ZXJzIGFyZSBhc3NvY2lhdGVkIHdpdGggdGhlIG1hcCB1c2luZ1xuICoge0BsaW5rIG1vZHVsZTpvbC9sYXllci9MYXllcn5MYXllciNzZXRNYXB9IGluc3RlYWQuXG4gKlxuICogQSBnZW5lcmljIGBjaGFuZ2VgIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIHN0YXRlIG9mIHRoZSBzb3VyY2UgY2hhbmdlcy5cbiAqXG4gKiBAZmlyZXMgaW1wb3J0KFwiLi4vcmVuZGVyL0V2ZW50LmpzXCIpLlJlbmRlckV2ZW50XG4gKi9cbnZhciBMYXllciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEJhc2VMYXllcikge1xuICBmdW5jdGlvbiBMYXllcihvcHRpb25zKSB7XG5cbiAgICB2YXIgYmFzZU9wdGlvbnMgPSBhc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgIGRlbGV0ZSBiYXNlT3B0aW9ucy5zb3VyY2U7XG5cbiAgICBCYXNlTGF5ZXIuY2FsbCh0aGlzLCBiYXNlT3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleX1cbiAgICAgKi9cbiAgICB0aGlzLm1hcFByZWNvbXBvc2VLZXlfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuLi9ldmVudHMuanNcIikuRXZlbnRzS2V5fVxuICAgICAqL1xuICAgIHRoaXMubWFwUmVuZGVyS2V5XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleX1cbiAgICAgKi9cbiAgICB0aGlzLnNvdXJjZUNoYW5nZUtleV8gPSBudWxsO1xuXG4gICAgaWYgKG9wdGlvbnMubWFwKSB7XG4gICAgICB0aGlzLnNldE1hcChvcHRpb25zLm1hcCk7XG4gICAgfVxuXG4gICAgbGlzdGVuKHRoaXMsXG4gICAgICBnZXRDaGFuZ2VFdmVudFR5cGUoTGF5ZXJQcm9wZXJ0eS5TT1VSQ0UpLFxuICAgICAgdGhpcy5oYW5kbGVTb3VyY2VQcm9wZXJ0eUNoYW5nZV8sIHRoaXMpO1xuXG4gICAgdmFyIHNvdXJjZSA9IG9wdGlvbnMuc291cmNlID8gb3B0aW9ucy5zb3VyY2UgOiBudWxsO1xuICAgIHRoaXMuc2V0U291cmNlKHNvdXJjZSk7XG4gIH1cblxuICBpZiAoIEJhc2VMYXllciApIExheWVyLl9fcHJvdG9fXyA9IEJhc2VMYXllcjtcbiAgTGF5ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQmFzZUxheWVyICYmIEJhc2VMYXllci5wcm90b3R5cGUgKTtcbiAgTGF5ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGF5ZXI7XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBMYXllci5wcm90b3R5cGUuZ2V0TGF5ZXJzQXJyYXkgPSBmdW5jdGlvbiBnZXRMYXllcnNBcnJheSAob3B0X2FycmF5KSB7XG4gICAgdmFyIGFycmF5ID0gb3B0X2FycmF5ID8gb3B0X2FycmF5IDogW107XG4gICAgYXJyYXkucHVzaCh0aGlzKTtcbiAgICByZXR1cm4gYXJyYXk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBMYXllci5wcm90b3R5cGUuZ2V0TGF5ZXJTdGF0ZXNBcnJheSA9IGZ1bmN0aW9uIGdldExheWVyU3RhdGVzQXJyYXkgKG9wdF9zdGF0ZXMpIHtcbiAgICB2YXIgc3RhdGVzID0gb3B0X3N0YXRlcyA/IG9wdF9zdGF0ZXMgOiBbXTtcbiAgICBzdGF0ZXMucHVzaCh0aGlzLmdldExheWVyU3RhdGUoKSk7XG4gICAgcmV0dXJuIHN0YXRlcztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBsYXllciBzb3VyY2UuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3NvdXJjZS9Tb3VyY2UuanNcIikuZGVmYXVsdH0gVGhlIGxheWVyIHNvdXJjZSAob3IgYG51bGxgIGlmIG5vdCB5ZXQgc2V0KS5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgTGF5ZXIucHJvdG90eXBlLmdldFNvdXJjZSA9IGZ1bmN0aW9uIGdldFNvdXJjZSAoKSB7XG4gICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0KExheWVyUHJvcGVydHkuU09VUkNFKTtcbiAgICByZXR1cm4gKFxuICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9zb3VyY2UvU291cmNlLmpzXCIpLmRlZmF1bHR9ICovIChzb3VyY2UpIHx8IG51bGxcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgICogQGluaGVyaXREb2NcbiAgICAqL1xuICBMYXllci5wcm90b3R5cGUuZ2V0U291cmNlU3RhdGUgPSBmdW5jdGlvbiBnZXRTb3VyY2VTdGF0ZSAoKSB7XG4gICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCk7XG4gICAgcmV0dXJuICFzb3VyY2UgPyBTb3VyY2VTdGF0ZS5VTkRFRklORUQgOiBzb3VyY2UuZ2V0U3RhdGUoKTtcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIExheWVyLnByb3RvdHlwZS5oYW5kbGVTb3VyY2VDaGFuZ2VfID0gZnVuY3Rpb24gaGFuZGxlU291cmNlQ2hhbmdlXyAoKSB7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBMYXllci5wcm90b3R5cGUuaGFuZGxlU291cmNlUHJvcGVydHlDaGFuZ2VfID0gZnVuY3Rpb24gaGFuZGxlU291cmNlUHJvcGVydHlDaGFuZ2VfICgpIHtcbiAgICBpZiAodGhpcy5zb3VyY2VDaGFuZ2VLZXlfKSB7XG4gICAgICB1bmxpc3RlbkJ5S2V5KHRoaXMuc291cmNlQ2hhbmdlS2V5Xyk7XG4gICAgICB0aGlzLnNvdXJjZUNoYW5nZUtleV8gPSBudWxsO1xuICAgIH1cbiAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKTtcbiAgICBpZiAoc291cmNlKSB7XG4gICAgICB0aGlzLnNvdXJjZUNoYW5nZUtleV8gPSBsaXN0ZW4oc291cmNlLFxuICAgICAgICBFdmVudFR5cGUuQ0hBTkdFLCB0aGlzLmhhbmRsZVNvdXJjZUNoYW5nZV8sIHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB0aGUgbGF5ZXIgdG8gYmUgcmVuZGVyZWQgb24gdG9wIG9mIG90aGVyIGxheWVycyBvbiBhIG1hcC4gVGhlIG1hcCB3aWxsXG4gICAqIG5vdCBtYW5hZ2UgdGhpcyBsYXllciBpbiBpdHMgbGF5ZXJzIGNvbGxlY3Rpb24sIGFuZCB0aGUgY2FsbGJhY2sgaW5cbiAgICoge0BsaW5rIG1vZHVsZTpvbC9NYXAjZm9yRWFjaExheWVyQXRQaXhlbH0gd2lsbCByZWNlaXZlIGBudWxsYCBhcyBsYXllci4gVGhpc1xuICAgKiBpcyB1c2VmdWwgZm9yIHRlbXBvcmFyeSBsYXllcnMuIFRvIHJlbW92ZSBhbiB1bm1hbmFnZWQgbGF5ZXIgZnJvbSB0aGUgbWFwLFxuICAgKiB1c2UgYCNzZXRNYXAobnVsbClgLlxuICAgKlxuICAgKiBUbyBhZGQgdGhlIGxheWVyIHRvIGEgbWFwIGFuZCBoYXZlIGl0IG1hbmFnZWQgYnkgdGhlIG1hcCwgdXNlXG4gICAqIHtAbGluayBtb2R1bGU6b2wvTWFwI2FkZExheWVyfSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1BsdWdnYWJsZU1hcC5qc1wiKS5kZWZhdWx0fSBtYXAgTWFwLlxuICAgKiBAYXBpXG4gICAqL1xuICBMYXllci5wcm90b3R5cGUuc2V0TWFwID0gZnVuY3Rpb24gc2V0TWFwIChtYXApIHtcbiAgICBpZiAodGhpcy5tYXBQcmVjb21wb3NlS2V5Xykge1xuICAgICAgdW5saXN0ZW5CeUtleSh0aGlzLm1hcFByZWNvbXBvc2VLZXlfKTtcbiAgICAgIHRoaXMubWFwUHJlY29tcG9zZUtleV8gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoIW1hcCkge1xuICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hcFJlbmRlcktleV8pIHtcbiAgICAgIHVubGlzdGVuQnlLZXkodGhpcy5tYXBSZW5kZXJLZXlfKTtcbiAgICAgIHRoaXMubWFwUmVuZGVyS2V5XyA9IG51bGw7XG4gICAgfVxuICAgIGlmIChtYXApIHtcbiAgICAgIHRoaXMubWFwUHJlY29tcG9zZUtleV8gPSBsaXN0ZW4obWFwLCBSZW5kZXJFdmVudFR5cGUuUFJFQ09NUE9TRSwgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHZhciByZW5kZXJFdmVudCA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vcmVuZGVyL0V2ZW50LmpzXCIpLmRlZmF1bHR9ICovIChldnQpO1xuICAgICAgICB2YXIgbGF5ZXJTdGF0ZSA9IHRoaXMuZ2V0TGF5ZXJTdGF0ZSgpO1xuICAgICAgICBsYXllclN0YXRlLm1hbmFnZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuZ2V0WkluZGV4KCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGxheWVyU3RhdGUuekluZGV4ID0gSW5maW5pdHk7XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyRXZlbnQuZnJhbWVTdGF0ZS5sYXllclN0YXRlc0FycmF5LnB1c2gobGF5ZXJTdGF0ZSk7XG4gICAgICAgIHJlbmRlckV2ZW50LmZyYW1lU3RhdGUubGF5ZXJTdGF0ZXNbZ2V0VWlkKHRoaXMpXSA9IGxheWVyU3RhdGU7XG4gICAgICB9LCB0aGlzKTtcbiAgICAgIHRoaXMubWFwUmVuZGVyS2V5XyA9IGxpc3Rlbih0aGlzLCBFdmVudFR5cGUuQ0hBTkdFLCBtYXAucmVuZGVyLCBtYXApO1xuICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGxheWVyIHNvdXJjZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zb3VyY2UvU291cmNlLmpzXCIpLmRlZmF1bHR9IHNvdXJjZSBUaGUgbGF5ZXIgc291cmNlLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBMYXllci5wcm90b3R5cGUuc2V0U291cmNlID0gZnVuY3Rpb24gc2V0U291cmNlIChzb3VyY2UpIHtcbiAgICB0aGlzLnNldChMYXllclByb3BlcnR5LlNPVVJDRSwgc291cmNlKTtcbiAgfTtcblxuICByZXR1cm4gTGF5ZXI7XG59KEJhc2VMYXllcikpO1xuXG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgbGF5ZXIgaXMgdmlzaWJsZSwgYW5kIGlmIHRoZSBwYXNzZWQgcmVzb2x1dGlvbiBpc1xuICogYmV0d2VlbiB0aGUgbGF5ZXIncyBtaW5SZXNvbHV0aW9uIGFuZCBtYXhSZXNvbHV0aW9uLiBUaGUgY29tcGFyaXNvbiBpc1xuICogaW5jbHVzaXZlIGZvciBgbWluUmVzb2x1dGlvbmAgYW5kIGV4Y2x1c2l2ZSBmb3IgYG1heFJlc29sdXRpb25gLlxuICogQHBhcmFtIHtTdGF0ZX0gbGF5ZXJTdGF0ZSBMYXllciBzdGF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgbGF5ZXIgaXMgdmlzaWJsZSBhdCB0aGUgZ2l2ZW4gcmVzb2x1dGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZpc2libGVBdFJlc29sdXRpb24obGF5ZXJTdGF0ZSwgcmVzb2x1dGlvbikge1xuICByZXR1cm4gbGF5ZXJTdGF0ZS52aXNpYmxlICYmIHJlc29sdXRpb24gPj0gbGF5ZXJTdGF0ZS5taW5SZXNvbHV0aW9uICYmXG4gICAgICByZXNvbHV0aW9uIDwgbGF5ZXJTdGF0ZS5tYXhSZXNvbHV0aW9uO1xufVxuXG5cbmV4cG9ydCBkZWZhdWx0IExheWVyO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1MYXllci5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvbGF5ZXIvUHJvcGVydHlcbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgT1BBQ0lUWTogJ29wYWNpdHknLFxuICBWSVNJQkxFOiAndmlzaWJsZScsXG4gIEVYVEVOVDogJ2V4dGVudCcsXG4gIFpfSU5ERVg6ICd6SW5kZXgnLFxuICBNQVhfUkVTT0xVVElPTjogJ21heFJlc29sdXRpb24nLFxuICBNSU5fUkVTT0xVVElPTjogJ21pblJlc29sdXRpb24nLFxuICBTT1VSQ0U6ICdzb3VyY2UnXG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qcm9wZXJ0eS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvbGF5ZXIvVGlsZVxuICovXG5pbXBvcnQgTGF5ZXJUeXBlIGZyb20gJy4uL0xheWVyVHlwZS5qcyc7XG5pbXBvcnQgTGF5ZXIgZnJvbSAnLi9MYXllci5qcyc7XG5pbXBvcnQgVGlsZVByb3BlcnR5IGZyb20gJy4vVGlsZVByb3BlcnR5LmpzJztcbmltcG9ydCB7YXNzaWdufSBmcm9tICcuLi9vYmouanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtvcGFjaXR5PTFdIE9wYWNpdHkgKDAsIDEpLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbdmlzaWJsZT10cnVlXSBWaXNpYmlsaXR5LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBbZXh0ZW50XSBUaGUgYm91bmRpbmcgZXh0ZW50IGZvciBsYXllciByZW5kZXJpbmcuICBUaGUgbGF5ZXIgd2lsbCBub3QgYmVcbiAqIHJlbmRlcmVkIG91dHNpZGUgb2YgdGhpcyBleHRlbnQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3pJbmRleF0gVGhlIHotaW5kZXggZm9yIGxheWVyIHJlbmRlcmluZy4gIEF0IHJlbmRlcmluZyB0aW1lLCB0aGUgbGF5ZXJzXG4gKiB3aWxsIGJlIG9yZGVyZWQsIGZpcnN0IGJ5IFotaW5kZXggYW5kIHRoZW4gYnkgcG9zaXRpb24uIFdoZW4gYHVuZGVmaW5lZGAsIGEgYHpJbmRleGAgb2YgMCBpcyBhc3N1bWVkXG4gKiBmb3IgbGF5ZXJzIHRoYXQgYXJlIGFkZGVkIHRvIHRoZSBtYXAncyBgbGF5ZXJzYCBjb2xsZWN0aW9uLCBvciBgSW5maW5pdHlgIHdoZW4gdGhlIGxheWVyJ3MgYHNldE1hcCgpYFxuICogbWV0aG9kIHdhcyB1c2VkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5SZXNvbHV0aW9uXSBUaGUgbWluaW11bSByZXNvbHV0aW9uIChpbmNsdXNpdmUpIGF0IHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZVxuICogdmlzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4UmVzb2x1dGlvbl0gVGhlIG1heGltdW0gcmVzb2x1dGlvbiAoZXhjbHVzaXZlKSBiZWxvdyB3aGljaCB0aGlzIGxheWVyIHdpbGxcbiAqIGJlIHZpc2libGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3ByZWxvYWQ9MF0gUHJlbG9hZC4gTG9hZCBsb3ctcmVzb2x1dGlvbiB0aWxlcyB1cCB0byBgcHJlbG9hZGAgbGV2ZWxzLiBgMGBcbiAqIG1lYW5zIG5vIHByZWxvYWRpbmcuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3NvdXJjZS9UaWxlLmpzXCIpLmRlZmF1bHR9IFtzb3VyY2VdIFNvdXJjZSBmb3IgdGhpcyBsYXllci5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLmRlZmF1bHR9IFttYXBdIFNldHMgdGhlIGxheWVyIGFzIG92ZXJsYXkgb24gYSBtYXAuIFRoZSBtYXAgd2lsbCBub3QgbWFuYWdlXG4gKiB0aGlzIGxheWVyIGluIGl0cyBsYXllcnMgY29sbGVjdGlvbiwgYW5kIHRoZSBsYXllciB3aWxsIGJlIHJlbmRlcmVkIG9uIHRvcC4gVGhpcyBpcyB1c2VmdWwgZm9yXG4gKiB0ZW1wb3JhcnkgbGF5ZXJzLiBUaGUgc3RhbmRhcmQgd2F5IHRvIGFkZCBhIGxheWVyIHRvIGEgbWFwIGFuZCBoYXZlIGl0IG1hbmFnZWQgYnkgdGhlIG1hcCBpcyB0b1xuICogdXNlIHtAbGluayBtb2R1bGU6b2wvTWFwI2FkZExheWVyfS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3VzZUludGVyaW1UaWxlc09uRXJyb3I9dHJ1ZV0gVXNlIGludGVyaW0gdGlsZXMgb24gZXJyb3IuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBGb3IgbGF5ZXIgc291cmNlcyB0aGF0IHByb3ZpZGUgcHJlLXJlbmRlcmVkLCB0aWxlZCBpbWFnZXMgaW4gZ3JpZHMgdGhhdCBhcmVcbiAqIG9yZ2FuaXplZCBieSB6b29tIGxldmVscyBmb3Igc3BlY2lmaWMgcmVzb2x1dGlvbnMuXG4gKiBOb3RlIHRoYXQgYW55IHByb3BlcnR5IHNldCBpbiB0aGUgb3B0aW9ucyBpcyBzZXQgYXMgYSB7QGxpbmsgbW9kdWxlOm9sL09iamVjdH5CYXNlT2JqZWN0fVxuICogcHJvcGVydHkgb24gdGhlIGxheWVyIG9iamVjdDsgZm9yIGV4YW1wbGUsIHNldHRpbmcgYHRpdGxlOiAnTXkgVGl0bGUnYCBpbiB0aGVcbiAqIG9wdGlvbnMgbWVhbnMgdGhhdCBgdGl0bGVgIGlzIG9ic2VydmFibGUsIGFuZCBoYXMgZ2V0L3NldCBhY2Nlc3NvcnMuXG4gKlxuICogQGFwaVxuICovXG52YXIgVGlsZUxheWVyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoTGF5ZXIpIHtcbiAgZnVuY3Rpb24gVGlsZUxheWVyKG9wdF9vcHRpb25zKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRfb3B0aW9ucyA/IG9wdF9vcHRpb25zIDoge307XG5cbiAgICB2YXIgYmFzZU9wdGlvbnMgPSBhc3NpZ24oe30sIG9wdGlvbnMpO1xuXG4gICAgZGVsZXRlIGJhc2VPcHRpb25zLnByZWxvYWQ7XG4gICAgZGVsZXRlIGJhc2VPcHRpb25zLnVzZUludGVyaW1UaWxlc09uRXJyb3I7XG4gICAgTGF5ZXIuY2FsbCh0aGlzLCBiYXNlT3B0aW9ucyk7XG5cbiAgICB0aGlzLnNldFByZWxvYWQob3B0aW9ucy5wcmVsb2FkICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnByZWxvYWQgOiAwKTtcbiAgICB0aGlzLnNldFVzZUludGVyaW1UaWxlc09uRXJyb3Iob3B0aW9ucy51c2VJbnRlcmltVGlsZXNPbkVycm9yICE9PSB1bmRlZmluZWQgP1xuICAgICAgb3B0aW9ucy51c2VJbnRlcmltVGlsZXNPbkVycm9yIDogdHJ1ZSk7XG5cbiAgICAvKipcbiAgICAqIFRoZSBsYXllciB0eXBlLlxuICAgICogQHByb3RlY3RlZFxuICAgICogQHR5cGUge2ltcG9ydChcIi4uL0xheWVyVHlwZS5qc1wiKS5kZWZhdWx0fVxuICAgICovXG4gICAgdGhpcy50eXBlID0gTGF5ZXJUeXBlLlRJTEU7XG5cbiAgfVxuXG4gIGlmICggTGF5ZXIgKSBUaWxlTGF5ZXIuX19wcm90b19fID0gTGF5ZXI7XG4gIFRpbGVMYXllci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBMYXllciAmJiBMYXllci5wcm90b3R5cGUgKTtcbiAgVGlsZUxheWVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRpbGVMYXllcjtcblxuICAvKipcbiAgKiBSZXR1cm4gdGhlIGxldmVsIGFzIG51bWJlciB0byB3aGljaCB3ZSB3aWxsIHByZWxvYWQgdGlsZXMgdXAgdG8uXG4gICogQHJldHVybiB7bnVtYmVyfSBUaGUgbGV2ZWwgdG8gcHJlbG9hZCB0aWxlcyB1cCB0by5cbiAgKiBAb2JzZXJ2YWJsZVxuICAqIEBhcGlcbiAgKi9cbiAgVGlsZUxheWVyLnByb3RvdHlwZS5nZXRQcmVsb2FkID0gZnVuY3Rpb24gZ2V0UHJlbG9hZCAoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5nZXQoVGlsZVByb3BlcnR5LlBSRUxPQUQpKTtcbiAgfTtcblxuICAvKipcbiAgKiBTZXQgdGhlIGxldmVsIGFzIG51bWJlciB0byB3aGljaCB3ZSB3aWxsIHByZWxvYWQgdGlsZXMgdXAgdG8uXG4gICogQHBhcmFtIHtudW1iZXJ9IHByZWxvYWQgVGhlIGxldmVsIHRvIHByZWxvYWQgdGlsZXMgdXAgdG8uXG4gICogQG9ic2VydmFibGVcbiAgKiBAYXBpXG4gICovXG4gIFRpbGVMYXllci5wcm90b3R5cGUuc2V0UHJlbG9hZCA9IGZ1bmN0aW9uIHNldFByZWxvYWQgKHByZWxvYWQpIHtcbiAgICB0aGlzLnNldChUaWxlUHJvcGVydHkuUFJFTE9BRCwgcHJlbG9hZCk7XG4gIH07XG5cbiAgLyoqXG4gICogV2hldGhlciB3ZSB1c2UgaW50ZXJpbSB0aWxlcyBvbiBlcnJvci5cbiAgKiBAcmV0dXJuIHtib29sZWFufSBVc2UgaW50ZXJpbSB0aWxlcyBvbiBlcnJvci5cbiAgKiBAb2JzZXJ2YWJsZVxuICAqIEBhcGlcbiAgKi9cbiAgVGlsZUxheWVyLnByb3RvdHlwZS5nZXRVc2VJbnRlcmltVGlsZXNPbkVycm9yID0gZnVuY3Rpb24gZ2V0VXNlSW50ZXJpbVRpbGVzT25FcnJvciAoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi8gKHRoaXMuZ2V0KFRpbGVQcm9wZXJ0eS5VU0VfSU5URVJJTV9USUxFU19PTl9FUlJPUikpO1xuICB9O1xuXG4gIC8qKlxuICAqIFNldCB3aGV0aGVyIHdlIHVzZSBpbnRlcmltIHRpbGVzIG9uIGVycm9yLlxuICAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlSW50ZXJpbVRpbGVzT25FcnJvciBVc2UgaW50ZXJpbSB0aWxlcyBvbiBlcnJvci5cbiAgKiBAb2JzZXJ2YWJsZVxuICAqIEBhcGlcbiAgKi9cbiAgVGlsZUxheWVyLnByb3RvdHlwZS5zZXRVc2VJbnRlcmltVGlsZXNPbkVycm9yID0gZnVuY3Rpb24gc2V0VXNlSW50ZXJpbVRpbGVzT25FcnJvciAodXNlSW50ZXJpbVRpbGVzT25FcnJvcikge1xuICAgIHRoaXMuc2V0KFRpbGVQcm9wZXJ0eS5VU0VfSU5URVJJTV9USUxFU19PTl9FUlJPUiwgdXNlSW50ZXJpbVRpbGVzT25FcnJvcik7XG4gIH07XG5cbiAgcmV0dXJuIFRpbGVMYXllcjtcbn0oTGF5ZXIpKTtcblxuXG4vKipcbiAqIFJldHVybiB0aGUgYXNzb2NpYXRlZCB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9UaWxlIHRpbGVzb3VyY2V9IG9mIHRoZSBsYXllci5cbiAqIEBmdW5jdGlvblxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vc291cmNlL1RpbGUuanNcIikuZGVmYXVsdH0gU291cmNlLlxuICogQGFwaVxuICovXG5UaWxlTGF5ZXIucHJvdG90eXBlLmdldFNvdXJjZTtcblxuXG5leHBvcnQgZGVmYXVsdCBUaWxlTGF5ZXI7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpbGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2xheWVyL1RpbGVQcm9wZXJ0eVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBQUkVMT0FEOiAncHJlbG9hZCcsXG4gIFVTRV9JTlRFUklNX1RJTEVTX09OX0VSUk9SOiAndXNlSW50ZXJpbVRpbGVzT25FcnJvcidcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpbGVQcm9wZXJ0eS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvbGF5ZXIvVmVjdG9yXG4gKi9cbmltcG9ydCBMYXllclR5cGUgZnJvbSAnLi4vTGF5ZXJUeXBlLmpzJztcbmltcG9ydCBMYXllciBmcm9tICcuL0xheWVyLmpzJztcbmltcG9ydCBWZWN0b3JSZW5kZXJUeXBlIGZyb20gJy4vVmVjdG9yUmVuZGVyVHlwZS5qcyc7XG5pbXBvcnQge2Fzc2lnbn0gZnJvbSAnLi4vb2JqLmpzJztcbmltcG9ydCB7Y3JlYXRlRGVmYXVsdFN0eWxlLCB0b0Z1bmN0aW9uIGFzIHRvU3R5bGVGdW5jdGlvbn0gZnJvbSAnLi4vc3R5bGUvU3R5bGUuanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtvcGFjaXR5PTFdIE9wYWNpdHkgKDAsIDEpLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbdmlzaWJsZT10cnVlXSBWaXNpYmlsaXR5LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBbZXh0ZW50XSBUaGUgYm91bmRpbmcgZXh0ZW50IGZvciBsYXllciByZW5kZXJpbmcuICBUaGUgbGF5ZXIgd2lsbCBub3QgYmVcbiAqIHJlbmRlcmVkIG91dHNpZGUgb2YgdGhpcyBleHRlbnQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3pJbmRleF0gVGhlIHotaW5kZXggZm9yIGxheWVyIHJlbmRlcmluZy4gIEF0IHJlbmRlcmluZyB0aW1lLCB0aGUgbGF5ZXJzXG4gKiB3aWxsIGJlIG9yZGVyZWQsIGZpcnN0IGJ5IFotaW5kZXggYW5kIHRoZW4gYnkgcG9zaXRpb24uIFdoZW4gYHVuZGVmaW5lZGAsIGEgYHpJbmRleGAgb2YgMCBpcyBhc3N1bWVkXG4gKiBmb3IgbGF5ZXJzIHRoYXQgYXJlIGFkZGVkIHRvIHRoZSBtYXAncyBgbGF5ZXJzYCBjb2xsZWN0aW9uLCBvciBgSW5maW5pdHlgIHdoZW4gdGhlIGxheWVyJ3MgYHNldE1hcCgpYFxuICogbWV0aG9kIHdhcyB1c2VkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5SZXNvbHV0aW9uXSBUaGUgbWluaW11bSByZXNvbHV0aW9uIChpbmNsdXNpdmUpIGF0IHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZVxuICogdmlzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4UmVzb2x1dGlvbl0gVGhlIG1heGltdW0gcmVzb2x1dGlvbiAoZXhjbHVzaXZlKSBiZWxvdyB3aGljaCB0aGlzIGxheWVyIHdpbGxcbiAqIGJlIHZpc2libGUuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3JlbmRlci5qc1wiKS5PcmRlckZ1bmN0aW9ufSBbcmVuZGVyT3JkZXJdIFJlbmRlciBvcmRlci4gRnVuY3Rpb24gdG8gYmUgdXNlZCB3aGVuIHNvcnRpbmdcbiAqIGZlYXR1cmVzIGJlZm9yZSByZW5kZXJpbmcuIEJ5IGRlZmF1bHQgZmVhdHVyZXMgYXJlIGRyYXduIGluIHRoZSBvcmRlciB0aGF0IHRoZXkgYXJlIGNyZWF0ZWQuIFVzZVxuICogYG51bGxgIHRvIGF2b2lkIHRoZSBzb3J0LCBidXQgZ2V0IGFuIHVuZGVmaW5lZCBkcmF3IG9yZGVyLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyZW5kZXJCdWZmZXI9MTAwXSBUaGUgYnVmZmVyIGluIHBpeGVscyBhcm91bmQgdGhlIHZpZXdwb3J0IGV4dGVudCB1c2VkIGJ5IHRoZVxuICogcmVuZGVyZXIgd2hlbiBnZXR0aW5nIGZlYXR1cmVzIGZyb20gdGhlIHZlY3RvciBzb3VyY2UgZm9yIHRoZSByZW5kZXJpbmcgb3IgaGl0LWRldGVjdGlvbi5cbiAqIFJlY29tbWVuZGVkIHZhbHVlOiB0aGUgc2l6ZSBvZiB0aGUgbGFyZ2VzdCBzeW1ib2wsIGxpbmUgd2lkdGggb3IgbGFiZWwuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vVmVjdG9yUmVuZGVyVHlwZS5qc1wiKS5kZWZhdWx0fHN0cmluZ30gW3JlbmRlck1vZGU9J3ZlY3RvciddIFJlbmRlciBtb2RlIGZvciB2ZWN0b3IgbGF5ZXJzOlxuICogICogYCdpbWFnZSdgOiBWZWN0b3IgbGF5ZXJzIGFyZSByZW5kZXJlZCBhcyBpbWFnZXMuIEdyZWF0IHBlcmZvcm1hbmNlLCBidXQgcG9pbnQgc3ltYm9scyBhbmRcbiAqICAgIHRleHRzIGFyZSBhbHdheXMgcm90YXRlZCB3aXRoIHRoZSB2aWV3IGFuZCBwaXhlbHMgYXJlIHNjYWxlZCBkdXJpbmcgem9vbSBhbmltYXRpb25zLlxuICogICogYCd2ZWN0b3InYDogVmVjdG9yIGxheWVycyBhcmUgcmVuZGVyZWQgYXMgdmVjdG9ycy4gTW9zdCBhY2N1cmF0ZSByZW5kZXJpbmcgZXZlbiBkdXJpbmdcbiAqICAgIGFuaW1hdGlvbnMsIGJ1dCBzbG93ZXIgcGVyZm9ybWFuY2UuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3NvdXJjZS9WZWN0b3IuanNcIikuZGVmYXVsdH0gW3NvdXJjZV0gU291cmNlLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuZGVmYXVsdH0gW21hcF0gU2V0cyB0aGUgbGF5ZXIgYXMgb3ZlcmxheSBvbiBhIG1hcC4gVGhlIG1hcCB3aWxsIG5vdCBtYW5hZ2VcbiAqIHRoaXMgbGF5ZXIgaW4gaXRzIGxheWVycyBjb2xsZWN0aW9uLCBhbmQgdGhlIGxheWVyIHdpbGwgYmUgcmVuZGVyZWQgb24gdG9wLiBUaGlzIGlzIHVzZWZ1bCBmb3JcbiAqIHRlbXBvcmFyeSBsYXllcnMuIFRoZSBzdGFuZGFyZCB3YXkgdG8gYWRkIGEgbGF5ZXIgdG8gYSBtYXAgYW5kIGhhdmUgaXQgbWFuYWdlZCBieSB0aGUgbWFwIGlzIHRvXG4gKiB1c2Uge0BsaW5rIG1vZHVsZTpvbC9NYXAjYWRkTGF5ZXJ9LlxuICogQHByb3BlcnR5IHtib29sZWFufSBbZGVjbHV0dGVyPWZhbHNlXSBEZWNsdXR0ZXIgaW1hZ2VzIGFuZCB0ZXh0LiBEZWNsdXR0ZXJpbmcgaXMgYXBwbGllZCB0byBhbGxcbiAqIGltYWdlIGFuZCB0ZXh0IHN0eWxlcywgYW5kIHRoZSBwcmlvcml0eSBpcyBkZWZpbmVkIGJ5IHRoZSB6LWluZGV4IG9mIHRoZSBzdHlsZS4gTG93ZXIgei1pbmRleFxuICogbWVhbnMgaGlnaGVyIHByaW9yaXR5LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUxpa2V9IFtzdHlsZV0gTGF5ZXIgc3R5bGUuIFNlZVxuICoge0BsaW5rIG1vZHVsZTpvbC9zdHlsZX0gZm9yIGRlZmF1bHQgc3R5bGUgd2hpY2ggd2lsbCBiZSB1c2VkIGlmIHRoaXMgaXMgbm90IGRlZmluZWQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt1cGRhdGVXaGlsZUFuaW1hdGluZz1mYWxzZV0gV2hlbiBzZXQgdG8gYHRydWVgIGFuZCBgcmVuZGVyTW9kZWBcbiAqIGlzIGB2ZWN0b3JgLCBmZWF0dXJlIGJhdGNoZXMgd2lsbCBiZSByZWNyZWF0ZWQgZHVyaW5nIGFuaW1hdGlvbnMuIFRoaXMgbWVhbnMgdGhhdCBub1xuICogdmVjdG9ycyB3aWxsIGJlIHNob3duIGNsaXBwZWQsIGJ1dCB0aGUgc2V0dGluZyB3aWxsIGhhdmUgYSBwZXJmb3JtYW5jZSBpbXBhY3QgZm9yIGxhcmdlXG4gKiBhbW91bnRzIG9mIHZlY3RvciBkYXRhLiBXaGVuIHNldCB0byBgZmFsc2VgLCBiYXRjaGVzIHdpbGwgYmUgcmVjcmVhdGVkIHdoZW4gbm8gYW5pbWF0aW9uXG4gKiBpcyBhY3RpdmUuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt1cGRhdGVXaGlsZUludGVyYWN0aW5nPWZhbHNlXSBXaGVuIHNldCB0byBgdHJ1ZWAgYW5kIGByZW5kZXJNb2RlYFxuICogaXMgYHZlY3RvcmAsIGZlYXR1cmUgYmF0Y2hlcyB3aWxsIGJlIHJlY3JlYXRlZCBkdXJpbmcgaW50ZXJhY3Rpb25zLiBTZWUgYWxzb1xuICogYHVwZGF0ZVdoaWxlQW5pbWF0aW5nYC5cbiAqL1xuXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBQcm9wZXJ0eSA9IHtcbiAgUkVOREVSX09SREVSOiAncmVuZGVyT3JkZXInXG59O1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogVmVjdG9yIGRhdGEgdGhhdCBpcyByZW5kZXJlZCBjbGllbnQtc2lkZS5cbiAqIE5vdGUgdGhhdCBhbnkgcHJvcGVydHkgc2V0IGluIHRoZSBvcHRpb25zIGlzIHNldCBhcyBhIHtAbGluayBtb2R1bGU6b2wvT2JqZWN0fkJhc2VPYmplY3R9XG4gKiBwcm9wZXJ0eSBvbiB0aGUgbGF5ZXIgb2JqZWN0OyBmb3IgZXhhbXBsZSwgc2V0dGluZyBgdGl0bGU6ICdNeSBUaXRsZSdgIGluIHRoZVxuICogb3B0aW9ucyBtZWFucyB0aGF0IGB0aXRsZWAgaXMgb2JzZXJ2YWJsZSwgYW5kIGhhcyBnZXQvc2V0IGFjY2Vzc29ycy5cbiAqXG4gKiBAYXBpXG4gKi9cbnZhciBWZWN0b3JMYXllciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKExheWVyKSB7XG4gIGZ1bmN0aW9uIFZlY3RvckxheWVyKG9wdF9vcHRpb25zKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRfb3B0aW9ucyA/XG4gICAgICBvcHRfb3B0aW9ucyA6IC8qKiBAdHlwZSB7T3B0aW9uc30gKi8gKHt9KTtcblxuICAgIHZhciBiYXNlT3B0aW9ucyA9IGFzc2lnbih7fSwgb3B0aW9ucyk7XG5cbiAgICBkZWxldGUgYmFzZU9wdGlvbnMuc3R5bGU7XG4gICAgZGVsZXRlIGJhc2VPcHRpb25zLnJlbmRlckJ1ZmZlcjtcbiAgICBkZWxldGUgYmFzZU9wdGlvbnMudXBkYXRlV2hpbGVBbmltYXRpbmc7XG4gICAgZGVsZXRlIGJhc2VPcHRpb25zLnVwZGF0ZVdoaWxlSW50ZXJhY3Rpbmc7XG4gICAgTGF5ZXIuY2FsbCh0aGlzLCBiYXNlT3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAqIEBwcml2YXRlXG4gICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAqL1xuICAgIHRoaXMuZGVjbHV0dGVyXyA9IG9wdGlvbnMuZGVjbHV0dGVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRlY2x1dHRlciA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIHRoaXMucmVuZGVyQnVmZmVyXyA9IG9wdGlvbnMucmVuZGVyQnVmZmVyICE9PSB1bmRlZmluZWQgP1xuICAgICAgb3B0aW9ucy5yZW5kZXJCdWZmZXIgOiAxMDA7XG5cbiAgICAvKipcbiAgICAqIFVzZXIgcHJvdmlkZWQgc3R5bGUuXG4gICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVMaWtlfVxuICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIHRoaXMuc3R5bGVfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICogU3R5bGUgZnVuY3Rpb24gZm9yIHVzZSB3aXRoaW4gdGhlIGxpYnJhcnkuXG4gICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVGdW5jdGlvbnx1bmRlZmluZWR9XG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgdGhpcy5zdHlsZUZ1bmN0aW9uXyA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMuc2V0U3R5bGUob3B0aW9ucy5zdHlsZSk7XG5cbiAgICAvKipcbiAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIHRoaXMudXBkYXRlV2hpbGVBbmltYXRpbmdfID0gb3B0aW9ucy51cGRhdGVXaGlsZUFuaW1hdGluZyAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdGlvbnMudXBkYXRlV2hpbGVBbmltYXRpbmcgOiBmYWxzZTtcblxuICAgIC8qKlxuICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgdGhpcy51cGRhdGVXaGlsZUludGVyYWN0aW5nXyA9IG9wdGlvbnMudXBkYXRlV2hpbGVJbnRlcmFjdGluZyAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdGlvbnMudXBkYXRlV2hpbGVJbnRlcmFjdGluZyA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgKiBAcHJpdmF0ZVxuICAgICogQHR5cGUge2ltcG9ydChcIi4vVmVjdG9yVGlsZVJlbmRlclR5cGUuanNcIikuZGVmYXVsdHxzdHJpbmd9XG4gICAgKi9cbiAgICB0aGlzLnJlbmRlck1vZGVfID0gb3B0aW9ucy5yZW5kZXJNb2RlIHx8IFZlY3RvclJlbmRlclR5cGUuVkVDVE9SO1xuXG4gICAgLyoqXG4gICAgKiBUaGUgbGF5ZXIgdHlwZS5cbiAgICAqIEBwcm90ZWN0ZWRcbiAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9MYXllclR5cGUuanNcIikuZGVmYXVsdH1cbiAgICAqL1xuICAgIHRoaXMudHlwZSA9IExheWVyVHlwZS5WRUNUT1I7XG5cbiAgfVxuXG4gIGlmICggTGF5ZXIgKSBWZWN0b3JMYXllci5fX3Byb3RvX18gPSBMYXllcjtcbiAgVmVjdG9yTGF5ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTGF5ZXIgJiYgTGF5ZXIucHJvdG90eXBlICk7XG4gIFZlY3RvckxheWVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFZlY3RvckxheWVyO1xuXG4gIC8qKlxuICAqIEByZXR1cm4ge2Jvb2xlYW59IERlY2x1dHRlci5cbiAgKi9cbiAgVmVjdG9yTGF5ZXIucHJvdG90eXBlLmdldERlY2x1dHRlciA9IGZ1bmN0aW9uIGdldERlY2x1dHRlciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVjbHV0dGVyXztcbiAgfTtcblxuICAvKipcbiAgKiBAcGFyYW0ge2Jvb2xlYW59IGRlY2x1dHRlciBEZWNsdXR0ZXIuXG4gICovXG4gIFZlY3RvckxheWVyLnByb3RvdHlwZS5zZXREZWNsdXR0ZXIgPSBmdW5jdGlvbiBzZXREZWNsdXR0ZXIgKGRlY2x1dHRlcikge1xuICAgIHRoaXMuZGVjbHV0dGVyXyA9IGRlY2x1dHRlcjtcbiAgfTtcblxuICAvKipcbiAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBSZW5kZXIgYnVmZmVyLlxuICAqL1xuICBWZWN0b3JMYXllci5wcm90b3R5cGUuZ2V0UmVuZGVyQnVmZmVyID0gZnVuY3Rpb24gZ2V0UmVuZGVyQnVmZmVyICgpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJCdWZmZXJfO1xuICB9O1xuXG4gIC8qKlxuICAqIEByZXR1cm4ge2Z1bmN0aW9uKGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdCwgaW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0KTogbnVtYmVyfG51bGx8dW5kZWZpbmVkfSBSZW5kZXJcbiAgKiAgICAgb3JkZXIuXG4gICovXG4gIFZlY3RvckxheWVyLnByb3RvdHlwZS5nZXRSZW5kZXJPcmRlciA9IGZ1bmN0aW9uIGdldFJlbmRlck9yZGVyICgpIHtcbiAgICByZXR1cm4gKFxuICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vcmVuZGVyLmpzXCIpLk9yZGVyRnVuY3Rpb258bnVsbHx1bmRlZmluZWR9ICovICh0aGlzLmdldChQcm9wZXJ0eS5SRU5ERVJfT1JERVIpKVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICogR2V0IHRoZSBzdHlsZSBmb3IgZmVhdHVyZXMuICBUaGlzIHJldHVybnMgd2hhdGV2ZXIgd2FzIHBhc3NlZCB0byB0aGUgYHN0eWxlYFxuICAqIG9wdGlvbiBhdCBjb25zdHJ1Y3Rpb24gb3IgdG8gdGhlIGBzZXRTdHlsZWAgbWV0aG9kLlxuICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLlN0eWxlTGlrZX1cbiAgKiAgICAgTGF5ZXIgc3R5bGUuXG4gICogQGFwaVxuICAqL1xuICBWZWN0b3JMYXllci5wcm90b3R5cGUuZ2V0U3R5bGUgPSBmdW5jdGlvbiBnZXRTdHlsZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3R5bGVfO1xuICB9O1xuXG4gIC8qKlxuICAqIEdldCB0aGUgc3R5bGUgZnVuY3Rpb24uXG4gICogQHJldHVybiB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVGdW5jdGlvbnx1bmRlZmluZWR9IExheWVyIHN0eWxlIGZ1bmN0aW9uLlxuICAqIEBhcGlcbiAgKi9cbiAgVmVjdG9yTGF5ZXIucHJvdG90eXBlLmdldFN0eWxlRnVuY3Rpb24gPSBmdW5jdGlvbiBnZXRTdHlsZUZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHlsZUZ1bmN0aW9uXztcbiAgfTtcblxuICAvKipcbiAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSByZW5kZXJlZCBsYXllciBzaG91bGQgYmUgdXBkYXRlZCB3aGlsZVxuICAqICAgICBhbmltYXRpbmcuXG4gICovXG4gIFZlY3RvckxheWVyLnByb3RvdHlwZS5nZXRVcGRhdGVXaGlsZUFuaW1hdGluZyA9IGZ1bmN0aW9uIGdldFVwZGF0ZVdoaWxlQW5pbWF0aW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVXaGlsZUFuaW1hdGluZ187XG4gIH07XG5cbiAgLyoqXG4gICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcmVuZGVyZWQgbGF5ZXIgc2hvdWxkIGJlIHVwZGF0ZWQgd2hpbGVcbiAgKiAgICAgaW50ZXJhY3RpbmcuXG4gICovXG4gIFZlY3RvckxheWVyLnByb3RvdHlwZS5nZXRVcGRhdGVXaGlsZUludGVyYWN0aW5nID0gZnVuY3Rpb24gZ2V0VXBkYXRlV2hpbGVJbnRlcmFjdGluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlV2hpbGVJbnRlcmFjdGluZ187XG4gIH07XG5cbiAgLyoqXG4gICogQHBhcmFtIHtpbXBvcnQoXCIuLi9yZW5kZXIuanNcIikuT3JkZXJGdW5jdGlvbnxudWxsfHVuZGVmaW5lZH0gcmVuZGVyT3JkZXJcbiAgKiAgICAgUmVuZGVyIG9yZGVyLlxuICAqL1xuICBWZWN0b3JMYXllci5wcm90b3R5cGUuc2V0UmVuZGVyT3JkZXIgPSBmdW5jdGlvbiBzZXRSZW5kZXJPcmRlciAocmVuZGVyT3JkZXIpIHtcbiAgICB0aGlzLnNldChQcm9wZXJ0eS5SRU5ERVJfT1JERVIsIHJlbmRlck9yZGVyKTtcbiAgfTtcblxuICAvKipcbiAgKiBTZXQgdGhlIHN0eWxlIGZvciBmZWF0dXJlcy4gIFRoaXMgY2FuIGJlIGEgc2luZ2xlIHN0eWxlIG9iamVjdCwgYW4gYXJyYXlcbiAgKiBvZiBzdHlsZXMsIG9yIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIGZlYXR1cmUgYW5kIHJlc29sdXRpb24gYW5kIHJldHVybnNcbiAgKiBhbiBhcnJheSBvZiBzdHlsZXMuIElmIGl0IGlzIGB1bmRlZmluZWRgIHRoZSBkZWZhdWx0IHN0eWxlIGlzIHVzZWQuIElmXG4gICogaXQgaXMgYG51bGxgIHRoZSBsYXllciBoYXMgbm8gc3R5bGUgKGEgYG51bGxgIHN0eWxlKSwgc28gb25seSBmZWF0dXJlc1xuICAqIHRoYXQgaGF2ZSB0aGVpciBvd24gc3R5bGVzIHdpbGwgYmUgcmVuZGVyZWQgaW4gdGhlIGxheWVyLiBTZWVcbiAgKiB7QGxpbmsgbW9kdWxlOm9sL3N0eWxlfSBmb3IgaW5mb3JtYXRpb24gb24gdGhlIGRlZmF1bHQgc3R5bGUuXG4gICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5kZWZhdWx0fEFycmF5PGltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHQ+fGltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLlN0eWxlRnVuY3Rpb258bnVsbHx1bmRlZmluZWR9IHN0eWxlIExheWVyIHN0eWxlLlxuICAqIEBhcGlcbiAgKi9cbiAgVmVjdG9yTGF5ZXIucHJvdG90eXBlLnNldFN0eWxlID0gZnVuY3Rpb24gc2V0U3R5bGUgKHN0eWxlKSB7XG4gICAgdGhpcy5zdHlsZV8gPSBzdHlsZSAhPT0gdW5kZWZpbmVkID8gc3R5bGUgOiBjcmVhdGVEZWZhdWx0U3R5bGU7XG4gICAgdGhpcy5zdHlsZUZ1bmN0aW9uXyA9IHN0eWxlID09PSBudWxsID9cbiAgICAgIHVuZGVmaW5lZCA6IHRvU3R5bGVGdW5jdGlvbih0aGlzLnN0eWxlXyk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH07XG5cbiAgLyoqXG4gICogQHJldHVybiB7aW1wb3J0KFwiLi9WZWN0b3JSZW5kZXJUeXBlLmpzXCIpLmRlZmF1bHR8c3RyaW5nfSBUaGUgcmVuZGVyIG1vZGUuXG4gICovXG4gIFZlY3RvckxheWVyLnByb3RvdHlwZS5nZXRSZW5kZXJNb2RlID0gZnVuY3Rpb24gZ2V0UmVuZGVyTW9kZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyTW9kZV87XG4gIH07XG5cbiAgcmV0dXJuIFZlY3RvckxheWVyO1xufShMYXllcikpO1xuXG5cbi8qKlxuICogUmV0dXJuIHRoZSBhc3NvY2lhdGVkIHtAbGluayBtb2R1bGU6b2wvc291cmNlL1ZlY3RvciB2ZWN0b3Jzb3VyY2V9IG9mIHRoZSBsYXllci5cbiAqIEBmdW5jdGlvblxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vc291cmNlL1ZlY3Rvci5qc1wiKS5kZWZhdWx0fSBTb3VyY2UuXG4gKiBAYXBpXG4gKi9cblZlY3RvckxheWVyLnByb3RvdHlwZS5nZXRTb3VyY2U7XG5cblxuZXhwb3J0IGRlZmF1bHQgVmVjdG9yTGF5ZXI7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZlY3Rvci5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvbGF5ZXIvVmVjdG9yUmVuZGVyVHlwZVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqIFJlbmRlciBtb2RlIGZvciB2ZWN0b3IgbGF5ZXJzOlxuICogICogYCdpbWFnZSdgOiBWZWN0b3IgbGF5ZXJzIGFyZSByZW5kZXJlZCBhcyBpbWFnZXMuIEdyZWF0IHBlcmZvcm1hbmNlLCBidXRcbiAqICAgIHBvaW50IHN5bWJvbHMgYW5kIHRleHRzIGFyZSBhbHdheXMgcm90YXRlZCB3aXRoIHRoZSB2aWV3IGFuZCBwaXhlbHMgYXJlXG4gKiAgICBzY2FsZWQgZHVyaW5nIHpvb20gYW5pbWF0aW9ucy5cbiAqICAqIGAndmVjdG9yJ2A6IFZlY3RvciBsYXllcnMgYXJlIHJlbmRlcmVkIGFzIHZlY3RvcnMuIE1vc3QgYWNjdXJhdGUgcmVuZGVyaW5nXG4gKiAgICBldmVuIGR1cmluZyBhbmltYXRpb25zLCBidXQgc2xvd2VyIHBlcmZvcm1hbmNlLlxuICogQGFwaVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIElNQUdFOiAnaW1hZ2UnLFxuICBWRUNUT1I6ICd2ZWN0b3InXG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1WZWN0b3JSZW5kZXJUeXBlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9sYXllci9WZWN0b3JUaWxlUmVuZGVyVHlwZVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqIFJlbmRlciBtb2RlIGZvciB2ZWN0b3IgdGlsZXM6XG4gKiAgKiBgJ2ltYWdlJ2A6IFZlY3RvciB0aWxlcyBhcmUgcmVuZGVyZWQgYXMgaW1hZ2VzLiBHcmVhdCBwZXJmb3JtYW5jZSwgYnV0XG4gKiAgICBwb2ludCBzeW1ib2xzIGFuZCB0ZXh0cyBhcmUgYWx3YXlzIHJvdGF0ZWQgd2l0aCB0aGUgdmlldyBhbmQgcGl4ZWxzIGFyZVxuICogICAgc2NhbGVkIGR1cmluZyB6b29tIGFuaW1hdGlvbnMuXG4gKiAgKiBgJ2h5YnJpZCdgOiBQb2x5Z29uIGFuZCBsaW5lIGVsZW1lbnRzIGFyZSByZW5kZXJlZCBhcyBpbWFnZXMsIHNvIHBpeGVsc1xuICogICAgYXJlIHNjYWxlZCBkdXJpbmcgem9vbSBhbmltYXRpb25zLiBQb2ludCBzeW1ib2xzIGFuZCB0ZXh0cyBhcmUgYWNjdXJhdGVseVxuICogICAgcmVuZGVyZWQgYXMgdmVjdG9ycyBhbmQgY2FuIHN0YXkgdXByaWdodCBvbiByb3RhdGVkIHZpZXdzLlxuICogICogYCd2ZWN0b3InYDogVmVjdG9yIHRpbGVzIGFyZSByZW5kZXJlZCBhcyB2ZWN0b3JzLiBNb3N0IGFjY3VyYXRlIHJlbmRlcmluZ1xuICogICAgZXZlbiBkdXJpbmcgYW5pbWF0aW9ucywgYnV0IHNsb3dlciBwZXJmb3JtYW5jZSB0aGFuIHRoZSBvdGhlciBvcHRpb25zLlxuICogQGFwaVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIElNQUdFOiAnaW1hZ2UnLFxuICBIWUJSSUQ6ICdoeWJyaWQnLFxuICBWRUNUT1I6ICd2ZWN0b3InXG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1WZWN0b3JUaWxlUmVuZGVyVHlwZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvbG9hZGluZ3N0cmF0ZWd5XG4gKi9cblxuXG4vKipcbiAqIFN0cmF0ZWd5IGZ1bmN0aW9uIGZvciBsb2FkaW5nIGFsbCBmZWF0dXJlcyB3aXRoIGEgc2luZ2xlIHJlcXVlc3QuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gKiBAcmV0dXJuIHtBcnJheTxpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnQ+fSBFeHRlbnRzLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWxsKGV4dGVudCwgcmVzb2x1dGlvbikge1xuICByZXR1cm4gW1stSW5maW5pdHksIC1JbmZpbml0eSwgSW5maW5pdHksIEluZmluaXR5XV07XG59XG5cblxuLyoqXG4gKiBTdHJhdGVneSBmdW5jdGlvbiBmb3IgbG9hZGluZyBmZWF0dXJlcyBiYXNlZCBvbiB0aGUgdmlldydzIGV4dGVudCBhbmRcbiAqIHJlc29sdXRpb24uXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gKiBAcmV0dXJuIHtBcnJheTxpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnQ+fSBFeHRlbnRzLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmJveChleHRlbnQsIHJlc29sdXRpb24pIHtcbiAgcmV0dXJuIFtleHRlbnRdO1xufVxuXG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0cmF0ZWd5IGZ1bmN0aW9uIGZvciBsb2FkaW5nIGZlYXR1cmVzIGJhc2VkIG9uIGEgdGlsZSBncmlkLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9IHRpbGVHcmlkIFRpbGUgZ3JpZC5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKGltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudCwgbnVtYmVyKTogQXJyYXk8aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50Pn0gTG9hZGluZyBzdHJhdGVneS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRpbGUodGlsZUdyaWQpIHtcbiAgcmV0dXJuIChcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICAgICAqIEByZXR1cm4ge0FycmF5PGltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudD59IEV4dGVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24oZXh0ZW50LCByZXNvbHV0aW9uKSB7XG4gICAgICB2YXIgeiA9IHRpbGVHcmlkLmdldFpGb3JSZXNvbHV0aW9uKHJlc29sdXRpb24pO1xuICAgICAgdmFyIHRpbGVSYW5nZSA9IHRpbGVHcmlkLmdldFRpbGVSYW5nZUZvckV4dGVudEFuZFooZXh0ZW50LCB6KTtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50Pn0gKi9cbiAgICAgIHZhciBleHRlbnRzID0gW107XG4gICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gKi9cbiAgICAgIHZhciB0aWxlQ29vcmQgPSBbeiwgMCwgMF07XG4gICAgICBmb3IgKHRpbGVDb29yZFsxXSA9IHRpbGVSYW5nZS5taW5YOyB0aWxlQ29vcmRbMV0gPD0gdGlsZVJhbmdlLm1heFg7ICsrdGlsZUNvb3JkWzFdKSB7XG4gICAgICAgIGZvciAodGlsZUNvb3JkWzJdID0gdGlsZVJhbmdlLm1pblk7IHRpbGVDb29yZFsyXSA8PSB0aWxlUmFuZ2UubWF4WTsgKyt0aWxlQ29vcmRbMl0pIHtcbiAgICAgICAgICBleHRlbnRzLnB1c2godGlsZUdyaWQuZ2V0VGlsZUNvb3JkRXh0ZW50KHRpbGVDb29yZCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZXh0ZW50cztcbiAgICB9XG4gICk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWRpbmdzdHJhdGVneS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvbWF0aFxuICovXG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi9hc3NlcnRzLmpzJztcblxuLyoqXG4gKiBUYWtlcyBhIG51bWJlciBhbmQgY2xhbXBzIGl0IHRvIHdpdGhpbiB0aGUgcHJvdmlkZWQgYm91bmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBpbnB1dCBudW1iZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gbWluIFRoZSBtaW5pbXVtIHZhbHVlIHRvIHJldHVybi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggVGhlIG1heGltdW0gdmFsdWUgdG8gcmV0dXJuLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgaW5wdXQgbnVtYmVyIGlmIGl0IGlzIHdpdGhpbiBib3VuZHMsIG9yIHRoZSBuZWFyZXN0XG4gKiAgICAgbnVtYmVyIHdpdGhpbiB0aGUgYm91bmRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xhbXAodmFsdWUsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgbWluKSwgbWF4KTtcbn1cblxuXG4vKipcbiAqIFJldHVybiB0aGUgaHlwZXJib2xpYyBjb3NpbmUgb2YgYSBnaXZlbiBudW1iZXIuIFRoZSBtZXRob2Qgd2lsbCB1c2UgdGhlXG4gKiBuYXRpdmUgYE1hdGguY29zaGAgZnVuY3Rpb24gaWYgaXQgaXMgYXZhaWxhYmxlLCBvdGhlcndpc2UgdGhlIGh5cGVyYm9saWNcbiAqIGNvc2luZSB3aWxsIGJlIGNhbGN1bGF0ZWQgdmlhIHRoZSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24gb2YgdGhlIE1vemlsbGFcbiAqIGRldmVsb3BlciBuZXR3b3JrLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEh5cGVyYm9saWMgY29zaW5lIG9mIHguXG4gKi9cbmV4cG9ydCB2YXIgY29zaCA9IChmdW5jdGlvbigpIHtcbiAgLy8gV3JhcHBlZCBpbiBhIGlpZmUsIHRvIHNhdmUgdGhlIG92ZXJoZWFkIG9mIGNoZWNraW5nIGZvciB0aGUgbmF0aXZlXG4gIC8vIGltcGxlbWVudGF0aW9uIG9uIGV2ZXJ5IGludm9jYXRpb24uXG4gIHZhciBjb3NoO1xuICBpZiAoJ2Nvc2gnIGluIE1hdGgpIHtcbiAgICAvLyBUaGUgZW52aXJvbm1lbnQgc3VwcG9ydHMgdGhlIG5hdGl2ZSBNYXRoLmNvc2ggZnVuY3Rpb24sIHVzZSBpdOKAplxuICAgIGNvc2ggPSBNYXRoLmNvc2g7XG4gIH0gZWxzZSB7XG4gICAgLy8g4oCmIGVsc2UsIHVzZSB0aGUgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9uIG9mIE1ETjpcbiAgICBjb3NoID0gZnVuY3Rpb24oeCkge1xuICAgICAgdmFyIHkgPSAvKiogQHR5cGUge01hdGh9ICovIChNYXRoKS5leHAoeCk7XG4gICAgICByZXR1cm4gKHkgKyAxIC8geSkgLyAyO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGNvc2g7XG59KCkpO1xuXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHNtYWxsZXN0IHBvd2VyIG9mIHR3byBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8geC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kVXBUb1Bvd2VyT2ZUd28oeCkge1xuICBhc3NlcnQoMCA8IHgsIDI5KTsgLy8gYHhgIG11c3QgYmUgZ3JlYXRlciB0aGFuIGAwYFxuICByZXR1cm4gTWF0aC5wb3coMiwgTWF0aC5jZWlsKE1hdGgubG9nKHgpIC8gTWF0aC5MTjIpKTtcbn1cblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNxdWFyZSBvZiB0aGUgY2xvc2VzdCBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBwb2ludCAoeCwgeSkgYW5kIHRoZVxuICogbGluZSBzZWdtZW50ICh4MSwgeTEpIHRvICh4MiwgeTIpLlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKiBAcGFyYW0ge251bWJlcn0geDEgWDEuXG4gKiBAcGFyYW0ge251bWJlcn0geTEgWTEuXG4gKiBAcGFyYW0ge251bWJlcn0geDIgWDIuXG4gKiBAcGFyYW0ge251bWJlcn0geTIgWTIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFNxdWFyZWQgZGlzdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkU2VnbWVudERpc3RhbmNlKHgsIHksIHgxLCB5MSwgeDIsIHkyKSB7XG4gIHZhciBkeCA9IHgyIC0geDE7XG4gIHZhciBkeSA9IHkyIC0geTE7XG4gIGlmIChkeCAhPT0gMCB8fCBkeSAhPT0gMCkge1xuICAgIHZhciB0ID0gKCh4IC0geDEpICogZHggKyAoeSAtIHkxKSAqIGR5KSAvIChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgaWYgKHQgPiAxKSB7XG4gICAgICB4MSA9IHgyO1xuICAgICAgeTEgPSB5MjtcbiAgICB9IGVsc2UgaWYgKHQgPiAwKSB7XG4gICAgICB4MSArPSBkeCAqIHQ7XG4gICAgICB5MSArPSBkeSAqIHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBzcXVhcmVkRGlzdGFuY2UoeCwgeSwgeDEsIHkxKTtcbn1cblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNxdWFyZSBvZiB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgcG9pbnRzICh4MSwgeTEpIGFuZCAoeDIsIHkyKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4MSBYMS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5MSBZMS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4MiBYMi5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5MiBZMi5cbiAqIEByZXR1cm4ge251bWJlcn0gU3F1YXJlZCBkaXN0YW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZSh4MSwgeTEsIHgyLCB5Mikge1xuICB2YXIgZHggPSB4MiAtIHgxO1xuICB2YXIgZHkgPSB5MiAtIHkxO1xuICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59XG5cblxuLyoqXG4gKiBTb2x2ZXMgc3lzdGVtIG9mIGxpbmVhciBlcXVhdGlvbnMgdXNpbmcgR2F1c3NpYW4gZWxpbWluYXRpb24gbWV0aG9kLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IG1hdCBBdWdtZW50ZWQgbWF0cml4IChuIHggbiArIDEgY29sdW1uKVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gcm93LW1ham9yIG9yZGVyLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVGhlIHJlc3VsdGluZyB2ZWN0b3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzb2x2ZUxpbmVhclN5c3RlbShtYXQpIHtcbiAgdmFyIG4gPSBtYXQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgLy8gRmluZCBtYXggaW4gdGhlIGktdGggY29sdW1uIChpZ25vcmluZyBpIC0gMSBmaXJzdCByb3dzKVxuICAgIHZhciBtYXhSb3cgPSBpO1xuICAgIHZhciBtYXhFbCA9IE1hdGguYWJzKG1hdFtpXVtpXSk7XG4gICAgZm9yICh2YXIgciA9IGkgKyAxOyByIDwgbjsgcisrKSB7XG4gICAgICB2YXIgYWJzVmFsdWUgPSBNYXRoLmFicyhtYXRbcl1baV0pO1xuICAgICAgaWYgKGFic1ZhbHVlID4gbWF4RWwpIHtcbiAgICAgICAgbWF4RWwgPSBhYnNWYWx1ZTtcbiAgICAgICAgbWF4Um93ID0gcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWF4RWwgPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsOyAvLyBtYXRyaXggaXMgc2luZ3VsYXJcbiAgICB9XG5cbiAgICAvLyBTd2FwIG1heCByb3cgd2l0aCBpLXRoIChjdXJyZW50KSByb3dcbiAgICB2YXIgdG1wID0gbWF0W21heFJvd107XG4gICAgbWF0W21heFJvd10gPSBtYXRbaV07XG4gICAgbWF0W2ldID0gdG1wO1xuXG4gICAgLy8gU3VidHJhY3QgdGhlIGktdGggcm93IHRvIG1ha2UgYWxsIHRoZSByZW1haW5pbmcgcm93cyAwIGluIHRoZSBpLXRoIGNvbHVtblxuICAgIGZvciAodmFyIGogPSBpICsgMTsgaiA8IG47IGorKykge1xuICAgICAgdmFyIGNvZWYgPSAtbWF0W2pdW2ldIC8gbWF0W2ldW2ldO1xuICAgICAgZm9yICh2YXIgayA9IGk7IGsgPCBuICsgMTsgaysrKSB7XG4gICAgICAgIGlmIChpID09IGspIHtcbiAgICAgICAgICBtYXRbal1ba10gPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdFtqXVtrXSArPSBjb2VmICogbWF0W2ldW2tdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gU29sdmUgQXg9YiBmb3IgdXBwZXIgdHJpYW5ndWxhciBtYXRyaXggQSAobWF0KVxuICB2YXIgeCA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgbCA9IG4gLSAxOyBsID49IDA7IGwtLSkge1xuICAgIHhbbF0gPSBtYXRbbF1bbl0gLyBtYXRbbF1bbF07XG4gICAgZm9yICh2YXIgbSA9IGwgLSAxOyBtID49IDA7IG0tLSkge1xuICAgICAgbWF0W21dW25dIC09IG1hdFttXVtsXSAqIHhbbF07XG4gICAgfVxuICB9XG4gIHJldHVybiB4O1xufVxuXG5cbi8qKlxuICogQ29udmVydHMgcmFkaWFucyB0byB0byBkZWdyZWVzLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZUluUmFkaWFucyBBbmdsZSBpbiByYWRpYW5zLlxuICogQHJldHVybiB7bnVtYmVyfSBBbmdsZSBpbiBkZWdyZWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9EZWdyZWVzKGFuZ2xlSW5SYWRpYW5zKSB7XG4gIHJldHVybiBhbmdsZUluUmFkaWFucyAqIDE4MCAvIE1hdGguUEk7XG59XG5cblxuLyoqXG4gKiBDb252ZXJ0cyBkZWdyZWVzIHRvIHJhZGlhbnMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlSW5EZWdyZWVzIEFuZ2xlIGluIGRlZ3JlZXMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuZ2xlIGluIHJhZGlhbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1JhZGlhbnMoYW5nbGVJbkRlZ3JlZXMpIHtcbiAgcmV0dXJuIGFuZ2xlSW5EZWdyZWVzICogTWF0aC5QSSAvIDE4MDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtb2R1bG8gb2YgYSAvIGIsIGRlcGVuZGluZyBvbiB0aGUgc2lnbiBvZiBiLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIERpdmlkZW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IGIgRGl2aXNvci5cbiAqIEByZXR1cm4ge251bWJlcn0gTW9kdWxvLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbW9kdWxvKGEsIGIpIHtcbiAgdmFyIHIgPSBhICUgYjtcbiAgcmV0dXJuIHIgKiBiIDwgMCA/IHIgKyBiIDogcjtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsaW5lYXJseSBpbnRlcnBvbGF0ZWQgdmFsdWUgb2YgeCBiZXR3ZWVuIGEgYW5kIGIuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGEgTnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0gYiBOdW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFZhbHVlIHRvIGJlIGludGVycG9sYXRlZC5cbiAqIEByZXR1cm4ge251bWJlcn0gSW50ZXJwb2xhdGVkIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGVycChhLCBiLCB4KSB7XG4gIHJldHVybiBhICsgeCAqIChiIC0gYSk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGguanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL29ialxuICovXG5cblxuLyoqXG4gKiBQb2x5ZmlsbCBmb3IgT2JqZWN0LmFzc2lnbigpLiAgQXNzaWducyBlbnVtZXJhYmxlIGFuZCBvd24gcHJvcGVydGllcyBmcm9tXG4gKiBvbmUgb3IgbW9yZSBzb3VyY2Ugb2JqZWN0cyB0byBhIHRhcmdldCBvYmplY3QuXG4gKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2Fzc2lnbi5cbiAqXG4gKiBAcGFyYW0geyFPYmplY3R9IHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSB2YXJfc291cmNlcyBUaGUgc291cmNlIG9iamVjdChzKS5cbiAqIEByZXR1cm4geyFPYmplY3R9IFRoZSBtb2RpZmllZCB0YXJnZXQgb2JqZWN0LlxuICovXG5leHBvcnQgdmFyIGFzc2lnbiA9ICh0eXBlb2YgT2JqZWN0LmFzc2lnbiA9PT0gJ2Z1bmN0aW9uJykgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24odGFyZ2V0LCB2YXJfc291cmNlcykge1xuICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cbiAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICB9XG5cbiAgdmFyIG91dHB1dCA9IE9iamVjdCh0YXJnZXQpO1xuICBmb3IgKHZhciBpID0gMSwgaWkgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHMkMVtpXTtcbiAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQgJiYgc291cmNlICE9PSBudWxsKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIG91dHB1dFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBwcm9wZXJ0aWVzIGZyb20gYW4gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsZWFyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXIob2JqZWN0KSB7XG4gIGZvciAodmFyIHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgIGRlbGV0ZSBvYmplY3RbcHJvcGVydHldO1xuICB9XG59XG5cblxuLyoqXG4gKiBHZXQgYW4gYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzIGZyb20gYW4gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3Q8SyxWPn0gb2JqZWN0IFRoZSBvYmplY3QgZnJvbSB3aGljaCB0byBnZXQgdGhlIHZhbHVlcy5cbiAqIEByZXR1cm4geyFBcnJheTxWPn0gVGhlIHByb3BlcnR5IHZhbHVlcy5cbiAqIEB0ZW1wbGF0ZSBLLFZcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFZhbHVlcyhvYmplY3QpIHtcbiAgdmFyIHZhbHVlcyA9IFtdO1xuICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICB2YWx1ZXMucHVzaChvYmplY3RbcHJvcGVydHldKTtcbiAgfVxuICByZXR1cm4gdmFsdWVzO1xufVxuXG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBoYXMgYW55IHByb3BlcnRpZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgb2JqZWN0IGlzIGVtcHR5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFbXB0eShvYmplY3QpIHtcbiAgdmFyIHByb3BlcnR5O1xuICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gIXByb3BlcnR5O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYmouanMubWFwIiwiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9vbC5jc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcblxuaWYobW9kdWxlLmhvdCkge1xuXHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL29sLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9vbC5jc3NcIik7XG5cblx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblxuXHRcdHZhciBsb2NhbHMgPSAoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0dmFyIGtleSwgaWR4ID0gMDtcblxuXHRcdFx0Zm9yKGtleSBpbiBhKSB7XG5cdFx0XHRcdGlmKCFiIHx8IGFba2V5XSAhPT0gYltrZXldKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdGlkeCsrO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3Ioa2V5IGluIGIpIGlkeC0tO1xuXG5cdFx0XHRyZXR1cm4gaWR4ID09PSAwO1xuXHRcdH0oY29udGVudC5sb2NhbHMsIG5ld0NvbnRlbnQubG9jYWxzKSk7XG5cblx0XHRpZighbG9jYWxzKSB0aHJvdyBuZXcgRXJyb3IoJ0Fib3J0aW5nIENTUyBITVIgZHVlIHRvIGNoYW5nZWQgY3NzLW1vZHVsZXMgbG9jYWxzLicpO1xuXG5cdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHR9KTtcblxuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iLCIvKipcbiAqIEBtb2R1bGUgb2wvcG9pbnRlci9FdmVudFNvdXJjZVxuICovXG5cbnZhciBFdmVudFNvdXJjZSA9IGZ1bmN0aW9uIEV2ZW50U291cmNlKGRpc3BhdGNoZXIsIG1hcHBpbmcpIHtcblxuICAvKipcbiAgICogQHR5cGUge2ltcG9ydChcIi4vUG9pbnRlckV2ZW50SGFuZGxlci5qc1wiKS5kZWZhdWx0fVxuICAgKi9cbiAgdGhpcy5kaXNwYXRjaGVyID0gZGlzcGF0Y2hlcjtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQGNvbnN0XG4gICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgZnVuY3Rpb24oRXZlbnQpPn1cbiAgICovXG4gIHRoaXMubWFwcGluZ18gPSBtYXBwaW5nO1xufTtcblxuLyoqXG4gKiBMaXN0IG9mIGV2ZW50cyBzdXBwb3J0ZWQgYnkgdGhpcyBzb3VyY2UuXG4gKiBAcmV0dXJuIHtBcnJheTxzdHJpbmc+fSBFdmVudCBuYW1lc1xuICovXG5FdmVudFNvdXJjZS5wcm90b3R5cGUuZ2V0RXZlbnRzID0gZnVuY3Rpb24gZ2V0RXZlbnRzICgpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMubWFwcGluZ18pO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBoYW5kbGVyIHRoYXQgc2hvdWxkIGhhbmRsZSBhIGdpdmVuIGV2ZW50IHR5cGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIFRoZSBldmVudCB0eXBlLlxuICogQHJldHVybiB7ZnVuY3Rpb24oRXZlbnQpfSBIYW5kbGVyXG4gKi9cbkV2ZW50U291cmNlLnByb3RvdHlwZS5nZXRIYW5kbGVyRm9yRXZlbnQgPSBmdW5jdGlvbiBnZXRIYW5kbGVyRm9yRXZlbnQgKGV2ZW50VHlwZSkge1xuICByZXR1cm4gdGhpcy5tYXBwaW5nX1tldmVudFR5cGVdO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgRXZlbnRTb3VyY2U7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUV2ZW50U291cmNlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9wb2ludGVyL0V2ZW50VHlwZVxuICovXG5cbi8qKlxuICogQ29uc3RhbnRzIGZvciBldmVudCBuYW1lcy5cbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgUE9JTlRFUk1PVkU6ICdwb2ludGVybW92ZScsXG4gIFBPSU5URVJET1dOOiAncG9pbnRlcmRvd24nLFxuICBQT0lOVEVSVVA6ICdwb2ludGVydXAnLFxuICBQT0lOVEVST1ZFUjogJ3BvaW50ZXJvdmVyJyxcbiAgUE9JTlRFUk9VVDogJ3BvaW50ZXJvdXQnLFxuICBQT0lOVEVSRU5URVI6ICdwb2ludGVyZW50ZXInLFxuICBQT0lOVEVSTEVBVkU6ICdwb2ludGVybGVhdmUnLFxuICBQT0lOVEVSQ0FOQ0VMOiAncG9pbnRlcmNhbmNlbCdcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUV2ZW50VHlwZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcG9pbnRlci9Nb3VzZVNvdXJjZVxuICovXG5cbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9Qb2x5bWVyL1BvaW50ZXJFdmVudHNcblxuLy8gQ29weXJpZ2h0IChjKSAyMDEzIFRoZSBQb2x5bWVyIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4vLyBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4vLyBtZXQ6XG4vL1xuLy8gKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuLy8gbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuLy8gKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4vLyBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyXG4vLyBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlXG4vLyBkaXN0cmlidXRpb24uXG4vLyAqIE5laXRoZXIgdGhlIG5hbWUgb2YgR29vZ2xlIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbi8vIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4vLyB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuLy9cbi8vIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbi8vIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1Rcbi8vIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuLy8gQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbi8vIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuLy8gU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuLy8gTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4vLyBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbi8vIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbi8vIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuLy8gT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cblxuaW1wb3J0IEV2ZW50U291cmNlIGZyb20gJy4vRXZlbnRTb3VyY2UuanMnO1xuXG5cbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBQT0lOVEVSX0lEID0gMTtcblxuXG4vKipcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCB2YXIgUE9JTlRFUl9UWVBFID0gJ21vdXNlJztcblxuXG4vKipcbiAqIFJhZGl1cyBhcm91bmQgdG91Y2hlbmQgdGhhdCBzd2FsbG93cyBtb3VzZSBldmVudHMuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqL1xudmFyIERFRFVQX0RJU1QgPSAyNTtcblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgbW91c2Vkb3duYC5cbiAqXG4gKiBAdGhpcyB7TW91c2VTb3VyY2V9XG4gKiBAcGFyYW0ge01vdXNlRXZlbnR9IGluRXZlbnQgVGhlIGluIGV2ZW50LlxuICovXG5mdW5jdGlvbiBtb3VzZWRvd24oaW5FdmVudCkge1xuICBpZiAoIXRoaXMuaXNFdmVudFNpbXVsYXRlZEZyb21Ub3VjaF8oaW5FdmVudCkpIHtcbiAgICAvLyBUT0RPKGRmcmVlZG1hbikgd29ya2Fyb3VuZCBmb3Igc29tZSBlbGVtZW50cyBub3Qgc2VuZGluZyBtb3VzZXVwXG4gICAgLy8gaHR0cDovL2NyYnVnLzE0OTA5MVxuICAgIGlmIChQT0lOVEVSX0lELnRvU3RyaW5nKCkgaW4gdGhpcy5wb2ludGVyTWFwKSB7XG4gICAgICB0aGlzLmNhbmNlbChpbkV2ZW50KTtcbiAgICB9XG4gICAgdmFyIGUgPSBwcmVwYXJlRXZlbnQoaW5FdmVudCwgdGhpcy5kaXNwYXRjaGVyKTtcbiAgICB0aGlzLnBvaW50ZXJNYXBbUE9JTlRFUl9JRC50b1N0cmluZygpXSA9IGluRXZlbnQ7XG4gICAgdGhpcy5kaXNwYXRjaGVyLmRvd24oZSwgaW5FdmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgbW91c2Vtb3ZlYC5cbiAqXG4gKiBAdGhpcyB7TW91c2VTb3VyY2V9XG4gKiBAcGFyYW0ge01vdXNlRXZlbnR9IGluRXZlbnQgVGhlIGluIGV2ZW50LlxuICovXG5mdW5jdGlvbiBtb3VzZW1vdmUoaW5FdmVudCkge1xuICBpZiAoIXRoaXMuaXNFdmVudFNpbXVsYXRlZEZyb21Ub3VjaF8oaW5FdmVudCkpIHtcbiAgICB2YXIgZSA9IHByZXBhcmVFdmVudChpbkV2ZW50LCB0aGlzLmRpc3BhdGNoZXIpO1xuICAgIHRoaXMuZGlzcGF0Y2hlci5tb3ZlKGUsIGluRXZlbnQpO1xuICB9XG59XG5cbi8qKlxuICogSGFuZGxlciBmb3IgYG1vdXNldXBgLlxuICpcbiAqIEB0aGlzIHtNb3VzZVNvdXJjZX1cbiAqIEBwYXJhbSB7TW91c2VFdmVudH0gaW5FdmVudCBUaGUgaW4gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIG1vdXNldXAoaW5FdmVudCkge1xuICBpZiAoIXRoaXMuaXNFdmVudFNpbXVsYXRlZEZyb21Ub3VjaF8oaW5FdmVudCkpIHtcbiAgICB2YXIgcCA9IHRoaXMucG9pbnRlck1hcFtQT0lOVEVSX0lELnRvU3RyaW5nKCldO1xuXG4gICAgaWYgKHAgJiYgcC5idXR0b24gPT09IGluRXZlbnQuYnV0dG9uKSB7XG4gICAgICB2YXIgZSA9IHByZXBhcmVFdmVudChpbkV2ZW50LCB0aGlzLmRpc3BhdGNoZXIpO1xuICAgICAgdGhpcy5kaXNwYXRjaGVyLnVwKGUsIGluRXZlbnQpO1xuICAgICAgdGhpcy5jbGVhbnVwTW91c2UoKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgbW91c2VvdmVyYC5cbiAqXG4gKiBAdGhpcyB7TW91c2VTb3VyY2V9XG4gKiBAcGFyYW0ge01vdXNlRXZlbnR9IGluRXZlbnQgVGhlIGluIGV2ZW50LlxuICovXG5mdW5jdGlvbiBtb3VzZW92ZXIoaW5FdmVudCkge1xuICBpZiAoIXRoaXMuaXNFdmVudFNpbXVsYXRlZEZyb21Ub3VjaF8oaW5FdmVudCkpIHtcbiAgICB2YXIgZSA9IHByZXBhcmVFdmVudChpbkV2ZW50LCB0aGlzLmRpc3BhdGNoZXIpO1xuICAgIHRoaXMuZGlzcGF0Y2hlci5lbnRlck92ZXIoZSwgaW5FdmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgbW91c2VvdXRgLlxuICpcbiAqIEB0aGlzIHtNb3VzZVNvdXJjZX1cbiAqIEBwYXJhbSB7TW91c2VFdmVudH0gaW5FdmVudCBUaGUgaW4gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIG1vdXNlb3V0KGluRXZlbnQpIHtcbiAgaWYgKCF0aGlzLmlzRXZlbnRTaW11bGF0ZWRGcm9tVG91Y2hfKGluRXZlbnQpKSB7XG4gICAgdmFyIGUgPSBwcmVwYXJlRXZlbnQoaW5FdmVudCwgdGhpcy5kaXNwYXRjaGVyKTtcbiAgICB0aGlzLmRpc3BhdGNoZXIubGVhdmVPdXQoZSwgaW5FdmVudCk7XG4gIH1cbn1cblxuXG52YXIgTW91c2VTb3VyY2UgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChFdmVudFNvdXJjZSkge1xuICBmdW5jdGlvbiBNb3VzZVNvdXJjZShkaXNwYXRjaGVyKSB7XG4gICAgdmFyIG1hcHBpbmcgPSB7XG4gICAgICAnbW91c2Vkb3duJzogbW91c2Vkb3duLFxuICAgICAgJ21vdXNlbW92ZSc6IG1vdXNlbW92ZSxcbiAgICAgICdtb3VzZXVwJzogbW91c2V1cCxcbiAgICAgICdtb3VzZW92ZXInOiBtb3VzZW92ZXIsXG4gICAgICAnbW91c2VvdXQnOiBtb3VzZW91dFxuICAgIH07XG4gICAgRXZlbnRTb3VyY2UuY2FsbCh0aGlzLCBkaXNwYXRjaGVyLCBtYXBwaW5nKTtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdFxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgRXZlbnR8T2JqZWN0Pn1cbiAgICAgKi9cbiAgICB0aGlzLnBvaW50ZXJNYXAgPSBkaXNwYXRjaGVyLnBvaW50ZXJNYXA7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RcbiAgICAgKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi4vcGl4ZWwuanNcIikuUGl4ZWw+fVxuICAgICAqL1xuICAgIHRoaXMubGFzdFRvdWNoZXMgPSBbXTtcbiAgfVxuXG4gIGlmICggRXZlbnRTb3VyY2UgKSBNb3VzZVNvdXJjZS5fX3Byb3RvX18gPSBFdmVudFNvdXJjZTtcbiAgTW91c2VTb3VyY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXZlbnRTb3VyY2UgJiYgRXZlbnRTb3VyY2UucHJvdG90eXBlICk7XG4gIE1vdXNlU291cmNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1vdXNlU291cmNlO1xuXG4gIC8qKlxuICAgKiBEZXRlY3QgaWYgYSBtb3VzZSBldmVudCB3YXMgc2ltdWxhdGVkIGZyb20gYSB0b3VjaCBieVxuICAgKiBjaGVja2luZyBpZiBwcmV2aW91c2x5IHRoZXJlIHdhcyBhIHRvdWNoIGV2ZW50IGF0IHRoZVxuICAgKiBzYW1lIHBvc2l0aW9uLlxuICAgKlxuICAgKiBGSVhNRSAtIEtub3duIHByb2JsZW0gd2l0aCB0aGUgbmF0aXZlIEFuZHJvaWQgYnJvd3NlciBvblxuICAgKiBTYW1zdW5nIEdULUk5MTAwIChBbmRyb2lkIDQuMS4yKTpcbiAgICogSW4gY2FzZSB0aGUgcGFnZSBpcyBzY3JvbGxlZCwgdGhpcyBmdW5jdGlvbiBkb2VzIG5vdCB3b3JrXG4gICAqIGNvcnJlY3RseSB3aGVuIGEgY2FudmFzIGlzIHVzZWQgKFdlYkdMIG9yIGNhbnZhcyByZW5kZXJlcikuXG4gICAqIE1vdXNlIGxpc3RlbmVycyBvbiBjYW52YXMgZWxlbWVudHMgKGZvciB0aGlzIGJyb3dzZXIpLCBjcmVhdGVcbiAgICogdHdvIG1vdXNlIGV2ZW50czogT25lICdnb29kJyBhbmQgb25lICdiYWQnIG9uZSAob24gb3RoZXIgYnJvd3NlcnMgb3JcbiAgICogd2hlbiBhIGRpdiBpcyB1c2VkLCB0aGVyZSBpcyBvbmx5IG9uZSBldmVudCkuIEZvciB0aGUgJ2JhZCcgb25lLFxuICAgKiBjbGllbnRYL2NsaWVudFkgYW5kIGFsc28gcGFnZVgvcGFnZVkgYXJlIHdyb25nIHdoZW4gdGhlIHBhZ2VcbiAgICogaXMgc2Nyb2xsZWQuIEJlY2F1c2Ugb2YgdGhhdCwgdGhpcyBmdW5jdGlvbiBjYW4gbm90IGRldGVjdCBpZlxuICAgKiB0aGUgZXZlbnRzIHdlcmUgc2ltdWxhdGVkIGZyb20gYSB0b3VjaCBldmVudC4gQXMgcmVzdWx0LCBhXG4gICAqIHBvaW50ZXIgZXZlbnQgYXQgYSB3cm9uZyBwb3NpdGlvbiBpcyBkaXNwYXRjaGVkLCB3aGljaCBjb25mdXNlc1xuICAgKiB0aGUgbWFwIGludGVyYWN0aW9ucy5cbiAgICogSXQgaXMgdW5jbGVhciwgaG93IG9uZSBjYW4gZ2V0IHRoZSBjb3JyZWN0IHBvc2l0aW9uIGZvciB0aGUgZXZlbnRcbiAgICogb3IgZGV0ZWN0IHRoYXQgdGhlIHBvc2l0aW9ucyBhcmUgaW52YWxpZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBpbkV2ZW50IFRoZSBpbiBldmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSwgaWYgdGhlIGV2ZW50IHdhcyBnZW5lcmF0ZWQgYnkgYSB0b3VjaC5cbiAgICovXG4gIE1vdXNlU291cmNlLnByb3RvdHlwZS5pc0V2ZW50U2ltdWxhdGVkRnJvbVRvdWNoXyA9IGZ1bmN0aW9uIGlzRXZlbnRTaW11bGF0ZWRGcm9tVG91Y2hfIChpbkV2ZW50KSB7XG4gICAgdmFyIGx0cyA9IHRoaXMubGFzdFRvdWNoZXM7XG4gICAgdmFyIHggPSBpbkV2ZW50LmNsaWVudFg7XG4gICAgdmFyIHkgPSBpbkV2ZW50LmNsaWVudFk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsdHMubGVuZ3RoLCB0ID0gKHZvaWQgMCk7IGkgPCBsICYmICh0ID0gbHRzW2ldKTsgaSsrKSB7XG4gICAgICAvLyBzaW11bGF0ZWQgbW91c2UgZXZlbnRzIHdpbGwgYmUgc3dhbGxvd2VkIG5lYXIgYSBwcmltYXJ5IHRvdWNoZW5kXG4gICAgICB2YXIgZHggPSBNYXRoLmFicyh4IC0gdFswXSk7XG4gICAgICB2YXIgZHkgPSBNYXRoLmFicyh5IC0gdFsxXSk7XG4gICAgICBpZiAoZHggPD0gREVEVVBfRElTVCAmJiBkeSA8PSBERURVUF9ESVNUKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMgYSBgcG9pbnRlcmNhbmNlbGAgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGluRXZlbnQgVGhlIGluIGV2ZW50LlxuICAgKi9cbiAgTW91c2VTb3VyY2UucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uIGNhbmNlbCAoaW5FdmVudCkge1xuICAgIHZhciBlID0gcHJlcGFyZUV2ZW50KGluRXZlbnQsIHRoaXMuZGlzcGF0Y2hlcik7XG4gICAgdGhpcy5kaXNwYXRjaGVyLmNhbmNlbChlLCBpbkV2ZW50KTtcbiAgICB0aGlzLmNsZWFudXBNb3VzZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIG1vdXNlIGZyb20gdGhlIGxpc3Qgb2YgYWN0aXZlIHBvaW50ZXJzLlxuICAgKi9cbiAgTW91c2VTb3VyY2UucHJvdG90eXBlLmNsZWFudXBNb3VzZSA9IGZ1bmN0aW9uIGNsZWFudXBNb3VzZSAoKSB7XG4gICAgZGVsZXRlIHRoaXMucG9pbnRlck1hcFtQT0lOVEVSX0lELnRvU3RyaW5nKCldO1xuICB9O1xuXG4gIHJldHVybiBNb3VzZVNvdXJjZTtcbn0oRXZlbnRTb3VyY2UpKTtcblxuXG4vKipcbiAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoZSBvcmlnaW5hbCBldmVudCB0aGF0IHdpbGwgYmUgdXNlZFxuICogZm9yIHRoZSBmYWtlIHBvaW50ZXIgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtFdmVudH0gaW5FdmVudCBUaGUgaW4gZXZlbnQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vUG9pbnRlckV2ZW50SGFuZGxlci5qc1wiKS5kZWZhdWx0fSBkaXNwYXRjaGVyIEV2ZW50IGhhbmRsZXIuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb3BpZWQgZXZlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmVwYXJlRXZlbnQoaW5FdmVudCwgZGlzcGF0Y2hlcikge1xuICB2YXIgZSA9IGRpc3BhdGNoZXIuY2xvbmVFdmVudChpbkV2ZW50LCBpbkV2ZW50KTtcblxuICAvLyBmb3J3YXJkIG1vdXNlIHByZXZlbnREZWZhdWx0XG4gIHZhciBwZCA9IGUucHJldmVudERlZmF1bHQ7XG4gIGUucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHtcbiAgICBpbkV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgcGQoKTtcbiAgfTtcblxuICBlLnBvaW50ZXJJZCA9IFBPSU5URVJfSUQ7XG4gIGUuaXNQcmltYXJ5ID0gdHJ1ZTtcbiAgZS5wb2ludGVyVHlwZSA9IFBPSU5URVJfVFlQRTtcblxuICByZXR1cm4gZTtcbn1cblxuXG5leHBvcnQgZGVmYXVsdCBNb3VzZVNvdXJjZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TW91c2VTb3VyY2UuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3BvaW50ZXIvTXNTb3VyY2VcbiAqL1xuLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL1BvbHltZXIvUG9pbnRlckV2ZW50c1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgVGhlIFBvbHltZXIgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vXG4vLyBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbi8vIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbi8vIG1ldDpcbi8vXG4vLyAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4vLyBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4vLyAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbi8vIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXJcbi8vIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGVcbi8vIGRpc3RyaWJ1dGlvbi5cbi8vICogTmVpdGhlciB0aGUgbmFtZSBvZiBHb29nbGUgSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuLy8gY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbi8vIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4vL1xuLy8gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuLy8gXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuLy8gTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4vLyBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuLy8gT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4vLyBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4vLyBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbi8vIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuLy8gVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuLy8gKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4vLyBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuXG5pbXBvcnQgRXZlbnRTb3VyY2UgZnJvbSAnLi9FdmVudFNvdXJjZS5qcyc7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtBcnJheTxzdHJpbmc+fVxuICovXG52YXIgUE9JTlRFUl9UWVBFUyA9IFtcbiAgJycsXG4gICd1bmF2YWlsYWJsZScsXG4gICd0b3VjaCcsXG4gICdwZW4nLFxuICAnbW91c2UnXG5dO1xuXG4vKipcbiAqIEhhbmRsZXIgZm9yIGBtc1BvaW50ZXJEb3duYC5cbiAqXG4gKiBAdGhpcyB7TXNTb3VyY2V9XG4gKiBAcGFyYW0ge01TUG9pbnRlckV2ZW50fSBpbkV2ZW50IFRoZSBpbiBldmVudC5cbiAqL1xuZnVuY3Rpb24gbXNQb2ludGVyRG93bihpbkV2ZW50KSB7XG4gIHRoaXMucG9pbnRlck1hcFtpbkV2ZW50LnBvaW50ZXJJZC50b1N0cmluZygpXSA9IGluRXZlbnQ7XG4gIHZhciBlID0gdGhpcy5wcmVwYXJlRXZlbnRfKGluRXZlbnQpO1xuICB0aGlzLmRpc3BhdGNoZXIuZG93bihlLCBpbkV2ZW50KTtcbn1cblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgbXNQb2ludGVyTW92ZWAuXG4gKlxuICogQHRoaXMge01zU291cmNlfVxuICogQHBhcmFtIHtNU1BvaW50ZXJFdmVudH0gaW5FdmVudCBUaGUgaW4gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIG1zUG9pbnRlck1vdmUoaW5FdmVudCkge1xuICB2YXIgZSA9IHRoaXMucHJlcGFyZUV2ZW50XyhpbkV2ZW50KTtcbiAgdGhpcy5kaXNwYXRjaGVyLm1vdmUoZSwgaW5FdmVudCk7XG59XG5cbi8qKlxuICogSGFuZGxlciBmb3IgYG1zUG9pbnRlclVwYC5cbiAqXG4gKiBAdGhpcyB7TXNTb3VyY2V9XG4gKiBAcGFyYW0ge01TUG9pbnRlckV2ZW50fSBpbkV2ZW50IFRoZSBpbiBldmVudC5cbiAqL1xuZnVuY3Rpb24gbXNQb2ludGVyVXAoaW5FdmVudCkge1xuICB2YXIgZSA9IHRoaXMucHJlcGFyZUV2ZW50XyhpbkV2ZW50KTtcbiAgdGhpcy5kaXNwYXRjaGVyLnVwKGUsIGluRXZlbnQpO1xuICB0aGlzLmNsZWFudXAoaW5FdmVudC5wb2ludGVySWQpO1xufVxuXG4vKipcbiAqIEhhbmRsZXIgZm9yIGBtc1BvaW50ZXJPdXRgLlxuICpcbiAqIEB0aGlzIHtNc1NvdXJjZX1cbiAqIEBwYXJhbSB7TVNQb2ludGVyRXZlbnR9IGluRXZlbnQgVGhlIGluIGV2ZW50LlxuICovXG5mdW5jdGlvbiBtc1BvaW50ZXJPdXQoaW5FdmVudCkge1xuICB2YXIgZSA9IHRoaXMucHJlcGFyZUV2ZW50XyhpbkV2ZW50KTtcbiAgdGhpcy5kaXNwYXRjaGVyLmxlYXZlT3V0KGUsIGluRXZlbnQpO1xufVxuXG4vKipcbiAqIEhhbmRsZXIgZm9yIGBtc1BvaW50ZXJPdmVyYC5cbiAqXG4gKiBAdGhpcyB7TXNTb3VyY2V9XG4gKiBAcGFyYW0ge01TUG9pbnRlckV2ZW50fSBpbkV2ZW50IFRoZSBpbiBldmVudC5cbiAqL1xuZnVuY3Rpb24gbXNQb2ludGVyT3ZlcihpbkV2ZW50KSB7XG4gIHZhciBlID0gdGhpcy5wcmVwYXJlRXZlbnRfKGluRXZlbnQpO1xuICB0aGlzLmRpc3BhdGNoZXIuZW50ZXJPdmVyKGUsIGluRXZlbnQpO1xufVxuXG4vKipcbiAqIEhhbmRsZXIgZm9yIGBtc1BvaW50ZXJDYW5jZWxgLlxuICpcbiAqIEB0aGlzIHtNc1NvdXJjZX1cbiAqIEBwYXJhbSB7TVNQb2ludGVyRXZlbnR9IGluRXZlbnQgVGhlIGluIGV2ZW50LlxuICovXG5mdW5jdGlvbiBtc1BvaW50ZXJDYW5jZWwoaW5FdmVudCkge1xuICB2YXIgZSA9IHRoaXMucHJlcGFyZUV2ZW50XyhpbkV2ZW50KTtcbiAgdGhpcy5kaXNwYXRjaGVyLmNhbmNlbChlLCBpbkV2ZW50KTtcbiAgdGhpcy5jbGVhbnVwKGluRXZlbnQucG9pbnRlcklkKTtcbn1cblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgbXNMb3N0UG9pbnRlckNhcHR1cmVgLlxuICpcbiAqIEB0aGlzIHtNc1NvdXJjZX1cbiAqIEBwYXJhbSB7TVNQb2ludGVyRXZlbnR9IGluRXZlbnQgVGhlIGluIGV2ZW50LlxuICovXG5mdW5jdGlvbiBtc0xvc3RQb2ludGVyQ2FwdHVyZShpbkV2ZW50KSB7XG4gIHZhciBlID0gdGhpcy5kaXNwYXRjaGVyLm1ha2VFdmVudCgnbG9zdHBvaW50ZXJjYXB0dXJlJywgaW5FdmVudCwgaW5FdmVudCk7XG4gIHRoaXMuZGlzcGF0Y2hlci5kaXNwYXRjaEV2ZW50KGUpO1xufVxuXG4vKipcbiAqIEhhbmRsZXIgZm9yIGBtc0dvdFBvaW50ZXJDYXB0dXJlYC5cbiAqXG4gKiBAdGhpcyB7TXNTb3VyY2V9XG4gKiBAcGFyYW0ge01TUG9pbnRlckV2ZW50fSBpbkV2ZW50IFRoZSBpbiBldmVudC5cbiAqL1xuZnVuY3Rpb24gbXNHb3RQb2ludGVyQ2FwdHVyZShpbkV2ZW50KSB7XG4gIHZhciBlID0gdGhpcy5kaXNwYXRjaGVyLm1ha2VFdmVudCgnZ290cG9pbnRlcmNhcHR1cmUnLCBpbkV2ZW50LCBpbkV2ZW50KTtcbiAgdGhpcy5kaXNwYXRjaGVyLmRpc3BhdGNoRXZlbnQoZSk7XG59XG5cbnZhciBNc1NvdXJjZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEV2ZW50U291cmNlKSB7XG4gIGZ1bmN0aW9uIE1zU291cmNlKGRpc3BhdGNoZXIpIHtcbiAgICB2YXIgbWFwcGluZyA9IHtcbiAgICAgICdNU1BvaW50ZXJEb3duJzogbXNQb2ludGVyRG93bixcbiAgICAgICdNU1BvaW50ZXJNb3ZlJzogbXNQb2ludGVyTW92ZSxcbiAgICAgICdNU1BvaW50ZXJVcCc6IG1zUG9pbnRlclVwLFxuICAgICAgJ01TUG9pbnRlck91dCc6IG1zUG9pbnRlck91dCxcbiAgICAgICdNU1BvaW50ZXJPdmVyJzogbXNQb2ludGVyT3ZlcixcbiAgICAgICdNU1BvaW50ZXJDYW5jZWwnOiBtc1BvaW50ZXJDYW5jZWwsXG4gICAgICAnTVNHb3RQb2ludGVyQ2FwdHVyZSc6IG1zR290UG9pbnRlckNhcHR1cmUsXG4gICAgICAnTVNMb3N0UG9pbnRlckNhcHR1cmUnOiBtc0xvc3RQb2ludGVyQ2FwdHVyZVxuICAgIH07XG4gICAgRXZlbnRTb3VyY2UuY2FsbCh0aGlzLCBkaXNwYXRjaGVyLCBtYXBwaW5nKTtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdFxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgTVNQb2ludGVyRXZlbnR8T2JqZWN0Pn1cbiAgICAgKi9cbiAgICB0aGlzLnBvaW50ZXJNYXAgPSBkaXNwYXRjaGVyLnBvaW50ZXJNYXA7XG4gIH1cblxuICBpZiAoIEV2ZW50U291cmNlICkgTXNTb3VyY2UuX19wcm90b19fID0gRXZlbnRTb3VyY2U7XG4gIE1zU291cmNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEV2ZW50U291cmNlICYmIEV2ZW50U291cmNlLnByb3RvdHlwZSApO1xuICBNc1NvdXJjZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNc1NvdXJjZTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhlIG9yaWdpbmFsIGV2ZW50IHRoYXQgd2lsbCBiZSB1c2VkXG4gICAqIGZvciB0aGUgZmFrZSBwb2ludGVyIGV2ZW50LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge01TUG9pbnRlckV2ZW50fSBpbkV2ZW50IFRoZSBpbiBldmVudC5cbiAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29waWVkIGV2ZW50LlxuICAgKi9cbiAgTXNTb3VyY2UucHJvdG90eXBlLnByZXBhcmVFdmVudF8gPSBmdW5jdGlvbiBwcmVwYXJlRXZlbnRfIChpbkV2ZW50KSB7XG4gICAgLyoqIEB0eXBlIHtNU1BvaW50ZXJFdmVudHxPYmplY3R9ICovXG4gICAgdmFyIGUgPSBpbkV2ZW50O1xuICAgIGlmICh0eXBlb2YgaW5FdmVudC5wb2ludGVyVHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGUgPSB0aGlzLmRpc3BhdGNoZXIuY2xvbmVFdmVudChpbkV2ZW50LCBpbkV2ZW50KTtcbiAgICAgIGUucG9pbnRlclR5cGUgPSBQT0lOVEVSX1RZUEVTW2luRXZlbnQucG9pbnRlclR5cGVdO1xuICAgIH1cblxuICAgIHJldHVybiBlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhpcyBwb2ludGVyIGZyb20gdGhlIGxpc3Qgb2YgYWN0aXZlIHBvaW50ZXJzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcG9pbnRlcklkIFBvaW50ZXIgaWRlbnRpZmllci5cbiAgICovXG4gIE1zU291cmNlLnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24gY2xlYW51cCAocG9pbnRlcklkKSB7XG4gICAgZGVsZXRlIHRoaXMucG9pbnRlck1hcFtwb2ludGVySWQudG9TdHJpbmcoKV07XG4gIH07XG5cbiAgcmV0dXJuIE1zU291cmNlO1xufShFdmVudFNvdXJjZSkpO1xuXG5leHBvcnQgZGVmYXVsdCBNc1NvdXJjZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TXNTb3VyY2UuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3BvaW50ZXIvTmF0aXZlU291cmNlXG4gKi9cblxuLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL1BvbHltZXIvUG9pbnRlckV2ZW50c1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgVGhlIFBvbHltZXIgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vXG4vLyBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbi8vIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbi8vIG1ldDpcbi8vXG4vLyAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4vLyBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4vLyAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbi8vIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXJcbi8vIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGVcbi8vIGRpc3RyaWJ1dGlvbi5cbi8vICogTmVpdGhlciB0aGUgbmFtZSBvZiBHb29nbGUgSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuLy8gY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbi8vIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4vL1xuLy8gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuLy8gXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuLy8gTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4vLyBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuLy8gT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4vLyBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4vLyBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbi8vIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuLy8gVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuLy8gKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4vLyBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuXG5pbXBvcnQgRXZlbnRTb3VyY2UgZnJvbSAnLi9FdmVudFNvdXJjZS5qcyc7XG5cbi8qKlxuICogSGFuZGxlciBmb3IgYHBvaW50ZXJkb3duYC5cbiAqXG4gKiBAdGhpcyB7TmF0aXZlU291cmNlfVxuICogQHBhcmFtIHtFdmVudH0gaW5FdmVudCBUaGUgaW4gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIHBvaW50ZXJEb3duKGluRXZlbnQpIHtcbiAgdGhpcy5kaXNwYXRjaGVyLmZpcmVOYXRpdmVFdmVudChpbkV2ZW50KTtcbn1cblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgcG9pbnRlcm1vdmVgLlxuICpcbiAqIEB0aGlzIHtOYXRpdmVTb3VyY2V9XG4gKiBAcGFyYW0ge0V2ZW50fSBpbkV2ZW50IFRoZSBpbiBldmVudC5cbiAqL1xuZnVuY3Rpb24gcG9pbnRlck1vdmUoaW5FdmVudCkge1xuICB0aGlzLmRpc3BhdGNoZXIuZmlyZU5hdGl2ZUV2ZW50KGluRXZlbnQpO1xufVxuXG4vKipcbiAqIEhhbmRsZXIgZm9yIGBwb2ludGVydXBgLlxuICpcbiAqIEB0aGlzIHtOYXRpdmVTb3VyY2V9XG4gKiBAcGFyYW0ge0V2ZW50fSBpbkV2ZW50IFRoZSBpbiBldmVudC5cbiAqL1xuZnVuY3Rpb24gcG9pbnRlclVwKGluRXZlbnQpIHtcbiAgdGhpcy5kaXNwYXRjaGVyLmZpcmVOYXRpdmVFdmVudChpbkV2ZW50KTtcbn1cblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgcG9pbnRlcm91dGAuXG4gKlxuICogQHRoaXMge05hdGl2ZVNvdXJjZX1cbiAqIEBwYXJhbSB7RXZlbnR9IGluRXZlbnQgVGhlIGluIGV2ZW50LlxuICovXG5mdW5jdGlvbiBwb2ludGVyT3V0KGluRXZlbnQpIHtcbiAgdGhpcy5kaXNwYXRjaGVyLmZpcmVOYXRpdmVFdmVudChpbkV2ZW50KTtcbn1cblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgcG9pbnRlcm92ZXJgLlxuICpcbiAqIEB0aGlzIHtOYXRpdmVTb3VyY2V9XG4gKiBAcGFyYW0ge0V2ZW50fSBpbkV2ZW50IFRoZSBpbiBldmVudC5cbiAqL1xuZnVuY3Rpb24gcG9pbnRlck92ZXIoaW5FdmVudCkge1xuICB0aGlzLmRpc3BhdGNoZXIuZmlyZU5hdGl2ZUV2ZW50KGluRXZlbnQpO1xufVxuXG4vKipcbiAqIEhhbmRsZXIgZm9yIGBwb2ludGVyY2FuY2VsYC5cbiAqXG4gKiBAdGhpcyB7TmF0aXZlU291cmNlfVxuICogQHBhcmFtIHtFdmVudH0gaW5FdmVudCBUaGUgaW4gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIHBvaW50ZXJDYW5jZWwoaW5FdmVudCkge1xuICB0aGlzLmRpc3BhdGNoZXIuZmlyZU5hdGl2ZUV2ZW50KGluRXZlbnQpO1xufVxuXG4vKipcbiAqIEhhbmRsZXIgZm9yIGBsb3N0cG9pbnRlcmNhcHR1cmVgLlxuICpcbiAqIEB0aGlzIHtOYXRpdmVTb3VyY2V9XG4gKiBAcGFyYW0ge0V2ZW50fSBpbkV2ZW50IFRoZSBpbiBldmVudC5cbiAqL1xuZnVuY3Rpb24gbG9zdFBvaW50ZXJDYXB0dXJlKGluRXZlbnQpIHtcbiAgdGhpcy5kaXNwYXRjaGVyLmZpcmVOYXRpdmVFdmVudChpbkV2ZW50KTtcbn1cblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgZ290cG9pbnRlcmNhcHR1cmVgLlxuICpcbiAqIEB0aGlzIHtOYXRpdmVTb3VyY2V9XG4gKiBAcGFyYW0ge0V2ZW50fSBpbkV2ZW50IFRoZSBpbiBldmVudC5cbiAqL1xuZnVuY3Rpb24gZ290UG9pbnRlckNhcHR1cmUoaW5FdmVudCkge1xuICB0aGlzLmRpc3BhdGNoZXIuZmlyZU5hdGl2ZUV2ZW50KGluRXZlbnQpO1xufVxuXG52YXIgTmF0aXZlU291cmNlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoRXZlbnRTb3VyY2UpIHtcbiAgZnVuY3Rpb24gTmF0aXZlU291cmNlKGRpc3BhdGNoZXIpIHtcbiAgICB2YXIgbWFwcGluZyA9IHtcbiAgICAgICdwb2ludGVyZG93bic6IHBvaW50ZXJEb3duLFxuICAgICAgJ3BvaW50ZXJtb3ZlJzogcG9pbnRlck1vdmUsXG4gICAgICAncG9pbnRlcnVwJzogcG9pbnRlclVwLFxuICAgICAgJ3BvaW50ZXJvdXQnOiBwb2ludGVyT3V0LFxuICAgICAgJ3BvaW50ZXJvdmVyJzogcG9pbnRlck92ZXIsXG4gICAgICAncG9pbnRlcmNhbmNlbCc6IHBvaW50ZXJDYW5jZWwsXG4gICAgICAnZ290cG9pbnRlcmNhcHR1cmUnOiBnb3RQb2ludGVyQ2FwdHVyZSxcbiAgICAgICdsb3N0cG9pbnRlcmNhcHR1cmUnOiBsb3N0UG9pbnRlckNhcHR1cmVcbiAgICB9O1xuICAgIEV2ZW50U291cmNlLmNhbGwodGhpcywgZGlzcGF0Y2hlciwgbWFwcGluZyk7XG4gIH1cblxuICBpZiAoIEV2ZW50U291cmNlICkgTmF0aXZlU291cmNlLl9fcHJvdG9fXyA9IEV2ZW50U291cmNlO1xuICBOYXRpdmVTb3VyY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXZlbnRTb3VyY2UgJiYgRXZlbnRTb3VyY2UucHJvdG90eXBlICk7XG4gIE5hdGl2ZVNvdXJjZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBOYXRpdmVTb3VyY2U7XG5cbiAgcmV0dXJuIE5hdGl2ZVNvdXJjZTtcbn0oRXZlbnRTb3VyY2UpKTtcblxuZXhwb3J0IGRlZmF1bHQgTmF0aXZlU291cmNlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1OYXRpdmVTb3VyY2UuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3BvaW50ZXIvUG9pbnRlckV2ZW50XG4gKi9cblxuLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL1BvbHltZXIvUG9pbnRlckV2ZW50c1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgVGhlIFBvbHltZXIgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vXG4vLyBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbi8vIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbi8vIG1ldDpcbi8vXG4vLyAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4vLyBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4vLyAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbi8vIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXJcbi8vIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGVcbi8vIGRpc3RyaWJ1dGlvbi5cbi8vICogTmVpdGhlciB0aGUgbmFtZSBvZiBHb29nbGUgSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuLy8gY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbi8vIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4vL1xuLy8gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuLy8gXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuLy8gTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4vLyBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuLy8gT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4vLyBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4vLyBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbi8vIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuLy8gVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuLy8gKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4vLyBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuXG5pbXBvcnQgX0V2ZW50IGZyb20gJy4uL2V2ZW50cy9FdmVudC5qcyc7XG5cblxuLyoqXG4gKiBJcyB0aGUgYGJ1dHRvbnNgIHByb3BlcnR5IHN1cHBvcnRlZD9cbiAqIEB0eXBlIHtib29sZWFufVxuICovXG52YXIgSEFTX0JVVFRPTlMgPSBmYWxzZTtcblxuXG52YXIgUG9pbnRlckV2ZW50ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoX0V2ZW50KSB7XG4gIGZ1bmN0aW9uIFBvaW50ZXJFdmVudCh0eXBlLCBvcmlnaW5hbEV2ZW50LCBvcHRfZXZlbnREaWN0KSB7XG4gICAgX0V2ZW50LmNhbGwodGhpcywgdHlwZSk7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RcbiAgICAgKiBAdHlwZSB7RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gb3JpZ2luYWxFdmVudDtcblxuICAgIHZhciBldmVudERpY3QgPSBvcHRfZXZlbnREaWN0ID8gb3B0X2V2ZW50RGljdCA6IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmJ1dHRvbnMgPSBnZXRCdXR0b25zKGV2ZW50RGljdCk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucHJlc3N1cmUgPSBnZXRQcmVzc3VyZShldmVudERpY3QsIHRoaXMuYnV0dG9ucyk7XG5cbiAgICAvLyBNb3VzZUV2ZW50IHJlbGF0ZWQgcHJvcGVydGllc1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5idWJibGVzID0gJ2J1YmJsZXMnIGluIGV2ZW50RGljdCA/IGV2ZW50RGljdFsnYnViYmxlcyddIDogZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmNhbmNlbGFibGUgPSAnY2FuY2VsYWJsZScgaW4gZXZlbnREaWN0ID8gZXZlbnREaWN0WydjYW5jZWxhYmxlJ10gOiBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy52aWV3ID0gJ3ZpZXcnIGluIGV2ZW50RGljdCA/IGV2ZW50RGljdFsndmlldyddIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kZXRhaWwgPSAnZGV0YWlsJyBpbiBldmVudERpY3QgPyBldmVudERpY3RbJ2RldGFpbCddIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zY3JlZW5YID0gJ3NjcmVlblgnIGluIGV2ZW50RGljdCA/IGV2ZW50RGljdFsnc2NyZWVuWCddIDogMDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zY3JlZW5ZID0gJ3NjcmVlblknIGluIGV2ZW50RGljdCA/IGV2ZW50RGljdFsnc2NyZWVuWSddIDogMDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jbGllbnRYID0gJ2NsaWVudFgnIGluIGV2ZW50RGljdCA/IGV2ZW50RGljdFsnY2xpZW50WCddIDogMDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jbGllbnRZID0gJ2NsaWVudFknIGluIGV2ZW50RGljdCA/IGV2ZW50RGljdFsnY2xpZW50WSddIDogMDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuY3RybEtleSA9ICdjdHJsS2V5JyBpbiBldmVudERpY3QgPyBldmVudERpY3RbJ2N0cmxLZXknXSA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5hbHRLZXkgPSAnYWx0S2V5JyBpbiBldmVudERpY3QgPyBldmVudERpY3RbJ2FsdEtleSddIDogZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnNoaWZ0S2V5ID0gJ3NoaWZ0S2V5JyBpbiBldmVudERpY3QgPyBldmVudERpY3RbJ3NoaWZ0S2V5J10gOiBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMubWV0YUtleSA9ICdtZXRhS2V5JyBpbiBldmVudERpY3QgPyBldmVudERpY3RbJ21ldGFLZXknXSA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmJ1dHRvbiA9ICdidXR0b24nIGluIGV2ZW50RGljdCA/IGV2ZW50RGljdFsnYnV0dG9uJ10gOiAwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge05vZGV9XG4gICAgICovXG4gICAgdGhpcy5yZWxhdGVkVGFyZ2V0ID0gJ3JlbGF0ZWRUYXJnZXQnIGluIGV2ZW50RGljdCA/XG4gICAgICBldmVudERpY3RbJ3JlbGF0ZWRUYXJnZXQnXSA6IG51bGw7XG5cbiAgICAvLyBQb2ludGVyRXZlbnQgcmVsYXRlZCBwcm9wZXJ0aWVzXG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucG9pbnRlcklkID0gJ3BvaW50ZXJJZCcgaW4gZXZlbnREaWN0ID8gZXZlbnREaWN0Wydwb2ludGVySWQnXSA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMud2lkdGggPSAnd2lkdGgnIGluIGV2ZW50RGljdCA/IGV2ZW50RGljdFsnd2lkdGgnXSA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaGVpZ2h0ID0gJ2hlaWdodCcgaW4gZXZlbnREaWN0ID8gZXZlbnREaWN0WydoZWlnaHQnXSA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudGlsdFggPSAndGlsdFgnIGluIGV2ZW50RGljdCA/IGV2ZW50RGljdFsndGlsdFgnXSA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudGlsdFkgPSAndGlsdFknIGluIGV2ZW50RGljdCA/IGV2ZW50RGljdFsndGlsdFknXSA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMucG9pbnRlclR5cGUgPSAncG9pbnRlclR5cGUnIGluIGV2ZW50RGljdCA/IGV2ZW50RGljdFsncG9pbnRlclR5cGUnXSA6ICcnO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmh3VGltZXN0YW1wID0gJ2h3VGltZXN0YW1wJyBpbiBldmVudERpY3QgPyBldmVudERpY3RbJ2h3VGltZXN0YW1wJ10gOiAwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5pc1ByaW1hcnkgPSAnaXNQcmltYXJ5JyBpbiBldmVudERpY3QgPyBldmVudERpY3RbJ2lzUHJpbWFyeSddIDogZmFsc2U7XG5cbiAgICAvLyBrZWVwIHRoZSBzZW1hbnRpY3Mgb2YgcHJldmVudERlZmF1bHRcbiAgICBpZiAob3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgdGhpcy5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBvcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGlmICggX0V2ZW50ICkgUG9pbnRlckV2ZW50Ll9fcHJvdG9fXyA9IF9FdmVudDtcbiAgUG9pbnRlckV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIF9FdmVudCAmJiBfRXZlbnQucHJvdG90eXBlICk7XG4gIFBvaW50ZXJFdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQb2ludGVyRXZlbnQ7XG5cbiAgcmV0dXJuIFBvaW50ZXJFdmVudDtcbn0oX0V2ZW50KSk7XG5cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsID8+fSBldmVudERpY3QgVGhlIGV2ZW50IGRpY3Rpb25hcnkuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEJ1dHRvbiBpbmRpY2F0b3IuXG4gKi9cbmZ1bmN0aW9uIGdldEJ1dHRvbnMoZXZlbnREaWN0KSB7XG4gIC8vIEFjY29yZGluZyB0byB0aGUgdzNjIHNwZWMsXG4gIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLU1vdXNlRXZlbnQtYnV0dG9uXG4gIC8vIE1vdXNlRXZlbnQuYnV0dG9uID09IDAgY2FuIG1lYW4gZWl0aGVyIG5vIG1vdXNlIGJ1dHRvbiBkZXByZXNzZWQsIG9yIHRoZVxuICAvLyBsZWZ0IG1vdXNlIGJ1dHRvbiBkZXByZXNzZWQuXG4gIC8vXG4gIC8vIEFzIG9mIG5vdywgdGhlIG9ubHkgd2F5IHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gdGhlIHR3byBzdGF0ZXMgb2ZcbiAgLy8gTW91c2VFdmVudC5idXR0b24gaXMgYnkgdXNpbmcgdGhlIGRlcHJlY2F0ZWQgTW91c2VFdmVudC53aGljaCBwcm9wZXJ0eSwgYXNcbiAgLy8gdGhpcyBtYXBzIG1vdXNlIGJ1dHRvbnMgdG8gcG9zaXRpdmUgaW50ZWdlcnMgPiAwLCBhbmQgdXNlcyAwIHRvIG1lYW4gdGhhdFxuICAvLyBubyBtb3VzZSBidXR0b24gaXMgaGVsZC5cbiAgLy9cbiAgLy8gTW91c2VFdmVudC53aGljaCBpcyBkZXJpdmVkIGZyb20gTW91c2VFdmVudC5idXR0b24gYXQgTW91c2VFdmVudCBjcmVhdGlvbixcbiAgLy8gYnV0IGluaXRNb3VzZUV2ZW50IGRvZXMgbm90IGV4cG9zZSBhbiBhcmd1bWVudCB3aXRoIHdoaWNoIHRvIHNldFxuICAvLyBNb3VzZUV2ZW50LndoaWNoLiBDYWxsaW5nIGluaXRNb3VzZUV2ZW50IHdpdGggYSBidXR0b25Bcmcgb2YgMCB3aWxsIHNldFxuICAvLyBNb3VzZUV2ZW50LmJ1dHRvbiA9PSAwIGFuZCBNb3VzZUV2ZW50LndoaWNoID09IDEsIGJyZWFraW5nIHRoZSBleHBlY3RhdGlvbnNcbiAgLy8gb2YgYXBwIGRldmVsb3BlcnMuXG4gIC8vXG4gIC8vIFRoZSBvbmx5IHdheSB0byBwcm9wYWdhdGUgdGhlIGNvcnJlY3Qgc3RhdGUgb2YgTW91c2VFdmVudC53aGljaCBhbmRcbiAgLy8gTW91c2VFdmVudC5idXR0b24gdG8gYSBuZXcgTW91c2VFdmVudC5idXR0b24gPT0gMCBhbmQgTW91c2VFdmVudC53aGljaCA9PSAwXG4gIC8vIGlzIHRvIGNhbGwgaW5pdE1vdXNlRXZlbnQgd2l0aCBhIGJ1dHRvbkFyZyB2YWx1ZSBvZiAtMS5cbiAgLy9cbiAgLy8gVGhpcyBpcyBmaXhlZCB3aXRoIERPTSBMZXZlbCA0J3MgdXNlIG9mIGJ1dHRvbnNcbiAgdmFyIGJ1dHRvbnM7XG4gIGlmIChldmVudERpY3QuYnV0dG9ucyB8fCBIQVNfQlVUVE9OUykge1xuICAgIGJ1dHRvbnMgPSBldmVudERpY3QuYnV0dG9ucztcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKGV2ZW50RGljdC53aGljaCkge1xuICAgICAgY2FzZSAxOiBidXR0b25zID0gMTsgYnJlYWs7XG4gICAgICBjYXNlIDI6IGJ1dHRvbnMgPSA0OyBicmVhaztcbiAgICAgIGNhc2UgMzogYnV0dG9ucyA9IDI7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogYnV0dG9ucyA9IDA7XG4gICAgfVxuICB9XG4gIHJldHVybiBidXR0b25zO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCA/Pn0gZXZlbnREaWN0IFRoZSBldmVudCBkaWN0aW9uYXJ5LlxuICogQHBhcmFtIHtudW1iZXJ9IGJ1dHRvbnMgQnV0dG9uIGluZGljYXRvci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHByZXNzdXJlLlxuICovXG5mdW5jdGlvbiBnZXRQcmVzc3VyZShldmVudERpY3QsIGJ1dHRvbnMpIHtcbiAgLy8gU3BlYyByZXF1aXJlcyB0aGF0IHBvaW50ZXJzIHdpdGhvdXQgcHJlc3N1cmUgc3BlY2lmaWVkIHVzZSAwLjUgZm9yIGRvd25cbiAgLy8gc3RhdGUgYW5kIDAgZm9yIHVwIHN0YXRlLlxuICB2YXIgcHJlc3N1cmUgPSAwO1xuICBpZiAoZXZlbnREaWN0LnByZXNzdXJlKSB7XG4gICAgcHJlc3N1cmUgPSBldmVudERpY3QucHJlc3N1cmU7XG4gIH0gZWxzZSB7XG4gICAgcHJlc3N1cmUgPSBidXR0b25zID8gMC41IDogMDtcbiAgfVxuICByZXR1cm4gcHJlc3N1cmU7XG59XG5cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGBidXR0b25zYCBwcm9wZXJ0eSBpcyBzdXBwb3J0ZWQuXG4gKi9cbihmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZXYgPSBuZXcgTW91c2VFdmVudCgnY2xpY2snLCB7YnV0dG9uczogMX0pO1xuICAgIEhBU19CVVRUT05TID0gZXYuYnV0dG9ucyA9PT0gMTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIHBhc3NcbiAgfVxufSkoKTtcblxuZXhwb3J0IGRlZmF1bHQgUG9pbnRlckV2ZW50O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qb2ludGVyRXZlbnQuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3BvaW50ZXIvUG9pbnRlckV2ZW50SGFuZGxlclxuICovXG5cbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9Qb2x5bWVyL1BvaW50ZXJFdmVudHNcblxuLy8gQ29weXJpZ2h0IChjKSAyMDEzIFRoZSBQb2x5bWVyIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4vLyBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4vLyBtZXQ6XG4vL1xuLy8gKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuLy8gbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuLy8gKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4vLyBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyXG4vLyBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlXG4vLyBkaXN0cmlidXRpb24uXG4vLyAqIE5laXRoZXIgdGhlIG5hbWUgb2YgR29vZ2xlIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbi8vIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4vLyB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuLy9cbi8vIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbi8vIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1Rcbi8vIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuLy8gQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbi8vIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuLy8gU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuLy8gTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4vLyBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbi8vIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbi8vIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuLy8gT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cblxuaW1wb3J0IHtsaXN0ZW4sIHVubGlzdGVufSBmcm9tICcuLi9ldmVudHMuanMnO1xuaW1wb3J0IEV2ZW50VGFyZ2V0IGZyb20gJy4uL2V2ZW50cy9UYXJnZXQuanMnO1xuaW1wb3J0IHtQT0lOVEVSLCBNU1BPSU5URVIsIFRPVUNIfSBmcm9tICcuLi9oYXMuanMnO1xuaW1wb3J0IFBvaW50ZXJFdmVudFR5cGUgZnJvbSAnLi9FdmVudFR5cGUuanMnO1xuaW1wb3J0IE1vdXNlU291cmNlLCB7cHJlcGFyZUV2ZW50IGFzIHByZXBhcmVNb3VzZUV2ZW50fSBmcm9tICcuL01vdXNlU291cmNlLmpzJztcbmltcG9ydCBNc1NvdXJjZSBmcm9tICcuL01zU291cmNlLmpzJztcbmltcG9ydCBOYXRpdmVTb3VyY2UgZnJvbSAnLi9OYXRpdmVTb3VyY2UuanMnO1xuaW1wb3J0IFBvaW50ZXJFdmVudCBmcm9tICcuL1BvaW50ZXJFdmVudC5qcyc7XG5pbXBvcnQgVG91Y2hTb3VyY2UgZnJvbSAnLi9Ub3VjaFNvdXJjZS5qcyc7XG5cblxuLyoqXG4gKiBQcm9wZXJ0aWVzIHRvIGNvcHkgd2hlbiBjbG9uaW5nIGFuIGV2ZW50LCB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICogQHR5cGUge0FycmF5PEFycmF5Pn1cbiAqL1xudmFyIENMT05FX1BST1BTID0gW1xuICAvLyBNb3VzZUV2ZW50XG4gIFsnYnViYmxlcycsIGZhbHNlXSxcbiAgWydjYW5jZWxhYmxlJywgZmFsc2VdLFxuICBbJ3ZpZXcnLCBudWxsXSxcbiAgWydkZXRhaWwnLCBudWxsXSxcbiAgWydzY3JlZW5YJywgMF0sXG4gIFsnc2NyZWVuWScsIDBdLFxuICBbJ2NsaWVudFgnLCAwXSxcbiAgWydjbGllbnRZJywgMF0sXG4gIFsnY3RybEtleScsIGZhbHNlXSxcbiAgWydhbHRLZXknLCBmYWxzZV0sXG4gIFsnc2hpZnRLZXknLCBmYWxzZV0sXG4gIFsnbWV0YUtleScsIGZhbHNlXSxcbiAgWydidXR0b24nLCAwXSxcbiAgWydyZWxhdGVkVGFyZ2V0JywgbnVsbF0sXG4gIC8vIERPTSBMZXZlbCAzXG4gIFsnYnV0dG9ucycsIDBdLFxuICAvLyBQb2ludGVyRXZlbnRcbiAgWydwb2ludGVySWQnLCAwXSxcbiAgWyd3aWR0aCcsIDBdLFxuICBbJ2hlaWdodCcsIDBdLFxuICBbJ3ByZXNzdXJlJywgMF0sXG4gIFsndGlsdFgnLCAwXSxcbiAgWyd0aWx0WScsIDBdLFxuICBbJ3BvaW50ZXJUeXBlJywgJyddLFxuICBbJ2h3VGltZXN0YW1wJywgMF0sXG4gIFsnaXNQcmltYXJ5JywgZmFsc2VdLFxuICAvLyBldmVudCBpbnN0YW5jZVxuICBbJ3R5cGUnLCAnJ10sXG4gIFsndGFyZ2V0JywgbnVsbF0sXG4gIFsnY3VycmVudFRhcmdldCcsIG51bGxdLFxuICBbJ3doaWNoJywgMF1cbl07XG5cblxudmFyIFBvaW50ZXJFdmVudEhhbmRsZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChFdmVudFRhcmdldCkge1xuICBmdW5jdGlvbiBQb2ludGVyRXZlbnRIYW5kbGVyKGVsZW1lbnQpIHtcbiAgICBFdmVudFRhcmdldC5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7RWxlbWVudHxIVE1MRG9jdW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5lbGVtZW50XyA9IGVsZW1lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIEV2ZW50fE9iamVjdD59XG4gICAgICovXG4gICAgdGhpcy5wb2ludGVyTWFwID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgZnVuY3Rpb24oRXZlbnQpPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZXZlbnRNYXBfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi9FdmVudFNvdXJjZS5qc1wiKS5kZWZhdWx0Pn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZXZlbnRTb3VyY2VMaXN0XyA9IFtdO1xuXG4gICAgdGhpcy5yZWdpc3RlclNvdXJjZXMoKTtcbiAgfVxuXG4gIGlmICggRXZlbnRUYXJnZXQgKSBQb2ludGVyRXZlbnRIYW5kbGVyLl9fcHJvdG9fXyA9IEV2ZW50VGFyZ2V0O1xuICBQb2ludGVyRXZlbnRIYW5kbGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEV2ZW50VGFyZ2V0ICYmIEV2ZW50VGFyZ2V0LnByb3RvdHlwZSApO1xuICBQb2ludGVyRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBvaW50ZXJFdmVudEhhbmRsZXI7XG5cbiAgLyoqXG4gICAqIFNldCB1cCB0aGUgZXZlbnQgc291cmNlcyAobW91c2UsIHRvdWNoIGFuZCBuYXRpdmUgcG9pbnRlcnMpXG4gICAqIHRoYXQgZ2VuZXJhdGUgcG9pbnRlciBldmVudHMuXG4gICAqL1xuICBQb2ludGVyRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5yZWdpc3RlclNvdXJjZXMgPSBmdW5jdGlvbiByZWdpc3RlclNvdXJjZXMgKCkge1xuICAgIGlmIChQT0lOVEVSKSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyU291cmNlKCduYXRpdmUnLCBuZXcgTmF0aXZlU291cmNlKHRoaXMpKTtcbiAgICB9IGVsc2UgaWYgKE1TUE9JTlRFUikge1xuICAgICAgdGhpcy5yZWdpc3RlclNvdXJjZSgnbXMnLCBuZXcgTXNTb3VyY2UodGhpcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbW91c2VTb3VyY2UgPSBuZXcgTW91c2VTb3VyY2UodGhpcyk7XG4gICAgICB0aGlzLnJlZ2lzdGVyU291cmNlKCdtb3VzZScsIG1vdXNlU291cmNlKTtcblxuICAgICAgaWYgKFRPVUNIKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJTb3VyY2UoJ3RvdWNoJywgbmV3IFRvdWNoU291cmNlKHRoaXMsIG1vdXNlU291cmNlKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVnaXN0ZXIgZXZlbnRzIG9uIHRoZSB2aWV3cG9ydCBlbGVtZW50XG4gICAgdGhpcy5yZWdpc3Rlcl8oKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGEgbmV3IGV2ZW50IHNvdXJjZSB0aGF0IHdpbGwgZ2VuZXJhdGUgcG9pbnRlciBldmVudHMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEEgbmFtZSBmb3IgdGhlIGV2ZW50IHNvdXJjZVxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRXZlbnRTb3VyY2UuanNcIikuZGVmYXVsdH0gc291cmNlIFRoZSBzb3VyY2UgZXZlbnQuXG4gICAqL1xuICBQb2ludGVyRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5yZWdpc3RlclNvdXJjZSA9IGZ1bmN0aW9uIHJlZ2lzdGVyU291cmNlIChuYW1lLCBzb3VyY2UpIHtcbiAgICB2YXIgcyA9IHNvdXJjZTtcbiAgICB2YXIgbmV3RXZlbnRzID0gcy5nZXRFdmVudHMoKTtcblxuICAgIGlmIChuZXdFdmVudHMpIHtcbiAgICAgIG5ld0V2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBzLmdldEhhbmRsZXJGb3JFdmVudChlKTtcblxuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgIHRoaXMuZXZlbnRNYXBfW2VdID0gaGFuZGxlci5iaW5kKHMpO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5ldmVudFNvdXJjZUxpc3RfLnB1c2gocyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdXAgdGhlIGV2ZW50cyBmb3IgYWxsIHJlZ2lzdGVyZWQgZXZlbnQgc291cmNlcy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFBvaW50ZXJFdmVudEhhbmRsZXIucHJvdG90eXBlLnJlZ2lzdGVyXyA9IGZ1bmN0aW9uIHJlZ2lzdGVyXyAoKSB7XG4gICAgdmFyIGwgPSB0aGlzLmV2ZW50U291cmNlTGlzdF8ubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgZXZlbnRTb3VyY2UgPSB0aGlzLmV2ZW50U291cmNlTGlzdF9baV07XG4gICAgICB0aGlzLmFkZEV2ZW50c18oZXZlbnRTb3VyY2UuZ2V0RXZlbnRzKCkpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGFsbCByZWdpc3RlcmVkIGV2ZW50cy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFBvaW50ZXJFdmVudEhhbmRsZXIucHJvdG90eXBlLnVucmVnaXN0ZXJfID0gZnVuY3Rpb24gdW5yZWdpc3Rlcl8gKCkge1xuICAgIHZhciBsID0gdGhpcy5ldmVudFNvdXJjZUxpc3RfLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGV2ZW50U291cmNlID0gdGhpcy5ldmVudFNvdXJjZUxpc3RfW2ldO1xuICAgICAgdGhpcy5yZW1vdmVFdmVudHNfKGV2ZW50U291cmNlLmdldEV2ZW50cygpKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGxzIHRoZSByaWdodCBoYW5kbGVyIGZvciBhIG5ldyBldmVudC5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtFdmVudH0gaW5FdmVudCBCcm93c2VyIGV2ZW50LlxuICAgKi9cbiAgUG9pbnRlckV2ZW50SGFuZGxlci5wcm90b3R5cGUuZXZlbnRIYW5kbGVyXyA9IGZ1bmN0aW9uIGV2ZW50SGFuZGxlcl8gKGluRXZlbnQpIHtcbiAgICB2YXIgdHlwZSA9IGluRXZlbnQudHlwZTtcbiAgICB2YXIgaGFuZGxlciA9IHRoaXMuZXZlbnRNYXBfW3R5cGVdO1xuICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICBoYW5kbGVyKGluRXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0dXAgbGlzdGVuZXJzIGZvciB0aGUgZ2l2ZW4gZXZlbnRzLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGV2ZW50cyBMaXN0IG9mIGV2ZW50cy5cbiAgICovXG4gIFBvaW50ZXJFdmVudEhhbmRsZXIucHJvdG90eXBlLmFkZEV2ZW50c18gPSBmdW5jdGlvbiBhZGRFdmVudHNfIChldmVudHMpIHtcbiAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgIGxpc3Rlbih0aGlzLmVsZW1lbnRfLCBldmVudE5hbWUsIHRoaXMuZXZlbnRIYW5kbGVyXywgdGhpcyk7XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgfTtcblxuICAvKipcbiAgICogVW5yZWdpc3RlciBsaXN0ZW5lcnMgZm9yIHRoZSBnaXZlbiBldmVudHMuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gZXZlbnRzIExpc3Qgb2YgZXZlbnRzLlxuICAgKi9cbiAgUG9pbnRlckV2ZW50SGFuZGxlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRzXyA9IGZ1bmN0aW9uIHJlbW92ZUV2ZW50c18gKGV2ZW50cykge1xuICAgIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGUpIHtcbiAgICAgIHVubGlzdGVuKHRoaXMuZWxlbWVudF8sIGUsIHRoaXMuZXZlbnRIYW5kbGVyXywgdGhpcyk7XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhIHNuYXBzaG90IG9mIGluRXZlbnQsIHdpdGggd3JpdGFibGUgcHJvcGVydGllcy5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgQnJvd3NlciBldmVudC5cbiAgICogQHBhcmFtIHtFdmVudHxUb3VjaH0gaW5FdmVudCBBbiBldmVudCB0aGF0IGNvbnRhaW5zXG4gICAqICAgIHByb3BlcnRpZXMgdG8gY29weS5cbiAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyBzaGFsbG93IGNvcGllcyBvZlxuICAgKiAgICBgaW5FdmVudGAncyBwcm9wZXJ0aWVzLlxuICAgKi9cbiAgUG9pbnRlckV2ZW50SGFuZGxlci5wcm90b3R5cGUuY2xvbmVFdmVudCA9IGZ1bmN0aW9uIGNsb25lRXZlbnQgKGV2ZW50LCBpbkV2ZW50KSB7XG4gICAgdmFyIGV2ZW50Q29weSA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IENMT05FX1BST1BTLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIHZhciBwID0gQ0xPTkVfUFJPUFNbaV1bMF07XG4gICAgICBldmVudENvcHlbcF0gPSBldmVudFtwXSB8fCBpbkV2ZW50W3BdIHx8IENMT05FX1BST1BTW2ldWzFdO1xuICAgIH1cblxuICAgIHJldHVybiBldmVudENvcHk7XG4gIH07XG5cbiAgLy8gRVZFTlRTXG5cblxuICAvKipcbiAgICogVHJpZ2dlcnMgYSAncG9pbnRlcmRvd24nIGV2ZW50LlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBQb2ludGVyIGV2ZW50IGRhdGEuXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudC5cbiAgICovXG4gIFBvaW50ZXJFdmVudEhhbmRsZXIucHJvdG90eXBlLmRvd24gPSBmdW5jdGlvbiBkb3duIChkYXRhLCBldmVudCkge1xuICAgIHRoaXMuZmlyZUV2ZW50KFBvaW50ZXJFdmVudFR5cGUuUE9JTlRFUkRPV04sIGRhdGEsIGV2ZW50KTtcbiAgfTtcblxuICAvKipcbiAgICogVHJpZ2dlcnMgYSAncG9pbnRlcm1vdmUnIGV2ZW50LlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBQb2ludGVyIGV2ZW50IGRhdGEuXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudC5cbiAgICovXG4gIFBvaW50ZXJFdmVudEhhbmRsZXIucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbiBtb3ZlIChkYXRhLCBldmVudCkge1xuICAgIHRoaXMuZmlyZUV2ZW50KFBvaW50ZXJFdmVudFR5cGUuUE9JTlRFUk1PVkUsIGRhdGEsIGV2ZW50KTtcbiAgfTtcblxuICAvKipcbiAgICogVHJpZ2dlcnMgYSAncG9pbnRlcnVwJyBldmVudC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgUG9pbnRlciBldmVudCBkYXRhLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQuXG4gICAqL1xuICBQb2ludGVyRXZlbnRIYW5kbGVyLnByb3RvdHlwZS51cCA9IGZ1bmN0aW9uIHVwIChkYXRhLCBldmVudCkge1xuICAgIHRoaXMuZmlyZUV2ZW50KFBvaW50ZXJFdmVudFR5cGUuUE9JTlRFUlVQLCBkYXRhLCBldmVudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRyaWdnZXJzIGEgJ3BvaW50ZXJlbnRlcicgZXZlbnQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFBvaW50ZXIgZXZlbnQgZGF0YS5cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50LlxuICAgKi9cbiAgUG9pbnRlckV2ZW50SGFuZGxlci5wcm90b3R5cGUuZW50ZXIgPSBmdW5jdGlvbiBlbnRlciAoZGF0YSwgZXZlbnQpIHtcbiAgICBkYXRhLmJ1YmJsZXMgPSBmYWxzZTtcbiAgICB0aGlzLmZpcmVFdmVudChQb2ludGVyRXZlbnRUeXBlLlBPSU5URVJFTlRFUiwgZGF0YSwgZXZlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUcmlnZ2VycyBhICdwb2ludGVybGVhdmUnIGV2ZW50LlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBQb2ludGVyIGV2ZW50IGRhdGEuXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudC5cbiAgICovXG4gIFBvaW50ZXJFdmVudEhhbmRsZXIucHJvdG90eXBlLmxlYXZlID0gZnVuY3Rpb24gbGVhdmUgKGRhdGEsIGV2ZW50KSB7XG4gICAgZGF0YS5idWJibGVzID0gZmFsc2U7XG4gICAgdGhpcy5maXJlRXZlbnQoUG9pbnRlckV2ZW50VHlwZS5QT0lOVEVSTEVBVkUsIGRhdGEsIGV2ZW50KTtcbiAgfTtcblxuICAvKipcbiAgICogVHJpZ2dlcnMgYSAncG9pbnRlcm92ZXInIGV2ZW50LlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBQb2ludGVyIGV2ZW50IGRhdGEuXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudC5cbiAgICovXG4gIFBvaW50ZXJFdmVudEhhbmRsZXIucHJvdG90eXBlLm92ZXIgPSBmdW5jdGlvbiBvdmVyIChkYXRhLCBldmVudCkge1xuICAgIGRhdGEuYnViYmxlcyA9IHRydWU7XG4gICAgdGhpcy5maXJlRXZlbnQoUG9pbnRlckV2ZW50VHlwZS5QT0lOVEVST1ZFUiwgZGF0YSwgZXZlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUcmlnZ2VycyBhICdwb2ludGVyb3V0JyBldmVudC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgUG9pbnRlciBldmVudCBkYXRhLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQuXG4gICAqL1xuICBQb2ludGVyRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5vdXQgPSBmdW5jdGlvbiBvdXQgKGRhdGEsIGV2ZW50KSB7XG4gICAgZGF0YS5idWJibGVzID0gdHJ1ZTtcbiAgICB0aGlzLmZpcmVFdmVudChQb2ludGVyRXZlbnRUeXBlLlBPSU5URVJPVVQsIGRhdGEsIGV2ZW50KTtcbiAgfTtcblxuICAvKipcbiAgICogVHJpZ2dlcnMgYSAncG9pbnRlcmNhbmNlbCcgZXZlbnQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFBvaW50ZXIgZXZlbnQgZGF0YS5cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50LlxuICAgKi9cbiAgUG9pbnRlckV2ZW50SGFuZGxlci5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gY2FuY2VsIChkYXRhLCBldmVudCkge1xuICAgIHRoaXMuZmlyZUV2ZW50KFBvaW50ZXJFdmVudFR5cGUuUE9JTlRFUkNBTkNFTCwgZGF0YSwgZXZlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUcmlnZ2VycyBhIGNvbWJpbmF0aW9uIG9mICdwb2ludGVyb3V0JyBhbmQgJ3BvaW50ZXJsZWF2ZScgZXZlbnRzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBQb2ludGVyIGV2ZW50IGRhdGEuXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudC5cbiAgICovXG4gIFBvaW50ZXJFdmVudEhhbmRsZXIucHJvdG90eXBlLmxlYXZlT3V0ID0gZnVuY3Rpb24gbGVhdmVPdXQgKGRhdGEsIGV2ZW50KSB7XG4gICAgdGhpcy5vdXQoZGF0YSwgZXZlbnQpO1xuICAgIGlmICghdGhpcy5jb250YWluc18oZGF0YS50YXJnZXQsIGRhdGEucmVsYXRlZFRhcmdldCkpIHtcbiAgICAgIHRoaXMubGVhdmUoZGF0YSwgZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVHJpZ2dlcnMgYSBjb21iaW5hdGlvbiBvZiAncG9pbnRlcm92ZXInIGFuZCAncG9pbnRlcmV2ZW50cycgZXZlbnRzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBQb2ludGVyIGV2ZW50IGRhdGEuXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudC5cbiAgICovXG4gIFBvaW50ZXJFdmVudEhhbmRsZXIucHJvdG90eXBlLmVudGVyT3ZlciA9IGZ1bmN0aW9uIGVudGVyT3ZlciAoZGF0YSwgZXZlbnQpIHtcbiAgICB0aGlzLm92ZXIoZGF0YSwgZXZlbnQpO1xuICAgIGlmICghdGhpcy5jb250YWluc18oZGF0YS50YXJnZXQsIGRhdGEucmVsYXRlZFRhcmdldCkpIHtcbiAgICAgIHRoaXMuZW50ZXIoZGF0YSwgZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZXIgVGhlIGNvbnRhaW5lciBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRhaW5lZCBUaGUgY29udGFpbmVkIGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgY29udGFpbmVyIGVsZW1lbnRcbiAgICogICBjb250YWlucyB0aGUgb3RoZXIgZWxlbWVudC5cbiAgICovXG4gIFBvaW50ZXJFdmVudEhhbmRsZXIucHJvdG90eXBlLmNvbnRhaW5zXyA9IGZ1bmN0aW9uIGNvbnRhaW5zXyAoY29udGFpbmVyLCBjb250YWluZWQpIHtcbiAgICBpZiAoIWNvbnRhaW5lciB8fCAhY29udGFpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBjb250YWluZXIuY29udGFpbnMoY29udGFpbmVkKTtcbiAgfTtcblxuICAvLyBFVkVOVCBDUkVBVElPTiBBTkQgVFJBQ0tJTkdcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgRXZlbnQgb2YgdHlwZSBgaW5UeXBlYCwgYmFzZWQgb24gdGhlIGluZm9ybWF0aW9uIGluXG4gICAqIGBkYXRhYC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGluVHlwZSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHR5cGUgb2YgZXZlbnQgdG8gY3JlYXRlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBQb2ludGVyIGV2ZW50IGRhdGEuXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudC5cbiAgICogQHJldHVybiB7UG9pbnRlckV2ZW50fSBBIFBvaW50ZXJFdmVudCBvZiB0eXBlIGBpblR5cGVgLlxuICAgKi9cbiAgUG9pbnRlckV2ZW50SGFuZGxlci5wcm90b3R5cGUubWFrZUV2ZW50ID0gZnVuY3Rpb24gbWFrZUV2ZW50IChpblR5cGUsIGRhdGEsIGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBQb2ludGVyRXZlbnQoaW5UeXBlLCBldmVudCwgZGF0YSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1ha2UgYW5kIGRpc3BhdGNoIGFuIGV2ZW50IGluIG9uZSBjYWxsLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5UeXBlIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdHlwZSBvZiBldmVudC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgUG9pbnRlciBldmVudCBkYXRhLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQuXG4gICAqL1xuICBQb2ludGVyRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5maXJlRXZlbnQgPSBmdW5jdGlvbiBmaXJlRXZlbnQgKGluVHlwZSwgZGF0YSwgZXZlbnQpIHtcbiAgICB2YXIgZSA9IHRoaXMubWFrZUV2ZW50KGluVHlwZSwgZGF0YSwgZXZlbnQpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHBvaW50ZXIgZXZlbnQgZnJvbSBhIG5hdGl2ZSBwb2ludGVyIGV2ZW50XG4gICAqIGFuZCBkaXNwYXRjaGVzIHRoaXMgZXZlbnQuXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IEEgcGxhdGZvcm0gZXZlbnQgd2l0aCBhIHRhcmdldC5cbiAgICovXG4gIFBvaW50ZXJFdmVudEhhbmRsZXIucHJvdG90eXBlLmZpcmVOYXRpdmVFdmVudCA9IGZ1bmN0aW9uIGZpcmVOYXRpdmVFdmVudCAoZXZlbnQpIHtcbiAgICB2YXIgZSA9IHRoaXMubWFrZUV2ZW50KGV2ZW50LnR5cGUsIGV2ZW50LCBldmVudCk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXcmFwIGEgbmF0aXZlIG1vdXNlIGV2ZW50IGludG8gYSBwb2ludGVyIGV2ZW50LlxuICAgKiBUaGlzIHByb3h5IG1ldGhvZCBpcyByZXF1aXJlZCBmb3IgdGhlIGxlZ2FjeSBJRSBzdXBwb3J0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIFRoZSBwb2ludGVyIGV2ZW50IHR5cGUuXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudC5cbiAgICogQHJldHVybiB7UG9pbnRlckV2ZW50fSBUaGUgd3JhcHBlZCBldmVudC5cbiAgICovXG4gIFBvaW50ZXJFdmVudEhhbmRsZXIucHJvdG90eXBlLndyYXBNb3VzZUV2ZW50ID0gZnVuY3Rpb24gd3JhcE1vdXNlRXZlbnQgKGV2ZW50VHlwZSwgZXZlbnQpIHtcbiAgICB2YXIgcG9pbnRlckV2ZW50ID0gdGhpcy5tYWtlRXZlbnQoXG4gICAgICBldmVudFR5cGUsIHByZXBhcmVNb3VzZUV2ZW50KGV2ZW50LCB0aGlzKSwgZXZlbnQpO1xuICAgIHJldHVybiBwb2ludGVyRXZlbnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBQb2ludGVyRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kaXNwb3NlSW50ZXJuYWwgPSBmdW5jdGlvbiBkaXNwb3NlSW50ZXJuYWwgKCkge1xuICAgIHRoaXMudW5yZWdpc3Rlcl8oKTtcbiAgICBFdmVudFRhcmdldC5wcm90b3R5cGUuZGlzcG9zZUludGVybmFsLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgcmV0dXJuIFBvaW50ZXJFdmVudEhhbmRsZXI7XG59KEV2ZW50VGFyZ2V0KSk7XG5cbmV4cG9ydCBkZWZhdWx0IFBvaW50ZXJFdmVudEhhbmRsZXI7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBvaW50ZXJFdmVudEhhbmRsZXIuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3BvaW50ZXIvVG91Y2hTb3VyY2VcbiAqL1xuXG4vLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vUG9seW1lci9Qb2ludGVyRXZlbnRzXG5cbi8vIENvcHlyaWdodCAoYykgMjAxMyBUaGUgUG9seW1lciBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy9cbi8vIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuLy8gbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuLy8gbWV0OlxuLy9cbi8vICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbi8vIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbi8vICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuLy8gY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lclxuLy8gaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZVxuLy8gZGlzdHJpYnV0aW9uLlxuLy8gKiBOZWl0aGVyIHRoZSBuYW1lIG9mIEdvb2dsZSBJbmMuIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4vLyBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbVxuLy8gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbi8vXG4vLyBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4vLyBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4vLyBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1Jcbi8vIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4vLyBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbi8vIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1Rcbi8vIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuLy8gREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4vLyBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4vLyAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0Vcbi8vIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG5cbmltcG9ydCB7cmVtb3ZlfSBmcm9tICcuLi9hcnJheS5qcyc7XG5pbXBvcnQgRXZlbnRTb3VyY2UgZnJvbSAnLi9FdmVudFNvdXJjZS5qcyc7XG5pbXBvcnQge1BPSU5URVJfSUR9IGZyb20gJy4vTW91c2VTb3VyY2UuanMnO1xuXG5cbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqL1xudmFyIENMSUNLX0NPVU5UX1RJTUVPVVQgPSAyMDA7XG5cbi8qKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xudmFyIFBPSU5URVJfVFlQRSA9ICd0b3VjaCc7XG5cbi8qKlxuICogSGFuZGxlciBmb3IgYHRvdWNoc3RhcnRgLCB0cmlnZ2VycyBgcG9pbnRlcm92ZXJgLFxuICogYHBvaW50ZXJlbnRlcmAgYW5kIGBwb2ludGVyZG93bmAgZXZlbnRzLlxuICpcbiAqIEB0aGlzIHtUb3VjaFNvdXJjZX1cbiAqIEBwYXJhbSB7VG91Y2hFdmVudH0gaW5FdmVudCBUaGUgaW4gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIHRvdWNoc3RhcnQoaW5FdmVudCkge1xuICB0aGlzLnZhY3V1bVRvdWNoZXNfKGluRXZlbnQpO1xuICB0aGlzLnNldFByaW1hcnlUb3VjaF8oaW5FdmVudC5jaGFuZ2VkVG91Y2hlc1swXSk7XG4gIHRoaXMuZGVkdXBTeW50aE1vdXNlXyhpbkV2ZW50KTtcbiAgdGhpcy5jbGlja0NvdW50XysrO1xuICB0aGlzLnByb2Nlc3NUb3VjaGVzXyhpbkV2ZW50LCB0aGlzLm92ZXJEb3duXyk7XG59XG5cbi8qKlxuICogSGFuZGxlciBmb3IgYHRvdWNobW92ZWAuXG4gKlxuICogQHRoaXMge1RvdWNoU291cmNlfVxuICogQHBhcmFtIHtUb3VjaEV2ZW50fSBpbkV2ZW50IFRoZSBpbiBldmVudC5cbiAqL1xuZnVuY3Rpb24gdG91Y2htb3ZlKGluRXZlbnQpIHtcbiAgdGhpcy5wcm9jZXNzVG91Y2hlc18oaW5FdmVudCwgdGhpcy5tb3ZlT3Zlck91dF8pO1xufVxuXG4vKipcbiAqIEhhbmRsZXIgZm9yIGB0b3VjaGVuZGAsIHRyaWdnZXJzIGBwb2ludGVydXBgLFxuICogYHBvaW50ZXJvdXRgIGFuZCBgcG9pbnRlcmxlYXZlYCBldmVudHMuXG4gKlxuICogQHRoaXMge1RvdWNoU291cmNlfVxuICogQHBhcmFtIHtUb3VjaEV2ZW50fSBpbkV2ZW50IFRoZSBldmVudC5cbiAqL1xuZnVuY3Rpb24gdG91Y2hlbmQoaW5FdmVudCkge1xuICB0aGlzLmRlZHVwU3ludGhNb3VzZV8oaW5FdmVudCk7XG4gIHRoaXMucHJvY2Vzc1RvdWNoZXNfKGluRXZlbnQsIHRoaXMudXBPdXRfKTtcbn1cblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgdG91Y2hjYW5jZWxgLCB0cmlnZ2VycyBgcG9pbnRlcmNhbmNlbGAsXG4gKiBgcG9pbnRlcm91dGAgYW5kIGBwb2ludGVybGVhdmVgIGV2ZW50cy5cbiAqXG4gKiBAdGhpcyB7VG91Y2hTb3VyY2V9XG4gKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGluRXZlbnQgVGhlIGluIGV2ZW50LlxuICovXG5mdW5jdGlvbiB0b3VjaGNhbmNlbChpbkV2ZW50KSB7XG4gIHRoaXMucHJvY2Vzc1RvdWNoZXNfKGluRXZlbnQsIHRoaXMuY2FuY2VsT3V0Xyk7XG59XG5cblxudmFyIFRvdWNoU291cmNlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoRXZlbnRTb3VyY2UpIHtcbiAgZnVuY3Rpb24gVG91Y2hTb3VyY2UoZGlzcGF0Y2hlciwgbW91c2VTb3VyY2UpIHtcbiAgICB2YXIgbWFwcGluZyA9IHtcbiAgICAgICd0b3VjaHN0YXJ0JzogdG91Y2hzdGFydCxcbiAgICAgICd0b3VjaG1vdmUnOiB0b3VjaG1vdmUsXG4gICAgICAndG91Y2hlbmQnOiB0b3VjaGVuZCxcbiAgICAgICd0b3VjaGNhbmNlbCc6IHRvdWNoY2FuY2VsXG4gICAgfTtcbiAgICBFdmVudFNvdXJjZS5jYWxsKHRoaXMsIGRpc3BhdGNoZXIsIG1hcHBpbmcpO1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0XG4gICAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBFdmVudHxPYmplY3Q+fVxuICAgICAqL1xuICAgIHRoaXMucG9pbnRlck1hcCA9IGRpc3BhdGNoZXIucG9pbnRlck1hcDtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL01vdXNlU291cmNlLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5tb3VzZVNvdXJjZSA9IG1vdXNlU291cmNlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmZpcnN0VG91Y2hJZF8gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jbGlja0NvdW50XyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqL1xuICAgIHRoaXMucmVzZXRJZF87XG5cbiAgICAvKipcbiAgICAgKiBNb3VzZSBldmVudCB0aW1lb3V0OiBUaGlzIHNob3VsZCBiZSBsb25nIGVub3VnaCB0b1xuICAgICAqIGlnbm9yZSBjb21wYXQgbW91c2UgZXZlbnRzIG1hZGUgYnkgdG91Y2guXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZGVkdXBUaW1lb3V0XyA9IDI1MDA7XG4gIH1cblxuICBpZiAoIEV2ZW50U291cmNlICkgVG91Y2hTb3VyY2UuX19wcm90b19fID0gRXZlbnRTb3VyY2U7XG4gIFRvdWNoU291cmNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEV2ZW50U291cmNlICYmIEV2ZW50U291cmNlLnByb3RvdHlwZSApO1xuICBUb3VjaFNvdXJjZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUb3VjaFNvdXJjZTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtUb3VjaH0gaW5Ub3VjaCBUaGUgaW4gdG91Y2guXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUsIGlmIHRoaXMgaXMgdGhlIHByaW1hcnkgdG91Y2guXG4gICAqL1xuICBUb3VjaFNvdXJjZS5wcm90b3R5cGUuaXNQcmltYXJ5VG91Y2hfID0gZnVuY3Rpb24gaXNQcmltYXJ5VG91Y2hfIChpblRvdWNoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlyc3RUb3VjaElkXyA9PT0gaW5Ub3VjaC5pZGVudGlmaWVyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgcHJpbWFyeSB0b3VjaCBpZiB0aGVyZSBhcmUgbm8gcG9pbnRlcnMsIG9yIHRoZSBvbmx5IHBvaW50ZXIgaXMgdGhlIG1vdXNlLlxuICAgKiBAcGFyYW0ge1RvdWNofSBpblRvdWNoIFRoZSBpbiB0b3VjaC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFRvdWNoU291cmNlLnByb3RvdHlwZS5zZXRQcmltYXJ5VG91Y2hfID0gZnVuY3Rpb24gc2V0UHJpbWFyeVRvdWNoXyAoaW5Ub3VjaCkge1xuICAgIHZhciBjb3VudCA9IE9iamVjdC5rZXlzKHRoaXMucG9pbnRlck1hcCkubGVuZ3RoO1xuICAgIGlmIChjb3VudCA9PT0gMCB8fCAoY291bnQgPT09IDEgJiYgUE9JTlRFUl9JRC50b1N0cmluZygpIGluIHRoaXMucG9pbnRlck1hcCkpIHtcbiAgICAgIHRoaXMuZmlyc3RUb3VjaElkXyA9IGluVG91Y2guaWRlbnRpZmllcjtcbiAgICAgIHRoaXMuY2FuY2VsUmVzZXRDbGlja0NvdW50XygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtQb2ludGVyRXZlbnR9IGluUG9pbnRlciBUaGUgaW4gcG9pbnRlciBvYmplY3QuXG4gICAqL1xuICBUb3VjaFNvdXJjZS5wcm90b3R5cGUucmVtb3ZlUHJpbWFyeVBvaW50ZXJfID0gZnVuY3Rpb24gcmVtb3ZlUHJpbWFyeVBvaW50ZXJfIChpblBvaW50ZXIpIHtcbiAgICBpZiAoaW5Qb2ludGVyLmlzUHJpbWFyeSkge1xuICAgICAgdGhpcy5maXJzdFRvdWNoSWRfID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5yZXNldENsaWNrQ291bnRfKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgVG91Y2hTb3VyY2UucHJvdG90eXBlLnJlc2V0Q2xpY2tDb3VudF8gPSBmdW5jdGlvbiByZXNldENsaWNrQ291bnRfICgpIHtcbiAgICB0aGlzLnJlc2V0SWRfID0gc2V0VGltZW91dChcbiAgICAgIHRoaXMucmVzZXRDbGlja0NvdW50SGFuZGxlcl8uYmluZCh0aGlzKSxcbiAgICAgIENMSUNLX0NPVU5UX1RJTUVPVVQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgVG91Y2hTb3VyY2UucHJvdG90eXBlLnJlc2V0Q2xpY2tDb3VudEhhbmRsZXJfID0gZnVuY3Rpb24gcmVzZXRDbGlja0NvdW50SGFuZGxlcl8gKCkge1xuICAgIHRoaXMuY2xpY2tDb3VudF8gPSAwO1xuICAgIHRoaXMucmVzZXRJZF8gPSB1bmRlZmluZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBUb3VjaFNvdXJjZS5wcm90b3R5cGUuY2FuY2VsUmVzZXRDbGlja0NvdW50XyA9IGZ1bmN0aW9uIGNhbmNlbFJlc2V0Q2xpY2tDb3VudF8gKCkge1xuICAgIGlmICh0aGlzLnJlc2V0SWRfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlc2V0SWRfKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gYnJvd3NlckV2ZW50IEJyb3dzZXIgZXZlbnRcbiAgICogQHBhcmFtIHtUb3VjaH0gaW5Ub3VjaCBUb3VjaCBldmVudFxuICAgKiBAcmV0dXJuIHtQb2ludGVyRXZlbnR9IEEgcG9pbnRlciBvYmplY3QuXG4gICAqL1xuICBUb3VjaFNvdXJjZS5wcm90b3R5cGUudG91Y2hUb1BvaW50ZXJfID0gZnVuY3Rpb24gdG91Y2hUb1BvaW50ZXJfIChicm93c2VyRXZlbnQsIGluVG91Y2gpIHtcbiAgICB2YXIgZSA9IHRoaXMuZGlzcGF0Y2hlci5jbG9uZUV2ZW50KGJyb3dzZXJFdmVudCwgaW5Ub3VjaCk7XG4gICAgLy8gU3BlYyBzcGVjaWZpZXMgdGhhdCBwb2ludGVySWQgMSBpcyByZXNlcnZlZCBmb3IgTW91c2UuXG4gICAgLy8gVG91Y2ggaWRlbnRpZmllcnMgY2FuIHN0YXJ0IGF0IDAuXG4gICAgLy8gQWRkIDIgdG8gdGhlIHRvdWNoIGlkZW50aWZpZXIgZm9yIGNvbXBhdGliaWxpdHkuXG4gICAgZS5wb2ludGVySWQgPSBpblRvdWNoLmlkZW50aWZpZXIgKyAyO1xuICAgIC8vIFRPRE86IGNoZWNrIGlmIHRoaXMgaXMgbmVjZXNzYXJ5P1xuICAgIC8vZS50YXJnZXQgPSBmaW5kVGFyZ2V0KGUpO1xuICAgIGUuYnViYmxlcyA9IHRydWU7XG4gICAgZS5jYW5jZWxhYmxlID0gdHJ1ZTtcbiAgICBlLmRldGFpbCA9IHRoaXMuY2xpY2tDb3VudF87XG4gICAgZS5idXR0b24gPSAwO1xuICAgIGUuYnV0dG9ucyA9IDE7XG4gICAgZS53aWR0aCA9IGluVG91Y2gucmFkaXVzWCB8fCAwO1xuICAgIGUuaGVpZ2h0ID0gaW5Ub3VjaC5yYWRpdXNZIHx8IDA7XG4gICAgZS5wcmVzc3VyZSA9IGluVG91Y2guZm9yY2UgfHwgMC41O1xuICAgIGUuaXNQcmltYXJ5ID0gdGhpcy5pc1ByaW1hcnlUb3VjaF8oaW5Ub3VjaCk7XG4gICAgZS5wb2ludGVyVHlwZSA9IFBPSU5URVJfVFlQRTtcblxuICAgIC8vIG1ha2Ugc3VyZSB0aGF0IHRoZSBwcm9wZXJ0aWVzIHRoYXQgYXJlIGRpZmZlcmVudCBmb3JcbiAgICAvLyBlYWNoIGBUb3VjaGAgb2JqZWN0IGFyZSBub3QgY29waWVkIGZyb20gdGhlIEJyb3dzZXJFdmVudCBvYmplY3RcbiAgICBlLmNsaWVudFggPSBpblRvdWNoLmNsaWVudFg7XG4gICAgZS5jbGllbnRZID0gaW5Ub3VjaC5jbGllbnRZO1xuICAgIGUuc2NyZWVuWCA9IGluVG91Y2guc2NyZWVuWDtcbiAgICBlLnNjcmVlblkgPSBpblRvdWNoLnNjcmVlblk7XG5cbiAgICByZXR1cm4gZTtcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBpbkV2ZW50IFRvdWNoIGV2ZW50XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oVG91Y2hFdmVudCwgUG9pbnRlckV2ZW50KX0gaW5GdW5jdGlvbiBJbiBmdW5jdGlvbi5cbiAgICovXG4gIFRvdWNoU291cmNlLnByb3RvdHlwZS5wcm9jZXNzVG91Y2hlc18gPSBmdW5jdGlvbiBwcm9jZXNzVG91Y2hlc18gKGluRXZlbnQsIGluRnVuY3Rpb24pIHtcbiAgICB2YXIgdG91Y2hlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGluRXZlbnQuY2hhbmdlZFRvdWNoZXMpO1xuICAgIHZhciBjb3VudCA9IHRvdWNoZXMubGVuZ3RoO1xuICAgIGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgaW5FdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy50b3VjaFRvUG9pbnRlcl8oaW5FdmVudCwgdG91Y2hlc1tpXSk7XG4gICAgICAvLyBmb3J3YXJkIHRvdWNoIHByZXZlbnREZWZhdWx0c1xuICAgICAgcG9pbnRlci5wcmV2ZW50RGVmYXVsdCA9IHByZXZlbnREZWZhdWx0O1xuICAgICAgaW5GdW5jdGlvbi5jYWxsKHRoaXMsIGluRXZlbnQsIHBvaW50ZXIpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtUb3VjaExpc3R9IHRvdWNoTGlzdCBUaGUgdG91Y2ggbGlzdC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNlYXJjaElkIFNlYXJjaCBpZGVudGlmaWVyLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlLCBpZiB0aGUgYFRvdWNoYCB3aXRoIHRoZSBnaXZlbiBpZCBpcyBpbiB0aGUgbGlzdC5cbiAgICovXG4gIFRvdWNoU291cmNlLnByb3RvdHlwZS5maW5kVG91Y2hfID0gZnVuY3Rpb24gZmluZFRvdWNoXyAodG91Y2hMaXN0LCBzZWFyY2hJZCkge1xuICAgIHZhciBsID0gdG91Y2hMaXN0Lmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIHRvdWNoID0gdG91Y2hMaXN0W2ldO1xuICAgICAgaWYgKHRvdWNoLmlkZW50aWZpZXIgPT09IHNlYXJjaElkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluIHNvbWUgaW5zdGFuY2VzLCBhIHRvdWNoc3RhcnQgY2FuIGhhcHBlbiB3aXRob3V0IGEgdG91Y2hlbmQuIFRoaXNcbiAgICogbGVhdmVzIHRoZSBwb2ludGVybWFwIGluIGEgYnJva2VuIHN0YXRlLlxuICAgKiBUaGVyZWZvcmUsIG9uIGV2ZXJ5IHRvdWNoc3RhcnQsIHdlIHJlbW92ZSB0aGUgdG91Y2hlcyB0aGF0IGRpZCBub3QgZmlyZSBhXG4gICAqIHRvdWNoZW5kIGV2ZW50LlxuICAgKiBUbyBrZWVwIHN0YXRlIGdsb2JhbGx5IGNvbnNpc3RlbnQsIHdlIGZpcmUgYSBwb2ludGVyY2FuY2VsIGZvclxuICAgKiB0aGlzIFwiYWJhbmRvbmVkXCIgdG91Y2hcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBpbkV2ZW50IFRoZSBpbiBldmVudC5cbiAgICovXG4gIFRvdWNoU291cmNlLnByb3RvdHlwZS52YWN1dW1Ub3VjaGVzXyA9IGZ1bmN0aW9uIHZhY3V1bVRvdWNoZXNfIChpbkV2ZW50KSB7XG4gICAgdmFyIHRvdWNoTGlzdCA9IGluRXZlbnQudG91Y2hlcztcbiAgICAvLyBwb2ludGVyTWFwLmdldENvdW50KCkgc2hvdWxkIGJlIDwgdG91Y2hMaXN0Lmxlbmd0aCBoZXJlLFxuICAgIC8vIGFzIHRoZSB0b3VjaHN0YXJ0IGhhcyBub3QgYmVlbiBwcm9jZXNzZWQgeWV0LlxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcy5wb2ludGVyTWFwKTtcbiAgICB2YXIgY291bnQgPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAoY291bnQgPj0gdG91Y2hMaXN0Lmxlbmd0aCkge1xuICAgICAgdmFyIGQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICB2YXIga2V5ID0gTnVtYmVyKGtleXNbaV0pO1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnBvaW50ZXJNYXBba2V5XTtcbiAgICAgICAgLy8gTmV2ZXIgcmVtb3ZlIHBvaW50ZXJJZCA9PSAxLCB3aGljaCBpcyBtb3VzZS5cbiAgICAgICAgLy8gVG91Y2ggaWRlbnRpZmllcnMgYXJlIDIgc21hbGxlciB0aGFuIHRoZWlyIHBvaW50ZXJJZCwgd2hpY2ggaXMgdGhlXG4gICAgICAgIC8vIGluZGV4IGluIHBvaW50ZXJtYXAuXG4gICAgICAgIGlmIChrZXkgIT0gUE9JTlRFUl9JRCAmJiAhdGhpcy5maW5kVG91Y2hfKHRvdWNoTGlzdCwga2V5IC0gMikpIHtcbiAgICAgICAgICBkLnB1c2godmFsdWUub3V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgZC5sZW5ndGg7ICsraSQxKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsT3V0XyhpbkV2ZW50LCBkW2kkMV0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBicm93c2VyRXZlbnQgVGhlIGV2ZW50LlxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gaW5Qb2ludGVyIFRoZSBpbiBwb2ludGVyIG9iamVjdC5cbiAgICovXG4gIFRvdWNoU291cmNlLnByb3RvdHlwZS5vdmVyRG93bl8gPSBmdW5jdGlvbiBvdmVyRG93bl8gKGJyb3dzZXJFdmVudCwgaW5Qb2ludGVyKSB7XG4gICAgdGhpcy5wb2ludGVyTWFwW2luUG9pbnRlci5wb2ludGVySWRdID0ge1xuICAgICAgdGFyZ2V0OiBpblBvaW50ZXIudGFyZ2V0LFxuICAgICAgb3V0OiBpblBvaW50ZXIsXG4gICAgICBvdXRUYXJnZXQ6IGluUG9pbnRlci50YXJnZXRcbiAgICB9O1xuICAgIHRoaXMuZGlzcGF0Y2hlci5vdmVyKGluUG9pbnRlciwgYnJvd3NlckV2ZW50KTtcbiAgICB0aGlzLmRpc3BhdGNoZXIuZW50ZXIoaW5Qb2ludGVyLCBicm93c2VyRXZlbnQpO1xuICAgIHRoaXMuZGlzcGF0Y2hlci5kb3duKGluUG9pbnRlciwgYnJvd3NlckV2ZW50KTtcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBicm93c2VyRXZlbnQgVGhlIGV2ZW50LlxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gaW5Qb2ludGVyIFRoZSBpbiBwb2ludGVyLlxuICAgKi9cbiAgVG91Y2hTb3VyY2UucHJvdG90eXBlLm1vdmVPdmVyT3V0XyA9IGZ1bmN0aW9uIG1vdmVPdmVyT3V0XyAoYnJvd3NlckV2ZW50LCBpblBvaW50ZXIpIHtcbiAgICB2YXIgZXZlbnQgPSBpblBvaW50ZXI7XG4gICAgdmFyIHBvaW50ZXIgPSB0aGlzLnBvaW50ZXJNYXBbZXZlbnQucG9pbnRlcklkXTtcbiAgICAvLyBhIGZpbmdlciBkcmlmdGVkIG9mZiB0aGUgc2NyZWVuLCBpZ25vcmUgaXRcbiAgICBpZiAoIXBvaW50ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG91dEV2ZW50ID0gcG9pbnRlci5vdXQ7XG4gICAgdmFyIG91dFRhcmdldCA9IHBvaW50ZXIub3V0VGFyZ2V0O1xuICAgIHRoaXMuZGlzcGF0Y2hlci5tb3ZlKGV2ZW50LCBicm93c2VyRXZlbnQpO1xuICAgIGlmIChvdXRFdmVudCAmJiBvdXRUYXJnZXQgIT09IGV2ZW50LnRhcmdldCkge1xuICAgICAgb3V0RXZlbnQucmVsYXRlZFRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqLyAoZXZlbnQpLnJlbGF0ZWRUYXJnZXQgPSBvdXRUYXJnZXQ7XG4gICAgICAvLyByZWNvdmVyIGZyb20gcmV0YXJnZXRpbmcgYnkgc2hhZG93XG4gICAgICBvdXRFdmVudC50YXJnZXQgPSBvdXRUYXJnZXQ7XG4gICAgICBpZiAoZXZlbnQudGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hlci5sZWF2ZU91dChvdXRFdmVudCwgYnJvd3NlckV2ZW50KTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaGVyLmVudGVyT3ZlcihldmVudCwgYnJvd3NlckV2ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNsZWFuIHVwIGNhc2Ugd2hlbiBmaW5nZXIgbGVhdmVzIHRoZSBzY3JlZW5cbiAgICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovIChldmVudCkudGFyZ2V0ID0gb3V0VGFyZ2V0O1xuICAgICAgICAvKiogQHR5cGUge09iamVjdH0gKi8gKGV2ZW50KS5yZWxhdGVkVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jYW5jZWxPdXRfKGJyb3dzZXJFdmVudCwgZXZlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICBwb2ludGVyLm91dCA9IGV2ZW50O1xuICAgIHBvaW50ZXIub3V0VGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGJyb3dzZXJFdmVudCBBbiBldmVudC5cbiAgICogQHBhcmFtIHtQb2ludGVyRXZlbnR9IGluUG9pbnRlciBUaGUgaW5Qb2ludGVyIG9iamVjdC5cbiAgICovXG4gIFRvdWNoU291cmNlLnByb3RvdHlwZS51cE91dF8gPSBmdW5jdGlvbiB1cE91dF8gKGJyb3dzZXJFdmVudCwgaW5Qb2ludGVyKSB7XG4gICAgdGhpcy5kaXNwYXRjaGVyLnVwKGluUG9pbnRlciwgYnJvd3NlckV2ZW50KTtcbiAgICB0aGlzLmRpc3BhdGNoZXIub3V0KGluUG9pbnRlciwgYnJvd3NlckV2ZW50KTtcbiAgICB0aGlzLmRpc3BhdGNoZXIubGVhdmUoaW5Qb2ludGVyLCBicm93c2VyRXZlbnQpO1xuICAgIHRoaXMuY2xlYW5VcFBvaW50ZXJfKGluUG9pbnRlcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gYnJvd3NlckV2ZW50IFRoZSBldmVudC5cbiAgICogQHBhcmFtIHtQb2ludGVyRXZlbnR9IGluUG9pbnRlciBUaGUgaW4gcG9pbnRlci5cbiAgICovXG4gIFRvdWNoU291cmNlLnByb3RvdHlwZS5jYW5jZWxPdXRfID0gZnVuY3Rpb24gY2FuY2VsT3V0XyAoYnJvd3NlckV2ZW50LCBpblBvaW50ZXIpIHtcbiAgICB0aGlzLmRpc3BhdGNoZXIuY2FuY2VsKGluUG9pbnRlciwgYnJvd3NlckV2ZW50KTtcbiAgICB0aGlzLmRpc3BhdGNoZXIub3V0KGluUG9pbnRlciwgYnJvd3NlckV2ZW50KTtcbiAgICB0aGlzLmRpc3BhdGNoZXIubGVhdmUoaW5Qb2ludGVyLCBicm93c2VyRXZlbnQpO1xuICAgIHRoaXMuY2xlYW5VcFBvaW50ZXJfKGluUG9pbnRlcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBpblBvaW50ZXIgVGhlIGluUG9pbnRlciBvYmplY3QuXG4gICAqL1xuICBUb3VjaFNvdXJjZS5wcm90b3R5cGUuY2xlYW5VcFBvaW50ZXJfID0gZnVuY3Rpb24gY2xlYW5VcFBvaW50ZXJfIChpblBvaW50ZXIpIHtcbiAgICBkZWxldGUgdGhpcy5wb2ludGVyTWFwW2luUG9pbnRlci5wb2ludGVySWRdO1xuICAgIHRoaXMucmVtb3ZlUHJpbWFyeVBvaW50ZXJfKGluUG9pbnRlcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByZXZlbnQgc3ludGggbW91c2UgZXZlbnRzIGZyb20gY3JlYXRpbmcgcG9pbnRlciBldmVudHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gaW5FdmVudCBUaGUgaW4gZXZlbnQuXG4gICAqL1xuICBUb3VjaFNvdXJjZS5wcm90b3R5cGUuZGVkdXBTeW50aE1vdXNlXyA9IGZ1bmN0aW9uIGRlZHVwU3ludGhNb3VzZV8gKGluRXZlbnQpIHtcbiAgICB2YXIgbHRzID0gdGhpcy5tb3VzZVNvdXJjZS5sYXN0VG91Y2hlcztcbiAgICB2YXIgdCA9IGluRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgLy8gb25seSB0aGUgcHJpbWFyeSBmaW5nZXIgd2lsbCBzeW50aCBtb3VzZSBldmVudHNcbiAgICBpZiAodGhpcy5pc1ByaW1hcnlUb3VjaF8odCkpIHtcbiAgICAgIC8vIHJlbWVtYmVyIHgveSBvZiBsYXN0IHRvdWNoXG4gICAgICB2YXIgbHQgPSBbdC5jbGllbnRYLCB0LmNsaWVudFldO1xuICAgICAgbHRzLnB1c2gobHQpO1xuXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyByZW1vdmUgdG91Y2ggYWZ0ZXIgdGltZW91dFxuICAgICAgICByZW1vdmUobHRzLCBsdCk7XG4gICAgICB9LCB0aGlzLmRlZHVwVGltZW91dF8pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVG91Y2hTb3VyY2U7XG59KEV2ZW50U291cmNlKSk7XG5cbmV4cG9ydCBkZWZhdWx0IFRvdWNoU291cmNlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ub3VjaFNvdXJjZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcHJvalxuICovXG5cbi8qKlxuICogVGhlIG9sL3Byb2ogbW9kdWxlIHN0b3JlczpcbiAqICogYSBsaXN0IG9mIHtAbGluayBtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufVxuICogb2JqZWN0cywgb25lIGZvciBlYWNoIHByb2plY3Rpb24gc3VwcG9ydGVkIGJ5IHRoZSBhcHBsaWNhdGlvblxuICogKiBhIGxpc3Qgb2YgdHJhbnNmb3JtIGZ1bmN0aW9ucyBuZWVkZWQgdG8gY29udmVydCBjb29yZGluYXRlcyBpbiBvbmUgcHJvamVjdGlvblxuICogaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBzdGF0aWMgZnVuY3Rpb25zIGFyZSB0aGUgbWV0aG9kcyB1c2VkIHRvIG1haW50YWluIHRoZXNlLlxuICogRWFjaCB0cmFuc2Zvcm0gZnVuY3Rpb24gY2FuIGhhbmRsZSBub3Qgb25seSBzaW1wbGUgY29vcmRpbmF0ZSBwYWlycywgYnV0IGFsc29cbiAqIGxhcmdlIGFycmF5cyBvZiBjb29yZGluYXRlcyBzdWNoIGFzIHZlY3RvciBnZW9tZXRyaWVzLlxuICpcbiAqIFdoZW4gbG9hZGVkLCB0aGUgbGlicmFyeSBhZGRzIHByb2plY3Rpb24gb2JqZWN0cyBmb3IgRVBTRzo0MzI2IChXR1M4NFxuICogZ2VvZ3JhcGhpYyBjb29yZGluYXRlcykgYW5kIEVQU0c6Mzg1NyAoV2ViIG9yIFNwaGVyaWNhbCBNZXJjYXRvciwgYXMgdXNlZFxuICogZm9yIGV4YW1wbGUgYnkgQmluZyBNYXBzIG9yIE9wZW5TdHJlZXRNYXApLCB0b2dldGhlciB3aXRoIHRoZSByZWxldmFudFxuICogdHJhbnNmb3JtIGZ1bmN0aW9ucy5cbiAqXG4gKiBBZGRpdGlvbmFsIHRyYW5zZm9ybXMgbWF5IGJlIGFkZGVkIGJ5IHVzaW5nIHRoZSBodHRwOi8vcHJvajRqcy5vcmcvXG4gKiBsaWJyYXJ5ICh2ZXJzaW9uIDIuMiBvciBsYXRlcikuIFlvdSBjYW4gdXNlIHRoZSBmdWxsIGJ1aWxkIHN1cHBsaWVkIGJ5XG4gKiBQcm9qNGpzLCBvciBjcmVhdGUgYSBjdXN0b20gYnVpbGQgdG8gc3VwcG9ydCB0aG9zZSBwcm9qZWN0aW9ucyB5b3UgbmVlZDsgc2VlXG4gKiB0aGUgUHJvajRqcyB3ZWJzaXRlIGZvciBob3cgdG8gZG8gdGhpcy4gWW91IGFsc28gbmVlZCB0aGUgUHJvajRqcyBkZWZpbml0aW9uc1xuICogZm9yIHRoZSByZXF1aXJlZCBwcm9qZWN0aW9ucy4gVGhlc2UgZGVmaW5pdGlvbnMgY2FuIGJlIG9idGFpbmVkIGZyb21cbiAqIGh0dHBzOi8vZXBzZy5pby8sIGFuZCBhcmUgYSBKUyBmdW5jdGlvbiwgc28gY2FuIGJlIGxvYWRlZCBpbiBhIHNjcmlwdFxuICogdGFnIChhcyBpbiB0aGUgZXhhbXBsZXMpIG9yIHBhc3RlZCBpbnRvIHlvdXIgYXBwbGljYXRpb24uXG4gKlxuICogQWZ0ZXIgYWxsIHJlcXVpcmVkIHByb2plY3Rpb24gZGVmaW5pdGlvbnMgYXJlIGFkZGVkIHRvIHByb2o0J3MgcmVnaXN0cnkgKGJ5XG4gKiB1c2luZyBgcHJvajQuZGVmcygpYCksIHNpbXBseSBjYWxsIGByZWdpc3Rlcihwcm9qNClgIGZyb20gdGhlIGBvbC9wcm9qL3Byb2o0YFxuICogcGFja2FnZS4gRXhpc3RpbmcgdHJhbnNmb3JtcyBhcmUgbm90IGNoYW5nZWQgYnkgdGhpcyBmdW5jdGlvbi4gU2VlXG4gKiBleGFtcGxlcy93bXMtaW1hZ2UtY3VzdG9tLXByb2ogZm9yIGFuIGV4YW1wbGUgb2YgdGhpcy5cbiAqXG4gKiBBZGRpdGlvbmFsIHByb2plY3Rpb24gZGVmaW5pdGlvbnMgY2FuIGJlIHJlZ2lzdGVyZWQgd2l0aCBgcHJvajQuZGVmcygpYCBhbnlcbiAqIHRpbWUuIEp1c3QgbWFrZSBzdXJlIHRvIGNhbGwgYHJlZ2lzdGVyKHByb2o0KWAgYWdhaW47IGZvciBleGFtcGxlLCB3aXRoIHVzZXItc3VwcGxpZWQgZGF0YSB3aGVyZSB5b3UgZG9uJ3RcbiAqIGtub3cgaW4gYWR2YW5jZSB3aGF0IHByb2plY3Rpb25zIGFyZSBuZWVkZWQsIHlvdSBjYW4gaW5pdGlhbGx5IGxvYWQgbWluaW1hbFxuICogc3VwcG9ydCBhbmQgdGhlbiBsb2FkIHdoaWNoZXZlciBhcmUgcmVxdWVzdGVkLlxuICpcbiAqIE5vdGUgdGhhdCBQcm9qNGpzIGRvZXMgbm90IHN1cHBvcnQgcHJvamVjdGlvbiBleHRlbnRzLiBJZiB5b3Ugd2FudCB0byBhZGRcbiAqIG9uZSBmb3IgY3JlYXRpbmcgZGVmYXVsdCB0aWxlIGdyaWRzLCB5b3UgY2FuIGFkZCBpdCBhZnRlciB0aGUgUHJvamVjdGlvblxuICogb2JqZWN0IGhhcyBiZWVuIGNyZWF0ZWQgd2l0aCBgc2V0RXh0ZW50YCwgZm9yIGV4YW1wbGUsXG4gKiBgZ2V0KCdFUFNHOjEyMzQnKS5zZXRFeHRlbnQoZXh0ZW50KWAuXG4gKlxuICogSW4gYWRkaXRpb24gdG8gUHJvajRqcyBzdXBwb3J0LCBhbnkgdHJhbnNmb3JtIGZ1bmN0aW9ucyBjYW4gYmUgYWRkZWQgd2l0aFxuICoge0BsaW5rIG1vZHVsZTpvbC9wcm9qfmFkZENvb3JkaW5hdGVUcmFuc2Zvcm1zfS4gVG8gdXNlIHRoaXMsIHlvdSBtdXN0IGZpcnN0IGNyZWF0ZVxuICogYSB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gb2JqZWN0IGZvciB0aGUgbmV3IHByb2plY3Rpb24gYW5kIGFkZCBpdCB3aXRoXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3Byb2p+YWRkUHJvamVjdGlvbn0uIFlvdSBjYW4gdGhlbiBhZGQgdGhlIGZvcndhcmQgYW5kIGludmVyc2VcbiAqIGZ1bmN0aW9ucyB3aXRoIHtAbGluayBtb2R1bGU6b2wvcHJvan5hZGRDb29yZGluYXRlVHJhbnNmb3Jtc30uIFNlZVxuICogZXhhbXBsZXMvd21zLWN1c3RvbS1wcm9qIGZvciBhbiBleGFtcGxlIG9mIHRoaXMuXG4gKlxuICogTm90ZSB0aGF0IGlmIG5vIHRyYW5zZm9ybXMgYXJlIG5lZWRlZCBhbmQgeW91IG9ubHkgbmVlZCB0byBkZWZpbmUgdGhlXG4gKiBwcm9qZWN0aW9uLCBqdXN0IGFkZCBhIHtAbGluayBtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSB3aXRoXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3Byb2p+YWRkUHJvamVjdGlvbn0uIFNlZSBleGFtcGxlcy93bXMtbm8tcHJvaiBmb3IgYW4gZXhhbXBsZSBvZlxuICogdGhpcy5cbiAqL1xuaW1wb3J0IHtnZXREaXN0YW5jZX0gZnJvbSAnLi9zcGhlcmUuanMnO1xuaW1wb3J0IHthcHBseVRyYW5zZm9ybX0gZnJvbSAnLi9leHRlbnQuanMnO1xuaW1wb3J0IHttb2R1bG99IGZyb20gJy4vbWF0aC5qcyc7XG5pbXBvcnQge3RvRVBTRzQzMjYsIGZyb21FUFNHNDMyNiwgUFJPSkVDVElPTlMgYXMgRVBTRzM4NTdfUFJPSkVDVElPTlN9IGZyb20gJy4vcHJvai9lcHNnMzg1Ny5qcyc7XG5pbXBvcnQge1BST0pFQ1RJT05TIGFzIEVQU0c0MzI2X1BST0pFQ1RJT05TfSBmcm9tICcuL3Byb2ovZXBzZzQzMjYuanMnO1xuaW1wb3J0IFByb2plY3Rpb24gZnJvbSAnLi9wcm9qL1Byb2plY3Rpb24uanMnO1xuaW1wb3J0IFVuaXRzLCB7TUVURVJTX1BFUl9VTklUfSBmcm9tICcuL3Byb2ovVW5pdHMuanMnO1xuaW1wb3J0ICogYXMgcHJvamVjdGlvbnMgZnJvbSAnLi9wcm9qL3Byb2plY3Rpb25zLmpzJztcbmltcG9ydCB7YWRkIGFzIGFkZFRyYW5zZm9ybUZ1bmMsIGNsZWFyIGFzIGNsZWFyVHJhbnNmb3JtRnVuY3MsIGdldCBhcyBnZXRUcmFuc2Zvcm1GdW5jfSBmcm9tICcuL3Byb2ovdHJhbnNmb3Jtcy5qcyc7XG5cblxuLyoqXG4gKiBBIHByb2plY3Rpb24gYXMge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259LCBTUlMgaWRlbnRpZmllclxuICogc3RyaW5nIG9yIHVuZGVmaW5lZC5cbiAqIEB0eXBlZGVmIHtQcm9qZWN0aW9ufHN0cmluZ3x1bmRlZmluZWR9IFByb2plY3Rpb25MaWtlXG4gKiBAYXBpXG4gKi9cblxuXG4vKipcbiAqIEEgdHJhbnNmb3JtIGZ1bmN0aW9uIGFjY2VwdHMgYW4gYXJyYXkgb2YgaW5wdXQgY29vcmRpbmF0ZSB2YWx1ZXMsIGFuIG9wdGlvbmFsXG4gKiBvdXRwdXQgYXJyYXksIGFuZCBhbiBvcHRpb25hbCBkaW1lbnNpb24gKGRlZmF1bHQgc2hvdWxkIGJlIDIpLiAgVGhlIGZ1bmN0aW9uXG4gKiB0cmFuc2Zvcm1zIHRoZSBpbnB1dCBjb29yZGluYXRlIHZhbHVlcywgcG9wdWxhdGVzIHRoZSBvdXRwdXQgYXJyYXksIGFuZFxuICogcmV0dXJucyB0aGUgb3V0cHV0IGFycmF5LlxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihBcnJheTxudW1iZXI+LCBBcnJheTxudW1iZXI+PSwgbnVtYmVyPSk6IEFycmF5PG51bWJlcj59IFRyYW5zZm9ybUZ1bmN0aW9uXG4gKiBAYXBpXG4gKi9cblxuXG5leHBvcnQge01FVEVSU19QRVJfVU5JVH07XG5cbmV4cG9ydCB7UHJvamVjdGlvbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBpbnB1dCBJbnB1dCBjb29yZGluYXRlIGFycmF5LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+PX0gb3B0X291dHB1dCBPdXRwdXQgYXJyYXkgb2YgY29vcmRpbmF0ZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9kaW1lbnNpb24gRGltZW5zaW9uLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gT3V0cHV0IGNvb3JkaW5hdGUgYXJyYXkgKG5ldyBhcnJheSwgc2FtZSBjb29yZGluYXRlXG4gKiAgICAgdmFsdWVzKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lVHJhbnNmb3JtKGlucHV0LCBvcHRfb3V0cHV0LCBvcHRfZGltZW5zaW9uKSB7XG4gIHZhciBvdXRwdXQ7XG4gIGlmIChvcHRfb3V0cHV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBpbnB1dC5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBvcHRfb3V0cHV0W2ldID0gaW5wdXRbaV07XG4gICAgfVxuICAgIG91dHB1dCA9IG9wdF9vdXRwdXQ7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0gaW5wdXQuc2xpY2UoKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBpbnB1dCBJbnB1dCBjb29yZGluYXRlIGFycmF5LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+PX0gb3B0X291dHB1dCBPdXRwdXQgYXJyYXkgb2YgY29vcmRpbmF0ZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9kaW1lbnNpb24gRGltZW5zaW9uLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gSW5wdXQgY29vcmRpbmF0ZSBhcnJheSAoc2FtZSBhcnJheSBhcyBpbnB1dCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGl0eVRyYW5zZm9ybShpbnB1dCwgb3B0X291dHB1dCwgb3B0X2RpbWVuc2lvbikge1xuICBpZiAob3B0X291dHB1dCAhPT0gdW5kZWZpbmVkICYmIGlucHV0ICE9PSBvcHRfb3V0cHV0KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gaW5wdXQubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgb3B0X291dHB1dFtpXSA9IGlucHV0W2ldO1xuICAgIH1cbiAgICBpbnB1dCA9IG9wdF9vdXRwdXQ7XG4gIH1cbiAgcmV0dXJuIGlucHV0O1xufVxuXG5cbi8qKlxuICogQWRkIGEgUHJvamVjdGlvbiBvYmplY3QgdG8gdGhlIGxpc3Qgb2Ygc3VwcG9ydGVkIHByb2plY3Rpb25zIHRoYXQgY2FuIGJlXG4gKiBsb29rZWQgdXAgYnkgdGhlaXIgY29kZS5cbiAqXG4gKiBAcGFyYW0ge1Byb2plY3Rpb259IHByb2plY3Rpb24gUHJvamVjdGlvbiBpbnN0YW5jZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFByb2plY3Rpb24ocHJvamVjdGlvbikge1xuICBwcm9qZWN0aW9ucy5hZGQocHJvamVjdGlvbi5nZXRDb2RlKCksIHByb2plY3Rpb24pO1xuICBhZGRUcmFuc2Zvcm1GdW5jKHByb2plY3Rpb24sIHByb2plY3Rpb24sIGNsb25lVHJhbnNmb3JtKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8UHJvamVjdGlvbj59IHByb2plY3Rpb25zIFByb2plY3Rpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkUHJvamVjdGlvbnMocHJvamVjdGlvbnMpIHtcbiAgcHJvamVjdGlvbnMuZm9yRWFjaChhZGRQcm9qZWN0aW9uKTtcbn1cblxuXG4vKipcbiAqIEZldGNoZXMgYSBQcm9qZWN0aW9uIG9iamVjdCBmb3IgdGhlIGNvZGUgc3BlY2lmaWVkLlxuICpcbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2V9IHByb2plY3Rpb25MaWtlIEVpdGhlciBhIGNvZGUgc3RyaW5nIHdoaWNoIGlzXG4gKiAgICAgYSBjb21iaW5hdGlvbiBvZiBhdXRob3JpdHkgYW5kIGlkZW50aWZpZXIgc3VjaCBhcyBcIkVQU0c6NDMyNlwiLCBvciBhblxuICogICAgIGV4aXN0aW5nIHByb2plY3Rpb24gb2JqZWN0LCBvciB1bmRlZmluZWQuXG4gKiBAcmV0dXJuIHtQcm9qZWN0aW9ufSBQcm9qZWN0aW9uIG9iamVjdCwgb3IgbnVsbCBpZiBub3QgaW4gbGlzdC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldChwcm9qZWN0aW9uTGlrZSkge1xuICByZXR1cm4gdHlwZW9mIHByb2plY3Rpb25MaWtlID09PSAnc3RyaW5nJyA/XG4gICAgcHJvamVjdGlvbnMuZ2V0KC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAocHJvamVjdGlvbkxpa2UpKSA6XG4gICAgKC8qKiBAdHlwZSB7UHJvamVjdGlvbn0gKi8gKHByb2plY3Rpb25MaWtlKSB8fCBudWxsKTtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgcG9pbnQgaW4gZGVncmVlcyBvciBkaXN0YW5jZSB1bml0cy5cbiAqIEZvciBwcm9qZWN0aW9ucyB3aXRoIGRlZ3JlZXMgYXMgdGhlIHVuaXQgdGhpcyB3aWxsIHNpbXBseSByZXR1cm4gdGhlXG4gKiBwcm92aWRlZCByZXNvbHV0aW9uLiBGb3Igb3RoZXIgcHJvamVjdGlvbnMgdGhlIHBvaW50IHJlc29sdXRpb24gaXNcbiAqIGJ5IGRlZmF1bHQgZXN0aW1hdGVkIGJ5IHRyYW5zZm9ybWluZyB0aGUgJ3BvaW50JyBwaXhlbCB0byBFUFNHOjQzMjYsXG4gKiBtZWFzdXJpbmcgaXRzIHdpZHRoIGFuZCBoZWlnaHQgb24gdGhlIG5vcm1hbCBzcGhlcmUsXG4gKiBhbmQgdGFraW5nIHRoZSBhdmVyYWdlIG9mIHRoZSB3aWR0aCBhbmQgaGVpZ2h0LlxuICogQSBjdXN0b20gZnVuY3Rpb24gY2FuIGJlIHByb3ZpZGVkIGZvciBhIHNwZWNpZmljIHByb2plY3Rpb24sIGVpdGhlclxuICogYnkgc2V0dGluZyB0aGUgYGdldFBvaW50UmVzb2x1dGlvbmAgb3B0aW9uIGluIHRoZVxuICoge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb25+UHJvamVjdGlvbn0gY29uc3RydWN0b3Igb3IgYnkgdXNpbmdcbiAqIHtAbGluayBtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9uflByb2plY3Rpb24jc2V0R2V0UG9pbnRSZXNvbHV0aW9ufSB0byBjaGFuZ2UgYW4gZXhpc3RpbmdcbiAqIHByb2plY3Rpb24gb2JqZWN0LlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gcHJvamVjdGlvbiBUaGUgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIE5vbWluYWwgcmVzb2x1dGlvbiBpbiBwcm9qZWN0aW9uIHVuaXRzLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gcG9pbnQgUG9pbnQgdG8gZmluZCBhZGp1c3RlZCByZXNvbHV0aW9uIGF0LlxuICogQHBhcmFtIHtVbml0cz19IG9wdF91bml0cyBVbml0cyB0byBnZXQgdGhlIHBvaW50IHJlc29sdXRpb24gaW4uXG4gKiBEZWZhdWx0IGlzIHRoZSBwcm9qZWN0aW9uJ3MgdW5pdHMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFBvaW50IHJlc29sdXRpb24uXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQb2ludFJlc29sdXRpb24ocHJvamVjdGlvbiwgcmVzb2x1dGlvbiwgcG9pbnQsIG9wdF91bml0cykge1xuICBwcm9qZWN0aW9uID0gZ2V0KHByb2plY3Rpb24pO1xuICB2YXIgcG9pbnRSZXNvbHV0aW9uO1xuICB2YXIgZ2V0dGVyID0gcHJvamVjdGlvbi5nZXRQb2ludFJlc29sdXRpb25GdW5jKCk7XG4gIGlmIChnZXR0ZXIpIHtcbiAgICBwb2ludFJlc29sdXRpb24gPSBnZXR0ZXIocmVzb2x1dGlvbiwgcG9pbnQpO1xuICB9IGVsc2Uge1xuICAgIHZhciB1bml0cyA9IHByb2plY3Rpb24uZ2V0VW5pdHMoKTtcbiAgICBpZiAodW5pdHMgPT0gVW5pdHMuREVHUkVFUyAmJiAhb3B0X3VuaXRzIHx8IG9wdF91bml0cyA9PSBVbml0cy5ERUdSRUVTKSB7XG4gICAgICBwb2ludFJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFc3RpbWF0ZSBwb2ludCByZXNvbHV0aW9uIGJ5IHRyYW5zZm9ybWluZyB0aGUgY2VudGVyIHBpeGVsIHRvIEVQU0c6NDMyNixcbiAgICAgIC8vIG1lYXN1cmluZyBpdHMgd2lkdGggYW5kIGhlaWdodCBvbiB0aGUgbm9ybWFsIHNwaGVyZSwgYW5kIHRha2luZyB0aGVcbiAgICAgIC8vIGF2ZXJhZ2Ugb2YgdGhlIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgICB2YXIgdG9FUFNHNDMyNiA9IGdldFRyYW5zZm9ybUZyb21Qcm9qZWN0aW9ucyhwcm9qZWN0aW9uLCBnZXQoJ0VQU0c6NDMyNicpKTtcbiAgICAgIHZhciB2ZXJ0aWNlcyA9IFtcbiAgICAgICAgcG9pbnRbMF0gLSByZXNvbHV0aW9uIC8gMiwgcG9pbnRbMV0sXG4gICAgICAgIHBvaW50WzBdICsgcmVzb2x1dGlvbiAvIDIsIHBvaW50WzFdLFxuICAgICAgICBwb2ludFswXSwgcG9pbnRbMV0gLSByZXNvbHV0aW9uIC8gMixcbiAgICAgICAgcG9pbnRbMF0sIHBvaW50WzFdICsgcmVzb2x1dGlvbiAvIDJcbiAgICAgIF07XG4gICAgICB2ZXJ0aWNlcyA9IHRvRVBTRzQzMjYodmVydGljZXMsIHZlcnRpY2VzLCAyKTtcbiAgICAgIHZhciB3aWR0aCA9IGdldERpc3RhbmNlKHZlcnRpY2VzLnNsaWNlKDAsIDIpLCB2ZXJ0aWNlcy5zbGljZSgyLCA0KSk7XG4gICAgICB2YXIgaGVpZ2h0ID0gZ2V0RGlzdGFuY2UodmVydGljZXMuc2xpY2UoNCwgNiksIHZlcnRpY2VzLnNsaWNlKDYsIDgpKTtcbiAgICAgIHBvaW50UmVzb2x1dGlvbiA9ICh3aWR0aCArIGhlaWdodCkgLyAyO1xuICAgICAgdmFyIG1ldGVyc1BlclVuaXQgPSBvcHRfdW5pdHMgP1xuICAgICAgICBNRVRFUlNfUEVSX1VOSVRbb3B0X3VuaXRzXSA6XG4gICAgICAgIHByb2plY3Rpb24uZ2V0TWV0ZXJzUGVyVW5pdCgpO1xuICAgICAgaWYgKG1ldGVyc1BlclVuaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwb2ludFJlc29sdXRpb24gLz0gbWV0ZXJzUGVyVW5pdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBvaW50UmVzb2x1dGlvbjtcbn1cblxuXG4vKipcbiAqIFJlZ2lzdGVycyB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbnMgdGhhdCBkb24ndCBhbHRlciBjb29yZGluYXRlcy4gVGhvc2UgYWxsb3dcbiAqIHRvIHRyYW5zZm9ybSBiZXR3ZWVuIHByb2plY3Rpb25zIHdpdGggZXF1YWwgbWVhbmluZy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PFByb2plY3Rpb24+fSBwcm9qZWN0aW9ucyBQcm9qZWN0aW9ucy5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZEVxdWl2YWxlbnRQcm9qZWN0aW9ucyhwcm9qZWN0aW9ucykge1xuICBhZGRQcm9qZWN0aW9ucyhwcm9qZWN0aW9ucyk7XG4gIHByb2plY3Rpb25zLmZvckVhY2goZnVuY3Rpb24oc291cmNlKSB7XG4gICAgcHJvamVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihkZXN0aW5hdGlvbikge1xuICAgICAgaWYgKHNvdXJjZSAhPT0gZGVzdGluYXRpb24pIHtcbiAgICAgICAgYWRkVHJhbnNmb3JtRnVuYyhzb3VyY2UsIGRlc3RpbmF0aW9uLCBjbG9uZVRyYW5zZm9ybSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5cbi8qKlxuICogUmVnaXN0ZXJzIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9ucyB0byBjb252ZXJ0IGNvb3JkaW5hdGVzIGluIGFueSBwcm9qZWN0aW9uXG4gKiBpbiBwcm9qZWN0aW9uMSB0byBhbnkgcHJvamVjdGlvbiBpbiBwcm9qZWN0aW9uMi5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PFByb2plY3Rpb24+fSBwcm9qZWN0aW9uczEgUHJvamVjdGlvbnMgd2l0aCBlcXVhbFxuICogICAgIG1lYW5pbmcuXG4gKiBAcGFyYW0ge0FycmF5PFByb2plY3Rpb24+fSBwcm9qZWN0aW9uczIgUHJvamVjdGlvbnMgd2l0aCBlcXVhbFxuICogICAgIG1lYW5pbmcuXG4gKiBAcGFyYW0ge1RyYW5zZm9ybUZ1bmN0aW9ufSBmb3J3YXJkVHJhbnNmb3JtIFRyYW5zZm9ybWF0aW9uIGZyb20gYW55XG4gKiAgIHByb2plY3Rpb24gaW4gcHJvamVjdGlvbjEgdG8gYW55IHByb2plY3Rpb24gaW4gcHJvamVjdGlvbjIuXG4gKiBAcGFyYW0ge1RyYW5zZm9ybUZ1bmN0aW9ufSBpbnZlcnNlVHJhbnNmb3JtIFRyYW5zZm9ybSBmcm9tIGFueSBwcm9qZWN0aW9uXG4gKiAgIGluIHByb2plY3Rpb24yIHRvIGFueSBwcm9qZWN0aW9uIGluIHByb2plY3Rpb24xLi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZEVxdWl2YWxlbnRUcmFuc2Zvcm1zKHByb2plY3Rpb25zMSwgcHJvamVjdGlvbnMyLCBmb3J3YXJkVHJhbnNmb3JtLCBpbnZlcnNlVHJhbnNmb3JtKSB7XG4gIHByb2plY3Rpb25zMS5mb3JFYWNoKGZ1bmN0aW9uKHByb2plY3Rpb24xKSB7XG4gICAgcHJvamVjdGlvbnMyLmZvckVhY2goZnVuY3Rpb24ocHJvamVjdGlvbjIpIHtcbiAgICAgIGFkZFRyYW5zZm9ybUZ1bmMocHJvamVjdGlvbjEsIHByb2plY3Rpb24yLCBmb3J3YXJkVHJhbnNmb3JtKTtcbiAgICAgIGFkZFRyYW5zZm9ybUZ1bmMocHJvamVjdGlvbjIsIHByb2plY3Rpb24xLCBpbnZlcnNlVHJhbnNmb3JtKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cblxuLyoqXG4gKiBDbGVhciBhbGwgY2FjaGVkIHByb2plY3Rpb25zIGFuZCB0cmFuc2Zvcm1zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJBbGxQcm9qZWN0aW9ucygpIHtcbiAgcHJvamVjdGlvbnMuY2xlYXIoKTtcbiAgY2xlYXJUcmFuc2Zvcm1GdW5jcygpO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtQcm9qZWN0aW9ufHN0cmluZ3x1bmRlZmluZWR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkZWZhdWx0Q29kZSBEZWZhdWx0IGNvZGUuXG4gKiBAcmV0dXJuIHtQcm9qZWN0aW9ufSBQcm9qZWN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUHJvamVjdGlvbihwcm9qZWN0aW9uLCBkZWZhdWx0Q29kZSkge1xuICBpZiAoIXByb2plY3Rpb24pIHtcbiAgICByZXR1cm4gZ2V0KGRlZmF1bHRDb2RlKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvamVjdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZ2V0KHByb2plY3Rpb24pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoXG4gICAgICAvKiogQHR5cGUge1Byb2plY3Rpb259ICovIChwcm9qZWN0aW9uKVxuICAgICk7XG4gIH1cbn1cblxuXG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgbW9kdWxlOm9sL3Byb2p+VHJhbnNmb3JtRnVuY3Rpb259IGZyb20gYSBzaW1wbGUgMkQgY29vcmRpbmF0ZSB0cmFuc2Zvcm1cbiAqIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbihpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZSk6IGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZFRyYW5zZm9ybSBDb29yZGluYXRlXG4gKiAgICAgdHJhbnNmb3JtLlxuICogQHJldHVybiB7VHJhbnNmb3JtRnVuY3Rpb259IFRyYW5zZm9ybSBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRyYW5zZm9ybUZyb21Db29yZGluYXRlVHJhbnNmb3JtKGNvb3JkVHJhbnNmb3JtKSB7XG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBpbnB1dCBJbnB1dC5cbiAgICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj49fSBvcHRfb3V0cHV0IE91dHB1dC5cbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9wdF9kaW1lbnNpb24gRGltZW5zaW9uLlxuICAgICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IE91dHB1dC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbihpbnB1dCwgb3B0X291dHB1dCwgb3B0X2RpbWVuc2lvbikge1xuICAgICAgdmFyIGxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICAgIHZhciBkaW1lbnNpb24gPSBvcHRfZGltZW5zaW9uICE9PSB1bmRlZmluZWQgPyBvcHRfZGltZW5zaW9uIDogMjtcbiAgICAgIHZhciBvdXRwdXQgPSBvcHRfb3V0cHV0ICE9PSB1bmRlZmluZWQgPyBvcHRfb3V0cHV0IDogbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSBkaW1lbnNpb24pIHtcbiAgICAgICAgdmFyIHBvaW50ID0gY29vcmRUcmFuc2Zvcm0oW2lucHV0W2ldLCBpbnB1dFtpICsgMV1dKTtcbiAgICAgICAgb3V0cHV0W2ldID0gcG9pbnRbMF07XG4gICAgICAgIG91dHB1dFtpICsgMV0gPSBwb2ludFsxXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IGRpbWVuc2lvbiAtIDE7IGogPj0gMjsgLS1qKSB7XG4gICAgICAgICAgb3V0cHV0W2kgKyBqXSA9IGlucHV0W2kgKyBqXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9KTtcbn1cblxuXG4vKipcbiAqIFJlZ2lzdGVycyBjb29yZGluYXRlIHRyYW5zZm9ybSBmdW5jdGlvbnMgdG8gY29udmVydCBjb29yZGluYXRlcyBiZXR3ZWVuIHRoZVxuICogc291cmNlIHByb2plY3Rpb24gYW5kIHRoZSBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uLlxuICogVGhlIGZvcndhcmQgYW5kIGludmVyc2UgZnVuY3Rpb25zIGNvbnZlcnQgY29vcmRpbmF0ZSBwYWlyczsgdGhpcyBmdW5jdGlvblxuICogY29udmVydHMgdGhlc2UgaW50byB0aGUgZnVuY3Rpb25zIHVzZWQgaW50ZXJuYWxseSB3aGljaCBhbHNvIGhhbmRsZVxuICogZXh0ZW50cyBhbmQgY29vcmRpbmF0ZSBhcnJheXMuXG4gKlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gc291cmNlIFNvdXJjZSBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gZGVzdGluYXRpb24gRGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGUpOiBpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gZm9yd2FyZCBUaGUgZm9yd2FyZCB0cmFuc2Zvcm1cbiAqICAgICBmdW5jdGlvbiAodGhhdCBpcywgZnJvbSB0aGUgc291cmNlIHByb2plY3Rpb24gdG8gdGhlIGRlc3RpbmF0aW9uXG4gKiAgICAgcHJvamVjdGlvbikgdGhhdCB0YWtlcyBhIHtAbGluayBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBhcyBhcmd1bWVudCBhbmQgcmV0dXJuc1xuICogICAgIHRoZSB0cmFuc2Zvcm1lZCB7QGxpbmsgbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlKTogaW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGludmVyc2UgVGhlIGludmVyc2UgdHJhbnNmb3JtXG4gKiAgICAgZnVuY3Rpb24gKHRoYXQgaXMsIGZyb20gdGhlIGRlc3RpbmF0aW9uIHByb2plY3Rpb24gdG8gdGhlIHNvdXJjZVxuICogICAgIHByb2plY3Rpb24pIHRoYXQgdGFrZXMgYSB7QGxpbmsgbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gYXMgYXJndW1lbnQgYW5kIHJldHVybnNcbiAqICAgICB0aGUgdHJhbnNmb3JtZWQge0BsaW5rIG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkQ29vcmRpbmF0ZVRyYW5zZm9ybXMoc291cmNlLCBkZXN0aW5hdGlvbiwgZm9yd2FyZCwgaW52ZXJzZSkge1xuICB2YXIgc291cmNlUHJvaiA9IGdldChzb3VyY2UpO1xuICB2YXIgZGVzdFByb2ogPSBnZXQoZGVzdGluYXRpb24pO1xuICBhZGRUcmFuc2Zvcm1GdW5jKHNvdXJjZVByb2osIGRlc3RQcm9qLCBjcmVhdGVUcmFuc2Zvcm1Gcm9tQ29vcmRpbmF0ZVRyYW5zZm9ybShmb3J3YXJkKSk7XG4gIGFkZFRyYW5zZm9ybUZ1bmMoZGVzdFByb2osIHNvdXJjZVByb2osIGNyZWF0ZVRyYW5zZm9ybUZyb21Db29yZGluYXRlVHJhbnNmb3JtKGludmVyc2UpKTtcbn1cblxuXG4vKipcbiAqIFRyYW5zZm9ybXMgYSBjb29yZGluYXRlIGZyb20gbG9uZ2l0dWRlL2xhdGl0dWRlIHRvIGEgZGlmZmVyZW50IHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUgYXMgbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZSwgaS5lLlxuICogICAgIGFuIGFycmF5IHdpdGggbG9uZ2l0dWRlIGFzIDFzdCBhbmQgbGF0aXR1ZGUgYXMgMm5kIGVsZW1lbnQuXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlPX0gb3B0X3Byb2plY3Rpb24gVGFyZ2V0IHByb2plY3Rpb24uIFRoZVxuICogICAgIGRlZmF1bHQgaXMgV2ViIE1lcmNhdG9yLCBpLmUuICdFUFNHOjM4NTcnLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IENvb3JkaW5hdGUgcHJvamVjdGVkIHRvIHRoZSB0YXJnZXQgcHJvamVjdGlvbi5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Mb25MYXQoY29vcmRpbmF0ZSwgb3B0X3Byb2plY3Rpb24pIHtcbiAgcmV0dXJuIHRyYW5zZm9ybShjb29yZGluYXRlLCAnRVBTRzo0MzI2JyxcbiAgICBvcHRfcHJvamVjdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0X3Byb2plY3Rpb24gOiAnRVBTRzozODU3Jyk7XG59XG5cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIGEgY29vcmRpbmF0ZSB0byBsb25naXR1ZGUvbGF0aXR1ZGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIFByb2plY3RlZCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZT19IG9wdF9wcm9qZWN0aW9uIFByb2plY3Rpb24gb2YgdGhlIGNvb3JkaW5hdGUuXG4gKiAgICAgVGhlIGRlZmF1bHQgaXMgV2ViIE1lcmNhdG9yLCBpLmUuICdFUFNHOjM4NTcnLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IENvb3JkaW5hdGUgYXMgbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZSwgaS5lLiBhbiBhcnJheVxuICogICAgIHdpdGggbG9uZ2l0dWRlIGFzIDFzdCBhbmQgbGF0aXR1ZGUgYXMgMm5kIGVsZW1lbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0xvbkxhdChjb29yZGluYXRlLCBvcHRfcHJvamVjdGlvbikge1xuICB2YXIgbG9uTGF0ID0gdHJhbnNmb3JtKGNvb3JkaW5hdGUsXG4gICAgb3B0X3Byb2plY3Rpb24gIT09IHVuZGVmaW5lZCA/IG9wdF9wcm9qZWN0aW9uIDogJ0VQU0c6Mzg1NycsICdFUFNHOjQzMjYnKTtcbiAgdmFyIGxvbiA9IGxvbkxhdFswXTtcbiAgaWYgKGxvbiA8IC0xODAgfHwgbG9uID4gMTgwKSB7XG4gICAgbG9uTGF0WzBdID0gbW9kdWxvKGxvbiArIDE4MCwgMzYwKSAtIDE4MDtcbiAgfVxuICByZXR1cm4gbG9uTGF0O1xufVxuXG5cbi8qKlxuICogQ2hlY2tzIGlmIHR3byBwcm9qZWN0aW9ucyBhcmUgdGhlIHNhbWUsIHRoYXQgaXMgZXZlcnkgY29vcmRpbmF0ZSBpbiBvbmVcbiAqIHByb2plY3Rpb24gZG9lcyByZXByZXNlbnQgdGhlIHNhbWUgZ2VvZ3JhcGhpYyBwb2ludCBhcyB0aGUgc2FtZSBjb29yZGluYXRlIGluXG4gKiB0aGUgb3RoZXIgcHJvamVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1Byb2plY3Rpb259IHByb2plY3Rpb24xIFByb2plY3Rpb24gMS5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbn0gcHJvamVjdGlvbjIgUHJvamVjdGlvbiAyLlxuICogQHJldHVybiB7Ym9vbGVhbn0gRXF1aXZhbGVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWl2YWxlbnQocHJvamVjdGlvbjEsIHByb2plY3Rpb24yKSB7XG4gIGlmIChwcm9qZWN0aW9uMSA9PT0gcHJvamVjdGlvbjIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgZXF1YWxVbml0cyA9IHByb2plY3Rpb24xLmdldFVuaXRzKCkgPT09IHByb2plY3Rpb24yLmdldFVuaXRzKCk7XG4gIGlmIChwcm9qZWN0aW9uMS5nZXRDb2RlKCkgPT09IHByb2plY3Rpb24yLmdldENvZGUoKSkge1xuICAgIHJldHVybiBlcXVhbFVuaXRzO1xuICB9IGVsc2Uge1xuICAgIHZhciB0cmFuc2Zvcm1GdW5jID0gZ2V0VHJhbnNmb3JtRnJvbVByb2plY3Rpb25zKHByb2plY3Rpb24xLCBwcm9qZWN0aW9uMik7XG4gICAgcmV0dXJuIHRyYW5zZm9ybUZ1bmMgPT09IGNsb25lVHJhbnNmb3JtICYmIGVxdWFsVW5pdHM7XG4gIH1cbn1cblxuXG4vKipcbiAqIFNlYXJjaGVzIGluIHRoZSBsaXN0IG9mIHRyYW5zZm9ybSBmdW5jdGlvbnMgZm9yIHRoZSBmdW5jdGlvbiBmb3IgY29udmVydGluZ1xuICogY29vcmRpbmF0ZXMgZnJvbSB0aGUgc291cmNlIHByb2plY3Rpb24gdG8gdGhlIGRlc3RpbmF0aW9uIHByb2plY3Rpb24uXG4gKlxuICogQHBhcmFtIHtQcm9qZWN0aW9ufSBzb3VyY2VQcm9qZWN0aW9uIFNvdXJjZSBQcm9qZWN0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbn0gZGVzdGluYXRpb25Qcm9qZWN0aW9uIERlc3RpbmF0aW9uIFByb2plY3Rpb25cbiAqICAgICBvYmplY3QuXG4gKiBAcmV0dXJuIHtUcmFuc2Zvcm1GdW5jdGlvbn0gVHJhbnNmb3JtIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHJhbnNmb3JtRnJvbVByb2plY3Rpb25zKHNvdXJjZVByb2plY3Rpb24sIGRlc3RpbmF0aW9uUHJvamVjdGlvbikge1xuICB2YXIgc291cmNlQ29kZSA9IHNvdXJjZVByb2plY3Rpb24uZ2V0Q29kZSgpO1xuICB2YXIgZGVzdGluYXRpb25Db2RlID0gZGVzdGluYXRpb25Qcm9qZWN0aW9uLmdldENvZGUoKTtcbiAgdmFyIHRyYW5zZm9ybUZ1bmMgPSBnZXRUcmFuc2Zvcm1GdW5jKHNvdXJjZUNvZGUsIGRlc3RpbmF0aW9uQ29kZSk7XG4gIGlmICghdHJhbnNmb3JtRnVuYykge1xuICAgIHRyYW5zZm9ybUZ1bmMgPSBpZGVudGl0eVRyYW5zZm9ybTtcbiAgfVxuICByZXR1cm4gdHJhbnNmb3JtRnVuYztcbn1cblxuXG4vKipcbiAqIEdpdmVuIHRoZSBwcm9qZWN0aW9uLWxpa2Ugb2JqZWN0cywgc2VhcmNoZXMgZm9yIGEgdHJhbnNmb3JtYXRpb25cbiAqIGZ1bmN0aW9uIHRvIGNvbnZlcnQgYSBjb29yZGluYXRlcyBhcnJheSBmcm9tIHRoZSBzb3VyY2UgcHJvamVjdGlvbiB0byB0aGVcbiAqIGRlc3RpbmF0aW9uIHByb2plY3Rpb24uXG4gKlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gc291cmNlIFNvdXJjZS5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2V9IGRlc3RpbmF0aW9uIERlc3RpbmF0aW9uLlxuICogQHJldHVybiB7VHJhbnNmb3JtRnVuY3Rpb259IFRyYW5zZm9ybSBmdW5jdGlvbi5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRyYW5zZm9ybShzb3VyY2UsIGRlc3RpbmF0aW9uKSB7XG4gIHZhciBzb3VyY2VQcm9qZWN0aW9uID0gZ2V0KHNvdXJjZSk7XG4gIHZhciBkZXN0aW5hdGlvblByb2plY3Rpb24gPSBnZXQoZGVzdGluYXRpb24pO1xuICByZXR1cm4gZ2V0VHJhbnNmb3JtRnJvbVByb2plY3Rpb25zKHNvdXJjZVByb2plY3Rpb24sIGRlc3RpbmF0aW9uUHJvamVjdGlvbik7XG59XG5cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIGEgY29vcmRpbmF0ZSBmcm9tIHNvdXJjZSBwcm9qZWN0aW9uIHRvIGRlc3RpbmF0aW9uIHByb2plY3Rpb24uXG4gKiBUaGlzIHJldHVybnMgYSBuZXcgY29vcmRpbmF0ZSAoYW5kIGRvZXMgbm90IG1vZGlmeSB0aGUgb3JpZ2luYWwpLlxuICpcbiAqIFNlZSB7QGxpbmsgbW9kdWxlOm9sL3Byb2p+dHJhbnNmb3JtRXh0ZW50fSBmb3IgZXh0ZW50IHRyYW5zZm9ybWF0aW9uLlxuICogU2VlIHRoZSB0cmFuc2Zvcm0gbWV0aG9kIG9mIHtAbGluayBtb2R1bGU6b2wvZ2VvbS9HZW9tZXRyeX5HZW9tZXRyeX0gYW5kIGl0c1xuICogc3ViY2xhc3NlcyBmb3IgZ2VvbWV0cnkgdHJhbnNmb3Jtcy5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBzb3VyY2UgU291cmNlIHByb2plY3Rpb24tbGlrZS5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2V9IGRlc3RpbmF0aW9uIERlc3RpbmF0aW9uIHByb2plY3Rpb24tbGlrZS5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBDb29yZGluYXRlLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtKGNvb3JkaW5hdGUsIHNvdXJjZSwgZGVzdGluYXRpb24pIHtcbiAgdmFyIHRyYW5zZm9ybUZ1bmMgPSBnZXRUcmFuc2Zvcm0oc291cmNlLCBkZXN0aW5hdGlvbik7XG4gIHJldHVybiB0cmFuc2Zvcm1GdW5jKGNvb3JkaW5hdGUsIHVuZGVmaW5lZCwgY29vcmRpbmF0ZS5sZW5ndGgpO1xufVxuXG5cbi8qKlxuICogVHJhbnNmb3JtcyBhbiBleHRlbnQgZnJvbSBzb3VyY2UgcHJvamVjdGlvbiB0byBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uLiAgVGhpc1xuICogcmV0dXJucyBhIG5ldyBleHRlbnQgKGFuZCBkb2VzIG5vdCBtb2RpZnkgdGhlIG9yaWdpbmFsKS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IFRoZSBleHRlbnQgdG8gdHJhbnNmb3JtLlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gc291cmNlIFNvdXJjZSBwcm9qZWN0aW9uLWxpa2UuXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBkZXN0aW5hdGlvbiBEZXN0aW5hdGlvbiBwcm9qZWN0aW9uLWxpa2UuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IFRoZSB0cmFuc2Zvcm1lZCBleHRlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1FeHRlbnQoZXh0ZW50LCBzb3VyY2UsIGRlc3RpbmF0aW9uKSB7XG4gIHZhciB0cmFuc2Zvcm1GdW5jID0gZ2V0VHJhbnNmb3JtKHNvdXJjZSwgZGVzdGluYXRpb24pO1xuICByZXR1cm4gYXBwbHlUcmFuc2Zvcm0oZXh0ZW50LCB0cmFuc2Zvcm1GdW5jKTtcbn1cblxuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIGdpdmVuIHBvaW50IHRvIHRoZSBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IHBvaW50IFBvaW50LlxuICogQHBhcmFtIHtQcm9qZWN0aW9ufSBzb3VyY2VQcm9qZWN0aW9uIFNvdXJjZSBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHtQcm9qZWN0aW9ufSBkZXN0aW5hdGlvblByb2plY3Rpb24gRGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBQb2ludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVdpdGhQcm9qZWN0aW9ucyhwb2ludCwgc291cmNlUHJvamVjdGlvbiwgZGVzdGluYXRpb25Qcm9qZWN0aW9uKSB7XG4gIHZhciB0cmFuc2Zvcm1GdW5jID0gZ2V0VHJhbnNmb3JtRnJvbVByb2plY3Rpb25zKHNvdXJjZVByb2plY3Rpb24sIGRlc3RpbmF0aW9uUHJvamVjdGlvbik7XG4gIHJldHVybiB0cmFuc2Zvcm1GdW5jKHBvaW50KTtcbn1cblxuLyoqXG4gKiBBZGQgdHJhbnNmb3JtcyB0byBhbmQgZnJvbSBFUFNHOjQzMjYgYW5kIEVQU0c6Mzg1Ny4gIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkXG4gKiBieSB3aGVuIHRoaXMgbW9kdWxlIGlzIGV4ZWN1dGVkIGFuZCBzaG91bGQgb25seSBuZWVkIHRvIGJlIGNhbGxlZCBhZ2FpbiBhZnRlclxuICogYGNsZWFyQWxsUHJvamVjdGlvbnMoKWAgaXMgY2FsbGVkIChlLmcuIGluIHRlc3RzKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZENvbW1vbigpIHtcbiAgLy8gQWRkIHRyYW5zZm9ybWF0aW9ucyB0aGF0IGRvbid0IGFsdGVyIGNvb3JkaW5hdGVzIHRvIGNvbnZlcnQgd2l0aGluIHNldCBvZlxuICAvLyBwcm9qZWN0aW9ucyB3aXRoIGVxdWFsIG1lYW5pbmcuXG4gIGFkZEVxdWl2YWxlbnRQcm9qZWN0aW9ucyhFUFNHMzg1N19QUk9KRUNUSU9OUyk7XG4gIGFkZEVxdWl2YWxlbnRQcm9qZWN0aW9ucyhFUFNHNDMyNl9QUk9KRUNUSU9OUyk7XG4gIC8vIEFkZCB0cmFuc2Zvcm1hdGlvbnMgdG8gY29udmVydCBFUFNHOjQzMjYgbGlrZSBjb29yZGluYXRlcyB0byBFUFNHOjM4NTcgbGlrZVxuICAvLyBjb29yZGluYXRlcyBhbmQgYmFjay5cbiAgYWRkRXF1aXZhbGVudFRyYW5zZm9ybXMoRVBTRzQzMjZfUFJPSkVDVElPTlMsIEVQU0czODU3X1BST0pFQ1RJT05TLCBmcm9tRVBTRzQzMjYsIHRvRVBTRzQzMjYpO1xufVxuXG5hZGRDb21tb24oKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvai5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcHJvai9Qcm9qZWN0aW9uXG4gKi9cbmltcG9ydCB7TUVURVJTX1BFUl9VTklUfSBmcm9tICcuL1VuaXRzLmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb2RlIFRoZSBTUlMgaWRlbnRpZmllciBjb2RlLCBlLmcuIGBFUFNHOjQzMjZgLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL1VuaXRzLmpzXCIpLmRlZmF1bHR8c3RyaW5nfSBbdW5pdHNdIFVuaXRzLiBSZXF1aXJlZCB1bmxlc3MgYVxuICogcHJvajQgcHJvamVjdGlvbiBpcyBkZWZpbmVkIGZvciBgY29kZWAuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IFtleHRlbnRdIFRoZSB2YWxpZGl0eSBleHRlbnQgZm9yIHRoZSBTUlMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2F4aXNPcmllbnRhdGlvbj0nZW51J10gVGhlIGF4aXMgb3JpZW50YXRpb24gYXMgc3BlY2lmaWVkIGluIFByb2o0LlxuICogQHByb3BlcnR5IHtib29sZWFufSBbZ2xvYmFsPWZhbHNlXSBXaGV0aGVyIHRoZSBwcm9qZWN0aW9uIGlzIHZhbGlkIGZvciB0aGUgd2hvbGUgZ2xvYmUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21ldGVyc1BlclVuaXRdIFRoZSBtZXRlcnMgcGVyIHVuaXQgZm9yIHRoZSBTUlMuXG4gKiBJZiBub3QgcHJvdmlkZWQsIHRoZSBgdW5pdHNgIGFyZSB1c2VkIHRvIGdldCB0aGUgbWV0ZXJzIHBlciB1bml0IGZyb20gdGhlIHtAbGluayBtb2R1bGU6b2wvcHJvai9Vbml0c35NRVRFUlNfUEVSX1VOSVR9XG4gKiBsb29rdXAgdGFibGUuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IFt3b3JsZEV4dGVudF0gVGhlIHdvcmxkIGV4dGVudCBmb3IgdGhlIFNSUy5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24obnVtYmVyLCBpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGUpOm51bWJlcn0gW2dldFBvaW50UmVzb2x1dGlvbl1cbiAqIEZ1bmN0aW9uIHRvIGRldGVybWluZSByZXNvbHV0aW9uIGF0IGEgcG9pbnQuIFRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBhXG4gKiBge251bWJlcn1gIHZpZXcgcmVzb2x1dGlvbiBhbmQgYW4gYHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9YCBhcyBhcmd1bWVudHMsIGFuZCByZXR1cm5zXG4gKiB0aGUgYHtudW1iZXJ9YCByZXNvbHV0aW9uIGF0IHRoZSBwYXNzZWQgY29vcmRpbmF0ZS4gSWYgdGhpcyBpcyBgdW5kZWZpbmVkYCxcbiAqIHRoZSBkZWZhdWx0IHtAbGluayBtb2R1bGU6b2wvcHJvaiNnZXRQb2ludFJlc29sdXRpb259IGZ1bmN0aW9uIHdpbGwgYmUgdXNlZC5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogUHJvamVjdGlvbiBkZWZpbml0aW9uIGNsYXNzLiBPbmUgb2YgdGhlc2UgaXMgY3JlYXRlZCBmb3IgZWFjaCBwcm9qZWN0aW9uXG4gKiBzdXBwb3J0ZWQgaW4gdGhlIGFwcGxpY2F0aW9uIGFuZCBzdG9yZWQgaW4gdGhlIHtAbGluayBtb2R1bGU6b2wvcHJvan0gbmFtZXNwYWNlLlxuICogWW91IGNhbiB1c2UgdGhlc2UgaW4gYXBwbGljYXRpb25zLCBidXQgdGhpcyBpcyBub3QgcmVxdWlyZWQsIGFzIEFQSSBwYXJhbXNcbiAqIGFuZCBvcHRpb25zIHVzZSB7QGxpbmsgbW9kdWxlOm9sL3Byb2p+UHJvamVjdGlvbkxpa2V9IHdoaWNoIG1lYW5zIHRoZSBzaW1wbGUgc3RyaW5nXG4gKiBjb2RlIHdpbGwgc3VmZmljZS5cbiAqXG4gKiBZb3UgY2FuIHVzZSB7QGxpbmsgbW9kdWxlOm9sL3Byb2p+Z2V0fSB0byByZXRyaWV2ZSB0aGUgb2JqZWN0IGZvciBhIHBhcnRpY3VsYXJcbiAqIHByb2plY3Rpb24uXG4gKlxuICogVGhlIGxpYnJhcnkgaW5jbHVkZXMgZGVmaW5pdGlvbnMgZm9yIGBFUFNHOjQzMjZgIGFuZCBgRVBTRzozODU3YCwgdG9nZXRoZXJcbiAqIHdpdGggdGhlIGZvbGxvd2luZyBhbGlhc2VzOlxuICogKiBgRVBTRzo0MzI2YDogQ1JTOjg0LCB1cm46b2djOmRlZjpjcnM6RVBTRzo2LjY6NDMyNixcbiAqICAgICB1cm46b2djOmRlZjpjcnM6T0dDOjEuMzpDUlM4NCwgdXJuOm9nYzpkZWY6Y3JzOk9HQzoyOjg0LFxuICogICAgIGh0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sL3Nycy9lcHNnLnhtbCM0MzI2LFxuICogICAgIHVybjp4LW9nYzpkZWY6Y3JzOkVQU0c6NDMyNlxuICogKiBgRVBTRzozODU3YDogRVBTRzoxMDIxMDAsIEVQU0c6MTAyMTEzLCBFUFNHOjkwMDkxMyxcbiAqICAgICB1cm46b2djOmRlZjpjcnM6RVBTRzo2LjE4OjM6Mzg1NyxcbiAqICAgICBodHRwOi8vd3d3Lm9wZW5naXMubmV0L2dtbC9zcnMvZXBzZy54bWwjMzg1N1xuICpcbiAqIElmIHlvdSB1c2UgW3Byb2o0anNdKGh0dHBzOi8vZ2l0aHViLmNvbS9wcm9qNGpzL3Byb2o0anMpLCBhbGlhc2VzIGNhblxuICogYmUgYWRkZWQgdXNpbmcgYHByb2o0LmRlZnMoKWAuIEFmdGVyIGFsbCByZXF1aXJlZCBwcm9qZWN0aW9uIGRlZmluaXRpb25zIGFyZVxuICogYWRkZWQsIGNhbGwgdGhlIHtAbGluayBtb2R1bGU6b2wvcHJvai9wcm9qNH5yZWdpc3Rlcn0gZnVuY3Rpb24uXG4gKlxuICogQGFwaVxuICovXG52YXIgUHJvamVjdGlvbiA9IGZ1bmN0aW9uIFByb2plY3Rpb24ob3B0aW9ucykge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRoaXMuY29kZV8gPSBvcHRpb25zLmNvZGU7XG5cbiAgLyoqXG4gICAqIFVuaXRzIG9mIHByb2plY3RlZCBjb29yZGluYXRlcy4gV2hlbiBzZXQgdG8gYFRJTEVfUElYRUxTYCwgYVxuICAgKiBgdGhpcy5leHRlbnRfYCBhbmQgYHRoaXMud29ybGRFeHRlbnRfYCBtdXN0IGJlIGNvbmZpZ3VyZWQgcHJvcGVybHkgZm9yIGVhY2hcbiAgICogdGlsZS5cbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge2ltcG9ydChcIi4vVW5pdHMuanNcIikuZGVmYXVsdH1cbiAgICovXG4gIHRoaXMudW5pdHNfID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL1VuaXRzLmpzXCIpLmRlZmF1bHR9ICovIChvcHRpb25zLnVuaXRzKTtcblxuICAvKipcbiAgICogVmFsaWRpdHkgZXh0ZW50IG9mIHRoZSBwcm9qZWN0aW9uIGluIHByb2plY3RlZCBjb29yZGluYXRlcy4gRm9yIHByb2plY3Rpb25zXG4gICAqIHdpdGggYFRJTEVfUElYRUxTYCB1bml0cywgdGhpcyBpcyB0aGUgZXh0ZW50IG9mIHRoZSB0aWxlIGluXG4gICAqIHRpbGUgcGl4ZWwgc3BhY2UuXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgKi9cbiAgdGhpcy5leHRlbnRfID0gb3B0aW9ucy5leHRlbnQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZXh0ZW50IDogbnVsbDtcblxuICAvKipcbiAgICogRXh0ZW50IG9mIHRoZSB3b3JsZCBpbiBFUFNHOjQzMjYuIEZvciBwcm9qZWN0aW9ucyB3aXRoXG4gICAqIGBUSUxFX1BJWEVMU2AgdW5pdHMsIHRoaXMgaXMgdGhlIGV4dGVudCBvZiB0aGUgdGlsZSBpblxuICAgKiBwcm9qZWN0ZWQgY29vcmRpbmF0ZSBzcGFjZS5cbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gICAqL1xuICB0aGlzLndvcmxkRXh0ZW50XyA9IG9wdGlvbnMud29ybGRFeHRlbnQgIT09IHVuZGVmaW5lZCA/XG4gICAgb3B0aW9ucy53b3JsZEV4dGVudCA6IG51bGw7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0aGlzLmF4aXNPcmllbnRhdGlvbl8gPSBvcHRpb25zLmF4aXNPcmllbnRhdGlvbiAhPT0gdW5kZWZpbmVkID9cbiAgICBvcHRpb25zLmF4aXNPcmllbnRhdGlvbiA6ICdlbnUnO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHRoaXMuZ2xvYmFsXyA9IG9wdGlvbnMuZ2xvYmFsICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmdsb2JhbCA6IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHRoaXMuY2FuV3JhcFhfID0gISEodGhpcy5nbG9iYWxfICYmIHRoaXMuZXh0ZW50Xyk7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIsIGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZSk6bnVtYmVyfHVuZGVmaW5lZH1cbiAgICovXG4gIHRoaXMuZ2V0UG9pbnRSZXNvbHV0aW9uRnVuY18gPSBvcHRpb25zLmdldFBvaW50UmVzb2x1dGlvbjtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge2ltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9XG4gICAqL1xuICB0aGlzLmRlZmF1bHRUaWxlR3JpZF8gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICovXG4gIHRoaXMubWV0ZXJzUGVyVW5pdF8gPSBvcHRpb25zLm1ldGVyc1BlclVuaXQ7XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBwcm9qZWN0aW9uIGlzIHN1aXRhYmxlIGZvciB3cmFwcGluZyB0aGUgeC1heGlzXG4gKi9cblByb2plY3Rpb24ucHJvdG90eXBlLmNhbldyYXBYID0gZnVuY3Rpb24gY2FuV3JhcFggKCkge1xuICByZXR1cm4gdGhpcy5jYW5XcmFwWF87XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY29kZSBmb3IgdGhpcyBwcm9qZWN0aW9uLCBlLmcuICdFUFNHOjQzMjYnLlxuICogQHJldHVybiB7c3RyaW5nfSBDb2RlLlxuICogQGFwaVxuICovXG5Qcm9qZWN0aW9uLnByb3RvdHlwZS5nZXRDb2RlID0gZnVuY3Rpb24gZ2V0Q29kZSAoKSB7XG4gIHJldHVybiB0aGlzLmNvZGVfO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHZhbGlkaXR5IGV4dGVudCBmb3IgdGhpcyBwcm9qZWN0aW9uLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gRXh0ZW50LlxuICogQGFwaVxuICovXG5Qcm9qZWN0aW9uLnByb3RvdHlwZS5nZXRFeHRlbnQgPSBmdW5jdGlvbiBnZXRFeHRlbnQgKCkge1xuICByZXR1cm4gdGhpcy5leHRlbnRfO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHVuaXRzIG9mIHRoaXMgcHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vVW5pdHMuanNcIikuZGVmYXVsdH0gVW5pdHMuXG4gKiBAYXBpXG4gKi9cblByb2plY3Rpb24ucHJvdG90eXBlLmdldFVuaXRzID0gZnVuY3Rpb24gZ2V0VW5pdHMgKCkge1xuICByZXR1cm4gdGhpcy51bml0c187XG59O1xuXG4vKipcbiAqIEdldCB0aGUgYW1vdW50IG9mIG1ldGVycyBwZXIgdW5pdCBvZiB0aGlzIHByb2plY3Rpb24uSWYgdGhlIHByb2plY3Rpb24gaXNcbiAqIG5vdCBjb25maWd1cmVkIHdpdGggYG1ldGVyc1BlclVuaXRgIG9yIGEgdW5pdHMgaWRlbnRpZmllciwgdGhlIHJldHVybiBpc1xuICogYHVuZGVmaW5lZGAuXG4gKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBNZXRlcnMuXG4gKiBAYXBpXG4gKi9cblByb2plY3Rpb24ucHJvdG90eXBlLmdldE1ldGVyc1BlclVuaXQgPSBmdW5jdGlvbiBnZXRNZXRlcnNQZXJVbml0ICgpIHtcbiAgcmV0dXJuIHRoaXMubWV0ZXJzUGVyVW5pdF8gfHwgTUVURVJTX1BFUl9VTklUW3RoaXMudW5pdHNfXTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSB3b3JsZCBleHRlbnQgZm9yIHRoaXMgcHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IEV4dGVudC5cbiAqIEBhcGlcbiAqL1xuUHJvamVjdGlvbi5wcm90b3R5cGUuZ2V0V29ybGRFeHRlbnQgPSBmdW5jdGlvbiBnZXRXb3JsZEV4dGVudCAoKSB7XG4gIHJldHVybiB0aGlzLndvcmxkRXh0ZW50Xztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBheGlzIG9yaWVudGF0aW9uIG9mIHRoaXMgcHJvamVjdGlvbi5cbiAqIEV4YW1wbGUgdmFsdWVzIGFyZTpcbiAqIGVudSAtIHRoZSBkZWZhdWx0IGVhc3RpbmcsIG5vcnRoaW5nLCBlbGV2YXRpb24uXG4gKiBuZXUgLSBub3J0aGluZywgZWFzdGluZywgdXAgLSB1c2VmdWwgZm9yIFwibGF0L2xvbmdcIiBnZW9ncmFwaGljIGNvb3JkaW5hdGVzLFxuICogICBvciBzb3V0aCBvcmllbnRhdGVkIHRyYW5zdmVyc2UgbWVyY2F0b3IuXG4gKiB3bnUgLSB3ZXN0aW5nLCBub3J0aGluZywgdXAgLSBzb21lIHBsYW5ldGFyeSBjb29yZGluYXRlIHN5c3RlbXMgaGF2ZVxuICogICBcIndlc3QgcG9zaXRpdmVcIiBjb29yZGluYXRlIHN5c3RlbXNcbiAqIEByZXR1cm4ge3N0cmluZ30gQXhpcyBvcmllbnRhdGlvbi5cbiAqIEBhcGlcbiAqL1xuUHJvamVjdGlvbi5wcm90b3R5cGUuZ2V0QXhpc09yaWVudGF0aW9uID0gZnVuY3Rpb24gZ2V0QXhpc09yaWVudGF0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuYXhpc09yaWVudGF0aW9uXztcbn07XG5cbi8qKlxuICogSXMgdGhpcyBwcm9qZWN0aW9uIGEgZ2xvYmFsIHByb2plY3Rpb24gd2hpY2ggc3BhbnMgdGhlIHdob2xlIHdvcmxkP1xuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcHJvamVjdGlvbiBpcyBnbG9iYWwuXG4gKiBAYXBpXG4gKi9cblByb2plY3Rpb24ucHJvdG90eXBlLmlzR2xvYmFsID0gZnVuY3Rpb24gaXNHbG9iYWwgKCkge1xuICByZXR1cm4gdGhpcy5nbG9iYWxfO1xufTtcblxuLyoqXG4gKiBTZXQgaWYgdGhlIHByb2plY3Rpb24gaXMgYSBnbG9iYWwgcHJvamVjdGlvbiB3aGljaCBzcGFucyB0aGUgd2hvbGUgd29ybGRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZ2xvYmFsIFdoZXRoZXIgdGhlIHByb2plY3Rpb24gaXMgZ2xvYmFsLlxuICogQGFwaVxuICovXG5Qcm9qZWN0aW9uLnByb3RvdHlwZS5zZXRHbG9iYWwgPSBmdW5jdGlvbiBzZXRHbG9iYWwgKGdsb2JhbCkge1xuICB0aGlzLmdsb2JhbF8gPSBnbG9iYWw7XG4gIHRoaXMuY2FuV3JhcFhfID0gISEoZ2xvYmFsICYmIHRoaXMuZXh0ZW50Xyk7XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9IFRoZSBkZWZhdWx0IHRpbGUgZ3JpZC5cbiAqL1xuUHJvamVjdGlvbi5wcm90b3R5cGUuZ2V0RGVmYXVsdFRpbGVHcmlkID0gZnVuY3Rpb24gZ2V0RGVmYXVsdFRpbGVHcmlkICgpIHtcbiAgcmV0dXJuIHRoaXMuZGVmYXVsdFRpbGVHcmlkXztcbn07XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSB0aWxlR3JpZCBUaGUgZGVmYXVsdCB0aWxlIGdyaWQuXG4gKi9cblByb2plY3Rpb24ucHJvdG90eXBlLnNldERlZmF1bHRUaWxlR3JpZCA9IGZ1bmN0aW9uIHNldERlZmF1bHRUaWxlR3JpZCAodGlsZUdyaWQpIHtcbiAgdGhpcy5kZWZhdWx0VGlsZUdyaWRfID0gdGlsZUdyaWQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgdmFsaWRpdHkgZXh0ZW50IGZvciB0aGlzIHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAYXBpXG4gKi9cblByb2plY3Rpb24ucHJvdG90eXBlLnNldEV4dGVudCA9IGZ1bmN0aW9uIHNldEV4dGVudCAoZXh0ZW50KSB7XG4gIHRoaXMuZXh0ZW50XyA9IGV4dGVudDtcbiAgdGhpcy5jYW5XcmFwWF8gPSAhISh0aGlzLmdsb2JhbF8gJiYgZXh0ZW50KTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSB3b3JsZCBleHRlbnQgZm9yIHRoaXMgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gd29ybGRFeHRlbnQgV29ybGQgZXh0ZW50XG4gKiAgIFttaW5sb24sIG1pbmxhdCwgbWF4bG9uLCBtYXhsYXRdLlxuICogQGFwaVxuICovXG5Qcm9qZWN0aW9uLnByb3RvdHlwZS5zZXRXb3JsZEV4dGVudCA9IGZ1bmN0aW9uIHNldFdvcmxkRXh0ZW50ICh3b3JsZEV4dGVudCkge1xuICB0aGlzLndvcmxkRXh0ZW50XyA9IHdvcmxkRXh0ZW50O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGdldFBvaW50UmVzb2x1dGlvbiBmdW5jdGlvbiAoc2VlIHtAbGluayBtb2R1bGU6b2wvcHJvan5nZXRQb2ludFJlc29sdXRpb259XG4gKiBmb3IgdGhpcyBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbihudW1iZXIsIGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZSk6bnVtYmVyfSBmdW5jIEZ1bmN0aW9uXG4gKiBAYXBpXG4gKi9cblByb2plY3Rpb24ucHJvdG90eXBlLnNldEdldFBvaW50UmVzb2x1dGlvbiA9IGZ1bmN0aW9uIHNldEdldFBvaW50UmVzb2x1dGlvbiAoZnVuYykge1xuICB0aGlzLmdldFBvaW50UmVzb2x1dGlvbkZ1bmNfID0gZnVuYztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjdXN0b20gcG9pbnQgcmVzb2x1dGlvbiBmdW5jdGlvbiBmb3IgdGhpcyBwcm9qZWN0aW9uIChpZiBzZXQpLlxuICogQHJldHVybiB7ZnVuY3Rpb24obnVtYmVyLCBpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGUpOm51bWJlcnx1bmRlZmluZWR9IFRoZSBjdXN0b20gcG9pbnRcbiAqIHJlc29sdXRpb24gZnVuY3Rpb24gKGlmIHNldCkuXG4gKi9cblByb2plY3Rpb24ucHJvdG90eXBlLmdldFBvaW50UmVzb2x1dGlvbkZ1bmMgPSBmdW5jdGlvbiBnZXRQb2ludFJlc29sdXRpb25GdW5jICgpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0UG9pbnRSZXNvbHV0aW9uRnVuY187XG59O1xuXG5leHBvcnQgZGVmYXVsdCBQcm9qZWN0aW9uO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qcm9qZWN0aW9uLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9wcm9qL1VuaXRzXG4gKi9cblxuLyoqXG4gKiBQcm9qZWN0aW9uIHVuaXRzOiBgJ2RlZ3JlZXMnYCwgYCdmdCdgLCBgJ20nYCwgYCdwaXhlbHMnYCwgYCd0aWxlLXBpeGVscydgIG9yXG4gKiBgJ3VzLWZ0J2AuXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG52YXIgVW5pdHMgPSB7XG4gIERFR1JFRVM6ICdkZWdyZWVzJyxcbiAgRkVFVDogJ2Z0JyxcbiAgTUVURVJTOiAnbScsXG4gIFBJWEVMUzogJ3BpeGVscycsXG4gIFRJTEVfUElYRUxTOiAndGlsZS1waXhlbHMnLFxuICBVU0ZFRVQ6ICd1cy1mdCdcbn07XG5cblxuLyoqXG4gKiBNZXRlcnMgcGVyIHVuaXQgbG9va3VwIHRhYmxlLlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PFVuaXRzLCBudW1iZXI+fVxuICogQGFwaVxuICovXG5leHBvcnQgdmFyIE1FVEVSU19QRVJfVU5JVCA9IHt9O1xuLy8gdXNlIHRoZSByYWRpdXMgb2YgdGhlIE5vcm1hbCBzcGhlcmVcbk1FVEVSU19QRVJfVU5JVFtVbml0cy5ERUdSRUVTXSA9IDIgKiBNYXRoLlBJICogNjM3MDk5NyAvIDM2MDtcbk1FVEVSU19QRVJfVU5JVFtVbml0cy5GRUVUXSA9IDAuMzA0ODtcbk1FVEVSU19QRVJfVU5JVFtVbml0cy5NRVRFUlNdID0gMTtcbk1FVEVSU19QRVJfVU5JVFtVbml0cy5VU0ZFRVRdID0gMTIwMCAvIDM5Mzc7XG5cbmV4cG9ydCBkZWZhdWx0IFVuaXRzO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Vbml0cy5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcHJvai9lcHNnMzg1N1xuICovXG5pbXBvcnQge2Nvc2h9IGZyb20gJy4uL21hdGguanMnO1xuaW1wb3J0IFByb2plY3Rpb24gZnJvbSAnLi9Qcm9qZWN0aW9uLmpzJztcbmltcG9ydCBVbml0cyBmcm9tICcuL1VuaXRzLmpzJztcblxuXG4vKipcbiAqIFJhZGl1cyBvZiBXR1M4NCBzcGhlcmVcbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgUkFESVVTID0gNjM3ODEzNztcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBIQUxGX1NJWkUgPSBNYXRoLlBJICogUkFESVVTO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAqL1xuZXhwb3J0IHZhciBFWFRFTlQgPSBbXG4gIC1IQUxGX1NJWkUsIC1IQUxGX1NJWkUsXG4gIEhBTEZfU0laRSwgSEFMRl9TSVpFXG5dO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAqL1xuZXhwb3J0IHZhciBXT1JMRF9FWFRFTlQgPSBbLTE4MCwgLTg1LCAxODAsIDg1XTtcblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFByb2plY3Rpb24gb2JqZWN0IGZvciB3ZWIvc3BoZXJpY2FsIE1lcmNhdG9yIChFUFNHOjM4NTcpLlxuICovXG52YXIgRVBTRzM4NTdQcm9qZWN0aW9uID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoUHJvamVjdGlvbikge1xuICBmdW5jdGlvbiBFUFNHMzg1N1Byb2plY3Rpb24oY29kZSkge1xuICAgIFByb2plY3Rpb24uY2FsbCh0aGlzLCB7XG4gICAgICBjb2RlOiBjb2RlLFxuICAgICAgdW5pdHM6IFVuaXRzLk1FVEVSUyxcbiAgICAgIGV4dGVudDogRVhURU5ULFxuICAgICAgZ2xvYmFsOiB0cnVlLFxuICAgICAgd29ybGRFeHRlbnQ6IFdPUkxEX0VYVEVOVCxcbiAgICAgIGdldFBvaW50UmVzb2x1dGlvbjogZnVuY3Rpb24ocmVzb2x1dGlvbiwgcG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdXRpb24gLyBjb3NoKHBvaW50WzFdIC8gUkFESVVTKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICB9XG5cbiAgaWYgKCBQcm9qZWN0aW9uICkgRVBTRzM4NTdQcm9qZWN0aW9uLl9fcHJvdG9fXyA9IFByb2plY3Rpb247XG4gIEVQU0czODU3UHJvamVjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQcm9qZWN0aW9uICYmIFByb2plY3Rpb24ucHJvdG90eXBlICk7XG4gIEVQU0czODU3UHJvamVjdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFUFNHMzg1N1Byb2plY3Rpb247XG5cbiAgcmV0dXJuIEVQU0czODU3UHJvamVjdGlvbjtcbn0oUHJvamVjdGlvbikpO1xuXG5cbi8qKlxuICogUHJvamVjdGlvbnMgZXF1YWwgdG8gRVBTRzozODU3LlxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge0FycmF5PGltcG9ydChcIi4vUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0Pn1cbiAqL1xuZXhwb3J0IHZhciBQUk9KRUNUSU9OUyA9IFtcbiAgbmV3IEVQU0czODU3UHJvamVjdGlvbignRVBTRzozODU3JyksXG4gIG5ldyBFUFNHMzg1N1Byb2plY3Rpb24oJ0VQU0c6MTAyMTAwJyksXG4gIG5ldyBFUFNHMzg1N1Byb2plY3Rpb24oJ0VQU0c6MTAyMTEzJyksXG4gIG5ldyBFUFNHMzg1N1Byb2plY3Rpb24oJ0VQU0c6OTAwOTEzJyksXG4gIG5ldyBFUFNHMzg1N1Byb2plY3Rpb24oJ3VybjpvZ2M6ZGVmOmNyczpFUFNHOjYuMTg6MzozODU3JyksXG4gIG5ldyBFUFNHMzg1N1Byb2plY3Rpb24oJ3VybjpvZ2M6ZGVmOmNyczpFUFNHOjozODU3JyksXG4gIG5ldyBFUFNHMzg1N1Byb2plY3Rpb24oJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sL3Nycy9lcHNnLnhtbCMzODU3Jylcbl07XG5cblxuLyoqXG4gKiBUcmFuc2Zvcm1hdGlvbiBmcm9tIEVQU0c6NDMyNiB0byBFUFNHOjM4NTcuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBpbnB1dCBJbnB1dCBhcnJheSBvZiBjb29yZGluYXRlIHZhbHVlcy5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPj19IG9wdF9vdXRwdXQgT3V0cHV0IGFycmF5IG9mIGNvb3JkaW5hdGUgdmFsdWVzLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZGltZW5zaW9uIERpbWVuc2lvbiAoZGVmYXVsdCBpcyBgMmApLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gT3V0cHV0IGFycmF5IG9mIGNvb3JkaW5hdGUgdmFsdWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUVQU0c0MzI2KGlucHV0LCBvcHRfb3V0cHV0LCBvcHRfZGltZW5zaW9uKSB7XG4gIHZhciBsZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gIHZhciBkaW1lbnNpb24gPSBvcHRfZGltZW5zaW9uID4gMSA/IG9wdF9kaW1lbnNpb24gOiAyO1xuICB2YXIgb3V0cHV0ID0gb3B0X291dHB1dDtcbiAgaWYgKG91dHB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGRpbWVuc2lvbiA+IDIpIHtcbiAgICAgIC8vIHByZXNlcnZlIHZhbHVlcyBiZXlvbmQgc2Vjb25kIGRpbWVuc2lvblxuICAgICAgb3V0cHV0ID0gaW5wdXQuc2xpY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0ID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgfVxuICB9XG4gIHZhciBoYWxmU2l6ZSA9IEhBTEZfU0laRTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gZGltZW5zaW9uKSB7XG4gICAgb3V0cHV0W2ldID0gaGFsZlNpemUgKiBpbnB1dFtpXSAvIDE4MDtcbiAgICB2YXIgeSA9IFJBRElVUyAqXG4gICAgICAgIE1hdGgubG9nKE1hdGgudGFuKE1hdGguUEkgKiAoaW5wdXRbaSArIDFdICsgOTApIC8gMzYwKSk7XG4gICAgaWYgKHkgPiBoYWxmU2l6ZSkge1xuICAgICAgeSA9IGhhbGZTaXplO1xuICAgIH0gZWxzZSBpZiAoeSA8IC1oYWxmU2l6ZSkge1xuICAgICAgeSA9IC1oYWxmU2l6ZTtcbiAgICB9XG4gICAgb3V0cHV0W2kgKyAxXSA9IHk7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG4vKipcbiAqIFRyYW5zZm9ybWF0aW9uIGZyb20gRVBTRzozODU3IHRvIEVQU0c6NDMyNi5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGlucHV0IElucHV0IGFycmF5IG9mIGNvb3JkaW5hdGUgdmFsdWVzLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+PX0gb3B0X291dHB1dCBPdXRwdXQgYXJyYXkgb2YgY29vcmRpbmF0ZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9kaW1lbnNpb24gRGltZW5zaW9uIChkZWZhdWx0IGlzIGAyYCkuXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBPdXRwdXQgYXJyYXkgb2YgY29vcmRpbmF0ZSB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0VQU0c0MzI2KGlucHV0LCBvcHRfb3V0cHV0LCBvcHRfZGltZW5zaW9uKSB7XG4gIHZhciBsZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gIHZhciBkaW1lbnNpb24gPSBvcHRfZGltZW5zaW9uID4gMSA/IG9wdF9kaW1lbnNpb24gOiAyO1xuICB2YXIgb3V0cHV0ID0gb3B0X291dHB1dDtcbiAgaWYgKG91dHB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGRpbWVuc2lvbiA+IDIpIHtcbiAgICAgIC8vIHByZXNlcnZlIHZhbHVlcyBiZXlvbmQgc2Vjb25kIGRpbWVuc2lvblxuICAgICAgb3V0cHV0ID0gaW5wdXQuc2xpY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0ID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgfVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IGRpbWVuc2lvbikge1xuICAgIG91dHB1dFtpXSA9IDE4MCAqIGlucHV0W2ldIC8gSEFMRl9TSVpFO1xuICAgIG91dHB1dFtpICsgMV0gPSAzNjAgKiBNYXRoLmF0YW4oXG4gICAgICBNYXRoLmV4cChpbnB1dFtpICsgMV0gLyBSQURJVVMpKSAvIE1hdGguUEkgLSA5MDtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcHNnMzg1Ny5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcHJvai9lcHNnNDMyNlxuICovXG5pbXBvcnQgUHJvamVjdGlvbiBmcm9tICcuL1Byb2plY3Rpb24uanMnO1xuaW1wb3J0IFVuaXRzIGZyb20gJy4vVW5pdHMuanMnO1xuXG5cbi8qKlxuICogU2VtaS1tYWpvciByYWRpdXMgb2YgdGhlIFdHUzg0IGVsbGlwc29pZC5cbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgUkFESVVTID0gNjM3ODEzNztcblxuXG4vKipcbiAqIEV4dGVudCBvZiB0aGUgRVBTRzo0MzI2IHByb2plY3Rpb24gd2hpY2ggaXMgdGhlIHdob2xlIHdvcmxkLlxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gKi9cbmV4cG9ydCB2YXIgRVhURU5UID0gWy0xODAsIC05MCwgMTgwLCA5MF07XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgTUVURVJTX1BFUl9VTklUID0gTWF0aC5QSSAqIFJBRElVUyAvIDE4MDtcblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFByb2plY3Rpb24gb2JqZWN0IGZvciBXR1M4NCBnZW9ncmFwaGljIGNvb3JkaW5hdGVzIChFUFNHOjQzMjYpLlxuICpcbiAqIE5vdGUgdGhhdCBPcGVuTGF5ZXJzIGRvZXMgbm90IHN0cmljdGx5IGNvbXBseSB3aXRoIHRoZSBFUFNHIGRlZmluaXRpb24uXG4gKiBUaGUgRVBTRyByZWdpc3RyeSBkZWZpbmVzIDQzMjYgYXMgYSBDUlMgZm9yIExhdGl0dWRlLExvbmdpdHVkZSAoeSx4KS5cbiAqIE9wZW5MYXllcnMgdHJlYXRzIEVQU0c6NDMyNiBhcyBhIHBzZXVkby1wcm9qZWN0aW9uLCB3aXRoIHgseSBjb29yZGluYXRlcy5cbiAqL1xudmFyIEVQU0c0MzI2UHJvamVjdGlvbiA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFByb2plY3Rpb24pIHtcbiAgZnVuY3Rpb24gRVBTRzQzMjZQcm9qZWN0aW9uKGNvZGUsIG9wdF9heGlzT3JpZW50YXRpb24pIHtcbiAgICBQcm9qZWN0aW9uLmNhbGwodGhpcywge1xuICAgICAgY29kZTogY29kZSxcbiAgICAgIHVuaXRzOiBVbml0cy5ERUdSRUVTLFxuICAgICAgZXh0ZW50OiBFWFRFTlQsXG4gICAgICBheGlzT3JpZW50YXRpb246IG9wdF9heGlzT3JpZW50YXRpb24sXG4gICAgICBnbG9iYWw6IHRydWUsXG4gICAgICBtZXRlcnNQZXJVbml0OiBNRVRFUlNfUEVSX1VOSVQsXG4gICAgICB3b3JsZEV4dGVudDogRVhURU5UXG4gICAgfSk7XG5cbiAgfVxuXG4gIGlmICggUHJvamVjdGlvbiApIEVQU0c0MzI2UHJvamVjdGlvbi5fX3Byb3RvX18gPSBQcm9qZWN0aW9uO1xuICBFUFNHNDMyNlByb2plY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUHJvamVjdGlvbiAmJiBQcm9qZWN0aW9uLnByb3RvdHlwZSApO1xuICBFUFNHNDMyNlByb2plY3Rpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRVBTRzQzMjZQcm9qZWN0aW9uO1xuXG4gIHJldHVybiBFUFNHNDMyNlByb2plY3Rpb247XG59KFByb2plY3Rpb24pKTtcblxuXG4vKipcbiAqIFByb2plY3Rpb25zIGVxdWFsIHRvIEVQU0c6NDMyNi5cbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdD59XG4gKi9cbmV4cG9ydCB2YXIgUFJPSkVDVElPTlMgPSBbXG4gIG5ldyBFUFNHNDMyNlByb2plY3Rpb24oJ0NSUzo4NCcpLFxuICBuZXcgRVBTRzQzMjZQcm9qZWN0aW9uKCdFUFNHOjQzMjYnLCAnbmV1JyksXG4gIG5ldyBFUFNHNDMyNlByb2plY3Rpb24oJ3VybjpvZ2M6ZGVmOmNyczpFUFNHOjo0MzI2JywgJ25ldScpLFxuICBuZXcgRVBTRzQzMjZQcm9qZWN0aW9uKCd1cm46b2djOmRlZjpjcnM6RVBTRzo2LjY6NDMyNicsICduZXUnKSxcbiAgbmV3IEVQU0c0MzI2UHJvamVjdGlvbigndXJuOm9nYzpkZWY6Y3JzOk9HQzoxLjM6Q1JTODQnKSxcbiAgbmV3IEVQU0c0MzI2UHJvamVjdGlvbigndXJuOm9nYzpkZWY6Y3JzOk9HQzoyOjg0JyksXG4gIG5ldyBFUFNHNDMyNlByb2plY3Rpb24oJ2h0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sL3Nycy9lcHNnLnhtbCM0MzI2JywgJ25ldScpLFxuICBuZXcgRVBTRzQzMjZQcm9qZWN0aW9uKCd1cm46eC1vZ2M6ZGVmOmNyczpFUFNHOjQzMjYnLCAnbmV1Jylcbl07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVwc2c0MzI2LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9wcm9qL3Byb2plY3Rpb25zXG4gKi9cblxuXG4vKipcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdD59XG4gKi9cbnZhciBjYWNoZSA9IHt9O1xuXG5cbi8qKlxuICogQ2xlYXIgdGhlIHByb2plY3Rpb25zIGNhY2hlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXIoKSB7XG4gIGNhY2hlID0ge307XG59XG5cblxuLyoqXG4gKiBHZXQgYSBjYWNoZWQgcHJvamVjdGlvbiBieSBjb2RlLlxuICogQHBhcmFtIHtzdHJpbmd9IGNvZGUgVGhlIGNvZGUgZm9yIHRoZSBwcm9qZWN0aW9uLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IFRoZSBwcm9qZWN0aW9uIChpZiBjYWNoZWQpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0KGNvZGUpIHtcbiAgcmV0dXJuIGNhY2hlW2NvZGVdIHx8IG51bGw7XG59XG5cblxuLyoqXG4gKiBBZGQgYSBwcm9qZWN0aW9uIHRvIHRoZSBjYWNoZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlIFRoZSBwcm9qZWN0aW9uIGNvZGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFRoZSBwcm9qZWN0aW9uIHRvIGNhY2hlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkKGNvZGUsIHByb2plY3Rpb24pIHtcbiAgY2FjaGVbY29kZV0gPSBwcm9qZWN0aW9uO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9qZWN0aW9ucy5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcHJvai90cmFuc2Zvcm1zXG4gKi9cbmltcG9ydCB7aXNFbXB0eX0gZnJvbSAnLi4vb2JqLmpzJztcblxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL3Byb2ouanNcIikuVHJhbnNmb3JtRnVuY3Rpb24+Pn1cbiAqL1xudmFyIHRyYW5zZm9ybXMgPSB7fTtcblxuXG4vKipcbiAqIENsZWFyIHRoZSB0cmFuc2Zvcm0gY2FjaGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhcigpIHtcbiAgdHJhbnNmb3JtcyA9IHt9O1xufVxuXG5cbi8qKlxuICogUmVnaXN0ZXJzIGEgY29udmVyc2lvbiBmdW5jdGlvbiB0byBjb252ZXJ0IGNvb3JkaW5hdGVzIGZyb20gdGhlIHNvdXJjZVxuICogcHJvamVjdGlvbiB0byB0aGUgZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBzb3VyY2UgU291cmNlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gZGVzdGluYXRpb24gRGVzdGluYXRpb24uXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ouanNcIikuVHJhbnNmb3JtRnVuY3Rpb259IHRyYW5zZm9ybUZuIFRyYW5zZm9ybS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZChzb3VyY2UsIGRlc3RpbmF0aW9uLCB0cmFuc2Zvcm1Gbikge1xuICB2YXIgc291cmNlQ29kZSA9IHNvdXJjZS5nZXRDb2RlKCk7XG4gIHZhciBkZXN0aW5hdGlvbkNvZGUgPSBkZXN0aW5hdGlvbi5nZXRDb2RlKCk7XG4gIGlmICghKHNvdXJjZUNvZGUgaW4gdHJhbnNmb3JtcykpIHtcbiAgICB0cmFuc2Zvcm1zW3NvdXJjZUNvZGVdID0ge307XG4gIH1cbiAgdHJhbnNmb3Jtc1tzb3VyY2VDb2RlXVtkZXN0aW5hdGlvbkNvZGVdID0gdHJhbnNmb3JtRm47XG59XG5cblxuLyoqXG4gKiBVbnJlZ2lzdGVycyB0aGUgY29udmVyc2lvbiBmdW5jdGlvbiB0byBjb252ZXJ0IGNvb3JkaW5hdGVzIGZyb20gdGhlIHNvdXJjZVxuICogcHJvamVjdGlvbiB0byB0aGUgZGVzdGluYXRpb24gcHJvamVjdGlvbi4gIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gY2xlYW4gdXBcbiAqIGNhY2hlZCB0cmFuc2Zvcm1zIGR1cmluZyB0ZXN0aW5nLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHNvdXJjZSBTb3VyY2UgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IGRlc3RpbmF0aW9uIERlc3RpbmF0aW9uIHByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9wcm9qLmpzXCIpLlRyYW5zZm9ybUZ1bmN0aW9ufSB0cmFuc2Zvcm1GbiBUaGUgdW5yZWdpc3RlcmVkIHRyYW5zZm9ybS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZShzb3VyY2UsIGRlc3RpbmF0aW9uKSB7XG4gIHZhciBzb3VyY2VDb2RlID0gc291cmNlLmdldENvZGUoKTtcbiAgdmFyIGRlc3RpbmF0aW9uQ29kZSA9IGRlc3RpbmF0aW9uLmdldENvZGUoKTtcbiAgdmFyIHRyYW5zZm9ybSA9IHRyYW5zZm9ybXNbc291cmNlQ29kZV1bZGVzdGluYXRpb25Db2RlXTtcbiAgZGVsZXRlIHRyYW5zZm9ybXNbc291cmNlQ29kZV1bZGVzdGluYXRpb25Db2RlXTtcbiAgaWYgKGlzRW1wdHkodHJhbnNmb3Jtc1tzb3VyY2VDb2RlXSkpIHtcbiAgICBkZWxldGUgdHJhbnNmb3Jtc1tzb3VyY2VDb2RlXTtcbiAgfVxuICByZXR1cm4gdHJhbnNmb3JtO1xufVxuXG5cbi8qKlxuICogR2V0IGEgdHJhbnNmb3JtIGdpdmVuIGEgc291cmNlIGNvZGUgYW5kIGEgZGVzdGluYXRpb24gY29kZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2VDb2RlIFRoZSBjb2RlIGZvciB0aGUgc291cmNlIHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVzdGluYXRpb25Db2RlIFRoZSBjb2RlIGZvciB0aGUgZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3Byb2ouanNcIikuVHJhbnNmb3JtRnVuY3Rpb258dW5kZWZpbmVkfSBUaGUgdHJhbnNmb3JtIGZ1bmN0aW9uIChpZiBmb3VuZCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXQoc291cmNlQ29kZSwgZGVzdGluYXRpb25Db2RlKSB7XG4gIHZhciB0cmFuc2Zvcm07XG4gIGlmIChzb3VyY2VDb2RlIGluIHRyYW5zZm9ybXMgJiYgZGVzdGluYXRpb25Db2RlIGluIHRyYW5zZm9ybXNbc291cmNlQ29kZV0pIHtcbiAgICB0cmFuc2Zvcm0gPSB0cmFuc2Zvcm1zW3NvdXJjZUNvZGVdW2Rlc3RpbmF0aW9uQ29kZV07XG4gIH1cbiAgcmV0dXJuIHRyYW5zZm9ybTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNmb3Jtcy5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyL0JveFxuICovXG5cbmltcG9ydCBEaXNwb3NhYmxlIGZyb20gJy4uL0Rpc3Bvc2FibGUuanMnO1xuaW1wb3J0IFBvbHlnb24gZnJvbSAnLi4vZ2VvbS9Qb2x5Z29uLmpzJztcblxudmFyIFJlbmRlckJveCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKERpc3Bvc2FibGUpIHtcbiAgZnVuY3Rpb24gUmVuZGVyQm94KGNsYXNzTmFtZSkge1xuICAgIERpc3Bvc2FibGUuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9nZW9tL1BvbHlnb24uanNcIikuZGVmYXVsdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZ2VvbWV0cnlfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtIVE1MRGl2RWxlbWVudH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZWxlbWVudF8gPSAvKiogQHR5cGUge0hUTUxEaXZFbGVtZW50fSAqLyAoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpO1xuICAgIHRoaXMuZWxlbWVudF8uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIHRoaXMuZWxlbWVudF8uY2xhc3NOYW1lID0gJ29sLWJveCAnICsgY2xhc3NOYW1lO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5tYXBfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsfVxuICAgICAqL1xuICAgIHRoaXMuc3RhcnRQaXhlbF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vcGl4ZWwuanNcIikuUGl4ZWx9XG4gICAgICovXG4gICAgdGhpcy5lbmRQaXhlbF8gPSBudWxsO1xuXG4gIH1cblxuICBpZiAoIERpc3Bvc2FibGUgKSBSZW5kZXJCb3guX19wcm90b19fID0gRGlzcG9zYWJsZTtcbiAgUmVuZGVyQm94LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIERpc3Bvc2FibGUgJiYgRGlzcG9zYWJsZS5wcm90b3R5cGUgKTtcbiAgUmVuZGVyQm94LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlbmRlckJveDtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIFJlbmRlckJveC5wcm90b3R5cGUuZGlzcG9zZUludGVybmFsID0gZnVuY3Rpb24gZGlzcG9zZUludGVybmFsICgpIHtcbiAgICB0aGlzLnNldE1hcChudWxsKTtcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFJlbmRlckJveC5wcm90b3R5cGUucmVuZGVyXyA9IGZ1bmN0aW9uIHJlbmRlcl8gKCkge1xuICAgIHZhciBzdGFydFBpeGVsID0gdGhpcy5zdGFydFBpeGVsXztcbiAgICB2YXIgZW5kUGl4ZWwgPSB0aGlzLmVuZFBpeGVsXztcbiAgICB2YXIgcHggPSAncHgnO1xuICAgIHZhciBzdHlsZSA9IHRoaXMuZWxlbWVudF8uc3R5bGU7XG4gICAgc3R5bGUubGVmdCA9IE1hdGgubWluKHN0YXJ0UGl4ZWxbMF0sIGVuZFBpeGVsWzBdKSArIHB4O1xuICAgIHN0eWxlLnRvcCA9IE1hdGgubWluKHN0YXJ0UGl4ZWxbMV0sIGVuZFBpeGVsWzFdKSArIHB4O1xuICAgIHN0eWxlLndpZHRoID0gTWF0aC5hYnMoZW5kUGl4ZWxbMF0gLSBzdGFydFBpeGVsWzBdKSArIHB4O1xuICAgIHN0eWxlLmhlaWdodCA9IE1hdGguYWJzKGVuZFBpeGVsWzFdIC0gc3RhcnRQaXhlbFsxXSkgKyBweDtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuZGVmYXVsdH0gbWFwIE1hcC5cbiAgICovXG4gIFJlbmRlckJveC5wcm90b3R5cGUuc2V0TWFwID0gZnVuY3Rpb24gc2V0TWFwIChtYXApIHtcbiAgICBpZiAodGhpcy5tYXBfKSB7XG4gICAgICB0aGlzLm1hcF8uZ2V0T3ZlcmxheUNvbnRhaW5lcigpLnJlbW92ZUNoaWxkKHRoaXMuZWxlbWVudF8pO1xuICAgICAgdmFyIHN0eWxlID0gdGhpcy5lbGVtZW50Xy5zdHlsZTtcbiAgICAgIHN0eWxlLmxlZnQgPSBzdHlsZS50b3AgPSBzdHlsZS53aWR0aCA9IHN0eWxlLmhlaWdodCA9ICdpbmhlcml0JztcbiAgICB9XG4gICAgdGhpcy5tYXBfID0gbWFwO1xuICAgIGlmICh0aGlzLm1hcF8pIHtcbiAgICAgIHRoaXMubWFwXy5nZXRPdmVybGF5Q29udGFpbmVyKCkuYXBwZW5kQ2hpbGQodGhpcy5lbGVtZW50Xyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsfSBzdGFydFBpeGVsIFN0YXJ0IHBpeGVsLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsfSBlbmRQaXhlbCBFbmQgcGl4ZWwuXG4gICAqL1xuICBSZW5kZXJCb3gucHJvdG90eXBlLnNldFBpeGVscyA9IGZ1bmN0aW9uIHNldFBpeGVscyAoc3RhcnRQaXhlbCwgZW5kUGl4ZWwpIHtcbiAgICB0aGlzLnN0YXJ0UGl4ZWxfID0gc3RhcnRQaXhlbDtcbiAgICB0aGlzLmVuZFBpeGVsXyA9IGVuZFBpeGVsO1xuICAgIHRoaXMuY3JlYXRlT3JVcGRhdGVHZW9tZXRyeSgpO1xuICAgIHRoaXMucmVuZGVyXygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG9yIHVwZGF0ZXMgdGhlIGNhY2hlZCBnZW9tZXRyeS5cbiAgICovXG4gIFJlbmRlckJveC5wcm90b3R5cGUuY3JlYXRlT3JVcGRhdGVHZW9tZXRyeSA9IGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlR2VvbWV0cnkgKCkge1xuICAgIHZhciBzdGFydFBpeGVsID0gdGhpcy5zdGFydFBpeGVsXztcbiAgICB2YXIgZW5kUGl4ZWwgPSB0aGlzLmVuZFBpeGVsXztcbiAgICB2YXIgcGl4ZWxzID0gW1xuICAgICAgc3RhcnRQaXhlbCxcbiAgICAgIFtzdGFydFBpeGVsWzBdLCBlbmRQaXhlbFsxXV0sXG4gICAgICBlbmRQaXhlbCxcbiAgICAgIFtlbmRQaXhlbFswXSwgc3RhcnRQaXhlbFsxXV1cbiAgICBdO1xuICAgIHZhciBjb29yZGluYXRlcyA9IHBpeGVscy5tYXAodGhpcy5tYXBfLmdldENvb3JkaW5hdGVGcm9tUGl4ZWwsIHRoaXMubWFwXyk7XG4gICAgLy8gY2xvc2UgdGhlIHBvbHlnb25cbiAgICBjb29yZGluYXRlc1s0XSA9IGNvb3JkaW5hdGVzWzBdLnNsaWNlKCk7XG4gICAgaWYgKCF0aGlzLmdlb21ldHJ5Xykge1xuICAgICAgdGhpcy5nZW9tZXRyeV8gPSBuZXcgUG9seWdvbihbY29vcmRpbmF0ZXNdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5nZW9tZXRyeV8uc2V0Q29vcmRpbmF0ZXMoW2Nvb3JkaW5hdGVzXSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9nZW9tL1BvbHlnb24uanNcIikuZGVmYXVsdH0gR2VvbWV0cnkuXG4gICAqL1xuICBSZW5kZXJCb3gucHJvdG90eXBlLmdldEdlb21ldHJ5ID0gZnVuY3Rpb24gZ2V0R2VvbWV0cnkgKCkge1xuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5XztcbiAgfTtcblxuICByZXR1cm4gUmVuZGVyQm94O1xufShEaXNwb3NhYmxlKSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgUmVuZGVyQm94O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Cb3guanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9FdmVudFxuICovXG5cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMvRXZlbnQuanMnO1xuXG52YXIgUmVuZGVyRXZlbnQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChFdmVudCkge1xuICBmdW5jdGlvbiBSZW5kZXJFdmVudCh0eXBlLCBvcHRfdmVjdG9yQ29udGV4dCwgb3B0X2ZyYW1lU3RhdGUsIG9wdF9jb250ZXh0LCBvcHRfZ2xDb250ZXh0KSB7XG5cbiAgICBFdmVudC5jYWxsKHRoaXMsIHR5cGUpO1xuXG4gICAgLyoqXG4gICAgICogRm9yIGNhbnZhcywgdGhpcyBpcyBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgbW9kdWxlOm9sL3JlbmRlci9jYW52YXMvSW1tZWRpYXRlfS5cbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9WZWN0b3JDb250ZXh0LmpzXCIpLmRlZmF1bHR8dW5kZWZpbmVkfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLnZlY3RvckNvbnRleHQgPSBvcHRfdmVjdG9yQ29udGV4dDtcblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgcmVuZGVyIGZyYW1lIHN0YXRlLlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuRnJhbWVTdGF0ZXx1bmRlZmluZWR9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMuZnJhbWVTdGF0ZSA9IG9wdF9mcmFtZVN0YXRlO1xuXG4gICAgLyoqXG4gICAgICogQ2FudmFzIGNvbnRleHQuIE9ubHkgYXZhaWxhYmxlIHdoZW4gYSBDYW52YXMgcmVuZGVyZXIgaXMgdXNlZCwgbnVsbFxuICAgICAqIG90aGVyd2lzZS5cbiAgICAgKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfG51bGx8dW5kZWZpbmVkfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLmNvbnRleHQgPSBvcHRfY29udGV4dDtcblxuICAgIC8qKlxuICAgICAqIFdlYkdMIGNvbnRleHQuIE9ubHkgYXZhaWxhYmxlIHdoZW4gYSBXZWJHTCByZW5kZXJlciBpcyB1c2VkLCBudWxsXG4gICAgICogb3RoZXJ3aXNlLlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi93ZWJnbC9Db250ZXh0LmpzXCIpLmRlZmF1bHR8bnVsbHx1bmRlZmluZWR9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMuZ2xDb250ZXh0ID0gb3B0X2dsQ29udGV4dDtcblxuICB9XG5cbiAgaWYgKCBFdmVudCApIFJlbmRlckV2ZW50Ll9fcHJvdG9fXyA9IEV2ZW50O1xuICBSZW5kZXJFdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFdmVudCAmJiBFdmVudC5wcm90b3R5cGUgKTtcbiAgUmVuZGVyRXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVuZGVyRXZlbnQ7XG5cbiAgcmV0dXJuIFJlbmRlckV2ZW50O1xufShFdmVudCkpO1xuXG5leHBvcnQgZGVmYXVsdCBSZW5kZXJFdmVudDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXZlbnQuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9FdmVudFR5cGVcbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgLyoqXG4gICAqIEBldmVudCBtb2R1bGU6b2wvcmVuZGVyL0V2ZW50flJlbmRlckV2ZW50I3Bvc3Rjb21wb3NlXG4gICAqIEBhcGlcbiAgICovXG4gIFBPU1RDT01QT1NFOiAncG9zdGNvbXBvc2UnLFxuICAvKipcbiAgICogQGV2ZW50IG1vZHVsZTpvbC9yZW5kZXIvRXZlbnR+UmVuZGVyRXZlbnQjcHJlY29tcG9zZVxuICAgKiBAYXBpXG4gICAqL1xuICBQUkVDT01QT1NFOiAncHJlY29tcG9zZScsXG4gIC8qKlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL3JlbmRlci9FdmVudH5SZW5kZXJFdmVudCNyZW5kZXJcbiAgICogQGFwaVxuICAgKi9cbiAgUkVOREVSOiAncmVuZGVyJyxcbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB3aGVuIHJlbmRlcmluZyBpcyBjb21wbGV0ZSwgaS5lLiBhbGwgc291cmNlcyBhbmQgdGlsZXMgaGF2ZVxuICAgKiBmaW5pc2hlZCBsb2FkaW5nIGZvciB0aGUgY3VycmVudCB2aWV3cG9ydCwgYW5kIGFsbCB0aWxlcyBhcmUgZmFkZWQgaW4uXG4gICAqIEBldmVudCBtb2R1bGU6b2wvcmVuZGVyL0V2ZW50flJlbmRlckV2ZW50I3JlbmRlcmNvbXBsZXRlXG4gICAqIEBhcGlcbiAgICovXG4gIFJFTkRFUkNPTVBMRVRFOiAncmVuZGVyY29tcGxldGUnXG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1FdmVudFR5cGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9SZXBsYXlHcm91cFxuICovXG5pbXBvcnQge2Fic3RyYWN0fSBmcm9tICcuLi91dGlsLmpzJztcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciByZXBsYXkgZ3JvdXBzLlxuICovXG52YXIgUmVwbGF5R3JvdXAgPSBmdW5jdGlvbiBSZXBsYXlHcm91cCAoKSB7fTtcblxuUmVwbGF5R3JvdXAucHJvdG90eXBlLmdldFJlcGxheSA9IGZ1bmN0aW9uIGdldFJlcGxheSAoekluZGV4LCByZXBsYXlUeXBlKSB7XG4gIHJldHVybiBhYnN0cmFjdCgpO1xufTtcblxuLyoqXG4gKiBAYWJzdHJhY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IElzIGVtcHR5LlxuICovXG5SZXBsYXlHcm91cC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkgKCkge1xuICByZXR1cm4gYWJzdHJhY3QoKTtcbn07XG5cbi8qKlxuICogQGFic3RyYWN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGdyb3VwIEdyb3VwIHdpdGggcHJldmlvdXMgcmVwbGF5XG4gKiBAcmV0dXJuIHtBcnJheTwqPn0gVGhlIHJlc3VsdGluZyBpbnN0cnVjdGlvbiBncm91cFxuICovXG5SZXBsYXlHcm91cC5wcm90b3R5cGUuYWRkRGVjbHV0dGVyID0gZnVuY3Rpb24gYWRkRGVjbHV0dGVyIChncm91cCkge1xuICByZXR1cm4gYWJzdHJhY3QoKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFJlcGxheUdyb3VwO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZXBsYXlHcm91cC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyL1JlcGxheVR5cGVcbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgQ0lSQ0xFOiAnQ2lyY2xlJyxcbiAgREVGQVVMVDogJ0RlZmF1bHQnLFxuICBJTUFHRTogJ0ltYWdlJyxcbiAgTElORV9TVFJJTkc6ICdMaW5lU3RyaW5nJyxcbiAgUE9MWUdPTjogJ1BvbHlnb24nLFxuICBURVhUOiAnVGV4dCdcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlcGxheVR5cGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9WZWN0b3JDb250ZXh0XG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBDb250ZXh0IGZvciBkcmF3aW5nIGdlb21ldHJpZXMuICBBIHZlY3RvciBjb250ZXh0IGlzIGF2YWlsYWJsZSBvbiByZW5kZXJcbiAqIGV2ZW50cyBhbmQgZG9lcyBub3QgbmVlZCB0byBiZSBjb25zdHJ1Y3RlZCBkaXJlY3RseS5cbiAqIEBhcGlcbiAqL1xudmFyIFZlY3RvckNvbnRleHQgPSBmdW5jdGlvbiBWZWN0b3JDb250ZXh0ICgpIHt9O1xuXG5WZWN0b3JDb250ZXh0LnByb3RvdHlwZS5kcmF3Q3VzdG9tID0gZnVuY3Rpb24gZHJhd0N1c3RvbSAoZ2VvbWV0cnksIGZlYXR1cmUsIHJlbmRlcmVyKSB7fTtcblxuLyoqXG4gKiBSZW5kZXIgYSBnZW9tZXRyeS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgVGhlIGdlb21ldHJ5IHRvIHJlbmRlci5cbiAqL1xuVmVjdG9yQ29udGV4dC5wcm90b3R5cGUuZHJhd0dlb21ldHJ5ID0gZnVuY3Rpb24gZHJhd0dlb21ldHJ5IChnZW9tZXRyeSkge307XG5cbi8qKlxuICogU2V0IHRoZSByZW5kZXJpbmcgc3R5bGUuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5kZWZhdWx0fSBzdHlsZSBUaGUgcmVuZGVyaW5nIHN0eWxlLlxuICovXG5WZWN0b3JDb250ZXh0LnByb3RvdHlwZS5zZXRTdHlsZSA9IGZ1bmN0aW9uIHNldFN0eWxlIChzdHlsZSkge307XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL0NpcmNsZS5qc1wiKS5kZWZhdWx0fSBjaXJjbGVHZW9tZXRyeSBDaXJjbGUgZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICovXG5WZWN0b3JDb250ZXh0LnByb3RvdHlwZS5kcmF3Q2lyY2xlID0gZnVuY3Rpb24gZHJhd0NpcmNsZSAoY2lyY2xlR2VvbWV0cnksIGZlYXR1cmUpIHt9O1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHR9IHN0eWxlIFN0eWxlLlxuICovXG5WZWN0b3JDb250ZXh0LnByb3RvdHlwZS5kcmF3RmVhdHVyZSA9IGZ1bmN0aW9uIGRyYXdGZWF0dXJlIChmZWF0dXJlLCBzdHlsZSkge307XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5Q29sbGVjdGlvbi5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeUNvbGxlY3Rpb25HZW9tZXRyeSBHZW9tZXRyeSBjb2xsZWN0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAqL1xuVmVjdG9yQ29udGV4dC5wcm90b3R5cGUuZHJhd0dlb21ldHJ5Q29sbGVjdGlvbiA9IGZ1bmN0aW9uIGRyYXdHZW9tZXRyeUNvbGxlY3Rpb24gKGdlb21ldHJ5Q29sbGVjdGlvbkdlb21ldHJ5LCBmZWF0dXJlKSB7fTtcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vTGluZVN0cmluZy5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBsaW5lU3RyaW5nR2VvbWV0cnkgTGluZSBzdHJpbmcgZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICovXG5WZWN0b3JDb250ZXh0LnByb3RvdHlwZS5kcmF3TGluZVN0cmluZyA9IGZ1bmN0aW9uIGRyYXdMaW5lU3RyaW5nIChsaW5lU3RyaW5nR2VvbWV0cnksIGZlYXR1cmUpIHt9O1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9NdWx0aUxpbmVTdHJpbmcuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gbXVsdGlMaW5lU3RyaW5nR2VvbWV0cnkgTXVsdGlMaW5lU3RyaW5nIGdlb21ldHJ5LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAqL1xuVmVjdG9yQ29udGV4dC5wcm90b3R5cGUuZHJhd011bHRpTGluZVN0cmluZyA9IGZ1bmN0aW9uIGRyYXdNdWx0aUxpbmVTdHJpbmcgKG11bHRpTGluZVN0cmluZ0dlb21ldHJ5LCBmZWF0dXJlKSB7fTtcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vTXVsdGlQb2ludC5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBtdWx0aVBvaW50R2VvbWV0cnkgTXVsdGlQb2ludCBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmUuXG4gKi9cblZlY3RvckNvbnRleHQucHJvdG90eXBlLmRyYXdNdWx0aVBvaW50ID0gZnVuY3Rpb24gZHJhd011bHRpUG9pbnQgKG11bHRpUG9pbnRHZW9tZXRyeSwgZmVhdHVyZSkge307XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL011bHRpUG9seWdvbi5qc1wiKS5kZWZhdWx0fSBtdWx0aVBvbHlnb25HZW9tZXRyeSBNdWx0aVBvbHlnb24gZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICovXG5WZWN0b3JDb250ZXh0LnByb3RvdHlwZS5kcmF3TXVsdGlQb2x5Z29uID0gZnVuY3Rpb24gZHJhd011bHRpUG9seWdvbiAobXVsdGlQb2x5Z29uR2VvbWV0cnksIGZlYXR1cmUpIHt9O1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9Qb2ludC5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBwb2ludEdlb21ldHJ5IFBvaW50IGdlb21ldHJ5LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAqL1xuVmVjdG9yQ29udGV4dC5wcm90b3R5cGUuZHJhd1BvaW50ID0gZnVuY3Rpb24gZHJhd1BvaW50IChwb2ludEdlb21ldHJ5LCBmZWF0dXJlKSB7fTtcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vUG9seWdvbi5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBwb2x5Z29uR2VvbWV0cnkgUG9seWdvbiBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmUuXG4gKi9cblZlY3RvckNvbnRleHQucHJvdG90eXBlLmRyYXdQb2x5Z29uID0gZnVuY3Rpb24gZHJhd1BvbHlnb24gKHBvbHlnb25HZW9tZXRyeSwgZmVhdHVyZSkge307XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAqL1xuVmVjdG9yQ29udGV4dC5wcm90b3R5cGUuZHJhd1RleHQgPSBmdW5jdGlvbiBkcmF3VGV4dCAoZ2VvbWV0cnksIGZlYXR1cmUpIHt9O1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc3R5bGUvRmlsbC5qc1wiKS5kZWZhdWx0fSBmaWxsU3R5bGUgRmlsbCBzdHlsZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc3R5bGUvU3Ryb2tlLmpzXCIpLmRlZmF1bHR9IHN0cm9rZVN0eWxlIFN0cm9rZSBzdHlsZS5cbiAqL1xuVmVjdG9yQ29udGV4dC5wcm90b3R5cGUuc2V0RmlsbFN0cm9rZVN0eWxlID0gZnVuY3Rpb24gc2V0RmlsbFN0cm9rZVN0eWxlIChmaWxsU3R5bGUsIHN0cm9rZVN0eWxlKSB7fTtcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3N0eWxlL0ltYWdlLmpzXCIpLmRlZmF1bHR9IGltYWdlU3R5bGUgSW1hZ2Ugc3R5bGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY2FudmFzLmpzXCIpLkRlY2x1dHRlckdyb3VwPX0gb3B0X2RlY2x1dHRlckdyb3VwIERlY2x1dHRlci5cbiAqL1xuVmVjdG9yQ29udGV4dC5wcm90b3R5cGUuc2V0SW1hZ2VTdHlsZSA9IGZ1bmN0aW9uIHNldEltYWdlU3R5bGUgKGltYWdlU3R5bGUsIG9wdF9kZWNsdXR0ZXJHcm91cCkge307XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zdHlsZS9UZXh0LmpzXCIpLmRlZmF1bHR9IHRleHRTdHlsZSBUZXh0IHN0eWxlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2NhbnZhcy5qc1wiKS5EZWNsdXR0ZXJHcm91cD19IG9wdF9kZWNsdXR0ZXJHcm91cCBEZWNsdXR0ZXIuXG4gKi9cblZlY3RvckNvbnRleHQucHJvdG90eXBlLnNldFRleHRTdHlsZSA9IGZ1bmN0aW9uIHNldFRleHRTdHlsZSAodGV4dFN0eWxlLCBvcHRfZGVjbHV0dGVyR3JvdXApIHt9O1xuXG5leHBvcnQgZGVmYXVsdCBWZWN0b3JDb250ZXh0O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1WZWN0b3JDb250ZXh0LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXIvY2FudmFzXG4gKi9cbmltcG9ydCB7Z2V0Rm9udEZhbWlsaWVzfSBmcm9tICcuLi9jc3MuanMnO1xuaW1wb3J0IHtjcmVhdGVDYW52YXNDb250ZXh0MkR9IGZyb20gJy4uL2RvbS5qcyc7XG5pbXBvcnQge2NsZWFyfSBmcm9tICcuLi9vYmouanMnO1xuaW1wb3J0IExSVUNhY2hlIGZyb20gJy4uL3N0cnVjdHMvTFJVQ2FjaGUuanMnO1xuaW1wb3J0IHtjcmVhdGUgYXMgY3JlYXRlVHJhbnNmb3JtfSBmcm9tICcuLi90cmFuc2Zvcm0uanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRmlsbFN0YXRlXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9IGZpbGxTdHlsZVxuICovXG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBGaWxsU3Ryb2tlU3RhdGVcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vY29sb3JsaWtlLmpzXCIpLkNvbG9yTGlrZX0gW2N1cnJlbnRGaWxsU3R5bGVdXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9IFtjdXJyZW50U3Ryb2tlU3R5bGVdXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2N1cnJlbnRMaW5lQ2FwXVxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBjdXJyZW50TGluZURhc2hcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY3VycmVudExpbmVEYXNoT2Zmc2V0XVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjdXJyZW50TGluZUpvaW5dXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2N1cnJlbnRMaW5lV2lkdGhdXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2N1cnJlbnRNaXRlckxpbWl0XVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtsYXN0U3Ryb2tlXVxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfSBbZmlsbFN0eWxlXVxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfSBbc3Ryb2tlU3R5bGVdXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2xpbmVDYXBdXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IGxpbmVEYXNoXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2xpbmVEYXNoT2Zmc2V0XVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtsaW5lSm9pbl1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbGluZVdpZHRoXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaXRlckxpbWl0XVxuICovXG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTdHJva2VTdGF0ZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGxpbmVDYXBcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gbGluZURhc2hcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsaW5lRGFzaE9mZnNldFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGxpbmVKb2luXG4gKiBAcHJvcGVydHkge251bWJlcn0gbGluZVdpZHRoXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWl0ZXJMaW1pdFxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfSBzdHJva2VTdHlsZVxuICovXG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBUZXh0U3RhdGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBmb250XG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3RleHRBbGlnbl1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0ZXh0QmFzZWxpbmVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcGxhY2VtZW50XVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhBbmdsZV1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW292ZXJmbG93XVxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9zdHlsZS9GaWxsLmpzXCIpLmRlZmF1bHR9IFtiYWNrZ3JvdW5kRmlsbF1cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vc3R5bGUvU3Ryb2tlLmpzXCIpLmRlZmF1bHR9IFtiYWNrZ3JvdW5kU3Ryb2tlXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtzY2FsZV1cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gW3BhZGRpbmddXG4gKi9cblxuXG4vKipcbiAqIENvbnRhaW5lciBmb3IgZGVjbHV0dGVyZWQgcmVwbGF5IGluc3RydWN0aW9ucyB0aGF0IG5lZWQgdG8gYmUgcmVuZGVyZWQgb3JcbiAqIG9taXR0ZWQgdG9nZXRoZXIsIGkuZS4gd2hlbiBzdHlsZXMgcmVuZGVyIGJvdGggYW4gaW1hZ2UgYW5kIHRleHQsIG9yIGZvciB0aGVcbiAqIGNoYXJhY3RlcnMgdGhhdCBmb3JtIHRleHQgYWxvbmcgbGluZXMuIFRoZSBiYXNpYyBlbGVtZW50cyBvZiB0aGlzIGFycmF5IGFyZVxuICogYFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZLCBjb3VudF1gLCB3aGVyZSB0aGUgZmlyc3QgZm91ciBlbnRyaWVzIGFyZSB0aGVcbiAqIHJlbmRlcmVkIGV4dGVudCBvZiB0aGUgZ3JvdXAgaW4gcGl4ZWwgc3BhY2UuIGBjb3VudGAgaXMgdGhlIG51bWJlciBvZiBzdHlsZXNcbiAqIGluIHRoZSBncm91cCwgaS5lLiAyIHdoZW4gYW4gaW1hZ2UgYW5kIGEgdGV4dCBhcmUgZ3JvdXBlZCwgb3IgMSBvdGhlcndpc2UuXG4gKiBJbiBhZGRpdGlvbiB0byB0aGVzZSBmb3VyIGVsZW1lbnRzLCBkZWNsdXR0ZXIgaW5zdHJ1Y3Rpb24gYXJyYXlzIChpLmUuIHRoZVxuICogYXJndW1lbnRzIHRvIHtAbGluayBtb2R1bGU6b2wvcmVuZGVyL2NhbnZhc35kcmF3SW1hZ2V9IGFyZSBhcHBlbmRlZCB0byB0aGUgYXJyYXkuXG4gKiBAdHlwZWRlZiB7QXJyYXk8Kj59IERlY2x1dHRlckdyb3VwXG4gKi9cblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IHZhciBkZWZhdWx0Rm9udCA9ICcxMHB4IHNhbnMtc2VyaWYnO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J9XG4gKi9cbmV4cG9ydCB2YXIgZGVmYXVsdEZpbGxTdHlsZSA9IFswLCAwLCAwLCAxXTtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IHZhciBkZWZhdWx0TGluZUNhcCA9ICdyb3VuZCc7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICovXG5leHBvcnQgdmFyIGRlZmF1bHRMaW5lRGFzaCA9IFtdO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIGRlZmF1bHRMaW5lRGFzaE9mZnNldCA9IDA7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCB2YXIgZGVmYXVsdExpbmVKb2luID0gJ3JvdW5kJztcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBkZWZhdWx0TWl0ZXJMaW1pdCA9IDEwO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J9XG4gKi9cbmV4cG9ydCB2YXIgZGVmYXVsdFN0cm9rZVN0eWxlID0gWzAsIDAsIDAsIDFdO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgdmFyIGRlZmF1bHRUZXh0QWxpZ24gPSAnY2VudGVyJztcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IHZhciBkZWZhdWx0VGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICovXG5leHBvcnQgdmFyIGRlZmF1bHRQYWRkaW5nID0gWzAsIDAsIDAsIDBdO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIGRlZmF1bHRMaW5lV2lkdGggPSAxO1xuXG5cbi8qKlxuICogVGhlIGxhYmVsIGNhY2hlIGZvciB0ZXh0IHJlbmRlcmluZy4gVG8gY2hhbmdlIHRoZSBkZWZhdWx0IGNhY2hlIHNpemUgb2YgMjA0OFxuICogZW50cmllcywgdXNlIHtAbGluayBtb2R1bGU6b2wvc3RydWN0cy9MUlVDYWNoZSNzZXRTaXplfS5cbiAqIEB0eXBlIHtMUlVDYWNoZTxIVE1MQ2FudmFzRWxlbWVudD59XG4gKiBAYXBpXG4gKi9cbmV4cG9ydCB2YXIgbGFiZWxDYWNoZSA9IG5ldyBMUlVDYWNoZSgpO1xuXG5cbi8qKlxuICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBudW1iZXI+fVxuICovXG5leHBvcnQgdmFyIGNoZWNrZWRGb250cyA9IHt9O1xuXG5cbi8qKlxuICogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAqL1xudmFyIG1lYXN1cmVDb250ZXh0ID0gbnVsbDtcblxuXG4vKipcbiAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgbnVtYmVyPn1cbiAqL1xuZXhwb3J0IHZhciB0ZXh0SGVpZ2h0cyA9IHt9O1xuXG5cbi8qKlxuICogQ2xlYXJzIHRoZSBsYWJlbCBjYWNoZSB3aGVuIGEgZm9udCBiZWNvbWVzIGF2YWlsYWJsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250U3BlYyBDU1MgZm9udCBzcGVjLlxuICovXG5leHBvcnQgdmFyIGNoZWNrRm9udCA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHJldHJpZXMgPSA2MDtcbiAgdmFyIGNoZWNrZWQgPSBjaGVja2VkRm9udHM7XG4gIHZhciBzaXplID0gJzMycHggJztcbiAgdmFyIHJlZmVyZW5jZUZvbnRzID0gWydtb25vc3BhY2UnLCAnc2VyaWYnXTtcbiAgdmFyIGxlbiA9IHJlZmVyZW5jZUZvbnRzLmxlbmd0aDtcbiAgdmFyIHRleHQgPSAnd215dHppbFdNWVRaSUxAIy8mPyQlMTBcXHVGMDEzJztcbiAgdmFyIGludGVydmFsLCByZWZlcmVuY2VXaWR0aDtcblxuICBmdW5jdGlvbiBpc0F2YWlsYWJsZShmb250KSB7XG4gICAgdmFyIGNvbnRleHQgPSBnZXRNZWFzdXJlQ29udGV4dCgpO1xuICAgIC8vIENoZWNrIHdlaWdodCByYW5nZXMgYWNjb3JkaW5nIHRvXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2ZvbnQtd2VpZ2h0I0ZhbGxiYWNrX3dlaWdodHNcbiAgICBmb3IgKHZhciB3ZWlnaHQgPSAxMDA7IHdlaWdodCA8PSA3MDA7IHdlaWdodCArPSAzMDApIHtcbiAgICAgIHZhciBmb250V2VpZ2h0ID0gd2VpZ2h0ICsgJyAnO1xuICAgICAgdmFyIGF2YWlsYWJsZSA9IHRydWU7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHZhciByZWZlcmVuY2VGb250ID0gcmVmZXJlbmNlRm9udHNbaV07XG4gICAgICAgIGNvbnRleHQuZm9udCA9IGZvbnRXZWlnaHQgKyBzaXplICsgcmVmZXJlbmNlRm9udDtcbiAgICAgICAgcmVmZXJlbmNlV2lkdGggPSBjb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoO1xuICAgICAgICBpZiAoZm9udCAhPSByZWZlcmVuY2VGb250KSB7XG4gICAgICAgICAgY29udGV4dC5mb250ID0gZm9udFdlaWdodCArIHNpemUgKyBmb250ICsgJywnICsgcmVmZXJlbmNlRm9udDtcbiAgICAgICAgICB2YXIgd2lkdGggPSBjb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoO1xuICAgICAgICAgIC8vIElmIHdpZHRoIGFuZCByZWZlcmVuY2VXaWR0aCBhcmUgdGhlIHNhbWUsIHRoZW4gdGhlIGZhbGxiYWNrIHdhcyB1c2VkXG4gICAgICAgICAgLy8gaW5zdGVhZCBvZiB0aGUgZm9udCB3ZSB3YW50ZWQsIHNvIHRoZSBmb250IGlzIG5vdCBhdmFpbGFibGUuXG4gICAgICAgICAgYXZhaWxhYmxlID0gYXZhaWxhYmxlICYmIHdpZHRoICE9IHJlZmVyZW5jZVdpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYXZhaWxhYmxlKSB7XG4gICAgICAgIC8vIENvbnNpZGVyIGZvbnQgYXZhaWxhYmxlIHdoZW4gaXQgaXMgYXZhaWxhYmxlIGluIG9uZSB3ZWlnaHQgcmFuZ2UuXG4gICAgICAgIC8vRklYTUUgV2l0aCB0aGlzIHdlIG1pc3MgcmFyZSBjb3JuZXIgY2FzZXMsIHNvIHdlIHNob3VsZCBjb25zaWRlclxuICAgICAgICAvL0ZJWE1FIGNoZWNraW5nIGF2YWlsYWJpbGl0eSBmb3IgZWFjaCByZXF1ZXN0ZWQgd2VpZ2h0IHJhbmdlLlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2soKSB7XG4gICAgdmFyIGRvbmUgPSB0cnVlO1xuICAgIGZvciAodmFyIGZvbnQgaW4gY2hlY2tlZCkge1xuICAgICAgaWYgKGNoZWNrZWRbZm9udF0gPCByZXRyaWVzKSB7XG4gICAgICAgIGlmIChpc0F2YWlsYWJsZShmb250KSkge1xuICAgICAgICAgIGNoZWNrZWRbZm9udF0gPSByZXRyaWVzO1xuICAgICAgICAgIGNsZWFyKHRleHRIZWlnaHRzKTtcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBsb2FkZWQgZm9udHMgYXJlIHBpY2tlZCB1cCBieSBTYWZhcmlcbiAgICAgICAgICBtZWFzdXJlQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgbGFiZWxDYWNoZS5jbGVhcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICsrY2hlY2tlZFtmb250XTtcbiAgICAgICAgICBkb25lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgaW50ZXJ2YWwgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGZvbnRTcGVjKSB7XG4gICAgdmFyIGZvbnRGYW1pbGllcyA9IGdldEZvbnRGYW1pbGllcyhmb250U3BlYyk7XG4gICAgaWYgKCFmb250RmFtaWxpZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZm9udEZhbWlsaWVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIHZhciBmb250RmFtaWx5ID0gZm9udEZhbWlsaWVzW2ldO1xuICAgICAgaWYgKCEoZm9udEZhbWlseSBpbiBjaGVja2VkKSkge1xuICAgICAgICBjaGVja2VkW2ZvbnRGYW1pbHldID0gcmV0cmllcztcbiAgICAgICAgaWYgKCFpc0F2YWlsYWJsZShmb250RmFtaWx5KSkge1xuICAgICAgICAgIGNoZWNrZWRbZm9udEZhbWlseV0gPSAwO1xuICAgICAgICAgIGlmIChpbnRlcnZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbnRlcnZhbCA9IHNldEludGVydmFsKGNoZWNrLCAzMik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufSkoKTtcblxuXG4vKipcbiAqIEByZXR1cm4ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gTWVhc3VyZSBjb250ZXh0LlxuICovXG5mdW5jdGlvbiBnZXRNZWFzdXJlQ29udGV4dCgpIHtcbiAgaWYgKCFtZWFzdXJlQ29udGV4dCkge1xuICAgIG1lYXN1cmVDb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKDEsIDEpO1xuICB9XG4gIHJldHVybiBtZWFzdXJlQ29udGV4dDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250IEZvbnQgdG8gdXNlIGZvciBtZWFzdXJpbmcuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IE1lYXN1cmVtZW50LlxuICovXG5leHBvcnQgdmFyIG1lYXN1cmVUZXh0SGVpZ2h0ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgc3BhbjtcbiAgdmFyIGhlaWdodHMgPSB0ZXh0SGVpZ2h0cztcbiAgcmV0dXJuIGZ1bmN0aW9uKGZvbnQpIHtcbiAgICB2YXIgaGVpZ2h0ID0gaGVpZ2h0c1tmb250XTtcbiAgICBpZiAoaGVpZ2h0ID09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCFzcGFuKSB7XG4gICAgICAgIHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIHNwYW4udGV4dENvbnRlbnQgPSAnTSc7XG4gICAgICAgIHNwYW4uc3R5bGUubWFyZ2luID0gc3Bhbi5zdHlsZS5wYWRkaW5nID0gJzAgIWltcG9ydGFudCc7XG4gICAgICAgIHNwYW4uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUgIWltcG9ydGFudCc7XG4gICAgICAgIHNwYW4uc3R5bGUubGVmdCA9ICctOTk5OTlweCAhaW1wb3J0YW50JztcbiAgICAgIH1cbiAgICAgIHNwYW4uc3R5bGUuZm9udCA9IGZvbnQ7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNwYW4pO1xuICAgICAgaGVpZ2h0ID0gaGVpZ2h0c1tmb250XSA9IHNwYW4ub2Zmc2V0SGVpZ2h0O1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChzcGFuKTtcbiAgICB9XG4gICAgcmV0dXJuIGhlaWdodDtcbiAgfTtcbn0pKCk7XG5cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9udCBGb250LlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGV4dC5cbiAqIEByZXR1cm4ge251bWJlcn0gV2lkdGguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZWFzdXJlVGV4dFdpZHRoKGZvbnQsIHRleHQpIHtcbiAgdmFyIG1lYXN1cmVDb250ZXh0ID0gZ2V0TWVhc3VyZUNvbnRleHQoKTtcbiAgaWYgKGZvbnQgIT0gbWVhc3VyZUNvbnRleHQuZm9udCkge1xuICAgIG1lYXN1cmVDb250ZXh0LmZvbnQgPSBmb250O1xuICB9XG4gIHJldHVybiBtZWFzdXJlQ29udGV4dC5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IENvbnRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gcm90YXRpb24gUm90YXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WCBYIG9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRZIFkgb2Zmc2V0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlQXRPZmZzZXQoY29udGV4dCwgcm90YXRpb24sIG9mZnNldFgsIG9mZnNldFkpIHtcbiAgaWYgKHJvdGF0aW9uICE9PSAwKSB7XG4gICAgY29udGV4dC50cmFuc2xhdGUob2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgY29udGV4dC5yb3RhdGUocm90YXRpb24pO1xuICAgIGNvbnRleHQudHJhbnNsYXRlKC1vZmZzZXRYLCAtb2Zmc2V0WSk7XG4gIH1cbn1cblxuXG5leHBvcnQgdmFyIHJlc2V0VHJhbnNmb3JtID0gY3JlYXRlVHJhbnNmb3JtKCk7XG5cblxuLyoqXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBDb250ZXh0LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfG51bGx9IHRyYW5zZm9ybSBUcmFuc2Zvcm0uXG4gKiBAcGFyYW0ge251bWJlcn0gb3BhY2l0eSBPcGFjaXR5LlxuICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR9IGltYWdlIEltYWdlLlxuICogQHBhcmFtIHtudW1iZXJ9IG9yaWdpblggT3JpZ2luIFguXG4gKiBAcGFyYW0ge251bWJlcn0gb3JpZ2luWSBPcmlnaW4gWS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB3IFdpZHRoLlxuICogQHBhcmFtIHtudW1iZXJ9IGggSGVpZ2h0LlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKiBAcGFyYW0ge251bWJlcn0gc2NhbGUgU2NhbGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkcmF3SW1hZ2UoY29udGV4dCxcbiAgdHJhbnNmb3JtLCBvcGFjaXR5LCBpbWFnZSwgb3JpZ2luWCwgb3JpZ2luWSwgdywgaCwgeCwgeSwgc2NhbGUpIHtcbiAgdmFyIGFscGhhO1xuICBpZiAob3BhY2l0eSAhPSAxKSB7XG4gICAgYWxwaGEgPSBjb250ZXh0Lmdsb2JhbEFscGhhO1xuICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBhbHBoYSAqIG9wYWNpdHk7XG4gIH1cbiAgaWYgKHRyYW5zZm9ybSkge1xuICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtLmFwcGx5KGNvbnRleHQsIHRyYW5zZm9ybSk7XG4gIH1cblxuICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgb3JpZ2luWCwgb3JpZ2luWSwgdywgaCwgeCwgeSwgdyAqIHNjYWxlLCBoICogc2NhbGUpO1xuXG4gIGlmIChhbHBoYSkge1xuICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBhbHBoYTtcbiAgfVxuICBpZiAodHJhbnNmb3JtKSB7XG4gICAgY29udGV4dC5zZXRUcmFuc2Zvcm0uYXBwbHkoY29udGV4dCwgcmVzZXRUcmFuc2Zvcm0pO1xuICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhbnZhcy5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyL2NhbnZhcy9JbWFnZVJlcGxheVxuICovXG5pbXBvcnQgQ2FudmFzSW5zdHJ1Y3Rpb24gZnJvbSAnLi9JbnN0cnVjdGlvbi5qcyc7XG5pbXBvcnQgQ2FudmFzUmVwbGF5IGZyb20gJy4vUmVwbGF5LmpzJztcblxudmFyIENhbnZhc0ltYWdlUmVwbGF5ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoQ2FudmFzUmVwbGF5KSB7XG4gIGZ1bmN0aW9uIENhbnZhc0ltYWdlUmVwbGF5KHRvbGVyYW5jZSwgbWF4RXh0ZW50LCByZXNvbHV0aW9uLCBwaXhlbFJhdGlvLCBvdmVybGFwcywgZGVjbHV0dGVyVHJlZSkge1xuICAgIENhbnZhc1JlcGxheS5jYWxsKHRoaXMsIHRvbGVyYW5jZSwgbWF4RXh0ZW50LCByZXNvbHV0aW9uLCBwaXhlbFJhdGlvLCBvdmVybGFwcywgZGVjbHV0dGVyVHJlZSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRGVjbHV0dGVyR3JvdXB9XG4gICAgICovXG4gICAgdGhpcy5kZWNsdXR0ZXJHcm91cF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnR8SFRNTFZpZGVvRWxlbWVudHxIVE1MSW1hZ2VFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW1hZ2VfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR8SFRNTEltYWdlRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuYW5jaG9yWF8gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuYW5jaG9yWV8gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuaGVpZ2h0XyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5vcGFjaXR5XyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5vcmlnaW5YXyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5vcmlnaW5ZXyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMucm90YXRlV2l0aFZpZXdfID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnJvdGF0aW9uXyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5zY2FsZV8gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMud2lkdGhfID0gdW5kZWZpbmVkO1xuXG4gIH1cblxuICBpZiAoIENhbnZhc1JlcGxheSApIENhbnZhc0ltYWdlUmVwbGF5Ll9fcHJvdG9fXyA9IENhbnZhc1JlcGxheTtcbiAgQ2FudmFzSW1hZ2VSZXBsYXkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ2FudmFzUmVwbGF5ICYmIENhbnZhc1JlcGxheS5wcm90b3R5cGUgKTtcbiAgQ2FudmFzSW1hZ2VSZXBsYXkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2FudmFzSW1hZ2VSZXBsYXk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge251bWJlcn0gTXkgZW5kLlxuICAgKi9cbiAgQ2FudmFzSW1hZ2VSZXBsYXkucHJvdG90eXBlLmRyYXdDb29yZGluYXRlc18gPSBmdW5jdGlvbiBkcmF3Q29vcmRpbmF0ZXNfIChmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUpIHtcbiAgICByZXR1cm4gdGhpcy5hcHBlbmRGbGF0Q29vcmRpbmF0ZXMoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCBmYWxzZSwgZmFsc2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQ2FudmFzSW1hZ2VSZXBsYXkucHJvdG90eXBlLmRyYXdQb2ludCA9IGZ1bmN0aW9uIGRyYXdQb2ludCAocG9pbnRHZW9tZXRyeSwgZmVhdHVyZSkge1xuICAgIGlmICghdGhpcy5pbWFnZV8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5iZWdpbkdlb21ldHJ5KHBvaW50R2VvbWV0cnksIGZlYXR1cmUpO1xuICAgIHZhciBmbGF0Q29vcmRpbmF0ZXMgPSBwb2ludEdlb21ldHJ5LmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgIHZhciBzdHJpZGUgPSBwb2ludEdlb21ldHJ5LmdldFN0cmlkZSgpO1xuICAgIHZhciBteUJlZ2luID0gdGhpcy5jb29yZGluYXRlcy5sZW5ndGg7XG4gICAgdmFyIG15RW5kID0gdGhpcy5kcmF3Q29vcmRpbmF0ZXNfKGZsYXRDb29yZGluYXRlcywgMCwgZmxhdENvb3JkaW5hdGVzLmxlbmd0aCwgc3RyaWRlKTtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKFtcbiAgICAgIENhbnZhc0luc3RydWN0aW9uLkRSQVdfSU1BR0UsIG15QmVnaW4sIG15RW5kLCB0aGlzLmltYWdlXyxcbiAgICAgIC8vIFJlbWFpbmluZyBhcmd1bWVudHMgdG8gRFJBV19JTUFHRSBhcmUgaW4gYWxwaGFiZXRpY2FsIG9yZGVyXG4gICAgICB0aGlzLmFuY2hvclhfLCB0aGlzLmFuY2hvcllfLCB0aGlzLmRlY2x1dHRlckdyb3VwXywgdGhpcy5oZWlnaHRfLCB0aGlzLm9wYWNpdHlfLFxuICAgICAgdGhpcy5vcmlnaW5YXywgdGhpcy5vcmlnaW5ZXywgdGhpcy5yb3RhdGVXaXRoVmlld18sIHRoaXMucm90YXRpb25fLFxuICAgICAgdGhpcy5zY2FsZV8gKiB0aGlzLnBpeGVsUmF0aW8sIHRoaXMud2lkdGhfXG4gICAgXSk7XG4gICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChbXG4gICAgICBDYW52YXNJbnN0cnVjdGlvbi5EUkFXX0lNQUdFLCBteUJlZ2luLCBteUVuZCwgdGhpcy5oaXREZXRlY3Rpb25JbWFnZV8sXG4gICAgICAvLyBSZW1haW5pbmcgYXJndW1lbnRzIHRvIERSQVdfSU1BR0UgYXJlIGluIGFscGhhYmV0aWNhbCBvcmRlclxuICAgICAgdGhpcy5hbmNob3JYXywgdGhpcy5hbmNob3JZXywgdGhpcy5kZWNsdXR0ZXJHcm91cF8sIHRoaXMuaGVpZ2h0XywgdGhpcy5vcGFjaXR5XyxcbiAgICAgIHRoaXMub3JpZ2luWF8sIHRoaXMub3JpZ2luWV8sIHRoaXMucm90YXRlV2l0aFZpZXdfLCB0aGlzLnJvdGF0aW9uXyxcbiAgICAgIHRoaXMuc2NhbGVfLCB0aGlzLndpZHRoX1xuICAgIF0pO1xuICAgIHRoaXMuZW5kR2VvbWV0cnkocG9pbnRHZW9tZXRyeSwgZmVhdHVyZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNJbWFnZVJlcGxheS5wcm90b3R5cGUuZHJhd011bHRpUG9pbnQgPSBmdW5jdGlvbiBkcmF3TXVsdGlQb2ludCAobXVsdGlQb2ludEdlb21ldHJ5LCBmZWF0dXJlKSB7XG4gICAgaWYgKCF0aGlzLmltYWdlXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmJlZ2luR2VvbWV0cnkobXVsdGlQb2ludEdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgICB2YXIgZmxhdENvb3JkaW5hdGVzID0gbXVsdGlQb2ludEdlb21ldHJ5LmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgIHZhciBzdHJpZGUgPSBtdWx0aVBvaW50R2VvbWV0cnkuZ2V0U3RyaWRlKCk7XG4gICAgdmFyIG15QmVnaW4gPSB0aGlzLmNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICB2YXIgbXlFbmQgPSB0aGlzLmRyYXdDb29yZGluYXRlc18oXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsIDAsIGZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHN0cmlkZSk7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChbXG4gICAgICBDYW52YXNJbnN0cnVjdGlvbi5EUkFXX0lNQUdFLCBteUJlZ2luLCBteUVuZCwgdGhpcy5pbWFnZV8sXG4gICAgICAvLyBSZW1haW5pbmcgYXJndW1lbnRzIHRvIERSQVdfSU1BR0UgYXJlIGluIGFscGhhYmV0aWNhbCBvcmRlclxuICAgICAgdGhpcy5hbmNob3JYXywgdGhpcy5hbmNob3JZXywgdGhpcy5kZWNsdXR0ZXJHcm91cF8sIHRoaXMuaGVpZ2h0XywgdGhpcy5vcGFjaXR5XyxcbiAgICAgIHRoaXMub3JpZ2luWF8sIHRoaXMub3JpZ2luWV8sIHRoaXMucm90YXRlV2l0aFZpZXdfLCB0aGlzLnJvdGF0aW9uXyxcbiAgICAgIHRoaXMuc2NhbGVfICogdGhpcy5waXhlbFJhdGlvLCB0aGlzLndpZHRoX1xuICAgIF0pO1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goW1xuICAgICAgQ2FudmFzSW5zdHJ1Y3Rpb24uRFJBV19JTUFHRSwgbXlCZWdpbiwgbXlFbmQsIHRoaXMuaGl0RGV0ZWN0aW9uSW1hZ2VfLFxuICAgICAgLy8gUmVtYWluaW5nIGFyZ3VtZW50cyB0byBEUkFXX0lNQUdFIGFyZSBpbiBhbHBoYWJldGljYWwgb3JkZXJcbiAgICAgIHRoaXMuYW5jaG9yWF8sIHRoaXMuYW5jaG9yWV8sIHRoaXMuZGVjbHV0dGVyR3JvdXBfLCB0aGlzLmhlaWdodF8sIHRoaXMub3BhY2l0eV8sXG4gICAgICB0aGlzLm9yaWdpblhfLCB0aGlzLm9yaWdpbllfLCB0aGlzLnJvdGF0ZVdpdGhWaWV3XywgdGhpcy5yb3RhdGlvbl8sXG4gICAgICB0aGlzLnNjYWxlXywgdGhpcy53aWR0aF9cbiAgICBdKTtcbiAgICB0aGlzLmVuZEdlb21ldHJ5KG11bHRpUG9pbnRHZW9tZXRyeSwgZmVhdHVyZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNJbWFnZVJlcGxheS5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gZmluaXNoICgpIHtcbiAgICB0aGlzLnJldmVyc2VIaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMoKTtcbiAgICAvLyBGSVhNRSB0aGlzIGRvZXNuJ3QgcmVhbGx5IHByb3RlY3QgdXMgYWdhaW5zdCBmdXJ0aGVyIGNhbGxzIHRvIGRyYXcqR2VvbWV0cnlcbiAgICB0aGlzLmFuY2hvclhfID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYW5jaG9yWV8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oaXREZXRlY3Rpb25JbWFnZV8gPSBudWxsO1xuICAgIHRoaXMuaW1hZ2VfID0gbnVsbDtcbiAgICB0aGlzLmhlaWdodF8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zY2FsZV8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vcGFjaXR5XyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9yaWdpblhfID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub3JpZ2luWV8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yb3RhdGVXaXRoVmlld18gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yb3RhdGlvbl8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aF8gPSB1bmRlZmluZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNJbWFnZVJlcGxheS5wcm90b3R5cGUuc2V0SW1hZ2VTdHlsZSA9IGZ1bmN0aW9uIHNldEltYWdlU3R5bGUgKGltYWdlU3R5bGUsIGRlY2x1dHRlckdyb3VwKSB7XG4gICAgdmFyIGFuY2hvciA9IGltYWdlU3R5bGUuZ2V0QW5jaG9yKCk7XG4gICAgdmFyIHNpemUgPSBpbWFnZVN0eWxlLmdldFNpemUoKTtcbiAgICB2YXIgaGl0RGV0ZWN0aW9uSW1hZ2UgPSBpbWFnZVN0eWxlLmdldEhpdERldGVjdGlvbkltYWdlKDEpO1xuICAgIHZhciBpbWFnZSA9IGltYWdlU3R5bGUuZ2V0SW1hZ2UoMSk7XG4gICAgdmFyIG9yaWdpbiA9IGltYWdlU3R5bGUuZ2V0T3JpZ2luKCk7XG4gICAgdGhpcy5hbmNob3JYXyA9IGFuY2hvclswXTtcbiAgICB0aGlzLmFuY2hvcllfID0gYW5jaG9yWzFdO1xuICAgIHRoaXMuZGVjbHV0dGVyR3JvdXBfID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRGVjbHV0dGVyR3JvdXB9ICovIChkZWNsdXR0ZXJHcm91cCk7XG4gICAgdGhpcy5oaXREZXRlY3Rpb25JbWFnZV8gPSBoaXREZXRlY3Rpb25JbWFnZTtcbiAgICB0aGlzLmltYWdlXyA9IGltYWdlO1xuICAgIHRoaXMuaGVpZ2h0XyA9IHNpemVbMV07XG4gICAgdGhpcy5vcGFjaXR5XyA9IGltYWdlU3R5bGUuZ2V0T3BhY2l0eSgpO1xuICAgIHRoaXMub3JpZ2luWF8gPSBvcmlnaW5bMF07XG4gICAgdGhpcy5vcmlnaW5ZXyA9IG9yaWdpblsxXTtcbiAgICB0aGlzLnJvdGF0ZVdpdGhWaWV3XyA9IGltYWdlU3R5bGUuZ2V0Um90YXRlV2l0aFZpZXcoKTtcbiAgICB0aGlzLnJvdGF0aW9uXyA9IGltYWdlU3R5bGUuZ2V0Um90YXRpb24oKTtcbiAgICB0aGlzLnNjYWxlXyA9IGltYWdlU3R5bGUuZ2V0U2NhbGUoKTtcbiAgICB0aGlzLndpZHRoXyA9IHNpemVbMF07XG4gIH07XG5cbiAgcmV0dXJuIENhbnZhc0ltYWdlUmVwbGF5O1xufShDYW52YXNSZXBsYXkpKTtcblxuXG5leHBvcnQgZGVmYXVsdCBDYW52YXNJbWFnZVJlcGxheTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW1hZ2VSZXBsYXkuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9jYW52YXMvSW1tZWRpYXRlXG4gKi9cbi8vIEZJWE1FIHRlc3QsIGVzcGVjaWFsbHkgcG9seWdvbnMgd2l0aCBob2xlcyBhbmQgbXVsdGlwb2x5Z29uc1xuLy8gRklYTUUgbmVlZCB0byBoYW5kbGUgbGFyZ2UgdGhpY2sgZmVhdHVyZXMgKHdoZXJlIHBpeGVsIHNpemUgbWF0dGVycylcbi8vIEZJWE1FIGFkZCBvZmZzZXQgYW5kIGVuZCB0byBvbC9nZW9tL2ZsYXQvdHJhbnNmb3JtfnRyYW5zZm9ybTJEP1xuXG5pbXBvcnQge2VxdWFsc30gZnJvbSAnLi4vLi4vYXJyYXkuanMnO1xuaW1wb3J0IHthc0NvbG9yTGlrZX0gZnJvbSAnLi4vLi4vY29sb3JsaWtlLmpzJztcbmltcG9ydCB7aW50ZXJzZWN0c30gZnJvbSAnLi4vLi4vZXh0ZW50LmpzJztcbmltcG9ydCBHZW9tZXRyeVR5cGUgZnJvbSAnLi4vLi4vZ2VvbS9HZW9tZXRyeVR5cGUuanMnO1xuaW1wb3J0IHt0cmFuc2Zvcm1HZW9tMkR9IGZyb20gJy4uLy4uL2dlb20vU2ltcGxlR2VvbWV0cnkuanMnO1xuaW1wb3J0IHt0cmFuc2Zvcm0yRH0gZnJvbSAnLi4vLi4vZ2VvbS9mbGF0L3RyYW5zZm9ybS5qcyc7XG5pbXBvcnQge0NBTlZBU19MSU5FX0RBU0h9IGZyb20gJy4uLy4uL2hhcy5qcyc7XG5pbXBvcnQgVmVjdG9yQ29udGV4dCBmcm9tICcuLi9WZWN0b3JDb250ZXh0LmpzJztcbmltcG9ydCB7ZGVmYXVsdFRleHRBbGlnbiwgZGVmYXVsdEZpbGxTdHlsZSwgZGVmYXVsdExpbmVDYXAsIGRlZmF1bHRMaW5lRGFzaCwgZGVmYXVsdExpbmVEYXNoT2Zmc2V0LCBkZWZhdWx0TGluZUpvaW4sIGRlZmF1bHRMaW5lV2lkdGgsIGRlZmF1bHRNaXRlckxpbWl0LCBkZWZhdWx0U3Ryb2tlU3R5bGUsIGRlZmF1bHRUZXh0QmFzZWxpbmUsIGRlZmF1bHRGb250fSBmcm9tICcuLi9jYW52YXMuanMnO1xuaW1wb3J0IHtjcmVhdGUgYXMgY3JlYXRlVHJhbnNmb3JtLCBjb21wb3NlIGFzIGNvbXBvc2VUcmFuc2Zvcm19IGZyb20gJy4uLy4uL3RyYW5zZm9ybS5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQSBjb25jcmV0ZSBzdWJjbGFzcyBvZiB7QGxpbmsgbW9kdWxlOm9sL3JlbmRlci9WZWN0b3JDb250ZXh0fSB0aGF0IGltcGxlbWVudHNcbiAqIGRpcmVjdCByZW5kZXJpbmcgb2YgZmVhdHVyZXMgYW5kIGdlb21ldHJpZXMgdG8gYW4gSFRNTDUgQ2FudmFzIGNvbnRleHQuXG4gKiBJbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyBhcmUgY3JlYXRlZCBpbnRlcm5hbGx5IGJ5IHRoZSBsaWJyYXJ5IGFuZFxuICogcHJvdmlkZWQgdG8gYXBwbGljYXRpb24gY29kZSBhcyB2ZWN0b3JDb250ZXh0IG1lbWJlciBvZiB0aGVcbiAqIHtAbGluayBtb2R1bGU6b2wvcmVuZGVyL0V2ZW50flJlbmRlckV2ZW50fSBvYmplY3QgYXNzb2NpYXRlZCB3aXRoIHBvc3Rjb21wb3NlLCBwcmVjb21wb3NlIGFuZFxuICogcmVuZGVyIGV2ZW50cyBlbWl0dGVkIGJ5IGxheWVycyBhbmQgbWFwcy5cbiAqL1xudmFyIENhbnZhc0ltbWVkaWF0ZVJlbmRlcmVyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoVmVjdG9yQ29udGV4dCkge1xuICBmdW5jdGlvbiBDYW52YXNJbW1lZGlhdGVSZW5kZXJlcihjb250ZXh0LCBwaXhlbFJhdGlvLCBleHRlbnQsIHRyYW5zZm9ybSwgdmlld1JvdGF0aW9uKSB7XG4gICAgVmVjdG9yQ29udGV4dC5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICAgICAqL1xuICAgIHRoaXMuY29udGV4dF8gPSBjb250ZXh0O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucGl4ZWxSYXRpb18gPSBwaXhlbFJhdGlvO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAgICAgKi9cbiAgICB0aGlzLmV4dGVudF8gPSBleHRlbnQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfVxuICAgICAqL1xuICAgIHRoaXMudHJhbnNmb3JtXyA9IHRyYW5zZm9ybTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnZpZXdSb3RhdGlvbl8gPSB2aWV3Um90YXRpb247XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkZpbGxTdGF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRleHRGaWxsU3RhdGVfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuLi9jYW52YXMuanNcIikuU3Ryb2tlU3RhdGV9XG4gICAgICovXG4gICAgdGhpcy5jb250ZXh0U3Ryb2tlU3RhdGVfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuLi9jYW52YXMuanNcIikuVGV4dFN0YXRlfVxuICAgICAqL1xuICAgIHRoaXMuY29udGV4dFRleHRTdGF0ZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5GaWxsU3RhdGV9XG4gICAgICovXG4gICAgdGhpcy5maWxsU3RhdGVfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuLi9jYW52YXMuanNcIikuU3Ryb2tlU3RhdGV9XG4gICAgICovXG4gICAgdGhpcy5zdHJva2VTdGF0ZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnR8SFRNTFZpZGVvRWxlbWVudHxIVE1MSW1hZ2VFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlQW5jaG9yWF8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VBbmNob3JZXyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbWFnZUhlaWdodF8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VPcGFjaXR5XyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbWFnZU9yaWdpblhfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlT3JpZ2luWV8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlUm90YXRlV2l0aFZpZXdfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbWFnZVJvdGF0aW9uXyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbWFnZVNjYWxlXyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbWFnZVdpZHRoXyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy50ZXh0XyA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudGV4dE9mZnNldFhfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRleHRPZmZzZXRZXyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMudGV4dFJvdGF0ZVdpdGhWaWV3XyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudGV4dFJvdGF0aW9uXyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50ZXh0U2NhbGVfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRmlsbFN0YXRlfVxuICAgICAqL1xuICAgIHRoaXMudGV4dEZpbGxTdGF0ZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5TdHJva2VTdGF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLnRleHRTdHJva2VTdGF0ZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5UZXh0U3RhdGV9XG4gICAgICovXG4gICAgdGhpcy50ZXh0U3RhdGVfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5waXhlbENvb3JkaW5hdGVzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX1cbiAgICAgKi9cbiAgICB0aGlzLnRtcExvY2FsVHJhbnNmb3JtXyA9IGNyZWF0ZVRyYW5zZm9ybSgpO1xuXG4gIH1cblxuICBpZiAoIFZlY3RvckNvbnRleHQgKSBDYW52YXNJbW1lZGlhdGVSZW5kZXJlci5fX3Byb3RvX18gPSBWZWN0b3JDb250ZXh0O1xuICBDYW52YXNJbW1lZGlhdGVSZW5kZXJlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBWZWN0b3JDb250ZXh0ICYmIFZlY3RvckNvbnRleHQucHJvdG90eXBlICk7XG4gIENhbnZhc0ltbWVkaWF0ZVJlbmRlcmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhbnZhc0ltbWVkaWF0ZVJlbmRlcmVyO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQ2FudmFzSW1tZWRpYXRlUmVuZGVyZXIucHJvdG90eXBlLmRyYXdJbWFnZXNfID0gZnVuY3Rpb24gZHJhd0ltYWdlc18gKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSkge1xuICAgIGlmICghdGhpcy5pbWFnZV8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHBpeGVsQ29vcmRpbmF0ZXMgPSB0cmFuc2Zvcm0yRChcbiAgICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIDIsIHRoaXMudHJhbnNmb3JtXyxcbiAgICAgIHRoaXMucGl4ZWxDb29yZGluYXRlc18pO1xuICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0XztcbiAgICB2YXIgbG9jYWxUcmFuc2Zvcm0gPSB0aGlzLnRtcExvY2FsVHJhbnNmb3JtXztcbiAgICB2YXIgYWxwaGEgPSBjb250ZXh0Lmdsb2JhbEFscGhhO1xuICAgIGlmICh0aGlzLmltYWdlT3BhY2l0eV8gIT0gMSkge1xuICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGFscGhhICogdGhpcy5pbWFnZU9wYWNpdHlfO1xuICAgIH1cbiAgICB2YXIgcm90YXRpb24gPSB0aGlzLmltYWdlUm90YXRpb25fO1xuICAgIGlmICh0aGlzLmltYWdlUm90YXRlV2l0aFZpZXdfKSB7XG4gICAgICByb3RhdGlvbiArPSB0aGlzLnZpZXdSb3RhdGlvbl87XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHBpeGVsQ29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgdmFyIHggPSBwaXhlbENvb3JkaW5hdGVzW2ldIC0gdGhpcy5pbWFnZUFuY2hvclhfO1xuICAgICAgdmFyIHkgPSBwaXhlbENvb3JkaW5hdGVzW2kgKyAxXSAtIHRoaXMuaW1hZ2VBbmNob3JZXztcbiAgICAgIGlmIChyb3RhdGlvbiAhPT0gMCB8fCB0aGlzLmltYWdlU2NhbGVfICE9IDEpIHtcbiAgICAgICAgdmFyIGNlbnRlclggPSB4ICsgdGhpcy5pbWFnZUFuY2hvclhfO1xuICAgICAgICB2YXIgY2VudGVyWSA9IHkgKyB0aGlzLmltYWdlQW5jaG9yWV87XG4gICAgICAgIGNvbXBvc2VUcmFuc2Zvcm0obG9jYWxUcmFuc2Zvcm0sXG4gICAgICAgICAgY2VudGVyWCwgY2VudGVyWSxcbiAgICAgICAgICB0aGlzLmltYWdlU2NhbGVfLCB0aGlzLmltYWdlU2NhbGVfLFxuICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgIC1jZW50ZXJYLCAtY2VudGVyWSk7XG4gICAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtLmFwcGx5KGNvbnRleHQsIGxvY2FsVHJhbnNmb3JtKTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuZHJhd0ltYWdlKHRoaXMuaW1hZ2VfLCB0aGlzLmltYWdlT3JpZ2luWF8sIHRoaXMuaW1hZ2VPcmlnaW5ZXyxcbiAgICAgICAgdGhpcy5pbWFnZVdpZHRoXywgdGhpcy5pbWFnZUhlaWdodF8sIHgsIHksXG4gICAgICAgIHRoaXMuaW1hZ2VXaWR0aF8sIHRoaXMuaW1hZ2VIZWlnaHRfKTtcbiAgICB9XG4gICAgaWYgKHJvdGF0aW9uICE9PSAwIHx8IHRoaXMuaW1hZ2VTY2FsZV8gIT0gMSkge1xuICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmltYWdlT3BhY2l0eV8gIT0gMSkge1xuICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGFscGhhO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIENhbnZhc0ltbWVkaWF0ZVJlbmRlcmVyLnByb3RvdHlwZS5kcmF3VGV4dF8gPSBmdW5jdGlvbiBkcmF3VGV4dF8gKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSkge1xuICAgIGlmICghdGhpcy50ZXh0U3RhdGVfIHx8IHRoaXMudGV4dF8gPT09ICcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnRleHRGaWxsU3RhdGVfKSB7XG4gICAgICB0aGlzLnNldENvbnRleHRGaWxsU3RhdGVfKHRoaXMudGV4dEZpbGxTdGF0ZV8pO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXh0U3Ryb2tlU3RhdGVfKSB7XG4gICAgICB0aGlzLnNldENvbnRleHRTdHJva2VTdGF0ZV8odGhpcy50ZXh0U3Ryb2tlU3RhdGVfKTtcbiAgICB9XG4gICAgdGhpcy5zZXRDb250ZXh0VGV4dFN0YXRlXyh0aGlzLnRleHRTdGF0ZV8pO1xuICAgIHZhciBwaXhlbENvb3JkaW5hdGVzID0gdHJhbnNmb3JtMkQoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIHRoaXMudHJhbnNmb3JtXyxcbiAgICAgIHRoaXMucGl4ZWxDb29yZGluYXRlc18pO1xuICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0XztcbiAgICB2YXIgcm90YXRpb24gPSB0aGlzLnRleHRSb3RhdGlvbl87XG4gICAgaWYgKHRoaXMudGV4dFJvdGF0ZVdpdGhWaWV3Xykge1xuICAgICAgcm90YXRpb24gKz0gdGhpcy52aWV3Um90YXRpb25fO1xuICAgIH1cbiAgICBmb3IgKDsgb2Zmc2V0IDwgZW5kOyBvZmZzZXQgKz0gc3RyaWRlKSB7XG4gICAgICB2YXIgeCA9IHBpeGVsQ29vcmRpbmF0ZXNbb2Zmc2V0XSArIHRoaXMudGV4dE9mZnNldFhfO1xuICAgICAgdmFyIHkgPSBwaXhlbENvb3JkaW5hdGVzW29mZnNldCArIDFdICsgdGhpcy50ZXh0T2Zmc2V0WV87XG4gICAgICBpZiAocm90YXRpb24gIT09IDAgfHwgdGhpcy50ZXh0U2NhbGVfICE9IDEpIHtcbiAgICAgICAgdmFyIGxvY2FsVHJhbnNmb3JtID0gY29tcG9zZVRyYW5zZm9ybSh0aGlzLnRtcExvY2FsVHJhbnNmb3JtXyxcbiAgICAgICAgICB4LCB5LFxuICAgICAgICAgIHRoaXMudGV4dFNjYWxlXywgdGhpcy50ZXh0U2NhbGVfLFxuICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgIC14LCAteSk7XG4gICAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtLmFwcGx5KGNvbnRleHQsIGxvY2FsVHJhbnNmb3JtKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnRleHRTdHJva2VTdGF0ZV8pIHtcbiAgICAgICAgY29udGV4dC5zdHJva2VUZXh0KHRoaXMudGV4dF8sIHgsIHkpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudGV4dEZpbGxTdGF0ZV8pIHtcbiAgICAgICAgY29udGV4dC5maWxsVGV4dCh0aGlzLnRleHRfLCB4LCB5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJvdGF0aW9uICE9PSAwIHx8IHRoaXMudGV4dFNjYWxlXyAhPSAxKSB7XG4gICAgICBjb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xvc2UgQ2xvc2UuXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge251bWJlcn0gZW5kIEVuZC5cbiAgICovXG4gIENhbnZhc0ltbWVkaWF0ZVJlbmRlcmVyLnByb3RvdHlwZS5tb3ZlVG9MaW5lVG9fID0gZnVuY3Rpb24gbW92ZVRvTGluZVRvXyAoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCBjbG9zZSkge1xuICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0XztcbiAgICB2YXIgcGl4ZWxDb29yZGluYXRlcyA9IHRyYW5zZm9ybTJEKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCB0aGlzLnRyYW5zZm9ybV8sXG4gICAgICB0aGlzLnBpeGVsQ29vcmRpbmF0ZXNfKTtcbiAgICBjb250ZXh0Lm1vdmVUbyhwaXhlbENvb3JkaW5hdGVzWzBdLCBwaXhlbENvb3JkaW5hdGVzWzFdKTtcbiAgICB2YXIgbGVuZ3RoID0gcGl4ZWxDb29yZGluYXRlcy5sZW5ndGg7XG4gICAgaWYgKGNsb3NlKSB7XG4gICAgICBsZW5ndGggLT0gMjtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBsZW5ndGg7IGkgKz0gMikge1xuICAgICAgY29udGV4dC5saW5lVG8ocGl4ZWxDb29yZGluYXRlc1tpXSwgcGl4ZWxDb29yZGluYXRlc1tpICsgMV0pO1xuICAgIH1cbiAgICBpZiAoY2xvc2UpIHtcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgfVxuICAgIHJldHVybiBlbmQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGVuZHMgRW5kcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge251bWJlcn0gRW5kLlxuICAgKi9cbiAgQ2FudmFzSW1tZWRpYXRlUmVuZGVyZXIucHJvdG90eXBlLmRyYXdSaW5nc18gPSBmdW5jdGlvbiBkcmF3UmluZ3NfIChmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBvZmZzZXQgPSB0aGlzLm1vdmVUb0xpbmVUb18oZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHNbaV0sIHN0cmlkZSwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlciBhIGNpcmNsZSBnZW9tZXRyeSBpbnRvIHRoZSBjYW52YXMuICBSZW5kZXJpbmcgaXMgaW1tZWRpYXRlIGFuZCB1c2VzXG4gICAqIHRoZSBjdXJyZW50IGZpbGwgYW5kIHN0cm9rZSBzdHlsZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9DaXJjbGUuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgQ2lyY2xlIGdlb21ldHJ5LlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGFwaVxuICAgKi9cbiAgQ2FudmFzSW1tZWRpYXRlUmVuZGVyZXIucHJvdG90eXBlLmRyYXdDaXJjbGUgPSBmdW5jdGlvbiBkcmF3Q2lyY2xlIChnZW9tZXRyeSkge1xuICAgIGlmICghaW50ZXJzZWN0cyh0aGlzLmV4dGVudF8sIGdlb21ldHJ5LmdldEV4dGVudCgpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5maWxsU3RhdGVfIHx8IHRoaXMuc3Ryb2tlU3RhdGVfKSB7XG4gICAgICBpZiAodGhpcy5maWxsU3RhdGVfKSB7XG4gICAgICAgIHRoaXMuc2V0Q29udGV4dEZpbGxTdGF0ZV8odGhpcy5maWxsU3RhdGVfKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0cm9rZVN0YXRlXykge1xuICAgICAgICB0aGlzLnNldENvbnRleHRTdHJva2VTdGF0ZV8odGhpcy5zdHJva2VTdGF0ZV8pO1xuICAgICAgfVxuICAgICAgdmFyIHBpeGVsQ29vcmRpbmF0ZXMgPSB0cmFuc2Zvcm1HZW9tMkQoXG4gICAgICAgIGdlb21ldHJ5LCB0aGlzLnRyYW5zZm9ybV8sIHRoaXMucGl4ZWxDb29yZGluYXRlc18pO1xuICAgICAgdmFyIGR4ID0gcGl4ZWxDb29yZGluYXRlc1syXSAtIHBpeGVsQ29vcmRpbmF0ZXNbMF07XG4gICAgICB2YXIgZHkgPSBwaXhlbENvb3JkaW5hdGVzWzNdIC0gcGl4ZWxDb29yZGluYXRlc1sxXTtcbiAgICAgIHZhciByYWRpdXMgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHRfO1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGNvbnRleHQuYXJjKFxuICAgICAgICBwaXhlbENvb3JkaW5hdGVzWzBdLCBwaXhlbENvb3JkaW5hdGVzWzFdLCByYWRpdXMsIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgIGlmICh0aGlzLmZpbGxTdGF0ZV8pIHtcbiAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdHJva2VTdGF0ZV8pIHtcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMudGV4dF8gIT09ICcnKSB7XG4gICAgICB0aGlzLmRyYXdUZXh0XyhnZW9tZXRyeS5nZXRDZW50ZXIoKSwgMCwgMiwgMik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHJlbmRlcmluZyBzdHlsZS4gIE5vdGUgdGhhdCBzaW5jZSB0aGlzIGlzIGFuIGltbWVkaWF0ZSByZW5kZXJpbmcgQVBJLFxuICAgKiBhbnkgYHpJbmRleGAgb24gdGhlIHByb3ZpZGVkIHN0eWxlIHdpbGwgYmUgaWdub3JlZC5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9zdHlsZS9TdHlsZS5qc1wiKS5kZWZhdWx0fSBzdHlsZSBUaGUgcmVuZGVyaW5nIHN0eWxlLlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGFwaVxuICAgKi9cbiAgQ2FudmFzSW1tZWRpYXRlUmVuZGVyZXIucHJvdG90eXBlLnNldFN0eWxlID0gZnVuY3Rpb24gc2V0U3R5bGUgKHN0eWxlKSB7XG4gICAgdGhpcy5zZXRGaWxsU3Ryb2tlU3R5bGUoc3R5bGUuZ2V0RmlsbCgpLCBzdHlsZS5nZXRTdHJva2UoKSk7XG4gICAgdGhpcy5zZXRJbWFnZVN0eWxlKHN0eWxlLmdldEltYWdlKCkpO1xuICAgIHRoaXMuc2V0VGV4dFN0eWxlKHN0eWxlLmdldFRleHQoKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlciBhIGdlb21ldHJ5IGludG8gdGhlIGNhbnZhcy4gIENhbGxcbiAgICoge0BsaW5rIG1vZHVsZTpvbC9yZW5kZXIvY2FudmFzL0ltbWVkaWF0ZSNzZXRTdHlsZX0gZmlyc3QgdG8gc2V0IHRoZSByZW5kZXJpbmcgc3R5bGUuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgVGhlIGdlb21ldHJ5IHRvIHJlbmRlci5cbiAgICogQG92ZXJyaWRlXG4gICAqIEBhcGlcbiAgICovXG4gIENhbnZhc0ltbWVkaWF0ZVJlbmRlcmVyLnByb3RvdHlwZS5kcmF3R2VvbWV0cnkgPSBmdW5jdGlvbiBkcmF3R2VvbWV0cnkgKGdlb21ldHJ5KSB7XG4gICAgdmFyIHR5cGUgPSBnZW9tZXRyeS5nZXRUeXBlKCk7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIEdlb21ldHJ5VHlwZS5QT0lOVDpcbiAgICAgICAgdGhpcy5kcmF3UG9pbnQoLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9nZW9tL1BvaW50LmpzXCIpLmRlZmF1bHR9ICovIChnZW9tZXRyeSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgR2VvbWV0cnlUeXBlLkxJTkVfU1RSSU5HOlxuICAgICAgICB0aGlzLmRyYXdMaW5lU3RyaW5nKC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9MaW5lU3RyaW5nLmpzXCIpLmRlZmF1bHR9ICovIChnZW9tZXRyeSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgR2VvbWV0cnlUeXBlLlBPTFlHT046XG4gICAgICAgIHRoaXMuZHJhd1BvbHlnb24oLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9nZW9tL1BvbHlnb24uanNcIikuZGVmYXVsdH0gKi8gKGdlb21ldHJ5KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuTVVMVElfUE9JTlQ6XG4gICAgICAgIHRoaXMuZHJhd011bHRpUG9pbnQoLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9nZW9tL011bHRpUG9pbnQuanNcIikuZGVmYXVsdH0gKi8gKGdlb21ldHJ5KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuTVVMVElfTElORV9TVFJJTkc6XG4gICAgICAgIHRoaXMuZHJhd011bHRpTGluZVN0cmluZygvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2dlb20vTXVsdGlMaW5lU3RyaW5nLmpzXCIpLmRlZmF1bHR9ICovIChnZW9tZXRyeSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgR2VvbWV0cnlUeXBlLk1VTFRJX1BPTFlHT046XG4gICAgICAgIHRoaXMuZHJhd011bHRpUG9seWdvbigvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2dlb20vTXVsdGlQb2x5Z29uLmpzXCIpLmRlZmF1bHR9ICovIChnZW9tZXRyeSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgR2VvbWV0cnlUeXBlLkdFT01FVFJZX0NPTExFQ1RJT046XG4gICAgICAgIHRoaXMuZHJhd0dlb21ldHJ5Q29sbGVjdGlvbigvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2dlb20vR2VvbWV0cnlDb2xsZWN0aW9uLmpzXCIpLmRlZmF1bHR9ICovIChnZW9tZXRyeSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgR2VvbWV0cnlUeXBlLkNJUkNMRTpcbiAgICAgICAgdGhpcy5kcmF3Q2lyY2xlKC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9DaXJjbGUuanNcIikuZGVmYXVsdH0gKi8gKGdlb21ldHJ5KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlciBhIGZlYXR1cmUgaW50byB0aGUgY2FudmFzLiAgTm90ZSB0aGF0IGFueSBgekluZGV4YCBvbiB0aGUgcHJvdmlkZWRcbiAgICogc3R5bGUgd2lsbCBiZSBpZ25vcmVkIC0gZmVhdHVyZXMgYXJlIHJlbmRlcmVkIGltbWVkaWF0ZWx5IGluIHRoZSBvcmRlciB0aGF0XG4gICAqIHRoaXMgbWV0aG9kIGlzIGNhbGxlZC4gIElmIHlvdSBuZWVkIGB6SW5kZXhgIHN1cHBvcnQsIHlvdSBzaG91bGQgYmUgdXNpbmcgYW5cbiAgICoge0BsaW5rIG1vZHVsZTpvbC9sYXllci9WZWN0b3J+VmVjdG9yTGF5ZXJ9IGluc3RlYWQuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdH0gc3R5bGUgU3R5bGUuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBDYW52YXNJbW1lZGlhdGVSZW5kZXJlci5wcm90b3R5cGUuZHJhd0ZlYXR1cmUgPSBmdW5jdGlvbiBkcmF3RmVhdHVyZSAoZmVhdHVyZSwgc3R5bGUpIHtcbiAgICB2YXIgZ2VvbWV0cnkgPSBzdHlsZS5nZXRHZW9tZXRyeUZ1bmN0aW9uKCkoZmVhdHVyZSk7XG4gICAgaWYgKCFnZW9tZXRyeSB8fCAhaW50ZXJzZWN0cyh0aGlzLmV4dGVudF8sIGdlb21ldHJ5LmdldEV4dGVudCgpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNldFN0eWxlKHN0eWxlKTtcbiAgICB0aGlzLmRyYXdHZW9tZXRyeShnZW9tZXRyeSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlciBhIEdlb21ldHJ5Q29sbGVjdGlvbiB0byB0aGUgY2FudmFzLiAgUmVuZGVyaW5nIGlzIGltbWVkaWF0ZSBhbmRcbiAgICogdXNlcyB0aGUgY3VycmVudCBzdHlsZXMgYXBwcm9wcmlhdGUgZm9yIGVhY2ggZ2VvbWV0cnkgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9HZW9tZXRyeUNvbGxlY3Rpb24uanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkgY29sbGVjdGlvbi5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBDYW52YXNJbW1lZGlhdGVSZW5kZXJlci5wcm90b3R5cGUuZHJhd0dlb21ldHJ5Q29sbGVjdGlvbiA9IGZ1bmN0aW9uIGRyYXdHZW9tZXRyeUNvbGxlY3Rpb24gKGdlb21ldHJ5KSB7XG4gICAgdmFyIGdlb21ldHJpZXMgPSBnZW9tZXRyeS5nZXRHZW9tZXRyaWVzQXJyYXkoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBnZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIHRoaXMuZHJhd0dlb21ldHJ5KGdlb21ldHJpZXNbaV0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVyIGEgUG9pbnQgZ2VvbWV0cnkgaW50byB0aGUgY2FudmFzLiAgUmVuZGVyaW5nIGlzIGltbWVkaWF0ZSBhbmQgdXNlc1xuICAgKiB0aGUgY3VycmVudCBzdHlsZS5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9nZW9tL1BvaW50LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBQb2ludCBnZW9tZXRyeS5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBDYW52YXNJbW1lZGlhdGVSZW5kZXJlci5wcm90b3R5cGUuZHJhd1BvaW50ID0gZnVuY3Rpb24gZHJhd1BvaW50IChnZW9tZXRyeSkge1xuICAgIHZhciBmbGF0Q29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICB2YXIgc3RyaWRlID0gZ2VvbWV0cnkuZ2V0U3RyaWRlKCk7XG4gICAgaWYgKHRoaXMuaW1hZ2VfKSB7XG4gICAgICB0aGlzLmRyYXdJbWFnZXNfKGZsYXRDb29yZGluYXRlcywgMCwgZmxhdENvb3JkaW5hdGVzLmxlbmd0aCwgc3RyaWRlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGV4dF8gIT09ICcnKSB7XG4gICAgICB0aGlzLmRyYXdUZXh0XyhmbGF0Q29vcmRpbmF0ZXMsIDAsIGZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHN0cmlkZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgYSBNdWx0aVBvaW50IGdlb21ldHJ5ICBpbnRvIHRoZSBjYW52YXMuICBSZW5kZXJpbmcgaXMgaW1tZWRpYXRlIGFuZFxuICAgKiB1c2VzIHRoZSBjdXJyZW50IHN0eWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2dlb20vTXVsdGlQb2ludC5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgTXVsdGlQb2ludCBnZW9tZXRyeS5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBDYW52YXNJbW1lZGlhdGVSZW5kZXJlci5wcm90b3R5cGUuZHJhd011bHRpUG9pbnQgPSBmdW5jdGlvbiBkcmF3TXVsdGlQb2ludCAoZ2VvbWV0cnkpIHtcbiAgICB2YXIgZmxhdENvb3JkaW5hdGVzID0gZ2VvbWV0cnkuZ2V0RmxhdENvb3JkaW5hdGVzKCk7XG4gICAgdmFyIHN0cmlkZSA9IGdlb21ldHJ5LmdldFN0cmlkZSgpO1xuICAgIGlmICh0aGlzLmltYWdlXykge1xuICAgICAgdGhpcy5kcmF3SW1hZ2VzXyhmbGF0Q29vcmRpbmF0ZXMsIDAsIGZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHN0cmlkZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRleHRfICE9PSAnJykge1xuICAgICAgdGhpcy5kcmF3VGV4dF8oZmxhdENvb3JkaW5hdGVzLCAwLCBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLCBzdHJpZGUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVyIGEgTGluZVN0cmluZyBpbnRvIHRoZSBjYW52YXMuICBSZW5kZXJpbmcgaXMgaW1tZWRpYXRlIGFuZCB1c2VzXG4gICAqIHRoZSBjdXJyZW50IHN0eWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2dlb20vTGluZVN0cmluZy5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgTGluZVN0cmluZyBnZW9tZXRyeS5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBDYW52YXNJbW1lZGlhdGVSZW5kZXJlci5wcm90b3R5cGUuZHJhd0xpbmVTdHJpbmcgPSBmdW5jdGlvbiBkcmF3TGluZVN0cmluZyAoZ2VvbWV0cnkpIHtcbiAgICBpZiAoIWludGVyc2VjdHModGhpcy5leHRlbnRfLCBnZW9tZXRyeS5nZXRFeHRlbnQoKSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3Ryb2tlU3RhdGVfKSB7XG4gICAgICB0aGlzLnNldENvbnRleHRTdHJva2VTdGF0ZV8odGhpcy5zdHJva2VTdGF0ZV8pO1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHRfO1xuICAgICAgdmFyIGZsYXRDb29yZGluYXRlcyA9IGdlb21ldHJ5LmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIHRoaXMubW92ZVRvTGluZVRvXyhmbGF0Q29vcmRpbmF0ZXMsIDAsIGZsYXRDb29yZGluYXRlcy5sZW5ndGgsXG4gICAgICAgIGdlb21ldHJ5LmdldFN0cmlkZSgpLCBmYWxzZSk7XG4gICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXh0XyAhPT0gJycpIHtcbiAgICAgIHZhciBmbGF0TWlkcG9pbnQgPSBnZW9tZXRyeS5nZXRGbGF0TWlkcG9pbnQoKTtcbiAgICAgIHRoaXMuZHJhd1RleHRfKGZsYXRNaWRwb2ludCwgMCwgMiwgMik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgYSBNdWx0aUxpbmVTdHJpbmcgZ2VvbWV0cnkgaW50byB0aGUgY2FudmFzLiAgUmVuZGVyaW5nIGlzIGltbWVkaWF0ZVxuICAgKiBhbmQgdXNlcyB0aGUgY3VycmVudCBzdHlsZS5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9nZW9tL011bHRpTGluZVN0cmluZy5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgTXVsdGlMaW5lU3RyaW5nIGdlb21ldHJ5LlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIENhbnZhc0ltbWVkaWF0ZVJlbmRlcmVyLnByb3RvdHlwZS5kcmF3TXVsdGlMaW5lU3RyaW5nID0gZnVuY3Rpb24gZHJhd011bHRpTGluZVN0cmluZyAoZ2VvbWV0cnkpIHtcbiAgICB2YXIgZ2VvbWV0cnlFeHRlbnQgPSBnZW9tZXRyeS5nZXRFeHRlbnQoKTtcbiAgICBpZiAoIWludGVyc2VjdHModGhpcy5leHRlbnRfLCBnZW9tZXRyeUV4dGVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3Ryb2tlU3RhdGVfKSB7XG4gICAgICB0aGlzLnNldENvbnRleHRTdHJva2VTdGF0ZV8odGhpcy5zdHJva2VTdGF0ZV8pO1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHRfO1xuICAgICAgdmFyIGZsYXRDb29yZGluYXRlcyA9IGdlb21ldHJ5LmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICB2YXIgZW5kcyA9IC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi8gKGdlb21ldHJ5LmdldEVuZHMoKSk7XG4gICAgICB2YXIgc3RyaWRlID0gZ2VvbWV0cnkuZ2V0U3RyaWRlKCk7XG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIG9mZnNldCA9IHRoaXMubW92ZVRvTGluZVRvXyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kc1tpXSwgc3RyaWRlLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXh0XyAhPT0gJycpIHtcbiAgICAgIHZhciBmbGF0TWlkcG9pbnRzID0gZ2VvbWV0cnkuZ2V0RmxhdE1pZHBvaW50cygpO1xuICAgICAgdGhpcy5kcmF3VGV4dF8oZmxhdE1pZHBvaW50cywgMCwgZmxhdE1pZHBvaW50cy5sZW5ndGgsIDIpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVyIGEgUG9seWdvbiBnZW9tZXRyeSBpbnRvIHRoZSBjYW52YXMuICBSZW5kZXJpbmcgaXMgaW1tZWRpYXRlIGFuZCB1c2VzXG4gICAqIHRoZSBjdXJyZW50IHN0eWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2dlb20vUG9seWdvbi5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgUG9seWdvbiBnZW9tZXRyeS5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBDYW52YXNJbW1lZGlhdGVSZW5kZXJlci5wcm90b3R5cGUuZHJhd1BvbHlnb24gPSBmdW5jdGlvbiBkcmF3UG9seWdvbiAoZ2VvbWV0cnkpIHtcbiAgICBpZiAoIWludGVyc2VjdHModGhpcy5leHRlbnRfLCBnZW9tZXRyeS5nZXRFeHRlbnQoKSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3Ryb2tlU3RhdGVfIHx8IHRoaXMuZmlsbFN0YXRlXykge1xuICAgICAgaWYgKHRoaXMuZmlsbFN0YXRlXykge1xuICAgICAgICB0aGlzLnNldENvbnRleHRGaWxsU3RhdGVfKHRoaXMuZmlsbFN0YXRlXyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdHJva2VTdGF0ZV8pIHtcbiAgICAgICAgdGhpcy5zZXRDb250ZXh0U3Ryb2tlU3RhdGVfKHRoaXMuc3Ryb2tlU3RhdGVfKTtcbiAgICAgIH1cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0XztcbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICB0aGlzLmRyYXdSaW5nc18oZ2VvbWV0cnkuZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMoKSxcbiAgICAgICAgMCwgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqLyAoZ2VvbWV0cnkuZ2V0RW5kcygpKSwgZ2VvbWV0cnkuZ2V0U3RyaWRlKCkpO1xuICAgICAgaWYgKHRoaXMuZmlsbFN0YXRlXykge1xuICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0cm9rZVN0YXRlXykge1xuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy50ZXh0XyAhPT0gJycpIHtcbiAgICAgIHZhciBmbGF0SW50ZXJpb3JQb2ludCA9IGdlb21ldHJ5LmdldEZsYXRJbnRlcmlvclBvaW50KCk7XG4gICAgICB0aGlzLmRyYXdUZXh0XyhmbGF0SW50ZXJpb3JQb2ludCwgMCwgMiwgMik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgTXVsdGlQb2x5Z29uIGdlb21ldHJ5IGludG8gdGhlIGNhbnZhcy4gIFJlbmRlcmluZyBpcyBpbW1lZGlhdGUgYW5kXG4gICAqIHVzZXMgdGhlIGN1cnJlbnQgc3R5bGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9NdWx0aVBvbHlnb24uanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgTXVsdGlQb2x5Z29uIGdlb21ldHJ5LlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIENhbnZhc0ltbWVkaWF0ZVJlbmRlcmVyLnByb3RvdHlwZS5kcmF3TXVsdGlQb2x5Z29uID0gZnVuY3Rpb24gZHJhd011bHRpUG9seWdvbiAoZ2VvbWV0cnkpIHtcbiAgICBpZiAoIWludGVyc2VjdHModGhpcy5leHRlbnRfLCBnZW9tZXRyeS5nZXRFeHRlbnQoKSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3Ryb2tlU3RhdGVfIHx8IHRoaXMuZmlsbFN0YXRlXykge1xuICAgICAgaWYgKHRoaXMuZmlsbFN0YXRlXykge1xuICAgICAgICB0aGlzLnNldENvbnRleHRGaWxsU3RhdGVfKHRoaXMuZmlsbFN0YXRlXyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdHJva2VTdGF0ZV8pIHtcbiAgICAgICAgdGhpcy5zZXRDb250ZXh0U3Ryb2tlU3RhdGVfKHRoaXMuc3Ryb2tlU3RhdGVfKTtcbiAgICAgIH1cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0XztcbiAgICAgIHZhciBmbGF0Q29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRPcmllbnRlZEZsYXRDb29yZGluYXRlcygpO1xuICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICB2YXIgZW5kc3MgPSBnZW9tZXRyeS5nZXRFbmRzcygpO1xuICAgICAgdmFyIHN0cmlkZSA9IGdlb21ldHJ5LmdldFN0cmlkZSgpO1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGVuZHNzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgdmFyIGVuZHMgPSBlbmRzc1tpXTtcbiAgICAgICAgb2Zmc2V0ID0gdGhpcy5kcmF3UmluZ3NfKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLCBzdHJpZGUpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZmlsbFN0YXRlXykge1xuICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0cm9rZVN0YXRlXykge1xuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy50ZXh0XyAhPT0gJycpIHtcbiAgICAgIHZhciBmbGF0SW50ZXJpb3JQb2ludHMgPSBnZW9tZXRyeS5nZXRGbGF0SW50ZXJpb3JQb2ludHMoKTtcbiAgICAgIHRoaXMuZHJhd1RleHRfKGZsYXRJbnRlcmlvclBvaW50cywgMCwgZmxhdEludGVyaW9yUG9pbnRzLmxlbmd0aCwgMik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5GaWxsU3RhdGV9IGZpbGxTdGF0ZSBGaWxsIHN0YXRlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQ2FudmFzSW1tZWRpYXRlUmVuZGVyZXIucHJvdG90eXBlLnNldENvbnRleHRGaWxsU3RhdGVfID0gZnVuY3Rpb24gc2V0Q29udGV4dEZpbGxTdGF0ZV8gKGZpbGxTdGF0ZSkge1xuICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0XztcbiAgICB2YXIgY29udGV4dEZpbGxTdGF0ZSA9IHRoaXMuY29udGV4dEZpbGxTdGF0ZV87XG4gICAgaWYgKCFjb250ZXh0RmlsbFN0YXRlKSB7XG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGZpbGxTdGF0ZS5maWxsU3R5bGU7XG4gICAgICB0aGlzLmNvbnRleHRGaWxsU3RhdGVfID0ge1xuICAgICAgICBmaWxsU3R5bGU6IGZpbGxTdGF0ZS5maWxsU3R5bGVcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjb250ZXh0RmlsbFN0YXRlLmZpbGxTdHlsZSAhPSBmaWxsU3RhdGUuZmlsbFN0eWxlKSB7XG4gICAgICAgIGNvbnRleHRGaWxsU3RhdGUuZmlsbFN0eWxlID0gY29udGV4dC5maWxsU3R5bGUgPSBmaWxsU3RhdGUuZmlsbFN0eWxlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuU3Ryb2tlU3RhdGV9IHN0cm9rZVN0YXRlIFN0cm9rZSBzdGF0ZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIENhbnZhc0ltbWVkaWF0ZVJlbmRlcmVyLnByb3RvdHlwZS5zZXRDb250ZXh0U3Ryb2tlU3RhdGVfID0gZnVuY3Rpb24gc2V0Q29udGV4dFN0cm9rZVN0YXRlXyAoc3Ryb2tlU3RhdGUpIHtcbiAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dF87XG4gICAgdmFyIGNvbnRleHRTdHJva2VTdGF0ZSA9IHRoaXMuY29udGV4dFN0cm9rZVN0YXRlXztcbiAgICBpZiAoIWNvbnRleHRTdHJva2VTdGF0ZSkge1xuICAgICAgY29udGV4dC5saW5lQ2FwID0gLyoqIEB0eXBlIHtDYW52YXNMaW5lQ2FwfSAqLyAoc3Ryb2tlU3RhdGUubGluZUNhcCk7XG4gICAgICBpZiAoQ0FOVkFTX0xJTkVfREFTSCkge1xuICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKHN0cm9rZVN0YXRlLmxpbmVEYXNoKTtcbiAgICAgICAgY29udGV4dC5saW5lRGFzaE9mZnNldCA9IHN0cm9rZVN0YXRlLmxpbmVEYXNoT2Zmc2V0O1xuICAgICAgfVxuICAgICAgY29udGV4dC5saW5lSm9pbiA9IC8qKiBAdHlwZSB7Q2FudmFzTGluZUpvaW59ICovIChzdHJva2VTdGF0ZS5saW5lSm9pbik7XG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHN0cm9rZVN0YXRlLmxpbmVXaWR0aDtcbiAgICAgIGNvbnRleHQubWl0ZXJMaW1pdCA9IHN0cm9rZVN0YXRlLm1pdGVyTGltaXQ7XG4gICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gc3Ryb2tlU3RhdGUuc3Ryb2tlU3R5bGU7XG4gICAgICB0aGlzLmNvbnRleHRTdHJva2VTdGF0ZV8gPSB7XG4gICAgICAgIGxpbmVDYXA6IHN0cm9rZVN0YXRlLmxpbmVDYXAsXG4gICAgICAgIGxpbmVEYXNoOiBzdHJva2VTdGF0ZS5saW5lRGFzaCxcbiAgICAgICAgbGluZURhc2hPZmZzZXQ6IHN0cm9rZVN0YXRlLmxpbmVEYXNoT2Zmc2V0LFxuICAgICAgICBsaW5lSm9pbjogc3Ryb2tlU3RhdGUubGluZUpvaW4sXG4gICAgICAgIGxpbmVXaWR0aDogc3Ryb2tlU3RhdGUubGluZVdpZHRoLFxuICAgICAgICBtaXRlckxpbWl0OiBzdHJva2VTdGF0ZS5taXRlckxpbWl0LFxuICAgICAgICBzdHJva2VTdHlsZTogc3Ryb2tlU3RhdGUuc3Ryb2tlU3R5bGVcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjb250ZXh0U3Ryb2tlU3RhdGUubGluZUNhcCAhPSBzdHJva2VTdGF0ZS5saW5lQ2FwKSB7XG4gICAgICAgIGNvbnRleHRTdHJva2VTdGF0ZS5saW5lQ2FwID0gY29udGV4dC5saW5lQ2FwID0gLyoqIEB0eXBlIHtDYW52YXNMaW5lQ2FwfSAqLyAoc3Ryb2tlU3RhdGUubGluZUNhcCk7XG4gICAgICB9XG4gICAgICBpZiAoQ0FOVkFTX0xJTkVfREFTSCkge1xuICAgICAgICBpZiAoIWVxdWFscyhjb250ZXh0U3Ryb2tlU3RhdGUubGluZURhc2gsIHN0cm9rZVN0YXRlLmxpbmVEYXNoKSkge1xuICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goY29udGV4dFN0cm9rZVN0YXRlLmxpbmVEYXNoID0gc3Ryb2tlU3RhdGUubGluZURhc2gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZXh0U3Ryb2tlU3RhdGUubGluZURhc2hPZmZzZXQgIT0gc3Ryb2tlU3RhdGUubGluZURhc2hPZmZzZXQpIHtcbiAgICAgICAgICBjb250ZXh0U3Ryb2tlU3RhdGUubGluZURhc2hPZmZzZXQgPSBjb250ZXh0LmxpbmVEYXNoT2Zmc2V0ID1cbiAgICAgICAgICAgICAgc3Ryb2tlU3RhdGUubGluZURhc2hPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb250ZXh0U3Ryb2tlU3RhdGUubGluZUpvaW4gIT0gc3Ryb2tlU3RhdGUubGluZUpvaW4pIHtcbiAgICAgICAgY29udGV4dFN0cm9rZVN0YXRlLmxpbmVKb2luID0gY29udGV4dC5saW5lSm9pbiA9IC8qKiBAdHlwZSB7Q2FudmFzTGluZUpvaW59ICovIChzdHJva2VTdGF0ZS5saW5lSm9pbik7XG4gICAgICB9XG4gICAgICBpZiAoY29udGV4dFN0cm9rZVN0YXRlLmxpbmVXaWR0aCAhPSBzdHJva2VTdGF0ZS5saW5lV2lkdGgpIHtcbiAgICAgICAgY29udGV4dFN0cm9rZVN0YXRlLmxpbmVXaWR0aCA9IGNvbnRleHQubGluZVdpZHRoID0gc3Ryb2tlU3RhdGUubGluZVdpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnRleHRTdHJva2VTdGF0ZS5taXRlckxpbWl0ICE9IHN0cm9rZVN0YXRlLm1pdGVyTGltaXQpIHtcbiAgICAgICAgY29udGV4dFN0cm9rZVN0YXRlLm1pdGVyTGltaXQgPSBjb250ZXh0Lm1pdGVyTGltaXQgPVxuICAgICAgICAgICAgc3Ryb2tlU3RhdGUubWl0ZXJMaW1pdDtcbiAgICAgIH1cbiAgICAgIGlmIChjb250ZXh0U3Ryb2tlU3RhdGUuc3Ryb2tlU3R5bGUgIT0gc3Ryb2tlU3RhdGUuc3Ryb2tlU3R5bGUpIHtcbiAgICAgICAgY29udGV4dFN0cm9rZVN0YXRlLnN0cm9rZVN0eWxlID0gY29udGV4dC5zdHJva2VTdHlsZSA9XG4gICAgICAgICAgICBzdHJva2VTdGF0ZS5zdHJva2VTdHlsZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLlRleHRTdGF0ZX0gdGV4dFN0YXRlIFRleHQgc3RhdGUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBDYW52YXNJbW1lZGlhdGVSZW5kZXJlci5wcm90b3R5cGUuc2V0Q29udGV4dFRleHRTdGF0ZV8gPSBmdW5jdGlvbiBzZXRDb250ZXh0VGV4dFN0YXRlXyAodGV4dFN0YXRlKSB7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHRfO1xuICAgIHZhciBjb250ZXh0VGV4dFN0YXRlID0gdGhpcy5jb250ZXh0VGV4dFN0YXRlXztcbiAgICB2YXIgdGV4dEFsaWduID0gdGV4dFN0YXRlLnRleHRBbGlnbiA/XG4gICAgICB0ZXh0U3RhdGUudGV4dEFsaWduIDogZGVmYXVsdFRleHRBbGlnbjtcbiAgICBpZiAoIWNvbnRleHRUZXh0U3RhdGUpIHtcbiAgICAgIGNvbnRleHQuZm9udCA9IHRleHRTdGF0ZS5mb250O1xuICAgICAgY29udGV4dC50ZXh0QWxpZ24gPSAvKiogQHR5cGUge0NhbnZhc1RleHRBbGlnbn0gKi8gKHRleHRBbGlnbik7XG4gICAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9IC8qKiBAdHlwZSB7Q2FudmFzVGV4dEJhc2VsaW5lfSAqLyAodGV4dFN0YXRlLnRleHRCYXNlbGluZSk7XG4gICAgICB0aGlzLmNvbnRleHRUZXh0U3RhdGVfID0ge1xuICAgICAgICBmb250OiB0ZXh0U3RhdGUuZm9udCxcbiAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICAgIHRleHRCYXNlbGluZTogdGV4dFN0YXRlLnRleHRCYXNlbGluZVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNvbnRleHRUZXh0U3RhdGUuZm9udCAhPSB0ZXh0U3RhdGUuZm9udCkge1xuICAgICAgICBjb250ZXh0VGV4dFN0YXRlLmZvbnQgPSBjb250ZXh0LmZvbnQgPSB0ZXh0U3RhdGUuZm9udDtcbiAgICAgIH1cbiAgICAgIGlmIChjb250ZXh0VGV4dFN0YXRlLnRleHRBbGlnbiAhPSB0ZXh0QWxpZ24pIHtcbiAgICAgICAgY29udGV4dFRleHRTdGF0ZS50ZXh0QWxpZ24gPSBjb250ZXh0LnRleHRBbGlnbiA9IC8qKiBAdHlwZSB7Q2FudmFzVGV4dEFsaWdufSAqLyAodGV4dEFsaWduKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb250ZXh0VGV4dFN0YXRlLnRleHRCYXNlbGluZSAhPSB0ZXh0U3RhdGUudGV4dEJhc2VsaW5lKSB7XG4gICAgICAgIGNvbnRleHRUZXh0U3RhdGUudGV4dEJhc2VsaW5lID0gY29udGV4dC50ZXh0QmFzZWxpbmUgPVxuICAgICAgICAgIC8qKiBAdHlwZSB7Q2FudmFzVGV4dEJhc2VsaW5lfSAqLyAodGV4dFN0YXRlLnRleHRCYXNlbGluZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGZpbGwgYW5kIHN0cm9rZSBzdHlsZSBmb3Igc3Vic2VxdWVudCBkcmF3IG9wZXJhdGlvbnMuICBUbyBjbGVhclxuICAgKiBlaXRoZXIgZmlsbCBvciBzdHJva2Ugc3R5bGVzLCBwYXNzIG51bGwgZm9yIHRoZSBhcHByb3ByaWF0ZSBwYXJhbWV0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vc3R5bGUvRmlsbC5qc1wiKS5kZWZhdWx0fSBmaWxsU3R5bGUgRmlsbCBzdHlsZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9zdHlsZS9TdHJva2UuanNcIikuZGVmYXVsdH0gc3Ryb2tlU3R5bGUgU3Ryb2tlIHN0eWxlLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIENhbnZhc0ltbWVkaWF0ZVJlbmRlcmVyLnByb3RvdHlwZS5zZXRGaWxsU3Ryb2tlU3R5bGUgPSBmdW5jdGlvbiBzZXRGaWxsU3Ryb2tlU3R5bGUgKGZpbGxTdHlsZSwgc3Ryb2tlU3R5bGUpIHtcbiAgICBpZiAoIWZpbGxTdHlsZSkge1xuICAgICAgdGhpcy5maWxsU3RhdGVfID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGZpbGxTdHlsZUNvbG9yID0gZmlsbFN0eWxlLmdldENvbG9yKCk7XG4gICAgICB0aGlzLmZpbGxTdGF0ZV8gPSB7XG4gICAgICAgIGZpbGxTdHlsZTogYXNDb2xvckxpa2UoZmlsbFN0eWxlQ29sb3IgP1xuICAgICAgICAgIGZpbGxTdHlsZUNvbG9yIDogZGVmYXVsdEZpbGxTdHlsZSlcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICghc3Ryb2tlU3R5bGUpIHtcbiAgICAgIHRoaXMuc3Ryb2tlU3RhdGVfID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0cm9rZVN0eWxlQ29sb3IgPSBzdHJva2VTdHlsZS5nZXRDb2xvcigpO1xuICAgICAgdmFyIHN0cm9rZVN0eWxlTGluZUNhcCA9IHN0cm9rZVN0eWxlLmdldExpbmVDYXAoKTtcbiAgICAgIHZhciBzdHJva2VTdHlsZUxpbmVEYXNoID0gc3Ryb2tlU3R5bGUuZ2V0TGluZURhc2goKTtcbiAgICAgIHZhciBzdHJva2VTdHlsZUxpbmVEYXNoT2Zmc2V0ID0gc3Ryb2tlU3R5bGUuZ2V0TGluZURhc2hPZmZzZXQoKTtcbiAgICAgIHZhciBzdHJva2VTdHlsZUxpbmVKb2luID0gc3Ryb2tlU3R5bGUuZ2V0TGluZUpvaW4oKTtcbiAgICAgIHZhciBzdHJva2VTdHlsZVdpZHRoID0gc3Ryb2tlU3R5bGUuZ2V0V2lkdGgoKTtcbiAgICAgIHZhciBzdHJva2VTdHlsZU1pdGVyTGltaXQgPSBzdHJva2VTdHlsZS5nZXRNaXRlckxpbWl0KCk7XG4gICAgICB0aGlzLnN0cm9rZVN0YXRlXyA9IHtcbiAgICAgICAgbGluZUNhcDogc3Ryb2tlU3R5bGVMaW5lQ2FwICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgIHN0cm9rZVN0eWxlTGluZUNhcCA6IGRlZmF1bHRMaW5lQ2FwLFxuICAgICAgICBsaW5lRGFzaDogc3Ryb2tlU3R5bGVMaW5lRGFzaCA/XG4gICAgICAgICAgc3Ryb2tlU3R5bGVMaW5lRGFzaCA6IGRlZmF1bHRMaW5lRGFzaCxcbiAgICAgICAgbGluZURhc2hPZmZzZXQ6IHN0cm9rZVN0eWxlTGluZURhc2hPZmZzZXQgP1xuICAgICAgICAgIHN0cm9rZVN0eWxlTGluZURhc2hPZmZzZXQgOiBkZWZhdWx0TGluZURhc2hPZmZzZXQsXG4gICAgICAgIGxpbmVKb2luOiBzdHJva2VTdHlsZUxpbmVKb2luICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgIHN0cm9rZVN0eWxlTGluZUpvaW4gOiBkZWZhdWx0TGluZUpvaW4sXG4gICAgICAgIGxpbmVXaWR0aDogdGhpcy5waXhlbFJhdGlvXyAqIChzdHJva2VTdHlsZVdpZHRoICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgIHN0cm9rZVN0eWxlV2lkdGggOiBkZWZhdWx0TGluZVdpZHRoKSxcbiAgICAgICAgbWl0ZXJMaW1pdDogc3Ryb2tlU3R5bGVNaXRlckxpbWl0ICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgIHN0cm9rZVN0eWxlTWl0ZXJMaW1pdCA6IGRlZmF1bHRNaXRlckxpbWl0LFxuICAgICAgICBzdHJva2VTdHlsZTogYXNDb2xvckxpa2Uoc3Ryb2tlU3R5bGVDb2xvciA/XG4gICAgICAgICAgc3Ryb2tlU3R5bGVDb2xvciA6IGRlZmF1bHRTdHJva2VTdHlsZSlcbiAgICAgIH07XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGltYWdlIHN0eWxlIGZvciBzdWJzZXF1ZW50IGRyYXcgb3BlcmF0aW9ucy4gIFBhc3MgbnVsbCB0byByZW1vdmVcbiAgICogdGhlIGltYWdlIHN0eWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3N0eWxlL0ltYWdlLmpzXCIpLmRlZmF1bHR9IGltYWdlU3R5bGUgSW1hZ2Ugc3R5bGUuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgQ2FudmFzSW1tZWRpYXRlUmVuZGVyZXIucHJvdG90eXBlLnNldEltYWdlU3R5bGUgPSBmdW5jdGlvbiBzZXRJbWFnZVN0eWxlIChpbWFnZVN0eWxlKSB7XG4gICAgaWYgKCFpbWFnZVN0eWxlKSB7XG4gICAgICB0aGlzLmltYWdlXyA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpbWFnZUFuY2hvciA9IGltYWdlU3R5bGUuZ2V0QW5jaG9yKCk7XG4gICAgICAvLyBGSVhNRSBwaXhlbCByYXRpb1xuICAgICAgdmFyIGltYWdlSW1hZ2UgPSBpbWFnZVN0eWxlLmdldEltYWdlKDEpO1xuICAgICAgdmFyIGltYWdlT3JpZ2luID0gaW1hZ2VTdHlsZS5nZXRPcmlnaW4oKTtcbiAgICAgIHZhciBpbWFnZVNpemUgPSBpbWFnZVN0eWxlLmdldFNpemUoKTtcbiAgICAgIHRoaXMuaW1hZ2VBbmNob3JYXyA9IGltYWdlQW5jaG9yWzBdO1xuICAgICAgdGhpcy5pbWFnZUFuY2hvcllfID0gaW1hZ2VBbmNob3JbMV07XG4gICAgICB0aGlzLmltYWdlSGVpZ2h0XyA9IGltYWdlU2l6ZVsxXTtcbiAgICAgIHRoaXMuaW1hZ2VfID0gaW1hZ2VJbWFnZTtcbiAgICAgIHRoaXMuaW1hZ2VPcGFjaXR5XyA9IGltYWdlU3R5bGUuZ2V0T3BhY2l0eSgpO1xuICAgICAgdGhpcy5pbWFnZU9yaWdpblhfID0gaW1hZ2VPcmlnaW5bMF07XG4gICAgICB0aGlzLmltYWdlT3JpZ2luWV8gPSBpbWFnZU9yaWdpblsxXTtcbiAgICAgIHRoaXMuaW1hZ2VSb3RhdGVXaXRoVmlld18gPSBpbWFnZVN0eWxlLmdldFJvdGF0ZVdpdGhWaWV3KCk7XG4gICAgICB0aGlzLmltYWdlUm90YXRpb25fID0gaW1hZ2VTdHlsZS5nZXRSb3RhdGlvbigpO1xuICAgICAgdGhpcy5pbWFnZVNjYWxlXyA9IGltYWdlU3R5bGUuZ2V0U2NhbGUoKSAqIHRoaXMucGl4ZWxSYXRpb187XG4gICAgICB0aGlzLmltYWdlV2lkdGhfID0gaW1hZ2VTaXplWzBdO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSB0ZXh0IHN0eWxlIGZvciBzdWJzZXF1ZW50IGRyYXcgb3BlcmF0aW9ucy4gIFBhc3MgbnVsbCB0b1xuICAgKiByZW1vdmUgdGhlIHRleHQgc3R5bGUuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vc3R5bGUvVGV4dC5qc1wiKS5kZWZhdWx0fSB0ZXh0U3R5bGUgVGV4dCBzdHlsZS5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBDYW52YXNJbW1lZGlhdGVSZW5kZXJlci5wcm90b3R5cGUuc2V0VGV4dFN0eWxlID0gZnVuY3Rpb24gc2V0VGV4dFN0eWxlICh0ZXh0U3R5bGUpIHtcbiAgICBpZiAoIXRleHRTdHlsZSkge1xuICAgICAgdGhpcy50ZXh0XyA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdGV4dEZpbGxTdHlsZSA9IHRleHRTdHlsZS5nZXRGaWxsKCk7XG4gICAgICBpZiAoIXRleHRGaWxsU3R5bGUpIHtcbiAgICAgICAgdGhpcy50ZXh0RmlsbFN0YXRlXyA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdGV4dEZpbGxTdHlsZUNvbG9yID0gdGV4dEZpbGxTdHlsZS5nZXRDb2xvcigpO1xuICAgICAgICB0aGlzLnRleHRGaWxsU3RhdGVfID0ge1xuICAgICAgICAgIGZpbGxTdHlsZTogYXNDb2xvckxpa2UodGV4dEZpbGxTdHlsZUNvbG9yID9cbiAgICAgICAgICAgIHRleHRGaWxsU3R5bGVDb2xvciA6IGRlZmF1bHRGaWxsU3R5bGUpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YXIgdGV4dFN0cm9rZVN0eWxlID0gdGV4dFN0eWxlLmdldFN0cm9rZSgpO1xuICAgICAgaWYgKCF0ZXh0U3Ryb2tlU3R5bGUpIHtcbiAgICAgICAgdGhpcy50ZXh0U3Ryb2tlU3RhdGVfID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0ZXh0U3Ryb2tlU3R5bGVDb2xvciA9IHRleHRTdHJva2VTdHlsZS5nZXRDb2xvcigpO1xuICAgICAgICB2YXIgdGV4dFN0cm9rZVN0eWxlTGluZUNhcCA9IHRleHRTdHJva2VTdHlsZS5nZXRMaW5lQ2FwKCk7XG4gICAgICAgIHZhciB0ZXh0U3Ryb2tlU3R5bGVMaW5lRGFzaCA9IHRleHRTdHJva2VTdHlsZS5nZXRMaW5lRGFzaCgpO1xuICAgICAgICB2YXIgdGV4dFN0cm9rZVN0eWxlTGluZURhc2hPZmZzZXQgPSB0ZXh0U3Ryb2tlU3R5bGUuZ2V0TGluZURhc2hPZmZzZXQoKTtcbiAgICAgICAgdmFyIHRleHRTdHJva2VTdHlsZUxpbmVKb2luID0gdGV4dFN0cm9rZVN0eWxlLmdldExpbmVKb2luKCk7XG4gICAgICAgIHZhciB0ZXh0U3Ryb2tlU3R5bGVXaWR0aCA9IHRleHRTdHJva2VTdHlsZS5nZXRXaWR0aCgpO1xuICAgICAgICB2YXIgdGV4dFN0cm9rZVN0eWxlTWl0ZXJMaW1pdCA9IHRleHRTdHJva2VTdHlsZS5nZXRNaXRlckxpbWl0KCk7XG4gICAgICAgIHRoaXMudGV4dFN0cm9rZVN0YXRlXyA9IHtcbiAgICAgICAgICBsaW5lQ2FwOiB0ZXh0U3Ryb2tlU3R5bGVMaW5lQ2FwICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgdGV4dFN0cm9rZVN0eWxlTGluZUNhcCA6IGRlZmF1bHRMaW5lQ2FwLFxuICAgICAgICAgIGxpbmVEYXNoOiB0ZXh0U3Ryb2tlU3R5bGVMaW5lRGFzaCA/XG4gICAgICAgICAgICB0ZXh0U3Ryb2tlU3R5bGVMaW5lRGFzaCA6IGRlZmF1bHRMaW5lRGFzaCxcbiAgICAgICAgICBsaW5lRGFzaE9mZnNldDogdGV4dFN0cm9rZVN0eWxlTGluZURhc2hPZmZzZXQgP1xuICAgICAgICAgICAgdGV4dFN0cm9rZVN0eWxlTGluZURhc2hPZmZzZXQgOiBkZWZhdWx0TGluZURhc2hPZmZzZXQsXG4gICAgICAgICAgbGluZUpvaW46IHRleHRTdHJva2VTdHlsZUxpbmVKb2luICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgdGV4dFN0cm9rZVN0eWxlTGluZUpvaW4gOiBkZWZhdWx0TGluZUpvaW4sXG4gICAgICAgICAgbGluZVdpZHRoOiB0ZXh0U3Ryb2tlU3R5bGVXaWR0aCAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIHRleHRTdHJva2VTdHlsZVdpZHRoIDogZGVmYXVsdExpbmVXaWR0aCxcbiAgICAgICAgICBtaXRlckxpbWl0OiB0ZXh0U3Ryb2tlU3R5bGVNaXRlckxpbWl0ICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgdGV4dFN0cm9rZVN0eWxlTWl0ZXJMaW1pdCA6IGRlZmF1bHRNaXRlckxpbWl0LFxuICAgICAgICAgIHN0cm9rZVN0eWxlOiBhc0NvbG9yTGlrZSh0ZXh0U3Ryb2tlU3R5bGVDb2xvciA/XG4gICAgICAgICAgICB0ZXh0U3Ryb2tlU3R5bGVDb2xvciA6IGRlZmF1bHRTdHJva2VTdHlsZSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHZhciB0ZXh0Rm9udCA9IHRleHRTdHlsZS5nZXRGb250KCk7XG4gICAgICB2YXIgdGV4dE9mZnNldFggPSB0ZXh0U3R5bGUuZ2V0T2Zmc2V0WCgpO1xuICAgICAgdmFyIHRleHRPZmZzZXRZID0gdGV4dFN0eWxlLmdldE9mZnNldFkoKTtcbiAgICAgIHZhciB0ZXh0Um90YXRlV2l0aFZpZXcgPSB0ZXh0U3R5bGUuZ2V0Um90YXRlV2l0aFZpZXcoKTtcbiAgICAgIHZhciB0ZXh0Um90YXRpb24gPSB0ZXh0U3R5bGUuZ2V0Um90YXRpb24oKTtcbiAgICAgIHZhciB0ZXh0U2NhbGUgPSB0ZXh0U3R5bGUuZ2V0U2NhbGUoKTtcbiAgICAgIHZhciB0ZXh0VGV4dCA9IHRleHRTdHlsZS5nZXRUZXh0KCk7XG4gICAgICB2YXIgdGV4dFRleHRBbGlnbiA9IHRleHRTdHlsZS5nZXRUZXh0QWxpZ24oKTtcbiAgICAgIHZhciB0ZXh0VGV4dEJhc2VsaW5lID0gdGV4dFN0eWxlLmdldFRleHRCYXNlbGluZSgpO1xuICAgICAgdGhpcy50ZXh0U3RhdGVfID0ge1xuICAgICAgICBmb250OiB0ZXh0Rm9udCAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICB0ZXh0Rm9udCA6IGRlZmF1bHRGb250LFxuICAgICAgICB0ZXh0QWxpZ246IHRleHRUZXh0QWxpZ24gIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgdGV4dFRleHRBbGlnbiA6IGRlZmF1bHRUZXh0QWxpZ24sXG4gICAgICAgIHRleHRCYXNlbGluZTogdGV4dFRleHRCYXNlbGluZSAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICB0ZXh0VGV4dEJhc2VsaW5lIDogZGVmYXVsdFRleHRCYXNlbGluZVxuICAgICAgfTtcbiAgICAgIHRoaXMudGV4dF8gPSB0ZXh0VGV4dCAhPT0gdW5kZWZpbmVkID8gdGV4dFRleHQgOiAnJztcbiAgICAgIHRoaXMudGV4dE9mZnNldFhfID1cbiAgICAgICAgICB0ZXh0T2Zmc2V0WCAhPT0gdW5kZWZpbmVkID8gKHRoaXMucGl4ZWxSYXRpb18gKiB0ZXh0T2Zmc2V0WCkgOiAwO1xuICAgICAgdGhpcy50ZXh0T2Zmc2V0WV8gPVxuICAgICAgICAgIHRleHRPZmZzZXRZICE9PSB1bmRlZmluZWQgPyAodGhpcy5waXhlbFJhdGlvXyAqIHRleHRPZmZzZXRZKSA6IDA7XG4gICAgICB0aGlzLnRleHRSb3RhdGVXaXRoVmlld18gPSB0ZXh0Um90YXRlV2l0aFZpZXcgIT09IHVuZGVmaW5lZCA/IHRleHRSb3RhdGVXaXRoVmlldyA6IGZhbHNlO1xuICAgICAgdGhpcy50ZXh0Um90YXRpb25fID0gdGV4dFJvdGF0aW9uICE9PSB1bmRlZmluZWQgPyB0ZXh0Um90YXRpb24gOiAwO1xuICAgICAgdGhpcy50ZXh0U2NhbGVfID0gdGhpcy5waXhlbFJhdGlvXyAqICh0ZXh0U2NhbGUgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgIHRleHRTY2FsZSA6IDEpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gQ2FudmFzSW1tZWRpYXRlUmVuZGVyZXI7XG59KFZlY3RvckNvbnRleHQpKTtcblxuXG5leHBvcnQgZGVmYXVsdCBDYW52YXNJbW1lZGlhdGVSZW5kZXJlcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW1tZWRpYXRlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXIvY2FudmFzL0luc3RydWN0aW9uXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG52YXIgSW5zdHJ1Y3Rpb24gPSB7XG4gIEJFR0lOX0dFT01FVFJZOiAwLFxuICBCRUdJTl9QQVRIOiAxLFxuICBDSVJDTEU6IDIsXG4gIENMT1NFX1BBVEg6IDMsXG4gIENVU1RPTTogNCxcbiAgRFJBV19DSEFSUzogNSxcbiAgRFJBV19JTUFHRTogNixcbiAgRU5EX0dFT01FVFJZOiA3LFxuICBGSUxMOiA4LFxuICBNT1ZFX1RPX0xJTkVfVE86IDksXG4gIFNFVF9GSUxMX1NUWUxFOiAxMCxcbiAgU0VUX1NUUk9LRV9TVFlMRTogMTEsXG4gIFNUUk9LRTogMTJcbn07XG5cblxuLyoqXG4gKiBAdHlwZSB7QXJyYXk8SW5zdHJ1Y3Rpb24+fVxuICovXG5leHBvcnQgdmFyIGZpbGxJbnN0cnVjdGlvbiA9IFtJbnN0cnVjdGlvbi5GSUxMXTtcblxuXG4vKipcbiAqIEB0eXBlIHtBcnJheTxJbnN0cnVjdGlvbj59XG4gKi9cbmV4cG9ydCB2YXIgc3Ryb2tlSW5zdHJ1Y3Rpb24gPSBbSW5zdHJ1Y3Rpb24uU1RST0tFXTtcblxuXG4vKipcbiAqIEB0eXBlIHtBcnJheTxJbnN0cnVjdGlvbj59XG4gKi9cbmV4cG9ydCB2YXIgYmVnaW5QYXRoSW5zdHJ1Y3Rpb24gPSBbSW5zdHJ1Y3Rpb24uQkVHSU5fUEFUSF07XG5cblxuLyoqXG4gKiBAdHlwZSB7QXJyYXk8SW5zdHJ1Y3Rpb24+fVxuICovXG5leHBvcnQgdmFyIGNsb3NlUGF0aEluc3RydWN0aW9uID0gW0luc3RydWN0aW9uLkNMT1NFX1BBVEhdO1xuXG5cbmV4cG9ydCBkZWZhdWx0IEluc3RydWN0aW9uO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbnN0cnVjdGlvbi5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyL2NhbnZhcy9MaW5lU3RyaW5nUmVwbGF5XG4gKi9cbmltcG9ydCBDYW52YXNJbnN0cnVjdGlvbiwge3N0cm9rZUluc3RydWN0aW9uLCBiZWdpblBhdGhJbnN0cnVjdGlvbn0gZnJvbSAnLi9JbnN0cnVjdGlvbi5qcyc7XG5pbXBvcnQgQ2FudmFzUmVwbGF5IGZyb20gJy4vUmVwbGF5LmpzJztcblxudmFyIENhbnZhc0xpbmVTdHJpbmdSZXBsYXkgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChDYW52YXNSZXBsYXkpIHtcbiAgZnVuY3Rpb24gQ2FudmFzTGluZVN0cmluZ1JlcGxheSh0b2xlcmFuY2UsIG1heEV4dGVudCwgcmVzb2x1dGlvbiwgcGl4ZWxSYXRpbywgb3ZlcmxhcHMsIGRlY2x1dHRlclRyZWUpIHtcbiAgICBDYW52YXNSZXBsYXkuY2FsbCh0aGlzLCB0b2xlcmFuY2UsIG1heEV4dGVudCwgcmVzb2x1dGlvbiwgcGl4ZWxSYXRpbywgb3ZlcmxhcHMsIGRlY2x1dHRlclRyZWUpO1xuICB9XG5cbiAgaWYgKCBDYW52YXNSZXBsYXkgKSBDYW52YXNMaW5lU3RyaW5nUmVwbGF5Ll9fcHJvdG9fXyA9IENhbnZhc1JlcGxheTtcbiAgQ2FudmFzTGluZVN0cmluZ1JlcGxheS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDYW52YXNSZXBsYXkgJiYgQ2FudmFzUmVwbGF5LnByb3RvdHlwZSApO1xuICBDYW52YXNMaW5lU3RyaW5nUmVwbGF5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhbnZhc0xpbmVTdHJpbmdSZXBsYXk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge251bWJlcn0gZW5kLlxuICAgKi9cbiAgQ2FudmFzTGluZVN0cmluZ1JlcGxheS5wcm90b3R5cGUuZHJhd0ZsYXRDb29yZGluYXRlc18gPSBmdW5jdGlvbiBkcmF3RmxhdENvb3JkaW5hdGVzXyAoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKSB7XG4gICAgdmFyIG15QmVnaW4gPSB0aGlzLmNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICB2YXIgbXlFbmQgPSB0aGlzLmFwcGVuZEZsYXRDb29yZGluYXRlcyhcbiAgICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgZmFsc2UsIGZhbHNlKTtcbiAgICB2YXIgbW92ZVRvTGluZVRvSW5zdHJ1Y3Rpb24gPSBbQ2FudmFzSW5zdHJ1Y3Rpb24uTU9WRV9UT19MSU5FX1RPLCBteUJlZ2luLCBteUVuZF07XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChtb3ZlVG9MaW5lVG9JbnN0cnVjdGlvbik7XG4gICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChtb3ZlVG9MaW5lVG9JbnN0cnVjdGlvbik7XG4gICAgcmV0dXJuIGVuZDtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENhbnZhc0xpbmVTdHJpbmdSZXBsYXkucHJvdG90eXBlLmRyYXdMaW5lU3RyaW5nID0gZnVuY3Rpb24gZHJhd0xpbmVTdHJpbmcgKGxpbmVTdHJpbmdHZW9tZXRyeSwgZmVhdHVyZSkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgdmFyIHN0cm9rZVN0eWxlID0gc3RhdGUuc3Ryb2tlU3R5bGU7XG4gICAgdmFyIGxpbmVXaWR0aCA9IHN0YXRlLmxpbmVXaWR0aDtcbiAgICBpZiAoc3Ryb2tlU3R5bGUgPT09IHVuZGVmaW5lZCB8fCBsaW5lV2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVN0cm9rZVN0eWxlKHN0YXRlLCB0aGlzLmFwcGx5U3Ryb2tlKTtcbiAgICB0aGlzLmJlZ2luR2VvbWV0cnkobGluZVN0cmluZ0dlb21ldHJ5LCBmZWF0dXJlKTtcbiAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKFtcbiAgICAgIENhbnZhc0luc3RydWN0aW9uLlNFVF9TVFJPS0VfU1RZTEUsXG4gICAgICBzdGF0ZS5zdHJva2VTdHlsZSwgc3RhdGUubGluZVdpZHRoLCBzdGF0ZS5saW5lQ2FwLCBzdGF0ZS5saW5lSm9pbixcbiAgICAgIHN0YXRlLm1pdGVyTGltaXQsIHN0YXRlLmxpbmVEYXNoLCBzdGF0ZS5saW5lRGFzaE9mZnNldFxuICAgIF0sIGJlZ2luUGF0aEluc3RydWN0aW9uKTtcbiAgICB2YXIgZmxhdENvb3JkaW5hdGVzID0gbGluZVN0cmluZ0dlb21ldHJ5LmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgIHZhciBzdHJpZGUgPSBsaW5lU3RyaW5nR2VvbWV0cnkuZ2V0U3RyaWRlKCk7XG4gICAgdGhpcy5kcmF3RmxhdENvb3JkaW5hdGVzXyhmbGF0Q29vcmRpbmF0ZXMsIDAsIGZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHN0cmlkZSk7XG4gICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChzdHJva2VJbnN0cnVjdGlvbik7XG4gICAgdGhpcy5lbmRHZW9tZXRyeShsaW5lU3RyaW5nR2VvbWV0cnksIGZlYXR1cmUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQ2FudmFzTGluZVN0cmluZ1JlcGxheS5wcm90b3R5cGUuZHJhd011bHRpTGluZVN0cmluZyA9IGZ1bmN0aW9uIGRyYXdNdWx0aUxpbmVTdHJpbmcgKG11bHRpTGluZVN0cmluZ0dlb21ldHJ5LCBmZWF0dXJlKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB2YXIgc3Ryb2tlU3R5bGUgPSBzdGF0ZS5zdHJva2VTdHlsZTtcbiAgICB2YXIgbGluZVdpZHRoID0gc3RhdGUubGluZVdpZHRoO1xuICAgIGlmIChzdHJva2VTdHlsZSA9PT0gdW5kZWZpbmVkIHx8IGxpbmVXaWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudXBkYXRlU3Ryb2tlU3R5bGUoc3RhdGUsIHRoaXMuYXBwbHlTdHJva2UpO1xuICAgIHRoaXMuYmVnaW5HZW9tZXRyeShtdWx0aUxpbmVTdHJpbmdHZW9tZXRyeSwgZmVhdHVyZSk7XG4gICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChbXG4gICAgICBDYW52YXNJbnN0cnVjdGlvbi5TRVRfU1RST0tFX1NUWUxFLFxuICAgICAgc3RhdGUuc3Ryb2tlU3R5bGUsIHN0YXRlLmxpbmVXaWR0aCwgc3RhdGUubGluZUNhcCwgc3RhdGUubGluZUpvaW4sXG4gICAgICBzdGF0ZS5taXRlckxpbWl0LCBzdGF0ZS5saW5lRGFzaCwgc3RhdGUubGluZURhc2hPZmZzZXRcbiAgICBdLCBiZWdpblBhdGhJbnN0cnVjdGlvbik7XG4gICAgdmFyIGVuZHMgPSBtdWx0aUxpbmVTdHJpbmdHZW9tZXRyeS5nZXRFbmRzKCk7XG4gICAgdmFyIGZsYXRDb29yZGluYXRlcyA9IG11bHRpTGluZVN0cmluZ0dlb21ldHJ5LmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgIHZhciBzdHJpZGUgPSBtdWx0aUxpbmVTdHJpbmdHZW9tZXRyeS5nZXRTdHJpZGUoKTtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIG9mZnNldCA9IHRoaXMuZHJhd0ZsYXRDb29yZGluYXRlc18oZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHNbaV0sIHN0cmlkZSk7XG4gICAgfVxuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goc3Ryb2tlSW5zdHJ1Y3Rpb24pO1xuICAgIHRoaXMuZW5kR2VvbWV0cnkobXVsdGlMaW5lU3RyaW5nR2VvbWV0cnksIGZlYXR1cmUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQ2FudmFzTGluZVN0cmluZ1JlcGxheS5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gZmluaXNoICgpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGlmIChzdGF0ZS5sYXN0U3Ryb2tlICE9IHVuZGVmaW5lZCAmJiBzdGF0ZS5sYXN0U3Ryb2tlICE9IHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKHN0cm9rZUluc3RydWN0aW9uKTtcbiAgICB9XG4gICAgdGhpcy5yZXZlcnNlSGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zKCk7XG4gICAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jLlxuICAgKi9cbiAgQ2FudmFzTGluZVN0cmluZ1JlcGxheS5wcm90b3R5cGUuYXBwbHlTdHJva2UgPSBmdW5jdGlvbiBhcHBseVN0cm9rZSAoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUubGFzdFN0cm9rZSAhPSB1bmRlZmluZWQgJiYgc3RhdGUubGFzdFN0cm9rZSAhPSB0aGlzLmNvb3JkaW5hdGVzLmxlbmd0aCkge1xuICAgICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChzdHJva2VJbnN0cnVjdGlvbik7XG4gICAgICBzdGF0ZS5sYXN0U3Ryb2tlID0gdGhpcy5jb29yZGluYXRlcy5sZW5ndGg7XG4gICAgfVxuICAgIHN0YXRlLmxhc3RTdHJva2UgPSAwO1xuICAgIENhbnZhc1JlcGxheS5wcm90b3R5cGUuYXBwbHlTdHJva2UuY2FsbCh0aGlzLCBzdGF0ZSk7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChiZWdpblBhdGhJbnN0cnVjdGlvbik7XG4gIH07XG5cbiAgcmV0dXJuIENhbnZhc0xpbmVTdHJpbmdSZXBsYXk7XG59KENhbnZhc1JlcGxheSkpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IENhbnZhc0xpbmVTdHJpbmdSZXBsYXk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxpbmVTdHJpbmdSZXBsYXkuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9jYW52YXMvUG9seWdvblJlcGxheVxuICovXG5pbXBvcnQge2FzU3RyaW5nfSBmcm9tICcuLi8uLi9jb2xvci5qcyc7XG5pbXBvcnQge3NuYXB9IGZyb20gJy4uLy4uL2dlb20vZmxhdC9zaW1wbGlmeS5qcyc7XG5pbXBvcnQge2RlZmF1bHRGaWxsU3R5bGV9IGZyb20gJy4uL2NhbnZhcy5qcyc7XG5pbXBvcnQgQ2FudmFzSW5zdHJ1Y3Rpb24sIHtcbiAgZmlsbEluc3RydWN0aW9uLCBzdHJva2VJbnN0cnVjdGlvbiwgYmVnaW5QYXRoSW5zdHJ1Y3Rpb24sIGNsb3NlUGF0aEluc3RydWN0aW9uXG59IGZyb20gJy4vSW5zdHJ1Y3Rpb24uanMnO1xuaW1wb3J0IENhbnZhc1JlcGxheSBmcm9tICcuL1JlcGxheS5qcyc7XG5cblxudmFyIENhbnZhc1BvbHlnb25SZXBsYXkgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChDYW52YXNSZXBsYXkpIHtcbiAgZnVuY3Rpb24gQ2FudmFzUG9seWdvblJlcGxheSh0b2xlcmFuY2UsIG1heEV4dGVudCwgcmVzb2x1dGlvbiwgcGl4ZWxSYXRpbywgb3ZlcmxhcHMsIGRlY2x1dHRlclRyZWUpIHtcbiAgICBDYW52YXNSZXBsYXkuY2FsbCh0aGlzLCB0b2xlcmFuY2UsIG1heEV4dGVudCwgcmVzb2x1dGlvbiwgcGl4ZWxSYXRpbywgb3ZlcmxhcHMsIGRlY2x1dHRlclRyZWUpO1xuICB9XG5cbiAgaWYgKCBDYW52YXNSZXBsYXkgKSBDYW52YXNQb2x5Z29uUmVwbGF5Ll9fcHJvdG9fXyA9IENhbnZhc1JlcGxheTtcbiAgQ2FudmFzUG9seWdvblJlcGxheS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDYW52YXNSZXBsYXkgJiYgQ2FudmFzUmVwbGF5LnByb3RvdHlwZSApO1xuICBDYW52YXNQb2x5Z29uUmVwbGF5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhbnZhc1BvbHlnb25SZXBsYXk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGVuZHMgRW5kcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge251bWJlcn0gRW5kLlxuICAgKi9cbiAgQ2FudmFzUG9seWdvblJlcGxheS5wcm90b3R5cGUuZHJhd0ZsYXRDb29yZGluYXRlc3NfID0gZnVuY3Rpb24gZHJhd0ZsYXRDb29yZGluYXRlc3NfIChmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB2YXIgZmlsbCA9IHN0YXRlLmZpbGxTdHlsZSAhPT0gdW5kZWZpbmVkO1xuICAgIHZhciBzdHJva2UgPSBzdGF0ZS5zdHJva2VTdHlsZSAhPSB1bmRlZmluZWQ7XG4gICAgdmFyIG51bUVuZHMgPSBlbmRzLmxlbmd0aDtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKGJlZ2luUGF0aEluc3RydWN0aW9uKTtcbiAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKGJlZ2luUGF0aEluc3RydWN0aW9uKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUVuZHM7ICsraSkge1xuICAgICAgdmFyIGVuZCA9IGVuZHNbaV07XG4gICAgICB2YXIgbXlCZWdpbiA9IHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgICAgdmFyIG15RW5kID0gdGhpcy5hcHBlbmRGbGF0Q29vcmRpbmF0ZXMoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCB0cnVlLCAhc3Ryb2tlKTtcbiAgICAgIHZhciBtb3ZlVG9MaW5lVG9JbnN0cnVjdGlvbiA9IFtDYW52YXNJbnN0cnVjdGlvbi5NT1ZFX1RPX0xJTkVfVE8sIG15QmVnaW4sIG15RW5kXTtcbiAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2gobW92ZVRvTGluZVRvSW5zdHJ1Y3Rpb24pO1xuICAgICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChtb3ZlVG9MaW5lVG9JbnN0cnVjdGlvbik7XG4gICAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICAgIC8vIFBlcmZvcm1hbmNlIG9wdGltaXphdGlvbjogb25seSBjYWxsIGNsb3NlUGF0aCgpIHdoZW4gd2UgaGF2ZSBhIHN0cm9rZS5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHRoZSByaW5nIGlzIGNsb3NlZCBhbHJlYWR5IChzZWUgYXBwZW5kRmxhdENvb3JkaW5hdGVzIGFib3ZlKS5cbiAgICAgICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChjbG9zZVBhdGhJbnN0cnVjdGlvbik7XG4gICAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goY2xvc2VQYXRoSW5zdHJ1Y3Rpb24pO1xuICAgICAgfVxuICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgIH1cbiAgICBpZiAoZmlsbCkge1xuICAgICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChmaWxsSW5zdHJ1Y3Rpb24pO1xuICAgICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChmaWxsSW5zdHJ1Y3Rpb24pO1xuICAgIH1cbiAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKHN0cm9rZUluc3RydWN0aW9uKTtcbiAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goc3Ryb2tlSW5zdHJ1Y3Rpb24pO1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQ2FudmFzUG9seWdvblJlcGxheS5wcm90b3R5cGUuZHJhd0NpcmNsZSA9IGZ1bmN0aW9uIGRyYXdDaXJjbGUgKGNpcmNsZUdlb21ldHJ5LCBmZWF0dXJlKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB2YXIgZmlsbFN0eWxlID0gc3RhdGUuZmlsbFN0eWxlO1xuICAgIHZhciBzdHJva2VTdHlsZSA9IHN0YXRlLnN0cm9rZVN0eWxlO1xuICAgIGlmIChmaWxsU3R5bGUgPT09IHVuZGVmaW5lZCAmJiBzdHJva2VTdHlsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2V0RmlsbFN0cm9rZVN0eWxlc18oY2lyY2xlR2VvbWV0cnkpO1xuICAgIHRoaXMuYmVnaW5HZW9tZXRyeShjaXJjbGVHZW9tZXRyeSwgZmVhdHVyZSk7XG4gICAgaWYgKHN0YXRlLmZpbGxTdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKFtcbiAgICAgICAgQ2FudmFzSW5zdHJ1Y3Rpb24uU0VUX0ZJTExfU1RZTEUsXG4gICAgICAgIGFzU3RyaW5nKGRlZmF1bHRGaWxsU3R5bGUpXG4gICAgICBdKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLnN0cm9rZVN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goW1xuICAgICAgICBDYW52YXNJbnN0cnVjdGlvbi5TRVRfU1RST0tFX1NUWUxFLFxuICAgICAgICBzdGF0ZS5zdHJva2VTdHlsZSwgc3RhdGUubGluZVdpZHRoLCBzdGF0ZS5saW5lQ2FwLCBzdGF0ZS5saW5lSm9pbixcbiAgICAgICAgc3RhdGUubWl0ZXJMaW1pdCwgc3RhdGUubGluZURhc2gsIHN0YXRlLmxpbmVEYXNoT2Zmc2V0XG4gICAgICBdKTtcbiAgICB9XG4gICAgdmFyIGZsYXRDb29yZGluYXRlcyA9IGNpcmNsZUdlb21ldHJ5LmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgIHZhciBzdHJpZGUgPSBjaXJjbGVHZW9tZXRyeS5nZXRTdHJpZGUoKTtcbiAgICB2YXIgbXlCZWdpbiA9IHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIHRoaXMuYXBwZW5kRmxhdENvb3JkaW5hdGVzKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLCAwLCBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLCBzdHJpZGUsIGZhbHNlLCBmYWxzZSk7XG4gICAgdmFyIGNpcmNsZUluc3RydWN0aW9uID0gW0NhbnZhc0luc3RydWN0aW9uLkNJUkNMRSwgbXlCZWdpbl07XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChiZWdpblBhdGhJbnN0cnVjdGlvbiwgY2lyY2xlSW5zdHJ1Y3Rpb24pO1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goYmVnaW5QYXRoSW5zdHJ1Y3Rpb24sIGNpcmNsZUluc3RydWN0aW9uKTtcbiAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKGZpbGxJbnN0cnVjdGlvbik7XG4gICAgaWYgKHN0YXRlLmZpbGxTdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKGZpbGxJbnN0cnVjdGlvbik7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5zdHJva2VTdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKHN0cm9rZUluc3RydWN0aW9uKTtcbiAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goc3Ryb2tlSW5zdHJ1Y3Rpb24pO1xuICAgIH1cbiAgICB0aGlzLmVuZEdlb21ldHJ5KGNpcmNsZUdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENhbnZhc1BvbHlnb25SZXBsYXkucHJvdG90eXBlLmRyYXdQb2x5Z29uID0gZnVuY3Rpb24gZHJhd1BvbHlnb24gKHBvbHlnb25HZW9tZXRyeSwgZmVhdHVyZSkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgdmFyIGZpbGxTdHlsZSA9IHN0YXRlLmZpbGxTdHlsZTtcbiAgICB2YXIgc3Ryb2tlU3R5bGUgPSBzdGF0ZS5zdHJva2VTdHlsZTtcbiAgICBpZiAoZmlsbFN0eWxlID09PSB1bmRlZmluZWQgJiYgc3Ryb2tlU3R5bGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNldEZpbGxTdHJva2VTdHlsZXNfKHBvbHlnb25HZW9tZXRyeSk7XG4gICAgdGhpcy5iZWdpbkdlb21ldHJ5KHBvbHlnb25HZW9tZXRyeSwgZmVhdHVyZSk7XG4gICAgaWYgKHN0YXRlLmZpbGxTdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKFtcbiAgICAgICAgQ2FudmFzSW5zdHJ1Y3Rpb24uU0VUX0ZJTExfU1RZTEUsXG4gICAgICAgIGFzU3RyaW5nKGRlZmF1bHRGaWxsU3R5bGUpXG4gICAgICBdKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLnN0cm9rZVN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goW1xuICAgICAgICBDYW52YXNJbnN0cnVjdGlvbi5TRVRfU1RST0tFX1NUWUxFLFxuICAgICAgICBzdGF0ZS5zdHJva2VTdHlsZSwgc3RhdGUubGluZVdpZHRoLCBzdGF0ZS5saW5lQ2FwLCBzdGF0ZS5saW5lSm9pbixcbiAgICAgICAgc3RhdGUubWl0ZXJMaW1pdCwgc3RhdGUubGluZURhc2gsIHN0YXRlLmxpbmVEYXNoT2Zmc2V0XG4gICAgICBdKTtcbiAgICB9XG4gICAgdmFyIGVuZHMgPSBwb2x5Z29uR2VvbWV0cnkuZ2V0RW5kcygpO1xuICAgIHZhciBmbGF0Q29vcmRpbmF0ZXMgPSBwb2x5Z29uR2VvbWV0cnkuZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICB2YXIgc3RyaWRlID0gcG9seWdvbkdlb21ldHJ5LmdldFN0cmlkZSgpO1xuICAgIHRoaXMuZHJhd0ZsYXRDb29yZGluYXRlc3NfKGZsYXRDb29yZGluYXRlcywgMCwgZW5kcywgc3RyaWRlKTtcbiAgICB0aGlzLmVuZEdlb21ldHJ5KHBvbHlnb25HZW9tZXRyeSwgZmVhdHVyZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNQb2x5Z29uUmVwbGF5LnByb3RvdHlwZS5kcmF3TXVsdGlQb2x5Z29uID0gZnVuY3Rpb24gZHJhd011bHRpUG9seWdvbiAobXVsdGlQb2x5Z29uR2VvbWV0cnksIGZlYXR1cmUpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHZhciBmaWxsU3R5bGUgPSBzdGF0ZS5maWxsU3R5bGU7XG4gICAgdmFyIHN0cm9rZVN0eWxlID0gc3RhdGUuc3Ryb2tlU3R5bGU7XG4gICAgaWYgKGZpbGxTdHlsZSA9PT0gdW5kZWZpbmVkICYmIHN0cm9rZVN0eWxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZXRGaWxsU3Ryb2tlU3R5bGVzXyhtdWx0aVBvbHlnb25HZW9tZXRyeSk7XG4gICAgdGhpcy5iZWdpbkdlb21ldHJ5KG11bHRpUG9seWdvbkdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgICBpZiAoc3RhdGUuZmlsbFN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goW1xuICAgICAgICBDYW52YXNJbnN0cnVjdGlvbi5TRVRfRklMTF9TVFlMRSxcbiAgICAgICAgYXNTdHJpbmcoZGVmYXVsdEZpbGxTdHlsZSlcbiAgICAgIF0pO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuc3Ryb2tlU3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChbXG4gICAgICAgIENhbnZhc0luc3RydWN0aW9uLlNFVF9TVFJPS0VfU1RZTEUsXG4gICAgICAgIHN0YXRlLnN0cm9rZVN0eWxlLCBzdGF0ZS5saW5lV2lkdGgsIHN0YXRlLmxpbmVDYXAsIHN0YXRlLmxpbmVKb2luLFxuICAgICAgICBzdGF0ZS5taXRlckxpbWl0LCBzdGF0ZS5saW5lRGFzaCwgc3RhdGUubGluZURhc2hPZmZzZXRcbiAgICAgIF0pO1xuICAgIH1cbiAgICB2YXIgZW5kc3MgPSBtdWx0aVBvbHlnb25HZW9tZXRyeS5nZXRFbmRzcygpO1xuICAgIHZhciBmbGF0Q29vcmRpbmF0ZXMgPSBtdWx0aVBvbHlnb25HZW9tZXRyeS5nZXRPcmllbnRlZEZsYXRDb29yZGluYXRlcygpO1xuICAgIHZhciBzdHJpZGUgPSBtdWx0aVBvbHlnb25HZW9tZXRyeS5nZXRTdHJpZGUoKTtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBvZmZzZXQgPSB0aGlzLmRyYXdGbGF0Q29vcmRpbmF0ZXNzXyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kc3NbaV0sIHN0cmlkZSk7XG4gICAgfVxuICAgIHRoaXMuZW5kR2VvbWV0cnkobXVsdGlQb2x5Z29uR2VvbWV0cnksIGZlYXR1cmUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQ2FudmFzUG9seWdvblJlcGxheS5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gZmluaXNoICgpIHtcbiAgICB0aGlzLnJldmVyc2VIaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMoKTtcbiAgICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgICAvLyBXZSB3YW50IHRvIHByZXNlcnZlIHRvcG9sb2d5IHdoZW4gZHJhd2luZyBwb2x5Z29ucy4gIFBvbHlnb25zIGFyZVxuICAgIC8vIHNpbXBsaWZpZWQgdXNpbmcgcXVhbnRpemF0aW9uIGFuZCBwb2ludCBlbGltaW5hdGlvbi4gSG93ZXZlciwgd2UgbWlnaHRcbiAgICAvLyBoYXZlIHJlY2VpdmVkIGEgbWl4IG9mIHF1YW50aXplZCBhbmQgbm9uLXF1YW50aXplZCBnZW9tZXRyaWVzLCBzbyBlbnN1cmVcbiAgICAvLyB0aGF0IGFsbCBhcmUgcXVhbnRpemVkIGJ5IHF1YW50aXppbmcgYWxsIGNvb3JkaW5hdGVzIGluIHRoZSBiYXRjaC5cbiAgICB2YXIgdG9sZXJhbmNlID0gdGhpcy50b2xlcmFuY2U7XG4gICAgaWYgKHRvbGVyYW5jZSAhPT0gMCkge1xuICAgICAgdmFyIGNvb3JkaW5hdGVzID0gdGhpcy5jb29yZGluYXRlcztcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgY29vcmRpbmF0ZXNbaV0gPSBzbmFwKGNvb3JkaW5hdGVzW2ldLCB0b2xlcmFuY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICovXG4gIENhbnZhc1BvbHlnb25SZXBsYXkucHJvdG90eXBlLnNldEZpbGxTdHJva2VTdHlsZXNfID0gZnVuY3Rpb24gc2V0RmlsbFN0cm9rZVN0eWxlc18gKGdlb21ldHJ5KSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB2YXIgZmlsbFN0eWxlID0gc3RhdGUuZmlsbFN0eWxlO1xuICAgIGlmIChmaWxsU3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy51cGRhdGVGaWxsU3R5bGUoc3RhdGUsIHRoaXMuY3JlYXRlRmlsbCwgZ2VvbWV0cnkpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuc3Ryb2tlU3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy51cGRhdGVTdHJva2VTdHlsZShzdGF0ZSwgdGhpcy5hcHBseVN0cm9rZSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBDYW52YXNQb2x5Z29uUmVwbGF5O1xufShDYW52YXNSZXBsYXkpKTtcblxuXG5leHBvcnQgZGVmYXVsdCBDYW52YXNQb2x5Z29uUmVwbGF5O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qb2x5Z29uUmVwbGF5LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXIvY2FudmFzL1JlcGxheVxuICovXG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi4vLi4vdXRpbC5qcyc7XG5pbXBvcnQge2VxdWFscywgcmV2ZXJzZVN1YkFycmF5fSBmcm9tICcuLi8uLi9hcnJheS5qcyc7XG5pbXBvcnQge2FzQ29sb3JMaWtlfSBmcm9tICcuLi8uLi9jb2xvcmxpa2UuanMnO1xuaW1wb3J0IHtidWZmZXIsIGNsb25lLCBjb29yZGluYXRlUmVsYXRpb25zaGlwLCBjcmVhdGVFbXB0eSwgY3JlYXRlT3JVcGRhdGUsXG4gIGNyZWF0ZU9yVXBkYXRlRW1wdHksIGV4dGVuZCwgZXh0ZW5kQ29vcmRpbmF0ZSwgaW50ZXJzZWN0c30gZnJvbSAnLi4vLi4vZXh0ZW50LmpzJztcbmltcG9ydCBSZWxhdGlvbnNoaXAgZnJvbSAnLi4vLi4vZXh0ZW50L1JlbGF0aW9uc2hpcC5qcyc7XG5pbXBvcnQgR2VvbWV0cnlUeXBlIGZyb20gJy4uLy4uL2dlb20vR2VvbWV0cnlUeXBlLmpzJztcbmltcG9ydCB7aW5mbGF0ZUNvb3JkaW5hdGVzLCBpbmZsYXRlQ29vcmRpbmF0ZXNBcnJheSwgaW5mbGF0ZU11bHRpQ29vcmRpbmF0ZXNBcnJheX0gZnJvbSAnLi4vLi4vZ2VvbS9mbGF0L2luZmxhdGUuanMnO1xuaW1wb3J0IHtsaW5lU3RyaW5nTGVuZ3RofSBmcm9tICcuLi8uLi9nZW9tL2ZsYXQvbGVuZ3RoLmpzJztcbmltcG9ydCB7ZHJhd1RleHRPblBhdGh9IGZyb20gJy4uLy4uL2dlb20vZmxhdC90ZXh0cGF0aC5qcyc7XG5pbXBvcnQge3RyYW5zZm9ybTJEfSBmcm9tICcuLi8uLi9nZW9tL2ZsYXQvdHJhbnNmb3JtLmpzJztcbmltcG9ydCB7Q0FOVkFTX0xJTkVfREFTSH0gZnJvbSAnLi4vLi4vaGFzLmpzJztcbmltcG9ydCB7aXNFbXB0eX0gZnJvbSAnLi4vLi4vb2JqLmpzJztcbmltcG9ydCBWZWN0b3JDb250ZXh0IGZyb20gJy4uL1ZlY3RvckNvbnRleHQuanMnO1xuaW1wb3J0IHtkcmF3SW1hZ2UsIHJlc2V0VHJhbnNmb3JtLCBkZWZhdWx0UGFkZGluZywgZGVmYXVsdEZpbGxTdHlsZSwgZGVmYXVsdFN0cm9rZVN0eWxlLFxuICBkZWZhdWx0TWl0ZXJMaW1pdCwgZGVmYXVsdExpbmVXaWR0aCwgZGVmYXVsdExpbmVKb2luLCBkZWZhdWx0TGluZURhc2hPZmZzZXQsXG4gIGRlZmF1bHRMaW5lRGFzaCwgZGVmYXVsdExpbmVDYXB9IGZyb20gJy4uL2NhbnZhcy5qcyc7XG5pbXBvcnQgQ2FudmFzSW5zdHJ1Y3Rpb24gZnJvbSAnLi9JbnN0cnVjdGlvbi5qcyc7XG5pbXBvcnQge1RFWFRfQUxJR059IGZyb20gJy4uL3JlcGxheS5qcyc7XG5pbXBvcnQge1xuICBjcmVhdGUgYXMgY3JlYXRlVHJhbnNmb3JtLFxuICBjb21wb3NlIGFzIGNvbXBvc2VUcmFuc2Zvcm0sXG4gIGFwcGx5IGFzIGFwcGx5VHJhbnNmb3JtLFxuICBzZXRGcm9tQXJyYXkgYXMgdHJhbnNmb3JtU2V0RnJvbUFycmF5XG59IGZyb20gJy4uLy4uL3RyYW5zZm9ybS5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAqL1xudmFyIHRtcEV4dGVudCA9IGNyZWF0ZUVtcHR5KCk7XG5cblxuLyoqXG4gKiBAdHlwZSB7IWltcG9ydChcIi4uLy4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19XG4gKi9cbnZhciB0bXBUcmFuc2Zvcm0gPSBjcmVhdGVUcmFuc2Zvcm0oKTtcblxuXG52YXIgQ2FudmFzUmVwbGF5ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoVmVjdG9yQ29udGV4dCkge1xuICBmdW5jdGlvbiBDYW52YXNSZXBsYXkodG9sZXJhbmNlLCBtYXhFeHRlbnQsIHJlc29sdXRpb24sIHBpeGVsUmF0aW8sIG92ZXJsYXBzLCBkZWNsdXR0ZXJUcmVlKSB7XG4gICAgVmVjdG9yQ29udGV4dC5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgdGhpcy5kZWNsdXR0ZXJUcmVlID0gZGVjbHV0dGVyVHJlZTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudG9sZXJhbmNlID0gdG9sZXJhbmNlO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBjb25zdFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgICAqL1xuICAgIHRoaXMubWF4RXh0ZW50ID0gbWF4RXh0ZW50O1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMub3ZlcmxhcHMgPSBvdmVybGFwcztcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1heExpbmVXaWR0aCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQGNvbnN0XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmFsaWduRmlsbF87XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTwqPn1cbiAgICAgKi9cbiAgICB0aGlzLmJlZ2luR2VvbWV0cnlJbnN0cnVjdGlvbjFfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PCo+fVxuICAgICAqL1xuICAgIHRoaXMuYmVnaW5HZW9tZXRyeUluc3RydWN0aW9uMl8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAgICAgKi9cbiAgICB0aGlzLmJ1ZmZlcmVkTWF4RXh0ZW50XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge0FycmF5PCo+fVxuICAgICAqL1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5jb29yZGluYXRlcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxudW1iZXIsaW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfEFycmF5PGltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT58QXJyYXk8QXJyYXk8aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj4+fVxuICAgICAqL1xuICAgIHRoaXMuY29vcmRpbmF0ZUNhY2hlXyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IWltcG9ydChcIi4uLy4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZFRyYW5zZm9ybV8gPSBjcmVhdGVUcmFuc2Zvcm0oKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7QXJyYXk8Kj59XG4gICAgICovXG4gICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5waXhlbENvb3JkaW5hdGVzXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5GaWxsU3Ryb2tlU3RhdGV9XG4gICAgICovXG4gICAgdGhpcy5zdGF0ZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkZpbGxTdHJva2VTdGF0ZX0gKi8gKHt9KTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnZpZXdSb3RhdGlvbl8gPSAwO1xuXG4gIH1cblxuICBpZiAoIFZlY3RvckNvbnRleHQgKSBDYW52YXNSZXBsYXkuX19wcm90b19fID0gVmVjdG9yQ29udGV4dDtcbiAgQ2FudmFzUmVwbGF5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFZlY3RvckNvbnRleHQgJiYgVmVjdG9yQ29udGV4dC5wcm90b3R5cGUgKTtcbiAgQ2FudmFzUmVwbGF5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhbnZhc1JlcGxheTtcblxuICAvKipcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IHAxIDFzdCBwb2ludCBvZiB0aGUgYmFja2dyb3VuZCBib3guXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBwMiAybmQgcG9pbnQgb2YgdGhlIGJhY2tncm91bmQgYm94LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gcDMgM3JkIHBvaW50IG9mIHRoZSBiYWNrZ3JvdW5kIGJveC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IHA0IDR0aCBwb2ludCBvZiB0aGUgYmFja2dyb3VuZCBib3guXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IGZpbGxJbnN0cnVjdGlvbiBGaWxsIGluc3RydWN0aW9uLlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBzdHJva2VJbnN0cnVjdGlvbiBTdHJva2UgaW5zdHJ1Y3Rpb24uXG4gICAqL1xuICBDYW52YXNSZXBsYXkucHJvdG90eXBlLnJlcGxheVRleHRCYWNrZ3JvdW5kXyA9IGZ1bmN0aW9uIHJlcGxheVRleHRCYWNrZ3JvdW5kXyAoY29udGV4dCwgcDEsIHAyLCBwMywgcDQsIGZpbGxJbnN0cnVjdGlvbiwgc3Ryb2tlSW5zdHJ1Y3Rpb24pIHtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQubW92ZVRvLmFwcGx5KGNvbnRleHQsIHAxKTtcbiAgICBjb250ZXh0LmxpbmVUby5hcHBseShjb250ZXh0LCBwMik7XG4gICAgY29udGV4dC5saW5lVG8uYXBwbHkoY29udGV4dCwgcDMpO1xuICAgIGNvbnRleHQubGluZVRvLmFwcGx5KGNvbnRleHQsIHA0KTtcbiAgICBjb250ZXh0LmxpbmVUby5hcHBseShjb250ZXh0LCBwMSk7XG4gICAgaWYgKGZpbGxJbnN0cnVjdGlvbikge1xuICAgICAgdGhpcy5hbGlnbkZpbGxfID0gLyoqIEB0eXBlIHtib29sZWFufSAqLyAoZmlsbEluc3RydWN0aW9uWzJdKTtcbiAgICAgIHRoaXMuZmlsbF8oY29udGV4dCk7XG4gICAgfVxuICAgIGlmIChzdHJva2VJbnN0cnVjdGlvbikge1xuICAgICAgdGhpcy5zZXRTdHJva2VTdHlsZV8oY29udGV4dCwgLyoqIEB0eXBlIHtBcnJheTwqPn0gKi8gKHN0cm9rZUluc3RydWN0aW9uKSk7XG4gICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR9IGltYWdlIEltYWdlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gYW5jaG9yWCBBbmNob3IgWC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGFuY2hvclkgQW5jaG9yIFkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkRlY2x1dHRlckdyb3VwfSBkZWNsdXR0ZXJHcm91cCBEZWNsdXR0ZXIgZ3JvdXAuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgSGVpZ2h0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gb3BhY2l0eSBPcGFjaXR5LlxuICAgKiBAcGFyYW0ge251bWJlcn0gb3JpZ2luWCBPcmlnaW4gWC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9yaWdpblkgT3JpZ2luIFkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlIFNjYWxlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNuYXBUb1BpeGVsIFNuYXAgdG8gcGl4ZWwuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBXaWR0aC5cbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBwYWRkaW5nIFBhZGRpbmcuXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IGZpbGxJbnN0cnVjdGlvbiBGaWxsIGluc3RydWN0aW9uLlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBzdHJva2VJbnN0cnVjdGlvbiBTdHJva2UgaW5zdHJ1Y3Rpb24uXG4gICAqL1xuICBDYW52YXNSZXBsYXkucHJvdG90eXBlLnJlcGxheUltYWdlXyA9IGZ1bmN0aW9uIHJlcGxheUltYWdlXyAoXG4gICAgY29udGV4dCxcbiAgICB4LFxuICAgIHksXG4gICAgaW1hZ2UsXG4gICAgYW5jaG9yWCxcbiAgICBhbmNob3JZLFxuICAgIGRlY2x1dHRlckdyb3VwLFxuICAgIGhlaWdodCxcbiAgICBvcGFjaXR5LFxuICAgIG9yaWdpblgsXG4gICAgb3JpZ2luWSxcbiAgICByb3RhdGlvbixcbiAgICBzY2FsZSxcbiAgICBzbmFwVG9QaXhlbCxcbiAgICB3aWR0aCxcbiAgICBwYWRkaW5nLFxuICAgIGZpbGxJbnN0cnVjdGlvbixcbiAgICBzdHJva2VJbnN0cnVjdGlvblxuICApIHtcbiAgICB2YXIgZmlsbFN0cm9rZSA9IGZpbGxJbnN0cnVjdGlvbiB8fCBzdHJva2VJbnN0cnVjdGlvbjtcbiAgICBhbmNob3JYICo9IHNjYWxlO1xuICAgIGFuY2hvclkgKj0gc2NhbGU7XG4gICAgeCAtPSBhbmNob3JYO1xuICAgIHkgLT0gYW5jaG9yWTtcblxuICAgIHZhciB3ID0gKHdpZHRoICsgb3JpZ2luWCA+IGltYWdlLndpZHRoKSA/IGltYWdlLndpZHRoIC0gb3JpZ2luWCA6IHdpZHRoO1xuICAgIHZhciBoID0gKGhlaWdodCArIG9yaWdpblkgPiBpbWFnZS5oZWlnaHQpID8gaW1hZ2UuaGVpZ2h0IC0gb3JpZ2luWSA6IGhlaWdodDtcbiAgICB2YXIgYm94VyA9IHBhZGRpbmdbM10gKyB3ICogc2NhbGUgKyBwYWRkaW5nWzFdO1xuICAgIHZhciBib3hIID0gcGFkZGluZ1swXSArIGggKiBzY2FsZSArIHBhZGRpbmdbMl07XG4gICAgdmFyIGJveFggPSB4IC0gcGFkZGluZ1szXTtcbiAgICB2YXIgYm94WSA9IHkgLSBwYWRkaW5nWzBdO1xuXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9ICovXG4gICAgdmFyIHAxO1xuICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSAqL1xuICAgIHZhciBwMjtcbiAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gKi9cbiAgICB2YXIgcDM7XG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9ICovXG4gICAgdmFyIHA0O1xuICAgIGlmIChmaWxsU3Ryb2tlIHx8IHJvdGF0aW9uICE9PSAwKSB7XG4gICAgICBwMSA9IFtib3hYLCBib3hZXTtcbiAgICAgIHAyID0gW2JveFggKyBib3hXLCBib3hZXTtcbiAgICAgIHAzID0gW2JveFggKyBib3hXLCBib3hZICsgYm94SF07XG4gICAgICBwNCA9IFtib3hYLCBib3hZICsgYm94SF07XG4gICAgfVxuXG4gICAgdmFyIHRyYW5zZm9ybSA9IG51bGw7XG4gICAgaWYgKHJvdGF0aW9uICE9PSAwKSB7XG4gICAgICB2YXIgY2VudGVyWCA9IHggKyBhbmNob3JYO1xuICAgICAgdmFyIGNlbnRlclkgPSB5ICsgYW5jaG9yWTtcbiAgICAgIHRyYW5zZm9ybSA9IGNvbXBvc2VUcmFuc2Zvcm0odG1wVHJhbnNmb3JtLCBjZW50ZXJYLCBjZW50ZXJZLCAxLCAxLCByb3RhdGlvbiwgLWNlbnRlclgsIC1jZW50ZXJZKTtcblxuICAgICAgY3JlYXRlT3JVcGRhdGVFbXB0eSh0bXBFeHRlbnQpO1xuICAgICAgZXh0ZW5kQ29vcmRpbmF0ZSh0bXBFeHRlbnQsIGFwcGx5VHJhbnNmb3JtKHRtcFRyYW5zZm9ybSwgcDEpKTtcbiAgICAgIGV4dGVuZENvb3JkaW5hdGUodG1wRXh0ZW50LCBhcHBseVRyYW5zZm9ybSh0bXBUcmFuc2Zvcm0sIHAyKSk7XG4gICAgICBleHRlbmRDb29yZGluYXRlKHRtcEV4dGVudCwgYXBwbHlUcmFuc2Zvcm0odG1wVHJhbnNmb3JtLCBwMykpO1xuICAgICAgZXh0ZW5kQ29vcmRpbmF0ZSh0bXBFeHRlbnQsIGFwcGx5VHJhbnNmb3JtKHRtcFRyYW5zZm9ybSwgcDQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3JlYXRlT3JVcGRhdGUoYm94WCwgYm94WSwgYm94WCArIGJveFcsIGJveFkgKyBib3hILCB0bXBFeHRlbnQpO1xuICAgIH1cbiAgICB2YXIgY2FudmFzID0gY29udGV4dC5jYW52YXM7XG4gICAgdmFyIHN0cm9rZVBhZGRpbmcgPSBzdHJva2VJbnN0cnVjdGlvbiA/IChzdHJva2VJbnN0cnVjdGlvblsyXSAqIHNjYWxlIC8gMikgOiAwO1xuICAgIHZhciBpbnRlcnNlY3RzID1cbiAgICAgICAgdG1wRXh0ZW50WzBdIC0gc3Ryb2tlUGFkZGluZyA8PSBjYW52YXMud2lkdGggJiYgdG1wRXh0ZW50WzJdICsgc3Ryb2tlUGFkZGluZyA+PSAwICYmXG4gICAgICAgIHRtcEV4dGVudFsxXSAtIHN0cm9rZVBhZGRpbmcgPD0gY2FudmFzLmhlaWdodCAmJiB0bXBFeHRlbnRbM10gKyBzdHJva2VQYWRkaW5nID49IDA7XG5cbiAgICBpZiAoc25hcFRvUGl4ZWwpIHtcbiAgICAgIHggPSBNYXRoLnJvdW5kKHgpO1xuICAgICAgeSA9IE1hdGgucm91bmQoeSk7XG4gICAgfVxuXG4gICAgaWYgKGRlY2x1dHRlckdyb3VwKSB7XG4gICAgICBpZiAoIWludGVyc2VjdHMgJiYgZGVjbHV0dGVyR3JvdXBbNF0gPT0gMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBleHRlbmQoZGVjbHV0dGVyR3JvdXAsIHRtcEV4dGVudCk7XG4gICAgICB2YXIgZGVjbHV0dGVyQXJncyA9IGludGVyc2VjdHMgP1xuICAgICAgICBbY29udGV4dCwgdHJhbnNmb3JtID8gdHJhbnNmb3JtLnNsaWNlKDApIDogbnVsbCwgb3BhY2l0eSwgaW1hZ2UsIG9yaWdpblgsIG9yaWdpblksIHcsIGgsIHgsIHksIHNjYWxlXSA6XG4gICAgICAgIG51bGw7XG4gICAgICBpZiAoZGVjbHV0dGVyQXJncyAmJiBmaWxsU3Ryb2tlKSB7XG4gICAgICAgIGRlY2x1dHRlckFyZ3MucHVzaChmaWxsSW5zdHJ1Y3Rpb24sIHN0cm9rZUluc3RydWN0aW9uLCBwMSwgcDIsIHAzLCBwNCk7XG4gICAgICB9XG4gICAgICBkZWNsdXR0ZXJHcm91cC5wdXNoKGRlY2x1dHRlckFyZ3MpO1xuICAgIH0gZWxzZSBpZiAoaW50ZXJzZWN0cykge1xuICAgICAgaWYgKGZpbGxTdHJva2UpIHtcbiAgICAgICAgdGhpcy5yZXBsYXlUZXh0QmFja2dyb3VuZF8oY29udGV4dCwgcDEsIHAyLCBwMywgcDQsXG4gICAgICAgICAgLyoqIEB0eXBlIHtBcnJheTwqPn0gKi8gKGZpbGxJbnN0cnVjdGlvbiksXG4gICAgICAgICAgLyoqIEB0eXBlIHtBcnJheTwqPn0gKi8gKHN0cm9rZUluc3RydWN0aW9uKSk7XG4gICAgICB9XG4gICAgICBkcmF3SW1hZ2UoY29udGV4dCwgdHJhbnNmb3JtLCBvcGFjaXR5LCBpbWFnZSwgb3JpZ2luWCwgb3JpZ2luWSwgdywgaCwgeCwgeSwgc2NhbGUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGRhc2hBcnJheSBEYXNoIGFycmF5LlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBEYXNoIGFycmF5IHdpdGggcGl4ZWwgcmF0aW8gYXBwbGllZFxuICAgKi9cbiAgQ2FudmFzUmVwbGF5LnByb3RvdHlwZS5hcHBseVBpeGVsUmF0aW8gPSBmdW5jdGlvbiBhcHBseVBpeGVsUmF0aW8gKGRhc2hBcnJheSkge1xuICAgIHZhciBwaXhlbFJhdGlvID0gdGhpcy5waXhlbFJhdGlvO1xuICAgIHJldHVybiBwaXhlbFJhdGlvID09IDEgPyBkYXNoQXJyYXkgOiBkYXNoQXJyYXkubWFwKGZ1bmN0aW9uKGRhc2gpIHtcbiAgICAgIHJldHVybiBkYXNoICogcGl4ZWxSYXRpbztcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBjbG9zZWQgTGFzdCBpbnB1dCBjb29yZGluYXRlIGVxdWFscyBmaXJzdC5cbiAgICogQHBhcmFtIHtib29sZWFufSBza2lwRmlyc3QgU2tpcCBmaXJzdCBjb29yZGluYXRlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4ge251bWJlcn0gTXkgZW5kLlxuICAgKi9cbiAgQ2FudmFzUmVwbGF5LnByb3RvdHlwZS5hcHBlbmRGbGF0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBhcHBlbmRGbGF0Q29vcmRpbmF0ZXMgKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgY2xvc2VkLCBza2lwRmlyc3QpIHtcblxuICAgIHZhciBteUVuZCA9IHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIHZhciBleHRlbnQgPSB0aGlzLmdldEJ1ZmZlcmVkTWF4RXh0ZW50KCk7XG4gICAgaWYgKHNraXBGaXJzdCkge1xuICAgICAgb2Zmc2V0ICs9IHN0cmlkZTtcbiAgICB9XG4gICAgdmFyIGxhc3RDb29yZCA9IFtmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XSwgZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdXTtcbiAgICB2YXIgbmV4dENvb3JkID0gW05hTiwgTmFOXTtcbiAgICB2YXIgc2tpcHBlZCA9IHRydWU7XG5cbiAgICB2YXIgaSwgbGFzdFJlbCwgbmV4dFJlbDtcbiAgICBmb3IgKGkgPSBvZmZzZXQgKyBzdHJpZGU7IGkgPCBlbmQ7IGkgKz0gc3RyaWRlKSB7XG4gICAgICBuZXh0Q29vcmRbMF0gPSBmbGF0Q29vcmRpbmF0ZXNbaV07XG4gICAgICBuZXh0Q29vcmRbMV0gPSBmbGF0Q29vcmRpbmF0ZXNbaSArIDFdO1xuICAgICAgbmV4dFJlbCA9IGNvb3JkaW5hdGVSZWxhdGlvbnNoaXAoZXh0ZW50LCBuZXh0Q29vcmQpO1xuICAgICAgaWYgKG5leHRSZWwgIT09IGxhc3RSZWwpIHtcbiAgICAgICAgaWYgKHNraXBwZWQpIHtcbiAgICAgICAgICB0aGlzLmNvb3JkaW5hdGVzW215RW5kKytdID0gbGFzdENvb3JkWzBdO1xuICAgICAgICAgIHRoaXMuY29vcmRpbmF0ZXNbbXlFbmQrK10gPSBsYXN0Q29vcmRbMV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb29yZGluYXRlc1tteUVuZCsrXSA9IG5leHRDb29yZFswXTtcbiAgICAgICAgdGhpcy5jb29yZGluYXRlc1tteUVuZCsrXSA9IG5leHRDb29yZFsxXTtcbiAgICAgICAgc2tpcHBlZCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChuZXh0UmVsID09PSBSZWxhdGlvbnNoaXAuSU5URVJTRUNUSU5HKSB7XG4gICAgICAgIHRoaXMuY29vcmRpbmF0ZXNbbXlFbmQrK10gPSBuZXh0Q29vcmRbMF07XG4gICAgICAgIHRoaXMuY29vcmRpbmF0ZXNbbXlFbmQrK10gPSBuZXh0Q29vcmRbMV07XG4gICAgICAgIHNraXBwZWQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNraXBwZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgbGFzdENvb3JkWzBdID0gbmV4dENvb3JkWzBdO1xuICAgICAgbGFzdENvb3JkWzFdID0gbmV4dENvb3JkWzFdO1xuICAgICAgbGFzdFJlbCA9IG5leHRSZWw7XG4gICAgfVxuXG4gICAgLy8gTGFzdCBjb29yZGluYXRlIGVxdWFscyBmaXJzdCBvciBvbmx5IG9uZSBwb2ludCB0byBhcHBlbmQ6XG4gICAgaWYgKChjbG9zZWQgJiYgc2tpcHBlZCkgfHwgaSA9PT0gb2Zmc2V0ICsgc3RyaWRlKSB7XG4gICAgICB0aGlzLmNvb3JkaW5hdGVzW215RW5kKytdID0gbGFzdENvb3JkWzBdO1xuICAgICAgdGhpcy5jb29yZGluYXRlc1tteUVuZCsrXSA9IGxhc3RDb29yZFsxXTtcbiAgICB9XG4gICAgcmV0dXJuIG15RW5kO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbmRzIEVuZHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHJlcGxheUVuZHMgUmVwbGF5IGVuZHMuXG4gICAqIEByZXR1cm4ge251bWJlcn0gT2Zmc2V0LlxuICAgKi9cbiAgQ2FudmFzUmVwbGF5LnByb3RvdHlwZS5kcmF3Q3VzdG9tQ29vcmRpbmF0ZXNfID0gZnVuY3Rpb24gZHJhd0N1c3RvbUNvb3JkaW5hdGVzXyAoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHMsIHN0cmlkZSwgcmVwbGF5RW5kcykge1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGVuZHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgdmFyIGVuZCA9IGVuZHNbaV07XG4gICAgICB2YXIgcmVwbGF5RW5kID0gdGhpcy5hcHBlbmRGbGF0Q29vcmRpbmF0ZXMoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgcmVwbGF5RW5kcy5wdXNoKHJlcGxheUVuZCk7XG4gICAgICBvZmZzZXQgPSBlbmQ7XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jLlxuICAgKi9cbiAgQ2FudmFzUmVwbGF5LnByb3RvdHlwZS5kcmF3Q3VzdG9tID0gZnVuY3Rpb24gZHJhd0N1c3RvbSAoZ2VvbWV0cnksIGZlYXR1cmUsIHJlbmRlcmVyKSB7XG4gICAgdGhpcy5iZWdpbkdlb21ldHJ5KGdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgICB2YXIgdHlwZSA9IGdlb21ldHJ5LmdldFR5cGUoKTtcbiAgICB2YXIgc3RyaWRlID0gZ2VvbWV0cnkuZ2V0U3RyaWRlKCk7XG4gICAgdmFyIHJlcGxheUJlZ2luID0gdGhpcy5jb29yZGluYXRlcy5sZW5ndGg7XG4gICAgdmFyIGZsYXRDb29yZGluYXRlcywgcmVwbGF5RW5kLCByZXBsYXlFbmRzLCByZXBsYXlFbmRzcztcbiAgICB2YXIgb2Zmc2V0O1xuICAgIGlmICh0eXBlID09IEdlb21ldHJ5VHlwZS5NVUxUSV9QT0xZR09OKSB7XG4gICAgICBnZW9tZXRyeSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9NdWx0aVBvbHlnb24uanNcIikuZGVmYXVsdH0gKi8gKGdlb21ldHJ5KTtcbiAgICAgIGZsYXRDb29yZGluYXRlcyA9IGdlb21ldHJ5LmdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzKCk7XG4gICAgICByZXBsYXlFbmRzcyA9IFtdO1xuICAgICAgdmFyIGVuZHNzID0gZ2VvbWV0cnkuZ2V0RW5kc3MoKTtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIHZhciBteUVuZHMgPSBbXTtcbiAgICAgICAgb2Zmc2V0ID0gdGhpcy5kcmF3Q3VzdG9tQ29vcmRpbmF0ZXNfKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzc1tpXSwgc3RyaWRlLCBteUVuZHMpO1xuICAgICAgICByZXBsYXlFbmRzcy5wdXNoKG15RW5kcyk7XG4gICAgICB9XG4gICAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKFtDYW52YXNJbnN0cnVjdGlvbi5DVVNUT00sXG4gICAgICAgIHJlcGxheUJlZ2luLCByZXBsYXlFbmRzcywgZ2VvbWV0cnksIHJlbmRlcmVyLCBpbmZsYXRlTXVsdGlDb29yZGluYXRlc0FycmF5XSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09IEdlb21ldHJ5VHlwZS5QT0xZR09OIHx8IHR5cGUgPT0gR2VvbWV0cnlUeXBlLk1VTFRJX0xJTkVfU1RSSU5HKSB7XG4gICAgICByZXBsYXlFbmRzID0gW107XG4gICAgICBmbGF0Q29vcmRpbmF0ZXMgPSAodHlwZSA9PSBHZW9tZXRyeVR5cGUuUE9MWUdPTikgP1xuICAgICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2dlb20vUG9seWdvbi5qc1wiKS5kZWZhdWx0fSAqLyAoZ2VvbWV0cnkpLmdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzKCkgOlxuICAgICAgICBnZW9tZXRyeS5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIG9mZnNldCA9IHRoaXMuZHJhd0N1c3RvbUNvb3JkaW5hdGVzXyhmbGF0Q29vcmRpbmF0ZXMsIDAsXG4gICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9Qb2x5Z29uLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vLi4vZ2VvbS9NdWx0aUxpbmVTdHJpbmcuanNcIikuZGVmYXVsdH0gKi8gKGdlb21ldHJ5KS5nZXRFbmRzKCksXG4gICAgICAgIHN0cmlkZSwgcmVwbGF5RW5kcyk7XG4gICAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKFtDYW52YXNJbnN0cnVjdGlvbi5DVVNUT00sXG4gICAgICAgIHJlcGxheUJlZ2luLCByZXBsYXlFbmRzLCBnZW9tZXRyeSwgcmVuZGVyZXIsIGluZmxhdGVDb29yZGluYXRlc0FycmF5XSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09IEdlb21ldHJ5VHlwZS5MSU5FX1NUUklORyB8fCB0eXBlID09IEdlb21ldHJ5VHlwZS5NVUxUSV9QT0lOVCkge1xuICAgICAgZmxhdENvb3JkaW5hdGVzID0gZ2VvbWV0cnkuZ2V0RmxhdENvb3JkaW5hdGVzKCk7XG4gICAgICByZXBsYXlFbmQgPSB0aGlzLmFwcGVuZEZsYXRDb29yZGluYXRlcyhcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzLCAwLCBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLCBzdHJpZGUsIGZhbHNlLCBmYWxzZSk7XG4gICAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKFtDYW52YXNJbnN0cnVjdGlvbi5DVVNUT00sXG4gICAgICAgIHJlcGxheUJlZ2luLCByZXBsYXlFbmQsIGdlb21ldHJ5LCByZW5kZXJlciwgaW5mbGF0ZUNvb3JkaW5hdGVzXSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09IEdlb21ldHJ5VHlwZS5QT0lOVCkge1xuICAgICAgZmxhdENvb3JkaW5hdGVzID0gZ2VvbWV0cnkuZ2V0RmxhdENvb3JkaW5hdGVzKCk7XG4gICAgICB0aGlzLmNvb3JkaW5hdGVzLnB1c2goZmxhdENvb3JkaW5hdGVzWzBdLCBmbGF0Q29vcmRpbmF0ZXNbMV0pO1xuICAgICAgcmVwbGF5RW5kID0gdGhpcy5jb29yZGluYXRlcy5sZW5ndGg7XG4gICAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKFtDYW52YXNJbnN0cnVjdGlvbi5DVVNUT00sXG4gICAgICAgIHJlcGxheUJlZ2luLCByZXBsYXlFbmQsIGdlb21ldHJ5LCByZW5kZXJlcl0pO1xuICAgIH1cbiAgICB0aGlzLmVuZEdlb21ldHJ5KGdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgfTtcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICovXG4gIENhbnZhc1JlcGxheS5wcm90b3R5cGUuYmVnaW5HZW9tZXRyeSA9IGZ1bmN0aW9uIGJlZ2luR2VvbWV0cnkgKGdlb21ldHJ5LCBmZWF0dXJlKSB7XG4gICAgdGhpcy5iZWdpbkdlb21ldHJ5SW5zdHJ1Y3Rpb24xXyA9IFtDYW52YXNJbnN0cnVjdGlvbi5CRUdJTl9HRU9NRVRSWSwgZmVhdHVyZSwgMF07XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh0aGlzLmJlZ2luR2VvbWV0cnlJbnN0cnVjdGlvbjFfKTtcbiAgICB0aGlzLmJlZ2luR2VvbWV0cnlJbnN0cnVjdGlvbjJfID0gW0NhbnZhc0luc3RydWN0aW9uLkJFR0lOX0dFT01FVFJZLCBmZWF0dXJlLCAwXTtcbiAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKHRoaXMuYmVnaW5HZW9tZXRyeUluc3RydWN0aW9uMl8pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGSVhNRSBlbXB0eSBkZXNjcmlwdGlvbiBmb3IganNkb2NcbiAgICovXG4gIENhbnZhc1JlcGxheS5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gZmluaXNoICgpIHt9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBDb250ZXh0LlxuICAgKi9cbiAgQ2FudmFzUmVwbGF5LnByb3RvdHlwZS5maWxsXyA9IGZ1bmN0aW9uIGZpbGxfIChjb250ZXh0KSB7XG4gICAgaWYgKHRoaXMuYWxpZ25GaWxsXykge1xuICAgICAgdmFyIG9yaWdpbiA9IGFwcGx5VHJhbnNmb3JtKHRoaXMucmVuZGVyZWRUcmFuc2Zvcm1fLCBbMCwgMF0pO1xuICAgICAgdmFyIHJlcGVhdFNpemUgPSA1MTIgKiB0aGlzLnBpeGVsUmF0aW87XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZShvcmlnaW5bMF0gJSByZXBlYXRTaXplLCBvcmlnaW5bMV0gJSByZXBlYXRTaXplKTtcbiAgICAgIGNvbnRleHQucm90YXRlKHRoaXMudmlld1JvdGF0aW9uXyk7XG4gICAgfVxuICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIGlmICh0aGlzLmFsaWduRmlsbF8pIHtcbiAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtLmFwcGx5KGNvbnRleHQsIHJlc2V0VHJhbnNmb3JtKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IENvbnRleHQuXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IGluc3RydWN0aW9uIEluc3RydWN0aW9uLlxuICAgKi9cbiAgQ2FudmFzUmVwbGF5LnByb3RvdHlwZS5zZXRTdHJva2VTdHlsZV8gPSBmdW5jdGlvbiBzZXRTdHJva2VTdHlsZV8gKGNvbnRleHQsIGluc3RydWN0aW9uKSB7XG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vY29sb3JsaWtlLmpzXCIpLkNvbG9yTGlrZX0gKi8gKGluc3RydWN0aW9uWzFdKTtcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bMl0pO1xuICAgIGNvbnRleHQubGluZUNhcCA9IC8qKiBAdHlwZSB7Q2FudmFzTGluZUNhcH0gKi8gKGluc3RydWN0aW9uWzNdKTtcbiAgICBjb250ZXh0LmxpbmVKb2luID0gLyoqIEB0eXBlIHtDYW52YXNMaW5lSm9pbn0gKi8gKGluc3RydWN0aW9uWzRdKTtcbiAgICBjb250ZXh0Lm1pdGVyTGltaXQgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzVdKTtcbiAgICBpZiAoQ0FOVkFTX0xJTkVfREFTSCkge1xuICAgICAgY29udGV4dC5saW5lRGFzaE9mZnNldCA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bN10pO1xuICAgICAgY29udGV4dC5zZXRMaW5lRGFzaCgvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovIChpbnN0cnVjdGlvbls2XSkpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRGVjbHV0dGVyR3JvdXB9IGRlY2x1dHRlckdyb3VwIERlY2x1dHRlciBncm91cC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmUuXG4gICAqL1xuICBDYW52YXNSZXBsYXkucHJvdG90eXBlLnJlbmRlckRlY2x1dHRlcl8gPSBmdW5jdGlvbiByZW5kZXJEZWNsdXR0ZXJfIChkZWNsdXR0ZXJHcm91cCwgZmVhdHVyZSkge1xuICAgIGlmIChkZWNsdXR0ZXJHcm91cCAmJiBkZWNsdXR0ZXJHcm91cC5sZW5ndGggPiA1KSB7XG4gICAgICB2YXIgZ3JvdXBDb3VudCA9IGRlY2x1dHRlckdyb3VwWzRdO1xuICAgICAgaWYgKGdyb3VwQ291bnQgPT0gMSB8fCBncm91cENvdW50ID09IGRlY2x1dHRlckdyb3VwLmxlbmd0aCAtIDUpIHtcbiAgICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9zdHJ1Y3RzL1JCdXNoLmpzXCIpLkVudHJ5fSAqL1xuICAgICAgICB2YXIgYm94ID0ge1xuICAgICAgICAgIG1pblg6IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoZGVjbHV0dGVyR3JvdXBbMF0pLFxuICAgICAgICAgIG1pblk6IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoZGVjbHV0dGVyR3JvdXBbMV0pLFxuICAgICAgICAgIG1heFg6IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoZGVjbHV0dGVyR3JvdXBbMl0pLFxuICAgICAgICAgIG1heFk6IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoZGVjbHV0dGVyR3JvdXBbM10pLFxuICAgICAgICAgIHZhbHVlOiBmZWF0dXJlXG4gICAgICAgIH07XG4gICAgICAgIGlmICghdGhpcy5kZWNsdXR0ZXJUcmVlLmNvbGxpZGVzKGJveCkpIHtcbiAgICAgICAgICB0aGlzLmRlY2x1dHRlclRyZWUuaW5zZXJ0KGJveCk7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDUsIGpqID0gZGVjbHV0dGVyR3JvdXAubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgICAgICAgdmFyIGRlY2x1dHRlckRhdGEgPSAvKiogQHR5cGUge0FycmF5fSAqLyAoZGVjbHV0dGVyR3JvdXBbal0pO1xuICAgICAgICAgICAgaWYgKGRlY2x1dHRlckRhdGEpIHtcbiAgICAgICAgICAgICAgaWYgKGRlY2x1dHRlckRhdGEubGVuZ3RoID4gMTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGxheVRleHRCYWNrZ3JvdW5kXyhkZWNsdXR0ZXJEYXRhWzBdLFxuICAgICAgICAgICAgICAgICAgZGVjbHV0dGVyRGF0YVsxM10sIGRlY2x1dHRlckRhdGFbMTRdLCBkZWNsdXR0ZXJEYXRhWzE1XSwgZGVjbHV0dGVyRGF0YVsxNl0sXG4gICAgICAgICAgICAgICAgICBkZWNsdXR0ZXJEYXRhWzExXSwgZGVjbHV0dGVyRGF0YVsxMl0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRyYXdJbWFnZS5hcHBseSh1bmRlZmluZWQsIGRlY2x1dHRlckRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZWNsdXR0ZXJHcm91cC5sZW5ndGggPSA1O1xuICAgICAgICBjcmVhdGVPclVwZGF0ZUVtcHR5KGRlY2x1dHRlckdyb3VwKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IENvbnRleHQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAgICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBib29sZWFuPn0gc2tpcHBlZEZlYXR1cmVzSGFzaCBJZHMgb2YgZmVhdHVyZXNcbiAgICogICAgIHRvIHNraXAuXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IGluc3RydWN0aW9ucyBJbnN0cnVjdGlvbnMgYXJyYXkuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc25hcFRvUGl4ZWwgU25hcCBwb2ludCBzeW1ib2xzIGFuZCB0ZXh0IHRvIGludGVnZXIgcGl4ZWxzLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKChpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0KSk6IFR8dW5kZWZpbmVkfSBmZWF0dXJlQ2FsbGJhY2sgRmVhdHVyZSBjYWxsYmFjay5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50PX0gb3B0X2hpdEV4dGVudCBPbmx5IGNoZWNrIGZlYXR1cmVzIHRoYXQgaW50ZXJzZWN0IHRoaXNcbiAgICogICAgIGV4dGVudC5cbiAgICogQHJldHVybiB7VHx1bmRlZmluZWR9IENhbGxiYWNrIHJlc3VsdC5cbiAgICogQHRlbXBsYXRlIFRcbiAgICovXG4gIENhbnZhc1JlcGxheS5wcm90b3R5cGUucmVwbGF5XyA9IGZ1bmN0aW9uIHJlcGxheV8gKFxuICAgIGNvbnRleHQsXG4gICAgdHJhbnNmb3JtLFxuICAgIHNraXBwZWRGZWF0dXJlc0hhc2gsXG4gICAgaW5zdHJ1Y3Rpb25zLFxuICAgIHNuYXBUb1BpeGVsLFxuICAgIGZlYXR1cmVDYWxsYmFjayxcbiAgICBvcHRfaGl0RXh0ZW50XG4gICkge1xuICAgIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi9cbiAgICB2YXIgcGl4ZWxDb29yZGluYXRlcztcbiAgICBpZiAodGhpcy5waXhlbENvb3JkaW5hdGVzXyAmJiBlcXVhbHModHJhbnNmb3JtLCB0aGlzLnJlbmRlcmVkVHJhbnNmb3JtXykpIHtcbiAgICAgIHBpeGVsQ29vcmRpbmF0ZXMgPSB0aGlzLnBpeGVsQ29vcmRpbmF0ZXNfO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXRoaXMucGl4ZWxDb29yZGluYXRlc18pIHtcbiAgICAgICAgdGhpcy5waXhlbENvb3JkaW5hdGVzXyA9IFtdO1xuICAgICAgfVxuICAgICAgcGl4ZWxDb29yZGluYXRlcyA9IHRyYW5zZm9ybTJEKFxuICAgICAgICB0aGlzLmNvb3JkaW5hdGVzLCAwLCB0aGlzLmNvb3JkaW5hdGVzLmxlbmd0aCwgMixcbiAgICAgICAgdHJhbnNmb3JtLCB0aGlzLnBpeGVsQ29vcmRpbmF0ZXNfKTtcbiAgICAgIHRyYW5zZm9ybVNldEZyb21BcnJheSh0aGlzLnJlbmRlcmVkVHJhbnNmb3JtXywgdHJhbnNmb3JtKTtcbiAgICB9XG4gICAgdmFyIHNraXBGZWF0dXJlcyA9ICFpc0VtcHR5KHNraXBwZWRGZWF0dXJlc0hhc2gpO1xuICAgIHZhciBpID0gMDsgLy8gaW5zdHJ1Y3Rpb24gaW5kZXhcbiAgICB2YXIgaWkgPSBpbnN0cnVjdGlvbnMubGVuZ3RoOyAvLyBlbmQgb2YgaW5zdHJ1Y3Rpb25zXG4gICAgdmFyIGQgPSAwOyAvLyBkYXRhIGluZGV4XG4gICAgdmFyIGRkOyAvLyBlbmQgb2YgcGVyLWluc3RydWN0aW9uIGRhdGFcbiAgICB2YXIgYW5jaG9yWCwgYW5jaG9yWSwgcHJldlgsIHByZXZZLCByb3VuZFgsIHJvdW5kWSwgZGVjbHV0dGVyR3JvdXAsIGltYWdlO1xuICAgIHZhciBwZW5kaW5nRmlsbCA9IDA7XG4gICAgdmFyIHBlbmRpbmdTdHJva2UgPSAwO1xuICAgIHZhciBsYXN0RmlsbEluc3RydWN0aW9uID0gbnVsbDtcbiAgICB2YXIgbGFzdFN0cm9rZUluc3RydWN0aW9uID0gbnVsbDtcbiAgICB2YXIgY29vcmRpbmF0ZUNhY2hlID0gdGhpcy5jb29yZGluYXRlQ2FjaGVfO1xuICAgIHZhciB2aWV3Um90YXRpb24gPSB0aGlzLnZpZXdSb3RhdGlvbl87XG5cbiAgICB2YXIgc3RhdGUgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL3JlbmRlci5qc1wiKS5TdGF0ZX0gKi8gKHtcbiAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICBwaXhlbFJhdGlvOiB0aGlzLnBpeGVsUmF0aW8sXG4gICAgICByZXNvbHV0aW9uOiB0aGlzLnJlc29sdXRpb24sXG4gICAgICByb3RhdGlvbjogdmlld1JvdGF0aW9uXG4gICAgfSk7XG5cbiAgICAvLyBXaGVuIHRoZSBiYXRjaCBzaXplIGdldHMgdG9vIGJpZywgcGVyZm9ybWFuY2UgZGVjcmVhc2VzLiAyMDAgaXMgYSBnb29kXG4gICAgLy8gYmFsYW5jZSBiZXR3ZWVuIGJhdGNoIHNpemUgYW5kIG51bWJlciBvZiBmaWxsL3N0cm9rZSBpbnN0cnVjdGlvbnMuXG4gICAgdmFyIGJhdGNoU2l6ZSA9IHRoaXMuaW5zdHJ1Y3Rpb25zICE9IGluc3RydWN0aW9ucyB8fCB0aGlzLm92ZXJsYXBzID8gMCA6IDIwMDtcbiAgICB2YXIgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSAqLyBmZWF0dXJlO1xuICAgIHZhciB4LCB5O1xuICAgIHdoaWxlIChpIDwgaWkpIHtcbiAgICAgIHZhciBpbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uc1tpXTtcbiAgICAgIHZhciB0eXBlID0gLyoqIEB0eXBlIHtDYW52YXNJbnN0cnVjdGlvbn0gKi8gKGluc3RydWN0aW9uWzBdKTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIENhbnZhc0luc3RydWN0aW9uLkJFR0lOX0dFT01FVFJZOlxuICAgICAgICAgIGZlYXR1cmUgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9ICovIChpbnN0cnVjdGlvblsxXSk7XG4gICAgICAgICAgaWYgKChza2lwRmVhdHVyZXMgJiYgc2tpcHBlZEZlYXR1cmVzSGFzaFtnZXRVaWQoZmVhdHVyZSldKSB8fCAhZmVhdHVyZS5nZXRHZW9tZXRyeSgpKSB7XG4gICAgICAgICAgICBpID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblsyXSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChvcHRfaGl0RXh0ZW50ICE9PSB1bmRlZmluZWQgJiYgIWludGVyc2VjdHMoXG4gICAgICAgICAgICBvcHRfaGl0RXh0ZW50LCBmZWF0dXJlLmdldEdlb21ldHJ5KCkuZ2V0RXh0ZW50KCkpKSB7XG4gICAgICAgICAgICBpID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblsyXSkgKyAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICArK2k7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENhbnZhc0luc3RydWN0aW9uLkJFR0lOX1BBVEg6XG4gICAgICAgICAgaWYgKHBlbmRpbmdGaWxsID4gYmF0Y2hTaXplKSB7XG4gICAgICAgICAgICB0aGlzLmZpbGxfKGNvbnRleHQpO1xuICAgICAgICAgICAgcGVuZGluZ0ZpbGwgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGVuZGluZ1N0cm9rZSA+IGJhdGNoU2l6ZSkge1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgICAgIHBlbmRpbmdTdHJva2UgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXBlbmRpbmdGaWxsICYmICFwZW5kaW5nU3Ryb2tlKSB7XG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgcHJldlggPSBwcmV2WSA9IE5hTjtcbiAgICAgICAgICB9XG4gICAgICAgICAgKytpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENhbnZhc0luc3RydWN0aW9uLkNJUkNMRTpcbiAgICAgICAgICBkID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblsxXSk7XG4gICAgICAgICAgdmFyIHgxID0gcGl4ZWxDb29yZGluYXRlc1tkXTtcbiAgICAgICAgICB2YXIgeTEgPSBwaXhlbENvb3JkaW5hdGVzW2QgKyAxXTtcbiAgICAgICAgICB2YXIgeDIgPSBwaXhlbENvb3JkaW5hdGVzW2QgKyAyXTtcbiAgICAgICAgICB2YXIgeTIgPSBwaXhlbENvb3JkaW5hdGVzW2QgKyAzXTtcbiAgICAgICAgICB2YXIgZHggPSB4MiAtIHgxO1xuICAgICAgICAgIHZhciBkeSA9IHkyIC0geTE7XG4gICAgICAgICAgdmFyIHIgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICAgIGNvbnRleHQubW92ZVRvKHgxICsgciwgeTEpO1xuICAgICAgICAgIGNvbnRleHQuYXJjKHgxLCB5MSwgciwgMCwgMiAqIE1hdGguUEksIHRydWUpO1xuICAgICAgICAgICsraTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDYW52YXNJbnN0cnVjdGlvbi5DTE9TRV9QQVRIOlxuICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgKytpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENhbnZhc0luc3RydWN0aW9uLkNVU1RPTTpcbiAgICAgICAgICBkID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblsxXSk7XG4gICAgICAgICAgZGQgPSBpbnN0cnVjdGlvblsyXTtcbiAgICAgICAgICB2YXIgZ2VvbWV0cnkgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2dlb20vU2ltcGxlR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gKi8gKGluc3RydWN0aW9uWzNdKTtcbiAgICAgICAgICB2YXIgcmVuZGVyZXIgPSBpbnN0cnVjdGlvbls0XTtcbiAgICAgICAgICB2YXIgZm4gPSBpbnN0cnVjdGlvbi5sZW5ndGggPT0gNiA/IGluc3RydWN0aW9uWzVdIDogdW5kZWZpbmVkO1xuICAgICAgICAgIHN0YXRlLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG4gICAgICAgICAgc3RhdGUuZmVhdHVyZSA9IGZlYXR1cmU7XG4gICAgICAgICAgaWYgKCEoaSBpbiBjb29yZGluYXRlQ2FjaGUpKSB7XG4gICAgICAgICAgICBjb29yZGluYXRlQ2FjaGVbaV0gPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGNvb3JkcyA9IGNvb3JkaW5hdGVDYWNoZVtpXTtcbiAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgIGZuKHBpeGVsQ29vcmRpbmF0ZXMsIGQsIGRkLCAyLCBjb29yZHMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb29yZHNbMF0gPSBwaXhlbENvb3JkaW5hdGVzW2RdO1xuICAgICAgICAgICAgY29vcmRzWzFdID0gcGl4ZWxDb29yZGluYXRlc1tkICsgMV07XG4gICAgICAgICAgICBjb29yZHMubGVuZ3RoID0gMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVuZGVyZXIoY29vcmRzLCBzdGF0ZSk7XG4gICAgICAgICAgKytpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENhbnZhc0luc3RydWN0aW9uLkRSQVdfSU1BR0U6XG4gICAgICAgICAgZCA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bMV0pO1xuICAgICAgICAgIGRkID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblsyXSk7XG4gICAgICAgICAgaW1hZ2UgPSAvKiogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR8SFRNTEltYWdlRWxlbWVudH0gKi9cbiAgICAgICAgICAgICAgKGluc3RydWN0aW9uWzNdKTtcbiAgICAgICAgICAvLyBSZW1haW5pbmcgYXJndW1lbnRzIGluIERSQVdfSU1BR0UgYXJlIGluIGFscGhhYmV0aWNhbCBvcmRlclxuICAgICAgICAgIGFuY2hvclggPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzRdKTtcbiAgICAgICAgICBhbmNob3JZID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvbls1XSk7XG4gICAgICAgICAgZGVjbHV0dGVyR3JvdXAgPSBmZWF0dXJlQ2FsbGJhY2sgPyBudWxsIDogLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRGVjbHV0dGVyR3JvdXB9ICovIChpbnN0cnVjdGlvbls2XSk7XG4gICAgICAgICAgdmFyIGhlaWdodCA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bN10pO1xuICAgICAgICAgIHZhciBvcGFjaXR5ID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvbls4XSk7XG4gICAgICAgICAgdmFyIG9yaWdpblggPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzldKTtcbiAgICAgICAgICB2YXIgb3JpZ2luWSA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bMTBdKTtcbiAgICAgICAgICB2YXIgcm90YXRlV2l0aFZpZXcgPSAvKiogQHR5cGUge2Jvb2xlYW59ICovIChpbnN0cnVjdGlvblsxMV0pO1xuICAgICAgICAgIHZhciByb3RhdGlvbiA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bMTJdKTtcbiAgICAgICAgICB2YXIgc2NhbGUgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzEzXSk7XG4gICAgICAgICAgdmFyIHdpZHRoID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblsxNF0pO1xuXG4gICAgICAgICAgdmFyIHBhZGRpbmcgPSAodm9pZCAwKSwgYmFja2dyb3VuZEZpbGwgPSAodm9pZCAwKSwgYmFja2dyb3VuZFN0cm9rZSA9ICh2b2lkIDApO1xuICAgICAgICAgIGlmIChpbnN0cnVjdGlvbi5sZW5ndGggPiAxNikge1xuICAgICAgICAgICAgcGFkZGluZyA9IC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi8gKGluc3RydWN0aW9uWzE1XSk7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kRmlsbCA9IC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi8gKGluc3RydWN0aW9uWzE2XSk7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kU3Ryb2tlID0gLyoqIEB0eXBlIHtib29sZWFufSAqLyAoaW5zdHJ1Y3Rpb25bMTddKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFkZGluZyA9IGRlZmF1bHRQYWRkaW5nO1xuICAgICAgICAgICAgYmFja2dyb3VuZEZpbGwgPSBiYWNrZ3JvdW5kU3Ryb2tlID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJvdGF0ZVdpdGhWaWV3KSB7XG4gICAgICAgICAgICByb3RhdGlvbiArPSB2aWV3Um90YXRpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoOyBkIDwgZGQ7IGQgKz0gMikge1xuICAgICAgICAgICAgdGhpcy5yZXBsYXlJbWFnZV8oY29udGV4dCxcbiAgICAgICAgICAgICAgcGl4ZWxDb29yZGluYXRlc1tkXSwgcGl4ZWxDb29yZGluYXRlc1tkICsgMV0sIGltYWdlLCBhbmNob3JYLCBhbmNob3JZLFxuICAgICAgICAgICAgICBkZWNsdXR0ZXJHcm91cCwgaGVpZ2h0LCBvcGFjaXR5LCBvcmlnaW5YLCBvcmlnaW5ZLCByb3RhdGlvbiwgc2NhbGUsXG4gICAgICAgICAgICAgIHNuYXBUb1BpeGVsLCB3aWR0aCwgcGFkZGluZyxcbiAgICAgICAgICAgICAgYmFja2dyb3VuZEZpbGwgPyAvKiogQHR5cGUge0FycmF5PCo+fSAqLyAobGFzdEZpbGxJbnN0cnVjdGlvbikgOiBudWxsLFxuICAgICAgICAgICAgICBiYWNrZ3JvdW5kU3Ryb2tlID8gLyoqIEB0eXBlIHtBcnJheTwqPn0gKi8gKGxhc3RTdHJva2VJbnN0cnVjdGlvbikgOiBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5yZW5kZXJEZWNsdXR0ZXJfKGRlY2x1dHRlckdyb3VwLCBmZWF0dXJlKTtcbiAgICAgICAgICArK2k7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ2FudmFzSW5zdHJ1Y3Rpb24uRFJBV19DSEFSUzpcbiAgICAgICAgICB2YXIgYmVnaW4gPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzFdKTtcbiAgICAgICAgICB2YXIgZW5kID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblsyXSk7XG4gICAgICAgICAgdmFyIGJhc2VsaW5lID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblszXSk7XG4gICAgICAgICAgZGVjbHV0dGVyR3JvdXAgPSBmZWF0dXJlQ2FsbGJhY2sgPyBudWxsIDogLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRGVjbHV0dGVyR3JvdXB9ICovIChpbnN0cnVjdGlvbls0XSk7XG4gICAgICAgICAgdmFyIG92ZXJmbG93ID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvbls1XSk7XG4gICAgICAgICAgdmFyIGZpbGxLZXkgPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKGluc3RydWN0aW9uWzZdKTtcbiAgICAgICAgICB2YXIgbWF4QW5nbGUgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzddKTtcbiAgICAgICAgICB2YXIgbWVhc3VyZSA9IC8qKiBAdHlwZSB7ZnVuY3Rpb24oc3RyaW5nKTpudW1iZXJ9ICovIChpbnN0cnVjdGlvbls4XSk7XG4gICAgICAgICAgdmFyIG9mZnNldFkgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzldKTtcbiAgICAgICAgICB2YXIgc3Ryb2tlS2V5ID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChpbnN0cnVjdGlvblsxMF0pO1xuICAgICAgICAgIHZhciBzdHJva2VXaWR0aCA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bMTFdKTtcbiAgICAgICAgICB2YXIgdGV4dCA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoaW5zdHJ1Y3Rpb25bMTJdKTtcbiAgICAgICAgICB2YXIgdGV4dEtleSA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoaW5zdHJ1Y3Rpb25bMTNdKTtcbiAgICAgICAgICB2YXIgdGV4dFNjYWxlID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblsxNF0pO1xuXG4gICAgICAgICAgdmFyIHBhdGhMZW5ndGggPSBsaW5lU3RyaW5nTGVuZ3RoKHBpeGVsQ29vcmRpbmF0ZXMsIGJlZ2luLCBlbmQsIDIpO1xuICAgICAgICAgIHZhciB0ZXh0TGVuZ3RoID0gbWVhc3VyZSh0ZXh0KTtcbiAgICAgICAgICBpZiAob3ZlcmZsb3cgfHwgdGV4dExlbmd0aCA8PSBwYXRoTGVuZ3RoKSB7XG4gICAgICAgICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4vVGV4dFJlcGxheS5qc1wiKS5kZWZhdWx0fSAqL1xuICAgICAgICAgICAgdmFyIHRleHRSZXBsYXkgPSAvKiogQHR5cGUgez99ICovICh0aGlzKTtcbiAgICAgICAgICAgIHZhciB0ZXh0QWxpZ24gPSB0ZXh0UmVwbGF5LnRleHRTdGF0ZXNbdGV4dEtleV0udGV4dEFsaWduO1xuICAgICAgICAgICAgdmFyIHN0YXJ0TSA9IChwYXRoTGVuZ3RoIC0gdGV4dExlbmd0aCkgKiBURVhUX0FMSUdOW3RleHRBbGlnbl07XG4gICAgICAgICAgICB2YXIgcGFydHMgPSBkcmF3VGV4dE9uUGF0aChcbiAgICAgICAgICAgICAgcGl4ZWxDb29yZGluYXRlcywgYmVnaW4sIGVuZCwgMiwgdGV4dCwgbWVhc3VyZSwgc3RhcnRNLCBtYXhBbmdsZSk7XG4gICAgICAgICAgICBpZiAocGFydHMpIHtcbiAgICAgICAgICAgICAgdmFyIGMgPSAodm9pZCAwKSwgY2MgPSAodm9pZCAwKSwgY2hhcnMgPSAodm9pZCAwKSwgbGFiZWwgPSAodm9pZCAwKSwgcGFydCA9ICh2b2lkIDApO1xuICAgICAgICAgICAgICBpZiAoc3Ryb2tlS2V5KSB7XG4gICAgICAgICAgICAgICAgZm9yIChjID0gMCwgY2MgPSBwYXJ0cy5sZW5ndGg7IGMgPCBjYzsgKytjKSB7XG4gICAgICAgICAgICAgICAgICBwYXJ0ID0gcGFydHNbY107IC8vIHgsIHksIGFuY2hvclgsIHJvdGF0aW9uLCBjaHVua1xuICAgICAgICAgICAgICAgICAgY2hhcnMgPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKHBhcnRbNF0pO1xuICAgICAgICAgICAgICAgICAgbGFiZWwgPSB0ZXh0UmVwbGF5LmdldEltYWdlKGNoYXJzLCB0ZXh0S2V5LCAnJywgc3Ryb2tlS2V5KTtcbiAgICAgICAgICAgICAgICAgIGFuY2hvclggPSAvKiogQHR5cGUge251bWJlcn0gKi8gKHBhcnRbMl0pICsgc3Ryb2tlV2lkdGg7XG4gICAgICAgICAgICAgICAgICBhbmNob3JZID0gYmFzZWxpbmUgKiBsYWJlbC5oZWlnaHQgKyAoMC41IC0gYmFzZWxpbmUpICogMiAqIHN0cm9rZVdpZHRoIC0gb2Zmc2V0WTtcbiAgICAgICAgICAgICAgICAgIHRoaXMucmVwbGF5SW1hZ2VfKGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAocGFydFswXSksIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAocGFydFsxXSksIGxhYmVsLFxuICAgICAgICAgICAgICAgICAgICBhbmNob3JYLCBhbmNob3JZLCBkZWNsdXR0ZXJHcm91cCwgbGFiZWwuaGVpZ2h0LCAxLCAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi8gKHBhcnRbM10pLCB0ZXh0U2NhbGUsIGZhbHNlLCBsYWJlbC53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFBhZGRpbmcsIG51bGwsIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZmlsbEtleSkge1xuICAgICAgICAgICAgICAgIGZvciAoYyA9IDAsIGNjID0gcGFydHMubGVuZ3RoOyBjIDwgY2M7ICsrYykge1xuICAgICAgICAgICAgICAgICAgcGFydCA9IHBhcnRzW2NdOyAvLyB4LCB5LCBhbmNob3JYLCByb3RhdGlvbiwgY2h1bmtcbiAgICAgICAgICAgICAgICAgIGNoYXJzID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChwYXJ0WzRdKTtcbiAgICAgICAgICAgICAgICAgIGxhYmVsID0gdGV4dFJlcGxheS5nZXRJbWFnZShjaGFycywgdGV4dEtleSwgZmlsbEtleSwgJycpO1xuICAgICAgICAgICAgICAgICAgYW5jaG9yWCA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAocGFydFsyXSk7XG4gICAgICAgICAgICAgICAgICBhbmNob3JZID0gYmFzZWxpbmUgKiBsYWJlbC5oZWlnaHQgLSBvZmZzZXRZO1xuICAgICAgICAgICAgICAgICAgdGhpcy5yZXBsYXlJbWFnZV8oY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovIChwYXJ0WzBdKSwgLyoqIEB0eXBlIHtudW1iZXJ9ICovIChwYXJ0WzFdKSwgbGFiZWwsXG4gICAgICAgICAgICAgICAgICAgIGFuY2hvclgsIGFuY2hvclksIGRlY2x1dHRlckdyb3VwLCBsYWJlbC5oZWlnaHQsIDEsIDAsIDAsXG4gICAgICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAocGFydFszXSksIHRleHRTY2FsZSwgZmFsc2UsIGxhYmVsLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0UGFkZGluZywgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMucmVuZGVyRGVjbHV0dGVyXyhkZWNsdXR0ZXJHcm91cCwgZmVhdHVyZSk7XG4gICAgICAgICAgKytpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENhbnZhc0luc3RydWN0aW9uLkVORF9HRU9NRVRSWTpcbiAgICAgICAgICBpZiAoZmVhdHVyZUNhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZlYXR1cmUgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9ICovIChpbnN0cnVjdGlvblsxXSk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gZmVhdHVyZUNhbGxiYWNrKGZlYXR1cmUpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICArK2k7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ2FudmFzSW5zdHJ1Y3Rpb24uRklMTDpcbiAgICAgICAgICBpZiAoYmF0Y2hTaXplKSB7XG4gICAgICAgICAgICBwZW5kaW5nRmlsbCsrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZpbGxfKGNvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICArK2k7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ2FudmFzSW5zdHJ1Y3Rpb24uTU9WRV9UT19MSU5FX1RPOlxuICAgICAgICAgIGQgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzFdKTtcbiAgICAgICAgICBkZCA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bMl0pO1xuICAgICAgICAgIHggPSBwaXhlbENvb3JkaW5hdGVzW2RdO1xuICAgICAgICAgIHkgPSBwaXhlbENvb3JkaW5hdGVzW2QgKyAxXTtcbiAgICAgICAgICByb3VuZFggPSAoeCArIDAuNSkgfCAwO1xuICAgICAgICAgIHJvdW5kWSA9ICh5ICsgMC41KSB8IDA7XG4gICAgICAgICAgaWYgKHJvdW5kWCAhPT0gcHJldlggfHwgcm91bmRZICE9PSBwcmV2WSkge1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgICBwcmV2WCA9IHJvdW5kWDtcbiAgICAgICAgICAgIHByZXZZID0gcm91bmRZO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGQgKz0gMjsgZCA8IGRkOyBkICs9IDIpIHtcbiAgICAgICAgICAgIHggPSBwaXhlbENvb3JkaW5hdGVzW2RdO1xuICAgICAgICAgICAgeSA9IHBpeGVsQ29vcmRpbmF0ZXNbZCArIDFdO1xuICAgICAgICAgICAgcm91bmRYID0gKHggKyAwLjUpIHwgMDtcbiAgICAgICAgICAgIHJvdW5kWSA9ICh5ICsgMC41KSB8IDA7XG4gICAgICAgICAgICBpZiAoZCA9PSBkZCAtIDIgfHwgcm91bmRYICE9PSBwcmV2WCB8fCByb3VuZFkgIT09IHByZXZZKSB7XG4gICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICBwcmV2WCA9IHJvdW5kWDtcbiAgICAgICAgICAgICAgcHJldlkgPSByb3VuZFk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgICsraTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDYW52YXNJbnN0cnVjdGlvbi5TRVRfRklMTF9TVFlMRTpcbiAgICAgICAgICBsYXN0RmlsbEluc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb247XG4gICAgICAgICAgdGhpcy5hbGlnbkZpbGxfID0gaW5zdHJ1Y3Rpb25bMl07XG5cbiAgICAgICAgICBpZiAocGVuZGluZ0ZpbGwpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsbF8oY29udGV4dCk7XG4gICAgICAgICAgICBwZW5kaW5nRmlsbCA9IDA7XG4gICAgICAgICAgICBpZiAocGVuZGluZ1N0cm9rZSkge1xuICAgICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICAgICAgICBwZW5kaW5nU3Ryb2tlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vY29sb3JsaWtlLmpzXCIpLkNvbG9yTGlrZX0gKi8gKGluc3RydWN0aW9uWzFdKTtcbiAgICAgICAgICArK2k7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ2FudmFzSW5zdHJ1Y3Rpb24uU0VUX1NUUk9LRV9TVFlMRTpcbiAgICAgICAgICBsYXN0U3Ryb2tlSW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbjtcbiAgICAgICAgICBpZiAocGVuZGluZ1N0cm9rZSkge1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgICAgIHBlbmRpbmdTdHJva2UgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnNldFN0cm9rZVN0eWxlXyhjb250ZXh0LCAvKiogQHR5cGUge0FycmF5PCo+fSAqLyAoaW5zdHJ1Y3Rpb24pKTtcbiAgICAgICAgICArK2k7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ2FudmFzSW5zdHJ1Y3Rpb24uU1RST0tFOlxuICAgICAgICAgIGlmIChiYXRjaFNpemUpIHtcbiAgICAgICAgICAgIHBlbmRpbmdTdHJva2UrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgKytpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICsraTsgLy8gY29uc3VtZSB0aGUgaW5zdHJ1Y3Rpb24gYW55d2F5LCB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwZW5kaW5nRmlsbCkge1xuICAgICAgdGhpcy5maWxsXyhjb250ZXh0KTtcbiAgICB9XG4gICAgaWYgKHBlbmRpbmdTdHJva2UpIHtcbiAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IENvbnRleHQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHZpZXdSb3RhdGlvbiBWaWV3IHJvdGF0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGJvb2xlYW4+fSBza2lwcGVkRmVhdHVyZXNIYXNoIElkcyBvZiBmZWF0dXJlc1xuICAgKiAgICAgdG8gc2tpcC5cbiAgICogQHBhcmFtIHtib29sZWFufSBzbmFwVG9QaXhlbCBTbmFwIHBvaW50IHN5bWJvbHMgYW5kIHRleHQgdG8gaW50ZWdlciBwaXhlbHMuXG4gICAqL1xuICBDYW52YXNSZXBsYXkucHJvdG90eXBlLnJlcGxheSA9IGZ1bmN0aW9uIHJlcGxheSAoY29udGV4dCwgdHJhbnNmb3JtLCB2aWV3Um90YXRpb24sIHNraXBwZWRGZWF0dXJlc0hhc2gsIHNuYXBUb1BpeGVsKSB7XG4gICAgdGhpcy52aWV3Um90YXRpb25fID0gdmlld1JvdGF0aW9uO1xuICAgIHRoaXMucmVwbGF5Xyhjb250ZXh0LCB0cmFuc2Zvcm0sXG4gICAgICBza2lwcGVkRmVhdHVyZXNIYXNoLCB0aGlzLmluc3RydWN0aW9ucywgc25hcFRvUGl4ZWwsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfSB0cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmlld1JvdGF0aW9uIFZpZXcgcm90YXRpb24uXG4gICAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgYm9vbGVhbj59IHNraXBwZWRGZWF0dXJlc0hhc2ggSWRzIG9mIGZlYXR1cmVzXG4gICAqICAgICB0byBza2lwLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKChpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0KSk6IFQ9fSBvcHRfZmVhdHVyZUNhbGxiYWNrXG4gICAqICAgICBGZWF0dXJlIGNhbGxiYWNrLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnQ9fSBvcHRfaGl0RXh0ZW50IE9ubHkgY2hlY2sgZmVhdHVyZXMgdGhhdCBpbnRlcnNlY3QgdGhpc1xuICAgKiAgICAgZXh0ZW50LlxuICAgKiBAcmV0dXJuIHtUfHVuZGVmaW5lZH0gQ2FsbGJhY2sgcmVzdWx0LlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKi9cbiAgQ2FudmFzUmVwbGF5LnByb3RvdHlwZS5yZXBsYXlIaXREZXRlY3Rpb24gPSBmdW5jdGlvbiByZXBsYXlIaXREZXRlY3Rpb24gKFxuICAgIGNvbnRleHQsXG4gICAgdHJhbnNmb3JtLFxuICAgIHZpZXdSb3RhdGlvbixcbiAgICBza2lwcGVkRmVhdHVyZXNIYXNoLFxuICAgIG9wdF9mZWF0dXJlQ2FsbGJhY2ssXG4gICAgb3B0X2hpdEV4dGVudFxuICApIHtcbiAgICB0aGlzLnZpZXdSb3RhdGlvbl8gPSB2aWV3Um90YXRpb247XG4gICAgcmV0dXJuIHRoaXMucmVwbGF5Xyhjb250ZXh0LCB0cmFuc2Zvcm0sIHNraXBwZWRGZWF0dXJlc0hhc2gsXG4gICAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucywgdHJ1ZSwgb3B0X2ZlYXR1cmVDYWxsYmFjaywgb3B0X2hpdEV4dGVudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldmVyc2UgdGhlIGhpdCBkZXRlY3Rpb24gaW5zdHJ1Y3Rpb25zLlxuICAgKi9cbiAgQ2FudmFzUmVwbGF5LnByb3RvdHlwZS5yZXZlcnNlSGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zID0gZnVuY3Rpb24gcmV2ZXJzZUhpdERldGVjdGlvbkluc3RydWN0aW9ucyAoKSB7XG4gICAgdmFyIGhpdERldGVjdGlvbkluc3RydWN0aW9ucyA9IHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zO1xuICAgIC8vIHN0ZXAgMSAtIHJldmVyc2UgYXJyYXlcbiAgICBoaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucmV2ZXJzZSgpO1xuICAgIC8vIHN0ZXAgMiAtIHJldmVyc2UgaW5zdHJ1Y3Rpb25zIHdpdGhpbiBnZW9tZXRyeSBibG9ja3NcbiAgICB2YXIgaTtcbiAgICB2YXIgbiA9IGhpdERldGVjdGlvbkluc3RydWN0aW9ucy5sZW5ndGg7XG4gICAgdmFyIGluc3RydWN0aW9uO1xuICAgIHZhciB0eXBlO1xuICAgIHZhciBiZWdpbiA9IC0xO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGluc3RydWN0aW9uID0gaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zW2ldO1xuICAgICAgdHlwZSA9IC8qKiBAdHlwZSB7Q2FudmFzSW5zdHJ1Y3Rpb259ICovIChpbnN0cnVjdGlvblswXSk7XG4gICAgICBpZiAodHlwZSA9PSBDYW52YXNJbnN0cnVjdGlvbi5FTkRfR0VPTUVUUlkpIHtcbiAgICAgICAgYmVnaW4gPSBpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09IENhbnZhc0luc3RydWN0aW9uLkJFR0lOX0dFT01FVFJZKSB7XG4gICAgICAgIGluc3RydWN0aW9uWzJdID0gaTtcbiAgICAgICAgcmV2ZXJzZVN1YkFycmF5KHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLCBiZWdpbiwgaSk7XG4gICAgICAgIGJlZ2luID0gLTE7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQ2FudmFzUmVwbGF5LnByb3RvdHlwZS5zZXRGaWxsU3Ryb2tlU3R5bGUgPSBmdW5jdGlvbiBzZXRGaWxsU3Ryb2tlU3R5bGUgKGZpbGxTdHlsZSwgc3Ryb2tlU3R5bGUpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGlmIChmaWxsU3R5bGUpIHtcbiAgICAgIHZhciBmaWxsU3R5bGVDb2xvciA9IGZpbGxTdHlsZS5nZXRDb2xvcigpO1xuICAgICAgc3RhdGUuZmlsbFN0eWxlID0gYXNDb2xvckxpa2UoZmlsbFN0eWxlQ29sb3IgP1xuICAgICAgICBmaWxsU3R5bGVDb2xvciA6IGRlZmF1bHRGaWxsU3R5bGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5maWxsU3R5bGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChzdHJva2VTdHlsZSkge1xuICAgICAgdmFyIHN0cm9rZVN0eWxlQ29sb3IgPSBzdHJva2VTdHlsZS5nZXRDb2xvcigpO1xuICAgICAgc3RhdGUuc3Ryb2tlU3R5bGUgPSBhc0NvbG9yTGlrZShzdHJva2VTdHlsZUNvbG9yID9cbiAgICAgICAgc3Ryb2tlU3R5bGVDb2xvciA6IGRlZmF1bHRTdHJva2VTdHlsZSk7XG4gICAgICB2YXIgc3Ryb2tlU3R5bGVMaW5lQ2FwID0gc3Ryb2tlU3R5bGUuZ2V0TGluZUNhcCgpO1xuICAgICAgc3RhdGUubGluZUNhcCA9IHN0cm9rZVN0eWxlTGluZUNhcCAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgc3Ryb2tlU3R5bGVMaW5lQ2FwIDogZGVmYXVsdExpbmVDYXA7XG4gICAgICB2YXIgc3Ryb2tlU3R5bGVMaW5lRGFzaCA9IHN0cm9rZVN0eWxlLmdldExpbmVEYXNoKCk7XG4gICAgICBzdGF0ZS5saW5lRGFzaCA9IHN0cm9rZVN0eWxlTGluZURhc2ggP1xuICAgICAgICBzdHJva2VTdHlsZUxpbmVEYXNoLnNsaWNlKCkgOiBkZWZhdWx0TGluZURhc2g7XG4gICAgICB2YXIgc3Ryb2tlU3R5bGVMaW5lRGFzaE9mZnNldCA9IHN0cm9rZVN0eWxlLmdldExpbmVEYXNoT2Zmc2V0KCk7XG4gICAgICBzdGF0ZS5saW5lRGFzaE9mZnNldCA9IHN0cm9rZVN0eWxlTGluZURhc2hPZmZzZXQgP1xuICAgICAgICBzdHJva2VTdHlsZUxpbmVEYXNoT2Zmc2V0IDogZGVmYXVsdExpbmVEYXNoT2Zmc2V0O1xuICAgICAgdmFyIHN0cm9rZVN0eWxlTGluZUpvaW4gPSBzdHJva2VTdHlsZS5nZXRMaW5lSm9pbigpO1xuICAgICAgc3RhdGUubGluZUpvaW4gPSBzdHJva2VTdHlsZUxpbmVKb2luICE9PSB1bmRlZmluZWQgP1xuICAgICAgICBzdHJva2VTdHlsZUxpbmVKb2luIDogZGVmYXVsdExpbmVKb2luO1xuICAgICAgdmFyIHN0cm9rZVN0eWxlV2lkdGggPSBzdHJva2VTdHlsZS5nZXRXaWR0aCgpO1xuICAgICAgc3RhdGUubGluZVdpZHRoID0gc3Ryb2tlU3R5bGVXaWR0aCAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgc3Ryb2tlU3R5bGVXaWR0aCA6IGRlZmF1bHRMaW5lV2lkdGg7XG4gICAgICB2YXIgc3Ryb2tlU3R5bGVNaXRlckxpbWl0ID0gc3Ryb2tlU3R5bGUuZ2V0TWl0ZXJMaW1pdCgpO1xuICAgICAgc3RhdGUubWl0ZXJMaW1pdCA9IHN0cm9rZVN0eWxlTWl0ZXJMaW1pdCAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgc3Ryb2tlU3R5bGVNaXRlckxpbWl0IDogZGVmYXVsdE1pdGVyTGltaXQ7XG5cbiAgICAgIGlmIChzdGF0ZS5saW5lV2lkdGggPiB0aGlzLm1heExpbmVXaWR0aCkge1xuICAgICAgICB0aGlzLm1heExpbmVXaWR0aCA9IHN0YXRlLmxpbmVXaWR0aDtcbiAgICAgICAgLy8gaW52YWxpZGF0ZSB0aGUgYnVmZmVyZWQgbWF4IGV4dGVudCBjYWNoZVxuICAgICAgICB0aGlzLmJ1ZmZlcmVkTWF4RXh0ZW50XyA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnN0cm9rZVN0eWxlID0gdW5kZWZpbmVkO1xuICAgICAgc3RhdGUubGluZUNhcCA9IHVuZGVmaW5lZDtcbiAgICAgIHN0YXRlLmxpbmVEYXNoID0gbnVsbDtcbiAgICAgIHN0YXRlLmxpbmVEYXNoT2Zmc2V0ID0gdW5kZWZpbmVkO1xuICAgICAgc3RhdGUubGluZUpvaW4gPSB1bmRlZmluZWQ7XG4gICAgICBzdGF0ZS5saW5lV2lkdGggPSB1bmRlZmluZWQ7XG4gICAgICBzdGF0ZS5taXRlckxpbWl0ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRmlsbFN0cm9rZVN0YXRlfSBzdGF0ZSBTdGF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICogQHJldHVybiB7QXJyYXk8Kj59IEZpbGwgaW5zdHJ1Y3Rpb24uXG4gICAqL1xuICBDYW52YXNSZXBsYXkucHJvdG90eXBlLmNyZWF0ZUZpbGwgPSBmdW5jdGlvbiBjcmVhdGVGaWxsIChzdGF0ZSwgZ2VvbWV0cnkpIHtcbiAgICB2YXIgZmlsbFN0eWxlID0gc3RhdGUuZmlsbFN0eWxlO1xuICAgIC8qKiBAdHlwZSB7QXJyYXk8Kj59ICovXG4gICAgdmFyIGZpbGxJbnN0cnVjdGlvbiA9IFtDYW52YXNJbnN0cnVjdGlvbi5TRVRfRklMTF9TVFlMRSwgZmlsbFN0eWxlXTtcbiAgICBpZiAodHlwZW9mIGZpbGxTdHlsZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIEZpbGwgaXMgYSBwYXR0ZXJuIG9yIGdyYWRpZW50IC0gYWxpZ24gaXQhXG4gICAgICBmaWxsSW5zdHJ1Y3Rpb24ucHVzaCh0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbGxJbnN0cnVjdGlvbjtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRmlsbFN0cm9rZVN0YXRlfSBzdGF0ZSBTdGF0ZS5cbiAgICovXG4gIENhbnZhc1JlcGxheS5wcm90b3R5cGUuYXBwbHlTdHJva2UgPSBmdW5jdGlvbiBhcHBseVN0cm9rZSAoc3RhdGUpIHtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKHRoaXMuY3JlYXRlU3Ryb2tlKHN0YXRlKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkZpbGxTdHJva2VTdGF0ZX0gc3RhdGUgU3RhdGUuXG4gICAqIEByZXR1cm4ge0FycmF5PCo+fSBTdHJva2UgaW5zdHJ1Y3Rpb24uXG4gICAqL1xuICBDYW52YXNSZXBsYXkucHJvdG90eXBlLmNyZWF0ZVN0cm9rZSA9IGZ1bmN0aW9uIGNyZWF0ZVN0cm9rZSAoc3RhdGUpIHtcbiAgICByZXR1cm4gW1xuICAgICAgQ2FudmFzSW5zdHJ1Y3Rpb24uU0VUX1NUUk9LRV9TVFlMRSxcbiAgICAgIHN0YXRlLnN0cm9rZVN0eWxlLCBzdGF0ZS5saW5lV2lkdGggKiB0aGlzLnBpeGVsUmF0aW8sIHN0YXRlLmxpbmVDYXAsXG4gICAgICBzdGF0ZS5saW5lSm9pbiwgc3RhdGUubWl0ZXJMaW1pdCxcbiAgICAgIHRoaXMuYXBwbHlQaXhlbFJhdGlvKHN0YXRlLmxpbmVEYXNoKSwgc3RhdGUubGluZURhc2hPZmZzZXQgKiB0aGlzLnBpeGVsUmF0aW9cbiAgICBdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5GaWxsU3Ryb2tlU3RhdGV9IHN0YXRlIFN0YXRlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6Q2FudmFzUmVwbGF5LCBpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRmlsbFN0cm9rZVN0YXRlLCAoaW1wb3J0KFwiLi4vLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdCkpOkFycmF5PCo+fSBjcmVhdGVGaWxsIENyZWF0ZSBmaWxsLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKi9cbiAgQ2FudmFzUmVwbGF5LnByb3RvdHlwZS51cGRhdGVGaWxsU3R5bGUgPSBmdW5jdGlvbiB1cGRhdGVGaWxsU3R5bGUgKHN0YXRlLCBjcmVhdGVGaWxsLCBnZW9tZXRyeSkge1xuICAgIHZhciBmaWxsU3R5bGUgPSBzdGF0ZS5maWxsU3R5bGU7XG4gICAgaWYgKHR5cGVvZiBmaWxsU3R5bGUgIT09ICdzdHJpbmcnIHx8IHN0YXRlLmN1cnJlbnRGaWxsU3R5bGUgIT0gZmlsbFN0eWxlKSB7XG4gICAgICBpZiAoZmlsbFN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChjcmVhdGVGaWxsLmNhbGwodGhpcywgc3RhdGUsIGdlb21ldHJ5KSk7XG4gICAgICB9XG4gICAgICBzdGF0ZS5jdXJyZW50RmlsbFN0eWxlID0gZmlsbFN0eWxlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRmlsbFN0cm9rZVN0YXRlfSBzdGF0ZSBTdGF0ZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOkNhbnZhc1JlcGxheSwgaW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkZpbGxTdHJva2VTdGF0ZSl9IGFwcGx5U3Ryb2tlIEFwcGx5IHN0cm9rZS5cbiAgICovXG4gIENhbnZhc1JlcGxheS5wcm90b3R5cGUudXBkYXRlU3Ryb2tlU3R5bGUgPSBmdW5jdGlvbiB1cGRhdGVTdHJva2VTdHlsZSAoc3RhdGUsIGFwcGx5U3Ryb2tlKSB7XG4gICAgdmFyIHN0cm9rZVN0eWxlID0gc3RhdGUuc3Ryb2tlU3R5bGU7XG4gICAgdmFyIGxpbmVDYXAgPSBzdGF0ZS5saW5lQ2FwO1xuICAgIHZhciBsaW5lRGFzaCA9IHN0YXRlLmxpbmVEYXNoO1xuICAgIHZhciBsaW5lRGFzaE9mZnNldCA9IHN0YXRlLmxpbmVEYXNoT2Zmc2V0O1xuICAgIHZhciBsaW5lSm9pbiA9IHN0YXRlLmxpbmVKb2luO1xuICAgIHZhciBsaW5lV2lkdGggPSBzdGF0ZS5saW5lV2lkdGg7XG4gICAgdmFyIG1pdGVyTGltaXQgPSBzdGF0ZS5taXRlckxpbWl0O1xuICAgIGlmIChzdGF0ZS5jdXJyZW50U3Ryb2tlU3R5bGUgIT0gc3Ryb2tlU3R5bGUgfHxcbiAgICAgICAgc3RhdGUuY3VycmVudExpbmVDYXAgIT0gbGluZUNhcCB8fFxuICAgICAgICAobGluZURhc2ggIT0gc3RhdGUuY3VycmVudExpbmVEYXNoICYmICFlcXVhbHMoc3RhdGUuY3VycmVudExpbmVEYXNoLCBsaW5lRGFzaCkpIHx8XG4gICAgICAgIHN0YXRlLmN1cnJlbnRMaW5lRGFzaE9mZnNldCAhPSBsaW5lRGFzaE9mZnNldCB8fFxuICAgICAgICBzdGF0ZS5jdXJyZW50TGluZUpvaW4gIT0gbGluZUpvaW4gfHxcbiAgICAgICAgc3RhdGUuY3VycmVudExpbmVXaWR0aCAhPSBsaW5lV2lkdGggfHxcbiAgICAgICAgc3RhdGUuY3VycmVudE1pdGVyTGltaXQgIT0gbWl0ZXJMaW1pdCkge1xuICAgICAgaWYgKHN0cm9rZVN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXBwbHlTdHJva2UuY2FsbCh0aGlzLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgICBzdGF0ZS5jdXJyZW50U3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZTtcbiAgICAgIHN0YXRlLmN1cnJlbnRMaW5lQ2FwID0gbGluZUNhcDtcbiAgICAgIHN0YXRlLmN1cnJlbnRMaW5lRGFzaCA9IGxpbmVEYXNoO1xuICAgICAgc3RhdGUuY3VycmVudExpbmVEYXNoT2Zmc2V0ID0gbGluZURhc2hPZmZzZXQ7XG4gICAgICBzdGF0ZS5jdXJyZW50TGluZUpvaW4gPSBsaW5lSm9pbjtcbiAgICAgIHN0YXRlLmN1cnJlbnRMaW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgICBzdGF0ZS5jdXJyZW50TWl0ZXJMaW1pdCA9IG1pdGVyTGltaXQ7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICovXG4gIENhbnZhc1JlcGxheS5wcm90b3R5cGUuZW5kR2VvbWV0cnkgPSBmdW5jdGlvbiBlbmRHZW9tZXRyeSAoZ2VvbWV0cnksIGZlYXR1cmUpIHtcbiAgICB0aGlzLmJlZ2luR2VvbWV0cnlJbnN0cnVjdGlvbjFfWzJdID0gdGhpcy5pbnN0cnVjdGlvbnMubGVuZ3RoO1xuICAgIHRoaXMuYmVnaW5HZW9tZXRyeUluc3RydWN0aW9uMV8gPSBudWxsO1xuICAgIHRoaXMuYmVnaW5HZW9tZXRyeUluc3RydWN0aW9uMl9bMl0gPSB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5sZW5ndGg7XG4gICAgdGhpcy5iZWdpbkdlb21ldHJ5SW5zdHJ1Y3Rpb24yXyA9IG51bGw7XG4gICAgdmFyIGVuZEdlb21ldHJ5SW5zdHJ1Y3Rpb24gPSBbQ2FudmFzSW5zdHJ1Y3Rpb24uRU5EX0dFT01FVFJZLCBmZWF0dXJlXTtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKGVuZEdlb21ldHJ5SW5zdHJ1Y3Rpb24pO1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goZW5kR2VvbWV0cnlJbnN0cnVjdGlvbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYnVmZmVyZWQgcmVuZGVyaW5nIGV4dGVudC4gIFJlbmRlcmluZyB3aWxsIGJlIGNsaXBwZWQgdG8gdGhlIGV4dGVudFxuICAgKiBwcm92aWRlZCB0byB0aGUgY29uc3RydWN0b3IuICBUbyBhY2NvdW50IGZvciBzeW1ib2xpemVycyB0aGF0IG1heSBpbnRlcnNlY3RcbiAgICogdGhpcyBleHRlbnQsIHdlIGNhbGN1bGF0ZSBhIGJ1ZmZlcmVkIGV4dGVudCAoZS5nLiBiYXNlZCBvbiBzdHJva2Ugd2lkdGgpLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fSBUaGUgYnVmZmVyZWQgcmVuZGVyaW5nIGV4dGVudC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgQ2FudmFzUmVwbGF5LnByb3RvdHlwZS5nZXRCdWZmZXJlZE1heEV4dGVudCA9IGZ1bmN0aW9uIGdldEJ1ZmZlcmVkTWF4RXh0ZW50ICgpIHtcbiAgICBpZiAoIXRoaXMuYnVmZmVyZWRNYXhFeHRlbnRfKSB7XG4gICAgICB0aGlzLmJ1ZmZlcmVkTWF4RXh0ZW50XyA9IGNsb25lKHRoaXMubWF4RXh0ZW50KTtcbiAgICAgIGlmICh0aGlzLm1heExpbmVXaWR0aCA+IDApIHtcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5yZXNvbHV0aW9uICogKHRoaXMubWF4TGluZVdpZHRoICsgMSkgLyAyO1xuICAgICAgICBidWZmZXIodGhpcy5idWZmZXJlZE1heEV4dGVudF8sIHdpZHRoLCB0aGlzLmJ1ZmZlcmVkTWF4RXh0ZW50Xyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmJ1ZmZlcmVkTWF4RXh0ZW50XztcbiAgfTtcblxuICByZXR1cm4gQ2FudmFzUmVwbGF5O1xufShWZWN0b3JDb250ZXh0KSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgQ2FudmFzUmVwbGF5O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZXBsYXkuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9jYW52YXMvUmVwbGF5R3JvdXBcbiAqL1xuXG5pbXBvcnQge251bWJlclNhZmVDb21wYXJlRnVuY3Rpb259IGZyb20gJy4uLy4uL2FycmF5LmpzJztcbmltcG9ydCB7Y3JlYXRlQ2FudmFzQ29udGV4dDJEfSBmcm9tICcuLi8uLi9kb20uanMnO1xuaW1wb3J0IHtidWZmZXIsIGNyZWF0ZUVtcHR5LCBleHRlbmRDb29yZGluYXRlfSBmcm9tICcuLi8uLi9leHRlbnQuanMnO1xuaW1wb3J0IHt0cmFuc2Zvcm0yRH0gZnJvbSAnLi4vLi4vZ2VvbS9mbGF0L3RyYW5zZm9ybS5qcyc7XG5pbXBvcnQge2lzRW1wdHl9IGZyb20gJy4uLy4uL29iai5qcyc7XG5pbXBvcnQgUmVwbGF5R3JvdXAgZnJvbSAnLi4vUmVwbGF5R3JvdXAuanMnO1xuaW1wb3J0IFJlcGxheVR5cGUgZnJvbSAnLi4vUmVwbGF5VHlwZS5qcyc7XG5pbXBvcnQgQ2FudmFzUmVwbGF5IGZyb20gJy4vUmVwbGF5LmpzJztcbmltcG9ydCBDYW52YXNJbWFnZVJlcGxheSBmcm9tICcuL0ltYWdlUmVwbGF5LmpzJztcbmltcG9ydCBDYW52YXNMaW5lU3RyaW5nUmVwbGF5IGZyb20gJy4vTGluZVN0cmluZ1JlcGxheS5qcyc7XG5pbXBvcnQgQ2FudmFzUG9seWdvblJlcGxheSBmcm9tICcuL1BvbHlnb25SZXBsYXkuanMnO1xuaW1wb3J0IENhbnZhc1RleHRSZXBsYXkgZnJvbSAnLi9UZXh0UmVwbGF5LmpzJztcbmltcG9ydCB7T1JERVJ9IGZyb20gJy4uL3JlcGxheS5qcyc7XG5pbXBvcnQge2NyZWF0ZSBhcyBjcmVhdGVUcmFuc2Zvcm0sIGNvbXBvc2UgYXMgY29tcG9zZVRyYW5zZm9ybX0gZnJvbSAnLi4vLi4vdHJhbnNmb3JtLmpzJztcblxuXG4vKipcbiAqIEB0eXBlIHtPYmplY3Q8UmVwbGF5VHlwZSwgdHlwZW9mIENhbnZhc1JlcGxheT59XG4gKi9cbnZhciBCQVRDSF9DT05TVFJVQ1RPUlMgPSB7XG4gICdDaXJjbGUnOiBDYW52YXNQb2x5Z29uUmVwbGF5LFxuICAnRGVmYXVsdCc6IENhbnZhc1JlcGxheSxcbiAgJ0ltYWdlJzogQ2FudmFzSW1hZ2VSZXBsYXksXG4gICdMaW5lU3RyaW5nJzogQ2FudmFzTGluZVN0cmluZ1JlcGxheSxcbiAgJ1BvbHlnb24nOiBDYW52YXNQb2x5Z29uUmVwbGF5LFxuICAnVGV4dCc6IENhbnZhc1RleHRSZXBsYXlcbn07XG5cblxudmFyIENhbnZhc1JlcGxheUdyb3VwID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoUmVwbGF5R3JvdXApIHtcbiAgZnVuY3Rpb24gQ2FudmFzUmVwbGF5R3JvdXAoXG4gICAgdG9sZXJhbmNlLFxuICAgIG1heEV4dGVudCxcbiAgICByZXNvbHV0aW9uLFxuICAgIHBpeGVsUmF0aW8sXG4gICAgb3ZlcmxhcHMsXG4gICAgZGVjbHV0dGVyVHJlZSxcbiAgICBvcHRfcmVuZGVyQnVmZmVyXG4gICkge1xuICAgIFJlcGxheUdyb3VwLmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBEZWNsdXR0ZXIgdHJlZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZGVjbHV0dGVyVHJlZV8gPSBkZWNsdXR0ZXJUcmVlO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5EZWNsdXR0ZXJHcm91cH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZGVjbHV0dGVyR3JvdXBfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRvbGVyYW5jZV8gPSB0b2xlcmFuY2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgICAqL1xuICAgIHRoaXMubWF4RXh0ZW50XyA9IG1heEV4dGVudDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5vdmVybGFwc18gPSBvdmVybGFwcztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnBpeGVsUmF0aW9fID0gcGl4ZWxSYXRpbztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc29sdXRpb25fID0gcmVzb2x1dGlvbjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJCdWZmZXJfID0gb3B0X3JlbmRlckJ1ZmZlcjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCAhT2JqZWN0PFJlcGxheVR5cGUsIENhbnZhc1JlcGxheT4+fVxuICAgICAqL1xuICAgIHRoaXMucmVwbGF5c0J5WkluZGV4XyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICAgICAqL1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uQ29udGV4dF8gPSBjcmVhdGVDYW52YXNDb250ZXh0MkQoMSwgMSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfVxuICAgICAqL1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uVHJhbnNmb3JtXyA9IGNyZWF0ZVRyYW5zZm9ybSgpO1xuICB9XG5cbiAgaWYgKCBSZXBsYXlHcm91cCApIENhbnZhc1JlcGxheUdyb3VwLl9fcHJvdG9fXyA9IFJlcGxheUdyb3VwO1xuICBDYW52YXNSZXBsYXlHcm91cC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBSZXBsYXlHcm91cCAmJiBSZXBsYXlHcm91cC5wcm90b3R5cGUgKTtcbiAgQ2FudmFzUmVwbGF5R3JvdXAucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2FudmFzUmVwbGF5R3JvdXA7XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNSZXBsYXlHcm91cC5wcm90b3R5cGUuYWRkRGVjbHV0dGVyID0gZnVuY3Rpb24gYWRkRGVjbHV0dGVyIChncm91cCkge1xuICAgIHZhciBkZWNsdXR0ZXIgPSBudWxsO1xuICAgIGlmICh0aGlzLmRlY2x1dHRlclRyZWVfKSB7XG4gICAgICBpZiAoZ3JvdXApIHtcbiAgICAgICAgZGVjbHV0dGVyID0gdGhpcy5kZWNsdXR0ZXJHcm91cF87XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoZGVjbHV0dGVyWzRdKSsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVjbHV0dGVyID0gdGhpcy5kZWNsdXR0ZXJHcm91cF8gPSBjcmVhdGVFbXB0eSgpO1xuICAgICAgICBkZWNsdXR0ZXIucHVzaCgxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlY2x1dHRlcjtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfSB0cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICAgKi9cbiAgQ2FudmFzUmVwbGF5R3JvdXAucHJvdG90eXBlLmNsaXAgPSBmdW5jdGlvbiBjbGlwIChjb250ZXh0LCB0cmFuc2Zvcm0pIHtcbiAgICB2YXIgZmxhdENsaXBDb29yZHMgPSB0aGlzLmdldENsaXBDb29yZHModHJhbnNmb3JtKTtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQubW92ZVRvKGZsYXRDbGlwQ29vcmRzWzBdLCBmbGF0Q2xpcENvb3Jkc1sxXSk7XG4gICAgY29udGV4dC5saW5lVG8oZmxhdENsaXBDb29yZHNbMl0sIGZsYXRDbGlwQ29vcmRzWzNdKTtcbiAgICBjb250ZXh0LmxpbmVUbyhmbGF0Q2xpcENvb3Jkc1s0XSwgZmxhdENsaXBDb29yZHNbNV0pO1xuICAgIGNvbnRleHQubGluZVRvKGZsYXRDbGlwQ29vcmRzWzZdLCBmbGF0Q2xpcENvb3Jkc1s3XSk7XG4gICAgY29udGV4dC5jbGlwKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8UmVwbGF5VHlwZT59IHJlcGxheXMgUmVwbGF5cy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSGFzIHJlcGxheXMgb2YgdGhlIHByb3ZpZGVkIHR5cGVzLlxuICAgKi9cbiAgQ2FudmFzUmVwbGF5R3JvdXAucHJvdG90eXBlLmhhc1JlcGxheXMgPSBmdW5jdGlvbiBoYXNSZXBsYXlzIChyZXBsYXlzKSB7XG4gICAgZm9yICh2YXIgekluZGV4IGluIHRoaXMucmVwbGF5c0J5WkluZGV4Xykge1xuICAgICAgdmFyIGNhbmRpZGF0ZXMgPSB0aGlzLnJlcGxheXNCeVpJbmRleF9bekluZGV4XTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHJlcGxheXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBpZiAocmVwbGF5c1tpXSBpbiBjYW5kaWRhdGVzKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGSVhNRSBlbXB0eSBkZXNjcmlwdGlvbiBmb3IganNkb2NcbiAgICovXG4gIENhbnZhc1JlcGxheUdyb3VwLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiBmaW5pc2ggKCkge1xuICAgIGZvciAodmFyIHpLZXkgaW4gdGhpcy5yZXBsYXlzQnlaSW5kZXhfKSB7XG4gICAgICB2YXIgcmVwbGF5cyA9IHRoaXMucmVwbGF5c0J5WkluZGV4X1t6S2V5XTtcbiAgICAgIGZvciAodmFyIHJlcGxheUtleSBpbiByZXBsYXlzKSB7XG4gICAgICAgIHJlcGxheXNbcmVwbGF5S2V5XS5maW5pc2goKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGhpdFRvbGVyYW5jZSBIaXQgdG9sZXJhbmNlIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBib29sZWFuPn0gc2tpcHBlZEZlYXR1cmVzSGFzaCBJZHMgb2YgZmVhdHVyZXMgdG8gc2tpcC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbigoaW1wb3J0KFwiLi4vLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdCkpOiBUfSBjYWxsYmFjayBGZWF0dXJlIGNhbGxiYWNrLlxuICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5EZWNsdXR0ZXJHcm91cD59IGRlY2x1dHRlclJlcGxheXMgRGVjbHV0dGVyIHJlcGxheXMuXG4gICAqIEByZXR1cm4ge1R8dW5kZWZpbmVkfSBDYWxsYmFjayByZXN1bHQuXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqL1xuICBDYW52YXNSZXBsYXlHcm91cC5wcm90b3R5cGUuZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGUgPSBmdW5jdGlvbiBmb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZSAoXG4gICAgY29vcmRpbmF0ZSxcbiAgICByZXNvbHV0aW9uLFxuICAgIHJvdGF0aW9uLFxuICAgIGhpdFRvbGVyYW5jZSxcbiAgICBza2lwcGVkRmVhdHVyZXNIYXNoLFxuICAgIGNhbGxiYWNrLFxuICAgIGRlY2x1dHRlclJlcGxheXNcbiAgKSB7XG5cbiAgICBoaXRUb2xlcmFuY2UgPSBNYXRoLnJvdW5kKGhpdFRvbGVyYW5jZSk7XG4gICAgdmFyIGNvbnRleHRTaXplID0gaGl0VG9sZXJhbmNlICogMiArIDE7XG4gICAgdmFyIHRyYW5zZm9ybSA9IGNvbXBvc2VUcmFuc2Zvcm0odGhpcy5oaXREZXRlY3Rpb25UcmFuc2Zvcm1fLFxuICAgICAgaGl0VG9sZXJhbmNlICsgMC41LCBoaXRUb2xlcmFuY2UgKyAwLjUsXG4gICAgICAxIC8gcmVzb2x1dGlvbiwgLTEgLyByZXNvbHV0aW9uLFxuICAgICAgLXJvdGF0aW9uLFxuICAgICAgLWNvb3JkaW5hdGVbMF0sIC1jb29yZGluYXRlWzFdKTtcbiAgICB2YXIgY29udGV4dCA9IHRoaXMuaGl0RGV0ZWN0aW9uQ29udGV4dF87XG5cbiAgICBpZiAoY29udGV4dC5jYW52YXMud2lkdGggIT09IGNvbnRleHRTaXplIHx8IGNvbnRleHQuY2FudmFzLmhlaWdodCAhPT0gY29udGV4dFNpemUpIHtcbiAgICAgIGNvbnRleHQuY2FudmFzLndpZHRoID0gY29udGV4dFNpemU7XG4gICAgICBjb250ZXh0LmNhbnZhcy5oZWlnaHQgPSBjb250ZXh0U2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgY29udGV4dFNpemUsIGNvbnRleHRTaXplKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAgICAgKi9cbiAgICB2YXIgaGl0RXh0ZW50O1xuICAgIGlmICh0aGlzLnJlbmRlckJ1ZmZlcl8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgaGl0RXh0ZW50ID0gY3JlYXRlRW1wdHkoKTtcbiAgICAgIGV4dGVuZENvb3JkaW5hdGUoaGl0RXh0ZW50LCBjb29yZGluYXRlKTtcbiAgICAgIGJ1ZmZlcihoaXRFeHRlbnQsIHJlc29sdXRpb24gKiAodGhpcy5yZW5kZXJCdWZmZXJfICsgaGl0VG9sZXJhbmNlKSwgaGl0RXh0ZW50KTtcbiAgICB9XG5cbiAgICB2YXIgbWFzayA9IGdldENpcmNsZUFycmF5KGhpdFRvbGVyYW5jZSk7XG4gICAgdmFyIGRlY2x1dHRlcmVkRmVhdHVyZXM7XG4gICAgaWYgKHRoaXMuZGVjbHV0dGVyVHJlZV8pIHtcbiAgICAgIGRlY2x1dHRlcmVkRmVhdHVyZXMgPSB0aGlzLmRlY2x1dHRlclRyZWVfLmFsbCgpLm1hcChmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICByZXR1cm4gZW50cnkudmFsdWU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgcmVwbGF5VHlwZTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICAgICAqIEByZXR1cm4gez99IENhbGxiYWNrIHJlc3VsdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmZWF0dXJlQ2FsbGJhY2soZmVhdHVyZSkge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNvbnRleHRTaXplLCBjb250ZXh0U2l6ZSkuZGF0YTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGV4dFNpemU7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbnRleHRTaXplOyBqKyspIHtcbiAgICAgICAgICBpZiAobWFza1tpXVtqXSkge1xuICAgICAgICAgICAgaWYgKGltYWdlRGF0YVsoaiAqIGNvbnRleHRTaXplICsgaSkgKiA0ICsgM10gPiAwKSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSAodm9pZCAwKTtcbiAgICAgICAgICAgICAgaWYgKCEoZGVjbHV0dGVyZWRGZWF0dXJlcyAmJiAocmVwbGF5VHlwZSA9PSBSZXBsYXlUeXBlLklNQUdFIHx8IHJlcGxheVR5cGUgPT0gUmVwbGF5VHlwZS5URVhUKSkgfHxcbiAgICAgICAgICAgICAgICAgIGRlY2x1dHRlcmVkRmVhdHVyZXMuaW5kZXhPZihmZWF0dXJlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjYWxsYmFjayhmZWF0dXJlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCBjb250ZXh0U2l6ZSwgY29udGV4dFNpemUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovXG4gICAgdmFyIHpzID0gT2JqZWN0LmtleXModGhpcy5yZXBsYXlzQnlaSW5kZXhfKS5tYXAoTnVtYmVyKTtcbiAgICB6cy5zb3J0KG51bWJlclNhZmVDb21wYXJlRnVuY3Rpb24pO1xuXG4gICAgdmFyIGksIGosIHJlcGxheXMsIHJlcGxheSwgcmVzdWx0O1xuICAgIGZvciAoaSA9IHpzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB2YXIgekluZGV4S2V5ID0genNbaV0udG9TdHJpbmcoKTtcbiAgICAgIHJlcGxheXMgPSB0aGlzLnJlcGxheXNCeVpJbmRleF9bekluZGV4S2V5XTtcbiAgICAgIGZvciAoaiA9IE9SREVSLmxlbmd0aCAtIDE7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgIHJlcGxheVR5cGUgPSBPUkRFUltqXTtcbiAgICAgICAgcmVwbGF5ID0gcmVwbGF5c1tyZXBsYXlUeXBlXTtcbiAgICAgICAgaWYgKHJlcGxheSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKGRlY2x1dHRlclJlcGxheXMgJiZcbiAgICAgICAgICAgICAgKHJlcGxheVR5cGUgPT0gUmVwbGF5VHlwZS5JTUFHRSB8fCByZXBsYXlUeXBlID09IFJlcGxheVR5cGUuVEVYVCkpIHtcbiAgICAgICAgICAgIHZhciBkZWNsdXR0ZXIgPSBkZWNsdXR0ZXJSZXBsYXlzW3pJbmRleEtleV07XG4gICAgICAgICAgICBpZiAoIWRlY2x1dHRlcikge1xuICAgICAgICAgICAgICBkZWNsdXR0ZXJSZXBsYXlzW3pJbmRleEtleV0gPSBbcmVwbGF5LCB0cmFuc2Zvcm0uc2xpY2UoMCldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGVjbHV0dGVyLnB1c2gocmVwbGF5LCB0cmFuc2Zvcm0uc2xpY2UoMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXBsYXkucmVwbGF5SGl0RGV0ZWN0aW9uKGNvbnRleHQsIHRyYW5zZm9ybSwgcm90YXRpb24sXG4gICAgICAgICAgICAgIHNraXBwZWRGZWF0dXJlc0hhc2gsIGZlYXR1cmVDYWxsYmFjaywgaGl0RXh0ZW50KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfSB0cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBDbGlwIGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgQ2FudmFzUmVwbGF5R3JvdXAucHJvdG90eXBlLmdldENsaXBDb29yZHMgPSBmdW5jdGlvbiBnZXRDbGlwQ29vcmRzICh0cmFuc2Zvcm0pIHtcbiAgICB2YXIgbWF4RXh0ZW50ID0gdGhpcy5tYXhFeHRlbnRfO1xuICAgIHZhciBtaW5YID0gbWF4RXh0ZW50WzBdO1xuICAgIHZhciBtaW5ZID0gbWF4RXh0ZW50WzFdO1xuICAgIHZhciBtYXhYID0gbWF4RXh0ZW50WzJdO1xuICAgIHZhciBtYXhZID0gbWF4RXh0ZW50WzNdO1xuICAgIHZhciBmbGF0Q2xpcENvb3JkcyA9IFttaW5YLCBtaW5ZLCBtaW5YLCBtYXhZLCBtYXhYLCBtYXhZLCBtYXhYLCBtaW5ZXTtcbiAgICB0cmFuc2Zvcm0yRChcbiAgICAgIGZsYXRDbGlwQ29vcmRzLCAwLCA4LCAyLCB0cmFuc2Zvcm0sIGZsYXRDbGlwQ29vcmRzKTtcbiAgICByZXR1cm4gZmxhdENsaXBDb29yZHM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNSZXBsYXlHcm91cC5wcm90b3R5cGUuZ2V0UmVwbGF5ID0gZnVuY3Rpb24gZ2V0UmVwbGF5ICh6SW5kZXgsIHJlcGxheVR5cGUpIHtcbiAgICB2YXIgekluZGV4S2V5ID0gekluZGV4ICE9PSB1bmRlZmluZWQgPyB6SW5kZXgudG9TdHJpbmcoKSA6ICcwJztcbiAgICB2YXIgcmVwbGF5cyA9IHRoaXMucmVwbGF5c0J5WkluZGV4X1t6SW5kZXhLZXldO1xuICAgIGlmIChyZXBsYXlzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlcGxheXMgPSB7fTtcbiAgICAgIHRoaXMucmVwbGF5c0J5WkluZGV4X1t6SW5kZXhLZXldID0gcmVwbGF5cztcbiAgICB9XG4gICAgdmFyIHJlcGxheSA9IHJlcGxheXNbcmVwbGF5VHlwZV07XG4gICAgaWYgKHJlcGxheSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgQ29uc3RydWN0b3IgPSBCQVRDSF9DT05TVFJVQ1RPUlNbcmVwbGF5VHlwZV07XG4gICAgICByZXBsYXkgPSBuZXcgQ29uc3RydWN0b3IodGhpcy50b2xlcmFuY2VfLCB0aGlzLm1heEV4dGVudF8sXG4gICAgICAgIHRoaXMucmVzb2x1dGlvbl8sIHRoaXMucGl4ZWxSYXRpb18sIHRoaXMub3ZlcmxhcHNfLCB0aGlzLmRlY2x1dHRlclRyZWVfKTtcbiAgICAgIHJlcGxheXNbcmVwbGF5VHlwZV0gPSByZXBsYXk7XG4gICAgfVxuICAgIHJldHVybiByZXBsYXk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsIE9iamVjdDxSZXBsYXlUeXBlLCBDYW52YXNSZXBsYXk+Pn0gUmVwbGF5cy5cbiAgICovXG4gIENhbnZhc1JlcGxheUdyb3VwLnByb3RvdHlwZS5nZXRSZXBsYXlzID0gZnVuY3Rpb24gZ2V0UmVwbGF5cyAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVwbGF5c0J5WkluZGV4XztcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENhbnZhc1JlcGxheUdyb3VwLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSQxICgpIHtcbiAgICByZXR1cm4gaXNFbXB0eSh0aGlzLnJlcGxheXNCeVpJbmRleF8pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBDb250ZXh0LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19IHRyYW5zZm9ybSBUcmFuc2Zvcm0uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2aWV3Um90YXRpb24gVmlldyByb3RhdGlvbi5cbiAgICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBib29sZWFuPn0gc2tpcHBlZEZlYXR1cmVzSGFzaCBJZHMgb2YgZmVhdHVyZXMgdG8gc2tpcC5cbiAgICogQHBhcmFtIHtib29sZWFufSBzbmFwVG9QaXhlbCBTbmFwIHBvaW50IHN5bWJvbHMgYW5kIHRlc3QgdG8gaW50ZWdlciBwaXhlbC5cbiAgICogQHBhcmFtIHtBcnJheTxSZXBsYXlUeXBlPj19IG9wdF9yZXBsYXlUeXBlcyBPcmRlcmVkIHJlcGxheSB0eXBlcyB0byByZXBsYXkuXG4gICAqICAgICBEZWZhdWx0IGlzIHtAbGluayBtb2R1bGU6b2wvcmVuZGVyL3JlcGxheX5PUkRFUn1cbiAgICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRGVjbHV0dGVyR3JvdXA+PX0gb3B0X2RlY2x1dHRlclJlcGxheXMgRGVjbHV0dGVyIHJlcGxheXMuXG4gICAqL1xuICBDYW52YXNSZXBsYXlHcm91cC5wcm90b3R5cGUucmVwbGF5ID0gZnVuY3Rpb24gcmVwbGF5IChcbiAgICBjb250ZXh0LFxuICAgIHRyYW5zZm9ybSxcbiAgICB2aWV3Um90YXRpb24sXG4gICAgc2tpcHBlZEZlYXR1cmVzSGFzaCxcbiAgICBzbmFwVG9QaXhlbCxcbiAgICBvcHRfcmVwbGF5VHlwZXMsXG4gICAgb3B0X2RlY2x1dHRlclJlcGxheXNcbiAgKSB7XG5cbiAgICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovXG4gICAgdmFyIHpzID0gT2JqZWN0LmtleXModGhpcy5yZXBsYXlzQnlaSW5kZXhfKS5tYXAoTnVtYmVyKTtcbiAgICB6cy5zb3J0KG51bWJlclNhZmVDb21wYXJlRnVuY3Rpb24pO1xuXG4gICAgLy8gc2V0dXAgY2xpcHBpbmcgc28gdGhhdCB0aGUgcGFydHMgb2Ygb3Zlci1zaW1wbGlmaWVkIGdlb21ldHJpZXMgYXJlIG5vdFxuICAgIC8vIHZpc2libGUgb3V0c2lkZSB0aGUgY3VycmVudCBleHRlbnQgd2hlbiBwYW5uaW5nXG4gICAgY29udGV4dC5zYXZlKCk7XG4gICAgdGhpcy5jbGlwKGNvbnRleHQsIHRyYW5zZm9ybSk7XG5cbiAgICB2YXIgcmVwbGF5VHlwZXMgPSBvcHRfcmVwbGF5VHlwZXMgPyBvcHRfcmVwbGF5VHlwZXMgOiBPUkRFUjtcbiAgICB2YXIgaSwgaWksIGosIGpqLCByZXBsYXlzLCByZXBsYXk7XG4gICAgZm9yIChpID0gMCwgaWkgPSB6cy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB2YXIgekluZGV4S2V5ID0genNbaV0udG9TdHJpbmcoKTtcbiAgICAgIHJlcGxheXMgPSB0aGlzLnJlcGxheXNCeVpJbmRleF9bekluZGV4S2V5XTtcbiAgICAgIGZvciAoaiA9IDAsIGpqID0gcmVwbGF5VHlwZXMubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgICB2YXIgcmVwbGF5VHlwZSA9IHJlcGxheVR5cGVzW2pdO1xuICAgICAgICByZXBsYXkgPSByZXBsYXlzW3JlcGxheVR5cGVdO1xuICAgICAgICBpZiAocmVwbGF5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAob3B0X2RlY2x1dHRlclJlcGxheXMgJiZcbiAgICAgICAgICAgICAgKHJlcGxheVR5cGUgPT0gUmVwbGF5VHlwZS5JTUFHRSB8fCByZXBsYXlUeXBlID09IFJlcGxheVR5cGUuVEVYVCkpIHtcbiAgICAgICAgICAgIHZhciBkZWNsdXR0ZXIgPSBvcHRfZGVjbHV0dGVyUmVwbGF5c1t6SW5kZXhLZXldO1xuICAgICAgICAgICAgaWYgKCFkZWNsdXR0ZXIpIHtcbiAgICAgICAgICAgICAgb3B0X2RlY2x1dHRlclJlcGxheXNbekluZGV4S2V5XSA9IFtyZXBsYXksIHRyYW5zZm9ybS5zbGljZSgwKV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkZWNsdXR0ZXIucHVzaChyZXBsYXksIHRyYW5zZm9ybS5zbGljZSgwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcGxheS5yZXBsYXkoY29udGV4dCwgdHJhbnNmb3JtLCB2aWV3Um90YXRpb24sIHNraXBwZWRGZWF0dXJlc0hhc2gsIHNuYXBUb1BpeGVsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgfTtcblxuICByZXR1cm4gQ2FudmFzUmVwbGF5R3JvdXA7XG59KFJlcGxheUdyb3VwKSk7XG5cblxuLyoqXG4gKiBUaGlzIGNhY2hlIGlzIHVzZWQgZm9yIHN0b3JpbmcgY2FsY3VsYXRlZCBwaXhlbCBjaXJjbGVzIGZvciBpbmNyZWFzaW5nIHBlcmZvcm1hbmNlLlxuICogSXQgaXMgYSBzdGF0aWMgcHJvcGVydHkgdG8gYWxsb3cgZWFjaCBSZXBsYXlncm91cCB0byBhY2Nlc3MgaXQuXG4gKiBAdHlwZSB7T2JqZWN0PG51bWJlciwgQXJyYXk8QXJyYXk8KGJvb2xlYW58dW5kZWZpbmVkKT4+Pn1cbiAqL1xudmFyIGNpcmNsZUFycmF5Q2FjaGUgPSB7XG4gIDA6IFtbdHJ1ZV1dXG59O1xuXG5cbi8qKlxuICogVGhpcyBtZXRob2QgZmlsbHMgYSByb3cgaW4gdGhlIGFycmF5IGZyb20gdGhlIGdpdmVuIGNvb3JkaW5hdGUgdG8gdGhlXG4gKiBtaWRkbGUgd2l0aCBgdHJ1ZWAuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PChib29sZWFufHVuZGVmaW5lZCk+Pn0gYXJyYXkgVGhlIGFycmF5IHRoYXQgd2lsbCBiZSBhbHRlcmVkLlxuICogQHBhcmFtIHtudW1iZXJ9IHggWCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWSBjb29yZGluYXRlLlxuICovXG5mdW5jdGlvbiBmaWxsQ2lyY2xlQXJyYXlSb3dUb01pZGRsZShhcnJheSwgeCwgeSkge1xuICB2YXIgaTtcbiAgdmFyIHJhZGl1cyA9IE1hdGguZmxvb3IoYXJyYXkubGVuZ3RoIC8gMik7XG4gIGlmICh4ID49IHJhZGl1cykge1xuICAgIGZvciAoaSA9IHJhZGl1czsgaSA8IHg7IGkrKykge1xuICAgICAgYXJyYXlbaV1beV0gPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIGlmICh4IDwgcmFkaXVzKSB7XG4gICAgZm9yIChpID0geCArIDE7IGkgPCByYWRpdXM7IGkrKykge1xuICAgICAgYXJyYXlbaV1beV0gPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5cbi8qKlxuICogVGhpcyBtZXRob2RzIGNyZWF0ZXMgYSBjaXJjbGUgaW5zaWRlIGEgZml0dGluZyBhcnJheS4gUG9pbnRzIGluc2lkZSB0aGVcbiAqIGNpcmNsZSBhcmUgbWFya2VkIGJ5IHRydWUsIHBvaW50cyBvbiB0aGUgb3V0c2lkZSBhcmUgdW5kZWZpbmVkLlxuICogSXQgdXNlcyB0aGUgbWlkcG9pbnQgY2lyY2xlIGFsZ29yaXRobS5cbiAqIEEgY2FjaGUgaXMgdXNlZCB0byBpbmNyZWFzZSBwZXJmb3JtYW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgUmFkaXVzLlxuICogQHJldHVybnMge0FycmF5PEFycmF5PChib29sZWFufHVuZGVmaW5lZCk+Pn0gQW4gYXJyYXkgd2l0aCBtYXJrZWQgY2lyY2xlIHBvaW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENpcmNsZUFycmF5KHJhZGl1cykge1xuICBpZiAoY2lyY2xlQXJyYXlDYWNoZVtyYWRpdXNdICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gY2lyY2xlQXJyYXlDYWNoZVtyYWRpdXNdO1xuICB9XG5cbiAgdmFyIGFycmF5U2l6ZSA9IHJhZGl1cyAqIDIgKyAxO1xuICB2YXIgYXJyID0gbmV3IEFycmF5KGFycmF5U2l6ZSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlTaXplOyBpKyspIHtcbiAgICBhcnJbaV0gPSBuZXcgQXJyYXkoYXJyYXlTaXplKTtcbiAgfVxuXG4gIHZhciB4ID0gcmFkaXVzO1xuICB2YXIgeSA9IDA7XG4gIHZhciBlcnJvciA9IDA7XG5cbiAgd2hpbGUgKHggPj0geSkge1xuICAgIGZpbGxDaXJjbGVBcnJheVJvd1RvTWlkZGxlKGFyciwgcmFkaXVzICsgeCwgcmFkaXVzICsgeSk7XG4gICAgZmlsbENpcmNsZUFycmF5Um93VG9NaWRkbGUoYXJyLCByYWRpdXMgKyB5LCByYWRpdXMgKyB4KTtcbiAgICBmaWxsQ2lyY2xlQXJyYXlSb3dUb01pZGRsZShhcnIsIHJhZGl1cyAtIHksIHJhZGl1cyArIHgpO1xuICAgIGZpbGxDaXJjbGVBcnJheVJvd1RvTWlkZGxlKGFyciwgcmFkaXVzIC0geCwgcmFkaXVzICsgeSk7XG4gICAgZmlsbENpcmNsZUFycmF5Um93VG9NaWRkbGUoYXJyLCByYWRpdXMgLSB4LCByYWRpdXMgLSB5KTtcbiAgICBmaWxsQ2lyY2xlQXJyYXlSb3dUb01pZGRsZShhcnIsIHJhZGl1cyAtIHksIHJhZGl1cyAtIHgpO1xuICAgIGZpbGxDaXJjbGVBcnJheVJvd1RvTWlkZGxlKGFyciwgcmFkaXVzICsgeSwgcmFkaXVzIC0geCk7XG4gICAgZmlsbENpcmNsZUFycmF5Um93VG9NaWRkbGUoYXJyLCByYWRpdXMgKyB4LCByYWRpdXMgLSB5KTtcblxuICAgIHkrKztcbiAgICBlcnJvciArPSAxICsgMiAqIHk7XG4gICAgaWYgKDIgKiAoZXJyb3IgLSB4KSArIDEgPiAwKSB7XG4gICAgICB4IC09IDE7XG4gICAgICBlcnJvciArPSAxIC0gMiAqIHg7XG4gICAgfVxuICB9XG5cbiAgY2lyY2xlQXJyYXlDYWNoZVtyYWRpdXNdID0gYXJyO1xuICByZXR1cm4gYXJyO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHshT2JqZWN0PHN0cmluZywgQXJyYXk8Kj4+fSBkZWNsdXR0ZXJSZXBsYXlzIERlY2x1dHRlciByZXBsYXlzLlxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc25hcFRvUGl4ZWwgU25hcCBwb2ludCBzeW1ib2xzIGFuZCB0ZXh0IHRvIGludGVnZXIgcGl4ZWxzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVwbGF5RGVjbHV0dGVyKGRlY2x1dHRlclJlcGxheXMsIGNvbnRleHQsIHJvdGF0aW9uLCBzbmFwVG9QaXhlbCkge1xuICB2YXIgenMgPSBPYmplY3Qua2V5cyhkZWNsdXR0ZXJSZXBsYXlzKS5tYXAoTnVtYmVyKS5zb3J0KG51bWJlclNhZmVDb21wYXJlRnVuY3Rpb24pO1xuICB2YXIgc2tpcHBlZEZlYXR1cmVVaWRzID0ge307XG4gIGZvciAodmFyIHogPSAwLCB6eiA9IHpzLmxlbmd0aDsgeiA8IHp6OyArK3opIHtcbiAgICB2YXIgcmVwbGF5RGF0YSA9IGRlY2x1dHRlclJlcGxheXNbenNbel0udG9TdHJpbmcoKV07XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcmVwbGF5RGF0YS5sZW5ndGg7IGkgPCBpaTspIHtcbiAgICAgIHZhciByZXBsYXkgPSByZXBsYXlEYXRhW2krK107XG4gICAgICB2YXIgdHJhbnNmb3JtID0gcmVwbGF5RGF0YVtpKytdO1xuICAgICAgcmVwbGF5LnJlcGxheShjb250ZXh0LCB0cmFuc2Zvcm0sIHJvdGF0aW9uLCBza2lwcGVkRmVhdHVyZVVpZHMsIHNuYXBUb1BpeGVsKTtcbiAgICB9XG4gIH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBDYW52YXNSZXBsYXlHcm91cDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVwbGF5R3JvdXAuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9jYW52YXMvVGV4dFJlcGxheVxuICovXG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi4vLi4vdXRpbC5qcyc7XG5pbXBvcnQge2FzQ29sb3JMaWtlfSBmcm9tICcuLi8uLi9jb2xvcmxpa2UuanMnO1xuaW1wb3J0IHtjcmVhdGVDYW52YXNDb250ZXh0MkR9IGZyb20gJy4uLy4uL2RvbS5qcyc7XG5pbXBvcnQge2ludGVyc2VjdHN9IGZyb20gJy4uLy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge21hdGNoaW5nQ2h1bmt9IGZyb20gJy4uLy4uL2dlb20vZmxhdC9zdHJhaWdodGNodW5rLmpzJztcbmltcG9ydCBHZW9tZXRyeVR5cGUgZnJvbSAnLi4vLi4vZ2VvbS9HZW9tZXRyeVR5cGUuanMnO1xuaW1wb3J0IHtDQU5WQVNfTElORV9EQVNIfSBmcm9tICcuLi8uLi9oYXMuanMnO1xuaW1wb3J0IHtsYWJlbENhY2hlLCBtZWFzdXJlVGV4dFdpZHRoLCBkZWZhdWx0VGV4dEFsaWduLCBtZWFzdXJlVGV4dEhlaWdodCwgZGVmYXVsdFBhZGRpbmcsIGRlZmF1bHRMaW5lQ2FwLCBkZWZhdWx0TGluZURhc2hPZmZzZXQsIGRlZmF1bHRMaW5lRGFzaCwgZGVmYXVsdExpbmVKb2luLCBkZWZhdWx0RmlsbFN0eWxlLCBjaGVja0ZvbnQsIGRlZmF1bHRGb250LCBkZWZhdWx0TGluZVdpZHRoLCBkZWZhdWx0TWl0ZXJMaW1pdCwgZGVmYXVsdFN0cm9rZVN0eWxlLCBkZWZhdWx0VGV4dEJhc2VsaW5lfSBmcm9tICcuLi9jYW52YXMuanMnO1xuaW1wb3J0IENhbnZhc0luc3RydWN0aW9uIGZyb20gJy4vSW5zdHJ1Y3Rpb24uanMnO1xuaW1wb3J0IENhbnZhc1JlcGxheSBmcm9tICcuL1JlcGxheS5qcyc7XG5pbXBvcnQge1RFWFRfQUxJR059IGZyb20gJy4uL3JlcGxheS5qcyc7XG5pbXBvcnQgVGV4dFBsYWNlbWVudCBmcm9tICcuLi8uLi9zdHlsZS9UZXh0UGxhY2VtZW50LmpzJztcblxudmFyIENhbnZhc1RleHRSZXBsYXkgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChDYW52YXNSZXBsYXkpIHtcbiAgZnVuY3Rpb24gQ2FudmFzVGV4dFJlcGxheSh0b2xlcmFuY2UsIG1heEV4dGVudCwgcmVzb2x1dGlvbiwgcGl4ZWxSYXRpbywgb3ZlcmxhcHMsIGRlY2x1dHRlclRyZWUpIHtcbiAgICBDYW52YXNSZXBsYXkuY2FsbCh0aGlzLCB0b2xlcmFuY2UsIG1heEV4dGVudCwgcmVzb2x1dGlvbiwgcGl4ZWxSYXRpbywgb3ZlcmxhcHMsIGRlY2x1dHRlclRyZWUpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkRlY2x1dHRlckdyb3VwfVxuICAgICAqL1xuICAgIHRoaXMuZGVjbHV0dGVyR3JvdXBfO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8SFRNTENhbnZhc0VsZW1lbnQ+fVxuICAgICAqL1xuICAgIHRoaXMubGFiZWxzXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy50ZXh0XyA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudGV4dE9mZnNldFhfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRleHRPZmZzZXRZXyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnRleHRSb3RhdGVXaXRoVmlld18gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50ZXh0Um90YXRpb25fID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRmlsbFN0YXRlfVxuICAgICAqL1xuICAgIHRoaXMudGV4dEZpbGxTdGF0ZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRmlsbFN0YXRlPn1cbiAgICAgKi9cbiAgICB0aGlzLmZpbGxTdGF0ZXMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuLi9jYW52YXMuanNcIikuU3Ryb2tlU3RhdGV9XG4gICAgICovXG4gICAgdGhpcy50ZXh0U3Ryb2tlU3RhdGVfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLlN0cm9rZVN0YXRlPn1cbiAgICAgKi9cbiAgICB0aGlzLnN0cm9rZVN0YXRlcyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLlRleHRTdGF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLnRleHRTdGF0ZV8gPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5UZXh0U3RhdGV9ICovICh7fSk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5UZXh0U3RhdGU+fVxuICAgICAqL1xuICAgIHRoaXMudGV4dFN0YXRlcyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMudGV4dEtleV8gPSAnJztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmZpbGxLZXlfID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5zdHJva2VLZXlfID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBudW1iZXI+Pn1cbiAgICAgKi9cbiAgICB0aGlzLndpZHRoc18gPSB7fTtcblxuICAgIGxhYmVsQ2FjaGUucHJ1bmUoKTtcblxuICB9XG5cbiAgaWYgKCBDYW52YXNSZXBsYXkgKSBDYW52YXNUZXh0UmVwbGF5Ll9fcHJvdG9fXyA9IENhbnZhc1JlcGxheTtcbiAgQ2FudmFzVGV4dFJlcGxheS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDYW52YXNSZXBsYXkgJiYgQ2FudmFzUmVwbGF5LnByb3RvdHlwZSApO1xuICBDYW52YXNUZXh0UmVwbGF5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhbnZhc1RleHRSZXBsYXk7XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNUZXh0UmVwbGF5LnByb3RvdHlwZS5kcmF3VGV4dCA9IGZ1bmN0aW9uIGRyYXdUZXh0IChnZW9tZXRyeSwgZmVhdHVyZSkge1xuICAgIHZhciBmaWxsU3RhdGUgPSB0aGlzLnRleHRGaWxsU3RhdGVfO1xuICAgIHZhciBzdHJva2VTdGF0ZSA9IHRoaXMudGV4dFN0cm9rZVN0YXRlXztcbiAgICB2YXIgdGV4dFN0YXRlID0gdGhpcy50ZXh0U3RhdGVfO1xuICAgIGlmICh0aGlzLnRleHRfID09PSAnJyB8fCAhdGV4dFN0YXRlIHx8ICghZmlsbFN0YXRlICYmICFzdHJva2VTdGF0ZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYmVnaW4gPSB0aGlzLmNvb3JkaW5hdGVzLmxlbmd0aDtcblxuICAgIHZhciBnZW9tZXRyeVR5cGUgPSBnZW9tZXRyeS5nZXRUeXBlKCk7XG4gICAgdmFyIGZsYXRDb29yZGluYXRlcyA9IG51bGw7XG4gICAgdmFyIGVuZCA9IDI7XG4gICAgdmFyIHN0cmlkZSA9IDI7XG4gICAgdmFyIGksIGlpO1xuXG4gICAgaWYgKHRleHRTdGF0ZS5wbGFjZW1lbnQgPT09IFRleHRQbGFjZW1lbnQuTElORSkge1xuICAgICAgaWYgKCFpbnRlcnNlY3RzKHRoaXMuZ2V0QnVmZmVyZWRNYXhFeHRlbnQoKSwgZ2VvbWV0cnkuZ2V0RXh0ZW50KCkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBlbmRzO1xuICAgICAgZmxhdENvb3JkaW5hdGVzID0gZ2VvbWV0cnkuZ2V0RmxhdENvb3JkaW5hdGVzKCk7XG4gICAgICBzdHJpZGUgPSBnZW9tZXRyeS5nZXRTdHJpZGUoKTtcbiAgICAgIGlmIChnZW9tZXRyeVR5cGUgPT0gR2VvbWV0cnlUeXBlLkxJTkVfU1RSSU5HKSB7XG4gICAgICAgIGVuZHMgPSBbZmxhdENvb3JkaW5hdGVzLmxlbmd0aF07XG4gICAgICB9IGVsc2UgaWYgKGdlb21ldHJ5VHlwZSA9PSBHZW9tZXRyeVR5cGUuTVVMVElfTElORV9TVFJJTkcpIHtcbiAgICAgICAgZW5kcyA9IGdlb21ldHJ5LmdldEVuZHMoKTtcbiAgICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnlUeXBlID09IEdlb21ldHJ5VHlwZS5QT0xZR09OKSB7XG4gICAgICAgIGVuZHMgPSBnZW9tZXRyeS5nZXRFbmRzKCkuc2xpY2UoMCwgMSk7XG4gICAgICB9IGVsc2UgaWYgKGdlb21ldHJ5VHlwZSA9PSBHZW9tZXRyeVR5cGUuTVVMVElfUE9MWUdPTikge1xuICAgICAgICB2YXIgZW5kc3MgPSBnZW9tZXRyeS5nZXRFbmRzcygpO1xuICAgICAgICBlbmRzID0gW107XG4gICAgICAgIGZvciAoaSA9IDAsIGlpID0gZW5kc3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgIGVuZHMucHVzaChlbmRzc1tpXVswXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuYmVnaW5HZW9tZXRyeShnZW9tZXRyeSwgZmVhdHVyZSk7XG4gICAgICB2YXIgdGV4dEFsaWduID0gdGV4dFN0YXRlLnRleHRBbGlnbjtcbiAgICAgIHZhciBmbGF0T2Zmc2V0ID0gMDtcbiAgICAgIHZhciBmbGF0RW5kO1xuICAgICAgZm9yICh2YXIgbyA9IDAsIG9vID0gZW5kcy5sZW5ndGg7IG8gPCBvbzsgKytvKSB7XG4gICAgICAgIGlmICh0ZXh0QWxpZ24gPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIHJhbmdlID0gbWF0Y2hpbmdDaHVuayh0ZXh0U3RhdGUubWF4QW5nbGUsIGZsYXRDb29yZGluYXRlcywgZmxhdE9mZnNldCwgZW5kc1tvXSwgc3RyaWRlKTtcbiAgICAgICAgICBmbGF0T2Zmc2V0ID0gcmFuZ2VbMF07XG4gICAgICAgICAgZmxhdEVuZCA9IHJhbmdlWzFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZsYXRFbmQgPSBlbmRzW29dO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IGZsYXRPZmZzZXQ7IGkgPCBmbGF0RW5kOyBpICs9IHN0cmlkZSkge1xuICAgICAgICAgIHRoaXMuY29vcmRpbmF0ZXMucHVzaChmbGF0Q29vcmRpbmF0ZXNbaV0sIGZsYXRDb29yZGluYXRlc1tpICsgMV0pO1xuICAgICAgICB9XG4gICAgICAgIGVuZCA9IHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgICAgICBmbGF0T2Zmc2V0ID0gZW5kc1tvXTtcbiAgICAgICAgdGhpcy5kcmF3Q2hhcnNfKGJlZ2luLCBlbmQsIHRoaXMuZGVjbHV0dGVyR3JvdXBfKTtcbiAgICAgICAgYmVnaW4gPSBlbmQ7XG4gICAgICB9XG4gICAgICB0aGlzLmVuZEdlb21ldHJ5KGdlb21ldHJ5LCBmZWF0dXJlKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbGFiZWwgPSB0aGlzLmdldEltYWdlKHRoaXMudGV4dF8sIHRoaXMudGV4dEtleV8sIHRoaXMuZmlsbEtleV8sIHRoaXMuc3Ryb2tlS2V5Xyk7XG4gICAgICB2YXIgd2lkdGggPSBsYWJlbC53aWR0aCAvIHRoaXMucGl4ZWxSYXRpbztcbiAgICAgIHN3aXRjaCAoZ2VvbWV0cnlUeXBlKSB7XG4gICAgICAgIGNhc2UgR2VvbWV0cnlUeXBlLlBPSU5UOlxuICAgICAgICBjYXNlIEdlb21ldHJ5VHlwZS5NVUxUSV9QT0lOVDpcbiAgICAgICAgICBmbGF0Q29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICAgICAgICBlbmQgPSBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdlb21ldHJ5VHlwZS5MSU5FX1NUUklORzpcbiAgICAgICAgICBmbGF0Q29vcmRpbmF0ZXMgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2dlb20vTGluZVN0cmluZy5qc1wiKS5kZWZhdWx0fSAqLyAoZ2VvbWV0cnkpLmdldEZsYXRNaWRwb2ludCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdlb21ldHJ5VHlwZS5DSVJDTEU6XG4gICAgICAgICAgZmxhdENvb3JkaW5hdGVzID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9nZW9tL0NpcmNsZS5qc1wiKS5kZWZhdWx0fSAqLyAoZ2VvbWV0cnkpLmdldENlbnRlcigpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdlb21ldHJ5VHlwZS5NVUxUSV9MSU5FX1NUUklORzpcbiAgICAgICAgICBmbGF0Q29vcmRpbmF0ZXMgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2dlb20vTXVsdGlMaW5lU3RyaW5nLmpzXCIpLmRlZmF1bHR9ICovIChnZW9tZXRyeSkuZ2V0RmxhdE1pZHBvaW50cygpO1xuICAgICAgICAgIGVuZCA9IGZsYXRDb29yZGluYXRlcy5sZW5ndGg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR2VvbWV0cnlUeXBlLlBPTFlHT046XG4gICAgICAgICAgZmxhdENvb3JkaW5hdGVzID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9nZW9tL1BvbHlnb24uanNcIikuZGVmYXVsdH0gKi8gKGdlb21ldHJ5KS5nZXRGbGF0SW50ZXJpb3JQb2ludCgpO1xuICAgICAgICAgIGlmICghdGV4dFN0YXRlLm92ZXJmbG93ICYmIGZsYXRDb29yZGluYXRlc1syXSAvIHRoaXMucmVzb2x1dGlvbiA8IHdpZHRoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0cmlkZSA9IDM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR2VvbWV0cnlUeXBlLk1VTFRJX1BPTFlHT046XG4gICAgICAgICAgdmFyIGludGVyaW9yUG9pbnRzID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9nZW9tL011bHRpUG9seWdvbi5qc1wiKS5kZWZhdWx0fSAqLyAoZ2VvbWV0cnkpLmdldEZsYXRJbnRlcmlvclBvaW50cygpO1xuICAgICAgICAgIGZsYXRDb29yZGluYXRlcyA9IFtdO1xuICAgICAgICAgIGZvciAoaSA9IDAsIGlpID0gaW50ZXJpb3JQb2ludHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMykge1xuICAgICAgICAgICAgaWYgKHRleHRTdGF0ZS5vdmVyZmxvdyB8fCBpbnRlcmlvclBvaW50c1tpICsgMl0gLyB0aGlzLnJlc29sdXRpb24gPj0gd2lkdGgpIHtcbiAgICAgICAgICAgICAgZmxhdENvb3JkaW5hdGVzLnB1c2goaW50ZXJpb3JQb2ludHNbaV0sIGludGVyaW9yUG9pbnRzW2kgKyAxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVuZCA9IGZsYXRDb29yZGluYXRlcy5sZW5ndGg7XG4gICAgICAgICAgaWYgKGVuZCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgfVxuICAgICAgZW5kID0gdGhpcy5hcHBlbmRGbGF0Q29vcmRpbmF0ZXMoZmxhdENvb3JkaW5hdGVzLCAwLCBlbmQsIHN0cmlkZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIGlmICh0ZXh0U3RhdGUuYmFja2dyb3VuZEZpbGwgfHwgdGV4dFN0YXRlLmJhY2tncm91bmRTdHJva2UpIHtcbiAgICAgICAgdGhpcy5zZXRGaWxsU3Ryb2tlU3R5bGUodGV4dFN0YXRlLmJhY2tncm91bmRGaWxsLCB0ZXh0U3RhdGUuYmFja2dyb3VuZFN0cm9rZSk7XG4gICAgICAgIGlmICh0ZXh0U3RhdGUuYmFja2dyb3VuZEZpbGwpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUZpbGxTdHlsZSh0aGlzLnN0YXRlLCB0aGlzLmNyZWF0ZUZpbGwsIGdlb21ldHJ5KTtcbiAgICAgICAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRmlsbCh0aGlzLnN0YXRlLCBnZW9tZXRyeSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXh0U3RhdGUuYmFja2dyb3VuZFN0cm9rZSkge1xuICAgICAgICAgIHRoaXMudXBkYXRlU3Ryb2tlU3R5bGUodGhpcy5zdGF0ZSwgdGhpcy5hcHBseVN0cm9rZSk7XG4gICAgICAgICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaCh0aGlzLmNyZWF0ZVN0cm9rZSh0aGlzLnN0YXRlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuYmVnaW5HZW9tZXRyeShnZW9tZXRyeSwgZmVhdHVyZSk7XG4gICAgICB0aGlzLmRyYXdUZXh0SW1hZ2VfKGxhYmVsLCBiZWdpbiwgZW5kKTtcbiAgICAgIHRoaXMuZW5kR2VvbWV0cnkoZ2VvbWV0cnksIGZlYXR1cmUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGV4dC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRLZXkgVGV4dCBzdHlsZSBrZXkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxsS2V5IEZpbGwgc3R5bGUga2V5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3Ryb2tlS2V5IFN0cm9rZSBzdHlsZSBrZXkuXG4gICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBJbWFnZS5cbiAgICovXG4gIENhbnZhc1RleHRSZXBsYXkucHJvdG90eXBlLmdldEltYWdlID0gZnVuY3Rpb24gZ2V0SW1hZ2UgKHRleHQsIHRleHRLZXksIGZpbGxLZXksIHN0cm9rZUtleSkge1xuICAgIHZhciBsYWJlbDtcbiAgICB2YXIga2V5ID0gc3Ryb2tlS2V5ICsgdGV4dEtleSArIHRleHQgKyBmaWxsS2V5ICsgdGhpcy5waXhlbFJhdGlvO1xuXG4gICAgaWYgKCFsYWJlbENhY2hlLmNvbnRhaW5zS2V5KGtleSkpIHtcbiAgICAgIHZhciBzdHJva2VTdGF0ZSA9IHN0cm9rZUtleSA/IHRoaXMuc3Ryb2tlU3RhdGVzW3N0cm9rZUtleV0gfHwgdGhpcy50ZXh0U3Ryb2tlU3RhdGVfIDogbnVsbDtcbiAgICAgIHZhciBmaWxsU3RhdGUgPSBmaWxsS2V5ID8gdGhpcy5maWxsU3RhdGVzW2ZpbGxLZXldIHx8IHRoaXMudGV4dEZpbGxTdGF0ZV8gOiBudWxsO1xuICAgICAgdmFyIHRleHRTdGF0ZSA9IHRoaXMudGV4dFN0YXRlc1t0ZXh0S2V5XSB8fCB0aGlzLnRleHRTdGF0ZV87XG4gICAgICB2YXIgcGl4ZWxSYXRpbyA9IHRoaXMucGl4ZWxSYXRpbztcbiAgICAgIHZhciBzY2FsZSA9IHRleHRTdGF0ZS5zY2FsZSAqIHBpeGVsUmF0aW87XG4gICAgICB2YXIgYWxpZ24gPSBURVhUX0FMSUdOW3RleHRTdGF0ZS50ZXh0QWxpZ24gfHwgZGVmYXVsdFRleHRBbGlnbl07XG4gICAgICB2YXIgc3Ryb2tlV2lkdGggPSBzdHJva2VLZXkgJiYgc3Ryb2tlU3RhdGUubGluZVdpZHRoID8gc3Ryb2tlU3RhdGUubGluZVdpZHRoIDogMDtcblxuICAgICAgdmFyIGxpbmVzID0gdGV4dC5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgbnVtTGluZXMgPSBsaW5lcy5sZW5ndGg7XG4gICAgICB2YXIgd2lkdGhzID0gW107XG4gICAgICB2YXIgd2lkdGggPSBtZWFzdXJlVGV4dFdpZHRocyh0ZXh0U3RhdGUuZm9udCwgbGluZXMsIHdpZHRocyk7XG4gICAgICB2YXIgbGluZUhlaWdodCA9IG1lYXN1cmVUZXh0SGVpZ2h0KHRleHRTdGF0ZS5mb250KTtcbiAgICAgIHZhciBoZWlnaHQgPSBsaW5lSGVpZ2h0ICogbnVtTGluZXM7XG4gICAgICB2YXIgcmVuZGVyV2lkdGggPSAod2lkdGggKyBzdHJva2VXaWR0aCk7XG4gICAgICB2YXIgY29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQyRChcbiAgICAgICAgTWF0aC5jZWlsKHJlbmRlcldpZHRoICogc2NhbGUpLFxuICAgICAgICBNYXRoLmNlaWwoKGhlaWdodCArIHN0cm9rZVdpZHRoKSAqIHNjYWxlKSk7XG4gICAgICBsYWJlbCA9IGNvbnRleHQuY2FudmFzO1xuICAgICAgbGFiZWxDYWNoZS5zZXQoa2V5LCBsYWJlbCk7XG4gICAgICBpZiAoc2NhbGUgIT0gMSkge1xuICAgICAgICBjb250ZXh0LnNjYWxlKHNjYWxlLCBzY2FsZSk7XG4gICAgICB9XG4gICAgICBjb250ZXh0LmZvbnQgPSB0ZXh0U3RhdGUuZm9udDtcbiAgICAgIGlmIChzdHJva2VLZXkpIHtcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHN0cm9rZVN0YXRlLnN0cm9rZVN0eWxlO1xuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHN0cm9rZVdpZHRoO1xuICAgICAgICBjb250ZXh0LmxpbmVDYXAgPSAvKiogQHR5cGUge0NhbnZhc0xpbmVDYXB9ICovIChzdHJva2VTdGF0ZS5saW5lQ2FwKTtcbiAgICAgICAgY29udGV4dC5saW5lSm9pbiA9IC8qKiBAdHlwZSB7Q2FudmFzTGluZUpvaW59ICovIChzdHJva2VTdGF0ZS5saW5lSm9pbik7XG4gICAgICAgIGNvbnRleHQubWl0ZXJMaW1pdCA9IHN0cm9rZVN0YXRlLm1pdGVyTGltaXQ7XG4gICAgICAgIGlmIChDQU5WQVNfTElORV9EQVNIICYmIHN0cm9rZVN0YXRlLmxpbmVEYXNoLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goc3Ryb2tlU3RhdGUubGluZURhc2gpO1xuICAgICAgICAgIGNvbnRleHQubGluZURhc2hPZmZzZXQgPSBzdHJva2VTdGF0ZS5saW5lRGFzaE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZpbGxLZXkpIHtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBmaWxsU3RhdGUuZmlsbFN0eWxlO1xuICAgICAgfVxuICAgICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgIGNvbnRleHQudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICB2YXIgbGVmdFJpZ2h0ID0gKDAuNSAtIGFsaWduKTtcbiAgICAgIHZhciB4ID0gYWxpZ24gKiBsYWJlbC53aWR0aCAvIHNjYWxlICsgbGVmdFJpZ2h0ICogc3Ryb2tlV2lkdGg7XG4gICAgICB2YXIgaTtcbiAgICAgIGlmIChzdHJva2VLZXkpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bUxpbmVzOyArK2kpIHtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZVRleHQobGluZXNbaV0sIHggKyBsZWZ0UmlnaHQgKiB3aWR0aHNbaV0sIDAuNSAqIChzdHJva2VXaWR0aCArIGxpbmVIZWlnaHQpICsgaSAqIGxpbmVIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZmlsbEtleSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtTGluZXM7ICsraSkge1xuICAgICAgICAgIGNvbnRleHQuZmlsbFRleHQobGluZXNbaV0sIHggKyBsZWZ0UmlnaHQgKiB3aWR0aHNbaV0sIDAuNSAqIChzdHJva2VXaWR0aCArIGxpbmVIZWlnaHQpICsgaSAqIGxpbmVIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsYWJlbENhY2hlLmdldChrZXkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBsYWJlbCBMYWJlbC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGJlZ2luIEJlZ2luLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAgICovXG4gIENhbnZhc1RleHRSZXBsYXkucHJvdG90eXBlLmRyYXdUZXh0SW1hZ2VfID0gZnVuY3Rpb24gZHJhd1RleHRJbWFnZV8gKGxhYmVsLCBiZWdpbiwgZW5kKSB7XG4gICAgdmFyIHRleHRTdGF0ZSA9IHRoaXMudGV4dFN0YXRlXztcbiAgICB2YXIgc3Ryb2tlU3RhdGUgPSB0aGlzLnRleHRTdHJva2VTdGF0ZV87XG4gICAgdmFyIHBpeGVsUmF0aW8gPSB0aGlzLnBpeGVsUmF0aW87XG4gICAgdmFyIGFsaWduID0gVEVYVF9BTElHTlt0ZXh0U3RhdGUudGV4dEFsaWduIHx8IGRlZmF1bHRUZXh0QWxpZ25dO1xuICAgIHZhciBiYXNlbGluZSA9IFRFWFRfQUxJR05bdGV4dFN0YXRlLnRleHRCYXNlbGluZV07XG4gICAgdmFyIHN0cm9rZVdpZHRoID0gc3Ryb2tlU3RhdGUgJiYgc3Ryb2tlU3RhdGUubGluZVdpZHRoID8gc3Ryb2tlU3RhdGUubGluZVdpZHRoIDogMDtcblxuICAgIHZhciBhbmNob3JYID0gYWxpZ24gKiBsYWJlbC53aWR0aCAvIHBpeGVsUmF0aW8gKyAyICogKDAuNSAtIGFsaWduKSAqIHN0cm9rZVdpZHRoO1xuICAgIHZhciBhbmNob3JZID0gYmFzZWxpbmUgKiBsYWJlbC5oZWlnaHQgLyBwaXhlbFJhdGlvICsgMiAqICgwLjUgLSBiYXNlbGluZSkgKiBzdHJva2VXaWR0aDtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKFtDYW52YXNJbnN0cnVjdGlvbi5EUkFXX0lNQUdFLCBiZWdpbiwgZW5kLFxuICAgICAgbGFiZWwsIChhbmNob3JYIC0gdGhpcy50ZXh0T2Zmc2V0WF8pICogcGl4ZWxSYXRpbywgKGFuY2hvclkgLSB0aGlzLnRleHRPZmZzZXRZXykgKiBwaXhlbFJhdGlvLFxuICAgICAgdGhpcy5kZWNsdXR0ZXJHcm91cF8sIGxhYmVsLmhlaWdodCwgMSwgMCwgMCwgdGhpcy50ZXh0Um90YXRlV2l0aFZpZXdfLCB0aGlzLnRleHRSb3RhdGlvbl8sXG4gICAgICAxLCBsYWJlbC53aWR0aCxcbiAgICAgIHRleHRTdGF0ZS5wYWRkaW5nID09IGRlZmF1bHRQYWRkaW5nID9cbiAgICAgICAgZGVmYXVsdFBhZGRpbmcgOiB0ZXh0U3RhdGUucGFkZGluZy5tYXAoZnVuY3Rpb24ocCkge1xuICAgICAgICAgIHJldHVybiBwICogcGl4ZWxSYXRpbztcbiAgICAgICAgfSksXG4gICAgICAhIXRleHRTdGF0ZS5iYWNrZ3JvdW5kRmlsbCwgISF0ZXh0U3RhdGUuYmFja2dyb3VuZFN0cm9rZVxuICAgIF0pO1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goW0NhbnZhc0luc3RydWN0aW9uLkRSQVdfSU1BR0UsIGJlZ2luLCBlbmQsXG4gICAgICBsYWJlbCwgKGFuY2hvclggLSB0aGlzLnRleHRPZmZzZXRYXykgKiBwaXhlbFJhdGlvLCAoYW5jaG9yWSAtIHRoaXMudGV4dE9mZnNldFlfKSAqIHBpeGVsUmF0aW8sXG4gICAgICB0aGlzLmRlY2x1dHRlckdyb3VwXywgbGFiZWwuaGVpZ2h0LCAxLCAwLCAwLCB0aGlzLnRleHRSb3RhdGVXaXRoVmlld18sIHRoaXMudGV4dFJvdGF0aW9uXyxcbiAgICAgIDEgLyBwaXhlbFJhdGlvLCBsYWJlbC53aWR0aCwgdGV4dFN0YXRlLnBhZGRpbmcsXG4gICAgICAhIXRleHRTdGF0ZS5iYWNrZ3JvdW5kRmlsbCwgISF0ZXh0U3RhdGUuYmFja2dyb3VuZFN0cm9rZVxuICAgIF0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gYmVnaW4gQmVnaW4uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5EZWNsdXR0ZXJHcm91cH0gZGVjbHV0dGVyR3JvdXAgRGVjbHV0dGVyIGdyb3VwLlxuICAgKi9cbiAgQ2FudmFzVGV4dFJlcGxheS5wcm90b3R5cGUuZHJhd0NoYXJzXyA9IGZ1bmN0aW9uIGRyYXdDaGFyc18gKGJlZ2luLCBlbmQsIGRlY2x1dHRlckdyb3VwKSB7XG4gICAgdmFyIHN0cm9rZVN0YXRlID0gdGhpcy50ZXh0U3Ryb2tlU3RhdGVfO1xuICAgIHZhciB0ZXh0U3RhdGUgPSB0aGlzLnRleHRTdGF0ZV87XG4gICAgdmFyIGZpbGxTdGF0ZSA9IHRoaXMudGV4dEZpbGxTdGF0ZV87XG5cbiAgICB2YXIgc3Ryb2tlS2V5ID0gdGhpcy5zdHJva2VLZXlfO1xuICAgIGlmIChzdHJva2VTdGF0ZSkge1xuICAgICAgaWYgKCEoc3Ryb2tlS2V5IGluIHRoaXMuc3Ryb2tlU3RhdGVzKSkge1xuICAgICAgICB0aGlzLnN0cm9rZVN0YXRlc1tzdHJva2VLZXldID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuU3Ryb2tlU3RhdGV9ICovICh7XG4gICAgICAgICAgc3Ryb2tlU3R5bGU6IHN0cm9rZVN0YXRlLnN0cm9rZVN0eWxlLFxuICAgICAgICAgIGxpbmVDYXA6IHN0cm9rZVN0YXRlLmxpbmVDYXAsXG4gICAgICAgICAgbGluZURhc2hPZmZzZXQ6IHN0cm9rZVN0YXRlLmxpbmVEYXNoT2Zmc2V0LFxuICAgICAgICAgIGxpbmVXaWR0aDogc3Ryb2tlU3RhdGUubGluZVdpZHRoLFxuICAgICAgICAgIGxpbmVKb2luOiBzdHJva2VTdGF0ZS5saW5lSm9pbixcbiAgICAgICAgICBtaXRlckxpbWl0OiBzdHJva2VTdGF0ZS5taXRlckxpbWl0LFxuICAgICAgICAgIGxpbmVEYXNoOiBzdHJva2VTdGF0ZS5saW5lRGFzaFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHRleHRLZXkgPSB0aGlzLnRleHRLZXlfO1xuICAgIGlmICghKHRoaXMudGV4dEtleV8gaW4gdGhpcy50ZXh0U3RhdGVzKSkge1xuICAgICAgdGhpcy50ZXh0U3RhdGVzW3RoaXMudGV4dEtleV9dID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuVGV4dFN0YXRlfSAqLyAoe1xuICAgICAgICBmb250OiB0ZXh0U3RhdGUuZm9udCxcbiAgICAgICAgdGV4dEFsaWduOiB0ZXh0U3RhdGUudGV4dEFsaWduIHx8IGRlZmF1bHRUZXh0QWxpZ24sXG4gICAgICAgIHNjYWxlOiB0ZXh0U3RhdGUuc2NhbGVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgZmlsbEtleSA9IHRoaXMuZmlsbEtleV87XG4gICAgaWYgKGZpbGxTdGF0ZSkge1xuICAgICAgaWYgKCEoZmlsbEtleSBpbiB0aGlzLmZpbGxTdGF0ZXMpKSB7XG4gICAgICAgIHRoaXMuZmlsbFN0YXRlc1tmaWxsS2V5XSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkZpbGxTdGF0ZX0gKi8gKHtcbiAgICAgICAgICBmaWxsU3R5bGU6IGZpbGxTdGF0ZS5maWxsU3R5bGVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHBpeGVsUmF0aW8gPSB0aGlzLnBpeGVsUmF0aW87XG4gICAgdmFyIGJhc2VsaW5lID0gVEVYVF9BTElHTlt0ZXh0U3RhdGUudGV4dEJhc2VsaW5lXTtcblxuICAgIHZhciBvZmZzZXRZID0gdGhpcy50ZXh0T2Zmc2V0WV8gKiBwaXhlbFJhdGlvO1xuICAgIHZhciB0ZXh0ID0gdGhpcy50ZXh0XztcbiAgICB2YXIgZm9udCA9IHRleHRTdGF0ZS5mb250O1xuICAgIHZhciB0ZXh0U2NhbGUgPSB0ZXh0U3RhdGUuc2NhbGU7XG4gICAgdmFyIHN0cm9rZVdpZHRoID0gc3Ryb2tlU3RhdGUgPyBzdHJva2VTdGF0ZS5saW5lV2lkdGggKiB0ZXh0U2NhbGUgLyAyIDogMDtcbiAgICB2YXIgd2lkdGhzID0gdGhpcy53aWR0aHNfW2ZvbnRdO1xuICAgIGlmICghd2lkdGhzKSB7XG4gICAgICB0aGlzLndpZHRoc19bZm9udF0gPSB3aWR0aHMgPSB7fTtcbiAgICB9XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChbQ2FudmFzSW5zdHJ1Y3Rpb24uRFJBV19DSEFSUyxcbiAgICAgIGJlZ2luLCBlbmQsIGJhc2VsaW5lLCBkZWNsdXR0ZXJHcm91cCxcbiAgICAgIHRleHRTdGF0ZS5vdmVyZmxvdywgZmlsbEtleSwgdGV4dFN0YXRlLm1heEFuZ2xlLFxuICAgICAgZnVuY3Rpb24odGV4dCkge1xuICAgICAgICB2YXIgd2lkdGggPSB3aWR0aHNbdGV4dF07XG4gICAgICAgIGlmICghd2lkdGgpIHtcbiAgICAgICAgICB3aWR0aCA9IHdpZHRoc1t0ZXh0XSA9IG1lYXN1cmVUZXh0V2lkdGgoZm9udCwgdGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdpZHRoICogdGV4dFNjYWxlICogcGl4ZWxSYXRpbztcbiAgICAgIH0sXG4gICAgICBvZmZzZXRZLCBzdHJva2VLZXksIHN0cm9rZVdpZHRoICogcGl4ZWxSYXRpbywgdGV4dCwgdGV4dEtleSwgMVxuICAgIF0pO1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goW0NhbnZhc0luc3RydWN0aW9uLkRSQVdfQ0hBUlMsXG4gICAgICBiZWdpbiwgZW5kLCBiYXNlbGluZSwgZGVjbHV0dGVyR3JvdXAsXG4gICAgICB0ZXh0U3RhdGUub3ZlcmZsb3csIGZpbGxLZXksIHRleHRTdGF0ZS5tYXhBbmdsZSxcbiAgICAgIGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gd2lkdGhzW3RleHRdO1xuICAgICAgICBpZiAoIXdpZHRoKSB7XG4gICAgICAgICAgd2lkdGggPSB3aWR0aHNbdGV4dF0gPSBtZWFzdXJlVGV4dFdpZHRoKGZvbnQsIHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3aWR0aCAqIHRleHRTY2FsZTtcbiAgICAgIH0sXG4gICAgICBvZmZzZXRZLCBzdHJva2VLZXksIHN0cm9rZVdpZHRoLCB0ZXh0LCB0ZXh0S2V5LCAxIC8gcGl4ZWxSYXRpb1xuICAgIF0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQ2FudmFzVGV4dFJlcGxheS5wcm90b3R5cGUuc2V0VGV4dFN0eWxlID0gZnVuY3Rpb24gc2V0VGV4dFN0eWxlICh0ZXh0U3R5bGUsIGRlY2x1dHRlckdyb3VwKSB7XG4gICAgdmFyIHRleHRTdGF0ZSwgZmlsbFN0YXRlLCBzdHJva2VTdGF0ZTtcbiAgICBpZiAoIXRleHRTdHlsZSkge1xuICAgICAgdGhpcy50ZXh0XyA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlY2x1dHRlckdyb3VwXyA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkRlY2x1dHRlckdyb3VwfSAqLyAoZGVjbHV0dGVyR3JvdXApO1xuXG4gICAgICB2YXIgdGV4dEZpbGxTdHlsZSA9IHRleHRTdHlsZS5nZXRGaWxsKCk7XG4gICAgICBpZiAoIXRleHRGaWxsU3R5bGUpIHtcbiAgICAgICAgZmlsbFN0YXRlID0gdGhpcy50ZXh0RmlsbFN0YXRlXyA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaWxsU3RhdGUgPSB0aGlzLnRleHRGaWxsU3RhdGVfO1xuICAgICAgICBpZiAoIWZpbGxTdGF0ZSkge1xuICAgICAgICAgIGZpbGxTdGF0ZSA9IHRoaXMudGV4dEZpbGxTdGF0ZV8gPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5GaWxsU3RhdGV9ICovICh7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZmlsbFN0YXRlLmZpbGxTdHlsZSA9IGFzQ29sb3JMaWtlKFxuICAgICAgICAgIHRleHRGaWxsU3R5bGUuZ2V0Q29sb3IoKSB8fCBkZWZhdWx0RmlsbFN0eWxlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRleHRTdHJva2VTdHlsZSA9IHRleHRTdHlsZS5nZXRTdHJva2UoKTtcbiAgICAgIGlmICghdGV4dFN0cm9rZVN0eWxlKSB7XG4gICAgICAgIHN0cm9rZVN0YXRlID0gdGhpcy50ZXh0U3Ryb2tlU3RhdGVfID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cm9rZVN0YXRlID0gdGhpcy50ZXh0U3Ryb2tlU3RhdGVfO1xuICAgICAgICBpZiAoIXN0cm9rZVN0YXRlKSB7XG4gICAgICAgICAgc3Ryb2tlU3RhdGUgPSB0aGlzLnRleHRTdHJva2VTdGF0ZV8gPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5TdHJva2VTdGF0ZX0gKi8gKHt9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGluZURhc2ggPSB0ZXh0U3Ryb2tlU3R5bGUuZ2V0TGluZURhc2goKTtcbiAgICAgICAgdmFyIGxpbmVEYXNoT2Zmc2V0ID0gdGV4dFN0cm9rZVN0eWxlLmdldExpbmVEYXNoT2Zmc2V0KCk7XG4gICAgICAgIHZhciBsaW5lV2lkdGggPSB0ZXh0U3Ryb2tlU3R5bGUuZ2V0V2lkdGgoKTtcbiAgICAgICAgdmFyIG1pdGVyTGltaXQgPSB0ZXh0U3Ryb2tlU3R5bGUuZ2V0TWl0ZXJMaW1pdCgpO1xuICAgICAgICBzdHJva2VTdGF0ZS5saW5lQ2FwID0gdGV4dFN0cm9rZVN0eWxlLmdldExpbmVDYXAoKSB8fCBkZWZhdWx0TGluZUNhcDtcbiAgICAgICAgc3Ryb2tlU3RhdGUubGluZURhc2ggPSBsaW5lRGFzaCA/IGxpbmVEYXNoLnNsaWNlKCkgOiBkZWZhdWx0TGluZURhc2g7XG4gICAgICAgIHN0cm9rZVN0YXRlLmxpbmVEYXNoT2Zmc2V0ID1cbiAgICAgICAgICAgIGxpbmVEYXNoT2Zmc2V0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0TGluZURhc2hPZmZzZXQgOiBsaW5lRGFzaE9mZnNldDtcbiAgICAgICAgc3Ryb2tlU3RhdGUubGluZUpvaW4gPSB0ZXh0U3Ryb2tlU3R5bGUuZ2V0TGluZUpvaW4oKSB8fCBkZWZhdWx0TGluZUpvaW47XG4gICAgICAgIHN0cm9rZVN0YXRlLmxpbmVXaWR0aCA9XG4gICAgICAgICAgICBsaW5lV2lkdGggPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRMaW5lV2lkdGggOiBsaW5lV2lkdGg7XG4gICAgICAgIHN0cm9rZVN0YXRlLm1pdGVyTGltaXQgPVxuICAgICAgICAgICAgbWl0ZXJMaW1pdCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdE1pdGVyTGltaXQgOiBtaXRlckxpbWl0O1xuICAgICAgICBzdHJva2VTdGF0ZS5zdHJva2VTdHlsZSA9IGFzQ29sb3JMaWtlKFxuICAgICAgICAgIHRleHRTdHJva2VTdHlsZS5nZXRDb2xvcigpIHx8IGRlZmF1bHRTdHJva2VTdHlsZSk7XG4gICAgICB9XG5cbiAgICAgIHRleHRTdGF0ZSA9IHRoaXMudGV4dFN0YXRlXztcbiAgICAgIHZhciBmb250ID0gdGV4dFN0eWxlLmdldEZvbnQoKSB8fCBkZWZhdWx0Rm9udDtcbiAgICAgIGNoZWNrRm9udChmb250KTtcbiAgICAgIHZhciB0ZXh0U2NhbGUgPSB0ZXh0U3R5bGUuZ2V0U2NhbGUoKTtcbiAgICAgIHRleHRTdGF0ZS5vdmVyZmxvdyA9IHRleHRTdHlsZS5nZXRPdmVyZmxvdygpO1xuICAgICAgdGV4dFN0YXRlLmZvbnQgPSBmb250O1xuICAgICAgdGV4dFN0YXRlLm1heEFuZ2xlID0gdGV4dFN0eWxlLmdldE1heEFuZ2xlKCk7XG4gICAgICB0ZXh0U3RhdGUucGxhY2VtZW50ID0gdGV4dFN0eWxlLmdldFBsYWNlbWVudCgpO1xuICAgICAgdGV4dFN0YXRlLnRleHRBbGlnbiA9IHRleHRTdHlsZS5nZXRUZXh0QWxpZ24oKTtcbiAgICAgIHRleHRTdGF0ZS50ZXh0QmFzZWxpbmUgPSB0ZXh0U3R5bGUuZ2V0VGV4dEJhc2VsaW5lKCkgfHwgZGVmYXVsdFRleHRCYXNlbGluZTtcbiAgICAgIHRleHRTdGF0ZS5iYWNrZ3JvdW5kRmlsbCA9IHRleHRTdHlsZS5nZXRCYWNrZ3JvdW5kRmlsbCgpO1xuICAgICAgdGV4dFN0YXRlLmJhY2tncm91bmRTdHJva2UgPSB0ZXh0U3R5bGUuZ2V0QmFja2dyb3VuZFN0cm9rZSgpO1xuICAgICAgdGV4dFN0YXRlLnBhZGRpbmcgPSB0ZXh0U3R5bGUuZ2V0UGFkZGluZygpIHx8IGRlZmF1bHRQYWRkaW5nO1xuICAgICAgdGV4dFN0YXRlLnNjYWxlID0gdGV4dFNjYWxlID09PSB1bmRlZmluZWQgPyAxIDogdGV4dFNjYWxlO1xuXG4gICAgICB2YXIgdGV4dE9mZnNldFggPSB0ZXh0U3R5bGUuZ2V0T2Zmc2V0WCgpO1xuICAgICAgdmFyIHRleHRPZmZzZXRZID0gdGV4dFN0eWxlLmdldE9mZnNldFkoKTtcbiAgICAgIHZhciB0ZXh0Um90YXRlV2l0aFZpZXcgPSB0ZXh0U3R5bGUuZ2V0Um90YXRlV2l0aFZpZXcoKTtcbiAgICAgIHZhciB0ZXh0Um90YXRpb24gPSB0ZXh0U3R5bGUuZ2V0Um90YXRpb24oKTtcbiAgICAgIHRoaXMudGV4dF8gPSB0ZXh0U3R5bGUuZ2V0VGV4dCgpIHx8ICcnO1xuICAgICAgdGhpcy50ZXh0T2Zmc2V0WF8gPSB0ZXh0T2Zmc2V0WCA9PT0gdW5kZWZpbmVkID8gMCA6IHRleHRPZmZzZXRYO1xuICAgICAgdGhpcy50ZXh0T2Zmc2V0WV8gPSB0ZXh0T2Zmc2V0WSA9PT0gdW5kZWZpbmVkID8gMCA6IHRleHRPZmZzZXRZO1xuICAgICAgdGhpcy50ZXh0Um90YXRlV2l0aFZpZXdfID0gdGV4dFJvdGF0ZVdpdGhWaWV3ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IHRleHRSb3RhdGVXaXRoVmlldztcbiAgICAgIHRoaXMudGV4dFJvdGF0aW9uXyA9IHRleHRSb3RhdGlvbiA9PT0gdW5kZWZpbmVkID8gMCA6IHRleHRSb3RhdGlvbjtcblxuICAgICAgdGhpcy5zdHJva2VLZXlfID0gc3Ryb2tlU3RhdGUgP1xuICAgICAgICAodHlwZW9mIHN0cm9rZVN0YXRlLnN0cm9rZVN0eWxlID09ICdzdHJpbmcnID8gc3Ryb2tlU3RhdGUuc3Ryb2tlU3R5bGUgOiBnZXRVaWQoc3Ryb2tlU3RhdGUuc3Ryb2tlU3R5bGUpKSArXG4gICAgICAgIHN0cm9rZVN0YXRlLmxpbmVDYXAgKyBzdHJva2VTdGF0ZS5saW5lRGFzaE9mZnNldCArICd8JyArIHN0cm9rZVN0YXRlLmxpbmVXaWR0aCArXG4gICAgICAgIHN0cm9rZVN0YXRlLmxpbmVKb2luICsgc3Ryb2tlU3RhdGUubWl0ZXJMaW1pdCArICdbJyArIHN0cm9rZVN0YXRlLmxpbmVEYXNoLmpvaW4oKSArICddJyA6XG4gICAgICAgICcnO1xuICAgICAgdGhpcy50ZXh0S2V5XyA9IHRleHRTdGF0ZS5mb250ICsgdGV4dFN0YXRlLnNjYWxlICsgKHRleHRTdGF0ZS50ZXh0QWxpZ24gfHwgJz8nKTtcbiAgICAgIHRoaXMuZmlsbEtleV8gPSBmaWxsU3RhdGUgP1xuICAgICAgICAodHlwZW9mIGZpbGxTdGF0ZS5maWxsU3R5bGUgPT0gJ3N0cmluZycgPyBmaWxsU3RhdGUuZmlsbFN0eWxlIDogKCd8JyArIGdldFVpZChmaWxsU3RhdGUuZmlsbFN0eWxlKSkpIDpcbiAgICAgICAgJyc7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBDYW52YXNUZXh0UmVwbGF5O1xufShDYW52YXNSZXBsYXkpKTtcblxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250IEZvbnQgdG8gdXNlIGZvciBtZWFzdXJpbmcuXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGxpbmVzIExpbmVzIHRvIG1lYXN1cmUuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHdpZHRocyBBcnJheSB3aWxsIGJlIHBvcHVsYXRlZCB3aXRoIHRoZSB3aWR0aHMgb2ZcbiAqIGVhY2ggbGluZS5cbiAqIEByZXR1cm4ge251bWJlcn0gV2lkdGggb2YgdGhlIHdob2xlIHRleHQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZWFzdXJlVGV4dFdpZHRocyhmb250LCBsaW5lcywgd2lkdGhzKSB7XG4gIHZhciBudW1MaW5lcyA9IGxpbmVzLmxlbmd0aDtcbiAgdmFyIHdpZHRoID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1MaW5lczsgKytpKSB7XG4gICAgdmFyIGN1cnJlbnRXaWR0aCA9IG1lYXN1cmVUZXh0V2lkdGgoZm9udCwgbGluZXNbaV0pO1xuICAgIHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIGN1cnJlbnRXaWR0aCk7XG4gICAgd2lkdGhzLnB1c2goY3VycmVudFdpZHRoKTtcbiAgfVxuICByZXR1cm4gd2lkdGg7XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgQ2FudmFzVGV4dFJlcGxheTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4dFJlcGxheS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyL3JlcGxheVxuICovXG5pbXBvcnQgUmVwbGF5VHlwZSBmcm9tICcuL1JlcGxheVR5cGUuanMnO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7QXJyYXk8UmVwbGF5VHlwZT59XG4gKi9cbmV4cG9ydCB2YXIgT1JERVIgPSBbXG4gIFJlcGxheVR5cGUuUE9MWUdPTixcbiAgUmVwbGF5VHlwZS5DSVJDTEUsXG4gIFJlcGxheVR5cGUuTElORV9TVFJJTkcsXG4gIFJlcGxheVR5cGUuSU1BR0UsXG4gIFJlcGxheVR5cGUuVEVYVCxcbiAgUmVwbGF5VHlwZS5ERUZBVUxUXG5dO1xuXG4vKipcbiAqIEBjb25zdFxuICogQGVudW0ge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBURVhUX0FMSUdOID0ge307XG5URVhUX0FMSUdOWydsZWZ0J10gPSAwO1xuVEVYVF9BTElHTlsnZW5kJ10gPSAwO1xuVEVYVF9BTElHTlsnY2VudGVyJ10gPSAwLjU7XG5URVhUX0FMSUdOWydyaWdodCddID0gMTtcblRFWFRfQUxJR05bJ3N0YXJ0J10gPSAxO1xuVEVYVF9BTElHTlsndG9wJ10gPSAwO1xuVEVYVF9BTElHTlsnbWlkZGxlJ10gPSAwLjU7XG5URVhUX0FMSUdOWydoYW5naW5nJ10gPSAwLjI7XG5URVhUX0FMSUdOWydhbHBoYWJldGljJ10gPSAwLjg7XG5URVhUX0FMSUdOWydpZGVvZ3JhcGhpYyddID0gMC44O1xuVEVYVF9BTElHTlsnYm90dG9tJ10gPSAxO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXBsYXkuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlcmVyL0xheWVyXG4gKi9cbmltcG9ydCB7Z2V0VWlkfSBmcm9tICcuLi91dGlsLmpzJztcbmltcG9ydCBJbWFnZVN0YXRlIGZyb20gJy4uL0ltYWdlU3RhdGUuanMnO1xuaW1wb3J0IE9ic2VydmFibGUgZnJvbSAnLi4vT2JzZXJ2YWJsZS5qcyc7XG5pbXBvcnQgVGlsZVN0YXRlIGZyb20gJy4uL1RpbGVTdGF0ZS5qcyc7XG5pbXBvcnQge2xpc3Rlbn0gZnJvbSAnLi4vZXZlbnRzLmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgU291cmNlU3RhdGUgZnJvbSAnLi4vc291cmNlL1N0YXRlLmpzJztcblxudmFyIExheWVyUmVuZGVyZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChPYnNlcnZhYmxlKSB7XG4gIGZ1bmN0aW9uIExheWVyUmVuZGVyZXIobGF5ZXIpIHtcblxuICAgIE9ic2VydmFibGUuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5sYXllcl8gPSBsYXllcjtcblxuICB9XG5cbiAgaWYgKCBPYnNlcnZhYmxlICkgTGF5ZXJSZW5kZXJlci5fX3Byb3RvX18gPSBPYnNlcnZhYmxlO1xuICBMYXllclJlbmRlcmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE9ic2VydmFibGUgJiYgT2JzZXJ2YWJsZS5wcm90b3R5cGUgKTtcbiAgTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMYXllclJlbmRlcmVyO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBmdW5jdGlvbiB0aGF0IGFkZHMgbG9hZGVkIHRpbGVzIHRvIHRoZSB0aWxlIGxvb2t1cC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zb3VyY2UvVGlsZS5qc1wiKS5kZWZhdWx0fSBzb3VyY2UgVGlsZSBzb3VyY2UuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbiBvZiB0aGUgdGlsZXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0PG51bWJlciwgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5kZWZhdWx0Pj59IHRpbGVzIExvb2t1cCBvZiBsb2FkZWQgdGlsZXMgYnkgem9vbSBsZXZlbC5cbiAgICogQHJldHVybiB7ZnVuY3Rpb24obnVtYmVyLCBpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdCk6Ym9vbGVhbn0gQSBmdW5jdGlvbiB0aGF0IGNhbiBiZVxuICAgKiAgICAgY2FsbGVkIHdpdGggYSB6b29tIGxldmVsIGFuZCBhIHRpbGUgcmFuZ2UgdG8gYWRkIGxvYWRlZCB0aWxlcyB0byB0aGUgbG9va3VwLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBMYXllclJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVMb2FkZWRUaWxlRmluZGVyID0gZnVuY3Rpb24gY3JlYXRlTG9hZGVkVGlsZUZpbmRlciAoc291cmNlLCBwcm9qZWN0aW9uLCB0aWxlcykge1xuICAgIHJldHVybiAoXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6b29tIFpvb20gbGV2ZWwuXG4gICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0fSB0aWxlUmFuZ2UgVGlsZSByYW5nZS5cbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB0aWxlIHJhbmdlIGlzIGZ1bGx5IGxvYWRlZC5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24oem9vbSwgdGlsZVJhbmdlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1RpbGUuanNcIikuZGVmYXVsdH0gdGlsZSBUaWxlLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gY2FsbGJhY2sodGlsZSkge1xuICAgICAgICAgIGlmICghdGlsZXNbem9vbV0pIHtcbiAgICAgICAgICAgIHRpbGVzW3pvb21dID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIHRpbGVzW3pvb21dW3RpbGUudGlsZUNvb3JkLnRvU3RyaW5nKCldID0gdGlsZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc291cmNlLmZvckVhY2hMb2FkZWRUaWxlKHByb2plY3Rpb24sIHpvb20sIHRpbGVSYW5nZSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1BsdWdnYWJsZU1hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaGl0VG9sZXJhbmNlIEhpdCB0b2xlcmFuY2UgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2UsIGltcG9ydChcIi4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHQpOiBUfSBjYWxsYmFjayBGZWF0dXJlIGNhbGxiYWNrLlxuICAgKiBAcmV0dXJuIHtUfHZvaWR9IENhbGxiYWNrIHJlc3VsdC5cbiAgICogQHRlbXBsYXRlIFRcbiAgICovXG4gIExheWVyUmVuZGVyZXIucHJvdG90eXBlLmZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlID0gZnVuY3Rpb24gZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGUgKGNvb3JkaW5hdGUsIGZyYW1lU3RhdGUsIGhpdFRvbGVyYW5jZSwgY2FsbGJhY2spIHt9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0fSBMYXllci5cbiAgICovXG4gIExheWVyUmVuZGVyZXIucHJvdG90eXBlLmdldExheWVyID0gZnVuY3Rpb24gZ2V0TGF5ZXIgKCkge1xuICAgIHJldHVybiB0aGlzLmxheWVyXztcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGNoYW5nZXMgaW4gaW1hZ2Ugc3RhdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHR9IGV2ZW50IEltYWdlIGNoYW5nZSBldmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIExheWVyUmVuZGVyZXIucHJvdG90eXBlLmhhbmRsZUltYWdlQ2hhbmdlXyA9IGZ1bmN0aW9uIGhhbmRsZUltYWdlQ2hhbmdlXyAoZXZlbnQpIHtcbiAgICB2YXIgaW1hZ2UgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL0ltYWdlLmpzXCIpLmRlZmF1bHR9ICovIChldmVudC50YXJnZXQpO1xuICAgIGlmIChpbWFnZS5nZXRTdGF0ZSgpID09PSBJbWFnZVN0YXRlLkxPQURFRCkge1xuICAgICAgdGhpcy5yZW5kZXJJZlJlYWR5QW5kVmlzaWJsZSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSXMgdGhlcmUgYSBmZWF0dXJlIGF0IHRoZSBnaXZlbiBjb29yZGluYXRlP1xuICAgKi9cbiAgTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuaGFzRmVhdHVyZUF0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGhhc0ZlYXR1cmVBdENvb3JkaW5hdGUgKGNvb3JkaW5hdGUsIGZyYW1lU3RhdGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIExvYWQgdGhlIGltYWdlIGlmIG5vdCBhbHJlYWR5IGxvYWRlZCwgYW5kIHJlZ2lzdGVyIHRoZSBpbWFnZSBjaGFuZ2VcbiAgICogbGlzdGVuZXIgaWYgbmVlZGVkLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ltYWdlQmFzZS5qc1wiKS5kZWZhdWx0fSBpbWFnZSBJbWFnZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBpbWFnZSBpcyBhbHJlYWR5IGxvYWRlZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIExheWVyUmVuZGVyZXIucHJvdG90eXBlLmxvYWRJbWFnZSA9IGZ1bmN0aW9uIGxvYWRJbWFnZSAoaW1hZ2UpIHtcbiAgICB2YXIgaW1hZ2VTdGF0ZSA9IGltYWdlLmdldFN0YXRlKCk7XG4gICAgaWYgKGltYWdlU3RhdGUgIT0gSW1hZ2VTdGF0ZS5MT0FERUQgJiYgaW1hZ2VTdGF0ZSAhPSBJbWFnZVN0YXRlLkVSUk9SKSB7XG4gICAgICBsaXN0ZW4oaW1hZ2UsIEV2ZW50VHlwZS5DSEFOR0UsIHRoaXMuaGFuZGxlSW1hZ2VDaGFuZ2VfLCB0aGlzKTtcbiAgICB9XG4gICAgaWYgKGltYWdlU3RhdGUgPT0gSW1hZ2VTdGF0ZS5JRExFKSB7XG4gICAgICBpbWFnZS5sb2FkKCk7XG4gICAgICBpbWFnZVN0YXRlID0gaW1hZ2UuZ2V0U3RhdGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIGltYWdlU3RhdGUgPT0gSW1hZ2VTdGF0ZS5MT0FERUQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIExheWVyUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlcklmUmVhZHlBbmRWaXNpYmxlID0gZnVuY3Rpb24gcmVuZGVySWZSZWFkeUFuZFZpc2libGUgKCkge1xuICAgIHZhciBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKTtcbiAgICBpZiAobGF5ZXIuZ2V0VmlzaWJsZSgpICYmIGxheWVyLmdldFNvdXJjZVN0YXRlKCkgPT0gU291cmNlU3RhdGUuUkVBRFkpIHtcbiAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zb3VyY2UvVGlsZS5qc1wiKS5kZWZhdWx0fSB0aWxlU291cmNlIFRpbGUgc291cmNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBMYXllclJlbmRlcmVyLnByb3RvdHlwZS5zY2hlZHVsZUV4cGlyZUNhY2hlID0gZnVuY3Rpb24gc2NoZWR1bGVFeHBpcmVDYWNoZSAoZnJhbWVTdGF0ZSwgdGlsZVNvdXJjZSkge1xuICAgIGlmICh0aWxlU291cmNlLmNhbkV4cGlyZUNhY2hlKCkpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zb3VyY2UvVGlsZS5qc1wiKS5kZWZhdWx0fSB0aWxlU291cmNlIFRpbGUgc291cmNlLlxuICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuZGVmYXVsdH0gbWFwIE1hcC5cbiAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAgICAgKi9cbiAgICAgIHZhciBwb3N0UmVuZGVyRnVuY3Rpb24gPSBmdW5jdGlvbih0aWxlU291cmNlLCBtYXAsIGZyYW1lU3RhdGUpIHtcbiAgICAgICAgdmFyIHRpbGVTb3VyY2VLZXkgPSBnZXRVaWQodGlsZVNvdXJjZSk7XG4gICAgICAgIGlmICh0aWxlU291cmNlS2V5IGluIGZyYW1lU3RhdGUudXNlZFRpbGVzKSB7XG4gICAgICAgICAgdGlsZVNvdXJjZS5leHBpcmVDYWNoZShmcmFtZVN0YXRlLnZpZXdTdGF0ZS5wcm9qZWN0aW9uLFxuICAgICAgICAgICAgZnJhbWVTdGF0ZS51c2VkVGlsZXNbdGlsZVNvdXJjZUtleV0pO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQobnVsbCwgdGlsZVNvdXJjZSk7XG5cbiAgICAgIGZyYW1lU3RhdGUucG9zdFJlbmRlckZ1bmN0aW9ucy5wdXNoKFxuICAgICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uL1BsdWdnYWJsZU1hcC5qc1wiKS5Qb3N0UmVuZGVyRnVuY3Rpb259ICovIChwb3N0UmVuZGVyRnVuY3Rpb24pXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHshT2JqZWN0PHN0cmluZywgIU9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0Pj59IHVzZWRUaWxlcyBVc2VkIHRpbGVzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3NvdXJjZS9UaWxlLmpzXCIpLmRlZmF1bHR9IHRpbGVTb3VyY2UgVGlsZSBzb3VyY2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6IFouXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHR9IHRpbGVSYW5nZSBUaWxlIHJhbmdlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBMYXllclJlbmRlcmVyLnByb3RvdHlwZS51cGRhdGVVc2VkVGlsZXMgPSBmdW5jdGlvbiB1cGRhdGVVc2VkVGlsZXMgKHVzZWRUaWxlcywgdGlsZVNvdXJjZSwgeiwgdGlsZVJhbmdlKSB7XG4gICAgLy8gRklYTUUgc2hvdWxkIHdlIHVzZSB0aWxlc1RvRHJhd0J5WiBpbnN0ZWFkP1xuICAgIHZhciB0aWxlU291cmNlS2V5ID0gZ2V0VWlkKHRpbGVTb3VyY2UpO1xuICAgIHZhciB6S2V5ID0gei50b1N0cmluZygpO1xuICAgIGlmICh0aWxlU291cmNlS2V5IGluIHVzZWRUaWxlcykge1xuICAgICAgaWYgKHpLZXkgaW4gdXNlZFRpbGVzW3RpbGVTb3VyY2VLZXldKSB7XG4gICAgICAgIHVzZWRUaWxlc1t0aWxlU291cmNlS2V5XVt6S2V5XS5leHRlbmQodGlsZVJhbmdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVzZWRUaWxlc1t0aWxlU291cmNlS2V5XVt6S2V5XSA9IHRpbGVSYW5nZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdXNlZFRpbGVzW3RpbGVTb3VyY2VLZXldID0ge307XG4gICAgICB1c2VkVGlsZXNbdGlsZVNvdXJjZUtleV1bektleV0gPSB0aWxlUmFuZ2U7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBNYW5hZ2UgdGlsZSBweXJhbWlkLlxuICAgKiBUaGlzIGZ1bmN0aW9uIHBlcmZvcm1zIGEgbnVtYmVyIG9mIGZ1bmN0aW9ucyByZWxhdGVkIHRvIHRoZSB0aWxlcyBhdCB0aGVcbiAgICogY3VycmVudCB6b29tIGFuZCBsb3dlciB6b29tIGxldmVsczpcbiAgICogLSByZWdpc3RlcnMgaWRsZSB0aWxlcyBpbiBmcmFtZVN0YXRlLndhbnRlZFRpbGVzIHNvIHRoYXQgdGhleSBhcmUgbm90XG4gICAqICAgZGlzY2FyZGVkIGJ5IHRoZSB0aWxlIHF1ZXVlXG4gICAqIC0gZW5xdWV1ZXMgbWlzc2luZyB0aWxlc1xuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1BsdWdnYWJsZU1hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3NvdXJjZS9UaWxlLmpzXCIpLmRlZmF1bHR9IHRpbGVTb3VyY2UgVGlsZSBzb3VyY2UuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH0gdGlsZUdyaWQgVGlsZSBncmlkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50WiBDdXJyZW50IFouXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwcmVsb2FkIExvYWQgbG93IHJlc29sdXRpb24gdGlsZXMgdXAgdG8gJ3ByZWxvYWQnIGxldmVscy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBULCBpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLmRlZmF1bHQpPX0gb3B0X3RpbGVDYWxsYmFjayBUaWxlIGNhbGxiYWNrLlxuICAgKiBAcGFyYW0ge1Q9fSBvcHRfdGhpcyBPYmplY3QgdG8gdXNlIGFzIGB0aGlzYCBpbiBgb3B0X3RpbGVDYWxsYmFja2AuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHRlbXBsYXRlIFRcbiAgICovXG4gIExheWVyUmVuZGVyZXIucHJvdG90eXBlLm1hbmFnZVRpbGVQeXJhbWlkID0gZnVuY3Rpb24gbWFuYWdlVGlsZVB5cmFtaWQgKFxuICAgIGZyYW1lU3RhdGUsXG4gICAgdGlsZVNvdXJjZSxcbiAgICB0aWxlR3JpZCxcbiAgICBwaXhlbFJhdGlvLFxuICAgIHByb2plY3Rpb24sXG4gICAgZXh0ZW50LFxuICAgIGN1cnJlbnRaLFxuICAgIHByZWxvYWQsXG4gICAgb3B0X3RpbGVDYWxsYmFjayxcbiAgICBvcHRfdGhpc1xuICApIHtcbiAgICB2YXIgdGlsZVNvdXJjZUtleSA9IGdldFVpZCh0aWxlU291cmNlKTtcbiAgICBpZiAoISh0aWxlU291cmNlS2V5IGluIGZyYW1lU3RhdGUud2FudGVkVGlsZXMpKSB7XG4gICAgICBmcmFtZVN0YXRlLndhbnRlZFRpbGVzW3RpbGVTb3VyY2VLZXldID0ge307XG4gICAgfVxuICAgIHZhciB3YW50ZWRUaWxlcyA9IGZyYW1lU3RhdGUud2FudGVkVGlsZXNbdGlsZVNvdXJjZUtleV07XG4gICAgdmFyIHRpbGVRdWV1ZSA9IGZyYW1lU3RhdGUudGlsZVF1ZXVlO1xuICAgIHZhciBtaW5ab29tID0gdGlsZUdyaWQuZ2V0TWluWm9vbSgpO1xuICAgIHZhciB0aWxlLCB0aWxlUmFuZ2UsIHRpbGVSZXNvbHV0aW9uLCB4LCB5LCB6O1xuICAgIGZvciAoeiA9IG1pblpvb207IHogPD0gY3VycmVudFo7ICsreikge1xuICAgICAgdGlsZVJhbmdlID0gdGlsZUdyaWQuZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWihleHRlbnQsIHosIHRpbGVSYW5nZSk7XG4gICAgICB0aWxlUmVzb2x1dGlvbiA9IHRpbGVHcmlkLmdldFJlc29sdXRpb24oeik7XG4gICAgICBmb3IgKHggPSB0aWxlUmFuZ2UubWluWDsgeCA8PSB0aWxlUmFuZ2UubWF4WDsgKyt4KSB7XG4gICAgICAgIGZvciAoeSA9IHRpbGVSYW5nZS5taW5ZOyB5IDw9IHRpbGVSYW5nZS5tYXhZOyArK3kpIHtcbiAgICAgICAgICBpZiAoY3VycmVudFogLSB6IDw9IHByZWxvYWQpIHtcbiAgICAgICAgICAgIHRpbGUgPSB0aWxlU291cmNlLmdldFRpbGUoeiwgeCwgeSwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbik7XG4gICAgICAgICAgICBpZiAodGlsZS5nZXRTdGF0ZSgpID09IFRpbGVTdGF0ZS5JRExFKSB7XG4gICAgICAgICAgICAgIHdhbnRlZFRpbGVzW3RpbGUuZ2V0S2V5KCldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaWYgKCF0aWxlUXVldWUuaXNLZXlRdWV1ZWQodGlsZS5nZXRLZXkoKSkpIHtcbiAgICAgICAgICAgICAgICB0aWxlUXVldWUuZW5xdWV1ZShbdGlsZSwgdGlsZVNvdXJjZUtleSxcbiAgICAgICAgICAgICAgICAgIHRpbGVHcmlkLmdldFRpbGVDb29yZENlbnRlcih0aWxlLnRpbGVDb29yZCksIHRpbGVSZXNvbHV0aW9uXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRfdGlsZUNhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgb3B0X3RpbGVDYWxsYmFjay5jYWxsKG9wdF90aGlzLCB0aWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGlsZVNvdXJjZS51c2VUaWxlKHosIHgsIHksIHByb2plY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gTGF5ZXJSZW5kZXJlcjtcbn0oT2JzZXJ2YWJsZSkpO1xuXG5leHBvcnQgZGVmYXVsdCBMYXllclJlbmRlcmVyO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1MYXllci5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyZXIvTWFwXG4gKi9cbmltcG9ydCB7YWJzdHJhY3QsIGdldFVpZH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5pbXBvcnQgRGlzcG9zYWJsZSBmcm9tICcuLi9EaXNwb3NhYmxlLmpzJztcbmltcG9ydCB7bGlzdGVuLCB1bmxpc3RlbkJ5S2V5fSBmcm9tICcuLi9ldmVudHMuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7Z2V0V2lkdGh9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge1RSVUV9IGZyb20gJy4uL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQge3Zpc2libGVBdFJlc29sdXRpb259IGZyb20gJy4uL2xheWVyL0xheWVyLmpzJztcbmltcG9ydCB7c2hhcmVkIGFzIGljb25JbWFnZUNhY2hlfSBmcm9tICcuLi9zdHlsZS9JY29uSW1hZ2VDYWNoZS5qcyc7XG5pbXBvcnQge2NvbXBvc2UgYXMgY29tcG9zZVRyYW5zZm9ybSwgaW52ZXJ0IGFzIGludmVydFRyYW5zZm9ybSwgc2V0RnJvbUFycmF5IGFzIHRyYW5zZm9ybVNldEZyb21BcnJheX0gZnJvbSAnLi4vdHJhbnNmb3JtLmpzJztcblxuLyoqXG4gKiBAYWJzdHJhY3RcbiAqL1xudmFyIE1hcFJlbmRlcmVyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoRGlzcG9zYWJsZSkge1xuICBmdW5jdGlvbiBNYXBSZW5kZXJlcihtYXApIHtcbiAgICBEaXNwb3NhYmxlLmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLm1hcF8gPSBtYXA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi9MYXllci5qc1wiKS5kZWZhdWx0Pn1cbiAgICAgKi9cbiAgICB0aGlzLmxheWVyUmVuZGVyZXJzXyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5sYXllclJlbmRlcmVyTGlzdGVuZXJzXyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8dHlwZW9mIGltcG9ydChcIi4vTGF5ZXIuanNcIikuZGVmYXVsdD59XG4gICAgICovXG4gICAgdGhpcy5sYXllclJlbmRlcmVyQ29uc3RydWN0b3JzXyA9IFtdO1xuXG4gIH1cblxuICBpZiAoIERpc3Bvc2FibGUgKSBNYXBSZW5kZXJlci5fX3Byb3RvX18gPSBEaXNwb3NhYmxlO1xuICBNYXBSZW5kZXJlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBEaXNwb3NhYmxlICYmIERpc3Bvc2FibGUucHJvdG90eXBlICk7XG4gIE1hcFJlbmRlcmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1hcFJlbmRlcmVyO1xuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9yZW5kZXIvRXZlbnRUeXBlLmpzXCIpLmRlZmF1bHR9IHR5cGUgRXZlbnQgdHlwZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICovXG4gIE1hcFJlbmRlcmVyLnByb3RvdHlwZS5kaXNwYXRjaFJlbmRlckV2ZW50ID0gZnVuY3Rpb24gZGlzcGF0Y2hSZW5kZXJFdmVudCAodHlwZSwgZnJhbWVTdGF0ZSkge1xuICAgIGFic3RyYWN0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGxheWVyIHJlbmRlcmVyIGNvbnN0cnVjdG9ycy5cbiAgICogQHBhcmFtIHtBcnJheTx0eXBlb2YgaW1wb3J0KFwiLi9MYXllci5qc1wiKS5kZWZhdWx0Pn0gY29uc3RydWN0b3JzIExheWVyIHJlbmRlcmVycy5cbiAgICovXG4gIE1hcFJlbmRlcmVyLnByb3RvdHlwZS5yZWdpc3RlckxheWVyUmVuZGVyZXJzID0gZnVuY3Rpb24gcmVnaXN0ZXJMYXllclJlbmRlcmVycyAoY29uc3RydWN0b3JzKSB7XG4gICAgdGhpcy5sYXllclJlbmRlcmVyQ29uc3RydWN0b3JzXy5wdXNoLmFwcGx5KHRoaXMubGF5ZXJSZW5kZXJlckNvbnN0cnVjdG9yc18sIGNvbnN0cnVjdG9ycyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWVTdGF0ZS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgTWFwUmVuZGVyZXIucHJvdG90eXBlLmNhbGN1bGF0ZU1hdHJpY2VzMkQgPSBmdW5jdGlvbiBjYWxjdWxhdGVNYXRyaWNlczJEIChmcmFtZVN0YXRlKSB7XG4gICAgdmFyIHZpZXdTdGF0ZSA9IGZyYW1lU3RhdGUudmlld1N0YXRlO1xuICAgIHZhciBjb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybSA9IGZyYW1lU3RhdGUuY29vcmRpbmF0ZVRvUGl4ZWxUcmFuc2Zvcm07XG4gICAgdmFyIHBpeGVsVG9Db29yZGluYXRlVHJhbnNmb3JtID0gZnJhbWVTdGF0ZS5waXhlbFRvQ29vcmRpbmF0ZVRyYW5zZm9ybTtcblxuICAgIGNvbXBvc2VUcmFuc2Zvcm0oY29vcmRpbmF0ZVRvUGl4ZWxUcmFuc2Zvcm0sXG4gICAgICBmcmFtZVN0YXRlLnNpemVbMF0gLyAyLCBmcmFtZVN0YXRlLnNpemVbMV0gLyAyLFxuICAgICAgMSAvIHZpZXdTdGF0ZS5yZXNvbHV0aW9uLCAtMSAvIHZpZXdTdGF0ZS5yZXNvbHV0aW9uLFxuICAgICAgLXZpZXdTdGF0ZS5yb3RhdGlvbixcbiAgICAgIC12aWV3U3RhdGUuY2VudGVyWzBdLCAtdmlld1N0YXRlLmNlbnRlclsxXSk7XG5cbiAgICBpbnZlcnRUcmFuc2Zvcm0oXG4gICAgICB0cmFuc2Zvcm1TZXRGcm9tQXJyYXkocGl4ZWxUb0Nvb3JkaW5hdGVUcmFuc2Zvcm0sIGNvb3JkaW5hdGVUb1BpeGVsVHJhbnNmb3JtKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGxheWVyIHJlbmRlcmVycy5cbiAgICovXG4gIE1hcFJlbmRlcmVyLnByb3RvdHlwZS5yZW1vdmVMYXllclJlbmRlcmVycyA9IGZ1bmN0aW9uIHJlbW92ZUxheWVyUmVuZGVyZXJzICgpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5sYXllclJlbmRlcmVyc18pIHtcbiAgICAgIHRoaXMucmVtb3ZlTGF5ZXJSZW5kZXJlckJ5S2V5XyhrZXkpLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWVTdGF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGhpdFRvbGVyYW5jZSBIaXQgdG9sZXJhbmNlIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBTLCBpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlLFxuICAgKiAgICAgaW1wb3J0KFwiLi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdCk6IFR9IGNhbGxiYWNrIEZlYXR1cmUgY2FsbGJhY2suXG4gICAqIEBwYXJhbSB7U30gdGhpc0FyZyBWYWx1ZSB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIGBjYWxsYmFja2AuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczogVSwgaW1wb3J0KFwiLi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdCk6IGJvb2xlYW59IGxheWVyRmlsdGVyIExheWVyIGZpbHRlclxuICAgKiAgICAgZnVuY3Rpb24sIG9ubHkgbGF5ZXJzIHdoaWNoIGFyZSB2aXNpYmxlIGFuZCBmb3Igd2hpY2ggdGhpcyBmdW5jdGlvblxuICAgKiAgICAgcmV0dXJucyBgdHJ1ZWAgd2lsbCBiZSB0ZXN0ZWQgZm9yIGZlYXR1cmVzLiAgQnkgZGVmYXVsdCwgYWxsIHZpc2libGVcbiAgICogICAgIGxheWVycyB3aWxsIGJlIHRlc3RlZC5cbiAgICogQHBhcmFtIHtVfSB0aGlzQXJnMiBWYWx1ZSB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIGBsYXllckZpbHRlcmAuXG4gICAqIEByZXR1cm4ge1R8dW5kZWZpbmVkfSBDYWxsYmFjayByZXN1bHQuXG4gICAqIEB0ZW1wbGF0ZSBTLFQsVVxuICAgKi9cbiAgTWFwUmVuZGVyZXIucHJvdG90eXBlLmZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlID0gZnVuY3Rpb24gZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGUgKFxuICAgIGNvb3JkaW5hdGUsXG4gICAgZnJhbWVTdGF0ZSxcbiAgICBoaXRUb2xlcmFuY2UsXG4gICAgY2FsbGJhY2ssXG4gICAgdGhpc0FyZyxcbiAgICBsYXllckZpbHRlcixcbiAgICB0aGlzQXJnMlxuICApIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHZhciB2aWV3U3RhdGUgPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZTtcbiAgICB2YXIgdmlld1Jlc29sdXRpb24gPSB2aWV3U3RhdGUucmVzb2x1dGlvbjtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdH0gbGF5ZXIgTGF5ZXIuXG4gICAgICogQHJldHVybiB7P30gQ2FsbGJhY2sgcmVzdWx0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlKGZlYXR1cmUsIGxheWVyKSB7XG4gICAgICB2YXIgbWFuYWdlZCA9IGZyYW1lU3RhdGUubGF5ZXJTdGF0ZXNbZ2V0VWlkKGxheWVyKV0ubWFuYWdlZDtcbiAgICAgIGlmICghKGdldFVpZChmZWF0dXJlKSBpbiBmcmFtZVN0YXRlLnNraXBwZWRGZWF0dXJlVWlkcyAmJiAhbWFuYWdlZCkpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgZmVhdHVyZSwgbWFuYWdlZCA/IGxheWVyIDogbnVsbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByb2plY3Rpb24gPSB2aWV3U3RhdGUucHJvamVjdGlvbjtcblxuICAgIHZhciB0cmFuc2xhdGVkQ29vcmRpbmF0ZSA9IGNvb3JkaW5hdGU7XG4gICAgaWYgKHByb2plY3Rpb24uY2FuV3JhcFgoKSkge1xuICAgICAgdmFyIHByb2plY3Rpb25FeHRlbnQgPSBwcm9qZWN0aW9uLmdldEV4dGVudCgpO1xuICAgICAgdmFyIHdvcmxkV2lkdGggPSBnZXRXaWR0aChwcm9qZWN0aW9uRXh0ZW50KTtcbiAgICAgIHZhciB4ID0gY29vcmRpbmF0ZVswXTtcbiAgICAgIGlmICh4IDwgcHJvamVjdGlvbkV4dGVudFswXSB8fCB4ID4gcHJvamVjdGlvbkV4dGVudFsyXSkge1xuICAgICAgICB2YXIgd29ybGRzQXdheSA9IE1hdGguY2VpbCgocHJvamVjdGlvbkV4dGVudFswXSAtIHgpIC8gd29ybGRXaWR0aCk7XG4gICAgICAgIHRyYW5zbGF0ZWRDb29yZGluYXRlID0gW3ggKyB3b3JsZFdpZHRoICogd29ybGRzQXdheSwgY29vcmRpbmF0ZVsxXV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxheWVyU3RhdGVzID0gZnJhbWVTdGF0ZS5sYXllclN0YXRlc0FycmF5O1xuICAgIHZhciBudW1MYXllcnMgPSBsYXllclN0YXRlcy5sZW5ndGg7XG4gICAgdmFyIGk7XG4gICAgZm9yIChpID0gbnVtTGF5ZXJzIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHZhciBsYXllclN0YXRlID0gbGF5ZXJTdGF0ZXNbaV07XG4gICAgICB2YXIgbGF5ZXIgPSBsYXllclN0YXRlLmxheWVyO1xuICAgICAgaWYgKHZpc2libGVBdFJlc29sdXRpb24obGF5ZXJTdGF0ZSwgdmlld1Jlc29sdXRpb24pICYmIGxheWVyRmlsdGVyLmNhbGwodGhpc0FyZzIsIGxheWVyKSkge1xuICAgICAgICB2YXIgbGF5ZXJSZW5kZXJlciA9IHRoaXMuZ2V0TGF5ZXJSZW5kZXJlcihsYXllcik7XG4gICAgICAgIHZhciBzb3VyY2UgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHR9ICovIChsYXllcikuZ2V0U291cmNlKCk7XG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICByZXN1bHQgPSBsYXllclJlbmRlcmVyLmZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlKFxuICAgICAgICAgICAgc291cmNlLmdldFdyYXBYKCkgPyB0cmFuc2xhdGVkQ29vcmRpbmF0ZSA6IGNvb3JkaW5hdGUsXG4gICAgICAgICAgICBmcmFtZVN0YXRlLCBoaXRUb2xlcmFuY2UsIGZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9waXhlbC5qc1wiKS5QaXhlbH0gcGl4ZWwgUGl4ZWwuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWVTdGF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGhpdFRvbGVyYW5jZSBIaXQgdG9sZXJhbmNlIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBTLCBpbXBvcnQoXCIuLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0LCAoVWludDhDbGFtcGVkQXJyYXl8VWludDhBcnJheSkpOiBUfSBjYWxsYmFjayBMYXllclxuICAgKiAgICAgY2FsbGJhY2suXG4gICAqIEBwYXJhbSB7U30gdGhpc0FyZyBWYWx1ZSB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIGBjYWxsYmFja2AuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczogVSwgaW1wb3J0KFwiLi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdCk6IGJvb2xlYW59IGxheWVyRmlsdGVyIExheWVyIGZpbHRlclxuICAgKiAgICAgZnVuY3Rpb24sIG9ubHkgbGF5ZXJzIHdoaWNoIGFyZSB2aXNpYmxlIGFuZCBmb3Igd2hpY2ggdGhpcyBmdW5jdGlvblxuICAgKiAgICAgcmV0dXJucyBgdHJ1ZWAgd2lsbCBiZSB0ZXN0ZWQgZm9yIGZlYXR1cmVzLiAgQnkgZGVmYXVsdCwgYWxsIHZpc2libGVcbiAgICogICAgIGxheWVycyB3aWxsIGJlIHRlc3RlZC5cbiAgICogQHBhcmFtIHtVfSB0aGlzQXJnMiBWYWx1ZSB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIGBsYXllckZpbHRlcmAuXG4gICAqIEByZXR1cm4ge1R8dW5kZWZpbmVkfSBDYWxsYmFjayByZXN1bHQuXG4gICAqIEB0ZW1wbGF0ZSBTLFQsVVxuICAgKi9cbiAgTWFwUmVuZGVyZXIucHJvdG90eXBlLmZvckVhY2hMYXllckF0UGl4ZWwgPSBmdW5jdGlvbiBmb3JFYWNoTGF5ZXJBdFBpeGVsIChwaXhlbCwgZnJhbWVTdGF0ZSwgaGl0VG9sZXJhbmNlLCBjYWxsYmFjaywgdGhpc0FyZywgbGF5ZXJGaWx0ZXIsIHRoaXNBcmcyKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWVTdGF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGhpdFRvbGVyYW5jZSBIaXQgdG9sZXJhbmNlIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBVLCBpbXBvcnQoXCIuLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0KTogYm9vbGVhbn0gbGF5ZXJGaWx0ZXIgTGF5ZXIgZmlsdGVyXG4gICAqICAgICBmdW5jdGlvbiwgb25seSBsYXllcnMgd2hpY2ggYXJlIHZpc2libGUgYW5kIGZvciB3aGljaCB0aGlzIGZ1bmN0aW9uXG4gICAqICAgICByZXR1cm5zIGB0cnVlYCB3aWxsIGJlIHRlc3RlZCBmb3IgZmVhdHVyZXMuICBCeSBkZWZhdWx0LCBhbGwgdmlzaWJsZVxuICAgKiAgICAgbGF5ZXJzIHdpbGwgYmUgdGVzdGVkLlxuICAgKiBAcGFyYW0ge1V9IHRoaXNBcmcgVmFsdWUgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyBgbGF5ZXJGaWx0ZXJgLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJcyB0aGVyZSBhIGZlYXR1cmUgYXQgdGhlIGdpdmVuIGNvb3JkaW5hdGU/XG4gICAqIEB0ZW1wbGF0ZSBVXG4gICAqL1xuICBNYXBSZW5kZXJlci5wcm90b3R5cGUuaGFzRmVhdHVyZUF0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGhhc0ZlYXR1cmVBdENvb3JkaW5hdGUgKGNvb3JkaW5hdGUsIGZyYW1lU3RhdGUsIGhpdFRvbGVyYW5jZSwgbGF5ZXJGaWx0ZXIsIHRoaXNBcmcpIHtcbiAgICB2YXIgaGFzRmVhdHVyZSA9IHRoaXMuZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGUoXG4gICAgICBjb29yZGluYXRlLCBmcmFtZVN0YXRlLCBoaXRUb2xlcmFuY2UsIFRSVUUsIHRoaXMsIGxheWVyRmlsdGVyLCB0aGlzQXJnKTtcblxuICAgIHJldHVybiBoYXNGZWF0dXJlICE9PSB1bmRlZmluZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vbGF5ZXIvQmFzZS5qc1wiKS5kZWZhdWx0fSBsYXllciBMYXllci5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL0xheWVyLmpzXCIpLmRlZmF1bHR9IExheWVyIHJlbmRlcmVyLlxuICAgKi9cbiAgTWFwUmVuZGVyZXIucHJvdG90eXBlLmdldExheWVyUmVuZGVyZXIgPSBmdW5jdGlvbiBnZXRMYXllclJlbmRlcmVyIChsYXllcikge1xuICAgIHZhciBsYXllcktleSA9IGdldFVpZChsYXllcik7XG4gICAgaWYgKGxheWVyS2V5IGluIHRoaXMubGF5ZXJSZW5kZXJlcnNfKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYXllclJlbmRlcmVyc19bbGF5ZXJLZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmVuZGVyZXI7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLmxheWVyUmVuZGVyZXJDb25zdHJ1Y3RvcnNfLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHRoaXMubGF5ZXJSZW5kZXJlckNvbnN0cnVjdG9yc19baV07XG4gICAgICAgIGlmIChjYW5kaWRhdGVbJ2hhbmRsZXMnXShsYXllcikpIHtcbiAgICAgICAgICByZW5kZXJlciA9IGNhbmRpZGF0ZVsnY3JlYXRlJ10odGhpcywgbGF5ZXIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5sYXllclJlbmRlcmVyc19bbGF5ZXJLZXldID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMubGF5ZXJSZW5kZXJlckxpc3RlbmVyc19bbGF5ZXJLZXldID0gbGlzdGVuKHJlbmRlcmVyLFxuICAgICAgICAgIEV2ZW50VHlwZS5DSEFOR0UsIHRoaXMuaGFuZGxlTGF5ZXJSZW5kZXJlckNoYW5nZV8sIHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gY3JlYXRlIHJlbmRlcmVyIGZvciBsYXllcjogJyArIGxheWVyLmdldFR5cGUoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVuZGVyZXI7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJLZXkgTGF5ZXIga2V5LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vTGF5ZXIuanNcIikuZGVmYXVsdH0gTGF5ZXIgcmVuZGVyZXIuXG4gICAqL1xuICBNYXBSZW5kZXJlci5wcm90b3R5cGUuZ2V0TGF5ZXJSZW5kZXJlckJ5S2V5ID0gZnVuY3Rpb24gZ2V0TGF5ZXJSZW5kZXJlckJ5S2V5IChsYXllcktleSkge1xuICAgIHJldHVybiB0aGlzLmxheWVyUmVuZGVyZXJzX1tsYXllcktleV07XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHJldHVybiB7T2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi9MYXllci5qc1wiKS5kZWZhdWx0Pn0gTGF5ZXIgcmVuZGVyZXJzLlxuICAgKi9cbiAgTWFwUmVuZGVyZXIucHJvdG90eXBlLmdldExheWVyUmVuZGVyZXJzID0gZnVuY3Rpb24gZ2V0TGF5ZXJSZW5kZXJlcnMgKCkge1xuICAgIHJldHVybiB0aGlzLmxheWVyUmVuZGVyZXJzXztcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLmRlZmF1bHR9IE1hcC5cbiAgICovXG4gIE1hcFJlbmRlcmVyLnByb3RvdHlwZS5nZXRNYXAgPSBmdW5jdGlvbiBnZXRNYXAgKCkge1xuICAgIHJldHVybiB0aGlzLm1hcF87XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBjaGFuZ2VzIGluIGEgbGF5ZXIgcmVuZGVyZXIuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBNYXBSZW5kZXJlci5wcm90b3R5cGUuaGFuZGxlTGF5ZXJSZW5kZXJlckNoYW5nZV8gPSBmdW5jdGlvbiBoYW5kbGVMYXllclJlbmRlcmVyQ2hhbmdlXyAoKSB7XG4gICAgdGhpcy5tYXBfLnJlbmRlcigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJLZXkgTGF5ZXIga2V5LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL0xheWVyLmpzXCIpLmRlZmF1bHR9IExheWVyIHJlbmRlcmVyLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTWFwUmVuZGVyZXIucHJvdG90eXBlLnJlbW92ZUxheWVyUmVuZGVyZXJCeUtleV8gPSBmdW5jdGlvbiByZW1vdmVMYXllclJlbmRlcmVyQnlLZXlfIChsYXllcktleSkge1xuICAgIHZhciBsYXllclJlbmRlcmVyID0gdGhpcy5sYXllclJlbmRlcmVyc19bbGF5ZXJLZXldO1xuICAgIGRlbGV0ZSB0aGlzLmxheWVyUmVuZGVyZXJzX1tsYXllcktleV07XG5cbiAgICB1bmxpc3RlbkJ5S2V5KHRoaXMubGF5ZXJSZW5kZXJlckxpc3RlbmVyc19bbGF5ZXJLZXldKTtcbiAgICBkZWxldGUgdGhpcy5sYXllclJlbmRlcmVyTGlzdGVuZXJzX1tsYXllcktleV07XG5cbiAgICByZXR1cm4gbGF5ZXJSZW5kZXJlcjtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuZGVmYXVsdH0gbWFwIE1hcC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIE1hcFJlbmRlcmVyLnByb3RvdHlwZS5yZW1vdmVVbnVzZWRMYXllclJlbmRlcmVyc18gPSBmdW5jdGlvbiByZW1vdmVVbnVzZWRMYXllclJlbmRlcmVyc18gKG1hcCwgZnJhbWVTdGF0ZSkge1xuICAgIGZvciAodmFyIGxheWVyS2V5IGluIHRoaXMubGF5ZXJSZW5kZXJlcnNfKSB7XG4gICAgICBpZiAoIWZyYW1lU3RhdGUgfHwgIShsYXllcktleSBpbiBmcmFtZVN0YXRlLmxheWVyU3RhdGVzKSkge1xuICAgICAgICB0aGlzLnJlbW92ZUxheWVyUmVuZGVyZXJCeUtleV8obGF5ZXJLZXkpLmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlci5cbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7P2ltcG9ydChcIi4uL1BsdWdnYWJsZU1hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKi9cbiAgTWFwUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gcmVuZGVyRnJhbWUgKGZyYW1lU3RhdGUpIHtcbiAgICBhYnN0cmFjdCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1BsdWdnYWJsZU1hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBNYXBSZW5kZXJlci5wcm90b3R5cGUuc2NoZWR1bGVFeHBpcmVJY29uQ2FjaGUgPSBmdW5jdGlvbiBzY2hlZHVsZUV4cGlyZUljb25DYWNoZSAoZnJhbWVTdGF0ZSkge1xuICAgIGZyYW1lU3RhdGUucG9zdFJlbmRlckZ1bmN0aW9ucy5wdXNoKC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLlBvc3RSZW5kZXJGdW5jdGlvbn0gKi8gKGV4cGlyZUljb25DYWNoZSkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgTWFwUmVuZGVyZXIucHJvdG90eXBlLnNjaGVkdWxlUmVtb3ZlVW51c2VkTGF5ZXJSZW5kZXJlcnMgPSBmdW5jdGlvbiBzY2hlZHVsZVJlbW92ZVVudXNlZExheWVyUmVuZGVyZXJzIChmcmFtZVN0YXRlKSB7XG4gICAgZm9yICh2YXIgbGF5ZXJLZXkgaW4gdGhpcy5sYXllclJlbmRlcmVyc18pIHtcbiAgICAgIGlmICghKGxheWVyS2V5IGluIGZyYW1lU3RhdGUubGF5ZXJTdGF0ZXMpKSB7XG4gICAgICAgIGZyYW1lU3RhdGUucG9zdFJlbmRlckZ1bmN0aW9ucy5wdXNoKFxuICAgICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLlBvc3RSZW5kZXJGdW5jdGlvbn0gKi8gKHRoaXMucmVtb3ZlVW51c2VkTGF5ZXJSZW5kZXJlcnNfLmJpbmQodGhpcykpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIE1hcFJlbmRlcmVyO1xufShEaXNwb3NhYmxlKSk7XG5cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL1BsdWdnYWJsZU1hcC5qc1wiKS5kZWZhdWx0fSBtYXAgTWFwLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAqL1xuZnVuY3Rpb24gZXhwaXJlSWNvbkNhY2hlKG1hcCwgZnJhbWVTdGF0ZSkge1xuICBpY29uSW1hZ2VDYWNoZS5leHBpcmUoKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vbGF5ZXIvTGF5ZXIuanNcIikuU3RhdGV9IHN0YXRlMSBGaXJzdCBsYXllciBzdGF0ZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vbGF5ZXIvTGF5ZXIuanNcIikuU3RhdGV9IHN0YXRlMiBTZWNvbmQgbGF5ZXIgc3RhdGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB6SW5kZXggZGlmZmVyZW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNvcnRCeVpJbmRleChzdGF0ZTEsIHN0YXRlMikge1xuICByZXR1cm4gc3RhdGUxLnpJbmRleCAtIHN0YXRlMi56SW5kZXg7XG59XG5leHBvcnQgZGVmYXVsdCBNYXBSZW5kZXJlcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWFwLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXJlci9jYW52YXMvSW1hZ2VMYXllclxuICovXG5pbXBvcnQge0VOQUJMRV9SQVNURVJfUkVQUk9KRUNUSU9OfSBmcm9tICcuLi8uLi9yZXByb2ovY29tbW9uLmpzJztcbmltcG9ydCBJbWFnZUNhbnZhcyBmcm9tICcuLi8uLi9JbWFnZUNhbnZhcy5qcyc7XG5pbXBvcnQgTGF5ZXJUeXBlIGZyb20gJy4uLy4uL0xheWVyVHlwZS5qcyc7XG5pbXBvcnQgVmlld0hpbnQgZnJvbSAnLi4vLi4vVmlld0hpbnQuanMnO1xuaW1wb3J0IHtlcXVhbHN9IGZyb20gJy4uLy4uL2FycmF5LmpzJztcbmltcG9ydCB7Z2V0SGVpZ2h0LCBnZXRJbnRlcnNlY3Rpb24sIGdldFdpZHRoLCBpc0VtcHR5fSBmcm9tICcuLi8uLi9leHRlbnQuanMnO1xuaW1wb3J0IFZlY3RvclJlbmRlclR5cGUgZnJvbSAnLi4vLi4vbGF5ZXIvVmVjdG9yUmVuZGVyVHlwZS5qcyc7XG5pbXBvcnQge2Fzc2lnbn0gZnJvbSAnLi4vLi4vb2JqLmpzJztcbmltcG9ydCB7bGF5ZXJSZW5kZXJlckNvbnN0cnVjdG9yc30gZnJvbSAnLi9NYXAuanMnO1xuaW1wb3J0IEludGVybWVkaWF0ZUNhbnZhc1JlbmRlcmVyIGZyb20gJy4vSW50ZXJtZWRpYXRlQ2FudmFzLmpzJztcbmltcG9ydCB7Y3JlYXRlIGFzIGNyZWF0ZVRyYW5zZm9ybSwgY29tcG9zZSBhcyBjb21wb3NlVHJhbnNmb3JtfSBmcm9tICcuLi8uLi90cmFuc2Zvcm0uanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIENhbnZhcyByZW5kZXJlciBmb3IgaW1hZ2UgbGF5ZXJzLlxuICogQGFwaVxuICovXG52YXIgQ2FudmFzSW1hZ2VMYXllclJlbmRlcmVyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoSW50ZXJtZWRpYXRlQ2FudmFzUmVuZGVyZXIpIHtcbiAgZnVuY3Rpb24gQ2FudmFzSW1hZ2VMYXllclJlbmRlcmVyKGltYWdlTGF5ZXIpIHtcblxuICAgIEludGVybWVkaWF0ZUNhbnZhc1JlbmRlcmVyLmNhbGwodGhpcywgaW1hZ2VMYXllcik7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi4vLi4vSW1hZ2VCYXNlLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5pbWFnZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlVHJhbnNmb3JtXyA9IGNyZWF0ZVRyYW5zZm9ybSgpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgeyFBcnJheTxzdHJpbmc+fVxuICAgICAqL1xuICAgIHRoaXMuc2tpcHBlZEZlYXR1cmVzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9WZWN0b3JMYXllci5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMudmVjdG9yUmVuZGVyZXJfID0gbnVsbDtcblxuICAgIGlmIChpbWFnZUxheWVyLmdldFR5cGUoKSA9PT0gTGF5ZXJUeXBlLlZFQ1RPUikge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gbGF5ZXJSZW5kZXJlckNvbnN0cnVjdG9ycy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIHZhciBjdG9yID0gbGF5ZXJSZW5kZXJlckNvbnN0cnVjdG9yc1tpXTtcbiAgICAgICAgaWYgKGN0b3IgIT09IENhbnZhc0ltYWdlTGF5ZXJSZW5kZXJlciAmJiBjdG9yWydoYW5kbGVzJ10oaW1hZ2VMYXllcikpIHtcbiAgICAgICAgICB0aGlzLnZlY3RvclJlbmRlcmVyXyA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9WZWN0b3JMYXllci5qc1wiKS5kZWZhdWx0fSAqLyAobmV3IGN0b3IoaW1hZ2VMYXllcikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gIH1cblxuICBpZiAoIEludGVybWVkaWF0ZUNhbnZhc1JlbmRlcmVyICkgQ2FudmFzSW1hZ2VMYXllclJlbmRlcmVyLl9fcHJvdG9fXyA9IEludGVybWVkaWF0ZUNhbnZhc1JlbmRlcmVyO1xuICBDYW52YXNJbWFnZUxheWVyUmVuZGVyZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSW50ZXJtZWRpYXRlQ2FudmFzUmVuZGVyZXIgJiYgSW50ZXJtZWRpYXRlQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlICk7XG4gIENhbnZhc0ltYWdlTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYW52YXNJbWFnZUxheWVyUmVuZGVyZXI7XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNJbWFnZUxheWVyUmVuZGVyZXIucHJvdG90eXBlLmRpc3Bvc2VJbnRlcm5hbCA9IGZ1bmN0aW9uIGRpc3Bvc2VJbnRlcm5hbCAoKSB7XG4gICAgaWYgKHRoaXMudmVjdG9yUmVuZGVyZXJfKSB7XG4gICAgICB0aGlzLnZlY3RvclJlbmRlcmVyXy5kaXNwb3NlKCk7XG4gICAgfVxuICAgIEludGVybWVkaWF0ZUNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5kaXNwb3NlSW50ZXJuYWwuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENhbnZhc0ltYWdlTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuZ2V0SW1hZ2UgPSBmdW5jdGlvbiBnZXRJbWFnZSAoKSB7XG4gICAgcmV0dXJuICF0aGlzLmltYWdlXyA/IG51bGwgOiB0aGlzLmltYWdlXy5nZXRJbWFnZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQ2FudmFzSW1hZ2VMYXllclJlbmRlcmVyLnByb3RvdHlwZS5nZXRJbWFnZVRyYW5zZm9ybSA9IGZ1bmN0aW9uIGdldEltYWdlVHJhbnNmb3JtICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbWFnZVRyYW5zZm9ybV87XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNJbWFnZUxheWVyUmVuZGVyZXIucHJvdG90eXBlLnByZXBhcmVGcmFtZSA9IGZ1bmN0aW9uIHByZXBhcmVGcmFtZSAoZnJhbWVTdGF0ZSwgbGF5ZXJTdGF0ZSkge1xuXG4gICAgdmFyIHBpeGVsUmF0aW8gPSBmcmFtZVN0YXRlLnBpeGVsUmF0aW87XG4gICAgdmFyIHNpemUgPSBmcmFtZVN0YXRlLnNpemU7XG4gICAgdmFyIHZpZXdTdGF0ZSA9IGZyYW1lU3RhdGUudmlld1N0YXRlO1xuICAgIHZhciB2aWV3Q2VudGVyID0gdmlld1N0YXRlLmNlbnRlcjtcbiAgICB2YXIgdmlld1Jlc29sdXRpb24gPSB2aWV3U3RhdGUucmVzb2x1dGlvbjtcblxuICAgIHZhciBpbWFnZTtcbiAgICB2YXIgaW1hZ2VMYXllciA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vbGF5ZXIvSW1hZ2UuanNcIikuZGVmYXVsdH0gKi8gKHRoaXMuZ2V0TGF5ZXIoKSk7XG4gICAgdmFyIGltYWdlU291cmNlID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9zb3VyY2UvSW1hZ2UuanNcIikuZGVmYXVsdH0gKi8gKGltYWdlTGF5ZXIuZ2V0U291cmNlKCkpO1xuXG4gICAgdmFyIGhpbnRzID0gZnJhbWVTdGF0ZS52aWV3SGludHM7XG5cbiAgICB2YXIgdmVjdG9yUmVuZGVyZXIgPSB0aGlzLnZlY3RvclJlbmRlcmVyXztcbiAgICB2YXIgcmVuZGVyZWRFeHRlbnQgPSBmcmFtZVN0YXRlLmV4dGVudDtcbiAgICBpZiAoIXZlY3RvclJlbmRlcmVyICYmIGxheWVyU3RhdGUuZXh0ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlbmRlcmVkRXh0ZW50ID0gZ2V0SW50ZXJzZWN0aW9uKHJlbmRlcmVkRXh0ZW50LCBsYXllclN0YXRlLmV4dGVudCk7XG4gICAgfVxuXG4gICAgaWYgKCFoaW50c1tWaWV3SGludC5BTklNQVRJTkddICYmICFoaW50c1tWaWV3SGludC5JTlRFUkFDVElOR10gJiZcbiAgICAgICAgIWlzRW1wdHkocmVuZGVyZWRFeHRlbnQpKSB7XG4gICAgICB2YXIgcHJvamVjdGlvbiA9IHZpZXdTdGF0ZS5wcm9qZWN0aW9uO1xuICAgICAgaWYgKCFFTkFCTEVfUkFTVEVSX1JFUFJPSkVDVElPTikge1xuICAgICAgICB2YXIgc291cmNlUHJvamVjdGlvbiA9IGltYWdlU291cmNlLmdldFByb2plY3Rpb24oKTtcbiAgICAgICAgaWYgKHNvdXJjZVByb2plY3Rpb24pIHtcbiAgICAgICAgICBwcm9qZWN0aW9uID0gc291cmNlUHJvamVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHNraXBwZWRGZWF0dXJlcyA9IHRoaXMuc2tpcHBlZEZlYXR1cmVzXztcbiAgICAgIGlmICh2ZWN0b3JSZW5kZXJlcikge1xuICAgICAgICB2YXIgY29udGV4dCA9IHZlY3RvclJlbmRlcmVyLmNvbnRleHQ7XG4gICAgICAgIHZhciBpbWFnZUZyYW1lU3RhdGUgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL1BsdWdnYWJsZU1hcC5qc1wiKS5GcmFtZVN0YXRlfSAqLyAoYXNzaWduKHt9LCBmcmFtZVN0YXRlLCB7XG4gICAgICAgICAgc2l6ZTogW1xuICAgICAgICAgICAgZ2V0V2lkdGgocmVuZGVyZWRFeHRlbnQpIC8gdmlld1Jlc29sdXRpb24sXG4gICAgICAgICAgICBnZXRIZWlnaHQocmVuZGVyZWRFeHRlbnQpIC8gdmlld1Jlc29sdXRpb25cbiAgICAgICAgICBdLFxuICAgICAgICAgIHZpZXdTdGF0ZTogLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9WaWV3LmpzXCIpLlN0YXRlfSAqLyAoYXNzaWduKHt9LCBmcmFtZVN0YXRlLnZpZXdTdGF0ZSwge1xuICAgICAgICAgICAgcm90YXRpb246IDBcbiAgICAgICAgICB9KSlcbiAgICAgICAgfSkpO1xuICAgICAgICB2YXIgbmV3U2tpcHBlZEZlYXR1cmVzID0gT2JqZWN0LmtleXMoaW1hZ2VGcmFtZVN0YXRlLnNraXBwZWRGZWF0dXJlVWlkcykuc29ydCgpO1xuICAgICAgICBpbWFnZSA9IG5ldyBJbWFnZUNhbnZhcyhyZW5kZXJlZEV4dGVudCwgdmlld1Jlc29sdXRpb24sIHBpeGVsUmF0aW8sIGNvbnRleHQuY2FudmFzLCBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgIGlmICh2ZWN0b3JSZW5kZXJlci5wcmVwYXJlRnJhbWUoaW1hZ2VGcmFtZVN0YXRlLCBsYXllclN0YXRlKSAmJlxuICAgICAgICAgICAgICAodmVjdG9yUmVuZGVyZXIucmVwbGF5R3JvdXBDaGFuZ2VkIHx8XG4gICAgICAgICAgICAgICFlcXVhbHMoc2tpcHBlZEZlYXR1cmVzLCBuZXdTa2lwcGVkRmVhdHVyZXMpKSkge1xuICAgICAgICAgICAgY29udGV4dC5jYW52YXMud2lkdGggPSBpbWFnZUZyYW1lU3RhdGUuc2l6ZVswXSAqIHBpeGVsUmF0aW87XG4gICAgICAgICAgICBjb250ZXh0LmNhbnZhcy5oZWlnaHQgPSBpbWFnZUZyYW1lU3RhdGUuc2l6ZVsxXSAqIHBpeGVsUmF0aW87XG4gICAgICAgICAgICB2ZWN0b3JSZW5kZXJlci5jb21wb3NlKGNvbnRleHQsIGltYWdlRnJhbWVTdGF0ZSwgbGF5ZXJTdGF0ZSk7XG4gICAgICAgICAgICBza2lwcGVkRmVhdHVyZXMgPSBuZXdTa2lwcGVkRmVhdHVyZXM7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbWFnZSA9IGltYWdlU291cmNlLmdldEltYWdlKFxuICAgICAgICAgIHJlbmRlcmVkRXh0ZW50LCB2aWV3UmVzb2x1dGlvbiwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbik7XG4gICAgICB9XG4gICAgICBpZiAoaW1hZ2UgJiYgdGhpcy5sb2FkSW1hZ2UoaW1hZ2UpKSB7XG4gICAgICAgIHRoaXMuaW1hZ2VfID0gaW1hZ2U7XG4gICAgICAgIHRoaXMuc2tpcHBlZEZlYXR1cmVzXyA9IHNraXBwZWRGZWF0dXJlcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5pbWFnZV8pIHtcbiAgICAgIGltYWdlID0gdGhpcy5pbWFnZV87XG4gICAgICB2YXIgaW1hZ2VFeHRlbnQgPSBpbWFnZS5nZXRFeHRlbnQoKTtcbiAgICAgIHZhciBpbWFnZVJlc29sdXRpb24gPSBpbWFnZS5nZXRSZXNvbHV0aW9uKCk7XG4gICAgICB2YXIgaW1hZ2VQaXhlbFJhdGlvID0gaW1hZ2UuZ2V0UGl4ZWxSYXRpbygpO1xuICAgICAgdmFyIHNjYWxlID0gcGl4ZWxSYXRpbyAqIGltYWdlUmVzb2x1dGlvbiAvXG4gICAgICAgICAgKHZpZXdSZXNvbHV0aW9uICogaW1hZ2VQaXhlbFJhdGlvKTtcbiAgICAgIHZhciB0cmFuc2Zvcm0gPSBjb21wb3NlVHJhbnNmb3JtKHRoaXMuaW1hZ2VUcmFuc2Zvcm1fLFxuICAgICAgICBwaXhlbFJhdGlvICogc2l6ZVswXSAvIDIsIHBpeGVsUmF0aW8gKiBzaXplWzFdIC8gMixcbiAgICAgICAgc2NhbGUsIHNjYWxlLFxuICAgICAgICAwLFxuICAgICAgICBpbWFnZVBpeGVsUmF0aW8gKiAoaW1hZ2VFeHRlbnRbMF0gLSB2aWV3Q2VudGVyWzBdKSAvIGltYWdlUmVzb2x1dGlvbixcbiAgICAgICAgaW1hZ2VQaXhlbFJhdGlvICogKHZpZXdDZW50ZXJbMV0gLSBpbWFnZUV4dGVudFszXSkgLyBpbWFnZVJlc29sdXRpb24pO1xuICAgICAgY29tcG9zZVRyYW5zZm9ybSh0aGlzLmNvb3JkaW5hdGVUb0NhbnZhc1BpeGVsVHJhbnNmb3JtLFxuICAgICAgICBwaXhlbFJhdGlvICogc2l6ZVswXSAvIDIgLSB0cmFuc2Zvcm1bNF0sIHBpeGVsUmF0aW8gKiBzaXplWzFdIC8gMiAtIHRyYW5zZm9ybVs1XSxcbiAgICAgICAgcGl4ZWxSYXRpbyAvIHZpZXdSZXNvbHV0aW9uLCAtcGl4ZWxSYXRpbyAvIHZpZXdSZXNvbHV0aW9uLFxuICAgICAgICAwLFxuICAgICAgICAtdmlld0NlbnRlclswXSwgLXZpZXdDZW50ZXJbMV0pO1xuXG4gICAgICB0aGlzLnJlbmRlcmVkUmVzb2x1dGlvbiA9IGltYWdlUmVzb2x1dGlvbiAqIHBpeGVsUmF0aW8gLyBpbWFnZVBpeGVsUmF0aW87XG4gICAgfVxuXG4gICAgcmV0dXJuICEhdGhpcy5pbWFnZV87XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNJbWFnZUxheWVyUmVuZGVyZXIucHJvdG90eXBlLmZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlID0gZnVuY3Rpb24gZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGUgKGNvb3JkaW5hdGUsIGZyYW1lU3RhdGUsIGhpdFRvbGVyYW5jZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy52ZWN0b3JSZW5kZXJlcl8pIHtcbiAgICAgIHJldHVybiB0aGlzLnZlY3RvclJlbmRlcmVyXy5mb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZShjb29yZGluYXRlLCBmcmFtZVN0YXRlLCBoaXRUb2xlcmFuY2UsIGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEludGVybWVkaWF0ZUNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5mb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZS5jYWxsKHRoaXMsIGNvb3JkaW5hdGUsIGZyYW1lU3RhdGUsIGhpdFRvbGVyYW5jZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gQ2FudmFzSW1hZ2VMYXllclJlbmRlcmVyO1xufShJbnRlcm1lZGlhdGVDYW52YXNSZW5kZXJlcikpO1xuXG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHRoaXMgcmVuZGVyZXIgaGFuZGxlcyB0aGUgcHJvdmlkZWQgbGF5ZXIuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHR9IGxheWVyIFRoZSBjYW5kaWRhdGUgbGF5ZXIuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgcmVuZGVyZXIgY2FuIHJlbmRlciB0aGUgbGF5ZXIuXG4gKi9cbkNhbnZhc0ltYWdlTGF5ZXJSZW5kZXJlclsnaGFuZGxlcyddID0gZnVuY3Rpb24obGF5ZXIpIHtcbiAgcmV0dXJuIGxheWVyLmdldFR5cGUoKSA9PT0gTGF5ZXJUeXBlLklNQUdFIHx8XG4gICAgbGF5ZXIuZ2V0VHlwZSgpID09PSBMYXllclR5cGUuVkVDVE9SICYmXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9sYXllci9WZWN0b3IuanNcIikuZGVmYXVsdH0gKi8gKGxheWVyKS5nZXRSZW5kZXJNb2RlKCkgPT09IFZlY3RvclJlbmRlclR5cGUuSU1BR0U7XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlIGEgbGF5ZXIgcmVuZGVyZXIuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcC5qc1wiKS5kZWZhdWx0fSBtYXBSZW5kZXJlciBUaGUgbWFwIHJlbmRlcmVyLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0fSBsYXllciBUaGUgbGF5ZXIgdG8gYmUgcmVuZGVyZXJkLlxuICogQHJldHVybiB7Q2FudmFzSW1hZ2VMYXllclJlbmRlcmVyfSBUaGUgbGF5ZXIgcmVuZGVyZXIuXG4gKi9cbkNhbnZhc0ltYWdlTGF5ZXJSZW5kZXJlclsnY3JlYXRlJ10gPSBmdW5jdGlvbihtYXBSZW5kZXJlciwgbGF5ZXIpIHtcbiAgcmV0dXJuIG5ldyBDYW52YXNJbWFnZUxheWVyUmVuZGVyZXIoLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9sYXllci9JbWFnZS5qc1wiKS5kZWZhdWx0fSAqLyAobGF5ZXIpKTtcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgQ2FudmFzSW1hZ2VMYXllclJlbmRlcmVyO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbWFnZUxheWVyLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXJlci9jYW52YXMvSW50ZXJtZWRpYXRlQ2FudmFzXG4gKi9cbmltcG9ydCB7YWJzdHJhY3R9IGZyb20gJy4uLy4uL3V0aWwuanMnO1xuaW1wb3J0IHtzY2FsZSBhcyBzY2FsZUNvb3JkaW5hdGV9IGZyb20gJy4uLy4uL2Nvb3JkaW5hdGUuanMnO1xuaW1wb3J0IHtjcmVhdGVDYW52YXNDb250ZXh0MkR9IGZyb20gJy4uLy4uL2RvbS5qcyc7XG5pbXBvcnQge2NvbnRhaW5zRXh0ZW50LCBpbnRlcnNlY3RzfSBmcm9tICcuLi8uLi9leHRlbnQuanMnO1xuaW1wb3J0IENhbnZhc0xheWVyUmVuZGVyZXIgZnJvbSAnLi9MYXllci5qcyc7XG5pbXBvcnQge2NyZWF0ZSBhcyBjcmVhdGVUcmFuc2Zvcm0sIGFwcGx5IGFzIGFwcGx5VHJhbnNmb3JtfSBmcm9tICcuLi8uLi90cmFuc2Zvcm0uanMnO1xuXG4vKipcbiAqIEBhYnN0cmFjdFxuICovXG52YXIgSW50ZXJtZWRpYXRlQ2FudmFzUmVuZGVyZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChDYW52YXNMYXllclJlbmRlcmVyKSB7XG4gIGZ1bmN0aW9uIEludGVybWVkaWF0ZUNhbnZhc1JlbmRlcmVyKGxheWVyKSB7XG5cbiAgICBDYW52YXNMYXllclJlbmRlcmVyLmNhbGwodGhpcywgbGF5ZXIpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfVxuICAgICAqL1xuICAgIHRoaXMuY29vcmRpbmF0ZVRvQ2FudmFzUGl4ZWxUcmFuc2Zvcm0gPSBjcmVhdGVUcmFuc2Zvcm0oKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAgICAgKi9cbiAgICB0aGlzLmhpdENhbnZhc0NvbnRleHRfID0gbnVsbDtcblxuICB9XG5cbiAgaWYgKCBDYW52YXNMYXllclJlbmRlcmVyICkgSW50ZXJtZWRpYXRlQ2FudmFzUmVuZGVyZXIuX19wcm90b19fID0gQ2FudmFzTGF5ZXJSZW5kZXJlcjtcbiAgSW50ZXJtZWRpYXRlQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ2FudmFzTGF5ZXJSZW5kZXJlciAmJiBDYW52YXNMYXllclJlbmRlcmVyLnByb3RvdHlwZSApO1xuICBJbnRlcm1lZGlhdGVDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbnRlcm1lZGlhdGVDYW52YXNSZW5kZXJlcjtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIEludGVybWVkaWF0ZUNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5jb21wb3NlRnJhbWUgPSBmdW5jdGlvbiBjb21wb3NlRnJhbWUgKGZyYW1lU3RhdGUsIGxheWVyU3RhdGUsIGNvbnRleHQpIHtcblxuICAgIHRoaXMucHJlQ29tcG9zZShjb250ZXh0LCBmcmFtZVN0YXRlKTtcblxuICAgIHZhciBpbWFnZSA9IHRoaXMuZ2V0SW1hZ2UoKTtcbiAgICBpZiAoaW1hZ2UpIHtcblxuICAgICAgLy8gY2xpcHBlZCByZW5kZXJpbmcgaWYgbGF5ZXIgZXh0ZW50IGlzIHNldFxuICAgICAgdmFyIGV4dGVudCA9IGxheWVyU3RhdGUuZXh0ZW50O1xuICAgICAgdmFyIGNsaXBwZWQgPSBleHRlbnQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICFjb250YWluc0V4dGVudChleHRlbnQsIGZyYW1lU3RhdGUuZXh0ZW50KSAmJlxuICAgICAgICAgIGludGVyc2VjdHMoZXh0ZW50LCBmcmFtZVN0YXRlLmV4dGVudCk7XG4gICAgICBpZiAoY2xpcHBlZCkge1xuICAgICAgICB0aGlzLmNsaXAoY29udGV4dCwgZnJhbWVTdGF0ZSwgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fSAqLyAoZXh0ZW50KSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbWFnZVRyYW5zZm9ybSA9IHRoaXMuZ2V0SW1hZ2VUcmFuc2Zvcm0oKTtcbiAgICAgIC8vIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLCBjb250ZXh0LnNhdmUgLyBjb250ZXh0LnJlc3RvcmUgaXMgbm90IHVzZWRcbiAgICAgIC8vIHRvIHNhdmUgYW5kIHJlc3RvcmUgdGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBhbmQgdGhlIG9wYWNpdHkuXG4gICAgICAvLyBzZWUgaHR0cDovL2pzcGVyZi5jb20vY29udGV4dC1zYXZlLXJlc3RvcmUtdmVyc3VzLXZhcmlhYmxlXG4gICAgICB2YXIgYWxwaGEgPSBjb250ZXh0Lmdsb2JhbEFscGhhO1xuICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGxheWVyU3RhdGUub3BhY2l0eTtcblxuICAgICAgLy8gZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIGNvbnRleHQuc2V0VHJhbnNmb3JtIGlzIG9ubHkgdXNlZFxuICAgICAgLy8gd2hlbiB0aGUgdmlldyBpcyByb3RhdGVkLiBzZWUgaHR0cDovL2pzcGVyZi5jb20vY2FudmFzLXRyYW5zZm9ybVxuICAgICAgdmFyIGR4ID0gaW1hZ2VUcmFuc2Zvcm1bNF07XG4gICAgICB2YXIgZHkgPSBpbWFnZVRyYW5zZm9ybVs1XTtcbiAgICAgIHZhciBkdyA9IGltYWdlLndpZHRoICogaW1hZ2VUcmFuc2Zvcm1bMF07XG4gICAgICB2YXIgZGggPSBpbWFnZS5oZWlnaHQgKiBpbWFnZVRyYW5zZm9ybVszXTtcbiAgICAgIGlmIChkdyA+PSAwLjUgJiYgZGggPj0gMC41KSB7XG4gICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLCAwLCAwLCAraW1hZ2Uud2lkdGgsICtpbWFnZS5oZWlnaHQsXG4gICAgICAgICAgTWF0aC5yb3VuZChkeCksIE1hdGgucm91bmQoZHkpLCBNYXRoLnJvdW5kKGR3KSwgTWF0aC5yb3VuZChkaCkpO1xuICAgICAgfVxuICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGFscGhhO1xuXG4gICAgICBpZiAoY2xpcHBlZCkge1xuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnBvc3RDb21wb3NlKGNvbnRleHQsIGZyYW1lU3RhdGUsIGxheWVyU3RhdGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR8SFRNTFZpZGVvRWxlbWVudHxIVE1MSW1hZ2VFbGVtZW50fSBDYW52YXMuXG4gICAqL1xuICBJbnRlcm1lZGlhdGVDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuZ2V0SW1hZ2UgPSBmdW5jdGlvbiBnZXRJbWFnZSAoKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHshaW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX0gSW1hZ2UgdHJhbnNmb3JtLlxuICAgKi9cbiAgSW50ZXJtZWRpYXRlQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmdldEltYWdlVHJhbnNmb3JtID0gZnVuY3Rpb24gZ2V0SW1hZ2VUcmFuc2Zvcm0gKCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgSW50ZXJtZWRpYXRlQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmZvckVhY2hMYXllckF0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGZvckVhY2hMYXllckF0Q29vcmRpbmF0ZSAoY29vcmRpbmF0ZSwgZnJhbWVTdGF0ZSwgaGl0VG9sZXJhbmNlLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIGlmICghdGhpcy5nZXRJbWFnZSgpKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHZhciBwaXhlbCA9IGFwcGx5VHJhbnNmb3JtKHRoaXMuY29vcmRpbmF0ZVRvQ2FudmFzUGl4ZWxUcmFuc2Zvcm0sIGNvb3JkaW5hdGUuc2xpY2UoKSk7XG4gICAgc2NhbGVDb29yZGluYXRlKHBpeGVsLCBmcmFtZVN0YXRlLnZpZXdTdGF0ZS5yZXNvbHV0aW9uIC8gdGhpcy5yZW5kZXJlZFJlc29sdXRpb24pO1xuXG4gICAgaWYgKCF0aGlzLmhpdENhbnZhc0NvbnRleHRfKSB7XG4gICAgICB0aGlzLmhpdENhbnZhc0NvbnRleHRfID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKDEsIDEpO1xuICAgIH1cblxuICAgIHRoaXMuaGl0Q2FudmFzQ29udGV4dF8uY2xlYXJSZWN0KDAsIDAsIDEsIDEpO1xuICAgIHRoaXMuaGl0Q2FudmFzQ29udGV4dF8uZHJhd0ltYWdlKHRoaXMuZ2V0SW1hZ2UoKSwgcGl4ZWxbMF0sIHBpeGVsWzFdLCAxLCAxLCAwLCAwLCAxLCAxKTtcblxuICAgIHZhciBpbWFnZURhdGEgPSB0aGlzLmhpdENhbnZhc0NvbnRleHRfLmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKS5kYXRhO1xuICAgIGlmIChpbWFnZURhdGFbM10gPiAwKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzLmdldExheWVyKCksIGltYWdlRGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBJbnRlcm1lZGlhdGVDYW52YXNSZW5kZXJlcjtcbn0oQ2FudmFzTGF5ZXJSZW5kZXJlcikpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IEludGVybWVkaWF0ZUNhbnZhc1JlbmRlcmVyO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbnRlcm1lZGlhdGVDYW52YXMuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlcmVyL2NhbnZhcy9MYXllclxuICovXG5pbXBvcnQge2Fic3RyYWN0fSBmcm9tICcuLi8uLi91dGlsLmpzJztcbmltcG9ydCB7Z2V0Qm90dG9tTGVmdCwgZ2V0Qm90dG9tUmlnaHQsIGdldFRvcExlZnQsIGdldFRvcFJpZ2h0fSBmcm9tICcuLi8uLi9leHRlbnQuanMnO1xuaW1wb3J0IHtUUlVFfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IFJlbmRlckV2ZW50IGZyb20gJy4uLy4uL3JlbmRlci9FdmVudC5qcyc7XG5pbXBvcnQgUmVuZGVyRXZlbnRUeXBlIGZyb20gJy4uLy4uL3JlbmRlci9FdmVudFR5cGUuanMnO1xuaW1wb3J0IHtyb3RhdGVBdE9mZnNldH0gZnJvbSAnLi4vLi4vcmVuZGVyL2NhbnZhcy5qcyc7XG5pbXBvcnQgQ2FudmFzSW1tZWRpYXRlUmVuZGVyZXIgZnJvbSAnLi4vLi4vcmVuZGVyL2NhbnZhcy9JbW1lZGlhdGUuanMnO1xuaW1wb3J0IExheWVyUmVuZGVyZXIgZnJvbSAnLi4vTGF5ZXIuanMnO1xuaW1wb3J0IHtjcmVhdGUgYXMgY3JlYXRlVHJhbnNmb3JtLCBhcHBseSBhcyBhcHBseVRyYW5zZm9ybSwgY29tcG9zZSBhcyBjb21wb3NlVHJhbnNmb3JtfSBmcm9tICcuLi8uLi90cmFuc2Zvcm0uanMnO1xuXG4vKipcbiAqIEBhYnN0cmFjdFxuICovXG52YXIgQ2FudmFzTGF5ZXJSZW5kZXJlciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKExheWVyUmVuZGVyZXIpIHtcbiAgZnVuY3Rpb24gQ2FudmFzTGF5ZXJSZW5kZXJlcihsYXllcikge1xuXG4gICAgTGF5ZXJSZW5kZXJlci5jYWxsKHRoaXMsIGxheWVyKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZWRSZXNvbHV0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX1cbiAgICAgKi9cbiAgICB0aGlzLnRyYW5zZm9ybV8gPSBjcmVhdGVUcmFuc2Zvcm0oKTtcblxuICB9XG5cbiAgaWYgKCBMYXllclJlbmRlcmVyICkgQ2FudmFzTGF5ZXJSZW5kZXJlci5fX3Byb3RvX18gPSBMYXllclJlbmRlcmVyO1xuICBDYW52YXNMYXllclJlbmRlcmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIExheWVyUmVuZGVyZXIgJiYgTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUgKTtcbiAgQ2FudmFzTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYW52YXNMYXllclJlbmRlcmVyO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBDb250ZXh0LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL1BsdWdnYWJsZU1hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBDbGlwIGV4dGVudC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgQ2FudmFzTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuY2xpcCA9IGZ1bmN0aW9uIGNsaXAgKGNvbnRleHQsIGZyYW1lU3RhdGUsIGV4dGVudCkge1xuICAgIHZhciBwaXhlbFJhdGlvID0gZnJhbWVTdGF0ZS5waXhlbFJhdGlvO1xuICAgIHZhciB3aWR0aCA9IGZyYW1lU3RhdGUuc2l6ZVswXSAqIHBpeGVsUmF0aW87XG4gICAgdmFyIGhlaWdodCA9IGZyYW1lU3RhdGUuc2l6ZVsxXSAqIHBpeGVsUmF0aW87XG4gICAgdmFyIHJvdGF0aW9uID0gZnJhbWVTdGF0ZS52aWV3U3RhdGUucm90YXRpb247XG4gICAgdmFyIHRvcExlZnQgPSBnZXRUb3BMZWZ0KGV4dGVudCk7XG4gICAgdmFyIHRvcFJpZ2h0ID0gZ2V0VG9wUmlnaHQoZXh0ZW50KTtcbiAgICB2YXIgYm90dG9tUmlnaHQgPSBnZXRCb3R0b21SaWdodChleHRlbnQpO1xuICAgIHZhciBib3R0b21MZWZ0ID0gZ2V0Qm90dG9tTGVmdChleHRlbnQpO1xuXG4gICAgYXBwbHlUcmFuc2Zvcm0oZnJhbWVTdGF0ZS5jb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybSwgdG9wTGVmdCk7XG4gICAgYXBwbHlUcmFuc2Zvcm0oZnJhbWVTdGF0ZS5jb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybSwgdG9wUmlnaHQpO1xuICAgIGFwcGx5VHJhbnNmb3JtKGZyYW1lU3RhdGUuY29vcmRpbmF0ZVRvUGl4ZWxUcmFuc2Zvcm0sIGJvdHRvbVJpZ2h0KTtcbiAgICBhcHBseVRyYW5zZm9ybShmcmFtZVN0YXRlLmNvb3JkaW5hdGVUb1BpeGVsVHJhbnNmb3JtLCBib3R0b21MZWZ0KTtcblxuICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgIHJvdGF0ZUF0T2Zmc2V0KGNvbnRleHQsIC1yb3RhdGlvbiwgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQubW92ZVRvKHRvcExlZnRbMF0gKiBwaXhlbFJhdGlvLCB0b3BMZWZ0WzFdICogcGl4ZWxSYXRpbyk7XG4gICAgY29udGV4dC5saW5lVG8odG9wUmlnaHRbMF0gKiBwaXhlbFJhdGlvLCB0b3BSaWdodFsxXSAqIHBpeGVsUmF0aW8pO1xuICAgIGNvbnRleHQubGluZVRvKGJvdHRvbVJpZ2h0WzBdICogcGl4ZWxSYXRpbywgYm90dG9tUmlnaHRbMV0gKiBwaXhlbFJhdGlvKTtcbiAgICBjb250ZXh0LmxpbmVUbyhib3R0b21MZWZ0WzBdICogcGl4ZWxSYXRpbywgYm90dG9tTGVmdFsxXSAqIHBpeGVsUmF0aW8pO1xuICAgIGNvbnRleHQuY2xpcCgpO1xuICAgIHJvdGF0ZUF0T2Zmc2V0KGNvbnRleHQsIHJvdGF0aW9uLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3JlbmRlci9FdmVudFR5cGUuanNcIikuZGVmYXVsdH0gdHlwZSBFdmVudCB0eXBlLlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBDb250ZXh0LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL1BsdWdnYWJsZU1hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm09fSBvcHRfdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIENhbnZhc0xheWVyUmVuZGVyZXIucHJvdG90eXBlLmRpc3BhdGNoQ29tcG9zZUV2ZW50XyA9IGZ1bmN0aW9uIGRpc3BhdGNoQ29tcG9zZUV2ZW50XyAodHlwZSwgY29udGV4dCwgZnJhbWVTdGF0ZSwgb3B0X3RyYW5zZm9ybSkge1xuICAgIHZhciBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKTtcbiAgICBpZiAobGF5ZXIuaGFzTGlzdGVuZXIodHlwZSkpIHtcbiAgICAgIHZhciB3aWR0aCA9IGZyYW1lU3RhdGUuc2l6ZVswXSAqIGZyYW1lU3RhdGUucGl4ZWxSYXRpbztcbiAgICAgIHZhciBoZWlnaHQgPSBmcmFtZVN0YXRlLnNpemVbMV0gKiBmcmFtZVN0YXRlLnBpeGVsUmF0aW87XG4gICAgICB2YXIgcm90YXRpb24gPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZS5yb3RhdGlvbjtcbiAgICAgIHJvdGF0ZUF0T2Zmc2V0KGNvbnRleHQsIC1yb3RhdGlvbiwgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcbiAgICAgIHZhciB0cmFuc2Zvcm0gPSBvcHRfdHJhbnNmb3JtICE9PSB1bmRlZmluZWQgP1xuICAgICAgICBvcHRfdHJhbnNmb3JtIDogdGhpcy5nZXRUcmFuc2Zvcm0oZnJhbWVTdGF0ZSwgMCk7XG4gICAgICB2YXIgcmVuZGVyID0gbmV3IENhbnZhc0ltbWVkaWF0ZVJlbmRlcmVyKFxuICAgICAgICBjb250ZXh0LCBmcmFtZVN0YXRlLnBpeGVsUmF0aW8sIGZyYW1lU3RhdGUuZXh0ZW50LCB0cmFuc2Zvcm0sXG4gICAgICAgIGZyYW1lU3RhdGUudmlld1N0YXRlLnJvdGF0aW9uKTtcbiAgICAgIHZhciBjb21wb3NlRXZlbnQgPSBuZXcgUmVuZGVyRXZlbnQodHlwZSwgcmVuZGVyLCBmcmFtZVN0YXRlLFxuICAgICAgICBjb250ZXh0LCBudWxsKTtcbiAgICAgIGxheWVyLmRpc3BhdGNoRXZlbnQoY29tcG9zZUV2ZW50KTtcbiAgICAgIHJvdGF0ZUF0T2Zmc2V0KGNvbnRleHQsIHJvdGF0aW9uLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9QbHVnZ2FibGVNYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZVN0YXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaGl0VG9sZXJhbmNlIEhpdCB0b2xlcmFuY2UgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6IFMsIGltcG9ydChcIi4uLy4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHQsIChVaW50OENsYW1wZWRBcnJheXxVaW50OEFycmF5KSk6IFR9IGNhbGxiYWNrIExheWVyXG4gICAqICAgICBjYWxsYmFjay5cbiAgICogQHBhcmFtIHtTfSB0aGlzQXJnIFZhbHVlIHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgYGNhbGxiYWNrYC5cbiAgICogQHJldHVybiB7VHx1bmRlZmluZWR9IENhbGxiYWNrIHJlc3VsdC5cbiAgICogQHRlbXBsYXRlIFMsVCxVXG4gICAqL1xuICBDYW52YXNMYXllclJlbmRlcmVyLnByb3RvdHlwZS5mb3JFYWNoTGF5ZXJBdENvb3JkaW5hdGUgPSBmdW5jdGlvbiBmb3JFYWNoTGF5ZXJBdENvb3JkaW5hdGUgKGNvb3JkaW5hdGUsIGZyYW1lU3RhdGUsIGhpdFRvbGVyYW5jZSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICB2YXIgaGFzRmVhdHVyZSA9IHRoaXMuZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGUoY29vcmRpbmF0ZSwgZnJhbWVTdGF0ZSwgaGl0VG9sZXJhbmNlLCBUUlVFKTtcblxuICAgIGlmIChoYXNGZWF0dXJlKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzLmdldExheWVyKCksIG51bGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9QbHVnZ2FibGVNYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9sYXllci9MYXllci5qc1wiKS5TdGF0ZX0gbGF5ZXJTdGF0ZSBMYXllciBzdGF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtPX0gb3B0X3RyYW5zZm9ybSBUcmFuc2Zvcm0uXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIENhbnZhc0xheWVyUmVuZGVyZXIucHJvdG90eXBlLnBvc3RDb21wb3NlID0gZnVuY3Rpb24gcG9zdENvbXBvc2UgKGNvbnRleHQsIGZyYW1lU3RhdGUsIGxheWVyU3RhdGUsIG9wdF90cmFuc2Zvcm0pIHtcbiAgICB0aGlzLmRpc3BhdGNoQ29tcG9zZUV2ZW50XyhSZW5kZXJFdmVudFR5cGUuUE9TVENPTVBPU0UsIGNvbnRleHQsIGZyYW1lU3RhdGUsIG9wdF90cmFuc2Zvcm0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBDb250ZXh0LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL1BsdWdnYWJsZU1hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm09fSBvcHRfdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgQ2FudmFzTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUucHJlQ29tcG9zZSA9IGZ1bmN0aW9uIHByZUNvbXBvc2UgKGNvbnRleHQsIGZyYW1lU3RhdGUsIG9wdF90cmFuc2Zvcm0pIHtcbiAgICB0aGlzLmRpc3BhdGNoQ29tcG9zZUV2ZW50XyhSZW5kZXJFdmVudFR5cGUuUFJFQ09NUE9TRSwgY29udGV4dCwgZnJhbWVTdGF0ZSwgb3B0X3RyYW5zZm9ybSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IENvbnRleHQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybT19IG9wdF90cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBDYW52YXNMYXllclJlbmRlcmVyLnByb3RvdHlwZS5kaXNwYXRjaFJlbmRlckV2ZW50ID0gZnVuY3Rpb24gZGlzcGF0Y2hSZW5kZXJFdmVudCAoY29udGV4dCwgZnJhbWVTdGF0ZSwgb3B0X3RyYW5zZm9ybSkge1xuICAgIHRoaXMuZGlzcGF0Y2hDb21wb3NlRXZlbnRfKFJlbmRlckV2ZW50VHlwZS5SRU5ERVIsIGNvbnRleHQsIGZyYW1lU3RhdGUsIG9wdF90cmFuc2Zvcm0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL1BsdWdnYWJsZU1hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WCBPZmZzZXQgb24gdGhlIHgtYXhpcyBpbiB2aWV3IGNvb3JkaW5hdGVzLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4geyFpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfSBUcmFuc2Zvcm0uXG4gICAqL1xuICBDYW52YXNMYXllclJlbmRlcmVyLnByb3RvdHlwZS5nZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiBnZXRUcmFuc2Zvcm0gKGZyYW1lU3RhdGUsIG9mZnNldFgpIHtcbiAgICB2YXIgdmlld1N0YXRlID0gZnJhbWVTdGF0ZS52aWV3U3RhdGU7XG4gICAgdmFyIHBpeGVsUmF0aW8gPSBmcmFtZVN0YXRlLnBpeGVsUmF0aW87XG4gICAgdmFyIGR4MSA9IHBpeGVsUmF0aW8gKiBmcmFtZVN0YXRlLnNpemVbMF0gLyAyO1xuICAgIHZhciBkeTEgPSBwaXhlbFJhdGlvICogZnJhbWVTdGF0ZS5zaXplWzFdIC8gMjtcbiAgICB2YXIgc3ggPSBwaXhlbFJhdGlvIC8gdmlld1N0YXRlLnJlc29sdXRpb247XG4gICAgdmFyIHN5ID0gLXN4O1xuICAgIHZhciBhbmdsZSA9IC12aWV3U3RhdGUucm90YXRpb247XG4gICAgdmFyIGR4MiA9IC12aWV3U3RhdGUuY2VudGVyWzBdICsgb2Zmc2V0WDtcbiAgICB2YXIgZHkyID0gLXZpZXdTdGF0ZS5jZW50ZXJbMV07XG4gICAgcmV0dXJuIGNvbXBvc2VUcmFuc2Zvcm0odGhpcy50cmFuc2Zvcm1fLCBkeDEsIGR5MSwgc3gsIHN5LCBhbmdsZSwgZHgyLCBkeTIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9QbHVnZ2FibGVNYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9sYXllci9MYXllci5qc1wiKS5TdGF0ZX0gbGF5ZXJTdGF0ZSBMYXllciBzdGF0ZS5cbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAgICovXG4gIENhbnZhc0xheWVyUmVuZGVyZXIucHJvdG90eXBlLmNvbXBvc2VGcmFtZSA9IGZ1bmN0aW9uIGNvbXBvc2VGcmFtZSAoZnJhbWVTdGF0ZSwgbGF5ZXJTdGF0ZSwgY29udGV4dCkge1xuICAgIGFic3RyYWN0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL1BsdWdnYWJsZU1hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2xheWVyL0xheWVyLmpzXCIpLlN0YXRlfSBsYXllclN0YXRlIExheWVyIHN0YXRlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSB3aGV0aGVyIGNvbXBvc2VGcmFtZSBzaG91bGQgYmUgY2FsbGVkLlxuICAgKi9cbiAgQ2FudmFzTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUucHJlcGFyZUZyYW1lID0gZnVuY3Rpb24gcHJlcGFyZUZyYW1lIChmcmFtZVN0YXRlLCBsYXllclN0YXRlKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH07XG5cbiAgcmV0dXJuIENhbnZhc0xheWVyUmVuZGVyZXI7XG59KExheWVyUmVuZGVyZXIpKTtcblxuZXhwb3J0IGRlZmF1bHQgQ2FudmFzTGF5ZXJSZW5kZXJlcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGF5ZXIuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlcmVyL2NhbnZhcy9NYXBcbiAqL1xuaW1wb3J0IHtjcmVhdGUgYXMgY3JlYXRlVHJhbnNmb3JtLCBhcHBseSBhcyBhcHBseVRyYW5zZm9ybSwgY29tcG9zZSBhcyBjb21wb3NlVHJhbnNmb3JtfSBmcm9tICcuLi8uLi90cmFuc2Zvcm0uanMnO1xuaW1wb3J0IHtpbmNsdWRlcywgc3RhYmxlU29ydH0gZnJvbSAnLi4vLi4vYXJyYXkuanMnO1xuaW1wb3J0IHtDTEFTU19VTlNFTEVDVEFCTEV9IGZyb20gJy4uLy4uL2Nzcy5qcyc7XG5pbXBvcnQge2NyZWF0ZUNhbnZhc0NvbnRleHQyRH0gZnJvbSAnLi4vLi4vZG9tLmpzJztcbmltcG9ydCB7dmlzaWJsZUF0UmVzb2x1dGlvbn0gZnJvbSAnLi4vLi4vbGF5ZXIvTGF5ZXIuanMnO1xuaW1wb3J0IFJlbmRlckV2ZW50IGZyb20gJy4uLy4uL3JlbmRlci9FdmVudC5qcyc7XG5pbXBvcnQgUmVuZGVyRXZlbnRUeXBlIGZyb20gJy4uLy4uL3JlbmRlci9FdmVudFR5cGUuanMnO1xuaW1wb3J0IHtyb3RhdGVBdE9mZnNldH0gZnJvbSAnLi4vLi4vcmVuZGVyL2NhbnZhcy5qcyc7XG5pbXBvcnQgQ2FudmFzSW1tZWRpYXRlUmVuZGVyZXIgZnJvbSAnLi4vLi4vcmVuZGVyL2NhbnZhcy9JbW1lZGlhdGUuanMnO1xuaW1wb3J0IE1hcFJlbmRlcmVyLCB7c29ydEJ5WkluZGV4fSBmcm9tICcuLi9NYXAuanMnO1xuaW1wb3J0IFNvdXJjZVN0YXRlIGZyb20gJy4uLy4uL3NvdXJjZS9TdGF0ZS5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZSB7QXJyYXk8dHlwZW9mIGltcG9ydChcIi4uL0xheWVyLmpzXCIpLmRlZmF1bHQ+fVxuICovXG5leHBvcnQgdmFyIGxheWVyUmVuZGVyZXJDb25zdHJ1Y3RvcnMgPSBbXTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBDYW52YXMgbWFwIHJlbmRlcmVyLlxuICogQGFwaVxuICovXG52YXIgQ2FudmFzTWFwUmVuZGVyZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChNYXBSZW5kZXJlcikge1xuICBmdW5jdGlvbiBDYW52YXNNYXBSZW5kZXJlcihtYXApIHtcbiAgICBNYXBSZW5kZXJlci5jYWxsKHRoaXMsIG1hcCk7XG5cbiAgICB2YXIgY29udGFpbmVyID0gbWFwLmdldFZpZXdwb3J0KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gICAgICovXG4gICAgdGhpcy5jb250ZXh0XyA9IGNyZWF0ZUNhbnZhc0NvbnRleHQyRCgpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5jYW52YXNfID0gdGhpcy5jb250ZXh0Xy5jYW52YXM7XG5cbiAgICB0aGlzLmNhbnZhc18uc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgdGhpcy5jYW52YXNfLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICB0aGlzLmNhbnZhc18uc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgdGhpcy5jYW52YXNfLmNsYXNzTmFtZSA9IENMQVNTX1VOU0VMRUNUQUJMRTtcbiAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKHRoaXMuY2FudmFzXywgY29udGFpbmVyLmNoaWxkTm9kZXNbMF0gfHwgbnVsbCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZWRWaXNpYmxlXyA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfVxuICAgICAqL1xuICAgIHRoaXMudHJhbnNmb3JtXyA9IGNyZWF0ZVRyYW5zZm9ybSgpO1xuXG4gIH1cblxuICBpZiAoIE1hcFJlbmRlcmVyICkgQ2FudmFzTWFwUmVuZGVyZXIuX19wcm90b19fID0gTWFwUmVuZGVyZXI7XG4gIENhbnZhc01hcFJlbmRlcmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1hcFJlbmRlcmVyICYmIE1hcFJlbmRlcmVyLnByb3RvdHlwZSApO1xuICBDYW52YXNNYXBSZW5kZXJlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYW52YXNNYXBSZW5kZXJlcjtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9yZW5kZXIvRXZlbnRUeXBlLmpzXCIpLmRlZmF1bHR9IHR5cGUgRXZlbnQgdHlwZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9QbHVnZ2FibGVNYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICovXG4gIENhbnZhc01hcFJlbmRlcmVyLnByb3RvdHlwZS5kaXNwYXRjaFJlbmRlckV2ZW50ID0gZnVuY3Rpb24gZGlzcGF0Y2hSZW5kZXJFdmVudCAodHlwZSwgZnJhbWVTdGF0ZSkge1xuICAgIHZhciBtYXAgPSB0aGlzLmdldE1hcCgpO1xuICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0XztcbiAgICBpZiAobWFwLmhhc0xpc3RlbmVyKHR5cGUpKSB7XG4gICAgICB2YXIgZXh0ZW50ID0gZnJhbWVTdGF0ZS5leHRlbnQ7XG4gICAgICB2YXIgcGl4ZWxSYXRpbyA9IGZyYW1lU3RhdGUucGl4ZWxSYXRpbztcbiAgICAgIHZhciB2aWV3U3RhdGUgPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZTtcbiAgICAgIHZhciByb3RhdGlvbiA9IHZpZXdTdGF0ZS5yb3RhdGlvbjtcblxuICAgICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMuZ2V0VHJhbnNmb3JtKGZyYW1lU3RhdGUpO1xuXG4gICAgICB2YXIgdmVjdG9yQ29udGV4dCA9IG5ldyBDYW52YXNJbW1lZGlhdGVSZW5kZXJlcihjb250ZXh0LCBwaXhlbFJhdGlvLFxuICAgICAgICBleHRlbnQsIHRyYW5zZm9ybSwgcm90YXRpb24pO1xuICAgICAgdmFyIGNvbXBvc2VFdmVudCA9IG5ldyBSZW5kZXJFdmVudCh0eXBlLCB2ZWN0b3JDb250ZXh0LFxuICAgICAgICBmcmFtZVN0YXRlLCBjb250ZXh0LCBudWxsKTtcbiAgICAgIG1hcC5kaXNwYXRjaEV2ZW50KGNvbXBvc2VFdmVudCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL1BsdWdnYWJsZU1hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4geyFpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfSBUcmFuc2Zvcm0uXG4gICAqL1xuICBDYW52YXNNYXBSZW5kZXJlci5wcm90b3R5cGUuZ2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gZ2V0VHJhbnNmb3JtIChmcmFtZVN0YXRlKSB7XG4gICAgdmFyIHZpZXdTdGF0ZSA9IGZyYW1lU3RhdGUudmlld1N0YXRlO1xuICAgIHZhciBkeDEgPSB0aGlzLmNhbnZhc18ud2lkdGggLyAyO1xuICAgIHZhciBkeTEgPSB0aGlzLmNhbnZhc18uaGVpZ2h0IC8gMjtcbiAgICB2YXIgc3ggPSBmcmFtZVN0YXRlLnBpeGVsUmF0aW8gLyB2aWV3U3RhdGUucmVzb2x1dGlvbjtcbiAgICB2YXIgc3kgPSAtc3g7XG4gICAgdmFyIGFuZ2xlID0gLXZpZXdTdGF0ZS5yb3RhdGlvbjtcbiAgICB2YXIgZHgyID0gLXZpZXdTdGF0ZS5jZW50ZXJbMF07XG4gICAgdmFyIGR5MiA9IC12aWV3U3RhdGUuY2VudGVyWzFdO1xuICAgIHJldHVybiBjb21wb3NlVHJhbnNmb3JtKHRoaXMudHJhbnNmb3JtXywgZHgxLCBkeTEsIHN4LCBzeSwgYW5nbGUsIGR4MiwgZHkyKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENhbnZhc01hcFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uIHJlbmRlckZyYW1lIChmcmFtZVN0YXRlKSB7XG5cbiAgICBpZiAoIWZyYW1lU3RhdGUpIHtcbiAgICAgIGlmICh0aGlzLnJlbmRlcmVkVmlzaWJsZV8pIHtcbiAgICAgICAgdGhpcy5jYW52YXNfLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMucmVuZGVyZWRWaXNpYmxlXyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0XztcbiAgICB2YXIgcGl4ZWxSYXRpbyA9IGZyYW1lU3RhdGUucGl4ZWxSYXRpbztcbiAgICB2YXIgd2lkdGggPSBNYXRoLnJvdW5kKGZyYW1lU3RhdGUuc2l6ZVswXSAqIHBpeGVsUmF0aW8pO1xuICAgIHZhciBoZWlnaHQgPSBNYXRoLnJvdW5kKGZyYW1lU3RhdGUuc2l6ZVsxXSAqIHBpeGVsUmF0aW8pO1xuICAgIGlmICh0aGlzLmNhbnZhc18ud2lkdGggIT0gd2lkdGggfHwgdGhpcy5jYW52YXNfLmhlaWdodCAhPSBoZWlnaHQpIHtcbiAgICAgIHRoaXMuY2FudmFzXy53aWR0aCA9IHdpZHRoO1xuICAgICAgdGhpcy5jYW52YXNfLmhlaWdodCA9IGhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgfVxuXG4gICAgdmFyIHJvdGF0aW9uID0gZnJhbWVTdGF0ZS52aWV3U3RhdGUucm90YXRpb247XG5cbiAgICB0aGlzLmNhbGN1bGF0ZU1hdHJpY2VzMkQoZnJhbWVTdGF0ZSk7XG5cbiAgICB0aGlzLmRpc3BhdGNoUmVuZGVyRXZlbnQoUmVuZGVyRXZlbnRUeXBlLlBSRUNPTVBPU0UsIGZyYW1lU3RhdGUpO1xuXG4gICAgdmFyIGxheWVyU3RhdGVzQXJyYXkgPSBmcmFtZVN0YXRlLmxheWVyU3RhdGVzQXJyYXk7XG4gICAgc3RhYmxlU29ydChsYXllclN0YXRlc0FycmF5LCBzb3J0QnlaSW5kZXgpO1xuXG4gICAgaWYgKHJvdGF0aW9uKSB7XG4gICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgIHJvdGF0ZUF0T2Zmc2V0KGNvbnRleHQsIHJvdGF0aW9uLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICAgIH1cblxuICAgIHZhciB2aWV3UmVzb2x1dGlvbiA9IGZyYW1lU3RhdGUudmlld1N0YXRlLnJlc29sdXRpb247XG4gICAgdmFyIGksIGlpO1xuICAgIGZvciAoaSA9IDAsIGlpID0gbGF5ZXJTdGF0ZXNBcnJheS5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB2YXIgbGF5ZXJTdGF0ZSA9IGxheWVyU3RhdGVzQXJyYXlbaV07XG4gICAgICB2YXIgbGF5ZXIgPSBsYXllclN0YXRlLmxheWVyO1xuICAgICAgdmFyIGxheWVyUmVuZGVyZXIgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vTGF5ZXIuanNcIikuZGVmYXVsdH0gKi8gKHRoaXMuZ2V0TGF5ZXJSZW5kZXJlcihsYXllcikpO1xuICAgICAgaWYgKCF2aXNpYmxlQXRSZXNvbHV0aW9uKGxheWVyU3RhdGUsIHZpZXdSZXNvbHV0aW9uKSB8fFxuICAgICAgICAgIGxheWVyU3RhdGUuc291cmNlU3RhdGUgIT0gU291cmNlU3RhdGUuUkVBRFkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAobGF5ZXJSZW5kZXJlci5wcmVwYXJlRnJhbWUoZnJhbWVTdGF0ZSwgbGF5ZXJTdGF0ZSkpIHtcbiAgICAgICAgbGF5ZXJSZW5kZXJlci5jb21wb3NlRnJhbWUoZnJhbWVTdGF0ZSwgbGF5ZXJTdGF0ZSwgY29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJvdGF0aW9uKSB7XG4gICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoUmVuZGVyRXZlbnQoUmVuZGVyRXZlbnRUeXBlLlBPU1RDT01QT1NFLCBmcmFtZVN0YXRlKTtcblxuICAgIGlmICghdGhpcy5yZW5kZXJlZFZpc2libGVfKSB7XG4gICAgICB0aGlzLmNhbnZhc18uc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgICAgdGhpcy5yZW5kZXJlZFZpc2libGVfID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLnNjaGVkdWxlUmVtb3ZlVW51c2VkTGF5ZXJSZW5kZXJlcnMoZnJhbWVTdGF0ZSk7XG4gICAgdGhpcy5zY2hlZHVsZUV4cGlyZUljb25DYWNoZShmcmFtZVN0YXRlKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENhbnZhc01hcFJlbmRlcmVyLnByb3RvdHlwZS5mb3JFYWNoTGF5ZXJBdFBpeGVsID0gZnVuY3Rpb24gZm9yRWFjaExheWVyQXRQaXhlbCAocGl4ZWwsIGZyYW1lU3RhdGUsIGhpdFRvbGVyYW5jZSwgY2FsbGJhY2ssIHRoaXNBcmcsIGxheWVyRmlsdGVyLCB0aGlzQXJnMikge1xuICAgIHZhciByZXN1bHQ7XG4gICAgdmFyIHZpZXdTdGF0ZSA9IGZyYW1lU3RhdGUudmlld1N0YXRlO1xuICAgIHZhciB2aWV3UmVzb2x1dGlvbiA9IHZpZXdTdGF0ZS5yZXNvbHV0aW9uO1xuXG4gICAgdmFyIGxheWVyU3RhdGVzID0gZnJhbWVTdGF0ZS5sYXllclN0YXRlc0FycmF5O1xuICAgIHZhciBudW1MYXllcnMgPSBsYXllclN0YXRlcy5sZW5ndGg7XG5cbiAgICB2YXIgY29vcmRpbmF0ZSA9IGFwcGx5VHJhbnNmb3JtKFxuICAgICAgZnJhbWVTdGF0ZS5waXhlbFRvQ29vcmRpbmF0ZVRyYW5zZm9ybSwgcGl4ZWwuc2xpY2UoKSk7XG5cbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgPSBudW1MYXllcnMgLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdmFyIGxheWVyU3RhdGUgPSBsYXllclN0YXRlc1tpXTtcbiAgICAgIHZhciBsYXllciA9IGxheWVyU3RhdGUubGF5ZXI7XG4gICAgICBpZiAodmlzaWJsZUF0UmVzb2x1dGlvbihsYXllclN0YXRlLCB2aWV3UmVzb2x1dGlvbikgJiYgbGF5ZXJGaWx0ZXIuY2FsbCh0aGlzQXJnMiwgbGF5ZXIpKSB7XG4gICAgICAgIHZhciBsYXllclJlbmRlcmVyID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL0xheWVyLmpzXCIpLmRlZmF1bHR9ICovICh0aGlzLmdldExheWVyUmVuZGVyZXIobGF5ZXIpKTtcbiAgICAgICAgcmVzdWx0ID0gbGF5ZXJSZW5kZXJlci5mb3JFYWNoTGF5ZXJBdENvb3JkaW5hdGUoXG4gICAgICAgICAgY29vcmRpbmF0ZSwgZnJhbWVTdGF0ZSwgaGl0VG9sZXJhbmNlLCBjYWxsYmFjaywgdGhpc0FyZyk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNNYXBSZW5kZXJlci5wcm90b3R5cGUucmVnaXN0ZXJMYXllclJlbmRlcmVycyA9IGZ1bmN0aW9uIHJlZ2lzdGVyTGF5ZXJSZW5kZXJlcnMgKGNvbnN0cnVjdG9ycykge1xuICAgIE1hcFJlbmRlcmVyLnByb3RvdHlwZS5yZWdpc3RlckxheWVyUmVuZGVyZXJzLmNhbGwodGhpcywgY29uc3RydWN0b3JzKTtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBjb25zdHJ1Y3RvcnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgdmFyIGN0b3IgPSBjb25zdHJ1Y3RvcnNbaV07XG4gICAgICBpZiAoIWluY2x1ZGVzKGxheWVyUmVuZGVyZXJDb25zdHJ1Y3RvcnMsIGN0b3IpKSB7XG4gICAgICAgIGxheWVyUmVuZGVyZXJDb25zdHJ1Y3RvcnMucHVzaChjdG9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIENhbnZhc01hcFJlbmRlcmVyO1xufShNYXBSZW5kZXJlcikpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IENhbnZhc01hcFJlbmRlcmVyO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXAuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlcmVyL2NhbnZhcy9UaWxlTGF5ZXJcbiAqL1xuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4uLy4uL3V0aWwuanMnO1xuaW1wb3J0IExheWVyVHlwZSBmcm9tICcuLi8uLi9MYXllclR5cGUuanMnO1xuaW1wb3J0IFRpbGVSYW5nZSBmcm9tICcuLi8uLi9UaWxlUmFuZ2UuanMnO1xuaW1wb3J0IFRpbGVTdGF0ZSBmcm9tICcuLi8uLi9UaWxlU3RhdGUuanMnO1xuaW1wb3J0IFZpZXdIaW50IGZyb20gJy4uLy4uL1ZpZXdIaW50LmpzJztcbmltcG9ydCB7Y3JlYXRlQ2FudmFzQ29udGV4dDJEfSBmcm9tICcuLi8uLi9kb20uanMnO1xuaW1wb3J0IHtjb250YWluc0V4dGVudCwgY3JlYXRlRW1wdHksIGVxdWFscywgZ2V0SW50ZXJzZWN0aW9uLCBpc0VtcHR5fSBmcm9tICcuLi8uLi9leHRlbnQuanMnO1xuaW1wb3J0IEludGVybWVkaWF0ZUNhbnZhc1JlbmRlcmVyIGZyb20gJy4vSW50ZXJtZWRpYXRlQ2FudmFzLmpzJztcbmltcG9ydCB7Y3JlYXRlIGFzIGNyZWF0ZVRyYW5zZm9ybSwgY29tcG9zZSBhcyBjb21wb3NlVHJhbnNmb3JtfSBmcm9tICcuLi8uLi90cmFuc2Zvcm0uanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIENhbnZhcyByZW5kZXJlciBmb3IgdGlsZSBsYXllcnMuXG4gKiBAYXBpXG4gKi9cbnZhciBDYW52YXNUaWxlTGF5ZXJSZW5kZXJlciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEludGVybWVkaWF0ZUNhbnZhc1JlbmRlcmVyKSB7XG4gIGZ1bmN0aW9uIENhbnZhc1RpbGVMYXllclJlbmRlcmVyKHRpbGVMYXllciwgb3B0X25vQ29udGV4dCkge1xuXG4gICAgSW50ZXJtZWRpYXRlQ2FudmFzUmVuZGVyZXIuY2FsbCh0aGlzLCB0aWxlTGF5ZXIpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gICAgICovXG4gICAgdGhpcy5jb250ZXh0ID0gb3B0X25vQ29udGV4dCA/IG51bGwgOiBjcmVhdGVDYW52YXNDb250ZXh0MkQoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm92ZXJzYW1wbGluZ187XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZWRFeHRlbnRfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZWRSZXZpc2lvbjtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7IUFycmF5PGltcG9ydChcIi4uLy4uL1RpbGUuanNcIikuZGVmYXVsdD59XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZFRpbGVzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMubmV3VGlsZXNfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gICAgICovXG4gICAgdGhpcy50bXBFeHRlbnQgPSBjcmVhdGVFbXB0eSgpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy50bXBUaWxlUmFuZ2VfID0gbmV3IFRpbGVSYW5nZSgwLCAwLCAwLCAwKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uLy4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19XG4gICAgICovXG4gICAgdGhpcy5pbWFnZVRyYW5zZm9ybV8gPSBjcmVhdGVUcmFuc2Zvcm0oKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuekRpcmVjdGlvbiA9IDA7XG5cbiAgfVxuXG4gIGlmICggSW50ZXJtZWRpYXRlQ2FudmFzUmVuZGVyZXIgKSBDYW52YXNUaWxlTGF5ZXJSZW5kZXJlci5fX3Byb3RvX18gPSBJbnRlcm1lZGlhdGVDYW52YXNSZW5kZXJlcjtcbiAgQ2FudmFzVGlsZUxheWVyUmVuZGVyZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSW50ZXJtZWRpYXRlQ2FudmFzUmVuZGVyZXIgJiYgSW50ZXJtZWRpYXRlQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlICk7XG4gIENhbnZhc1RpbGVMYXllclJlbmRlcmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhbnZhc1RpbGVMYXllclJlbmRlcmVyO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL1RpbGUuanNcIikuZGVmYXVsdH0gdGlsZSBUaWxlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaWxlIGlzIGRyYXdhYmxlLlxuICAgKi9cbiAgQ2FudmFzVGlsZUxheWVyUmVuZGVyZXIucHJvdG90eXBlLmlzRHJhd2FibGVUaWxlXyA9IGZ1bmN0aW9uIGlzRHJhd2FibGVUaWxlXyAodGlsZSkge1xuICAgIHZhciB0aWxlTGF5ZXIgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2xheWVyL1RpbGUuanNcIikuZGVmYXVsdH0gKi8gKHRoaXMuZ2V0TGF5ZXIoKSk7XG4gICAgdmFyIHRpbGVTdGF0ZSA9IHRpbGUuZ2V0U3RhdGUoKTtcbiAgICB2YXIgdXNlSW50ZXJpbVRpbGVzT25FcnJvciA9IHRpbGVMYXllci5nZXRVc2VJbnRlcmltVGlsZXNPbkVycm9yKCk7XG4gICAgcmV0dXJuIHRpbGVTdGF0ZSA9PSBUaWxlU3RhdGUuTE9BREVEIHx8XG4gICAgICAgIHRpbGVTdGF0ZSA9PSBUaWxlU3RhdGUuRU1QVFkgfHxcbiAgICAgICAgdGlsZVN0YXRlID09IFRpbGVTdGF0ZS5FUlJPUiAmJiAhdXNlSW50ZXJpbVRpbGVzT25FcnJvcjtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHogVGlsZSBjb29yZGluYXRlIHouXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFRpbGUgY29vcmRpbmF0ZSB4LlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBUaWxlIGNvb3JkaW5hdGUgeS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7IWltcG9ydChcIi4uLy4uL1RpbGUuanNcIikuZGVmYXVsdH0gVGlsZS5cbiAgICovXG4gIENhbnZhc1RpbGVMYXllclJlbmRlcmVyLnByb3RvdHlwZS5nZXRUaWxlID0gZnVuY3Rpb24gZ2V0VGlsZSAoeiwgeCwgeSwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbikge1xuICAgIHZhciB0aWxlTGF5ZXIgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2xheWVyL1RpbGUuanNcIikuZGVmYXVsdH0gKi8gKHRoaXMuZ2V0TGF5ZXIoKSk7XG4gICAgdmFyIHRpbGVTb3VyY2UgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL3NvdXJjZS9UaWxlLmpzXCIpLmRlZmF1bHR9ICovICh0aWxlTGF5ZXIuZ2V0U291cmNlKCkpO1xuICAgIHZhciB0aWxlID0gdGlsZVNvdXJjZS5nZXRUaWxlKHosIHgsIHksIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pO1xuICAgIGlmICh0aWxlLmdldFN0YXRlKCkgPT0gVGlsZVN0YXRlLkVSUk9SKSB7XG4gICAgICBpZiAoIXRpbGVMYXllci5nZXRVc2VJbnRlcmltVGlsZXNPbkVycm9yKCkpIHtcbiAgICAgICAgLy8gV2hlbiB1c2VJbnRlcmltVGlsZXNPbkVycm9yIGlzIGZhbHNlLCB3ZSBjb25zaWRlciB0aGUgZXJyb3IgdGlsZSBhcyBsb2FkZWQuXG4gICAgICAgIHRpbGUuc2V0U3RhdGUoVGlsZVN0YXRlLkxPQURFRCk7XG4gICAgICB9IGVsc2UgaWYgKHRpbGVMYXllci5nZXRQcmVsb2FkKCkgPiAwKSB7XG4gICAgICAgIC8vIFByZWxvYWRlZCB0aWxlcyBmb3IgbG93ZXIgcmVzb2x1dGlvbnMgbWlnaHQgaGF2ZSBmaW5pc2hlZCBsb2FkaW5nLlxuICAgICAgICB0aGlzLm5ld1RpbGVzXyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5pc0RyYXdhYmxlVGlsZV8odGlsZSkpIHtcbiAgICAgIHRpbGUgPSB0aWxlLmdldEludGVyaW1UaWxlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aWxlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQ2FudmFzVGlsZUxheWVyUmVuZGVyZXIucHJvdG90eXBlLnByZXBhcmVGcmFtZSA9IGZ1bmN0aW9uIHByZXBhcmVGcmFtZSAoZnJhbWVTdGF0ZSwgbGF5ZXJTdGF0ZSkge1xuXG4gICAgdmFyIHBpeGVsUmF0aW8gPSBmcmFtZVN0YXRlLnBpeGVsUmF0aW87XG4gICAgdmFyIHNpemUgPSBmcmFtZVN0YXRlLnNpemU7XG4gICAgdmFyIHZpZXdTdGF0ZSA9IGZyYW1lU3RhdGUudmlld1N0YXRlO1xuICAgIHZhciBwcm9qZWN0aW9uID0gdmlld1N0YXRlLnByb2plY3Rpb247XG4gICAgdmFyIHZpZXdSZXNvbHV0aW9uID0gdmlld1N0YXRlLnJlc29sdXRpb247XG4gICAgdmFyIHZpZXdDZW50ZXIgPSB2aWV3U3RhdGUuY2VudGVyO1xuXG4gICAgdmFyIHRpbGVMYXllciA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vbGF5ZXIvVGlsZS5qc1wiKS5kZWZhdWx0fSAqLyAodGhpcy5nZXRMYXllcigpKTtcbiAgICB2YXIgdGlsZVNvdXJjZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vc291cmNlL1RpbGUuanNcIikuZGVmYXVsdH0gKi8gKHRpbGVMYXllci5nZXRTb3VyY2UoKSk7XG4gICAgdmFyIHNvdXJjZVJldmlzaW9uID0gdGlsZVNvdXJjZS5nZXRSZXZpc2lvbigpO1xuICAgIHZhciB0aWxlR3JpZCA9IHRpbGVTb3VyY2UuZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICAgIHZhciB6ID0gdGlsZUdyaWQuZ2V0WkZvclJlc29sdXRpb24odmlld1Jlc29sdXRpb24sIHRoaXMuekRpcmVjdGlvbik7XG4gICAgdmFyIHRpbGVSZXNvbHV0aW9uID0gdGlsZUdyaWQuZ2V0UmVzb2x1dGlvbih6KTtcbiAgICB2YXIgb3ZlcnNhbXBsaW5nID0gTWF0aC5yb3VuZCh2aWV3UmVzb2x1dGlvbiAvIHRpbGVSZXNvbHV0aW9uKSB8fCAxO1xuICAgIHZhciBleHRlbnQgPSBmcmFtZVN0YXRlLmV4dGVudDtcblxuICAgIGlmIChsYXllclN0YXRlLmV4dGVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBleHRlbnQgPSBnZXRJbnRlcnNlY3Rpb24oZXh0ZW50LCBsYXllclN0YXRlLmV4dGVudCk7XG4gICAgfVxuICAgIGlmIChpc0VtcHR5KGV4dGVudCkpIHtcbiAgICAgIC8vIFJldHVybiBmYWxzZSB0byBwcmV2ZW50IHRoZSByZW5kZXJpbmcgb2YgdGhlIGxheWVyLlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciB0aWxlUmFuZ2UgPSB0aWxlR3JpZC5nZXRUaWxlUmFuZ2VGb3JFeHRlbnRBbmRaKGV4dGVudCwgeik7XG4gICAgdmFyIGltYWdlRXh0ZW50ID0gdGlsZUdyaWQuZ2V0VGlsZVJhbmdlRXh0ZW50KHosIHRpbGVSYW5nZSk7XG5cbiAgICB2YXIgdGlsZVBpeGVsUmF0aW8gPSB0aWxlU291cmNlLmdldFRpbGVQaXhlbFJhdGlvKHBpeGVsUmF0aW8pO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge09iamVjdDxudW1iZXIsIE9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uLy4uL1RpbGUuanNcIikuZGVmYXVsdD4+fVxuICAgICAqL1xuICAgIHZhciB0aWxlc1RvRHJhd0J5WiA9IHt9O1xuICAgIHRpbGVzVG9EcmF3QnlaW3pdID0ge307XG5cbiAgICB2YXIgZmluZExvYWRlZFRpbGVzID0gdGhpcy5jcmVhdGVMb2FkZWRUaWxlRmluZGVyKFxuICAgICAgdGlsZVNvdXJjZSwgcHJvamVjdGlvbiwgdGlsZXNUb0RyYXdCeVopO1xuXG4gICAgdmFyIGhpbnRzID0gZnJhbWVTdGF0ZS52aWV3SGludHM7XG4gICAgdmFyIGFuaW1hdGluZ09ySW50ZXJhY3RpbmcgPSBoaW50c1tWaWV3SGludC5BTklNQVRJTkddIHx8IGhpbnRzW1ZpZXdIaW50LklOVEVSQUNUSU5HXTtcblxuICAgIHZhciB0bXBFeHRlbnQgPSB0aGlzLnRtcEV4dGVudDtcbiAgICB2YXIgdG1wVGlsZVJhbmdlID0gdGhpcy50bXBUaWxlUmFuZ2VfO1xuICAgIHRoaXMubmV3VGlsZXNfID0gZmFsc2U7XG4gICAgdmFyIHRpbGUsIHgsIHk7XG4gICAgZm9yICh4ID0gdGlsZVJhbmdlLm1pblg7IHggPD0gdGlsZVJhbmdlLm1heFg7ICsreCkge1xuICAgICAgZm9yICh5ID0gdGlsZVJhbmdlLm1pblk7IHkgPD0gdGlsZVJhbmdlLm1heFk7ICsreSkge1xuICAgICAgICBpZiAoRGF0ZS5ub3coKSAtIGZyYW1lU3RhdGUudGltZSA+IDE2ICYmIGFuaW1hdGluZ09ySW50ZXJhY3RpbmcpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aWxlID0gdGhpcy5nZXRUaWxlKHosIHgsIHksIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pO1xuICAgICAgICBpZiAodGhpcy5pc0RyYXdhYmxlVGlsZV8odGlsZSkpIHtcbiAgICAgICAgICB2YXIgdWlkID0gZ2V0VWlkKHRoaXMpO1xuICAgICAgICAgIGlmICh0aWxlLmdldFN0YXRlKCkgPT0gVGlsZVN0YXRlLkxPQURFRCkge1xuICAgICAgICAgICAgdGlsZXNUb0RyYXdCeVpbel1bdGlsZS50aWxlQ29vcmQudG9TdHJpbmcoKV0gPSB0aWxlO1xuICAgICAgICAgICAgdmFyIGluVHJhbnNpdGlvbiA9IHRpbGUuaW5UcmFuc2l0aW9uKHVpZCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMubmV3VGlsZXNfICYmIChpblRyYW5zaXRpb24gfHwgdGhpcy5yZW5kZXJlZFRpbGVzLmluZGV4T2YodGlsZSkgPT09IC0xKSkge1xuICAgICAgICAgICAgICB0aGlzLm5ld1RpbGVzXyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aWxlLmdldEFscGhhKHVpZCwgZnJhbWVTdGF0ZS50aW1lKSA9PT0gMSkge1xuICAgICAgICAgICAgLy8gZG9uJ3QgbG9vayBmb3IgYWx0IHRpbGVzIGlmIGFscGhhIGlzIDFcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGlsZFRpbGVSYW5nZSA9IHRpbGVHcmlkLmdldFRpbGVDb29yZENoaWxkVGlsZVJhbmdlKFxuICAgICAgICAgIHRpbGUudGlsZUNvb3JkLCB0bXBUaWxlUmFuZ2UsIHRtcEV4dGVudCk7XG4gICAgICAgIHZhciBjb3ZlcmVkID0gZmFsc2U7XG4gICAgICAgIGlmIChjaGlsZFRpbGVSYW5nZSkge1xuICAgICAgICAgIGNvdmVyZWQgPSBmaW5kTG9hZGVkVGlsZXMoeiArIDEsIGNoaWxkVGlsZVJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvdmVyZWQpIHtcbiAgICAgICAgICB0aWxlR3JpZC5mb3JFYWNoVGlsZUNvb3JkUGFyZW50VGlsZVJhbmdlKFxuICAgICAgICAgICAgdGlsZS50aWxlQ29vcmQsIGZpbmRMb2FkZWRUaWxlcywgbnVsbCwgdG1wVGlsZVJhbmdlLCB0bXBFeHRlbnQpO1xuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVuZGVyZWRSZXNvbHV0aW9uID0gdGlsZVJlc29sdXRpb24gKiBwaXhlbFJhdGlvIC8gdGlsZVBpeGVsUmF0aW8gKiBvdmVyc2FtcGxpbmc7XG4gICAgaWYgKCEodGhpcy5yZW5kZXJlZFJlc29sdXRpb24gJiYgRGF0ZS5ub3coKSAtIGZyYW1lU3RhdGUudGltZSA+IDE2ICYmIGFuaW1hdGluZ09ySW50ZXJhY3RpbmcpICYmIChcbiAgICAgIHRoaXMubmV3VGlsZXNfIHx8XG4gICAgICAgICAgISh0aGlzLnJlbmRlcmVkRXh0ZW50XyAmJiBjb250YWluc0V4dGVudCh0aGlzLnJlbmRlcmVkRXh0ZW50XywgZXh0ZW50KSkgfHxcbiAgICAgICAgICB0aGlzLnJlbmRlcmVkUmV2aXNpb24gIT0gc291cmNlUmV2aXNpb24gfHxcbiAgICAgICAgICBvdmVyc2FtcGxpbmcgIT0gdGhpcy5vdmVyc2FtcGxpbmdfIHx8XG4gICAgICAgICAgIWFuaW1hdGluZ09ySW50ZXJhY3RpbmcgJiYgcmVuZGVyZWRSZXNvbHV0aW9uICE9IHRoaXMucmVuZGVyZWRSZXNvbHV0aW9uXG4gICAgKSkge1xuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgIHZhciB0aWxlUGl4ZWxTaXplID0gdGlsZVNvdXJjZS5nZXRUaWxlUGl4ZWxTaXplKHosIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pO1xuICAgICAgICB2YXIgd2lkdGggPSBNYXRoLnJvdW5kKHRpbGVSYW5nZS5nZXRXaWR0aCgpICogdGlsZVBpeGVsU2l6ZVswXSAvIG92ZXJzYW1wbGluZyk7XG4gICAgICAgIHZhciBoZWlnaHQgPSBNYXRoLnJvdW5kKHRpbGVSYW5nZS5nZXRIZWlnaHQoKSAqIHRpbGVQaXhlbFNpemVbMV0gLyBvdmVyc2FtcGxpbmcpO1xuICAgICAgICB2YXIgY2FudmFzID0gY29udGV4dC5jYW52YXM7XG4gICAgICAgIGlmIChjYW52YXMud2lkdGggIT0gd2lkdGggfHwgY2FudmFzLmhlaWdodCAhPSBoZWlnaHQpIHtcbiAgICAgICAgICB0aGlzLm92ZXJzYW1wbGluZ18gPSBvdmVyc2FtcGxpbmc7XG4gICAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoKHRoaXMucmVuZGVyZWRFeHRlbnRfICYmICFlcXVhbHMoaW1hZ2VFeHRlbnQsIHRoaXMucmVuZGVyZWRFeHRlbnRfKSkgfHxcbiAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlZFJldmlzaW9uICE9IHNvdXJjZVJldmlzaW9uKSB7XG4gICAgICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3ZlcnNhbXBsaW5nID0gdGhpcy5vdmVyc2FtcGxpbmdfO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVuZGVyZWRUaWxlcy5sZW5ndGggPSAwO1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqL1xuICAgICAgdmFyIHpzID0gT2JqZWN0LmtleXModGlsZXNUb0RyYXdCeVopLm1hcChOdW1iZXIpO1xuICAgICAgenMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIGlmIChhID09PSB6KSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0gZWxzZSBpZiAoYiA9PT0geikge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYSA+IGIgPyAxIDogYSA8IGIgPyAtMSA6IDA7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIGN1cnJlbnRSZXNvbHV0aW9uLCBjdXJyZW50U2NhbGUsIGN1cnJlbnRUaWxlUGl4ZWxTaXplLCBjdXJyZW50WiwgaSwgaWk7XG4gICAgICB2YXIgdGlsZUV4dGVudCwgdGlsZUd1dHRlciwgdGlsZXNUb0RyYXcsIHcsIGg7XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IHpzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgY3VycmVudFogPSB6c1tpXTtcbiAgICAgICAgY3VycmVudFRpbGVQaXhlbFNpemUgPSB0aWxlU291cmNlLmdldFRpbGVQaXhlbFNpemUoY3VycmVudFosIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pO1xuICAgICAgICBjdXJyZW50UmVzb2x1dGlvbiA9IHRpbGVHcmlkLmdldFJlc29sdXRpb24oY3VycmVudFopO1xuICAgICAgICBjdXJyZW50U2NhbGUgPSBjdXJyZW50UmVzb2x1dGlvbiAvIHRpbGVSZXNvbHV0aW9uO1xuICAgICAgICB0aWxlR3V0dGVyID0gdGlsZVBpeGVsUmF0aW8gKiB0aWxlU291cmNlLmdldEd1dHRlckZvclByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gICAgICAgIHRpbGVzVG9EcmF3ID0gdGlsZXNUb0RyYXdCeVpbY3VycmVudFpdO1xuICAgICAgICBmb3IgKHZhciB0aWxlQ29vcmRLZXkgaW4gdGlsZXNUb0RyYXcpIHtcbiAgICAgICAgICB0aWxlID0gdGlsZXNUb0RyYXdbdGlsZUNvb3JkS2V5XTtcbiAgICAgICAgICB0aWxlRXh0ZW50ID0gdGlsZUdyaWQuZ2V0VGlsZUNvb3JkRXh0ZW50KHRpbGUuZ2V0VGlsZUNvb3JkKCksIHRtcEV4dGVudCk7XG4gICAgICAgICAgeCA9ICh0aWxlRXh0ZW50WzBdIC0gaW1hZ2VFeHRlbnRbMF0pIC8gdGlsZVJlc29sdXRpb24gKiB0aWxlUGl4ZWxSYXRpbyAvIG92ZXJzYW1wbGluZztcbiAgICAgICAgICB5ID0gKGltYWdlRXh0ZW50WzNdIC0gdGlsZUV4dGVudFszXSkgLyB0aWxlUmVzb2x1dGlvbiAqIHRpbGVQaXhlbFJhdGlvIC8gb3ZlcnNhbXBsaW5nO1xuICAgICAgICAgIHcgPSBjdXJyZW50VGlsZVBpeGVsU2l6ZVswXSAqIGN1cnJlbnRTY2FsZSAvIG92ZXJzYW1wbGluZztcbiAgICAgICAgICBoID0gY3VycmVudFRpbGVQaXhlbFNpemVbMV0gKiBjdXJyZW50U2NhbGUgLyBvdmVyc2FtcGxpbmc7XG4gICAgICAgICAgdGhpcy5kcmF3VGlsZUltYWdlKHRpbGUsIGZyYW1lU3RhdGUsIGxheWVyU3RhdGUsIHgsIHksIHcsIGgsIHRpbGVHdXR0ZXIsIHogPT09IGN1cnJlbnRaKTtcbiAgICAgICAgICB0aGlzLnJlbmRlcmVkVGlsZXMucHVzaCh0aWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnJlbmRlcmVkUmV2aXNpb24gPSBzb3VyY2VSZXZpc2lvbjtcbiAgICAgIHRoaXMucmVuZGVyZWRSZXNvbHV0aW9uID0gdGlsZVJlc29sdXRpb24gKiBwaXhlbFJhdGlvIC8gdGlsZVBpeGVsUmF0aW8gKiBvdmVyc2FtcGxpbmc7XG4gICAgICB0aGlzLnJlbmRlcmVkRXh0ZW50XyA9IGltYWdlRXh0ZW50O1xuICAgIH1cblxuICAgIHZhciBzY2FsZSA9IHRoaXMucmVuZGVyZWRSZXNvbHV0aW9uIC8gdmlld1Jlc29sdXRpb247XG4gICAgdmFyIHRyYW5zZm9ybSA9IGNvbXBvc2VUcmFuc2Zvcm0odGhpcy5pbWFnZVRyYW5zZm9ybV8sXG4gICAgICBwaXhlbFJhdGlvICogc2l6ZVswXSAvIDIsIHBpeGVsUmF0aW8gKiBzaXplWzFdIC8gMixcbiAgICAgIHNjYWxlLCBzY2FsZSxcbiAgICAgIDAsXG4gICAgICAodGhpcy5yZW5kZXJlZEV4dGVudF9bMF0gLSB2aWV3Q2VudGVyWzBdKSAvIHRoaXMucmVuZGVyZWRSZXNvbHV0aW9uICogcGl4ZWxSYXRpbyxcbiAgICAgICh2aWV3Q2VudGVyWzFdIC0gdGhpcy5yZW5kZXJlZEV4dGVudF9bM10pIC8gdGhpcy5yZW5kZXJlZFJlc29sdXRpb24gKiBwaXhlbFJhdGlvKTtcbiAgICBjb21wb3NlVHJhbnNmb3JtKHRoaXMuY29vcmRpbmF0ZVRvQ2FudmFzUGl4ZWxUcmFuc2Zvcm0sXG4gICAgICBwaXhlbFJhdGlvICogc2l6ZVswXSAvIDIgLSB0cmFuc2Zvcm1bNF0sIHBpeGVsUmF0aW8gKiBzaXplWzFdIC8gMiAtIHRyYW5zZm9ybVs1XSxcbiAgICAgIHBpeGVsUmF0aW8gLyB2aWV3UmVzb2x1dGlvbiwgLXBpeGVsUmF0aW8gLyB2aWV3UmVzb2x1dGlvbixcbiAgICAgIDAsXG4gICAgICAtdmlld0NlbnRlclswXSwgLXZpZXdDZW50ZXJbMV0pO1xuXG5cbiAgICB0aGlzLnVwZGF0ZVVzZWRUaWxlcyhmcmFtZVN0YXRlLnVzZWRUaWxlcywgdGlsZVNvdXJjZSwgeiwgdGlsZVJhbmdlKTtcbiAgICB0aGlzLm1hbmFnZVRpbGVQeXJhbWlkKGZyYW1lU3RhdGUsIHRpbGVTb3VyY2UsIHRpbGVHcmlkLCBwaXhlbFJhdGlvLFxuICAgICAgcHJvamVjdGlvbiwgZXh0ZW50LCB6LCB0aWxlTGF5ZXIuZ2V0UHJlbG9hZCgpKTtcbiAgICB0aGlzLnNjaGVkdWxlRXhwaXJlQ2FjaGUoZnJhbWVTdGF0ZSwgdGlsZVNvdXJjZSk7XG5cbiAgICByZXR1cm4gdGhpcy5yZW5kZXJlZFRpbGVzLmxlbmd0aCA+IDA7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vVGlsZS5qc1wiKS5kZWZhdWx0fSB0aWxlIFRpbGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vbGF5ZXIvTGF5ZXIuanNcIikuU3RhdGV9IGxheWVyU3RhdGUgTGF5ZXIgc3RhdGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IExlZnQgb2YgdGhlIHRpbGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IFRvcCBvZiB0aGUgdGlsZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHcgV2lkdGggb2YgdGhlIHRpbGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoIEhlaWdodCBvZiB0aGUgdGlsZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGd1dHRlciBUaWxlIGd1dHRlci5cbiAgICogQHBhcmFtIHtib29sZWFufSB0cmFuc2l0aW9uIEFwcGx5IGFuIGFscGhhIHRyYW5zaXRpb24uXG4gICAqL1xuICBDYW52YXNUaWxlTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuZHJhd1RpbGVJbWFnZSA9IGZ1bmN0aW9uIGRyYXdUaWxlSW1hZ2UgKHRpbGUsIGZyYW1lU3RhdGUsIGxheWVyU3RhdGUsIHgsIHksIHcsIGgsIGd1dHRlciwgdHJhbnNpdGlvbikge1xuICAgIHZhciBpbWFnZSA9IHRoaXMuZ2V0VGlsZUltYWdlKHRpbGUpO1xuICAgIGlmICghaW1hZ2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHVpZCA9IGdldFVpZCh0aGlzKTtcbiAgICB2YXIgYWxwaGEgPSB0cmFuc2l0aW9uID8gdGlsZS5nZXRBbHBoYSh1aWQsIGZyYW1lU3RhdGUudGltZSkgOiAxO1xuICAgIHZhciB0aWxlTGF5ZXIgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2xheWVyL1RpbGUuanNcIikuZGVmYXVsdH0gKi8gKHRoaXMuZ2V0TGF5ZXIoKSk7XG4gICAgdmFyIHRpbGVTb3VyY2UgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL3NvdXJjZS9UaWxlLmpzXCIpLmRlZmF1bHR9ICovICh0aWxlTGF5ZXIuZ2V0U291cmNlKCkpO1xuICAgIGlmIChhbHBoYSA9PT0gMSAmJiAhdGlsZVNvdXJjZS5nZXRPcGFxdWUoZnJhbWVTdGF0ZS52aWV3U3RhdGUucHJvamVjdGlvbikpIHtcbiAgICAgIHRoaXMuY29udGV4dC5jbGVhclJlY3QoeCwgeSwgdywgaCk7XG4gICAgfVxuICAgIHZhciBhbHBoYUNoYW5nZWQgPSBhbHBoYSAhPT0gdGhpcy5jb250ZXh0Lmdsb2JhbEFscGhhO1xuICAgIGlmIChhbHBoYUNoYW5nZWQpIHtcbiAgICAgIHRoaXMuY29udGV4dC5zYXZlKCk7XG4gICAgICB0aGlzLmNvbnRleHQuZ2xvYmFsQWxwaGEgPSBhbHBoYTtcbiAgICB9XG4gICAgdGhpcy5jb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgZ3V0dGVyLCBndXR0ZXIsXG4gICAgICBpbWFnZS53aWR0aCAtIDIgKiBndXR0ZXIsIGltYWdlLmhlaWdodCAtIDIgKiBndXR0ZXIsIHgsIHksIHcsIGgpO1xuXG4gICAgaWYgKGFscGhhQ2hhbmdlZCkge1xuICAgICAgdGhpcy5jb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgaWYgKGFscGhhICE9PSAxKSB7XG4gICAgICBmcmFtZVN0YXRlLmFuaW1hdGUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodHJhbnNpdGlvbikge1xuICAgICAgdGlsZS5lbmRUcmFuc2l0aW9uKHVpZCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQ2FudmFzVGlsZUxheWVyUmVuZGVyZXIucHJvdG90eXBlLmdldEltYWdlID0gZnVuY3Rpb24gZ2V0SW1hZ2UgKCkge1xuICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICAgIHJldHVybiBjb250ZXh0ID8gY29udGV4dC5jYW52YXMgOiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQ2FudmFzVGlsZUxheWVyUmVuZGVyZXIucHJvdG90eXBlLmdldEltYWdlVHJhbnNmb3JtID0gZnVuY3Rpb24gZ2V0SW1hZ2VUcmFuc2Zvcm0gKCkge1xuICAgIHJldHVybiB0aGlzLmltYWdlVHJhbnNmb3JtXztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBpbWFnZSBmcm9tIGEgdGlsZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9UaWxlLmpzXCIpLmRlZmF1bHR9IHRpbGUgVGlsZS5cbiAgICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR8SFRNTEltYWdlRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fSBJbWFnZS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgQ2FudmFzVGlsZUxheWVyUmVuZGVyZXIucHJvdG90eXBlLmdldFRpbGVJbWFnZSA9IGZ1bmN0aW9uIGdldFRpbGVJbWFnZSAodGlsZSkge1xuICAgIHJldHVybiAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL0ltYWdlVGlsZS5qc1wiKS5kZWZhdWx0fSAqLyAodGlsZSkuZ2V0SW1hZ2UoKTtcbiAgfTtcblxuICByZXR1cm4gQ2FudmFzVGlsZUxheWVyUmVuZGVyZXI7XG59KEludGVybWVkaWF0ZUNhbnZhc1JlbmRlcmVyKSk7XG5cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdGhpcyByZW5kZXJlciBoYW5kbGVzIHRoZSBwcm92aWRlZCBsYXllci5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdH0gbGF5ZXIgVGhlIGNhbmRpZGF0ZSBsYXllci5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSByZW5kZXJlciBjYW4gcmVuZGVyIHRoZSBsYXllci5cbiAqL1xuQ2FudmFzVGlsZUxheWVyUmVuZGVyZXJbJ2hhbmRsZXMnXSA9IGZ1bmN0aW9uKGxheWVyKSB7XG4gIHJldHVybiBsYXllci5nZXRUeXBlKCkgPT09IExheWVyVHlwZS5USUxFO1xufTtcblxuXG4vKipcbiAqIENyZWF0ZSBhIGxheWVyIHJlbmRlcmVyLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdH0gbWFwUmVuZGVyZXIgVGhlIG1hcCByZW5kZXJlci5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdH0gbGF5ZXIgVGhlIGxheWVyIHRvIGJlIHJlbmRlcmVyZC5cbiAqIEByZXR1cm4ge0NhbnZhc1RpbGVMYXllclJlbmRlcmVyfSBUaGUgbGF5ZXIgcmVuZGVyZXIuXG4gKi9cbkNhbnZhc1RpbGVMYXllclJlbmRlcmVyWydjcmVhdGUnXSA9IGZ1bmN0aW9uKG1hcFJlbmRlcmVyLCBsYXllcikge1xuICByZXR1cm4gbmV3IENhbnZhc1RpbGVMYXllclJlbmRlcmVyKC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vbGF5ZXIvVGlsZS5qc1wiKS5kZWZhdWx0fSAqLyAobGF5ZXIpKTtcbn07XG5cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uLy4uL2xheWVyL1RpbGUuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi8uLi9sYXllci9WZWN0b3JUaWxlLmpzXCIpLmRlZmF1bHR9XG4gKi9cbkNhbnZhc1RpbGVMYXllclJlbmRlcmVyLnByb3RvdHlwZS5nZXRMYXllcjtcblxuXG5leHBvcnQgZGVmYXVsdCBDYW52YXNUaWxlTGF5ZXJSZW5kZXJlcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGlsZUxheWVyLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXJlci9jYW52YXMvVmVjdG9yTGF5ZXJcbiAqL1xuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4uLy4uL3V0aWwuanMnO1xuaW1wb3J0IExheWVyVHlwZSBmcm9tICcuLi8uLi9MYXllclR5cGUuanMnO1xuaW1wb3J0IFZpZXdIaW50IGZyb20gJy4uLy4uL1ZpZXdIaW50LmpzJztcbmltcG9ydCB7Y3JlYXRlQ2FudmFzQ29udGV4dDJEfSBmcm9tICcuLi8uLi9kb20uanMnO1xuaW1wb3J0IHtsaXN0ZW4sIHVubGlzdGVufSBmcm9tICcuLi8uLi9ldmVudHMuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi8uLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCByYnVzaCBmcm9tICdyYnVzaCc7XG5pbXBvcnQge2J1ZmZlciwgY3JlYXRlRW1wdHksIGNvbnRhaW5zRXh0ZW50LCBnZXRXaWR0aH0gZnJvbSAnLi4vLi4vZXh0ZW50LmpzJztcbmltcG9ydCBSZW5kZXJFdmVudFR5cGUgZnJvbSAnLi4vLi4vcmVuZGVyL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQge2xhYmVsQ2FjaGUsIHJvdGF0ZUF0T2Zmc2V0fSBmcm9tICcuLi8uLi9yZW5kZXIvY2FudmFzLmpzJztcbmltcG9ydCBDYW52YXNSZXBsYXlHcm91cCBmcm9tICcuLi8uLi9yZW5kZXIvY2FudmFzL1JlcGxheUdyb3VwLmpzJztcbmltcG9ydCBDYW52YXNMYXllclJlbmRlcmVyIGZyb20gJy4vTGF5ZXIuanMnO1xuaW1wb3J0IHtkZWZhdWx0T3JkZXIgYXMgZGVmYXVsdFJlbmRlck9yZGVyLCBnZXRUb2xlcmFuY2UgYXMgZ2V0UmVuZGVyVG9sZXJhbmNlLCBnZXRTcXVhcmVkVG9sZXJhbmNlIGFzIGdldFNxdWFyZWRSZW5kZXJUb2xlcmFuY2UsIHJlbmRlckZlYXR1cmV9IGZyb20gJy4uL3ZlY3Rvci5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQ2FudmFzIHJlbmRlcmVyIGZvciB2ZWN0b3IgbGF5ZXJzLlxuICogQGFwaVxuICovXG52YXIgQ2FudmFzVmVjdG9yTGF5ZXJSZW5kZXJlciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKENhbnZhc0xheWVyUmVuZGVyZXIpIHtcbiAgZnVuY3Rpb24gQ2FudmFzVmVjdG9yTGF5ZXJSZW5kZXJlcih2ZWN0b3JMYXllcikge1xuXG4gICAgQ2FudmFzTGF5ZXJSZW5kZXJlci5jYWxsKHRoaXMsIHZlY3RvckxheWVyKTtcblxuICAgIC8qKlxuICAgICAqIERlY2x1dHRlciB0cmVlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5kZWNsdXR0ZXJUcmVlXyA9IHZlY3RvckxheWVyLmdldERlY2x1dHRlcigpID8gcmJ1c2goOSwgdW5kZWZpbmVkKSA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZGlydHlfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZFJldmlzaW9uXyA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZWRSZXNvbHV0aW9uXyA9IE5hTjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZEV4dGVudF8gPSBjcmVhdGVFbXB0eSgpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0LCBpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQpOiBudW1iZXJ8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVkUmVuZGVyT3JkZXJfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uLy4uL3JlbmRlci9jYW52YXMvUmVwbGF5R3JvdXAuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLnJlcGxheUdyb3VwXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBIG5ldyByZXBsYXkgZ3JvdXAgaGFkIHRvIGJlIGNyZWF0ZWQgYnkgYHByZXBhcmVGcmFtZSgpYFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVwbGF5R3JvdXBDaGFuZ2VkID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gICAgICovXG4gICAgdGhpcy5jb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKCk7XG5cbiAgICBsaXN0ZW4obGFiZWxDYWNoZSwgRXZlbnRUeXBlLkNMRUFSLCB0aGlzLmhhbmRsZUZvbnRzQ2hhbmdlZF8sIHRoaXMpO1xuXG4gIH1cblxuICBpZiAoIENhbnZhc0xheWVyUmVuZGVyZXIgKSBDYW52YXNWZWN0b3JMYXllclJlbmRlcmVyLl9fcHJvdG9fXyA9IENhbnZhc0xheWVyUmVuZGVyZXI7XG4gIENhbnZhc1ZlY3RvckxheWVyUmVuZGVyZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ2FudmFzTGF5ZXJSZW5kZXJlciAmJiBDYW52YXNMYXllclJlbmRlcmVyLnByb3RvdHlwZSApO1xuICBDYW52YXNWZWN0b3JMYXllclJlbmRlcmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhbnZhc1ZlY3RvckxheWVyUmVuZGVyZXI7XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNWZWN0b3JMYXllclJlbmRlcmVyLnByb3RvdHlwZS5kaXNwb3NlSW50ZXJuYWwgPSBmdW5jdGlvbiBkaXNwb3NlSW50ZXJuYWwgKCkge1xuICAgIHVubGlzdGVuKGxhYmVsQ2FjaGUsIEV2ZW50VHlwZS5DTEVBUiwgdGhpcy5oYW5kbGVGb250c0NoYW5nZWRfLCB0aGlzKTtcbiAgICBDYW52YXNMYXllclJlbmRlcmVyLnByb3RvdHlwZS5kaXNwb3NlSW50ZXJuYWwuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9QbHVnZ2FibGVNYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9sYXllci9MYXllci5qc1wiKS5TdGF0ZX0gbGF5ZXJTdGF0ZSBMYXllciBzdGF0ZS5cbiAgICovXG4gIENhbnZhc1ZlY3RvckxheWVyUmVuZGVyZXIucHJvdG90eXBlLmNvbXBvc2UgPSBmdW5jdGlvbiBjb21wb3NlIChjb250ZXh0LCBmcmFtZVN0YXRlLCBsYXllclN0YXRlKSB7XG4gICAgdmFyIGV4dGVudCA9IGZyYW1lU3RhdGUuZXh0ZW50O1xuICAgIHZhciBwaXhlbFJhdGlvID0gZnJhbWVTdGF0ZS5waXhlbFJhdGlvO1xuICAgIHZhciBza2lwcGVkRmVhdHVyZVVpZHMgPSBsYXllclN0YXRlLm1hbmFnZWQgP1xuICAgICAgZnJhbWVTdGF0ZS5za2lwcGVkRmVhdHVyZVVpZHMgOiB7fTtcbiAgICB2YXIgdmlld1N0YXRlID0gZnJhbWVTdGF0ZS52aWV3U3RhdGU7XG4gICAgdmFyIHByb2plY3Rpb24gPSB2aWV3U3RhdGUucHJvamVjdGlvbjtcbiAgICB2YXIgcm90YXRpb24gPSB2aWV3U3RhdGUucm90YXRpb247XG4gICAgdmFyIHByb2plY3Rpb25FeHRlbnQgPSBwcm9qZWN0aW9uLmdldEV4dGVudCgpO1xuICAgIHZhciB2ZWN0b3JTb3VyY2UgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL3NvdXJjZS9WZWN0b3IuanNcIikuZGVmYXVsdH0gKi8gKHRoaXMuZ2V0TGF5ZXIoKS5nZXRTb3VyY2UoKSk7XG5cbiAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy5nZXRUcmFuc2Zvcm0oZnJhbWVTdGF0ZSwgMCk7XG5cbiAgICAvLyBjbGlwcGVkIHJlbmRlcmluZyBpZiBsYXllciBleHRlbnQgaXMgc2V0XG4gICAgdmFyIGNsaXBFeHRlbnQgPSBsYXllclN0YXRlLmV4dGVudDtcbiAgICB2YXIgY2xpcHBlZCA9IGNsaXBFeHRlbnQgIT09IHVuZGVmaW5lZDtcbiAgICBpZiAoY2xpcHBlZCkge1xuICAgICAgdGhpcy5jbGlwKGNvbnRleHQsIGZyYW1lU3RhdGUsIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gKi8gKGNsaXBFeHRlbnQpKTtcbiAgICB9XG4gICAgdmFyIHJlcGxheUdyb3VwID0gdGhpcy5yZXBsYXlHcm91cF87XG4gICAgaWYgKHJlcGxheUdyb3VwICYmICFyZXBsYXlHcm91cC5pc0VtcHR5KCkpIHtcbiAgICAgIGlmICh0aGlzLmRlY2x1dHRlclRyZWVfKSB7XG4gICAgICAgIHRoaXMuZGVjbHV0dGVyVHJlZV8uY2xlYXIoKTtcbiAgICAgIH1cbiAgICAgIHZhciBsYXllciA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vbGF5ZXIvVmVjdG9yLmpzXCIpLmRlZmF1bHR9ICovICh0aGlzLmdldExheWVyKCkpO1xuICAgICAgdmFyIGRyYXdPZmZzZXRYID0gMDtcbiAgICAgIHZhciBkcmF3T2Zmc2V0WSA9IDA7XG4gICAgICB2YXIgcmVwbGF5Q29udGV4dDtcbiAgICAgIHZhciB0cmFuc3BhcmVudExheWVyID0gbGF5ZXJTdGF0ZS5vcGFjaXR5ICE9PSAxO1xuICAgICAgdmFyIGhhc1JlbmRlckxpc3RlbmVycyA9IGxheWVyLmhhc0xpc3RlbmVyKFJlbmRlckV2ZW50VHlwZS5SRU5ERVIpO1xuICAgICAgaWYgKHRyYW5zcGFyZW50TGF5ZXIgfHwgaGFzUmVuZGVyTGlzdGVuZXJzKSB7XG4gICAgICAgIHZhciBkcmF3V2lkdGggPSBjb250ZXh0LmNhbnZhcy53aWR0aDtcbiAgICAgICAgdmFyIGRyYXdIZWlnaHQgPSBjb250ZXh0LmNhbnZhcy5oZWlnaHQ7XG4gICAgICAgIGlmIChyb3RhdGlvbikge1xuICAgICAgICAgIHZhciBkcmF3U2l6ZSA9IE1hdGgucm91bmQoTWF0aC5zcXJ0KGRyYXdXaWR0aCAqIGRyYXdXaWR0aCArIGRyYXdIZWlnaHQgKiBkcmF3SGVpZ2h0KSk7XG4gICAgICAgICAgZHJhd09mZnNldFggPSAoZHJhd1NpemUgLSBkcmF3V2lkdGgpIC8gMjtcbiAgICAgICAgICBkcmF3T2Zmc2V0WSA9IChkcmF3U2l6ZSAtIGRyYXdIZWlnaHQpIC8gMjtcbiAgICAgICAgICBkcmF3V2lkdGggPSBkcmF3SGVpZ2h0ID0gZHJhd1NpemU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVzaXplIGFuZCBjbGVhclxuICAgICAgICB0aGlzLmNvbnRleHQuY2FudmFzLndpZHRoID0gZHJhd1dpZHRoO1xuICAgICAgICB0aGlzLmNvbnRleHQuY2FudmFzLmhlaWdodCA9IGRyYXdIZWlnaHQ7XG4gICAgICAgIHJlcGxheUNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXBsYXlDb250ZXh0ID0gY29udGV4dDtcbiAgICAgIH1cblxuICAgICAgdmFyIGFscGhhID0gcmVwbGF5Q29udGV4dC5nbG9iYWxBbHBoYTtcbiAgICAgIGlmICghdHJhbnNwYXJlbnRMYXllcikge1xuICAgICAgICAvLyBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgY29udGV4dC5zYXZlIC8gY29udGV4dC5yZXN0b3JlIGlzIG5vdCB1c2VkXG4gICAgICAgIC8vIHRvIHNhdmUgYW5kIHJlc3RvcmUgdGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBhbmQgdGhlIG9wYWNpdHkuXG4gICAgICAgIC8vIHNlZSBodHRwOi8vanNwZXJmLmNvbS9jb250ZXh0LXNhdmUtcmVzdG9yZS12ZXJzdXMtdmFyaWFibGVcbiAgICAgICAgcmVwbGF5Q29udGV4dC5nbG9iYWxBbHBoYSA9IGxheWVyU3RhdGUub3BhY2l0eTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlcGxheUNvbnRleHQgIT0gY29udGV4dCkge1xuICAgICAgICByZXBsYXlDb250ZXh0LnRyYW5zbGF0ZShkcmF3T2Zmc2V0WCwgZHJhd09mZnNldFkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmlld0hpbnRzID0gZnJhbWVTdGF0ZS52aWV3SGludHM7XG4gICAgICB2YXIgc25hcFRvUGl4ZWwgPSAhKHZpZXdIaW50c1tWaWV3SGludC5BTklNQVRJTkddIHx8IHZpZXdIaW50c1tWaWV3SGludC5JTlRFUkFDVElOR10pO1xuICAgICAgdmFyIHdpZHRoID0gZnJhbWVTdGF0ZS5zaXplWzBdICogcGl4ZWxSYXRpbztcbiAgICAgIHZhciBoZWlnaHQgPSBmcmFtZVN0YXRlLnNpemVbMV0gKiBwaXhlbFJhdGlvO1xuICAgICAgcm90YXRlQXRPZmZzZXQocmVwbGF5Q29udGV4dCwgLXJvdGF0aW9uLFxuICAgICAgICB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICAgICAgcmVwbGF5R3JvdXAucmVwbGF5KHJlcGxheUNvbnRleHQsIHRyYW5zZm9ybSwgcm90YXRpb24sIHNraXBwZWRGZWF0dXJlVWlkcywgc25hcFRvUGl4ZWwpO1xuICAgICAgaWYgKHZlY3RvclNvdXJjZS5nZXRXcmFwWCgpICYmIHByb2plY3Rpb24uY2FuV3JhcFgoKSAmJlxuICAgICAgICAgICFjb250YWluc0V4dGVudChwcm9qZWN0aW9uRXh0ZW50LCBleHRlbnQpKSB7XG4gICAgICAgIHZhciBzdGFydFggPSBleHRlbnRbMF07XG4gICAgICAgIHZhciB3b3JsZFdpZHRoID0gZ2V0V2lkdGgocHJvamVjdGlvbkV4dGVudCk7XG4gICAgICAgIHZhciB3b3JsZCA9IDA7XG4gICAgICAgIHZhciBvZmZzZXRYO1xuICAgICAgICB3aGlsZSAoc3RhcnRYIDwgcHJvamVjdGlvbkV4dGVudFswXSkge1xuICAgICAgICAgIC0td29ybGQ7XG4gICAgICAgICAgb2Zmc2V0WCA9IHdvcmxkV2lkdGggKiB3b3JsZDtcbiAgICAgICAgICB0cmFuc2Zvcm0gPSB0aGlzLmdldFRyYW5zZm9ybShmcmFtZVN0YXRlLCBvZmZzZXRYKTtcbiAgICAgICAgICByZXBsYXlHcm91cC5yZXBsYXkocmVwbGF5Q29udGV4dCwgdHJhbnNmb3JtLCByb3RhdGlvbiwgc2tpcHBlZEZlYXR1cmVVaWRzLCBzbmFwVG9QaXhlbCk7XG4gICAgICAgICAgc3RhcnRYICs9IHdvcmxkV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgd29ybGQgPSAwO1xuICAgICAgICBzdGFydFggPSBleHRlbnRbMl07XG4gICAgICAgIHdoaWxlIChzdGFydFggPiBwcm9qZWN0aW9uRXh0ZW50WzJdKSB7XG4gICAgICAgICAgKyt3b3JsZDtcbiAgICAgICAgICBvZmZzZXRYID0gd29ybGRXaWR0aCAqIHdvcmxkO1xuICAgICAgICAgIHRyYW5zZm9ybSA9IHRoaXMuZ2V0VHJhbnNmb3JtKGZyYW1lU3RhdGUsIG9mZnNldFgpO1xuICAgICAgICAgIHJlcGxheUdyb3VwLnJlcGxheShyZXBsYXlDb250ZXh0LCB0cmFuc2Zvcm0sIHJvdGF0aW9uLCBza2lwcGVkRmVhdHVyZVVpZHMsIHNuYXBUb1BpeGVsKTtcbiAgICAgICAgICBzdGFydFggLT0gd29ybGRXaWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcm90YXRlQXRPZmZzZXQocmVwbGF5Q29udGV4dCwgcm90YXRpb24sXG4gICAgICAgIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG5cbiAgICAgIGlmIChoYXNSZW5kZXJMaXN0ZW5lcnMpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaFJlbmRlckV2ZW50KHJlcGxheUNvbnRleHQsIGZyYW1lU3RhdGUsIHRyYW5zZm9ybSk7XG4gICAgICB9XG4gICAgICBpZiAocmVwbGF5Q29udGV4dCAhPSBjb250ZXh0KSB7XG4gICAgICAgIGlmICh0cmFuc3BhcmVudExheWVyKSB7XG4gICAgICAgICAgdmFyIG1haW5Db250ZXh0QWxwaGEgPSBjb250ZXh0Lmdsb2JhbEFscGhhO1xuICAgICAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBsYXllclN0YXRlLm9wYWNpdHk7XG4gICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UocmVwbGF5Q29udGV4dC5jYW52YXMsIC1kcmF3T2Zmc2V0WCwgLWRyYXdPZmZzZXRZKTtcbiAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gbWFpbkNvbnRleHRBbHBoYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShyZXBsYXlDb250ZXh0LmNhbnZhcywgLWRyYXdPZmZzZXRYLCAtZHJhd09mZnNldFkpO1xuICAgICAgICB9XG4gICAgICAgIHJlcGxheUNvbnRleHQudHJhbnNsYXRlKC1kcmF3T2Zmc2V0WCwgLWRyYXdPZmZzZXRZKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0cmFuc3BhcmVudExheWVyKSB7XG4gICAgICAgIHJlcGxheUNvbnRleHQuZ2xvYmFsQWxwaGEgPSBhbHBoYTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2xpcHBlZCkge1xuICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQ2FudmFzVmVjdG9yTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuY29tcG9zZUZyYW1lID0gZnVuY3Rpb24gY29tcG9zZUZyYW1lIChmcmFtZVN0YXRlLCBsYXllclN0YXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMuZ2V0VHJhbnNmb3JtKGZyYW1lU3RhdGUsIDApO1xuICAgIHRoaXMucHJlQ29tcG9zZShjb250ZXh0LCBmcmFtZVN0YXRlLCB0cmFuc2Zvcm0pO1xuICAgIHRoaXMuY29tcG9zZShjb250ZXh0LCBmcmFtZVN0YXRlLCBsYXllclN0YXRlKTtcbiAgICB0aGlzLnBvc3RDb21wb3NlKGNvbnRleHQsIGZyYW1lU3RhdGUsIGxheWVyU3RhdGUsIHRyYW5zZm9ybSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNWZWN0b3JMYXllclJlbmRlcmVyLnByb3RvdHlwZS5mb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlIChjb29yZGluYXRlLCBmcmFtZVN0YXRlLCBoaXRUb2xlcmFuY2UsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgaWYgKCF0aGlzLnJlcGxheUdyb3VwXykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJlc29sdXRpb24gPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZS5yZXNvbHV0aW9uO1xuICAgICAgdmFyIHJvdGF0aW9uID0gZnJhbWVTdGF0ZS52aWV3U3RhdGUucm90YXRpb247XG4gICAgICB2YXIgbGF5ZXIgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2xheWVyL1ZlY3Rvci5qc1wiKS5kZWZhdWx0fSAqLyAodGhpcy5nZXRMYXllcigpKTtcbiAgICAgIC8qKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIGJvb2xlYW4+fSAqL1xuICAgICAgdmFyIGZlYXR1cmVzID0ge307XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5yZXBsYXlHcm91cF8uZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGUoY29vcmRpbmF0ZSwgcmVzb2x1dGlvbiwgcm90YXRpb24sIGhpdFRvbGVyYW5jZSwge30sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICAgICAgICogQHJldHVybiB7P30gQ2FsbGJhY2sgcmVzdWx0LlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgICAgICAgIHZhciBrZXkgPSBnZXRVaWQoZmVhdHVyZSk7XG4gICAgICAgICAgaWYgKCEoa2V5IGluIGZlYXR1cmVzKSkge1xuICAgICAgICAgICAgZmVhdHVyZXNba2V5XSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzQXJnLCBmZWF0dXJlLCBsYXllcik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBudWxsKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0fSBldmVudCBFdmVudC5cbiAgICovXG4gIENhbnZhc1ZlY3RvckxheWVyUmVuZGVyZXIucHJvdG90eXBlLmhhbmRsZUZvbnRzQ2hhbmdlZF8gPSBmdW5jdGlvbiBoYW5kbGVGb250c0NoYW5nZWRfIChldmVudCkge1xuICAgIHZhciBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKTtcbiAgICBpZiAobGF5ZXIuZ2V0VmlzaWJsZSgpICYmIHRoaXMucmVwbGF5R3JvdXBfKSB7XG4gICAgICBsYXllci5jaGFuZ2VkKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgY2hhbmdlcyBpbiBpbWFnZSBzdHlsZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdH0gZXZlbnQgSW1hZ2Ugc3R5bGUgY2hhbmdlIGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQ2FudmFzVmVjdG9yTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuaGFuZGxlU3R5bGVJbWFnZUNoYW5nZV8gPSBmdW5jdGlvbiBoYW5kbGVTdHlsZUltYWdlQ2hhbmdlXyAoZXZlbnQpIHtcbiAgICB0aGlzLnJlbmRlcklmUmVhZHlBbmRWaXNpYmxlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNWZWN0b3JMYXllclJlbmRlcmVyLnByb3RvdHlwZS5wcmVwYXJlRnJhbWUgPSBmdW5jdGlvbiBwcmVwYXJlRnJhbWUgKGZyYW1lU3RhdGUsIGxheWVyU3RhdGUpIHtcbiAgICB2YXIgdmVjdG9yTGF5ZXIgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2xheWVyL1ZlY3Rvci5qc1wiKS5kZWZhdWx0fSAqLyAodGhpcy5nZXRMYXllcigpKTtcbiAgICB2YXIgdmVjdG9yU291cmNlID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9zb3VyY2UvVmVjdG9yLmpzXCIpLmRlZmF1bHR9ICovICh2ZWN0b3JMYXllci5nZXRTb3VyY2UoKSk7XG5cbiAgICB2YXIgYW5pbWF0aW5nID0gZnJhbWVTdGF0ZS52aWV3SGludHNbVmlld0hpbnQuQU5JTUFUSU5HXTtcbiAgICB2YXIgaW50ZXJhY3RpbmcgPSBmcmFtZVN0YXRlLnZpZXdIaW50c1tWaWV3SGludC5JTlRFUkFDVElOR107XG4gICAgdmFyIHVwZGF0ZVdoaWxlQW5pbWF0aW5nID0gdmVjdG9yTGF5ZXIuZ2V0VXBkYXRlV2hpbGVBbmltYXRpbmcoKTtcbiAgICB2YXIgdXBkYXRlV2hpbGVJbnRlcmFjdGluZyA9IHZlY3RvckxheWVyLmdldFVwZGF0ZVdoaWxlSW50ZXJhY3RpbmcoKTtcblxuICAgIGlmICghdGhpcy5kaXJ0eV8gJiYgKCF1cGRhdGVXaGlsZUFuaW1hdGluZyAmJiBhbmltYXRpbmcpIHx8XG4gICAgICAgICghdXBkYXRlV2hpbGVJbnRlcmFjdGluZyAmJiBpbnRlcmFjdGluZykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBmcmFtZVN0YXRlRXh0ZW50ID0gZnJhbWVTdGF0ZS5leHRlbnQ7XG4gICAgdmFyIHZpZXdTdGF0ZSA9IGZyYW1lU3RhdGUudmlld1N0YXRlO1xuICAgIHZhciBwcm9qZWN0aW9uID0gdmlld1N0YXRlLnByb2plY3Rpb247XG4gICAgdmFyIHJlc29sdXRpb24gPSB2aWV3U3RhdGUucmVzb2x1dGlvbjtcbiAgICB2YXIgcGl4ZWxSYXRpbyA9IGZyYW1lU3RhdGUucGl4ZWxSYXRpbztcbiAgICB2YXIgdmVjdG9yTGF5ZXJSZXZpc2lvbiA9IHZlY3RvckxheWVyLmdldFJldmlzaW9uKCk7XG4gICAgdmFyIHZlY3RvckxheWVyUmVuZGVyQnVmZmVyID0gdmVjdG9yTGF5ZXIuZ2V0UmVuZGVyQnVmZmVyKCk7XG4gICAgdmFyIHZlY3RvckxheWVyUmVuZGVyT3JkZXIgPSB2ZWN0b3JMYXllci5nZXRSZW5kZXJPcmRlcigpO1xuXG4gICAgaWYgKHZlY3RvckxheWVyUmVuZGVyT3JkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmVjdG9yTGF5ZXJSZW5kZXJPcmRlciA9IGRlZmF1bHRSZW5kZXJPcmRlcjtcbiAgICB9XG5cbiAgICB2YXIgZXh0ZW50ID0gYnVmZmVyKGZyYW1lU3RhdGVFeHRlbnQsXG4gICAgICB2ZWN0b3JMYXllclJlbmRlckJ1ZmZlciAqIHJlc29sdXRpb24pO1xuICAgIHZhciBwcm9qZWN0aW9uRXh0ZW50ID0gdmlld1N0YXRlLnByb2plY3Rpb24uZ2V0RXh0ZW50KCk7XG5cbiAgICBpZiAodmVjdG9yU291cmNlLmdldFdyYXBYKCkgJiYgdmlld1N0YXRlLnByb2plY3Rpb24uY2FuV3JhcFgoKSAmJlxuICAgICAgICAhY29udGFpbnNFeHRlbnQocHJvamVjdGlvbkV4dGVudCwgZnJhbWVTdGF0ZS5leHRlbnQpKSB7XG4gICAgICAvLyBGb3IgdGhlIHJlcGxheSBncm91cCwgd2UgbmVlZCBhbiBleHRlbnQgdGhhdCBpbnRlcnNlY3RzIHRoZSByZWFsIHdvcmxkXG4gICAgICAvLyAoLTE4MMKwIHRvICsxODDCsCkuIFRvIHN1cHBvcnQgZ2VvbWV0cmllcyBpbiBhIGNvb3JkaW5hdGUgcmFuZ2UgZnJvbSAtNTQwwrBcbiAgICAgIC8vIHRvICs1NDDCsCwgd2UgYWRkIGF0IGxlYXN0IDEgd29ybGQgd2lkdGggb24gZWFjaCBzaWRlIG9mIHRoZSBwcm9qZWN0aW9uXG4gICAgICAvLyBleHRlbnQuIElmIHRoZSB2aWV3cG9ydCBpcyB3aWRlciB0aGFuIHRoZSB3b3JsZCwgd2UgbmVlZCB0byBhZGQgaGFsZiBvZlxuICAgICAgLy8gdGhlIHZpZXdwb3J0IHdpZHRoIHRvIG1ha2Ugc3VyZSB3ZSBjb3ZlciB0aGUgd2hvbGUgdmlld3BvcnQuXG4gICAgICB2YXIgd29ybGRXaWR0aCA9IGdldFdpZHRoKHByb2plY3Rpb25FeHRlbnQpO1xuICAgICAgdmFyIGd1dHRlciA9IE1hdGgubWF4KGdldFdpZHRoKGV4dGVudCkgLyAyLCB3b3JsZFdpZHRoKTtcbiAgICAgIGV4dGVudFswXSA9IHByb2plY3Rpb25FeHRlbnRbMF0gLSBndXR0ZXI7XG4gICAgICBleHRlbnRbMl0gPSBwcm9qZWN0aW9uRXh0ZW50WzJdICsgZ3V0dGVyO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5kaXJ0eV8gJiZcbiAgICAgICAgdGhpcy5yZW5kZXJlZFJlc29sdXRpb25fID09IHJlc29sdXRpb24gJiZcbiAgICAgICAgdGhpcy5yZW5kZXJlZFJldmlzaW9uXyA9PSB2ZWN0b3JMYXllclJldmlzaW9uICYmXG4gICAgICAgIHRoaXMucmVuZGVyZWRSZW5kZXJPcmRlcl8gPT0gdmVjdG9yTGF5ZXJSZW5kZXJPcmRlciAmJlxuICAgICAgICBjb250YWluc0V4dGVudCh0aGlzLnJlbmRlcmVkRXh0ZW50XywgZXh0ZW50KSkge1xuICAgICAgdGhpcy5yZXBsYXlHcm91cENoYW5nZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMucmVwbGF5R3JvdXBfID0gbnVsbDtcblxuICAgIHRoaXMuZGlydHlfID0gZmFsc2U7XG5cbiAgICB2YXIgcmVwbGF5R3JvdXAgPSBuZXcgQ2FudmFzUmVwbGF5R3JvdXAoXG4gICAgICBnZXRSZW5kZXJUb2xlcmFuY2UocmVzb2x1dGlvbiwgcGl4ZWxSYXRpbyksIGV4dGVudCwgcmVzb2x1dGlvbixcbiAgICAgIHBpeGVsUmF0aW8sIHZlY3RvclNvdXJjZS5nZXRPdmVybGFwcygpLCB0aGlzLmRlY2x1dHRlclRyZWVfLCB2ZWN0b3JMYXllci5nZXRSZW5kZXJCdWZmZXIoKSk7XG4gICAgdmVjdG9yU291cmNlLmxvYWRGZWF0dXJlcyhleHRlbnQsIHJlc29sdXRpb24sIHByb2plY3Rpb24pO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmUuXG4gICAgICogQHRoaXMge0NhbnZhc1ZlY3RvckxheWVyUmVuZGVyZXJ9XG4gICAgICovXG4gICAgdmFyIHJlbmRlciA9IGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgICAgIHZhciBzdHlsZXM7XG4gICAgICB2YXIgc3R5bGVGdW5jdGlvbiA9IGZlYXR1cmUuZ2V0U3R5bGVGdW5jdGlvbigpIHx8IHZlY3RvckxheWVyLmdldFN0eWxlRnVuY3Rpb24oKTtcbiAgICAgIGlmIChzdHlsZUZ1bmN0aW9uKSB7XG4gICAgICAgIHN0eWxlcyA9IHN0eWxlRnVuY3Rpb24oZmVhdHVyZSwgcmVzb2x1dGlvbik7XG4gICAgICB9XG4gICAgICBpZiAoc3R5bGVzKSB7XG4gICAgICAgIHZhciBkaXJ0eSA9IHRoaXMucmVuZGVyRmVhdHVyZShcbiAgICAgICAgICBmZWF0dXJlLCByZXNvbHV0aW9uLCBwaXhlbFJhdGlvLCBzdHlsZXMsIHJlcGxheUdyb3VwKTtcbiAgICAgICAgdGhpcy5kaXJ0eV8gPSB0aGlzLmRpcnR5XyB8fCBkaXJ0eTtcbiAgICAgIH1cbiAgICB9LmJpbmQodGhpcyk7XG4gICAgaWYgKHZlY3RvckxheWVyUmVuZGVyT3JkZXIpIHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi4vLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn0gKi9cbiAgICAgIHZhciBmZWF0dXJlcyA9IFtdO1xuICAgICAgdmVjdG9yU291cmNlLmZvckVhY2hGZWF0dXJlSW5FeHRlbnQoZXh0ZW50LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgICAgICAgICBmZWF0dXJlcy5wdXNoKGZlYXR1cmUpO1xuICAgICAgICB9KTtcbiAgICAgIGZlYXR1cmVzLnNvcnQodmVjdG9yTGF5ZXJSZW5kZXJPcmRlcik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBmZWF0dXJlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIHJlbmRlcihmZWF0dXJlc1tpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZlY3RvclNvdXJjZS5mb3JFYWNoRmVhdHVyZUluRXh0ZW50KGV4dGVudCwgcmVuZGVyKTtcbiAgICB9XG4gICAgcmVwbGF5R3JvdXAuZmluaXNoKCk7XG5cbiAgICB0aGlzLnJlbmRlcmVkUmVzb2x1dGlvbl8gPSByZXNvbHV0aW9uO1xuICAgIHRoaXMucmVuZGVyZWRSZXZpc2lvbl8gPSB2ZWN0b3JMYXllclJldmlzaW9uO1xuICAgIHRoaXMucmVuZGVyZWRSZW5kZXJPcmRlcl8gPSB2ZWN0b3JMYXllclJlbmRlck9yZGVyO1xuICAgIHRoaXMucmVuZGVyZWRFeHRlbnRfID0gZXh0ZW50O1xuICAgIHRoaXMucmVwbGF5R3JvdXBfID0gcmVwbGF5R3JvdXA7XG5cbiAgICB0aGlzLnJlcGxheUdyb3VwQ2hhbmdlZCA9IHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHR8QXJyYXk8aW1wb3J0KFwiLi4vLi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdD59IHN0eWxlcyBUaGUgc3R5bGUgb3IgYXJyYXkgb2Ygc3R5bGVzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3JlbmRlci9jYW52YXMvUmVwbGF5R3JvdXAuanNcIikuZGVmYXVsdH0gcmVwbGF5R3JvdXAgUmVwbGF5IGdyb3VwLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgYW4gaW1hZ2UgaXMgbG9hZGluZy5cbiAgICovXG4gIENhbnZhc1ZlY3RvckxheWVyUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckZlYXR1cmUgPSBmdW5jdGlvbiByZW5kZXJGZWF0dXJlJDEgKGZlYXR1cmUsIHJlc29sdXRpb24sIHBpeGVsUmF0aW8sIHN0eWxlcywgcmVwbGF5R3JvdXApIHtcbiAgICBpZiAoIXN0eWxlcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgbG9hZGluZyA9IGZhbHNlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHN0eWxlcykpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHN0eWxlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGxvYWRpbmcgPSByZW5kZXJGZWF0dXJlKFxuICAgICAgICAgIHJlcGxheUdyb3VwLCBmZWF0dXJlLCBzdHlsZXNbaV0sXG4gICAgICAgICAgZ2V0U3F1YXJlZFJlbmRlclRvbGVyYW5jZShyZXNvbHV0aW9uLCBwaXhlbFJhdGlvKSxcbiAgICAgICAgICB0aGlzLmhhbmRsZVN0eWxlSW1hZ2VDaGFuZ2VfLCB0aGlzKSB8fCBsb2FkaW5nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2FkaW5nID0gcmVuZGVyRmVhdHVyZShcbiAgICAgICAgcmVwbGF5R3JvdXAsIGZlYXR1cmUsIHN0eWxlcyxcbiAgICAgICAgZ2V0U3F1YXJlZFJlbmRlclRvbGVyYW5jZShyZXNvbHV0aW9uLCBwaXhlbFJhdGlvKSxcbiAgICAgICAgdGhpcy5oYW5kbGVTdHlsZUltYWdlQ2hhbmdlXywgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBsb2FkaW5nO1xuICB9O1xuXG4gIHJldHVybiBDYW52YXNWZWN0b3JMYXllclJlbmRlcmVyO1xufShDYW52YXNMYXllclJlbmRlcmVyKSk7XG5cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdGhpcyByZW5kZXJlciBoYW5kbGVzIHRoZSBwcm92aWRlZCBsYXllci5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdH0gbGF5ZXIgVGhlIGNhbmRpZGF0ZSBsYXllci5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSByZW5kZXJlciBjYW4gcmVuZGVyIHRoZSBsYXllci5cbiAqL1xuQ2FudmFzVmVjdG9yTGF5ZXJSZW5kZXJlclsnaGFuZGxlcyddID0gZnVuY3Rpb24obGF5ZXIpIHtcbiAgcmV0dXJuIGxheWVyLmdldFR5cGUoKSA9PT0gTGF5ZXJUeXBlLlZFQ1RPUjtcbn07XG5cblxuLyoqXG4gKiBDcmVhdGUgYSBsYXllciByZW5kZXJlci5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHR9IG1hcFJlbmRlcmVyIFRoZSBtYXAgcmVuZGVyZXIuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHR9IGxheWVyIFRoZSBsYXllciB0byBiZSByZW5kZXJlcmQuXG4gKiBAcmV0dXJuIHtDYW52YXNWZWN0b3JMYXllclJlbmRlcmVyfSBUaGUgbGF5ZXIgcmVuZGVyZXIuXG4gKi9cbkNhbnZhc1ZlY3RvckxheWVyUmVuZGVyZXJbJ2NyZWF0ZSddID0gZnVuY3Rpb24obWFwUmVuZGVyZXIsIGxheWVyKSB7XG4gIHJldHVybiBuZXcgQ2FudmFzVmVjdG9yTGF5ZXJSZW5kZXJlcigvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2xheWVyL1ZlY3Rvci5qc1wiKS5kZWZhdWx0fSAqLyAobGF5ZXIpKTtcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgQ2FudmFzVmVjdG9yTGF5ZXJSZW5kZXJlcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VmVjdG9yTGF5ZXIuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlcmVyL2NhbnZhcy9WZWN0b3JUaWxlTGF5ZXJcbiAqL1xuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4uLy4uL3V0aWwuanMnO1xuaW1wb3J0IExheWVyVHlwZSBmcm9tICcuLi8uLi9MYXllclR5cGUuanMnO1xuaW1wb3J0IFRpbGVTdGF0ZSBmcm9tICcuLi8uLi9UaWxlU3RhdGUuanMnO1xuaW1wb3J0IFZpZXdIaW50IGZyb20gJy4uLy4uL1ZpZXdIaW50LmpzJztcbmltcG9ydCB7Y3JlYXRlQ2FudmFzQ29udGV4dDJEfSBmcm9tICcuLi8uLi9kb20uanMnO1xuaW1wb3J0IHtsaXN0ZW4sIHVubGlzdGVufSBmcm9tICcuLi8uLi9ldmVudHMuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi8uLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCByYnVzaCBmcm9tICdyYnVzaCc7XG5pbXBvcnQge2J1ZmZlciwgY29udGFpbnNDb29yZGluYXRlLCBlcXVhbHMsIGdldEludGVyc2VjdGlvbiwgZ2V0VG9wTGVmdCwgaW50ZXJzZWN0c30gZnJvbSAnLi4vLi4vZXh0ZW50LmpzJztcbmltcG9ydCBWZWN0b3JUaWxlUmVuZGVyVHlwZSBmcm9tICcuLi8uLi9sYXllci9WZWN0b3JUaWxlUmVuZGVyVHlwZS5qcyc7XG5pbXBvcnQge2VxdWl2YWxlbnQgYXMgZXF1aXZhbGVudFByb2plY3Rpb259IGZyb20gJy4uLy4uL3Byb2ouanMnO1xuaW1wb3J0IFVuaXRzIGZyb20gJy4uLy4uL3Byb2ovVW5pdHMuanMnO1xuaW1wb3J0IFJlcGxheVR5cGUgZnJvbSAnLi4vLi4vcmVuZGVyL1JlcGxheVR5cGUuanMnO1xuaW1wb3J0IHtsYWJlbENhY2hlLCByb3RhdGVBdE9mZnNldH0gZnJvbSAnLi4vLi4vcmVuZGVyL2NhbnZhcy5qcyc7XG5pbXBvcnQgQ2FudmFzUmVwbGF5R3JvdXAsIHtyZXBsYXlEZWNsdXR0ZXJ9IGZyb20gJy4uLy4uL3JlbmRlci9jYW52YXMvUmVwbGF5R3JvdXAuanMnO1xuaW1wb3J0IHtPUkRFUn0gZnJvbSAnLi4vLi4vcmVuZGVyL3JlcGxheS5qcyc7XG5pbXBvcnQgQ2FudmFzVGlsZUxheWVyUmVuZGVyZXIgZnJvbSAnLi9UaWxlTGF5ZXIuanMnO1xuaW1wb3J0IHtnZXRTcXVhcmVkVG9sZXJhbmNlIGFzIGdldFNxdWFyZWRSZW5kZXJUb2xlcmFuY2UsIHJlbmRlckZlYXR1cmV9IGZyb20gJy4uL3ZlY3Rvci5qcyc7XG5pbXBvcnQge1xuICBjcmVhdGUgYXMgY3JlYXRlVHJhbnNmb3JtLFxuICBjb21wb3NlIGFzIGNvbXBvc2VUcmFuc2Zvcm0sXG4gIHJlc2V0IGFzIHJlc2V0VHJhbnNmb3JtLFxuICBzY2FsZSBhcyBzY2FsZVRyYW5zZm9ybSxcbiAgdHJhbnNsYXRlIGFzIHRyYW5zbGF0ZVRyYW5zZm9ybVxufSBmcm9tICcuLi8uLi90cmFuc2Zvcm0uanMnO1xuXG5cbi8qKlxuICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBBcnJheTxpbXBvcnQoXCIuLi8uLi9yZW5kZXIvUmVwbGF5VHlwZS5qc1wiKS5kZWZhdWx0Pj59XG4gKi9cbnZhciBJTUFHRV9SRVBMQVlTID0ge1xuICAnaW1hZ2UnOiBbUmVwbGF5VHlwZS5QT0xZR09OLCBSZXBsYXlUeXBlLkNJUkNMRSxcbiAgICBSZXBsYXlUeXBlLkxJTkVfU1RSSU5HLCBSZXBsYXlUeXBlLklNQUdFLCBSZXBsYXlUeXBlLlRFWFRdLFxuICAnaHlicmlkJzogW1JlcGxheVR5cGUuUE9MWUdPTiwgUmVwbGF5VHlwZS5MSU5FX1NUUklOR11cbn07XG5cblxuLyoqXG4gKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIEFycmF5PGltcG9ydChcIi4uLy4uL3JlbmRlci9SZXBsYXlUeXBlLmpzXCIpLmRlZmF1bHQ+Pn1cbiAqL1xudmFyIFZFQ1RPUl9SRVBMQVlTID0ge1xuICAnaW1hZ2UnOiBbUmVwbGF5VHlwZS5ERUZBVUxUXSxcbiAgJ2h5YnJpZCc6IFtSZXBsYXlUeXBlLklNQUdFLCBSZXBsYXlUeXBlLlRFWFQsIFJlcGxheVR5cGUuREVGQVVMVF0sXG4gICd2ZWN0b3InOiBPUkRFUlxufTtcblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIENhbnZhcyByZW5kZXJlciBmb3IgdmVjdG9yIHRpbGUgbGF5ZXJzLlxuICogQGFwaVxuICovXG52YXIgQ2FudmFzVmVjdG9yVGlsZUxheWVyUmVuZGVyZXIgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChDYW52YXNUaWxlTGF5ZXJSZW5kZXJlcikge1xuICBmdW5jdGlvbiBDYW52YXNWZWN0b3JUaWxlTGF5ZXJSZW5kZXJlcihsYXllcikge1xuXG4gICAgQ2FudmFzVGlsZUxheWVyUmVuZGVyZXIuY2FsbCh0aGlzLCBsYXllciwgdHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBEZWNsdXR0ZXIgdHJlZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZGVjbHV0dGVyVHJlZV8gPSBsYXllci5nZXREZWNsdXR0ZXIoKSA/IHJidXNoKDksIHVuZGVmaW5lZCkgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmRpcnR5XyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZWRMYXllclJldmlzaW9uXztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uLy4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19XG4gICAgICovXG4gICAgdGhpcy50bXBUcmFuc2Zvcm1fID0gY3JlYXRlVHJhbnNmb3JtKCk7XG5cbiAgICB2YXIgcmVuZGVyTW9kZSA9IGxheWVyLmdldFJlbmRlck1vZGUoKTtcblxuICAgIC8vIFVzZSBsb3dlciByZXNvbHV0aW9uIGZvciBwdXJlIHZlY3RvciByZW5kZXJpbmcuIENsb3Nlc3QgcmVzb2x1dGlvbiBvdGhlcndpc2UuXG4gICAgdGhpcy56RGlyZWN0aW9uID0gcmVuZGVyTW9kZSA9PT0gVmVjdG9yVGlsZVJlbmRlclR5cGUuVkVDVE9SID8gMSA6IDA7XG5cbiAgICBpZiAocmVuZGVyTW9kZSAhPT0gVmVjdG9yVGlsZVJlbmRlclR5cGUuVkVDVE9SKSB7XG4gICAgICB0aGlzLmNvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0MkQoKTtcbiAgICB9XG5cblxuICAgIGxpc3RlbihsYWJlbENhY2hlLCBFdmVudFR5cGUuQ0xFQVIsIHRoaXMuaGFuZGxlRm9udHNDaGFuZ2VkXywgdGhpcyk7XG5cbiAgfVxuXG4gIGlmICggQ2FudmFzVGlsZUxheWVyUmVuZGVyZXIgKSBDYW52YXNWZWN0b3JUaWxlTGF5ZXJSZW5kZXJlci5fX3Byb3RvX18gPSBDYW52YXNUaWxlTGF5ZXJSZW5kZXJlcjtcbiAgQ2FudmFzVmVjdG9yVGlsZUxheWVyUmVuZGVyZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ2FudmFzVGlsZUxheWVyUmVuZGVyZXIgJiYgQ2FudmFzVGlsZUxheWVyUmVuZGVyZXIucHJvdG90eXBlICk7XG4gIENhbnZhc1ZlY3RvclRpbGVMYXllclJlbmRlcmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhbnZhc1ZlY3RvclRpbGVMYXllclJlbmRlcmVyO1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQ2FudmFzVmVjdG9yVGlsZUxheWVyUmVuZGVyZXIucHJvdG90eXBlLmRpc3Bvc2VJbnRlcm5hbCA9IGZ1bmN0aW9uIGRpc3Bvc2VJbnRlcm5hbCAoKSB7XG4gICAgdW5saXN0ZW4obGFiZWxDYWNoZSwgRXZlbnRUeXBlLkNMRUFSLCB0aGlzLmhhbmRsZUZvbnRzQ2hhbmdlZF8sIHRoaXMpO1xuICAgIENhbnZhc1RpbGVMYXllclJlbmRlcmVyLnByb3RvdHlwZS5kaXNwb3NlSW50ZXJuYWwuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENhbnZhc1ZlY3RvclRpbGVMYXllclJlbmRlcmVyLnByb3RvdHlwZS5nZXRUaWxlID0gZnVuY3Rpb24gZ2V0VGlsZSAoeiwgeCwgeSwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbikge1xuICAgIHZhciB0aWxlID0gQ2FudmFzVGlsZUxheWVyUmVuZGVyZXIucHJvdG90eXBlLmdldFRpbGUuY2FsbCh0aGlzLCB6LCB4LCB5LCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKTtcbiAgICBpZiAodGlsZS5nZXRTdGF0ZSgpID09PSBUaWxlU3RhdGUuTE9BREVEKSB7XG4gICAgICB0aGlzLmNyZWF0ZVJlcGxheUdyb3VwXygvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL1ZlY3RvckltYWdlVGlsZS5qc1wiKS5kZWZhdWx0fSAqLyAodGlsZSksIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pO1xuICAgICAgaWYgKHRoaXMuY29udGV4dCkge1xuICAgICAgICB0aGlzLnJlbmRlclRpbGVJbWFnZV8oLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9WZWN0b3JJbWFnZVRpbGUuanNcIikuZGVmYXVsdH0gKi8gKHRpbGUpLCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRpbGU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNWZWN0b3JUaWxlTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuZ2V0VGlsZUltYWdlID0gZnVuY3Rpb24gZ2V0VGlsZUltYWdlICh0aWxlKSB7XG4gICAgdmFyIHRpbGVMYXllciA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vbGF5ZXIvVGlsZS5qc1wiKS5kZWZhdWx0fSAqLyAodGhpcy5nZXRMYXllcigpKTtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9WZWN0b3JJbWFnZVRpbGUuanNcIikuZGVmYXVsdH0gKi8gKHRpbGUpLmdldEltYWdlKHRpbGVMYXllcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNWZWN0b3JUaWxlTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUucHJlcGFyZUZyYW1lID0gZnVuY3Rpb24gcHJlcGFyZUZyYW1lIChmcmFtZVN0YXRlLCBsYXllclN0YXRlKSB7XG4gICAgdmFyIGxheWVyID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9sYXllci9WZWN0b3IuanNcIikuZGVmYXVsdH0gKi8gKHRoaXMuZ2V0TGF5ZXIoKSk7XG4gICAgdmFyIGxheWVyUmV2aXNpb24gPSBsYXllci5nZXRSZXZpc2lvbigpO1xuICAgIGlmICh0aGlzLnJlbmRlcmVkTGF5ZXJSZXZpc2lvbl8gIT0gbGF5ZXJSZXZpc2lvbikge1xuICAgICAgdGhpcy5yZW5kZXJlZFRpbGVzLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIHRoaXMucmVuZGVyZWRMYXllclJldmlzaW9uXyA9IGxheWVyUmV2aXNpb247XG4gICAgcmV0dXJuIENhbnZhc1RpbGVMYXllclJlbmRlcmVyLnByb3RvdHlwZS5wcmVwYXJlRnJhbWUuY2FsbCh0aGlzLCBmcmFtZVN0YXRlLCBsYXllclN0YXRlKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9WZWN0b3JJbWFnZVRpbGUuanNcIikuZGVmYXVsdH0gdGlsZSBUaWxlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQ2FudmFzVmVjdG9yVGlsZUxheWVyUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZVJlcGxheUdyb3VwXyA9IGZ1bmN0aW9uIGNyZWF0ZVJlcGxheUdyb3VwXyAodGlsZSwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGxheWVyID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9sYXllci9WZWN0b3IuanNcIikuZGVmYXVsdH0gKi8gKHRoaXMuZ2V0TGF5ZXIoKSk7XG4gICAgdmFyIHJldmlzaW9uID0gbGF5ZXIuZ2V0UmV2aXNpb24oKTtcbiAgICB2YXIgcmVuZGVyT3JkZXIgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL3JlbmRlci5qc1wiKS5PcmRlckZ1bmN0aW9ufSAqLyAobGF5ZXIuZ2V0UmVuZGVyT3JkZXIoKSkgfHwgbnVsbDtcblxuICAgIHZhciByZXBsYXlTdGF0ZSA9IHRpbGUuZ2V0UmVwbGF5U3RhdGUobGF5ZXIpO1xuICAgIGlmICghcmVwbGF5U3RhdGUuZGlydHkgJiYgcmVwbGF5U3RhdGUucmVuZGVyZWRSZXZpc2lvbiA9PSByZXZpc2lvbiAmJlxuICAgICAgICByZXBsYXlTdGF0ZS5yZW5kZXJlZFJlbmRlck9yZGVyID09IHJlbmRlck9yZGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vc291cmNlL1ZlY3RvclRpbGUuanNcIikuZGVmYXVsdH0gKi8gKGxheWVyLmdldFNvdXJjZSgpKTtcbiAgICB2YXIgc291cmNlVGlsZUdyaWQgPSBzb3VyY2UuZ2V0VGlsZUdyaWQoKTtcbiAgICB2YXIgdGlsZUdyaWQgPSBzb3VyY2UuZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICAgIHZhciByZXNvbHV0aW9uID0gdGlsZUdyaWQuZ2V0UmVzb2x1dGlvbih0aWxlLnRpbGVDb29yZFswXSk7XG4gICAgdmFyIHRpbGVFeHRlbnQgPSB0aWxlLmV4dGVudDtcblxuICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCB0LCB0dCApIHtcbiAgICAgIHZhciBzb3VyY2VUaWxlID0gdGlsZS5nZXRUaWxlKHRpbGUudGlsZUtleXNbdF0pO1xuICAgICAgaWYgKHNvdXJjZVRpbGUuZ2V0U3RhdGUoKSAhPSBUaWxlU3RhdGUuTE9BREVEKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZVRpbGVDb29yZCA9IHNvdXJjZVRpbGUudGlsZUNvb3JkO1xuICAgICAgdmFyIHNvdXJjZVRpbGVFeHRlbnQgPSBzb3VyY2VUaWxlR3JpZC5nZXRUaWxlQ29vcmRFeHRlbnQoc291cmNlVGlsZUNvb3JkKTtcbiAgICAgIHZhciBzaGFyZWRFeHRlbnQgPSBnZXRJbnRlcnNlY3Rpb24odGlsZUV4dGVudCwgc291cmNlVGlsZUV4dGVudCk7XG4gICAgICB2YXIgYnVmZmVyZWRFeHRlbnQgPSBlcXVhbHMoc291cmNlVGlsZUV4dGVudCwgc2hhcmVkRXh0ZW50KSA/IG51bGwgOlxuICAgICAgICBidWZmZXIoc2hhcmVkRXh0ZW50LCBsYXllci5nZXRSZW5kZXJCdWZmZXIoKSAqIHJlc29sdXRpb24sIHRoaXMkMS50bXBFeHRlbnQpO1xuICAgICAgdmFyIHRpbGVQcm9qZWN0aW9uID0gc291cmNlVGlsZS5nZXRQcm9qZWN0aW9uKCk7XG4gICAgICB2YXIgcmVwcm9qZWN0ID0gZmFsc2U7XG4gICAgICBpZiAoIWVxdWl2YWxlbnRQcm9qZWN0aW9uKHByb2plY3Rpb24sIHRpbGVQcm9qZWN0aW9uKSkge1xuICAgICAgICByZXByb2plY3QgPSB0cnVlO1xuICAgICAgICBzb3VyY2VUaWxlLnNldFByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gICAgICB9XG4gICAgICByZXBsYXlTdGF0ZS5kaXJ0eSA9IGZhbHNlO1xuICAgICAgdmFyIHJlcGxheUdyb3VwID0gbmV3IENhbnZhc1JlcGxheUdyb3VwKDAsIHNoYXJlZEV4dGVudCwgcmVzb2x1dGlvbixcbiAgICAgICAgcGl4ZWxSYXRpbywgc291cmNlLmdldE92ZXJsYXBzKCksIHRoaXMkMS5kZWNsdXR0ZXJUcmVlXywgbGF5ZXIuZ2V0UmVuZGVyQnVmZmVyKCkpO1xuICAgICAgdmFyIHNxdWFyZWRUb2xlcmFuY2UgPSBnZXRTcXVhcmVkUmVuZGVyVG9sZXJhbmNlKHJlc29sdXRpb24sIHBpeGVsUmF0aW8pO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgICAgICogQHRoaXMge0NhbnZhc1ZlY3RvclRpbGVMYXllclJlbmRlcmVyfVxuICAgICAgICovXG4gICAgICB2YXIgcmVuZGVyID0gZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgICAgICB2YXIgc3R5bGVzO1xuICAgICAgICB2YXIgc3R5bGVGdW5jdGlvbiA9IGZlYXR1cmUuZ2V0U3R5bGVGdW5jdGlvbigpIHx8IGxheWVyLmdldFN0eWxlRnVuY3Rpb24oKTtcbiAgICAgICAgaWYgKHN0eWxlRnVuY3Rpb24pIHtcbiAgICAgICAgICBzdHlsZXMgPSBzdHlsZUZ1bmN0aW9uKGZlYXR1cmUsIHJlc29sdXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHlsZXMpIHtcbiAgICAgICAgICB2YXIgZGlydHkgPSB0aGlzLnJlbmRlckZlYXR1cmUoZmVhdHVyZSwgc3F1YXJlZFRvbGVyYW5jZSwgc3R5bGVzLCByZXBsYXlHcm91cCk7XG4gICAgICAgICAgdGhpcy5kaXJ0eV8gPSB0aGlzLmRpcnR5XyB8fCBkaXJ0eTtcbiAgICAgICAgICByZXBsYXlTdGF0ZS5kaXJ0eSA9IHJlcGxheVN0YXRlLmRpcnR5IHx8IGRpcnR5O1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgZmVhdHVyZXMgPSBzb3VyY2VUaWxlLmdldEZlYXR1cmVzKCk7XG4gICAgICBpZiAocmVuZGVyT3JkZXIgJiYgcmVuZGVyT3JkZXIgIT09IHJlcGxheVN0YXRlLnJlbmRlcmVkUmVuZGVyT3JkZXIpIHtcbiAgICAgICAgZmVhdHVyZXMuc29ydChyZW5kZXJPcmRlcik7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBmZWF0dXJlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIHZhciBmZWF0dXJlID0gZmVhdHVyZXNbaV07XG4gICAgICAgIGlmIChyZXByb2plY3QpIHtcbiAgICAgICAgICBpZiAodGlsZVByb2plY3Rpb24uZ2V0VW5pdHMoKSA9PSBVbml0cy5USUxFX1BJWEVMUykge1xuICAgICAgICAgICAgLy8gcHJvamVjdGVkIHRpbGUgZXh0ZW50XG4gICAgICAgICAgICB0aWxlUHJvamVjdGlvbi5zZXRXb3JsZEV4dGVudChzb3VyY2VUaWxlRXh0ZW50KTtcbiAgICAgICAgICAgIC8vIHRpbGUgZXh0ZW50IGluIHRpbGUgcGl4ZWwgc3BhY2VcbiAgICAgICAgICAgIHRpbGVQcm9qZWN0aW9uLnNldEV4dGVudChzb3VyY2VUaWxlLmdldEV4dGVudCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmVhdHVyZS5nZXRHZW9tZXRyeSgpLnRyYW5zZm9ybSh0aWxlUHJvamVjdGlvbiwgcHJvamVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFidWZmZXJlZEV4dGVudCB8fCBpbnRlcnNlY3RzKGJ1ZmZlcmVkRXh0ZW50LCBmZWF0dXJlLmdldEdlb21ldHJ5KCkuZ2V0RXh0ZW50KCkpKSB7XG4gICAgICAgICAgcmVuZGVyLmNhbGwodGhpcyQxLCBmZWF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVwbGF5R3JvdXAuZmluaXNoKCk7XG4gICAgICBzb3VyY2VUaWxlLnNldFJlcGxheUdyb3VwKGxheWVyLCB0aWxlLnRpbGVDb29yZC50b1N0cmluZygpLCByZXBsYXlHcm91cCk7XG4gICAgfTtcblxuICAgIGZvciAodmFyIHQgPSAwLCB0dCA9IHRpbGUudGlsZUtleXMubGVuZ3RoOyB0IDwgdHQ7ICsrdCkgbG9vcCggdCwgdHQgKTtcbiAgICByZXBsYXlTdGF0ZS5yZW5kZXJlZFJldmlzaW9uID0gcmV2aXNpb247XG4gICAgcmVwbGF5U3RhdGUucmVuZGVyZWRSZW5kZXJPcmRlciA9IHJlbmRlck9yZGVyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQ2FudmFzVmVjdG9yVGlsZUxheWVyUmVuZGVyZXIucHJvdG90eXBlLmZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlID0gZnVuY3Rpb24gZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGUgKGNvb3JkaW5hdGUsIGZyYW1lU3RhdGUsIGhpdFRvbGVyYW5jZSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICB2YXIgcmVzb2x1dGlvbiA9IGZyYW1lU3RhdGUudmlld1N0YXRlLnJlc29sdXRpb247XG4gICAgdmFyIHJvdGF0aW9uID0gZnJhbWVTdGF0ZS52aWV3U3RhdGUucm90YXRpb247XG4gICAgaGl0VG9sZXJhbmNlID0gaGl0VG9sZXJhbmNlID09IHVuZGVmaW5lZCA/IDAgOiBoaXRUb2xlcmFuY2U7XG4gICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcigpO1xuICAgIC8qKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIGJvb2xlYW4+fSAqL1xuICAgIHZhciBmZWF0dXJlcyA9IHt9O1xuXG4gICAgdmFyIHJlbmRlcmVkVGlsZXMgPSAvKiogQHR5cGUge0FycmF5PGltcG9ydChcIi4uLy4uL1ZlY3RvckltYWdlVGlsZS5qc1wiKS5kZWZhdWx0Pn0gKi8gKHRoaXMucmVuZGVyZWRUaWxlcyk7XG5cbiAgICB2YXIgYnVmZmVyZWRFeHRlbnQsIGZvdW5kO1xuICAgIHZhciBpLCBpaTtcbiAgICBmb3IgKGkgPSAwLCBpaSA9IHJlbmRlcmVkVGlsZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgdmFyIHRpbGUgPSByZW5kZXJlZFRpbGVzW2ldO1xuICAgICAgYnVmZmVyZWRFeHRlbnQgPSBidWZmZXIodGlsZS5leHRlbnQsIGhpdFRvbGVyYW5jZSAqIHJlc29sdXRpb24sIGJ1ZmZlcmVkRXh0ZW50KTtcbiAgICAgIGlmICghY29udGFpbnNDb29yZGluYXRlKGJ1ZmZlcmVkRXh0ZW50LCBjb29yZGluYXRlKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIHQgPSAwLCB0dCA9IHRpbGUudGlsZUtleXMubGVuZ3RoOyB0IDwgdHQ7ICsrdCkge1xuICAgICAgICB2YXIgc291cmNlVGlsZSA9IHRpbGUuZ2V0VGlsZSh0aWxlLnRpbGVLZXlzW3RdKTtcbiAgICAgICAgaWYgKHNvdXJjZVRpbGUuZ2V0U3RhdGUoKSAhPSBUaWxlU3RhdGUuTE9BREVEKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcGxheUdyb3VwID0gLyoqIEB0eXBlIHtDYW52YXNSZXBsYXlHcm91cH0gKi8gKHNvdXJjZVRpbGUuZ2V0UmVwbGF5R3JvdXAobGF5ZXIsXG4gICAgICAgICAgdGlsZS50aWxlQ29vcmQudG9TdHJpbmcoKSkpO1xuICAgICAgICBmb3VuZCA9IGZvdW5kIHx8IHJlcGxheUdyb3VwLmZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlKGNvb3JkaW5hdGUsIHJlc29sdXRpb24sIHJvdGF0aW9uLCBoaXRUb2xlcmFuY2UsIHt9LFxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgICAgICAgICAqIEByZXR1cm4gez99IENhbGxiYWNrIHJlc3VsdC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBmdW5jdGlvbihmZWF0dXJlKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gZ2V0VWlkKGZlYXR1cmUpO1xuICAgICAgICAgICAgaWYgKCEoa2V5IGluIGZlYXR1cmVzKSkge1xuICAgICAgICAgICAgICBmZWF0dXJlc1trZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgZmVhdHVyZSwgbGF5ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIG51bGwpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm91bmQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vVmVjdG9yVGlsZS5qc1wiKS5kZWZhdWx0fSB0aWxlIFRpbGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uLy4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19IHRyYW5zZm9ybSBUcmFuc2Zvcm0uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBDYW52YXNWZWN0b3JUaWxlTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuZ2V0UmVwbGF5VHJhbnNmb3JtXyA9IGZ1bmN0aW9uIGdldFJlcGxheVRyYW5zZm9ybV8gKHRpbGUsIGZyYW1lU3RhdGUpIHtcbiAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKCk7XG4gICAgdmFyIHNvdXJjZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vc291cmNlL1ZlY3RvclRpbGUuanNcIikuZGVmYXVsdH0gKi8gKGxheWVyLmdldFNvdXJjZSgpKTtcbiAgICB2YXIgdGlsZUdyaWQgPSBzb3VyY2UuZ2V0VGlsZUdyaWQoKTtcbiAgICB2YXIgdGlsZUNvb3JkID0gdGlsZS50aWxlQ29vcmQ7XG4gICAgdmFyIHRpbGVSZXNvbHV0aW9uID0gdGlsZUdyaWQuZ2V0UmVzb2x1dGlvbih0aWxlQ29vcmRbMF0pO1xuICAgIHZhciB2aWV3U3RhdGUgPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZTtcbiAgICB2YXIgcGl4ZWxSYXRpbyA9IGZyYW1lU3RhdGUucGl4ZWxSYXRpbztcbiAgICB2YXIgcmVuZGVyUmVzb2x1dGlvbiA9IHZpZXdTdGF0ZS5yZXNvbHV0aW9uIC8gcGl4ZWxSYXRpbztcbiAgICB2YXIgdGlsZUV4dGVudCA9IHRpbGVHcmlkLmdldFRpbGVDb29yZEV4dGVudCh0aWxlQ29vcmQsIHRoaXMudG1wRXh0ZW50KTtcbiAgICB2YXIgY2VudGVyID0gdmlld1N0YXRlLmNlbnRlcjtcbiAgICB2YXIgb3JpZ2luID0gZ2V0VG9wTGVmdCh0aWxlRXh0ZW50KTtcbiAgICB2YXIgc2l6ZSA9IGZyYW1lU3RhdGUuc2l6ZTtcbiAgICB2YXIgb2Zmc2V0WCA9IE1hdGgucm91bmQocGl4ZWxSYXRpbyAqIHNpemVbMF0gLyAyKTtcbiAgICB2YXIgb2Zmc2V0WSA9IE1hdGgucm91bmQocGl4ZWxSYXRpbyAqIHNpemVbMV0gLyAyKTtcbiAgICByZXR1cm4gY29tcG9zZVRyYW5zZm9ybSh0aGlzLnRtcFRyYW5zZm9ybV8sXG4gICAgICBvZmZzZXRYLCBvZmZzZXRZLFxuICAgICAgdGlsZVJlc29sdXRpb24gLyByZW5kZXJSZXNvbHV0aW9uLCB0aWxlUmVzb2x1dGlvbiAvIHJlbmRlclJlc29sdXRpb24sXG4gICAgICB2aWV3U3RhdGUucm90YXRpb24sXG4gICAgICAob3JpZ2luWzBdIC0gY2VudGVyWzBdKSAvIHRpbGVSZXNvbHV0aW9uLFxuICAgICAgKGNlbnRlclsxXSAtIG9yaWdpblsxXSkgLyB0aWxlUmVzb2x1dGlvbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHR9IGV2ZW50IEV2ZW50LlxuICAgKi9cbiAgQ2FudmFzVmVjdG9yVGlsZUxheWVyUmVuZGVyZXIucHJvdG90eXBlLmhhbmRsZUZvbnRzQ2hhbmdlZF8gPSBmdW5jdGlvbiBoYW5kbGVGb250c0NoYW5nZWRfIChldmVudCkge1xuICAgIHZhciBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKTtcbiAgICBpZiAobGF5ZXIuZ2V0VmlzaWJsZSgpICYmIHRoaXMucmVuZGVyZWRMYXllclJldmlzaW9uXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsYXllci5jaGFuZ2VkKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgY2hhbmdlcyBpbiBpbWFnZSBzdHlsZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdH0gZXZlbnQgSW1hZ2Ugc3R5bGUgY2hhbmdlIGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQ2FudmFzVmVjdG9yVGlsZUxheWVyUmVuZGVyZXIucHJvdG90eXBlLmhhbmRsZVN0eWxlSW1hZ2VDaGFuZ2VfID0gZnVuY3Rpb24gaGFuZGxlU3R5bGVJbWFnZUNoYW5nZV8gKGV2ZW50KSB7XG4gICAgdGhpcy5yZW5kZXJJZlJlYWR5QW5kVmlzaWJsZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQ2FudmFzVmVjdG9yVGlsZUxheWVyUmVuZGVyZXIucHJvdG90eXBlLnBvc3RDb21wb3NlID0gZnVuY3Rpb24gcG9zdENvbXBvc2UgKGNvbnRleHQsIGZyYW1lU3RhdGUsIGxheWVyU3RhdGUpIHtcbiAgICB2YXIgbGF5ZXIgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2xheWVyL1ZlY3Rvci5qc1wiKS5kZWZhdWx0fSAqLyAodGhpcy5nZXRMYXllcigpKTtcbiAgICB2YXIgcmVuZGVyTW9kZSA9IGxheWVyLmdldFJlbmRlck1vZGUoKTtcbiAgICBpZiAocmVuZGVyTW9kZSAhPSBWZWN0b3JUaWxlUmVuZGVyVHlwZS5JTUFHRSkge1xuICAgICAgdmFyIGRlY2x1dHRlclJlcGxheXMgPSBsYXllci5nZXREZWNsdXR0ZXIoKSA/IHt9IDogbnVsbDtcbiAgICAgIHZhciBzb3VyY2UgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL3NvdXJjZS9WZWN0b3JUaWxlLmpzXCIpLmRlZmF1bHR9ICovIChsYXllci5nZXRTb3VyY2UoKSk7XG4gICAgICB2YXIgcmVwbGF5VHlwZXMgPSBWRUNUT1JfUkVQTEFZU1tyZW5kZXJNb2RlXTtcbiAgICAgIHZhciBwaXhlbFJhdGlvID0gZnJhbWVTdGF0ZS5waXhlbFJhdGlvO1xuICAgICAgdmFyIHJvdGF0aW9uID0gZnJhbWVTdGF0ZS52aWV3U3RhdGUucm90YXRpb247XG4gICAgICB2YXIgc2l6ZSA9IGZyYW1lU3RhdGUuc2l6ZTtcbiAgICAgIHZhciBvZmZzZXRYLCBvZmZzZXRZO1xuICAgICAgaWYgKHJvdGF0aW9uKSB7XG4gICAgICAgIG9mZnNldFggPSBNYXRoLnJvdW5kKHBpeGVsUmF0aW8gKiBzaXplWzBdIC8gMik7XG4gICAgICAgIG9mZnNldFkgPSBNYXRoLnJvdW5kKHBpeGVsUmF0aW8gKiBzaXplWzFdIC8gMik7XG4gICAgICAgIHJvdGF0ZUF0T2Zmc2V0KGNvbnRleHQsIC1yb3RhdGlvbiwgb2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgICB9XG4gICAgICBpZiAoZGVjbHV0dGVyUmVwbGF5cykge1xuICAgICAgICB0aGlzLmRlY2x1dHRlclRyZWVfLmNsZWFyKCk7XG4gICAgICB9XG4gICAgICB2YXIgdmlld0hpbnRzID0gZnJhbWVTdGF0ZS52aWV3SGludHM7XG4gICAgICB2YXIgc25hcFRvUGl4ZWwgPSAhKHZpZXdIaW50c1tWaWV3SGludC5BTklNQVRJTkddIHx8IHZpZXdIaW50c1tWaWV3SGludC5JTlRFUkFDVElOR10pO1xuICAgICAgdmFyIHRpbGVzID0gdGhpcy5yZW5kZXJlZFRpbGVzO1xuICAgICAgdmFyIHRpbGVHcmlkID0gc291cmNlLmdldFRpbGVHcmlkRm9yUHJvamVjdGlvbihmcmFtZVN0YXRlLnZpZXdTdGF0ZS5wcm9qZWN0aW9uKTtcbiAgICAgIHZhciBjbGlwcyA9IFtdO1xuICAgICAgdmFyIHpzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gdGlsZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIHRpbGUgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL1ZlY3RvckltYWdlVGlsZS5qc1wiKS5kZWZhdWx0fSAqLyAodGlsZXNbaV0pO1xuICAgICAgICBpZiAodGlsZS5nZXRTdGF0ZSgpID09IFRpbGVTdGF0ZS5BQk9SVCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aWxlQ29vcmQgPSB0aWxlLnRpbGVDb29yZDtcbiAgICAgICAgdmFyIHdvcmxkT2Zmc2V0ID0gdGlsZUdyaWQuZ2V0VGlsZUNvb3JkRXh0ZW50KHRpbGVDb29yZCwgdGhpcy50bXBFeHRlbnQpWzBdIC0gdGlsZS5leHRlbnRbMF07XG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAodmFyIHQgPSAwLCB0dCA9IHRpbGUudGlsZUtleXMubGVuZ3RoOyB0IDwgdHQ7ICsrdCkge1xuICAgICAgICAgIHZhciBzb3VyY2VUaWxlID0gdGlsZS5nZXRUaWxlKHRpbGUudGlsZUtleXNbdF0pO1xuICAgICAgICAgIGlmIChzb3VyY2VUaWxlLmdldFN0YXRlKCkgIT0gVGlsZVN0YXRlLkxPQURFRCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZXBsYXlHcm91cCA9IC8qKiBAdHlwZSB7Q2FudmFzUmVwbGF5R3JvdXB9ICovIChzb3VyY2VUaWxlLmdldFJlcGxheUdyb3VwKGxheWVyLCB0aWxlQ29vcmQudG9TdHJpbmcoKSkpO1xuICAgICAgICAgIGlmICghcmVwbGF5R3JvdXAgfHwgIXJlcGxheUdyb3VwLmhhc1JlcGxheXMocmVwbGF5VHlwZXMpKSB7XG4gICAgICAgICAgICAvLyBzb3VyY2VUaWxlIHdhcyBub3QgeWV0IGxvYWRlZCB3aGVuIHRoaXMuY3JlYXRlUmVwbGF5R3JvdXBfKCkgd2FzXG4gICAgICAgICAgICAvLyBjYWxsZWQsIG9yIGl0IGhhcyBubyByZXBsYXlzIG9mIHRoZSB0eXBlcyB3ZSB3YW50IHRvIHJlbmRlclxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdHJhbnNmb3JtKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm0gPSB0aGlzLmdldFRyYW5zZm9ybShmcmFtZVN0YXRlLCB3b3JsZE9mZnNldCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjdXJyZW50WiA9IHNvdXJjZVRpbGUudGlsZUNvb3JkWzBdO1xuICAgICAgICAgIHZhciBjdXJyZW50Q2xpcCA9IHJlcGxheUdyb3VwLmdldENsaXBDb29yZHModHJhbnNmb3JtKTtcbiAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gbGF5ZXJTdGF0ZS5vcGFjaXR5O1xuICAgICAgICAgIC8vIENyZWF0ZSBhIGNsaXAgbWFzayBmb3IgcmVnaW9ucyBpbiB0aGlzIGxvdyByZXNvbHV0aW9uIHRpbGUgdGhhdCBhcmVcbiAgICAgICAgICAvLyBhbHJlYWR5IGZpbGxlZCBieSBhIGhpZ2hlciByZXNvbHV0aW9uIHRpbGVcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgamogPSBjbGlwcy5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgICAgICAgICB2YXIgY2xpcCA9IGNsaXBzW2pdO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRaIDwgenNbal0pIHtcbiAgICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgLy8gY291bnRlci1jbG9ja3dpc2UgKG91dGVyIHJpbmcpIGZvciBjdXJyZW50IHRpbGVcbiAgICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oY3VycmVudENsaXBbMF0sIGN1cnJlbnRDbGlwWzFdKTtcbiAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oY3VycmVudENsaXBbMl0sIGN1cnJlbnRDbGlwWzNdKTtcbiAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oY3VycmVudENsaXBbNF0sIGN1cnJlbnRDbGlwWzVdKTtcbiAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oY3VycmVudENsaXBbNl0sIGN1cnJlbnRDbGlwWzddKTtcbiAgICAgICAgICAgICAgLy8gY2xvY2t3aXNlIChpbm5lciByaW5nKSBmb3IgaGlnaGVyIHJlc29sdXRpb24gdGlsZVxuICAgICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhjbGlwWzZdLCBjbGlwWzddKTtcbiAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oY2xpcFs0XSwgY2xpcFs1XSk7XG4gICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGNsaXBbMl0sIGNsaXBbM10pO1xuICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhjbGlwWzBdLCBjbGlwWzFdKTtcbiAgICAgICAgICAgICAgY29udGV4dC5jbGlwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlcGxheUdyb3VwLnJlcGxheShjb250ZXh0LCB0cmFuc2Zvcm0sIHJvdGF0aW9uLCB7fSwgc25hcFRvUGl4ZWwsIHJlcGxheVR5cGVzLCBkZWNsdXR0ZXJSZXBsYXlzKTtcbiAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgICBjbGlwcy5wdXNoKGN1cnJlbnRDbGlwKTtcbiAgICAgICAgICB6cy5wdXNoKGN1cnJlbnRaKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRlY2x1dHRlclJlcGxheXMpIHtcbiAgICAgICAgcmVwbGF5RGVjbHV0dGVyKGRlY2x1dHRlclJlcGxheXMsIGNvbnRleHQsIHJvdGF0aW9uLCBzbmFwVG9QaXhlbCk7XG4gICAgICB9XG4gICAgICBpZiAocm90YXRpb24pIHtcbiAgICAgICAgcm90YXRlQXRPZmZzZXQoY29udGV4dCwgcm90YXRpb24sXG4gICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovIChvZmZzZXRYKSwgLyoqIEB0eXBlIHtudW1iZXJ9ICovIChvZmZzZXRZKSk7XG4gICAgICB9XG4gICAgfVxuICAgIENhbnZhc1RpbGVMYXllclJlbmRlcmVyLnByb3RvdHlwZS5wb3N0Q29tcG9zZS5jYWxsKHRoaXMsIGNvbnRleHQsIGZyYW1lU3RhdGUsIGxheWVyU3RhdGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNxdWFyZWRUb2xlcmFuY2UgU3F1YXJlZCB0b2xlcmFuY2UuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdHxBcnJheTxpbXBvcnQoXCIuLi8uLi9zdHlsZS9TdHlsZS5qc1wiKS5kZWZhdWx0Pn0gc3R5bGVzIFRoZSBzdHlsZSBvciBhcnJheSBvZiBzdHlsZXMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vcmVuZGVyL2NhbnZhcy9SZXBsYXlHcm91cC5qc1wiKS5kZWZhdWx0fSByZXBsYXlHcm91cCBSZXBsYXkgZ3JvdXAuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiBhbiBpbWFnZSBpcyBsb2FkaW5nLlxuICAgKi9cbiAgQ2FudmFzVmVjdG9yVGlsZUxheWVyUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckZlYXR1cmUgPSBmdW5jdGlvbiByZW5kZXJGZWF0dXJlJDEgKGZlYXR1cmUsIHNxdWFyZWRUb2xlcmFuY2UsIHN0eWxlcywgcmVwbGF5R3JvdXApIHtcbiAgICBpZiAoIXN0eWxlcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgbG9hZGluZyA9IGZhbHNlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHN0eWxlcykpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHN0eWxlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGxvYWRpbmcgPSByZW5kZXJGZWF0dXJlKFxuICAgICAgICAgIHJlcGxheUdyb3VwLCBmZWF0dXJlLCBzdHlsZXNbaV0sIHNxdWFyZWRUb2xlcmFuY2UsXG4gICAgICAgICAgdGhpcy5oYW5kbGVTdHlsZUltYWdlQ2hhbmdlXywgdGhpcykgfHwgbG9hZGluZztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9hZGluZyA9IHJlbmRlckZlYXR1cmUoXG4gICAgICAgIHJlcGxheUdyb3VwLCBmZWF0dXJlLCBzdHlsZXMsIHNxdWFyZWRUb2xlcmFuY2UsXG4gICAgICAgIHRoaXMuaGFuZGxlU3R5bGVJbWFnZUNoYW5nZV8sIHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gbG9hZGluZztcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9WZWN0b3JJbWFnZVRpbGUuanNcIikuZGVmYXVsdH0gdGlsZSBUaWxlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQ2FudmFzVmVjdG9yVGlsZUxheWVyUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclRpbGVJbWFnZV8gPSBmdW5jdGlvbiByZW5kZXJUaWxlSW1hZ2VfICh0aWxlLCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKSB7XG4gICAgdmFyIGxheWVyID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9sYXllci9WZWN0b3IuanNcIikuZGVmYXVsdH0gKi8gKHRoaXMuZ2V0TGF5ZXIoKSk7XG4gICAgdmFyIHJlcGxheVN0YXRlID0gdGlsZS5nZXRSZXBsYXlTdGF0ZShsYXllcik7XG4gICAgdmFyIHJldmlzaW9uID0gbGF5ZXIuZ2V0UmV2aXNpb24oKTtcbiAgICB2YXIgcmVwbGF5cyA9IElNQUdFX1JFUExBWVNbbGF5ZXIuZ2V0UmVuZGVyTW9kZSgpXTtcbiAgICBpZiAocmVwbGF5cyAmJiByZXBsYXlTdGF0ZS5yZW5kZXJlZFRpbGVSZXZpc2lvbiAhPT0gcmV2aXNpb24pIHtcbiAgICAgIHJlcGxheVN0YXRlLnJlbmRlcmVkVGlsZVJldmlzaW9uID0gcmV2aXNpb247XG4gICAgICB2YXIgdGlsZUNvb3JkID0gdGlsZS53cmFwcGVkVGlsZUNvb3JkO1xuICAgICAgdmFyIHogPSB0aWxlQ29vcmRbMF07XG4gICAgICB2YXIgc291cmNlID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9zb3VyY2UvVmVjdG9yVGlsZS5qc1wiKS5kZWZhdWx0fSAqLyAobGF5ZXIuZ2V0U291cmNlKCkpO1xuICAgICAgdmFyIHRpbGVHcmlkID0gc291cmNlLmdldFRpbGVHcmlkRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgICAgIHZhciByZXNvbHV0aW9uID0gdGlsZUdyaWQuZ2V0UmVzb2x1dGlvbih6KTtcbiAgICAgIHZhciBjb250ZXh0ID0gdGlsZS5nZXRDb250ZXh0KGxheWVyKTtcbiAgICAgIHZhciBzaXplID0gc291cmNlLmdldFRpbGVQaXhlbFNpemUoeiwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbik7XG4gICAgICBjb250ZXh0LmNhbnZhcy53aWR0aCA9IHNpemVbMF07XG4gICAgICBjb250ZXh0LmNhbnZhcy5oZWlnaHQgPSBzaXplWzFdO1xuICAgICAgdmFyIHRpbGVFeHRlbnQgPSB0aWxlR3JpZC5nZXRUaWxlQ29vcmRFeHRlbnQodGlsZUNvb3JkLCB0aGlzLnRtcEV4dGVudCk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aWxlLnRpbGVLZXlzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgdmFyIHNvdXJjZVRpbGUgPSB0aWxlLmdldFRpbGUodGlsZS50aWxlS2V5c1tpXSk7XG4gICAgICAgIGlmIChzb3VyY2VUaWxlLmdldFN0YXRlKCkgIT0gVGlsZVN0YXRlLkxPQURFRCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwaXhlbFNjYWxlID0gcGl4ZWxSYXRpbyAvIHJlc29sdXRpb247XG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSByZXNldFRyYW5zZm9ybSh0aGlzLnRtcFRyYW5zZm9ybV8pO1xuICAgICAgICBzY2FsZVRyYW5zZm9ybSh0cmFuc2Zvcm0sIHBpeGVsU2NhbGUsIC1waXhlbFNjYWxlKTtcbiAgICAgICAgdHJhbnNsYXRlVHJhbnNmb3JtKHRyYW5zZm9ybSwgLXRpbGVFeHRlbnRbMF0sIC10aWxlRXh0ZW50WzNdKTtcbiAgICAgICAgdmFyIHJlcGxheUdyb3VwID0gLyoqIEB0eXBlIHtDYW52YXNSZXBsYXlHcm91cH0gKi8gKHNvdXJjZVRpbGUuZ2V0UmVwbGF5R3JvdXAobGF5ZXIsXG4gICAgICAgICAgdGlsZS50aWxlQ29vcmQudG9TdHJpbmcoKSkpO1xuICAgICAgICByZXBsYXlHcm91cC5yZXBsYXkoY29udGV4dCwgdHJhbnNmb3JtLCAwLCB7fSwgdHJ1ZSwgcmVwbGF5cyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBDYW52YXNWZWN0b3JUaWxlTGF5ZXJSZW5kZXJlcjtcbn0oQ2FudmFzVGlsZUxheWVyUmVuZGVyZXIpKTtcblxuXG4vKipcbiAqIERldGVybWluZSBpZiB0aGlzIHJlbmRlcmVyIGhhbmRsZXMgdGhlIHByb3ZpZGVkIGxheWVyLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0fSBsYXllciBUaGUgY2FuZGlkYXRlIGxheWVyLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHJlbmRlcmVyIGNhbiByZW5kZXIgdGhlIGxheWVyLlxuICovXG5DYW52YXNWZWN0b3JUaWxlTGF5ZXJSZW5kZXJlclsnaGFuZGxlcyddID0gZnVuY3Rpb24obGF5ZXIpIHtcbiAgcmV0dXJuIGxheWVyLmdldFR5cGUoKSA9PT0gTGF5ZXJUeXBlLlZFQ1RPUl9USUxFO1xufTtcblxuXG4vKipcbiAqIENyZWF0ZSBhIGxheWVyIHJlbmRlcmVyLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXAuanNcIikuZGVmYXVsdH0gbWFwUmVuZGVyZXIgVGhlIG1hcCByZW5kZXJlci5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdH0gbGF5ZXIgVGhlIGxheWVyIHRvIGJlIHJlbmRlcmVyZC5cbiAqIEByZXR1cm4ge0NhbnZhc1ZlY3RvclRpbGVMYXllclJlbmRlcmVyfSBUaGUgbGF5ZXIgcmVuZGVyZXIuXG4gKi9cbkNhbnZhc1ZlY3RvclRpbGVMYXllclJlbmRlcmVyWydjcmVhdGUnXSA9IGZ1bmN0aW9uKG1hcFJlbmRlcmVyLCBsYXllcikge1xuICByZXR1cm4gbmV3IENhbnZhc1ZlY3RvclRpbGVMYXllclJlbmRlcmVyKC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vbGF5ZXIvVmVjdG9yVGlsZS5qc1wiKS5kZWZhdWx0fSAqLyAobGF5ZXIpKTtcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgQ2FudmFzVmVjdG9yVGlsZUxheWVyUmVuZGVyZXI7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZlY3RvclRpbGVMYXllci5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyZXIvdmVjdG9yXG4gKi9cbmltcG9ydCB7Z2V0VWlkfSBmcm9tICcuLi91dGlsLmpzJztcbmltcG9ydCBJbWFnZVN0YXRlIGZyb20gJy4uL0ltYWdlU3RhdGUuanMnO1xuaW1wb3J0IEdlb21ldHJ5VHlwZSBmcm9tICcuLi9nZW9tL0dlb21ldHJ5VHlwZS5qcyc7XG5pbXBvcnQgUmVwbGF5VHlwZSBmcm9tICcuLi9yZW5kZXIvUmVwbGF5VHlwZS5qcyc7XG5cblxuLyoqXG4gKiBUb2xlcmFuY2UgZm9yIGdlb21ldHJ5IHNpbXBsaWZpY2F0aW9uIGluIGRldmljZSBwaXhlbHMuXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG52YXIgU0lNUExJRllfVE9MRVJBTkNFID0gMC41O1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PGltcG9ydChcIi4uL2dlb20vR2VvbWV0cnlUeXBlLmpzXCIpLmRlZmF1bHQsXG4gKiAgICAgICAgICAgICAgICBmdW5jdGlvbihpbXBvcnQoXCIuLi9yZW5kZXIvUmVwbGF5R3JvdXAuanNcIikuZGVmYXVsdCwgaW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0LFxuICogICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdCwgT2JqZWN0KT59XG4gKi9cbnZhciBHRU9NRVRSWV9SRU5ERVJFUlMgPSB7XG4gICdQb2ludCc6IHJlbmRlclBvaW50R2VvbWV0cnksXG4gICdMaW5lU3RyaW5nJzogcmVuZGVyTGluZVN0cmluZ0dlb21ldHJ5LFxuICAnUG9seWdvbic6IHJlbmRlclBvbHlnb25HZW9tZXRyeSxcbiAgJ011bHRpUG9pbnQnOiByZW5kZXJNdWx0aVBvaW50R2VvbWV0cnksXG4gICdNdWx0aUxpbmVTdHJpbmcnOiByZW5kZXJNdWx0aUxpbmVTdHJpbmdHZW9tZXRyeSxcbiAgJ011bHRpUG9seWdvbic6IHJlbmRlck11bHRpUG9seWdvbkdlb21ldHJ5LFxuICAnR2VvbWV0cnlDb2xsZWN0aW9uJzogcmVuZGVyR2VvbWV0cnlDb2xsZWN0aW9uR2VvbWV0cnksXG4gICdDaXJjbGUnOiByZW5kZXJDaXJjbGVHZW9tZXRyeVxufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZTEgRmVhdHVyZSAxLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlMiBGZWF0dXJlIDIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE9yZGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdE9yZGVyKGZlYXR1cmUxLCBmZWF0dXJlMikge1xuICByZXR1cm4gcGFyc2VJbnQoZ2V0VWlkKGZlYXR1cmUxKSwgMTApIC0gcGFyc2VJbnQoZ2V0VWlkKGZlYXR1cmUyKSwgMTApO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICogQHJldHVybiB7bnVtYmVyfSBTcXVhcmVkIHBpeGVsIHRvbGVyYW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNxdWFyZWRUb2xlcmFuY2UocmVzb2x1dGlvbiwgcGl4ZWxSYXRpbykge1xuICB2YXIgdG9sZXJhbmNlID0gZ2V0VG9sZXJhbmNlKHJlc29sdXRpb24sIHBpeGVsUmF0aW8pO1xuICByZXR1cm4gdG9sZXJhbmNlICogdG9sZXJhbmNlO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICogQHJldHVybiB7bnVtYmVyfSBQaXhlbCB0b2xlcmFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUb2xlcmFuY2UocmVzb2x1dGlvbiwgcGl4ZWxSYXRpbykge1xuICByZXR1cm4gU0lNUExJRllfVE9MRVJBTkNFICogcmVzb2x1dGlvbiAvIHBpeGVsUmF0aW87XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3JlbmRlci9SZXBsYXlHcm91cC5qc1wiKS5kZWZhdWx0fSByZXBsYXlHcm91cCBSZXBsYXkgZ3JvdXAuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vQ2lyY2xlLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5kZWZhdWx0fSBzdHlsZSBTdHlsZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmUuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckNpcmNsZUdlb21ldHJ5KHJlcGxheUdyb3VwLCBnZW9tZXRyeSwgc3R5bGUsIGZlYXR1cmUpIHtcbiAgdmFyIGZpbGxTdHlsZSA9IHN0eWxlLmdldEZpbGwoKTtcbiAgdmFyIHN0cm9rZVN0eWxlID0gc3R5bGUuZ2V0U3Ryb2tlKCk7XG4gIGlmIChmaWxsU3R5bGUgfHwgc3Ryb2tlU3R5bGUpIHtcbiAgICB2YXIgY2lyY2xlUmVwbGF5ID0gcmVwbGF5R3JvdXAuZ2V0UmVwbGF5KHN0eWxlLmdldFpJbmRleCgpLCBSZXBsYXlUeXBlLkNJUkNMRSk7XG4gICAgY2lyY2xlUmVwbGF5LnNldEZpbGxTdHJva2VTdHlsZShmaWxsU3R5bGUsIHN0cm9rZVN0eWxlKTtcbiAgICBjaXJjbGVSZXBsYXkuZHJhd0NpcmNsZShnZW9tZXRyeSwgZmVhdHVyZSk7XG4gIH1cbiAgdmFyIHRleHRTdHlsZSA9IHN0eWxlLmdldFRleHQoKTtcbiAgaWYgKHRleHRTdHlsZSkge1xuICAgIHZhciB0ZXh0UmVwbGF5ID0gcmVwbGF5R3JvdXAuZ2V0UmVwbGF5KHN0eWxlLmdldFpJbmRleCgpLCBSZXBsYXlUeXBlLlRFWFQpO1xuICAgIHRleHRSZXBsYXkuc2V0VGV4dFN0eWxlKHRleHRTdHlsZSwgcmVwbGF5R3JvdXAuYWRkRGVjbHV0dGVyKGZhbHNlKSk7XG4gICAgdGV4dFJlcGxheS5kcmF3VGV4dChnZW9tZXRyeSwgZmVhdHVyZSk7XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcmVuZGVyL1JlcGxheUdyb3VwLmpzXCIpLmRlZmF1bHR9IHJlcGxheUdyb3VwIFJlcGxheSBncm91cC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZSBGZWF0dXJlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5kZWZhdWx0fSBzdHlsZSBTdHlsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcXVhcmVkVG9sZXJhbmNlIFNxdWFyZWQgdG9sZXJhbmNlLlxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBULCBpbXBvcnQoXCIuLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdCl9IGxpc3RlbmVyIExpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtUfSB0aGlzQXJnIFZhbHVlIHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgYGxpc3RlbmVyYC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiBzdHlsZSBpcyBsb2FkaW5nLlxuICogQHRlbXBsYXRlIFRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlckZlYXR1cmUocmVwbGF5R3JvdXAsIGZlYXR1cmUsIHN0eWxlLCBzcXVhcmVkVG9sZXJhbmNlLCBsaXN0ZW5lciwgdGhpc0FyZykge1xuICB2YXIgbG9hZGluZyA9IGZhbHNlO1xuICB2YXIgaW1hZ2VTdHlsZSA9IHN0eWxlLmdldEltYWdlKCk7XG4gIGlmIChpbWFnZVN0eWxlKSB7XG4gICAgdmFyIGltYWdlU3RhdGUgPSBpbWFnZVN0eWxlLmdldEltYWdlU3RhdGUoKTtcbiAgICBpZiAoaW1hZ2VTdGF0ZSA9PSBJbWFnZVN0YXRlLkxPQURFRCB8fCBpbWFnZVN0YXRlID09IEltYWdlU3RhdGUuRVJST1IpIHtcbiAgICAgIGltYWdlU3R5bGUudW5saXN0ZW5JbWFnZUNoYW5nZShsaXN0ZW5lciwgdGhpc0FyZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpbWFnZVN0YXRlID09IEltYWdlU3RhdGUuSURMRSkge1xuICAgICAgICBpbWFnZVN0eWxlLmxvYWQoKTtcbiAgICAgIH1cbiAgICAgIGltYWdlU3RhdGUgPSBpbWFnZVN0eWxlLmdldEltYWdlU3RhdGUoKTtcbiAgICAgIGltYWdlU3R5bGUubGlzdGVuSW1hZ2VDaGFuZ2UobGlzdGVuZXIsIHRoaXNBcmcpO1xuICAgICAgbG9hZGluZyA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJlbmRlckZlYXR1cmVJbnRlcm5hbChyZXBsYXlHcm91cCwgZmVhdHVyZSwgc3R5bGUsIHNxdWFyZWRUb2xlcmFuY2UpO1xuXG4gIHJldHVybiBsb2FkaW5nO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9yZW5kZXIvUmVwbGF5R3JvdXAuanNcIikuZGVmYXVsdH0gcmVwbGF5R3JvdXAgUmVwbGF5IGdyb3VwLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHR9IHN0eWxlIFN0eWxlLlxuICogQHBhcmFtIHtudW1iZXJ9IHNxdWFyZWRUb2xlcmFuY2UgU3F1YXJlZCB0b2xlcmFuY2UuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckZlYXR1cmVJbnRlcm5hbChyZXBsYXlHcm91cCwgZmVhdHVyZSwgc3R5bGUsIHNxdWFyZWRUb2xlcmFuY2UpIHtcbiAgdmFyIGdlb21ldHJ5ID0gc3R5bGUuZ2V0R2VvbWV0cnlGdW5jdGlvbigpKGZlYXR1cmUpO1xuICBpZiAoIWdlb21ldHJ5KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBzaW1wbGlmaWVkR2VvbWV0cnkgPSBnZW9tZXRyeS5nZXRTaW1wbGlmaWVkR2VvbWV0cnkoc3F1YXJlZFRvbGVyYW5jZSk7XG4gIHZhciByZW5kZXJlciA9IHN0eWxlLmdldFJlbmRlcmVyKCk7XG4gIGlmIChyZW5kZXJlcikge1xuICAgIHJlbmRlckdlb21ldHJ5KHJlcGxheUdyb3VwLCBzaW1wbGlmaWVkR2VvbWV0cnksIHN0eWxlLCBmZWF0dXJlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZ2VvbWV0cnlSZW5kZXJlciA9IEdFT01FVFJZX1JFTkRFUkVSU1tzaW1wbGlmaWVkR2VvbWV0cnkuZ2V0VHlwZSgpXTtcbiAgICBnZW9tZXRyeVJlbmRlcmVyKHJlcGxheUdyb3VwLCBzaW1wbGlmaWVkR2VvbWV0cnksIHN0eWxlLCBmZWF0dXJlKTtcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9yZW5kZXIvUmVwbGF5R3JvdXAuanNcIikuZGVmYXVsdH0gcmVwbGF5R3JvdXAgUmVwbGF5IGdyb3VwLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vcmVuZGVyL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHR9IHN0eWxlIFN0eWxlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckdlb21ldHJ5KHJlcGxheUdyb3VwLCBnZW9tZXRyeSwgc3R5bGUsIGZlYXR1cmUpIHtcbiAgaWYgKGdlb21ldHJ5LmdldFR5cGUoKSA9PSBHZW9tZXRyeVR5cGUuR0VPTUVUUllfQ09MTEVDVElPTikge1xuICAgIHZhciBnZW9tZXRyaWVzID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5Q29sbGVjdGlvbi5qc1wiKS5kZWZhdWx0fSAqLyAoZ2VvbWV0cnkpLmdldEdlb21ldHJpZXMoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBnZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIHJlbmRlckdlb21ldHJ5KHJlcGxheUdyb3VwLCBnZW9tZXRyaWVzW2ldLCBzdHlsZSwgZmVhdHVyZSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcmVwbGF5ID0gcmVwbGF5R3JvdXAuZ2V0UmVwbGF5KHN0eWxlLmdldFpJbmRleCgpLCBSZXBsYXlUeXBlLkRFRkFVTFQpO1xuICByZXBsYXkuZHJhd0N1c3RvbSgvKiogQHR5cGUge2ltcG9ydChcIi4uL2dlb20vU2ltcGxlR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gKi8gKGdlb21ldHJ5KSwgZmVhdHVyZSwgc3R5bGUuZ2V0UmVuZGVyZXIoKSk7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3JlbmRlci9SZXBsYXlHcm91cC5qc1wiKS5kZWZhdWx0fSByZXBsYXlHcm91cCBSZXBsYXkgZ3JvdXAuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnlDb2xsZWN0aW9uLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5kZWZhdWx0fSBzdHlsZSBTdHlsZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmUuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckdlb21ldHJ5Q29sbGVjdGlvbkdlb21ldHJ5KHJlcGxheUdyb3VwLCBnZW9tZXRyeSwgc3R5bGUsIGZlYXR1cmUpIHtcbiAgdmFyIGdlb21ldHJpZXMgPSBnZW9tZXRyeS5nZXRHZW9tZXRyaWVzQXJyYXkoKTtcbiAgdmFyIGksIGlpO1xuICBmb3IgKGkgPSAwLCBpaSA9IGdlb21ldHJpZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIHZhciBnZW9tZXRyeVJlbmRlcmVyID1cbiAgICAgICAgR0VPTUVUUllfUkVOREVSRVJTW2dlb21ldHJpZXNbaV0uZ2V0VHlwZSgpXTtcbiAgICBnZW9tZXRyeVJlbmRlcmVyKHJlcGxheUdyb3VwLCBnZW9tZXRyaWVzW2ldLCBzdHlsZSwgZmVhdHVyZSk7XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcmVuZGVyL1JlcGxheUdyb3VwLmpzXCIpLmRlZmF1bHR9IHJlcGxheUdyb3VwIFJlcGxheSBncm91cC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9MaW5lU3RyaW5nLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vcmVuZGVyL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHR9IHN0eWxlIFN0eWxlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckxpbmVTdHJpbmdHZW9tZXRyeShyZXBsYXlHcm91cCwgZ2VvbWV0cnksIHN0eWxlLCBmZWF0dXJlKSB7XG4gIHZhciBzdHJva2VTdHlsZSA9IHN0eWxlLmdldFN0cm9rZSgpO1xuICBpZiAoc3Ryb2tlU3R5bGUpIHtcbiAgICB2YXIgbGluZVN0cmluZ1JlcGxheSA9IHJlcGxheUdyb3VwLmdldFJlcGxheShzdHlsZS5nZXRaSW5kZXgoKSwgUmVwbGF5VHlwZS5MSU5FX1NUUklORyk7XG4gICAgbGluZVN0cmluZ1JlcGxheS5zZXRGaWxsU3Ryb2tlU3R5bGUobnVsbCwgc3Ryb2tlU3R5bGUpO1xuICAgIGxpbmVTdHJpbmdSZXBsYXkuZHJhd0xpbmVTdHJpbmcoZ2VvbWV0cnksIGZlYXR1cmUpO1xuICB9XG4gIHZhciB0ZXh0U3R5bGUgPSBzdHlsZS5nZXRUZXh0KCk7XG4gIGlmICh0ZXh0U3R5bGUpIHtcbiAgICB2YXIgdGV4dFJlcGxheSA9IHJlcGxheUdyb3VwLmdldFJlcGxheShzdHlsZS5nZXRaSW5kZXgoKSwgUmVwbGF5VHlwZS5URVhUKTtcbiAgICB0ZXh0UmVwbGF5LnNldFRleHRTdHlsZSh0ZXh0U3R5bGUsIHJlcGxheUdyb3VwLmFkZERlY2x1dHRlcihmYWxzZSkpO1xuICAgIHRleHRSZXBsYXkuZHJhd1RleHQoZ2VvbWV0cnksIGZlYXR1cmUpO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3JlbmRlci9SZXBsYXlHcm91cC5qc1wiKS5kZWZhdWx0fSByZXBsYXlHcm91cCBSZXBsYXkgZ3JvdXAuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vTXVsdGlMaW5lU3RyaW5nLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vcmVuZGVyL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHR9IHN0eWxlIFN0eWxlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlck11bHRpTGluZVN0cmluZ0dlb21ldHJ5KHJlcGxheUdyb3VwLCBnZW9tZXRyeSwgc3R5bGUsIGZlYXR1cmUpIHtcbiAgdmFyIHN0cm9rZVN0eWxlID0gc3R5bGUuZ2V0U3Ryb2tlKCk7XG4gIGlmIChzdHJva2VTdHlsZSkge1xuICAgIHZhciBsaW5lU3RyaW5nUmVwbGF5ID0gcmVwbGF5R3JvdXAuZ2V0UmVwbGF5KHN0eWxlLmdldFpJbmRleCgpLCBSZXBsYXlUeXBlLkxJTkVfU1RSSU5HKTtcbiAgICBsaW5lU3RyaW5nUmVwbGF5LnNldEZpbGxTdHJva2VTdHlsZShudWxsLCBzdHJva2VTdHlsZSk7XG4gICAgbGluZVN0cmluZ1JlcGxheS5kcmF3TXVsdGlMaW5lU3RyaW5nKGdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgfVxuICB2YXIgdGV4dFN0eWxlID0gc3R5bGUuZ2V0VGV4dCgpO1xuICBpZiAodGV4dFN0eWxlKSB7XG4gICAgdmFyIHRleHRSZXBsYXkgPSByZXBsYXlHcm91cC5nZXRSZXBsYXkoc3R5bGUuZ2V0WkluZGV4KCksIFJlcGxheVR5cGUuVEVYVCk7XG4gICAgdGV4dFJlcGxheS5zZXRUZXh0U3R5bGUodGV4dFN0eWxlLCByZXBsYXlHcm91cC5hZGREZWNsdXR0ZXIoZmFsc2UpKTtcbiAgICB0ZXh0UmVwbGF5LmRyYXdUZXh0KGdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9yZW5kZXIvUmVwbGF5R3JvdXAuanNcIikuZGVmYXVsdH0gcmVwbGF5R3JvdXAgUmVwbGF5IGdyb3VwLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL011bHRpUG9seWdvbi5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdH0gc3R5bGUgU3R5bGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICovXG5mdW5jdGlvbiByZW5kZXJNdWx0aVBvbHlnb25HZW9tZXRyeShyZXBsYXlHcm91cCwgZ2VvbWV0cnksIHN0eWxlLCBmZWF0dXJlKSB7XG4gIHZhciBmaWxsU3R5bGUgPSBzdHlsZS5nZXRGaWxsKCk7XG4gIHZhciBzdHJva2VTdHlsZSA9IHN0eWxlLmdldFN0cm9rZSgpO1xuICBpZiAoc3Ryb2tlU3R5bGUgfHwgZmlsbFN0eWxlKSB7XG4gICAgdmFyIHBvbHlnb25SZXBsYXkgPSByZXBsYXlHcm91cC5nZXRSZXBsYXkoc3R5bGUuZ2V0WkluZGV4KCksIFJlcGxheVR5cGUuUE9MWUdPTik7XG4gICAgcG9seWdvblJlcGxheS5zZXRGaWxsU3Ryb2tlU3R5bGUoZmlsbFN0eWxlLCBzdHJva2VTdHlsZSk7XG4gICAgcG9seWdvblJlcGxheS5kcmF3TXVsdGlQb2x5Z29uKGdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgfVxuICB2YXIgdGV4dFN0eWxlID0gc3R5bGUuZ2V0VGV4dCgpO1xuICBpZiAodGV4dFN0eWxlKSB7XG4gICAgdmFyIHRleHRSZXBsYXkgPSByZXBsYXlHcm91cC5nZXRSZXBsYXkoc3R5bGUuZ2V0WkluZGV4KCksIFJlcGxheVR5cGUuVEVYVCk7XG4gICAgdGV4dFJlcGxheS5zZXRUZXh0U3R5bGUodGV4dFN0eWxlLCByZXBsYXlHcm91cC5hZGREZWNsdXR0ZXIoZmFsc2UpKTtcbiAgICB0ZXh0UmVwbGF5LmRyYXdUZXh0KGdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9yZW5kZXIvUmVwbGF5R3JvdXAuanNcIikuZGVmYXVsdH0gcmVwbGF5R3JvdXAgUmVwbGF5IGdyb3VwLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL1BvaW50LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vcmVuZGVyL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHR9IHN0eWxlIFN0eWxlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclBvaW50R2VvbWV0cnkocmVwbGF5R3JvdXAsIGdlb21ldHJ5LCBzdHlsZSwgZmVhdHVyZSkge1xuICB2YXIgaW1hZ2VTdHlsZSA9IHN0eWxlLmdldEltYWdlKCk7XG4gIGlmIChpbWFnZVN0eWxlKSB7XG4gICAgaWYgKGltYWdlU3R5bGUuZ2V0SW1hZ2VTdGF0ZSgpICE9IEltYWdlU3RhdGUuTE9BREVEKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpbWFnZVJlcGxheSA9IHJlcGxheUdyb3VwLmdldFJlcGxheShzdHlsZS5nZXRaSW5kZXgoKSwgUmVwbGF5VHlwZS5JTUFHRSk7XG4gICAgaW1hZ2VSZXBsYXkuc2V0SW1hZ2VTdHlsZShpbWFnZVN0eWxlLCByZXBsYXlHcm91cC5hZGREZWNsdXR0ZXIoZmFsc2UpKTtcbiAgICBpbWFnZVJlcGxheS5kcmF3UG9pbnQoZ2VvbWV0cnksIGZlYXR1cmUpO1xuICB9XG4gIHZhciB0ZXh0U3R5bGUgPSBzdHlsZS5nZXRUZXh0KCk7XG4gIGlmICh0ZXh0U3R5bGUpIHtcbiAgICB2YXIgdGV4dFJlcGxheSA9IHJlcGxheUdyb3VwLmdldFJlcGxheShzdHlsZS5nZXRaSW5kZXgoKSwgUmVwbGF5VHlwZS5URVhUKTtcbiAgICB0ZXh0UmVwbGF5LnNldFRleHRTdHlsZSh0ZXh0U3R5bGUsIHJlcGxheUdyb3VwLmFkZERlY2x1dHRlcighIWltYWdlU3R5bGUpKTtcbiAgICB0ZXh0UmVwbGF5LmRyYXdUZXh0KGdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9yZW5kZXIvUmVwbGF5R3JvdXAuanNcIikuZGVmYXVsdH0gcmVwbGF5R3JvdXAgUmVwbGF5IGdyb3VwLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL011bHRpUG9pbnQuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9yZW5kZXIvRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdH0gc3R5bGUgU3R5bGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUgRmVhdHVyZS5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyTXVsdGlQb2ludEdlb21ldHJ5KHJlcGxheUdyb3VwLCBnZW9tZXRyeSwgc3R5bGUsIGZlYXR1cmUpIHtcbiAgdmFyIGltYWdlU3R5bGUgPSBzdHlsZS5nZXRJbWFnZSgpO1xuICBpZiAoaW1hZ2VTdHlsZSkge1xuICAgIGlmIChpbWFnZVN0eWxlLmdldEltYWdlU3RhdGUoKSAhPSBJbWFnZVN0YXRlLkxPQURFRCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaW1hZ2VSZXBsYXkgPSByZXBsYXlHcm91cC5nZXRSZXBsYXkoc3R5bGUuZ2V0WkluZGV4KCksIFJlcGxheVR5cGUuSU1BR0UpO1xuICAgIGltYWdlUmVwbGF5LnNldEltYWdlU3R5bGUoaW1hZ2VTdHlsZSwgcmVwbGF5R3JvdXAuYWRkRGVjbHV0dGVyKGZhbHNlKSk7XG4gICAgaW1hZ2VSZXBsYXkuZHJhd011bHRpUG9pbnQoZ2VvbWV0cnksIGZlYXR1cmUpO1xuICB9XG4gIHZhciB0ZXh0U3R5bGUgPSBzdHlsZS5nZXRUZXh0KCk7XG4gIGlmICh0ZXh0U3R5bGUpIHtcbiAgICB2YXIgdGV4dFJlcGxheSA9IHJlcGxheUdyb3VwLmdldFJlcGxheShzdHlsZS5nZXRaSW5kZXgoKSwgUmVwbGF5VHlwZS5URVhUKTtcbiAgICB0ZXh0UmVwbGF5LnNldFRleHRTdHlsZSh0ZXh0U3R5bGUsIHJlcGxheUdyb3VwLmFkZERlY2x1dHRlcighIWltYWdlU3R5bGUpKTtcbiAgICB0ZXh0UmVwbGF5LmRyYXdUZXh0KGdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9yZW5kZXIvUmVwbGF5R3JvdXAuanNcIikuZGVmYXVsdH0gcmVwbGF5R3JvdXAgUmVwbGF5IGdyb3VwLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL1BvbHlnb24uanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9yZW5kZXIvRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdH0gc3R5bGUgU3R5bGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUgRmVhdHVyZS5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyUG9seWdvbkdlb21ldHJ5KHJlcGxheUdyb3VwLCBnZW9tZXRyeSwgc3R5bGUsIGZlYXR1cmUpIHtcbiAgdmFyIGZpbGxTdHlsZSA9IHN0eWxlLmdldEZpbGwoKTtcbiAgdmFyIHN0cm9rZVN0eWxlID0gc3R5bGUuZ2V0U3Ryb2tlKCk7XG4gIGlmIChmaWxsU3R5bGUgfHwgc3Ryb2tlU3R5bGUpIHtcbiAgICB2YXIgcG9seWdvblJlcGxheSA9IHJlcGxheUdyb3VwLmdldFJlcGxheShzdHlsZS5nZXRaSW5kZXgoKSwgUmVwbGF5VHlwZS5QT0xZR09OKTtcbiAgICBwb2x5Z29uUmVwbGF5LnNldEZpbGxTdHJva2VTdHlsZShmaWxsU3R5bGUsIHN0cm9rZVN0eWxlKTtcbiAgICBwb2x5Z29uUmVwbGF5LmRyYXdQb2x5Z29uKGdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgfVxuICB2YXIgdGV4dFN0eWxlID0gc3R5bGUuZ2V0VGV4dCgpO1xuICBpZiAodGV4dFN0eWxlKSB7XG4gICAgdmFyIHRleHRSZXBsYXkgPSByZXBsYXlHcm91cC5nZXRSZXBsYXkoc3R5bGUuZ2V0WkluZGV4KCksIFJlcGxheVR5cGUuVEVYVCk7XG4gICAgdGV4dFJlcGxheS5zZXRUZXh0U3R5bGUodGV4dFN0eWxlLCByZXBsYXlHcm91cC5hZGREZWNsdXR0ZXIoZmFsc2UpKTtcbiAgICB0ZXh0UmVwbGF5LmRyYXdUZXh0KGdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgfVxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZWN0b3IuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlcHJvalxuICovXG5pbXBvcnQge2NyZWF0ZUNhbnZhc0NvbnRleHQyRH0gZnJvbSAnLi9kb20uanMnO1xuaW1wb3J0IHtjb250YWluc0Nvb3JkaW5hdGUsIGNyZWF0ZUVtcHR5LCBleHRlbmQsIGdldEhlaWdodCwgZ2V0VG9wTGVmdCwgZ2V0V2lkdGh9IGZyb20gJy4vZXh0ZW50LmpzJztcbmltcG9ydCB7c29sdmVMaW5lYXJTeXN0ZW19IGZyb20gJy4vbWF0aC5qcyc7XG5pbXBvcnQge2dldFBvaW50UmVzb2x1dGlvbiwgdHJhbnNmb3JtfSBmcm9tICcuL3Byb2ouanMnO1xuXG5cbi8qKlxuICogQ2FsY3VsYXRlcyBpZGVhbCByZXNvbHV0aW9uIHRvIHVzZSBmcm9tIHRoZSBzb3VyY2UgaW4gb3JkZXIgdG8gYWNoaWV2ZVxuICogcGl4ZWwgbWFwcGluZyBhcyBjbG9zZSBhcyBwb3NzaWJsZSB0byAxOjEgZHVyaW5nIHJlcHJvamVjdGlvbi5cbiAqIFRoZSByZXNvbHV0aW9uIGlzIGNhbGN1bGF0ZWQgcmVnYXJkbGVzcyBvZiB3aGF0IHJlc29sdXRpb25zXG4gKiBhcmUgYWN0dWFsbHkgYXZhaWxhYmxlIGluIHRoZSBkYXRhc2V0IChUaWxlR3JpZCwgSW1hZ2UsIC4uLikuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBzb3VyY2VQcm9qIFNvdXJjZSBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSB0YXJnZXRQcm9qIFRhcmdldCBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gdGFyZ2V0Q2VudGVyIFRhcmdldCBjZW50ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0UmVzb2x1dGlvbiBUYXJnZXQgcmVzb2x1dGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGJlc3QgcmVzb2x1dGlvbiB0byB1c2UuIENhbiBiZSArLUluZmluaXR5LCBOYU4gb3IgMC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVNvdXJjZVJlc29sdXRpb24oc291cmNlUHJvaiwgdGFyZ2V0UHJvaixcbiAgdGFyZ2V0Q2VudGVyLCB0YXJnZXRSZXNvbHV0aW9uKSB7XG5cbiAgdmFyIHNvdXJjZUNlbnRlciA9IHRyYW5zZm9ybSh0YXJnZXRDZW50ZXIsIHRhcmdldFByb2osIHNvdXJjZVByb2opO1xuXG4gIC8vIGNhbGN1bGF0ZSB0aGUgaWRlYWwgcmVzb2x1dGlvbiBvZiB0aGUgc291cmNlIGRhdGFcbiAgdmFyIHNvdXJjZVJlc29sdXRpb24gPSBnZXRQb2ludFJlc29sdXRpb24odGFyZ2V0UHJvaiwgdGFyZ2V0UmVzb2x1dGlvbiwgdGFyZ2V0Q2VudGVyKTtcblxuICB2YXIgdGFyZ2V0TWV0ZXJzUGVyVW5pdCA9IHRhcmdldFByb2ouZ2V0TWV0ZXJzUGVyVW5pdCgpO1xuICBpZiAodGFyZ2V0TWV0ZXJzUGVyVW5pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc291cmNlUmVzb2x1dGlvbiAqPSB0YXJnZXRNZXRlcnNQZXJVbml0O1xuICB9XG4gIHZhciBzb3VyY2VNZXRlcnNQZXJVbml0ID0gc291cmNlUHJvai5nZXRNZXRlcnNQZXJVbml0KCk7XG4gIGlmIChzb3VyY2VNZXRlcnNQZXJVbml0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBzb3VyY2VSZXNvbHV0aW9uIC89IHNvdXJjZU1ldGVyc1BlclVuaXQ7XG4gIH1cblxuICAvLyBCYXNlZCBvbiB0aGUgcHJvamVjdGlvbiBwcm9wZXJ0aWVzLCB0aGUgcG9pbnQgcmVzb2x1dGlvbiBhdCB0aGUgc3BlY2lmaWVkXG4gIC8vIGNvb3JkaW5hdGVzIG1heSBiZSBzbGlnaHRseSBkaWZmZXJlbnQuIFdlIG5lZWQgdG8gcmV2ZXJzZS1jb21wZW5zYXRlIHRoaXNcbiAgLy8gaW4gb3JkZXIgdG8gYWNoaWV2ZSBvcHRpbWFsIHJlc3VsdHMuXG5cbiAgdmFyIHNvdXJjZUV4dGVudCA9IHNvdXJjZVByb2ouZ2V0RXh0ZW50KCk7XG4gIGlmICghc291cmNlRXh0ZW50IHx8IGNvbnRhaW5zQ29vcmRpbmF0ZShzb3VyY2VFeHRlbnQsIHNvdXJjZUNlbnRlcikpIHtcbiAgICB2YXIgY29tcGVuc2F0aW9uRmFjdG9yID0gZ2V0UG9pbnRSZXNvbHV0aW9uKHNvdXJjZVByb2osIHNvdXJjZVJlc29sdXRpb24sIHNvdXJjZUNlbnRlcikgL1xuICAgICAgICBzb3VyY2VSZXNvbHV0aW9uO1xuICAgIGlmIChpc0Zpbml0ZShjb21wZW5zYXRpb25GYWN0b3IpICYmIGNvbXBlbnNhdGlvbkZhY3RvciA+IDApIHtcbiAgICAgIHNvdXJjZVJlc29sdXRpb24gLz0gY29tcGVuc2F0aW9uRmFjdG9yO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzb3VyY2VSZXNvbHV0aW9uO1xufVxuXG5cbi8qKlxuICogRW5sYXJnZSB0aGUgY2xpcHBpbmcgdHJpYW5nbGUgcG9pbnQgYnkgMSBwaXhlbCB0byBlbnN1cmUgdGhlIGVkZ2VzIG92ZXJsYXBcbiAqIGluIG9yZGVyIHRvIG1hc2sgZ2FwcyBjYXVzZWQgYnkgYW50aWFsaWFzaW5nLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBjZW50cm9pZFggQ2VudHJvaWQgb2YgdGhlIHRyaWFuZ2xlICh4IGNvb3JkaW5hdGUgaW4gcGl4ZWxzKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjZW50cm9pZFkgQ2VudHJvaWQgb2YgdGhlIHRyaWFuZ2xlICh5IGNvb3JkaW5hdGUgaW4gcGl4ZWxzKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgKGluIHBpeGVscykuXG4gKiBAcGFyYW0ge251bWJlcn0geSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IChpbiBwaXhlbHMpLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IE5ldyBwb2ludCAxIHB4IGZhcnRoZXIgZnJvbSB0aGUgY2VudHJvaWQuXG4gKi9cbmZ1bmN0aW9uIGVubGFyZ2VDbGlwUG9pbnQoY2VudHJvaWRYLCBjZW50cm9pZFksIHgsIHkpIHtcbiAgdmFyIGRYID0geCAtIGNlbnRyb2lkWDtcbiAgdmFyIGRZID0geSAtIGNlbnRyb2lkWTtcbiAgdmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KGRYICogZFggKyBkWSAqIGRZKTtcbiAgcmV0dXJuIFtNYXRoLnJvdW5kKHggKyBkWCAvIGRpc3RhbmNlKSwgTWF0aC5yb3VuZCh5ICsgZFkgLyBkaXN0YW5jZSldO1xufVxuXG5cbi8qKlxuICogUmVuZGVycyB0aGUgc291cmNlIGRhdGEgaW50byBuZXcgY2FudmFzIGJhc2VkIG9uIHRoZSB0cmlhbmd1bGF0aW9uLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBXaWR0aCBvZiB0aGUgY2FudmFzLlxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBIZWlnaHQgb2YgdGhlIGNhbnZhcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICogQHBhcmFtIHtudW1iZXJ9IHNvdXJjZVJlc29sdXRpb24gU291cmNlIHJlc29sdXRpb24uXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gc291cmNlRXh0ZW50IEV4dGVudCBvZiB0aGUgZGF0YSBzb3VyY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0UmVzb2x1dGlvbiBUYXJnZXQgcmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSB0YXJnZXRFeHRlbnQgVGFyZ2V0IGV4dGVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9yZXByb2ovVHJpYW5ndWxhdGlvbi5qc1wiKS5kZWZhdWx0fSB0cmlhbmd1bGF0aW9uXG4gKiBDYWxjdWxhdGVkIHRyaWFuZ3VsYXRpb24uXG4gKiBAcGFyYW0ge0FycmF5PHtleHRlbnQ6IGltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudCxcbiAqICAgICAgICAgICAgICAgICBpbWFnZTogKEhUTUxDYW52YXNFbGVtZW50fEhUTUxJbWFnZUVsZW1lbnR8SFRNTFZpZGVvRWxlbWVudCl9Pn0gc291cmNlc1xuICogQXJyYXkgb2Ygc291cmNlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBndXR0ZXIgR3V0dGVyIG9mIHRoZSBzb3VyY2VzLlxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3JlbmRlckVkZ2VzIFJlbmRlciByZXByb2plY3Rpb24gZWRnZXMuXG4gKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH0gQ2FudmFzIHdpdGggcmVwcm9qZWN0ZWQgZGF0YS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcih3aWR0aCwgaGVpZ2h0LCBwaXhlbFJhdGlvLFxuICBzb3VyY2VSZXNvbHV0aW9uLCBzb3VyY2VFeHRlbnQsIHRhcmdldFJlc29sdXRpb24sIHRhcmdldEV4dGVudCxcbiAgdHJpYW5ndWxhdGlvbiwgc291cmNlcywgZ3V0dGVyLCBvcHRfcmVuZGVyRWRnZXMpIHtcblxuICB2YXIgY29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQyRChNYXRoLnJvdW5kKHBpeGVsUmF0aW8gKiB3aWR0aCksXG4gICAgTWF0aC5yb3VuZChwaXhlbFJhdGlvICogaGVpZ2h0KSk7XG5cbiAgaWYgKHNvdXJjZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGNvbnRleHQuY2FudmFzO1xuICB9XG5cbiAgY29udGV4dC5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcblxuICB2YXIgc291cmNlRGF0YUV4dGVudCA9IGNyZWF0ZUVtcHR5KCk7XG4gIHNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbihzcmMsIGksIGFycikge1xuICAgIGV4dGVuZChzb3VyY2VEYXRhRXh0ZW50LCBzcmMuZXh0ZW50KTtcbiAgfSk7XG5cbiAgdmFyIGNhbnZhc1dpZHRoSW5Vbml0cyA9IGdldFdpZHRoKHNvdXJjZURhdGFFeHRlbnQpO1xuICB2YXIgY2FudmFzSGVpZ2h0SW5Vbml0cyA9IGdldEhlaWdodChzb3VyY2VEYXRhRXh0ZW50KTtcbiAgdmFyIHN0aXRjaENvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0MkQoXG4gICAgTWF0aC5yb3VuZChwaXhlbFJhdGlvICogY2FudmFzV2lkdGhJblVuaXRzIC8gc291cmNlUmVzb2x1dGlvbiksXG4gICAgTWF0aC5yb3VuZChwaXhlbFJhdGlvICogY2FudmFzSGVpZ2h0SW5Vbml0cyAvIHNvdXJjZVJlc29sdXRpb24pKTtcblxuICB2YXIgc3RpdGNoU2NhbGUgPSBwaXhlbFJhdGlvIC8gc291cmNlUmVzb2x1dGlvbjtcblxuICBzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24oc3JjLCBpLCBhcnIpIHtcbiAgICB2YXIgeFBvcyA9IHNyYy5leHRlbnRbMF0gLSBzb3VyY2VEYXRhRXh0ZW50WzBdO1xuICAgIHZhciB5UG9zID0gLShzcmMuZXh0ZW50WzNdIC0gc291cmNlRGF0YUV4dGVudFszXSk7XG4gICAgdmFyIHNyY1dpZHRoID0gZ2V0V2lkdGgoc3JjLmV4dGVudCk7XG4gICAgdmFyIHNyY0hlaWdodCA9IGdldEhlaWdodChzcmMuZXh0ZW50KTtcblxuICAgIHN0aXRjaENvbnRleHQuZHJhd0ltYWdlKFxuICAgICAgc3JjLmltYWdlLFxuICAgICAgZ3V0dGVyLCBndXR0ZXIsXG4gICAgICBzcmMuaW1hZ2Uud2lkdGggLSAyICogZ3V0dGVyLCBzcmMuaW1hZ2UuaGVpZ2h0IC0gMiAqIGd1dHRlcixcbiAgICAgIHhQb3MgKiBzdGl0Y2hTY2FsZSwgeVBvcyAqIHN0aXRjaFNjYWxlLFxuICAgICAgc3JjV2lkdGggKiBzdGl0Y2hTY2FsZSwgc3JjSGVpZ2h0ICogc3RpdGNoU2NhbGUpO1xuICB9KTtcblxuICB2YXIgdGFyZ2V0VG9wTGVmdCA9IGdldFRvcExlZnQodGFyZ2V0RXh0ZW50KTtcblxuICB0cmlhbmd1bGF0aW9uLmdldFRyaWFuZ2xlcygpLmZvckVhY2goZnVuY3Rpb24odHJpYW5nbGUsIGksIGFycikge1xuICAgIC8qIENhbGN1bGF0ZSBhZmZpbmUgdHJhbnNmb3JtIChzcmMgLT4gZHN0KVxuICAgICAqIFJlc3VsdGluZyBtYXRyaXggY2FuIGJlIHVzZWQgdG8gdHJhbnNmb3JtIGNvb3JkaW5hdGVcbiAgICAgKiBmcm9tIGBzb3VyY2VQcm9qZWN0aW9uYCB0byBkZXN0aW5hdGlvbiBwaXhlbHMuXG4gICAgICpcbiAgICAgKiBUbyBvcHRpbWl6ZSBudW1iZXIgb2YgY29udGV4dCBjYWxscyBhbmQgaW5jcmVhc2UgbnVtZXJpY2FsIHN0YWJpbGl0eSxcbiAgICAgKiB3ZSBhbHNvIGRvIHRoZSBmb2xsb3dpbmcgb3BlcmF0aW9uczpcbiAgICAgKiB0cmFucygtdG9wTGVmdEV4dGVudENvcm5lciksIHNjYWxlKDEgLyB0YXJnZXRSZXNvbHV0aW9uKSwgc2NhbGUoMSwgLTEpXG4gICAgICogaGVyZSBiZWZvcmUgc29sdmluZyB0aGUgbGluZWFyIHN5c3RlbSBzbyBbdWksIHZpXSBhcmUgcGl4ZWwgY29vcmRpbmF0ZXMuXG4gICAgICpcbiAgICAgKiBTcmMgcG9pbnRzOiB4aSwgeWlcbiAgICAgKiBEc3QgcG9pbnRzOiB1aSwgdmlcbiAgICAgKiBBZmZpbmUgY29lZmZpY2llbnRzOiBhaWpcbiAgICAgKlxuICAgICAqIHwgeDAgeTAgMSAgMCAgMCAwIHwgICB8YTAwfCAgIHx1MHxcbiAgICAgKiB8IHgxIHkxIDEgIDAgIDAgMCB8ICAgfGEwMXwgICB8dTF8XG4gICAgICogfCB4MiB5MiAxICAwICAwIDAgfCB4IHxhMDJ8ID0gfHUyfFxuICAgICAqIHwgIDAgIDAgMCB4MCB5MCAxIHwgICB8YTEwfCAgIHx2MHxcbiAgICAgKiB8ICAwICAwIDAgeDEgeTEgMSB8ICAgfGExMXwgICB8djF8XG4gICAgICogfCAgMCAgMCAwIHgyIHkyIDEgfCAgIHxhMTJ8ICAgfHYyfFxuICAgICAqL1xuICAgIHZhciBzb3VyY2UgPSB0cmlhbmdsZS5zb3VyY2U7XG4gICAgdmFyIHRhcmdldCA9IHRyaWFuZ2xlLnRhcmdldDtcbiAgICB2YXIgeDAgPSBzb3VyY2VbMF1bMF0sIHkwID0gc291cmNlWzBdWzFdO1xuICAgIHZhciB4MSA9IHNvdXJjZVsxXVswXSwgeTEgPSBzb3VyY2VbMV1bMV07XG4gICAgdmFyIHgyID0gc291cmNlWzJdWzBdLCB5MiA9IHNvdXJjZVsyXVsxXTtcbiAgICB2YXIgdTAgPSAodGFyZ2V0WzBdWzBdIC0gdGFyZ2V0VG9wTGVmdFswXSkgLyB0YXJnZXRSZXNvbHV0aW9uO1xuICAgIHZhciB2MCA9IC0odGFyZ2V0WzBdWzFdIC0gdGFyZ2V0VG9wTGVmdFsxXSkgLyB0YXJnZXRSZXNvbHV0aW9uO1xuICAgIHZhciB1MSA9ICh0YXJnZXRbMV1bMF0gLSB0YXJnZXRUb3BMZWZ0WzBdKSAvIHRhcmdldFJlc29sdXRpb247XG4gICAgdmFyIHYxID0gLSh0YXJnZXRbMV1bMV0gLSB0YXJnZXRUb3BMZWZ0WzFdKSAvIHRhcmdldFJlc29sdXRpb247XG4gICAgdmFyIHUyID0gKHRhcmdldFsyXVswXSAtIHRhcmdldFRvcExlZnRbMF0pIC8gdGFyZ2V0UmVzb2x1dGlvbjtcbiAgICB2YXIgdjIgPSAtKHRhcmdldFsyXVsxXSAtIHRhcmdldFRvcExlZnRbMV0pIC8gdGFyZ2V0UmVzb2x1dGlvbjtcblxuICAgIC8vIFNoaWZ0IGFsbCB0aGUgc291cmNlIHBvaW50cyB0byBpbXByb3ZlIG51bWVyaWNhbCBzdGFiaWxpdHlcbiAgICAvLyBvZiBhbGwgdGhlIHN1YnNlcXVlbnQgY2FsY3VsYXRpb25zLiBUaGUgW3gwLCB5MF0gaXMgdXNlZCBoZXJlLlxuICAgIC8vIFRoaXMgaXMgYWxzbyB1c2VkIHRvIHNpbXBsaWZ5IHRoZSBsaW5lYXIgc3lzdGVtLlxuICAgIHZhciBzb3VyY2VOdW1lcmljYWxTaGlmdFggPSB4MDtcbiAgICB2YXIgc291cmNlTnVtZXJpY2FsU2hpZnRZID0geTA7XG4gICAgeDAgPSAwO1xuICAgIHkwID0gMDtcbiAgICB4MSAtPSBzb3VyY2VOdW1lcmljYWxTaGlmdFg7XG4gICAgeTEgLT0gc291cmNlTnVtZXJpY2FsU2hpZnRZO1xuICAgIHgyIC09IHNvdXJjZU51bWVyaWNhbFNoaWZ0WDtcbiAgICB5MiAtPSBzb3VyY2VOdW1lcmljYWxTaGlmdFk7XG5cbiAgICB2YXIgYXVnbWVudGVkTWF0cml4ID0gW1xuICAgICAgW3gxLCB5MSwgMCwgMCwgdTEgLSB1MF0sXG4gICAgICBbeDIsIHkyLCAwLCAwLCB1MiAtIHUwXSxcbiAgICAgIFswLCAwLCB4MSwgeTEsIHYxIC0gdjBdLFxuICAgICAgWzAsIDAsIHgyLCB5MiwgdjIgLSB2MF1cbiAgICBdO1xuICAgIHZhciBhZmZpbmVDb2VmcyA9IHNvbHZlTGluZWFyU3lzdGVtKGF1Z21lbnRlZE1hdHJpeCk7XG4gICAgaWYgKCFhZmZpbmVDb2Vmcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgdmFyIGNlbnRyb2lkWCA9ICh1MCArIHUxICsgdTIpIC8gMztcbiAgICB2YXIgY2VudHJvaWRZID0gKHYwICsgdjEgKyB2MikgLyAzO1xuICAgIHZhciBwMCA9IGVubGFyZ2VDbGlwUG9pbnQoY2VudHJvaWRYLCBjZW50cm9pZFksIHUwLCB2MCk7XG4gICAgdmFyIHAxID0gZW5sYXJnZUNsaXBQb2ludChjZW50cm9pZFgsIGNlbnRyb2lkWSwgdTEsIHYxKTtcbiAgICB2YXIgcDIgPSBlbmxhcmdlQ2xpcFBvaW50KGNlbnRyb2lkWCwgY2VudHJvaWRZLCB1MiwgdjIpO1xuXG4gICAgY29udGV4dC5tb3ZlVG8ocDFbMF0sIHAxWzFdKTtcbiAgICBjb250ZXh0LmxpbmVUbyhwMFswXSwgcDBbMV0pO1xuICAgIGNvbnRleHQubGluZVRvKHAyWzBdLCBwMlsxXSk7XG4gICAgY29udGV4dC5jbGlwKCk7XG5cbiAgICBjb250ZXh0LnRyYW5zZm9ybShcbiAgICAgIGFmZmluZUNvZWZzWzBdLCBhZmZpbmVDb2Vmc1syXSwgYWZmaW5lQ29lZnNbMV0sIGFmZmluZUNvZWZzWzNdLCB1MCwgdjApO1xuXG4gICAgY29udGV4dC50cmFuc2xhdGUoc291cmNlRGF0YUV4dGVudFswXSAtIHNvdXJjZU51bWVyaWNhbFNoaWZ0WCxcbiAgICAgIHNvdXJjZURhdGFFeHRlbnRbM10gLSBzb3VyY2VOdW1lcmljYWxTaGlmdFkpO1xuXG4gICAgY29udGV4dC5zY2FsZShzb3VyY2VSZXNvbHV0aW9uIC8gcGl4ZWxSYXRpbyxcbiAgICAgIC1zb3VyY2VSZXNvbHV0aW9uIC8gcGl4ZWxSYXRpbyk7XG5cbiAgICBjb250ZXh0LmRyYXdJbWFnZShzdGl0Y2hDb250ZXh0LmNhbnZhcywgMCwgMCk7XG4gICAgY29udGV4dC5yZXN0b3JlKCk7XG4gIH0pO1xuXG4gIGlmIChvcHRfcmVuZGVyRWRnZXMpIHtcbiAgICBjb250ZXh0LnNhdmUoKTtcblxuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAnYmxhY2snO1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gMTtcblxuICAgIHRyaWFuZ3VsYXRpb24uZ2V0VHJpYW5nbGVzKCkuZm9yRWFjaChmdW5jdGlvbih0cmlhbmdsZSwgaSwgYXJyKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gdHJpYW5nbGUudGFyZ2V0O1xuICAgICAgdmFyIHUwID0gKHRhcmdldFswXVswXSAtIHRhcmdldFRvcExlZnRbMF0pIC8gdGFyZ2V0UmVzb2x1dGlvbjtcbiAgICAgIHZhciB2MCA9IC0odGFyZ2V0WzBdWzFdIC0gdGFyZ2V0VG9wTGVmdFsxXSkgLyB0YXJnZXRSZXNvbHV0aW9uO1xuICAgICAgdmFyIHUxID0gKHRhcmdldFsxXVswXSAtIHRhcmdldFRvcExlZnRbMF0pIC8gdGFyZ2V0UmVzb2x1dGlvbjtcbiAgICAgIHZhciB2MSA9IC0odGFyZ2V0WzFdWzFdIC0gdGFyZ2V0VG9wTGVmdFsxXSkgLyB0YXJnZXRSZXNvbHV0aW9uO1xuICAgICAgdmFyIHUyID0gKHRhcmdldFsyXVswXSAtIHRhcmdldFRvcExlZnRbMF0pIC8gdGFyZ2V0UmVzb2x1dGlvbjtcbiAgICAgIHZhciB2MiA9IC0odGFyZ2V0WzJdWzFdIC0gdGFyZ2V0VG9wTGVmdFsxXSkgLyB0YXJnZXRSZXNvbHV0aW9uO1xuXG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgY29udGV4dC5tb3ZlVG8odTEsIHYxKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHUwLCB2MCk7XG4gICAgICBjb250ZXh0LmxpbmVUbyh1MiwgdjIpO1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgfSk7XG5cbiAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgfVxuICByZXR1cm4gY29udGV4dC5jYW52YXM7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlcHJvai5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVwcm9qL1RpbGVcbiAqL1xuaW1wb3J0IHtFUlJPUl9USFJFU0hPTER9IGZyb20gJy4vY29tbW9uLmpzJztcblxuaW1wb3J0IFRpbGUgZnJvbSAnLi4vVGlsZS5qcyc7XG5pbXBvcnQgVGlsZVN0YXRlIGZyb20gJy4uL1RpbGVTdGF0ZS5qcyc7XG5pbXBvcnQge2xpc3RlbiwgdW5saXN0ZW5CeUtleX0gZnJvbSAnLi4vZXZlbnRzLmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQge2dldEFyZWEsIGdldENlbnRlciwgZ2V0SW50ZXJzZWN0aW9ufSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IHtjbGFtcH0gZnJvbSAnLi4vbWF0aC5qcyc7XG5pbXBvcnQge2NhbGN1bGF0ZVNvdXJjZVJlc29sdXRpb24sIHJlbmRlciBhcyByZW5kZXJSZXByb2plY3RlZH0gZnJvbSAnLi4vcmVwcm9qLmpzJztcbmltcG9ydCBUcmlhbmd1bGF0aW9uIGZyb20gJy4vVHJpYW5ndWxhdGlvbi5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24obnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyKSA6IGltcG9ydChcIi4uL1RpbGUuanNcIikuZGVmYXVsdH0gRnVuY3Rpb25UeXBlXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIENsYXNzIGVuY2Fwc3VsYXRpbmcgc2luZ2xlIHJlcHJvamVjdGVkIHRpbGUuXG4gKiBTZWUge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVGlsZUltYWdlflRpbGVJbWFnZX0uXG4gKlxuICovXG52YXIgUmVwcm9qVGlsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFRpbGUpIHtcbiAgZnVuY3Rpb24gUmVwcm9qVGlsZShcbiAgICBzb3VyY2VQcm9qLFxuICAgIHNvdXJjZVRpbGVHcmlkLFxuICAgIHRhcmdldFByb2osXG4gICAgdGFyZ2V0VGlsZUdyaWQsXG4gICAgdGlsZUNvb3JkLFxuICAgIHdyYXBwZWRUaWxlQ29vcmQsXG4gICAgcGl4ZWxSYXRpbyxcbiAgICBndXR0ZXIsXG4gICAgZ2V0VGlsZUZ1bmN0aW9uLFxuICAgIG9wdF9lcnJvclRocmVzaG9sZCxcbiAgICBvcHRfcmVuZGVyRWRnZXNcbiAgKSB7XG4gICAgVGlsZS5jYWxsKHRoaXMsIHRpbGVDb29yZCwgVGlsZVN0YXRlLklETEUpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlckVkZ2VzXyA9IG9wdF9yZW5kZXJFZGdlcyAhPT0gdW5kZWZpbmVkID8gb3B0X3JlbmRlckVkZ2VzIDogZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5waXhlbFJhdGlvXyA9IHBpeGVsUmF0aW87XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5ndXR0ZXJfID0gZ3V0dGVyO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5jYW52YXNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5zb3VyY2VUaWxlR3JpZF8gPSBzb3VyY2VUaWxlR3JpZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy50YXJnZXRUaWxlR3JpZF8gPSB0YXJnZXRUaWxlR3JpZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9XG4gICAgICovXG4gICAgdGhpcy53cmFwcGVkVGlsZUNvb3JkXyA9IHdyYXBwZWRUaWxlQ29vcmQgPyB3cmFwcGVkVGlsZUNvb3JkIDogdGlsZUNvb3JkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IUFycmF5PGltcG9ydChcIi4uL1RpbGUuanNcIikuZGVmYXVsdD59XG4gICAgICovXG4gICAgdGhpcy5zb3VyY2VUaWxlc18gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PGltcG9ydChcIi4uL2V2ZW50cy5qc1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMuc291cmNlc0xpc3RlbmVyS2V5c18gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc291cmNlWl8gPSAwO1xuXG4gICAgdmFyIHRhcmdldEV4dGVudCA9IHRhcmdldFRpbGVHcmlkLmdldFRpbGVDb29yZEV4dGVudCh0aGlzLndyYXBwZWRUaWxlQ29vcmRfKTtcbiAgICB2YXIgbWF4VGFyZ2V0RXh0ZW50ID0gdGhpcy50YXJnZXRUaWxlR3JpZF8uZ2V0RXh0ZW50KCk7XG4gICAgdmFyIG1heFNvdXJjZUV4dGVudCA9IHRoaXMuc291cmNlVGlsZUdyaWRfLmdldEV4dGVudCgpO1xuXG4gICAgdmFyIGxpbWl0ZWRUYXJnZXRFeHRlbnQgPSBtYXhUYXJnZXRFeHRlbnQgP1xuICAgICAgZ2V0SW50ZXJzZWN0aW9uKHRhcmdldEV4dGVudCwgbWF4VGFyZ2V0RXh0ZW50KSA6IHRhcmdldEV4dGVudDtcblxuICAgIGlmIChnZXRBcmVhKGxpbWl0ZWRUYXJnZXRFeHRlbnQpID09PSAwKSB7XG4gICAgICAvLyBUaWxlIGlzIGNvbXBsZXRlbHkgb3V0c2lkZSByYW5nZSAtPiBFTVBUWVxuICAgICAgLy8gVE9ETzogaXMgaXQgYWN0dWFsbHkgY29ycmVjdCB0aGF0IHRoZSBzb3VyY2UgZXZlbiBjcmVhdGVzIHRoZSB0aWxlID9cbiAgICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuRU1QVFk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZVByb2pFeHRlbnQgPSBzb3VyY2VQcm9qLmdldEV4dGVudCgpO1xuICAgIGlmIChzb3VyY2VQcm9qRXh0ZW50KSB7XG4gICAgICBpZiAoIW1heFNvdXJjZUV4dGVudCkge1xuICAgICAgICBtYXhTb3VyY2VFeHRlbnQgPSBzb3VyY2VQcm9qRXh0ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF4U291cmNlRXh0ZW50ID0gZ2V0SW50ZXJzZWN0aW9uKG1heFNvdXJjZUV4dGVudCwgc291cmNlUHJvakV4dGVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldFJlc29sdXRpb24gPSB0YXJnZXRUaWxlR3JpZC5nZXRSZXNvbHV0aW9uKFxuICAgICAgdGhpcy53cmFwcGVkVGlsZUNvb3JkX1swXSk7XG5cbiAgICB2YXIgdGFyZ2V0Q2VudGVyID0gZ2V0Q2VudGVyKGxpbWl0ZWRUYXJnZXRFeHRlbnQpO1xuICAgIHZhciBzb3VyY2VSZXNvbHV0aW9uID0gY2FsY3VsYXRlU291cmNlUmVzb2x1dGlvbihcbiAgICAgIHNvdXJjZVByb2osIHRhcmdldFByb2osIHRhcmdldENlbnRlciwgdGFyZ2V0UmVzb2x1dGlvbik7XG5cbiAgICBpZiAoIWlzRmluaXRlKHNvdXJjZVJlc29sdXRpb24pIHx8IHNvdXJjZVJlc29sdXRpb24gPD0gMCkge1xuICAgICAgLy8gaW52YWxpZCBzb3VyY2VSZXNvbHV0aW9uIC0+IEVNUFRZXG4gICAgICAvLyBwcm9iYWJseSBlZGdlcyBvZiB0aGUgcHJvamVjdGlvbnMgd2hlbiBubyBleHRlbnQgaXMgZGVmaW5lZFxuICAgICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5FTVBUWTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZXJyb3JUaHJlc2hvbGRJblBpeGVscyA9IG9wdF9lcnJvclRocmVzaG9sZCAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdF9lcnJvclRocmVzaG9sZCA6IEVSUk9SX1RIUkVTSE9MRDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFpbXBvcnQoXCIuL1RyaWFuZ3VsYXRpb24uanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWFuZ3VsYXRpb25fID0gbmV3IFRyaWFuZ3VsYXRpb24oXG4gICAgICBzb3VyY2VQcm9qLCB0YXJnZXRQcm9qLCBsaW1pdGVkVGFyZ2V0RXh0ZW50LCBtYXhTb3VyY2VFeHRlbnQsXG4gICAgICBzb3VyY2VSZXNvbHV0aW9uICogZXJyb3JUaHJlc2hvbGRJblBpeGVscyk7XG5cbiAgICBpZiAodGhpcy50cmlhbmd1bGF0aW9uXy5nZXRUcmlhbmdsZXMoKS5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIG5vIHZhbGlkIHRyaWFuZ2xlcyAtPiBFTVBUWVxuICAgICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5FTVBUWTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnNvdXJjZVpfID0gc291cmNlVGlsZUdyaWQuZ2V0WkZvclJlc29sdXRpb24oc291cmNlUmVzb2x1dGlvbik7XG4gICAgdmFyIHNvdXJjZUV4dGVudCA9IHRoaXMudHJpYW5ndWxhdGlvbl8uY2FsY3VsYXRlU291cmNlRXh0ZW50KCk7XG5cbiAgICBpZiAobWF4U291cmNlRXh0ZW50KSB7XG4gICAgICBpZiAoc291cmNlUHJvai5jYW5XcmFwWCgpKSB7XG4gICAgICAgIHNvdXJjZUV4dGVudFsxXSA9IGNsYW1wKFxuICAgICAgICAgIHNvdXJjZUV4dGVudFsxXSwgbWF4U291cmNlRXh0ZW50WzFdLCBtYXhTb3VyY2VFeHRlbnRbM10pO1xuICAgICAgICBzb3VyY2VFeHRlbnRbM10gPSBjbGFtcChcbiAgICAgICAgICBzb3VyY2VFeHRlbnRbM10sIG1heFNvdXJjZUV4dGVudFsxXSwgbWF4U291cmNlRXh0ZW50WzNdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNvdXJjZUV4dGVudCA9IGdldEludGVyc2VjdGlvbihzb3VyY2VFeHRlbnQsIG1heFNvdXJjZUV4dGVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFnZXRBcmVhKHNvdXJjZUV4dGVudCkpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuRU1QVFk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzb3VyY2VSYW5nZSA9IHNvdXJjZVRpbGVHcmlkLmdldFRpbGVSYW5nZUZvckV4dGVudEFuZFooXG4gICAgICAgIHNvdXJjZUV4dGVudCwgdGhpcy5zb3VyY2VaXyk7XG5cbiAgICAgIGZvciAodmFyIHNyY1ggPSBzb3VyY2VSYW5nZS5taW5YOyBzcmNYIDw9IHNvdXJjZVJhbmdlLm1heFg7IHNyY1grKykge1xuICAgICAgICBmb3IgKHZhciBzcmNZID0gc291cmNlUmFuZ2UubWluWTsgc3JjWSA8PSBzb3VyY2VSYW5nZS5tYXhZOyBzcmNZKyspIHtcbiAgICAgICAgICB2YXIgdGlsZSA9IGdldFRpbGVGdW5jdGlvbih0aGlzLnNvdXJjZVpfLCBzcmNYLCBzcmNZLCBwaXhlbFJhdGlvKTtcbiAgICAgICAgICBpZiAodGlsZSkge1xuICAgICAgICAgICAgdGhpcy5zb3VyY2VUaWxlc18ucHVzaCh0aWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc291cmNlVGlsZXNfLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkVNUFRZO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICggVGlsZSApIFJlcHJvalRpbGUuX19wcm90b19fID0gVGlsZTtcbiAgUmVwcm9qVGlsZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUaWxlICYmIFRpbGUucHJvdG90eXBlICk7XG4gIFJlcHJvalRpbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVwcm9qVGlsZTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIFJlcHJvalRpbGUucHJvdG90eXBlLmRpc3Bvc2VJbnRlcm5hbCA9IGZ1bmN0aW9uIGRpc3Bvc2VJbnRlcm5hbCAoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT0gVGlsZVN0YXRlLkxPQURJTkcpIHtcbiAgICAgIHRoaXMudW5saXN0ZW5Tb3VyY2VzXygpO1xuICAgIH1cbiAgICBUaWxlLnByb3RvdHlwZS5kaXNwb3NlSW50ZXJuYWwuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBIVE1MIENhbnZhcyBlbGVtZW50IGZvciB0aGlzIHRpbGUuXG4gICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBDYW52YXMuXG4gICAqL1xuICBSZXByb2pUaWxlLnByb3RvdHlwZS5nZXRJbWFnZSA9IGZ1bmN0aW9uIGdldEltYWdlICgpIHtcbiAgICByZXR1cm4gdGhpcy5jYW52YXNfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgUmVwcm9qVGlsZS5wcm90b3R5cGUucmVwcm9qZWN0XyA9IGZ1bmN0aW9uIHJlcHJvamVjdF8gKCkge1xuICAgIHZhciBzb3VyY2VzID0gW107XG4gICAgdGhpcy5zb3VyY2VUaWxlc18uZm9yRWFjaChmdW5jdGlvbih0aWxlLCBpLCBhcnIpIHtcbiAgICAgIGlmICh0aWxlICYmIHRpbGUuZ2V0U3RhdGUoKSA9PSBUaWxlU3RhdGUuTE9BREVEKSB7XG4gICAgICAgIHNvdXJjZXMucHVzaCh7XG4gICAgICAgICAgZXh0ZW50OiB0aGlzLnNvdXJjZVRpbGVHcmlkXy5nZXRUaWxlQ29vcmRFeHRlbnQodGlsZS50aWxlQ29vcmQpLFxuICAgICAgICAgIGltYWdlOiB0aWxlLmdldEltYWdlKClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLnNvdXJjZVRpbGVzXy5sZW5ndGggPSAwO1xuXG4gICAgaWYgKHNvdXJjZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkVSUk9SO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgeiA9IHRoaXMud3JhcHBlZFRpbGVDb29yZF9bMF07XG4gICAgICB2YXIgc2l6ZSA9IHRoaXMudGFyZ2V0VGlsZUdyaWRfLmdldFRpbGVTaXplKHopO1xuICAgICAgdmFyIHdpZHRoID0gdHlwZW9mIHNpemUgPT09ICdudW1iZXInID8gc2l6ZSA6IHNpemVbMF07XG4gICAgICB2YXIgaGVpZ2h0ID0gdHlwZW9mIHNpemUgPT09ICdudW1iZXInID8gc2l6ZSA6IHNpemVbMV07XG4gICAgICB2YXIgdGFyZ2V0UmVzb2x1dGlvbiA9IHRoaXMudGFyZ2V0VGlsZUdyaWRfLmdldFJlc29sdXRpb24oeik7XG4gICAgICB2YXIgc291cmNlUmVzb2x1dGlvbiA9IHRoaXMuc291cmNlVGlsZUdyaWRfLmdldFJlc29sdXRpb24odGhpcy5zb3VyY2VaXyk7XG5cbiAgICAgIHZhciB0YXJnZXRFeHRlbnQgPSB0aGlzLnRhcmdldFRpbGVHcmlkXy5nZXRUaWxlQ29vcmRFeHRlbnQoXG4gICAgICAgIHRoaXMud3JhcHBlZFRpbGVDb29yZF8pO1xuICAgICAgdGhpcy5jYW52YXNfID0gcmVuZGVyUmVwcm9qZWN0ZWQod2lkdGgsIGhlaWdodCwgdGhpcy5waXhlbFJhdGlvXyxcbiAgICAgICAgc291cmNlUmVzb2x1dGlvbiwgdGhpcy5zb3VyY2VUaWxlR3JpZF8uZ2V0RXh0ZW50KCksXG4gICAgICAgIHRhcmdldFJlc29sdXRpb24sIHRhcmdldEV4dGVudCwgdGhpcy50cmlhbmd1bGF0aW9uXywgc291cmNlcyxcbiAgICAgICAgdGhpcy5ndXR0ZXJfLCB0aGlzLnJlbmRlckVkZ2VzXyk7XG5cbiAgICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuTE9BREVEO1xuICAgIH1cbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIFJlcHJvalRpbGUucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiBsb2FkICgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PSBUaWxlU3RhdGUuSURMRSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5MT0FESU5HO1xuICAgICAgdGhpcy5jaGFuZ2VkKCk7XG5cbiAgICAgIHZhciBsZWZ0VG9Mb2FkID0gMDtcblxuICAgICAgdGhpcy5zb3VyY2VzTGlzdGVuZXJLZXlzXyA9IFtdO1xuICAgICAgdGhpcy5zb3VyY2VUaWxlc18uZm9yRWFjaChmdW5jdGlvbih0aWxlLCBpLCBhcnIpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGlsZS5nZXRTdGF0ZSgpO1xuICAgICAgICBpZiAoc3RhdGUgPT0gVGlsZVN0YXRlLklETEUgfHwgc3RhdGUgPT0gVGlsZVN0YXRlLkxPQURJTkcpIHtcbiAgICAgICAgICBsZWZ0VG9Mb2FkKys7XG5cbiAgICAgICAgICB2YXIgc291cmNlTGlzdGVuS2V5ID0gbGlzdGVuKHRpbGUsIEV2ZW50VHlwZS5DSEFOR0UsXG4gICAgICAgICAgICBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgIHZhciBzdGF0ZSA9IHRpbGUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgaWYgKHN0YXRlID09IFRpbGVTdGF0ZS5MT0FERUQgfHxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPT0gVGlsZVN0YXRlLkVSUk9SIHx8XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID09IFRpbGVTdGF0ZS5FTVBUWSkge1xuICAgICAgICAgICAgICAgIHVubGlzdGVuQnlLZXkoc291cmNlTGlzdGVuS2V5KTtcbiAgICAgICAgICAgICAgICBsZWZ0VG9Mb2FkLS07XG4gICAgICAgICAgICAgICAgaWYgKGxlZnRUb0xvYWQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMudW5saXN0ZW5Tb3VyY2VzXygpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5yZXByb2plY3RfKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICB0aGlzLnNvdXJjZXNMaXN0ZW5lcktleXNfLnB1c2goc291cmNlTGlzdGVuS2V5KTtcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgdGhpcy5zb3VyY2VUaWxlc18uZm9yRWFjaChmdW5jdGlvbih0aWxlLCBpLCBhcnIpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGlsZS5nZXRTdGF0ZSgpO1xuICAgICAgICBpZiAoc3RhdGUgPT0gVGlsZVN0YXRlLklETEUpIHtcbiAgICAgICAgICB0aWxlLmxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChsZWZ0VG9Mb2FkID09PSAwKSB7XG4gICAgICAgIHNldFRpbWVvdXQodGhpcy5yZXByb2plY3RfLmJpbmQodGhpcyksIDApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFJlcHJvalRpbGUucHJvdG90eXBlLnVubGlzdGVuU291cmNlc18gPSBmdW5jdGlvbiB1bmxpc3RlblNvdXJjZXNfICgpIHtcbiAgICB0aGlzLnNvdXJjZXNMaXN0ZW5lcktleXNfLmZvckVhY2godW5saXN0ZW5CeUtleSk7XG4gICAgdGhpcy5zb3VyY2VzTGlzdGVuZXJLZXlzXyA9IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIFJlcHJvalRpbGU7XG59KFRpbGUpKTtcblxuXG5leHBvcnQgZGVmYXVsdCBSZXByb2pUaWxlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaWxlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9yZXByb2ovVHJpYW5ndWxhdGlvblxuICovXG5pbXBvcnQge2JvdW5kaW5nRXh0ZW50LCBjcmVhdGVFbXB0eSwgZXh0ZW5kQ29vcmRpbmF0ZSwgZ2V0Qm90dG9tTGVmdCwgZ2V0Qm90dG9tUmlnaHQsXG4gIGdldFRvcExlZnQsIGdldFRvcFJpZ2h0LCBnZXRXaWR0aCwgaW50ZXJzZWN0c30gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7bW9kdWxvfSBmcm9tICcuLi9tYXRoLmpzJztcbmltcG9ydCB7Z2V0VHJhbnNmb3JtfSBmcm9tICcuLi9wcm9qLmpzJztcblxuXG4vKipcbiAqIFNpbmdsZSB0cmlhbmdsZTsgY29uc2lzdHMgb2YgMyBzb3VyY2UgcG9pbnRzIGFuZCAzIHRhcmdldCBwb2ludHMuXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBUcmlhbmdsZVxuICogQHByb3BlcnR5IHtBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSBzb3VyY2VcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn0gdGFyZ2V0XG4gKi9cblxuXG4vKipcbiAqIE1heGltdW0gbnVtYmVyIG9mIHN1YmRpdmlzaW9uIHN0ZXBzIGR1cmluZyByYXN0ZXIgcmVwcm9qZWN0aW9uIHRyaWFuZ3VsYXRpb24uXG4gKiBQcmV2ZW50cyBoaWdoIG1lbW9yeSB1c2FnZSBhbmQgbGFyZ2UgbnVtYmVyIG9mIHByb2o0IGNhbGxzIChmb3IgY2VydGFpblxuICogdHJhbnNmb3JtYXRpb25zIGFuZCBhcmVhcykuIEF0IG1vc3QgYDIqKDJedGhpcylgIHRyaWFuZ2xlcyBhcmUgY3JlYXRlZCBmb3JcbiAqIGVhY2ggdHJpYW5ndWxhdGVkIGV4dGVudCAodGlsZS9pbWFnZSkuXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG52YXIgTUFYX1NVQkRJVklTSU9OID0gMTA7XG5cblxuLyoqXG4gKiBNYXhpbXVtIGFsbG93ZWQgc2l6ZSBvZiB0cmlhbmdsZSByZWxhdGl2ZSB0byB3b3JsZCB3aWR0aC4gV2hlbiB0cmFuc2Zvcm1pbmdcbiAqIGNvcm5lcnMgb2Ygd29ybGQgZXh0ZW50IGJldHdlZW4gY2VydGFpbiBwcm9qZWN0aW9ucywgdGhlIHJlc3VsdGluZ1xuICogdHJpYW5ndWxhdGlvbiBzZWVtcyB0byBoYXZlIHplcm8gZXJyb3IgYW5kIG5vIHN1YmRpdmlzaW9uIGlzIHBlcmZvcm1lZC4gSWZcbiAqIHRoZSB0cmlhbmdsZSB3aWR0aCBpcyBtb3JlIHRoYW4gdGhpcyAocmVsYXRpdmUgdG8gd29ybGQgd2lkdGg7IDAtMSksXG4gKiBzdWJkaXZpc29uIGlzIGZvcmNlZCAodXAgdG8gYE1BWF9TVUJESVZJU0lPTmApLiBEZWZhdWx0IGlzIGAwLjI1YC5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbnZhciBNQVhfVFJJQU5HTEVfV0lEVEggPSAwLjI1O1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQ2xhc3MgY29udGFpbmluZyB0cmlhbmd1bGF0aW9uIG9mIHRoZSBnaXZlbiB0YXJnZXQgZXh0ZW50LlxuICogVXNlZCBmb3IgZGV0ZXJtaW5pbmcgc291cmNlIGRhdGEgYW5kIHRoZSByZXByb2plY3Rpb24gaXRzZWxmLlxuICovXG52YXIgVHJpYW5ndWxhdGlvbiA9IGZ1bmN0aW9uIFRyaWFuZ3VsYXRpb24oc291cmNlUHJvaiwgdGFyZ2V0UHJvaiwgdGFyZ2V0RXh0ZW50LCBtYXhTb3VyY2VFeHRlbnQsIGVycm9yVGhyZXNob2xkKSB7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuc291cmNlUHJval8gPSBzb3VyY2VQcm9qO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnRhcmdldFByb2pfID0gdGFyZ2V0UHJvajtcblxuICAvKiogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSAqL1xuICB2YXIgdHJhbnNmb3JtSW52Q2FjaGUgPSB7fTtcbiAgdmFyIHRyYW5zZm9ybUludiA9IGdldFRyYW5zZm9ybSh0aGlzLnRhcmdldFByb2pfLCB0aGlzLnNvdXJjZVByb2pfKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGMgQSBjb29yZGluYXRlLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFRyYW5zZm9ybWVkIGNvb3JkaW5hdGUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnRyYW5zZm9ybUludl8gPSBmdW5jdGlvbihjKSB7XG4gICAgdmFyIGtleSA9IGNbMF0gKyAnLycgKyBjWzFdO1xuICAgIGlmICghdHJhbnNmb3JtSW52Q2FjaGVba2V5XSkge1xuICAgICAgdHJhbnNmb3JtSW52Q2FjaGVba2V5XSA9IHRyYW5zZm9ybUludihjKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zZm9ybUludkNhY2hlW2tleV07XG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5tYXhTb3VyY2VFeHRlbnRfID0gbWF4U291cmNlRXh0ZW50O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5lcnJvclRocmVzaG9sZFNxdWFyZWRfID0gZXJyb3JUaHJlc2hvbGQgKiBlcnJvclRocmVzaG9sZDtcblxuICAvKipcbiAgICogQHR5cGUge0FycmF5PFRyaWFuZ2xlPn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMudHJpYW5nbGVzXyA9IFtdO1xuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgdGhhdCB0aGUgdHJpYW5ndWxhdGlvbiBjcm9zc2VzIGVkZ2Ugb2YgdGhlIHNvdXJjZSBwcm9qZWN0aW9uLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMud3JhcHNYSW5Tb3VyY2VfID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5jYW5XcmFwWEluU291cmNlXyA9IHRoaXMuc291cmNlUHJval8uY2FuV3JhcFgoKSAmJlxuICAgICAgISFtYXhTb3VyY2VFeHRlbnQgJiZcbiAgICAgICEhdGhpcy5zb3VyY2VQcm9qXy5nZXRFeHRlbnQoKSAmJlxuICAgICAgKGdldFdpZHRoKG1heFNvdXJjZUV4dGVudCkgPT0gZ2V0V2lkdGgodGhpcy5zb3VyY2VQcm9qXy5nZXRFeHRlbnQoKSkpO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7P251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuc291cmNlV29ybGRXaWR0aF8gPSB0aGlzLnNvdXJjZVByb2pfLmdldEV4dGVudCgpID9cbiAgICBnZXRXaWR0aCh0aGlzLnNvdXJjZVByb2pfLmdldEV4dGVudCgpKSA6IG51bGw7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHs/bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy50YXJnZXRXb3JsZFdpZHRoXyA9IHRoaXMudGFyZ2V0UHJval8uZ2V0RXh0ZW50KCkgP1xuICAgIGdldFdpZHRoKHRoaXMudGFyZ2V0UHJval8uZ2V0RXh0ZW50KCkpIDogbnVsbDtcblxuICB2YXIgZGVzdGluYXRpb25Ub3BMZWZ0ID0gZ2V0VG9wTGVmdCh0YXJnZXRFeHRlbnQpO1xuICB2YXIgZGVzdGluYXRpb25Ub3BSaWdodCA9IGdldFRvcFJpZ2h0KHRhcmdldEV4dGVudCk7XG4gIHZhciBkZXN0aW5hdGlvbkJvdHRvbVJpZ2h0ID0gZ2V0Qm90dG9tUmlnaHQodGFyZ2V0RXh0ZW50KTtcbiAgdmFyIGRlc3RpbmF0aW9uQm90dG9tTGVmdCA9IGdldEJvdHRvbUxlZnQodGFyZ2V0RXh0ZW50KTtcbiAgdmFyIHNvdXJjZVRvcExlZnQgPSB0aGlzLnRyYW5zZm9ybUludl8oZGVzdGluYXRpb25Ub3BMZWZ0KTtcbiAgdmFyIHNvdXJjZVRvcFJpZ2h0ID0gdGhpcy50cmFuc2Zvcm1JbnZfKGRlc3RpbmF0aW9uVG9wUmlnaHQpO1xuICB2YXIgc291cmNlQm90dG9tUmlnaHQgPSB0aGlzLnRyYW5zZm9ybUludl8oZGVzdGluYXRpb25Cb3R0b21SaWdodCk7XG4gIHZhciBzb3VyY2VCb3R0b21MZWZ0ID0gdGhpcy50cmFuc2Zvcm1JbnZfKGRlc3RpbmF0aW9uQm90dG9tTGVmdCk7XG5cbiAgdGhpcy5hZGRRdWFkXyhcbiAgICBkZXN0aW5hdGlvblRvcExlZnQsIGRlc3RpbmF0aW9uVG9wUmlnaHQsXG4gICAgZGVzdGluYXRpb25Cb3R0b21SaWdodCwgZGVzdGluYXRpb25Cb3R0b21MZWZ0LFxuICAgIHNvdXJjZVRvcExlZnQsIHNvdXJjZVRvcFJpZ2h0LCBzb3VyY2VCb3R0b21SaWdodCwgc291cmNlQm90dG9tTGVmdCxcbiAgICBNQVhfU1VCRElWSVNJT04pO1xuXG4gIGlmICh0aGlzLndyYXBzWEluU291cmNlXykge1xuICAgIHZhciBsZWZ0Qm91bmQgPSBJbmZpbml0eTtcbiAgICB0aGlzLnRyaWFuZ2xlc18uZm9yRWFjaChmdW5jdGlvbih0cmlhbmdsZSwgaSwgYXJyKSB7XG4gICAgICBsZWZ0Qm91bmQgPSBNYXRoLm1pbihsZWZ0Qm91bmQsXG4gICAgICAgIHRyaWFuZ2xlLnNvdXJjZVswXVswXSwgdHJpYW5nbGUuc291cmNlWzFdWzBdLCB0cmlhbmdsZS5zb3VyY2VbMl1bMF0pO1xuICAgIH0pO1xuXG4gICAgLy8gU2hpZnQgdHJpYW5nbGVzIHRvIGJlIGFzIGNsb3NlIHRvIGBsZWZ0Qm91bmRgIGFzIHBvc3NpYmxlXG4gICAgLy8gKGlmIHRoZSBkaXN0YW5jZSBpcyBtb3JlIHRoYW4gYHdvcmxkV2lkdGggLyAyYCBpdCBjYW4gYmUgY2xvc2VyLlxuICAgIHRoaXMudHJpYW5nbGVzXy5mb3JFYWNoKGZ1bmN0aW9uKHRyaWFuZ2xlKSB7XG4gICAgICBpZiAoTWF0aC5tYXgodHJpYW5nbGUuc291cmNlWzBdWzBdLCB0cmlhbmdsZS5zb3VyY2VbMV1bMF0sXG4gICAgICAgIHRyaWFuZ2xlLnNvdXJjZVsyXVswXSkgLSBsZWZ0Qm91bmQgPiB0aGlzLnNvdXJjZVdvcmxkV2lkdGhfIC8gMikge1xuICAgICAgICB2YXIgbmV3VHJpYW5nbGUgPSBbW3RyaWFuZ2xlLnNvdXJjZVswXVswXSwgdHJpYW5nbGUuc291cmNlWzBdWzFdXSxcbiAgICAgICAgICBbdHJpYW5nbGUuc291cmNlWzFdWzBdLCB0cmlhbmdsZS5zb3VyY2VbMV1bMV1dLFxuICAgICAgICAgIFt0cmlhbmdsZS5zb3VyY2VbMl1bMF0sIHRyaWFuZ2xlLnNvdXJjZVsyXVsxXV1dO1xuICAgICAgICBpZiAoKG5ld1RyaWFuZ2xlWzBdWzBdIC0gbGVmdEJvdW5kKSA+IHRoaXMuc291cmNlV29ybGRXaWR0aF8gLyAyKSB7XG4gICAgICAgICAgbmV3VHJpYW5nbGVbMF1bMF0gLT0gdGhpcy5zb3VyY2VXb3JsZFdpZHRoXztcbiAgICAgICAgfVxuICAgICAgICBpZiAoKG5ld1RyaWFuZ2xlWzFdWzBdIC0gbGVmdEJvdW5kKSA+IHRoaXMuc291cmNlV29ybGRXaWR0aF8gLyAyKSB7XG4gICAgICAgICAgbmV3VHJpYW5nbGVbMV1bMF0gLT0gdGhpcy5zb3VyY2VXb3JsZFdpZHRoXztcbiAgICAgICAgfVxuICAgICAgICBpZiAoKG5ld1RyaWFuZ2xlWzJdWzBdIC0gbGVmdEJvdW5kKSA+IHRoaXMuc291cmNlV29ybGRXaWR0aF8gLyAyKSB7XG4gICAgICAgICAgbmV3VHJpYW5nbGVbMl1bMF0gLT0gdGhpcy5zb3VyY2VXb3JsZFdpZHRoXztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJhcmVseSAoaWYgdGhlIGV4dGVudCBjb250YWlucyBib3RoIHRoZSBkYXRlbGluZSBhbmQgcHJpbWUgbWVyaWRpYW4pXG4gICAgICAgIC8vIHRoZSBzaGlmdCBjYW4gaW4gdHVybiBicmVhayBzb21lIHRyaWFuZ2xlcy5cbiAgICAgICAgLy8gRGV0ZWN0IHRoaXMgaGVyZSBhbmQgZG9uJ3Qgc2hpZnQgaW4gc3VjaCBjYXNlcy5cbiAgICAgICAgdmFyIG1pblggPSBNYXRoLm1pbihcbiAgICAgICAgICBuZXdUcmlhbmdsZVswXVswXSwgbmV3VHJpYW5nbGVbMV1bMF0sIG5ld1RyaWFuZ2xlWzJdWzBdKTtcbiAgICAgICAgdmFyIG1heFggPSBNYXRoLm1heChcbiAgICAgICAgICBuZXdUcmlhbmdsZVswXVswXSwgbmV3VHJpYW5nbGVbMV1bMF0sIG5ld1RyaWFuZ2xlWzJdWzBdKTtcbiAgICAgICAgaWYgKChtYXhYIC0gbWluWCkgPCB0aGlzLnNvdXJjZVdvcmxkV2lkdGhfIC8gMikge1xuICAgICAgICAgIHRyaWFuZ2xlLnNvdXJjZSA9IG5ld1RyaWFuZ2xlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIHRyYW5zZm9ybUludkNhY2hlID0ge307XG59O1xuXG4vKipcbiAqIEFkZHMgdHJpYW5nbGUgdG8gdGhlIHRyaWFuZ3VsYXRpb24uXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gYSBUaGUgdGFyZ2V0IGEgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBiIFRoZSB0YXJnZXQgYiBjb29yZGluYXRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGMgVGhlIHRhcmdldCBjIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gYVNyYyBUaGUgc291cmNlIGEgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBiU3JjIFRoZSBzb3VyY2UgYiBjb29yZGluYXRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNTcmMgVGhlIHNvdXJjZSBjIGNvb3JkaW5hdGUuXG4gKiBAcHJpdmF0ZVxuICovXG5Ucmlhbmd1bGF0aW9uLnByb3RvdHlwZS5hZGRUcmlhbmdsZV8gPSBmdW5jdGlvbiBhZGRUcmlhbmdsZV8gKGEsIGIsIGMsIGFTcmMsIGJTcmMsIGNTcmMpIHtcbiAgdGhpcy50cmlhbmdsZXNfLnB1c2goe1xuICAgIHNvdXJjZTogW2FTcmMsIGJTcmMsIGNTcmNdLFxuICAgIHRhcmdldDogW2EsIGIsIGNdXG4gIH0pO1xufTtcblxuLyoqXG4gKiBBZGRzIHF1YWQgKHBvaW50cyBpbiBjbG9jay13aXNlIG9yZGVyKSB0byB0aGUgdHJpYW5ndWxhdGlvblxuICogKGFuZCByZXByb2plY3RzIHRoZSB2ZXJ0aWNlcykgaWYgdmFsaWQuXG4gKiBQZXJmb3JtcyBxdWFkIHN1YmRpdmlzaW9uIGlmIG5lZWRlZCB0byBpbmNyZWFzZSBwcmVjaXNpb24uXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGEgVGhlIHRhcmdldCBhIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gYiBUaGUgdGFyZ2V0IGIgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjIFRoZSB0YXJnZXQgYyBjb29yZGluYXRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGQgVGhlIHRhcmdldCBkIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gYVNyYyBUaGUgc291cmNlIGEgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBiU3JjIFRoZSBzb3VyY2UgYiBjb29yZGluYXRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNTcmMgVGhlIHNvdXJjZSBjIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gZFNyYyBUaGUgc291cmNlIGQgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhTdWJkaXZpc2lvbiBNYXhpbWFsIGFsbG93ZWQgc3ViZGl2aXNpb24gb2YgdGhlIHF1YWQuXG4gKiBAcHJpdmF0ZVxuICovXG5Ucmlhbmd1bGF0aW9uLnByb3RvdHlwZS5hZGRRdWFkXyA9IGZ1bmN0aW9uIGFkZFF1YWRfIChhLCBiLCBjLCBkLCBhU3JjLCBiU3JjLCBjU3JjLCBkU3JjLCBtYXhTdWJkaXZpc2lvbikge1xuXG4gIHZhciBzb3VyY2VRdWFkRXh0ZW50ID0gYm91bmRpbmdFeHRlbnQoW2FTcmMsIGJTcmMsIGNTcmMsIGRTcmNdKTtcbiAgdmFyIHNvdXJjZUNvdmVyYWdlWCA9IHRoaXMuc291cmNlV29ybGRXaWR0aF8gP1xuICAgIGdldFdpZHRoKHNvdXJjZVF1YWRFeHRlbnQpIC8gdGhpcy5zb3VyY2VXb3JsZFdpZHRoXyA6IG51bGw7XG4gIHZhciBzb3VyY2VXb3JsZFdpZHRoID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovICh0aGlzLnNvdXJjZVdvcmxkV2lkdGhfKTtcblxuICAvLyB3aGVuIHRoZSBxdWFkIGlzIHdyYXBwZWQgaW4gdGhlIHNvdXJjZSBwcm9qZWN0aW9uXG4gIC8vIGl0IGNvdmVycyBtb3N0IG9mIHRoZSBwcm9qZWN0aW9uIGV4dGVudCwgYnV0IG5vdCBmdWxseVxuICB2YXIgd3JhcHNYID0gdGhpcy5zb3VyY2VQcm9qXy5jYW5XcmFwWCgpICYmXG4gICAgICAgICAgICAgICBzb3VyY2VDb3ZlcmFnZVggPiAwLjUgJiYgc291cmNlQ292ZXJhZ2VYIDwgMTtcblxuICB2YXIgbmVlZHNTdWJkaXZpc2lvbiA9IGZhbHNlO1xuXG4gIGlmIChtYXhTdWJkaXZpc2lvbiA+IDApIHtcbiAgICBpZiAodGhpcy50YXJnZXRQcm9qXy5pc0dsb2JhbCgpICYmIHRoaXMudGFyZ2V0V29ybGRXaWR0aF8pIHtcbiAgICAgIHZhciB0YXJnZXRRdWFkRXh0ZW50ID0gYm91bmRpbmdFeHRlbnQoW2EsIGIsIGMsIGRdKTtcbiAgICAgIHZhciB0YXJnZXRDb3ZlcmFnZVggPSBnZXRXaWR0aCh0YXJnZXRRdWFkRXh0ZW50KSAvIHRoaXMudGFyZ2V0V29ybGRXaWR0aF87XG4gICAgICBuZWVkc1N1YmRpdmlzaW9uID0gdGFyZ2V0Q292ZXJhZ2VYID4gTUFYX1RSSUFOR0xFX1dJRFRIIHx8XG4gICAgICAgIG5lZWRzU3ViZGl2aXNpb247XG4gICAgfVxuICAgIGlmICghd3JhcHNYICYmIHRoaXMuc291cmNlUHJval8uaXNHbG9iYWwoKSAmJiBzb3VyY2VDb3ZlcmFnZVgpIHtcbiAgICAgIG5lZWRzU3ViZGl2aXNpb24gPSBzb3VyY2VDb3ZlcmFnZVggPiBNQVhfVFJJQU5HTEVfV0lEVEggfHxcbiAgICAgICAgICBuZWVkc1N1YmRpdmlzaW9uO1xuICAgIH1cbiAgfVxuXG4gIGlmICghbmVlZHNTdWJkaXZpc2lvbiAmJiB0aGlzLm1heFNvdXJjZUV4dGVudF8pIHtcbiAgICBpZiAoIWludGVyc2VjdHMoc291cmNlUXVhZEV4dGVudCwgdGhpcy5tYXhTb3VyY2VFeHRlbnRfKSkge1xuICAgICAgLy8gd2hvbGUgcXVhZCBvdXRzaWRlIHNvdXJjZSBwcm9qZWN0aW9uIGV4dGVudCAtPiBpZ25vcmVcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAoIW5lZWRzU3ViZGl2aXNpb24pIHtcbiAgICBpZiAoIWlzRmluaXRlKGFTcmNbMF0pIHx8ICFpc0Zpbml0ZShhU3JjWzFdKSB8fFxuICAgICAgICAhaXNGaW5pdGUoYlNyY1swXSkgfHwgIWlzRmluaXRlKGJTcmNbMV0pIHx8XG4gICAgICAgICFpc0Zpbml0ZShjU3JjWzBdKSB8fCAhaXNGaW5pdGUoY1NyY1sxXSkgfHxcbiAgICAgICAgIWlzRmluaXRlKGRTcmNbMF0pIHx8ICFpc0Zpbml0ZShkU3JjWzFdKSkge1xuICAgICAgaWYgKG1heFN1YmRpdmlzaW9uID4gMCkge1xuICAgICAgICBuZWVkc1N1YmRpdmlzaW9uID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAobWF4U3ViZGl2aXNpb24gPiAwKSB7XG4gICAgaWYgKCFuZWVkc1N1YmRpdmlzaW9uKSB7XG4gICAgICB2YXIgY2VudGVyID0gWyhhWzBdICsgY1swXSkgLyAyLCAoYVsxXSArIGNbMV0pIC8gMl07XG4gICAgICB2YXIgY2VudGVyU3JjID0gdGhpcy50cmFuc2Zvcm1JbnZfKGNlbnRlcik7XG5cbiAgICAgIHZhciBkeDtcbiAgICAgIGlmICh3cmFwc1gpIHtcbiAgICAgICAgdmFyIGNlbnRlclNyY0VzdGltWCA9XG4gICAgICAgICAgICAobW9kdWxvKGFTcmNbMF0sIHNvdXJjZVdvcmxkV2lkdGgpICtcbiAgICAgICAgICAgICBtb2R1bG8oY1NyY1swXSwgc291cmNlV29ybGRXaWR0aCkpIC8gMjtcbiAgICAgICAgZHggPSBjZW50ZXJTcmNFc3RpbVggLVxuICAgICAgICAgICAgbW9kdWxvKGNlbnRlclNyY1swXSwgc291cmNlV29ybGRXaWR0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkeCA9IChhU3JjWzBdICsgY1NyY1swXSkgLyAyIC0gY2VudGVyU3JjWzBdO1xuICAgICAgfVxuICAgICAgdmFyIGR5ID0gKGFTcmNbMV0gKyBjU3JjWzFdKSAvIDIgLSBjZW50ZXJTcmNbMV07XG4gICAgICB2YXIgY2VudGVyU3JjRXJyb3JTcXVhcmVkID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICBuZWVkc1N1YmRpdmlzaW9uID0gY2VudGVyU3JjRXJyb3JTcXVhcmVkID4gdGhpcy5lcnJvclRocmVzaG9sZFNxdWFyZWRfO1xuICAgIH1cbiAgICBpZiAobmVlZHNTdWJkaXZpc2lvbikge1xuICAgICAgaWYgKE1hdGguYWJzKGFbMF0gLSBjWzBdKSA8PSBNYXRoLmFicyhhWzFdIC0gY1sxXSkpIHtcbiAgICAgICAgLy8gc3BsaXQgaG9yaXpvbnRhbGx5ICh0b3AgJiBib3R0b20pXG4gICAgICAgIHZhciBiYyA9IFsoYlswXSArIGNbMF0pIC8gMiwgKGJbMV0gKyBjWzFdKSAvIDJdO1xuICAgICAgICB2YXIgYmNTcmMgPSB0aGlzLnRyYW5zZm9ybUludl8oYmMpO1xuICAgICAgICB2YXIgZGEgPSBbKGRbMF0gKyBhWzBdKSAvIDIsIChkWzFdICsgYVsxXSkgLyAyXTtcbiAgICAgICAgdmFyIGRhU3JjID0gdGhpcy50cmFuc2Zvcm1JbnZfKGRhKTtcblxuICAgICAgICB0aGlzLmFkZFF1YWRfKFxuICAgICAgICAgIGEsIGIsIGJjLCBkYSwgYVNyYywgYlNyYywgYmNTcmMsIGRhU3JjLCBtYXhTdWJkaXZpc2lvbiAtIDEpO1xuICAgICAgICB0aGlzLmFkZFF1YWRfKFxuICAgICAgICAgIGRhLCBiYywgYywgZCwgZGFTcmMsIGJjU3JjLCBjU3JjLCBkU3JjLCBtYXhTdWJkaXZpc2lvbiAtIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc3BsaXQgdmVydGljYWxseSAobGVmdCAmIHJpZ2h0KVxuICAgICAgICB2YXIgYWIgPSBbKGFbMF0gKyBiWzBdKSAvIDIsIChhWzFdICsgYlsxXSkgLyAyXTtcbiAgICAgICAgdmFyIGFiU3JjID0gdGhpcy50cmFuc2Zvcm1JbnZfKGFiKTtcbiAgICAgICAgdmFyIGNkID0gWyhjWzBdICsgZFswXSkgLyAyLCAoY1sxXSArIGRbMV0pIC8gMl07XG4gICAgICAgIHZhciBjZFNyYyA9IHRoaXMudHJhbnNmb3JtSW52XyhjZCk7XG5cbiAgICAgICAgdGhpcy5hZGRRdWFkXyhcbiAgICAgICAgICBhLCBhYiwgY2QsIGQsIGFTcmMsIGFiU3JjLCBjZFNyYywgZFNyYywgbWF4U3ViZGl2aXNpb24gLSAxKTtcbiAgICAgICAgdGhpcy5hZGRRdWFkXyhcbiAgICAgICAgICBhYiwgYiwgYywgY2QsIGFiU3JjLCBiU3JjLCBjU3JjLCBjZFNyYywgbWF4U3ViZGl2aXNpb24gLSAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAod3JhcHNYKSB7XG4gICAgaWYgKCF0aGlzLmNhbldyYXBYSW5Tb3VyY2VfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMud3JhcHNYSW5Tb3VyY2VfID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuYWRkVHJpYW5nbGVfKGEsIGMsIGQsIGFTcmMsIGNTcmMsIGRTcmMpO1xuICB0aGlzLmFkZFRyaWFuZ2xlXyhhLCBiLCBjLCBhU3JjLCBiU3JjLCBjU3JjKTtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyBleHRlbnQgb2YgdGhlICdzb3VyY2UnIGNvb3JkaW5hdGVzIGZyb20gYWxsIHRoZSB0cmlhbmdsZXMuXG4gKlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gQ2FsY3VsYXRlZCBleHRlbnQuXG4gKi9cblRyaWFuZ3VsYXRpb24ucHJvdG90eXBlLmNhbGN1bGF0ZVNvdXJjZUV4dGVudCA9IGZ1bmN0aW9uIGNhbGN1bGF0ZVNvdXJjZUV4dGVudCAoKSB7XG4gIHZhciBleHRlbnQgPSBjcmVhdGVFbXB0eSgpO1xuXG4gIHRoaXMudHJpYW5nbGVzXy5mb3JFYWNoKGZ1bmN0aW9uKHRyaWFuZ2xlLCBpLCBhcnIpIHtcbiAgICB2YXIgc3JjID0gdHJpYW5nbGUuc291cmNlO1xuICAgIGV4dGVuZENvb3JkaW5hdGUoZXh0ZW50LCBzcmNbMF0pO1xuICAgIGV4dGVuZENvb3JkaW5hdGUoZXh0ZW50LCBzcmNbMV0pO1xuICAgIGV4dGVuZENvb3JkaW5hdGUoZXh0ZW50LCBzcmNbMl0pO1xuICB9KTtcblxuICByZXR1cm4gZXh0ZW50O1xufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtBcnJheTxUcmlhbmdsZT59IEFycmF5IG9mIHRoZSBjYWxjdWxhdGVkIHRyaWFuZ2xlcy5cbiAqL1xuVHJpYW5ndWxhdGlvbi5wcm90b3R5cGUuZ2V0VHJpYW5nbGVzID0gZnVuY3Rpb24gZ2V0VHJpYW5nbGVzICgpIHtcbiAgcmV0dXJuIHRoaXMudHJpYW5nbGVzXztcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFRyaWFuZ3VsYXRpb247XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRyaWFuZ3VsYXRpb24uanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlcHJvai9jb21tb25cbiAqL1xuXG4vKipcbiAqIERlZmF1bHQgbWF4aW11bSBhbGxvd2VkIHRocmVzaG9sZCAgKGluIHBpeGVscykgZm9yIHJlcHJvamVjdGlvblxuICogdHJpYW5ndWxhdGlvbi5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgRVJST1JfVEhSRVNIT0xEID0gMC41O1xuXG4vKipcbiAqIEVuYWJsZSBhdXRvbWF0aWMgcmVwcm9qZWN0aW9uIG9mIHJhc3RlciBzb3VyY2VzLiBEZWZhdWx0IGlzIGB0cnVlYC5cbiAqIFRPRE86IGRlY2lkZSBpZiB3ZSB3YW50IHRvIGV4cG9zZSB0aGlzIGFzIGEgYnVpbGQgZmxhZyBvciByZW1vdmUgaXRcbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5leHBvcnQgdmFyIEVOQUJMRV9SQVNURVJfUkVQUk9KRUNUSU9OID0gdHJ1ZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tbW9uLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9yZXNvbHV0aW9uY29uc3RyYWludFxuICovXG5pbXBvcnQge2xpbmVhckZpbmROZWFyZXN0fSBmcm9tICcuL2FycmF5LmpzJztcbmltcG9ydCB7Y2xhbXB9IGZyb20gJy4vbWF0aC5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oKG51bWJlcnx1bmRlZmluZWQpLCBudW1iZXIsIG51bWJlcik6IChudW1iZXJ8dW5kZWZpbmVkKX0gVHlwZVxuICovXG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHJlc29sdXRpb25zIFJlc29sdXRpb25zLlxuICogQHJldHVybiB7VHlwZX0gWm9vbSBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNuYXBUb1Jlc29sdXRpb25zKHJlc29sdXRpb25zKSB7XG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhIERlbHRhLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXJlY3Rpb24gRGlyZWN0aW9uLlxuICAgICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFJlc29sdXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24ocmVzb2x1dGlvbiwgZGVsdGEsIGRpcmVjdGlvbikge1xuICAgICAgaWYgKHJlc29sdXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgeiA9IGxpbmVhckZpbmROZWFyZXN0KHJlc29sdXRpb25zLCByZXNvbHV0aW9uLCBkaXJlY3Rpb24pO1xuICAgICAgICB6ID0gY2xhbXAoeiArIGRlbHRhLCAwLCByZXNvbHV0aW9ucy5sZW5ndGggLSAxKTtcbiAgICAgICAgdmFyIGluZGV4ID0gTWF0aC5mbG9vcih6KTtcbiAgICAgICAgaWYgKHogIT0gaW5kZXggJiYgaW5kZXggPCByZXNvbHV0aW9ucy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgdmFyIHBvd2VyID0gcmVzb2x1dGlvbnNbaW5kZXhdIC8gcmVzb2x1dGlvbnNbaW5kZXggKyAxXTtcbiAgICAgICAgICByZXR1cm4gcmVzb2x1dGlvbnNbaW5kZXhdIC8gTWF0aC5wb3cocG93ZXIsIHogLSBpbmRleCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdXRpb25zW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gICk7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gcG93ZXIgUG93ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4UmVzb2x1dGlvbiBNYXhpbXVtIHJlc29sdXRpb24uXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9tYXhMZXZlbCBNYXhpbXVtIGxldmVsLlxuICogQHJldHVybiB7VHlwZX0gWm9vbSBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNuYXBUb1Bvd2VyKHBvd2VyLCBtYXhSZXNvbHV0aW9uLCBvcHRfbWF4TGV2ZWwpIHtcbiAgcmV0dXJuIChcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGEgRGVsdGEuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpcmVjdGlvbiBEaXJlY3Rpb24uXG4gICAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gUmVzb2x1dGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbihyZXNvbHV0aW9uLCBkZWx0YSwgZGlyZWN0aW9uKSB7XG4gICAgICBpZiAocmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSAtZGlyZWN0aW9uIC8gMiArIDAuNTtcbiAgICAgICAgdmFyIG9sZExldmVsID0gTWF0aC5mbG9vcihcbiAgICAgICAgICBNYXRoLmxvZyhtYXhSZXNvbHV0aW9uIC8gcmVzb2x1dGlvbikgLyBNYXRoLmxvZyhwb3dlcikgKyBvZmZzZXQpO1xuICAgICAgICB2YXIgbmV3TGV2ZWwgPSBNYXRoLm1heChvbGRMZXZlbCArIGRlbHRhLCAwKTtcbiAgICAgICAgaWYgKG9wdF9tYXhMZXZlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbmV3TGV2ZWwgPSBNYXRoLm1pbihuZXdMZXZlbCwgb3B0X21heExldmVsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4UmVzb2x1dGlvbiAvIE1hdGgucG93KHBvd2VyLCBuZXdMZXZlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHV0aW9uY29uc3RyYWludC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcm90YXRpb25jb25zdHJhaW50XG4gKi9cbmltcG9ydCB7dG9SYWRpYW5zfSBmcm9tICcuL21hdGguanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKChudW1iZXJ8dW5kZWZpbmVkKSwgbnVtYmVyKTogKG51bWJlcnx1bmRlZmluZWQpfSBUeXBlXG4gKi9cblxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gcm90YXRpb24gUm90YXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gZGVsdGEgRGVsdGEuXG4gKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBSb3RhdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpc2FibGUocm90YXRpb24sIGRlbHRhKSB7XG4gIGlmIChyb3RhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YSBEZWx0YS5cbiAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFJvdGF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9uZShyb3RhdGlvbiwgZGVsdGEpIHtcbiAgaWYgKHJvdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcm90YXRpb24gKyBkZWx0YTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gbiBOLlxuICogQHJldHVybiB7VHlwZX0gUm90YXRpb24gY29uc3RyYWludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNuYXBUb04obikge1xuICB2YXIgdGhldGEgPSAyICogTWF0aC5QSSAvIG47XG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGEgRGVsdGEuXG4gICAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gUm90YXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24ocm90YXRpb24sIGRlbHRhKSB7XG4gICAgICBpZiAocm90YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByb3RhdGlvbiA9IE1hdGguZmxvb3IoKHJvdGF0aW9uICsgZGVsdGEpIC8gdGhldGEgKyAwLjUpICogdGhldGE7XG4gICAgICAgIHJldHVybiByb3RhdGlvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF90b2xlcmFuY2UgVG9sZXJhbmNlLlxuICogQHJldHVybiB7VHlwZX0gUm90YXRpb24gY29uc3RyYWludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNuYXBUb1plcm8ob3B0X3RvbGVyYW5jZSkge1xuICB2YXIgdG9sZXJhbmNlID0gb3B0X3RvbGVyYW5jZSB8fCB0b1JhZGlhbnMoNSk7XG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGEgRGVsdGEuXG4gICAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gUm90YXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24ocm90YXRpb24sIGRlbHRhKSB7XG4gICAgICBpZiAocm90YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoTWF0aC5hYnMocm90YXRpb24gKyBkZWx0YSkgPD0gdG9sZXJhbmNlKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHJvdGF0aW9uICsgZGVsdGE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdGF0aW9uY29uc3RyYWludC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvc2l6ZVxuICovXG5cblxuLyoqXG4gKiBBbiBhcnJheSBvZiBudW1iZXJzIHJlcHJlc2VudGluZyBhIHNpemU6IGBbd2lkdGgsIGhlaWdodF1gLlxuICogQHR5cGVkZWYge0FycmF5PG51bWJlcj59IFNpemVcbiAqIEBhcGlcbiAqL1xuXG5cbi8qKlxuICogUmV0dXJucyBhIGJ1ZmZlcmVkIHNpemUuXG4gKiBAcGFyYW0ge1NpemV9IHNpemUgU2l6ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIGFtb3VudCBieSB3aGljaCB0byBidWZmZXIuXG4gKiBAcGFyYW0ge1NpemU9fSBvcHRfc2l6ZSBPcHRpb25hbCByZXVzYWJsZSBzaXplIGFycmF5LlxuICogQHJldHVybiB7U2l6ZX0gVGhlIGJ1ZmZlcmVkIHNpemUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWZmZXIoc2l6ZSwgbnVtLCBvcHRfc2l6ZSkge1xuICBpZiAob3B0X3NpemUgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wdF9zaXplID0gWzAsIDBdO1xuICB9XG4gIG9wdF9zaXplWzBdID0gc2l6ZVswXSArIDIgKiBudW07XG4gIG9wdF9zaXplWzFdID0gc2l6ZVsxXSArIDIgKiBudW07XG4gIHJldHVybiBvcHRfc2l6ZTtcbn1cblxuXG4vKipcbiAqIERldGVybWluZXMgaWYgYSBzaXplIGhhcyBhIHBvc2l0aXZlIGFyZWEuXG4gKiBAcGFyYW0ge1NpemV9IHNpemUgVGhlIHNpemUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBzaXplIGhhcyBhIHBvc2l0aXZlIGFyZWEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNBcmVhKHNpemUpIHtcbiAgcmV0dXJuIHNpemVbMF0gPiAwICYmIHNpemVbMV0gPiAwO1xufVxuXG5cbi8qKlxuICogUmV0dXJucyBhIHNpemUgc2NhbGVkIGJ5IGEgcmF0aW8uIFRoZSByZXN1bHQgd2lsbCBiZSBhbiBhcnJheSBvZiBpbnRlZ2Vycy5cbiAqIEBwYXJhbSB7U2l6ZX0gc2l6ZSBTaXplLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhdGlvIFJhdGlvLlxuICogQHBhcmFtIHtTaXplPX0gb3B0X3NpemUgT3B0aW9uYWwgcmV1c2FibGUgc2l6ZSBhcnJheS5cbiAqIEByZXR1cm4ge1NpemV9IFRoZSBzY2FsZWQgc2l6ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKHNpemUsIHJhdGlvLCBvcHRfc2l6ZSkge1xuICBpZiAob3B0X3NpemUgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wdF9zaXplID0gWzAsIDBdO1xuICB9XG4gIG9wdF9zaXplWzBdID0gKHNpemVbMF0gKiByYXRpbyArIDAuNSkgfCAwO1xuICBvcHRfc2l6ZVsxXSA9IChzaXplWzFdICogcmF0aW8gKyAwLjUpIHwgMDtcbiAgcmV0dXJuIG9wdF9zaXplO1xufVxuXG5cbi8qKlxuICogUmV0dXJucyBhbiBgU2l6ZWAgYXJyYXkgZm9yIHRoZSBwYXNzZWQgaW4gbnVtYmVyIChtZWFuaW5nOiBzcXVhcmUpIG9yXG4gKiBgU2l6ZWAgYXJyYXkuXG4gKiAobWVhbmluZzogbm9uLXNxdWFyZSksXG4gKiBAcGFyYW0ge251bWJlcnxTaXplfSBzaXplIFdpZHRoIGFuZCBoZWlnaHQuXG4gKiBAcGFyYW0ge1NpemU9fSBvcHRfc2l6ZSBPcHRpb25hbCByZXVzYWJsZSBzaXplIGFycmF5LlxuICogQHJldHVybiB7U2l6ZX0gU2l6ZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvU2l6ZShzaXplLCBvcHRfc2l6ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShzaXplKSkge1xuICAgIHJldHVybiBzaXplO1xuICB9IGVsc2Uge1xuICAgIGlmIChvcHRfc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRfc2l6ZSA9IFtzaXplLCBzaXplXTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0X3NpemVbMF0gPSBvcHRfc2l6ZVsxXSA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiBvcHRfc2l6ZTtcbiAgfVxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaXplLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9zb3VyY2UvT1NNXG4gKi9cblxuaW1wb3J0IFhZWiBmcm9tICcuL1hZWi5qcyc7XG5cblxuLyoqXG4gKiBUaGUgYXR0cmlidXRpb24gY29udGFpbmluZyBhIGxpbmsgdG8gdGhlIE9wZW5TdHJlZXRNYXAgQ29weXJpZ2h0IGFuZCBMaWNlbnNlXG4gKiBwYWdlLlxuICogQGNvbnN0XG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQGFwaVxuICovXG5leHBvcnQgdmFyIEFUVFJJQlVUSU9OID0gJyYjMTY5OyAnICtcbiAgICAgICc8YSBocmVmPVwiaHR0cHM6Ly93d3cub3BlbnN0cmVldG1hcC5vcmcvY29weXJpZ2h0XCI+T3BlblN0cmVldE1hcDwvYT4gJyArXG4gICAgICAnY29udHJpYnV0b3JzLic7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vU291cmNlLmpzXCIpLkF0dHJpYnV0aW9uTGlrZX0gW2F0dHJpYnV0aW9uc10gQXR0cmlidXRpb25zLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtjYWNoZVNpemU9MjA0OF0gQ2FjaGUgc2l6ZS5cbiAqIEBwcm9wZXJ0eSB7bnVsbHxzdHJpbmd9IFtjcm9zc09yaWdpbl0gVGhlIGBjcm9zc09yaWdpbmAgYXR0cmlidXRlIGZvciBsb2FkZWQgaW1hZ2VzLiAgTm90ZSB0aGF0XG4gKiB5b3UgbXVzdCBwcm92aWRlIGEgYGNyb3NzT3JpZ2luYCB2YWx1ZSBpZiB5b3UgYXJlIHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlciBvciBpZiB5b3Ugd2FudCB0b1xuICogYWNjZXNzIHBpeGVsIGRhdGEgd2l0aCB0aGUgQ2FudmFzIHJlbmRlcmVyLiAgU2VlXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0NPUlNfZW5hYmxlZF9pbWFnZSBmb3IgbW9yZSBkZXRhaWwuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFpvb209MTldIE1heCB6b29tLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbb3BhcXVlPXRydWVdIFdoZXRoZXIgdGhlIGxheWVyIGlzIG9wYXF1ZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmVwcm9qZWN0aW9uRXJyb3JUaHJlc2hvbGQ9MS41XSBNYXhpbXVtIGFsbG93ZWQgcmVwcm9qZWN0aW9uIGVycm9yIChpbiBwaXhlbHMpLlxuICogSGlnaGVyIHZhbHVlcyBjYW4gaW5jcmVhc2UgcmVwcm9qZWN0aW9uIHBlcmZvcm1hbmNlLCBidXQgZGVjcmVhc2UgcHJlY2lzaW9uLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLkxvYWRGdW5jdGlvbn0gW3RpbGVMb2FkRnVuY3Rpb25dIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGxvYWQgYSB0aWxlIGdpdmVuIGEgVVJMLiBUaGUgZGVmYXVsdCBpc1xuICogYGBganNcbiAqIGZ1bmN0aW9uKGltYWdlVGlsZSwgc3JjKSB7XG4gKiAgIGltYWdlVGlsZS5nZXRJbWFnZSgpLnNyYyA9IHNyYztcbiAqIH07XG4gKiBgYGBcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdXJsPSdodHRwczovL3thLWN9LnRpbGUub3BlbnN0cmVldG1hcC5vcmcve3p9L3t4fS97eX0ucG5nJ10gVVJMIHRlbXBsYXRlLlxuICogTXVzdCBpbmNsdWRlIGB7eH1gLCBge3l9YCBvciBgey15fWAsIGFuZCBge3p9YCBwbGFjZWhvbGRlcnMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt3cmFwWD10cnVlXSBXaGV0aGVyIHRvIHdyYXAgdGhlIHdvcmxkIGhvcml6b250YWxseS5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogTGF5ZXIgc291cmNlIGZvciB0aGUgT3BlblN0cmVldE1hcCB0aWxlIHNlcnZlci5cbiAqIEBhcGlcbiAqL1xudmFyIE9TTSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFhZWikge1xuICBmdW5jdGlvbiBPU00ob3B0X29wdGlvbnMpIHtcblxuICAgIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgfHwge307XG5cbiAgICB2YXIgYXR0cmlidXRpb25zO1xuICAgIGlmIChvcHRpb25zLmF0dHJpYnV0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBhdHRyaWJ1dGlvbnMgPSBvcHRpb25zLmF0dHJpYnV0aW9ucztcbiAgICB9IGVsc2Uge1xuICAgICAgYXR0cmlidXRpb25zID0gW0FUVFJJQlVUSU9OXTtcbiAgICB9XG5cbiAgICB2YXIgY3Jvc3NPcmlnaW4gPSBvcHRpb25zLmNyb3NzT3JpZ2luICE9PSB1bmRlZmluZWQgP1xuICAgICAgb3B0aW9ucy5jcm9zc09yaWdpbiA6ICdhbm9ueW1vdXMnO1xuXG4gICAgdmFyIHVybCA9IG9wdGlvbnMudXJsICE9PSB1bmRlZmluZWQgP1xuICAgICAgb3B0aW9ucy51cmwgOiAnaHR0cHM6Ly97YS1jfS50aWxlLm9wZW5zdHJlZXRtYXAub3JnL3t6fS97eH0ve3l9LnBuZyc7XG5cbiAgICBYWVouY2FsbCh0aGlzLCB7XG4gICAgICBhdHRyaWJ1dGlvbnM6IGF0dHJpYnV0aW9ucyxcbiAgICAgIGNhY2hlU2l6ZTogb3B0aW9ucy5jYWNoZVNpemUsXG4gICAgICBjcm9zc09yaWdpbjogY3Jvc3NPcmlnaW4sXG4gICAgICBvcGFxdWU6IG9wdGlvbnMub3BhcXVlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm9wYXF1ZSA6IHRydWUsXG4gICAgICBtYXhab29tOiBvcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubWF4Wm9vbSA6IDE5LFxuICAgICAgcmVwcm9qZWN0aW9uRXJyb3JUaHJlc2hvbGQ6IG9wdGlvbnMucmVwcm9qZWN0aW9uRXJyb3JUaHJlc2hvbGQsXG4gICAgICB0aWxlTG9hZEZ1bmN0aW9uOiBvcHRpb25zLnRpbGVMb2FkRnVuY3Rpb24sXG4gICAgICB1cmw6IHVybCxcbiAgICAgIHdyYXBYOiBvcHRpb25zLndyYXBYLFxuICAgICAgYXR0cmlidXRpb25zQ29sbGFwc2libGU6IGZhbHNlXG4gICAgfSk7XG5cbiAgfVxuXG4gIGlmICggWFlaICkgT1NNLl9fcHJvdG9fXyA9IFhZWjtcbiAgT1NNLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFhZWiAmJiBYWVoucHJvdG90eXBlICk7XG4gIE9TTS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBPU007XG5cbiAgcmV0dXJuIE9TTTtcbn0oWFlaKSk7XG5cbmV4cG9ydCBkZWZhdWx0IE9TTTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T1NNLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9zb3VyY2UvU291cmNlXG4gKi9cbmltcG9ydCB7YWJzdHJhY3R9IGZyb20gJy4uL3V0aWwuanMnO1xuaW1wb3J0IEJhc2VPYmplY3QgZnJvbSAnLi4vT2JqZWN0LmpzJztcbmltcG9ydCB7Z2V0IGFzIGdldFByb2plY3Rpb259IGZyb20gJy4uL3Byb2ouanMnO1xuaW1wb3J0IFNvdXJjZVN0YXRlIGZyb20gJy4vU3RhdGUuanMnO1xuXG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBzdHJpbmcgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyByZXByZXNlbnRpbmcgc291cmNlXG4gKiBhdHRyaWJ1dGlvbnMuXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKGltcG9ydChcIi4uL1BsdWdnYWJsZU1hcC5qc1wiKS5GcmFtZVN0YXRlKTogKHN0cmluZ3xBcnJheTxzdHJpbmc+KX0gQXR0cmlidXRpb25cbiAqL1xuXG5cbi8qKlxuICogQSB0eXBlIHRoYXQgY2FuIGJlIHVzZWQgdG8gcHJvdmlkZSBhdHRyaWJ1dGlvbiBpbmZvcm1hdGlvbiBmb3IgZGF0YSBzb3VyY2VzLlxuICpcbiAqIEl0IHJlcHJlc2VudHMgZWl0aGVyXG4gKiAqIGEgc2ltcGxlIHN0cmluZyAoZS5nLiBgJ8KpIEFjbWUgSW5jLidgKVxuICogKiBhbiBhcnJheSBvZiBzaW1wbGUgc3RyaW5ncyAoZS5nLiBgWyfCqSBBY21lIEluYy4nLCAnwqkgQmFjbWUgSW5jLiddYClcbiAqICogYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5ncyAoYHtAbGluayBtb2R1bGU6b2wvc291cmNlL1NvdXJjZX5BdHRyaWJ1dGlvbn1gKVxuICpcbiAqIEB0eXBlZGVmIHtzdHJpbmd8QXJyYXk8c3RyaW5nPnxBdHRyaWJ1dGlvbn0gQXR0cmlidXRpb25MaWtlXG4gKi9cblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7QXR0cmlidXRpb25MaWtlfSBbYXR0cmlidXRpb25zXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbYXR0cmlidXRpb25zQ29sbGFwc2libGU9dHJ1ZV0gQXR0cmlidXRpb25zIGFyZSBjb2xsYXBzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gcHJvamVjdGlvblxuICogQHByb3BlcnR5IHtTb3VyY2VTdGF0ZX0gW3N0YXRlPSdyZWFkeSddXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt3cmFwWD1mYWxzZV1cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWJzdHJhY3QgYmFzZSBjbGFzczsgbm9ybWFsbHkgb25seSB1c2VkIGZvciBjcmVhdGluZyBzdWJjbGFzc2VzIGFuZCBub3RcbiAqIGluc3RhbnRpYXRlZCBpbiBhcHBzLlxuICogQmFzZSBjbGFzcyBmb3Ige0BsaW5rIG1vZHVsZTpvbC9sYXllci9MYXllcn5MYXllcn0gc291cmNlcy5cbiAqXG4gKiBBIGdlbmVyaWMgYGNoYW5nZWAgZXZlbnQgaXMgdHJpZ2dlcmVkIHdoZW4gdGhlIHN0YXRlIG9mIHRoZSBzb3VyY2UgY2hhbmdlcy5cbiAqIEBhYnN0cmFjdFxuICogQGFwaVxuICovXG52YXIgU291cmNlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoQmFzZU9iamVjdCkge1xuICBmdW5jdGlvbiBTb3VyY2Uob3B0aW9ucykge1xuXG4gICAgQmFzZU9iamVjdC5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5wcm9qZWN0aW9uXyA9IGdldFByb2plY3Rpb24ob3B0aW9ucy5wcm9qZWN0aW9uKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9BdHRyaWJ1dGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmF0dHJpYnV0aW9uc18gPSBhZGFwdEF0dHJpYnV0aW9ucyhvcHRpb25zLmF0dHJpYnV0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuYXR0cmlidXRpb25zQ29sbGFwc2libGVfID0gb3B0aW9ucy5hdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZSAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdGlvbnMuYXR0cmlidXRpb25zQ29sbGFwc2libGUgOiB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBzb3VyY2UgaXMgY3VycmVudGx5IGxvYWRpbmcgZGF0YS4gU291cmNlcyB0aGF0IGRlZmVyIGxvYWRpbmcgdG8gdGhlXG4gICAgICogbWFwJ3MgdGlsZSBxdWV1ZSBuZXZlciBzZXQgdGhpcyB0byBgdHJ1ZWAuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtTb3VyY2VTdGF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLnN0YXRlXyA9IG9wdGlvbnMuc3RhdGUgIT09IHVuZGVmaW5lZCA/XG4gICAgICBvcHRpb25zLnN0YXRlIDogU291cmNlU3RhdGUuUkVBRFk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMud3JhcFhfID0gb3B0aW9ucy53cmFwWCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy53cmFwWCA6IGZhbHNlO1xuXG4gIH1cblxuICBpZiAoIEJhc2VPYmplY3QgKSBTb3VyY2UuX19wcm90b19fID0gQmFzZU9iamVjdDtcbiAgU291cmNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJhc2VPYmplY3QgJiYgQmFzZU9iamVjdC5wcm90b3R5cGUgKTtcbiAgU291cmNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNvdXJjZTtcblxuICAvKipcbiAgICogR2V0IHRoZSBhdHRyaWJ1dGlvbiBmdW5jdGlvbiBmb3IgdGhlIHNvdXJjZS5cbiAgICogQHJldHVybiB7P0F0dHJpYnV0aW9ufSBBdHRyaWJ1dGlvbiBmdW5jdGlvbi5cbiAgICovXG4gIFNvdXJjZS5wcm90b3R5cGUuZ2V0QXR0cmlidXRpb25zID0gZnVuY3Rpb24gZ2V0QXR0cmlidXRpb25zICgpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGlvbnNfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBBYXR0cmlidXRpb25zIGFyZSBjb2xsYXBzaWJsZS5cbiAgICovXG4gIFNvdXJjZS5wcm90b3R5cGUuZ2V0QXR0cmlidXRpb25zQ29sbGFwc2libGUgPSBmdW5jdGlvbiBnZXRBdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cmlidXRpb25zQ29sbGFwc2libGVfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHByb2plY3Rpb24gb2YgdGhlIHNvdXJjZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IFByb2plY3Rpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIFNvdXJjZS5wcm90b3R5cGUuZ2V0UHJvamVjdGlvbiA9IGZ1bmN0aW9uIGdldFByb2plY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnByb2plY3Rpb25fO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPnx1bmRlZmluZWR9IFJlc29sdXRpb25zLlxuICAgKi9cbiAgU291cmNlLnByb3RvdHlwZS5nZXRSZXNvbHV0aW9ucyA9IGZ1bmN0aW9uIGdldFJlc29sdXRpb25zICgpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBzdGF0ZSBvZiB0aGUgc291cmNlLCBzZWUge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvU3RhdGV+U3RhdGV9IGZvciBwb3NzaWJsZSBzdGF0ZXMuXG4gICAqIEByZXR1cm4ge1NvdXJjZVN0YXRlfSBTdGF0ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgU291cmNlLnByb3RvdHlwZS5nZXRTdGF0ZSA9IGZ1bmN0aW9uIGdldFN0YXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZV87XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW58dW5kZWZpbmVkfSBXcmFwIFguXG4gICAqL1xuICBTb3VyY2UucHJvdG90eXBlLmdldFdyYXBYID0gZnVuY3Rpb24gZ2V0V3JhcFggKCkge1xuICAgIHJldHVybiB0aGlzLndyYXBYXztcbiAgfTtcblxuICAvKipcbiAgICogUmVmcmVzaGVzIHRoZSBzb3VyY2UgYW5kIGZpbmFsbHkgZGlzcGF0Y2hlcyBhICdjaGFuZ2UnIGV2ZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBTb3VyY2UucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiByZWZyZXNoICgpIHtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBhdHRyaWJ1dGlvbnMgb2YgdGhlIHNvdXJjZS5cbiAgICogQHBhcmFtIHtBdHRyaWJ1dGlvbkxpa2V8dW5kZWZpbmVkfSBhdHRyaWJ1dGlvbnMgQXR0cmlidXRpb25zLlxuICAgKiAgICAgQ2FuIGJlIHBhc3NlZCBhcyBgc3RyaW5nYCwgYEFycmF5PHN0cmluZz5gLCBge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvU291cmNlfkF0dHJpYnV0aW9ufWAsXG4gICAqICAgICBvciBgdW5kZWZpbmVkYC5cbiAgICogQGFwaVxuICAgKi9cbiAgU291cmNlLnByb3RvdHlwZS5zZXRBdHRyaWJ1dGlvbnMgPSBmdW5jdGlvbiBzZXRBdHRyaWJ1dGlvbnMgKGF0dHJpYnV0aW9ucykge1xuICAgIHRoaXMuYXR0cmlidXRpb25zXyA9IGFkYXB0QXR0cmlidXRpb25zKGF0dHJpYnV0aW9ucyk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc3RhdGUgb2YgdGhlIHNvdXJjZS5cbiAgICogQHBhcmFtIHtTb3VyY2VTdGF0ZX0gc3RhdGUgU3RhdGUuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIFNvdXJjZS5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiBzZXRTdGF0ZSAoc3RhdGUpIHtcbiAgICB0aGlzLnN0YXRlXyA9IHN0YXRlO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9O1xuXG4gIHJldHVybiBTb3VyY2U7XG59KEJhc2VPYmplY3QpKTtcblxuXG4vKipcbiAqIFR1cm5zIHRoZSBhdHRyaWJ1dGlvbnMgb3B0aW9uIGludG8gYW4gYXR0cmlidXRpb25zIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtBdHRyaWJ1dGlvbkxpa2V8dW5kZWZpbmVkfSBhdHRyaWJ1dGlvbkxpa2UgVGhlIGF0dHJpYnV0aW9uIG9wdGlvbi5cbiAqIEByZXR1cm4gez9BdHRyaWJ1dGlvbn0gQW4gYXR0cmlidXRpb24gZnVuY3Rpb24gKG9yIG51bGwpLlxuICovXG5mdW5jdGlvbiBhZGFwdEF0dHJpYnV0aW9ucyhhdHRyaWJ1dGlvbkxpa2UpIHtcbiAgaWYgKCFhdHRyaWJ1dGlvbkxpa2UpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShhdHRyaWJ1dGlvbkxpa2UpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGZyYW1lU3RhdGUpIHtcbiAgICAgIHJldHVybiBhdHRyaWJ1dGlvbkxpa2U7XG4gICAgfTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYXR0cmlidXRpb25MaWtlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGF0dHJpYnV0aW9uTGlrZTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihmcmFtZVN0YXRlKSB7XG4gICAgcmV0dXJuIFthdHRyaWJ1dGlvbkxpa2VdO1xuICB9O1xufVxuXG5cbmV4cG9ydCBkZWZhdWx0IFNvdXJjZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U291cmNlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9zb3VyY2UvU3RhbWVuXG4gKi9cblxuaW1wb3J0IHtBVFRSSUJVVElPTiBhcyBPU01fQVRUUklCVVRJT059IGZyb20gJy4vT1NNLmpzJztcbmltcG9ydCBYWVogZnJvbSAnLi9YWVouanMnO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn1cbiAqL1xudmFyIEFUVFJJQlVUSU9OUyA9IFtcbiAgJ01hcCB0aWxlcyBieSA8YSBocmVmPVwiaHR0cHM6Ly9zdGFtZW4uY29tL1wiPlN0YW1lbiBEZXNpZ248L2E+LCAnICtcbiAgICAgICAgJ3VuZGVyIDxhIGhyZWY9XCJodHRwczovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnkvMy4wL1wiPkNDIEJZJyArXG4gICAgICAgICcgMy4wPC9hPi4nLFxuICBPU01fQVRUUklCVVRJT05cbl07XG5cblxuLyoqXG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywge2V4dGVuc2lvbjogc3RyaW5nLCBvcGFxdWU6IGJvb2xlYW59Pn1cbiAqL1xudmFyIExheWVyQ29uZmlnID0ge1xuICAndGVycmFpbic6IHtcbiAgICBleHRlbnNpb246ICdqcGcnLFxuICAgIG9wYXF1ZTogdHJ1ZVxuICB9LFxuICAndGVycmFpbi1iYWNrZ3JvdW5kJzoge1xuICAgIGV4dGVuc2lvbjogJ2pwZycsXG4gICAgb3BhcXVlOiB0cnVlXG4gIH0sXG4gICd0ZXJyYWluLWxhYmVscyc6IHtcbiAgICBleHRlbnNpb246ICdwbmcnLFxuICAgIG9wYXF1ZTogZmFsc2VcbiAgfSxcbiAgJ3RlcnJhaW4tbGluZXMnOiB7XG4gICAgZXh0ZW5zaW9uOiAncG5nJyxcbiAgICBvcGFxdWU6IGZhbHNlXG4gIH0sXG4gICd0b25lci1iYWNrZ3JvdW5kJzoge1xuICAgIGV4dGVuc2lvbjogJ3BuZycsXG4gICAgb3BhcXVlOiB0cnVlXG4gIH0sXG4gICd0b25lcic6IHtcbiAgICBleHRlbnNpb246ICdwbmcnLFxuICAgIG9wYXF1ZTogdHJ1ZVxuICB9LFxuICAndG9uZXItaHlicmlkJzoge1xuICAgIGV4dGVuc2lvbjogJ3BuZycsXG4gICAgb3BhcXVlOiBmYWxzZVxuICB9LFxuICAndG9uZXItbGFiZWxzJzoge1xuICAgIGV4dGVuc2lvbjogJ3BuZycsXG4gICAgb3BhcXVlOiBmYWxzZVxuICB9LFxuICAndG9uZXItbGluZXMnOiB7XG4gICAgZXh0ZW5zaW9uOiAncG5nJyxcbiAgICBvcGFxdWU6IGZhbHNlXG4gIH0sXG4gICd0b25lci1saXRlJzoge1xuICAgIGV4dGVuc2lvbjogJ3BuZycsXG4gICAgb3BhcXVlOiB0cnVlXG4gIH0sXG4gICd3YXRlcmNvbG9yJzoge1xuICAgIGV4dGVuc2lvbjogJ2pwZycsXG4gICAgb3BhcXVlOiB0cnVlXG4gIH1cbn07XG5cblxuLyoqXG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywge21pblpvb206IG51bWJlciwgbWF4Wm9vbTogbnVtYmVyfT59XG4gKi9cbnZhciBQcm92aWRlckNvbmZpZyA9IHtcbiAgJ3RlcnJhaW4nOiB7XG4gICAgbWluWm9vbTogNCxcbiAgICBtYXhab29tOiAxOFxuICB9LFxuICAndG9uZXInOiB7XG4gICAgbWluWm9vbTogMCxcbiAgICBtYXhab29tOiAyMFxuICB9LFxuICAnd2F0ZXJjb2xvcic6IHtcbiAgICBtaW5ab29tOiAxLFxuICAgIG1heFpvb206IDE2XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2NhY2hlU2l6ZT0yMDQ4XSBDYWNoZSBzaXplLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGxheWVyIExheWVyIG5hbWUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pblpvb21dIE1pbmltdW0gem9vbS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4Wm9vbV0gTWF4aW11bSB6b29tLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyZXByb2plY3Rpb25FcnJvclRocmVzaG9sZD0wLjVdIE1heGltdW0gYWxsb3dlZCByZXByb2plY3Rpb24gZXJyb3IgKGluIHBpeGVscykuXG4gKiBIaWdoZXIgdmFsdWVzIGNhbiBpbmNyZWFzZSByZXByb2plY3Rpb24gcGVyZm9ybWFuY2UsIGJ1dCBkZWNyZWFzZSBwcmVjaXNpb24uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL1RpbGUuanNcIikuTG9hZEZ1bmN0aW9ufSBbdGlsZUxvYWRGdW5jdGlvbl1cbiAqIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGxvYWQgYSB0aWxlIGdpdmVuIGEgVVJMLiBUaGUgZGVmYXVsdCBpc1xuICogYGBganNcbiAqIGZ1bmN0aW9uKGltYWdlVGlsZSwgc3JjKSB7XG4gKiAgIGltYWdlVGlsZS5nZXRJbWFnZSgpLnNyYyA9IHNyYztcbiAqIH07XG4gKiBgYGBcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdXJsXSBVUkwgdGVtcGxhdGUuIE11c3QgaW5jbHVkZSBge3h9YCwgYHt5fWAgb3IgYHsteX1gLCBhbmQgYHt6fWAgcGxhY2Vob2xkZXJzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbd3JhcFg9dHJ1ZV0gV2hldGhlciB0byB3cmFwIHRoZSB3b3JsZCBob3Jpem9udGFsbHkuXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIExheWVyIHNvdXJjZSBmb3IgdGhlIFN0YW1lbiB0aWxlIHNlcnZlci5cbiAqIEBhcGlcbiAqL1xudmFyIFN0YW1lbiA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFhZWikge1xuICBmdW5jdGlvbiBTdGFtZW4ob3B0aW9ucykge1xuICAgIHZhciBpID0gb3B0aW9ucy5sYXllci5pbmRleE9mKCctJyk7XG4gICAgdmFyIHByb3ZpZGVyID0gaSA9PSAtMSA/IG9wdGlvbnMubGF5ZXIgOiBvcHRpb25zLmxheWVyLnNsaWNlKDAsIGkpO1xuICAgIHZhciBwcm92aWRlckNvbmZpZyA9IFByb3ZpZGVyQ29uZmlnW3Byb3ZpZGVyXTtcblxuICAgIHZhciBsYXllckNvbmZpZyA9IExheWVyQ29uZmlnW29wdGlvbnMubGF5ZXJdO1xuXG4gICAgdmFyIHVybCA9IG9wdGlvbnMudXJsICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnVybCA6XG4gICAgICAnaHR0cHM6Ly9zdGFtZW4tdGlsZXMte2EtZH0uYS5zc2wuZmFzdGx5Lm5ldC8nICsgb3B0aW9ucy5sYXllciArXG4gICAgICAgICcve3p9L3t4fS97eX0uJyArIGxheWVyQ29uZmlnLmV4dGVuc2lvbjtcblxuICAgIFhZWi5jYWxsKHRoaXMsIHtcbiAgICAgIGF0dHJpYnV0aW9uczogQVRUUklCVVRJT05TLFxuICAgICAgY2FjaGVTaXplOiBvcHRpb25zLmNhY2hlU2l6ZSxcbiAgICAgIGNyb3NzT3JpZ2luOiAnYW5vbnltb3VzJyxcbiAgICAgIG1heFpvb206IG9wdGlvbnMubWF4Wm9vbSAhPSB1bmRlZmluZWQgPyBvcHRpb25zLm1heFpvb20gOiBwcm92aWRlckNvbmZpZy5tYXhab29tLFxuICAgICAgbWluWm9vbTogb3B0aW9ucy5taW5ab29tICE9IHVuZGVmaW5lZCA/IG9wdGlvbnMubWluWm9vbSA6IHByb3ZpZGVyQ29uZmlnLm1pblpvb20sXG4gICAgICBvcGFxdWU6IGxheWVyQ29uZmlnLm9wYXF1ZSxcbiAgICAgIHJlcHJvamVjdGlvbkVycm9yVGhyZXNob2xkOiBvcHRpb25zLnJlcHJvamVjdGlvbkVycm9yVGhyZXNob2xkLFxuICAgICAgdGlsZUxvYWRGdW5jdGlvbjogb3B0aW9ucy50aWxlTG9hZEZ1bmN0aW9uLFxuICAgICAgdXJsOiB1cmwsXG4gICAgICB3cmFwWDogb3B0aW9ucy53cmFwWFxuICAgIH0pO1xuXG4gIH1cblxuICBpZiAoIFhZWiApIFN0YW1lbi5fX3Byb3RvX18gPSBYWVo7XG4gIFN0YW1lbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBYWVogJiYgWFlaLnByb3RvdHlwZSApO1xuICBTdGFtZW4ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3RhbWVuO1xuXG4gIHJldHVybiBTdGFtZW47XG59KFhZWikpO1xuXG5leHBvcnQgZGVmYXVsdCBTdGFtZW47XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0YW1lbi5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvc291cmNlL1N0YXRlXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICogU3RhdGUgb2YgdGhlIHNvdXJjZSwgb25lIG9mICd1bmRlZmluZWQnLCAnbG9hZGluZycsICdyZWFkeScgb3IgJ2Vycm9yJy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBVTkRFRklORUQ6ICd1bmRlZmluZWQnLFxuICBMT0FESU5HOiAnbG9hZGluZycsXG4gIFJFQURZOiAncmVhZHknLFxuICBFUlJPUjogJ2Vycm9yJ1xufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RhdGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3NvdXJjZS9UaWxlXG4gKi9cbmltcG9ydCB7YWJzdHJhY3R9IGZyb20gJy4uL3V0aWwuanMnO1xuaW1wb3J0IFRpbGVDYWNoZSBmcm9tICcuLi9UaWxlQ2FjaGUuanMnO1xuaW1wb3J0IFRpbGVTdGF0ZSBmcm9tICcuLi9UaWxlU3RhdGUuanMnO1xuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cy9FdmVudC5qcyc7XG5pbXBvcnQge2VxdWl2YWxlbnR9IGZyb20gJy4uL3Byb2ouanMnO1xuaW1wb3J0IHt0b1NpemUsIHNjYWxlIGFzIHNjYWxlU2l6ZX0gZnJvbSAnLi4vc2l6ZS5qcyc7XG5pbXBvcnQgU291cmNlIGZyb20gJy4vU291cmNlLmpzJztcbmltcG9ydCB7Z2V0S2V5WlhZLCB3aXRoaW5FeHRlbnRBbmRafSBmcm9tICcuLi90aWxlY29vcmQuanMnO1xuaW1wb3J0IHt3cmFwWCwgZ2V0Rm9yUHJvamVjdGlvbiBhcyBnZXRUaWxlR3JpZEZvclByb2plY3Rpb259IGZyb20gJy4uL3RpbGVncmlkLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vU291cmNlLmpzXCIpLkF0dHJpYnV0aW9uTGlrZX0gW2F0dHJpYnV0aW9uc11cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2F0dHJpYnV0aW9uc0NvbGxhcHNpYmxlPXRydWVdIEF0dHJpYnV0aW9ucyBhcmUgY29sbGFwc2libGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2NhY2hlU2l6ZV1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW29wYXF1ZV1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdGlsZVBpeGVsUmF0aW9dXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3Byb2ouanNcIikuUHJvamVjdGlvbkxpa2V9IFtwcm9qZWN0aW9uXVxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL1N0YXRlLmpzXCIpLmRlZmF1bHR9IFtzdGF0ZV1cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH0gW3RpbGVHcmlkXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbd3JhcFg9dHJ1ZV1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdHJhbnNpdGlvbl1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBba2V5XVxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzOyBub3JtYWxseSBvbmx5IHVzZWQgZm9yIGNyZWF0aW5nIHN1YmNsYXNzZXMgYW5kIG5vdFxuICogaW5zdGFudGlhdGVkIGluIGFwcHMuXG4gKiBCYXNlIGNsYXNzIGZvciBzb3VyY2VzIHByb3ZpZGluZyBpbWFnZXMgZGl2aWRlZCBpbnRvIGEgdGlsZSBncmlkLlxuICogQGFic3RyYWN0XG4gKiBAYXBpXG4gKi9cbnZhciBUaWxlU291cmNlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoU291cmNlKSB7XG4gIGZ1bmN0aW9uIFRpbGVTb3VyY2Uob3B0aW9ucykge1xuXG4gICAgU291cmNlLmNhbGwodGhpcywge1xuICAgICAgYXR0cmlidXRpb25zOiBvcHRpb25zLmF0dHJpYnV0aW9ucyxcbiAgICAgIGF0dHJpYnV0aW9uc0NvbGxhcHNpYmxlOiBvcHRpb25zLmF0dHJpYnV0aW9uc0NvbGxhcHNpYmxlLFxuICAgICAgcHJvamVjdGlvbjogb3B0aW9ucy5wcm9qZWN0aW9uLFxuICAgICAgc3RhdGU6IG9wdGlvbnMuc3RhdGUsXG4gICAgICB3cmFwWDogb3B0aW9ucy53cmFwWFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLm9wYXF1ZV8gPSBvcHRpb25zLm9wYXF1ZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5vcGFxdWUgOiBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRpbGVQaXhlbFJhdGlvXyA9IG9wdGlvbnMudGlsZVBpeGVsUmF0aW8gIT09IHVuZGVmaW5lZCA/XG4gICAgICBvcHRpb25zLnRpbGVQaXhlbFJhdGlvIDogMTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLnRpbGVHcmlkID0gb3B0aW9ucy50aWxlR3JpZCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy50aWxlR3JpZCA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL1RpbGVDYWNoZS5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMudGlsZUNhY2hlID0gbmV3IFRpbGVDYWNoZShvcHRpb25zLmNhY2hlU2l6ZSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX1cbiAgICAgKi9cbiAgICB0aGlzLnRtcFNpemUgPSBbMCwgMF07XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5rZXlfID0gb3B0aW9ucy5rZXkgfHwgJyc7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL1RpbGUuanNcIikuT3B0aW9uc31cbiAgICAgKi9cbiAgICB0aGlzLnRpbGVPcHRpb25zID0ge3RyYW5zaXRpb246IG9wdGlvbnMudHJhbnNpdGlvbn07XG5cbiAgfVxuXG4gIGlmICggU291cmNlICkgVGlsZVNvdXJjZS5fX3Byb3RvX18gPSBTb3VyY2U7XG4gIFRpbGVTb3VyY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU291cmNlICYmIFNvdXJjZS5wcm90b3R5cGUgKTtcbiAgVGlsZVNvdXJjZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUaWxlU291cmNlO1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBDYW4gZXhwaXJlIGNhY2hlLlxuICAgKi9cbiAgVGlsZVNvdXJjZS5wcm90b3R5cGUuY2FuRXhwaXJlQ2FjaGUgPSBmdW5jdGlvbiBjYW5FeHBpcmVDYWNoZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMudGlsZUNhY2hlLmNhbkV4cGlyZUNhY2hlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHBhcmFtIHshT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHQ+fSB1c2VkVGlsZXMgVXNlZCB0aWxlcy5cbiAgICovXG4gIFRpbGVTb3VyY2UucHJvdG90eXBlLmV4cGlyZUNhY2hlID0gZnVuY3Rpb24gZXhwaXJlQ2FjaGUgKHByb2plY3Rpb24sIHVzZWRUaWxlcykge1xuICAgIHZhciB0aWxlQ2FjaGUgPSB0aGlzLmdldFRpbGVDYWNoZUZvclByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gICAgaWYgKHRpbGVDYWNoZSkge1xuICAgICAgdGlsZUNhY2hlLmV4cGlyZUNhY2hlKHVzZWRUaWxlcyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6IFpvb20gbGV2ZWwuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHR9IHRpbGVSYW5nZSBUaWxlIHJhbmdlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGltcG9ydChcIi4uL1RpbGUuanNcIikuZGVmYXVsdCk6KGJvb2xlYW58dm9pZCl9IGNhbGxiYWNrIENhbGxlZCB3aXRoIGVhY2hcbiAgICogICAgIGxvYWRlZCB0aWxlLiAgSWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYGZhbHNlYCwgdGhlIHRpbGUgd2lsbCBub3QgYmVcbiAgICogICAgIGNvbnNpZGVyZWQgbG9hZGVkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgdGlsZSByYW5nZSBpcyBmdWxseSBjb3ZlcmVkIHdpdGggbG9hZGVkIHRpbGVzLlxuICAgKi9cbiAgVGlsZVNvdXJjZS5wcm90b3R5cGUuZm9yRWFjaExvYWRlZFRpbGUgPSBmdW5jdGlvbiBmb3JFYWNoTG9hZGVkVGlsZSAocHJvamVjdGlvbiwgeiwgdGlsZVJhbmdlLCBjYWxsYmFjaykge1xuICAgIHZhciB0aWxlQ2FjaGUgPSB0aGlzLmdldFRpbGVDYWNoZUZvclByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gICAgaWYgKCF0aWxlQ2FjaGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgY292ZXJlZCA9IHRydWU7XG4gICAgdmFyIHRpbGUsIHRpbGVDb29yZEtleSwgbG9hZGVkO1xuICAgIGZvciAodmFyIHggPSB0aWxlUmFuZ2UubWluWDsgeCA8PSB0aWxlUmFuZ2UubWF4WDsgKyt4KSB7XG4gICAgICBmb3IgKHZhciB5ID0gdGlsZVJhbmdlLm1pblk7IHkgPD0gdGlsZVJhbmdlLm1heFk7ICsreSkge1xuICAgICAgICB0aWxlQ29vcmRLZXkgPSBnZXRLZXlaWFkoeiwgeCwgeSk7XG4gICAgICAgIGxvYWRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGlsZUNhY2hlLmNvbnRhaW5zS2V5KHRpbGVDb29yZEtleSkpIHtcbiAgICAgICAgICB0aWxlID0gLyoqIEB0eXBlIHshaW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5kZWZhdWx0fSAqLyAodGlsZUNhY2hlLmdldCh0aWxlQ29vcmRLZXkpKTtcbiAgICAgICAgICBsb2FkZWQgPSB0aWxlLmdldFN0YXRlKCkgPT09IFRpbGVTdGF0ZS5MT0FERUQ7XG4gICAgICAgICAgaWYgKGxvYWRlZCkge1xuICAgICAgICAgICAgbG9hZGVkID0gKGNhbGxiYWNrKHRpbGUpICE9PSBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbG9hZGVkKSB7XG4gICAgICAgICAgY292ZXJlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb3ZlcmVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqIEByZXR1cm4ge251bWJlcn0gR3V0dGVyLlxuICAgKi9cbiAgVGlsZVNvdXJjZS5wcm90b3R5cGUuZ2V0R3V0dGVyRm9yUHJvamVjdGlvbiA9IGZ1bmN0aW9uIGdldEd1dHRlckZvclByb2plY3Rpb24gKHByb2plY3Rpb24pIHtcbiAgICByZXR1cm4gMDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBrZXkgdG8gYmUgdXNlZCBmb3IgYWxsIHRpbGVzIGluIHRoZSBzb3VyY2UuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGtleSBmb3IgYWxsIHRpbGVzLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBUaWxlU291cmNlLnByb3RvdHlwZS5nZXRLZXkgPSBmdW5jdGlvbiBnZXRLZXkgKCkge1xuICAgIHJldHVybiB0aGlzLmtleV87XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdmFsdWUgdG8gYmUgdXNlZCBhcyB0aGUga2V5IGZvciBhbGwgdGlsZXMgaW4gdGhlIHNvdXJjZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IGZvciB0aWxlcy5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgVGlsZVNvdXJjZS5wcm90b3R5cGUuc2V0S2V5ID0gZnVuY3Rpb24gc2V0S2V5IChrZXkpIHtcbiAgICBpZiAodGhpcy5rZXlfICE9PSBrZXkpIHtcbiAgICAgIHRoaXMua2V5XyA9IGtleTtcbiAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBPcGFxdWUuXG4gICAqL1xuICBUaWxlU291cmNlLnByb3RvdHlwZS5nZXRPcGFxdWUgPSBmdW5jdGlvbiBnZXRPcGFxdWUgKHByb2plY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5vcGFxdWVfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgVGlsZVNvdXJjZS5wcm90b3R5cGUuZ2V0UmVzb2x1dGlvbnMgPSBmdW5jdGlvbiBnZXRSZXNvbHV0aW9ucyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudGlsZUdyaWQuZ2V0UmVzb2x1dGlvbnMoKTtcbiAgfTtcblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6IFRpbGUgY29vcmRpbmF0ZSB6LlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBUaWxlIGNvb3JkaW5hdGUgeC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgVGlsZSBjb29yZGluYXRlIHkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqIEByZXR1cm4geyFpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLmRlZmF1bHR9IFRpbGUuXG4gICAqL1xuICBUaWxlU291cmNlLnByb3RvdHlwZS5nZXRUaWxlID0gZnVuY3Rpb24gZ2V0VGlsZSAoeiwgeCwgeSwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbikge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHRpbGUgZ3JpZCBvZiB0aGUgdGlsZSBzb3VyY2UuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9IFRpbGUgZ3JpZC5cbiAgICogQGFwaVxuICAgKi9cbiAgVGlsZVNvdXJjZS5wcm90b3R5cGUuZ2V0VGlsZUdyaWQgPSBmdW5jdGlvbiBnZXRUaWxlR3JpZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMudGlsZUdyaWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7IWltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9IFRpbGUgZ3JpZC5cbiAgICovXG4gIFRpbGVTb3VyY2UucHJvdG90eXBlLmdldFRpbGVHcmlkRm9yUHJvamVjdGlvbiA9IGZ1bmN0aW9uIGdldFRpbGVHcmlkRm9yUHJvamVjdGlvbiQxIChwcm9qZWN0aW9uKSB7XG4gICAgaWYgKCF0aGlzLnRpbGVHcmlkKSB7XG4gICAgICByZXR1cm4gZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy50aWxlR3JpZDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vVGlsZUNhY2hlLmpzXCIpLmRlZmF1bHR9IFRpbGUgY2FjaGUuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIFRpbGVTb3VyY2UucHJvdG90eXBlLmdldFRpbGVDYWNoZUZvclByb2plY3Rpb24gPSBmdW5jdGlvbiBnZXRUaWxlQ2FjaGVGb3JQcm9qZWN0aW9uIChwcm9qZWN0aW9uKSB7XG4gICAgdmFyIHRoaXNQcm9qID0gdGhpcy5nZXRQcm9qZWN0aW9uKCk7XG4gICAgaWYgKHRoaXNQcm9qICYmICFlcXVpdmFsZW50KHRoaXNQcm9qLCBwcm9qZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnRpbGVDYWNoZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdGlsZSBwaXhlbCByYXRpbyBmb3IgdGhpcyBzb3VyY2UuIFN1YmNsYXNzZXMgbWF5IG92ZXJyaWRlIHRoaXNcbiAgICogbWV0aG9kLCB3aGljaCBpcyBtZWFudCB0byByZXR1cm4gYSBzdXBwb3J0ZWQgcGl4ZWwgcmF0aW8gdGhhdCBtYXRjaGVzIHRoZVxuICAgKiBwcm92aWRlZCBgcGl4ZWxSYXRpb2AgYXMgY2xvc2UgYXMgcG9zc2libGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRpbGUgcGl4ZWwgcmF0aW8uXG4gICAqL1xuICBUaWxlU291cmNlLnByb3RvdHlwZS5nZXRUaWxlUGl4ZWxSYXRpbyA9IGZ1bmN0aW9uIGdldFRpbGVQaXhlbFJhdGlvIChwaXhlbFJhdGlvKSB7XG4gICAgcmV0dXJuIHRoaXMudGlsZVBpeGVsUmF0aW9fO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0geiBaLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IFRpbGUgc2l6ZS5cbiAgICovXG4gIFRpbGVTb3VyY2UucHJvdG90eXBlLmdldFRpbGVQaXhlbFNpemUgPSBmdW5jdGlvbiBnZXRUaWxlUGl4ZWxTaXplICh6LCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKSB7XG4gICAgdmFyIHRpbGVHcmlkID0gdGhpcy5nZXRUaWxlR3JpZEZvclByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gICAgdmFyIHRpbGVQaXhlbFJhdGlvID0gdGhpcy5nZXRUaWxlUGl4ZWxSYXRpbyhwaXhlbFJhdGlvKTtcbiAgICB2YXIgdGlsZVNpemUgPSB0b1NpemUodGlsZUdyaWQuZ2V0VGlsZVNpemUoeiksIHRoaXMudG1wU2l6ZSk7XG4gICAgaWYgKHRpbGVQaXhlbFJhdGlvID09IDEpIHtcbiAgICAgIHJldHVybiB0aWxlU2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNjYWxlU2l6ZSh0aWxlU2l6ZSwgdGlsZVBpeGVsUmF0aW8sIHRoaXMudG1wU2l6ZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdGlsZSBjb29yZGluYXRlIHdyYXBwZWQgYXJvdW5kIHRoZSB4LWF4aXMuIFdoZW4gdGhlIHRpbGUgY29vcmRpbmF0ZVxuICAgKiBpcyBvdXRzaWRlIHRoZSByZXNvbHV0aW9uIGFuZCBleHRlbnQgcmFuZ2Ugb2YgdGhlIHRpbGUgZ3JpZCwgYG51bGxgIHdpbGwgYmVcbiAgICogcmV0dXJuZWQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdD19IG9wdF9wcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IFRpbGUgY29vcmRpbmF0ZSB0byBiZSBwYXNzZWQgdG8gdGhlIHRpbGVVcmxGdW5jdGlvbiBvclxuICAgKiAgICAgbnVsbCBpZiBubyB0aWxlIFVSTCBzaG91bGQgYmUgY3JlYXRlZCBmb3IgdGhlIHBhc3NlZCBgdGlsZUNvb3JkYC5cbiAgICovXG4gIFRpbGVTb3VyY2UucHJvdG90eXBlLmdldFRpbGVDb29yZEZvclRpbGVVcmxGdW5jdGlvbiA9IGZ1bmN0aW9uIGdldFRpbGVDb29yZEZvclRpbGVVcmxGdW5jdGlvbiAodGlsZUNvb3JkLCBvcHRfcHJvamVjdGlvbikge1xuICAgIHZhciBwcm9qZWN0aW9uID0gb3B0X3Byb2plY3Rpb24gIT09IHVuZGVmaW5lZCA/XG4gICAgICBvcHRfcHJvamVjdGlvbiA6IHRoaXMuZ2V0UHJvamVjdGlvbigpO1xuICAgIHZhciB0aWxlR3JpZCA9IHRoaXMuZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICAgIGlmICh0aGlzLmdldFdyYXBYKCkgJiYgcHJvamVjdGlvbi5pc0dsb2JhbCgpKSB7XG4gICAgICB0aWxlQ29vcmQgPSB3cmFwWCh0aWxlR3JpZCwgdGlsZUNvb3JkLCBwcm9qZWN0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHdpdGhpbkV4dGVudEFuZFoodGlsZUNvb3JkLCB0aWxlR3JpZCkgPyB0aWxlQ29vcmQgOiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgVGlsZVNvdXJjZS5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uIHJlZnJlc2ggKCkge1xuICAgIHRoaXMudGlsZUNhY2hlLmNsZWFyKCk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1hcmtzIGEgdGlsZSBjb29yZCBhcyBiZWluZyB1c2VkLCB3aXRob3V0IHRyaWdnZXJpbmcgYSBsb2FkLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHogVGlsZSBjb29yZGluYXRlIHouXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFRpbGUgY29vcmRpbmF0ZSB4LlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBUaWxlIGNvb3JkaW5hdGUgeS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgKi9cbiAgVGlsZVNvdXJjZS5wcm90b3R5cGUudXNlVGlsZSA9IGZ1bmN0aW9uIHVzZVRpbGUgKHosIHgsIHksIHByb2plY3Rpb24pIHt9O1xuXG4gIHJldHVybiBUaWxlU291cmNlO1xufShTb3VyY2UpKTtcblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEV2ZW50cyBlbWl0dGVkIGJ5IHtAbGluayBtb2R1bGU6b2wvc291cmNlL1RpbGV+VGlsZVNvdXJjZX0gaW5zdGFuY2VzIGFyZSBpbnN0YW5jZXMgb2YgdGhpc1xuICogdHlwZS5cbiAqL1xuZXhwb3J0IHZhciBUaWxlU291cmNlRXZlbnQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChFdmVudCkge1xuICBmdW5jdGlvbiBUaWxlU291cmNlRXZlbnQodHlwZSwgdGlsZSkge1xuXG4gICAgRXZlbnQuY2FsbCh0aGlzLCB0eXBlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0aWxlIHJlbGF0ZWQgdG8gdGhlIGV2ZW50LlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLmRlZmF1bHR9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMudGlsZSA9IHRpbGU7XG5cbiAgfVxuXG4gIGlmICggRXZlbnQgKSBUaWxlU291cmNlRXZlbnQuX19wcm90b19fID0gRXZlbnQ7XG4gIFRpbGVTb3VyY2VFdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFdmVudCAmJiBFdmVudC5wcm90b3R5cGUgKTtcbiAgVGlsZVNvdXJjZUV2ZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRpbGVTb3VyY2VFdmVudDtcblxuICByZXR1cm4gVGlsZVNvdXJjZUV2ZW50O1xufShFdmVudCkpO1xuXG5leHBvcnQgZGVmYXVsdCBUaWxlU291cmNlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaWxlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9zb3VyY2UvVGlsZUV2ZW50VHlwZVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiBhIHRpbGUgc3RhcnRzIGxvYWRpbmcuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvc291cmNlL1RpbGUuVGlsZVNvdXJjZUV2ZW50I3RpbGVsb2Fkc3RhcnRcbiAgICogQGFwaVxuICAgKi9cbiAgVElMRUxPQURTVEFSVDogJ3RpbGVsb2Fkc3RhcnQnLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiBhIHRpbGUgZmluaXNoZXMgbG9hZGluZywgZWl0aGVyIHdoZW4gaXRzIGRhdGEgaXMgbG9hZGVkLFxuICAgKiBvciB3aGVuIGxvYWRpbmcgd2FzIGFib3J0ZWQgYmVjYXVzZSB0aGUgdGlsZSBpcyBubyBsb25nZXIgbmVlZGVkLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL3NvdXJjZS9UaWxlLlRpbGVTb3VyY2VFdmVudCN0aWxlbG9hZGVuZFxuICAgKiBAYXBpXG4gICAqL1xuICBUSUxFTE9BREVORDogJ3RpbGVsb2FkZW5kJyxcblxuICAvKipcbiAgICogVHJpZ2dlcmVkIGlmIHRpbGUgbG9hZGluZyByZXN1bHRzIGluIGFuIGVycm9yLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL3NvdXJjZS9UaWxlLlRpbGVTb3VyY2VFdmVudCN0aWxlbG9hZGVycm9yXG4gICAqIEBhcGlcbiAgICovXG4gIFRJTEVMT0FERVJST1I6ICd0aWxlbG9hZGVycm9yJ1xuXG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaWxlRXZlbnRUeXBlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9zb3VyY2UvVGlsZUltYWdlXG4gKi9cbmltcG9ydCB7RU5BQkxFX1JBU1RFUl9SRVBST0pFQ1RJT059IGZyb20gJy4uL3JlcHJvai9jb21tb24uanMnO1xuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4uL3V0aWwuanMnO1xuaW1wb3J0IEltYWdlVGlsZSBmcm9tICcuLi9JbWFnZVRpbGUuanMnO1xuaW1wb3J0IFRpbGVDYWNoZSBmcm9tICcuLi9UaWxlQ2FjaGUuanMnO1xuaW1wb3J0IFRpbGVTdGF0ZSBmcm9tICcuLi9UaWxlU3RhdGUuanMnO1xuaW1wb3J0IHtsaXN0ZW59IGZyb20gJy4uL2V2ZW50cy5qcyc7XG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4uL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IHtlcXVpdmFsZW50LCBnZXQgYXMgZ2V0UHJvamVjdGlvbn0gZnJvbSAnLi4vcHJvai5qcyc7XG5pbXBvcnQgUmVwcm9qVGlsZSBmcm9tICcuLi9yZXByb2ovVGlsZS5qcyc7XG5pbXBvcnQgVXJsVGlsZSBmcm9tICcuL1VybFRpbGUuanMnO1xuaW1wb3J0IHtnZXRLZXksIGdldEtleVpYWX0gZnJvbSAnLi4vdGlsZWNvb3JkLmpzJztcbmltcG9ydCB7Z2V0Rm9yUHJvamVjdGlvbiBhcyBnZXRUaWxlR3JpZEZvclByb2plY3Rpb259IGZyb20gJy4uL3RpbGVncmlkLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vU291cmNlLmpzXCIpLkF0dHJpYnV0aW9uTGlrZX0gW2F0dHJpYnV0aW9uc10gQXR0cmlidXRpb25zLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbYXR0cmlidXRpb25zQ29sbGFwc2libGU9dHJ1ZV0gQXR0cmlidXRpb25zIGFyZSBjb2xsYXBzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY2FjaGVTaXplPTIwNDhdIENhY2hlIHNpemUuXG4gKiBAcHJvcGVydHkge251bGx8c3RyaW5nfSBbY3Jvc3NPcmlnaW5dIFRoZSBgY3Jvc3NPcmlnaW5gIGF0dHJpYnV0ZSBmb3IgbG9hZGVkIGltYWdlcy4gIE5vdGUgdGhhdFxuICogeW91IG11c3QgcHJvdmlkZSBhIGBjcm9zc09yaWdpbmAgdmFsdWUgaWYgeW91IGFyZSB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXIgb3IgaWYgeW91IHdhbnQgdG9cbiAqIGFjY2VzcyBwaXhlbCBkYXRhIHdpdGggdGhlIENhbnZhcyByZW5kZXJlci4gIFNlZVxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9DT1JTX2VuYWJsZWRfaW1hZ2UgZm9yIG1vcmUgZGV0YWlsLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbb3BhcXVlPXRydWVdIFdoZXRoZXIgdGhlIGxheWVyIGlzIG9wYXF1ZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyZXByb2plY3Rpb25FcnJvclRocmVzaG9sZD0wLjVdIE1heGltdW0gYWxsb3dlZCByZXByb2plY3Rpb24gZXJyb3IgKGluIHBpeGVscykuXG4gKiBIaWdoZXIgdmFsdWVzIGNhbiBpbmNyZWFzZSByZXByb2plY3Rpb24gcGVyZm9ybWFuY2UsIGJ1dCBkZWNyZWFzZSBwcmVjaXNpb24uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vU3RhdGUuanNcIikuZGVmYXVsdH0gW3N0YXRlXSBTb3VyY2Ugc3RhdGUuXG4gKiBAcHJvcGVydHkge3R5cGVvZiBpbXBvcnQoXCIuLi9JbWFnZVRpbGUuanNcIikuZGVmYXVsdH0gW3RpbGVDbGFzc10gQ2xhc3MgdXNlZCB0byBpbnN0YW50aWF0ZSBpbWFnZSB0aWxlcy5cbiAqIERlZmF1bHQgaXMge0BsaW5rIG1vZHVsZTpvbC9JbWFnZVRpbGV+SW1hZ2VUaWxlfS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH0gW3RpbGVHcmlkXSBUaWxlIGdyaWQuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL1RpbGUuanNcIikuTG9hZEZ1bmN0aW9ufSBbdGlsZUxvYWRGdW5jdGlvbl0gT3B0aW9uYWwgZnVuY3Rpb24gdG8gbG9hZCBhIHRpbGUgZ2l2ZW4gYSBVUkwuIFRoZSBkZWZhdWx0IGlzXG4gKiBgYGBqc1xuICogZnVuY3Rpb24oaW1hZ2VUaWxlLCBzcmMpIHtcbiAqICAgaW1hZ2VUaWxlLmdldEltYWdlKCkuc3JjID0gc3JjO1xuICogfTtcbiAqIGBgYFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0aWxlUGl4ZWxSYXRpbz0xXSBUaGUgcGl4ZWwgcmF0aW8gdXNlZCBieSB0aGUgdGlsZSBzZXJ2aWNlLiBGb3IgZXhhbXBsZSwgaWYgdGhlIHRpbGVcbiAqIHNlcnZpY2UgYWR2ZXJ0aXplcyAyNTZweCBieSAyNTZweCB0aWxlcyBidXQgYWN0dWFsbHkgc2VuZHMgNTEycHhcbiAqIGJ5IDUxMnB4IGltYWdlcyAoZm9yIHJldGluYS9oaWRwaSBkZXZpY2VzKSB0aGVuIGB0aWxlUGl4ZWxSYXRpb2BcbiAqIHNob3VsZCBiZSBzZXQgdG8gYDJgLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLlVybEZ1bmN0aW9ufSBbdGlsZVVybEZ1bmN0aW9uXSBPcHRpb25hbCBmdW5jdGlvbiB0byBnZXQgdGlsZSBVUkwgZ2l2ZW4gYSB0aWxlIGNvb3JkaW5hdGUgYW5kIHRoZSBwcm9qZWN0aW9uLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt1cmxdIFVSTCB0ZW1wbGF0ZS4gTXVzdCBpbmNsdWRlIGB7eH1gLCBge3l9YCBvciBgey15fWAsIGFuZCBge3p9YCBwbGFjZWhvbGRlcnMuXG4gKiBBIGB7Py0/fWAgdGVtcGxhdGUgcGF0dGVybiwgZm9yIGV4YW1wbGUgYHN1YmRvbWFpbnthLWZ9LmRvbWFpbi5jb21gLCBtYXkgYmVcbiAqIHVzZWQgaW5zdGVhZCBvZiBkZWZpbmluZyBlYWNoIG9uZSBzZXBhcmF0ZWx5IGluIHRoZSBgdXJsc2Agb3B0aW9uLlxuICogQHByb3BlcnR5IHtBcnJheTxzdHJpbmc+fSBbdXJsc10gQW4gYXJyYXkgb2YgVVJMIHRlbXBsYXRlcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3dyYXBYXSBXaGV0aGVyIHRvIHdyYXAgdGhlIHdvcmxkIGhvcml6b250YWxseS4gVGhlIGRlZmF1bHQsIGlzIHRvXG4gKiByZXF1ZXN0IG91dC1vZi1ib3VuZHMgdGlsZXMgZnJvbSB0aGUgc2VydmVyLiBXaGVuIHNldCB0byBgZmFsc2VgLCBvbmx5IG9uZVxuICogd29ybGQgd2lsbCBiZSByZW5kZXJlZC4gV2hlbiBzZXQgdG8gYHRydWVgLCB0aWxlcyB3aWxsIGJlIHJlcXVlc3RlZCBmb3Igb25lXG4gKiB3b3JsZCBvbmx5LCBidXQgdGhleSB3aWxsIGJlIHdyYXBwZWQgaG9yaXpvbnRhbGx5IHRvIHJlbmRlciBtdWx0aXBsZSB3b3JsZHMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RyYW5zaXRpb25dIER1cmF0aW9uIG9mIHRoZSBvcGFjaXR5IHRyYW5zaXRpb24gZm9yIHJlbmRlcmluZy5cbiAqIFRvIGRpc2FibGUgdGhlIG9wYWNpdHkgdHJhbnNpdGlvbiwgcGFzcyBgdHJhbnNpdGlvbjogMGAuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2tleV0gT3B0aW9uYWwgdGlsZSBrZXkgZm9yIHByb3BlciBjYWNoZSBmZXRjaGluZ1xuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBCYXNlIGNsYXNzIGZvciBzb3VyY2VzIHByb3ZpZGluZyBpbWFnZXMgZGl2aWRlZCBpbnRvIGEgdGlsZSBncmlkLlxuICpcbiAqIEBmaXJlcyBpbXBvcnQoXCIuL1RpbGUuanNcIikuVGlsZVNvdXJjZUV2ZW50XG4gKiBAYXBpXG4gKi9cbnZhciBUaWxlSW1hZ2UgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChVcmxUaWxlKSB7XG4gIGZ1bmN0aW9uIFRpbGVJbWFnZShvcHRpb25zKSB7XG5cbiAgICBVcmxUaWxlLmNhbGwodGhpcywge1xuICAgICAgYXR0cmlidXRpb25zOiBvcHRpb25zLmF0dHJpYnV0aW9ucyxcbiAgICAgIGNhY2hlU2l6ZTogb3B0aW9ucy5jYWNoZVNpemUsXG4gICAgICBvcGFxdWU6IG9wdGlvbnMub3BhcXVlLFxuICAgICAgcHJvamVjdGlvbjogb3B0aW9ucy5wcm9qZWN0aW9uLFxuICAgICAgc3RhdGU6IG9wdGlvbnMuc3RhdGUsXG4gICAgICB0aWxlR3JpZDogb3B0aW9ucy50aWxlR3JpZCxcbiAgICAgIHRpbGVMb2FkRnVuY3Rpb246IG9wdGlvbnMudGlsZUxvYWRGdW5jdGlvbiA/XG4gICAgICAgIG9wdGlvbnMudGlsZUxvYWRGdW5jdGlvbiA6IGRlZmF1bHRUaWxlTG9hZEZ1bmN0aW9uLFxuICAgICAgdGlsZVBpeGVsUmF0aW86IG9wdGlvbnMudGlsZVBpeGVsUmF0aW8sXG4gICAgICB0aWxlVXJsRnVuY3Rpb246IG9wdGlvbnMudGlsZVVybEZ1bmN0aW9uLFxuICAgICAgdXJsOiBvcHRpb25zLnVybCxcbiAgICAgIHVybHM6IG9wdGlvbnMudXJscyxcbiAgICAgIHdyYXBYOiBvcHRpb25zLndyYXBYLFxuICAgICAgdHJhbnNpdGlvbjogb3B0aW9ucy50cmFuc2l0aW9uLFxuICAgICAga2V5OiBvcHRpb25zLmtleSxcbiAgICAgIGF0dHJpYnV0aW9uc0NvbGxhcHNpYmxlOiBvcHRpb25zLmF0dHJpYnV0aW9uc0NvbGxhcHNpYmxlXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUgez9zdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5jcm9zc09yaWdpbiA9XG4gICAgICAgIG9wdGlvbnMuY3Jvc3NPcmlnaW4gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY3Jvc3NPcmlnaW4gOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHt0eXBlb2YgSW1hZ2VUaWxlfVxuICAgICAqL1xuICAgIHRoaXMudGlsZUNsYXNzID0gb3B0aW9ucy50aWxlQ2xhc3MgIT09IHVuZGVmaW5lZCA/XG4gICAgICBvcHRpb25zLnRpbGVDbGFzcyA6IEltYWdlVGlsZTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIFRpbGVDYWNoZT59XG4gICAgICovXG4gICAgdGhpcy50aWxlQ2FjaGVGb3JQcm9qZWN0aW9uID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0Pn1cbiAgICAgKi9cbiAgICB0aGlzLnRpbGVHcmlkRm9yUHJvamVjdGlvbiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnJlcHJvamVjdGlvbkVycm9yVGhyZXNob2xkXyA9IG9wdGlvbnMucmVwcm9qZWN0aW9uRXJyb3JUaHJlc2hvbGQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyUmVwcm9qZWN0aW9uRWRnZXNfID0gZmFsc2U7XG4gIH1cblxuICBpZiAoIFVybFRpbGUgKSBUaWxlSW1hZ2UuX19wcm90b19fID0gVXJsVGlsZTtcbiAgVGlsZUltYWdlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFVybFRpbGUgJiYgVXJsVGlsZS5wcm90b3R5cGUgKTtcbiAgVGlsZUltYWdlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRpbGVJbWFnZTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIFRpbGVJbWFnZS5wcm90b3R5cGUuY2FuRXhwaXJlQ2FjaGUgPSBmdW5jdGlvbiBjYW5FeHBpcmVDYWNoZSAoKSB7XG4gICAgaWYgKCFFTkFCTEVfUkFTVEVSX1JFUFJPSkVDVElPTikge1xuICAgICAgcmV0dXJuIFVybFRpbGUucHJvdG90eXBlLmNhbkV4cGlyZUNhY2hlLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRpbGVDYWNoZS5jYW5FeHBpcmVDYWNoZSgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMudGlsZUNhY2hlRm9yUHJvamVjdGlvbikge1xuICAgICAgICBpZiAodGhpcy50aWxlQ2FjaGVGb3JQcm9qZWN0aW9uW2tleV0uY2FuRXhwaXJlQ2FjaGUoKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIFRpbGVJbWFnZS5wcm90b3R5cGUuZXhwaXJlQ2FjaGUgPSBmdW5jdGlvbiBleHBpcmVDYWNoZSAocHJvamVjdGlvbiwgdXNlZFRpbGVzKSB7XG4gICAgaWYgKCFFTkFCTEVfUkFTVEVSX1JFUFJPSkVDVElPTikge1xuICAgICAgVXJsVGlsZS5wcm90b3R5cGUuZXhwaXJlQ2FjaGUuY2FsbCh0aGlzLCBwcm9qZWN0aW9uLCB1c2VkVGlsZXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdXNlZFRpbGVDYWNoZSA9IHRoaXMuZ2V0VGlsZUNhY2hlRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcblxuICAgIHRoaXMudGlsZUNhY2hlLmV4cGlyZUNhY2hlKHRoaXMudGlsZUNhY2hlID09IHVzZWRUaWxlQ2FjaGUgPyB1c2VkVGlsZXMgOiB7fSk7XG4gICAgZm9yICh2YXIgaWQgaW4gdGhpcy50aWxlQ2FjaGVGb3JQcm9qZWN0aW9uKSB7XG4gICAgICB2YXIgdGlsZUNhY2hlID0gdGhpcy50aWxlQ2FjaGVGb3JQcm9qZWN0aW9uW2lkXTtcbiAgICAgIHRpbGVDYWNoZS5leHBpcmVDYWNoZSh0aWxlQ2FjaGUgPT0gdXNlZFRpbGVDYWNoZSA/IHVzZWRUaWxlcyA6IHt9KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBUaWxlSW1hZ2UucHJvdG90eXBlLmdldEd1dHRlckZvclByb2plY3Rpb24gPSBmdW5jdGlvbiBnZXRHdXR0ZXJGb3JQcm9qZWN0aW9uIChwcm9qZWN0aW9uKSB7XG4gICAgaWYgKEVOQUJMRV9SQVNURVJfUkVQUk9KRUNUSU9OICYmXG4gICAgICAgIHRoaXMuZ2V0UHJvamVjdGlvbigpICYmIHByb2plY3Rpb24gJiYgIWVxdWl2YWxlbnQodGhpcy5nZXRQcm9qZWN0aW9uKCksIHByb2plY3Rpb24pKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0R3V0dGVyKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEd1dHRlci5cbiAgICovXG4gIFRpbGVJbWFnZS5wcm90b3R5cGUuZ2V0R3V0dGVyID0gZnVuY3Rpb24gZ2V0R3V0dGVyICgpIHtcbiAgICByZXR1cm4gMDtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIFRpbGVJbWFnZS5wcm90b3R5cGUuZ2V0T3BhcXVlID0gZnVuY3Rpb24gZ2V0T3BhcXVlIChwcm9qZWN0aW9uKSB7XG4gICAgaWYgKEVOQUJMRV9SQVNURVJfUkVQUk9KRUNUSU9OICYmXG4gICAgICAgIHRoaXMuZ2V0UHJvamVjdGlvbigpICYmIHByb2plY3Rpb24gJiYgIWVxdWl2YWxlbnQodGhpcy5nZXRQcm9qZWN0aW9uKCksIHByb2plY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBVcmxUaWxlLnByb3RvdHlwZS5nZXRPcGFxdWUuY2FsbCh0aGlzLCBwcm9qZWN0aW9uKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBUaWxlSW1hZ2UucHJvdG90eXBlLmdldFRpbGVHcmlkRm9yUHJvamVjdGlvbiA9IGZ1bmN0aW9uIGdldFRpbGVHcmlkRm9yUHJvamVjdGlvbiQxIChwcm9qZWN0aW9uKSB7XG4gICAgaWYgKCFFTkFCTEVfUkFTVEVSX1JFUFJPSkVDVElPTikge1xuICAgICAgcmV0dXJuIFVybFRpbGUucHJvdG90eXBlLmdldFRpbGVHcmlkRm9yUHJvamVjdGlvbi5jYWxsKHRoaXMsIHByb2plY3Rpb24pO1xuICAgIH1cbiAgICB2YXIgdGhpc1Byb2ogPSB0aGlzLmdldFByb2plY3Rpb24oKTtcbiAgICBpZiAodGhpcy50aWxlR3JpZCAmJiAoIXRoaXNQcm9qIHx8IGVxdWl2YWxlbnQodGhpc1Byb2osIHByb2plY3Rpb24pKSkge1xuICAgICAgcmV0dXJuIHRoaXMudGlsZUdyaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwcm9qS2V5ID0gZ2V0VWlkKHByb2plY3Rpb24pO1xuICAgICAgaWYgKCEocHJvaktleSBpbiB0aGlzLnRpbGVHcmlkRm9yUHJvamVjdGlvbikpIHtcbiAgICAgICAgdGhpcy50aWxlR3JpZEZvclByb2plY3Rpb25bcHJvaktleV0gPSBnZXRUaWxlR3JpZEZvclByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gKFxuICAgICAgICAvKiogQHR5cGUgeyFpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSAqLyAodGhpcy50aWxlR3JpZEZvclByb2plY3Rpb25bcHJvaktleV0pXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIFRpbGVJbWFnZS5wcm90b3R5cGUuZ2V0VGlsZUNhY2hlRm9yUHJvamVjdGlvbiA9IGZ1bmN0aW9uIGdldFRpbGVDYWNoZUZvclByb2plY3Rpb24gKHByb2plY3Rpb24pIHtcbiAgICBpZiAoIUVOQUJMRV9SQVNURVJfUkVQUk9KRUNUSU9OKSB7XG4gICAgICByZXR1cm4gVXJsVGlsZS5wcm90b3R5cGUuZ2V0VGlsZUNhY2hlRm9yUHJvamVjdGlvbi5jYWxsKHRoaXMsIHByb2plY3Rpb24pO1xuICAgIH1cbiAgICB2YXIgdGhpc1Byb2ogPSB0aGlzLmdldFByb2plY3Rpb24oKTsgaWYgKCF0aGlzUHJvaiB8fCBlcXVpdmFsZW50KHRoaXNQcm9qLCBwcm9qZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIHRoaXMudGlsZUNhY2hlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHJvaktleSA9IGdldFVpZChwcm9qZWN0aW9uKTtcbiAgICAgIGlmICghKHByb2pLZXkgaW4gdGhpcy50aWxlQ2FjaGVGb3JQcm9qZWN0aW9uKSkge1xuICAgICAgICB0aGlzLnRpbGVDYWNoZUZvclByb2plY3Rpb25bcHJvaktleV0gPSBuZXcgVGlsZUNhY2hlKHRoaXMudGlsZUNhY2hlLmhpZ2hXYXRlck1hcmspO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudGlsZUNhY2hlRm9yUHJvamVjdGlvbltwcm9qS2V5XTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6IFRpbGUgY29vcmRpbmF0ZSB6LlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBUaWxlIGNvb3JkaW5hdGUgeC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgVGlsZSBjb29yZGluYXRlIHkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBzZXQgb24gdGhlIHRpbGUuXG4gICAqIEByZXR1cm4geyFpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLmRlZmF1bHR9IFRpbGUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBUaWxlSW1hZ2UucHJvdG90eXBlLmNyZWF0ZVRpbGVfID0gZnVuY3Rpb24gY3JlYXRlVGlsZV8gKHosIHgsIHksIHBpeGVsUmF0aW8sIHByb2plY3Rpb24sIGtleSkge1xuICAgIHZhciB0aWxlQ29vcmQgPSBbeiwgeCwgeV07XG4gICAgdmFyIHVybFRpbGVDb29yZCA9IHRoaXMuZ2V0VGlsZUNvb3JkRm9yVGlsZVVybEZ1bmN0aW9uKFxuICAgICAgdGlsZUNvb3JkLCBwcm9qZWN0aW9uKTtcbiAgICB2YXIgdGlsZVVybCA9IHVybFRpbGVDb29yZCA/XG4gICAgICB0aGlzLnRpbGVVcmxGdW5jdGlvbih1cmxUaWxlQ29vcmQsIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pIDogdW5kZWZpbmVkO1xuICAgIHZhciB0aWxlID0gbmV3IHRoaXMudGlsZUNsYXNzKFxuICAgICAgdGlsZUNvb3JkLFxuICAgICAgdGlsZVVybCAhPT0gdW5kZWZpbmVkID8gVGlsZVN0YXRlLklETEUgOiBUaWxlU3RhdGUuRU1QVFksXG4gICAgICB0aWxlVXJsICE9PSB1bmRlZmluZWQgPyB0aWxlVXJsIDogJycsXG4gICAgICB0aGlzLmNyb3NzT3JpZ2luLFxuICAgICAgdGhpcy50aWxlTG9hZEZ1bmN0aW9uLFxuICAgICAgdGhpcy50aWxlT3B0aW9ucyk7XG4gICAgdGlsZS5rZXkgPSBrZXk7XG4gICAgbGlzdGVuKHRpbGUsIEV2ZW50VHlwZS5DSEFOR0UsXG4gICAgICB0aGlzLmhhbmRsZVRpbGVDaGFuZ2UsIHRoaXMpO1xuICAgIHJldHVybiB0aWxlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgVGlsZUltYWdlLnByb3RvdHlwZS5nZXRUaWxlID0gZnVuY3Rpb24gZ2V0VGlsZSAoeiwgeCwgeSwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbikge1xuICAgIHZhciBzb3VyY2VQcm9qZWN0aW9uID0gLyoqIEB0eXBlIHshaW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9ICovICh0aGlzLmdldFByb2plY3Rpb24oKSk7XG4gICAgaWYgKCFFTkFCTEVfUkFTVEVSX1JFUFJPSkVDVElPTiB8fFxuICAgICAgICAhc291cmNlUHJvamVjdGlvbiB8fCAhcHJvamVjdGlvbiB8fCBlcXVpdmFsZW50KHNvdXJjZVByb2plY3Rpb24sIHByb2plY3Rpb24pKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRUaWxlSW50ZXJuYWwoeiwgeCwgeSwgcGl4ZWxSYXRpbywgc291cmNlUHJvamVjdGlvbiB8fCBwcm9qZWN0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNhY2hlID0gdGhpcy5nZXRUaWxlQ2FjaGVGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICAgICAgdmFyIHRpbGVDb29yZCA9IFt6LCB4LCB5XTtcbiAgICAgIHZhciB0aWxlO1xuICAgICAgdmFyIHRpbGVDb29yZEtleSA9IGdldEtleSh0aWxlQ29vcmQpO1xuICAgICAgaWYgKGNhY2hlLmNvbnRhaW5zS2V5KHRpbGVDb29yZEtleSkpIHtcbiAgICAgICAgdGlsZSA9IC8qKiBAdHlwZSB7IWltcG9ydChcIi4uL1RpbGUuanNcIikuZGVmYXVsdH0gKi8gKGNhY2hlLmdldCh0aWxlQ29vcmRLZXkpKTtcbiAgICAgIH1cbiAgICAgIHZhciBrZXkgPSB0aGlzLmdldEtleSgpO1xuICAgICAgaWYgKHRpbGUgJiYgdGlsZS5rZXkgPT0ga2V5KSB7XG4gICAgICAgIHJldHVybiB0aWxlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNvdXJjZVRpbGVHcmlkID0gdGhpcy5nZXRUaWxlR3JpZEZvclByb2plY3Rpb24oc291cmNlUHJvamVjdGlvbik7XG4gICAgICAgIHZhciB0YXJnZXRUaWxlR3JpZCA9IHRoaXMuZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICAgICAgICB2YXIgd3JhcHBlZFRpbGVDb29yZCA9XG4gICAgICAgICAgICB0aGlzLmdldFRpbGVDb29yZEZvclRpbGVVcmxGdW5jdGlvbih0aWxlQ29vcmQsIHByb2plY3Rpb24pO1xuICAgICAgICB2YXIgbmV3VGlsZSA9IG5ldyBSZXByb2pUaWxlKFxuICAgICAgICAgIHNvdXJjZVByb2plY3Rpb24sIHNvdXJjZVRpbGVHcmlkLFxuICAgICAgICAgIHByb2plY3Rpb24sIHRhcmdldFRpbGVHcmlkLFxuICAgICAgICAgIHRpbGVDb29yZCwgd3JhcHBlZFRpbGVDb29yZCwgdGhpcy5nZXRUaWxlUGl4ZWxSYXRpbyhwaXhlbFJhdGlvKSxcbiAgICAgICAgICB0aGlzLmdldEd1dHRlcigpLFxuICAgICAgICAgIGZ1bmN0aW9uKHosIHgsIHksIHBpeGVsUmF0aW8pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFRpbGVJbnRlcm5hbCh6LCB4LCB5LCBwaXhlbFJhdGlvLCBzb3VyY2VQcm9qZWN0aW9uKTtcbiAgICAgICAgICB9LmJpbmQodGhpcyksIHRoaXMucmVwcm9qZWN0aW9uRXJyb3JUaHJlc2hvbGRfLFxuICAgICAgICAgIHRoaXMucmVuZGVyUmVwcm9qZWN0aW9uRWRnZXNfKTtcbiAgICAgICAgbmV3VGlsZS5rZXkgPSBrZXk7XG5cbiAgICAgICAgaWYgKHRpbGUpIHtcbiAgICAgICAgICBuZXdUaWxlLmludGVyaW1UaWxlID0gdGlsZTtcbiAgICAgICAgICBuZXdUaWxlLnJlZnJlc2hJbnRlcmltQ2hhaW4oKTtcbiAgICAgICAgICBjYWNoZS5yZXBsYWNlKHRpbGVDb29yZEtleSwgbmV3VGlsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FjaGUuc2V0KHRpbGVDb29yZEtleSwgbmV3VGlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1RpbGU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0geiBUaWxlIGNvb3JkaW5hdGUgei5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggVGlsZSBjb29yZGluYXRlIHguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IFRpbGUgY29vcmRpbmF0ZSB5LlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHBhcmFtIHshaW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7IWltcG9ydChcIi4uL1RpbGUuanNcIikuZGVmYXVsdH0gVGlsZS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgVGlsZUltYWdlLnByb3RvdHlwZS5nZXRUaWxlSW50ZXJuYWwgPSBmdW5jdGlvbiBnZXRUaWxlSW50ZXJuYWwgKHosIHgsIHksIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pIHtcbiAgICB2YXIgdGlsZSA9IG51bGw7XG4gICAgdmFyIHRpbGVDb29yZEtleSA9IGdldEtleVpYWSh6LCB4LCB5KTtcbiAgICB2YXIga2V5ID0gdGhpcy5nZXRLZXkoKTtcbiAgICBpZiAoIXRoaXMudGlsZUNhY2hlLmNvbnRhaW5zS2V5KHRpbGVDb29yZEtleSkpIHtcbiAgICAgIHRpbGUgPSB0aGlzLmNyZWF0ZVRpbGVfKHosIHgsIHksIHBpeGVsUmF0aW8sIHByb2plY3Rpb24sIGtleSk7XG4gICAgICB0aGlzLnRpbGVDYWNoZS5zZXQodGlsZUNvb3JkS2V5LCB0aWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGlsZSA9IHRoaXMudGlsZUNhY2hlLmdldCh0aWxlQ29vcmRLZXkpO1xuICAgICAgaWYgKHRpbGUua2V5ICE9IGtleSkge1xuICAgICAgICAvLyBUaGUgc291cmNlJ3MgcGFyYW1zIGNoYW5nZWQuIElmIHRoZSB0aWxlIGhhcyBhbiBpbnRlcmltIHRpbGUgYW5kIGlmIHdlXG4gICAgICAgIC8vIGNhbiB1c2UgaXQgdGhlbiB3ZSB1c2UgaXQuIE90aGVyd2lzZSB3ZSBjcmVhdGUgYSBuZXcgdGlsZS4gIEluIGJvdGhcbiAgICAgICAgLy8gY2FzZXMgd2UgYXR0ZW1wdCB0byBhc3NpZ24gYW4gaW50ZXJpbSB0aWxlIHRvIHRoZSBuZXcgdGlsZS5cbiAgICAgICAgdmFyIGludGVyaW1UaWxlID0gdGlsZTtcbiAgICAgICAgdGlsZSA9IHRoaXMuY3JlYXRlVGlsZV8oeiwgeCwgeSwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbiwga2V5KTtcblxuICAgICAgICAvL21ha2UgdGhlIG5ldyB0aWxlIHRoZSBoZWFkIG9mIHRoZSBsaXN0LFxuICAgICAgICBpZiAoaW50ZXJpbVRpbGUuZ2V0U3RhdGUoKSA9PSBUaWxlU3RhdGUuSURMRSkge1xuICAgICAgICAgIC8vdGhlIG9sZCB0aWxlIGhhc24ndCBiZWd1biBsb2FkaW5nIHlldCwgYW5kIGlzIG5vdyBvdXRkYXRlZCwgc28gd2UgY2FuIHNpbXBseSBkaXNjYXJkIGl0XG4gICAgICAgICAgdGlsZS5pbnRlcmltVGlsZSA9IGludGVyaW1UaWxlLmludGVyaW1UaWxlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpbGUuaW50ZXJpbVRpbGUgPSBpbnRlcmltVGlsZTtcbiAgICAgICAgfVxuICAgICAgICB0aWxlLnJlZnJlc2hJbnRlcmltQ2hhaW4oKTtcbiAgICAgICAgdGhpcy50aWxlQ2FjaGUucmVwbGFjZSh0aWxlQ29vcmRLZXksIHRpbGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGlsZTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB3aGV0aGVyIHRvIHJlbmRlciByZXByb2plY3Rpb24gZWRnZXMgb3Igbm90ICh1c3VhbGx5IGZvciBkZWJ1Z2dpbmcpLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlbmRlciBSZW5kZXIgdGhlIGVkZ2VzLlxuICAgKiBAYXBpXG4gICAqL1xuICBUaWxlSW1hZ2UucHJvdG90eXBlLnNldFJlbmRlclJlcHJvamVjdGlvbkVkZ2VzID0gZnVuY3Rpb24gc2V0UmVuZGVyUmVwcm9qZWN0aW9uRWRnZXMgKHJlbmRlcikge1xuICAgIGlmICghRU5BQkxFX1JBU1RFUl9SRVBST0pFQ1RJT04gfHxcbiAgICAgICAgdGhpcy5yZW5kZXJSZXByb2plY3Rpb25FZGdlc18gPT0gcmVuZGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucmVuZGVyUmVwcm9qZWN0aW9uRWRnZXNfID0gcmVuZGVyO1xuICAgIGZvciAodmFyIGlkIGluIHRoaXMudGlsZUNhY2hlRm9yUHJvamVjdGlvbikge1xuICAgICAgdGhpcy50aWxlQ2FjaGVGb3JQcm9qZWN0aW9uW2lkXS5jbGVhcigpO1xuICAgIH1cbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB0aGUgdGlsZSBncmlkIHRvIHVzZSB3aGVuIHJlcHJvamVjdGluZyB0aGUgdGlsZXMgdG8gdGhlIGdpdmVuXG4gICAqIHByb2plY3Rpb24gaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCB0aWxlIGdyaWQgZm9yIHRoZSBwcm9qZWN0aW9uLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiB0aGUgZGVmYXVsdCB0aWxlIGdyaWQgY2Fubm90IGJlIGNyZWF0ZWRcbiAgICogKGUuZy4gcHJvamVjdGlvbiBoYXMgbm8gZXh0ZW50IGRlZmluZWQpIG9yXG4gICAqIGZvciBvcHRpbWl6YXRpb24gcmVhc29ucyAoY3VzdG9tIHRpbGUgc2l6ZSwgcmVzb2x1dGlvbnMsIC4uLikuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9IHRpbGVncmlkIFRpbGUgZ3JpZCB0byB1c2UgZm9yIHRoZSBwcm9qZWN0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBUaWxlSW1hZ2UucHJvdG90eXBlLnNldFRpbGVHcmlkRm9yUHJvamVjdGlvbiA9IGZ1bmN0aW9uIHNldFRpbGVHcmlkRm9yUHJvamVjdGlvbiAocHJvamVjdGlvbiwgdGlsZWdyaWQpIHtcbiAgICBpZiAoRU5BQkxFX1JBU1RFUl9SRVBST0pFQ1RJT04pIHtcbiAgICAgIHZhciBwcm9qID0gZ2V0UHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgICAgIGlmIChwcm9qKSB7XG4gICAgICAgIHZhciBwcm9qS2V5ID0gZ2V0VWlkKHByb2opO1xuICAgICAgICBpZiAoIShwcm9qS2V5IGluIHRoaXMudGlsZUdyaWRGb3JQcm9qZWN0aW9uKSkge1xuICAgICAgICAgIHRoaXMudGlsZUdyaWRGb3JQcm9qZWN0aW9uW3Byb2pLZXldID0gdGlsZWdyaWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFRpbGVJbWFnZTtcbn0oVXJsVGlsZSkpO1xuXG5cbi8qKlxuICogQHBhcmFtIHtJbWFnZVRpbGV9IGltYWdlVGlsZSBJbWFnZSB0aWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IHNyYyBTb3VyY2UuXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRUaWxlTG9hZEZ1bmN0aW9uKGltYWdlVGlsZSwgc3JjKSB7XG4gIC8qKiBAdHlwZSB7SFRNTEltYWdlRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fSAqLyAoaW1hZ2VUaWxlLmdldEltYWdlKCkpLnNyYyA9IHNyYztcbn1cblxuZXhwb3J0IGRlZmF1bHQgVGlsZUltYWdlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaWxlSW1hZ2UuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3NvdXJjZS9VcmxUaWxlXG4gKi9cbmltcG9ydCB7Z2V0VWlkfSBmcm9tICcuLi91dGlsLmpzJztcbmltcG9ydCBUaWxlU3RhdGUgZnJvbSAnLi4vVGlsZVN0YXRlLmpzJztcbmltcG9ydCB7ZXhwYW5kVXJsLCBjcmVhdGVGcm9tVGVtcGxhdGVzLCBudWxsVGlsZVVybEZ1bmN0aW9ufSBmcm9tICcuLi90aWxldXJsZnVuY3Rpb24uanMnO1xuaW1wb3J0IFRpbGVTb3VyY2UsIHtUaWxlU291cmNlRXZlbnR9IGZyb20gJy4vVGlsZS5qcyc7XG5pbXBvcnQgVGlsZUV2ZW50VHlwZSBmcm9tICcuL1RpbGVFdmVudFR5cGUuanMnO1xuaW1wb3J0IHtnZXRLZXlaWFl9IGZyb20gJy4uL3RpbGVjb29yZC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL1NvdXJjZS5qc1wiKS5BdHRyaWJ1dGlvbkxpa2V9IFthdHRyaWJ1dGlvbnNdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZT10cnVlXSBBdHRyaWJ1dGlvbnMgYXJlIGNvbGxhcHNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtjYWNoZVNpemVdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtvcGFxdWVdXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3Byb2ouanNcIikuUHJvamVjdGlvbkxpa2V9IFtwcm9qZWN0aW9uXVxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL1N0YXRlLmpzXCIpLmRlZmF1bHR9IFtzdGF0ZV1cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH0gW3RpbGVHcmlkXVxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLkxvYWRGdW5jdGlvbn0gdGlsZUxvYWRGdW5jdGlvblxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0aWxlUGl4ZWxSYXRpb11cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5VcmxGdW5jdGlvbn0gW3RpbGVVcmxGdW5jdGlvbl1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdXJsXVxuICogQHByb3BlcnR5IHtBcnJheTxzdHJpbmc+fSBbdXJsc11cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3dyYXBYPXRydWVdXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RyYW5zaXRpb25dXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2tleV1cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQmFzZSBjbGFzcyBmb3Igc291cmNlcyBwcm92aWRpbmcgdGlsZXMgZGl2aWRlZCBpbnRvIGEgdGlsZSBncmlkIG92ZXIgaHR0cC5cbiAqXG4gKiBAZmlyZXMgaW1wb3J0KFwiLi9UaWxlLmpzXCIpLlRpbGVTb3VyY2VFdmVudFxuICovXG52YXIgVXJsVGlsZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFRpbGVTb3VyY2UpIHtcbiAgZnVuY3Rpb24gVXJsVGlsZShvcHRpb25zKSB7XG5cbiAgICBUaWxlU291cmNlLmNhbGwodGhpcywge1xuICAgICAgYXR0cmlidXRpb25zOiBvcHRpb25zLmF0dHJpYnV0aW9ucyxcbiAgICAgIGNhY2hlU2l6ZTogb3B0aW9ucy5jYWNoZVNpemUsXG4gICAgICBvcGFxdWU6IG9wdGlvbnMub3BhcXVlLFxuICAgICAgcHJvamVjdGlvbjogb3B0aW9ucy5wcm9qZWN0aW9uLFxuICAgICAgc3RhdGU6IG9wdGlvbnMuc3RhdGUsXG4gICAgICB0aWxlR3JpZDogb3B0aW9ucy50aWxlR3JpZCxcbiAgICAgIHRpbGVQaXhlbFJhdGlvOiBvcHRpb25zLnRpbGVQaXhlbFJhdGlvLFxuICAgICAgd3JhcFg6IG9wdGlvbnMud3JhcFgsXG4gICAgICB0cmFuc2l0aW9uOiBvcHRpb25zLnRyYW5zaXRpb24sXG4gICAgICBrZXk6IG9wdGlvbnMua2V5LFxuICAgICAgYXR0cmlidXRpb25zQ29sbGFwc2libGU6IG9wdGlvbnMuYXR0cmlidXRpb25zQ29sbGFwc2libGVcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5nZW5lcmF0ZVRpbGVVcmxGdW5jdGlvbl8gPSAhb3B0aW9ucy50aWxlVXJsRnVuY3Rpb247XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL1RpbGUuanNcIikuTG9hZEZ1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMudGlsZUxvYWRGdW5jdGlvbiA9IG9wdGlvbnMudGlsZUxvYWRGdW5jdGlvbjtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5VcmxGdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLnRpbGVVcmxGdW5jdGlvbiA9IG9wdGlvbnMudGlsZVVybEZ1bmN0aW9uID8gb3B0aW9ucy50aWxlVXJsRnVuY3Rpb24uYmluZCh0aGlzKSA6IG51bGxUaWxlVXJsRnVuY3Rpb247XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUgeyFBcnJheTxzdHJpbmc+fG51bGx9XG4gICAgICovXG4gICAgdGhpcy51cmxzID0gbnVsbDtcblxuICAgIGlmIChvcHRpb25zLnVybHMpIHtcbiAgICAgIHRoaXMuc2V0VXJscyhvcHRpb25zLnVybHMpO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy51cmwpIHtcbiAgICAgIHRoaXMuc2V0VXJsKG9wdGlvbnMudXJsKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy50aWxlVXJsRnVuY3Rpb24pIHtcbiAgICAgIHRoaXMuc2V0VGlsZVVybEZ1bmN0aW9uKG9wdGlvbnMudGlsZVVybEZ1bmN0aW9uLCB0aGlzLmtleV8pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBib29sZWFuPn1cbiAgICAgKi9cbiAgICB0aGlzLnRpbGVMb2FkaW5nS2V5c18gPSB7fTtcblxuICB9XG5cbiAgaWYgKCBUaWxlU291cmNlICkgVXJsVGlsZS5fX3Byb3RvX18gPSBUaWxlU291cmNlO1xuICBVcmxUaWxlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRpbGVTb3VyY2UgJiYgVGlsZVNvdXJjZS5wcm90b3R5cGUgKTtcbiAgVXJsVGlsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBVcmxUaWxlO1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHRpbGUgbG9hZCBmdW5jdGlvbiBvZiB0aGUgc291cmNlLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLkxvYWRGdW5jdGlvbn0gVGlsZUxvYWRGdW5jdGlvblxuICAgKiBAYXBpXG4gICAqL1xuICBVcmxUaWxlLnByb3RvdHlwZS5nZXRUaWxlTG9hZEZ1bmN0aW9uID0gZnVuY3Rpb24gZ2V0VGlsZUxvYWRGdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudGlsZUxvYWRGdW5jdGlvbjtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB0aWxlIFVSTCBmdW5jdGlvbiBvZiB0aGUgc291cmNlLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLlVybEZ1bmN0aW9ufSBUaWxlVXJsRnVuY3Rpb25cbiAgICogQGFwaVxuICAgKi9cbiAgVXJsVGlsZS5wcm90b3R5cGUuZ2V0VGlsZVVybEZ1bmN0aW9uID0gZnVuY3Rpb24gZ2V0VGlsZVVybEZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy50aWxlVXJsRnVuY3Rpb247XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgVVJMcyB1c2VkIGZvciB0aGlzIHNvdXJjZS5cbiAgICogV2hlbiBhIHRpbGVVcmxGdW5jdGlvbiBpcyB1c2VkIGluc3RlYWQgb2YgdXJsIG9yIHVybHMsXG4gICAqIG51bGwgd2lsbCBiZSByZXR1cm5lZC5cbiAgICogQHJldHVybiB7IUFycmF5PHN0cmluZz58bnVsbH0gVVJMcy5cbiAgICogQGFwaVxuICAgKi9cbiAgVXJsVGlsZS5wcm90b3R5cGUuZ2V0VXJscyA9IGZ1bmN0aW9uIGdldFVybHMgKCkge1xuICAgIHJldHVybiB0aGlzLnVybHM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSB0aWxlIGNoYW5nZSBldmVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHR9IGV2ZW50IEV2ZW50LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBVcmxUaWxlLnByb3RvdHlwZS5oYW5kbGVUaWxlQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlVGlsZUNoYW5nZSAoZXZlbnQpIHtcbiAgICB2YXIgdGlsZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5kZWZhdWx0fSAqLyAoZXZlbnQudGFyZ2V0KTtcbiAgICB2YXIgdWlkID0gZ2V0VWlkKHRpbGUpO1xuICAgIHZhciB0aWxlU3RhdGUgPSB0aWxlLmdldFN0YXRlKCk7XG4gICAgdmFyIHR5cGU7XG4gICAgaWYgKHRpbGVTdGF0ZSA9PSBUaWxlU3RhdGUuTE9BRElORykge1xuICAgICAgdGhpcy50aWxlTG9hZGluZ0tleXNfW3VpZF0gPSB0cnVlO1xuICAgICAgdHlwZSA9IFRpbGVFdmVudFR5cGUuVElMRUxPQURTVEFSVDtcbiAgICB9IGVsc2UgaWYgKHVpZCBpbiB0aGlzLnRpbGVMb2FkaW5nS2V5c18pIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnRpbGVMb2FkaW5nS2V5c19bdWlkXTtcbiAgICAgIHR5cGUgPSB0aWxlU3RhdGUgPT0gVGlsZVN0YXRlLkVSUk9SID8gVGlsZUV2ZW50VHlwZS5USUxFTE9BREVSUk9SIDpcbiAgICAgICAgKHRpbGVTdGF0ZSA9PSBUaWxlU3RhdGUuTE9BREVEIHx8IHRpbGVTdGF0ZSA9PSBUaWxlU3RhdGUuQUJPUlQpID9cbiAgICAgICAgICBUaWxlRXZlbnRUeXBlLlRJTEVMT0FERU5EIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodHlwZSAhPSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgVGlsZVNvdXJjZUV2ZW50KHR5cGUsIHRpbGUpKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdGlsZSBsb2FkIGZ1bmN0aW9uIG9mIHRoZSBzb3VyY2UuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5Mb2FkRnVuY3Rpb259IHRpbGVMb2FkRnVuY3Rpb24gVGlsZSBsb2FkIGZ1bmN0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBVcmxUaWxlLnByb3RvdHlwZS5zZXRUaWxlTG9hZEZ1bmN0aW9uID0gZnVuY3Rpb24gc2V0VGlsZUxvYWRGdW5jdGlvbiAodGlsZUxvYWRGdW5jdGlvbikge1xuICAgIHRoaXMudGlsZUNhY2hlLmNsZWFyKCk7XG4gICAgdGhpcy50aWxlTG9hZEZ1bmN0aW9uID0gdGlsZUxvYWRGdW5jdGlvbjtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSB0aWxlIFVSTCBmdW5jdGlvbiBvZiB0aGUgc291cmNlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1RpbGUuanNcIikuVXJsRnVuY3Rpb259IHRpbGVVcmxGdW5jdGlvbiBUaWxlIFVSTCBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBrZXkgT3B0aW9uYWwgbmV3IHRpbGUga2V5IGZvciB0aGUgc291cmNlLlxuICAgKiBAYXBpXG4gICAqL1xuICBVcmxUaWxlLnByb3RvdHlwZS5zZXRUaWxlVXJsRnVuY3Rpb24gPSBmdW5jdGlvbiBzZXRUaWxlVXJsRnVuY3Rpb24gKHRpbGVVcmxGdW5jdGlvbiwga2V5KSB7XG4gICAgdGhpcy50aWxlVXJsRnVuY3Rpb24gPSB0aWxlVXJsRnVuY3Rpb247XG4gICAgdGhpcy50aWxlQ2FjaGUucHJ1bmVFeGNlcHROZXdlc3RaKCk7XG4gICAgaWYgKHR5cGVvZiBrZXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLnNldEtleShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgVVJMIHRvIHVzZSBmb3IgcmVxdWVzdHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVVJMLlxuICAgKiBAYXBpXG4gICAqL1xuICBVcmxUaWxlLnByb3RvdHlwZS5zZXRVcmwgPSBmdW5jdGlvbiBzZXRVcmwgKHVybCkge1xuICAgIHZhciB1cmxzID0gdGhpcy51cmxzID0gZXhwYW5kVXJsKHVybCk7XG4gICAgdGhpcy5zZXRVcmxzKHVybHMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIFVSTHMgdG8gdXNlIGZvciByZXF1ZXN0cy5cbiAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSB1cmxzIFVSTHMuXG4gICAqIEBhcGlcbiAgICovXG4gIFVybFRpbGUucHJvdG90eXBlLnNldFVybHMgPSBmdW5jdGlvbiBzZXRVcmxzICh1cmxzKSB7XG4gICAgdGhpcy51cmxzID0gdXJscztcbiAgICB2YXIga2V5ID0gdXJscy5qb2luKCdcXG4nKTtcbiAgICBpZiAodGhpcy5nZW5lcmF0ZVRpbGVVcmxGdW5jdGlvbl8pIHtcbiAgICAgIHRoaXMuc2V0VGlsZVVybEZ1bmN0aW9uKGNyZWF0ZUZyb21UZW1wbGF0ZXModXJscywgdGhpcy50aWxlR3JpZCksIGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0S2V5KGtleSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgVXJsVGlsZS5wcm90b3R5cGUudXNlVGlsZSA9IGZ1bmN0aW9uIHVzZVRpbGUgKHosIHgsIHkpIHtcbiAgICB2YXIgdGlsZUNvb3JkS2V5ID0gZ2V0S2V5WlhZKHosIHgsIHkpO1xuICAgIGlmICh0aGlzLnRpbGVDYWNoZS5jb250YWluc0tleSh0aWxlQ29vcmRLZXkpKSB7XG4gICAgICB0aGlzLnRpbGVDYWNoZS5nZXQodGlsZUNvb3JkS2V5KTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFVybFRpbGU7XG59KFRpbGVTb3VyY2UpKTtcblxuXG5leHBvcnQgZGVmYXVsdCBVcmxUaWxlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1VcmxUaWxlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9zb3VyY2UvVmVjdG9yXG4gKi9cblxuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4uL3V0aWwuanMnO1xuaW1wb3J0IENvbGxlY3Rpb24gZnJvbSAnLi4vQ29sbGVjdGlvbi5qcyc7XG5pbXBvcnQgQ29sbGVjdGlvbkV2ZW50VHlwZSBmcm9tICcuLi9Db2xsZWN0aW9uRXZlbnRUeXBlLmpzJztcbmltcG9ydCBPYmplY3RFdmVudFR5cGUgZnJvbSAnLi4vT2JqZWN0RXZlbnRUeXBlLmpzJztcbmltcG9ydCB7ZXh0ZW5kfSBmcm9tICcuLi9hcnJheS5qcyc7XG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi4vYXNzZXJ0cy5qcyc7XG5pbXBvcnQge2xpc3RlbiwgdW5saXN0ZW5CeUtleX0gZnJvbSAnLi4vZXZlbnRzLmpzJztcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMvRXZlbnQuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7Y29udGFpbnNFeHRlbnQsIGVxdWFsc30gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7eGhyfSBmcm9tICcuLi9mZWF0dXJlbG9hZGVyLmpzJztcbmltcG9ydCB7VFJVRSwgVk9JRH0gZnJvbSAnLi4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCB7YWxsIGFzIGFsbFN0cmF0ZWd5fSBmcm9tICcuLi9sb2FkaW5nc3RyYXRlZ3kuanMnO1xuaW1wb3J0IHtpc0VtcHR5LCBnZXRWYWx1ZXN9IGZyb20gJy4uL29iai5qcyc7XG5pbXBvcnQgU291cmNlIGZyb20gJy4vU291cmNlLmpzJztcbmltcG9ydCBTb3VyY2VTdGF0ZSBmcm9tICcuL1N0YXRlLmpzJztcbmltcG9ydCBWZWN0b3JFdmVudFR5cGUgZnJvbSAnLi9WZWN0b3JFdmVudFR5cGUuanMnO1xuaW1wb3J0IFJCdXNoIGZyb20gJy4uL3N0cnVjdHMvUkJ1c2guanMnO1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGFuZCBhIHJlc29sdXRpb24gYXMgYXJndW1lbnRzLCBhbmRcbiAqIHJldHVybnMgYW4gYXJyYXkgb2Yge0BsaW5rIG1vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSB3aXRoIHRoZSBleHRlbnRzIHRvIGxvYWQuIFVzdWFsbHkgdGhpc1xuICogaXMgb25lIG9mIHRoZSBzdGFuZGFyZCB7QGxpbmsgbW9kdWxlOm9sL2xvYWRpbmdzdHJhdGVneX0gc3RyYXRlZ2llcy5cbiAqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudCwgbnVtYmVyKTogQXJyYXk8aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudD59IExvYWRpbmdTdHJhdGVneVxuICogQGFwaVxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBFdmVudHMgZW1pdHRlZCBieSB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3J9IGluc3RhbmNlcyBhcmUgaW5zdGFuY2VzIG9mIHRoaXNcbiAqIHR5cGUuXG4gKi9cbmV4cG9ydCB2YXIgVmVjdG9yU291cmNlRXZlbnQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChFdmVudCkge1xuICBmdW5jdGlvbiBWZWN0b3JTb3VyY2VFdmVudCh0eXBlLCBvcHRfZmVhdHVyZSkge1xuXG4gICAgRXZlbnQuY2FsbCh0aGlzLCB0eXBlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmZWF0dXJlIGJlaW5nIGFkZGVkIG9yIHJlbW92ZWQuXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdHx1bmRlZmluZWR9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMuZmVhdHVyZSA9IG9wdF9mZWF0dXJlO1xuXG4gIH1cblxuICBpZiAoIEV2ZW50ICkgVmVjdG9yU291cmNlRXZlbnQuX19wcm90b19fID0gRXZlbnQ7XG4gIFZlY3RvclNvdXJjZUV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEV2ZW50ICYmIEV2ZW50LnByb3RvdHlwZSApO1xuICBWZWN0b3JTb3VyY2VFdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBWZWN0b3JTb3VyY2VFdmVudDtcblxuICByZXR1cm4gVmVjdG9yU291cmNlRXZlbnQ7XG59KEV2ZW50KSk7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vU291cmNlLmpzXCIpLkF0dHJpYnV0aW9uTGlrZX0gW2F0dHJpYnV0aW9uc10gQXR0cmlidXRpb25zLlxuICogQHByb3BlcnR5IHtBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fENvbGxlY3Rpb248aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn0gW2ZlYXR1cmVzXVxuICogRmVhdHVyZXMuIElmIHByb3ZpZGVkIGFzIHtAbGluayBtb2R1bGU6b2wvQ29sbGVjdGlvbn0sIHRoZSBmZWF0dXJlcyBpbiB0aGUgc291cmNlXG4gKiBhbmQgdGhlIGNvbGxlY3Rpb24gd2lsbCBzdGF5IGluIHN5bmMuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2Zvcm1hdC9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IFtmb3JtYXRdIFRoZSBmZWF0dXJlIGZvcm1hdCB1c2VkIGJ5IHRoZSBYSFJcbiAqIGZlYXR1cmUgbG9hZGVyIHdoZW4gYHVybGAgaXMgc2V0LiBSZXF1aXJlZCBpZiBgdXJsYCBpcyBzZXQsIG90aGVyd2lzZSBpZ25vcmVkLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9mZWF0dXJlbG9hZGVyLmpzXCIpLkZlYXR1cmVMb2FkZXJ9IFtsb2FkZXJdXG4gKiBUaGUgbG9hZGVyIGZ1bmN0aW9uIHVzZWQgdG8gbG9hZCBmZWF0dXJlcywgZnJvbSBhIHJlbW90ZSBzb3VyY2UgZm9yIGV4YW1wbGUuXG4gKiBJZiB0aGlzIGlzIG5vdCBzZXQgYW5kIGB1cmxgIGlzIHNldCwgdGhlIHNvdXJjZSB3aWxsIGNyZWF0ZSBhbmQgdXNlIGFuIFhIUlxuICogZmVhdHVyZSBsb2FkZXIuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0IHtWZWN0b3J9IGZyb20gJ29sL3NvdXJjZSc7XG4gKiBpbXBvcnQge0dlb0pTT059IGZyb20gJ29sL2Zvcm1hdCc7XG4gKiBpbXBvcnQge2Jib3h9IGZyb20gJ29sL2xvYWRpbmdzdHJhdGVneSc7XG4gKlxuICogdmFyIHZlY3RvclNvdXJjZSA9IG5ldyBWZWN0b3Ioe1xuICogICBmb3JtYXQ6IG5ldyBHZW9KU09OKCksXG4gKiAgIGxvYWRlcjogZnVuY3Rpb24oZXh0ZW50LCByZXNvbHV0aW9uLCBwcm9qZWN0aW9uKSB7XG4gKiAgICAgIHZhciBwcm9qID0gcHJvamVjdGlvbi5nZXRDb2RlKCk7XG4gKiAgICAgIHZhciB1cmwgPSAnaHR0cHM6Ly9haG9jZXZhci5jb20vZ2Vvc2VydmVyL3dmcz9zZXJ2aWNlPVdGUyYnICtcbiAqICAgICAgICAgICd2ZXJzaW9uPTEuMS4wJnJlcXVlc3Q9R2V0RmVhdHVyZSZ0eXBlbmFtZT1vc206d2F0ZXJfYXJlYXMmJyArXG4gKiAgICAgICAgICAnb3V0cHV0Rm9ybWF0PWFwcGxpY2F0aW9uL2pzb24mc3JzbmFtZT0nICsgcHJvaiArICcmJyArXG4gKiAgICAgICAgICAnYmJveD0nICsgZXh0ZW50LmpvaW4oJywnKSArICcsJyArIHByb2o7XG4gKiAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAqICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCk7XG4gKiAgICAgIHZhciBvbkVycm9yID0gZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgdmVjdG9yU291cmNlLnJlbW92ZUxvYWRlZEV4dGVudChleHRlbnQpO1xuICogICAgICB9XG4gKiAgICAgIHhoci5vbmVycm9yID0gb25FcnJvcjtcbiAqICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICogICAgICAgIGlmICh4aHIuc3RhdHVzID09IDIwMCkge1xuICogICAgICAgICAgdmVjdG9yU291cmNlLmFkZEZlYXR1cmVzKFxuICogICAgICAgICAgICAgIHZlY3RvclNvdXJjZS5nZXRGb3JtYXQoKS5yZWFkRmVhdHVyZXMoeGhyLnJlc3BvbnNlVGV4dCkpO1xuICogICAgICAgIH0gZWxzZSB7XG4gKiAgICAgICAgICBvbkVycm9yKCk7XG4gKiAgICAgICAgfVxuICogICAgICB9XG4gKiAgICAgIHhoci5zZW5kKCk7XG4gKiAgICB9LFxuICogICAgc3RyYXRlZ3k6IGJib3hcbiAqICB9KTtcbiAqIGBgYFxuICogQHByb3BlcnR5IHtib29sZWFufSBbb3ZlcmxhcHM9dHJ1ZV0gVGhpcyBzb3VyY2UgbWF5IGhhdmUgb3ZlcmxhcHBpbmcgZ2VvbWV0cmllcy5cbiAqIFNldHRpbmcgdGhpcyB0byBgZmFsc2VgIChlLmcuIGZvciBzb3VyY2VzIHdpdGggcG9seWdvbnMgdGhhdCByZXByZXNlbnQgYWRtaW5pc3RyYXRpdmVcbiAqIGJvdW5kYXJpZXMgb3IgVG9wb0pTT04gc291cmNlcykgYWxsb3dzIHRoZSByZW5kZXJlciB0byBvcHRpbWlzZSBmaWxsIGFuZFxuICogc3Ryb2tlIG9wZXJhdGlvbnMuXG4gKiBAcHJvcGVydHkge0xvYWRpbmdTdHJhdGVneX0gW3N0cmF0ZWd5XSBUaGUgbG9hZGluZyBzdHJhdGVneSB0byB1c2UuXG4gKiBCeSBkZWZhdWx0IGFuIHtAbGluayBtb2R1bGU6b2wvbG9hZGluZ3N0cmF0ZWd5fmFsbH1cbiAqIHN0cmF0ZWd5IGlzIHVzZWQsIGEgb25lLW9mZiBzdHJhdGVneSB3aGljaCBsb2FkcyBhbGwgZmVhdHVyZXMgYXQgb25jZS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfGltcG9ydChcIi4uL2ZlYXR1cmVsb2FkZXIuanNcIikuRmVhdHVyZVVybEZ1bmN0aW9ufSBbdXJsXVxuICogU2V0dGluZyB0aGlzIG9wdGlvbiBpbnN0cnVjdHMgdGhlIHNvdXJjZSB0byBsb2FkIGZlYXR1cmVzIHVzaW5nIGFuIFhIUiBsb2FkZXJcbiAqIChzZWUge0BsaW5rIG1vZHVsZTpvbC9mZWF0dXJlbG9hZGVyfnhocn0pLiBVc2UgYSBgc3RyaW5nYCBhbmQgYW5cbiAqIHtAbGluayBtb2R1bGU6b2wvbG9hZGluZ3N0cmF0ZWd5fmFsbH0gZm9yIGEgb25lLW9mZiBkb3dubG9hZCBvZiBhbGwgZmVhdHVyZXMgZnJvbVxuICogdGhlIGdpdmVuIFVSTC4gVXNlIGEge0BsaW5rIG1vZHVsZTpvbC9mZWF0dXJlbG9hZGVyfkZlYXR1cmVVcmxGdW5jdGlvbn0gdG8gZ2VuZXJhdGUgdGhlIHVybCB3aXRoXG4gKiBvdGhlciBsb2FkaW5nIHN0cmF0ZWdpZXMuXG4gKiBSZXF1aXJlcyBgZm9ybWF0YCB0byBiZSBzZXQgYXMgd2VsbC5cbiAqIFdoZW4gZGVmYXVsdCBYSFIgZmVhdHVyZSBsb2FkZXIgaXMgcHJvdmlkZWQsIHRoZSBmZWF0dXJlcyB3aWxsXG4gKiBiZSB0cmFuc2Zvcm1lZCBmcm9tIHRoZSBkYXRhIHByb2plY3Rpb24gdG8gdGhlIHZpZXcgcHJvamVjdGlvblxuICogZHVyaW5nIHBhcnNpbmcuIElmIHlvdXIgcmVtb3RlIGRhdGEgc291cmNlIGRvZXMgbm90IGFkdmVydGlzZSBpdHMgcHJvamVjdGlvblxuICogcHJvcGVybHksIHRoaXMgdHJhbnNmb3JtYXRpb24gd2lsbCBiZSBpbmNvcnJlY3QuIEZvciBzb21lIGZvcm1hdHMsIHRoZVxuICogZGVmYXVsdCBwcm9qZWN0aW9uICh1c3VhbGx5IEVQU0c6NDMyNikgY2FuIGJlIG92ZXJyaWRkZW4gYnkgc2V0dGluZyB0aGVcbiAqIGRhdGFQcm9qZWN0aW9uIGNvbnN0cnVjdG9yIG9wdGlvbiBvbiB0aGUgZm9ybWF0LlxuICogTm90ZSB0aGF0IGlmIGEgc291cmNlIGNvbnRhaW5zIG5vbi1mZWF0dXJlIGRhdGEsIHN1Y2ggYXMgYSBHZW9KU09OIGdlb21ldHJ5XG4gKiBvciBhIEtNTCBOZXR3b3JrTGluaywgdGhlc2Ugd2lsbCBiZSBpZ25vcmVkLiBVc2UgYSBjdXN0b20gbG9hZGVyIHRvIGxvYWQgdGhlc2UuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt1c2VTcGF0aWFsSW5kZXg9dHJ1ZV1cbiAqIEJ5IGRlZmF1bHQsIGFuIFJUcmVlIGlzIHVzZWQgYXMgc3BhdGlhbCBpbmRleC4gV2hlbiBmZWF0dXJlcyBhcmUgcmVtb3ZlZCBhbmRcbiAqIGFkZGVkIGZyZXF1ZW50bHksIGFuZCB0aGUgdG90YWwgbnVtYmVyIG9mIGZlYXR1cmVzIGlzIGxvdywgc2V0dGluZyB0aGlzIHRvXG4gKiBgZmFsc2VgIG1heSBpbXByb3ZlIHBlcmZvcm1hbmNlLlxuICpcbiAqIE5vdGUgdGhhdFxuICoge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yflZlY3RvclNvdXJjZSNnZXRGZWF0dXJlc0luRXh0ZW50fSxcbiAqIHtAbGluayBtb2R1bGU6b2wvc291cmNlL1ZlY3Rvcn5WZWN0b3JTb3VyY2UjZ2V0Q2xvc2VzdEZlYXR1cmVUb0Nvb3JkaW5hdGV9IGFuZFxuICoge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yflZlY3RvclNvdXJjZSNnZXRFeHRlbnR9IGNhbm5vdCBiZSB1c2VkIHdoZW4gYHVzZVNwYXRpYWxJbmRleGAgaXNcbiAqIHNldCB0byBgZmFsc2VgLCBhbmQge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yflZlY3RvclNvdXJjZSNmb3JFYWNoRmVhdHVyZUluRXh0ZW50fSB3aWxsIGxvb3BcbiAqIHRocm91Z2ggYWxsIGZlYXR1cmVzLlxuICpcbiAqIFdoZW4gc2V0IHRvIGBmYWxzZWAsIHRoZSBmZWF0dXJlcyB3aWxsIGJlIG1haW50YWluZWQgaW4gYW5cbiAqIHtAbGluayBtb2R1bGU6b2wvQ29sbGVjdGlvbn0sIHdoaWNoIGNhbiBiZSByZXRyaWV2ZWQgdGhyb3VnaFxuICoge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yflZlY3RvclNvdXJjZSNnZXRGZWF0dXJlc0NvbGxlY3Rpb259LlxuICogQHByb3BlcnR5IHtib29sZWFufSBbd3JhcFg9dHJ1ZV0gV3JhcCB0aGUgd29ybGQgaG9yaXpvbnRhbGx5LiBGb3IgdmVjdG9yIGVkaXRpbmcgYWNyb3NzIHRoZVxuICogLTE4MMKwIGFuZCAxODDCsCBtZXJpZGlhbnMgdG8gd29yayBwcm9wZXJseSwgdGhpcyBzaG91bGQgYmUgc2V0IHRvIGBmYWxzZWAuIFRoZVxuICogcmVzdWx0aW5nIGdlb21ldHJ5IGNvb3JkaW5hdGVzIHdpbGwgdGhlbiBleGNlZWQgdGhlIHdvcmxkIGJvdW5kcy5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogUHJvdmlkZXMgYSBzb3VyY2Ugb2YgZmVhdHVyZXMgZm9yIHZlY3RvciBsYXllcnMuIFZlY3RvciBmZWF0dXJlcyBwcm92aWRlZFxuICogYnkgdGhpcyBzb3VyY2UgYXJlIHN1aXRhYmxlIGZvciBlZGl0aW5nLiBTZWUge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yVGlsZX5WZWN0b3JUaWxlfSBmb3JcbiAqIHZlY3RvciBkYXRhIHRoYXQgaXMgb3B0aW1pemVkIGZvciByZW5kZXJpbmcuXG4gKlxuICogQGZpcmVzIG9sL3NvdXJjZS9WZWN0b3IuVmVjdG9yU291cmNlRXZlbnRcbiAqIEBhcGlcbiAqL1xudmFyIFZlY3RvclNvdXJjZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFNvdXJjZSkge1xuICBmdW5jdGlvbiBWZWN0b3JTb3VyY2Uob3B0X29wdGlvbnMpIHtcblxuICAgIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgfHwge307XG5cbiAgICBTb3VyY2UuY2FsbCh0aGlzLCB7XG4gICAgICBhdHRyaWJ1dGlvbnM6IG9wdGlvbnMuYXR0cmlidXRpb25zLFxuICAgICAgcHJvamVjdGlvbjogdW5kZWZpbmVkLFxuICAgICAgc3RhdGU6IFNvdXJjZVN0YXRlLlJFQURZLFxuICAgICAgd3JhcFg6IG9wdGlvbnMud3JhcFggIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMud3JhcFggOiB0cnVlXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9mZWF0dXJlbG9hZGVyLmpzXCIpLkZlYXR1cmVMb2FkZXJ9XG4gICAgICovXG4gICAgdGhpcy5sb2FkZXJfID0gVk9JRDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2Zvcm1hdC9GZWF0dXJlLmpzXCIpLmRlZmF1bHR8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuZm9ybWF0XyA9IG9wdGlvbnMuZm9ybWF0O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLm92ZXJsYXBzXyA9IG9wdGlvbnMub3ZlcmxhcHMgPT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdGlvbnMub3ZlcmxhcHM7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd8aW1wb3J0KFwiLi4vZmVhdHVyZWxvYWRlci5qc1wiKS5GZWF0dXJlVXJsRnVuY3Rpb258dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMudXJsXyA9IG9wdGlvbnMudXJsO1xuXG4gICAgaWYgKG9wdGlvbnMubG9hZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMubG9hZGVyXyA9IG9wdGlvbnMubG9hZGVyO1xuICAgIH0gZWxzZSBpZiAodGhpcy51cmxfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGFzc2VydCh0aGlzLmZvcm1hdF8sIDcpOyAvLyBgZm9ybWF0YCBtdXN0IGJlIHNldCB3aGVuIGB1cmxgIGlzIHNldFxuICAgICAgLy8gY3JlYXRlIGEgWEhSIGZlYXR1cmUgbG9hZGVyIGZvciBcInVybFwiIGFuZCBcImZvcm1hdFwiXG4gICAgICB0aGlzLmxvYWRlcl8gPSB4aHIodGhpcy51cmxfLCAvKiogQHR5cGUge2ltcG9ydChcIi4uL2Zvcm1hdC9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9ICovICh0aGlzLmZvcm1hdF8pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtMb2FkaW5nU3RyYXRlZ3l9XG4gICAgICovXG4gICAgdGhpcy5zdHJhdGVneV8gPSBvcHRpb25zLnN0cmF0ZWd5ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0cmF0ZWd5IDogYWxsU3RyYXRlZ3k7XG5cbiAgICB2YXIgdXNlU3BhdGlhbEluZGV4ID1cbiAgICAgICAgb3B0aW9ucy51c2VTcGF0aWFsSW5kZXggIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudXNlU3BhdGlhbEluZGV4IDogdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge1JCdXNoPGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59XG4gICAgICovXG4gICAgdGhpcy5mZWF0dXJlc1J0cmVlXyA9IHVzZVNwYXRpYWxJbmRleCA/IG5ldyBSQnVzaCgpIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge1JCdXNoPHtleHRlbnQ6IGltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9Pn1cbiAgICAgKi9cbiAgICB0aGlzLmxvYWRlZEV4dGVudHNSdHJlZV8gPSBuZXcgUkJ1c2goKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fVxuICAgICAqL1xuICAgIHRoaXMubnVsbEdlb21ldHJ5RmVhdHVyZXNfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBBIGxvb2t1cCBvZiBmZWF0dXJlcyBieSBpZCAodGhlIHJldHVybiBmcm9tIGZlYXR1cmUuZ2V0SWQoKSkuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59XG4gICAgICovXG4gICAgdGhpcy5pZEluZGV4XyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQSBsb29rdXAgb2YgZmVhdHVyZXMgd2l0aG91dCBpZCAoa2V5ZWQgYnkgZ2V0VWlkKGZlYXR1cmUpKS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn1cbiAgICAgKi9cbiAgICB0aGlzLnVuZGVmSWRJbmRleF8gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsIEFycmF5PGltcG9ydChcIi4uL2V2ZW50cy5qc1wiKS5FdmVudHNLZXk+Pn1cbiAgICAgKi9cbiAgICB0aGlzLmZlYXR1cmVDaGFuZ2VLZXlzXyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fVxuICAgICAqL1xuICAgIHRoaXMuZmVhdHVyZXNDb2xsZWN0aW9uXyA9IG51bGw7XG5cbiAgICB2YXIgY29sbGVjdGlvbiwgZmVhdHVyZXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5mZWF0dXJlcykpIHtcbiAgICAgIGZlYXR1cmVzID0gb3B0aW9ucy5mZWF0dXJlcztcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZmVhdHVyZXMpIHtcbiAgICAgIGNvbGxlY3Rpb24gPSBvcHRpb25zLmZlYXR1cmVzO1xuICAgICAgZmVhdHVyZXMgPSBjb2xsZWN0aW9uLmdldEFycmF5KCk7XG4gICAgfVxuICAgIGlmICghdXNlU3BhdGlhbEluZGV4ICYmIGNvbGxlY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKGZlYXR1cmVzKTtcbiAgICB9XG4gICAgaWYgKGZlYXR1cmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuYWRkRmVhdHVyZXNJbnRlcm5hbChmZWF0dXJlcyk7XG4gICAgfVxuICAgIGlmIChjb2xsZWN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuYmluZEZlYXR1cmVzQ29sbGVjdGlvbl8oY29sbGVjdGlvbik7XG4gICAgfVxuXG4gIH1cblxuICBpZiAoIFNvdXJjZSApIFZlY3RvclNvdXJjZS5fX3Byb3RvX18gPSBTb3VyY2U7XG4gIFZlY3RvclNvdXJjZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBTb3VyY2UgJiYgU291cmNlLnByb3RvdHlwZSApO1xuICBWZWN0b3JTb3VyY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVmVjdG9yU291cmNlO1xuXG4gIC8qKlxuICAgKiBBZGQgYSBzaW5nbGUgZmVhdHVyZSB0byB0aGUgc291cmNlLiAgSWYgeW91IHdhbnQgdG8gYWRkIGEgYmF0Y2ggb2YgZmVhdHVyZXNcbiAgICogYXQgb25jZSwgY2FsbCB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3J+VmVjdG9yU291cmNlI2FkZEZlYXR1cmVzICNhZGRGZWF0dXJlcygpfVxuICAgKiBpbnN0ZWFkLiBBIGZlYXR1cmUgd2lsbCBub3QgYmUgYWRkZWQgdG8gdGhlIHNvdXJjZSBpZiBmZWF0dXJlIHdpdGhcbiAgICogdGhlIHNhbWUgaWQgaXMgYWxyZWFkeSB0aGVyZS4gVGhlIHJlYXNvbiBmb3IgdGhpcyBiZWhhdmlvciBpcyB0byBhdm9pZFxuICAgKiBmZWF0dXJlIGR1cGxpY2F0aW9uIHdoZW4gdXNpbmcgYmJveCBvciB0aWxlIGxvYWRpbmcgc3RyYXRlZ2llcy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZSB0byBhZGQuXG4gICAqIEBhcGlcbiAgICovXG4gIFZlY3RvclNvdXJjZS5wcm90b3R5cGUuYWRkRmVhdHVyZSA9IGZ1bmN0aW9uIGFkZEZlYXR1cmUgKGZlYXR1cmUpIHtcbiAgICB0aGlzLmFkZEZlYXR1cmVJbnRlcm5hbChmZWF0dXJlKTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBBZGQgYSBmZWF0dXJlIHdpdGhvdXQgZmlyaW5nIGEgYGNoYW5nZWAgZXZlbnQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmUuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIFZlY3RvclNvdXJjZS5wcm90b3R5cGUuYWRkRmVhdHVyZUludGVybmFsID0gZnVuY3Rpb24gYWRkRmVhdHVyZUludGVybmFsIChmZWF0dXJlKSB7XG4gICAgdmFyIGZlYXR1cmVLZXkgPSBnZXRVaWQoZmVhdHVyZSk7XG5cbiAgICBpZiAoIXRoaXMuYWRkVG9JbmRleF8oZmVhdHVyZUtleSwgZmVhdHVyZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnNldHVwQ2hhbmdlRXZlbnRzXyhmZWF0dXJlS2V5LCBmZWF0dXJlKTtcblxuICAgIHZhciBnZW9tZXRyeSA9IGZlYXR1cmUuZ2V0R2VvbWV0cnkoKTtcbiAgICBpZiAoZ2VvbWV0cnkpIHtcbiAgICAgIHZhciBleHRlbnQgPSBnZW9tZXRyeS5nZXRFeHRlbnQoKTtcbiAgICAgIGlmICh0aGlzLmZlYXR1cmVzUnRyZWVfKSB7XG4gICAgICAgIHRoaXMuZmVhdHVyZXNSdHJlZV8uaW5zZXJ0KGV4dGVudCwgZmVhdHVyZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubnVsbEdlb21ldHJ5RmVhdHVyZXNfW2ZlYXR1cmVLZXldID0gZmVhdHVyZTtcbiAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICBuZXcgVmVjdG9yU291cmNlRXZlbnQoVmVjdG9yRXZlbnRUeXBlLkFEREZFQVRVUkUsIGZlYXR1cmUpKTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZUtleSBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGZlYXR1cmUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIFRoZSBmZWF0dXJlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgVmVjdG9yU291cmNlLnByb3RvdHlwZS5zZXR1cENoYW5nZUV2ZW50c18gPSBmdW5jdGlvbiBzZXR1cENoYW5nZUV2ZW50c18gKGZlYXR1cmVLZXksIGZlYXR1cmUpIHtcbiAgICB0aGlzLmZlYXR1cmVDaGFuZ2VLZXlzX1tmZWF0dXJlS2V5XSA9IFtcbiAgICAgIGxpc3RlbihmZWF0dXJlLCBFdmVudFR5cGUuQ0hBTkdFLFxuICAgICAgICB0aGlzLmhhbmRsZUZlYXR1cmVDaGFuZ2VfLCB0aGlzKSxcbiAgICAgIGxpc3RlbihmZWF0dXJlLCBPYmplY3RFdmVudFR5cGUuUFJPUEVSVFlDSEFOR0UsXG4gICAgICAgIHRoaXMuaGFuZGxlRmVhdHVyZUNoYW5nZV8sIHRoaXMpXG4gICAgXTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZUtleSBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGZlYXR1cmUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIFRoZSBmZWF0dXJlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgZmVhdHVyZSBpcyBcInZhbGlkXCIsIGluIHRoZSBzZW5zZSB0aGF0IGl0IGlzIGFsc28gYVxuICAgKiAgICAgY2FuZGlkYXRlIGZvciBpbnNlcnRpb24gaW50byB0aGUgUnRyZWUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBWZWN0b3JTb3VyY2UucHJvdG90eXBlLmFkZFRvSW5kZXhfID0gZnVuY3Rpb24gYWRkVG9JbmRleF8gKGZlYXR1cmVLZXksIGZlYXR1cmUpIHtcbiAgICB2YXIgdmFsaWQgPSB0cnVlO1xuICAgIHZhciBpZCA9IGZlYXR1cmUuZ2V0SWQoKTtcbiAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCEoaWQudG9TdHJpbmcoKSBpbiB0aGlzLmlkSW5kZXhfKSkge1xuICAgICAgICB0aGlzLmlkSW5kZXhfW2lkLnRvU3RyaW5nKCldID0gZmVhdHVyZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydCghKGZlYXR1cmVLZXkgaW4gdGhpcy51bmRlZklkSW5kZXhfKSxcbiAgICAgICAgMzApOyAvLyBUaGUgcGFzc2VkIGBmZWF0dXJlYCB3YXMgYWxyZWFkeSBhZGRlZCB0byB0aGUgc291cmNlXG4gICAgICB0aGlzLnVuZGVmSWRJbmRleF9bZmVhdHVyZUtleV0gPSBmZWF0dXJlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsaWQ7XG4gIH07XG5cblxuICAvKipcbiAgICogQWRkIGEgYmF0Y2ggb2YgZmVhdHVyZXMgdG8gdGhlIHNvdXJjZS5cbiAgICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fSBmZWF0dXJlcyBGZWF0dXJlcyB0byBhZGQuXG4gICAqIEBhcGlcbiAgICovXG4gIFZlY3RvclNvdXJjZS5wcm90b3R5cGUuYWRkRmVhdHVyZXMgPSBmdW5jdGlvbiBhZGRGZWF0dXJlcyAoZmVhdHVyZXMpIHtcbiAgICB0aGlzLmFkZEZlYXR1cmVzSW50ZXJuYWwoZmVhdHVyZXMpO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEFkZCBmZWF0dXJlcyB3aXRob3V0IGZpcmluZyBhIGBjaGFuZ2VgIGV2ZW50LlxuICAgKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59IGZlYXR1cmVzIEZlYXR1cmVzLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBWZWN0b3JTb3VyY2UucHJvdG90eXBlLmFkZEZlYXR1cmVzSW50ZXJuYWwgPSBmdW5jdGlvbiBhZGRGZWF0dXJlc0ludGVybmFsIChmZWF0dXJlcykge1xuICAgIHZhciBleHRlbnRzID0gW107XG4gICAgdmFyIG5ld0ZlYXR1cmVzID0gW107XG4gICAgdmFyIGdlb21ldHJ5RmVhdHVyZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBmZWF0dXJlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGZlYXR1cmUgPSBmZWF0dXJlc1tpXTtcbiAgICAgIHZhciBmZWF0dXJlS2V5ID0gZ2V0VWlkKGZlYXR1cmUpO1xuICAgICAgaWYgKHRoaXMuYWRkVG9JbmRleF8oZmVhdHVyZUtleSwgZmVhdHVyZSkpIHtcbiAgICAgICAgbmV3RmVhdHVyZXMucHVzaChmZWF0dXJlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpJDEgPSAwLCBsZW5ndGgkMSA9IG5ld0ZlYXR1cmVzLmxlbmd0aDsgaSQxIDwgbGVuZ3RoJDE7IGkkMSsrKSB7XG4gICAgICB2YXIgZmVhdHVyZSQxID0gbmV3RmVhdHVyZXNbaSQxXTtcbiAgICAgIHZhciBmZWF0dXJlS2V5JDEgPSBnZXRVaWQoZmVhdHVyZSQxKTtcbiAgICAgIHRoaXMuc2V0dXBDaGFuZ2VFdmVudHNfKGZlYXR1cmVLZXkkMSwgZmVhdHVyZSQxKTtcblxuICAgICAgdmFyIGdlb21ldHJ5ID0gZmVhdHVyZSQxLmdldEdlb21ldHJ5KCk7XG4gICAgICBpZiAoZ2VvbWV0cnkpIHtcbiAgICAgICAgdmFyIGV4dGVudCA9IGdlb21ldHJ5LmdldEV4dGVudCgpO1xuICAgICAgICBleHRlbnRzLnB1c2goZXh0ZW50KTtcbiAgICAgICAgZ2VvbWV0cnlGZWF0dXJlcy5wdXNoKGZlYXR1cmUkMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm51bGxHZW9tZXRyeUZlYXR1cmVzX1tmZWF0dXJlS2V5JDFdID0gZmVhdHVyZSQxO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5mZWF0dXJlc1J0cmVlXykge1xuICAgICAgdGhpcy5mZWF0dXJlc1J0cmVlXy5sb2FkKGV4dGVudHMsIGdlb21ldHJ5RmVhdHVyZXMpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkkMiA9IDAsIGxlbmd0aCQyID0gbmV3RmVhdHVyZXMubGVuZ3RoOyBpJDIgPCBsZW5ndGgkMjsgaSQyKyspIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgVmVjdG9yU291cmNlRXZlbnQoVmVjdG9yRXZlbnRUeXBlLkFEREZFQVRVUkUsIG5ld0ZlYXR1cmVzW2kkMl0pKTtcbiAgICB9XG4gIH07XG5cblxuICAvKipcbiAgICogQHBhcmFtIHshQ29sbGVjdGlvbjxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fSBjb2xsZWN0aW9uIENvbGxlY3Rpb24uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBWZWN0b3JTb3VyY2UucHJvdG90eXBlLmJpbmRGZWF0dXJlc0NvbGxlY3Rpb25fID0gZnVuY3Rpb24gYmluZEZlYXR1cmVzQ29sbGVjdGlvbl8gKGNvbGxlY3Rpb24pIHtcbiAgICB2YXIgbW9kaWZ5aW5nQ29sbGVjdGlvbiA9IGZhbHNlO1xuICAgIGxpc3Rlbih0aGlzLCBWZWN0b3JFdmVudFR5cGUuQURERkVBVFVSRSxcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtWZWN0b3JTb3VyY2VFdmVudH0gZXZ0IFRoZSB2ZWN0b3Igc291cmNlIGV2ZW50XG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBpZiAoIW1vZGlmeWluZ0NvbGxlY3Rpb24pIHtcbiAgICAgICAgICBtb2RpZnlpbmdDb2xsZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICBjb2xsZWN0aW9uLnB1c2goZXZ0LmZlYXR1cmUpO1xuICAgICAgICAgIG1vZGlmeWluZ0NvbGxlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgbGlzdGVuKHRoaXMsIFZlY3RvckV2ZW50VHlwZS5SRU1PVkVGRUFUVVJFLFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge1ZlY3RvclNvdXJjZUV2ZW50fSBldnQgVGhlIHZlY3RvciBzb3VyY2UgZXZlbnRcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIGlmICghbW9kaWZ5aW5nQ29sbGVjdGlvbikge1xuICAgICAgICAgIG1vZGlmeWluZ0NvbGxlY3Rpb24gPSB0cnVlO1xuICAgICAgICAgIGNvbGxlY3Rpb24ucmVtb3ZlKGV2dC5mZWF0dXJlKTtcbiAgICAgICAgICBtb2RpZnlpbmdDb2xsZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIGxpc3Rlbihjb2xsZWN0aW9uLCBDb2xsZWN0aW9uRXZlbnRUeXBlLkFERCxcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9Db2xsZWN0aW9uLmpzXCIpLkNvbGxlY3Rpb25FdmVudH0gZXZ0IFRoZSBjb2xsZWN0aW9uIGV2ZW50XG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBpZiAoIW1vZGlmeWluZ0NvbGxlY3Rpb24pIHtcbiAgICAgICAgICBtb2RpZnlpbmdDb2xsZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmFkZEZlYXR1cmUoLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9ICovIChldnQuZWxlbWVudCkpO1xuICAgICAgICAgIG1vZGlmeWluZ0NvbGxlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG4gICAgbGlzdGVuKGNvbGxlY3Rpb24sIENvbGxlY3Rpb25FdmVudFR5cGUuUkVNT1ZFLFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0NvbGxlY3Rpb24uanNcIikuQ29sbGVjdGlvbkV2ZW50fSBldnQgVGhlIGNvbGxlY3Rpb24gZXZlbnRcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIGlmICghbW9kaWZ5aW5nQ29sbGVjdGlvbikge1xuICAgICAgICAgIG1vZGlmeWluZ0NvbGxlY3Rpb24gPSB0cnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlRmVhdHVyZSgvKiogQHR5cGUge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gKi8gKGV2dC5lbGVtZW50KSk7XG4gICAgICAgICAgbW9kaWZ5aW5nQ29sbGVjdGlvbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICB0aGlzLmZlYXR1cmVzQ29sbGVjdGlvbl8gPSBjb2xsZWN0aW9uO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbGwgZmVhdHVyZXMgZnJvbSB0aGUgc291cmNlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfZmFzdCBTa2lwIGRpc3BhdGNoaW5nIG9mIHtAbGluayBtb2R1bGU6b2wvc291cmNlL1ZlY3Rvci5WZWN0b3JTb3VyY2VFdmVudCNyZW1vdmVmZWF0dXJlfSBldmVudHMuXG4gICAqIEBhcGlcbiAgICovXG4gIFZlY3RvclNvdXJjZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAob3B0X2Zhc3QpIHtcbiAgICBpZiAob3B0X2Zhc3QpIHtcbiAgICAgIGZvciAodmFyIGZlYXR1cmVJZCBpbiB0aGlzLmZlYXR1cmVDaGFuZ2VLZXlzXykge1xuICAgICAgICB2YXIga2V5cyA9IHRoaXMuZmVhdHVyZUNoYW5nZUtleXNfW2ZlYXR1cmVJZF07XG4gICAgICAgIGtleXMuZm9yRWFjaCh1bmxpc3RlbkJ5S2V5KTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5mZWF0dXJlc0NvbGxlY3Rpb25fKSB7XG4gICAgICAgIHRoaXMuZmVhdHVyZUNoYW5nZUtleXNfID0ge307XG4gICAgICAgIHRoaXMuaWRJbmRleF8gPSB7fTtcbiAgICAgICAgdGhpcy51bmRlZklkSW5kZXhfID0ge307XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmZlYXR1cmVzUnRyZWVfKSB7XG4gICAgICAgIHRoaXMuZmVhdHVyZXNSdHJlZV8uZm9yRWFjaCh0aGlzLnJlbW92ZUZlYXR1cmVJbnRlcm5hbCwgdGhpcyk7XG4gICAgICAgIGZvciAodmFyIGlkIGluIHRoaXMubnVsbEdlb21ldHJ5RmVhdHVyZXNfKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVGZWF0dXJlSW50ZXJuYWwodGhpcy5udWxsR2VvbWV0cnlGZWF0dXJlc19baWRdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5mZWF0dXJlc0NvbGxlY3Rpb25fKSB7XG4gICAgICB0aGlzLmZlYXR1cmVzQ29sbGVjdGlvbl8uY2xlYXIoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5mZWF0dXJlc1J0cmVlXykge1xuICAgICAgdGhpcy5mZWF0dXJlc1J0cmVlXy5jbGVhcigpO1xuICAgIH1cbiAgICB0aGlzLmxvYWRlZEV4dGVudHNSdHJlZV8uY2xlYXIoKTtcbiAgICB0aGlzLm51bGxHZW9tZXRyeUZlYXR1cmVzXyA9IHt9O1xuXG4gICAgdmFyIGNsZWFyRXZlbnQgPSBuZXcgVmVjdG9yU291cmNlRXZlbnQoVmVjdG9yRXZlbnRUeXBlLkNMRUFSKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoY2xlYXJFdmVudCk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH07XG5cblxuICAvKipcbiAgICogSXRlcmF0ZSB0aHJvdWdoIGFsbCBmZWF0dXJlcyBvbiB0aGUgc291cmNlLCBjYWxsaW5nIHRoZSBwcm92aWRlZCBjYWxsYmFja1xuICAgKiB3aXRoIGVhY2ggb25lLiAgSWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYW55IFwidHJ1dGh5XCIgdmFsdWUsIGl0ZXJhdGlvbiB3aWxsXG4gICAqIHN0b3AgYW5kIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgc2FtZSB2YWx1ZS5cbiAgICogTm90ZTogdGhpcyBmdW5jdGlvbiBvbmx5IGl0ZXJhdGUgdGhyb3VnaCB0aGUgZmVhdHVyZSB0aGF0IGhhdmUgYSBkZWZpbmVkIGdlb21ldHJ5LlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdCk6IFR9IGNhbGxiYWNrIENhbGxlZCB3aXRoIGVhY2ggZmVhdHVyZVxuICAgKiAgICAgb24gdGhlIHNvdXJjZS4gIFJldHVybiBhIHRydXRoeSB2YWx1ZSB0byBzdG9wIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybiB7VHx1bmRlZmluZWR9IFRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgbGFzdCBjYWxsIHRvIHRoZSBjYWxsYmFjay5cbiAgICogQHRlbXBsYXRlIFRcbiAgICogQGFwaVxuICAgKi9cbiAgVmVjdG9yU291cmNlLnByb3RvdHlwZS5mb3JFYWNoRmVhdHVyZSA9IGZ1bmN0aW9uIGZvckVhY2hGZWF0dXJlIChjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLmZlYXR1cmVzUnRyZWVfKSB7XG4gICAgICByZXR1cm4gdGhpcy5mZWF0dXJlc1J0cmVlXy5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZmVhdHVyZXNDb2xsZWN0aW9uXykge1xuICAgICAgdGhpcy5mZWF0dXJlc0NvbGxlY3Rpb25fLmZvckVhY2goY2FsbGJhY2spO1xuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBJdGVyYXRlIHRocm91Z2ggYWxsIGZlYXR1cmVzIHdob3NlIGdlb21ldHJpZXMgY29udGFpbiB0aGUgcHJvdmlkZWRcbiAgICogY29vcmRpbmF0ZSwgY2FsbGluZyB0aGUgY2FsbGJhY2sgd2l0aCBlYWNoIGZlYXR1cmUuICBJZiB0aGUgY2FsbGJhY2sgcmV0dXJuc1xuICAgKiBhIFwidHJ1dGh5XCIgdmFsdWUsIGl0ZXJhdGlvbiB3aWxsIHN0b3AgYW5kIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgc2FtZVxuICAgKiB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQpOiBUfSBjYWxsYmFjayBDYWxsZWQgd2l0aCBlYWNoIGZlYXR1cmVcbiAgICogICAgIHdob3NlIGdvZW1ldHJ5IGNvbnRhaW5zIHRoZSBwcm92aWRlZCBjb29yZGluYXRlLlxuICAgKiBAcmV0dXJuIHtUfHVuZGVmaW5lZH0gVGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBsYXN0IGNhbGwgdG8gdGhlIGNhbGxiYWNrLlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKi9cbiAgVmVjdG9yU291cmNlLnByb3RvdHlwZS5mb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZURpcmVjdCA9IGZ1bmN0aW9uIGZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlRGlyZWN0IChjb29yZGluYXRlLCBjYWxsYmFjaykge1xuICAgIHZhciBleHRlbnQgPSBbY29vcmRpbmF0ZVswXSwgY29vcmRpbmF0ZVsxXSwgY29vcmRpbmF0ZVswXSwgY29vcmRpbmF0ZVsxXV07XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaEZlYXR1cmVJbkV4dGVudChleHRlbnQsIGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgICAgIHZhciBnZW9tZXRyeSA9IGZlYXR1cmUuZ2V0R2VvbWV0cnkoKTtcbiAgICAgIGlmIChnZW9tZXRyeS5pbnRlcnNlY3RzQ29vcmRpbmF0ZShjb29yZGluYXRlKSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZmVhdHVyZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEl0ZXJhdGUgdGhyb3VnaCBhbGwgZmVhdHVyZXMgd2hvc2UgYm91bmRpbmcgYm94IGludGVyc2VjdHMgdGhlIHByb3ZpZGVkXG4gICAqIGV4dGVudCAobm90ZSB0aGF0IHRoZSBmZWF0dXJlJ3MgZ2VvbWV0cnkgbWF5IG5vdCBpbnRlcnNlY3QgdGhlIGV4dGVudCksXG4gICAqIGNhbGxpbmcgdGhlIGNhbGxiYWNrIHdpdGggZWFjaCBmZWF0dXJlLiAgSWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYSBcInRydXRoeVwiXG4gICAqIHZhbHVlLCBpdGVyYXRpb24gd2lsbCBzdG9wIGFuZCB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHNhbWUgdmFsdWUuXG4gICAqXG4gICAqIElmIHlvdSBhcmUgaW50ZXJlc3RlZCBpbiBmZWF0dXJlcyB3aG9zZSBnZW9tZXRyeSBpbnRlcnNlY3RzIGFuIGV4dGVudCwgY2FsbFxuICAgKiB0aGUge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yflZlY3RvclNvdXJjZSNmb3JFYWNoRmVhdHVyZUludGVyc2VjdGluZ0V4dGVudCAjZm9yRWFjaEZlYXR1cmVJbnRlcnNlY3RpbmdFeHRlbnQoKX0gbWV0aG9kIGluc3RlYWQuXG4gICAqXG4gICAqIFdoZW4gYHVzZVNwYXRpYWxJbmRleGAgaXMgc2V0IHRvIGZhbHNlLCB0aGlzIG1ldGhvZCB3aWxsIGxvb3AgdGhyb3VnaCBhbGxcbiAgICogZmVhdHVyZXMsIGVxdWl2YWxlbnQgdG8ge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yflZlY3RvclNvdXJjZSNmb3JFYWNoRmVhdHVyZSAjZm9yRWFjaEZlYXR1cmUoKX0uXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQpOiBUfSBjYWxsYmFjayBDYWxsZWQgd2l0aCBlYWNoIGZlYXR1cmVcbiAgICogICAgIHdob3NlIGJvdW5kaW5nIGJveCBpbnRlcnNlY3RzIHRoZSBwcm92aWRlZCBleHRlbnQuXG4gICAqIEByZXR1cm4ge1R8dW5kZWZpbmVkfSBUaGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGxhc3QgY2FsbCB0byB0aGUgY2FsbGJhY2suXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqIEBhcGlcbiAgICovXG4gIFZlY3RvclNvdXJjZS5wcm90b3R5cGUuZm9yRWFjaEZlYXR1cmVJbkV4dGVudCA9IGZ1bmN0aW9uIGZvckVhY2hGZWF0dXJlSW5FeHRlbnQgKGV4dGVudCwgY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5mZWF0dXJlc1J0cmVlXykge1xuICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZXNSdHJlZV8uZm9yRWFjaEluRXh0ZW50KGV4dGVudCwgY2FsbGJhY2spO1xuICAgIH0gZWxzZSBpZiAodGhpcy5mZWF0dXJlc0NvbGxlY3Rpb25fKSB7XG4gICAgICB0aGlzLmZlYXR1cmVzQ29sbGVjdGlvbl8uZm9yRWFjaChjYWxsYmFjayk7XG4gICAgfVxuICB9O1xuXG5cbiAgLyoqXG4gICAqIEl0ZXJhdGUgdGhyb3VnaCBhbGwgZmVhdHVyZXMgd2hvc2UgZ2VvbWV0cnkgaW50ZXJzZWN0cyB0aGUgcHJvdmlkZWQgZXh0ZW50LFxuICAgKiBjYWxsaW5nIHRoZSBjYWxsYmFjayB3aXRoIGVhY2ggZmVhdHVyZS4gIElmIHRoZSBjYWxsYmFjayByZXR1cm5zIGEgXCJ0cnV0aHlcIlxuICAgKiB2YWx1ZSwgaXRlcmF0aW9uIHdpbGwgc3RvcCBhbmQgdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSBzYW1lIHZhbHVlLlxuICAgKlxuICAgKiBJZiB5b3Ugb25seSB3YW50IHRvIHRlc3QgZm9yIGJvdW5kaW5nIGJveCBpbnRlcnNlY3Rpb24sIGNhbGwgdGhlXG4gICAqIHtAbGluayBtb2R1bGU6b2wvc291cmNlL1ZlY3Rvcn5WZWN0b3JTb3VyY2UjZm9yRWFjaEZlYXR1cmVJbkV4dGVudCAjZm9yRWFjaEZlYXR1cmVJbkV4dGVudCgpfSBtZXRob2QgaW5zdGVhZC5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdCk6IFR9IGNhbGxiYWNrIENhbGxlZCB3aXRoIGVhY2ggZmVhdHVyZVxuICAgKiAgICAgd2hvc2UgZ2VvbWV0cnkgaW50ZXJzZWN0cyB0aGUgcHJvdmlkZWQgZXh0ZW50LlxuICAgKiBAcmV0dXJuIHtUfHVuZGVmaW5lZH0gVGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBsYXN0IGNhbGwgdG8gdGhlIGNhbGxiYWNrLlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKiBAYXBpXG4gICAqL1xuICBWZWN0b3JTb3VyY2UucHJvdG90eXBlLmZvckVhY2hGZWF0dXJlSW50ZXJzZWN0aW5nRXh0ZW50ID0gZnVuY3Rpb24gZm9yRWFjaEZlYXR1cmVJbnRlcnNlY3RpbmdFeHRlbnQgKGV4dGVudCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoRmVhdHVyZUluRXh0ZW50KGV4dGVudCxcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICAgICAqIEByZXR1cm4ge1R8dW5kZWZpbmVkfSBUaGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGxhc3QgY2FsbCB0byB0aGUgY2FsbGJhY2suXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gZmVhdHVyZS5nZXRHZW9tZXRyeSgpO1xuICAgICAgICBpZiAoZ2VvbWV0cnkuaW50ZXJzZWN0c0V4dGVudChleHRlbnQpKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGNhbGxiYWNrKGZlYXR1cmUpO1xuICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGZlYXR1cmVzIGNvbGxlY3Rpb24gYXNzb2NpYXRlZCB3aXRoIHRoaXMgc291cmNlLiBXaWxsIGJlIGBudWxsYFxuICAgKiB1bmxlc3MgdGhlIHNvdXJjZSB3YXMgY29uZmlndXJlZCB3aXRoIGB1c2VTcGF0aWFsSW5kZXhgIHNldCB0byBgZmFsc2VgLCBvclxuICAgKiB3aXRoIGFuIHtAbGluayBtb2R1bGU6b2wvQ29sbGVjdGlvbn0gYXMgYGZlYXR1cmVzYC5cbiAgICogQHJldHVybiB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fSBUaGUgY29sbGVjdGlvbiBvZiBmZWF0dXJlcy5cbiAgICogQGFwaVxuICAgKi9cbiAgVmVjdG9yU291cmNlLnByb3RvdHlwZS5nZXRGZWF0dXJlc0NvbGxlY3Rpb24gPSBmdW5jdGlvbiBnZXRGZWF0dXJlc0NvbGxlY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmZlYXR1cmVzQ29sbGVjdGlvbl87XG4gIH07XG5cblxuICAvKipcbiAgICogR2V0IGFsbCBmZWF0dXJlcyBvbiB0aGUgc291cmNlIGluIHJhbmRvbSBvcmRlci5cbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn0gRmVhdHVyZXMuXG4gICAqIEBhcGlcbiAgICovXG4gIFZlY3RvclNvdXJjZS5wcm90b3R5cGUuZ2V0RmVhdHVyZXMgPSBmdW5jdGlvbiBnZXRGZWF0dXJlcyAoKSB7XG4gICAgdmFyIGZlYXR1cmVzO1xuICAgIGlmICh0aGlzLmZlYXR1cmVzQ29sbGVjdGlvbl8pIHtcbiAgICAgIGZlYXR1cmVzID0gdGhpcy5mZWF0dXJlc0NvbGxlY3Rpb25fLmdldEFycmF5KCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmZlYXR1cmVzUnRyZWVfKSB7XG4gICAgICBmZWF0dXJlcyA9IHRoaXMuZmVhdHVyZXNSdHJlZV8uZ2V0QWxsKCk7XG4gICAgICBpZiAoIWlzRW1wdHkodGhpcy5udWxsR2VvbWV0cnlGZWF0dXJlc18pKSB7XG4gICAgICAgIGV4dGVuZChmZWF0dXJlcywgZ2V0VmFsdWVzKHRoaXMubnVsbEdlb21ldHJ5RmVhdHVyZXNfKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoXG4gICAgICAvKiogQHR5cGUge0FycmF5PGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59ICovIChmZWF0dXJlcylcbiAgICApO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEdldCBhbGwgZmVhdHVyZXMgd2hvc2UgZ2VvbWV0cnkgaW50ZXJzZWN0cyB0aGUgcHJvdmlkZWQgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn0gRmVhdHVyZXMuXG4gICAqIEBhcGlcbiAgICovXG4gIFZlY3RvclNvdXJjZS5wcm90b3R5cGUuZ2V0RmVhdHVyZXNBdENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRGZWF0dXJlc0F0Q29vcmRpbmF0ZSAoY29vcmRpbmF0ZSkge1xuICAgIHZhciBmZWF0dXJlcyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGVEaXJlY3QoY29vcmRpbmF0ZSwgZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgICAgZmVhdHVyZXMucHVzaChmZWF0dXJlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZmVhdHVyZXM7XG4gIH07XG5cblxuICAvKipcbiAgICogR2V0IGFsbCBmZWF0dXJlcyBpbiB0aGUgcHJvdmlkZWQgZXh0ZW50LiAgTm90ZSB0aGF0IHRoaXMgcmV0dXJucyBhbiBhcnJheSBvZlxuICAgKiBhbGwgZmVhdHVyZXMgaW50ZXJzZWN0aW5nIHRoZSBnaXZlbiBleHRlbnQgaW4gcmFuZG9tIG9yZGVyIChzbyBpdCBtYXkgaW5jbHVkZVxuICAgKiBmZWF0dXJlcyB3aG9zZSBnZW9tZXRyaWVzIGRvIG5vdCBpbnRlcnNlY3QgdGhlIGV4dGVudCkuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIG5vdCBhdmFpbGFibGUgd2hlbiB0aGUgc291cmNlIGlzIGNvbmZpZ3VyZWQgd2l0aFxuICAgKiBgdXNlU3BhdGlhbEluZGV4YCBzZXQgdG8gYGZhbHNlYC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcmV0dXJuIHtBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fSBGZWF0dXJlcy5cbiAgICogQGFwaVxuICAgKi9cbiAgVmVjdG9yU291cmNlLnByb3RvdHlwZS5nZXRGZWF0dXJlc0luRXh0ZW50ID0gZnVuY3Rpb24gZ2V0RmVhdHVyZXNJbkV4dGVudCAoZXh0ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuZmVhdHVyZXNSdHJlZV8uZ2V0SW5FeHRlbnQoZXh0ZW50KTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNsb3Nlc3QgZmVhdHVyZSB0byB0aGUgcHJvdmlkZWQgY29vcmRpbmF0ZS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgbm90IGF2YWlsYWJsZSB3aGVuIHRoZSBzb3VyY2UgaXMgY29uZmlndXJlZCB3aXRoXG4gICAqIGB1c2VTcGF0aWFsSW5kZXhgIHNldCB0byBgZmFsc2VgLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdCk6Ym9vbGVhbj19IG9wdF9maWx0ZXIgRmVhdHVyZSBmaWx0ZXIgZnVuY3Rpb24uXG4gICAqICAgICBUaGUgZmlsdGVyIGZ1bmN0aW9uIHdpbGwgcmVjZWl2ZSBvbmUgYXJndW1lbnQsIHRoZSB7QGxpbmsgbW9kdWxlOm9sL0ZlYXR1cmUgZmVhdHVyZX1cbiAgICogICAgIGFuZCBpdCBzaG91bGQgcmV0dXJuIGEgYm9vbGVhbiB2YWx1ZS4gQnkgZGVmYXVsdCwgbm8gZmlsdGVyaW5nIGlzIG1hZGUuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gQ2xvc2VzdCBmZWF0dXJlLlxuICAgKiBAYXBpXG4gICAqL1xuICBWZWN0b3JTb3VyY2UucHJvdG90eXBlLmdldENsb3Nlc3RGZWF0dXJlVG9Db29yZGluYXRlID0gZnVuY3Rpb24gZ2V0Q2xvc2VzdEZlYXR1cmVUb0Nvb3JkaW5hdGUgKGNvb3JkaW5hdGUsIG9wdF9maWx0ZXIpIHtcbiAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IGZlYXR1cmUgdXNpbmcgYnJhbmNoIGFuZCBib3VuZC4gIFdlIHN0YXJ0IHNlYXJjaGluZyBhblxuICAgIC8vIGluZmluaXRlIGV4dGVudCwgYW5kIGZpbmQgdGhlIGRpc3RhbmNlIGZyb20gdGhlIGZpcnN0IGZlYXR1cmUgZm91bmQuICBUaGlzXG4gICAgLy8gYmVjb21lcyB0aGUgY2xvc2VzdCBmZWF0dXJlLiAgV2UgdGhlbiBjb21wdXRlIGEgc21hbGxlciBleHRlbnQgd2hpY2ggYW55XG4gICAgLy8gY2xvc2VyIGZlYXR1cmUgbXVzdCBpbnRlcnNlY3QuICBXZSBjb250aW51ZSBzZWFyY2hpbmcgd2l0aCB0aGlzIHNtYWxsZXJcbiAgICAvLyBleHRlbnQsIHRyeWluZyB0byBmaW5kIGEgY2xvc2VyIGZlYXR1cmUuICBFdmVyeSB0aW1lIHdlIGZpbmQgYSBjbG9zZXJcbiAgICAvLyBmZWF0dXJlLCB3ZSB1cGRhdGUgdGhlIGV4dGVudCBiZWluZyBzZWFyY2hlZCBzbyB0aGF0IGFueSBldmVuIGNsb3NlclxuICAgIC8vIGZlYXR1cmUgbXVzdCBpbnRlcnNlY3QgaXQuICBXZSBjb250aW51ZSB1bnRpbCB3ZSBydW4gb3V0IG9mIGZlYXR1cmVzLlxuICAgIHZhciB4ID0gY29vcmRpbmF0ZVswXTtcbiAgICB2YXIgeSA9IGNvb3JkaW5hdGVbMV07XG4gICAgdmFyIGNsb3Nlc3RGZWF0dXJlID0gbnVsbDtcbiAgICB2YXIgY2xvc2VzdFBvaW50ID0gW05hTiwgTmFOXTtcbiAgICB2YXIgbWluU3F1YXJlZERpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgdmFyIGV4dGVudCA9IFstSW5maW5pdHksIC1JbmZpbml0eSwgSW5maW5pdHksIEluZmluaXR5XTtcbiAgICB2YXIgZmlsdGVyID0gb3B0X2ZpbHRlciA/IG9wdF9maWx0ZXIgOiBUUlVFO1xuICAgIHRoaXMuZmVhdHVyZXNSdHJlZV8uZm9yRWFjaEluRXh0ZW50KGV4dGVudCxcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgICAgICBpZiAoZmlsdGVyKGZlYXR1cmUpKSB7XG4gICAgICAgICAgdmFyIGdlb21ldHJ5ID0gZmVhdHVyZS5nZXRHZW9tZXRyeSgpO1xuICAgICAgICAgIHZhciBwcmV2aW91c01pblNxdWFyZWREaXN0YW5jZSA9IG1pblNxdWFyZWREaXN0YW5jZTtcbiAgICAgICAgICBtaW5TcXVhcmVkRGlzdGFuY2UgPSBnZW9tZXRyeS5jbG9zZXN0UG9pbnRYWShcbiAgICAgICAgICAgIHgsIHksIGNsb3Nlc3RQb2ludCwgbWluU3F1YXJlZERpc3RhbmNlKTtcbiAgICAgICAgICBpZiAobWluU3F1YXJlZERpc3RhbmNlIDwgcHJldmlvdXNNaW5TcXVhcmVkRGlzdGFuY2UpIHtcbiAgICAgICAgICAgIGNsb3Nlc3RGZWF0dXJlID0gZmVhdHVyZTtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgc25lYWt5LiAgUmVkdWNlIHRoZSBleHRlbnQgdGhhdCBpdCBpcyBjdXJyZW50bHkgYmVpbmdcbiAgICAgICAgICAgIC8vIHNlYXJjaGVkIHdoaWxlIHRoZSBSLVRyZWUgdHJhdmVyc2FsIHVzaW5nIHRoaXMgc2FtZSBleHRlbnQgb2JqZWN0XG4gICAgICAgICAgICAvLyBpcyBzdGlsbCBpbiBwcm9ncmVzcy4gIFRoaXMgaXMgc2FmZSBiZWNhdXNlIHRoZSBuZXcgZXh0ZW50IGlzXG4gICAgICAgICAgICAvLyBzdHJpY3RseSBjb250YWluZWQgYnkgdGhlIG9sZCBleHRlbnQuXG4gICAgICAgICAgICB2YXIgbWluRGlzdGFuY2UgPSBNYXRoLnNxcnQobWluU3F1YXJlZERpc3RhbmNlKTtcbiAgICAgICAgICAgIGV4dGVudFswXSA9IHggLSBtaW5EaXN0YW5jZTtcbiAgICAgICAgICAgIGV4dGVudFsxXSA9IHkgLSBtaW5EaXN0YW5jZTtcbiAgICAgICAgICAgIGV4dGVudFsyXSA9IHggKyBtaW5EaXN0YW5jZTtcbiAgICAgICAgICAgIGV4dGVudFszXSA9IHkgKyBtaW5EaXN0YW5jZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIHJldHVybiBjbG9zZXN0RmVhdHVyZTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGV4dGVudCBvZiB0aGUgZmVhdHVyZXMgY3VycmVudGx5IGluIHRoZSBzb3VyY2UuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIG5vdCBhdmFpbGFibGUgd2hlbiB0aGUgc291cmNlIGlzIGNvbmZpZ3VyZWQgd2l0aFxuICAgKiBgdXNlU3BhdGlhbEluZGV4YCBzZXQgdG8gYGZhbHNlYC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50PX0gb3B0X2V4dGVudCBEZXN0aW5hdGlvbiBleHRlbnQuIElmIHByb3ZpZGVkLCBubyBuZXcgZXh0ZW50XG4gICAqICAgICB3aWxsIGJlIGNyZWF0ZWQuIEluc3RlYWQsIHRoYXQgZXh0ZW50J3MgY29vcmRpbmF0ZXMgd2lsbCBiZSBvdmVyd3JpdHRlbi5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gRXh0ZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBWZWN0b3JTb3VyY2UucHJvdG90eXBlLmdldEV4dGVudCA9IGZ1bmN0aW9uIGdldEV4dGVudCAob3B0X2V4dGVudCkge1xuICAgIHJldHVybiB0aGlzLmZlYXR1cmVzUnRyZWVfLmdldEV4dGVudChvcHRfZXh0ZW50KTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBHZXQgYSBmZWF0dXJlIGJ5IGl0cyBpZGVudGlmaWVyICh0aGUgdmFsdWUgcmV0dXJuZWQgYnkgZmVhdHVyZS5nZXRJZCgpKS5cbiAgICogTm90ZSB0aGF0IHRoZSBpbmRleCB0cmVhdHMgc3RyaW5nIGFuZCBudW1lcmljIGlkZW50aWZpZXJzIGFzIHRoZSBzYW1lLiAgU29cbiAgICogYHNvdXJjZS5nZXRGZWF0dXJlQnlJZCgyKWAgd2lsbCByZXR1cm4gYSBmZWF0dXJlIHdpdGggaWQgYCcyJ2Agb3IgYDJgLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGlkIEZlYXR1cmUgaWRlbnRpZmllci5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBUaGUgZmVhdHVyZSAob3IgYG51bGxgIGlmIG5vdCBmb3VuZCkuXG4gICAqIEBhcGlcbiAgICovXG4gIFZlY3RvclNvdXJjZS5wcm90b3R5cGUuZ2V0RmVhdHVyZUJ5SWQgPSBmdW5jdGlvbiBnZXRGZWF0dXJlQnlJZCAoaWQpIHtcbiAgICB2YXIgZmVhdHVyZSA9IHRoaXMuaWRJbmRleF9baWQudG9TdHJpbmcoKV07XG4gICAgcmV0dXJuIGZlYXR1cmUgIT09IHVuZGVmaW5lZCA/IGZlYXR1cmUgOiBudWxsO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZm9ybWF0IGFzc29jaWF0ZWQgd2l0aCB0aGlzIHNvdXJjZS5cbiAgICpcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZm9ybWF0L0ZlYXR1cmUuanNcIikuZGVmYXVsdHx1bmRlZmluZWR9IFRoZSBmZWF0dXJlIGZvcm1hdC5cbiAgICogQGFwaVxuICAgKi9cbiAgVmVjdG9yU291cmNlLnByb3RvdHlwZS5nZXRGb3JtYXQgPSBmdW5jdGlvbiBnZXRGb3JtYXQgKCkge1xuICAgIHJldHVybiB0aGlzLmZvcm1hdF87XG4gIH07XG5cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHNvdXJjZSBjYW4gaGF2ZSBvdmVybGFwcGluZyBnZW9tZXRyaWVzLlxuICAgKi9cbiAgVmVjdG9yU291cmNlLnByb3RvdHlwZS5nZXRPdmVybGFwcyA9IGZ1bmN0aW9uIGdldE92ZXJsYXBzICgpIHtcbiAgICByZXR1cm4gdGhpcy5vdmVybGFwc187XG4gIH07XG5cblxuICAvKipcbiAgICogR2V0IHRoZSB1cmwgYXNzb2NpYXRlZCB3aXRoIHRoaXMgc291cmNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd8aW1wb3J0KFwiLi4vZmVhdHVyZWxvYWRlci5qc1wiKS5GZWF0dXJlVXJsRnVuY3Rpb258dW5kZWZpbmVkfSBUaGUgdXJsLlxuICAgKiBAYXBpXG4gICAqL1xuICBWZWN0b3JTb3VyY2UucHJvdG90eXBlLmdldFVybCA9IGZ1bmN0aW9uIGdldFVybCAoKSB7XG4gICAgcmV0dXJuIHRoaXMudXJsXztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBFdmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFZlY3RvclNvdXJjZS5wcm90b3R5cGUuaGFuZGxlRmVhdHVyZUNoYW5nZV8gPSBmdW5jdGlvbiBoYW5kbGVGZWF0dXJlQ2hhbmdlXyAoZXZlbnQpIHtcbiAgICB2YXIgZmVhdHVyZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSAqLyAoZXZlbnQudGFyZ2V0KTtcbiAgICB2YXIgZmVhdHVyZUtleSA9IGdldFVpZChmZWF0dXJlKTtcbiAgICB2YXIgZ2VvbWV0cnkgPSBmZWF0dXJlLmdldEdlb21ldHJ5KCk7XG4gICAgaWYgKCFnZW9tZXRyeSkge1xuICAgICAgaWYgKCEoZmVhdHVyZUtleSBpbiB0aGlzLm51bGxHZW9tZXRyeUZlYXR1cmVzXykpIHtcbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZXNSdHJlZV8pIHtcbiAgICAgICAgICB0aGlzLmZlYXR1cmVzUnRyZWVfLnJlbW92ZShmZWF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm51bGxHZW9tZXRyeUZlYXR1cmVzX1tmZWF0dXJlS2V5XSA9IGZlYXR1cmU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBleHRlbnQgPSBnZW9tZXRyeS5nZXRFeHRlbnQoKTtcbiAgICAgIGlmIChmZWF0dXJlS2V5IGluIHRoaXMubnVsbEdlb21ldHJ5RmVhdHVyZXNfKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm51bGxHZW9tZXRyeUZlYXR1cmVzX1tmZWF0dXJlS2V5XTtcbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZXNSdHJlZV8pIHtcbiAgICAgICAgICB0aGlzLmZlYXR1cmVzUnRyZWVfLmluc2VydChleHRlbnQsIGZlYXR1cmUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlc1J0cmVlXykge1xuICAgICAgICAgIHRoaXMuZmVhdHVyZXNSdHJlZV8udXBkYXRlKGV4dGVudCwgZmVhdHVyZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGlkID0gZmVhdHVyZS5nZXRJZCgpO1xuICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgc2lkID0gaWQudG9TdHJpbmcoKTtcbiAgICAgIGlmIChmZWF0dXJlS2V5IGluIHRoaXMudW5kZWZJZEluZGV4Xykge1xuICAgICAgICBkZWxldGUgdGhpcy51bmRlZklkSW5kZXhfW2ZlYXR1cmVLZXldO1xuICAgICAgICB0aGlzLmlkSW5kZXhfW3NpZF0gPSBmZWF0dXJlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuaWRJbmRleF9bc2lkXSAhPT0gZmVhdHVyZSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlRnJvbUlkSW5kZXhfKGZlYXR1cmUpO1xuICAgICAgICAgIHRoaXMuaWRJbmRleF9bc2lkXSA9IGZlYXR1cmU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCEoZmVhdHVyZUtleSBpbiB0aGlzLnVuZGVmSWRJbmRleF8pKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRnJvbUlkSW5kZXhfKGZlYXR1cmUpO1xuICAgICAgICB0aGlzLnVuZGVmSWRJbmRleF9bZmVhdHVyZUtleV0gPSBmZWF0dXJlO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IFZlY3RvclNvdXJjZUV2ZW50KFxuICAgICAgVmVjdG9yRXZlbnRUeXBlLkNIQU5HRUZFQVRVUkUsIGZlYXR1cmUpKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBmZWF0dXJlIGlzIGNvbnRhaW5lZCB3aXRoaW4gdGhlIHNvdXJjZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSGFzIGZlYXR1cmUuXG4gICAqIEBhcGlcbiAgICovXG4gIFZlY3RvclNvdXJjZS5wcm90b3R5cGUuaGFzRmVhdHVyZSA9IGZ1bmN0aW9uIGhhc0ZlYXR1cmUgKGZlYXR1cmUpIHtcbiAgICB2YXIgaWQgPSBmZWF0dXJlLmdldElkKCk7XG4gICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBpZCBpbiB0aGlzLmlkSW5kZXhfO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZ2V0VWlkKGZlYXR1cmUpIGluIHRoaXMudW5kZWZJZEluZGV4XztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIGVtcHR5LlxuICAgKi9cbiAgVmVjdG9yU291cmNlLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSQxICgpIHtcbiAgICByZXR1cm4gdGhpcy5mZWF0dXJlc1J0cmVlXy5pc0VtcHR5KCkgJiYgaXNFbXB0eSh0aGlzLm51bGxHZW9tZXRyeUZlYXR1cmVzXyk7XG4gIH07XG5cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqL1xuICBWZWN0b3JTb3VyY2UucHJvdG90eXBlLmxvYWRGZWF0dXJlcyA9IGZ1bmN0aW9uIGxvYWRGZWF0dXJlcyAoZXh0ZW50LCByZXNvbHV0aW9uLCBwcm9qZWN0aW9uKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgbG9hZGVkRXh0ZW50c1J0cmVlID0gdGhpcy5sb2FkZWRFeHRlbnRzUnRyZWVfO1xuICAgIHZhciBleHRlbnRzVG9Mb2FkID0gdGhpcy5zdHJhdGVneV8oZXh0ZW50LCByZXNvbHV0aW9uKTtcbiAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uICggaSwgaWkgKSB7XG4gICAgICB2YXIgZXh0ZW50VG9Mb2FkID0gZXh0ZW50c1RvTG9hZFtpXTtcbiAgICAgIHZhciBhbHJlYWR5TG9hZGVkID0gbG9hZGVkRXh0ZW50c1J0cmVlLmZvckVhY2hJbkV4dGVudChleHRlbnRUb0xvYWQsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge3tleHRlbnQ6IGltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9fSBvYmplY3QgT2JqZWN0LlxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBDb250YWlucy5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgIHJldHVybiBjb250YWluc0V4dGVudChvYmplY3QuZXh0ZW50LCBleHRlbnRUb0xvYWQpO1xuICAgICAgICB9KTtcbiAgICAgIGlmICghYWxyZWFkeUxvYWRlZCkge1xuICAgICAgICB0aGlzJDEubG9hZGVyXy5jYWxsKHRoaXMkMSwgZXh0ZW50VG9Mb2FkLCByZXNvbHV0aW9uLCBwcm9qZWN0aW9uKTtcbiAgICAgICAgbG9hZGVkRXh0ZW50c1J0cmVlLmluc2VydChleHRlbnRUb0xvYWQsIHtleHRlbnQ6IGV4dGVudFRvTG9hZC5zbGljZSgpfSk7XG4gICAgICAgIHRoaXMkMS5sb2FkaW5nID0gdGhpcyQxLmxvYWRlcl8gIT09IFZPSUQ7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGV4dGVudHNUb0xvYWQubGVuZ3RoOyBpIDwgaWk7ICsraSkgbG9vcCggaSwgaWkgKTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gZXh0ZW50IGZyb20gdGhlIGxpc3Qgb2YgbG9hZGVkIGV4dGVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQGFwaVxuICAgKi9cbiAgVmVjdG9yU291cmNlLnByb3RvdHlwZS5yZW1vdmVMb2FkZWRFeHRlbnQgPSBmdW5jdGlvbiByZW1vdmVMb2FkZWRFeHRlbnQgKGV4dGVudCkge1xuICAgIHZhciBsb2FkZWRFeHRlbnRzUnRyZWUgPSB0aGlzLmxvYWRlZEV4dGVudHNSdHJlZV87XG4gICAgdmFyIG9iajtcbiAgICBsb2FkZWRFeHRlbnRzUnRyZWUuZm9yRWFjaEluRXh0ZW50KGV4dGVudCwgZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICBpZiAoZXF1YWxzKG9iamVjdC5leHRlbnQsIGV4dGVudCkpIHtcbiAgICAgICAgb2JqID0gb2JqZWN0O1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAob2JqKSB7XG4gICAgICBsb2FkZWRFeHRlbnRzUnRyZWUucmVtb3ZlKG9iaik7XG4gICAgfVxuICB9O1xuXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIHNpbmdsZSBmZWF0dXJlIGZyb20gdGhlIHNvdXJjZS4gIElmIHlvdSB3YW50IHRvIHJlbW92ZSBhbGwgZmVhdHVyZXNcbiAgICogYXQgb25jZSwgdXNlIHRoZSB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3J+VmVjdG9yU291cmNlI2NsZWFyICNjbGVhcigpfSBtZXRob2RcbiAgICogaW5zdGVhZC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZSB0byByZW1vdmUuXG4gICAqIEBhcGlcbiAgICovXG4gIFZlY3RvclNvdXJjZS5wcm90b3R5cGUucmVtb3ZlRmVhdHVyZSA9IGZ1bmN0aW9uIHJlbW92ZUZlYXR1cmUgKGZlYXR1cmUpIHtcbiAgICB2YXIgZmVhdHVyZUtleSA9IGdldFVpZChmZWF0dXJlKTtcbiAgICBpZiAoZmVhdHVyZUtleSBpbiB0aGlzLm51bGxHZW9tZXRyeUZlYXR1cmVzXykge1xuICAgICAgZGVsZXRlIHRoaXMubnVsbEdlb21ldHJ5RmVhdHVyZXNfW2ZlYXR1cmVLZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5mZWF0dXJlc1J0cmVlXykge1xuICAgICAgICB0aGlzLmZlYXR1cmVzUnRyZWVfLnJlbW92ZShmZWF0dXJlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5yZW1vdmVGZWF0dXJlSW50ZXJuYWwoZmVhdHVyZSk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH07XG5cblxuICAvKipcbiAgICogUmVtb3ZlIGZlYXR1cmUgd2l0aG91dCBmaXJpbmcgYSBgY2hhbmdlYCBldmVudC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgVmVjdG9yU291cmNlLnByb3RvdHlwZS5yZW1vdmVGZWF0dXJlSW50ZXJuYWwgPSBmdW5jdGlvbiByZW1vdmVGZWF0dXJlSW50ZXJuYWwgKGZlYXR1cmUpIHtcbiAgICB2YXIgZmVhdHVyZUtleSA9IGdldFVpZChmZWF0dXJlKTtcbiAgICB0aGlzLmZlYXR1cmVDaGFuZ2VLZXlzX1tmZWF0dXJlS2V5XS5mb3JFYWNoKHVubGlzdGVuQnlLZXkpO1xuICAgIGRlbGV0ZSB0aGlzLmZlYXR1cmVDaGFuZ2VLZXlzX1tmZWF0dXJlS2V5XTtcbiAgICB2YXIgaWQgPSBmZWF0dXJlLmdldElkKCk7XG4gICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmlkSW5kZXhfW2lkLnRvU3RyaW5nKCldO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdGhpcy51bmRlZklkSW5kZXhfW2ZlYXR1cmVLZXldO1xuICAgIH1cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IFZlY3RvclNvdXJjZUV2ZW50KFxuICAgICAgVmVjdG9yRXZlbnRUeXBlLlJFTU9WRUZFQVRVUkUsIGZlYXR1cmUpKTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBmZWF0dXJlIGZyb20gdGhlIGlkIGluZGV4LiAgQ2FsbGVkIGludGVybmFsbHkgd2hlbiB0aGUgZmVhdHVyZSBpZFxuICAgKiBtYXkgaGF2ZSBjaGFuZ2VkLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBUaGUgZmVhdHVyZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gUmVtb3ZlZCB0aGUgZmVhdHVyZSBmcm9tIHRoZSBpbmRleC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFZlY3RvclNvdXJjZS5wcm90b3R5cGUucmVtb3ZlRnJvbUlkSW5kZXhfID0gZnVuY3Rpb24gcmVtb3ZlRnJvbUlkSW5kZXhfIChmZWF0dXJlKSB7XG4gICAgdmFyIHJlbW92ZWQgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpZCBpbiB0aGlzLmlkSW5kZXhfKSB7XG4gICAgICBpZiAodGhpcy5pZEluZGV4X1tpZF0gPT09IGZlYXR1cmUpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuaWRJbmRleF9baWRdO1xuICAgICAgICByZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZW1vdmVkO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbmV3IGxvYWRlciBvZiB0aGUgc291cmNlLiBUaGUgbmV4dCBsb2FkRmVhdHVyZXMgY2FsbCB3aWxsIHVzZSB0aGVcbiAgICogbmV3IGxvYWRlci5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9mZWF0dXJlbG9hZGVyLmpzXCIpLkZlYXR1cmVMb2FkZXJ9IGxvYWRlciBUaGUgbG9hZGVyIHRvIHNldC5cbiAgICogQGFwaVxuICAgKi9cbiAgVmVjdG9yU291cmNlLnByb3RvdHlwZS5zZXRMb2FkZXIgPSBmdW5jdGlvbiBzZXRMb2FkZXIgKGxvYWRlcikge1xuICAgIHRoaXMubG9hZGVyXyA9IGxvYWRlcjtcbiAgfTtcblxuICByZXR1cm4gVmVjdG9yU291cmNlO1xufShTb3VyY2UpKTtcblxuXG5leHBvcnQgZGVmYXVsdCBWZWN0b3JTb3VyY2U7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZlY3Rvci5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvc291cmNlL1ZlY3RvckV2ZW50VHlwZVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICAvKipcbiAgICogVHJpZ2dlcmVkIHdoZW4gYSBmZWF0dXJlIGlzIGFkZGVkIHRvIHRoZSBzb3VyY2UuXG4gICAqIEBldmVudCBvbC9zb3VyY2UvVmVjdG9yLlZlY3RvclNvdXJjZUV2ZW50I2FkZGZlYXR1cmVcbiAgICogQGFwaVxuICAgKi9cbiAgQURERkVBVFVSRTogJ2FkZGZlYXR1cmUnLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiBhIGZlYXR1cmUgaXMgdXBkYXRlZC5cbiAgICogQGV2ZW50IG9sL3NvdXJjZS9WZWN0b3IuVmVjdG9yU291cmNlRXZlbnQjY2hhbmdlZmVhdHVyZVxuICAgKiBAYXBpXG4gICAqL1xuICBDSEFOR0VGRUFUVVJFOiAnY2hhbmdlZmVhdHVyZScsXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB3aGVuIHRoZSBjbGVhciBtZXRob2QgaXMgY2FsbGVkIG9uIHRoZSBzb3VyY2UuXG4gICAqIEBldmVudCBvbC9zb3VyY2UvVmVjdG9yLlZlY3RvclNvdXJjZUV2ZW50I2NsZWFyXG4gICAqIEBhcGlcbiAgICovXG4gIENMRUFSOiAnY2xlYXInLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiBhIGZlYXR1cmUgaXMgcmVtb3ZlZCBmcm9tIHRoZSBzb3VyY2UuXG4gICAqIFNlZSB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3IjY2xlYXIgc291cmNlLmNsZWFyKCl9IGZvciBleGNlcHRpb25zLlxuICAgKiBAZXZlbnQgb2wvc291cmNlL1ZlY3Rvci5WZWN0b3JTb3VyY2VFdmVudCNyZW1vdmVmZWF0dXJlXG4gICAqIEBhcGlcbiAgICovXG4gIFJFTU9WRUZFQVRVUkU6ICdyZW1vdmVmZWF0dXJlJ1xufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VmVjdG9yRXZlbnRUeXBlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9zb3VyY2UvWFlaXG4gKi9cblxuaW1wb3J0IFRpbGVJbWFnZSBmcm9tICcuL1RpbGVJbWFnZS5qcyc7XG5pbXBvcnQge2NyZWF0ZVhZWiwgZXh0ZW50RnJvbVByb2plY3Rpb259IGZyb20gJy4uL3RpbGVncmlkLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vU291cmNlLmpzXCIpLkF0dHJpYnV0aW9uTGlrZX0gW2F0dHJpYnV0aW9uc10gQXR0cmlidXRpb25zLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbYXR0cmlidXRpb25zQ29sbGFwc2libGU9dHJ1ZV0gQXR0cmlidXRpb25zIGFyZSBjb2xsYXBzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY2FjaGVTaXplPTIwNDhdIENhY2hlIHNpemUuXG4gKiBAcHJvcGVydHkge251bGx8c3RyaW5nfSBbY3Jvc3NPcmlnaW5dIFRoZSBgY3Jvc3NPcmlnaW5gIGF0dHJpYnV0ZSBmb3IgbG9hZGVkIGltYWdlcy4gIE5vdGUgdGhhdFxuICogeW91IG11c3QgcHJvdmlkZSBhIGBjcm9zc09yaWdpbmAgdmFsdWUgaWYgeW91IGFyZSB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXIgb3IgaWYgeW91IHdhbnQgdG9cbiAqIGFjY2VzcyBwaXhlbCBkYXRhIHdpdGggdGhlIENhbnZhcyByZW5kZXJlci4gIFNlZVxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9DT1JTX2VuYWJsZWRfaW1hZ2UgZm9yIG1vcmUgZGV0YWlsLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbb3BhcXVlPXRydWVdIFdoZXRoZXIgdGhlIGxheWVyIGlzIG9wYXF1ZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gW3Byb2plY3Rpb249J0VQU0c6Mzg1NyddIFByb2plY3Rpb24uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JlcHJvamVjdGlvbkVycm9yVGhyZXNob2xkPTAuNV0gTWF4aW11bSBhbGxvd2VkIHJlcHJvamVjdGlvbiBlcnJvciAoaW4gcGl4ZWxzKS5cbiAqIEhpZ2hlciB2YWx1ZXMgY2FuIGluY3JlYXNlIHJlcHJvamVjdGlvbiBwZXJmb3JtYW5jZSwgYnV0IGRlY3JlYXNlIHByZWNpc2lvbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4Wm9vbT0xOF0gT3B0aW9uYWwgbWF4IHpvb20gbGV2ZWwuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pblpvb209MF0gT3B0aW9uYWwgbWluIHpvb20gbGV2ZWwuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9IFt0aWxlR3JpZF0gVGlsZSBncmlkLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLkxvYWRGdW5jdGlvbn0gW3RpbGVMb2FkRnVuY3Rpb25dIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGxvYWQgYSB0aWxlIGdpdmVuIGEgVVJMLiBUaGUgZGVmYXVsdCBpc1xuICogYGBganNcbiAqIGZ1bmN0aW9uKGltYWdlVGlsZSwgc3JjKSB7XG4gKiAgIGltYWdlVGlsZS5nZXRJbWFnZSgpLnNyYyA9IHNyYztcbiAqIH07XG4gKiBgYGBcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdGlsZVBpeGVsUmF0aW89MV0gVGhlIHBpeGVsIHJhdGlvIHVzZWQgYnkgdGhlIHRpbGUgc2VydmljZS5cbiAqIEZvciBleGFtcGxlLCBpZiB0aGUgdGlsZSBzZXJ2aWNlIGFkdmVydGl6ZXMgMjU2cHggYnkgMjU2cHggdGlsZXMgYnV0IGFjdHVhbGx5IHNlbmRzIDUxMnB4XG4gKiBieSA1MTJweCBpbWFnZXMgKGZvciByZXRpbmEvaGlkcGkgZGV2aWNlcykgdGhlbiBgdGlsZVBpeGVsUmF0aW9gXG4gKiBzaG91bGQgYmUgc2V0IHRvIGAyYC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gW3RpbGVTaXplPVsyNTYsIDI1Nl1dIFRoZSB0aWxlIHNpemUgdXNlZCBieSB0aGUgdGlsZSBzZXJ2aWNlLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLlVybEZ1bmN0aW9ufSBbdGlsZVVybEZ1bmN0aW9uXSBPcHRpb25hbCBmdW5jdGlvbiB0byBnZXRcbiAqIHRpbGUgVVJMIGdpdmVuIGEgdGlsZSBjb29yZGluYXRlIGFuZCB0aGUgcHJvamVjdGlvbi5cbiAqIFJlcXVpcmVkIGlmIHVybCBvciB1cmxzIGFyZSBub3QgcHJvdmlkZWQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3VybF0gVVJMIHRlbXBsYXRlLiBNdXN0IGluY2x1ZGUgYHt4fWAsIGB7eX1gIG9yIGB7LXl9YCxcbiAqIGFuZCBge3p9YCBwbGFjZWhvbGRlcnMuIEEgYHs/LT99YCB0ZW1wbGF0ZSBwYXR0ZXJuLCBmb3IgZXhhbXBsZSBgc3ViZG9tYWlue2EtZn0uZG9tYWluLmNvbWAsXG4gKiBtYXkgYmUgdXNlZCBpbnN0ZWFkIG9mIGRlZmluaW5nIGVhY2ggb25lIHNlcGFyYXRlbHkgaW4gdGhlIGB1cmxzYCBvcHRpb24uXG4gKiBAcHJvcGVydHkge0FycmF5PHN0cmluZz59IFt1cmxzXSBBbiBhcnJheSBvZiBVUkwgdGVtcGxhdGVzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbd3JhcFg9dHJ1ZV0gV2hldGhlciB0byB3cmFwIHRoZSB3b3JsZCBob3Jpem9udGFsbHkuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RyYW5zaXRpb25dIER1cmF0aW9uIG9mIHRoZSBvcGFjaXR5IHRyYW5zaXRpb24gZm9yIHJlbmRlcmluZy5cbiAqIFRvIGRpc2FibGUgdGhlIG9wYWNpdHkgdHJhbnNpdGlvbiwgcGFzcyBgdHJhbnNpdGlvbjogMGAuXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIExheWVyIHNvdXJjZSBmb3IgdGlsZSBkYXRhIHdpdGggVVJMcyBpbiBhIHNldCBYWVogZm9ybWF0IHRoYXQgYXJlXG4gKiBkZWZpbmVkIGluIGEgVVJMIHRlbXBsYXRlLiBCeSBkZWZhdWx0LCB0aGlzIGZvbGxvd3MgdGhlIHdpZGVseS11c2VkXG4gKiBHb29nbGUgZ3JpZCB3aGVyZSBgeGAgMCBhbmQgYHlgIDAgYXJlIGluIHRoZSB0b3AgbGVmdC4gR3JpZHMgbGlrZVxuICogVE1TIHdoZXJlIGB4YCAwIGFuZCBgeWAgMCBhcmUgaW4gdGhlIGJvdHRvbSBsZWZ0IGNhbiBiZSB1c2VkIGJ5XG4gKiB1c2luZyB0aGUgYHsteX1gIHBsYWNlaG9sZGVyIGluIHRoZSBVUkwgdGVtcGxhdGUsIHNvIGxvbmcgYXMgdGhlXG4gKiBzb3VyY2UgZG9lcyBub3QgaGF2ZSBhIGN1c3RvbSB0aWxlIGdyaWQuIEluIHRoaXMgY2FzZSxcbiAqIHtAbGluayBtb2R1bGU6b2wvc291cmNlL1RpbGVJbWFnZX0gY2FuIGJlIHVzZWQgd2l0aCBhIGB0aWxlVXJsRnVuY3Rpb25gXG4gKiBzdWNoIGFzOlxuICpcbiAqICB0aWxlVXJsRnVuY3Rpb246IGZ1bmN0aW9uKGNvb3JkaW5hdGUpIHtcbiAqICAgIHJldHVybiAnaHR0cDovL21hcHNlcnZlci5jb20vJyArIGNvb3JkaW5hdGVbMF0gKyAnLycgK1xuICogICAgICAgIGNvb3JkaW5hdGVbMV0gKyAnLycgKyBjb29yZGluYXRlWzJdICsgJy5wbmcnO1xuICogICAgfVxuICpcbiAqIEBhcGlcbiAqL1xudmFyIFhZWiA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFRpbGVJbWFnZSkge1xuICBmdW5jdGlvbiBYWVoob3B0X29wdGlvbnMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IG9wdF9vcHRpb25zIHx8IHt9O1xuICAgIHZhciBwcm9qZWN0aW9uID0gb3B0aW9ucy5wcm9qZWN0aW9uICE9PSB1bmRlZmluZWQgP1xuICAgICAgb3B0aW9ucy5wcm9qZWN0aW9uIDogJ0VQU0c6Mzg1Nyc7XG5cbiAgICB2YXIgdGlsZUdyaWQgPSBvcHRpb25zLnRpbGVHcmlkICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnRpbGVHcmlkIDpcbiAgICAgIGNyZWF0ZVhZWih7XG4gICAgICAgIGV4dGVudDogZXh0ZW50RnJvbVByb2plY3Rpb24ocHJvamVjdGlvbiksXG4gICAgICAgIG1heFpvb206IG9wdGlvbnMubWF4Wm9vbSxcbiAgICAgICAgbWluWm9vbTogb3B0aW9ucy5taW5ab29tLFxuICAgICAgICB0aWxlU2l6ZTogb3B0aW9ucy50aWxlU2l6ZVxuICAgICAgfSk7XG5cbiAgICBUaWxlSW1hZ2UuY2FsbCh0aGlzLCB7XG4gICAgICBhdHRyaWJ1dGlvbnM6IG9wdGlvbnMuYXR0cmlidXRpb25zLFxuICAgICAgY2FjaGVTaXplOiBvcHRpb25zLmNhY2hlU2l6ZSxcbiAgICAgIGNyb3NzT3JpZ2luOiBvcHRpb25zLmNyb3NzT3JpZ2luLFxuICAgICAgb3BhcXVlOiBvcHRpb25zLm9wYXF1ZSxcbiAgICAgIHByb2plY3Rpb246IHByb2plY3Rpb24sXG4gICAgICByZXByb2plY3Rpb25FcnJvclRocmVzaG9sZDogb3B0aW9ucy5yZXByb2plY3Rpb25FcnJvclRocmVzaG9sZCxcbiAgICAgIHRpbGVHcmlkOiB0aWxlR3JpZCxcbiAgICAgIHRpbGVMb2FkRnVuY3Rpb246IG9wdGlvbnMudGlsZUxvYWRGdW5jdGlvbixcbiAgICAgIHRpbGVQaXhlbFJhdGlvOiBvcHRpb25zLnRpbGVQaXhlbFJhdGlvLFxuICAgICAgdGlsZVVybEZ1bmN0aW9uOiBvcHRpb25zLnRpbGVVcmxGdW5jdGlvbixcbiAgICAgIHVybDogb3B0aW9ucy51cmwsXG4gICAgICB1cmxzOiBvcHRpb25zLnVybHMsXG4gICAgICB3cmFwWDogb3B0aW9ucy53cmFwWCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy53cmFwWCA6IHRydWUsXG4gICAgICB0cmFuc2l0aW9uOiBvcHRpb25zLnRyYW5zaXRpb24sXG4gICAgICBhdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZTogb3B0aW9ucy5hdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZVxuICAgIH0pO1xuXG4gIH1cblxuICBpZiAoIFRpbGVJbWFnZSApIFhZWi5fX3Byb3RvX18gPSBUaWxlSW1hZ2U7XG4gIFhZWi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUaWxlSW1hZ2UgJiYgVGlsZUltYWdlLnByb3RvdHlwZSApO1xuICBYWVoucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gWFlaO1xuXG4gIHJldHVybiBYWVo7XG59KFRpbGVJbWFnZSkpO1xuXG5leHBvcnQgZGVmYXVsdCBYWVo7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVhZWi5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBMYXRpdHVkZS9sb25naXR1ZGUgc3BoZXJpY2FsIGdlb2Rlc3kgZm9ybXVsYWUgdGFrZW4gZnJvbVxuICogaHR0cDovL3d3dy5tb3ZhYmxlLXR5cGUuY28udWsvc2NyaXB0cy9sYXRsb25nLmh0bWxcbiAqIExpY2Vuc2VkIHVuZGVyIENDLUJZLTMuMC5cbiAqL1xuXG4vKipcbiAqIEBtb2R1bGUgb2wvc3BoZXJlXG4gKi9cbmltcG9ydCB7dG9SYWRpYW5zLCB0b0RlZ3JlZXN9IGZyb20gJy4vbWF0aC5qcyc7XG5pbXBvcnQgR2VvbWV0cnlUeXBlIGZyb20gJy4vZ2VvbS9HZW9tZXRyeVR5cGUuanMnO1xuXG5cbi8qKlxuICogT2JqZWN0IGxpdGVyYWwgd2l0aCBvcHRpb25zIGZvciB0aGUge0BsaW5rIGdldExlbmd0aH0gb3Ige0BsaW5rIGdldEFyZWF9XG4gKiBmdW5jdGlvbnMuXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTcGhlcmVNZXRyaWNPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gW3Byb2plY3Rpb249J0VQU0c6Mzg1NyddXG4gKiBQcm9qZWN0aW9uIG9mIHRoZSAgZ2VvbWV0cnkuICBCeSBkZWZhdWx0LCB0aGUgZ2VvbWV0cnkgaXMgYXNzdW1lZCB0byBiZSBpblxuICogV2ViIE1lcmNhdG9yLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyYWRpdXM9NjM3MTAwOC44XSBTcGhlcmUgcmFkaXVzLiAgQnkgZGVmYXVsdCwgdGhlIHJhZGl1cyBvZiB0aGVcbiAqIGVhcnRoIGlzIHVzZWQgKENsYXJrZSAxODY2IEF1dGhhbGljIFNwaGVyZSkuXG4gKi9cblxuXG4vKipcbiAqIFRoZSBtZWFuIEVhcnRoIHJhZGl1cyAoMS8zICogKDJhICsgYikpIGZvciB0aGUgV0dTODQgZWxsaXBzb2lkLlxuICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRWFydGhfcmFkaXVzI01lYW5fcmFkaXVzXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIERFRkFVTFRfUkFESVVTID0gNjM3MTAwOC44O1xuXG5cbi8qKlxuICogR2V0IHRoZSBncmVhdCBjaXJjbGUgZGlzdGFuY2UgKGluIG1ldGVycykgYmV0d2VlbiB0d28gZ2VvZ3JhcGhpYyBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7QXJyYXl9IGMxIFN0YXJ0aW5nIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge0FycmF5fSBjMiBFbmRpbmcgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X3JhZGl1cyBUaGUgc3BoZXJlIHJhZGl1cyB0byB1c2UuICBEZWZhdWx0cyB0byB0aGUgRWFydGgnc1xuICogICAgIG1lYW4gcmFkaXVzIHVzaW5nIHRoZSBXR1M4NCBlbGxpcHNvaWQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBncmVhdCBjaXJjbGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgcG9pbnRzIChpbiBtZXRlcnMpLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlzdGFuY2UoYzEsIGMyLCBvcHRfcmFkaXVzKSB7XG4gIHZhciByYWRpdXMgPSBvcHRfcmFkaXVzIHx8IERFRkFVTFRfUkFESVVTO1xuICB2YXIgbGF0MSA9IHRvUmFkaWFucyhjMVsxXSk7XG4gIHZhciBsYXQyID0gdG9SYWRpYW5zKGMyWzFdKTtcbiAgdmFyIGRlbHRhTGF0QnkyID0gKGxhdDIgLSBsYXQxKSAvIDI7XG4gIHZhciBkZWx0YUxvbkJ5MiA9IHRvUmFkaWFucyhjMlswXSAtIGMxWzBdKSAvIDI7XG4gIHZhciBhID0gTWF0aC5zaW4oZGVsdGFMYXRCeTIpICogTWF0aC5zaW4oZGVsdGFMYXRCeTIpICtcbiAgICAgIE1hdGguc2luKGRlbHRhTG9uQnkyKSAqIE1hdGguc2luKGRlbHRhTG9uQnkyKSAqXG4gICAgICBNYXRoLmNvcyhsYXQxKSAqIE1hdGguY29zKGxhdDIpO1xuICByZXR1cm4gMiAqIHJhZGl1cyAqIE1hdGguYXRhbjIoTWF0aC5zcXJ0KGEpLCBNYXRoLnNxcnQoMSAtIGEpKTtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgY3VtdWxhdGl2ZSBncmVhdCBjaXJjbGUgbGVuZ3RoIG9mIGxpbmVzdHJpbmcgY29vcmRpbmF0ZXMgKGdlb2dyYXBoaWMpLlxuICogQHBhcmFtIHtBcnJheX0gY29vcmRpbmF0ZXMgTGluZXN0cmluZyBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgVGhlIHNwaGVyZSByYWRpdXMgdG8gdXNlLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbGVuZ3RoIChpbiBtZXRlcnMpLlxuICovXG5mdW5jdGlvbiBnZXRMZW5ndGhJbnRlcm5hbChjb29yZGluYXRlcywgcmFkaXVzKSB7XG4gIHZhciBsZW5ndGggPSAwO1xuICBmb3IgKHZhciBpID0gMCwgaWkgPSBjb29yZGluYXRlcy5sZW5ndGg7IGkgPCBpaSAtIDE7ICsraSkge1xuICAgIGxlbmd0aCArPSBnZXREaXN0YW5jZShjb29yZGluYXRlc1tpXSwgY29vcmRpbmF0ZXNbaSArIDFdLCByYWRpdXMpO1xuICB9XG4gIHJldHVybiBsZW5ndGg7XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIHNwaGVyaWNhbCBsZW5ndGggb2YgYSBnZW9tZXRyeS4gIFRoaXMgbGVuZ3RoIGlzIHRoZSBzdW0gb2YgdGhlXG4gKiBncmVhdCBjaXJjbGUgZGlzdGFuY2VzIGJldHdlZW4gY29vcmRpbmF0ZXMuICBGb3IgcG9seWdvbnMsIHRoZSBsZW5ndGggaXNcbiAqIHRoZSBzdW0gb2YgYWxsIHJpbmdzLiAgRm9yIHBvaW50cywgdGhlIGxlbmd0aCBpcyB6ZXJvLiAgRm9yIG11bHRpLXBhcnRcbiAqIGdlb21ldHJpZXMsIHRoZSBsZW5ndGggaXMgdGhlIHN1bSBvZiB0aGUgbGVuZ3RoIG9mIGVhY2ggcGFydC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEEgZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge1NwaGVyZU1ldHJpY09wdGlvbnM9fSBvcHRfb3B0aW9ucyBPcHRpb25zIGZvciB0aGVcbiAqIGxlbmd0aCBjYWxjdWxhdGlvbi4gIEJ5IGRlZmF1bHQsIGdlb21ldHJpZXMgYXJlIGFzc3VtZWQgdG8gYmUgaW4gJ0VQU0c6Mzg1NycuXG4gKiBZb3UgY2FuIGNoYW5nZSB0aGlzIGJ5IHByb3ZpZGluZyBhIGBwcm9qZWN0aW9uYCBvcHRpb24uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzcGhlcmljYWwgbGVuZ3RoIChpbiBtZXRlcnMpLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGVuZ3RoKGdlb21ldHJ5LCBvcHRfb3B0aW9ucykge1xuICB2YXIgb3B0aW9ucyA9IG9wdF9vcHRpb25zIHx8IHt9O1xuICB2YXIgcmFkaXVzID0gb3B0aW9ucy5yYWRpdXMgfHwgREVGQVVMVF9SQURJVVM7XG4gIHZhciBwcm9qZWN0aW9uID0gb3B0aW9ucy5wcm9qZWN0aW9uIHx8ICdFUFNHOjM4NTcnO1xuICB2YXIgdHlwZSA9IGdlb21ldHJ5LmdldFR5cGUoKTtcbiAgaWYgKHR5cGUgIT09IEdlb21ldHJ5VHlwZS5HRU9NRVRSWV9DT0xMRUNUSU9OKSB7XG4gICAgZ2VvbWV0cnkgPSBnZW9tZXRyeS5jbG9uZSgpLnRyYW5zZm9ybShwcm9qZWN0aW9uLCAnRVBTRzo0MzI2Jyk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IDA7XG4gIHZhciBjb29yZGluYXRlcywgY29vcmRzLCBpLCBpaSwgaiwgamo7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgR2VvbWV0cnlUeXBlLlBPSU5UOlxuICAgIGNhc2UgR2VvbWV0cnlUeXBlLk1VTFRJX1BPSU5UOiB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBHZW9tZXRyeVR5cGUuTElORV9TVFJJTkc6XG4gICAgY2FzZSBHZW9tZXRyeVR5cGUuTElORUFSX1JJTkc6IHtcbiAgICAgIGNvb3JkaW5hdGVzID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL2dlb20vU2ltcGxlR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gKi8gKGdlb21ldHJ5KS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgbGVuZ3RoID0gZ2V0TGVuZ3RoSW50ZXJuYWwoY29vcmRpbmF0ZXMsIHJhZGl1cyk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBHZW9tZXRyeVR5cGUuTVVMVElfTElORV9TVFJJTkc6XG4gICAgY2FzZSBHZW9tZXRyeVR5cGUuUE9MWUdPTjoge1xuICAgICAgY29vcmRpbmF0ZXMgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSAqLyAoZ2VvbWV0cnkpLmdldENvb3JkaW5hdGVzKCk7XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgbGVuZ3RoICs9IGdldExlbmd0aEludGVybmFsKGNvb3JkaW5hdGVzW2ldLCByYWRpdXMpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgR2VvbWV0cnlUeXBlLk1VTFRJX1BPTFlHT046IHtcbiAgICAgIGNvb3JkaW5hdGVzID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL2dlb20vU2ltcGxlR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gKi8gKGdlb21ldHJ5KS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgZm9yIChpID0gMCwgaWkgPSBjb29yZGluYXRlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGNvb3JkcyA9IGNvb3JkaW5hdGVzW2ldO1xuICAgICAgICBmb3IgKGogPSAwLCBqaiA9IGNvb3Jkcy5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgICAgICAgbGVuZ3RoICs9IGdldExlbmd0aEludGVybmFsKGNvb3Jkc1tqXSwgcmFkaXVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgR2VvbWV0cnlUeXBlLkdFT01FVFJZX0NPTExFQ1RJT046IHtcbiAgICAgIHZhciBnZW9tZXRyaWVzID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL2dlb20vR2VvbWV0cnlDb2xsZWN0aW9uLmpzXCIpLmRlZmF1bHR9ICovIChnZW9tZXRyeSkuZ2V0R2VvbWV0cmllcygpO1xuICAgICAgZm9yIChpID0gMCwgaWkgPSBnZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgbGVuZ3RoICs9IGdldExlbmd0aChnZW9tZXRyaWVzW2ldLCBvcHRfb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBnZW9tZXRyeSB0eXBlOiAnICsgdHlwZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBsZW5ndGg7XG59XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzcGhlcmljYWwgYXJlYSBmb3IgYSBsaXN0IG9mIGNvb3JkaW5hdGVzLlxuICpcbiAqIFtSZWZlcmVuY2VdKGh0dHBzOi8vdHJzLW5ldy5qcGwubmFzYS5nb3YvaGFuZGxlLzIwMTQvNDA0MDkpXG4gKiBSb2JlcnQuIEcuIENoYW1iZXJsYWluIGFuZCBXaWxsaWFtIEguIER1cXVldHRlLCBcIlNvbWUgQWxnb3JpdGhtcyBmb3JcbiAqIFBvbHlnb25zIG9uIGEgU3BoZXJlXCIsIEpQTCBQdWJsaWNhdGlvbiAwNy0wMywgSmV0IFByb3B1bHNpb25cbiAqIExhYm9yYXRvcnksIFBhc2FkZW5hLCBDQSwgSnVuZSAyMDA3XG4gKlxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59IGNvb3JkaW5hdGVzIExpc3Qgb2YgY29vcmRpbmF0ZXMgb2YgYSBsaW5lYXJcbiAqIHJpbmcuIElmIHRoZSByaW5nIGlzIG9yaWVudGVkIGNsb2Nrd2lzZSwgdGhlIGFyZWEgd2lsbCBiZSBwb3NpdGl2ZSxcbiAqIG90aGVyd2lzZSBpdCB3aWxsIGJlIG5lZ2F0aXZlLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBUaGUgc3BoZXJlIHJhZGl1cy5cbiAqIEByZXR1cm4ge251bWJlcn0gQXJlYSAoaW4gc3F1YXJlIG1ldGVycykuXG4gKi9cbmZ1bmN0aW9uIGdldEFyZWFJbnRlcm5hbChjb29yZGluYXRlcywgcmFkaXVzKSB7XG4gIHZhciBhcmVhID0gMDtcbiAgdmFyIGxlbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgdmFyIHgxID0gY29vcmRpbmF0ZXNbbGVuIC0gMV1bMF07XG4gIHZhciB5MSA9IGNvb3JkaW5hdGVzW2xlbiAtIDFdWzFdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHgyID0gY29vcmRpbmF0ZXNbaV1bMF07XG4gICAgdmFyIHkyID0gY29vcmRpbmF0ZXNbaV1bMV07XG4gICAgYXJlYSArPSB0b1JhZGlhbnMoeDIgLSB4MSkgKlxuICAgICAgICAoMiArIE1hdGguc2luKHRvUmFkaWFucyh5MSkpICtcbiAgICAgICAgTWF0aC5zaW4odG9SYWRpYW5zKHkyKSkpO1xuICAgIHgxID0geDI7XG4gICAgeTEgPSB5MjtcbiAgfVxuICByZXR1cm4gYXJlYSAqIHJhZGl1cyAqIHJhZGl1cyAvIDIuMDtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgc3BoZXJpY2FsIGFyZWEgb2YgYSBnZW9tZXRyeS4gIFRoaXMgaXMgdGhlIGFyZWEgKGluIG1ldGVycykgYXNzdW1pbmdcbiAqIHRoYXQgcG9seWdvbiBlZGdlcyBhcmUgc2VnbWVudHMgb2YgZ3JlYXQgY2lyY2xlcyBvbiBhIHNwaGVyZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEEgZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge1NwaGVyZU1ldHJpY09wdGlvbnM9fSBvcHRfb3B0aW9ucyBPcHRpb25zIGZvciB0aGUgYXJlYVxuICogICAgIGNhbGN1bGF0aW9uLiAgQnkgZGVmYXVsdCwgZ2VvbWV0cmllcyBhcmUgYXNzdW1lZCB0byBiZSBpbiAnRVBTRzozODU3Jy5cbiAqICAgICBZb3UgY2FuIGNoYW5nZSB0aGlzIGJ5IHByb3ZpZGluZyBhIGBwcm9qZWN0aW9uYCBvcHRpb24uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzcGhlcmljYWwgYXJlYSAoaW4gc3F1YXJlIG1ldGVycykuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBcmVhKGdlb21ldHJ5LCBvcHRfb3B0aW9ucykge1xuICB2YXIgb3B0aW9ucyA9IG9wdF9vcHRpb25zIHx8IHt9O1xuICB2YXIgcmFkaXVzID0gb3B0aW9ucy5yYWRpdXMgfHwgREVGQVVMVF9SQURJVVM7XG4gIHZhciBwcm9qZWN0aW9uID0gb3B0aW9ucy5wcm9qZWN0aW9uIHx8ICdFUFNHOjM4NTcnO1xuICB2YXIgdHlwZSA9IGdlb21ldHJ5LmdldFR5cGUoKTtcbiAgaWYgKHR5cGUgIT09IEdlb21ldHJ5VHlwZS5HRU9NRVRSWV9DT0xMRUNUSU9OKSB7XG4gICAgZ2VvbWV0cnkgPSBnZW9tZXRyeS5jbG9uZSgpLnRyYW5zZm9ybShwcm9qZWN0aW9uLCAnRVBTRzo0MzI2Jyk7XG4gIH1cbiAgdmFyIGFyZWEgPSAwO1xuICB2YXIgY29vcmRpbmF0ZXMsIGNvb3JkcywgaSwgaWksIGosIGpqO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIEdlb21ldHJ5VHlwZS5QT0lOVDpcbiAgICBjYXNlIEdlb21ldHJ5VHlwZS5NVUxUSV9QT0lOVDpcbiAgICBjYXNlIEdlb21ldHJ5VHlwZS5MSU5FX1NUUklORzpcbiAgICBjYXNlIEdlb21ldHJ5VHlwZS5NVUxUSV9MSU5FX1NUUklORzpcbiAgICBjYXNlIEdlb21ldHJ5VHlwZS5MSU5FQVJfUklORzoge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgR2VvbWV0cnlUeXBlLlBPTFlHT046IHtcbiAgICAgIGNvb3JkaW5hdGVzID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL2dlb20vUG9seWdvbi5qc1wiKS5kZWZhdWx0fSAqLyAoZ2VvbWV0cnkpLmdldENvb3JkaW5hdGVzKCk7XG4gICAgICBhcmVhID0gTWF0aC5hYnMoZ2V0QXJlYUludGVybmFsKGNvb3JkaW5hdGVzWzBdLCByYWRpdXMpKTtcbiAgICAgIGZvciAoaSA9IDEsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBhcmVhIC09IE1hdGguYWJzKGdldEFyZWFJbnRlcm5hbChjb29yZGluYXRlc1tpXSwgcmFkaXVzKSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBHZW9tZXRyeVR5cGUuTVVMVElfUE9MWUdPTjoge1xuICAgICAgY29vcmRpbmF0ZXMgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSAqLyAoZ2VvbWV0cnkpLmdldENvb3JkaW5hdGVzKCk7XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgY29vcmRzID0gY29vcmRpbmF0ZXNbaV07XG4gICAgICAgIGFyZWEgKz0gTWF0aC5hYnMoZ2V0QXJlYUludGVybmFsKGNvb3Jkc1swXSwgcmFkaXVzKSk7XG4gICAgICAgIGZvciAoaiA9IDEsIGpqID0gY29vcmRzLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICAgICAgICBhcmVhIC09IE1hdGguYWJzKGdldEFyZWFJbnRlcm5hbChjb29yZHNbal0sIHJhZGl1cykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBHZW9tZXRyeVR5cGUuR0VPTUVUUllfQ09MTEVDVElPTjoge1xuICAgICAgdmFyIGdlb21ldHJpZXMgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vZ2VvbS9HZW9tZXRyeUNvbGxlY3Rpb24uanNcIikuZGVmYXVsdH0gKi8gKGdlb21ldHJ5KS5nZXRHZW9tZXRyaWVzKCk7XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IGdlb21ldHJpZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBhcmVhICs9IGdldEFyZWEoZ2VvbWV0cmllc1tpXSwgb3B0X29wdGlvbnMpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgZ2VvbWV0cnkgdHlwZTogJyArIHR5cGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJlYTtcbn1cblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGNvb3JkaW5hdGUgYXQgdGhlIGdpdmVuIGRpc3RhbmNlIGFuZCBiZWFyaW5nIGZyb20gYGMxYC5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjMSBUaGUgb3JpZ2luIHBvaW50IChgW2xvbiwgbGF0XWAgaW4gZGVncmVlcykuXG4gKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2UgVGhlIGdyZWF0LWNpcmNsZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBvcmlnaW5cbiAqICAgICBwb2ludCBhbmQgdGhlIHRhcmdldCBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiZWFyaW5nIFRoZSBiZWFyaW5nIChpbiByYWRpYW5zKS5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X3JhZGl1cyBUaGUgc3BoZXJlIHJhZGl1cyB0byB1c2UuICBEZWZhdWx0cyB0byB0aGUgRWFydGgnc1xuICogICAgIG1lYW4gcmFkaXVzIHVzaW5nIHRoZSBXR1M4NCBlbGxpcHNvaWQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gVGhlIHRhcmdldCBwb2ludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9mZnNldChjMSwgZGlzdGFuY2UsIGJlYXJpbmcsIG9wdF9yYWRpdXMpIHtcbiAgdmFyIHJhZGl1cyA9IG9wdF9yYWRpdXMgfHwgREVGQVVMVF9SQURJVVM7XG4gIHZhciBsYXQxID0gdG9SYWRpYW5zKGMxWzFdKTtcbiAgdmFyIGxvbjEgPSB0b1JhZGlhbnMoYzFbMF0pO1xuICB2YXIgZEJ5UiA9IGRpc3RhbmNlIC8gcmFkaXVzO1xuICB2YXIgbGF0ID0gTWF0aC5hc2luKFxuICAgIE1hdGguc2luKGxhdDEpICogTWF0aC5jb3MoZEJ5UikgK1xuICAgICAgTWF0aC5jb3MobGF0MSkgKiBNYXRoLnNpbihkQnlSKSAqIE1hdGguY29zKGJlYXJpbmcpKTtcbiAgdmFyIGxvbiA9IGxvbjEgKyBNYXRoLmF0YW4yKFxuICAgIE1hdGguc2luKGJlYXJpbmcpICogTWF0aC5zaW4oZEJ5UikgKiBNYXRoLmNvcyhsYXQxKSxcbiAgICBNYXRoLmNvcyhkQnlSKSAtIE1hdGguc2luKGxhdDEpICogTWF0aC5zaW4obGF0KSk7XG4gIHJldHVybiBbdG9EZWdyZWVzKGxvbiksIHRvRGVncmVlcyhsYXQpXTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3BoZXJlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9zdHJpbmdcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgTnVtYmVyIHRvIGJlIGZvcm1hdHRlZFxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFRoZSBkZXNpcmVkIHdpZHRoXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9wcmVjaXNpb24gUHJlY2lzaW9uIG9mIHRoZSBvdXRwdXQgc3RyaW5nIChpLmUuIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcylcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEZvcm1hdHRlZCBzdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhZE51bWJlcihudW1iZXIsIHdpZHRoLCBvcHRfcHJlY2lzaW9uKSB7XG4gIHZhciBudW1iZXJTdHJpbmcgPSBvcHRfcHJlY2lzaW9uICE9PSB1bmRlZmluZWQgPyBudW1iZXIudG9GaXhlZChvcHRfcHJlY2lzaW9uKSA6ICcnICsgbnVtYmVyO1xuICB2YXIgZGVjaW1hbCA9IG51bWJlclN0cmluZy5pbmRleE9mKCcuJyk7XG4gIGRlY2ltYWwgPSBkZWNpbWFsID09PSAtMSA/IG51bWJlclN0cmluZy5sZW5ndGggOiBkZWNpbWFsO1xuICByZXR1cm4gZGVjaW1hbCA+IHdpZHRoID8gbnVtYmVyU3RyaW5nIDogbmV3IEFycmF5KDEgKyB3aWR0aCAtIGRlY2ltYWwpLmpvaW4oJzAnKSArIG51bWJlclN0cmluZztcbn1cblxuXG4vKipcbiAqIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vb21pY2hlbHNlbi9jb21wYXJlLXZlcnNpb25zL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHYxIEZpcnN0IHZlcnNpb25cbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdjIgU2Vjb25kIHZlcnNpb25cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlVmVyc2lvbnModjEsIHYyKSB7XG4gIHZhciBzMSA9ICgnJyArIHYxKS5zcGxpdCgnLicpO1xuICB2YXIgczIgPSAoJycgKyB2Mikuc3BsaXQoJy4nKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IE1hdGgubWF4KHMxLmxlbmd0aCwgczIubGVuZ3RoKTsgaSsrKSB7XG4gICAgdmFyIG4xID0gcGFyc2VJbnQoczFbaV0gfHwgJzAnLCAxMCk7XG4gICAgdmFyIG4yID0gcGFyc2VJbnQoczJbaV0gfHwgJzAnLCAxMCk7XG5cbiAgICBpZiAobjEgPiBuMikge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGlmIChuMiA+IG4xKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmluZy5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvc3RydWN0cy9MUlVDYWNoZVxuICovXG5cbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuLi9hc3NlcnRzLmpzJztcbmltcG9ydCBFdmVudFRhcmdldCBmcm9tICcuLi9ldmVudHMvVGFyZ2V0LmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBFbnRyeVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGtleV9cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBuZXdlclxuICogQHByb3BlcnR5IHtPYmplY3R9IG9sZGVyXG4gKiBAcHJvcGVydHkgeyp9IHZhbHVlX1xuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBJbXBsZW1lbnRzIGEgTGVhc3QtUmVjZW50bHktVXNlZCBjYWNoZSB3aGVyZSB0aGUga2V5cyBkbyBub3QgY29uZmxpY3Qgd2l0aFxuICogT2JqZWN0J3MgcHJvcGVydGllcyAoZS5nLiAnaGFzT3duUHJvcGVydHknIGlzIG5vdCBhbGxvd2VkIGFzIGEga2V5KS4gRXhwaXJpbmdcbiAqIGl0ZW1zIGZyb20gdGhlIGNhY2hlIGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZiB0aGUgdXNlci5cbiAqXG4gKiBAZmlyZXMgaW1wb3J0KFwiLi4vZXZlbnRzL0V2ZW50LmpzXCIpLkV2ZW50XG4gKiBAdGVtcGxhdGUgVFxuICovXG52YXIgTFJVQ2FjaGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChFdmVudFRhcmdldCkge1xuICBmdW5jdGlvbiBMUlVDYWNoZShvcHRfaGlnaFdhdGVyTWFyaykge1xuXG4gICAgRXZlbnRUYXJnZXQuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gb3B0X2hpZ2hXYXRlck1hcmsgIT09IHVuZGVmaW5lZCA/IG9wdF9oaWdoV2F0ZXJNYXJrIDogMjA0ODtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmNvdW50XyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgRW50cnk+fVxuICAgICAqL1xuICAgIHRoaXMuZW50cmllc18gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9FbnRyeX1cbiAgICAgKi9cbiAgICB0aGlzLm9sZGVzdF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P0VudHJ5fVxuICAgICAqL1xuICAgIHRoaXMubmV3ZXN0XyA9IG51bGw7XG5cbiAgfVxuXG4gIGlmICggRXZlbnRUYXJnZXQgKSBMUlVDYWNoZS5fX3Byb3RvX18gPSBFdmVudFRhcmdldDtcbiAgTFJVQ2FjaGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXZlbnRUYXJnZXQgJiYgRXZlbnRUYXJnZXQucHJvdG90eXBlICk7XG4gIExSVUNhY2hlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExSVUNhY2hlO1xuXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IENhbiBleHBpcmUgY2FjaGUuXG4gICAqL1xuICBMUlVDYWNoZS5wcm90b3R5cGUuY2FuRXhwaXJlQ2FjaGUgPSBmdW5jdGlvbiBjYW5FeHBpcmVDYWNoZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q291bnQoKSA+IHRoaXMuaGlnaFdhdGVyTWFyaztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBGSVhNRSBlbXB0eSBkZXNjcmlwdGlvbiBmb3IganNkb2NcbiAgICovXG4gIExSVUNhY2hlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICB0aGlzLmNvdW50XyA9IDA7XG4gICAgdGhpcy5lbnRyaWVzXyA9IHt9O1xuICAgIHRoaXMub2xkZXN0XyA9IG51bGw7XG4gICAgdGhpcy5uZXdlc3RfID0gbnVsbDtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRUeXBlLkNMRUFSKTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gQ29udGFpbnMga2V5LlxuICAgKi9cbiAgTFJVQ2FjaGUucHJvdG90eXBlLmNvbnRhaW5zS2V5ID0gZnVuY3Rpb24gY29udGFpbnNLZXkgKGtleSkge1xuICAgIHJldHVybiB0aGlzLmVudHJpZXNfLmhhc093blByb3BlcnR5KGtleSk7XG4gIH07XG5cblxuICAvKipcbiAgICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBTLCBULCBzdHJpbmcsIExSVUNhY2hlKTogP30gZiBUaGUgZnVuY3Rpb25cbiAgICogICAgIHRvIGNhbGwgZm9yIGV2ZXJ5IGVudHJ5IGZyb20gdGhlIG9sZGVzdCB0byB0aGUgbmV3ZXIuIFRoaXMgZnVuY3Rpb24gdGFrZXNcbiAgICogICAgIDMgYXJndW1lbnRzICh0aGUgZW50cnkgdmFsdWUsIHRoZSBlbnRyeSBrZXkgYW5kIHRoZSBMUlVDYWNoZSBvYmplY3QpLlxuICAgKiAgICAgVGhlIHJldHVybiB2YWx1ZSBpcyBpZ25vcmVkLlxuICAgKiBAcGFyYW0ge1M9fSBvcHRfdGhpcyBUaGUgb2JqZWN0IHRvIHVzZSBhcyBgdGhpc2AgaW4gYGZgLlxuICAgKiBAdGVtcGxhdGUgU1xuICAgKi9cbiAgTFJVQ2FjaGUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoIChmLCBvcHRfdGhpcykge1xuICAgIHZhciBlbnRyeSA9IHRoaXMub2xkZXN0XztcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGYuY2FsbChvcHRfdGhpcywgZW50cnkudmFsdWVfLCBlbnRyeS5rZXlfLCB0aGlzKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV3ZXI7XG4gICAgfVxuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgS2V5LlxuICAgKiBAcmV0dXJuIHtUfSBWYWx1ZS5cbiAgICovXG4gIExSVUNhY2hlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKGtleSkge1xuICAgIHZhciBlbnRyeSA9IHRoaXMuZW50cmllc19ba2V5XTtcbiAgICBhc3NlcnQoZW50cnkgIT09IHVuZGVmaW5lZCxcbiAgICAgIDE1KTsgLy8gVHJpZWQgdG8gZ2V0IGEgdmFsdWUgZm9yIGEga2V5IHRoYXQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGNhY2hlXG4gICAgaWYgKGVudHJ5ID09PSB0aGlzLm5ld2VzdF8pIHtcbiAgICAgIHJldHVybiBlbnRyeS52YWx1ZV87XG4gICAgfSBlbHNlIGlmIChlbnRyeSA9PT0gdGhpcy5vbGRlc3RfKSB7XG4gICAgICB0aGlzLm9sZGVzdF8gPSAvKiogQHR5cGUge0VudHJ5fSAqLyAodGhpcy5vbGRlc3RfLm5ld2VyKTtcbiAgICAgIHRoaXMub2xkZXN0Xy5vbGRlciA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVudHJ5Lm5ld2VyLm9sZGVyID0gZW50cnkub2xkZXI7XG4gICAgICBlbnRyeS5vbGRlci5uZXdlciA9IGVudHJ5Lm5ld2VyO1xuICAgIH1cbiAgICBlbnRyeS5uZXdlciA9IG51bGw7XG4gICAgZW50cnkub2xkZXIgPSB0aGlzLm5ld2VzdF87XG4gICAgdGhpcy5uZXdlc3RfLm5ld2VyID0gZW50cnk7XG4gICAgdGhpcy5uZXdlc3RfID0gZW50cnk7XG4gICAgcmV0dXJuIGVudHJ5LnZhbHVlXztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gZW50cnkgZnJvbSB0aGUgY2FjaGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGVudHJ5IGtleS5cbiAgICogQHJldHVybiB7VH0gVGhlIHJlbW92ZWQgZW50cnkuXG4gICAqL1xuICBMUlVDYWNoZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlIChrZXkpIHtcbiAgICB2YXIgZW50cnkgPSB0aGlzLmVudHJpZXNfW2tleV07XG4gICAgYXNzZXJ0KGVudHJ5ICE9PSB1bmRlZmluZWQsIDE1KTsgLy8gVHJpZWQgdG8gZ2V0IGEgdmFsdWUgZm9yIGEga2V5IHRoYXQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGNhY2hlXG4gICAgaWYgKGVudHJ5ID09PSB0aGlzLm5ld2VzdF8pIHtcbiAgICAgIHRoaXMubmV3ZXN0XyA9IC8qKiBAdHlwZSB7RW50cnl9ICovIChlbnRyeS5vbGRlcik7XG4gICAgICBpZiAodGhpcy5uZXdlc3RfKSB7XG4gICAgICAgIHRoaXMubmV3ZXN0Xy5uZXdlciA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbnRyeSA9PT0gdGhpcy5vbGRlc3RfKSB7XG4gICAgICB0aGlzLm9sZGVzdF8gPSAvKiogQHR5cGUge0VudHJ5fSAqLyAoZW50cnkubmV3ZXIpO1xuICAgICAgaWYgKHRoaXMub2xkZXN0Xykge1xuICAgICAgICB0aGlzLm9sZGVzdF8ub2xkZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbnRyeS5uZXdlci5vbGRlciA9IGVudHJ5Lm9sZGVyO1xuICAgICAgZW50cnkub2xkZXIubmV3ZXIgPSBlbnRyeS5uZXdlcjtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuZW50cmllc19ba2V5XTtcbiAgICAtLXRoaXMuY291bnRfO1xuICAgIHJldHVybiBlbnRyeS52YWx1ZV87XG4gIH07XG5cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBDb3VudC5cbiAgICovXG4gIExSVUNhY2hlLnByb3RvdHlwZS5nZXRDb3VudCA9IGZ1bmN0aW9uIGdldENvdW50ICgpIHtcbiAgICByZXR1cm4gdGhpcy5jb3VudF87XG4gIH07XG5cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8c3RyaW5nPn0gS2V5cy5cbiAgICovXG4gIExSVUNhY2hlLnByb3RvdHlwZS5nZXRLZXlzID0gZnVuY3Rpb24gZ2V0S2V5cyAoKSB7XG4gICAgdmFyIGtleXMgPSBuZXcgQXJyYXkodGhpcy5jb3VudF8pO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgZW50cnk7XG4gICAgZm9yIChlbnRyeSA9IHRoaXMubmV3ZXN0XzsgZW50cnk7IGVudHJ5ID0gZW50cnkub2xkZXIpIHtcbiAgICAgIGtleXNbaSsrXSA9IGVudHJ5LmtleV87XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PFQ+fSBWYWx1ZXMuXG4gICAqL1xuICBMUlVDYWNoZS5wcm90b3R5cGUuZ2V0VmFsdWVzID0gZnVuY3Rpb24gZ2V0VmFsdWVzICgpIHtcbiAgICB2YXIgdmFsdWVzID0gbmV3IEFycmF5KHRoaXMuY291bnRfKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGVudHJ5O1xuICAgIGZvciAoZW50cnkgPSB0aGlzLm5ld2VzdF87IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm9sZGVyKSB7XG4gICAgICB2YWx1ZXNbaSsrXSA9IGVudHJ5LnZhbHVlXztcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtUfSBMYXN0IHZhbHVlLlxuICAgKi9cbiAgTFJVQ2FjaGUucHJvdG90eXBlLnBlZWtMYXN0ID0gZnVuY3Rpb24gcGVla0xhc3QgKCkge1xuICAgIHJldHVybiB0aGlzLm9sZGVzdF8udmFsdWVfO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTGFzdCBrZXkuXG4gICAqL1xuICBMUlVDYWNoZS5wcm90b3R5cGUucGVla0xhc3RLZXkgPSBmdW5jdGlvbiBwZWVrTGFzdEtleSAoKSB7XG4gICAgcmV0dXJuIHRoaXMub2xkZXN0Xy5rZXlfO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEdldCB0aGUga2V5IG9mIHRoZSBuZXdlc3QgaXRlbSBpbiB0aGUgY2FjaGUuICBUaHJvd3MgaWYgdGhlIGNhY2hlIGlzIGVtcHR5LlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBuZXdlc3Qga2V5LlxuICAgKi9cbiAgTFJVQ2FjaGUucHJvdG90eXBlLnBlZWtGaXJzdEtleSA9IGZ1bmN0aW9uIHBlZWtGaXJzdEtleSAoKSB7XG4gICAgcmV0dXJuIHRoaXMubmV3ZXN0Xy5rZXlfO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1R9IHZhbHVlIFZhbHVlLlxuICAgKi9cbiAgTFJVQ2FjaGUucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uIHBvcCAoKSB7XG4gICAgdmFyIGVudHJ5ID0gdGhpcy5vbGRlc3RfO1xuICAgIGRlbGV0ZSB0aGlzLmVudHJpZXNfW2VudHJ5LmtleV9dO1xuICAgIGlmIChlbnRyeS5uZXdlcikge1xuICAgICAgZW50cnkubmV3ZXIub2xkZXIgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLm9sZGVzdF8gPSAvKiogQHR5cGUge0VudHJ5fSAqLyAoZW50cnkubmV3ZXIpO1xuICAgIGlmICghdGhpcy5vbGRlc3RfKSB7XG4gICAgICB0aGlzLm5ld2VzdF8gPSBudWxsO1xuICAgIH1cbiAgICAtLXRoaXMuY291bnRfO1xuICAgIHJldHVybiBlbnRyeS52YWx1ZV87XG4gIH07XG5cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkuXG4gICAqIEBwYXJhbSB7VH0gdmFsdWUgVmFsdWUuXG4gICAqL1xuICBMUlVDYWNoZS5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UgKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLmdldChrZXkpOyAvLyB1cGRhdGUgYG5ld2VzdF9gXG4gICAgdGhpcy5lbnRyaWVzX1trZXldLnZhbHVlXyA9IHZhbHVlO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgS2V5LlxuICAgKiBAcGFyYW0ge1R9IHZhbHVlIFZhbHVlLlxuICAgKi9cbiAgTFJVQ2FjaGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAoa2V5LCB2YWx1ZSkge1xuICAgIGFzc2VydCghKGtleSBpbiB0aGlzLmVudHJpZXNfKSxcbiAgICAgIDE2KTsgLy8gVHJpZWQgdG8gc2V0IGEgdmFsdWUgZm9yIGEga2V5IHRoYXQgaXMgdXNlZCBhbHJlYWR5XG4gICAgdmFyIGVudHJ5ID0gLyoqIEB0eXBlIHtFbnRyeX0gKi8gKHtcbiAgICAgIGtleV86IGtleSxcbiAgICAgIG5ld2VyOiBudWxsLFxuICAgICAgb2xkZXI6IHRoaXMubmV3ZXN0XyxcbiAgICAgIHZhbHVlXzogdmFsdWVcbiAgICB9KTtcbiAgICBpZiAoIXRoaXMubmV3ZXN0Xykge1xuICAgICAgdGhpcy5vbGRlc3RfID0gZW50cnk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubmV3ZXN0Xy5uZXdlciA9IGVudHJ5O1xuICAgIH1cbiAgICB0aGlzLm5ld2VzdF8gPSBlbnRyeTtcbiAgICB0aGlzLmVudHJpZXNfW2tleV0gPSBlbnRyeTtcbiAgICArK3RoaXMuY291bnRfO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFNldCBhIG1heGltdW0gbnVtYmVyIG9mIGVudHJpZXMgZm9yIHRoZSBjYWNoZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgQ2FjaGUgc2l6ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgTFJVQ2FjaGUucHJvdG90eXBlLnNldFNpemUgPSBmdW5jdGlvbiBzZXRTaXplIChzaXplKSB7XG4gICAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gc2l6ZTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBQcnVuZSB0aGUgY2FjaGUuXG4gICAqL1xuICBMUlVDYWNoZS5wcm90b3R5cGUucHJ1bmUgPSBmdW5jdGlvbiBwcnVuZSAoKSB7XG4gICAgd2hpbGUgKHRoaXMuY2FuRXhwaXJlQ2FjaGUoKSkge1xuICAgICAgdGhpcy5wb3AoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIExSVUNhY2hlO1xufShFdmVudFRhcmdldCkpO1xuXG5leHBvcnQgZGVmYXVsdCBMUlVDYWNoZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TFJVQ2FjaGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3N0cnVjdHMvUHJpb3JpdHlRdWV1ZVxuICovXG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi4vYXNzZXJ0cy5qcyc7XG5pbXBvcnQge2NsZWFyfSBmcm9tICcuLi9vYmouanMnO1xuXG5cbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBEUk9QID0gSW5maW5pdHk7XG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBQcmlvcml0eSBxdWV1ZS5cbiAqXG4gKiBUaGUgaW1wbGVtZW50YXRpb24gaXMgaW5zcGlyZWQgZnJvbSB0aGUgQ2xvc3VyZSBMaWJyYXJ5J3MgSGVhcCBjbGFzcyBhbmRcbiAqIFB5dGhvbidzIGhlYXBxIG1vZHVsZS5cbiAqXG4gKiBTZWUgaHR0cDovL2Nsb3N1cmUtbGlicmFyeS5nb29nbGVjb2RlLmNvbS9zdm4vZG9jcy9jbG9zdXJlX2dvb2dfc3RydWN0c19oZWFwLmpzLnNvdXJjZS5odG1sXG4gKiBhbmQgaHR0cDovL2hnLnB5dGhvbi5vcmcvY3B5dGhvbi9maWxlLzIuNy9MaWIvaGVhcHEucHkuXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqL1xudmFyIFByaW9yaXR5UXVldWUgPSBmdW5jdGlvbiBQcmlvcml0eVF1ZXVlKHByaW9yaXR5RnVuY3Rpb24sIGtleUZ1bmN0aW9uKSB7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtmdW5jdGlvbihUKTogbnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5wcmlvcml0eUZ1bmN0aW9uXyA9IHByaW9yaXR5RnVuY3Rpb247XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtmdW5jdGlvbihUKTogc3RyaW5nfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5rZXlGdW5jdGlvbl8gPSBrZXlGdW5jdGlvbjtcblxuICAvKipcbiAgICogQHR5cGUge0FycmF5PFQ+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5lbGVtZW50c18gPSBbXTtcblxuICAvKipcbiAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnByaW9yaXRpZXNfID0gW107XG5cbiAgLyoqXG4gICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgYm9vbGVhbj59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnF1ZXVlZEVsZW1lbnRzXyA9IHt9O1xuXG59O1xuXG4vKipcbiAqIEZJWE1FIGVtcHR5IGRlc2NyaXB0aW9uIGZvciBqc2RvY1xuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyJDEgKCkge1xuICB0aGlzLmVsZW1lbnRzXy5sZW5ndGggPSAwO1xuICB0aGlzLnByaW9yaXRpZXNfLmxlbmd0aCA9IDA7XG4gIGNsZWFyKHRoaXMucXVldWVkRWxlbWVudHNfKTtcbn07XG5cblxuLyoqXG4gKiBSZW1vdmUgYW5kIHJldHVybiB0aGUgaGlnaGVzdC1wcmlvcml0eSBlbGVtZW50LiBPKGxvZyBOKS5cbiAqIEByZXR1cm4ge1R9IEVsZW1lbnQuXG4gKi9cblByaW9yaXR5UXVldWUucHJvdG90eXBlLmRlcXVldWUgPSBmdW5jdGlvbiBkZXF1ZXVlICgpIHtcbiAgdmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50c187XG4gIHZhciBwcmlvcml0aWVzID0gdGhpcy5wcmlvcml0aWVzXztcbiAgdmFyIGVsZW1lbnQgPSBlbGVtZW50c1swXTtcbiAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgZWxlbWVudHMubGVuZ3RoID0gMDtcbiAgICBwcmlvcml0aWVzLmxlbmd0aCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgZWxlbWVudHNbMF0gPSBlbGVtZW50cy5wb3AoKTtcbiAgICBwcmlvcml0aWVzWzBdID0gcHJpb3JpdGllcy5wb3AoKTtcbiAgICB0aGlzLnNpZnRVcF8oMCk7XG4gIH1cbiAgdmFyIGVsZW1lbnRLZXkgPSB0aGlzLmtleUZ1bmN0aW9uXyhlbGVtZW50KTtcbiAgZGVsZXRlIHRoaXMucXVldWVkRWxlbWVudHNfW2VsZW1lbnRLZXldO1xuICByZXR1cm4gZWxlbWVudDtcbn07XG5cblxuLyoqXG4gKiBFbnF1ZXVlIGFuIGVsZW1lbnQuIE8obG9nIE4pLlxuICogQHBhcmFtIHtUfSBlbGVtZW50IEVsZW1lbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgZWxlbWVudCB3YXMgYWRkZWQgdG8gdGhlIHF1ZXVlLlxuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5lbnF1ZXVlID0gZnVuY3Rpb24gZW5xdWV1ZSAoZWxlbWVudCkge1xuICBhc3NlcnQoISh0aGlzLmtleUZ1bmN0aW9uXyhlbGVtZW50KSBpbiB0aGlzLnF1ZXVlZEVsZW1lbnRzXyksXG4gICAgMzEpOyAvLyBUcmllZCB0byBlbnF1ZXVlIGFuIGBlbGVtZW50YCB0aGF0IHdhcyBhbHJlYWR5IGFkZGVkIHRvIHRoZSBxdWV1ZVxuICB2YXIgcHJpb3JpdHkgPSB0aGlzLnByaW9yaXR5RnVuY3Rpb25fKGVsZW1lbnQpO1xuICBpZiAocHJpb3JpdHkgIT0gRFJPUCkge1xuICAgIHRoaXMuZWxlbWVudHNfLnB1c2goZWxlbWVudCk7XG4gICAgdGhpcy5wcmlvcml0aWVzXy5wdXNoKHByaW9yaXR5KTtcbiAgICB0aGlzLnF1ZXVlZEVsZW1lbnRzX1t0aGlzLmtleUZ1bmN0aW9uXyhlbGVtZW50KV0gPSB0cnVlO1xuICAgIHRoaXMuc2lmdERvd25fKDAsIHRoaXMuZWxlbWVudHNfLmxlbmd0aCAtIDEpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtudW1iZXJ9IENvdW50LlxuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5nZXRDb3VudCA9IGZ1bmN0aW9uIGdldENvdW50ICgpIHtcbiAgcmV0dXJuIHRoaXMuZWxlbWVudHNfLmxlbmd0aDtcbn07XG5cblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBvZiB0aGUgbGVmdCBjaGlsZCBvZiB0aGUgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXguXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBub2RlIHRvIGdldCB0aGUgbGVmdCBjaGlsZCBmb3IuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgbGVmdCBjaGlsZC5cbiAqIEBwcml2YXRlXG4gKi9cblByaW9yaXR5UXVldWUucHJvdG90eXBlLmdldExlZnRDaGlsZEluZGV4XyA9IGZ1bmN0aW9uIGdldExlZnRDaGlsZEluZGV4XyAoaW5kZXgpIHtcbiAgcmV0dXJuIGluZGV4ICogMiArIDE7XG59O1xuXG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggb2YgdGhlIHJpZ2h0IGNoaWxkIG9mIHRoZSBub2RlIGF0IHRoZSBnaXZlbiBpbmRleC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIG5vZGUgdG8gZ2V0IHRoZSByaWdodCBjaGlsZCBmb3IuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgcmlnaHQgY2hpbGQuXG4gKiBAcHJpdmF0ZVxuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5nZXRSaWdodENoaWxkSW5kZXhfID0gZnVuY3Rpb24gZ2V0UmlnaHRDaGlsZEluZGV4XyAoaW5kZXgpIHtcbiAgcmV0dXJuIGluZGV4ICogMiArIDI7XG59O1xuXG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggb2YgdGhlIHBhcmVudCBvZiB0aGUgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXguXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBub2RlIHRvIGdldCB0aGUgcGFyZW50IGZvci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGluZGV4IG9mIHRoZSBwYXJlbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5nZXRQYXJlbnRJbmRleF8gPSBmdW5jdGlvbiBnZXRQYXJlbnRJbmRleF8gKGluZGV4KSB7XG4gIHJldHVybiAoaW5kZXggLSAxKSA+PiAxO1xufTtcblxuXG4vKipcbiAqIE1ha2UgdGhpcyBhIGhlYXAuIE8oTikuXG4gKiBAcHJpdmF0ZVxuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5oZWFwaWZ5XyA9IGZ1bmN0aW9uIGhlYXBpZnlfICgpIHtcbiAgdmFyIGk7XG4gIGZvciAoaSA9ICh0aGlzLmVsZW1lbnRzXy5sZW5ndGggPj4gMSkgLSAxOyBpID49IDA7IGktLSkge1xuICAgIHRoaXMuc2lmdFVwXyhpKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEByZXR1cm4ge2Jvb2xlYW59IElzIGVtcHR5LlxuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSAoKSB7XG4gIHJldHVybiB0aGlzLmVsZW1lbnRzXy5sZW5ndGggPT09IDA7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkuXG4gKiBAcmV0dXJuIHtib29sZWFufSBJcyBrZXkgcXVldWVkLlxuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5pc0tleVF1ZXVlZCA9IGZ1bmN0aW9uIGlzS2V5UXVldWVkIChrZXkpIHtcbiAgcmV0dXJuIGtleSBpbiB0aGlzLnF1ZXVlZEVsZW1lbnRzXztcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge1R9IGVsZW1lbnQgRWxlbWVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IElzIHF1ZXVlZC5cbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuaXNRdWV1ZWQgPSBmdW5jdGlvbiBpc1F1ZXVlZCAoZWxlbWVudCkge1xuICByZXR1cm4gdGhpcy5pc0tleVF1ZXVlZCh0aGlzLmtleUZ1bmN0aW9uXyhlbGVtZW50KSk7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbm9kZSB0byBtb3ZlIGRvd24uXG4gKiBAcHJpdmF0ZVxuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5zaWZ0VXBfID0gZnVuY3Rpb24gc2lmdFVwXyAoaW5kZXgpIHtcbiAgdmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50c187XG4gIHZhciBwcmlvcml0aWVzID0gdGhpcy5wcmlvcml0aWVzXztcbiAgdmFyIGNvdW50ID0gZWxlbWVudHMubGVuZ3RoO1xuICB2YXIgZWxlbWVudCA9IGVsZW1lbnRzW2luZGV4XTtcbiAgdmFyIHByaW9yaXR5ID0gcHJpb3JpdGllc1tpbmRleF07XG4gIHZhciBzdGFydEluZGV4ID0gaW5kZXg7XG5cbiAgd2hpbGUgKGluZGV4IDwgKGNvdW50ID4+IDEpKSB7XG4gICAgdmFyIGxJbmRleCA9IHRoaXMuZ2V0TGVmdENoaWxkSW5kZXhfKGluZGV4KTtcbiAgICB2YXIgckluZGV4ID0gdGhpcy5nZXRSaWdodENoaWxkSW5kZXhfKGluZGV4KTtcblxuICAgIHZhciBzbWFsbGVyQ2hpbGRJbmRleCA9IHJJbmRleCA8IGNvdW50ICYmXG4gICAgICAgIHByaW9yaXRpZXNbckluZGV4XSA8IHByaW9yaXRpZXNbbEluZGV4XSA/XG4gICAgICBySW5kZXggOiBsSW5kZXg7XG5cbiAgICBlbGVtZW50c1tpbmRleF0gPSBlbGVtZW50c1tzbWFsbGVyQ2hpbGRJbmRleF07XG4gICAgcHJpb3JpdGllc1tpbmRleF0gPSBwcmlvcml0aWVzW3NtYWxsZXJDaGlsZEluZGV4XTtcbiAgICBpbmRleCA9IHNtYWxsZXJDaGlsZEluZGV4O1xuICB9XG5cbiAgZWxlbWVudHNbaW5kZXhdID0gZWxlbWVudDtcbiAgcHJpb3JpdGllc1tpbmRleF0gPSBwcmlvcml0eTtcbiAgdGhpcy5zaWZ0RG93bl8oc3RhcnRJbmRleCwgaW5kZXgpO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEluZGV4IFRoZSBpbmRleCBvZiB0aGUgcm9vdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIG5vZGUgdG8gbW92ZSB1cC5cbiAqIEBwcml2YXRlXG4gKi9cblByaW9yaXR5UXVldWUucHJvdG90eXBlLnNpZnREb3duXyA9IGZ1bmN0aW9uIHNpZnREb3duXyAoc3RhcnRJbmRleCwgaW5kZXgpIHtcbiAgdmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50c187XG4gIHZhciBwcmlvcml0aWVzID0gdGhpcy5wcmlvcml0aWVzXztcbiAgdmFyIGVsZW1lbnQgPSBlbGVtZW50c1tpbmRleF07XG4gIHZhciBwcmlvcml0eSA9IHByaW9yaXRpZXNbaW5kZXhdO1xuXG4gIHdoaWxlIChpbmRleCA+IHN0YXJ0SW5kZXgpIHtcbiAgICB2YXIgcGFyZW50SW5kZXggPSB0aGlzLmdldFBhcmVudEluZGV4XyhpbmRleCk7XG4gICAgaWYgKHByaW9yaXRpZXNbcGFyZW50SW5kZXhdID4gcHJpb3JpdHkpIHtcbiAgICAgIGVsZW1lbnRzW2luZGV4XSA9IGVsZW1lbnRzW3BhcmVudEluZGV4XTtcbiAgICAgIHByaW9yaXRpZXNbaW5kZXhdID0gcHJpb3JpdGllc1twYXJlbnRJbmRleF07XG4gICAgICBpbmRleCA9IHBhcmVudEluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgZWxlbWVudHNbaW5kZXhdID0gZWxlbWVudDtcbiAgcHJpb3JpdGllc1tpbmRleF0gPSBwcmlvcml0eTtcbn07XG5cblxuLyoqXG4gKiBGSVhNRSBlbXB0eSBkZXNjcmlwdGlvbiBmb3IganNkb2NcbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUucmVwcmlvcml0aXplID0gZnVuY3Rpb24gcmVwcmlvcml0aXplICgpIHtcbiAgdmFyIHByaW9yaXR5RnVuY3Rpb24gPSB0aGlzLnByaW9yaXR5RnVuY3Rpb25fO1xuICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzXztcbiAgdmFyIHByaW9yaXRpZXMgPSB0aGlzLnByaW9yaXRpZXNfO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbiA9IGVsZW1lbnRzLmxlbmd0aDtcbiAgdmFyIGVsZW1lbnQsIGksIHByaW9yaXR5O1xuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgIHByaW9yaXR5ID0gcHJpb3JpdHlGdW5jdGlvbihlbGVtZW50KTtcbiAgICBpZiAocHJpb3JpdHkgPT0gRFJPUCkge1xuICAgICAgZGVsZXRlIHRoaXMucXVldWVkRWxlbWVudHNfW3RoaXMua2V5RnVuY3Rpb25fKGVsZW1lbnQpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJpb3JpdGllc1tpbmRleF0gPSBwcmlvcml0eTtcbiAgICAgIGVsZW1lbnRzW2luZGV4KytdID0gZWxlbWVudDtcbiAgICB9XG4gIH1cbiAgZWxlbWVudHMubGVuZ3RoID0gaW5kZXg7XG4gIHByaW9yaXRpZXMubGVuZ3RoID0gaW5kZXg7XG4gIHRoaXMuaGVhcGlmeV8oKTtcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgUHJpb3JpdHlRdWV1ZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHJpb3JpdHlRdWV1ZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvc3RydWN0cy9SQnVzaFxuICovXG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5pbXBvcnQgcmJ1c2ggZnJvbSAncmJ1c2gnO1xuaW1wb3J0IHtjcmVhdGVPclVwZGF0ZSwgZXF1YWxzfSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IHtpc0VtcHR5fSBmcm9tICcuLi9vYmouanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEVudHJ5XG4gKiBAcHJvcGVydHkge251bWJlcn0gbWluWFxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1pbllcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhYXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWF4WVxuICogQHByb3BlcnR5IHtPYmplY3R9IFt2YWx1ZV1cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFdyYXBwZXIgYXJvdW5kIHRoZSBSQnVzaCBieSBWbGFkaW1pciBBZ2Fmb25raW4uXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vdXJuZXIvcmJ1c2guXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqL1xudmFyIFJCdXNoID0gZnVuY3Rpb24gUkJ1c2gob3B0X21heEVudHJpZXMpIHtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMucmJ1c2hfID0gcmJ1c2gob3B0X21heEVudHJpZXMsIHVuZGVmaW5lZCk7XG5cbiAgLyoqXG4gICAqIEEgbWFwcGluZyBiZXR3ZWVuIHRoZSBvYmplY3RzIGFkZGVkIHRvIHRoaXMgcmJ1c2ggd3JhcHBlclxuICAgKiBhbmQgdGhlIG9iamVjdHMgdGhhdCBhcmUgYWN0dWFsbHkgYWRkZWQgdG8gdGhlIGludGVybmFsIHJidXNoLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgRW50cnk+fVxuICAgKi9cbiAgdGhpcy5pdGVtc18gPSB7fTtcblxufTtcblxuLyoqXG4gKiBJbnNlcnQgYSB2YWx1ZSBpbnRvIHRoZSBSQnVzaC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7VH0gdmFsdWUgVmFsdWUuXG4gKi9cblJCdXNoLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiBpbnNlcnQgKGV4dGVudCwgdmFsdWUpIHtcbiAgLyoqIEB0eXBlIHtFbnRyeX0gKi9cbiAgdmFyIGl0ZW0gPSB7XG4gICAgbWluWDogZXh0ZW50WzBdLFxuICAgIG1pblk6IGV4dGVudFsxXSxcbiAgICBtYXhYOiBleHRlbnRbMl0sXG4gICAgbWF4WTogZXh0ZW50WzNdLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xuXG4gIHRoaXMucmJ1c2hfLmluc2VydChpdGVtKTtcbiAgdGhpcy5pdGVtc19bZ2V0VWlkKHZhbHVlKV0gPSBpdGVtO1xufTtcblxuXG4vKipcbiAqIEJ1bGstaW5zZXJ0IHZhbHVlcyBpbnRvIHRoZSBSQnVzaC5cbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudD59IGV4dGVudHMgRXh0ZW50cy5cbiAqIEBwYXJhbSB7QXJyYXk8VD59IHZhbHVlcyBWYWx1ZXMuXG4gKi9cblJCdXNoLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gbG9hZCAoZXh0ZW50cywgdmFsdWVzKSB7XG4gIHZhciBpdGVtcyA9IG5ldyBBcnJheSh2YWx1ZXMubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGV4dGVudCA9IGV4dGVudHNbaV07XG4gICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xuXG4gICAgLyoqIEB0eXBlIHtFbnRyeX0gKi9cbiAgICB2YXIgaXRlbSA9IHtcbiAgICAgIG1pblg6IGV4dGVudFswXSxcbiAgICAgIG1pblk6IGV4dGVudFsxXSxcbiAgICAgIG1heFg6IGV4dGVudFsyXSxcbiAgICAgIG1heFk6IGV4dGVudFszXSxcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH07XG4gICAgaXRlbXNbaV0gPSBpdGVtO1xuICAgIHRoaXMuaXRlbXNfW2dldFVpZCh2YWx1ZSldID0gaXRlbTtcbiAgfVxuICB0aGlzLnJidXNoXy5sb2FkKGl0ZW1zKTtcbn07XG5cblxuLyoqXG4gKiBSZW1vdmUgYSB2YWx1ZSBmcm9tIHRoZSBSQnVzaC5cbiAqIEBwYXJhbSB7VH0gdmFsdWUgVmFsdWUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBSZW1vdmVkLlxuICovXG5SQnVzaC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlICh2YWx1ZSkge1xuICB2YXIgdWlkID0gZ2V0VWlkKHZhbHVlKTtcblxuICAvLyBnZXQgdGhlIG9iamVjdCBpbiB3aGljaCB0aGUgdmFsdWUgd2FzIHdyYXBwZWQgd2hlbiBhZGRpbmcgdG8gdGhlXG4gIC8vIGludGVybmFsIHJidXNoLiB0aGVuIHVzZSB0aGF0IG9iamVjdCB0byBkbyB0aGUgcmVtb3ZhbC5cbiAgdmFyIGl0ZW0gPSB0aGlzLml0ZW1zX1t1aWRdO1xuICBkZWxldGUgdGhpcy5pdGVtc19bdWlkXTtcbiAgcmV0dXJuIHRoaXMucmJ1c2hfLnJlbW92ZShpdGVtKSAhPT0gbnVsbDtcbn07XG5cblxuLyoqXG4gKiBVcGRhdGUgdGhlIGV4dGVudCBvZiBhIHZhbHVlIGluIHRoZSBSQnVzaC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7VH0gdmFsdWUgVmFsdWUuXG4gKi9cblJCdXNoLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKGV4dGVudCwgdmFsdWUpIHtcbiAgdmFyIGl0ZW0gPSB0aGlzLml0ZW1zX1tnZXRVaWQodmFsdWUpXTtcbiAgdmFyIGJib3ggPSBbaXRlbS5taW5YLCBpdGVtLm1pblksIGl0ZW0ubWF4WCwgaXRlbS5tYXhZXTtcbiAgaWYgKCFlcXVhbHMoYmJveCwgZXh0ZW50KSkge1xuICAgIHRoaXMucmVtb3ZlKHZhbHVlKTtcbiAgICB0aGlzLmluc2VydChleHRlbnQsIHZhbHVlKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFJldHVybiBhbGwgdmFsdWVzIGluIHRoZSBSQnVzaC5cbiAqIEByZXR1cm4ge0FycmF5PFQ+fSBBbGwuXG4gKi9cblJCdXNoLnByb3RvdHlwZS5nZXRBbGwgPSBmdW5jdGlvbiBnZXRBbGwgKCkge1xuICB2YXIgaXRlbXMgPSB0aGlzLnJidXNoXy5hbGwoKTtcbiAgcmV0dXJuIGl0ZW1zLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW0udmFsdWU7XG4gIH0pO1xufTtcblxuXG4vKipcbiAqIFJldHVybiBhbGwgdmFsdWVzIGluIHRoZSBnaXZlbiBleHRlbnQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtBcnJheTxUPn0gQWxsIGluIGV4dGVudC5cbiAqL1xuUkJ1c2gucHJvdG90eXBlLmdldEluRXh0ZW50ID0gZnVuY3Rpb24gZ2V0SW5FeHRlbnQgKGV4dGVudCkge1xuICAvKiogQHR5cGUge0VudHJ5fSAqL1xuICB2YXIgYmJveCA9IHtcbiAgICBtaW5YOiBleHRlbnRbMF0sXG4gICAgbWluWTogZXh0ZW50WzFdLFxuICAgIG1heFg6IGV4dGVudFsyXSxcbiAgICBtYXhZOiBleHRlbnRbM11cbiAgfTtcbiAgdmFyIGl0ZW1zID0gdGhpcy5yYnVzaF8uc2VhcmNoKGJib3gpO1xuICByZXR1cm4gaXRlbXMubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbS52YWx1ZTtcbiAgfSk7XG59O1xuXG5cbi8qKlxuICogQ2FsbHMgYSBjYWxsYmFjayBmdW5jdGlvbiB3aXRoIGVhY2ggdmFsdWUgaW4gdGhlIHRyZWUuXG4gKiBJZiB0aGUgY2FsbGJhY2sgcmV0dXJucyBhIHRydXRoeSB2YWx1ZSwgdGhpcyB2YWx1ZSBpcyByZXR1cm5lZCB3aXRob3V0XG4gKiBjaGVja2luZyB0aGUgcmVzdCBvZiB0aGUgdHJlZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczogUywgVCk6ICp9IGNhbGxiYWNrIENhbGxiYWNrLlxuICogQHBhcmFtIHtTPX0gb3B0X3RoaXMgVGhlIG9iamVjdCB0byB1c2UgYXMgYHRoaXNgIGluIGBjYWxsYmFja2AuXG4gKiBAcmV0dXJuIHsqfSBDYWxsYmFjayByZXR1cm4gdmFsdWUuXG4gKiBAdGVtcGxhdGUgU1xuICovXG5SQnVzaC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2ggKGNhbGxiYWNrLCBvcHRfdGhpcykge1xuICByZXR1cm4gdGhpcy5mb3JFYWNoXyh0aGlzLmdldEFsbCgpLCBjYWxsYmFjaywgb3B0X3RoaXMpO1xufTtcblxuXG4vKipcbiAqIENhbGxzIGEgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aCBlYWNoIHZhbHVlIGluIHRoZSBwcm92aWRlZCBleHRlbnQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6IFMsIFQpOiAqfSBjYWxsYmFjayBDYWxsYmFjay5cbiAqIEBwYXJhbSB7Uz19IG9wdF90aGlzIFRoZSBvYmplY3QgdG8gdXNlIGFzIGB0aGlzYCBpbiBgY2FsbGJhY2tgLlxuICogQHJldHVybiB7Kn0gQ2FsbGJhY2sgcmV0dXJuIHZhbHVlLlxuICogQHRlbXBsYXRlIFNcbiAqL1xuUkJ1c2gucHJvdG90eXBlLmZvckVhY2hJbkV4dGVudCA9IGZ1bmN0aW9uIGZvckVhY2hJbkV4dGVudCAoZXh0ZW50LCBjYWxsYmFjaywgb3B0X3RoaXMpIHtcbiAgcmV0dXJuIHRoaXMuZm9yRWFjaF8odGhpcy5nZXRJbkV4dGVudChleHRlbnQpLCBjYWxsYmFjaywgb3B0X3RoaXMpO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8VD59IHZhbHVlcyBWYWx1ZXMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6IFMsIFQpOiAqfSBjYWxsYmFjayBDYWxsYmFjay5cbiAqIEBwYXJhbSB7Uz19IG9wdF90aGlzIFRoZSBvYmplY3QgdG8gdXNlIGFzIGB0aGlzYCBpbiBgY2FsbGJhY2tgLlxuICogQHByaXZhdGVcbiAqIEByZXR1cm4geyp9IENhbGxiYWNrIHJldHVybiB2YWx1ZS5cbiAqIEB0ZW1wbGF0ZSBTXG4gKi9cblJCdXNoLnByb3RvdHlwZS5mb3JFYWNoXyA9IGZ1bmN0aW9uIGZvckVhY2hfICh2YWx1ZXMsIGNhbGxiYWNrLCBvcHRfdGhpcykge1xuICB2YXIgcmVzdWx0O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICByZXN1bHQgPSBjYWxsYmFjay5jYWxsKG9wdF90aGlzLCB2YWx1ZXNbaV0pO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKlxuICogQHJldHVybiB7Ym9vbGVhbn0gSXMgZW1wdHkuXG4gKi9cblJCdXNoLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSQxICgpIHtcbiAgcmV0dXJuIGlzRW1wdHkodGhpcy5pdGVtc18pO1xufTtcblxuXG4vKipcbiAqIFJlbW92ZSBhbGwgdmFsdWVzIGZyb20gdGhlIFJCdXNoLlxuICovXG5SQnVzaC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gIHRoaXMucmJ1c2hfLmNsZWFyKCk7XG4gIHRoaXMuaXRlbXNfID0ge307XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50PX0gb3B0X2V4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBFeHRlbnQuXG4gKi9cblJCdXNoLnByb3RvdHlwZS5nZXRFeHRlbnQgPSBmdW5jdGlvbiBnZXRFeHRlbnQgKG9wdF9leHRlbnQpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLnJidXNoXy50b0pTT04oKTtcbiAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlKGRhdGEubWluWCwgZGF0YS5taW5ZLCBkYXRhLm1heFgsIGRhdGEubWF4WSwgb3B0X2V4dGVudCk7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHtSQnVzaH0gcmJ1c2ggUi1UcmVlLlxuICovXG5SQnVzaC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChyYnVzaCkge1xuICB0aGlzLnJidXNoXy5sb2FkKHJidXNoLnJidXNoXy5hbGwoKSk7XG4gIGZvciAodmFyIGkgaW4gcmJ1c2guaXRlbXNfKSB7XG4gICAgdGhpcy5pdGVtc19baV0gPSByYnVzaC5pdGVtc19baV07XG4gIH1cbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgUkJ1c2g7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJCdXNoLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9zdHlsZS9DaXJjbGVcbiAqL1xuXG5pbXBvcnQgUmVndWxhclNoYXBlIGZyb20gJy4vUmVndWxhclNoYXBlLmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9GaWxsLmpzXCIpLmRlZmF1bHR9IFtmaWxsXSBGaWxsIHN0eWxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHJhZGl1cyBDaXJjbGUgcmFkaXVzLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL1N0cm9rZS5qc1wiKS5kZWZhdWx0fSBbc3Ryb2tlXSBTdHJva2Ugc3R5bGUuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vQXRsYXNNYW5hZ2VyLmpzXCIpLmRlZmF1bHR9IFthdGxhc01hbmFnZXJdIFRoZSBhdGxhcyBtYW5hZ2VyIHRvIHVzZSBmb3IgdGhpcyBjaXJjbGUuXG4gKiBXaGVuIHVzaW5nIFdlYkdMIGl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSBhbiBhdGxhcyBtYW5hZ2VyIHRvIGF2b2lkIHRleHR1cmUgc3dpdGNoaW5nLiBJZiBhbiBhdGxhcyBtYW5hZ2VyIGlzIGdpdmVuLFxuICogdGhlIGNpcmNsZSBpcyBhZGRlZCB0byBhbiBhdGxhcy4gQnkgZGVmYXVsdCBubyBhdGxhcyBtYW5hZ2VyIGlzIHVzZWQuXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFNldCBjaXJjbGUgc3R5bGUgZm9yIHZlY3RvciBmZWF0dXJlcy5cbiAqIEBhcGlcbiAqL1xudmFyIENpcmNsZVN0eWxlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoUmVndWxhclNoYXBlKSB7XG4gIGZ1bmN0aW9uIENpcmNsZVN0eWxlKG9wdF9vcHRpb25zKSB7XG5cbiAgICB2YXIgb3B0aW9ucyA9IG9wdF9vcHRpb25zIHx8IC8qKiBAdHlwZSB7T3B0aW9uc30gKi8gKHt9KTtcblxuICAgIFJlZ3VsYXJTaGFwZS5jYWxsKHRoaXMsIHtcbiAgICAgIHBvaW50czogSW5maW5pdHksXG4gICAgICBmaWxsOiBvcHRpb25zLmZpbGwsXG4gICAgICByYWRpdXM6IG9wdGlvbnMucmFkaXVzLFxuICAgICAgc3Ryb2tlOiBvcHRpb25zLnN0cm9rZSxcbiAgICAgIGF0bGFzTWFuYWdlcjogb3B0aW9ucy5hdGxhc01hbmFnZXJcbiAgICB9KTtcblxuICB9XG5cbiAgaWYgKCBSZWd1bGFyU2hhcGUgKSBDaXJjbGVTdHlsZS5fX3Byb3RvX18gPSBSZWd1bGFyU2hhcGU7XG4gIENpcmNsZVN0eWxlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFJlZ3VsYXJTaGFwZSAmJiBSZWd1bGFyU2hhcGUucHJvdG90eXBlICk7XG4gIENpcmNsZVN0eWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENpcmNsZVN0eWxlO1xuXG4gIC8qKlxuICAqIENsb25lcyB0aGUgc3R5bGUuICBJZiBhbiBhdGxhc21hbmFnZXIgd2FzIHByb3ZpZGVkIHRvIHRoZSBvcmlnaW5hbCBzdHlsZSBpdCB3aWxsIGJlIHVzZWQgaW4gdGhlIGNsb25lZCBzdHlsZSwgdG9vLlxuICAqIEByZXR1cm4ge0NpcmNsZVN0eWxlfSBUaGUgY2xvbmVkIHN0eWxlLlxuICAqIEBvdmVycmlkZVxuICAqIEBhcGlcbiAgKi9cbiAgQ2lyY2xlU3R5bGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgIHZhciBzdHlsZSA9IG5ldyBDaXJjbGVTdHlsZSh7XG4gICAgICBmaWxsOiB0aGlzLmdldEZpbGwoKSA/IHRoaXMuZ2V0RmlsbCgpLmNsb25lKCkgOiB1bmRlZmluZWQsXG4gICAgICBzdHJva2U6IHRoaXMuZ2V0U3Ryb2tlKCkgPyB0aGlzLmdldFN0cm9rZSgpLmNsb25lKCkgOiB1bmRlZmluZWQsXG4gICAgICByYWRpdXM6IHRoaXMuZ2V0UmFkaXVzKCksXG4gICAgICBhdGxhc01hbmFnZXI6IHRoaXMuYXRsYXNNYW5hZ2VyX1xuICAgIH0pO1xuICAgIHN0eWxlLnNldE9wYWNpdHkodGhpcy5nZXRPcGFjaXR5KCkpO1xuICAgIHN0eWxlLnNldFNjYWxlKHRoaXMuZ2V0U2NhbGUoKSk7XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9O1xuXG4gIC8qKlxuICAqIFNldCB0aGUgY2lyY2xlIHJhZGl1cy5cbiAgKlxuICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgQ2lyY2xlIHJhZGl1cy5cbiAgKiBAYXBpXG4gICovXG4gIENpcmNsZVN0eWxlLnByb3RvdHlwZS5zZXRSYWRpdXMgPSBmdW5jdGlvbiBzZXRSYWRpdXMgKHJhZGl1cykge1xuICAgIHRoaXMucmFkaXVzXyA9IHJhZGl1cztcbiAgICB0aGlzLnJlbmRlcl8odGhpcy5hdGxhc01hbmFnZXJfKTtcbiAgfTtcblxuICByZXR1cm4gQ2lyY2xlU3R5bGU7XG59KFJlZ3VsYXJTaGFwZSkpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IENpcmNsZVN0eWxlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1DaXJjbGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3N0eWxlL0ZpbGxcbiAqL1xuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4uL3V0aWwuanMnO1xuaW1wb3J0IHthc1N0cmluZ30gZnJvbSAnLi4vY29sb3IuanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcnxpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfSBbY29sb3JdIEEgY29sb3IsIGdyYWRpZW50IG9yIHBhdHRlcm4uXG4gKiBTZWUge0BsaW5rIG1vZHVsZTpvbC9jb2xvcn5Db2xvcn0gYW5kIHtAbGluayBtb2R1bGU6b2wvY29sb3JsaWtlfkNvbG9yTGlrZX0gZm9yIHBvc3NpYmxlIGZvcm1hdHMuXG4gKiBEZWZhdWx0IG51bGw7IGlmIG51bGwsIHRoZSBDYW52YXMvcmVuZGVyZXIgZGVmYXVsdCBibGFjayB3aWxsIGJlIHVzZWQuXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFNldCBmaWxsIHN0eWxlIGZvciB2ZWN0b3IgZmVhdHVyZXMuXG4gKiBAYXBpXG4gKi9cbnZhciBGaWxsID0gZnVuY3Rpb24gRmlsbChvcHRfb3B0aW9ucykge1xuXG4gIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgfHwge307XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcnxpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfVxuICAgKi9cbiAgdGhpcy5jb2xvcl8gPSBvcHRpb25zLmNvbG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNvbG9yIDogbnVsbDtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9XG4gICAqL1xuICB0aGlzLmNoZWNrc3VtXyA9IHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogQ2xvbmVzIHRoZSBzdHlsZS4gVGhlIGNvbG9yIGlzIG5vdCBjbG9uZWQgaWYgaXQgaXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9jb2xvcmxpa2V+Q29sb3JMaWtlfS5cbiAqIEByZXR1cm4ge0ZpbGx9IFRoZSBjbG9uZWQgc3R5bGUuXG4gKiBAYXBpXG4gKi9cbkZpbGwucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuICB2YXIgY29sb3IgPSB0aGlzLmdldENvbG9yKCk7XG4gIHJldHVybiBuZXcgRmlsbCh7XG4gICAgY29sb3I6IEFycmF5LmlzQXJyYXkoY29sb3IpID8gY29sb3Iuc2xpY2UoKSA6IGNvbG9yIHx8IHVuZGVmaW5lZFxuICB9KTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBmaWxsIGNvbG9yLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J8aW1wb3J0KFwiLi4vY29sb3JsaWtlLmpzXCIpLkNvbG9yTGlrZX0gQ29sb3IuXG4gKiBAYXBpXG4gKi9cbkZpbGwucHJvdG90eXBlLmdldENvbG9yID0gZnVuY3Rpb24gZ2V0Q29sb3IgKCkge1xuICByZXR1cm4gdGhpcy5jb2xvcl87XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29sb3IuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcnxpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfSBjb2xvciBDb2xvci5cbiAqIEBhcGlcbiAqL1xuRmlsbC5wcm90b3R5cGUuc2V0Q29sb3IgPSBmdW5jdGlvbiBzZXRDb2xvciAoY29sb3IpIHtcbiAgdGhpcy5jb2xvcl8gPSBjb2xvcjtcbiAgdGhpcy5jaGVja3N1bV8gPSB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGNoZWNrc3VtLlxuICovXG5GaWxsLnByb3RvdHlwZS5nZXRDaGVja3N1bSA9IGZ1bmN0aW9uIGdldENoZWNrc3VtICgpIHtcbiAgaWYgKHRoaXMuY2hlY2tzdW1fID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgY29sb3IgPSB0aGlzLmNvbG9yXztcbiAgICBpZiAoY29sb3IpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbG9yKSB8fCB0eXBlb2YgY29sb3IgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5jaGVja3N1bV8gPSAnZicgKyBhc1N0cmluZygvKiogQHR5cGUge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfHN0cmluZ30gKi8gKGNvbG9yKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNoZWNrc3VtXyA9IGdldFVpZCh0aGlzLmNvbG9yXyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2hlY2tzdW1fID0gJ2YtJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcy5jaGVja3N1bV87XG59O1xuXG5leHBvcnQgZGVmYXVsdCBGaWxsO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1GaWxsLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9zdHlsZS9JY29uSW1hZ2VDYWNoZVxuICovXG5pbXBvcnQge2FzU3RyaW5nfSBmcm9tICcuLi9jb2xvci5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogU2luZ2xldG9uIGNsYXNzLiBBdmFpbGFibGUgdGhyb3VnaCB7QGxpbmsgbW9kdWxlOm9sL3N0eWxlL0ljb25JbWFnZUNhY2hlfnNoYXJlZH0uXG4gKi9cbnZhciBJY29uSW1hZ2VDYWNoZSA9IGZ1bmN0aW9uIEljb25JbWFnZUNhY2hlKCkge1xuXG4gIC8qKlxuICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi9JY29uSW1hZ2UuanNcIikuZGVmYXVsdD59XG4gICogQHByaXZhdGVcbiAgKi9cbiAgdGhpcy5jYWNoZV8gPSB7fTtcblxuICAvKipcbiAgKiBAdHlwZSB7bnVtYmVyfVxuICAqIEBwcml2YXRlXG4gICovXG4gIHRoaXMuY2FjaGVTaXplXyA9IDA7XG5cbiAgLyoqXG4gICogQHR5cGUge251bWJlcn1cbiAgKiBAcHJpdmF0ZVxuICAqL1xuICB0aGlzLm1heENhY2hlU2l6ZV8gPSAzMjtcbn07XG5cbi8qKlxuKiBGSVhNRSBlbXB0eSBkZXNjcmlwdGlvbiBmb3IganNkb2NcbiovXG5JY29uSW1hZ2VDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gIHRoaXMuY2FjaGVfID0ge307XG4gIHRoaXMuY2FjaGVTaXplXyA9IDA7XG59O1xuXG4vKipcbiogRklYTUUgZW1wdHkgZGVzY3JpcHRpb24gZm9yIGpzZG9jXG4qL1xuSWNvbkltYWdlQ2FjaGUucHJvdG90eXBlLmV4cGlyZSA9IGZ1bmN0aW9uIGV4cGlyZSAoKSB7XG4gIGlmICh0aGlzLmNhY2hlU2l6ZV8gPiB0aGlzLm1heENhY2hlU2l6ZV8pIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuY2FjaGVfKSB7XG4gICAgICB2YXIgaWNvbkltYWdlID0gdGhpcy5jYWNoZV9ba2V5XTtcbiAgICAgIGlmICgoaSsrICYgMykgPT09IDAgJiYgIWljb25JbWFnZS5oYXNMaXN0ZW5lcigpKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNhY2hlX1trZXldO1xuICAgICAgICAtLXRoaXMuY2FjaGVTaXplXztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuKiBAcGFyYW0ge3N0cmluZ30gc3JjIFNyYy5cbiogQHBhcmFtIHs/c3RyaW5nfSBjcm9zc09yaWdpbiBDcm9zcyBvcmlnaW4uXG4qIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J9IGNvbG9yIENvbG9yLlxuKiBAcmV0dXJuIHtpbXBvcnQoXCIuL0ljb25JbWFnZS5qc1wiKS5kZWZhdWx0fSBJY29uIGltYWdlLlxuKi9cbkljb25JbWFnZUNhY2hlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKHNyYywgY3Jvc3NPcmlnaW4sIGNvbG9yKSB7XG4gIHZhciBrZXkgPSBnZXRLZXkoc3JjLCBjcm9zc09yaWdpbiwgY29sb3IpO1xuICByZXR1cm4ga2V5IGluIHRoaXMuY2FjaGVfID8gdGhpcy5jYWNoZV9ba2V5XSA6IG51bGw7XG59O1xuXG4vKipcbiogQHBhcmFtIHtzdHJpbmd9IHNyYyBTcmMuXG4qIEBwYXJhbSB7P3N0cmluZ30gY3Jvc3NPcmlnaW4gQ3Jvc3Mgb3JpZ2luLlxuKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfSBjb2xvciBDb2xvci5cbiogQHBhcmFtIHtpbXBvcnQoXCIuL0ljb25JbWFnZS5qc1wiKS5kZWZhdWx0fSBpY29uSW1hZ2UgSWNvbiBpbWFnZS5cbiovXG5JY29uSW1hZ2VDYWNoZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0IChzcmMsIGNyb3NzT3JpZ2luLCBjb2xvciwgaWNvbkltYWdlKSB7XG4gIHZhciBrZXkgPSBnZXRLZXkoc3JjLCBjcm9zc09yaWdpbiwgY29sb3IpO1xuICB0aGlzLmNhY2hlX1trZXldID0gaWNvbkltYWdlO1xuICArK3RoaXMuY2FjaGVTaXplXztcbn07XG5cbi8qKlxuKiBTZXQgdGhlIGNhY2hlIHNpemUgb2YgdGhlIGljb24gY2FjaGUuIERlZmF1bHQgaXMgYDMyYC4gQ2hhbmdlIHRoaXMgdmFsdWUgd2hlblxuKiB5b3VyIG1hcCB1c2VzIG1vcmUgdGhhbiAzMiBkaWZmZXJlbnQgaWNvbiBpbWFnZXMgYW5kIHlvdSBhcmUgbm90IGNhY2hpbmcgaWNvblxuKiBzdHlsZXMgb24gdGhlIGFwcGxpY2F0aW9uIGxldmVsLlxuKiBAcGFyYW0ge251bWJlcn0gbWF4Q2FjaGVTaXplIENhY2hlIG1heCBzaXplLlxuKiBAYXBpXG4qL1xuSWNvbkltYWdlQ2FjaGUucHJvdG90eXBlLnNldFNpemUgPSBmdW5jdGlvbiBzZXRTaXplIChtYXhDYWNoZVNpemUpIHtcbiAgdGhpcy5tYXhDYWNoZVNpemVfID0gbWF4Q2FjaGVTaXplO1xuICB0aGlzLmV4cGlyZSgpO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzcmMgU3JjLlxuICogQHBhcmFtIHs/c3RyaW5nfSBjcm9zc09yaWdpbiBDcm9zcyBvcmlnaW4uXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfSBjb2xvciBDb2xvci5cbiAqIEByZXR1cm4ge3N0cmluZ30gQ2FjaGUga2V5LlxuICovXG5mdW5jdGlvbiBnZXRLZXkoc3JjLCBjcm9zc09yaWdpbiwgY29sb3IpIHtcbiAgdmFyIGNvbG9yU3RyaW5nID0gY29sb3IgPyBhc1N0cmluZyhjb2xvcikgOiAnbnVsbCc7XG4gIHJldHVybiBjcm9zc09yaWdpbiArICc6JyArIHNyYyArICc6JyArIGNvbG9yU3RyaW5nO1xufVxuXG5cbmV4cG9ydCBkZWZhdWx0IEljb25JbWFnZUNhY2hlO1xuXG5cbi8qKlxuICogVGhlIHtAbGluayBtb2R1bGU6b2wvc3R5bGUvSWNvbkltYWdlQ2FjaGV+SWNvbkltYWdlQ2FjaGV9IGZvclxuICoge0BsaW5rIG1vZHVsZTpvbC9zdHlsZS9JY29ufkljb259IGltYWdlcy5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IHZhciBzaGFyZWQgPSBuZXcgSWNvbkltYWdlQ2FjaGUoKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SWNvbkltYWdlQ2FjaGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3N0eWxlL0ltYWdlXG4gKi9cbmltcG9ydCB7YWJzdHJhY3R9IGZyb20gJy4uL3V0aWwuanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IG9wYWNpdHlcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcm90YXRlV2l0aFZpZXdcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByb3RhdGlvblxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNjYWxlXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEEgYmFzZSBjbGFzcyB1c2VkIGZvciBjcmVhdGluZyBzdWJjbGFzc2VzIGFuZCBub3QgaW5zdGFudGlhdGVkIGluXG4gKiBhcHBzLiBCYXNlIGNsYXNzIGZvciB7QGxpbmsgbW9kdWxlOm9sL3N0eWxlL0ljb25+SWNvbn0sIHtAbGluayBtb2R1bGU6b2wvc3R5bGUvQ2lyY2xlfkNpcmNsZVN0eWxlfSBhbmRcbiAqIHtAbGluayBtb2R1bGU6b2wvc3R5bGUvUmVndWxhclNoYXBlflJlZ3VsYXJTaGFwZX0uXG4gKiBAYWJzdHJhY3RcbiAqIEBhcGlcbiAqL1xudmFyIEltYWdlU3R5bGUgPSBmdW5jdGlvbiBJbWFnZVN0eWxlKG9wdGlvbnMpIHtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMub3BhY2l0eV8gPSBvcHRpb25zLm9wYWNpdHk7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgdGhpcy5yb3RhdGVXaXRoVmlld18gPSBvcHRpb25zLnJvdGF0ZVdpdGhWaWV3O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5yb3RhdGlvbl8gPSBvcHRpb25zLnJvdGF0aW9uO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5zY2FsZV8gPSBvcHRpb25zLnNjYWxlO1xuXG59O1xuXG4vKipcbiAqIENsb25lcyB0aGUgc3R5bGUuXG4gKiBAcmV0dXJuIHtJbWFnZVN0eWxlfSBUaGUgY2xvbmVkIHN0eWxlLlxuICogQGFwaVxuICovXG5JbWFnZVN0eWxlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgcmV0dXJuIG5ldyBJbWFnZVN0eWxlKHtcbiAgICBvcGFjaXR5OiB0aGlzLmdldE9wYWNpdHkoKSxcbiAgICBzY2FsZTogdGhpcy5nZXRTY2FsZSgpLFxuICAgIHJvdGF0aW9uOiB0aGlzLmdldFJvdGF0aW9uKCksXG4gICAgcm90YXRlV2l0aFZpZXc6IHRoaXMuZ2V0Um90YXRlV2l0aFZpZXcoKVxuICB9KTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBzeW1ib2xpemVyIG9wYWNpdHkuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE9wYWNpdHkuXG4gKiBAYXBpXG4gKi9cbkltYWdlU3R5bGUucHJvdG90eXBlLmdldE9wYWNpdHkgPSBmdW5jdGlvbiBnZXRPcGFjaXR5ICgpIHtcbiAgcmV0dXJuIHRoaXMub3BhY2l0eV87XG59O1xuXG4vKipcbiAqIERldGVybWluZSB3aGV0aGVyIHRoZSBzeW1ib2xpemVyIHJvdGF0ZXMgd2l0aCB0aGUgbWFwLlxuICogQHJldHVybiB7Ym9vbGVhbn0gUm90YXRlIHdpdGggbWFwLlxuICogQGFwaVxuICovXG5JbWFnZVN0eWxlLnByb3RvdHlwZS5nZXRSb3RhdGVXaXRoVmlldyA9IGZ1bmN0aW9uIGdldFJvdGF0ZVdpdGhWaWV3ICgpIHtcbiAgcmV0dXJuIHRoaXMucm90YXRlV2l0aFZpZXdfO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHN5bW9ibGl6ZXIgcm90YXRpb24uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFJvdGF0aW9uLlxuICogQGFwaVxuICovXG5JbWFnZVN0eWxlLnByb3RvdHlwZS5nZXRSb3RhdGlvbiA9IGZ1bmN0aW9uIGdldFJvdGF0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucm90YXRpb25fO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHN5bWJvbGl6ZXIgc2NhbGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFNjYWxlLlxuICogQGFwaVxuICovXG5JbWFnZVN0eWxlLnByb3RvdHlwZS5nZXRTY2FsZSA9IGZ1bmN0aW9uIGdldFNjYWxlICgpIHtcbiAgcmV0dXJuIHRoaXMuc2NhbGVfO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBkZXByZWNhdGVkIGFuZCBhbHdheXMgcmV0dXJucyBmYWxzZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IGZhbHNlLlxuICogQGRlcHJlY2F0ZWRcbiAqIEBhcGlcbiAqL1xuSW1hZ2VTdHlsZS5wcm90b3R5cGUuZ2V0U25hcFRvUGl4ZWwgPSBmdW5jdGlvbiBnZXRTbmFwVG9QaXhlbCAoKSB7XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBhbmNob3IgcG9pbnQgaW4gcGl4ZWxzLiBUaGUgYW5jaG9yIGRldGVybWluZXMgdGhlIGNlbnRlciBwb2ludCBmb3IgdGhlXG4gKiBzeW1ib2xpemVyLlxuICogQGFic3RyYWN0XG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBBbmNob3IuXG4gKi9cbkltYWdlU3R5bGUucHJvdG90eXBlLmdldEFuY2hvciA9IGZ1bmN0aW9uIGdldEFuY2hvciAoKSB7XG4gIHJldHVybiBhYnN0cmFjdCgpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGltYWdlIGVsZW1lbnQgZm9yIHRoZSBzeW1ib2xpemVyLlxuICogQGFic3RyYWN0XG4gKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR8SFRNTEltYWdlRWxlbWVudH0gSW1hZ2UgZWxlbWVudC5cbiAqL1xuSW1hZ2VTdHlsZS5wcm90b3R5cGUuZ2V0SW1hZ2UgPSBmdW5jdGlvbiBnZXRJbWFnZSAocGl4ZWxSYXRpbykge1xuICByZXR1cm4gYWJzdHJhY3QoKTtcbn07XG5cbi8qKlxuICogQGFic3RyYWN0XG4gKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR8SFRNTEltYWdlRWxlbWVudH0gSW1hZ2UgZWxlbWVudC5cbiAqL1xuSW1hZ2VTdHlsZS5wcm90b3R5cGUuZ2V0SGl0RGV0ZWN0aW9uSW1hZ2UgPSBmdW5jdGlvbiBnZXRIaXREZXRlY3Rpb25JbWFnZSAocGl4ZWxSYXRpbykge1xuICByZXR1cm4gYWJzdHJhY3QoKTtcbn07XG5cbi8qKlxuICogQGFic3RyYWN0XG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9JbWFnZVN0YXRlLmpzXCIpLmRlZmF1bHR9IEltYWdlIHN0YXRlLlxuICovXG5JbWFnZVN0eWxlLnByb3RvdHlwZS5nZXRJbWFnZVN0YXRlID0gZnVuY3Rpb24gZ2V0SW1hZ2VTdGF0ZSAoKSB7XG4gIHJldHVybiBhYnN0cmFjdCgpO1xufTtcblxuLyoqXG4gKiBAYWJzdHJhY3RcbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gSW1hZ2Ugc2l6ZS5cbiAqL1xuSW1hZ2VTdHlsZS5wcm90b3R5cGUuZ2V0SW1hZ2VTaXplID0gZnVuY3Rpb24gZ2V0SW1hZ2VTaXplICgpIHtcbiAgcmV0dXJuIGFic3RyYWN0KCk7XG59O1xuXG4vKipcbiAqIEBhYnN0cmFjdFxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBTaXplIG9mIHRoZSBoaXQtZGV0ZWN0aW9uIGltYWdlLlxuICovXG5JbWFnZVN0eWxlLnByb3RvdHlwZS5nZXRIaXREZXRlY3Rpb25JbWFnZVNpemUgPSBmdW5jdGlvbiBnZXRIaXREZXRlY3Rpb25JbWFnZVNpemUgKCkge1xuICByZXR1cm4gYWJzdHJhY3QoKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBvcmlnaW4gb2YgdGhlIHN5bWJvbGl6ZXIuXG4gKiBAYWJzdHJhY3RcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IE9yaWdpbi5cbiAqL1xuSW1hZ2VTdHlsZS5wcm90b3R5cGUuZ2V0T3JpZ2luID0gZnVuY3Rpb24gZ2V0T3JpZ2luICgpIHtcbiAgcmV0dXJuIGFic3RyYWN0KCk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgc2l6ZSBvZiB0aGUgc3ltYm9saXplciAoaW4gcGl4ZWxzKS5cbiAqIEBhYnN0cmFjdFxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBTaXplLlxuICovXG5JbWFnZVN0eWxlLnByb3RvdHlwZS5nZXRTaXplID0gZnVuY3Rpb24gZ2V0U2l6ZSAoKSB7XG4gIHJldHVybiBhYnN0cmFjdCgpO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG9wYWNpdHkuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG9wYWNpdHkgT3BhY2l0eS5cbiAqIEBhcGlcbiAqL1xuSW1hZ2VTdHlsZS5wcm90b3R5cGUuc2V0T3BhY2l0eSA9IGZ1bmN0aW9uIHNldE9wYWNpdHkgKG9wYWNpdHkpIHtcbiAgdGhpcy5vcGFjaXR5XyA9IG9wYWNpdHk7XG59O1xuXG4vKipcbiAqIFNldCB3aGV0aGVyIHRvIHJvdGF0ZSB0aGUgc3R5bGUgd2l0aCB0aGUgdmlldy5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHJvdGF0ZVdpdGhWaWV3IFJvdGF0ZSB3aXRoIG1hcC5cbiAqIEBhcGlcbiAqL1xuSW1hZ2VTdHlsZS5wcm90b3R5cGUuc2V0Um90YXRlV2l0aFZpZXcgPSBmdW5jdGlvbiBzZXRSb3RhdGVXaXRoVmlldyAocm90YXRlV2l0aFZpZXcpIHtcbiAgdGhpcy5yb3RhdGVXaXRoVmlld18gPSByb3RhdGVXaXRoVmlldztcbn07XG5cbi8qKlxuICogU2V0IHRoZSByb3RhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gcm90YXRpb24gUm90YXRpb24uXG4gKiBAYXBpXG4gKi9cbkltYWdlU3R5bGUucHJvdG90eXBlLnNldFJvdGF0aW9uID0gZnVuY3Rpb24gc2V0Um90YXRpb24gKHJvdGF0aW9uKSB7XG4gIHRoaXMucm90YXRpb25fID0gcm90YXRpb247XG59O1xuLyoqXG4gKiBTZXQgdGhlIHNjYWxlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZSBTY2FsZS5cbiAqIEBhcGlcbiAqL1xuSW1hZ2VTdHlsZS5wcm90b3R5cGUuc2V0U2NhbGUgPSBmdW5jdGlvbiBzZXRTY2FsZSAoc2NhbGUpIHtcbiAgdGhpcy5zY2FsZV8gPSBzY2FsZTtcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgZGVwcmVjYXRlZCBhbmQgZG9lcyBub3RoaW5nLlxuICogQHBhcmFtIHtib29sZWFufSBzbmFwVG9QaXhlbCBTbmFwIHRvIHBpeGVsP1xuICogQGRlcHJlY2F0ZWRcbiAqIEBhcGlcbiAqL1xuSW1hZ2VTdHlsZS5wcm90b3R5cGUuc2V0U25hcFRvUGl4ZWwgPSBmdW5jdGlvbiBzZXRTbmFwVG9QaXhlbCAoc25hcFRvUGl4ZWwpIHt9O1xuXG4vKipcbiAqIEBhYnN0cmFjdFxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBULCBpbXBvcnQoXCIuLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdCl9IGxpc3RlbmVyIExpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtUfSB0aGlzQXJnIFZhbHVlIHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgYGxpc3RlbmVyYC5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2V2ZW50cy5qc1wiKS5FdmVudHNLZXl8dW5kZWZpbmVkfSBMaXN0ZW5lciBrZXkuXG4gKiBAdGVtcGxhdGUgVFxuICovXG5JbWFnZVN0eWxlLnByb3RvdHlwZS5saXN0ZW5JbWFnZUNoYW5nZSA9IGZ1bmN0aW9uIGxpc3RlbkltYWdlQ2hhbmdlIChsaXN0ZW5lciwgdGhpc0FyZykge1xuICByZXR1cm4gYWJzdHJhY3QoKTtcbn07XG5cbi8qKlxuICogTG9hZCBub3QgeWV0IGxvYWRlZCBVUkkuXG4gKiBAYWJzdHJhY3RcbiAqL1xuSW1hZ2VTdHlsZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIGxvYWQgKCkge1xuICBhYnN0cmFjdCgpO1xufTtcblxuLyoqXG4gKiBAYWJzdHJhY3RcbiAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczogVCwgaW1wb3J0KFwiLi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHQpfSBsaXN0ZW5lciBMaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7VH0gdGhpc0FyZyBWYWx1ZSB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIGBsaXN0ZW5lcmAuXG4gKiBAdGVtcGxhdGUgVFxuICovXG5JbWFnZVN0eWxlLnByb3RvdHlwZS51bmxpc3RlbkltYWdlQ2hhbmdlID0gZnVuY3Rpb24gdW5saXN0ZW5JbWFnZUNoYW5nZSAobGlzdGVuZXIsIHRoaXNBcmcpIHtcbiAgYWJzdHJhY3QoKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEltYWdlU3R5bGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUltYWdlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9zdHlsZS9SZWd1bGFyU2hhcGVcbiAqL1xuXG5pbXBvcnQge2FzU3RyaW5nfSBmcm9tICcuLi9jb2xvci5qcyc7XG5pbXBvcnQge2FzQ29sb3JMaWtlfSBmcm9tICcuLi9jb2xvcmxpa2UuanMnO1xuaW1wb3J0IHtjcmVhdGVDYW52YXNDb250ZXh0MkR9IGZyb20gJy4uL2RvbS5qcyc7XG5pbXBvcnQge0NBTlZBU19MSU5FX0RBU0h9IGZyb20gJy4uL2hhcy5qcyc7XG5pbXBvcnQgSW1hZ2VTdGF0ZSBmcm9tICcuLi9JbWFnZVN0YXRlLmpzJztcbmltcG9ydCB7ZGVmYXVsdFN0cm9rZVN0eWxlLCBkZWZhdWx0RmlsbFN0eWxlLCBkZWZhdWx0TGluZUNhcCwgZGVmYXVsdExpbmVXaWR0aCwgZGVmYXVsdExpbmVKb2luLCBkZWZhdWx0TWl0ZXJMaW1pdH0gZnJvbSAnLi4vcmVuZGVyL2NhbnZhcy5qcyc7XG5pbXBvcnQgSW1hZ2VTdHlsZSBmcm9tICcuL0ltYWdlLmpzJztcblxuXG4vKipcbiAqIFNwZWNpZnkgcmFkaXVzIGZvciByZWd1bGFyIHBvbHlnb25zLCBvciByYWRpdXMxIGFuZCByYWRpdXMyIGZvciBzdGFycy5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9GaWxsLmpzXCIpLmRlZmF1bHR9IFtmaWxsXSBGaWxsIHN0eWxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHBvaW50cyBOdW1iZXIgb2YgcG9pbnRzIGZvciBzdGFycyBhbmQgcmVndWxhciBwb2x5Z29ucy4gSW4gY2FzZSBvZiBhIHBvbHlnb24sIHRoZSBudW1iZXIgb2YgcG9pbnRzXG4gKiBpcyB0aGUgbnVtYmVyIG9mIHNpZGVzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyYWRpdXNdIFJhZGl1cyBvZiBhIHJlZ3VsYXIgcG9seWdvbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmFkaXVzMV0gT3V0ZXIgcmFkaXVzIG9mIGEgc3Rhci5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmFkaXVzMl0gSW5uZXIgcmFkaXVzIG9mIGEgc3Rhci5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbYW5nbGU9MF0gU2hhcGUncyBhbmdsZSBpbiByYWRpYW5zLiBBIHZhbHVlIG9mIDAgd2lsbCBoYXZlIG9uZSBvZiB0aGUgc2hhcGUncyBwb2ludCBmYWNpbmcgdXAuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vU3Ryb2tlLmpzXCIpLmRlZmF1bHR9IFtzdHJva2VdIFN0cm9rZSBzdHlsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcm90YXRpb249MF0gUm90YXRpb24gaW4gcmFkaWFucyAocG9zaXRpdmUgcm90YXRpb24gY2xvY2t3aXNlKS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JvdGF0ZVdpdGhWaWV3PWZhbHNlXSBXaGV0aGVyIHRvIHJvdGF0ZSB0aGUgc2hhcGUgd2l0aCB0aGUgdmlldy5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9BdGxhc01hbmFnZXIuanNcIikuZGVmYXVsdH0gW2F0bGFzTWFuYWdlcl0gVGhlIGF0bGFzIG1hbmFnZXIgdG8gdXNlIGZvciB0aGlzIHN5bWJvbC4gV2hlblxuICogdXNpbmcgV2ViR0wgaXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIGFuIGF0bGFzIG1hbmFnZXIgdG8gYXZvaWQgdGV4dHVyZSBzd2l0Y2hpbmcuIElmIGFuIGF0bGFzIG1hbmFnZXIgaXMgZ2l2ZW4sIHRoZVxuICogc3ltYm9sIGlzIGFkZGVkIHRvIGFuIGF0bGFzLiBCeSBkZWZhdWx0IG5vIGF0bGFzIG1hbmFnZXIgaXMgdXNlZC5cbiAqL1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUmVuZGVyT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfSBbc3Ryb2tlU3R5bGVdXG4gKiBAcHJvcGVydHkge251bWJlcn0gc3Ryb2tlV2lkdGhcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaXplXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbGluZUNhcFxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBsaW5lRGFzaFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxpbmVEYXNoT2Zmc2V0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbGluZUpvaW5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaXRlckxpbWl0XG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFNldCByZWd1bGFyIHNoYXBlIHN0eWxlIGZvciB2ZWN0b3IgZmVhdHVyZXMuIFRoZSByZXN1bHRpbmcgc2hhcGUgd2lsbCBiZVxuICogYSByZWd1bGFyIHBvbHlnb24gd2hlbiBgcmFkaXVzYCBpcyBwcm92aWRlZCwgb3IgYSBzdGFyIHdoZW4gYHJhZGl1czFgIGFuZFxuICogYHJhZGl1czJgIGFyZSBwcm92aWRlZC5cbiAqIEBhcGlcbiAqL1xudmFyIFJlZ3VsYXJTaGFwZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEltYWdlU3R5bGUpIHtcbiAgZnVuY3Rpb24gUmVndWxhclNoYXBlKG9wdGlvbnMpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB2YXIgcm90YXRlV2l0aFZpZXcgPSBvcHRpb25zLnJvdGF0ZVdpdGhWaWV3ICE9PSB1bmRlZmluZWQgP1xuICAgICAgb3B0aW9ucy5yb3RhdGVXaXRoVmlldyA6IGZhbHNlO1xuXG4gICAgSW1hZ2VTdHlsZS5jYWxsKHRoaXMsIHtcbiAgICAgIG9wYWNpdHk6IDEsXG4gICAgICByb3RhdGVXaXRoVmlldzogcm90YXRlV2l0aFZpZXcsXG4gICAgICByb3RhdGlvbjogb3B0aW9ucy5yb3RhdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5yb3RhdGlvbiA6IDAsXG4gICAgICBzY2FsZTogMVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8c3RyaW5nfG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5jaGVja3N1bXNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuY2FudmFzXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmhpdERldGVjdGlvbkNhbnZhc18gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9GaWxsLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5maWxsXyA9IG9wdGlvbnMuZmlsbCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5maWxsIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5vcmlnaW5fID0gWzAsIDBdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucG9pbnRzXyA9IG9wdGlvbnMucG9pbnRzO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yYWRpdXNfID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChvcHRpb25zLnJhZGl1cyAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdGlvbnMucmFkaXVzIDogb3B0aW9ucy5yYWRpdXMxKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5yYWRpdXMyXyA9IG9wdGlvbnMucmFkaXVzMjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmFuZ2xlXyA9IG9wdGlvbnMuYW5nbGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYW5nbGUgOiAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLnN0cm9rZV8gPSBvcHRpb25zLnN0cm9rZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zdHJva2UgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLmFuY2hvcl8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfVxuICAgICAqL1xuICAgIHRoaXMuc2l6ZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VTaXplXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9XG4gICAgICovXG4gICAgdGhpcy5oaXREZXRlY3Rpb25JbWFnZVNpemVfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9BdGxhc01hbmFnZXIuanNcIikuZGVmYXVsdHx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5hdGxhc01hbmFnZXJfID0gb3B0aW9ucy5hdGxhc01hbmFnZXI7XG5cbiAgICB0aGlzLnJlbmRlcl8odGhpcy5hdGxhc01hbmFnZXJfKTtcblxuICB9XG5cbiAgaWYgKCBJbWFnZVN0eWxlICkgUmVndWxhclNoYXBlLl9fcHJvdG9fXyA9IEltYWdlU3R5bGU7XG4gIFJlZ3VsYXJTaGFwZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbWFnZVN0eWxlICYmIEltYWdlU3R5bGUucHJvdG90eXBlICk7XG4gIFJlZ3VsYXJTaGFwZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZWd1bGFyU2hhcGU7XG5cbiAgLyoqXG4gICAqIENsb25lcyB0aGUgc3R5bGUuIElmIGFuIGF0bGFzbWFuYWdlciB3YXMgcHJvdmlkZWQgdG8gdGhlIG9yaWdpbmFsIHN0eWxlIGl0IHdpbGwgYmUgdXNlZCBpbiB0aGUgY2xvbmVkIHN0eWxlLCB0b28uXG4gICAqIEByZXR1cm4ge1JlZ3VsYXJTaGFwZX0gVGhlIGNsb25lZCBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgUmVndWxhclNoYXBlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgICB2YXIgc3R5bGUgPSBuZXcgUmVndWxhclNoYXBlKHtcbiAgICAgIGZpbGw6IHRoaXMuZ2V0RmlsbCgpID8gdGhpcy5nZXRGaWxsKCkuY2xvbmUoKSA6IHVuZGVmaW5lZCxcbiAgICAgIHBvaW50czogdGhpcy5nZXRQb2ludHMoKSxcbiAgICAgIHJhZGl1czogdGhpcy5nZXRSYWRpdXMoKSxcbiAgICAgIHJhZGl1czI6IHRoaXMuZ2V0UmFkaXVzMigpLFxuICAgICAgYW5nbGU6IHRoaXMuZ2V0QW5nbGUoKSxcbiAgICAgIHN0cm9rZTogdGhpcy5nZXRTdHJva2UoKSA/IHRoaXMuZ2V0U3Ryb2tlKCkuY2xvbmUoKSA6IHVuZGVmaW5lZCxcbiAgICAgIHJvdGF0aW9uOiB0aGlzLmdldFJvdGF0aW9uKCksXG4gICAgICByb3RhdGVXaXRoVmlldzogdGhpcy5nZXRSb3RhdGVXaXRoVmlldygpLFxuICAgICAgYXRsYXNNYW5hZ2VyOiB0aGlzLmF0bGFzTWFuYWdlcl9cbiAgICB9KTtcbiAgICBzdHlsZS5zZXRPcGFjaXR5KHRoaXMuZ2V0T3BhY2l0eSgpKTtcbiAgICBzdHlsZS5zZXRTY2FsZSh0aGlzLmdldFNjYWxlKCkpO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGFwaVxuICAgKi9cbiAgUmVndWxhclNoYXBlLnByb3RvdHlwZS5nZXRBbmNob3IgPSBmdW5jdGlvbiBnZXRBbmNob3IgKCkge1xuICAgIHJldHVybiB0aGlzLmFuY2hvcl87XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYW5nbGUgdXNlZCBpbiBnZW5lcmF0aW5nIHRoZSBzaGFwZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBTaGFwZSdzIHJvdGF0aW9uIGluIHJhZGlhbnMuXG4gICAqIEBhcGlcbiAgICovXG4gIFJlZ3VsYXJTaGFwZS5wcm90b3R5cGUuZ2V0QW5nbGUgPSBmdW5jdGlvbiBnZXRBbmdsZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYW5nbGVfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGZpbGwgc3R5bGUgZm9yIHRoZSBzaGFwZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9GaWxsLmpzXCIpLmRlZmF1bHR9IEZpbGwgc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIFJlZ3VsYXJTaGFwZS5wcm90b3R5cGUuZ2V0RmlsbCA9IGZ1bmN0aW9uIGdldEZpbGwgKCkge1xuICAgIHJldHVybiB0aGlzLmZpbGxfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgUmVndWxhclNoYXBlLnByb3RvdHlwZS5nZXRIaXREZXRlY3Rpb25JbWFnZSA9IGZ1bmN0aW9uIGdldEhpdERldGVjdGlvbkltYWdlIChwaXhlbFJhdGlvKSB7XG4gICAgcmV0dXJuIHRoaXMuaGl0RGV0ZWN0aW9uQ2FudmFzXztcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGFwaVxuICAgKi9cbiAgUmVndWxhclNoYXBlLnByb3RvdHlwZS5nZXRJbWFnZSA9IGZ1bmN0aW9uIGdldEltYWdlIChwaXhlbFJhdGlvKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzXztcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIFJlZ3VsYXJTaGFwZS5wcm90b3R5cGUuZ2V0SW1hZ2VTaXplID0gZnVuY3Rpb24gZ2V0SW1hZ2VTaXplICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbWFnZVNpemVfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgUmVndWxhclNoYXBlLnByb3RvdHlwZS5nZXRIaXREZXRlY3Rpb25JbWFnZVNpemUgPSBmdW5jdGlvbiBnZXRIaXREZXRlY3Rpb25JbWFnZVNpemUgKCkge1xuICAgIHJldHVybiB0aGlzLmhpdERldGVjdGlvbkltYWdlU2l6ZV87XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBSZWd1bGFyU2hhcGUucHJvdG90eXBlLmdldEltYWdlU3RhdGUgPSBmdW5jdGlvbiBnZXRJbWFnZVN0YXRlICgpIHtcbiAgICByZXR1cm4gSW1hZ2VTdGF0ZS5MT0FERUQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqIEBhcGlcbiAgICovXG4gIFJlZ3VsYXJTaGFwZS5wcm90b3R5cGUuZ2V0T3JpZ2luID0gZnVuY3Rpb24gZ2V0T3JpZ2luICgpIHtcbiAgICByZXR1cm4gdGhpcy5vcmlnaW5fO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG51bWJlciBvZiBwb2ludHMgZm9yIGdlbmVyYXRpbmcgdGhlIHNoYXBlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE51bWJlciBvZiBwb2ludHMgZm9yIHN0YXJzIGFuZCByZWd1bGFyIHBvbHlnb25zLlxuICAgKiBAYXBpXG4gICAqL1xuICBSZWd1bGFyU2hhcGUucHJvdG90eXBlLmdldFBvaW50cyA9IGZ1bmN0aW9uIGdldFBvaW50cyAoKSB7XG4gICAgcmV0dXJuIHRoaXMucG9pbnRzXztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSAocHJpbWFyeSkgcmFkaXVzIGZvciB0aGUgc2hhcGUuXG4gICAqIEByZXR1cm4ge251bWJlcn0gUmFkaXVzLlxuICAgKiBAYXBpXG4gICAqL1xuICBSZWd1bGFyU2hhcGUucHJvdG90eXBlLmdldFJhZGl1cyA9IGZ1bmN0aW9uIGdldFJhZGl1cyAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmFkaXVzXztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBzZWNvbmRhcnkgcmFkaXVzIGZvciB0aGUgc2hhcGUuXG4gICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFJhZGl1czIuXG4gICAqIEBhcGlcbiAgICovXG4gIFJlZ3VsYXJTaGFwZS5wcm90b3R5cGUuZ2V0UmFkaXVzMiA9IGZ1bmN0aW9uIGdldFJhZGl1czIgKCkge1xuICAgIHJldHVybiB0aGlzLnJhZGl1czJfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKiBAYXBpXG4gICAqL1xuICBSZWd1bGFyU2hhcGUucHJvdG90eXBlLmdldFNpemUgPSBmdW5jdGlvbiBnZXRTaXplICgpIHtcbiAgICByZXR1cm4gdGhpcy5zaXplXztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBzdHJva2Ugc3R5bGUgZm9yIHRoZSBzaGFwZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdH0gU3Ryb2tlIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBSZWd1bGFyU2hhcGUucHJvdG90eXBlLmdldFN0cm9rZSA9IGZ1bmN0aW9uIGdldFN0cm9rZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3Ryb2tlXztcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIFJlZ3VsYXJTaGFwZS5wcm90b3R5cGUubGlzdGVuSW1hZ2VDaGFuZ2UgPSBmdW5jdGlvbiBsaXN0ZW5JbWFnZUNoYW5nZSAobGlzdGVuZXIsIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgUmVndWxhclNoYXBlLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gbG9hZCAoKSB7fTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIFJlZ3VsYXJTaGFwZS5wcm90b3R5cGUudW5saXN0ZW5JbWFnZUNoYW5nZSA9IGZ1bmN0aW9uIHVubGlzdGVuSW1hZ2VDaGFuZ2UgKGxpc3RlbmVyLCB0aGlzQXJnKSB7fTtcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vQXRsYXNNYW5hZ2VyLmpzXCIpLmRlZmF1bHR8dW5kZWZpbmVkfSBhdGxhc01hbmFnZXIgQW4gYXRsYXMgbWFuYWdlci5cbiAgICovXG4gIFJlZ3VsYXJTaGFwZS5wcm90b3R5cGUucmVuZGVyXyA9IGZ1bmN0aW9uIHJlbmRlcl8gKGF0bGFzTWFuYWdlcikge1xuICAgIHZhciBpbWFnZVNpemU7XG4gICAgdmFyIGxpbmVDYXAgPSAnJztcbiAgICB2YXIgbGluZUpvaW4gPSAnJztcbiAgICB2YXIgbWl0ZXJMaW1pdCA9IDA7XG4gICAgdmFyIGxpbmVEYXNoID0gbnVsbDtcbiAgICB2YXIgbGluZURhc2hPZmZzZXQgPSAwO1xuICAgIHZhciBzdHJva2VTdHlsZTtcbiAgICB2YXIgc3Ryb2tlV2lkdGggPSAwO1xuXG4gICAgaWYgKHRoaXMuc3Ryb2tlXykge1xuICAgICAgc3Ryb2tlU3R5bGUgPSB0aGlzLnN0cm9rZV8uZ2V0Q29sb3IoKTtcbiAgICAgIGlmIChzdHJva2VTdHlsZSA9PT0gbnVsbCkge1xuICAgICAgICBzdHJva2VTdHlsZSA9IGRlZmF1bHRTdHJva2VTdHlsZTtcbiAgICAgIH1cbiAgICAgIHN0cm9rZVN0eWxlID0gYXNDb2xvckxpa2Uoc3Ryb2tlU3R5bGUpO1xuICAgICAgc3Ryb2tlV2lkdGggPSB0aGlzLnN0cm9rZV8uZ2V0V2lkdGgoKTtcbiAgICAgIGlmIChzdHJva2VXaWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN0cm9rZVdpZHRoID0gZGVmYXVsdExpbmVXaWR0aDtcbiAgICAgIH1cbiAgICAgIGxpbmVEYXNoID0gdGhpcy5zdHJva2VfLmdldExpbmVEYXNoKCk7XG4gICAgICBsaW5lRGFzaE9mZnNldCA9IHRoaXMuc3Ryb2tlXy5nZXRMaW5lRGFzaE9mZnNldCgpO1xuICAgICAgaWYgKCFDQU5WQVNfTElORV9EQVNIKSB7XG4gICAgICAgIGxpbmVEYXNoID0gbnVsbDtcbiAgICAgICAgbGluZURhc2hPZmZzZXQgPSAwO1xuICAgICAgfVxuICAgICAgbGluZUpvaW4gPSB0aGlzLnN0cm9rZV8uZ2V0TGluZUpvaW4oKTtcbiAgICAgIGlmIChsaW5lSm9pbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxpbmVKb2luID0gZGVmYXVsdExpbmVKb2luO1xuICAgICAgfVxuICAgICAgbGluZUNhcCA9IHRoaXMuc3Ryb2tlXy5nZXRMaW5lQ2FwKCk7XG4gICAgICBpZiAobGluZUNhcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxpbmVDYXAgPSBkZWZhdWx0TGluZUNhcDtcbiAgICAgIH1cbiAgICAgIG1pdGVyTGltaXQgPSB0aGlzLnN0cm9rZV8uZ2V0TWl0ZXJMaW1pdCgpO1xuICAgICAgaWYgKG1pdGVyTGltaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtaXRlckxpbWl0ID0gZGVmYXVsdE1pdGVyTGltaXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNpemUgPSAyICogKHRoaXMucmFkaXVzXyArIHN0cm9rZVdpZHRoKSArIDE7XG5cbiAgICAvKiogQHR5cGUge1JlbmRlck9wdGlvbnN9ICovXG4gICAgdmFyIHJlbmRlck9wdGlvbnMgPSB7XG4gICAgICBzdHJva2VTdHlsZTogc3Ryb2tlU3R5bGUsXG4gICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgICBzaXplOiBzaXplLFxuICAgICAgbGluZUNhcDogbGluZUNhcCxcbiAgICAgIGxpbmVEYXNoOiBsaW5lRGFzaCxcbiAgICAgIGxpbmVEYXNoT2Zmc2V0OiBsaW5lRGFzaE9mZnNldCxcbiAgICAgIGxpbmVKb2luOiBsaW5lSm9pbixcbiAgICAgIG1pdGVyTGltaXQ6IG1pdGVyTGltaXRcbiAgICB9O1xuXG4gICAgaWYgKGF0bGFzTWFuYWdlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBubyBhdGxhcyBtYW5hZ2VyIGlzIHVzZWQsIGNyZWF0ZSBhIG5ldyBjYW52YXNcbiAgICAgIHZhciBjb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKHNpemUsIHNpemUpO1xuICAgICAgdGhpcy5jYW52YXNfID0gY29udGV4dC5jYW52YXM7XG5cbiAgICAgIC8vIGNhbnZhcy53aWR0aCBhbmQgaGVpZ2h0IGFyZSByb3VuZGVkIHRvIHRoZSBjbG9zZXN0IGludGVnZXJcbiAgICAgIHNpemUgPSB0aGlzLmNhbnZhc18ud2lkdGg7XG4gICAgICBpbWFnZVNpemUgPSBzaXplO1xuXG4gICAgICB0aGlzLmRyYXdfKHJlbmRlck9wdGlvbnMsIGNvbnRleHQsIDAsIDApO1xuXG4gICAgICB0aGlzLmNyZWF0ZUhpdERldGVjdGlvbkNhbnZhc18ocmVuZGVyT3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGFuIGF0bGFzIG1hbmFnZXIgaXMgdXNlZCwgYWRkIHRoZSBzeW1ib2wgdG8gYW4gYXRsYXNcbiAgICAgIHNpemUgPSBNYXRoLnJvdW5kKHNpemUpO1xuXG4gICAgICB2YXIgaGFzQ3VzdG9tSGl0RGV0ZWN0aW9uSW1hZ2UgPSAhdGhpcy5maWxsXztcbiAgICAgIHZhciByZW5kZXJIaXREZXRlY3Rpb25DYWxsYmFjaztcbiAgICAgIGlmIChoYXNDdXN0b21IaXREZXRlY3Rpb25JbWFnZSkge1xuICAgICAgICAvLyByZW5kZXIgdGhlIGhpdC1kZXRlY3Rpb24gaW1hZ2UgaW50byBhIHNlcGFyYXRlIGF0bGFzIGltYWdlXG4gICAgICAgIHJlbmRlckhpdERldGVjdGlvbkNhbGxiYWNrID1cbiAgICAgICAgICAgIHRoaXMuZHJhd0hpdERldGVjdGlvbkNhbnZhc18uYmluZCh0aGlzLCByZW5kZXJPcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlkID0gdGhpcy5nZXRDaGVja3N1bSgpO1xuICAgICAgdmFyIGluZm8gPSBhdGxhc01hbmFnZXIuYWRkKFxuICAgICAgICBpZCwgc2l6ZSwgc2l6ZSwgdGhpcy5kcmF3Xy5iaW5kKHRoaXMsIHJlbmRlck9wdGlvbnMpLFxuICAgICAgICByZW5kZXJIaXREZXRlY3Rpb25DYWxsYmFjayk7XG5cbiAgICAgIHRoaXMuY2FudmFzXyA9IGluZm8uaW1hZ2U7XG4gICAgICB0aGlzLm9yaWdpbl8gPSBbaW5mby5vZmZzZXRYLCBpbmZvLm9mZnNldFldO1xuICAgICAgaW1hZ2VTaXplID0gaW5mby5pbWFnZS53aWR0aDtcblxuICAgICAgaWYgKGhhc0N1c3RvbUhpdERldGVjdGlvbkltYWdlKSB7XG4gICAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uQ2FudmFzXyA9IGluZm8uaGl0SW1hZ2U7XG4gICAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW1hZ2VTaXplXyA9XG4gICAgICAgICAgICBbaW5mby5oaXRJbWFnZS53aWR0aCwgaW5mby5oaXRJbWFnZS5oZWlnaHRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oaXREZXRlY3Rpb25DYW52YXNfID0gdGhpcy5jYW52YXNfO1xuICAgICAgICB0aGlzLmhpdERldGVjdGlvbkltYWdlU2l6ZV8gPSBbaW1hZ2VTaXplLCBpbWFnZVNpemVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYW5jaG9yXyA9IFtzaXplIC8gMiwgc2l6ZSAvIDJdO1xuICAgIHRoaXMuc2l6ZV8gPSBbc2l6ZSwgc2l6ZV07XG4gICAgdGhpcy5pbWFnZVNpemVfID0gW2ltYWdlU2l6ZSwgaW1hZ2VTaXplXTtcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtSZW5kZXJPcHRpb25zfSByZW5kZXJPcHRpb25zIFJlbmRlciBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBUaGUgcmVuZGVyaW5nIGNvbnRleHQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFRoZSBvcmlnaW4gZm9yIHRoZSBzeW1ib2wgKHgpLlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBUaGUgb3JpZ2luIGZvciB0aGUgc3ltYm9sICh5KS5cbiAgICovXG4gIFJlZ3VsYXJTaGFwZS5wcm90b3R5cGUuZHJhd18gPSBmdW5jdGlvbiBkcmF3XyAocmVuZGVyT3B0aW9ucywgY29udGV4dCwgeCwgeSkge1xuICAgIHZhciBpLCBhbmdsZTAsIHJhZGl1c0M7XG4gICAgLy8gcmVzZXQgdHJhbnNmb3JtXG4gICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cbiAgICAvLyB0aGVuIG1vdmUgdG8gKHgsIHkpXG4gICAgY29udGV4dC50cmFuc2xhdGUoeCwgeSk7XG5cbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuXG4gICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzXztcbiAgICBpZiAocG9pbnRzID09PSBJbmZpbml0eSkge1xuICAgICAgY29udGV4dC5hcmMoXG4gICAgICAgIHJlbmRlck9wdGlvbnMuc2l6ZSAvIDIsIHJlbmRlck9wdGlvbnMuc2l6ZSAvIDIsXG4gICAgICAgIHRoaXMucmFkaXVzXywgMCwgMiAqIE1hdGguUEksIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmFkaXVzMiA9ICh0aGlzLnJhZGl1czJfICE9PSB1bmRlZmluZWQpID8gdGhpcy5yYWRpdXMyX1xuICAgICAgICA6IHRoaXMucmFkaXVzXztcbiAgICAgIGlmIChyYWRpdXMyICE9PSB0aGlzLnJhZGl1c18pIHtcbiAgICAgICAgcG9pbnRzID0gMiAqIHBvaW50cztcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPD0gcG9pbnRzOyBpKyspIHtcbiAgICAgICAgYW5nbGUwID0gaSAqIDIgKiBNYXRoLlBJIC8gcG9pbnRzIC0gTWF0aC5QSSAvIDIgKyB0aGlzLmFuZ2xlXztcbiAgICAgICAgcmFkaXVzQyA9IGkgJSAyID09PSAwID8gdGhpcy5yYWRpdXNfIDogcmFkaXVzMjtcbiAgICAgICAgY29udGV4dC5saW5lVG8ocmVuZGVyT3B0aW9ucy5zaXplIC8gMiArIHJhZGl1c0MgKiBNYXRoLmNvcyhhbmdsZTApLFxuICAgICAgICAgIHJlbmRlck9wdGlvbnMuc2l6ZSAvIDIgKyByYWRpdXNDICogTWF0aC5zaW4oYW5nbGUwKSk7XG4gICAgICB9XG4gICAgfVxuXG5cbiAgICBpZiAodGhpcy5maWxsXykge1xuICAgICAgdmFyIGNvbG9yID0gdGhpcy5maWxsXy5nZXRDb2xvcigpO1xuICAgICAgaWYgKGNvbG9yID09PSBudWxsKSB7XG4gICAgICAgIGNvbG9yID0gZGVmYXVsdEZpbGxTdHlsZTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gYXNDb2xvckxpa2UoY29sb3IpO1xuICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnN0cm9rZV8pIHtcbiAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSByZW5kZXJPcHRpb25zLnN0cm9rZVN0eWxlO1xuICAgICAgY29udGV4dC5saW5lV2lkdGggPSByZW5kZXJPcHRpb25zLnN0cm9rZVdpZHRoO1xuICAgICAgaWYgKHJlbmRlck9wdGlvbnMubGluZURhc2gpIHtcbiAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChyZW5kZXJPcHRpb25zLmxpbmVEYXNoKTtcbiAgICAgICAgY29udGV4dC5saW5lRGFzaE9mZnNldCA9IHJlbmRlck9wdGlvbnMubGluZURhc2hPZmZzZXQ7XG4gICAgICB9XG4gICAgICBjb250ZXh0LmxpbmVDYXAgPSAvKiogQHR5cGUge0NhbnZhc0xpbmVDYXB9ICovIChyZW5kZXJPcHRpb25zLmxpbmVDYXApO1xuICAgICAgY29udGV4dC5saW5lSm9pbiA9IC8qKiBAdHlwZSB7Q2FudmFzTGluZUpvaW59ICovIChyZW5kZXJPcHRpb25zLmxpbmVKb2luKTtcbiAgICAgIGNvbnRleHQubWl0ZXJMaW1pdCA9IHJlbmRlck9wdGlvbnMubWl0ZXJMaW1pdDtcbiAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgfVxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UmVuZGVyT3B0aW9uc30gcmVuZGVyT3B0aW9ucyBSZW5kZXIgb3B0aW9ucy5cbiAgICovXG4gIFJlZ3VsYXJTaGFwZS5wcm90b3R5cGUuY3JlYXRlSGl0RGV0ZWN0aW9uQ2FudmFzXyA9IGZ1bmN0aW9uIGNyZWF0ZUhpdERldGVjdGlvbkNhbnZhc18gKHJlbmRlck9wdGlvbnMpIHtcbiAgICB0aGlzLmhpdERldGVjdGlvbkltYWdlU2l6ZV8gPSBbcmVuZGVyT3B0aW9ucy5zaXplLCByZW5kZXJPcHRpb25zLnNpemVdO1xuICAgIGlmICh0aGlzLmZpbGxfKSB7XG4gICAgICB0aGlzLmhpdERldGVjdGlvbkNhbnZhc18gPSB0aGlzLmNhbnZhc187XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaWYgbm8gZmlsbCBzdHlsZSBpcyBzZXQsIGNyZWF0ZSBhbiBleHRyYSBoaXQtZGV0ZWN0aW9uIGltYWdlIHdpdGggYVxuICAgIC8vIGRlZmF1bHQgZmlsbCBzdHlsZVxuICAgIHZhciBjb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKHJlbmRlck9wdGlvbnMuc2l6ZSwgcmVuZGVyT3B0aW9ucy5zaXplKTtcbiAgICB0aGlzLmhpdERldGVjdGlvbkNhbnZhc18gPSBjb250ZXh0LmNhbnZhcztcblxuICAgIHRoaXMuZHJhd0hpdERldGVjdGlvbkNhbnZhc18ocmVuZGVyT3B0aW9ucywgY29udGV4dCwgMCwgMCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UmVuZGVyT3B0aW9uc30gcmVuZGVyT3B0aW9ucyBSZW5kZXIgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgVGhlIGNvbnRleHQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFRoZSBvcmlnaW4gZm9yIHRoZSBzeW1ib2wgKHgpLlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBUaGUgb3JpZ2luIGZvciB0aGUgc3ltYm9sICh5KS5cbiAgICovXG4gIFJlZ3VsYXJTaGFwZS5wcm90b3R5cGUuZHJhd0hpdERldGVjdGlvbkNhbnZhc18gPSBmdW5jdGlvbiBkcmF3SGl0RGV0ZWN0aW9uQ2FudmFzXyAocmVuZGVyT3B0aW9ucywgY29udGV4dCwgeCwgeSkge1xuICAgIC8vIHJlc2V0IHRyYW5zZm9ybVxuICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXG4gICAgLy8gdGhlbiBtb3ZlIHRvICh4LCB5KVxuICAgIGNvbnRleHQudHJhbnNsYXRlKHgsIHkpO1xuXG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcblxuICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50c187XG4gICAgaWYgKHBvaW50cyA9PT0gSW5maW5pdHkpIHtcbiAgICAgIGNvbnRleHQuYXJjKFxuICAgICAgICByZW5kZXJPcHRpb25zLnNpemUgLyAyLCByZW5kZXJPcHRpb25zLnNpemUgLyAyLFxuICAgICAgICB0aGlzLnJhZGl1c18sIDAsIDIgKiBNYXRoLlBJLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJhZGl1czIgPSAodGhpcy5yYWRpdXMyXyAhPT0gdW5kZWZpbmVkKSA/IHRoaXMucmFkaXVzMl9cbiAgICAgICAgOiB0aGlzLnJhZGl1c187XG4gICAgICBpZiAocmFkaXVzMiAhPT0gdGhpcy5yYWRpdXNfKSB7XG4gICAgICAgIHBvaW50cyA9IDIgKiBwb2ludHM7XG4gICAgICB9XG4gICAgICB2YXIgaSwgcmFkaXVzQywgYW5nbGUwO1xuICAgICAgZm9yIChpID0gMDsgaSA8PSBwb2ludHM7IGkrKykge1xuICAgICAgICBhbmdsZTAgPSBpICogMiAqIE1hdGguUEkgLyBwb2ludHMgLSBNYXRoLlBJIC8gMiArIHRoaXMuYW5nbGVfO1xuICAgICAgICByYWRpdXNDID0gaSAlIDIgPT09IDAgPyB0aGlzLnJhZGl1c18gOiByYWRpdXMyO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyhyZW5kZXJPcHRpb25zLnNpemUgLyAyICsgcmFkaXVzQyAqIE1hdGguY29zKGFuZ2xlMCksXG4gICAgICAgICAgcmVuZGVyT3B0aW9ucy5zaXplIC8gMiArIHJhZGl1c0MgKiBNYXRoLnNpbihhbmdsZTApKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGFzU3RyaW5nKGRlZmF1bHRGaWxsU3R5bGUpO1xuICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIGlmICh0aGlzLnN0cm9rZV8pIHtcbiAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSByZW5kZXJPcHRpb25zLnN0cm9rZVN0eWxlO1xuICAgICAgY29udGV4dC5saW5lV2lkdGggPSByZW5kZXJPcHRpb25zLnN0cm9rZVdpZHRoO1xuICAgICAgaWYgKHJlbmRlck9wdGlvbnMubGluZURhc2gpIHtcbiAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChyZW5kZXJPcHRpb25zLmxpbmVEYXNoKTtcbiAgICAgICAgY29udGV4dC5saW5lRGFzaE9mZnNldCA9IHJlbmRlck9wdGlvbnMubGluZURhc2hPZmZzZXQ7XG4gICAgICB9XG4gICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgIH1cbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjaGVja3N1bS5cbiAgICovXG4gIFJlZ3VsYXJTaGFwZS5wcm90b3R5cGUuZ2V0Q2hlY2tzdW0gPSBmdW5jdGlvbiBnZXRDaGVja3N1bSAoKSB7XG4gICAgdmFyIHN0cm9rZUNoZWNrc3VtID0gdGhpcy5zdHJva2VfID9cbiAgICAgIHRoaXMuc3Ryb2tlXy5nZXRDaGVja3N1bSgpIDogJy0nO1xuICAgIHZhciBmaWxsQ2hlY2tzdW0gPSB0aGlzLmZpbGxfID9cbiAgICAgIHRoaXMuZmlsbF8uZ2V0Q2hlY2tzdW0oKSA6ICctJztcblxuICAgIHZhciByZWNhbGN1bGF0ZSA9ICF0aGlzLmNoZWNrc3Vtc18gfHxcbiAgICAgICAgKHN0cm9rZUNoZWNrc3VtICE9IHRoaXMuY2hlY2tzdW1zX1sxXSB8fFxuICAgICAgICBmaWxsQ2hlY2tzdW0gIT0gdGhpcy5jaGVja3N1bXNfWzJdIHx8XG4gICAgICAgIHRoaXMucmFkaXVzXyAhPSB0aGlzLmNoZWNrc3Vtc19bM10gfHxcbiAgICAgICAgdGhpcy5yYWRpdXMyXyAhPSB0aGlzLmNoZWNrc3Vtc19bNF0gfHxcbiAgICAgICAgdGhpcy5hbmdsZV8gIT0gdGhpcy5jaGVja3N1bXNfWzVdIHx8XG4gICAgICAgIHRoaXMucG9pbnRzXyAhPSB0aGlzLmNoZWNrc3Vtc19bNl0pO1xuXG4gICAgaWYgKHJlY2FsY3VsYXRlKSB7XG4gICAgICB2YXIgY2hlY2tzdW0gPSAncicgKyBzdHJva2VDaGVja3N1bSArIGZpbGxDaGVja3N1bSArXG4gICAgICAgICAgKHRoaXMucmFkaXVzXyAhPT0gdW5kZWZpbmVkID8gdGhpcy5yYWRpdXNfLnRvU3RyaW5nKCkgOiAnLScpICtcbiAgICAgICAgICAodGhpcy5yYWRpdXMyXyAhPT0gdW5kZWZpbmVkID8gdGhpcy5yYWRpdXMyXy50b1N0cmluZygpIDogJy0nKSArXG4gICAgICAgICAgKHRoaXMuYW5nbGVfICE9PSB1bmRlZmluZWQgPyB0aGlzLmFuZ2xlXy50b1N0cmluZygpIDogJy0nKSArXG4gICAgICAgICAgKHRoaXMucG9pbnRzXyAhPT0gdW5kZWZpbmVkID8gdGhpcy5wb2ludHNfLnRvU3RyaW5nKCkgOiAnLScpO1xuICAgICAgdGhpcy5jaGVja3N1bXNfID0gW2NoZWNrc3VtLCBzdHJva2VDaGVja3N1bSwgZmlsbENoZWNrc3VtLFxuICAgICAgICB0aGlzLnJhZGl1c18sIHRoaXMucmFkaXVzMl8sIHRoaXMuYW5nbGVfLCB0aGlzLnBvaW50c19dO1xuICAgIH1cblxuICAgIHJldHVybiAvKiogQHR5cGUge3N0cmluZ30gKi8gKHRoaXMuY2hlY2tzdW1zX1swXSk7XG4gIH07XG5cbiAgcmV0dXJuIFJlZ3VsYXJTaGFwZTtcbn0oSW1hZ2VTdHlsZSkpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IFJlZ3VsYXJTaGFwZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVndWxhclNoYXBlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9zdHlsZS9TdHJva2VcbiAqL1xuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4uL3V0aWwuanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcnxpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfSBbY29sb3JdIEEgY29sb3IsIGdyYWRpZW50IG9yIHBhdHRlcm4uXG4gKiBTZWUge0BsaW5rIG1vZHVsZTpvbC9jb2xvcn5Db2xvcn0gYW5kIHtAbGluayBtb2R1bGU6b2wvY29sb3JsaWtlfkNvbG9yTGlrZX0gZm9yIHBvc3NpYmxlIGZvcm1hdHMuXG4gKiBEZWZhdWx0IG51bGw7IGlmIG51bGwsIHRoZSBDYW52YXMvcmVuZGVyZXIgZGVmYXVsdCBibGFjayB3aWxsIGJlIHVzZWQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2xpbmVDYXA9J3JvdW5kJ10gTGluZSBjYXAgc3R5bGU6IGBidXR0YCwgYHJvdW5kYCwgb3IgYHNxdWFyZWAuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2xpbmVKb2luPSdyb3VuZCddIExpbmUgam9pbiBzdHlsZTogYGJldmVsYCwgYHJvdW5kYCwgb3IgYG1pdGVyYC5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gW2xpbmVEYXNoXSBMaW5lIGRhc2ggcGF0dGVybi4gRGVmYXVsdCBpcyBgdW5kZWZpbmVkYCAobm8gZGFzaCkuXG4gKiBQbGVhc2Ugbm90ZSB0aGF0IEludGVybmV0IEV4cGxvcmVyIDEwIGFuZCBsb3dlciBkbyBub3Qgc3VwcG9ydCB0aGUgYHNldExpbmVEYXNoYCBtZXRob2Qgb25cbiAqIHRoZSBgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEYCBhbmQgdGhlcmVmb3JlIHRoaXMgb3B0aW9uIHdpbGwgaGF2ZSBubyB2aXN1YWwgZWZmZWN0IGluIHRoZXNlIGJyb3dzZXJzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtsaW5lRGFzaE9mZnNldD0wXSBMaW5lIGRhc2ggb2Zmc2V0LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaXRlckxpbWl0PTEwXSBNaXRlciBsaW1pdC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbd2lkdGhdIFdpZHRoLlxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBTZXQgc3Ryb2tlIHN0eWxlIGZvciB2ZWN0b3IgZmVhdHVyZXMuXG4gKiBOb3RlIHRoYXQgdGhlIGRlZmF1bHRzIGdpdmVuIGFyZSB0aGUgQ2FudmFzIGRlZmF1bHRzLCB3aGljaCB3aWxsIGJlIHVzZWQgaWZcbiAqIG9wdGlvbiBpcyBub3QgZGVmaW5lZC4gVGhlIGBnZXRgIGZ1bmN0aW9ucyByZXR1cm4gd2hhdGV2ZXIgd2FzIGVudGVyZWQgaW5cbiAqIHRoZSBvcHRpb25zOyB0aGV5IHdpbGwgbm90IHJldHVybiB0aGUgZGVmYXVsdC5cbiAqIEBhcGlcbiAqL1xudmFyIFN0cm9rZSA9IGZ1bmN0aW9uIFN0cm9rZShvcHRfb3B0aW9ucykge1xuXG4gIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgfHwge307XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcnxpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfVxuICAgKi9cbiAgdGhpcy5jb2xvcl8gPSBvcHRpb25zLmNvbG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNvbG9yIDogbnVsbDtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9XG4gICAqL1xuICB0aGlzLmxpbmVDYXBfID0gb3B0aW9ucy5saW5lQ2FwO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICovXG4gIHRoaXMubGluZURhc2hfID0gb3B0aW9ucy5saW5lRGFzaCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5saW5lRGFzaCA6IG51bGw7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgKi9cbiAgdGhpcy5saW5lRGFzaE9mZnNldF8gPSBvcHRpb25zLmxpbmVEYXNoT2Zmc2V0O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7c3RyaW5nfHVuZGVmaW5lZH1cbiAgICovXG4gIHRoaXMubGluZUpvaW5fID0gb3B0aW9ucy5saW5lSm9pbjtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAqL1xuICB0aGlzLm1pdGVyTGltaXRfID0gb3B0aW9ucy5taXRlckxpbWl0O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICovXG4gIHRoaXMud2lkdGhfID0gb3B0aW9ucy53aWR0aDtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9XG4gICAqL1xuICB0aGlzLmNoZWNrc3VtXyA9IHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogQ2xvbmVzIHRoZSBzdHlsZS5cbiAqIEByZXR1cm4ge1N0cm9rZX0gVGhlIGNsb25lZCBzdHlsZS5cbiAqIEBhcGlcbiAqL1xuU3Ryb2tlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgdmFyIGNvbG9yID0gdGhpcy5nZXRDb2xvcigpO1xuICByZXR1cm4gbmV3IFN0cm9rZSh7XG4gICAgY29sb3I6IEFycmF5LmlzQXJyYXkoY29sb3IpID8gY29sb3Iuc2xpY2UoKSA6IGNvbG9yIHx8IHVuZGVmaW5lZCxcbiAgICBsaW5lQ2FwOiB0aGlzLmdldExpbmVDYXAoKSxcbiAgICBsaW5lRGFzaDogdGhpcy5nZXRMaW5lRGFzaCgpID8gdGhpcy5nZXRMaW5lRGFzaCgpLnNsaWNlKCkgOiB1bmRlZmluZWQsXG4gICAgbGluZURhc2hPZmZzZXQ6IHRoaXMuZ2V0TGluZURhc2hPZmZzZXQoKSxcbiAgICBsaW5lSm9pbjogdGhpcy5nZXRMaW5lSm9pbigpLFxuICAgIG1pdGVyTGltaXQ6IHRoaXMuZ2V0TWl0ZXJMaW1pdCgpLFxuICAgIHdpZHRoOiB0aGlzLmdldFdpZHRoKClcbiAgfSk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgc3Ryb2tlIGNvbG9yLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J8aW1wb3J0KFwiLi4vY29sb3JsaWtlLmpzXCIpLkNvbG9yTGlrZX0gQ29sb3IuXG4gKiBAYXBpXG4gKi9cblN0cm9rZS5wcm90b3R5cGUuZ2V0Q29sb3IgPSBmdW5jdGlvbiBnZXRDb2xvciAoKSB7XG4gIHJldHVybiB0aGlzLmNvbG9yXztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBsaW5lIGNhcCB0eXBlIGZvciB0aGUgc3Ryb2tlLlxuICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0gTGluZSBjYXAuXG4gKiBAYXBpXG4gKi9cblN0cm9rZS5wcm90b3R5cGUuZ2V0TGluZUNhcCA9IGZ1bmN0aW9uIGdldExpbmVDYXAgKCkge1xuICByZXR1cm4gdGhpcy5saW5lQ2FwXztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBsaW5lIGRhc2ggc3R5bGUgZm9yIHRoZSBzdHJva2UuXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBMaW5lIGRhc2guXG4gKiBAYXBpXG4gKi9cblN0cm9rZS5wcm90b3R5cGUuZ2V0TGluZURhc2ggPSBmdW5jdGlvbiBnZXRMaW5lRGFzaCAoKSB7XG4gIHJldHVybiB0aGlzLmxpbmVEYXNoXztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBsaW5lIGRhc2ggb2Zmc2V0IGZvciB0aGUgc3Ryb2tlLlxuICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gTGluZSBkYXNoIG9mZnNldC5cbiAqIEBhcGlcbiAqL1xuU3Ryb2tlLnByb3RvdHlwZS5nZXRMaW5lRGFzaE9mZnNldCA9IGZ1bmN0aW9uIGdldExpbmVEYXNoT2Zmc2V0ICgpIHtcbiAgcmV0dXJuIHRoaXMubGluZURhc2hPZmZzZXRfO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGxpbmUgam9pbiB0eXBlIGZvciB0aGUgc3Ryb2tlLlxuICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0gTGluZSBqb2luLlxuICogQGFwaVxuICovXG5TdHJva2UucHJvdG90eXBlLmdldExpbmVKb2luID0gZnVuY3Rpb24gZ2V0TGluZUpvaW4gKCkge1xuICByZXR1cm4gdGhpcy5saW5lSm9pbl87XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbWl0ZXIgbGltaXQgZm9yIHRoZSBzdHJva2UuXG4gKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBNaXRlciBsaW1pdC5cbiAqIEBhcGlcbiAqL1xuU3Ryb2tlLnByb3RvdHlwZS5nZXRNaXRlckxpbWl0ID0gZnVuY3Rpb24gZ2V0TWl0ZXJMaW1pdCAoKSB7XG4gIHJldHVybiB0aGlzLm1pdGVyTGltaXRfO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHN0cm9rZSB3aWR0aC5cbiAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFdpZHRoLlxuICogQGFwaVxuICovXG5TdHJva2UucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24gZ2V0V2lkdGggKCkge1xuICByZXR1cm4gdGhpcy53aWR0aF87XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29sb3IuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcnxpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfSBjb2xvciBDb2xvci5cbiAqIEBhcGlcbiAqL1xuU3Ryb2tlLnByb3RvdHlwZS5zZXRDb2xvciA9IGZ1bmN0aW9uIHNldENvbG9yIChjb2xvcikge1xuICB0aGlzLmNvbG9yXyA9IGNvbG9yO1xuICB0aGlzLmNoZWNrc3VtXyA9IHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBsaW5lIGNhcC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IGxpbmVDYXAgTGluZSBjYXAuXG4gKiBAYXBpXG4gKi9cblN0cm9rZS5wcm90b3R5cGUuc2V0TGluZUNhcCA9IGZ1bmN0aW9uIHNldExpbmVDYXAgKGxpbmVDYXApIHtcbiAgdGhpcy5saW5lQ2FwXyA9IGxpbmVDYXA7XG4gIHRoaXMuY2hlY2tzdW1fID0gdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGxpbmUgZGFzaC5cbiAqXG4gKiBQbGVhc2Ugbm90ZSB0aGF0IEludGVybmV0IEV4cGxvcmVyIDEwIGFuZCBsb3dlciBbZG8gbm90IHN1cHBvcnRdW21kbl0gdGhlXG4gKiBgc2V0TGluZURhc2hgIG1ldGhvZCBvbiB0aGUgYENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRGAgYW5kIHRoZXJlZm9yZSB0aGlzXG4gKiBwcm9wZXJ0eSB3aWxsIGhhdmUgbm8gdmlzdWFsIGVmZmVjdCBpbiB0aGVzZSBicm93c2Vycy5cbiAqXG4gKiBbbWRuXTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9zZXRMaW5lRGFzaCNCcm93c2VyX2NvbXBhdGliaWxpdHlcbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGxpbmVEYXNoIExpbmUgZGFzaC5cbiAqIEBhcGlcbiAqL1xuU3Ryb2tlLnByb3RvdHlwZS5zZXRMaW5lRGFzaCA9IGZ1bmN0aW9uIHNldExpbmVEYXNoIChsaW5lRGFzaCkge1xuICB0aGlzLmxpbmVEYXNoXyA9IGxpbmVEYXNoO1xuICB0aGlzLmNoZWNrc3VtXyA9IHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBsaW5lIGRhc2ggb2Zmc2V0LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gbGluZURhc2hPZmZzZXQgTGluZSBkYXNoIG9mZnNldC5cbiAqIEBhcGlcbiAqL1xuU3Ryb2tlLnByb3RvdHlwZS5zZXRMaW5lRGFzaE9mZnNldCA9IGZ1bmN0aW9uIHNldExpbmVEYXNoT2Zmc2V0IChsaW5lRGFzaE9mZnNldCkge1xuICB0aGlzLmxpbmVEYXNoT2Zmc2V0XyA9IGxpbmVEYXNoT2Zmc2V0O1xuICB0aGlzLmNoZWNrc3VtXyA9IHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBsaW5lIGpvaW4uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSBsaW5lSm9pbiBMaW5lIGpvaW4uXG4gKiBAYXBpXG4gKi9cblN0cm9rZS5wcm90b3R5cGUuc2V0TGluZUpvaW4gPSBmdW5jdGlvbiBzZXRMaW5lSm9pbiAobGluZUpvaW4pIHtcbiAgdGhpcy5saW5lSm9pbl8gPSBsaW5lSm9pbjtcbiAgdGhpcy5jaGVja3N1bV8gPSB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbWl0ZXIgbGltaXQuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSBtaXRlckxpbWl0IE1pdGVyIGxpbWl0LlxuICogQGFwaVxuICovXG5TdHJva2UucHJvdG90eXBlLnNldE1pdGVyTGltaXQgPSBmdW5jdGlvbiBzZXRNaXRlckxpbWl0IChtaXRlckxpbWl0KSB7XG4gIHRoaXMubWl0ZXJMaW1pdF8gPSBtaXRlckxpbWl0O1xuICB0aGlzLmNoZWNrc3VtXyA9IHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSB3aWR0aC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHdpZHRoIFdpZHRoLlxuICogQGFwaVxuICovXG5TdHJva2UucHJvdG90eXBlLnNldFdpZHRoID0gZnVuY3Rpb24gc2V0V2lkdGggKHdpZHRoKSB7XG4gIHRoaXMud2lkdGhfID0gd2lkdGg7XG4gIHRoaXMuY2hlY2tzdW1fID0gdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjaGVja3N1bS5cbiAqL1xuU3Ryb2tlLnByb3RvdHlwZS5nZXRDaGVja3N1bSA9IGZ1bmN0aW9uIGdldENoZWNrc3VtICgpIHtcbiAgaWYgKHRoaXMuY2hlY2tzdW1fID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLmNoZWNrc3VtXyA9ICdzJztcbiAgICBpZiAodGhpcy5jb2xvcl8pIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5jb2xvcl8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuY2hlY2tzdW1fICs9IHRoaXMuY29sb3JfO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jaGVja3N1bV8gKz0gZ2V0VWlkKHRoaXMuY29sb3JfKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jaGVja3N1bV8gKz0gJy0nO1xuICAgIH1cbiAgICB0aGlzLmNoZWNrc3VtXyArPSAnLCcgK1xuICAgICAgICAodGhpcy5saW5lQ2FwXyAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICB0aGlzLmxpbmVDYXBfLnRvU3RyaW5nKCkgOiAnLScpICsgJywnICtcbiAgICAgICAgKHRoaXMubGluZURhc2hfID9cbiAgICAgICAgICB0aGlzLmxpbmVEYXNoXy50b1N0cmluZygpIDogJy0nKSArICcsJyArXG4gICAgICAgICh0aGlzLmxpbmVEYXNoT2Zmc2V0XyAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICB0aGlzLmxpbmVEYXNoT2Zmc2V0XyA6ICctJykgKyAnLCcgK1xuICAgICAgICAodGhpcy5saW5lSm9pbl8gIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgdGhpcy5saW5lSm9pbl8gOiAnLScpICsgJywnICtcbiAgICAgICAgKHRoaXMubWl0ZXJMaW1pdF8gIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgdGhpcy5taXRlckxpbWl0Xy50b1N0cmluZygpIDogJy0nKSArICcsJyArXG4gICAgICAgICh0aGlzLndpZHRoXyAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICB0aGlzLndpZHRoXy50b1N0cmluZygpIDogJy0nKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmNoZWNrc3VtXztcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFN0cm9rZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3Ryb2tlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9zdHlsZS9TdHlsZVxuICovXG5cbi8qKlxuICogRmVhdHVyZSBzdHlsZXMuXG4gKlxuICogSWYgbm8gc3R5bGUgaXMgZGVmaW5lZCwgdGhlIGZvbGxvd2luZyBkZWZhdWx0IHN0eWxlIGlzIHVzZWQ6XG4gKiBgYGBqc1xuICogIGltcG9ydCB7RmlsbCwgU3Ryb2tlLCBDaXJjbGUsIFN0eWxlfSBmcm9tICdvbC9zdHlsZSc7XG4gKlxuICogIHZhciBmaWxsID0gbmV3IEZpbGwoe1xuICogICAgY29sb3I6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNCknXG4gKiAgfSk7XG4gKiAgdmFyIHN0cm9rZSA9IG5ldyBTdHJva2Uoe1xuICogICAgY29sb3I6ICcjMzM5OUNDJyxcbiAqICAgIHdpZHRoOiAxLjI1XG4gKiAgfSk7XG4gKiAgdmFyIHN0eWxlcyA9IFtcbiAqICAgIG5ldyBTdHlsZSh7XG4gKiAgICAgIGltYWdlOiBuZXcgQ2lyY2xlKHtcbiAqICAgICAgICBmaWxsOiBmaWxsLFxuICogICAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICogICAgICAgIHJhZGl1czogNVxuICogICAgICB9KSxcbiAqICAgICAgZmlsbDogZmlsbCxcbiAqICAgICAgc3Ryb2tlOiBzdHJva2VcbiAqICAgIH0pXG4gKiAgXTtcbiAqIGBgYFxuICpcbiAqIEEgc2VwYXJhdGUgZWRpdGluZyBzdHlsZSBoYXMgdGhlIGZvbGxvd2luZyBkZWZhdWx0czpcbiAqIGBgYGpzXG4gKiAgaW1wb3J0IHtGaWxsLCBTdHJva2UsIENpcmNsZSwgU3R5bGV9IGZyb20gJ29sL3N0eWxlJztcbiAqICBpbXBvcnQgR2VvbWV0cnlUeXBlIGZyb20gJ29sL2dlb20vR2VvbWV0cnlUeXBlJztcbiAqXG4gKiAgdmFyIHdoaXRlID0gWzI1NSwgMjU1LCAyNTUsIDFdO1xuICogIHZhciBibHVlID0gWzAsIDE1MywgMjU1LCAxXTtcbiAqICB2YXIgd2lkdGggPSAzO1xuICogIHN0eWxlc1tHZW9tZXRyeVR5cGUuUE9MWUdPTl0gPSBbXG4gKiAgICBuZXcgU3R5bGUoe1xuICogICAgICBmaWxsOiBuZXcgRmlsbCh7XG4gKiAgICAgICAgY29sb3I6IFsyNTUsIDI1NSwgMjU1LCAwLjVdXG4gKiAgICAgIH0pXG4gKiAgICB9KVxuICogIF07XG4gKiAgc3R5bGVzW0dlb21ldHJ5VHlwZS5NVUxUSV9QT0xZR09OXSA9XG4gKiAgICAgIHN0eWxlc1tHZW9tZXRyeVR5cGUuUE9MWUdPTl07XG4gKiAgc3R5bGVzW0dlb21ldHJ5VHlwZS5MSU5FX1NUUklOR10gPSBbXG4gKiAgICBuZXcgU3R5bGUoe1xuICogICAgICBzdHJva2U6IG5ldyBTdHJva2Uoe1xuICogICAgICAgIGNvbG9yOiB3aGl0ZSxcbiAqICAgICAgICB3aWR0aDogd2lkdGggKyAyXG4gKiAgICAgIH0pXG4gKiAgICB9KSxcbiAqICAgIG5ldyBTdHlsZSh7XG4gKiAgICAgIHN0cm9rZTogbmV3IFN0cm9rZSh7XG4gKiAgICAgICAgY29sb3I6IGJsdWUsXG4gKiAgICAgICAgd2lkdGg6IHdpZHRoXG4gKiAgICAgIH0pXG4gKiAgICB9KVxuICogIF07XG4gKiAgc3R5bGVzW0dlb21ldHJ5VHlwZS5NVUxUSV9MSU5FX1NUUklOR10gPVxuICogICAgICBzdHlsZXNbR2VvbWV0cnlUeXBlLkxJTkVfU1RSSU5HXTtcbiAqICBzdHlsZXNbR2VvbWV0cnlUeXBlLlBPSU5UXSA9IFtcbiAqICAgIG5ldyBTdHlsZSh7XG4gKiAgICAgIGltYWdlOiBuZXcgQ2lyY2xlKHtcbiAqICAgICAgICByYWRpdXM6IHdpZHRoICogMixcbiAqICAgICAgICBmaWxsOiBuZXcgRmlsbCh7XG4gKiAgICAgICAgICBjb2xvcjogYmx1ZVxuICogICAgICAgIH0pLFxuICogICAgICAgIHN0cm9rZTogbmV3IFN0cm9rZSh7XG4gKiAgICAgICAgICBjb2xvcjogd2hpdGUsXG4gKiAgICAgICAgICB3aWR0aDogd2lkdGggLyAyXG4gKiAgICAgICAgfSlcbiAqICAgICAgfSksXG4gKiAgICAgIHpJbmRleDogSW5maW5pdHlcbiAqICAgIH0pXG4gKiAgXTtcbiAqICBzdHlsZXNbR2VvbWV0cnlUeXBlLk1VTFRJX1BPSU5UXSA9XG4gKiAgICAgIHN0eWxlc1tHZW9tZXRyeVR5cGUuUE9JTlRdO1xuICogIHN0eWxlc1tHZW9tZXRyeVR5cGUuR0VPTUVUUllfQ09MTEVDVElPTl0gPVxuICogICAgICBzdHlsZXNbR2VvbWV0cnlUeXBlLlBPTFlHT05dLmNvbmNhdChcbiAqICAgICAgICAgIHN0eWxlc1tHZW9tZXRyeVR5cGUuTElORV9TVFJJTkddLFxuICogICAgICAgICAgc3R5bGVzW0dlb21ldHJ5VHlwZS5QT0lOVF1cbiAqICAgICAgKTtcbiAqIGBgYFxuICovXG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi4vYXNzZXJ0cy5qcyc7XG5pbXBvcnQgR2VvbWV0cnlUeXBlIGZyb20gJy4uL2dlb20vR2VvbWV0cnlUeXBlLmpzJztcbmltcG9ydCBDaXJjbGVTdHlsZSBmcm9tICcuL0NpcmNsZS5qcyc7XG5pbXBvcnQgRmlsbCBmcm9tICcuL0ZpbGwuanMnO1xuaW1wb3J0IFN0cm9rZSBmcm9tICcuL1N0cm9rZS5qcyc7XG5cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9GZWF0dXJlfSBhbmQgYSBge251bWJlcn1gXG4gKiByZXByZXNlbnRpbmcgdGhlIHZpZXcncyByZXNvbHV0aW9uLiBUaGUgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3N0eWxlL1N0eWxlfSBvciBhbiBhcnJheSBvZiB0aGVtLiBUaGlzIHdheSBlLmcuIGFcbiAqIHZlY3RvciBsYXllciBjYW4gYmUgc3R5bGVkLlxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlLCBudW1iZXIpOihTdHlsZXxBcnJheTxTdHlsZT4pfSBTdHlsZUZ1bmN0aW9uXG4gKi9cblxuLyoqXG4gKiBBIHtAbGluayBTdHlsZX0sIGFuIGFycmF5IG9mIHtAbGluayBTdHlsZX0sIG9yIGEge0BsaW5rIFN0eWxlRnVuY3Rpb259LlxuICogQHR5cGVkZWYge1N0eWxlfEFycmF5PFN0eWxlPnxTdHlsZUZ1bmN0aW9ufSBTdHlsZUxpa2VcbiAqL1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL0ZlYXR1cmV9IGFzIGFyZ3VtZW50IGFuZCByZXR1cm5zIGFuXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2dlb20vR2VvbWV0cnl9IHRoYXQgd2lsbCBiZSByZW5kZXJlZCBhbmQgc3R5bGVkIGZvciB0aGUgZmVhdHVyZS5cbiAqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZSk6XG4gKiAgICAgKGltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9yZW5kZXIvRmVhdHVyZS5qc1wiKS5kZWZhdWx0fHVuZGVmaW5lZCl9IEdlb21ldHJ5RnVuY3Rpb25cbiAqL1xuXG5cbi8qKlxuICogQ3VzdG9tIHJlbmRlcmVyIGZ1bmN0aW9uLiBUYWtlcyB0d28gYXJndW1lbnRzOlxuICpcbiAqIDEuIFRoZSBwaXhlbCBjb29yZGluYXRlcyBvZiB0aGUgZ2VvbWV0cnkgaW4gR2VvSlNPTiBub3RhdGlvbi5cbiAqIDIuIFRoZSB7QGxpbmsgbW9kdWxlOm9sL3JlbmRlcn5TdGF0ZX0gb2YgdGhlIGxheWVyIHJlbmRlcmVyLlxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbigoaW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfEFycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT58QXJyYXk8QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj4pLGltcG9ydChcIi4uL3JlbmRlci5qc1wiKS5TdGF0ZSl9XG4gKiBSZW5kZXJGdW5jdGlvblxuICovXG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ3xpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR8R2VvbWV0cnlGdW5jdGlvbn0gW2dlb21ldHJ5XSBGZWF0dXJlIHByb3BlcnR5IG9yIGdlb21ldHJ5XG4gKiBvciBmdW5jdGlvbiByZXR1cm5pbmcgYSBnZW9tZXRyeSB0byByZW5kZXIgZm9yIHRoaXMgc3R5bGUuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vRmlsbC5qc1wiKS5kZWZhdWx0fSBbZmlsbF0gRmlsbCBzdHlsZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9JbWFnZS5qc1wiKS5kZWZhdWx0fSBbaW1hZ2VdIEltYWdlIHN0eWxlLlxuICogQHByb3BlcnR5IHtSZW5kZXJGdW5jdGlvbn0gW3JlbmRlcmVyXSBDdXN0b20gcmVuZGVyZXIuIFdoZW4gY29uZmlndXJlZCwgYGZpbGxgLCBgc3Ryb2tlYCBhbmQgYGltYWdlYCB3aWxsIGJlXG4gKiBpZ25vcmVkLCBhbmQgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdpdGggZWFjaCByZW5kZXIgZnJhbWUgZm9yIGVhY2ggZ2VvbWV0cnkuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vU3Ryb2tlLmpzXCIpLmRlZmF1bHR9IFtzdHJva2VdIFN0cm9rZSBzdHlsZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9UZXh0LmpzXCIpLmRlZmF1bHR9IFt0ZXh0XSBUZXh0IHN0eWxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt6SW5kZXhdIFogaW5kZXguXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBDb250YWluZXIgZm9yIHZlY3RvciBmZWF0dXJlIHJlbmRlcmluZyBzdHlsZXMuIEFueSBjaGFuZ2VzIG1hZGUgdG8gdGhlIHN0eWxlXG4gKiBvciBpdHMgY2hpbGRyZW4gdGhyb3VnaCBgc2V0KigpYCBtZXRob2RzIHdpbGwgbm90IHRha2UgZWZmZWN0IHVudGlsIHRoZVxuICogZmVhdHVyZSBvciBsYXllciB0aGF0IHVzZXMgdGhlIHN0eWxlIGlzIHJlLXJlbmRlcmVkLlxuICogQGFwaVxuICovXG52YXIgU3R5bGUgPSBmdW5jdGlvbiBTdHlsZShvcHRfb3B0aW9ucykge1xuXG4gIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgfHwge307XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtzdHJpbmd8aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fEdlb21ldHJ5RnVuY3Rpb259XG4gICAqL1xuICB0aGlzLmdlb21ldHJ5XyA9IG51bGw7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHshR2VvbWV0cnlGdW5jdGlvbn1cbiAgICovXG4gIHRoaXMuZ2VvbWV0cnlGdW5jdGlvbl8gPSBkZWZhdWx0R2VvbWV0cnlGdW5jdGlvbjtcblxuICBpZiAob3B0aW9ucy5nZW9tZXRyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5zZXRHZW9tZXRyeShvcHRpb25zLmdlb21ldHJ5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9GaWxsLmpzXCIpLmRlZmF1bHR9XG4gICAqL1xuICB0aGlzLmZpbGxfID0gb3B0aW9ucy5maWxsICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmZpbGwgOiBudWxsO1xuXG4gIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vSW1hZ2UuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgdGhpcy5pbWFnZV8gPSBvcHRpb25zLmltYWdlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmltYWdlIDogbnVsbDtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge1JlbmRlckZ1bmN0aW9ufG51bGx9XG4gICAqL1xuICB0aGlzLnJlbmRlcmVyXyA9IG9wdGlvbnMucmVuZGVyZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucmVuZGVyZXIgOiBudWxsO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdH1cbiAgICovXG4gIHRoaXMuc3Ryb2tlXyA9IG9wdGlvbnMuc3Ryb2tlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0cm9rZSA6IG51bGw7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtpbXBvcnQoXCIuL1RleHQuanNcIikuZGVmYXVsdH1cbiAgICovXG4gIHRoaXMudGV4dF8gPSBvcHRpb25zLnRleHQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudGV4dCA6IG51bGw7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgKi9cbiAgdGhpcy56SW5kZXhfID0gb3B0aW9ucy56SW5kZXg7XG5cbn07XG5cbi8qKlxuICogQ2xvbmVzIHRoZSBzdHlsZS5cbiAqIEByZXR1cm4ge1N0eWxlfSBUaGUgY2xvbmVkIHN0eWxlLlxuICogQGFwaVxuICovXG5TdHlsZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gIHZhciBnZW9tZXRyeSA9IHRoaXMuZ2V0R2VvbWV0cnkoKTtcbiAgaWYgKGdlb21ldHJ5ICYmIHR5cGVvZiBnZW9tZXRyeSA9PT0gJ29iamVjdCcpIHtcbiAgICBnZW9tZXRyeSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSAqLyAoZ2VvbWV0cnkpLmNsb25lKCk7XG4gIH1cbiAgcmV0dXJuIG5ldyBTdHlsZSh7XG4gICAgZ2VvbWV0cnk6IGdlb21ldHJ5LFxuICAgIGZpbGw6IHRoaXMuZ2V0RmlsbCgpID8gdGhpcy5nZXRGaWxsKCkuY2xvbmUoKSA6IHVuZGVmaW5lZCxcbiAgICBpbWFnZTogdGhpcy5nZXRJbWFnZSgpID8gdGhpcy5nZXRJbWFnZSgpLmNsb25lKCkgOiB1bmRlZmluZWQsXG4gICAgc3Ryb2tlOiB0aGlzLmdldFN0cm9rZSgpID8gdGhpcy5nZXRTdHJva2UoKS5jbG9uZSgpIDogdW5kZWZpbmVkLFxuICAgIHRleHQ6IHRoaXMuZ2V0VGV4dCgpID8gdGhpcy5nZXRUZXh0KCkuY2xvbmUoKSA6IHVuZGVmaW5lZCxcbiAgICB6SW5kZXg6IHRoaXMuZ2V0WkluZGV4KClcbiAgfSk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY3VzdG9tIHJlbmRlcmVyIGZ1bmN0aW9uIHRoYXQgd2FzIGNvbmZpZ3VyZWQgd2l0aFxuICoge0BsaW5rICNzZXRSZW5kZXJlcn0gb3IgdGhlIGByZW5kZXJlcmAgY29uc3RydWN0b3Igb3B0aW9uLlxuICogQHJldHVybiB7UmVuZGVyRnVuY3Rpb258bnVsbH0gQ3VzdG9tIHJlbmRlcmVyIGZ1bmN0aW9uLlxuICogQGFwaVxuICovXG5TdHlsZS5wcm90b3R5cGUuZ2V0UmVuZGVyZXIgPSBmdW5jdGlvbiBnZXRSZW5kZXJlciAoKSB7XG4gIHJldHVybiB0aGlzLnJlbmRlcmVyXztcbn07XG5cbi8qKlxuICogU2V0cyBhIGN1c3RvbSByZW5kZXJlciBmdW5jdGlvbiBmb3IgdGhpcyBzdHlsZS4gV2hlbiBzZXQsIGBmaWxsYCwgYHN0cm9rZWBcbiAqIGFuZCBgaW1hZ2VgIG9wdGlvbnMgb2YgdGhlIHN0eWxlIHdpbGwgYmUgaWdub3JlZC5cbiAqIEBwYXJhbSB7UmVuZGVyRnVuY3Rpb258bnVsbH0gcmVuZGVyZXIgQ3VzdG9tIHJlbmRlcmVyIGZ1bmN0aW9uLlxuICogQGFwaVxuICovXG5TdHlsZS5wcm90b3R5cGUuc2V0UmVuZGVyZXIgPSBmdW5jdGlvbiBzZXRSZW5kZXJlciAocmVuZGVyZXIpIHtcbiAgdGhpcy5yZW5kZXJlcl8gPSByZW5kZXJlcjtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBnZW9tZXRyeSB0byBiZSByZW5kZXJlZC5cbiAqIEByZXR1cm4ge3N0cmluZ3xpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR8R2VvbWV0cnlGdW5jdGlvbn1cbiAqIEZlYXR1cmUgcHJvcGVydHkgb3IgZ2VvbWV0cnkgb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBnZW9tZXRyeSB0aGF0IHdpbGxcbiAqIGJlIHJlbmRlcmVkIHdpdGggdGhpcyBzdHlsZS5cbiAqIEBhcGlcbiAqL1xuU3R5bGUucHJvdG90eXBlLmdldEdlb21ldHJ5ID0gZnVuY3Rpb24gZ2V0R2VvbWV0cnkgKCkge1xuICByZXR1cm4gdGhpcy5nZW9tZXRyeV87XG59O1xuXG4vKipcbiAqIEdldCB0aGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSBhIGdlb21ldHJ5IGZvciByZW5kZXJpbmcuXG4gKiBAcmV0dXJuIHshR2VvbWV0cnlGdW5jdGlvbn0gRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBhIGZlYXR1cmVcbiAqIGFuZCByZXR1cm5zIHRoZSBnZW9tZXRyeSB0byByZW5kZXIgaW5zdGVhZCBvZiB0aGUgZmVhdHVyZSdzIGdlb21ldHJ5LlxuICogQGFwaVxuICovXG5TdHlsZS5wcm90b3R5cGUuZ2V0R2VvbWV0cnlGdW5jdGlvbiA9IGZ1bmN0aW9uIGdldEdlb21ldHJ5RnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5nZW9tZXRyeUZ1bmN0aW9uXztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBmaWxsIHN0eWxlLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9GaWxsLmpzXCIpLmRlZmF1bHR9IEZpbGwgc3R5bGUuXG4gKiBAYXBpXG4gKi9cblN0eWxlLnByb3RvdHlwZS5nZXRGaWxsID0gZnVuY3Rpb24gZ2V0RmlsbCAoKSB7XG4gIHJldHVybiB0aGlzLmZpbGxfO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGZpbGwgc3R5bGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vRmlsbC5qc1wiKS5kZWZhdWx0fSBmaWxsIEZpbGwgc3R5bGUuXG4gKiBAYXBpXG4gKi9cblN0eWxlLnByb3RvdHlwZS5zZXRGaWxsID0gZnVuY3Rpb24gc2V0RmlsbCAoZmlsbCkge1xuICB0aGlzLmZpbGxfID0gZmlsbDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBpbWFnZSBzdHlsZS5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vSW1hZ2UuanNcIikuZGVmYXVsdH0gSW1hZ2Ugc3R5bGUuXG4gKiBAYXBpXG4gKi9cblN0eWxlLnByb3RvdHlwZS5nZXRJbWFnZSA9IGZ1bmN0aW9uIGdldEltYWdlICgpIHtcbiAgcmV0dXJuIHRoaXMuaW1hZ2VfO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGltYWdlIHN0eWxlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL0ltYWdlLmpzXCIpLmRlZmF1bHR9IGltYWdlIEltYWdlIHN0eWxlLlxuICogQGFwaVxuICovXG5TdHlsZS5wcm90b3R5cGUuc2V0SW1hZ2UgPSBmdW5jdGlvbiBzZXRJbWFnZSAoaW1hZ2UpIHtcbiAgdGhpcy5pbWFnZV8gPSBpbWFnZTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBzdHJva2Ugc3R5bGUuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL1N0cm9rZS5qc1wiKS5kZWZhdWx0fSBTdHJva2Ugc3R5bGUuXG4gKiBAYXBpXG4gKi9cblN0eWxlLnByb3RvdHlwZS5nZXRTdHJva2UgPSBmdW5jdGlvbiBnZXRTdHJva2UgKCkge1xuICByZXR1cm4gdGhpcy5zdHJva2VfO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHN0cm9rZSBzdHlsZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdH0gc3Ryb2tlIFN0cm9rZSBzdHlsZS5cbiAqIEBhcGlcbiAqL1xuU3R5bGUucHJvdG90eXBlLnNldFN0cm9rZSA9IGZ1bmN0aW9uIHNldFN0cm9rZSAoc3Ryb2tlKSB7XG4gIHRoaXMuc3Ryb2tlXyA9IHN0cm9rZTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSB0ZXh0IHN0eWxlLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9UZXh0LmpzXCIpLmRlZmF1bHR9IFRleHQgc3R5bGUuXG4gKiBAYXBpXG4gKi9cblN0eWxlLnByb3RvdHlwZS5nZXRUZXh0ID0gZnVuY3Rpb24gZ2V0VGV4dCAoKSB7XG4gIHJldHVybiB0aGlzLnRleHRfO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHRleHQgc3R5bGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vVGV4dC5qc1wiKS5kZWZhdWx0fSB0ZXh0IFRleHQgc3R5bGUuXG4gKiBAYXBpXG4gKi9cblN0eWxlLnByb3RvdHlwZS5zZXRUZXh0ID0gZnVuY3Rpb24gc2V0VGV4dCAodGV4dCkge1xuICB0aGlzLnRleHRfID0gdGV4dDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSB6LWluZGV4IGZvciB0aGUgc3R5bGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBaSW5kZXguXG4gKiBAYXBpXG4gKi9cblN0eWxlLnByb3RvdHlwZS5nZXRaSW5kZXggPSBmdW5jdGlvbiBnZXRaSW5kZXggKCkge1xuICByZXR1cm4gdGhpcy56SW5kZXhfO1xufTtcblxuLyoqXG4gKiBTZXQgYSBnZW9tZXRyeSB0aGF0IGlzIHJlbmRlcmVkIGluc3RlYWQgb2YgdGhlIGZlYXR1cmUncyBnZW9tZXRyeS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR8R2VvbWV0cnlGdW5jdGlvbn0gZ2VvbWV0cnlcbiAqICAgRmVhdHVyZSBwcm9wZXJ0eSBvciBnZW9tZXRyeSBvciBmdW5jdGlvbiByZXR1cm5pbmcgYSBnZW9tZXRyeSB0byByZW5kZXJcbiAqICAgZm9yIHRoaXMgc3R5bGUuXG4gKiBAYXBpXG4gKi9cblN0eWxlLnByb3RvdHlwZS5zZXRHZW9tZXRyeSA9IGZ1bmN0aW9uIHNldEdlb21ldHJ5IChnZW9tZXRyeSkge1xuICBpZiAodHlwZW9mIGdlb21ldHJ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5nZW9tZXRyeUZ1bmN0aW9uXyA9IGdlb21ldHJ5O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBnZW9tZXRyeSA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLmdlb21ldHJ5RnVuY3Rpb25fID0gZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9ICovIChmZWF0dXJlLmdldChnZW9tZXRyeSkpXG4gICAgICApO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoIWdlb21ldHJ5KSB7XG4gICAgdGhpcy5nZW9tZXRyeUZ1bmN0aW9uXyA9IGRlZmF1bHRHZW9tZXRyeUZ1bmN0aW9uO1xuICB9IGVsc2UgaWYgKGdlb21ldHJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLmdlb21ldHJ5RnVuY3Rpb25fID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gKi8gKGdlb21ldHJ5KVxuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIHRoaXMuZ2VvbWV0cnlfID0gZ2VvbWV0cnk7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgei1pbmRleC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHpJbmRleCBaSW5kZXguXG4gKiBAYXBpXG4gKi9cblN0eWxlLnByb3RvdHlwZS5zZXRaSW5kZXggPSBmdW5jdGlvbiBzZXRaSW5kZXggKHpJbmRleCkge1xuICB0aGlzLnpJbmRleF8gPSB6SW5kZXg7XG59O1xuXG5cbi8qKlxuICogQ29udmVydCB0aGUgcHJvdmlkZWQgb2JqZWN0IGludG8gYSBzdHlsZSBmdW5jdGlvbi4gIEZ1bmN0aW9ucyBwYXNzZWQgdGhyb3VnaFxuICogdW5jaGFuZ2VkLiAgQXJyYXlzIG9mIFN0eWxlIG9yIHNpbmdsZSBzdHlsZSBvYmplY3RzIHdyYXBwZWQgaW4gYVxuICogbmV3IHN0eWxlIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtTdHlsZUZ1bmN0aW9ufEFycmF5PFN0eWxlPnxTdHlsZX0gb2JqXG4gKiAgICAgQSBzdHlsZSBmdW5jdGlvbiwgYSBzaW5nbGUgc3R5bGUsIG9yIGFuIGFycmF5IG9mIHN0eWxlcy5cbiAqIEByZXR1cm4ge1N0eWxlRnVuY3Rpb259IEEgc3R5bGUgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0Z1bmN0aW9uKG9iaikge1xuICB2YXIgc3R5bGVGdW5jdGlvbjtcblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHN0eWxlRnVuY3Rpb24gPSBvYmo7XG4gIH0gZWxzZSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PFN0eWxlPn1cbiAgICAgKi9cbiAgICB2YXIgc3R5bGVzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgIHN0eWxlcyA9IG9iajtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KHR5cGVvZiAvKiogQHR5cGUgez99ICovIChvYmopLmdldFpJbmRleCA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgNDEpOyAvLyBFeHBlY3RlZCBhbiBgU3R5bGVgIG9yIGFuIGFycmF5IG9mIGBTdHlsZWBcbiAgICAgIHZhciBzdHlsZSA9IC8qKiBAdHlwZSB7U3R5bGV9ICovIChvYmopO1xuICAgICAgc3R5bGVzID0gW3N0eWxlXTtcbiAgICB9XG4gICAgc3R5bGVGdW5jdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHN0eWxlcztcbiAgICB9O1xuICB9XG4gIHJldHVybiBzdHlsZUZ1bmN0aW9uO1xufVxuXG5cbi8qKlxuICogQHR5cGUge0FycmF5PFN0eWxlPn1cbiAqL1xudmFyIGRlZmF1bHRTdHlsZXMgPSBudWxsO1xuXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICogQHJldHVybiB7QXJyYXk8U3R5bGU+fSBTdHlsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRTdHlsZShmZWF0dXJlLCByZXNvbHV0aW9uKSB7XG4gIC8vIFdlIGRvbid0IHVzZSBhbiBpbW1lZGlhdGVseS1pbnZva2VkIGZ1bmN0aW9uXG4gIC8vIGFuZCBhIGNsb3N1cmUgc28gd2UgZG9uJ3QgZ2V0IGFuIGVycm9yIGF0IHNjcmlwdCBldmFsdWF0aW9uIHRpbWUgaW5cbiAgLy8gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBDYW52YXMuIChpbXBvcnQoXCIuL0NpcmNsZS5qc1wiKS5DaXJjbGVTdHlsZSBkb2VzXG4gIC8vIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpIGF0IGNvbnN0cnVjdGlvbiB0aW1lLCB3aGljaCB3aWxsIGNhdXNlIGFuLmVycm9yXG4gIC8vIGluIHN1Y2ggYnJvd3NlcnMuKVxuICBpZiAoIWRlZmF1bHRTdHlsZXMpIHtcbiAgICB2YXIgZmlsbCA9IG5ldyBGaWxsKHtcbiAgICAgIGNvbG9yOiAncmdiYSgyNTUsMjU1LDI1NSwwLjQpJ1xuICAgIH0pO1xuICAgIHZhciBzdHJva2UgPSBuZXcgU3Ryb2tlKHtcbiAgICAgIGNvbG9yOiAnIzMzOTlDQycsXG4gICAgICB3aWR0aDogMS4yNVxuICAgIH0pO1xuICAgIGRlZmF1bHRTdHlsZXMgPSBbXG4gICAgICBuZXcgU3R5bGUoe1xuICAgICAgICBpbWFnZTogbmV3IENpcmNsZVN0eWxlKHtcbiAgICAgICAgICBmaWxsOiBmaWxsLFxuICAgICAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgICAgIHJhZGl1czogNVxuICAgICAgICB9KSxcbiAgICAgICAgZmlsbDogZmlsbCxcbiAgICAgICAgc3Ryb2tlOiBzdHJva2VcbiAgICAgIH0pXG4gICAgXTtcbiAgfVxuICByZXR1cm4gZGVmYXVsdFN0eWxlcztcbn1cblxuXG4vKipcbiAqIERlZmF1bHQgc3R5bGVzIGZvciBlZGl0aW5nIGZlYXR1cmVzLlxuICogQHJldHVybiB7T2JqZWN0PGltcG9ydChcIi4uL2dlb20vR2VvbWV0cnlUeXBlLmpzXCIpLmRlZmF1bHQsIEFycmF5PFN0eWxlPj59IFN0eWxlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRWRpdGluZ1N0eWxlKCkge1xuICAvKiogQHR5cGUge09iamVjdDxpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5VHlwZS5qc1wiKS5kZWZhdWx0LCBBcnJheTxTdHlsZT4+fSAqL1xuICB2YXIgc3R5bGVzID0ge307XG4gIHZhciB3aGl0ZSA9IFsyNTUsIDI1NSwgMjU1LCAxXTtcbiAgdmFyIGJsdWUgPSBbMCwgMTUzLCAyNTUsIDFdO1xuICB2YXIgd2lkdGggPSAzO1xuICBzdHlsZXNbR2VvbWV0cnlUeXBlLlBPTFlHT05dID0gW1xuICAgIG5ldyBTdHlsZSh7XG4gICAgICBmaWxsOiBuZXcgRmlsbCh7XG4gICAgICAgIGNvbG9yOiBbMjU1LCAyNTUsIDI1NSwgMC41XVxuICAgICAgfSlcbiAgICB9KVxuICBdO1xuICBzdHlsZXNbR2VvbWV0cnlUeXBlLk1VTFRJX1BPTFlHT05dID1cbiAgICAgIHN0eWxlc1tHZW9tZXRyeVR5cGUuUE9MWUdPTl07XG5cbiAgc3R5bGVzW0dlb21ldHJ5VHlwZS5MSU5FX1NUUklOR10gPSBbXG4gICAgbmV3IFN0eWxlKHtcbiAgICAgIHN0cm9rZTogbmV3IFN0cm9rZSh7XG4gICAgICAgIGNvbG9yOiB3aGl0ZSxcbiAgICAgICAgd2lkdGg6IHdpZHRoICsgMlxuICAgICAgfSlcbiAgICB9KSxcbiAgICBuZXcgU3R5bGUoe1xuICAgICAgc3Ryb2tlOiBuZXcgU3Ryb2tlKHtcbiAgICAgICAgY29sb3I6IGJsdWUsXG4gICAgICAgIHdpZHRoOiB3aWR0aFxuICAgICAgfSlcbiAgICB9KVxuICBdO1xuICBzdHlsZXNbR2VvbWV0cnlUeXBlLk1VTFRJX0xJTkVfU1RSSU5HXSA9XG4gICAgICBzdHlsZXNbR2VvbWV0cnlUeXBlLkxJTkVfU1RSSU5HXTtcblxuICBzdHlsZXNbR2VvbWV0cnlUeXBlLkNJUkNMRV0gPVxuICAgICAgc3R5bGVzW0dlb21ldHJ5VHlwZS5QT0xZR09OXS5jb25jYXQoXG4gICAgICAgIHN0eWxlc1tHZW9tZXRyeVR5cGUuTElORV9TVFJJTkddXG4gICAgICApO1xuXG5cbiAgc3R5bGVzW0dlb21ldHJ5VHlwZS5QT0lOVF0gPSBbXG4gICAgbmV3IFN0eWxlKHtcbiAgICAgIGltYWdlOiBuZXcgQ2lyY2xlU3R5bGUoe1xuICAgICAgICByYWRpdXM6IHdpZHRoICogMixcbiAgICAgICAgZmlsbDogbmV3IEZpbGwoe1xuICAgICAgICAgIGNvbG9yOiBibHVlXG4gICAgICAgIH0pLFxuICAgICAgICBzdHJva2U6IG5ldyBTdHJva2Uoe1xuICAgICAgICAgIGNvbG9yOiB3aGl0ZSxcbiAgICAgICAgICB3aWR0aDogd2lkdGggLyAyXG4gICAgICAgIH0pXG4gICAgICB9KSxcbiAgICAgIHpJbmRleDogSW5maW5pdHlcbiAgICB9KVxuICBdO1xuICBzdHlsZXNbR2VvbWV0cnlUeXBlLk1VTFRJX1BPSU5UXSA9XG4gICAgICBzdHlsZXNbR2VvbWV0cnlUeXBlLlBPSU5UXTtcblxuICBzdHlsZXNbR2VvbWV0cnlUeXBlLkdFT01FVFJZX0NPTExFQ1RJT05dID1cbiAgICAgIHN0eWxlc1tHZW9tZXRyeVR5cGUuUE9MWUdPTl0uY29uY2F0KFxuICAgICAgICBzdHlsZXNbR2VvbWV0cnlUeXBlLkxJTkVfU1RSSU5HXSxcbiAgICAgICAgc3R5bGVzW0dlb21ldHJ5VHlwZS5QT0lOVF1cbiAgICAgICk7XG5cbiAgcmV0dXJuIHN0eWxlcztcbn1cblxuXG4vKipcbiAqIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggYSBmZWF0dXJlIGFuZCByZXR1cm5zIGl0cyBkZWZhdWx0IGdlb21ldHJ5LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUgdG8gZ2V0IHRoZSBnZW9tZXRyeSBmb3IuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vcmVuZGVyL0ZlYXR1cmUuanNcIikuZGVmYXVsdHx1bmRlZmluZWR9IEdlb21ldHJ5IHRvIHJlbmRlci5cbiAqL1xuZnVuY3Rpb24gZGVmYXVsdEdlb21ldHJ5RnVuY3Rpb24oZmVhdHVyZSkge1xuICByZXR1cm4gZmVhdHVyZS5nZXRHZW9tZXRyeSgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBTdHlsZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3R5bGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3N0eWxlL1RleHRQbGFjZW1lbnRcbiAqL1xuXG4vKipcbiAqIFRleHQgcGxhY2VtZW50LiBPbmUgb2YgYCdwb2ludCdgLCBgJ2xpbmUnYC4gRGVmYXVsdCBpcyBgJ3BvaW50J2AuIE5vdGUgdGhhdFxuICogYCdsaW5lJ2AgcmVxdWlyZXMgdGhlIHVuZGVybHlpbmcgZ2VvbWV0cnkgdG8gYmUgYSB7QGxpbmsgbW9kdWxlOm9sL2dlb20vTGluZVN0cmluZ35MaW5lU3RyaW5nfSxcbiAqIHtAbGluayBtb2R1bGU6b2wvZ2VvbS9Qb2x5Z29uflBvbHlnb259LCB7QGxpbmsgbW9kdWxlOm9sL2dlb20vTXVsdGlMaW5lU3RyaW5nfk11bHRpTGluZVN0cmluZ30gb3JcbiAqIHtAbGluayBtb2R1bGU6b2wvZ2VvbS9NdWx0aVBvbHlnb25+TXVsdGlQb2x5Z29ufS5cbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgUE9JTlQ6ICdwb2ludCcsXG4gIExJTkU6ICdsaW5lJ1xufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4dFBsYWNlbWVudC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvdGlsZWNvb3JkXG4gKi9cblxuXG4vKipcbiAqIEFuIGFycmF5IG9mIHRocmVlIG51bWJlcnMgcmVwcmVzZW50aW5nIHRoZSBsb2NhdGlvbiBvZiBhIHRpbGUgaW4gYSB0aWxlXG4gKiBncmlkLiBUaGUgb3JkZXIgaXMgYHpgLCBgeGAsIGFuZCBgeWAuIGB6YCBpcyB0aGUgem9vbSBsZXZlbC5cbiAqIEB0eXBlZGVmIHtBcnJheTxudW1iZXI+fSBUaWxlQ29vcmRcbiAqIEBhcGlcbiAqL1xuXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHogWi5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICogQHBhcmFtIHtUaWxlQ29vcmQ9fSBvcHRfdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAqIEByZXR1cm4ge1RpbGVDb29yZH0gVGlsZSBjb29yZGluYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGUoeiwgeCwgeSwgb3B0X3RpbGVDb29yZCkge1xuICBpZiAob3B0X3RpbGVDb29yZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0X3RpbGVDb29yZFswXSA9IHo7XG4gICAgb3B0X3RpbGVDb29yZFsxXSA9IHg7XG4gICAgb3B0X3RpbGVDb29yZFsyXSA9IHk7XG4gICAgcmV0dXJuIG9wdF90aWxlQ29vcmQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFt6LCB4LCB5XTtcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHogWi5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICogQHJldHVybiB7c3RyaW5nfSBLZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRLZXlaWFkoeiwgeCwgeSkge1xuICByZXR1cm4geiArICcvJyArIHggKyAnLycgKyB5O1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBrZXkgZm9yIGEgdGlsZSBjb29yZC5cbiAqIEBwYXJhbSB7VGlsZUNvb3JkfSB0aWxlQ29vcmQgVGhlIHRpbGUgY29vcmQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEtleSh0aWxlQ29vcmQpIHtcbiAgcmV0dXJuIGdldEtleVpYWSh0aWxlQ29vcmRbMF0sIHRpbGVDb29yZFsxXSwgdGlsZUNvb3JkWzJdKTtcbn1cblxuXG4vKipcbiAqIEdldCBhIHRpbGUgY29vcmQgZ2l2ZW4gYSBrZXkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSB0aWxlIGNvb3JkIGtleS5cbiAqIEByZXR1cm4ge1RpbGVDb29yZH0gVGhlIHRpbGUgY29vcmQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tS2V5KGtleSkge1xuICByZXR1cm4ga2V5LnNwbGl0KCcvJykubWFwKE51bWJlcik7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge1RpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEhhc2guXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoKHRpbGVDb29yZCkge1xuICByZXR1cm4gKHRpbGVDb29yZFsxXSA8PCB0aWxlQ29vcmRbMF0pICsgdGlsZUNvb3JkWzJdO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtUaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkLlxuICogQHJldHVybiB7c3RyaW5nfSBRdWFkIGtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1YWRLZXkodGlsZUNvb3JkKSB7XG4gIHZhciB6ID0gdGlsZUNvb3JkWzBdO1xuICB2YXIgZGlnaXRzID0gbmV3IEFycmF5KHopO1xuICB2YXIgbWFzayA9IDEgPDwgKHogLSAxKTtcbiAgdmFyIGksIGNoYXJDb2RlO1xuICBmb3IgKGkgPSAwOyBpIDwgejsgKytpKSB7XG4gICAgLy8gNDggaXMgY2hhckNvZGUgZm9yIDAgLSAnMCcuY2hhckNvZGVBdCgwKVxuICAgIGNoYXJDb2RlID0gNDg7XG4gICAgaWYgKHRpbGVDb29yZFsxXSAmIG1hc2spIHtcbiAgICAgIGNoYXJDb2RlICs9IDE7XG4gICAgfVxuICAgIGlmICh0aWxlQ29vcmRbMl0gJiBtYXNrKSB7XG4gICAgICBjaGFyQ29kZSArPSAyO1xuICAgIH1cbiAgICBkaWdpdHNbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbiAgICBtYXNrID4+PSAxO1xuICB9XG4gIHJldHVybiBkaWdpdHMuam9pbignJyk7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge1RpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7IWltcG9ydChcIi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH0gdGlsZUdyaWQgVGlsZSBncmlkLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGlsZSBjb29yZGluYXRlIGlzIHdpdGhpbiBleHRlbnQgYW5kIHpvb20gbGV2ZWwgcmFuZ2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3aXRoaW5FeHRlbnRBbmRaKHRpbGVDb29yZCwgdGlsZUdyaWQpIHtcbiAgdmFyIHogPSB0aWxlQ29vcmRbMF07XG4gIHZhciB4ID0gdGlsZUNvb3JkWzFdO1xuICB2YXIgeSA9IHRpbGVDb29yZFsyXTtcblxuICBpZiAodGlsZUdyaWQuZ2V0TWluWm9vbSgpID4geiB8fCB6ID4gdGlsZUdyaWQuZ2V0TWF4Wm9vbSgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBleHRlbnQgPSB0aWxlR3JpZC5nZXRFeHRlbnQoKTtcbiAgdmFyIHRpbGVSYW5nZTtcbiAgaWYgKCFleHRlbnQpIHtcbiAgICB0aWxlUmFuZ2UgPSB0aWxlR3JpZC5nZXRGdWxsVGlsZVJhbmdlKHopO1xuICB9IGVsc2Uge1xuICAgIHRpbGVSYW5nZSA9IHRpbGVHcmlkLmdldFRpbGVSYW5nZUZvckV4dGVudEFuZFooZXh0ZW50LCB6KTtcbiAgfVxuICBpZiAoIXRpbGVSYW5nZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aWxlUmFuZ2UuY29udGFpbnNYWSh4LCB5KTtcbiAgfVxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD10aWxlY29vcmQuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3RpbGVncmlkXG4gKi9cbmltcG9ydCB7REVGQVVMVF9NQVhfWk9PTSwgREVGQVVMVF9USUxFX1NJWkV9IGZyb20gJy4vdGlsZWdyaWQvY29tbW9uLmpzJztcbmltcG9ydCB7dG9TaXplfSBmcm9tICcuL3NpemUuanMnO1xuaW1wb3J0IHtjb250YWluc0Nvb3JkaW5hdGUsIGNyZWF0ZU9yVXBkYXRlLCBnZXRDb3JuZXIsIGdldEhlaWdodCwgZ2V0V2lkdGh9IGZyb20gJy4vZXh0ZW50LmpzJztcbmltcG9ydCBDb3JuZXIgZnJvbSAnLi9leHRlbnQvQ29ybmVyLmpzJztcbmltcG9ydCB7Z2V0IGFzIGdldFByb2plY3Rpb24sIE1FVEVSU19QRVJfVU5JVH0gZnJvbSAnLi9wcm9qLmpzJztcbmltcG9ydCBVbml0cyBmcm9tICcuL3Byb2ovVW5pdHMuanMnO1xuaW1wb3J0IFRpbGVHcmlkIGZyb20gJy4vdGlsZWdyaWQvVGlsZUdyaWQuanMnO1xuXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHshVGlsZUdyaWR9IERlZmF1bHQgdGlsZSBncmlkIGZvciB0aGVcbiAqIHBhc3NlZCBwcm9qZWN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Rm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKSB7XG4gIHZhciB0aWxlR3JpZCA9IHByb2plY3Rpb24uZ2V0RGVmYXVsdFRpbGVHcmlkKCk7XG4gIGlmICghdGlsZUdyaWQpIHtcbiAgICB0aWxlR3JpZCA9IGNyZWF0ZUZvclByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gICAgcHJvamVjdGlvbi5zZXREZWZhdWx0VGlsZUdyaWQodGlsZUdyaWQpO1xuICB9XG4gIHJldHVybiB0aWxlR3JpZDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7VGlsZUdyaWR9IHRpbGVHcmlkIFRpbGUgZ3JpZC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IFRpbGUgY29vcmRpbmF0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXBYKHRpbGVHcmlkLCB0aWxlQ29vcmQsIHByb2plY3Rpb24pIHtcbiAgdmFyIHogPSB0aWxlQ29vcmRbMF07XG4gIHZhciBjZW50ZXIgPSB0aWxlR3JpZC5nZXRUaWxlQ29vcmRDZW50ZXIodGlsZUNvb3JkKTtcbiAgdmFyIHByb2plY3Rpb25FeHRlbnQgPSBleHRlbnRGcm9tUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgaWYgKCFjb250YWluc0Nvb3JkaW5hdGUocHJvamVjdGlvbkV4dGVudCwgY2VudGVyKSkge1xuICAgIHZhciB3b3JsZFdpZHRoID0gZ2V0V2lkdGgocHJvamVjdGlvbkV4dGVudCk7XG4gICAgdmFyIHdvcmxkc0F3YXkgPSBNYXRoLmNlaWwoKHByb2plY3Rpb25FeHRlbnRbMF0gLSBjZW50ZXJbMF0pIC8gd29ybGRXaWR0aCk7XG4gICAgY2VudGVyWzBdICs9IHdvcmxkV2lkdGggKiB3b3JsZHNBd2F5O1xuICAgIHJldHVybiB0aWxlR3JpZC5nZXRUaWxlQ29vcmRGb3JDb29yZEFuZFooY2VudGVyLCB6KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGlsZUNvb3JkO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X21heFpvb20gTWF4aW11bSB6b29tIGxldmVsIChkZWZhdWx0IGlzXG4gKiAgICAgREVGQVVMVF9NQVhfWk9PTSkuXG4gKiBAcGFyYW0ge251bWJlcnxpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZT19IG9wdF90aWxlU2l6ZSBUaWxlIHNpemUgKGRlZmF1bHQgdXNlc1xuICogICAgIERFRkFVTFRfVElMRV9TSVpFKS5cbiAqIEBwYXJhbSB7Q29ybmVyPX0gb3B0X2Nvcm5lciBFeHRlbnQgY29ybmVyIChkZWZhdWx0IGlzIGAndG9wLWxlZnQnYCkuXG4gKiBAcmV0dXJuIHshVGlsZUdyaWR9IFRpbGVHcmlkIGluc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRm9yRXh0ZW50KGV4dGVudCwgb3B0X21heFpvb20sIG9wdF90aWxlU2l6ZSwgb3B0X2Nvcm5lcikge1xuICB2YXIgY29ybmVyID0gb3B0X2Nvcm5lciAhPT0gdW5kZWZpbmVkID8gb3B0X2Nvcm5lciA6IENvcm5lci5UT1BfTEVGVDtcblxuICB2YXIgcmVzb2x1dGlvbnMgPSByZXNvbHV0aW9uc0Zyb21FeHRlbnQoZXh0ZW50LCBvcHRfbWF4Wm9vbSwgb3B0X3RpbGVTaXplKTtcblxuICByZXR1cm4gbmV3IFRpbGVHcmlkKHtcbiAgICBleHRlbnQ6IGV4dGVudCxcbiAgICBvcmlnaW46IGdldENvcm5lcihleHRlbnQsIGNvcm5lciksXG4gICAgcmVzb2x1dGlvbnM6IHJlc29sdXRpb25zLFxuICAgIHRpbGVTaXplOiBvcHRfdGlsZVNpemVcbiAgfSk7XG59XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBYWVpPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW2V4dGVudF0gRXh0ZW50IGZvciB0aGUgdGlsZSBncmlkLiBUaGUgb3JpZ2luIGZvciBhbiBYWVogdGlsZSBncmlkIGlzIHRoZVxuICogdG9wLWxlZnQgY29ybmVyIG9mIHRoZSBleHRlbnQuIFRoZSB6ZXJvIGxldmVsIG9mIHRoZSBncmlkIGlzIGRlZmluZWQgYnkgdGhlIHJlc29sdXRpb24gYXQgd2hpY2ggb25lIHRpbGUgZml0cyBpbiB0aGVcbiAqIHByb3ZpZGVkIGV4dGVudC4gSWYgbm90IHByb3ZpZGVkLCB0aGUgZXh0ZW50IG9mIHRoZSBFUFNHOjM4NTcgcHJvamVjdGlvbiBpcyB1c2VkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhab29tXSBNYXhpbXVtIHpvb20uIFRoZSBkZWZhdWx0IGlzIGA0MmAuIFRoaXMgZGV0ZXJtaW5lcyB0aGUgbnVtYmVyIG9mIGxldmVsc1xuICogaW4gdGhlIGdyaWQgc2V0LiBGb3IgZXhhbXBsZSwgYSBgbWF4Wm9vbWAgb2YgMjEgbWVhbnMgdGhlcmUgYXJlIDIyIGxldmVscyBpbiB0aGUgZ3JpZCBzZXQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pblpvb209MF0gTWluaW11bSB6b29tLlxuICogQHByb3BlcnR5IHtudW1iZXJ8aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9IFt0aWxlU2l6ZT1bMjU2LCAyNTZdXSBUaWxlIHNpemUgaW4gcGl4ZWxzLlxuICovXG5cblxuLyoqXG4gKiBDcmVhdGVzIGEgdGlsZSBncmlkIHdpdGggYSBzdGFuZGFyZCBYWVogdGlsaW5nIHNjaGVtZS5cbiAqIEBwYXJhbSB7WFlaT3B0aW9ucz19IG9wdF9vcHRpb25zIFRpbGUgZ3JpZCBvcHRpb25zLlxuICogQHJldHVybiB7IVRpbGVHcmlkfSBUaWxlIGdyaWQgaW5zdGFuY2UuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVYWVoob3B0X29wdGlvbnMpIHtcbiAgLyoqIEB0eXBlIHtYWVpPcHRpb25zfSAqL1xuICB2YXIgeHl6T3B0aW9ucyA9IG9wdF9vcHRpb25zIHx8IHt9O1xuXG4gIHZhciBleHRlbnQgPSB4eXpPcHRpb25zLmV4dGVudCB8fCBnZXRQcm9qZWN0aW9uKCdFUFNHOjM4NTcnKS5nZXRFeHRlbnQoKTtcblxuICAvKiogQHR5cGUge2ltcG9ydChcIi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuT3B0aW9uc30gKi9cbiAgdmFyIGdyaWRPcHRpb25zID0ge1xuICAgIGV4dGVudDogZXh0ZW50LFxuICAgIG1pblpvb206IHh5ek9wdGlvbnMubWluWm9vbSxcbiAgICB0aWxlU2l6ZTogeHl6T3B0aW9ucy50aWxlU2l6ZSxcbiAgICByZXNvbHV0aW9uczogcmVzb2x1dGlvbnNGcm9tRXh0ZW50KFxuICAgICAgZXh0ZW50LFxuICAgICAgeHl6T3B0aW9ucy5tYXhab29tLFxuICAgICAgeHl6T3B0aW9ucy50aWxlU2l6ZVxuICAgIClcbiAgfTtcbiAgcmV0dXJuIG5ldyBUaWxlR3JpZChncmlkT3B0aW9ucyk7XG59XG5cblxuLyoqXG4gKiBDcmVhdGUgYSByZXNvbHV0aW9ucyBhcnJheSBmcm9tIGFuIGV4dGVudC4gIEEgem9vbSBmYWN0b3Igb2YgMiBpcyBhc3N1bWVkLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9tYXhab29tIE1heGltdW0gem9vbSBsZXZlbCAoZGVmYXVsdCBpc1xuICogICAgIERFRkFVTFRfTUFYX1pPT00pLlxuICogQHBhcmFtIHtudW1iZXJ8aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemU9fSBvcHRfdGlsZVNpemUgVGlsZSBzaXplIChkZWZhdWx0IHVzZXNcbiAqICAgICBERUZBVUxUX1RJTEVfU0laRSkuXG4gKiBAcmV0dXJuIHshQXJyYXk8bnVtYmVyPn0gUmVzb2x1dGlvbnMgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdXRpb25zRnJvbUV4dGVudChleHRlbnQsIG9wdF9tYXhab29tLCBvcHRfdGlsZVNpemUpIHtcbiAgdmFyIG1heFpvb20gPSBvcHRfbWF4Wm9vbSAhPT0gdW5kZWZpbmVkID9cbiAgICBvcHRfbWF4Wm9vbSA6IERFRkFVTFRfTUFYX1pPT007XG5cbiAgdmFyIGhlaWdodCA9IGdldEhlaWdodChleHRlbnQpO1xuICB2YXIgd2lkdGggPSBnZXRXaWR0aChleHRlbnQpO1xuXG4gIHZhciB0aWxlU2l6ZSA9IHRvU2l6ZShvcHRfdGlsZVNpemUgIT09IHVuZGVmaW5lZCA/XG4gICAgb3B0X3RpbGVTaXplIDogREVGQVVMVF9USUxFX1NJWkUpO1xuICB2YXIgbWF4UmVzb2x1dGlvbiA9IE1hdGgubWF4KFxuICAgIHdpZHRoIC8gdGlsZVNpemVbMF0sIGhlaWdodCAvIHRpbGVTaXplWzFdKTtcblxuICB2YXIgbGVuZ3RoID0gbWF4Wm9vbSArIDE7XG4gIHZhciByZXNvbHV0aW9ucyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICBmb3IgKHZhciB6ID0gMDsgeiA8IGxlbmd0aDsgKyt6KSB7XG4gICAgcmVzb2x1dGlvbnNbel0gPSBtYXhSZXNvbHV0aW9uIC8gTWF0aC5wb3coMiwgeik7XG4gIH1cbiAgcmV0dXJuIHJlc29sdXRpb25zO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ouanNcIikuUHJvamVjdGlvbkxpa2V9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X21heFpvb20gTWF4aW11bSB6b29tIGxldmVsIChkZWZhdWx0IGlzXG4gKiAgICAgREVGQVVMVF9NQVhfWk9PTSkuXG4gKiBAcGFyYW0ge251bWJlcnxpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZT19IG9wdF90aWxlU2l6ZSBUaWxlIHNpemUgKGRlZmF1bHQgdXNlc1xuICogICAgIERFRkFVTFRfVElMRV9TSVpFKS5cbiAqIEBwYXJhbSB7Q29ybmVyPX0gb3B0X2Nvcm5lciBFeHRlbnQgY29ybmVyIChkZWZhdWx0IGlzIGAndG9wLWxlZnQnYCkuXG4gKiBAcmV0dXJuIHshVGlsZUdyaWR9IFRpbGVHcmlkIGluc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uLCBvcHRfbWF4Wm9vbSwgb3B0X3RpbGVTaXplLCBvcHRfY29ybmVyKSB7XG4gIHZhciBleHRlbnQgPSBleHRlbnRGcm9tUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgcmV0dXJuIGNyZWF0ZUZvckV4dGVudChleHRlbnQsIG9wdF9tYXhab29tLCBvcHRfdGlsZVNpemUsIG9wdF9jb3JuZXIpO1xufVxuXG5cbi8qKlxuICogR2VuZXJhdGUgYSB0aWxlIGdyaWQgZXh0ZW50IGZyb20gYSBwcm9qZWN0aW9uLiAgSWYgdGhlIHByb2plY3Rpb24gaGFzIGFuXG4gKiBleHRlbnQsIGl0IGlzIHVzZWQuICBJZiBub3QsIGEgZ2xvYmFsIGV4dGVudCBpcyBhc3N1bWVkLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ouanNcIikuUHJvamVjdGlvbkxpa2V9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW50RnJvbVByb2plY3Rpb24ocHJvamVjdGlvbikge1xuICBwcm9qZWN0aW9uID0gZ2V0UHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgdmFyIGV4dGVudCA9IHByb2plY3Rpb24uZ2V0RXh0ZW50KCk7XG4gIGlmICghZXh0ZW50KSB7XG4gICAgdmFyIGhhbGYgPSAxODAgKiBNRVRFUlNfUEVSX1VOSVRbVW5pdHMuREVHUkVFU10gLyBwcm9qZWN0aW9uLmdldE1ldGVyc1BlclVuaXQoKTtcbiAgICBleHRlbnQgPSBjcmVhdGVPclVwZGF0ZSgtaGFsZiwgLWhhbGYsIGhhbGYsIGhhbGYpO1xuICB9XG4gIHJldHVybiBleHRlbnQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbGVncmlkLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC90aWxlZ3JpZC9UaWxlR3JpZFxuICovXG5pbXBvcnQge0RFRkFVTFRfVElMRV9TSVpFfSBmcm9tICcuL2NvbW1vbi5qcyc7XG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi4vYXNzZXJ0cy5qcyc7XG5pbXBvcnQgVGlsZVJhbmdlLCB7Y3JlYXRlT3JVcGRhdGUgYXMgY3JlYXRlT3JVcGRhdGVUaWxlUmFuZ2V9IGZyb20gJy4uL1RpbGVSYW5nZS5qcyc7XG5pbXBvcnQge2lzU29ydGVkLCBsaW5lYXJGaW5kTmVhcmVzdH0gZnJvbSAnLi4vYXJyYXkuanMnO1xuaW1wb3J0IHtjcmVhdGVPclVwZGF0ZSwgZ2V0VG9wTGVmdH0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7Y2xhbXB9IGZyb20gJy4uL21hdGguanMnO1xuaW1wb3J0IHt0b1NpemV9IGZyb20gJy4uL3NpemUuanMnO1xuaW1wb3J0IHtjcmVhdGVPclVwZGF0ZSBhcyBjcmVhdGVPclVwZGF0ZVRpbGVDb29yZH0gZnJvbSAnLi4vdGlsZWNvb3JkLmpzJztcblxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAdHlwZSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH1cbiAqL1xudmFyIHRtcFRpbGVDb29yZCA9IFswLCAwLCAwXTtcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW2V4dGVudF0gRXh0ZW50IGZvciB0aGUgdGlsZSBncmlkLiBObyB0aWxlcyBvdXRzaWRlIHRoaXNcbiAqIGV4dGVudCB3aWxsIGJlIHJlcXVlc3RlZCBieSB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9UaWxlfSBzb3VyY2VzLiBXaGVuIG5vIGBvcmlnaW5gIG9yXG4gKiBgb3JpZ2luc2AgYXJlIGNvbmZpZ3VyZWQsIHRoZSBgb3JpZ2luYCB3aWxsIGJlIHNldCB0byB0aGUgdG9wLWxlZnQgY29ybmVyIG9mIHRoZSBleHRlbnQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pblpvb209MF0gTWluaW11bSB6b29tLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFtvcmlnaW5dIFRoZSB0aWxlIGdyaWQgb3JpZ2luLCBpLmUuIHdoZXJlIHRoZSBgeGBcbiAqIGFuZCBgeWAgYXhlcyBtZWV0IChgW3osIDAsIDBdYCkuIFRpbGUgY29vcmRpbmF0ZXMgaW5jcmVhc2UgbGVmdCB0byByaWdodCBhbmQgdXB3YXJkcy4gSWYgbm90XG4gKiBzcGVjaWZpZWQsIGBleHRlbnRgIG9yIGBvcmlnaW5zYCBtdXN0IGJlIHByb3ZpZGVkLlxuICogQHByb3BlcnR5IHtBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSBbb3JpZ2luc10gVGlsZSBncmlkIG9yaWdpbnMsIGkuZS4gd2hlcmVcbiAqIHRoZSBgeGAgYW5kIGB5YCBheGVzIG1lZXQgKGBbeiwgMCwgMF1gKSwgZm9yIGVhY2ggem9vbSBsZXZlbC4gSWYgZ2l2ZW4sIHRoZSBhcnJheSBsZW5ndGhcbiAqIHNob3VsZCBtYXRjaCB0aGUgbGVuZ3RoIG9mIHRoZSBgcmVzb2x1dGlvbnNgIGFycmF5LCBpLmUuIGVhY2ggcmVzb2x1dGlvbiBjYW4gaGF2ZSBhIGRpZmZlcmVudFxuICogb3JpZ2luLiBUaWxlIGNvb3JkaW5hdGVzIGluY3JlYXNlIGxlZnQgdG8gcmlnaHQgYW5kIHVwd2FyZHMuIElmIG5vdCBzcGVjaWZpZWQsIGBleHRlbnRgIG9yXG4gKiBgb3JpZ2luYCBtdXN0IGJlIHByb3ZpZGVkLlxuICogQHByb3BlcnR5IHshQXJyYXk8bnVtYmVyPn0gcmVzb2x1dGlvbnMgUmVzb2x1dGlvbnMuIFRoZSBhcnJheSBpbmRleCBvZiBlYWNoIHJlc29sdXRpb24gbmVlZHNcbiAqIHRvIG1hdGNoIHRoZSB6b29tIGxldmVsLiBUaGlzIG1lYW5zIHRoYXQgZXZlbiBpZiBhIGBtaW5ab29tYCBpcyBjb25maWd1cmVkLCB0aGUgcmVzb2x1dGlvbnNcbiAqIGFycmF5IHdpbGwgaGF2ZSBhIGxlbmd0aCBvZiBgbWF4Wm9vbSArIDFgLlxuICogQHByb3BlcnR5IHtBcnJheTxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemU+fSBbc2l6ZXNdIFNpemVzLlxuICogQHByb3BlcnR5IHtudW1iZXJ8aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBbdGlsZVNpemVdIFRpbGUgc2l6ZS5cbiAqIERlZmF1bHQgaXMgYFsyNTYsIDI1Nl1gLlxuICogQHByb3BlcnR5IHtBcnJheTxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemU+fSBbdGlsZVNpemVzXSBUaWxlIHNpemVzLiBJZiBnaXZlbiwgdGhlIGFycmF5IGxlbmd0aFxuICogc2hvdWxkIG1hdGNoIHRoZSBsZW5ndGggb2YgdGhlIGByZXNvbHV0aW9uc2AgYXJyYXksIGkuZS4gZWFjaCByZXNvbHV0aW9uIGNhbiBoYXZlIGEgZGlmZmVyZW50XG4gKiB0aWxlIHNpemUuXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEJhc2UgY2xhc3MgZm9yIHNldHRpbmcgdGhlIGdyaWQgcGF0dGVybiBmb3Igc291cmNlcyBhY2Nlc3NpbmcgdGlsZWQtaW1hZ2VcbiAqIHNlcnZlcnMuXG4gKiBAYXBpXG4gKi9cbnZhciBUaWxlR3JpZCA9IGZ1bmN0aW9uIFRpbGVHcmlkKG9wdGlvbnMpIHtcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5taW5ab29tID0gb3B0aW9ucy5taW5ab29tICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1pblpvb20gOiAwO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7IUFycmF5PG51bWJlcj59XG4gICAqL1xuICB0aGlzLnJlc29sdXRpb25zXyA9IG9wdGlvbnMucmVzb2x1dGlvbnM7XG4gIGFzc2VydChpc1NvcnRlZCh0aGlzLnJlc29sdXRpb25zXywgZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBiIC0gYTtcbiAgfSwgdHJ1ZSksIDE3KTsgLy8gYHJlc29sdXRpb25zYCBtdXN0IGJlIHNvcnRlZCBpbiBkZXNjZW5kaW5nIG9yZGVyXG5cblxuICAvLyBjaGVjayBpZiB3ZSd2ZSBnb3QgYSBjb25zaXN0ZW50IHpvb20gZmFjdG9yIGFuZCBvcmlnaW5cbiAgdmFyIHpvb21GYWN0b3I7XG4gIGlmICghb3B0aW9ucy5vcmlnaW5zKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdGhpcy5yZXNvbHV0aW9uc18ubGVuZ3RoIC0gMTsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGlmICghem9vbUZhY3Rvcikge1xuICAgICAgICB6b29tRmFjdG9yID0gdGhpcy5yZXNvbHV0aW9uc19baV0gLyB0aGlzLnJlc29sdXRpb25zX1tpICsgMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5yZXNvbHV0aW9uc19baV0gLyB0aGlzLnJlc29sdXRpb25zX1tpICsgMV0gIT09IHpvb21GYWN0b3IpIHtcbiAgICAgICAgICB6b29tRmFjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAqL1xuICB0aGlzLnpvb21GYWN0b3JfID0gem9vbUZhY3RvcjtcblxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLm1heFpvb20gPSB0aGlzLnJlc29sdXRpb25zXy5sZW5ndGggLSAxO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfVxuICAgKi9cbiAgdGhpcy5vcmlnaW5fID0gb3B0aW9ucy5vcmlnaW4gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMub3JpZ2luIDogbnVsbDtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0FycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59XG4gICAqL1xuICB0aGlzLm9yaWdpbnNfID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMub3JpZ2lucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5vcmlnaW5zXyA9IG9wdGlvbnMub3JpZ2lucztcbiAgICBhc3NlcnQodGhpcy5vcmlnaW5zXy5sZW5ndGggPT0gdGhpcy5yZXNvbHV0aW9uc18ubGVuZ3RoLFxuICAgICAgMjApOyAvLyBOdW1iZXIgb2YgYG9yaWdpbnNgIGFuZCBgcmVzb2x1dGlvbnNgIG11c3QgYmUgZXF1YWxcbiAgfVxuXG4gIHZhciBleHRlbnQgPSBvcHRpb25zLmV4dGVudDtcblxuICBpZiAoZXh0ZW50ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICF0aGlzLm9yaWdpbl8gJiYgIXRoaXMub3JpZ2luc18pIHtcbiAgICB0aGlzLm9yaWdpbl8gPSBnZXRUb3BMZWZ0KGV4dGVudCk7XG4gIH1cblxuICBhc3NlcnQoXG4gICAgKCF0aGlzLm9yaWdpbl8gJiYgdGhpcy5vcmlnaW5zXykgfHwgKHRoaXMub3JpZ2luXyAmJiAhdGhpcy5vcmlnaW5zXyksXG4gICAgMTgpOyAvLyBFaXRoZXIgYG9yaWdpbmAgb3IgYG9yaWdpbnNgIG11c3QgYmUgY29uZmlndXJlZCwgbmV2ZXIgYm90aFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyfGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZT59XG4gICAqL1xuICB0aGlzLnRpbGVTaXplc18gPSBudWxsO1xuICBpZiAob3B0aW9ucy50aWxlU2l6ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMudGlsZVNpemVzXyA9IG9wdGlvbnMudGlsZVNpemVzO1xuICAgIGFzc2VydCh0aGlzLnRpbGVTaXplc18ubGVuZ3RoID09IHRoaXMucmVzb2x1dGlvbnNfLmxlbmd0aCxcbiAgICAgIDE5KTsgLy8gTnVtYmVyIG9mIGB0aWxlU2l6ZXNgIGFuZCBgcmVzb2x1dGlvbnNgIG11c3QgYmUgZXF1YWxcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bnVtYmVyfGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX1cbiAgICovXG4gIHRoaXMudGlsZVNpemVfID0gb3B0aW9ucy50aWxlU2l6ZSAhPT0gdW5kZWZpbmVkID9cbiAgICBvcHRpb25zLnRpbGVTaXplIDpcbiAgICAhdGhpcy50aWxlU2l6ZXNfID8gREVGQVVMVF9USUxFX1NJWkUgOiBudWxsO1xuICBhc3NlcnQoXG4gICAgKCF0aGlzLnRpbGVTaXplXyAmJiB0aGlzLnRpbGVTaXplc18pIHx8XG4gICAgICAodGhpcy50aWxlU2l6ZV8gJiYgIXRoaXMudGlsZVNpemVzXyksXG4gICAgMjIpOyAvLyBFaXRoZXIgYHRpbGVTaXplYCBvciBgdGlsZVNpemVzYCBtdXN0IGJlIGNvbmZpZ3VyZWQsIG5ldmVyIGJvdGhcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gICAqL1xuICB0aGlzLmV4dGVudF8gPSBleHRlbnQgIT09IHVuZGVmaW5lZCA/IGV4dGVudCA6IG51bGw7XG5cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0FycmF5PGltcG9ydChcIi4uL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0Pn1cbiAgICovXG4gIHRoaXMuZnVsbFRpbGVSYW5nZXNfID0gbnVsbDtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge2ltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX1cbiAgICovXG4gIHRoaXMudG1wU2l6ZV8gPSBbMCwgMF07XG5cbiAgaWYgKG9wdGlvbnMuc2l6ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuZnVsbFRpbGVSYW5nZXNfID0gb3B0aW9ucy5zaXplcy5tYXAoZnVuY3Rpb24oc2l6ZSwgeikge1xuICAgICAgdmFyIHRpbGVSYW5nZSA9IG5ldyBUaWxlUmFuZ2UoXG4gICAgICAgIE1hdGgubWluKDAsIHNpemVbMF0pLCBNYXRoLm1heChzaXplWzBdIC0gMSwgLTEpLFxuICAgICAgICBNYXRoLm1pbigwLCBzaXplWzFdKSwgTWF0aC5tYXgoc2l6ZVsxXSAtIDEsIC0xKSk7XG4gICAgICByZXR1cm4gdGlsZVJhbmdlO1xuICAgIH0sIHRoaXMpO1xuICB9IGVsc2UgaWYgKGV4dGVudCkge1xuICAgIHRoaXMuY2FsY3VsYXRlVGlsZVJhbmdlc18oZXh0ZW50KTtcbiAgfVxuXG59O1xuXG4vKipcbiAqIENhbGwgYSBmdW5jdGlvbiB3aXRoIGVhY2ggdGlsZSBjb29yZGluYXRlIGZvciBhIGdpdmVuIGV4dGVudCBhbmQgem9vbSBsZXZlbC5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gem9vbSBJbnRlZ2VyIHpvb20gbGV2ZWwuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmQpfSBjYWxsYmFjayBGdW5jdGlvbiBjYWxsZWQgd2l0aCBlYWNoIHRpbGUgY29vcmRpbmF0ZS5cbiAqIEBhcGlcbiAqL1xuVGlsZUdyaWQucHJvdG90eXBlLmZvckVhY2hUaWxlQ29vcmQgPSBmdW5jdGlvbiBmb3JFYWNoVGlsZUNvb3JkIChleHRlbnQsIHpvb20sIGNhbGxiYWNrKSB7XG4gIHZhciB0aWxlUmFuZ2UgPSB0aGlzLmdldFRpbGVSYW5nZUZvckV4dGVudEFuZFooZXh0ZW50LCB6b29tKTtcbiAgZm9yICh2YXIgaSA9IHRpbGVSYW5nZS5taW5YLCBpaSA9IHRpbGVSYW5nZS5tYXhYOyBpIDw9IGlpOyArK2kpIHtcbiAgICBmb3IgKHZhciBqID0gdGlsZVJhbmdlLm1pblksIGpqID0gdGlsZVJhbmdlLm1heFk7IGogPD0gamo7ICsraikge1xuICAgICAgY2FsbGJhY2soW3pvb20sIGksIGpdKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBULCBudW1iZXIsIGltcG9ydChcIi4uL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0KTogYm9vbGVhbn0gY2FsbGJhY2sgQ2FsbGJhY2suXG4gKiBAcGFyYW0ge1Q9fSBvcHRfdGhpcyBUaGUgb2JqZWN0IHRvIHVzZSBhcyBgdGhpc2AgaW4gYGNhbGxiYWNrYC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHQ9fSBvcHRfdGlsZVJhbmdlIFRlbXBvcmFyeSBpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdCBvYmplY3QuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnQ9fSBvcHRfZXh0ZW50IFRlbXBvcmFyeSBpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50IG9iamVjdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IENhbGxiYWNrIHN1Y2NlZWRlZC5cbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cblRpbGVHcmlkLnByb3RvdHlwZS5mb3JFYWNoVGlsZUNvb3JkUGFyZW50VGlsZVJhbmdlID0gZnVuY3Rpb24gZm9yRWFjaFRpbGVDb29yZFBhcmVudFRpbGVSYW5nZSAodGlsZUNvb3JkLCBjYWxsYmFjaywgb3B0X3RoaXMsIG9wdF90aWxlUmFuZ2UsIG9wdF9leHRlbnQpIHtcbiAgdmFyIHRpbGVSYW5nZSwgeCwgeTtcbiAgdmFyIHRpbGVDb29yZEV4dGVudCA9IG51bGw7XG4gIHZhciB6ID0gdGlsZUNvb3JkWzBdIC0gMTtcbiAgaWYgKHRoaXMuem9vbUZhY3Rvcl8gPT09IDIpIHtcbiAgICB4ID0gdGlsZUNvb3JkWzFdO1xuICAgIHkgPSB0aWxlQ29vcmRbMl07XG4gIH0gZWxzZSB7XG4gICAgdGlsZUNvb3JkRXh0ZW50ID0gdGhpcy5nZXRUaWxlQ29vcmRFeHRlbnQodGlsZUNvb3JkLCBvcHRfZXh0ZW50KTtcbiAgfVxuICB3aGlsZSAoeiA+PSB0aGlzLm1pblpvb20pIHtcbiAgICBpZiAodGhpcy56b29tRmFjdG9yXyA9PT0gMikge1xuICAgICAgeCA9IE1hdGguZmxvb3IoeCAvIDIpO1xuICAgICAgeSA9IE1hdGguZmxvb3IoeSAvIDIpO1xuICAgICAgdGlsZVJhbmdlID0gY3JlYXRlT3JVcGRhdGVUaWxlUmFuZ2UoeCwgeCwgeSwgeSwgb3B0X3RpbGVSYW5nZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbGVSYW5nZSA9IHRoaXMuZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWih0aWxlQ29vcmRFeHRlbnQsIHosIG9wdF90aWxlUmFuZ2UpO1xuICAgIH1cbiAgICBpZiAoY2FsbGJhY2suY2FsbChvcHRfdGhpcywgeiwgdGlsZVJhbmdlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC0tejtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgZXh0ZW50IGZvciB0aGlzIHRpbGUgZ3JpZCwgaWYgaXQgd2FzIGNvbmZpZ3VyZWQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBFeHRlbnQuXG4gKi9cblRpbGVHcmlkLnByb3RvdHlwZS5nZXRFeHRlbnQgPSBmdW5jdGlvbiBnZXRFeHRlbnQgKCkge1xuICByZXR1cm4gdGhpcy5leHRlbnRfO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIG1heGltdW0gem9vbSBsZXZlbCBmb3IgdGhlIGdyaWQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE1heCB6b29tLlxuICogQGFwaVxuICovXG5UaWxlR3JpZC5wcm90b3R5cGUuZ2V0TWF4Wm9vbSA9IGZ1bmN0aW9uIGdldE1heFpvb20gKCkge1xuICByZXR1cm4gdGhpcy5tYXhab29tO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIG1pbmltdW0gem9vbSBsZXZlbCBmb3IgdGhlIGdyaWQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE1pbiB6b29tLlxuICogQGFwaVxuICovXG5UaWxlR3JpZC5wcm90b3R5cGUuZ2V0TWluWm9vbSA9IGZ1bmN0aW9uIGdldE1pblpvb20gKCkge1xuICByZXR1cm4gdGhpcy5taW5ab29tO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIG9yaWdpbiBmb3IgdGhlIGdyaWQgYXQgdGhlIGdpdmVuIHpvb20gbGV2ZWwuXG4gKiBAcGFyYW0ge251bWJlcn0geiBJbnRlZ2VyIHpvb20gbGV2ZWwuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IE9yaWdpbi5cbiAqIEBhcGlcbiAqL1xuVGlsZUdyaWQucHJvdG90eXBlLmdldE9yaWdpbiA9IGZ1bmN0aW9uIGdldE9yaWdpbiAoeikge1xuICBpZiAodGhpcy5vcmlnaW5fKSB7XG4gICAgcmV0dXJuIHRoaXMub3JpZ2luXztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5vcmlnaW5zX1t6XTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIHJlc29sdXRpb24gZm9yIHRoZSBnaXZlbiB6b29tIGxldmVsLlxuICogQHBhcmFtIHtudW1iZXJ9IHogSW50ZWdlciB6b29tIGxldmVsLlxuICogQHJldHVybiB7bnVtYmVyfSBSZXNvbHV0aW9uLlxuICogQGFwaVxuICovXG5UaWxlR3JpZC5wcm90b3R5cGUuZ2V0UmVzb2x1dGlvbiA9IGZ1bmN0aW9uIGdldFJlc29sdXRpb24gKHopIHtcbiAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbnNfW3pdO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGxpc3Qgb2YgcmVzb2x1dGlvbnMgZm9yIHRoZSB0aWxlIGdyaWQuXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBSZXNvbHV0aW9ucy5cbiAqIEBhcGlcbiAqL1xuVGlsZUdyaWQucHJvdG90eXBlLmdldFJlc29sdXRpb25zID0gZnVuY3Rpb24gZ2V0UmVzb2x1dGlvbnMgKCkge1xuICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uc187XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHQ9fSBvcHRfdGlsZVJhbmdlIFRlbXBvcmFyeSBpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdCBvYmplY3QuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnQ9fSBvcHRfZXh0ZW50IFRlbXBvcmFyeSBpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50IG9iamVjdC5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0fSBUaWxlIHJhbmdlLlxuICovXG5UaWxlR3JpZC5wcm90b3R5cGUuZ2V0VGlsZUNvb3JkQ2hpbGRUaWxlUmFuZ2UgPSBmdW5jdGlvbiBnZXRUaWxlQ29vcmRDaGlsZFRpbGVSYW5nZSAodGlsZUNvb3JkLCBvcHRfdGlsZVJhbmdlLCBvcHRfZXh0ZW50KSB7XG4gIGlmICh0aWxlQ29vcmRbMF0gPCB0aGlzLm1heFpvb20pIHtcbiAgICBpZiAodGhpcy56b29tRmFjdG9yXyA9PT0gMikge1xuICAgICAgdmFyIG1pblggPSB0aWxlQ29vcmRbMV0gKiAyO1xuICAgICAgdmFyIG1pblkgPSB0aWxlQ29vcmRbMl0gKiAyO1xuICAgICAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlVGlsZVJhbmdlKG1pblgsIG1pblggKyAxLCBtaW5ZLCBtaW5ZICsgMSwgb3B0X3RpbGVSYW5nZSk7XG4gICAgfVxuICAgIHZhciB0aWxlQ29vcmRFeHRlbnQgPSB0aGlzLmdldFRpbGVDb29yZEV4dGVudCh0aWxlQ29vcmQsIG9wdF9leHRlbnQpO1xuICAgIHJldHVybiB0aGlzLmdldFRpbGVSYW5nZUZvckV4dGVudEFuZFooXG4gICAgICB0aWxlQ29vcmRFeHRlbnQsIHRpbGVDb29yZFswXSArIDEsIG9wdF90aWxlUmFuZ2UpO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGV4dGVudCBmb3IgYSB0aWxlIHJhbmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IHogSW50ZWdlciB6b29tIGxldmVsLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdH0gdGlsZVJhbmdlIFRpbGUgcmFuZ2UuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnQ9fSBvcHRfZXh0ZW50IFRlbXBvcmFyeSBpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50IG9iamVjdC5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IEV4dGVudC5cbiAqL1xuVGlsZUdyaWQucHJvdG90eXBlLmdldFRpbGVSYW5nZUV4dGVudCA9IGZ1bmN0aW9uIGdldFRpbGVSYW5nZUV4dGVudCAoeiwgdGlsZVJhbmdlLCBvcHRfZXh0ZW50KSB7XG4gIHZhciBvcmlnaW4gPSB0aGlzLmdldE9yaWdpbih6KTtcbiAgdmFyIHJlc29sdXRpb24gPSB0aGlzLmdldFJlc29sdXRpb24oeik7XG4gIHZhciB0aWxlU2l6ZSA9IHRvU2l6ZSh0aGlzLmdldFRpbGVTaXplKHopLCB0aGlzLnRtcFNpemVfKTtcbiAgdmFyIG1pblggPSBvcmlnaW5bMF0gKyB0aWxlUmFuZ2UubWluWCAqIHRpbGVTaXplWzBdICogcmVzb2x1dGlvbjtcbiAgdmFyIG1heFggPSBvcmlnaW5bMF0gKyAodGlsZVJhbmdlLm1heFggKyAxKSAqIHRpbGVTaXplWzBdICogcmVzb2x1dGlvbjtcbiAgdmFyIG1pblkgPSBvcmlnaW5bMV0gKyB0aWxlUmFuZ2UubWluWSAqIHRpbGVTaXplWzFdICogcmVzb2x1dGlvbjtcbiAgdmFyIG1heFkgPSBvcmlnaW5bMV0gKyAodGlsZVJhbmdlLm1heFkgKyAxKSAqIHRpbGVTaXplWzFdICogcmVzb2x1dGlvbjtcbiAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlKG1pblgsIG1pblksIG1heFgsIG1heFksIG9wdF9leHRlbnQpO1xufTtcblxuLyoqXG4gKiBHZXQgYSB0aWxlIHJhbmdlIGZvciB0aGUgZ2l2ZW4gZXh0ZW50IGFuZCBpbnRlZ2VyIHpvb20gbGV2ZWwuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0geiBJbnRlZ2VyIHpvb20gbGV2ZWwuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0PX0gb3B0X3RpbGVSYW5nZSBUZW1wb3JhcnkgdGlsZSByYW5nZSBvYmplY3QuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdH0gVGlsZSByYW5nZS5cbiAqL1xuVGlsZUdyaWQucHJvdG90eXBlLmdldFRpbGVSYW5nZUZvckV4dGVudEFuZFogPSBmdW5jdGlvbiBnZXRUaWxlUmFuZ2VGb3JFeHRlbnRBbmRaIChleHRlbnQsIHosIG9wdF90aWxlUmFuZ2UpIHtcbiAgdmFyIHRpbGVDb29yZCA9IHRtcFRpbGVDb29yZDtcbiAgdGhpcy5nZXRUaWxlQ29vcmRGb3JYWUFuZFpfKGV4dGVudFswXSwgZXh0ZW50WzFdLCB6LCBmYWxzZSwgdGlsZUNvb3JkKTtcbiAgdmFyIG1pblggPSB0aWxlQ29vcmRbMV07XG4gIHZhciBtaW5ZID0gdGlsZUNvb3JkWzJdO1xuICB0aGlzLmdldFRpbGVDb29yZEZvclhZQW5kWl8oZXh0ZW50WzJdLCBleHRlbnRbM10sIHosIHRydWUsIHRpbGVDb29yZCk7XG4gIHJldHVybiBjcmVhdGVPclVwZGF0ZVRpbGVSYW5nZShtaW5YLCB0aWxlQ29vcmRbMV0sIG1pblksIHRpbGVDb29yZFsyXSwgb3B0X3RpbGVSYW5nZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gVGlsZSBjZW50ZXIuXG4gKi9cblRpbGVHcmlkLnByb3RvdHlwZS5nZXRUaWxlQ29vcmRDZW50ZXIgPSBmdW5jdGlvbiBnZXRUaWxlQ29vcmRDZW50ZXIgKHRpbGVDb29yZCkge1xuICB2YXIgb3JpZ2luID0gdGhpcy5nZXRPcmlnaW4odGlsZUNvb3JkWzBdKTtcbiAgdmFyIHJlc29sdXRpb24gPSB0aGlzLmdldFJlc29sdXRpb24odGlsZUNvb3JkWzBdKTtcbiAgdmFyIHRpbGVTaXplID0gdG9TaXplKHRoaXMuZ2V0VGlsZVNpemUodGlsZUNvb3JkWzBdKSwgdGhpcy50bXBTaXplXyk7XG4gIHJldHVybiBbXG4gICAgb3JpZ2luWzBdICsgKHRpbGVDb29yZFsxXSArIDAuNSkgKiB0aWxlU2l6ZVswXSAqIHJlc29sdXRpb24sXG4gICAgb3JpZ2luWzFdICsgKHRpbGVDb29yZFsyXSArIDAuNSkgKiB0aWxlU2l6ZVsxXSAqIHJlc29sdXRpb25cbiAgXTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBleHRlbnQgb2YgYSB0aWxlIGNvb3JkaW5hdGUuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50PX0gb3B0X2V4dGVudCBUZW1wb3JhcnkgZXh0ZW50IG9iamVjdC5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IEV4dGVudC5cbiAqIEBhcGlcbiAqL1xuVGlsZUdyaWQucHJvdG90eXBlLmdldFRpbGVDb29yZEV4dGVudCA9IGZ1bmN0aW9uIGdldFRpbGVDb29yZEV4dGVudCAodGlsZUNvb3JkLCBvcHRfZXh0ZW50KSB7XG4gIHZhciBvcmlnaW4gPSB0aGlzLmdldE9yaWdpbih0aWxlQ29vcmRbMF0pO1xuICB2YXIgcmVzb2x1dGlvbiA9IHRoaXMuZ2V0UmVzb2x1dGlvbih0aWxlQ29vcmRbMF0pO1xuICB2YXIgdGlsZVNpemUgPSB0b1NpemUodGhpcy5nZXRUaWxlU2l6ZSh0aWxlQ29vcmRbMF0pLCB0aGlzLnRtcFNpemVfKTtcbiAgdmFyIG1pblggPSBvcmlnaW5bMF0gKyB0aWxlQ29vcmRbMV0gKiB0aWxlU2l6ZVswXSAqIHJlc29sdXRpb247XG4gIHZhciBtaW5ZID0gb3JpZ2luWzFdICsgdGlsZUNvb3JkWzJdICogdGlsZVNpemVbMV0gKiByZXNvbHV0aW9uO1xuICB2YXIgbWF4WCA9IG1pblggKyB0aWxlU2l6ZVswXSAqIHJlc29sdXRpb247XG4gIHZhciBtYXhZID0gbWluWSArIHRpbGVTaXplWzFdICogcmVzb2x1dGlvbjtcbiAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlKG1pblgsIG1pblksIG1heFgsIG1heFksIG9wdF9leHRlbnQpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHRpbGUgY29vcmRpbmF0ZSBmb3IgdGhlIGdpdmVuIG1hcCBjb29yZGluYXRlIGFuZCByZXNvbHV0aW9uLlRoaXNcbiAqIG1ldGhvZCBjb25zaWRlcnMgdGhhdCBjb29yZGluYXRlcyB0aGF0IGludGVyc2VjdCB0aWxlIGJvdW5kYXJpZXMgc2hvdWxkIGJlXG4gKiBhc3NpZ25lZCB0aGUgaGlnaGVyIHRpbGUgY29vcmRpbmF0ZS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZD19IG9wdF90aWxlQ29vcmQgRGVzdGluYXRpb24gaW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZCBvYmplY3QuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSBUaWxlIGNvb3JkaW5hdGUuXG4gKiBAYXBpXG4gKi9cblRpbGVHcmlkLnByb3RvdHlwZS5nZXRUaWxlQ29vcmRGb3JDb29yZEFuZFJlc29sdXRpb24gPSBmdW5jdGlvbiBnZXRUaWxlQ29vcmRGb3JDb29yZEFuZFJlc29sdXRpb24gKGNvb3JkaW5hdGUsIHJlc29sdXRpb24sIG9wdF90aWxlQ29vcmQpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0VGlsZUNvb3JkRm9yWFlBbmRSZXNvbHV0aW9uXyhcbiAgICBjb29yZGluYXRlWzBdLCBjb29yZGluYXRlWzFdLCByZXNvbHV0aW9uLCBmYWxzZSwgb3B0X3RpbGVDb29yZCk7XG59O1xuXG4vKipcbiAqIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBzaG91bGQgbm90IGJlIGNhbGxlZCBmb3IgcmVzb2x1dGlvbnMgdGhhdCBjb3JyZXNwb25kXG4gKiB0byBhbiBpbnRlZ2VyIHpvb20gbGV2ZWwuSW5zdGVhZCBjYWxsIHRoZSBgZ2V0VGlsZUNvb3JkRm9yWFlBbmRaX2AgbWV0aG9kLlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uIChmb3IgYSBub24taW50ZWdlciB6b29tIGxldmVsKS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcmV2ZXJzZUludGVyc2VjdGlvblBvbGljeSBJbnN0ZWFkIG9mIGxldHRpbmcgZWRnZVxuICogICBpbnRlcnNlY3Rpb25zIGdvIHRvIHRoZSBoaWdoZXIgdGlsZSBjb29yZGluYXRlLCBsZXQgZWRnZSBpbnRlcnNlY3Rpb25zXG4gKiAgIGdvIHRvIHRoZSBsb3dlciB0aWxlIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmQ9fSBvcHRfdGlsZUNvb3JkIFRlbXBvcmFyeSBpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkIG9iamVjdC5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IFRpbGUgY29vcmRpbmF0ZS5cbiAqIEBwcml2YXRlXG4gKi9cblRpbGVHcmlkLnByb3RvdHlwZS5nZXRUaWxlQ29vcmRGb3JYWUFuZFJlc29sdXRpb25fID0gZnVuY3Rpb24gZ2V0VGlsZUNvb3JkRm9yWFlBbmRSZXNvbHV0aW9uXyAoeCwgeSwgcmVzb2x1dGlvbiwgcmV2ZXJzZUludGVyc2VjdGlvblBvbGljeSwgb3B0X3RpbGVDb29yZCkge1xuICB2YXIgeiA9IHRoaXMuZ2V0WkZvclJlc29sdXRpb24ocmVzb2x1dGlvbik7XG4gIHZhciBzY2FsZSA9IHJlc29sdXRpb24gLyB0aGlzLmdldFJlc29sdXRpb24oeik7XG4gIHZhciBvcmlnaW4gPSB0aGlzLmdldE9yaWdpbih6KTtcbiAgdmFyIHRpbGVTaXplID0gdG9TaXplKHRoaXMuZ2V0VGlsZVNpemUoeiksIHRoaXMudG1wU2l6ZV8pO1xuXG4gIHZhciBhZGp1c3RYID0gcmV2ZXJzZUludGVyc2VjdGlvblBvbGljeSA/IDAuNSA6IDA7XG4gIHZhciBhZGp1c3RZID0gcmV2ZXJzZUludGVyc2VjdGlvblBvbGljeSA/IDAgOiAwLjU7XG4gIHZhciB4RnJvbU9yaWdpbiA9IE1hdGguZmxvb3IoKHggLSBvcmlnaW5bMF0pIC8gcmVzb2x1dGlvbiArIGFkanVzdFgpO1xuICB2YXIgeUZyb21PcmlnaW4gPSBNYXRoLmZsb29yKCh5IC0gb3JpZ2luWzFdKSAvIHJlc29sdXRpb24gKyBhZGp1c3RZKTtcbiAgdmFyIHRpbGVDb29yZFggPSBzY2FsZSAqIHhGcm9tT3JpZ2luIC8gdGlsZVNpemVbMF07XG4gIHZhciB0aWxlQ29vcmRZID0gc2NhbGUgKiB5RnJvbU9yaWdpbiAvIHRpbGVTaXplWzFdO1xuXG4gIGlmIChyZXZlcnNlSW50ZXJzZWN0aW9uUG9saWN5KSB7XG4gICAgdGlsZUNvb3JkWCA9IE1hdGguY2VpbCh0aWxlQ29vcmRYKSAtIDE7XG4gICAgdGlsZUNvb3JkWSA9IE1hdGguY2VpbCh0aWxlQ29vcmRZKSAtIDE7XG4gIH0gZWxzZSB7XG4gICAgdGlsZUNvb3JkWCA9IE1hdGguZmxvb3IodGlsZUNvb3JkWCk7XG4gICAgdGlsZUNvb3JkWSA9IE1hdGguZmxvb3IodGlsZUNvb3JkWSk7XG4gIH1cblxuICByZXR1cm4gY3JlYXRlT3JVcGRhdGVUaWxlQ29vcmQoeiwgdGlsZUNvb3JkWCwgdGlsZUNvb3JkWSwgb3B0X3RpbGVDb29yZCk7XG59O1xuXG4vKipcbiAqIEFsdGhvdWdoIHRoZXJlIGlzIHJlcGV0aXRpb24gYmV0d2VlbiB0aGlzIG1ldGhvZCBhbmQgYGdldFRpbGVDb29yZEZvclhZQW5kUmVzb2x1dGlvbl9gLFxuICogdGhleSBzaG91bGQgaGF2ZSBzZXBhcmF0ZSBpbXBsZW1lbnRhdGlvbnMuVGhpcyBtZXRob2QgaXMgZm9yIGludGVnZXIgem9vbVxuICogbGV2ZWxzLlRoZSBvdGhlciBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGZvciByZXNvbHV0aW9ucyBjb3JyZXNwb25kaW5nXG4gKiB0byBub24taW50ZWdlciB6b29tIGxldmVscy5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IE1hcCB4IGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0geSBNYXAgeSBjb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHogSW50ZWdlciB6b29tIGxldmVsLlxuICogQHBhcmFtIHtib29sZWFufSByZXZlcnNlSW50ZXJzZWN0aW9uUG9saWN5IEluc3RlYWQgb2YgbGV0dGluZyBlZGdlXG4gKiAgIGludGVyc2VjdGlvbnMgZ28gdG8gdGhlIGhpZ2hlciB0aWxlIGNvb3JkaW5hdGUsIGxldCBlZGdlIGludGVyc2VjdGlvbnNcbiAqICAgZ28gdG8gdGhlIGxvd2VyIHRpbGUgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZD19IG9wdF90aWxlQ29vcmQgVGVtcG9yYXJ5IGltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmQgb2JqZWN0LlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gVGlsZSBjb29yZGluYXRlLlxuICogQHByaXZhdGVcbiAqL1xuVGlsZUdyaWQucHJvdG90eXBlLmdldFRpbGVDb29yZEZvclhZQW5kWl8gPSBmdW5jdGlvbiBnZXRUaWxlQ29vcmRGb3JYWUFuZFpfICh4LCB5LCB6LCByZXZlcnNlSW50ZXJzZWN0aW9uUG9saWN5LCBvcHRfdGlsZUNvb3JkKSB7XG4gIHZhciBvcmlnaW4gPSB0aGlzLmdldE9yaWdpbih6KTtcbiAgdmFyIHJlc29sdXRpb24gPSB0aGlzLmdldFJlc29sdXRpb24oeik7XG4gIHZhciB0aWxlU2l6ZSA9IHRvU2l6ZSh0aGlzLmdldFRpbGVTaXplKHopLCB0aGlzLnRtcFNpemVfKTtcblxuICB2YXIgYWRqdXN0WCA9IHJldmVyc2VJbnRlcnNlY3Rpb25Qb2xpY3kgPyAwLjUgOiAwO1xuICB2YXIgYWRqdXN0WSA9IHJldmVyc2VJbnRlcnNlY3Rpb25Qb2xpY3kgPyAwIDogMC41O1xuICB2YXIgeEZyb21PcmlnaW4gPSBNYXRoLmZsb29yKCh4IC0gb3JpZ2luWzBdKSAvIHJlc29sdXRpb24gKyBhZGp1c3RYKTtcbiAgdmFyIHlGcm9tT3JpZ2luID0gTWF0aC5mbG9vcigoeSAtIG9yaWdpblsxXSkgLyByZXNvbHV0aW9uICsgYWRqdXN0WSk7XG4gIHZhciB0aWxlQ29vcmRYID0geEZyb21PcmlnaW4gLyB0aWxlU2l6ZVswXTtcbiAgdmFyIHRpbGVDb29yZFkgPSB5RnJvbU9yaWdpbiAvIHRpbGVTaXplWzFdO1xuXG4gIGlmIChyZXZlcnNlSW50ZXJzZWN0aW9uUG9saWN5KSB7XG4gICAgdGlsZUNvb3JkWCA9IE1hdGguY2VpbCh0aWxlQ29vcmRYKSAtIDE7XG4gICAgdGlsZUNvb3JkWSA9IE1hdGguY2VpbCh0aWxlQ29vcmRZKSAtIDE7XG4gIH0gZWxzZSB7XG4gICAgdGlsZUNvb3JkWCA9IE1hdGguZmxvb3IodGlsZUNvb3JkWCk7XG4gICAgdGlsZUNvb3JkWSA9IE1hdGguZmxvb3IodGlsZUNvb3JkWSk7XG4gIH1cblxuICByZXR1cm4gY3JlYXRlT3JVcGRhdGVUaWxlQ29vcmQoeiwgdGlsZUNvb3JkWCwgdGlsZUNvb3JkWSwgb3B0X3RpbGVDb29yZCk7XG59O1xuXG4vKipcbiAqIEdldCBhIHRpbGUgY29vcmRpbmF0ZSBnaXZlbiBhIG1hcCBjb29yZGluYXRlIGFuZCB6b29tIGxldmVsLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB6IFpvb20gbGV2ZWwuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmQ9fSBvcHRfdGlsZUNvb3JkIERlc3RpbmF0aW9uIGltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmQgb2JqZWN0LlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gVGlsZSBjb29yZGluYXRlLlxuICogQGFwaVxuICovXG5UaWxlR3JpZC5wcm90b3R5cGUuZ2V0VGlsZUNvb3JkRm9yQ29vcmRBbmRaID0gZnVuY3Rpb24gZ2V0VGlsZUNvb3JkRm9yQ29vcmRBbmRaIChjb29yZGluYXRlLCB6LCBvcHRfdGlsZUNvb3JkKSB7XG4gIHJldHVybiB0aGlzLmdldFRpbGVDb29yZEZvclhZQW5kWl8oXG4gICAgY29vcmRpbmF0ZVswXSwgY29vcmRpbmF0ZVsxXSwgeiwgZmFsc2UsIG9wdF90aWxlQ29vcmQpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRpbGUgcmVzb2x1dGlvbi5cbiAqL1xuVGlsZUdyaWQucHJvdG90eXBlLmdldFRpbGVDb29yZFJlc29sdXRpb24gPSBmdW5jdGlvbiBnZXRUaWxlQ29vcmRSZXNvbHV0aW9uICh0aWxlQ29vcmQpIHtcbiAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbnNfW3RpbGVDb29yZFswXV07XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdGlsZSBzaXplIGZvciBhIHpvb20gbGV2ZWwuIFRoZSB0eXBlIG9mIHRoZSByZXR1cm4gdmFsdWUgbWF0Y2hlcyB0aGVcbiAqIGB0aWxlU2l6ZWAgb3IgYHRpbGVTaXplc2AgdGhhdCB0aGUgdGlsZSBncmlkIHdhcyBjb25maWd1cmVkIHdpdGguIFRvIGFsd2F5c1xuICogZ2V0IGFuIGBpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemVgLCBydW4gdGhlIHJlc3VsdCB0aHJvdWdoIGBpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemUudG9TaXplKClgLlxuICogQHBhcmFtIHtudW1iZXJ9IHogWi5cbiAqIEByZXR1cm4ge251bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IFRpbGUgc2l6ZS5cbiAqIEBhcGlcbiAqL1xuVGlsZUdyaWQucHJvdG90eXBlLmdldFRpbGVTaXplID0gZnVuY3Rpb24gZ2V0VGlsZVNpemUgKHopIHtcbiAgaWYgKHRoaXMudGlsZVNpemVfKSB7XG4gICAgcmV0dXJuIHRoaXMudGlsZVNpemVfO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLnRpbGVTaXplc19bel07XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHogWm9vbSBsZXZlbC5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0fSBFeHRlbnQgdGlsZSByYW5nZSBmb3IgdGhlIHNwZWNpZmllZCB6b29tIGxldmVsLlxuICovXG5UaWxlR3JpZC5wcm90b3R5cGUuZ2V0RnVsbFRpbGVSYW5nZSA9IGZ1bmN0aW9uIGdldEZ1bGxUaWxlUmFuZ2UgKHopIHtcbiAgaWYgKCF0aGlzLmZ1bGxUaWxlUmFuZ2VzXykge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLmZ1bGxUaWxlUmFuZ2VzX1t6XTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZGlyZWN0aW9uIElmIDAsIHRoZSBuZWFyZXN0IHJlc29sdXRpb24gd2lsbCBiZSB1c2VkLlxuICogICBJZiAxLCB0aGUgbmVhcmVzdCBsb3dlciByZXNvbHV0aW9uIHdpbGwgYmUgdXNlZC4gSWYgLTEsIHRoZSBuZWFyZXN0XG4gKiAgIGhpZ2hlciByZXNvbHV0aW9uIHdpbGwgYmUgdXNlZC4gRGVmYXVsdCBpcyAwLlxuICogQHJldHVybiB7bnVtYmVyfSBaLlxuICogQGFwaVxuICovXG5UaWxlR3JpZC5wcm90b3R5cGUuZ2V0WkZvclJlc29sdXRpb24gPSBmdW5jdGlvbiBnZXRaRm9yUmVzb2x1dGlvbiAocmVzb2x1dGlvbiwgb3B0X2RpcmVjdGlvbikge1xuICB2YXIgeiA9IGxpbmVhckZpbmROZWFyZXN0KHRoaXMucmVzb2x1dGlvbnNfLCByZXNvbHV0aW9uLCBvcHRfZGlyZWN0aW9uIHx8IDApO1xuICByZXR1cm4gY2xhbXAoeiwgdGhpcy5taW5ab29tLCB0aGlzLm1heFpvb20pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0geyFpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50IGZvciB0aGlzIHRpbGUgZ3JpZC5cbiAqIEBwcml2YXRlXG4gKi9cblRpbGVHcmlkLnByb3RvdHlwZS5jYWxjdWxhdGVUaWxlUmFuZ2VzXyA9IGZ1bmN0aW9uIGNhbGN1bGF0ZVRpbGVSYW5nZXNfIChleHRlbnQpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMucmVzb2x1dGlvbnNfLmxlbmd0aDtcbiAgdmFyIGZ1bGxUaWxlUmFuZ2VzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gIGZvciAodmFyIHogPSB0aGlzLm1pblpvb207IHogPCBsZW5ndGg7ICsreikge1xuICAgIGZ1bGxUaWxlUmFuZ2VzW3pdID0gdGhpcy5nZXRUaWxlUmFuZ2VGb3JFeHRlbnRBbmRaKGV4dGVudCwgeik7XG4gIH1cbiAgdGhpcy5mdWxsVGlsZVJhbmdlc18gPSBmdWxsVGlsZVJhbmdlcztcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgVGlsZUdyaWQ7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpbGVHcmlkLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC90aWxlZ3JpZC9jb21tb25cbiAqL1xuXG4vKipcbiAqIERlZmF1bHQgbWF4aW11bSB6b29tIGZvciBkZWZhdWx0IHRpbGUgZ3JpZHMuXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIERFRkFVTFRfTUFYX1pPT00gPSA0MjtcblxuLyoqXG4gKiBEZWZhdWx0IHRpbGUgc2l6ZS5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgREVGQVVMVF9USUxFX1NJWkUgPSAyNTY7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbW1vbi5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvdGlsZXVybGZ1bmN0aW9uXG4gKi9cbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuL2Fzc2VydHMuanMnO1xuaW1wb3J0IHttb2R1bG99IGZyb20gJy4vbWF0aC5qcyc7XG5pbXBvcnQge2hhc2ggYXMgdGlsZUNvb3JkSGFzaH0gZnJvbSAnLi90aWxlY29vcmQuanMnO1xuXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRlbXBsYXRlIFRlbXBsYXRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9IHRpbGVHcmlkIFRpbGUgZ3JpZC5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vVGlsZS5qc1wiKS5VcmxGdW5jdGlvbn0gVGlsZSBVUkwgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGcm9tVGVtcGxhdGUodGVtcGxhdGUsIHRpbGVHcmlkKSB7XG4gIHZhciB6UmVnRXggPSAvXFx7elxcfS9nO1xuICB2YXIgeFJlZ0V4ID0gL1xce3hcXH0vZztcbiAgdmFyIHlSZWdFeCA9IC9cXHt5XFx9L2c7XG4gIHZhciBkYXNoWVJlZ0V4ID0gL1xcey15XFx9L2c7XG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIENvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAgICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0gVGlsZSBVUkwuXG4gICAgICovXG4gICAgZnVuY3Rpb24odGlsZUNvb3JkLCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKSB7XG4gICAgICBpZiAoIXRpbGVDb29yZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlLnJlcGxhY2UoelJlZ0V4LCB0aWxlQ29vcmRbMF0udG9TdHJpbmcoKSlcbiAgICAgICAgICAucmVwbGFjZSh4UmVnRXgsIHRpbGVDb29yZFsxXS50b1N0cmluZygpKVxuICAgICAgICAgIC5yZXBsYWNlKHlSZWdFeCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgeSA9IC10aWxlQ29vcmRbMl0gLSAxO1xuICAgICAgICAgICAgcmV0dXJuIHkudG9TdHJpbmcoKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5yZXBsYWNlKGRhc2hZUmVnRXgsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHogPSB0aWxlQ29vcmRbMF07XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSB0aWxlR3JpZC5nZXRGdWxsVGlsZVJhbmdlKHopO1xuICAgICAgICAgICAgYXNzZXJ0KHJhbmdlLCA1NSk7IC8vIFRoZSB7LXl9IHBsYWNlaG9sZGVyIHJlcXVpcmVzIGEgdGlsZSBncmlkIHdpdGggZXh0ZW50XG4gICAgICAgICAgICB2YXIgeSA9IHJhbmdlLmdldEhlaWdodCgpICsgdGlsZUNvb3JkWzJdO1xuICAgICAgICAgICAgcmV0dXJuIHkudG9TdHJpbmcoKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHRlbXBsYXRlcyBUZW1wbGF0ZXMuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH0gdGlsZUdyaWQgVGlsZSBncmlkLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9UaWxlLmpzXCIpLlVybEZ1bmN0aW9ufSBUaWxlIFVSTCBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZyb21UZW1wbGF0ZXModGVtcGxhdGVzLCB0aWxlR3JpZCkge1xuICB2YXIgbGVuID0gdGVtcGxhdGVzLmxlbmd0aDtcbiAgdmFyIHRpbGVVcmxGdW5jdGlvbnMgPSBuZXcgQXJyYXkobGVuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHRpbGVVcmxGdW5jdGlvbnNbaV0gPSBjcmVhdGVGcm9tVGVtcGxhdGUodGVtcGxhdGVzW2ldLCB0aWxlR3JpZCk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUZyb21UaWxlVXJsRnVuY3Rpb25zKHRpbGVVcmxGdW5jdGlvbnMpO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuL1RpbGUuanNcIikuVXJsRnVuY3Rpb24+fSB0aWxlVXJsRnVuY3Rpb25zIFRpbGUgVVJMIEZ1bmN0aW9ucy5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vVGlsZS5qc1wiKS5VcmxGdW5jdGlvbn0gVGlsZSBVUkwgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGcm9tVGlsZVVybEZ1bmN0aW9ucyh0aWxlVXJsRnVuY3Rpb25zKSB7XG4gIGlmICh0aWxlVXJsRnVuY3Rpb25zLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB0aWxlVXJsRnVuY3Rpb25zWzBdO1xuICB9XG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIENvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAgICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0gVGlsZSBVUkwuXG4gICAgICovXG4gICAgZnVuY3Rpb24odGlsZUNvb3JkLCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKSB7XG4gICAgICBpZiAoIXRpbGVDb29yZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGggPSB0aWxlQ29vcmRIYXNoKHRpbGVDb29yZCk7XG4gICAgICAgIHZhciBpbmRleCA9IG1vZHVsbyhoLCB0aWxlVXJsRnVuY3Rpb25zLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiB0aWxlVXJsRnVuY3Rpb25zW2luZGV4XSh0aWxlQ29vcmQsIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pO1xuICAgICAgfVxuICAgIH1cbiAgKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge3N0cmluZ3x1bmRlZmluZWR9IFRpbGUgVVJMLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbnVsbFRpbGVVcmxGdW5jdGlvbih0aWxlQ29vcmQsIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pIHtcbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVVJMLlxuICogQHJldHVybiB7QXJyYXk8c3RyaW5nPn0gQXJyYXkgb2YgdXJscy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZFVybCh1cmwpIHtcbiAgdmFyIHVybHMgPSBbXTtcbiAgdmFyIG1hdGNoID0gL1xceyhbYS16XSktKFthLXpdKVxcfS8uZXhlYyh1cmwpO1xuICBpZiAobWF0Y2gpIHtcbiAgICAvLyBjaGFyIHJhbmdlXG4gICAgdmFyIHN0YXJ0Q2hhckNvZGUgPSBtYXRjaFsxXS5jaGFyQ29kZUF0KDApO1xuICAgIHZhciBzdG9wQ2hhckNvZGUgPSBtYXRjaFsyXS5jaGFyQ29kZUF0KDApO1xuICAgIHZhciBjaGFyQ29kZTtcbiAgICBmb3IgKGNoYXJDb2RlID0gc3RhcnRDaGFyQ29kZTsgY2hhckNvZGUgPD0gc3RvcENoYXJDb2RlOyArK2NoYXJDb2RlKSB7XG4gICAgICB1cmxzLnB1c2godXJsLnJlcGxhY2UobWF0Y2hbMF0sIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpKSk7XG4gICAgfVxuICAgIHJldHVybiB1cmxzO1xuICB9XG4gIG1hdGNoID0gbWF0Y2ggPSAvXFx7KFxcZCspLShcXGQrKVxcfS8uZXhlYyh1cmwpO1xuICBpZiAobWF0Y2gpIHtcbiAgICAvLyBudW1iZXIgcmFuZ2VcbiAgICB2YXIgc3RvcCA9IHBhcnNlSW50KG1hdGNoWzJdLCAxMCk7XG4gICAgZm9yICh2YXIgaSA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7IGkgPD0gc3RvcDsgaSsrKSB7XG4gICAgICB1cmxzLnB1c2godXJsLnJlcGxhY2UobWF0Y2hbMF0sIGkudG9TdHJpbmcoKSkpO1xuICAgIH1cbiAgICByZXR1cm4gdXJscztcbiAgfVxuICB1cmxzLnB1c2godXJsKTtcbiAgcmV0dXJuIHVybHM7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbGV1cmxmdW5jdGlvbi5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvdHJhbnNmb3JtXG4gKi9cbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuL2Fzc2VydHMuanMnO1xuXG5cbi8qKlxuICogQW4gYXJyYXkgcmVwcmVzZW50aW5nIGFuIGFmZmluZSAyZCB0cmFuc2Zvcm1hdGlvbiBmb3IgdXNlIHdpdGhcbiAqIHtAbGluayBtb2R1bGU6b2wvdHJhbnNmb3JtfSBmdW5jdGlvbnMuIFRoZSBhcnJheSBoYXMgNiBlbGVtZW50cy5cbiAqIEB0eXBlZGVmIHshQXJyYXk8bnVtYmVyPn0gVHJhbnNmb3JtXG4gKi9cblxuXG4vKipcbiAqIENvbGxlY3Rpb24gb2YgYWZmaW5lIDJkIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9ucy4gVGhlIGZ1bmN0aW9ucyB3b3JrIG9uIGFuXG4gKiBhcnJheSBvZiA2IGVsZW1lbnRzLiBUaGUgZWxlbWVudCBvcmRlciBpcyBjb21wYXRpYmxlIHdpdGggdGhlIFtTVkdNYXRyaXhcbiAqIGludGVyZmFjZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NWR01hdHJpeCkgYW5kIGlzXG4gKiBhIHN1YnNldCAoZWxlbWVudHMgYSB0byBmKSBvZiBhIDPDlzMgbWF0cml4OlxuICogYGBgXG4gKiBbIGEgYyBlIF1cbiAqIFsgYiBkIGYgXVxuICogWyAwIDAgMSBdXG4gKiBgYGBcbiAqL1xuXG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEB0eXBlIHtUcmFuc2Zvcm19XG4gKi9cbnZhciB0bXBfID0gbmV3IEFycmF5KDYpO1xuXG5cbi8qKlxuICogQ3JlYXRlIGFuIGlkZW50aXR5IHRyYW5zZm9ybS5cbiAqIEByZXR1cm4geyFUcmFuc2Zvcm19IElkZW50aXR5IHRyYW5zZm9ybS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgcmV0dXJuIFsxLCAwLCAwLCAxLCAwLCAwXTtcbn1cblxuXG4vKipcbiAqIFJlc2V0cyB0aGUgZ2l2ZW4gdHJhbnNmb3JtIHRvIGFuIGlkZW50aXR5IHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAqIEByZXR1cm4geyFUcmFuc2Zvcm19IFRyYW5zZm9ybS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0KHRyYW5zZm9ybSkge1xuICByZXR1cm4gc2V0KHRyYW5zZm9ybSwgMSwgMCwgMCwgMSwgMCwgMCk7XG59XG5cblxuLyoqXG4gKiBNdWx0aXBseSB0aGUgdW5kZXJseWluZyBtYXRyaWNlcyBvZiB0d28gdHJhbnNmb3JtcyBhbmQgcmV0dXJuIHRoZSByZXN1bHQgaW5cbiAqIHRoZSBmaXJzdCB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0geyFUcmFuc2Zvcm19IHRyYW5zZm9ybTEgVHJhbnNmb3JtIHBhcmFtZXRlcnMgb2YgbWF0cml4IDEuXG4gKiBAcGFyYW0geyFUcmFuc2Zvcm19IHRyYW5zZm9ybTIgVHJhbnNmb3JtIHBhcmFtZXRlcnMgb2YgbWF0cml4IDIuXG4gKiBAcmV0dXJuIHshVHJhbnNmb3JtfSB0cmFuc2Zvcm0xIG11bHRpcGxpZWQgd2l0aCB0cmFuc2Zvcm0yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkodHJhbnNmb3JtMSwgdHJhbnNmb3JtMikge1xuICB2YXIgYTEgPSB0cmFuc2Zvcm0xWzBdO1xuICB2YXIgYjEgPSB0cmFuc2Zvcm0xWzFdO1xuICB2YXIgYzEgPSB0cmFuc2Zvcm0xWzJdO1xuICB2YXIgZDEgPSB0cmFuc2Zvcm0xWzNdO1xuICB2YXIgZTEgPSB0cmFuc2Zvcm0xWzRdO1xuICB2YXIgZjEgPSB0cmFuc2Zvcm0xWzVdO1xuICB2YXIgYTIgPSB0cmFuc2Zvcm0yWzBdO1xuICB2YXIgYjIgPSB0cmFuc2Zvcm0yWzFdO1xuICB2YXIgYzIgPSB0cmFuc2Zvcm0yWzJdO1xuICB2YXIgZDIgPSB0cmFuc2Zvcm0yWzNdO1xuICB2YXIgZTIgPSB0cmFuc2Zvcm0yWzRdO1xuICB2YXIgZjIgPSB0cmFuc2Zvcm0yWzVdO1xuXG4gIHRyYW5zZm9ybTFbMF0gPSBhMSAqIGEyICsgYzEgKiBiMjtcbiAgdHJhbnNmb3JtMVsxXSA9IGIxICogYTIgKyBkMSAqIGIyO1xuICB0cmFuc2Zvcm0xWzJdID0gYTEgKiBjMiArIGMxICogZDI7XG4gIHRyYW5zZm9ybTFbM10gPSBiMSAqIGMyICsgZDEgKiBkMjtcbiAgdHJhbnNmb3JtMVs0XSA9IGExICogZTIgKyBjMSAqIGYyICsgZTE7XG4gIHRyYW5zZm9ybTFbNV0gPSBiMSAqIGUyICsgZDEgKiBmMiArIGYxO1xuXG4gIHJldHVybiB0cmFuc2Zvcm0xO1xufVxuXG4vKipcbiAqIFNldCB0aGUgdHJhbnNmb3JtIGNvbXBvbmVudHMgYS1mIG9uIGEgZ2l2ZW4gdHJhbnNmb3JtLlxuICogQHBhcmFtIHshVHJhbnNmb3JtfSB0cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIGEgY29tcG9uZW50IG9mIHRoZSB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0ge251bWJlcn0gYiBUaGUgYiBjb21wb25lbnQgb2YgdGhlIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjIFRoZSBjIGNvbXBvbmVudCBvZiB0aGUgdHJhbnNmb3JtLlxuICogQHBhcmFtIHtudW1iZXJ9IGQgVGhlIGQgY29tcG9uZW50IG9mIHRoZSB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0ge251bWJlcn0gZSBUaGUgZSBjb21wb25lbnQgb2YgdGhlIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmIFRoZSBmIGNvbXBvbmVudCBvZiB0aGUgdHJhbnNmb3JtLlxuICogQHJldHVybiB7IVRyYW5zZm9ybX0gTWF0cml4IHdpdGggdHJhbnNmb3JtIGFwcGxpZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXQodHJhbnNmb3JtLCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHRyYW5zZm9ybVswXSA9IGE7XG4gIHRyYW5zZm9ybVsxXSA9IGI7XG4gIHRyYW5zZm9ybVsyXSA9IGM7XG4gIHRyYW5zZm9ybVszXSA9IGQ7XG4gIHRyYW5zZm9ybVs0XSA9IGU7XG4gIHRyYW5zZm9ybVs1XSA9IGY7XG4gIHJldHVybiB0cmFuc2Zvcm07XG59XG5cblxuLyoqXG4gKiBTZXQgdHJhbnNmb3JtIG9uIG9uZSBtYXRyaXggZnJvbSBhbm90aGVyIG1hdHJpeC5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gdHJhbnNmb3JtMSBNYXRyaXggdG8gc2V0IHRyYW5zZm9ybSB0by5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gdHJhbnNmb3JtMiBNYXRyaXggdG8gc2V0IHRyYW5zZm9ybSBmcm9tLlxuICogQHJldHVybiB7IVRyYW5zZm9ybX0gdHJhbnNmb3JtMSB3aXRoIHRyYW5zZm9ybSBmcm9tIHRyYW5zZm9ybTIgYXBwbGllZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldEZyb21BcnJheSh0cmFuc2Zvcm0xLCB0cmFuc2Zvcm0yKSB7XG4gIHRyYW5zZm9ybTFbMF0gPSB0cmFuc2Zvcm0yWzBdO1xuICB0cmFuc2Zvcm0xWzFdID0gdHJhbnNmb3JtMlsxXTtcbiAgdHJhbnNmb3JtMVsyXSA9IHRyYW5zZm9ybTJbMl07XG4gIHRyYW5zZm9ybTFbM10gPSB0cmFuc2Zvcm0yWzNdO1xuICB0cmFuc2Zvcm0xWzRdID0gdHJhbnNmb3JtMls0XTtcbiAgdHJhbnNmb3JtMVs1XSA9IHRyYW5zZm9ybTJbNV07XG4gIHJldHVybiB0cmFuc2Zvcm0xO1xufVxuXG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgZ2l2ZW4gY29vcmRpbmF0ZSB3aXRoIHRoZSBnaXZlbiB0cmFuc2Zvcm0gcmV0dXJuaW5nIHRoZVxuICogcmVzdWx0aW5nLCB0cmFuc2Zvcm1lZCBjb29yZGluYXRlLiBUaGUgY29vcmRpbmF0ZSB3aWxsIGJlIG1vZGlmaWVkIGluLXBsYWNlLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSB0cmFuc2Zvcm0gVGhlIHRyYW5zZm9ybWF0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZXxpbXBvcnQoXCIuL3BpeGVsLmpzXCIpLlBpeGVsfSBjb29yZGluYXRlIFRoZSBjb29yZGluYXRlIHRvIHRyYW5zZm9ybS5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfGltcG9ydChcIi4vcGl4ZWwuanNcIikuUGl4ZWx9IHJldHVybiBjb29yZGluYXRlIHNvIHRoYXQgb3BlcmF0aW9ucyBjYW4gYmVcbiAqICAgICBjaGFpbmVkIHRvZ2V0aGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHkodHJhbnNmb3JtLCBjb29yZGluYXRlKSB7XG4gIHZhciB4ID0gY29vcmRpbmF0ZVswXTtcbiAgdmFyIHkgPSBjb29yZGluYXRlWzFdO1xuICBjb29yZGluYXRlWzBdID0gdHJhbnNmb3JtWzBdICogeCArIHRyYW5zZm9ybVsyXSAqIHkgKyB0cmFuc2Zvcm1bNF07XG4gIGNvb3JkaW5hdGVbMV0gPSB0cmFuc2Zvcm1bMV0gKiB4ICsgdHJhbnNmb3JtWzNdICogeSArIHRyYW5zZm9ybVs1XTtcbiAgcmV0dXJuIGNvb3JkaW5hdGU7XG59XG5cblxuLyoqXG4gKiBBcHBsaWVzIHJvdGF0aW9uIHRvIHRoZSBnaXZlbiB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0geyFUcmFuc2Zvcm19IHRyYW5zZm9ybSBUcmFuc2Zvcm0uXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGUgQW5nbGUgaW4gcmFkaWFucy5cbiAqIEByZXR1cm4geyFUcmFuc2Zvcm19IFRoZSByb3RhdGVkIHRyYW5zZm9ybS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZSh0cmFuc2Zvcm0sIGFuZ2xlKSB7XG4gIHZhciBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG4gIHZhciBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG4gIHJldHVybiBtdWx0aXBseSh0cmFuc2Zvcm0sIHNldCh0bXBfLCBjb3MsIHNpbiwgLXNpbiwgY29zLCAwLCAwKSk7XG59XG5cblxuLyoqXG4gKiBBcHBsaWVzIHNjYWxlIHRvIGEgZ2l2ZW4gdHJhbnNmb3JtLlxuICogQHBhcmFtIHshVHJhbnNmb3JtfSB0cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICogQHBhcmFtIHtudW1iZXJ9IHggU2NhbGUgZmFjdG9yIHguXG4gKiBAcGFyYW0ge251bWJlcn0geSBTY2FsZSBmYWN0b3IgeS5cbiAqIEByZXR1cm4geyFUcmFuc2Zvcm19IFRoZSBzY2FsZWQgdHJhbnNmb3JtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUodHJhbnNmb3JtLCB4LCB5KSB7XG4gIHJldHVybiBtdWx0aXBseSh0cmFuc2Zvcm0sIHNldCh0bXBfLCB4LCAwLCAwLCB5LCAwLCAwKSk7XG59XG5cblxuLyoqXG4gKiBBcHBsaWVzIHRyYW5zbGF0aW9uIHRvIHRoZSBnaXZlbiB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0geyFUcmFuc2Zvcm19IHRyYW5zZm9ybSBUcmFuc2Zvcm0uXG4gKiBAcGFyYW0ge251bWJlcn0gZHggVHJhbnNsYXRpb24geC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkeSBUcmFuc2xhdGlvbiB5LlxuICogQHJldHVybiB7IVRyYW5zZm9ybX0gVGhlIHRyYW5zbGF0ZWQgdHJhbnNmb3JtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNsYXRlKHRyYW5zZm9ybSwgZHgsIGR5KSB7XG4gIHJldHVybiBtdWx0aXBseSh0cmFuc2Zvcm0sIHNldCh0bXBfLCAxLCAwLCAwLCAxLCBkeCwgZHkpKTtcbn1cblxuXG4vKipcbiAqIENyZWF0ZXMgYSBjb21wb3NpdGUgdHJhbnNmb3JtIGdpdmVuIGFuIGluaXRpYWwgdHJhbnNsYXRpb24sIHNjYWxlLCByb3RhdGlvbiwgYW5kXG4gKiBmaW5hbCB0cmFuc2xhdGlvbiAoaW4gdGhhdCBvcmRlciBvbmx5LCBub3QgY29tbXV0YXRpdmUpLlxuICogQHBhcmFtIHshVHJhbnNmb3JtfSB0cmFuc2Zvcm0gVGhlIHRyYW5zZm9ybSAod2lsbCBiZSBtb2RpZmllZCBpbiBwbGFjZSkuXG4gKiBAcGFyYW0ge251bWJlcn0gZHgxIEluaXRpYWwgdHJhbnNsYXRpb24geC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkeTEgSW5pdGlhbCB0cmFuc2xhdGlvbiB5LlxuICogQHBhcmFtIHtudW1iZXJ9IHN4IFNjYWxlIGZhY3RvciB4LlxuICogQHBhcmFtIHtudW1iZXJ9IHN5IFNjYWxlIGZhY3RvciB5LlxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlIFJvdGF0aW9uIChpbiBjb3VudGVyLWNsb2Nrd2lzZSByYWRpYW5zKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkeDIgRmluYWwgdHJhbnNsYXRpb24geC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkeTIgRmluYWwgdHJhbnNsYXRpb24geS5cbiAqIEByZXR1cm4geyFUcmFuc2Zvcm19IFRoZSBjb21wb3NpdGUgdHJhbnNmb3JtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcG9zZSh0cmFuc2Zvcm0sIGR4MSwgZHkxLCBzeCwgc3ksIGFuZ2xlLCBkeDIsIGR5Mikge1xuICB2YXIgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuICB2YXIgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xuICB0cmFuc2Zvcm1bMF0gPSBzeCAqIGNvcztcbiAgdHJhbnNmb3JtWzFdID0gc3kgKiBzaW47XG4gIHRyYW5zZm9ybVsyXSA9IC1zeCAqIHNpbjtcbiAgdHJhbnNmb3JtWzNdID0gc3kgKiBjb3M7XG4gIHRyYW5zZm9ybVs0XSA9IGR4MiAqIHN4ICogY29zIC0gZHkyICogc3ggKiBzaW4gKyBkeDE7XG4gIHRyYW5zZm9ybVs1XSA9IGR4MiAqIHN5ICogc2luICsgZHkyICogc3kgKiBjb3MgKyBkeTE7XG4gIHJldHVybiB0cmFuc2Zvcm07XG59XG5cblxuLyoqXG4gKiBJbnZlcnQgdGhlIGdpdmVuIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAqIEByZXR1cm4geyFUcmFuc2Zvcm19IEludmVyc2Ugb2YgdGhlIHRyYW5zZm9ybS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmVydCh0cmFuc2Zvcm0pIHtcbiAgdmFyIGRldCA9IGRldGVybWluYW50KHRyYW5zZm9ybSk7XG4gIGFzc2VydChkZXQgIT09IDAsIDMyKTsgLy8gVHJhbnNmb3JtYXRpb24gbWF0cml4IGNhbm5vdCBiZSBpbnZlcnRlZFxuXG4gIHZhciBhID0gdHJhbnNmb3JtWzBdO1xuICB2YXIgYiA9IHRyYW5zZm9ybVsxXTtcbiAgdmFyIGMgPSB0cmFuc2Zvcm1bMl07XG4gIHZhciBkID0gdHJhbnNmb3JtWzNdO1xuICB2YXIgZSA9IHRyYW5zZm9ybVs0XTtcbiAgdmFyIGYgPSB0cmFuc2Zvcm1bNV07XG5cbiAgdHJhbnNmb3JtWzBdID0gZCAvIGRldDtcbiAgdHJhbnNmb3JtWzFdID0gLWIgLyBkZXQ7XG4gIHRyYW5zZm9ybVsyXSA9IC1jIC8gZGV0O1xuICB0cmFuc2Zvcm1bM10gPSBhIC8gZGV0O1xuICB0cmFuc2Zvcm1bNF0gPSAoYyAqIGYgLSBkICogZSkgLyBkZXQ7XG4gIHRyYW5zZm9ybVs1XSA9IC0oYSAqIGYgLSBiICogZSkgLyBkZXQ7XG5cbiAgcmV0dXJuIHRyYW5zZm9ybTtcbn1cblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGRldGVybWluYW50IG9mIHRoZSBnaXZlbiBtYXRyaXguXG4gKiBAcGFyYW0geyFUcmFuc2Zvcm19IG1hdCBNYXRyaXguXG4gKiBAcmV0dXJuIHtudW1iZXJ9IERldGVybWluYW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGV0ZXJtaW5hbnQobWF0KSB7XG4gIHJldHVybiBtYXRbMF0gKiBtYXRbM10gLSBtYXRbMV0gKiBtYXRbMl07XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zZm9ybS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvdXRpbFxuICovXG5cbi8qKlxuICogQHJldHVybiB7P30gQW55IHJldHVybi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFic3RyYWN0KCkge1xuICByZXR1cm4gLyoqIEB0eXBlIHs/fSAqLyAoKGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5pbXBsZW1lbnRlZCBhYnN0cmFjdCBtZXRob2QuJyk7XG4gIH0pKCkpO1xufVxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBVc2FnZTpcbiAqXG4gKiAgICAgZnVuY3Rpb24gUGFyZW50Q2xhc3MoYSwgYikgeyB9XG4gKiAgICAgUGFyZW50Q2xhc3MucHJvdG90eXBlLmZvbyA9IGZ1bmN0aW9uKGEpIHsgfVxuICpcbiAqICAgICBmdW5jdGlvbiBDaGlsZENsYXNzKGEsIGIsIGMpIHtcbiAqICAgICAgIC8vIENhbGwgcGFyZW50IGNvbnN0cnVjdG9yXG4gKiAgICAgICBQYXJlbnRDbGFzcy5jYWxsKHRoaXMsIGEsIGIpO1xuICogICAgIH1cbiAqICAgICBpbmhlcml0cyhDaGlsZENsYXNzLCBQYXJlbnRDbGFzcyk7XG4gKlxuICogICAgIHZhciBjaGlsZCA9IG5ldyBDaGlsZENsYXNzKCdhJywgJ2InLCAnc2VlJyk7XG4gKiAgICAgY2hpbGQuZm9vKCk7IC8vIFRoaXMgd29ya3MuXG4gKlxuICogQHBhcmFtIHshRnVuY3Rpb259IGNoaWxkQ3RvciBDaGlsZCBjb25zdHJ1Y3Rvci5cbiAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBwYXJlbnRDdG9yIFBhcmVudCBjb25zdHJ1Y3Rvci5cbiAqIEBmdW5jdGlvbiBtb2R1bGU6b2wuaW5oZXJpdHNcbiAqIEBkZXByZWNhdGVkXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmhlcml0cyhjaGlsZEN0b3IsIHBhcmVudEN0b3IpIHtcbiAgY2hpbGRDdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocGFyZW50Q3Rvci5wcm90b3R5cGUpO1xuICBjaGlsZEN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY2hpbGRDdG9yO1xufVxuXG4vKipcbiAqIENvdW50ZXIgZm9yIGdldFVpZC5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgdWlkQ291bnRlcl8gPSAwO1xuXG4vKipcbiAqIEdldHMgYSB1bmlxdWUgSUQgZm9yIGFuIG9iamVjdC4gVGhpcyBtdXRhdGVzIHRoZSBvYmplY3Qgc28gdGhhdCBmdXJ0aGVyIGNhbGxzXG4gKiB3aXRoIHRoZSBzYW1lIG9iamVjdCBhcyBhIHBhcmFtZXRlciByZXR1cm5zIHRoZSBzYW1lIHZhbHVlLiBVbmlxdWUgSURzIGFyZSBnZW5lcmF0ZWRcbiAqIGFzIGEgc3RyaWN0bHkgaW5jcmVhc2luZyBzZXF1ZW5jZS4gQWRhcHRlZCBmcm9tIGdvb2cuZ2V0VWlkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBnZXQgdGhlIHVuaXF1ZSBJRCBmb3IuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB1bmlxdWUgSUQgZm9yIHRoZSBvYmplY3QuXG4gKiBAZnVuY3Rpb24gbW9kdWxlOm9sLmdldFVpZFxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VWlkKG9iaikge1xuICByZXR1cm4gb2JqLm9sX3VpZCB8fCAob2JqLm9sX3VpZCA9IFN0cmluZygrK3VpZENvdW50ZXJfKSk7XG59XG5cbi8qKlxuICogT3BlbkxheWVycyB2ZXJzaW9uLlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IHZhciBWRVJTSU9OID0gJzUuMy4zJztcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvd2ViZ2xcbiAqL1xuXG5cbi8qKlxuICogQ29uc3RhbnRzIHRha2VuIGZyb20gZ29vZy53ZWJnbFxuICovXG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgT05FID0gMTtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBTUkNfQUxQSEEgPSAweDAzMDI7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgQ09MT1JfQVRUQUNITUVOVDAgPSAweDhDRTA7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgQ09MT1JfQlVGRkVSX0JJVCA9IDB4MDAwMDQwMDA7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgVFJJQU5HTEVTID0gMHgwMDA0O1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIFRSSUFOR0xFX1NUUklQID0gMHgwMDA1O1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIE9ORV9NSU5VU19TUkNfQUxQSEEgPSAweDAzMDM7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgQVJSQVlfQlVGRkVSID0gMHg4ODkyO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIEVMRU1FTlRfQVJSQVlfQlVGRkVSID0gMHg4ODkzO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIFNUUkVBTV9EUkFXID0gMHg4OEUwO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIFNUQVRJQ19EUkFXID0gMHg4OEU0O1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIERZTkFNSUNfRFJBVyA9IDB4ODhFODtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBDVUxMX0ZBQ0UgPSAweDBCNDQ7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgQkxFTkQgPSAweDBCRTI7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgU1RFTkNJTF9URVNUID0gMHgwQjkwO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIERFUFRIX1RFU1QgPSAweDBCNzE7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgU0NJU1NPUl9URVNUID0gMHgwQzExO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIFVOU0lHTkVEX0JZVEUgPSAweDE0MDE7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgVU5TSUdORURfU0hPUlQgPSAweDE0MDM7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgVU5TSUdORURfSU5UID0gMHgxNDA1O1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIEZMT0FUID0gMHgxNDA2O1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIFJHQkEgPSAweDE5MDg7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgRlJBR01FTlRfU0hBREVSID0gMHg4QjMwO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIFZFUlRFWF9TSEFERVIgPSAweDhCMzE7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgTElOS19TVEFUVVMgPSAweDhCODI7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgTElORUFSID0gMHgyNjAxO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIFRFWFRVUkVfTUFHX0ZJTFRFUiA9IDB4MjgwMDtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBURVhUVVJFX01JTl9GSUxURVIgPSAweDI4MDE7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgVEVYVFVSRV9XUkFQX1MgPSAweDI4MDI7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgVEVYVFVSRV9XUkFQX1QgPSAweDI4MDM7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgVEVYVFVSRV8yRCA9IDB4MERFMTtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBURVhUVVJFMCA9IDB4ODRDMDtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBDTEFNUF9UT19FREdFID0gMHg4MTJGO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIENPTVBJTEVfU1RBVFVTID0gMHg4QjgxO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIEZSQU1FQlVGRkVSID0gMHg4RDQwO1xuXG5cbi8qKiBlbmQgb2YgZ29vZy53ZWJnbCBjb25zdGFudHNcbiAqL1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn1cbiAqL1xudmFyIENPTlRFWFRfSURTID0gW1xuICAnZXhwZXJpbWVudGFsLXdlYmdsJyxcbiAgJ3dlYmdsJyxcbiAgJ3dlYmtpdC0zZCcsXG4gICdtb3otd2ViZ2wnXG5dO1xuXG5cbi8qKlxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIENhbnZhcy5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X2F0dHJpYnV0ZXMgQXR0cmlidXRlcy5cbiAqIEByZXR1cm4ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gV2ViR0wgcmVuZGVyaW5nIGNvbnRleHQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb250ZXh0KGNhbnZhcywgb3B0X2F0dHJpYnV0ZXMpIHtcbiAgdmFyIGlpID0gQ09OVEVYVF9JRFMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGlpOyArK2kpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChDT05URVhUX0lEU1tpXSwgb3B0X2F0dHJpYnV0ZXMpO1xuICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7IVdlYkdMUmVuZGVyaW5nQ29udGV4dH0gKi8gKGNvbnRleHQpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIHBhc3NcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cblxuLyoqXG4gKiBJbmNsdWRlIGRlYnVnZ2FibGUgc2hhZGVyIHNvdXJjZXMuICBEZWZhdWx0IGlzIGB0cnVlYC4gVGhpcyBzaG91bGQgYmUgc2V0IHRvXG4gKiBgZmFsc2VgIGZvciBwcm9kdWN0aW9uIGJ1aWxkcy5cbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5leHBvcnQgdmFyIERFQlVHID0gdHJ1ZTtcblxuXG4vKipcbiAqIFRoZSBtYXhpbXVtIHN1cHBvcnRlZCBXZWJHTCB0ZXh0dXJlIHNpemUgaW4gcGl4ZWxzLiBJZiBXZWJHTCBpcyBub3RcbiAqIHN1cHBvcnRlZCwgdGhlIHZhbHVlIGlzIHNldCB0byBgdW5kZWZpbmVkYC5cbiAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICovXG52YXIgTUFYX1RFWFRVUkVfU0laRTsgLy8gdmFsdWUgaXMgc2V0IGJlbG93XG5cblxuLyoqXG4gKiBMaXN0IG9mIHN1cHBvcnRlZCBXZWJHTCBleHRlbnNpb25zLlxuICogQHR5cGUge0FycmF5PHN0cmluZz59XG4gKi9cbnZhciBFWFRFTlNJT05TOyAvLyB2YWx1ZSBpcyBzZXQgYmVsb3dcblxuXG4vKipcbiAqIFRydWUgaWYgYm90aCBPcGVuTGF5ZXJzIGFuZCBicm93c2VyIHN1cHBvcnQgV2ViR0wuXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBhcGlcbiAqL1xudmFyIEhBUyA9IGZhbHNlO1xuXG4vL1RPRE8gUmVtb3ZlIHNpZGUgZWZmZWN0c1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICdXZWJHTFJlbmRlcmluZ0NvbnRleHQnIGluIHdpbmRvdykge1xuICB0cnkge1xuICAgIHZhciBjYW52YXMgPSAvKiogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fSAqLyAoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykpO1xuICAgIHZhciBnbCA9IGdldENvbnRleHQoY2FudmFzLCB7ZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdDogdHJ1ZX0pO1xuICAgIGlmIChnbCkge1xuICAgICAgSEFTID0gdHJ1ZTtcbiAgICAgIE1BWF9URVhUVVJFX1NJWkUgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVEVYVFVSRV9TSVpFKSk7XG4gICAgICBFWFRFTlNJT05TID0gZ2wuZ2V0U3VwcG9ydGVkRXh0ZW5zaW9ucygpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIHBhc3NcbiAgfVxufVxuXG5leHBvcnQge0hBUywgTUFYX1RFWFRVUkVfU0laRSwgRVhURU5TSU9OU307XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlYmdsLmpzLm1hcCIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcblx0KGdsb2JhbC5xdWlja3NlbGVjdCA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gcXVpY2tzZWxlY3QoYXJyLCBrLCBsZWZ0LCByaWdodCwgY29tcGFyZSkge1xuICAgIHF1aWNrc2VsZWN0U3RlcChhcnIsIGssIGxlZnQgfHwgMCwgcmlnaHQgfHwgKGFyci5sZW5ndGggLSAxKSwgY29tcGFyZSB8fCBkZWZhdWx0Q29tcGFyZSk7XG59XG5cbmZ1bmN0aW9uIHF1aWNrc2VsZWN0U3RlcChhcnIsIGssIGxlZnQsIHJpZ2h0LCBjb21wYXJlKSB7XG5cbiAgICB3aGlsZSAocmlnaHQgPiBsZWZ0KSB7XG4gICAgICAgIGlmIChyaWdodCAtIGxlZnQgPiA2MDApIHtcbiAgICAgICAgICAgIHZhciBuID0gcmlnaHQgLSBsZWZ0ICsgMTtcbiAgICAgICAgICAgIHZhciBtID0gayAtIGxlZnQgKyAxO1xuICAgICAgICAgICAgdmFyIHogPSBNYXRoLmxvZyhuKTtcbiAgICAgICAgICAgIHZhciBzID0gMC41ICogTWF0aC5leHAoMiAqIHogLyAzKTtcbiAgICAgICAgICAgIHZhciBzZCA9IDAuNSAqIE1hdGguc3FydCh6ICogcyAqIChuIC0gcykgLyBuKSAqIChtIC0gbiAvIDIgPCAwID8gLTEgOiAxKTtcbiAgICAgICAgICAgIHZhciBuZXdMZWZ0ID0gTWF0aC5tYXgobGVmdCwgTWF0aC5mbG9vcihrIC0gbSAqIHMgLyBuICsgc2QpKTtcbiAgICAgICAgICAgIHZhciBuZXdSaWdodCA9IE1hdGgubWluKHJpZ2h0LCBNYXRoLmZsb29yKGsgKyAobiAtIG0pICogcyAvIG4gKyBzZCkpO1xuICAgICAgICAgICAgcXVpY2tzZWxlY3RTdGVwKGFyciwgaywgbmV3TGVmdCwgbmV3UmlnaHQsIGNvbXBhcmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHQgPSBhcnJba107XG4gICAgICAgIHZhciBpID0gbGVmdDtcbiAgICAgICAgdmFyIGogPSByaWdodDtcblxuICAgICAgICBzd2FwKGFyciwgbGVmdCwgayk7XG4gICAgICAgIGlmIChjb21wYXJlKGFycltyaWdodF0sIHQpID4gMCkgc3dhcChhcnIsIGxlZnQsIHJpZ2h0KTtcblxuICAgICAgICB3aGlsZSAoaSA8IGopIHtcbiAgICAgICAgICAgIHN3YXAoYXJyLCBpLCBqKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKGFycltpXSwgdCkgPCAwKSBpKys7XG4gICAgICAgICAgICB3aGlsZSAoY29tcGFyZShhcnJbal0sIHQpID4gMCkgai0tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbXBhcmUoYXJyW2xlZnRdLCB0KSA9PT0gMCkgc3dhcChhcnIsIGxlZnQsIGopO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgIHN3YXAoYXJyLCBqLCByaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaiA8PSBrKSBsZWZ0ID0gaiArIDE7XG4gICAgICAgIGlmIChrIDw9IGopIHJpZ2h0ID0gaiAtIDE7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzd2FwKGFyciwgaSwgaikge1xuICAgIHZhciB0bXAgPSBhcnJbaV07XG4gICAgYXJyW2ldID0gYXJyW2pdO1xuICAgIGFycltqXSA9IHRtcDtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdENvbXBhcmUoYSwgYikge1xuICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMDtcbn1cblxucmV0dXJuIHF1aWNrc2VsZWN0O1xuXG59KSkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJidXNoO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IHJidXNoO1xuXG52YXIgcXVpY2tzZWxlY3QgPSByZXF1aXJlKCdxdWlja3NlbGVjdCcpO1xuXG5mdW5jdGlvbiByYnVzaChtYXhFbnRyaWVzLCBmb3JtYXQpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgcmJ1c2gpKSByZXR1cm4gbmV3IHJidXNoKG1heEVudHJpZXMsIGZvcm1hdCk7XG5cbiAgICAvLyBtYXggZW50cmllcyBpbiBhIG5vZGUgaXMgOSBieSBkZWZhdWx0OyBtaW4gbm9kZSBmaWxsIGlzIDQwJSBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoaXMuX21heEVudHJpZXMgPSBNYXRoLm1heCg0LCBtYXhFbnRyaWVzIHx8IDkpO1xuICAgIHRoaXMuX21pbkVudHJpZXMgPSBNYXRoLm1heCgyLCBNYXRoLmNlaWwodGhpcy5fbWF4RW50cmllcyAqIDAuNCkpO1xuXG4gICAgaWYgKGZvcm1hdCkge1xuICAgICAgICB0aGlzLl9pbml0Rm9ybWF0KGZvcm1hdCk7XG4gICAgfVxuXG4gICAgdGhpcy5jbGVhcigpO1xufVxuXG5yYnVzaC5wcm90b3R5cGUgPSB7XG5cbiAgICBhbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FsbCh0aGlzLmRhdGEsIFtdKTtcbiAgICB9LFxuXG4gICAgc2VhcmNoOiBmdW5jdGlvbiAoYmJveCkge1xuXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5kYXRhLFxuICAgICAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgICAgICB0b0JCb3ggPSB0aGlzLnRvQkJveDtcblxuICAgICAgICBpZiAoIWludGVyc2VjdHMoYmJveCwgbm9kZSkpIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgdmFyIG5vZGVzVG9TZWFyY2ggPSBbXSxcbiAgICAgICAgICAgIGksIGxlbiwgY2hpbGQsIGNoaWxkQkJveDtcblxuICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXG4gICAgICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGNoaWxkQkJveCA9IG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZDtcblxuICAgICAgICAgICAgICAgIGlmIChpbnRlcnNlY3RzKGJib3gsIGNoaWxkQkJveCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubGVhZikgcmVzdWx0LnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb250YWlucyhiYm94LCBjaGlsZEJCb3gpKSB0aGlzLl9hbGwoY2hpbGQsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2Ugbm9kZXNUb1NlYXJjaC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbm9kZXNUb1NlYXJjaC5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGNvbGxpZGVzOiBmdW5jdGlvbiAoYmJveCkge1xuXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5kYXRhLFxuICAgICAgICAgICAgdG9CQm94ID0gdGhpcy50b0JCb3g7XG5cbiAgICAgICAgaWYgKCFpbnRlcnNlY3RzKGJib3gsIG5vZGUpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgdmFyIG5vZGVzVG9TZWFyY2ggPSBbXSxcbiAgICAgICAgICAgIGksIGxlbiwgY2hpbGQsIGNoaWxkQkJveDtcblxuICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXG4gICAgICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGNoaWxkQkJveCA9IG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZDtcblxuICAgICAgICAgICAgICAgIGlmIChpbnRlcnNlY3RzKGJib3gsIGNoaWxkQkJveCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubGVhZiB8fCBjb250YWlucyhiYm94LCBjaGlsZEJCb3gpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNUb1NlYXJjaC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbm9kZXNUb1NlYXJjaC5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgbG9hZDogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKCEoZGF0YSAmJiBkYXRhLmxlbmd0aCkpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8IHRoaXMuX21pbkVudHJpZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnQoZGF0YVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGJ1aWxkIHRoZSB0cmVlIHdpdGggdGhlIGdpdmVuIGRhdGEgZnJvbSBzY3JhdGNoIHVzaW5nIE9NVCBhbGdvcml0aG1cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9idWlsZChkYXRhLnNsaWNlKCksIDAsIGRhdGEubGVuZ3RoIC0gMSwgMCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmRhdGEuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBzYXZlIGFzIGlzIGlmIHRyZWUgaXMgZW1wdHlcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5vZGU7XG5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRhdGEuaGVpZ2h0ID09PSBub2RlLmhlaWdodCkge1xuICAgICAgICAgICAgLy8gc3BsaXQgcm9vdCBpZiB0cmVlcyBoYXZlIHRoZSBzYW1lIGhlaWdodFxuICAgICAgICAgICAgdGhpcy5fc3BsaXRSb290KHRoaXMuZGF0YSwgbm9kZSk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEuaGVpZ2h0IDwgbm9kZS5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAvLyBzd2FwIHRyZWVzIGlmIGluc2VydGVkIG9uZSBpcyBiaWdnZXJcbiAgICAgICAgICAgICAgICB2YXIgdG1wTm9kZSA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBub2RlO1xuICAgICAgICAgICAgICAgIG5vZGUgPSB0bXBOb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpbnNlcnQgdGhlIHNtYWxsIHRyZWUgaW50byB0aGUgbGFyZ2UgdHJlZSBhdCBhcHByb3ByaWF0ZSBsZXZlbFxuICAgICAgICAgICAgdGhpcy5faW5zZXJ0KG5vZGUsIHRoaXMuZGF0YS5oZWlnaHQgLSBub2RlLmhlaWdodCAtIDEsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGluc2VydDogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0pIHRoaXMuX2luc2VydChpdGVtLCB0aGlzLmRhdGEuaGVpZ2h0IC0gMSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBjcmVhdGVOb2RlKFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJlbW92ZTogZnVuY3Rpb24gKGl0ZW0sIGVxdWFsc0ZuKSB7XG4gICAgICAgIGlmICghaXRlbSkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmRhdGEsXG4gICAgICAgICAgICBiYm94ID0gdGhpcy50b0JCb3goaXRlbSksXG4gICAgICAgICAgICBwYXRoID0gW10sXG4gICAgICAgICAgICBpbmRleGVzID0gW10sXG4gICAgICAgICAgICBpLCBwYXJlbnQsIGluZGV4LCBnb2luZ1VwO1xuXG4gICAgICAgIC8vIGRlcHRoLWZpcnN0IGl0ZXJhdGl2ZSB0cmVlIHRyYXZlcnNhbFxuICAgICAgICB3aGlsZSAobm9kZSB8fCBwYXRoLmxlbmd0aCkge1xuXG4gICAgICAgICAgICBpZiAoIW5vZGUpIHsgLy8gZ28gdXBcbiAgICAgICAgICAgICAgICBub2RlID0gcGF0aC5wb3AoKTtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaSA9IGluZGV4ZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgZ29pbmdVcCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChub2RlLmxlYWYpIHsgLy8gY2hlY2sgY3VycmVudCBub2RlXG4gICAgICAgICAgICAgICAgaW5kZXggPSBmaW5kSXRlbShpdGVtLCBub2RlLmNoaWxkcmVuLCBlcXVhbHNGbik7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGl0ZW0gZm91bmQsIHJlbW92ZSB0aGUgaXRlbSBhbmQgY29uZGVuc2UgdHJlZSB1cHdhcmRzXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25kZW5zZShwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWdvaW5nVXAgJiYgIW5vZGUubGVhZiAmJiBjb250YWlucyhub2RlLCBiYm94KSkgeyAvLyBnbyBkb3duXG4gICAgICAgICAgICAgICAgcGF0aC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIGluZGV4ZXMucHVzaChpKTtcbiAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBub2RlO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuWzBdO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmVudCkgeyAvLyBnbyByaWdodFxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50LmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGdvaW5nVXAgPSBmYWxzZTtcblxuICAgICAgICAgICAgfSBlbHNlIG5vZGUgPSBudWxsOyAvLyBub3RoaW5nIGZvdW5kXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgdG9CQm94OiBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbTsgfSxcblxuICAgIGNvbXBhcmVNaW5YOiBjb21wYXJlTm9kZU1pblgsXG4gICAgY29tcGFyZU1pblk6IGNvbXBhcmVOb2RlTWluWSxcblxuICAgIHRvSlNPTjogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5kYXRhOyB9LFxuXG4gICAgZnJvbUpTT046IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfYWxsOiBmdW5jdGlvbiAobm9kZSwgcmVzdWx0KSB7XG4gICAgICAgIHZhciBub2Rlc1RvU2VhcmNoID0gW107XG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5sZWFmKSByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIG5vZGUuY2hpbGRyZW4pO1xuICAgICAgICAgICAgZWxzZSBub2Rlc1RvU2VhcmNoLnB1c2guYXBwbHkobm9kZXNUb1NlYXJjaCwgbm9kZS5jaGlsZHJlbik7XG5cbiAgICAgICAgICAgIG5vZGUgPSBub2Rlc1RvU2VhcmNoLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIF9idWlsZDogZnVuY3Rpb24gKGl0ZW1zLCBsZWZ0LCByaWdodCwgaGVpZ2h0KSB7XG5cbiAgICAgICAgdmFyIE4gPSByaWdodCAtIGxlZnQgKyAxLFxuICAgICAgICAgICAgTSA9IHRoaXMuX21heEVudHJpZXMsXG4gICAgICAgICAgICBub2RlO1xuXG4gICAgICAgIGlmIChOIDw9IE0pIHtcbiAgICAgICAgICAgIC8vIHJlYWNoZWQgbGVhZiBsZXZlbDsgcmV0dXJuIGxlYWZcbiAgICAgICAgICAgIG5vZGUgPSBjcmVhdGVOb2RlKGl0ZW1zLnNsaWNlKGxlZnQsIHJpZ2h0ICsgMSkpO1xuICAgICAgICAgICAgY2FsY0JCb3gobm9kZSwgdGhpcy50b0JCb3gpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWhlaWdodCkge1xuICAgICAgICAgICAgLy8gdGFyZ2V0IGhlaWdodCBvZiB0aGUgYnVsay1sb2FkZWQgdHJlZVxuICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5jZWlsKE1hdGgubG9nKE4pIC8gTWF0aC5sb2coTSkpO1xuXG4gICAgICAgICAgICAvLyB0YXJnZXQgbnVtYmVyIG9mIHJvb3QgZW50cmllcyB0byBtYXhpbWl6ZSBzdG9yYWdlIHV0aWxpemF0aW9uXG4gICAgICAgICAgICBNID0gTWF0aC5jZWlsKE4gLyBNYXRoLnBvdyhNLCBoZWlnaHQgLSAxKSk7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gY3JlYXRlTm9kZShbXSk7XG4gICAgICAgIG5vZGUubGVhZiA9IGZhbHNlO1xuICAgICAgICBub2RlLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAvLyBzcGxpdCB0aGUgaXRlbXMgaW50byBNIG1vc3RseSBzcXVhcmUgdGlsZXNcblxuICAgICAgICB2YXIgTjIgPSBNYXRoLmNlaWwoTiAvIE0pLFxuICAgICAgICAgICAgTjEgPSBOMiAqIE1hdGguY2VpbChNYXRoLnNxcnQoTSkpLFxuICAgICAgICAgICAgaSwgaiwgcmlnaHQyLCByaWdodDM7XG5cbiAgICAgICAgbXVsdGlTZWxlY3QoaXRlbXMsIGxlZnQsIHJpZ2h0LCBOMSwgdGhpcy5jb21wYXJlTWluWCk7XG5cbiAgICAgICAgZm9yIChpID0gbGVmdDsgaSA8PSByaWdodDsgaSArPSBOMSkge1xuXG4gICAgICAgICAgICByaWdodDIgPSBNYXRoLm1pbihpICsgTjEgLSAxLCByaWdodCk7XG5cbiAgICAgICAgICAgIG11bHRpU2VsZWN0KGl0ZW1zLCBpLCByaWdodDIsIE4yLCB0aGlzLmNvbXBhcmVNaW5ZKTtcblxuICAgICAgICAgICAgZm9yIChqID0gaTsgaiA8PSByaWdodDI7IGogKz0gTjIpIHtcblxuICAgICAgICAgICAgICAgIHJpZ2h0MyA9IE1hdGgubWluKGogKyBOMiAtIDEsIHJpZ2h0Mik7XG5cbiAgICAgICAgICAgICAgICAvLyBwYWNrIGVhY2ggZW50cnkgcmVjdXJzaXZlbHlcbiAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2godGhpcy5fYnVpbGQoaXRlbXMsIGosIHJpZ2h0MywgaGVpZ2h0IC0gMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2FsY0JCb3gobm9kZSwgdGhpcy50b0JCb3gpO1xuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG5cbiAgICBfY2hvb3NlU3VidHJlZTogZnVuY3Rpb24gKGJib3gsIG5vZGUsIGxldmVsLCBwYXRoKSB7XG5cbiAgICAgICAgdmFyIGksIGxlbiwgY2hpbGQsIHRhcmdldE5vZGUsIGFyZWEsIGVubGFyZ2VtZW50LCBtaW5BcmVhLCBtaW5FbmxhcmdlbWVudDtcblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgcGF0aC5wdXNoKG5vZGUpO1xuXG4gICAgICAgICAgICBpZiAobm9kZS5sZWFmIHx8IHBhdGgubGVuZ3RoIC0gMSA9PT0gbGV2ZWwpIGJyZWFrO1xuXG4gICAgICAgICAgICBtaW5BcmVhID0gbWluRW5sYXJnZW1lbnQgPSBJbmZpbml0eTtcblxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBhcmVhID0gYmJveEFyZWEoY2hpbGQpO1xuICAgICAgICAgICAgICAgIGVubGFyZ2VtZW50ID0gZW5sYXJnZWRBcmVhKGJib3gsIGNoaWxkKSAtIGFyZWE7XG5cbiAgICAgICAgICAgICAgICAvLyBjaG9vc2UgZW50cnkgd2l0aCB0aGUgbGVhc3QgYXJlYSBlbmxhcmdlbWVudFxuICAgICAgICAgICAgICAgIGlmIChlbmxhcmdlbWVudCA8IG1pbkVubGFyZ2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbkVubGFyZ2VtZW50ID0gZW5sYXJnZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhIDwgbWluQXJlYSA/IGFyZWEgOiBtaW5BcmVhO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXROb2RlID0gY2hpbGQ7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVubGFyZ2VtZW50ID09PSBtaW5FbmxhcmdlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgY2hvb3NlIG9uZSB3aXRoIHRoZSBzbWFsbGVzdCBhcmVhXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmVhIDwgbWluQXJlYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXROb2RlID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGUgPSB0YXJnZXROb2RlIHx8IG5vZGUuY2hpbGRyZW5bMF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuXG4gICAgX2luc2VydDogZnVuY3Rpb24gKGl0ZW0sIGxldmVsLCBpc05vZGUpIHtcblxuICAgICAgICB2YXIgdG9CQm94ID0gdGhpcy50b0JCb3gsXG4gICAgICAgICAgICBiYm94ID0gaXNOb2RlID8gaXRlbSA6IHRvQkJveChpdGVtKSxcbiAgICAgICAgICAgIGluc2VydFBhdGggPSBbXTtcblxuICAgICAgICAvLyBmaW5kIHRoZSBiZXN0IG5vZGUgZm9yIGFjY29tbW9kYXRpbmcgdGhlIGl0ZW0sIHNhdmluZyBhbGwgbm9kZXMgYWxvbmcgdGhlIHBhdGggdG9vXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5fY2hvb3NlU3VidHJlZShiYm94LCB0aGlzLmRhdGEsIGxldmVsLCBpbnNlcnRQYXRoKTtcblxuICAgICAgICAvLyBwdXQgdGhlIGl0ZW0gaW50byB0aGUgbm9kZVxuICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2goaXRlbSk7XG4gICAgICAgIGV4dGVuZChub2RlLCBiYm94KTtcblxuICAgICAgICAvLyBzcGxpdCBvbiBub2RlIG92ZXJmbG93OyBwcm9wYWdhdGUgdXB3YXJkcyBpZiBuZWNlc3NhcnlcbiAgICAgICAgd2hpbGUgKGxldmVsID49IDApIHtcbiAgICAgICAgICAgIGlmIChpbnNlcnRQYXRoW2xldmVsXS5jaGlsZHJlbi5sZW5ndGggPiB0aGlzLl9tYXhFbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3BsaXQoaW5zZXJ0UGF0aCwgbGV2ZWwpO1xuICAgICAgICAgICAgICAgIGxldmVsLS07XG4gICAgICAgICAgICB9IGVsc2UgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGp1c3QgYmJveGVzIGFsb25nIHRoZSBpbnNlcnRpb24gcGF0aFxuICAgICAgICB0aGlzLl9hZGp1c3RQYXJlbnRCQm94ZXMoYmJveCwgaW5zZXJ0UGF0aCwgbGV2ZWwpO1xuICAgIH0sXG5cbiAgICAvLyBzcGxpdCBvdmVyZmxvd2VkIG5vZGUgaW50byB0d29cbiAgICBfc3BsaXQ6IGZ1bmN0aW9uIChpbnNlcnRQYXRoLCBsZXZlbCkge1xuXG4gICAgICAgIHZhciBub2RlID0gaW5zZXJ0UGF0aFtsZXZlbF0sXG4gICAgICAgICAgICBNID0gbm9kZS5jaGlsZHJlbi5sZW5ndGgsXG4gICAgICAgICAgICBtID0gdGhpcy5fbWluRW50cmllcztcblxuICAgICAgICB0aGlzLl9jaG9vc2VTcGxpdEF4aXMobm9kZSwgbSwgTSk7XG5cbiAgICAgICAgdmFyIHNwbGl0SW5kZXggPSB0aGlzLl9jaG9vc2VTcGxpdEluZGV4KG5vZGUsIG0sIE0pO1xuXG4gICAgICAgIHZhciBuZXdOb2RlID0gY3JlYXRlTm9kZShub2RlLmNoaWxkcmVuLnNwbGljZShzcGxpdEluZGV4LCBub2RlLmNoaWxkcmVuLmxlbmd0aCAtIHNwbGl0SW5kZXgpKTtcbiAgICAgICAgbmV3Tm9kZS5oZWlnaHQgPSBub2RlLmhlaWdodDtcbiAgICAgICAgbmV3Tm9kZS5sZWFmID0gbm9kZS5sZWFmO1xuXG4gICAgICAgIGNhbGNCQm94KG5vZGUsIHRoaXMudG9CQm94KTtcbiAgICAgICAgY2FsY0JCb3gobmV3Tm9kZSwgdGhpcy50b0JCb3gpO1xuXG4gICAgICAgIGlmIChsZXZlbCkgaW5zZXJ0UGF0aFtsZXZlbCAtIDFdLmNoaWxkcmVuLnB1c2gobmV3Tm9kZSk7XG4gICAgICAgIGVsc2UgdGhpcy5fc3BsaXRSb290KG5vZGUsIG5ld05vZGUpO1xuICAgIH0sXG5cbiAgICBfc3BsaXRSb290OiBmdW5jdGlvbiAobm9kZSwgbmV3Tm9kZSkge1xuICAgICAgICAvLyBzcGxpdCByb290IG5vZGVcbiAgICAgICAgdGhpcy5kYXRhID0gY3JlYXRlTm9kZShbbm9kZSwgbmV3Tm9kZV0pO1xuICAgICAgICB0aGlzLmRhdGEuaGVpZ2h0ID0gbm9kZS5oZWlnaHQgKyAxO1xuICAgICAgICB0aGlzLmRhdGEubGVhZiA9IGZhbHNlO1xuICAgICAgICBjYWxjQkJveCh0aGlzLmRhdGEsIHRoaXMudG9CQm94KTtcbiAgICB9LFxuXG4gICAgX2Nob29zZVNwbGl0SW5kZXg6IGZ1bmN0aW9uIChub2RlLCBtLCBNKSB7XG5cbiAgICAgICAgdmFyIGksIGJib3gxLCBiYm94Miwgb3ZlcmxhcCwgYXJlYSwgbWluT3ZlcmxhcCwgbWluQXJlYSwgaW5kZXg7XG5cbiAgICAgICAgbWluT3ZlcmxhcCA9IG1pbkFyZWEgPSBJbmZpbml0eTtcblxuICAgICAgICBmb3IgKGkgPSBtOyBpIDw9IE0gLSBtOyBpKyspIHtcbiAgICAgICAgICAgIGJib3gxID0gZGlzdEJCb3gobm9kZSwgMCwgaSwgdGhpcy50b0JCb3gpO1xuICAgICAgICAgICAgYmJveDIgPSBkaXN0QkJveChub2RlLCBpLCBNLCB0aGlzLnRvQkJveCk7XG5cbiAgICAgICAgICAgIG92ZXJsYXAgPSBpbnRlcnNlY3Rpb25BcmVhKGJib3gxLCBiYm94Mik7XG4gICAgICAgICAgICBhcmVhID0gYmJveEFyZWEoYmJveDEpICsgYmJveEFyZWEoYmJveDIpO1xuXG4gICAgICAgICAgICAvLyBjaG9vc2UgZGlzdHJpYnV0aW9uIHdpdGggbWluaW11bSBvdmVybGFwXG4gICAgICAgICAgICBpZiAob3ZlcmxhcCA8IG1pbk92ZXJsYXApIHtcbiAgICAgICAgICAgICAgICBtaW5PdmVybGFwID0gb3ZlcmxhcDtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG5cbiAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYSA8IG1pbkFyZWEgPyBhcmVhIDogbWluQXJlYTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChvdmVybGFwID09PSBtaW5PdmVybGFwKSB7XG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGNob29zZSBkaXN0cmlidXRpb24gd2l0aCBtaW5pbXVtIGFyZWFcbiAgICAgICAgICAgICAgICBpZiAoYXJlYSA8IG1pbkFyZWEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWE7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSxcblxuICAgIC8vIHNvcnRzIG5vZGUgY2hpbGRyZW4gYnkgdGhlIGJlc3QgYXhpcyBmb3Igc3BsaXRcbiAgICBfY2hvb3NlU3BsaXRBeGlzOiBmdW5jdGlvbiAobm9kZSwgbSwgTSkge1xuXG4gICAgICAgIHZhciBjb21wYXJlTWluWCA9IG5vZGUubGVhZiA/IHRoaXMuY29tcGFyZU1pblggOiBjb21wYXJlTm9kZU1pblgsXG4gICAgICAgICAgICBjb21wYXJlTWluWSA9IG5vZGUubGVhZiA/IHRoaXMuY29tcGFyZU1pblkgOiBjb21wYXJlTm9kZU1pblksXG4gICAgICAgICAgICB4TWFyZ2luID0gdGhpcy5fYWxsRGlzdE1hcmdpbihub2RlLCBtLCBNLCBjb21wYXJlTWluWCksXG4gICAgICAgICAgICB5TWFyZ2luID0gdGhpcy5fYWxsRGlzdE1hcmdpbihub2RlLCBtLCBNLCBjb21wYXJlTWluWSk7XG5cbiAgICAgICAgLy8gaWYgdG90YWwgZGlzdHJpYnV0aW9ucyBtYXJnaW4gdmFsdWUgaXMgbWluaW1hbCBmb3IgeCwgc29ydCBieSBtaW5YLFxuICAgICAgICAvLyBvdGhlcndpc2UgaXQncyBhbHJlYWR5IHNvcnRlZCBieSBtaW5ZXG4gICAgICAgIGlmICh4TWFyZ2luIDwgeU1hcmdpbikgbm9kZS5jaGlsZHJlbi5zb3J0KGNvbXBhcmVNaW5YKTtcbiAgICB9LFxuXG4gICAgLy8gdG90YWwgbWFyZ2luIG9mIGFsbCBwb3NzaWJsZSBzcGxpdCBkaXN0cmlidXRpb25zIHdoZXJlIGVhY2ggbm9kZSBpcyBhdCBsZWFzdCBtIGZ1bGxcbiAgICBfYWxsRGlzdE1hcmdpbjogZnVuY3Rpb24gKG5vZGUsIG0sIE0sIGNvbXBhcmUpIHtcblxuICAgICAgICBub2RlLmNoaWxkcmVuLnNvcnQoY29tcGFyZSk7XG5cbiAgICAgICAgdmFyIHRvQkJveCA9IHRoaXMudG9CQm94LFxuICAgICAgICAgICAgbGVmdEJCb3ggPSBkaXN0QkJveChub2RlLCAwLCBtLCB0b0JCb3gpLFxuICAgICAgICAgICAgcmlnaHRCQm94ID0gZGlzdEJCb3gobm9kZSwgTSAtIG0sIE0sIHRvQkJveCksXG4gICAgICAgICAgICBtYXJnaW4gPSBiYm94TWFyZ2luKGxlZnRCQm94KSArIGJib3hNYXJnaW4ocmlnaHRCQm94KSxcbiAgICAgICAgICAgIGksIGNoaWxkO1xuXG4gICAgICAgIGZvciAoaSA9IG07IGkgPCBNIC0gbTsgaSsrKSB7XG4gICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBleHRlbmQobGVmdEJCb3gsIG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZCk7XG4gICAgICAgICAgICBtYXJnaW4gKz0gYmJveE1hcmdpbihsZWZ0QkJveCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSBNIC0gbSAtIDE7IGkgPj0gbTsgaS0tKSB7XG4gICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBleHRlbmQocmlnaHRCQm94LCBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQpO1xuICAgICAgICAgICAgbWFyZ2luICs9IGJib3hNYXJnaW4ocmlnaHRCQm94KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXJnaW47XG4gICAgfSxcblxuICAgIF9hZGp1c3RQYXJlbnRCQm94ZXM6IGZ1bmN0aW9uIChiYm94LCBwYXRoLCBsZXZlbCkge1xuICAgICAgICAvLyBhZGp1c3QgYmJveGVzIGFsb25nIHRoZSBnaXZlbiB0cmVlIHBhdGhcbiAgICAgICAgZm9yICh2YXIgaSA9IGxldmVsOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgZXh0ZW5kKHBhdGhbaV0sIGJib3gpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9jb25kZW5zZTogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgcGF0aCwgcmVtb3ZpbmcgZW1wdHkgbm9kZXMgYW5kIHVwZGF0aW5nIGJib3hlc1xuICAgICAgICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxLCBzaWJsaW5nczsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChwYXRoW2ldLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzaWJsaW5ncyA9IHBhdGhbaSAtIDFdLmNoaWxkcmVuO1xuICAgICAgICAgICAgICAgICAgICBzaWJsaW5ncy5zcGxpY2Uoc2libGluZ3MuaW5kZXhPZihwYXRoW2ldKSwgMSk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgdGhpcy5jbGVhcigpO1xuXG4gICAgICAgICAgICB9IGVsc2UgY2FsY0JCb3gocGF0aFtpXSwgdGhpcy50b0JCb3gpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9pbml0Rm9ybWF0OiBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIC8vIGRhdGEgZm9ybWF0IChtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZIGFjY2Vzc29ycylcblxuICAgICAgICAvLyB1c2VzIGV2YWwtdHlwZSBmdW5jdGlvbiBjb21waWxhdGlvbiBpbnN0ZWFkIG9mIGp1c3QgYWNjZXB0aW5nIGEgdG9CQm94IGZ1bmN0aW9uXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlIGFsZ29yaXRobXMgYXJlIHZlcnkgc2Vuc2l0aXZlIHRvIHNvcnRpbmcgZnVuY3Rpb25zIHBlcmZvcm1hbmNlLFxuICAgICAgICAvLyBzbyB0aGV5IHNob3VsZCBiZSBkZWFkIHNpbXBsZSBhbmQgd2l0aG91dCBpbm5lciBjYWxsc1xuXG4gICAgICAgIHZhciBjb21wYXJlQXJyID0gWydyZXR1cm4gYScsICcgLSBiJywgJzsnXTtcblxuICAgICAgICB0aGlzLmNvbXBhcmVNaW5YID0gbmV3IEZ1bmN0aW9uKCdhJywgJ2InLCBjb21wYXJlQXJyLmpvaW4oZm9ybWF0WzBdKSk7XG4gICAgICAgIHRoaXMuY29tcGFyZU1pblkgPSBuZXcgRnVuY3Rpb24oJ2EnLCAnYicsIGNvbXBhcmVBcnIuam9pbihmb3JtYXRbMV0pKTtcblxuICAgICAgICB0aGlzLnRvQkJveCA9IG5ldyBGdW5jdGlvbignYScsXG4gICAgICAgICAgICAncmV0dXJuIHttaW5YOiBhJyArIGZvcm1hdFswXSArXG4gICAgICAgICAgICAnLCBtaW5ZOiBhJyArIGZvcm1hdFsxXSArXG4gICAgICAgICAgICAnLCBtYXhYOiBhJyArIGZvcm1hdFsyXSArXG4gICAgICAgICAgICAnLCBtYXhZOiBhJyArIGZvcm1hdFszXSArICd9OycpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGZpbmRJdGVtKGl0ZW0sIGl0ZW1zLCBlcXVhbHNGbikge1xuICAgIGlmICghZXF1YWxzRm4pIHJldHVybiBpdGVtcy5pbmRleE9mKGl0ZW0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZXF1YWxzRm4oaXRlbSwgaXRlbXNbaV0pKSByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuXG4vLyBjYWxjdWxhdGUgbm9kZSdzIGJib3ggZnJvbSBiYm94ZXMgb2YgaXRzIGNoaWxkcmVuXG5mdW5jdGlvbiBjYWxjQkJveChub2RlLCB0b0JCb3gpIHtcbiAgICBkaXN0QkJveChub2RlLCAwLCBub2RlLmNoaWxkcmVuLmxlbmd0aCwgdG9CQm94LCBub2RlKTtcbn1cblxuLy8gbWluIGJvdW5kaW5nIHJlY3RhbmdsZSBvZiBub2RlIGNoaWxkcmVuIGZyb20gayB0byBwLTFcbmZ1bmN0aW9uIGRpc3RCQm94KG5vZGUsIGssIHAsIHRvQkJveCwgZGVzdE5vZGUpIHtcbiAgICBpZiAoIWRlc3ROb2RlKSBkZXN0Tm9kZSA9IGNyZWF0ZU5vZGUobnVsbCk7XG4gICAgZGVzdE5vZGUubWluWCA9IEluZmluaXR5O1xuICAgIGRlc3ROb2RlLm1pblkgPSBJbmZpbml0eTtcbiAgICBkZXN0Tm9kZS5tYXhYID0gLUluZmluaXR5O1xuICAgIGRlc3ROb2RlLm1heFkgPSAtSW5maW5pdHk7XG5cbiAgICBmb3IgKHZhciBpID0gaywgY2hpbGQ7IGkgPCBwOyBpKyspIHtcbiAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICBleHRlbmQoZGVzdE5vZGUsIG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlc3ROb2RlO1xufVxuXG5mdW5jdGlvbiBleHRlbmQoYSwgYikge1xuICAgIGEubWluWCA9IE1hdGgubWluKGEubWluWCwgYi5taW5YKTtcbiAgICBhLm1pblkgPSBNYXRoLm1pbihhLm1pblksIGIubWluWSk7XG4gICAgYS5tYXhYID0gTWF0aC5tYXgoYS5tYXhYLCBiLm1heFgpO1xuICAgIGEubWF4WSA9IE1hdGgubWF4KGEubWF4WSwgYi5tYXhZKTtcbiAgICByZXR1cm4gYTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZU5vZGVNaW5YKGEsIGIpIHsgcmV0dXJuIGEubWluWCAtIGIubWluWDsgfVxuZnVuY3Rpb24gY29tcGFyZU5vZGVNaW5ZKGEsIGIpIHsgcmV0dXJuIGEubWluWSAtIGIubWluWTsgfVxuXG5mdW5jdGlvbiBiYm94QXJlYShhKSAgIHsgcmV0dXJuIChhLm1heFggLSBhLm1pblgpICogKGEubWF4WSAtIGEubWluWSk7IH1cbmZ1bmN0aW9uIGJib3hNYXJnaW4oYSkgeyByZXR1cm4gKGEubWF4WCAtIGEubWluWCkgKyAoYS5tYXhZIC0gYS5taW5ZKTsgfVxuXG5mdW5jdGlvbiBlbmxhcmdlZEFyZWEoYSwgYikge1xuICAgIHJldHVybiAoTWF0aC5tYXgoYi5tYXhYLCBhLm1heFgpIC0gTWF0aC5taW4oYi5taW5YLCBhLm1pblgpKSAqXG4gICAgICAgICAgIChNYXRoLm1heChiLm1heFksIGEubWF4WSkgLSBNYXRoLm1pbihiLm1pblksIGEubWluWSkpO1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3Rpb25BcmVhKGEsIGIpIHtcbiAgICB2YXIgbWluWCA9IE1hdGgubWF4KGEubWluWCwgYi5taW5YKSxcbiAgICAgICAgbWluWSA9IE1hdGgubWF4KGEubWluWSwgYi5taW5ZKSxcbiAgICAgICAgbWF4WCA9IE1hdGgubWluKGEubWF4WCwgYi5tYXhYKSxcbiAgICAgICAgbWF4WSA9IE1hdGgubWluKGEubWF4WSwgYi5tYXhZKTtcblxuICAgIHJldHVybiBNYXRoLm1heCgwLCBtYXhYIC0gbWluWCkgKlxuICAgICAgICAgICBNYXRoLm1heCgwLCBtYXhZIC0gbWluWSk7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zKGEsIGIpIHtcbiAgICByZXR1cm4gYS5taW5YIDw9IGIubWluWCAmJlxuICAgICAgICAgICBhLm1pblkgPD0gYi5taW5ZICYmXG4gICAgICAgICAgIGIubWF4WCA8PSBhLm1heFggJiZcbiAgICAgICAgICAgYi5tYXhZIDw9IGEubWF4WTtcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0cyhhLCBiKSB7XG4gICAgcmV0dXJuIGIubWluWCA8PSBhLm1heFggJiZcbiAgICAgICAgICAgYi5taW5ZIDw9IGEubWF4WSAmJlxuICAgICAgICAgICBiLm1heFggPj0gYS5taW5YICYmXG4gICAgICAgICAgIGIubWF4WSA+PSBhLm1pblk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vZGUoY2hpbGRyZW4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgIGhlaWdodDogMSxcbiAgICAgICAgbGVhZjogdHJ1ZSxcbiAgICAgICAgbWluWDogSW5maW5pdHksXG4gICAgICAgIG1pblk6IEluZmluaXR5LFxuICAgICAgICBtYXhYOiAtSW5maW5pdHksXG4gICAgICAgIG1heFk6IC1JbmZpbml0eVxuICAgIH07XG59XG5cbi8vIHNvcnQgYW4gYXJyYXkgc28gdGhhdCBpdGVtcyBjb21lIGluIGdyb3VwcyBvZiBuIHVuc29ydGVkIGl0ZW1zLCB3aXRoIGdyb3VwcyBzb3J0ZWQgYmV0d2VlbiBlYWNoIG90aGVyO1xuLy8gY29tYmluZXMgc2VsZWN0aW9uIGFsZ29yaXRobSB3aXRoIGJpbmFyeSBkaXZpZGUgJiBjb25xdWVyIGFwcHJvYWNoXG5cbmZ1bmN0aW9uIG11bHRpU2VsZWN0KGFyciwgbGVmdCwgcmlnaHQsIG4sIGNvbXBhcmUpIHtcbiAgICB2YXIgc3RhY2sgPSBbbGVmdCwgcmlnaHRdLFxuICAgICAgICBtaWQ7XG5cbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIHJpZ2h0ID0gc3RhY2sucG9wKCk7XG4gICAgICAgIGxlZnQgPSBzdGFjay5wb3AoKTtcblxuICAgICAgICBpZiAocmlnaHQgLSBsZWZ0IDw9IG4pIGNvbnRpbnVlO1xuXG4gICAgICAgIG1pZCA9IGxlZnQgKyBNYXRoLmNlaWwoKHJpZ2h0IC0gbGVmdCkgLyBuIC8gMikgKiBuO1xuICAgICAgICBxdWlja3NlbGVjdChhcnIsIG1pZCwgbGVmdCwgcmlnaHQsIGNvbXBhcmUpO1xuXG4gICAgICAgIHN0YWNrLnB1c2gobGVmdCwgbWlkLCBtaWQsIHJpZ2h0KTtcbiAgICB9XG59XG4iLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7fTtcblxudmFyXHRtZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbWVtbztcblx0fTtcbn07XG5cbnZhciBpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cdC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG5cdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcblx0Ly8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuXHQvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcblx0Ly8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG5cdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcbn0pO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gKHRhcmdldCwgcGFyZW50KSB7XG4gIGlmIChwYXJlbnQpe1xuICAgIHJldHVybiBwYXJlbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xuICB9XG4gIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG59O1xuXG52YXIgZ2V0RWxlbWVudCA9IChmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW8gPSB7fTtcblxuXHRyZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBwYXNzaW5nIGZ1bmN0aW9uIGluIG9wdGlvbnMsIHRoZW4gdXNlIGl0IGZvciByZXNvbHZlIFwiaGVhZFwiIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgLy8gVXNlZnVsIGZvciBTaGFkb3cgUm9vdCBzdHlsZSBpLmVcbiAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgICAgICAgICAgLy8gICBpbnNlcnRJbnRvOiBmdW5jdGlvbiAoKSB7IHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2Zvb1wiKS5zaGFkb3dSb290IH1cbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdHZhciBzdHlsZVRhcmdldCA9IGdldFRhcmdldC5jYWxsKHRoaXMsIHRhcmdldCwgcGFyZW50KTtcblx0XHRcdC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cdFx0XHRpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcblx0XHRcdFx0XHQvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG5cdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG5cdFx0fVxuXHRcdHJldHVybiBtZW1vW3RhcmdldF1cblx0fTtcbn0pKCk7XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyXHRzaW5nbGV0b25Db3VudGVyID0gMDtcbnZhclx0c3R5bGVzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xuXG52YXJcdGZpeFVybHMgPSByZXF1aXJlKFwiLi91cmxzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYgKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcblx0fVxuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdG9wdGlvbnMuYXR0cnMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRycyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuYXR0cnMgOiB7fTtcblxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXHRpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gXCJib29sZWFuXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIDxoZWFkPiBlbGVtZW50XG4gICAgICAgIGlmICghb3B0aW9ucy5pbnNlcnRJbnRvKSBvcHRpb25zLmluc2VydEludG8gPSBcImhlYWRcIjtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0QXQpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucyk7XG5cblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcblx0XHR9XG5cblx0XHRpZihuZXdMaXN0KSB7XG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QsIG9wdGlvbnMpO1xuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xuXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIGRvbVN0eWxlLnBhcnRzW2pdKCk7XG5cblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzLCBvcHRpb25zKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRpZihkb21TdHlsZSkge1xuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMgKGxpc3QsIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlcyA9IFtdO1xuXHR2YXIgbmV3U3R5bGVzID0ge307XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xuXHRcdHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZSBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQgKG9wdGlvbnMsIHN0eWxlKSB7XG5cdHZhciB0YXJnZXQgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50bylcblxuXHRpZiAoIXRhcmdldCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0SW50bycgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuXHR9XG5cblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcFtzdHlsZXNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XG5cdFx0aWYgKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZiAobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0XHR9XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlKTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XG5cdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0fSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zLmluc2VydEF0LmJlZm9yZSkge1xuXHRcdHZhciBuZXh0U2libGluZyA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRBdC5iZWZvcmUsIHRhcmdldCk7XG5cdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbmV4dFNpYmxpbmcpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIltTdHlsZSBMb2FkZXJdXFxuXFxuIEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnICgnb3B0aW9ucy5pbnNlcnRBdCcpIGZvdW5kLlxcbiBNdXN0IGJlICd0b3AnLCAnYm90dG9tJywgb3IgT2JqZWN0LlxcbiAoaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIjaW5zZXJ0YXQpXFxuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudCAoc3R5bGUpIHtcblx0aWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblx0c3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG5cblx0dmFyIGlkeCA9IHN0eWxlc0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZSk7XG5cdGlmKGlkeCA+PSAwKSB7XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXG5cdGlmKG9wdGlvbnMuYXR0cnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHR9XG5cblx0aWYob3B0aW9ucy5hdHRycy5ub25jZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dmFyIG5vbmNlID0gZ2V0Tm9uY2UoKTtcblx0XHRpZiAobm9uY2UpIHtcblx0XHRcdG9wdGlvbnMuYXR0cnMubm9uY2UgPSBub25jZTtcblx0XHR9XG5cdH1cblxuXHRhZGRBdHRycyhzdHlsZSwgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZSk7XG5cblx0cmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5rRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuXG5cdGlmKG9wdGlvbnMuYXR0cnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHR9XG5cdG9wdGlvbnMuYXR0cnMucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cblx0YWRkQXR0cnMobGluaywgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rKTtcblxuXHRyZXR1cm4gbGluaztcbn1cblxuZnVuY3Rpb24gYWRkQXR0cnMgKGVsLCBhdHRycykge1xuXHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0ZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBnZXROb25jZSgpIHtcblx0aWYgKHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHJldHVybiBfX3dlYnBhY2tfbm9uY2VfXztcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGUsIHVwZGF0ZSwgcmVtb3ZlLCByZXN1bHQ7XG5cblx0Ly8gSWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2FzIGRlZmluZWQsIHJ1biBpdCBvbiB0aGUgY3NzXG5cdGlmIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvYmouY3NzKSB7XG5cdCAgICByZXN1bHQgPSB0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbidcblx0XHQgPyBvcHRpb25zLnRyYW5zZm9ybShvYmouY3NzKSBcblx0XHQgOiBvcHRpb25zLnRyYW5zZm9ybS5kZWZhdWx0KG9iai5jc3MpO1xuXG5cdCAgICBpZiAocmVzdWx0KSB7XG5cdCAgICBcdC8vIElmIHRyYW5zZm9ybSByZXR1cm5zIGEgdmFsdWUsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgcnVubmluZyBydW50aW1lIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgY3NzLlxuXHQgICAgXHRvYmouY3NzID0gcmVzdWx0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgIFx0Ly8gSWYgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIGRvbid0IGFkZCB0aGlzIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgY29uZGl0aW9uYWwgbG9hZGluZyBvZiBjc3Ncblx0ICAgIFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgXHRcdC8vIG5vb3Bcblx0ICAgIFx0fTtcblx0ICAgIH1cblx0fVxuXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuXG5cdFx0c3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuXG5cdH0gZWxzZSBpZiAoXG5cdFx0b2JqLnNvdXJjZU1hcCAmJlxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCJcblx0KSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cblx0XHRcdGlmKHN0eWxlLmhyZWYpIFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGUuaHJlZik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZSA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cdFx0fTtcblx0fVxuXG5cdHVwZGF0ZShvYmopO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqKSB7XG5cdFx0aWYgKG5ld09iaikge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG5cdFx0XHRcdG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG5cdFx0XHRcdG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXBcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZW1vdmUoKTtcblx0XHR9XG5cdH07XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcblxuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHR9O1xufSkoKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XG5cblx0aWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcblx0fSBlbHNlIHtcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG5cblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZSwgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG5cblx0aWYobWVkaWEpIHtcblx0XHRzdHlsZS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcblx0fVxuXG5cdGlmKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG5cdH0gZWxzZSB7XG5cdFx0d2hpbGUoc3R5bGUuZmlyc3RDaGlsZCkge1xuXHRcdFx0c3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG5cdFx0fVxuXG5cdFx0c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGluayAobGluaywgb3B0aW9ucywgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuXHQvKlxuXHRcdElmIGNvbnZlcnRUb0Fic29sdXRlVXJscyBpc24ndCBkZWZpbmVkLCBidXQgc291cmNlbWFwcyBhcmUgZW5hYmxlZFxuXHRcdGFuZCB0aGVyZSBpcyBubyBwdWJsaWNQYXRoIGRlZmluZWQgdGhlbiBsZXRzIHR1cm4gY29udmVydFRvQWJzb2x1dGVVcmxzXG5cdFx0b24gYnkgZGVmYXVsdC4gIE90aGVyd2lzZSBkZWZhdWx0IHRvIHRoZSBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgb3B0aW9uXG5cdFx0ZGlyZWN0bHlcblx0Ki9cblx0dmFyIGF1dG9GaXhVcmxzID0gb3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgPT09IHVuZGVmaW5lZCAmJiBzb3VyY2VNYXA7XG5cblx0aWYgKG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzIHx8IGF1dG9GaXhVcmxzKSB7XG5cdFx0Y3NzID0gZml4VXJscyhjc3MpO1xuXHR9XG5cblx0aWYgKHNvdXJjZU1hcCkge1xuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuXHR9XG5cblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XG5cblx0dmFyIG9sZFNyYyA9IGxpbmsuaHJlZjtcblxuXHRsaW5rLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXG5cdGlmKG9sZFNyYykgVVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xufVxuIiwiXG4vKipcbiAqIFdoZW4gc291cmNlIG1hcHMgYXJlIGVuYWJsZWQsIGBzdHlsZS1sb2FkZXJgIHVzZXMgYSBsaW5rIGVsZW1lbnQgd2l0aCBhIGRhdGEtdXJpIHRvXG4gKiBlbWJlZCB0aGUgY3NzIG9uIHRoZSBwYWdlLiBUaGlzIGJyZWFrcyBhbGwgcmVsYXRpdmUgdXJscyBiZWNhdXNlIG5vdyB0aGV5IGFyZSByZWxhdGl2ZSB0byBhXG4gKiBidW5kbGUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBwYWdlLlxuICpcbiAqIE9uZSBzb2x1dGlvbiBpcyB0byBvbmx5IHVzZSBmdWxsIHVybHMsIGJ1dCB0aGF0IG1heSBiZSBpbXBvc3NpYmxlLlxuICpcbiAqIEluc3RlYWQsIHRoaXMgZnVuY3Rpb24gXCJmaXhlc1wiIHRoZSByZWxhdGl2ZSB1cmxzIHRvIGJlIGFic29sdXRlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYWdlIGxvY2F0aW9uLlxuICpcbiAqIEEgcnVkaW1lbnRhcnkgdGVzdCBzdWl0ZSBpcyBsb2NhdGVkIGF0IGB0ZXN0L2ZpeFVybHMuanNgIGFuZCBjYW4gYmUgcnVuIHZpYSB0aGUgYG5wbSB0ZXN0YCBjb21tYW5kLlxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgLy8gZ2V0IGN1cnJlbnQgbG9jYXRpb25cbiAgdmFyIGxvY2F0aW9uID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYXRpb247XG5cbiAgaWYgKCFsb2NhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZpeFVybHMgcmVxdWlyZXMgd2luZG93LmxvY2F0aW9uXCIpO1xuICB9XG5cblx0Ly8gYmxhbmsgb3IgbnVsbD9cblx0aWYgKCFjc3MgfHwgdHlwZW9mIGNzcyAhPT0gXCJzdHJpbmdcIikge1xuXHQgIHJldHVybiBjc3M7XG4gIH1cblxuICB2YXIgYmFzZVVybCA9IGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgbG9jYXRpb24uaG9zdDtcbiAgdmFyIGN1cnJlbnREaXIgPSBiYXNlVXJsICsgbG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCBcIi9cIik7XG5cblx0Ly8gY29udmVydCBlYWNoIHVybCguLi4pXG5cdC8qXG5cdFRoaXMgcmVndWxhciBleHByZXNzaW9uIGlzIGp1c3QgYSB3YXkgdG8gcmVjdXJzaXZlbHkgbWF0Y2ggYnJhY2tldHMgd2l0aGluXG5cdGEgc3RyaW5nLlxuXG5cdCAvdXJsXFxzKlxcKCAgPSBNYXRjaCBvbiB0aGUgd29yZCBcInVybFwiIHdpdGggYW55IHdoaXRlc3BhY2UgYWZ0ZXIgaXQgYW5kIHRoZW4gYSBwYXJlbnNcblx0ICAgKCAgPSBTdGFydCBhIGNhcHR1cmluZyBncm91cFxuXHQgICAgICg/OiAgPSBTdGFydCBhIG5vbi1jYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAgICAgW14pKF0gID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICg/OiAgPSBTdGFydCBhbm90aGVyIG5vbi1jYXB0dXJpbmcgZ3JvdXBzXG5cdCAgICAgICAgICAgICAgICAgW14pKF0rICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgICAgICBbXikoXSogID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgXFwpICA9IE1hdGNoIGEgZW5kIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICApICA9IEVuZCBHcm91cFxuICAgICAgICAgICAgICAqXFwpID0gTWF0Y2ggYW55dGhpbmcgYW5kIHRoZW4gYSBjbG9zZSBwYXJlbnNcbiAgICAgICAgICApICA9IENsb3NlIG5vbi1jYXB0dXJpbmcgZ3JvdXBcbiAgICAgICAgICAqICA9IE1hdGNoIGFueXRoaW5nXG4gICAgICAgKSAgPSBDbG9zZSBjYXB0dXJpbmcgZ3JvdXBcblx0IFxcKSAgPSBNYXRjaCBhIGNsb3NlIHBhcmVuc1xuXG5cdCAvZ2kgID0gR2V0IGFsbCBtYXRjaGVzLCBub3QgdGhlIGZpcnN0LiAgQmUgY2FzZSBpbnNlbnNpdGl2ZS5cblx0ICovXG5cdHZhciBmaXhlZENzcyA9IGNzcy5yZXBsYWNlKC91cmxcXHMqXFwoKCg/OlteKShdfFxcKCg/OlteKShdK3xcXChbXikoXSpcXCkpKlxcKSkqKVxcKS9naSwgZnVuY3Rpb24oZnVsbE1hdGNoLCBvcmlnVXJsKSB7XG5cdFx0Ly8gc3RyaXAgcXVvdGVzIChpZiB0aGV5IGV4aXN0KVxuXHRcdHZhciB1bnF1b3RlZE9yaWdVcmwgPSBvcmlnVXJsXG5cdFx0XHQudHJpbSgpXG5cdFx0XHQucmVwbGFjZSgvXlwiKC4qKVwiJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KVxuXHRcdFx0LnJlcGxhY2UoL14nKC4qKSckLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pO1xuXG5cdFx0Ly8gYWxyZWFkeSBhIGZ1bGwgdXJsPyBubyBjaGFuZ2Vcblx0XHRpZiAoL14oI3xkYXRhOnxodHRwOlxcL1xcL3xodHRwczpcXC9cXC98ZmlsZTpcXC9cXC9cXC98XFxzKiQpL2kudGVzdCh1bnF1b3RlZE9yaWdVcmwpKSB7XG5cdFx0ICByZXR1cm4gZnVsbE1hdGNoO1xuXHRcdH1cblxuXHRcdC8vIGNvbnZlcnQgdGhlIHVybCB0byBhIGZ1bGwgdXJsXG5cdFx0dmFyIG5ld1VybDtcblxuXHRcdGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi8vXCIpID09PSAwKSB7XG5cdFx0ICBcdC8vVE9ETzogc2hvdWxkIHdlIGFkZCBwcm90b2NvbD9cblx0XHRcdG5ld1VybCA9IHVucXVvdGVkT3JpZ1VybDtcblx0XHR9IGVsc2UgaWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiL1wiKSA9PT0gMCkge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJhc2UgdXJsXG5cdFx0XHRuZXdVcmwgPSBiYXNlVXJsICsgdW5xdW90ZWRPcmlnVXJsOyAvLyBhbHJlYWR5IHN0YXJ0cyB3aXRoICcvJ1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byBjdXJyZW50IGRpcmVjdG9yeVxuXHRcdFx0bmV3VXJsID0gY3VycmVudERpciArIHVucXVvdGVkT3JpZ1VybC5yZXBsYWNlKC9eXFwuXFwvLywgXCJcIik7IC8vIFN0cmlwIGxlYWRpbmcgJy4vJ1xuXHRcdH1cblxuXHRcdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgdXJsKC4uLilcblx0XHRyZXR1cm4gXCJ1cmwoXCIgKyBKU09OLnN0cmluZ2lmeShuZXdVcmwpICsgXCIpXCI7XG5cdH0pO1xuXG5cdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgY3NzXG5cdHJldHVybiBmaXhlZENzcztcbn07XG4iLCJpbXBvcnQgTGl6bWFwTWFwRWxlbWVudCBmcm9tICcuL21vZHVsZXMvTGl6bWFwTWFwRWxlbWVudC5qcyc7XG5pbXBvcnQgTGl6bWFwQmFzZUxheWVyc0VsZW1lbnQgZnJvbSAnLi9tb2R1bGVzL0xpem1hcEJhc2VMYXllcnNFbGVtZW50LmpzJztcblxud2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnbGl6bWFwLW1hcCcsIExpem1hcE1hcEVsZW1lbnQpO1xud2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnbGl6bWFwLWJhc2VsYXllcnMnLCBMaXptYXBCYXNlTGF5ZXJzRWxlbWVudCk7XG4iLCJpbXBvcnQgTGl6bWFwTGF5ZXJHcm91cCBmcm9tICcuL0xpem1hcExheWVyR3JvdXAuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaXptYXBCYXNlTGF5ZXJzRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICBjb25zdCBzaGFkb3dSb290ID0gdGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiAnb3BlbicgfSk7XG5cbiAgICAgICAgdGhpcy5fbWFwRWxlbWVudDtcbiAgICB9XG5cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcblxuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgICAgICAvLyBUT0RPIGFkZGV2ZW50bGlzdGVuZXJcbiAgICAgICAgd2luZG93Lm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY29uc3QgbWFwU2VsZWN0b3IgPSBzZWxmLmdldEF0dHJpYnV0ZSgnbWFwLXNlbGVjdG9yJyk7XG5cbiAgICAgICAgICAgIGlmIChtYXBTZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcEVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKG1hcFNlbGVjdG9yKTtcblxuICAgICAgICAgICAgICAgIGlmIChtYXBFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXBFbGVtZW50Lm5vZGVOYW1lID09PSBcIkxJWk1BUC1NQVBcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fbWFwRWxlbWVudCA9IG1hcEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiYXNlTGF5ZXJHcm91cCA9IG5ldyBMaXptYXBMYXllckdyb3VwKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXR1YWxseUV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXllcnNMaXN0OiBtYXBFbGVtZW50LmJhc2VMYXllcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBFbGVtZW50LmJhc2VMYXllckdyb3VwID0gYmFzZUxheWVyR3JvdXA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJFbGVtZW50IGlzIG5vdCBhIGxpem1hcC1tYXAgZWxlbWVudC5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJtYXAtc2VsZWN0b3IgZG9lcyBub3QgcmVmZXJlbmNlIGFuIGVsZW1lbnQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwibWFwLXNlbGVjdG9yIHVuZGVmaW5lZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgbmV3U2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VsZWN0Jyk7XG5cbiAgICAgICAgZm9yIChsZXQgW2xheWVySWQsIGNvbmZpZ10gb2YgdGhpcy5fbWFwRWxlbWVudC5iYXNlTGF5ZXJzKSB7XG4gICAgICAgICAgICBsZXQgbmV3Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgICAgICAgICAgbmV3Tm9kZS5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgbGF5ZXJJZCk7XG4gICAgICAgICAgICBpZiAoY29uZmlnLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICBuZXdOb2RlLnNldEF0dHJpYnV0ZSgnc2VsZWN0ZWQnLCAnc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld05vZGUuaW5uZXJUZXh0ID0gY29uZmlnLm5hbWU7XG5cbiAgICAgICAgICAgIG5ld1NlbGVjdC5hcHBlbmRDaGlsZChuZXdOb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV2ZW50IGNoYW5nZVxuICAgICAgICBuZXdTZWxlY3Qub25jaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX21hcEVsZW1lbnQuYmFzZUxheWVyVmlzaWJsZSA9IGV2ZW50LnRhcmdldC52YWx1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQobmV3U2VsZWN0KTtcbiAgICB9XG59XG5cbiIsImltcG9ydCBUaWxlTGF5ZXIgZnJvbSAnb2wvbGF5ZXIvVGlsZS5qcyc7XG5pbXBvcnQgT1NNIGZyb20gJ29sL3NvdXJjZS9PU00uanMnO1xuaW1wb3J0IFN0YW1lbiBmcm9tICdvbC9zb3VyY2UvU3RhbWVuLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGl6bWFwTGF5ZXIge1xuICAgIGNvbnN0cnVjdG9yKGxheWVySWQsIHZpc2libGUpIHtcbiAgICAgICAgdGhpcy5fT0xsYXllcjtcbiAgICAgICAgdGhpcy5fbGF5ZXJJZCA9IGxheWVySWQ7XG4gICAgICAgIGlmIChsYXllcklkID09PSAnb3NtTWFwbmlrJykge1xuICAgICAgICAgICAgdGhpcy5fT0xsYXllciA9IG5ldyBUaWxlTGF5ZXIoe1xuICAgICAgICAgICAgICAgIGxheWVySWQ6IGxheWVySWQsXG4gICAgICAgICAgICAgICAgdmlzaWJsZTogdmlzaWJsZSxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IG5ldyBPU00oKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIGlmIChsYXllcklkID09PSAnb3NtU3RhbWVuVG9uZXInKSB7XG4gICAgICAgICAgICB0aGlzLl9PTGxheWVyID0gbmV3IFRpbGVMYXllcih7XG4gICAgICAgICAgICAgICAgbGF5ZXJJZDogbGF5ZXJJZCxcbiAgICAgICAgICAgICAgICB2aXNpYmxlOiB2aXNpYmxlLFxuICAgICAgICAgICAgICAgIHNvdXJjZTogbmV3IFN0YW1lbih7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyOiAndG9uZXInXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IE9MbGF5ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9PTGxheWVyO1xuICAgIH1cblxuICAgIGdldCBsYXllcklkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGF5ZXJJZDtcbiAgICB9XG5cbiAgICBzZXQgbGF5ZXJWaXNpYmxlKHZpc2libGUpIHtcbiAgICAgICAgdGhpcy5fT0xsYXllci5zZXRWaXNpYmxlKHZpc2libGUpO1xuICAgIH1cbn0iLCJpbXBvcnQgTGl6bWFwTGF5ZXIgZnJvbSAnLi9MaXptYXBMYXllci5qcyc7XG5pbXBvcnQgTGF5ZXJHcm91cCBmcm9tICdvbC9sYXllci9Hcm91cCc7XG5cbi8vIGF0dHJpYnV0IHNlbGVjdGVkXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaXptYXBMYXllckdyb3VwIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRfb3B0aW9ucykge1xuXG4gICAgICAgIHRoaXMuX211dHVhbGx5RXhjbHVzaXZlID0gb3B0X29wdGlvbnMubXV0dWFsbHlFeGNsdXNpdmU7XG5cbiAgICAgICAgdGhpcy5fbGl6bWFwTGF5ZXJzID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgW2xheWVySWQsIGNvbmZpZ10gb2Ygb3B0X29wdGlvbnMubGF5ZXJzTGlzdCkge1xuICAgICAgICAgICAgY29uc3QgbGl6bWFwTGF5ZXIgPSBuZXcgTGl6bWFwTGF5ZXIobGF5ZXJJZCwgY29uZmlnLnZpc2libGUpO1xuXG4gICAgICAgICAgICB0aGlzLl9saXptYXBMYXllcnMucHVzaChsaXptYXBMYXllcik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9PTGxheWVyR3JvdXAgPSBuZXcgTGF5ZXJHcm91cCh7XG4gICAgICAgICAgICBsYXllcnM6IHRoaXMuT0xMYXllcnMoKVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIGNsYXNzIGl0ZXJhYmxlXG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIGxldCBpbmRleCA9IC0xO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0OiAoKSA9PiAoeyB2YWx1ZTogdGhpcy5fbGl6bWFwTGF5ZXJzWysraW5kZXhdLCBkb25lOiAhKGluZGV4IGluIHRoaXMuX2xpem1hcExheWVycykgfSlcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgZ2V0IE9MbGF5ZXJHcm91cCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX09MbGF5ZXJHcm91cDtcbiAgICB9XG5cbiAgICBzZXQgbGF5ZXJWaXNpYmxlKGxheWVySWQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9saXptYXBMYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIFNldCB2aXNpYmlsaXR5IHRvIGZhbHNlIHdoZW4gbXV0dWFsbHkgZXhjbHVzaXZlXG4gICAgICAgICAgICBpZiAodGhpcy5fbXV0dWFsbHlFeGNsdXNpdmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saXptYXBMYXllcnNbaV0ubGF5ZXJWaXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fbGl6bWFwTGF5ZXJzW2ldLmxheWVySWQgPT09IGxheWVySWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saXptYXBMYXllcnNbaV0ubGF5ZXJWaXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE8gOiB1dGlsaXNlciBtYXAoKVxuICAgIE9MTGF5ZXJzKCkge1xuICAgICAgICBsZXQgT0xMYXllcnMgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2xpem1hcExheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgT0xMYXllcnMucHVzaCh0aGlzLl9saXptYXBMYXllcnNbaV0uT0xsYXllcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gT0xMYXllcnM7XG4gICAgfVxufSIsImltcG9ydCAnb2wvb2wuY3NzJztcblxuLy8gT0xNYXAgYW5kIG5vdCBNYXAgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggZ2xvYmFsIG9iamVjdCBNYXBcbmltcG9ydCBPTE1hcCBmcm9tICdvbC9NYXAuanMnO1xuaW1wb3J0IFZpZXcgZnJvbSAnb2wvVmlldy5qcyc7XG5pbXBvcnQgVGlsZUxheWVyIGZyb20gJ29sL2xheWVyL1RpbGUuanMnO1xuaW1wb3J0IE9TTSBmcm9tICdvbC9zb3VyY2UvT1NNLmpzJztcblxuaW1wb3J0IExpem1hcExheWVyR3JvdXAgZnJvbSAnLi9MaXptYXBMYXllckdyb3VwLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGl6bWFwTWFwRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLl9PTE1hcDtcbiAgICAgICAgdGhpcy5fYmFzZUxheWVyR3JvdXA7XG4gICAgfVxuXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgXHRjb25zdCBtYXAgID0gbmV3IE9MTWFwKHtcbiAgICAgICAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgICAgICAgIHZpZXc6IG5ldyBWaWV3KHtcbiAgICAgICAgICAgICAgICBjZW50ZXI6IFswLCAwXSxcbiAgICAgICAgICAgICAgICB6b29tOiAyXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fT0xNYXAgPSBtYXA7XG5cbiAgICAgICAgY29uc3QgYmFzZUxheWVyR3JvdXAgPSBuZXcgTGl6bWFwTGF5ZXJHcm91cCh7XG4gICAgICAgICAgICBtdXR1YWxseUV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIGxheWVyc0xpc3Q6IHRoaXMuYmFzZUxheWVyc1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9iYXNlTGF5ZXJHcm91cCA9IGJhc2VMYXllckdyb3VwO1xuICAgIH1cblxuICAgIGdldCBiYXNlTGF5ZXJHcm91cCgpe1xuICAgIFx0cmV0dXJuIHRoaXMuX2Jhc2VMYXllckdyb3VwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQHBhcmFtIExpem1hcExheWVyR3JvdXAgbGl6bWFwTGF5ZXJHcm91cFxuICAgICoqL1xuXG4gICAgc2V0IGJhc2VMYXllckdyb3VwKGxpem1hcExheWVyR3JvdXApe1xuICAgIFx0dGhpcy5fYmFzZUxheWVyR3JvdXAgPSBsaXptYXBMYXllckdyb3VwO1xuICAgIFx0dGhpcy5fT0xNYXAuYWRkTGF5ZXIobGl6bWFwTGF5ZXJHcm91cC5PTGxheWVyR3JvdXApO1xuICAgIH1cblxuICAgIHNldCBiYXNlTGF5ZXJWaXNpYmxlKGxheWVySWQpe1xuICAgIFx0dGhpcy5fYmFzZUxheWVyR3JvdXAubGF5ZXJWaXNpYmxlID0gbGF5ZXJJZDtcbiAgICB9XG5cbiAgICAvLyBUT0RPIGdldCBiYXNlIGxheWVycyBsaXN0IGZyb20gY29uZmlnXG4gICAgZ2V0IGJhc2VMYXllcnMoKXtcbiAgICBcdHJldHVybiBuZXcgTWFwKFtcbiAgICAgICAgICAgIFsnb3NtTWFwbmlrJyx7bmFtZTogJ09TTScsIHZpc2libGU6IGZhbHNlfV0sXG4gICAgICAgICAgICBbJ29zbVN0YW1lblRvbmVyJyx7bmFtZTogJ09TTSBUb25lcicsIHZpc2libGU6IHRydWV9XVxuICAgICAgICBdKTtcbiAgICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9